[
  {
    "sha": "25dfe8d816b609cff331213d80d7c892cad32716",
    "filename": "src/hotspot/os/aix/attachListener_aix.cpp",
    "status": "modified",
    "additions": 1,
    "deletions": 22,
    "changes": 23,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/os/aix/attachListener_aix.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/os/aix/attachListener_aix.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/os/aix/attachListener_aix.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and/or its affiliates. All rights reserved.\n  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n@@ -440,10 +440,6 @@ void AixAttachOperation::complete(jint result, bufferedStream* st) {\n   JavaThread* thread = JavaThread::current();\n   ThreadBlockInVM tbivm(thread);\n \n-  thread->set_suspend_equivalent();\n-  // cleared by handle_special_suspend_equivalent_condition() or\n-  // java_suspend_self() via check_and_wait_while_suspended()\n-\n   // write operation result\n   char msg[32];\n   sprintf(msg, \"%d\\n\", result);\n@@ -459,9 +455,6 @@ void AixAttachOperation::complete(jint result, bufferedStream* st) {\n   // done\n   ::close(this->socket());\n \n-  // were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n   delete this;\n }\n \n@@ -472,15 +465,8 @@ AttachOperation* AttachListener::dequeue() {\n   JavaThread* thread = JavaThread::current();\n   ThreadBlockInVM tbivm(thread);\n \n-  thread->set_suspend_equivalent();\n-  // cleared by handle_special_suspend_equivalent_condition() or\n-  // java_suspend_self() via check_and_wait_while_suspended()\n-\n   AttachOperation* op = AixAttachListener::dequeue();\n \n-  // were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n   return op;\n }\n \n@@ -511,15 +497,8 @@ int AttachListener::pd_init() {\n   JavaThread* thread = JavaThread::current();\n   ThreadBlockInVM tbivm(thread);\n \n-  thread->set_suspend_equivalent();\n-  // cleared by handle_special_suspend_equivalent_condition() or\n-  // java_suspend_self() via check_and_wait_while_suspended()\n-\n   int ret_code = AixAttachListener::init();\n \n-  // were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n   return ret_code;\n }\n "
  },
  {
    "sha": "9daad43dc7ad567dd87c9ce44b1363d18c4f5931",
    "filename": "src/hotspot/os/bsd/attachListener_bsd.cpp",
    "status": "modified",
    "additions": 1,
    "deletions": 22,
    "changes": 23,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/os/bsd/attachListener_bsd.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/os/bsd/attachListener_bsd.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/os/bsd/attachListener_bsd.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -409,10 +409,6 @@ void BsdAttachOperation::complete(jint result, bufferedStream* st) {\n   JavaThread* thread = JavaThread::current();\n   ThreadBlockInVM tbivm(thread);\n \n-  thread->set_suspend_equivalent();\n-  // cleared by handle_special_suspend_equivalent_condition() or\n-  // java_suspend_self() via check_and_wait_while_suspended()\n-\n   // write operation result\n   char msg[32];\n   sprintf(msg, \"%d\\n\", result);\n@@ -427,9 +423,6 @@ void BsdAttachOperation::complete(jint result, bufferedStream* st) {\n   // done\n   ::close(this->socket());\n \n-  // were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n   delete this;\n }\n \n@@ -440,15 +433,8 @@ AttachOperation* AttachListener::dequeue() {\n   JavaThread* thread = JavaThread::current();\n   ThreadBlockInVM tbivm(thread);\n \n-  thread->set_suspend_equivalent();\n-  // cleared by handle_special_suspend_equivalent_condition() or\n-  // java_suspend_self() via check_and_wait_while_suspended()\n-\n   AttachOperation* op = BsdAttachListener::dequeue();\n \n-  // were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n   return op;\n }\n \n@@ -479,15 +465,8 @@ int AttachListener::pd_init() {\n   JavaThread* thread = JavaThread::current();\n   ThreadBlockInVM tbivm(thread);\n \n-  thread->set_suspend_equivalent();\n-  // cleared by handle_special_suspend_equivalent_condition() or\n-  // java_suspend_self() via check_and_wait_while_suspended()\n-\n   int ret_code = BsdAttachListener::init();\n \n-  // were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n   return ret_code;\n }\n "
  },
  {
    "sha": "628c3f1c462b158362502077c7f14f4330149cf9",
    "filename": "src/hotspot/os/linux/attachListener_linux.cpp",
    "status": "modified",
    "additions": 1,
    "deletions": 22,
    "changes": 23,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/os/linux/attachListener_linux.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/os/linux/attachListener_linux.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/os/linux/attachListener_linux.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -409,10 +409,6 @@ void LinuxAttachOperation::complete(jint result, bufferedStream* st) {\n   JavaThread* thread = JavaThread::current();\n   ThreadBlockInVM tbivm(thread);\n \n-  thread->set_suspend_equivalent();\n-  // cleared by handle_special_suspend_equivalent_condition() or\n-  // java_suspend_self() via check_and_wait_while_suspended()\n-\n   // write operation result\n   char msg[32];\n   sprintf(msg, \"%d\\n\", result);\n@@ -427,9 +423,6 @@ void LinuxAttachOperation::complete(jint result, bufferedStream* st) {\n   // done\n   ::close(this->socket());\n \n-  // were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n   delete this;\n }\n \n@@ -440,15 +433,8 @@ AttachOperation* AttachListener::dequeue() {\n   JavaThread* thread = JavaThread::current();\n   ThreadBlockInVM tbivm(thread);\n \n-  thread->set_suspend_equivalent();\n-  // cleared by handle_special_suspend_equivalent_condition() or\n-  // java_suspend_self() via check_and_wait_while_suspended()\n-\n   AttachOperation* op = LinuxAttachListener::dequeue();\n \n-  // were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n   return op;\n }\n \n@@ -479,15 +465,8 @@ int AttachListener::pd_init() {\n   JavaThread* thread = JavaThread::current();\n   ThreadBlockInVM tbivm(thread);\n \n-  thread->set_suspend_equivalent();\n-  // cleared by handle_special_suspend_equivalent_condition() or\n-  // java_suspend_self() via check_and_wait_while_suspended()\n-\n   int ret_code = LinuxAttachListener::init();\n \n-  // were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n   return ret_code;\n }\n "
  },
  {
    "sha": "bf7de0c288f280022c22079c382cca31c8e0b5fb",
    "filename": "src/hotspot/os/posix/os_posix.cpp",
    "status": "modified",
    "additions": 0,
    "deletions": 7,
    "changes": 7,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/os/posix/os_posix.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/os/posix/os_posix.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/os/posix/os_posix.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -1571,8 +1571,6 @@ void Parker::park(bool isAbsolute, jlong time) {\n   }\n \n   OSThreadWaitState osts(jt->osthread(), false /* not Object.wait() */);\n-  jt->set_suspend_equivalent();\n-  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n \n   assert(_cur_index == -1, \"invariant\");\n   if (time == 0) {\n@@ -1595,11 +1593,6 @@ void Parker::park(bool isAbsolute, jlong time) {\n   // Paranoia to ensure our locked and lock-free paths interact\n   // correctly with each other and Java-level accesses.\n   OrderAccess::fence();\n-\n-  // If externally suspended while waiting, re-suspend\n-  if (jt->handle_special_suspend_equivalent_condition()) {\n-    jt->java_suspend_self();\n-  }\n }\n \n void Parker::unpark() {"
  },
  {
    "sha": "4d38cb8fcf0898933a5588cb9958b39e35da6317",
    "filename": "src/hotspot/os/posix/signals_posix.cpp",
    "status": "modified",
    "additions": 7,
    "deletions": 26,
    "changes": 33,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/os/posix/signals_posix.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/os/posix/signals_posix.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/os/posix/signals_posix.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -32,6 +32,7 @@\n #include \"runtime/java.hpp\"\n #include \"runtime/os.hpp\"\n #include \"runtime/osThread.hpp\"\n+#include \"runtime/semaphore.inline.hpp\"\n #include \"runtime/stubRoutines.hpp\"\n #include \"runtime/thread.hpp\"\n #include \"signals_posix.hpp\"\n@@ -369,27 +370,7 @@ static int check_pending_signals() {\n         return i;\n       }\n     }\n-    JavaThread *thread = JavaThread::current();\n-    ThreadBlockInVM tbivm(thread);\n-\n-    bool threadIsSuspended;\n-    do {\n-      thread->set_suspend_equivalent();\n-      // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n-      sig_semaphore->wait();\n-\n-      // were we externally suspended while we were waiting?\n-      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n-      if (threadIsSuspended) {\n-        // The semaphore has been incremented, but while we were waiting\n-        // another thread suspended us. We don't want to continue running\n-        // while suspended because that would surprise the thread that\n-        // suspended us.\n-        sig_semaphore->signal();\n-\n-        thread->java_suspend_self();\n-      }\n-    } while (threadIsSuspended);\n+    sig_semaphore->wait_with_safepoint_check(JavaThread::current());\n   }\n   ShouldNotReachHere();\n   return 0; // Satisfy compiler\n@@ -1558,9 +1539,9 @@ void PosixSignals::hotspot_sigmask(Thread* thread) {\n //      - sets target osthread state to continue\n //      - sends signal to end the sigsuspend loop in the SR_handler\n //\n-//  Note that the SR_lock plays no role in this suspend/resume protocol,\n+//  Note that the UtilLock plays no role in this suspend/resume protocol,\n //  but is checked for NULL in SR_handler as a thread termination indicator.\n-//  The SR_lock is, however, used by JavaThread::java_suspend()/java_resume() APIs.\n+//  The UtilLock is, however, used by JavaThread::java_suspend()/java_resume() APIs.\n //\n //  Note that resume_clear_context() and suspend_save_context() are needed\n //  by SR_handler(), so that fetch_frame_from_context() works,\n@@ -1606,11 +1587,11 @@ static void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {\n \n   // On some systems we have seen signal delivery get \"stuck\" until the signal\n   // mask is changed as part of thread termination. Check that the current thread\n-  // has not already terminated (via SR_lock()) - else the following assertion\n+  // has not already terminated (via UtilLock()) - else the following assertion\n   // will fail because the thread is no longer a JavaThread as the ~JavaThread\n   // destructor has completed.\n \n-  if (thread->SR_lock() == NULL) {\n+  if (thread->is_Java_thread() && thread->as_Java_thread()->UtilLock() == NULL) {\n     return;\n   }\n "
  },
  {
    "sha": "8b5a2cb7ab4fb8e1bc9f9f209a9e4f8028c6cff1",
    "filename": "src/hotspot/os/windows/attachListener_windows.cpp",
    "status": "modified",
    "additions": 1,
    "deletions": 15,
    "changes": 16,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/os/windows/attachListener_windows.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/os/windows/attachListener_windows.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/os/windows/attachListener_windows.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -310,10 +310,6 @@ void Win32AttachOperation::complete(jint result, bufferedStream* result_stream)\n   JavaThread* thread = JavaThread::current();\n   ThreadBlockInVM tbivm(thread);\n \n-  thread->set_suspend_equivalent();\n-  // cleared by handle_special_suspend_equivalent_condition() or\n-  // java_suspend_self() via check_and_wait_while_suspended()\n-\n   HANDLE hPipe = open_pipe();\n   int lastError = (int)::GetLastError();\n   if (hPipe != INVALID_HANDLE_VALUE) {\n@@ -351,9 +347,6 @@ void Win32AttachOperation::complete(jint result, bufferedStream* result_stream)\n \n     ::ReleaseMutex(Win32AttachListener::mutex());\n   }\n-\n-  // were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n }\n \n \n@@ -363,15 +356,8 @@ AttachOperation* AttachListener::dequeue() {\n   JavaThread* thread = JavaThread::current();\n   ThreadBlockInVM tbivm(thread);\n \n-  thread->set_suspend_equivalent();\n-  // cleared by handle_special_suspend_equivalent_condition() or\n-  // java_suspend_self() via check_and_wait_while_suspended()\n-\n   AttachOperation* op = Win32AttachListener::dequeue();\n \n-  // were we externally suspended while we were waiting?\n-  thread->check_and_wait_while_suspended();\n-\n   return op;\n }\n "
  },
  {
    "sha": "fb422647d2cea3ec3b8868ad8c9bab885c70a9a5",
    "filename": "src/hotspot/os/windows/os_windows.cpp",
    "status": "modified",
    "additions": 1,
    "deletions": 28,
    "changes": 29,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/os/windows/os_windows.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/os/windows/os_windows.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/os/windows/os_windows.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -2205,28 +2205,7 @@ static int check_pending_signals() {\n         return i;\n       }\n     }\n-    JavaThread *thread = JavaThread::current();\n-\n-    ThreadBlockInVM tbivm(thread);\n-\n-    bool threadIsSuspended;\n-    do {\n-      thread->set_suspend_equivalent();\n-      // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n-      sig_sem->wait();\n-\n-      // were we externally suspended while we were waiting?\n-      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n-      if (threadIsSuspended) {\n-        // The semaphore has been incremented, but while we were waiting\n-        // another thread suspended us. We don't want to continue running\n-        // while suspended because that would surprise the thread that\n-        // suspended us.\n-        sig_sem->signal();\n-\n-        thread->java_suspend_self();\n-      }\n-    } while (threadIsSuspended);\n+    sig_sem->wait_with_safepoint_check(JavaThread::current());\n   }\n   ShouldNotReachHere();\n   return 0; // Satisfy compiler\n@@ -5473,15 +5452,9 @@ void Parker::park(bool isAbsolute, jlong time) {\n   } else {\n     ThreadBlockInVM tbivm(thread);\n     OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n-    thread->set_suspend_equivalent();\n \n     WaitForSingleObject(_ParkHandle, time);\n     ResetEvent(_ParkHandle);\n-\n-    // If externally suspended while waiting, re-suspend\n-    if (thread->handle_special_suspend_equivalent_condition()) {\n-      thread->java_suspend_self();\n-    }\n   }\n }\n "
  },
  {
    "sha": "effacfb8481d0593762dba959380da858a35164b",
    "filename": "src/hotspot/share/logging/logTag.hpp",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/logging/logTag.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/logging/logTag.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/logging/logTag.hpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -173,6 +173,7 @@\n   LOG_TAG(stringtable) \\\n   LOG_TAG(subclass) \\\n   LOG_TAG(survivor) \\\n+  LOG_TAG(suspend) \\\n   LOG_TAG(sweep) \\\n   LOG_TAG(symboltable) \\\n   LOG_TAG(system) \\"
  },
  {
    "sha": "0a363ec61c8dcdea2026ad9d194da01bc5adaeb1",
    "filename": "src/hotspot/share/prims/jvm.cpp",
    "status": "modified",
    "additions": 2,
    "deletions": 41,
    "changes": 43,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/prims/jvm.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/prims/jvm.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/prims/jvm.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -2978,32 +2978,9 @@ JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))\n   JavaThread* receiver = NULL;\n   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &receiver, NULL);\n   if (is_alive) {\n-    // jthread refers to a live JavaThread.\n-    {\n-      MutexLocker ml(receiver->SR_lock(), Mutex::_no_safepoint_check_flag);\n-      if (receiver->is_external_suspend()) {\n-        // Don't allow nested external suspend requests. We can't return\n-        // an error from this interface so just ignore the problem.\n-        return;\n-      }\n-      if (receiver->is_exiting()) { // thread is in the process of exiting\n-        return;\n-      }\n-      receiver->set_external_suspend();\n-    }\n-\n-    // java_suspend() will catch threads in the process of exiting\n-    // and will ignore them.\n+    // jthread refers to a live JavaThread, but java_suspend() will\n+    // detect a thread that has started to exit and will ignore it.\n     receiver->java_suspend();\n-\n-    // It would be nice to have the following assertion in all the\n-    // time, but it is possible for a racing resume request to have\n-    // resumed this thread right after we suspended it. Temporarily\n-    // enable this assertion if you are chasing a different kind of\n-    // bug.\n-    //\n-    // assert(java_lang_Thread::thread(receiver->threadObj()) == NULL ||\n-    //   receiver->is_being_ext_suspended(), \"thread is not suspended\");\n   }\n JVM_END\n \n@@ -3014,22 +2991,6 @@ JVM_ENTRY(void, JVM_ResumeThread(JNIEnv* env, jobject jthread))\n   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &receiver, NULL);\n   if (is_alive) {\n     // jthread refers to a live JavaThread.\n-\n-    // This is the original comment for this Threads_lock grab:\n-    //   We need to *always* get the threads lock here, since this operation cannot be allowed during\n-    //   a safepoint. The safepoint code relies on suspending a thread to examine its state. If other\n-    //   threads randomly resumes threads, then a thread might not be suspended when the safepoint code\n-    //   looks at it.\n-    //\n-    // The above comment dates back to when we had both internal and\n-    // external suspend APIs that shared a common underlying mechanism.\n-    // External suspend is now entirely cooperative and doesn't share\n-    // anything with internal suspend. That said, there are some\n-    // assumptions in the VM that an external resume grabs the\n-    // Threads_lock. We can't drop the Threads_lock grab here until we\n-    // resolve the assumptions that exist elsewhere.\n-    //\n-    MutexLocker ml(Threads_lock);\n     receiver->java_resume();\n   }\n JVM_END"
  },
  {
    "sha": "5441da7c4d860b00ff627cdb1ddf4c95ffcbb3fd",
    "filename": "src/hotspot/share/prims/jvmtiEnv.cpp",
    "status": "modified",
    "additions": 35,
    "deletions": 47,
    "changes": 82,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/prims/jvmtiEnv.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/prims/jvmtiEnv.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/prims/jvmtiEnv.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -879,7 +879,7 @@ JvmtiEnv::GetThreadState(jthread thread, jint* thread_state_ptr) {\n     // We have a JavaThread* so add more state bits.\n     JavaThreadState jts = java_thread->thread_state();\n \n-    if (java_thread->is_being_ext_suspended()) {\n+    if (java_thread->is_suspended()) {\n       state |= JVMTI_THREAD_STATE_SUSPENDED;\n     }\n     if (jts == _thread_in_native) {\n@@ -945,24 +945,18 @@ jvmtiError\n JvmtiEnv::SuspendThread(JavaThread* java_thread) {\n   // don't allow hidden thread suspend request.\n   if (java_thread->is_hidden_from_external_view()) {\n-    return (JVMTI_ERROR_NONE);\n+    return JVMTI_ERROR_NONE;\n   }\n-\n-  {\n-    MutexLocker ml(java_thread->SR_lock(), Mutex::_no_safepoint_check_flag);\n-    if (java_thread->is_external_suspend()) {\n-      // don't allow nested external suspend requests.\n-      return (JVMTI_ERROR_THREAD_SUSPENDED);\n-    }\n-    if (java_thread->is_exiting()) { // thread is in the process of exiting\n-      return (JVMTI_ERROR_THREAD_NOT_ALIVE);\n-    }\n-    java_thread->set_external_suspend();\n+  if (java_thread->is_suspended()) {\n+    return JVMTI_ERROR_THREAD_SUSPENDED;\n   }\n-\n   if (!JvmtiSuspendControl::suspend(java_thread)) {\n-    // the thread was in the process of exiting\n-    return (JVMTI_ERROR_THREAD_NOT_ALIVE);\n+    // Either the thread is already suspended or\n+    // the thread was in the process of exiting:\n+    if (java_thread->is_exiting()) {\n+      return JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    }\n+    return JVMTI_ERROR_THREAD_SUSPENDED;\n   }\n   return JVMTI_ERROR_NONE;\n } /* end SuspendThread */\n@@ -973,8 +967,10 @@ JvmtiEnv::SuspendThread(JavaThread* java_thread) {\n // results - pre-checked for NULL\n jvmtiError\n JvmtiEnv::SuspendThreadList(jint request_count, const jthread* request_list, jvmtiError* results) {\n+  int self_index = -1;\n   int needSafepoint = 0;  // > 0 if we need a safepoint\n-  ThreadsListHandle tlh;\n+  JavaThread* current = JavaThread::current();\n+  ThreadsListHandle tlh(current);\n   for (int i = 0; i < request_count; i++) {\n     JavaThread *java_thread = NULL;\n     jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), request_list[i], &java_thread, NULL);\n@@ -987,38 +983,32 @@ JvmtiEnv::SuspendThreadList(jint request_count, const jthread* request_list, jvm\n       results[i] = JVMTI_ERROR_NONE;  // indicate successful suspend\n       continue;\n     }\n-\n-    {\n-      MutexLocker ml(java_thread->SR_lock(), Mutex::_no_safepoint_check_flag);\n-      if (java_thread->is_external_suspend()) {\n-        // don't allow nested external suspend requests.\n-        results[i] = JVMTI_ERROR_THREAD_SUSPENDED;\n-        continue;\n-      }\n-      if (java_thread->is_exiting()) { // thread is in the process of exiting\n-        results[i] = JVMTI_ERROR_THREAD_NOT_ALIVE;\n-        continue;\n-      }\n-      java_thread->set_external_suspend();\n-    }\n-    if (java_thread->thread_state() == _thread_in_native) {\n-      // We need to try and suspend native threads here. Threads in\n-      // other states will self-suspend on their next transition.\n-      if (!JvmtiSuspendControl::suspend(java_thread)) {\n-        // The thread was in the process of exiting. Force another\n-        // safepoint to make sure that this thread transitions.\n-        needSafepoint++;\n+    if (java_thread->is_suspended()) {\n+      results[i] = JVMTI_ERROR_THREAD_SUSPENDED;  // indicate successful suspend\n+      continue;\n+    }\n+    if (java_thread == current) {\n+      self_index = i;\n+      continue;\n+    }\n+    if (!JvmtiSuspendControl::suspend(java_thread)) {\n+      // Either the thread is already suspended or\n+      // the thread was in the process of exiting:\n+      if (java_thread->is_exiting()) {\n         results[i] = JVMTI_ERROR_THREAD_NOT_ALIVE;\n         continue;\n       }\n-    } else {\n-      needSafepoint++;\n+      results[i] =  JVMTI_ERROR_THREAD_SUSPENDED;\n+      continue;\n     }\n     results[i] = JVMTI_ERROR_NONE;  // indicate successful suspend\n   }\n-  if (needSafepoint > 0) {\n-    VM_ThreadsSuspendJVMTI tsj;\n-    VMThread::execute(&tsj);\n+  if (self_index >= 0) {\n+    if (!JvmtiSuspendControl::suspend(current)) {\n+      results[self_index] = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    } else {\n+      results[self_index] = JVMTI_ERROR_NONE;  // indicate successful suspend\n+    }\n   }\n   // per-thread suspend results returned via results parameter\n   return JVMTI_ERROR_NONE;\n@@ -1033,11 +1023,9 @@ JvmtiEnv::ResumeThread(JavaThread* java_thread) {\n   if (java_thread->is_hidden_from_external_view()) {\n     return JVMTI_ERROR_NONE;\n   }\n-\n-  if (!java_thread->is_being_ext_suspended()) {\n+  if (!java_thread->is_suspended()) {\n     return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n   }\n-\n   if (!JvmtiSuspendControl::resume(java_thread)) {\n     return JVMTI_ERROR_INTERNAL;\n   }\n@@ -1063,7 +1051,7 @@ JvmtiEnv::ResumeThreadList(jint request_count, const jthread* request_list, jvmt\n       results[i] = JVMTI_ERROR_NONE;  // indicate successful resume\n       continue;\n     }\n-    if (!java_thread->is_being_ext_suspended()) {\n+    if (!java_thread->is_suspended()) {\n       results[i] = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n       continue;\n     }"
  },
  {
    "sha": "11a4b2117be080c66c867483c5ef3dcfc1a71127",
    "filename": "src/hotspot/share/prims/jvmtiEnvBase.cpp",
    "status": "modified",
    "additions": 4,
    "deletions": 5,
    "changes": 9,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/prims/jvmtiEnvBase.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/prims/jvmtiEnvBase.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/prims/jvmtiEnvBase.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -1182,8 +1182,7 @@ MultipleStackTracesCollector::fill_frames(jthread jt, JavaThread *thr, oop threa\n   }\n \n   if (thr != NULL) {    // add more state bits if there is a JavaThead to query\n-    // same as is_being_ext_suspended() but without locking\n-    if (thr->is_ext_suspended() || thr->is_external_suspend()) {\n+    if (thr->is_suspended()) {\n       state |= JVMTI_THREAD_STATE_SUSPENDED;\n     }\n     JavaThreadState jts = thr->thread_state();\n@@ -1401,7 +1400,7 @@ SetForceEarlyReturn::doit(Thread *target, bool self) {\n   HandleMark   hm(current_thread);\n \n   if (!self) {\n-    if (!java_thread->is_external_suspend()) {\n+    if (!java_thread->is_suspended()) {\n       _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n       return;\n     }\n@@ -1534,7 +1533,7 @@ UpdateForPopTopFrameClosure::doit(Thread *target, bool self) {\n   JavaThread* java_thread = target->as_Java_thread();\n   assert(java_thread == _state->get_thread(), \"Must be\");\n \n-  if (!self && !java_thread->is_external_suspend()) {\n+  if (!self && !java_thread->is_suspended()) {\n     _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n     return;\n   }\n@@ -1625,7 +1624,7 @@ SetFramePopClosure::doit(Thread *target, bool self) {\n \n   assert(_state->get_thread() == java_thread, \"Must be\");\n \n-  if (!self && !java_thread->is_external_suspend()) {\n+  if (!self && !java_thread->is_suspended()) {\n     _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n     return;\n   }"
  },
  {
    "sha": "40076e2804f26fea513983910f5ffd92719c3b84",
    "filename": "src/hotspot/share/prims/jvmtiImpl.cpp",
    "status": "modified",
    "additions": 3,
    "deletions": 37,
    "changes": 40,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/prims/jvmtiImpl.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/prims/jvmtiImpl.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/prims/jvmtiImpl.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -765,47 +765,13 @@ VM_GetReceiver::VM_GetReceiver(\n //\n \n bool JvmtiSuspendControl::suspend(JavaThread *java_thread) {\n-  // external suspend should have caught suspending a thread twice\n-\n-  // Immediate suspension required for JPDA back-end so JVMTI agent threads do\n-  // not deadlock due to later suspension on transitions while holding\n-  // raw monitors.  Passing true causes the immediate suspension.\n-  // java_suspend() will catch threads in the process of exiting\n-  // and will ignore them.\n-  java_thread->java_suspend();\n-\n-  // It would be nice to have the following assertion in all the time,\n-  // but it is possible for a racing resume request to have resumed\n-  // this thread right after we suspended it. Temporarily enable this\n-  // assertion if you are chasing a different kind of bug.\n-  //\n-  // assert(java_lang_Thread::thread(java_thread->threadObj()) == NULL ||\n-  //   java_thread->is_being_ext_suspended(), \"thread is not suspended\");\n-\n-  if (java_lang_Thread::thread(java_thread->threadObj()) == NULL) {\n-    // check again because we can get delayed in java_suspend():\n-    // the thread is in process of exiting.\n-    return false;\n-  }\n-\n-  return true;\n+  return java_thread->java_suspend();\n }\n \n bool JvmtiSuspendControl::resume(JavaThread *java_thread) {\n-  // external suspend should have caught resuming a thread twice\n-  assert(java_thread->is_being_ext_suspended(), \"thread should be suspended\");\n-\n-  // resume thread\n-  {\n-    // must always grab Threads_lock, see JVM_SuspendThread\n-    MutexLocker ml(Threads_lock);\n-    java_thread->java_resume();\n-  }\n-\n-  return true;\n+  return java_thread->java_resume();\n }\n \n-\n void JvmtiSuspendControl::print() {\n #ifndef PRODUCT\n   ResourceMark rm;\n@@ -817,7 +783,7 @@ void JvmtiSuspendControl::print() {\n #else\n     const char *name   = \"\";\n #endif /*JVMTI_TRACE */\n-    log_stream.print(\"%s(%c \", name, thread->is_being_ext_suspended() ? 'S' : '_');\n+    log_stream.print(\"%s(%c \", name, thread->is_suspended() ? 'S' : '_');\n     if (!thread->has_last_Java_frame()) {\n       log_stream.print(\"no stack\");\n     }"
  },
  {
    "sha": "0c615c5409c9701d1e1b46eaad814716c9438dce",
    "filename": "src/hotspot/share/prims/jvmtiRawMonitor.cpp",
    "status": "modified",
    "additions": 45,
    "deletions": 47,
    "changes": 92,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/prims/jvmtiRawMonitor.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/prims/jvmtiRawMonitor.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/prims/jvmtiRawMonitor.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -241,7 +241,6 @@ int JvmtiRawMonitor::simple_wait(Thread* self, jlong millis) {\n         ret = M_INTERRUPTED;\n     } else {\n       ThreadBlockInVM tbivm(jt);\n-      jt->set_suspend_equivalent();\n       if (millis <= 0) {\n         self->_ParkEvent->park();\n       } else {\n@@ -307,23 +306,37 @@ void JvmtiRawMonitor::simple_notify(Thread* self, bool all) {\n   return;\n }\n \n-// Any JavaThread will enter here with state _thread_blocked\n+// Any JavaThread will enter here with state _thread_blocked unless we\n+// are in single-threaded mode during startup.\n void JvmtiRawMonitor::raw_enter(Thread* self) {\n   void* contended;\n   JavaThread* jt = NULL;\n   // don't enter raw monitor if thread is being externally suspended, it will\n   // surprise the suspender if a \"suspended\" thread can still enter monitor\n   if (self->is_Java_thread()) {\n     jt = self->as_Java_thread();\n-    jt->SR_lock()->lock_without_safepoint_check();\n-    while (jt->is_external_suspend()) {\n-      jt->SR_lock()->unlock();\n-      jt->java_suspend_self();\n-      jt->SR_lock()->lock_without_safepoint_check();\n+    while (true) {\n+      // To pause suspend requests while in native we must block handshakes.\n+      jt->handshake_state()->lock();\n+      // Suspend requested flag can only be set in handshakes.\n+      // By blocking handshakes, suspend request flag cannot change its value.\n+      if (!jt->is_suspend_requested()) {\n+        contended = Atomic::cmpxchg(&_owner, (Thread*)NULL, jt);\n+        jt->handshake_state()->unlock();\n+        break;\n+      }\n+      jt->handshake_state()->unlock();\n+\n+      // We may only be in states other than _thread_blocked when we are\n+      // in single-threaded mode during startup.\n+      guarantee(jt->thread_state() == _thread_blocked, \"invariant\");\n+\n+      jt->set_thread_state_fence(_thread_blocked_trans);\n+      SafepointMechanism::process_if_requested(jt);\n+      // We should transition to thread_in_vm and then to thread_in_vm_trans,\n+      // but those are always treated the same as _thread_blocked_trans.\n+      jt->set_thread_state(_thread_blocked);\n     }\n-    // guarded by SR_lock to avoid racing with new external suspend requests.\n-    contended = Atomic::cmpxchg(&_owner, (Thread*)NULL, jt);\n-    jt->SR_lock()->unlock();\n   } else {\n     contended = Atomic::cmpxchg(&_owner, (Thread*)NULL, self);\n   }\n@@ -344,28 +357,20 @@ void JvmtiRawMonitor::raw_enter(Thread* self) {\n   if (!self->is_Java_thread()) {\n     simple_enter(self);\n   } else {\n+    // In multi-threaded mode, we must enter this method blocked.\n     guarantee(jt->thread_state() == _thread_blocked, \"invariant\");\n     for (;;) {\n-      jt->set_suspend_equivalent();\n-      // cleared by handle_special_suspend_equivalent_condition() or\n-      // java_suspend_self()\n       simple_enter(jt);\n-\n-      // were we externally suspended while we were waiting?\n-      if (!jt->handle_special_suspend_equivalent_condition()) {\n+      if (!SafepointMechanism::should_process(jt)) {\n+        // Not suspended so we're done here:\n         break;\n       }\n-\n-      // This thread was externally suspended\n-      // We have reentered the contended monitor, but while we were\n-      // waiting another thread suspended us. We don't want to reenter\n-      // the monitor while suspended because that would surprise the\n-      // thread that suspended us.\n-      //\n-      // Drop the lock\n       simple_exit(jt);\n-\n-      jt->java_suspend_self();\n+      jt->set_thread_state_fence(_thread_blocked_trans);\n+      SafepointMechanism::process_if_requested(jt);\n+      // We should transition to thread_in_vm and then to thread_in_vm_trans,\n+      // but those are always treated the same as _thread_blocked_trans.\n+      jt->set_thread_state(_thread_blocked);\n     }\n   }\n \n@@ -411,29 +416,22 @@ int JvmtiRawMonitor::raw_wait(jlong millis, Thread* self) {\n \n   if (self->is_Java_thread()) {\n     JavaThread* jt = self->as_Java_thread();\n+    guarantee(jt->thread_state() == _thread_in_native, \"invariant\");\n     for (;;) {\n-      jt->set_suspend_equivalent();\n-      if (!jt->handle_special_suspend_equivalent_condition()) {\n+      if (!SafepointMechanism::should_process(jt)) {\n+        // Not suspended so we're done here:\n         break;\n-      } else {\n-        // We've been suspended whilst waiting and so we have to\n-        // relinquish the raw monitor until we are resumed. Of course\n-        // after reacquiring we have to re-check for suspension again.\n-        // Suspension requires we are _thread_blocked, and we also have to\n-        // recheck for being interrupted.\n-        simple_exit(jt);\n-        {\n-          ThreadInVMfromNative tivm(jt);\n-          {\n-            ThreadBlockInVM tbivm(jt);\n-            jt->java_suspend_self();\n-          }\n-          if (jt->is_interrupted(true)) {\n-            ret = M_INTERRUPTED;\n-          }\n-        }\n-        simple_enter(jt);\n       }\n+      simple_exit(jt);\n+      jt->set_thread_state_fence(_thread_in_native_trans);\n+      SafepointMechanism::process_if_requested(jt);\n+      if (jt->is_interrupted(true)) {\n+        ret = M_INTERRUPTED;\n+      }\n+      // We should transition to thread_in_vm and then to thread_in_vm_trans,\n+      // but those are always treated the same as _thread_in_native_trans.\n+      jt->set_thread_state(_thread_in_native);\n+      simple_enter(jt);\n     }\n     guarantee(jt == _owner, \"invariant\");\n   } else {"
  },
  {
    "sha": "e61241fdd63ceca2a700b538329f037e6aa2fc83",
    "filename": "src/hotspot/share/prims/jvmtiThreadState.cpp",
    "status": "modified",
    "additions": 0,
    "deletions": 5,
    "changes": 5,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/prims/jvmtiThreadState.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/prims/jvmtiThreadState.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/prims/jvmtiThreadState.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -294,11 +294,6 @@ int JvmtiThreadState::cur_stack_depth() {\n   return _cur_stack_depth;\n }\n \n-bool JvmtiThreadState::may_be_walked() {\n-  return (get_thread()->is_being_ext_suspended() || (JavaThread::current() == get_thread()));\n-}\n-\n-\n void JvmtiThreadState::process_pending_step_for_popframe() {\n   // We are single stepping as the last part of the PopFrame() dance\n   // so we have some house keeping to do."
  },
  {
    "sha": "9ddd8308c4733051a838abf77b9d515d052ff13c",
    "filename": "src/hotspot/share/prims/jvmtiThreadState.hpp",
    "status": "modified",
    "additions": 1,
    "deletions": 3,
    "changes": 4,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/prims/jvmtiThreadState.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/prims/jvmtiThreadState.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/prims/jvmtiThreadState.hpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -312,8 +312,6 @@ class JvmtiThreadState : public CHeapObj<mtInternal> {\n \n  public:\n \n-  bool may_be_walked();\n-\n   // Thread local event collector setter and getter methods.\n   JvmtiDynamicCodeEventCollector* get_dynamic_code_event_collector() {\n     return _dynamic_code_event_collector;"
  },
  {
    "sha": "bbf1dd53b60329fb778a33b2f3a3a601a2f9e1d1",
    "filename": "src/hotspot/share/runtime/handshake.cpp",
    "status": "modified",
    "additions": 79,
    "deletions": 9,
    "changes": 88,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/handshake.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/handshake.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/handshake.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -400,8 +400,6 @@ HandshakeState::HandshakeState(JavaThread* target) :\n \n void HandshakeState::add_operation(HandshakeOperation* op) {\n   // Adds are done lock free and so is arming.\n-  // Calling this method with lock held is considered an error.\n-  assert(!_lock.owned_by_self(), \"Lock should not be held\");\n   _queue.push(op);\n   SafepointMechanism::arm_local_poll_release(_handshakee);\n }\n@@ -428,22 +426,21 @@ HandshakeOperation* HandshakeState::pop() {\n   return _queue.pop(non_self_queue_filter);\n };\n \n-void HandshakeState::process_by_self() {\n+bool HandshakeState::process_by_self() {\n   assert(Thread::current() == _handshakee, \"should call from _handshakee\");\n   assert(!_handshakee->is_terminated(), \"should not be a terminated thread\");\n   assert(_handshakee->thread_state() != _thread_blocked, \"should not be in a blocked state\");\n   assert(_handshakee->thread_state() != _thread_in_native, \"should not be in native\");\n   ThreadInVMForHandshake tivm(_handshakee);\n   {\n+    ttyLocker::break_tty_lock_for_safepoint(os::current_thread_id());\n     NoSafepointVerifier nsv;\n-    process_self_inner();\n+    return process_self_inner();\n   }\n }\n \n-void HandshakeState::process_self_inner() {\n+bool HandshakeState::process_self_inner() {\n   while (should_process()) {\n-    HandleMark hm(_handshakee);\n-    PreserveExceptionMark pem(_handshakee);\n     MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n     HandshakeOperation* op = pop_for_self();\n     if (op != NULL) {\n@@ -452,13 +449,23 @@ void HandshakeState::process_self_inner() {\n       log_trace(handshake)(\"Proc handshake %s \" INTPTR_FORMAT \" on \" INTPTR_FORMAT \" by self\",\n                            async ? \"asynchronous\" : \"synchronous\", p2i(op), p2i(_handshakee));\n       op->prepare(_handshakee, _handshakee);\n-      op->do_handshake(_handshakee);\n-      if (async) {\n+      if (!async) {\n+        HandleMark hm(_handshakee);\n+        PreserveExceptionMark pem(_handshakee);\n+        op->do_handshake(_handshakee);\n+      } else {\n+        // Asynchronous may block so they may not execute ~PreserveExceptionMark before safepointing\n+        // in outer loop.\n+        op->do_handshake(_handshakee);\n         log_handshake_info(((AsyncHandshakeOperation*)op)->start_time(), op->name(), 1, 0, \"asynchronous\");\n         delete op;\n+        return false; // Must check for safepoints\n       }\n+    } else {\n+      return true;\n     }\n   }\n+  return true;\n }\n \n bool HandshakeState::can_process_handshake() {\n@@ -562,3 +569,66 @@ HandshakeState::ProcessResult HandshakeState::try_process(HandshakeOperation* ma\n                        pr_ret == HandshakeState::_succeeded ? \"including\" : \"excluding\", p2i(match_op));\n   return pr_ret;\n }\n+\n+void HandshakeState::lock() {\n+  _lock.lock_without_safepoint_check();\n+}\n+\n+void HandshakeState::unlock() {\n+  _lock.unlock();\n+}\n+\n+// The careful dance between thread suspension and exit is handled here.\n+// The caller has notified the agents that we are exiting, before we go\n+// on, we must check for a pending external suspend request and honor it\n+// in order to not surprise the thread that made the suspend request.\n+void HandshakeState::thread_exit() {\n+  assert(JavaThread::current() == _handshakee, \"Must be\");\n+  while (true) {\n+    {\n+      MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+      if (!_handshakee->is_suspend_requested()) {\n+        _handshakee->set_exiting();\n+        // No more external suspends are allowed at this point.\n+        return;\n+      }\n+    }\n+    ThreadBlockInVM tbivm(_handshakee);\n+    // We're done with this suspend request, but we have to loop around\n+    // and check again. Eventually we will get the lock without a pending\n+    // external suspend request and will be able to mark ourselves as\n+    // exiting.\n+  }\n+}\n+\n+void HandshakeState::suspend_in_handshake() {\n+  assert(Thread::current() == _handshakee, \"should call from _handshakee\");\n+  assert(_lock.owned_by_self(), \"Lock must be held\");\n+  assert(!_handshakee->has_last_Java_frame() || _handshakee->frame_anchor()->walkable(), \"should have walkable stack\");\n+  JavaThreadState jts = _handshakee->thread_state();\n+  while (_handshakee->_suspended) {\n+    _handshakee->set_thread_state(_thread_blocked);\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended\", p2i(_handshakee));\n+    _lock.wait_without_safepoint_check();\n+  }\n+  _handshakee->set_thread_state(jts);\n+  _handshakee->set_suspend_requested(false);\n+  log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" resumed\", p2i(_handshakee));\n+}\n+\n+bool HandshakeState::resume() {\n+  // Can't be suspended if there is no suspend request.\n+  if (!_handshakee->is_suspend_requested()) {\n+    return false;\n+  }\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+  // Can't be suspended if there is no suspend request.\n+  if (!_handshakee->is_suspend_requested()) {\n+    assert(!_handshakee->is_suspended(), \"cannot be suspended without a suspend request\");\n+    return false;\n+  }\n+  // Resume the thread.\n+  _handshakee->set_suspend(false);\n+  _lock.notify();\n+  return true;\n+}"
  },
  {
    "sha": "caea6c306580dbec283819b63e667fdace90d94b",
    "filename": "src/hotspot/share/runtime/handshake.hpp",
    "status": "modified",
    "additions": 21,
    "deletions": 9,
    "changes": 30,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/handshake.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/handshake.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/handshake.hpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -43,9 +43,9 @@ class HandshakeClosure : public ThreadClosure, public CHeapObj<mtThread> {\n   const char* const _name;\n  public:\n   HandshakeClosure(const char* name) : _name(name) {}\n-  virtual ~HandshakeClosure() {}\n-  const char* name() const    { return _name; }\n-  virtual bool is_async()     { return false; }\n+  virtual ~HandshakeClosure()                      {}\n+  const char* name() const                         { return _name; }\n+  virtual bool is_async()                          { return false; }\n   virtual void do_thread(Thread* thread) = 0;\n };\n \n@@ -61,38 +61,47 @@ class Handshake : public AllStatic {\n   // Execution of handshake operation\n   static void execute(HandshakeClosure*       hs_cl);\n   static void execute(HandshakeClosure*       hs_cl, JavaThread* target);\n-  static void execute(AsyncHandshakeClosure* hs_cl, JavaThread* target);\n+  static void execute(AsyncHandshakeClosure*  hs_cl, JavaThread* target);\n };\n \n+class JvmtiRawMonitor;\n+\n // The HandshakeState keeps track of an ongoing handshake for this JavaThread.\n // VMThread/Handshaker and JavaThread are serialized with _lock making sure the\n // operation is only done by either VMThread/Handshaker on behalf of the\n // JavaThread or by the target JavaThread itself.\n class HandshakeState {\n+  friend JvmtiRawMonitor;\n   // This a back reference to the JavaThread,\n   // the target for all operation in the queue.\n   JavaThread* _handshakee;\n   // The queue containing handshake operations to be performed on _handshakee.\n   FilterQueue<HandshakeOperation*> _queue;\n-  // Provides mutual exclusion to this state and queue.\n-  Mutex   _lock;\n+  // Provides mutual exclusion to this state and queue. Also used for\n+  // JavaThread suspend/resume operations.\n+  Monitor _lock;\n   // Set to the thread executing the handshake operation.\n   Thread* _active_handshaker;\n \n   bool claim_handshake();\n   bool possibly_can_process_handshake();\n   bool can_process_handshake();\n-  void process_self_inner();\n+  bool process_self_inner();\n \n   bool have_non_self_executable_operation();\n   HandshakeOperation* pop_for_self();\n   HandshakeOperation* pop();\n \n+  void lock();\n+  void unlock();\n+\n  public:\n   HandshakeState(JavaThread* thread);\n \n   void add_operation(HandshakeOperation* op);\n \n+  void thread_exit();\n+\n   bool has_operation() {\n     return !_queue.is_empty();\n   }\n@@ -108,7 +117,7 @@ class HandshakeState {\n     return !_queue.is_empty() || _lock.is_locked();\n   }\n \n-  void process_by_self();\n+  bool process_by_self();\n \n   enum ProcessResult {\n     _no_operation = 0,\n@@ -121,6 +130,9 @@ class HandshakeState {\n   ProcessResult try_process(HandshakeOperation* match_op);\n \n   Thread* active_handshaker() const { return _active_handshaker; }\n+\n+  void suspend_in_handshake();\n+  bool resume();\n };\n \n #endif // SHARE_RUNTIME_HANDSHAKE_HPP"
  },
  {
    "sha": "49e0a27fb90bfcda9eb9baf50e404611c3701707",
    "filename": "src/hotspot/share/runtime/mutex.cpp",
    "status": "modified",
    "additions": 4,
    "deletions": 20,
    "changes": 24,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/mutex.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/mutex.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/mutex.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -215,7 +215,7 @@ bool Monitor::wait_without_safepoint_check(int64_t timeout) {\n   return wait_status != 0;          // return true IFF timeout\n }\n \n-bool Monitor::wait(int64_t timeout, bool as_suspend_equivalent) {\n+bool Monitor::wait(int64_t timeout) {\n   JavaThread* const self = JavaThread::current();\n   // Safepoint checking logically implies an active JavaThread.\n   assert(self->is_active_Java_thread(), \"invariant\");\n@@ -238,25 +238,9 @@ bool Monitor::wait(int64_t timeout, bool as_suspend_equivalent) {\n   {\n     ThreadBlockInVMWithDeadlockCheck tbivmdc(self, &in_flight_mutex);\n     OSThreadWaitState osts(self->osthread(), false /* not Object.wait() */);\n-    if (as_suspend_equivalent) {\n-      self->set_suspend_equivalent();\n-      // cleared by handle_special_suspend_equivalent_condition() or\n-      // java_suspend_self()\n-    }\n \n     wait_status = _lock.wait(timeout);\n     in_flight_mutex = this;  // save for ~ThreadBlockInVMWithDeadlockCheck\n-\n-    // were we externally suspended while we were waiting?\n-    if (as_suspend_equivalent && self->handle_special_suspend_equivalent_condition()) {\n-      // Our event wait has finished and we own the lock, but\n-      // while we were waiting another thread suspended us. We don't\n-      // want to hold the lock while suspended because that\n-      // would surprise the thread that suspended us.\n-      _lock.unlock();\n-      self->java_suspend_self();\n-      _lock.lock();\n-    }\n   }\n \n   if (in_flight_mutex != NULL) {\n@@ -275,9 +259,9 @@ Mutex::~Mutex() {\n   assert_owner(NULL);\n }\n \n-// Only Threads_lock, Heap_lock and SR_lock may be safepoint_check_sometimes.\n+// Only Threads_lock, Heap_lock and Util_lock may be safepoint_check_sometimes.\n bool is_sometimes_ok(const char* name) {\n-  return (strcmp(name, \"Threads_lock\") == 0 || strcmp(name, \"Heap_lock\") == 0 || strcmp(name, \"SR_lock\") == 0);\n+  return (strcmp(name, \"Threads_lock\") == 0 || strcmp(name, \"Heap_lock\") == 0 || strcmp(name, \"Util_lock\") == 0);\n }\n \n Mutex::Mutex(int Rank, const char * name, bool allow_vm_block,"
  },
  {
    "sha": "5035525b3773a3bb179ac89606d92499a220a59b",
    "filename": "src/hotspot/share/runtime/mutex.hpp",
    "status": "modified",
    "additions": 3,
    "deletions": 5,
    "changes": 8,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/mutex.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/mutex.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/mutex.hpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -227,10 +227,8 @@ class Monitor : public Mutex {\n \n   // Wait until monitor is notified (or times out).\n   // Defaults are to make safepoint checks, wait time is forever (i.e.,\n-  // zero), and not a suspend-equivalent condition. Returns true if wait\n-  // times out; otherwise returns false.\n-  bool wait(int64_t timeout = 0,\n-            bool as_suspend_equivalent = !_as_suspend_equivalent_flag);\n+  // zero). Returns true if wait times out; otherwise returns false.\n+  bool wait(int64_t timeout = 0);\n   bool wait_without_safepoint_check(int64_t timeout = 0);\n   void notify();\n   void notify_all();"
  },
  {
    "sha": "ccb0df933c6ffe274c5bb21a131009eae38686fc",
    "filename": "src/hotspot/share/runtime/mutexLocker.hpp",
    "status": "modified",
    "additions": 2,
    "deletions": 3,
    "changes": 5,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/mutexLocker.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/mutexLocker.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/mutexLocker.hpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -256,10 +256,9 @@ class MonitorLocker: public MutexLocker {\n     assert(_monitor != NULL, \"NULL monitor not allowed\");\n   }\n \n-  bool wait(int64_t timeout = 0,\n-            bool as_suspend_equivalent = !Mutex::_as_suspend_equivalent_flag) {\n+  bool wait(int64_t timeout = 0) {\n     if (_flag == Mutex::_safepoint_check_flag) {\n-      return _monitor->wait(timeout, as_suspend_equivalent);\n+      return _monitor->wait(timeout);\n     } else {\n       return _monitor->wait_without_safepoint_check(timeout);\n     }"
  },
  {
    "sha": "b199f53a1c522615775b23a8ecb7fd51550c5dd6",
    "filename": "src/hotspot/share/runtime/nonJavaThread.cpp",
    "status": "modified",
    "additions": 2,
    "deletions": 3,
    "changes": 5,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/nonJavaThread.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/nonJavaThread.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/nonJavaThread.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -323,9 +323,8 @@ void WatcherThread::stop() {\n   MonitorLocker mu(Terminator_lock);\n \n   while (watcher_thread() != NULL) {\n-    // This wait should make safepoint checks, wait without a timeout,\n-    // and wait as a suspend-equivalent condition.\n-    mu.wait(0, Mutex::_as_suspend_equivalent_flag);\n+    // This wait should make safepoint checks, wait without a timeout.\n+    mu.wait(0);\n   }\n }\n "
  },
  {
    "sha": "4d0872caeb08db604d016566f7e3c8c498e56599",
    "filename": "src/hotspot/share/runtime/notificationThread.cpp",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/notificationThread.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/notificationThread.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/notificationThread.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -107,8 +107,8 @@ void NotificationThread::notification_thread_entry(JavaThread* jt, TRAPS) {\n               (has_dcmd_notification_event = DCmdFactory::has_pending_jmx_notification()) |\n               (has_gc_notification_event = GCNotifier::has_event()))\n              == 0) {\n-        // Wait as a suspend equalent until notified that there is some work to do.\n-        ml.wait(0, true);\n+        // Wait until notified that there is some work to do.\n+        ml.wait(0);\n       }\n \n     }"
  },
  {
    "sha": "cf7e5e395c0189e279057a592e6e69a4e716f3bd",
    "filename": "src/hotspot/share/runtime/objectMonitor.cpp",
    "status": "modified",
    "additions": 49,
    "deletions": 82,
    "changes": 131,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/objectMonitor.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/objectMonitor.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/objectMonitor.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -404,29 +404,30 @@ bool ObjectMonitor::enter(TRAPS) {\n     }\n \n     OSThreadContendState osts(Self->osthread());\n-    ThreadBlockInVM tbivm(jt);\n \n-    // TODO-FIXME: change the following for(;;) loop to straight-line code.\n+    jt->frame_anchor()->make_walkable(jt);\n+    OrderAccess::storestore();\n     for (;;) {\n-      jt->set_suspend_equivalent();\n-      // cleared by handle_special_suspend_equivalent_condition()\n-      // or java_suspend_self()\n-\n+      jt->set_thread_state(_thread_blocked);\n       EnterI(THREAD);\n-\n-      if (!ExitSuspendEquivalent(jt)) break;\n-\n-      // We have acquired the contended monitor, but while we were\n-      // waiting another thread suspended us. We don't want to enter\n-      // the monitor while suspended because that would surprise the\n-      // thread that suspended us.\n-      //\n-      _recursions = 0;\n-      _succ = NULL;\n-      exit(false, Self);\n-\n-      jt->java_suspend_self();\n+      jt->set_thread_state_fence(_thread_blocked_trans);\n+      if (SafepointMechanism::should_process(jt)) {\n+        // We have acquired the contended monitor, but while we were\n+        // waiting another thread suspended us. We don't want to enter\n+        // the monitor while suspended because that would surprise the\n+        // thread that suspended us.\n+        _recursions = 0;\n+        _succ = NULL;\n+        exit(false, Self);\n+        SafepointMechanism::process_if_requested(jt);\n+        // Since we are going to _thread_blocked we skip setting _thread_in_vm here.\n+      } else {\n+        // Only exit path from for loop\n+        jt->set_thread_state(_thread_in_vm);\n+        break;\n+      }\n     }\n+\n     Self->set_current_pending_monitor(NULL);\n \n     // We cleared the pending monitor info since we've just gotten past\n@@ -957,25 +958,21 @@ void ObjectMonitor::ReenterI(Thread * Self, ObjectWaiter * SelfNode) {\n     if (TryLock(Self) > 0) break;\n     if (TrySpin(Self) > 0) break;\n \n-    // State transition wrappers around park() ...\n-    // ReenterI() wisely defers state transitions until\n-    // it's clear we must park the thread.\n     {\n       OSThreadContendState osts(Self->osthread());\n-      ThreadBlockInVM tbivm(jt);\n-\n-      // cleared by handle_special_suspend_equivalent_condition()\n-      // or java_suspend_self()\n-      jt->set_suspend_equivalent();\n+      jt->frame_anchor()->make_walkable(jt);\n+      OrderAccess::storestore();\n+      jt->set_thread_state(_thread_blocked);\n       Self->_ParkEvent->park();\n-\n-      // were we externally suspended while we were waiting?\n-      for (;;) {\n-        if (!ExitSuspendEquivalent(jt)) break;\n-        if (_succ == Self) { _succ = NULL; OrderAccess::fence(); }\n-        jt->java_suspend_self();\n-        jt->set_suspend_equivalent();\n+      jt->set_thread_state_fence(_thread_blocked_trans);\n+      if (SafepointMechanism::should_process(jt)) {\n+        if (_succ == Self) {\n+            _succ = NULL;\n+            OrderAccess::fence();\n+        }\n+        SafepointMechanism::process_if_requested(jt);\n       }\n+      jt->set_thread_state(_thread_in_vm);\n     }\n \n     // Try again, but just so we distinguish between futile wakeups and\n@@ -1323,41 +1320,6 @@ void ObjectMonitor::exit(bool not_suspended, TRAPS) {\n   }\n }\n \n-// ExitSuspendEquivalent:\n-// A faster alternate to handle_special_suspend_equivalent_condition()\n-//\n-// handle_special_suspend_equivalent_condition() unconditionally\n-// acquires the SR_lock.  On some platforms uncontended MutexLocker()\n-// operations have high latency.  Note that in ::enter() we call HSSEC\n-// while holding the monitor, so we effectively lengthen the critical sections.\n-//\n-// There are a number of possible solutions:\n-//\n-// A.  To ameliorate the problem we might also defer state transitions\n-//     to as late as possible -- just prior to parking.\n-//     Given that, we'd call HSSEC after having returned from park(),\n-//     but before attempting to acquire the monitor.  This is only a\n-//     partial solution.  It avoids calling HSSEC while holding the\n-//     monitor (good), but it still increases successor reacquisition latency --\n-//     the interval between unparking a successor and the time the successor\n-//     resumes and retries the lock.  See ReenterI(), which defers state transitions.\n-//     If we use this technique we can also avoid EnterI()-exit() loop\n-//     in ::enter() where we iteratively drop the lock and then attempt\n-//     to reacquire it after suspending.\n-//\n-// B.  In the future we might fold all the suspend bits into a\n-//     composite per-thread suspend flag and then update it with CAS().\n-//     Alternately, a Dekker-like mechanism with multiple variables\n-//     would suffice:\n-//       ST Self->_suspend_equivalent = false\n-//       MEMBAR\n-//       LD Self_>_suspend_flags\n-\n-bool ObjectMonitor::ExitSuspendEquivalent(JavaThread * jSelf) {\n-  return jSelf->handle_special_suspend_equivalent_condition();\n-}\n-\n-\n void ObjectMonitor::ExitEpilog(Thread * Self, ObjectWaiter * Wakee) {\n   assert(owner_raw() == Self, \"invariant\");\n \n@@ -1571,10 +1533,9 @@ void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) {\n     OSThread* osthread = Self->osthread();\n     OSThreadWaitState osts(osthread, true);\n     {\n-      ThreadBlockInVM tbivm(jt);\n-      // Thread is in thread_blocked state and oop access is unsafe.\n-      jt->set_suspend_equivalent();\n-\n+      jt->frame_anchor()->make_walkable(jt);\n+      OrderAccess::storestore();\n+      jt->set_thread_state(_thread_blocked);\n       if (interrupted || HAS_PENDING_EXCEPTION) {\n         // Intentionally empty\n       } else if (node._notified == 0) {\n@@ -1584,14 +1545,16 @@ void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) {\n           ret = Self->_ParkEvent->park(millis);\n         }\n       }\n-\n-      // were we externally suspended while we were waiting?\n-      if (ExitSuspendEquivalent (jt)) {\n-        // TODO-FIXME: add -- if succ == Self then succ = null.\n-        jt->java_suspend_self();\n+      jt->set_thread_state_fence(_thread_blocked_trans);\n+      if (SafepointMechanism::should_process(jt)) {\n+        if (_succ == Self) {\n+            _succ = NULL;\n+            OrderAccess::fence();\n+        }\n+        SafepointMechanism::process_if_requested(jt);\n       }\n-\n-    } // Exit thread safepoint: transition _thread_blocked -> _thread_in_vm\n+      jt->set_thread_state(_thread_in_vm);\n+    }\n \n     // Node may be on the WaitSet, the EntryList (or cxq), or in transition\n     // from the WaitSet to the EntryList.\n@@ -1953,8 +1916,12 @@ int ObjectMonitor::TrySpin(Thread * Self) {\n     // This is in keeping with the \"no loitering in runtime\" rule.\n     // We periodically check to see if there's a safepoint pending.\n     if ((ctr & 0xFF) == 0) {\n-      if (SafepointMechanism::should_process(Self)) {\n-        goto Abort;           // abrupt spin egress\n+      JavaThread* self_jt = Self->as_Java_thread();\n+      if (self_jt->thread_state() != _thread_blocked) {\n+        assert(self_jt->thread_state() != _thread_in_native, \"Must not be\");\n+        if (SafepointMechanism::should_process(Self->as_Java_thread())) {\n+          goto Abort;           // abrupt spin egress\n+        }\n       }\n       SpinPause();\n     }"
  },
  {
    "sha": "e99e8363b5690f34027cc1dd78d5e12b11f1345f",
    "filename": "src/hotspot/share/runtime/os.cpp",
    "status": "modified",
    "additions": 12,
    "deletions": 5,
    "changes": 17,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/os.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/os.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/os.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -871,11 +871,18 @@ int os::random() {\n // locking.\n \n void os::start_thread(Thread* thread) {\n-  // guard suspend/resume\n-  MutexLocker ml(thread->SR_lock(), Mutex::_no_safepoint_check_flag);\n-  OSThread* osthread = thread->osthread();\n-  osthread->set_state(RUNNABLE);\n-  pd_start_thread(thread);\n+  if (thread->is_Java_thread()) {\n+    JavaThread* jt = thread->as_Java_thread();\n+    // guard suspend/resume\n+    MutexLocker ml(jt->UtilLock(), Mutex::_no_safepoint_check_flag);\n+    OSThread* osthread = jt->osthread();\n+    osthread->set_state(RUNNABLE);\n+    pd_start_thread(jt);\n+  } else {\n+    OSThread* osthread = thread->osthread();\n+    osthread->set_state(RUNNABLE);\n+    pd_start_thread(thread);\n+  }\n }\n \n void os::abort(bool dump_core) {"
  },
  {
    "sha": "7b9912dc6e49b4b5954026c0af38bcdb487ea912",
    "filename": "src/hotspot/share/runtime/safepointMechanism.cpp",
    "status": "modified",
    "additions": 24,
    "deletions": 17,
    "changes": 41,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/safepointMechanism.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/safepointMechanism.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/safepointMechanism.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -77,24 +77,29 @@ void SafepointMechanism::default_initialize() {\n }\n \n void SafepointMechanism::process(JavaThread *thread) {\n-  if (global_poll()) {\n-    // Any load in ::block must not pass the global poll load.\n-    // Otherwise we might load an old safepoint counter (for example).\n-    OrderAccess::loadload();\n-    SafepointSynchronize::block(thread);\n-  }\n-\n-  // The call to on_safepoint fixes the thread's oops and the first few frames.\n-  //\n-  // The call has been carefully placed here to cater for a few situations:\n-  // 1) After we exit from block after a global poll\n-  // 2) After a thread races with the disarming of the global poll and transitions from native/blocked\n-  // 3) Before the handshake code is run\n-  StackWatermarkSet::on_safepoint(thread);\n+  bool need_rechecking;\n+  do {\n+    need_rechecking = false;\n+    if (global_poll()) {\n+      // Any load in ::block() must not pass the global poll load.\n+      // Otherwise we might load an old safepoint counter (for example).\n+      OrderAccess::loadload();\n+      SafepointSynchronize::block(thread);\n+    }\n \n-  if (thread->handshake_state()->should_process()) {\n-    thread->handshake_state()->process_by_self();\n-  }\n+    // The call to on_safepoint fixes the thread's oops and the first few frames.\n+    //\n+    // The call has been carefully placed here to cater to a few situations:\n+    // 1) After we exit from block after a global poll\n+    // 2) After a thread races with the disarming of the global poll and transitions from native/blocked\n+    // 3) Before the handshake code is run\n+    StackWatermarkSet::on_safepoint(thread);\n+\n+    if (thread->handshake_state()->should_process() &&\n+        !thread->handshake_state()->process_by_self()) {\n+      need_rechecking = true;\n+    }\n+  } while (need_rechecking);\n }\n \n uintptr_t SafepointMechanism::compute_poll_word(bool armed, uintptr_t stack_watermark) {\n@@ -111,6 +116,8 @@ uintptr_t SafepointMechanism::compute_poll_word(bool armed, uintptr_t stack_wate\n }\n \n void SafepointMechanism::update_poll_values(JavaThread* thread) {\n+  assert(thread->thread_state() != _thread_blocked, \"Must not be\");\n+  assert(thread->thread_state() != _thread_in_native, \"Must not be\");\n   for (;;) {\n     bool armed = global_poll() || thread->handshake_state()->has_operation();\n     uintptr_t stack_watermark = StackWatermarkSet::lowest_watermark(thread);"
  },
  {
    "sha": "b54db7b329fe8f8d16a4303a8055950c6b1ab07b",
    "filename": "src/hotspot/share/runtime/sweeper.cpp",
    "status": "modified",
    "additions": 3,
    "deletions": 11,
    "changes": 14,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/sweeper.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/sweeper.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/sweeper.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -265,16 +265,8 @@ void NMethodSweeper::force_sweep() {\n  * Handle a safepoint request\n  */\n void NMethodSweeper::handle_safepoint_request() {\n-  JavaThread* thread = JavaThread::current();\n-  if (SafepointMechanism::should_process(thread)) {\n-    if (PrintMethodFlushing && Verbose) {\n-      tty->print_cr(\"### Sweep at %d out of %d, yielding to safepoint\", _seen, CodeCache::nmethod_count());\n-    }\n-    MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-\n-    ThreadBlockInVM tbivm(thread);\n-    thread->java_suspend_self();\n-  }\n+  MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+  ThreadBlockInVM tbiv(JavaThread::current());\n }\n \n void NMethodSweeper::sweep() {"
  },
  {
    "sha": "7174dbcc9f8e4b35e430cba49881e696b56e0bfc",
    "filename": "src/hotspot/share/runtime/thread.cpp",
    "status": "modified",
    "additions": 81,
    "deletions": 327,
    "changes": 408,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/thread.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/thread.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/thread.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -272,8 +272,6 @@ Thread::Thread() {\n   _visited_for_critical_count = false;\n #endif\n \n-  _SR_lock = new Monitor(Mutex::suspend_resume, \"SR_lock\", true,\n-                         Monitor::_safepoint_check_sometimes);\n   _suspend_flags = 0;\n \n   // thread-specific hashCode stream generator state - Marsaglia shift-xor form\n@@ -451,11 +449,6 @@ Thread::~Thread() {\n   delete handle_area();\n   delete metadata_handles();\n \n-  // SR_handler uses this as a termination indicator -\n-  // needs to happen before os::free_thread()\n-  delete _SR_lock;\n-  _SR_lock = NULL;\n-\n   // osthread() can be NULL, if creation of thread failed.\n   if (osthread() != NULL) os::free_thread(osthread());\n \n@@ -576,119 +569,6 @@ void Thread::send_async_exception(oop java_thread, oop java_throwable) {\n   Handshake::execute(&vm_stop, target);\n }\n \n-\n-// Check if an external suspend request has completed (or has been\n-// cancelled). Returns true if the thread is externally suspended and\n-// false otherwise.\n-bool JavaThread::is_ext_suspend_completed() {\n-  bool did_trans_retry = false;  // only do thread_in_native_trans retry once\n-  bool do_trans_retry;           // flag to force the retry\n-\n-  do {\n-    do_trans_retry = false;\n-\n-    if (is_exiting()) {\n-      // Thread is in the process of exiting. This is always checked\n-      // first to reduce the risk of dereferencing a freed JavaThread.\n-      return false;\n-    }\n-\n-    if (!is_external_suspend()) {\n-      // Suspend request is cancelled. This is always checked before\n-      // is_ext_suspended() to reduce the risk of a rogue resume\n-      // confusing the thread that made the suspend request.\n-      return false;\n-    }\n-\n-    if (is_ext_suspended()) {\n-      // thread is suspended\n-      return true;\n-    }\n-\n-    // Now that we no longer do hard suspends of threads running\n-    // native code, the target thread can be changing thread state\n-    // while we are in this routine:\n-    //\n-    //   _thread_in_native -> _thread_in_native_trans -> _thread_blocked\n-    //\n-    // We save a copy of the thread state as observed at this moment\n-    // and make our decision about suspend completeness based on the\n-    // copy. This closes the race where the thread state is seen as\n-    // _thread_in_native_trans in the if-thread_blocked check, but is\n-    // seen as _thread_blocked in if-thread_in_native_trans check.\n-    JavaThreadState save_state = thread_state();\n-\n-    if (save_state == _thread_blocked && is_suspend_equivalent()) {\n-      // If the thread's state is _thread_blocked and this blocking\n-      // condition is known to be equivalent to a suspend, then we can\n-      // consider the thread to be externally suspended. This means that\n-      // the code that sets _thread_blocked has been modified to do\n-      // self-suspension if the blocking condition releases. We also\n-      // used to check for CONDVAR_WAIT here, but that is now covered by\n-      // the _thread_blocked with self-suspension check.\n-      //\n-      // Return true since we wouldn't be here unless there was still an\n-      // external suspend request.\n-      return true;\n-    } else if (save_state == _thread_in_native && frame_anchor()->walkable()) {\n-      // Threads running native code will self-suspend on native==>VM/Java\n-      // transitions. If its stack is walkable (should always be the case\n-      // unless this function is called before the actual java_suspend()\n-      // call), then the wait is done.\n-      return true;\n-    } else if (!did_trans_retry &&\n-               save_state == _thread_in_native_trans &&\n-               frame_anchor()->walkable()) {\n-      // The thread is transitioning from thread_in_native to another\n-      // thread state. check_safepoint_and_suspend_for_native_trans()\n-      // will force the thread to self-suspend. If it hasn't gotten\n-      // there yet we may have caught the thread in-between the native\n-      // code check above and the self-suspend.\n-      //\n-      // Since we use the saved thread state in the if-statement above,\n-      // there is a chance that the thread has already transitioned to\n-      // _thread_blocked by the time we get here. In that case, we will\n-      // make a single unnecessary pass through the logic below. This\n-      // doesn't hurt anything since we still do the trans retry.\n-\n-      // Once the thread leaves thread_in_native_trans for another\n-      // thread state, we break out of this retry loop. We shouldn't\n-      // need this flag to prevent us from getting back here, but\n-      // sometimes paranoia is good.\n-      did_trans_retry = true;\n-\n-      // We wait for the thread to transition to a more usable state.\n-      for (int i = 1; i <= SuspendRetryCount; i++) {\n-        // We used to do an \"os::yield_all(i)\" call here with the intention\n-        // that yielding would increase on each retry. However, the parameter\n-        // is ignored on Linux which means the yield didn't scale up. Waiting\n-        // on the SR_lock below provides a much more predictable scale up for\n-        // the delay. It also provides a simple/direct point to check for any\n-        // safepoint requests from the VMThread\n-\n-        // temporarily drops SR_lock while doing wait with safepoint check\n-        // (if we're a JavaThread - the WatcherThread can also call this)\n-        // and increase delay with each retry\n-        if (Thread::current()->is_Java_thread()) {\n-          SR_lock()->wait(i * SuspendRetryDelay);\n-        } else {\n-          SR_lock()->wait_without_safepoint_check(i * SuspendRetryDelay);\n-        }\n-\n-        // check the actual thread state instead of what we saved above\n-        if (thread_state() != _thread_in_native_trans) {\n-          // the thread has transitioned to another thread state so\n-          // try all the checks (except this one) one more time.\n-          do_trans_retry = true;\n-          break;\n-        }\n-      } // end retry loop\n-    }\n-  } while (do_trans_retry);\n-\n-  return false;\n-}\n-\n // GC Support\n bool Thread::claim_par_threads_do(uintx claim_token) {\n   uintx token = _threads_do_token;\n@@ -1183,7 +1063,6 @@ JavaThread::JavaThread() :\n   _saved_exception_pc(nullptr),\n \n   _terminated(_not_terminated),\n-  _suspend_equivalent(false),\n   _in_deopt_handler(0),\n   _doing_unsafe_access(false),\n   _do_not_unlock_if_synchronized(false),\n@@ -1213,6 +1092,9 @@ JavaThread::JavaThread() :\n \n   _handshake(this),\n \n+  _suspended(false),\n+  _suspend_requested(false),\n+\n   _popframe_preserved_args(nullptr),\n   _popframe_preserved_args_size(0),\n \n@@ -1228,6 +1110,8 @@ JavaThread::JavaThread() :\n \n   _SleepEvent(ParkEvent::Allocate(this))\n {\n+  _util_lock = new Monitor(Mutex::suspend_resume, \"Util_lock\", true,\n+                         Monitor::_safepoint_check_sometimes);\n \n   set_jni_functions(jni_functions());\n \n@@ -1391,6 +1275,11 @@ JavaThread::~JavaThread() {\n     FREE_C_HEAP_ARRAY(jlong, _jvmci_counters);\n   }\n #endif // INCLUDE_JVMCI\n+\n+  // SR_handler uses this as a termination indicator -\n+  // needs to happen before os::free_thread()\n+  delete _util_lock;\n+  _util_lock = NULL;\n }\n \n \n@@ -1554,33 +1443,10 @@ void JavaThread::exit(bool destroy_vm, ExitType exit_type) {\n       JvmtiExport::post_thread_end(this);\n     }\n \n-    // We have notified the agents that we are exiting, before we go on,\n-    // we must check for a pending external suspend request and honor it\n-    // in order to not surprise the thread that made the suspend request.\n-    while (true) {\n-      {\n-        MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-        if (!is_external_suspend()) {\n-          set_terminated(_thread_exiting);\n-          ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n-          break;\n-        }\n-        // Implied else:\n-        // Things get a little tricky here. We have a pending external\n-        // suspend request, but we are holding the SR_lock so we\n-        // can't just self-suspend. So we temporarily drop the lock\n-        // and then self-suspend.\n-      }\n-\n-      ThreadBlockInVM tbivm(this);\n-      java_suspend_self();\n+    // The careful dance between thread suspension and exit is handled here:\n+    _handshake.thread_exit();\n+    ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n \n-      // We're done with this suspend request, but we have to loop around\n-      // and check again. Eventually we will get SR_lock without a pending\n-      // external suspend request and will be able to mark ourselves as\n-      // exiting.\n-    }\n-    // no more external suspends are allowed at this point\n   } else {\n     assert(!is_terminated() && !is_exiting(), \"must not be exiting\");\n     // before_exit() has already posted JVMTI THREAD_END events\n@@ -1854,12 +1720,6 @@ void JavaThread::check_and_handle_async_exceptions(bool check_unsafe_error) {\n \n void JavaThread::handle_special_runtime_exit_condition(bool check_asyncs) {\n \n-  // Check for pending external suspend.\n-  if (is_external_suspend_with_lock()) {\n-    frame_anchor()->make_walkable(this);\n-    java_suspend_self_with_safepoint_check();\n-  }\n-\n   if (is_obj_deopt_suspend()) {\n     frame_anchor()->make_walkable(this);\n     wait_for_object_deoptimization();\n@@ -1921,150 +1781,79 @@ void JavaThread::send_thread_stop(oop java_throwable)  {\n   this->interrupt();\n }\n \n-// External suspension mechanism.\n-//\n-// Tell the VM to suspend a thread when ever it knows that it does not hold on\n-// to any VM_locks and it is at a transition\n-// Self-suspension will happen on the transition out of the vm.\n-// Catch \"this\" coming in from JNIEnv pointers when the thread has been freed\n-//\n-// Guarantees on return:\n-//   + Target thread will not execute any new bytecode (that's why we need to\n-//     force a safepoint)\n-//   + Target thread will not enter any new monitors\n-//\n-void JavaThread::java_suspend() {\n-  ThreadsListHandle tlh;\n-  if (!tlh.includes(this) || threadObj() == NULL || is_exiting()) {\n-    return;\n+class ThreadSuspensionHandshake : public AsyncHandshakeClosure {\n+ public:\n+  ThreadSuspensionHandshake() : AsyncHandshakeClosure(\"ThreadSuspension\") {}\n+  void do_thread(Thread* thr) {\n+    JavaThread* target = thr->as_Java_thread();\n+    target->handshake_state()->suspend_in_handshake();\n   }\n+};\n \n-  { MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    if (!is_external_suspend()) {\n-      // a racing resume has cancelled us; bail out now\n+class SuspendThreadHandshake : public HandshakeClosure {\n+  bool _did_suspend;\n+public:\n+  SuspendThreadHandshake() : HandshakeClosure(\"SuspendThread\"), _did_suspend(false) {}\n+  void do_thread(Thread* thr) {\n+    JavaThread* target = thr->as_Java_thread();\n+    if (target->is_exiting() ||\n+       target->threadObj() == NULL) {\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" exiting\", p2i(target));\n       return;\n     }\n-\n-    // suspend is done\n-\n-    // Warning: is_ext_suspend_completed() may temporarily drop the\n-    // SR_lock to allow the thread to reach a stable thread state if\n-    // it is currently in a transient thread state.\n-    if (is_ext_suspend_completed()) {\n-      return;\n+    assert(java_lang_Thread::thread(target->threadObj()) != NULL, \"BAD\");\n+    if (target->is_suspend_requested()) {\n+      if (target->is_suspended()) {\n+        // Target suspended\n+        log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(target));\n+        return;\n+      } else {\n+        // Target is going to wake up and leave suspension.\n+        // Let's just stop the thread from doing that.\n+        log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-suspended\", p2i(target));\n+        target->set_suspend(true);\n+        _did_suspend = true;\n+        return;\n+      }\n     }\n-  }\n-\n-  if (Thread::current() == this) {\n-    // Safely self-suspend.\n-    // If we don't do this explicitly it will implicitly happen\n-    // before we transition back to Java, and on some other thread-state\n-    // transition paths, but not as we exit a JVM TI SuspendThread call.\n-    // As SuspendThread(current) must not return (until resumed) we must\n-    // self-suspend here.\n-    ThreadBlockInVM tbivm(this);\n-    java_suspend_self();\n-  } else {\n-    VM_ThreadSuspend vm_suspend;\n-    VMThread::execute(&vm_suspend);\n-  }\n-}\n+    // no suspend request\n+    assert(!target->is_suspended(), \"cannot be suspended without a suspend request\");\n+    // Thread is safe, so it must execute the request, thus we can count it as suspended\n+    // from this point.\n+    target->set_suspend(true);\n+    _did_suspend = true;\n+    target->set_suspend_requested(true);\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" suspended, arming ThreadSuspension\", p2i(target));\n+    ThreadSuspensionHandshake* ts = new ThreadSuspensionHandshake();\n+    Handshake::execute(ts, target);\n+  }\n+  bool did_suspend() { return _did_suspend; }\n+};\n \n-// Part II of external suspension.\n-// A JavaThread self suspends when it detects a pending external suspend\n-// request. This is usually on transitions. It is also done in places\n-// where continuing to the next transition would surprise the caller,\n-// e.g., monitor entry.\n-//\n-// Returns the number of times that the thread self-suspended.\n+// External suspension mechanism.\n //\n-// Note: DO NOT call java_suspend_self() when you just want to block current\n-//       thread. java_suspend_self() is the second stage of cooperative\n-//       suspension for external suspend requests and should only be used\n-//       to complete an external suspend request.\n+// Guarantees on return (for a valid target thread):\n+//   - Target thread will not execute any new bytecode.\n+//   - Target thread will not enter any new monitors.\n //\n-int JavaThread::java_suspend_self() {\n-  assert(thread_state() == _thread_blocked, \"wrong state for java_suspend_self()\");\n-  int ret = 0;\n-\n-  // we are in the process of exiting so don't suspend\n-  if (is_exiting()) {\n-    clear_external_suspend();\n-    return ret;\n-  }\n-\n-  assert(_anchor.walkable() || !has_last_Java_frame(),\n-         \"must have walkable stack\");\n-\n-  MonitorLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-\n-  assert(!this->is_ext_suspended(),\n-         \"a thread trying to self-suspend should not already be suspended\");\n-\n-  if (this->is_suspend_equivalent()) {\n-    // If we are self-suspending as a result of the lifting of a\n-    // suspend equivalent condition, then the suspend_equivalent\n-    // flag is not cleared until we set the ext_suspended flag.\n-    this->clear_suspend_equivalent();\n+bool JavaThread::java_suspend() {\n+  ThreadsListHandle tlh;\n+  if (!tlh.includes(this)) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on threadslist, no suspension\", p2i(this));\n+    return false;\n   }\n+  SuspendThreadHandshake st;\n+  Handshake::execute(&st, this);\n+  return st.did_suspend();\n+}\n \n-  // A racing resume may have cancelled us before we grabbed SR_lock\n-  // above. Or another external suspend request could be waiting for us\n-  // by the time we return from SR_lock()->wait(). The thread\n-  // that requested the suspension may already be trying to walk our\n-  // stack and if we return now, we can change the stack out from under\n-  // it. This would be a \"bad thing (TM)\" and cause the stack walker\n-  // to crash. We stay self-suspended until there are no more pending\n-  // external suspend requests.\n-  while (is_external_suspend()) {\n-    ret++;\n-    this->set_ext_suspended();\n-\n-    // _ext_suspended flag is cleared by java_resume()\n-    while (is_ext_suspended()) {\n-      ml.wait();\n-    }\n+bool JavaThread::java_resume() {\n+  ThreadsListHandle tlh;\n+  if (!tlh.includes(this)) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on threadslist, nothing to resume\", p2i(this));\n+    return false;\n   }\n-  return ret;\n-}\n-\n-// Helper routine to set up the correct thread state before calling java_suspend_self.\n-// This is called when regular thread-state transition helpers can't be used because\n-// we can be in various states, in particular _thread_in_native_trans.\n-// We have to set the thread state directly to _thread_blocked so that it will\n-// be seen to be safepoint/handshake safe whilst suspended. This is also\n-// necessary to allow a thread in is_ext_suspend_completed, that observed the\n-// _thread_in_native_trans state, to proceed.\n-// The problem with setting thread state directly is that a\n-// safepoint could happen just after java_suspend_self() returns after being resumed,\n-// and the VM thread will see the _thread_blocked state. So we must check for a safepoint\n-// after restoring the state to make sure we won't leave while a safepoint is in progress.\n-// However, not all initial-states are allowed when performing a safepoint check, as we\n-// should never be blocking at a safepoint whilst in those states(*). Of these 'bad' states\n-// only _thread_in_native is possible when executing this code (based on our two callers).\n-// A thread that is _thread_in_native is already safepoint-safe and so it doesn't matter\n-// whether the VMThread sees the _thread_blocked state, or the _thread_in_native state,\n-// and so we don't need the explicit safepoint check.\n-// (*) See switch statement in SafepointSynchronize::block() for thread states that are\n-// allowed when performing a safepoint check.\n-\n-void JavaThread::java_suspend_self_with_safepoint_check() {\n-  assert(this == Thread::current(), \"invariant\");\n-  JavaThreadState state = thread_state();\n-\n-  do {\n-    set_thread_state(_thread_blocked);\n-    java_suspend_self();\n-    // The current thread could have been suspended again. We have to check for\n-    // suspend after restoring the saved state. Without this the current thread\n-    // might return to _thread_in_Java and execute bytecodes for an arbitrary\n-    // long time.\n-    set_thread_state_fence(state);\n-\n-    if (state != _thread_in_native) {\n-      SafepointMechanism::process_if_requested(this);\n-    }\n-  } while (is_external_suspend());\n+  return this->handshake_state()->resume();\n }\n \n // Wait for another thread to perform object reallocation and relocking on behalf of\n@@ -2090,10 +1879,6 @@ void JavaThread::wait_for_object_deoptimization() {\n   bool spin_wait = os::is_MP();\n   do {\n     set_thread_state(_thread_blocked);\n-    // Check if _external_suspend was set in the previous loop iteration.\n-    if (is_external_suspend()) {\n-      java_suspend_self();\n-    }\n     // Wait for object deoptimization if requested.\n     if (spin_wait) {\n       // A single deoptimization is typically very short. Microbenchmarks\n@@ -2121,7 +1906,7 @@ void JavaThread::wait_for_object_deoptimization() {\n     }\n     // A handshake for obj. deoptimization suspend could have been processed so\n     // we must check after processing.\n-  } while (is_obj_deopt_suspend() || is_external_suspend());\n+  } while (is_obj_deopt_suspend());\n }\n \n #ifdef ASSERT\n@@ -2171,29 +1956,6 @@ void JavaThread::check_special_condition_for_native_trans(JavaThread *thread) {\n   }\n }\n \n-// We need to guarantee the Threads_lock here, since resumes are not\n-// allowed during safepoint synchronization\n-// Can only resume from an external suspension\n-void JavaThread::java_resume() {\n-  assert_locked_or_safepoint(Threads_lock);\n-\n-  // Sanity check: thread is gone, has started exiting or the thread\n-  // was not externally suspended.\n-  ThreadsListHandle tlh;\n-  if (!tlh.includes(this) || is_exiting() || !is_external_suspend()) {\n-    return;\n-  }\n-\n-  MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-\n-  clear_external_suspend();\n-\n-  if (is_ext_suspended()) {\n-    clear_ext_suspended();\n-    SR_lock()->notify_all();\n-  }\n-}\n-\n #ifndef PRODUCT\n // Deoptimization\n // Function for testing deoptimization\n@@ -2759,15 +2521,7 @@ bool JavaThread::sleep(jlong millis) {\n     {\n       ThreadBlockInVM tbivm(this);\n       OSThreadWaitState osts(this->osthread(), false /* not Object.wait() */);\n-\n-      this->set_suspend_equivalent();\n-      // cleared by handle_special_suspend_equivalent_condition() or\n-      // java_suspend_self() via check_and_wait_while_suspended()\n-\n       slp->park(millis);\n-\n-      // were we externally suspended while we were waiting?\n-      this->check_and_wait_while_suspended();\n     }\n \n     // Update elapsed time tracking\n@@ -3689,11 +3443,11 @@ bool Threads::destroy_vm() {\n   _vm_complete = false;\n #endif\n   // Wait until we are the last non-daemon thread to execute\n-  { MonitorLocker nu(Threads_lock);\n+  {\n+    MonitorLocker nu(Threads_lock);\n     while (Threads::number_of_non_daemon_threads() > 1)\n-      // This wait should make safepoint checks, wait without a timeout,\n-      // and wait as a suspend-equivalent condition.\n-      nu.wait(0, Mutex::_as_suspend_equivalent_flag);\n+      // This wait should make safepoint checks, wait without a timeout.\n+      nu.wait(0);\n   }\n \n   EventShutdown e;\n@@ -3864,7 +3618,7 @@ void Threads::remove(JavaThread* p, bool is_daemon) {\n     // the thread might mess around with locks after this point. This can cause it\n     // to do callbacks into the safepoint code. However, the safepoint code is not aware\n     // of this thread since it is removed from the queue.\n-    p->set_terminated_value();\n+    p->set_terminated();\n \n     // Notify threads waiting in EscapeBarriers\n     EscapeBarrier::thread_removed(p);"
  },
  {
    "sha": "b78fec488db7ae427b4496ff7981ea79c6db5fc1",
    "filename": "src/hotspot/share/runtime/thread.hpp",
    "status": "modified",
    "additions": 21,
    "deletions": 161,
    "changes": 182,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/thread.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/thread.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/thread.hpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -212,80 +212,11 @@ class Thread: public ThreadShadow {\n \n  protected:\n   static void* allocate(size_t size, bool throw_excpt, MEMFLAGS flags = mtThread);\n- private:\n-\n-  // ***************************************************************\n-  // Suspend and resume support\n-  // ***************************************************************\n-  //\n-  // VM suspend/resume no longer exists - it was once used for various\n-  // things including safepoints but was deprecated and finally removed\n-  // in Java 7. Because VM suspension was considered \"internal\" Java-level\n-  // suspension was considered \"external\", and this legacy naming scheme\n-  // remains.\n-  //\n-  // External suspend/resume requests come from JVM_SuspendThread,\n-  // JVM_ResumeThread, JVMTI SuspendThread, and finally JVMTI\n-  // ResumeThread. External\n-  // suspend requests cause _external_suspend to be set and external\n-  // resume requests cause _external_suspend to be cleared.\n-  // External suspend requests do not nest on top of other external\n-  // suspend requests. The higher level APIs reject suspend requests\n-  // for already suspended threads.\n-  //\n-  // The external_suspend\n-  // flag is checked by has_special_runtime_exit_condition() and java thread\n-  // will self-suspend when handle_special_runtime_exit_condition() is\n-  // called. Most uses of the _thread_blocked state in JavaThreads are\n-  // considered the same as being externally suspended; if the blocking\n-  // condition lifts, the JavaThread will self-suspend. Other places\n-  // where VM checks for external_suspend include:\n-  //   + mutex granting (do not enter monitors when thread is suspended)\n-  //   + state transitions from _thread_in_native\n-  //\n-  // In general, java_suspend() does not wait for an external suspend\n-  // request to complete. When it returns, the only guarantee is that\n-  // the _external_suspend field is true.\n-  //\n-  // wait_for_ext_suspend_completion() is used to wait for an external\n-  // suspend request to complete. External suspend requests are usually\n-  // followed by some other interface call that requires the thread to\n-  // be quiescent, e.g., GetCallTrace(). By moving the \"wait time\" into\n-  // the interface that requires quiescence, we give the JavaThread a\n-  // chance to self-suspend before we need it to be quiescent. This\n-  // improves overall suspend/query performance.\n-  //\n-  // _suspend_flags controls the behavior of java_ suspend/resume.\n-  // It must be set under the protection of SR_lock. Read from the flag is\n-  // OK without SR_lock as long as the value is only used as a hint.\n-  // (e.g., check _external_suspend first without lock and then recheck\n-  // inside SR_lock and finish the suspension)\n-  //\n-  // _suspend_flags is also overloaded for other \"special conditions\" so\n-  // that a single check indicates whether any special action is needed\n-  // eg. for async exceptions.\n-  // -------------------------------------------------------------------\n-  // Notes:\n-  // 1. The suspend/resume logic no longer uses ThreadState in OSThread\n-  // but we still update its value to keep other part of the system (mainly\n-  // JVMTI) happy. ThreadState is legacy code (see notes in\n-  // osThread.hpp).\n-  //\n-  // 2. It would be more natural if set_external_suspend() is private and\n-  // part of java_suspend(), but that probably would affect the suspend/query\n-  // performance. Need more investigation on this.\n \n-  // suspend/resume lock: used for self-suspend\n-  Monitor* _SR_lock;\n-\n- protected:\n   enum SuspendFlags {\n     // NOTE: avoid using the sign-bit as cc generates different test code\n     //       when the sign-bit is used, and sometimes incorrectly - see CR 6398077\n \n-    _external_suspend       = 0x20000000U, // thread is asked to self suspend\n-    _ext_suspended          = 0x40000000U, // thread has self-suspended\n-\n     _has_async_exception    = 0x00000001U, // there is a pending async exception\n \n     _trace_flag             = 0x00000004U, // call tracing backend\n@@ -511,8 +442,6 @@ class Thread: public ThreadShadow {\n     os::set_native_thread_name(name);\n   }\n \n-  Monitor* SR_lock() const                       { return _SR_lock; }\n-\n   bool has_async_exception() const { return (_suspend_flags & _has_async_exception) != 0; }\n \n   inline void set_suspend_flag(SuspendFlags f);\n@@ -858,6 +787,7 @@ class JavaThread: public Thread {\n   friend class JVMCIVMStructs;\n   friend class WhiteBox;\n   friend class ThreadsSMRSupport; // to access _threadObj for exiting_threads_oops_do\n+  friend class HandshakeState;\n  private:\n   bool           _on_thread_list;                // Is set when this JavaThread is added to the Threads list\n   OopHandle      _threadObj;                     // The Java level thread object\n@@ -957,8 +887,7 @@ class JavaThread: public Thread {\n   // _vm_exited is a special value to cover the case of a JavaThread\n   // executing native code after the VM itself is terminated.\n   volatile TerminatedTypes _terminated;\n-  // suspend/resume support\n-  volatile bool         _suspend_equivalent;     // Suspend equivalent condition\n+\n   jint                  _in_deopt_handler;       // count of deoptimization\n                                                  // handlers thread is in\n   volatile bool         _doing_unsafe_access;    // Thread may fault due to unsafe access\n@@ -1163,9 +1092,10 @@ class JavaThread: public Thread {\n     return l_terminated != _not_terminated && l_terminated != _thread_exiting;\n   }\n   bool is_terminated() const;\n-  void set_terminated(TerminatedTypes t);\n+  void set_exiting() { _terminated = _thread_exiting; }\n+  void set_vm_exited() { _terminated = _vm_exited; };\n   // special for Threads::remove() which is static:\n-  void set_terminated_value();\n+  void set_terminated();\n   void block_if_vm_exited();\n \n   bool doing_unsafe_access()                     { return _doing_unsafe_access; }\n@@ -1192,96 +1122,36 @@ class JavaThread: public Thread {\n \n   // Suspend/resume support for JavaThread\n  private:\n-  inline void set_ext_suspended();\n-  inline void clear_ext_suspended();\n+  bool _suspended;\n+  bool _suspend_requested;\n \n  public:\n-  void java_suspend(); // higher-level suspension logic called by the public APIs\n-  void java_resume();  // higher-level resume logic called by the public APIs\n-  int  java_suspend_self(); // low-level self-suspension mechanics\n+  bool java_suspend(); // higher-level suspension logic called by the public APIs\n+  bool java_resume();  // higher-level resume logic called by the public APIs\n \n-  // Synchronize with another thread that is deoptimizing objects of the\n-  // current thread, i.e. reverts optimizations based on escape analysis.\n-  void wait_for_object_deoptimization();\n+  bool is_suspended() { return Atomic::load(&_suspended); }\n+  void set_suspend(bool to) { return Atomic::store(&_suspended, to); }\n \n- private:\n-  // mid-level wrapper around java_suspend_self to set up correct state and\n-  // check for a pending safepoint at the end\n-  void java_suspend_self_with_safepoint_check();\n+  bool is_suspend_requested() { return Atomic::load(&_suspend_requested); }\n+  void set_suspend_requested(bool to) { return Atomic::store(&_suspend_requested, to); }\n \n+  Mutex* UtilLock() { return _util_lock; }\n+ private:\n+  Mutex* _util_lock;\n  public:\n-  void check_and_wait_while_suspended() {\n-    assert(JavaThread::current() == this, \"sanity check\");\n-\n-    bool do_self_suspend;\n-    do {\n-      // were we externally suspended while we were waiting?\n-      do_self_suspend = handle_special_suspend_equivalent_condition();\n-      if (do_self_suspend) {\n-        // don't surprise the thread that suspended us by returning\n-        java_suspend_self();\n-        set_suspend_equivalent();\n-      }\n-    } while (do_self_suspend);\n-  }\n   static void check_safepoint_and_suspend_for_native_trans(JavaThread *thread);\n   // Check for async exception in addition to safepoint and suspend request.\n   static void check_special_condition_for_native_trans(JavaThread *thread);\n \n-  bool is_ext_suspend_completed();\n-\n-  inline void set_external_suspend();\n-  inline void clear_external_suspend();\n-\n-  bool is_external_suspend() const {\n-    return (_suspend_flags & _external_suspend) != 0;\n-  }\n   // Whenever a thread transitions from native to vm/java it must suspend\n   // if external|deopt suspend is present.\n   bool is_suspend_after_native() const {\n-    return (_suspend_flags & (_external_suspend | _obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n-  }\n-\n-  // external suspend request is completed\n-  bool is_ext_suspended() const {\n-    return (_suspend_flags & _ext_suspended) != 0;\n-  }\n-\n-  bool is_external_suspend_with_lock() const {\n-    MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    return is_external_suspend();\n+    return (_suspend_flags & (_obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n   }\n \n-  // Special method to handle a pending external suspend request\n-  // when a suspend equivalent condition lifts.\n-  bool handle_special_suspend_equivalent_condition() {\n-    assert(is_suspend_equivalent(),\n-           \"should only be called in a suspend equivalence condition\");\n-    MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    bool ret = is_external_suspend();\n-    if (!ret) {\n-      // not about to self-suspend so clear suspend equivalence\n-      clear_suspend_equivalent();\n-    }\n-    // implied else:\n-    // We have a pending external suspend request so we leave the\n-    // suspend_equivalent flag set until java_suspend_self() sets\n-    // the ext_suspended flag and clears the suspend_equivalent\n-    // flag. This insures that wait_for_ext_suspend_completion()\n-    // will return consistent values.\n-    return ret;\n-  }\n-\n-  // utility methods to see if we are doing some kind of suspension\n-  bool is_being_ext_suspended() const            {\n-    MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    return is_ext_suspended() || is_external_suspend();\n-  }\n-\n-  bool is_suspend_equivalent() const             { return _suspend_equivalent; }\n-\n-  void set_suspend_equivalent()                  { _suspend_equivalent = true; }\n-  void clear_suspend_equivalent()                { _suspend_equivalent = false; }\n+  // Synchronize with another thread that is deoptimizing objects of the\n+  // current thread, i.e. reverts optimizations based on escape analysis.\n+  void wait_for_object_deoptimization();\n \n   // Thread.stop support\n   void send_thread_stop(oop throwable);\n@@ -1302,17 +1172,7 @@ class JavaThread: public Thread {\n   // Return true if JavaThread has an asynchronous condition or\n   // if external suspension is requested.\n   bool has_special_runtime_exit_condition() {\n-    // Because we don't use is_external_suspend_with_lock\n-    // it is possible that we won't see an asynchronous external suspend\n-    // request that has just gotten started, i.e., SR_lock grabbed but\n-    // _external_suspend field change either not made yet or not visible\n-    // yet. However, this is okay because the request is asynchronous and\n-    // we will see the new flag value the next time through. It's also\n-    // possible that the external suspend request is dropped after\n-    // we have checked is_external_suspend(), we will recheck its value\n-    // under SR_lock in java_suspend_self().\n-    return (_special_runtime_exit_condition != _no_async_condition) ||\n-            is_external_suspend() || is_trace_suspend() || is_obj_deopt_suspend();\n+    return (_special_runtime_exit_condition != _no_async_condition) || is_trace_suspend() || is_obj_deopt_suspend();\n   }\n \n   void set_pending_unsafe_access_error()          { _special_runtime_exit_condition = _async_unsafe_access_error; }"
  },
  {
    "sha": "0453c965da0f2b3101e1bc0546bf21e82b603683",
    "filename": "src/hotspot/share/runtime/thread.inline.hpp",
    "status": "modified",
    "additions": 1,
    "deletions": 20,
    "changes": 21,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/thread.inline.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/thread.inline.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/thread.inline.hpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -94,20 +94,6 @@ inline void Thread::set_threads_hazard_ptr(ThreadsList* new_list) {\n   Atomic::release_store_fence(&_threads_hazard_ptr, new_list);\n }\n \n-inline void JavaThread::set_ext_suspended() {\n-  set_suspend_flag (_ext_suspended);\n-}\n-inline void JavaThread::clear_ext_suspended() {\n-  clear_suspend_flag(_ext_suspended);\n-}\n-\n-inline void JavaThread::set_external_suspend() {\n-  set_suspend_flag(_external_suspend);\n-}\n-inline void JavaThread::clear_external_suspend() {\n-  clear_suspend_flag(_external_suspend);\n-}\n-\n inline void JavaThread::set_pending_async_exception(oop e) {\n   _pending_async_exception = e;\n   _special_runtime_exit_condition = _async_exception;\n@@ -182,13 +168,8 @@ inline bool JavaThread::is_terminated() const {\n   return check_is_terminated(l_terminated);\n }\n \n-inline void JavaThread::set_terminated(TerminatedTypes t) {\n-  // use release-store so the setting of _terminated is seen more quickly\n-  Atomic::release_store((volatile jint *) &_terminated, (jint) t);\n-}\n-\n // special for Threads::remove() which is static:\n-inline void JavaThread::set_terminated_value() {\n+inline void JavaThread::set_terminated() {\n   // use release-store so the setting of _terminated is seen more quickly\n   Atomic::release_store((volatile jint *) &_terminated, (jint) _thread_terminated);\n }"
  },
  {
    "sha": "3078cfb22a210d6e3effe9ebb90635468e9fd493",
    "filename": "src/hotspot/share/runtime/vmOperations.cpp",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/openjdk/jdk/blob/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/vmOperations.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/06bd92226cb5a65ae994487c04fdb085e4cd975f/src/hotspot/share/runtime/vmOperations.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/runtime/vmOperations.cpp?ref=06bd92226cb5a65ae994487c04fdb085e4cd975f",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -355,7 +355,7 @@ int VM_Exit::set_vm_exited() {\n   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {\n     if (thr!=thr_cur && thr->thread_state() == _thread_in_native) {\n       ++num_active;\n-      thr->set_terminated(JavaThread::_vm_exited);  // per-thread flag\n+      thr->set_vm_exited();  // per-thread flag\n     }\n   }\n "
  }
]
