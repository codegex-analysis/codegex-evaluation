[
  {
    "sha": "bbc9042ebcac540c30599fac6810d54a7e528135",
    "filename": "src/java.base/share/classes/java/io/ObjectInputFilter.java",
    "status": "modified",
    "additions": 5,
    "deletions": 5,
    "changes": 10,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/io/ObjectInputFilter.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/io/ObjectInputFilter.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/io/ObjectInputFilter.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -226,12 +226,12 @@ private Config() {}\n         /**\n          * Lock object for system-wide filter.\n          */\n-        private final static Object serialFilterLock = new Object();\n+        private static final Object serialFilterLock = new Object();\n \n         /**\n          * Debug: Logger\n          */\n-        private final static System.Logger configLog;\n+        private static final System.Logger configLog;\n \n         /**\n          * Logger for debugging.\n@@ -246,14 +246,14 @@ static void filterLog(System.Logger.Level level, String msg, Object... args) {\n          * The name for the system-wide deserialization filter.\n          * Used as a system property and a java.security.Security property.\n          */\n-        private final static String SERIAL_FILTER_PROPNAME = \"jdk.serialFilter\";\n+        private static final String SERIAL_FILTER_PROPNAME = \"jdk.serialFilter\";\n \n         /**\n          * The system-wide filter; may be null.\n          * Lookup the filter in java.security.Security or\n          * the system property.\n          */\n-        private final static ObjectInputFilter configuredFilter;\n+        private static final ObjectInputFilter configuredFilter;\n \n         static {\n             configuredFilter = AccessController\n@@ -405,7 +405,7 @@ static ObjectInputFilter createFilter2(String pattern) {\n          * used for all ObjectInputStreams that do not set their own filters.\n          *\n          */\n-        final static class Global implements ObjectInputFilter {\n+        static final class Global implements ObjectInputFilter {\n             /**\n              * The pattern used to create the filter.\n              */"
  },
  {
    "sha": "acdd222121fa04b99ddeea0ef00170613cb28733",
    "filename": "src/java.base/share/classes/java/lang/StackFrameInfo.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/StackFrameInfo.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/StackFrameInfo.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/lang/StackFrameInfo.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -31,7 +31,7 @@\n import java.lang.invoke.MethodType;\n \n class StackFrameInfo implements StackFrame {\n-    private final static JavaLangInvokeAccess JLIA =\n+    private static final JavaLangInvokeAccess JLIA =\n         SharedSecrets.getJavaLangInvokeAccess();\n \n     private final boolean retainClassRef;"
  },
  {
    "sha": "b7a3617fb66fc5dca1870ef308efcacd0d9ac0c6",
    "filename": "src/java.base/share/classes/java/lang/StackStreamFactory.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/StackStreamFactory.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/StackStreamFactory.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/lang/StackStreamFactory.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -63,7 +63,7 @@ private StackStreamFactory() {}\n \n     // Stack walk implementation classes to be excluded during stack walking\n     // lazily add subclasses when they are loaded.\n-    private final static Set<Class<?>> stackWalkImplClasses = init();\n+    private static final Set<Class<?>> stackWalkImplClasses = init();\n \n     private static final int SMALL_BATCH       = 8;\n     private static final int BATCH_SIZE        = 32;\n@@ -81,7 +81,7 @@ private StackStreamFactory() {}\n      * Performance work and extensive testing is needed to replace the\n      * VM built-in backtrace filled in Throwable with the StackWalker.\n      */\n-    final static boolean isDebug =\n+    static final boolean isDebug =\n             \"true\".equals(GetPropertyAction.privilegedGetProperty(\"stackwalk.debug\"));\n \n     static <T> StackFrameTraverser<T>"
  },
  {
    "sha": "d1d28b83cc54aa5994f4822f7def7cb533243bd7",
    "filename": "src/java.base/share/classes/java/lang/StackWalker.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/StackWalker.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/StackWalker.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/lang/StackWalker.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -290,7 +290,7 @@ public default String getDescriptor() {\n \n     static final EnumSet<Option> DEFAULT_EMPTY_OPTION = EnumSet.noneOf(Option.class);\n \n-    private final static StackWalker DEFAULT_WALKER =\n+    private static final StackWalker DEFAULT_WALKER =\n         new StackWalker(DEFAULT_EMPTY_OPTION);\n \n     private final Set<Option> options;"
  },
  {
    "sha": "726e51322d0730d445f2e392cb4f992d6c1a24a0",
    "filename": "src/java.base/share/classes/java/lang/StringLatin1.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/StringLatin1.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/StringLatin1.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/lang/StringLatin1.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -643,7 +643,7 @@ public static String stripTrailing(byte[] value) {\n         return (right != value.length) ? newString(value, 0, right) : null;\n     }\n \n-    private final static class LinesSpliterator implements Spliterator<String> {\n+    private static final class LinesSpliterator implements Spliterator<String> {\n         private byte[] value;\n         private int index;        // current index, modified on advance/split\n         private final int fence;  // one past last index"
  },
  {
    "sha": "df4770c6486409b43ac3d9272333f870ee4ec24d",
    "filename": "src/java.base/share/classes/java/lang/StringUTF16.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/StringUTF16.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/StringUTF16.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/lang/StringUTF16.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -1065,7 +1065,7 @@ public static String stripTrailing(byte[] value) {\n         return (right != length) ? newString(value, 0, right) : null;\n     }\n \n-    private final static class LinesSpliterator implements Spliterator<String> {\n+    private static final class LinesSpliterator implements Spliterator<String> {\n         private byte[] value;\n         private int index;        // current index, modified on advance/split\n         private final int fence;  // one past last index"
  },
  {
    "sha": "16d7c79f69b20ebc483b89379cbaf076bb828c23",
    "filename": "src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -664,7 +664,7 @@ static MethodHandle makeBlockInliningWrapper(MethodHandle target) {\n                                    DONT_INLINE_THRESHOLD);\n     }\n \n-    private final static class Makers {\n+    private static final class Makers {\n         /** Constructs reinvoker lambda form which block inlining during JIT-compilation for a particular method handle */\n         static final Function<MethodHandle, LambdaForm> PRODUCE_BLOCK_INLINING_FORM = new Function<MethodHandle, LambdaForm>() {\n             @Override"
  },
  {
    "sha": "ee3a27b4a83ccc02e1330f54cc4e36f5ab086eec",
    "filename": "src/java.base/share/classes/java/lang/invoke/VarHandleGuards.java",
    "status": "modified",
    "additions": 79,
    "deletions": 79,
    "changes": 158,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/invoke/VarHandleGuards.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/invoke/VarHandleGuards.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/lang/invoke/VarHandleGuards.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -33,7 +33,7 @@\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static Object guard_L_L(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_L_L(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -50,7 +50,7 @@ final static Object guard_L_L(VarHandle handle, Object arg0, VarHandle.AccessDes\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_LL_V(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LL_V(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -68,7 +68,7 @@ final static void guard_LL_V(VarHandle handle, Object arg0, Object arg1, VarHand\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_LLL_Z(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LLL_Z(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -84,7 +84,7 @@ final static boolean guard_LLL_Z(VarHandle handle, Object arg0, Object arg1, Obj\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static Object guard_LLL_L(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LLL_L(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -101,7 +101,7 @@ final static Object guard_LLL_L(VarHandle handle, Object arg0, Object arg1, Obje\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static Object guard_LL_L(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LL_L(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -118,7 +118,7 @@ final static Object guard_LL_L(VarHandle handle, Object arg0, Object arg1, VarHa\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static int guard_L_I(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_L_I(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -134,7 +134,7 @@ final static int guard_L_I(VarHandle handle, Object arg0, VarHandle.AccessDescri\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_LI_V(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LI_V(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -152,7 +152,7 @@ final static void guard_LI_V(VarHandle handle, Object arg0, int arg1, VarHandle.\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_LII_Z(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LII_Z(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -168,7 +168,7 @@ final static boolean guard_LII_Z(VarHandle handle, Object arg0, int arg1, int ar\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static int guard_LII_I(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_LII_I(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -184,7 +184,7 @@ final static int guard_LII_I(VarHandle handle, Object arg0, int arg1, int arg2,\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static int guard_LI_I(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_LI_I(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -200,7 +200,7 @@ final static int guard_LI_I(VarHandle handle, Object arg0, int arg1, VarHandle.A\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static long guard_L_J(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_L_J(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -216,7 +216,7 @@ final static long guard_L_J(VarHandle handle, Object arg0, VarHandle.AccessDescr\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_LJ_V(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LJ_V(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -234,7 +234,7 @@ final static void guard_LJ_V(VarHandle handle, Object arg0, long arg1, VarHandle\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_LJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -250,7 +250,7 @@ final static boolean guard_LJJ_Z(VarHandle handle, Object arg0, long arg1, long\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static long guard_LJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_LJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -266,7 +266,7 @@ final static long guard_LJJ_J(VarHandle handle, Object arg0, long arg1, long arg\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static long guard_LJ_J(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_LJ_J(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -282,7 +282,7 @@ final static long guard_LJ_J(VarHandle handle, Object arg0, long arg1, VarHandle\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static float guard_L_F(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_L_F(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -298,7 +298,7 @@ final static float guard_L_F(VarHandle handle, Object arg0, VarHandle.AccessDesc\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_LF_V(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LF_V(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -316,7 +316,7 @@ final static void guard_LF_V(VarHandle handle, Object arg0, float arg1, VarHandl\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_LFF_Z(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LFF_Z(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -332,7 +332,7 @@ final static boolean guard_LFF_Z(VarHandle handle, Object arg0, float arg1, floa\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static float guard_LFF_F(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LFF_F(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -348,7 +348,7 @@ final static float guard_LFF_F(VarHandle handle, Object arg0, float arg1, float\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static float guard_LF_F(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LF_F(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -364,7 +364,7 @@ final static float guard_LF_F(VarHandle handle, Object arg0, float arg1, VarHand\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static double guard_L_D(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_L_D(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -380,7 +380,7 @@ final static double guard_L_D(VarHandle handle, Object arg0, VarHandle.AccessDes\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_LD_V(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LD_V(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -398,7 +398,7 @@ final static void guard_LD_V(VarHandle handle, Object arg0, double arg1, VarHand\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_LDD_Z(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LDD_Z(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -414,7 +414,7 @@ final static boolean guard_LDD_Z(VarHandle handle, Object arg0, double arg1, dou\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static double guard_LDD_D(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LDD_D(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -430,7 +430,7 @@ final static double guard_LDD_D(VarHandle handle, Object arg0, double arg1, doub\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static double guard_LD_D(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LD_D(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -446,7 +446,7 @@ final static double guard_LD_D(VarHandle handle, Object arg0, double arg1, VarHa\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static Object guard__L(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard__L(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -463,7 +463,7 @@ final static Object guard__L(VarHandle handle, VarHandle.AccessDescriptor ad) th\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_L_V(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_L_V(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -481,7 +481,7 @@ final static void guard_L_V(VarHandle handle, Object arg0, VarHandle.AccessDescr\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_LL_Z(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LL_Z(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -497,7 +497,7 @@ final static boolean guard_LL_Z(VarHandle handle, Object arg0, Object arg1, VarH\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static int guard__I(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard__I(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -513,7 +513,7 @@ final static int guard__I(VarHandle handle, VarHandle.AccessDescriptor ad) throw\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_I_V(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_I_V(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -531,7 +531,7 @@ final static void guard_I_V(VarHandle handle, int arg0, VarHandle.AccessDescript\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_II_Z(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_II_Z(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -547,7 +547,7 @@ final static boolean guard_II_Z(VarHandle handle, int arg0, int arg1, VarHandle.\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static int guard_II_I(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_II_I(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -563,7 +563,7 @@ final static int guard_II_I(VarHandle handle, int arg0, int arg1, VarHandle.Acce\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static int guard_I_I(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_I_I(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -579,7 +579,7 @@ final static int guard_I_I(VarHandle handle, int arg0, VarHandle.AccessDescripto\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static long guard__J(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard__J(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -595,7 +595,7 @@ final static long guard__J(VarHandle handle, VarHandle.AccessDescriptor ad) thro\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_J_V(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_J_V(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -613,7 +613,7 @@ final static void guard_J_V(VarHandle handle, long arg0, VarHandle.AccessDescrip\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_JJ_Z(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_JJ_Z(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -629,7 +629,7 @@ final static boolean guard_JJ_Z(VarHandle handle, long arg0, long arg1, VarHandl\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static long guard_JJ_J(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_JJ_J(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -645,7 +645,7 @@ final static long guard_JJ_J(VarHandle handle, long arg0, long arg1, VarHandle.A\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static long guard_J_J(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_J_J(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -661,7 +661,7 @@ final static long guard_J_J(VarHandle handle, long arg0, VarHandle.AccessDescrip\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static float guard__F(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard__F(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -677,7 +677,7 @@ final static float guard__F(VarHandle handle, VarHandle.AccessDescriptor ad) thr\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_F_V(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_F_V(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -695,7 +695,7 @@ final static void guard_F_V(VarHandle handle, float arg0, VarHandle.AccessDescri\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_FF_Z(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_FF_Z(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -711,7 +711,7 @@ final static boolean guard_FF_Z(VarHandle handle, float arg0, float arg1, VarHan\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static float guard_FF_F(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_FF_F(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -727,7 +727,7 @@ final static float guard_FF_F(VarHandle handle, float arg0, float arg1, VarHandl\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static float guard_F_F(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_F_F(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -743,7 +743,7 @@ final static float guard_F_F(VarHandle handle, float arg0, VarHandle.AccessDescr\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static double guard__D(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard__D(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -759,7 +759,7 @@ final static double guard__D(VarHandle handle, VarHandle.AccessDescriptor ad) th\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_D_V(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_D_V(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -777,7 +777,7 @@ final static void guard_D_V(VarHandle handle, double arg0, VarHandle.AccessDescr\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_DD_Z(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_DD_Z(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -793,7 +793,7 @@ final static boolean guard_DD_Z(VarHandle handle, double arg0, double arg1, VarH\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static double guard_DD_D(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_DD_D(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -809,7 +809,7 @@ final static double guard_DD_D(VarHandle handle, double arg0, double arg1, VarHa\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static double guard_D_D(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_D_D(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -825,7 +825,7 @@ final static double guard_D_D(VarHandle handle, double arg0, VarHandle.AccessDes\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static Object guard_LI_L(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LI_L(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -842,7 +842,7 @@ final static Object guard_LI_L(VarHandle handle, Object arg0, int arg1, VarHandl\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_LIL_V(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LIL_V(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -860,7 +860,7 @@ final static void guard_LIL_V(VarHandle handle, Object arg0, int arg1, Object ar\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_LILL_Z(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LILL_Z(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -876,7 +876,7 @@ final static boolean guard_LILL_Z(VarHandle handle, Object arg0, int arg1, Objec\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static Object guard_LILL_L(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LILL_L(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -893,7 +893,7 @@ final static Object guard_LILL_L(VarHandle handle, Object arg0, int arg1, Object\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static Object guard_LIL_L(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LIL_L(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -910,7 +910,7 @@ final static Object guard_LIL_L(VarHandle handle, Object arg0, int arg1, Object\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_LII_V(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LII_V(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -928,7 +928,7 @@ final static void guard_LII_V(VarHandle handle, Object arg0, int arg1, int arg2,\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_LIII_Z(VarHandle handle, Object arg0, int arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LIII_Z(VarHandle handle, Object arg0, int arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -944,7 +944,7 @@ final static boolean guard_LIII_Z(VarHandle handle, Object arg0, int arg1, int a\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static int guard_LIII_I(VarHandle handle, Object arg0, int arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_LIII_I(VarHandle handle, Object arg0, int arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -960,7 +960,7 @@ final static int guard_LIII_I(VarHandle handle, Object arg0, int arg1, int arg2,\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static long guard_LI_J(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_LI_J(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -976,7 +976,7 @@ final static long guard_LI_J(VarHandle handle, Object arg0, int arg1, VarHandle.\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_LIJ_V(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LIJ_V(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -994,7 +994,7 @@ final static void guard_LIJ_V(VarHandle handle, Object arg0, int arg1, long arg2\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_LIJJ_Z(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LIJJ_Z(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1010,7 +1010,7 @@ final static boolean guard_LIJJ_Z(VarHandle handle, Object arg0, int arg1, long\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static long guard_LIJJ_J(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_LIJJ_J(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1026,7 +1026,7 @@ final static long guard_LIJJ_J(VarHandle handle, Object arg0, int arg1, long arg\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static long guard_LIJ_J(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_LIJ_J(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1042,7 +1042,7 @@ final static long guard_LIJ_J(VarHandle handle, Object arg0, int arg1, long arg2\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static float guard_LI_F(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LI_F(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1058,7 +1058,7 @@ final static float guard_LI_F(VarHandle handle, Object arg0, int arg1, VarHandle\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_LIF_V(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LIF_V(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1076,7 +1076,7 @@ final static void guard_LIF_V(VarHandle handle, Object arg0, int arg1, float arg\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_LIFF_Z(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LIFF_Z(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1092,7 +1092,7 @@ final static boolean guard_LIFF_Z(VarHandle handle, Object arg0, int arg1, float\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static float guard_LIFF_F(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LIFF_F(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1108,7 +1108,7 @@ final static float guard_LIFF_F(VarHandle handle, Object arg0, int arg1, float a\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static float guard_LIF_F(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LIF_F(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1124,7 +1124,7 @@ final static float guard_LIF_F(VarHandle handle, Object arg0, int arg1, float ar\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static double guard_LI_D(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LI_D(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1140,7 +1140,7 @@ final static double guard_LI_D(VarHandle handle, Object arg0, int arg1, VarHandl\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_LID_V(VarHandle handle, Object arg0, int arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LID_V(VarHandle handle, Object arg0, int arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1158,7 +1158,7 @@ final static void guard_LID_V(VarHandle handle, Object arg0, int arg1, double ar\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_LIDD_Z(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LIDD_Z(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1174,7 +1174,7 @@ final static boolean guard_LIDD_Z(VarHandle handle, Object arg0, int arg1, doubl\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static double guard_LIDD_D(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LIDD_D(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1190,7 +1190,7 @@ final static double guard_LIDD_D(VarHandle handle, Object arg0, int arg1, double\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static double guard_LID_D(VarHandle handle, Object arg0, int arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LID_D(VarHandle handle, Object arg0, int arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1206,7 +1206,7 @@ final static double guard_LID_D(VarHandle handle, Object arg0, int arg1, double\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static int guard_LJ_I(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_LJ_I(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1222,7 +1222,7 @@ final static int guard_LJ_I(VarHandle handle, Object arg0, long arg1, VarHandle.\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_LJI_V(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LJI_V(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1240,7 +1240,7 @@ final static void guard_LJI_V(VarHandle handle, Object arg0, long arg1, int arg2\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_LJII_Z(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LJII_Z(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1256,7 +1256,7 @@ final static boolean guard_LJII_Z(VarHandle handle, Object arg0, long arg1, int\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static int guard_LJII_I(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_LJII_I(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1272,7 +1272,7 @@ final static int guard_LJII_I(VarHandle handle, Object arg0, long arg1, int arg2\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static int guard_LJI_I(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_LJI_I(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1288,7 +1288,7 @@ final static int guard_LJI_I(VarHandle handle, Object arg0, long arg1, int arg2,\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static void guard_LJJ_V(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LJJ_V(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1306,7 +1306,7 @@ final static void guard_LJJ_V(VarHandle handle, Object arg0, long arg1, long arg\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static boolean guard_LJJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LJJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);\n@@ -1322,7 +1322,7 @@ final static boolean guard_LJJJ_Z(VarHandle handle, Object arg0, long arg1, long\n     @ForceInline\n     @LambdaForm.Compiled\n     @Hidden\n-    final static long guard_LJJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_LJJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n         if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n             throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n                     + ad.symbolicMethodTypeExact);"
  },
  {
    "sha": "a874993e6651c7352fad12369ef55585a7c8f9be",
    "filename": "src/java.base/share/classes/java/lang/invoke/VarHandles.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/invoke/VarHandles.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/invoke/VarHandles.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/lang/invoke/VarHandles.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -686,7 +686,7 @@ private static boolean isCheckedException(Class<?> clazz) {\n //                @ForceInline\n //                @LambdaForm.Compiled\n //                @Hidden\n-//                final static <METHOD> throws Throwable {\n+//                static final <METHOD> throws Throwable {\n //                    if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n //                        throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n //                                + ad.symbolicMethodTypeExact);\n@@ -704,7 +704,7 @@ private static boolean isCheckedException(Class<?> clazz) {\n //                @ForceInline\n //                @LambdaForm.Compiled\n //                @Hidden\n-//                final static <METHOD> throws Throwable {\n+//                static final <METHOD> throws Throwable {\n //                    if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n //                        throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n //                                + ad.symbolicMethodTypeExact);"
  },
  {
    "sha": "648fb8b6c80c6b0c21c28273dd0c4f732f0fa358",
    "filename": "src/java.base/share/classes/java/lang/module/ModuleDescriptor.java",
    "status": "modified",
    "additions": 5,
    "deletions": 5,
    "changes": 10,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/module/ModuleDescriptor.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/module/ModuleDescriptor.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/lang/module/ModuleDescriptor.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -135,7 +135,7 @@\n      * @since 9\n      */\n \n-    public final static class Requires\n+    public static final class Requires\n         implements Comparable<Requires>\n     {\n \n@@ -362,7 +362,7 @@ public String toString() {\n      * @since 9\n      */\n \n-    public final static class Exports\n+    public static final class Exports\n         implements Comparable<Exports>\n     {\n \n@@ -568,7 +568,7 @@ public String toString() {\n      * @since 9\n      */\n \n-    public final static class Opens\n+    public static final class Opens\n         implements Comparable<Opens>\n     {\n         /**\n@@ -767,7 +767,7 @@ public String toString() {\n      * @since 9\n      */\n \n-    public final static class Provides\n+    public static final class Provides\n         implements Comparable<Provides>\n     {\n         private final String service;\n@@ -940,7 +940,7 @@ public String toString() {\n      * @since 9\n      */\n \n-    public final static class Version\n+    public static final class Version\n         implements Comparable<Version>\n     {\n "
  },
  {
    "sha": "f3f5964ef4313739bf50276c60930c29454ba716",
    "filename": "src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -98,9 +98,9 @@\n                             \"jdk.proxy.ProxyGenerator.saveGeneratedFiles\"));\n \n     /* Preloaded ProxyMethod objects for methods in java.lang.Object */\n-    private final static ProxyMethod hashCodeMethod;\n-    private final static ProxyMethod equalsMethod;\n-    private final static ProxyMethod toStringMethod;\n+    private static final ProxyMethod hashCodeMethod;\n+    private static final ProxyMethod equalsMethod;\n+    private static final ProxyMethod toStringMethod;\n \n     static {\n         try {"
  },
  {
    "sha": "a9988f77b8cf5e384bd14ed7550de9e6decbce11",
    "filename": "src/java.base/share/classes/java/nio/BufferMismatch.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/nio/BufferMismatch.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/nio/BufferMismatch.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/nio/BufferMismatch.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -32,7 +32,7 @@\n  */\n final class BufferMismatch {\n \n-    final static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n \n     static int mismatch(ByteBuffer a, int aOff, ByteBuffer b, int bOff, int length) {\n         int i = 0;"
  },
  {
    "sha": "37a4218fa687ed8af333511c51f66cb26e3e8eca",
    "filename": "src/java.base/share/classes/java/text/CompactNumberFormat.java",
    "status": "modified",
    "additions": 11,
    "deletions": 11,
    "changes": 22,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/text/CompactNumberFormat.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/text/CompactNumberFormat.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/text/CompactNumberFormat.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -1211,14 +1211,14 @@ private void processCompactPatterns() {\n     }\n \n     // Patterns for plurals syntax validation\n-    private final static String EXPR = \"([niftvwe])\\\\s*(([/%])\\\\s*(\\\\d+))*\";\n-    private final static String RELATION = \"(!?=)\";\n-    private final static String VALUE_RANGE = \"((\\\\d+)\\\\.\\\\.(\\\\d+)|\\\\d+)\";\n-    private final static String CONDITION = EXPR + \"\\\\s*\" +\n+    private static final String EXPR = \"([niftvwe])\\\\s*(([/%])\\\\s*(\\\\d+))*\";\n+    private static final String RELATION = \"(!?=)\";\n+    private static final String VALUE_RANGE = \"((\\\\d+)\\\\.\\\\.(\\\\d+)|\\\\d+)\";\n+    private static final String CONDITION = EXPR + \"\\\\s*\" +\n                                              RELATION + \"\\\\s*\" +\n                                              VALUE_RANGE + \"\\\\s*\" +\n                                              \"(,\\\\s*\" + VALUE_RANGE + \")*\";\n-    private final static Pattern PLURALRULES_PATTERN =\n+    private static final Pattern PLURALRULES_PATTERN =\n             Pattern.compile(\"(zero|one|two|few|many):\\\\s*\" +\n                             CONDITION +\n                             \"(\\\\s*(and|or)\\\\s*\" + CONDITION + \")*\");\n@@ -2421,12 +2421,12 @@ private static boolean matchPluralRule(String condition, double input) {\n                 .allMatch(r -> relationCheck(r, input)));\n     }\n \n-    private final static String NAMED_EXPR = \"(?<op>[niftvwe])\\\\s*((?<div>[/%])\\\\s*(?<val>\\\\d+))*\";\n-    private final static String NAMED_RELATION = \"(?<rel>!?=)\";\n-    private final static String NAMED_VALUE_RANGE = \"(?<start>\\\\d+)\\\\.\\\\.(?<end>\\\\d+)|(?<value>\\\\d+)\";\n-    private final static Pattern EXPR_PATTERN = Pattern.compile(NAMED_EXPR);\n-    private final static Pattern RELATION_PATTERN = Pattern.compile(NAMED_RELATION);\n-    private final static Pattern VALUE_RANGE_PATTERN = Pattern.compile(NAMED_VALUE_RANGE);\n+    private static final String NAMED_EXPR = \"(?<op>[niftvwe])\\\\s*((?<div>[/%])\\\\s*(?<val>\\\\d+))*\";\n+    private static final String NAMED_RELATION = \"(?<rel>!?=)\";\n+    private static final String NAMED_VALUE_RANGE = \"(?<start>\\\\d+)\\\\.\\\\.(?<end>\\\\d+)|(?<value>\\\\d+)\";\n+    private static final Pattern EXPR_PATTERN = Pattern.compile(NAMED_EXPR);\n+    private static final Pattern RELATION_PATTERN = Pattern.compile(NAMED_RELATION);\n+    private static final Pattern VALUE_RANGE_PATTERN = Pattern.compile(NAMED_VALUE_RANGE);\n \n     /**\n      * Checks if the 'input' equals the value, or within the range."
  },
  {
    "sha": "f7d6a74378dcedbad56518146f9ab65ee9418ac8",
    "filename": "src/java.base/share/classes/java/text/NumberFormat.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/text/NumberFormat.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/text/NumberFormat.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/text/NumberFormat.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -619,7 +619,7 @@ public static NumberFormat getPercentInstance(Locale inLocale) {\n     /**\n      * Returns a scientific format for the current default locale.\n      */\n-    /*public*/ final static NumberFormat getScientificInstance() {\n+    /*public*/ static final NumberFormat getScientificInstance() {\n         return getInstance(Locale.getDefault(Locale.Category.FORMAT), null, SCIENTIFICSTYLE);\n     }\n "
  },
  {
    "sha": "2fd1260c2d8e09b7a3d36faa474c6abc91b59676",
    "filename": "src/java.base/share/classes/java/time/format/DateTimeFormatterBuilder.java",
    "status": "modified",
    "additions": 4,
    "deletions": 4,
    "changes": 8,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/time/format/DateTimeFormatterBuilder.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/java/time/format/DateTimeFormatterBuilder.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/time/format/DateTimeFormatterBuilder.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -5041,7 +5041,7 @@ public String toString() {\n      */\n     static final class DayPeriodPrinterParser implements DateTimePrinterParser {\n         private final TextStyle textStyle;\n-        private final static ConcurrentMap<Locale, LocaleStore> DAYPERIOD_LOCALESTORE = new ConcurrentHashMap<>();\n+        private static final ConcurrentMap<Locale, LocaleStore> DAYPERIOD_LOCALESTORE = new ConcurrentHashMap<>();\n \n         /**\n          * Constructor.\n@@ -5148,15 +5148,15 @@ private static LocaleStore findDayPeriodStore(Locale locale) {\n         /**\n          *  DayPeriod cache\n          */\n-        private final static Map<Locale, Map<DayPeriod, Long>> DAYPERIOD_CACHE = new ConcurrentHashMap<>();\n+        private static final Map<Locale, Map<DayPeriod, Long>> DAYPERIOD_CACHE = new ConcurrentHashMap<>();\n         /**\n          * comparator based on the duration of the day period.\n          */\n-        private final static Comparator<DayPeriod> DPCOMPARATOR = (dp1, dp2) -> (int)(dp1.duration() - dp2.duration());\n+        private static final Comparator<DayPeriod> DPCOMPARATOR = (dp1, dp2) -> (int)(dp1.duration() - dp2.duration());\n         /**\n          * Pattern to parse day period rules\n          */\n-        private final static Pattern RULE = Pattern.compile(\"(?<type>[a-z12]+):(?<from>\\\\d{2}):00(-(?<to>\\\\d{2}))*\");\n+        private static final Pattern RULE = Pattern.compile(\"(?<type>[a-z12]+):(?<from>\\\\d{2}):00(-(?<to>\\\\d{2}))*\");\n         /**\n          * minute-of-day of \"at\" or \"from\" attribute\n          */"
  },
  {
    "sha": "63e9ae78e83170c54cfb19f243e2885a6db9a3e3",
    "filename": "src/java.base/share/classes/jdk/internal/jimage/ImageReader.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/jdk/internal/jimage/ImageReader.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/jdk/internal/jimage/ImageReader.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/jdk/internal/jimage/ImageReader.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -204,7 +204,7 @@ public InputStream getResourceStream(ImageLocation loc) {\n         return reader.getResourceStream(loc);\n     }\n \n-    private final static class SharedImageReader extends BasicImageReader {\n+    private static final class SharedImageReader extends BasicImageReader {\n         static final int SIZE_OF_OFFSET = Integer.BYTES;\n \n         static final Map<Path, SharedImageReader> OPEN_FILES = new HashMap<>();"
  },
  {
    "sha": "ee71089fb77e96c6f2fa6e9c1edf516b941c94c0",
    "filename": "src/java.base/share/classes/jdk/internal/jrtfs/SystemImage.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/jdk/internal/jrtfs/SystemImage.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/jdk/internal/jrtfs/SystemImage.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/jdk/internal/jrtfs/SystemImage.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -80,9 +80,9 @@ void close() throws IOException {\n \n     static final String RUNTIME_HOME;\n     // \"modules\" jimage file Path\n-    final static Path moduleImageFile;\n+    static final Path moduleImageFile;\n     // \"modules\" jimage exists or not?\n-    final static boolean modulesImageExists;\n+    static final boolean modulesImageExists;\n     // <JAVA_HOME>/modules directory Path\n     static final Path explodedModulesDir;\n "
  },
  {
    "sha": "dbc4d5a74b4af0bb532e773535745a8df0538639",
    "filename": "src/java.base/share/classes/jdk/internal/logger/DefaultLoggerFinder.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/jdk/internal/logger/DefaultLoggerFinder.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/jdk/internal/logger/DefaultLoggerFinder.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/jdk/internal/logger/DefaultLoggerFinder.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -134,8 +134,8 @@ synchronized Logger get(Function<String, Logger> loggerSupplier, final String na\n             return w;\n         }\n \n-        final static SharedLoggers system = new SharedLoggers();\n-        final static SharedLoggers application = new SharedLoggers();\n+        static final SharedLoggers system = new SharedLoggers();\n+        static final SharedLoggers application = new SharedLoggers();\n     }\n \n     public static boolean isSystem(Module m) {"
  },
  {
    "sha": "727a5ff3c14b5c8bd043ac441121a24d33340e84",
    "filename": "src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/SerialVersionUIDAdder.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/SerialVersionUIDAdder.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/SerialVersionUIDAdder.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/SerialVersionUIDAdder.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -349,7 +349,7 @@ public boolean hasSVUID() {\n     }\n \n     /**\n-      * Adds a final static serialVersionUID field to the class, with the given value.\n+      * Adds a static final serialVersionUID field to the class, with the given value.\n       *\n       * @param svuid the serialVersionUID field value.\n       */"
  },
  {
    "sha": "6a3534b1af77a0f8d1032feefcec4314cff11fc6",
    "filename": "src/java.base/share/classes/jdk/internal/ref/CleanerFactory.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/jdk/internal/ref/CleanerFactory.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/jdk/internal/ref/CleanerFactory.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/jdk/internal/ref/CleanerFactory.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -37,7 +37,7 @@\n public final class CleanerFactory {\n \n     /* The common Cleaner. */\n-    private final static Cleaner commonCleaner = Cleaner.create(new ThreadFactory() {\n+    private static final Cleaner commonCleaner = Cleaner.create(new ThreadFactory() {\n         @Override\n         public Thread newThread(Runnable r) {\n             return InnocuousThread.newSystemThread(\"Common-Cleaner\","
  },
  {
    "sha": "578519f7dcf7762092dfe813fe673b9e273dd8b2",
    "filename": "src/java.base/share/classes/jdk/internal/ref/CleanerImpl.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/jdk/internal/ref/CleanerImpl.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/jdk/internal/ref/CleanerImpl.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/jdk/internal/ref/CleanerImpl.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -204,7 +204,7 @@ public void clear() {\n      * The factory is a singleton.\n      */\n     static final class InnocuousThreadFactory implements ThreadFactory {\n-        final static ThreadFactory factory = new InnocuousThreadFactory();\n+        static final ThreadFactory factory = new InnocuousThreadFactory();\n \n         static ThreadFactory factory() {\n             return factory;"
  },
  {
    "sha": "21aae324b2502564d6ccc066a6876cbeb86ea092",
    "filename": "src/java.base/share/classes/sun/net/util/IPAddressUtil.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/sun/net/util/IPAddressUtil.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/sun/net/util/IPAddressUtil.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/sun/net/util/IPAddressUtil.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -307,7 +307,7 @@ private static boolean isIPv4MappedAddress(byte[] addr) {\n      * Mapping from unscoped local Inet(6)Address to the same address\n      * including the correct scope-id, determined from NetworkInterface.\n      */\n-    private final static ConcurrentHashMap<InetAddress,InetAddress>\n+    private static final ConcurrentHashMap<InetAddress,InetAddress>\n         cache = new ConcurrentHashMap<>();\n \n     /**"
  },
  {
    "sha": "a8b40897aed18e687a049fc321f419671f7bb42b",
    "filename": "src/java.base/share/classes/sun/security/provider/AbstractDrbg.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/sun/security/provider/AbstractDrbg.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/sun/security/provider/AbstractDrbg.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/sun/security/provider/AbstractDrbg.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -518,7 +518,7 @@ public final synchronized void engineSetSeed(byte[] input) {\n      * assumed to support prediction resistance and always contains\n      * full-entropy.\n      */\n-    private final static EntropySource defaultES =\n+    private static final EntropySource defaultES =\n             (minE, minLen, maxLen, pr) -> {\n         byte[] result = new byte[minLen];\n         SeedGenerator.generateSeed(result);"
  },
  {
    "sha": "4c6c0cd435fc63599ac82167a288babf6576d6fe",
    "filename": "src/java.base/share/classes/sun/security/ssl/SSLCipher.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/sun/security/ssl/SSLCipher.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/sun/security/ssl/SSLCipher.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/sun/security/ssl/SSLCipher.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -411,7 +411,7 @@\n     private static final HashMap<String, Long> cipherLimits = new HashMap<>();\n \n     // Keywords found on the jdk.tls.keyLimits security property.\n-    final static String[] tag = {\"KEYUPDATE\"};\n+    static final String[] tag = {\"KEYUPDATE\"};\n \n     static  {\n         final long max = 4611686018427387904L; // 2^62"
  },
  {
    "sha": "e30405f15e2a6c5a141e4ad28acbe079eb5f340e",
    "filename": "src/java.base/share/classes/sun/security/ssl/SSLSessionContextImpl.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/sun/security/ssl/SSLSessionContextImpl.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/sun/security/ssl/SSLSessionContextImpl.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/sun/security/ssl/SSLSessionContextImpl.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -58,9 +58,9 @@\n  */\n \n final class SSLSessionContextImpl implements SSLSessionContext {\n-    private final static int DEFAULT_MAX_CACHE_SIZE = 20480;\n+    private static final int DEFAULT_MAX_CACHE_SIZE = 20480;\n     // Default lifetime of a session. 24 hours\n-    final static int DEFAULT_SESSION_TIMEOUT = 86400;\n+    static final int DEFAULT_SESSION_TIMEOUT = 86400;\n \n     private final Cache<SessionId, SSLSessionImpl> sessionCache;\n                                         // session cache, session id as key"
  },
  {
    "sha": "c35e95b661bc0acba55d1e583c3c478d10b411a2",
    "filename": "src/java.base/share/classes/sun/security/ssl/SessionTicketExtension.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/sun/security/ssl/SessionTicketExtension.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/sun/security/ssl/SessionTicketExtension.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/sun/security/ssl/SessionTicketExtension.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -112,7 +112,7 @@\n     }\n \n     // Crypto key context for session state.  Used with stateless operation.\n-    final static class StatelessKey {\n+    static final class StatelessKey {\n         final long timeout;\n         final SecretKey key;\n         final int num;"
  },
  {
    "sha": "bde0142316ca3a69e47ae675f9f5aa322bff9f60",
    "filename": "src/java.base/share/classes/sun/security/util/ResourcesMgr.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/sun/security/util/ResourcesMgr.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/sun/security/util/ResourcesMgr.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/sun/security/util/ResourcesMgr.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -34,7 +34,7 @@\n  */\n public class ResourcesMgr {\n     // intended for java.security, javax.security and sun.security resources\n-    private final static Map<String, ResourceBundle> bundles = new ConcurrentHashMap<>();\n+    private static final Map<String, ResourceBundle> bundles = new ConcurrentHashMap<>();\n \n     public static String getString(String s) {\n         return getBundle(\"sun.security.util.Resources\").getString(s);"
  },
  {
    "sha": "f65dff6d31406e3bcb7ce8be0b8cae1639489e59",
    "filename": "src/java.base/share/classes/sun/security/util/SignatureUtil.java",
    "status": "modified",
    "additions": 6,
    "deletions": 6,
    "changes": 12,
    "blob_url": "https://github.com/openjdk/jdk/blob/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/sun/security/util/SignatureUtil.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/86aa9a349fd1197eae5d7377416f47919cfaa2f5/src/java.base/share/classes/sun/security/util/SignatureUtil.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/sun/security/util/SignatureUtil.java?ref=86aa9a349fd1197eae5d7377416f47919cfaa2f5",
    "patch": "@@ -195,9 +195,9 @@ public static void initSignWithParam(Signature s, PrivateKey key,\n     }\n \n     public static class EdDSADigestAlgHolder {\n-        public final static AlgorithmId sha512;\n-        public final static AlgorithmId shake256;\n-        public final static AlgorithmId shake256$512;\n+        public static final AlgorithmId sha512;\n+        public static final AlgorithmId shake256;\n+        public static final AlgorithmId shake256$512;\n \n         static {\n             try {\n@@ -508,15 +508,15 @@ public static String getDefaultSigAlgForKey(PrivateKey k) {\n \n     // Useful PSSParameterSpec objects\n     private static class PSSParamsHolder {\n-        final static PSSParameterSpec PSS_256_SPEC = new PSSParameterSpec(\n+        static final PSSParameterSpec PSS_256_SPEC = new PSSParameterSpec(\n                 \"SHA-256\", \"MGF1\",\n                 MGF1ParameterSpec.SHA256,\n                 32, PSSParameterSpec.TRAILER_FIELD_BC);\n-        final static PSSParameterSpec PSS_384_SPEC = new PSSParameterSpec(\n+        static final PSSParameterSpec PSS_384_SPEC = new PSSParameterSpec(\n                 \"SHA-384\", \"MGF1\",\n                 MGF1ParameterSpec.SHA384,\n                 48, PSSParameterSpec.TRAILER_FIELD_BC);\n-        final static PSSParameterSpec PSS_512_SPEC = new PSSParameterSpec(\n+        static final PSSParameterSpec PSS_512_SPEC = new PSSParameterSpec(\n                 \"SHA-512\", \"MGF1\",\n                 MGF1ParameterSpec.SHA512,\n                 64, PSSParameterSpec.TRAILER_FIELD_BC);"
  }
]
