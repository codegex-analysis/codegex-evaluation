[
  {
    "sha": "12857b35cd598fe0e69afd61271b5062d268b350",
    "filename": "src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template",
    "status": "modified",
    "additions": 46,
    "deletions": 11,
    "changes": 57,
    "blob_url": "https://github.com/openjdk/jdk/blob/3127ee0d34ecc6365ed3c87592320d4f2c412272/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template",
    "raw_url": "https://github.com/openjdk/jdk/raw/3127ee0d34ecc6365ed3c87592320d4f2c412272/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template?ref=3127ee0d34ecc6365ed3c87592320d4f2c412272",
    "patch": "@@ -198,19 +198,30 @@ class Direct$Type$Buffer$RW$$BO$\n     // For duplicates and slices\n     //\n     Direct$Type$Buffer$RW$$BO$(DirectBuffer db,         // package-private\n-                               int mark, int pos, int lim, int cap,\n-                               int off, MemorySegmentProxy segment)\n+                               int mark, int pos, int lim, int cap, int off,\n+#if[byte]\n+                               FileDescriptor fd, boolean isSync,\n+#end[byte]\n+                               MemorySegmentProxy segment)\n     {\n #if[rw]\n-        super(mark, pos, lim, cap, segment);\n+        super(mark, pos, lim, cap,\n+#if[byte]\n+              fd, isSync,\n+#end[byte]\n+              segment);\n         address = ((Buffer)db).address + off;\n #if[byte]\n         cleaner = null;\n #end[byte]\n         Object attachment = db.attachment();\n         att = (attachment == null ? db : attachment);\n #else[rw]\n-        super(db, mark, pos, lim, cap, off, segment);\n+        super(db, mark, pos, lim, cap, off,\n+#if[byte]\n+              fd, isSync,\n+#end[byte]\n+              segment);\n         this.isReadOnly = true;\n #end[rw]\n     }\n@@ -220,34 +231,53 @@ class Direct$Type$Buffer$RW$$BO$\n         return null;\n     }\n \n-    public $Type$Buffer slice() {\n+    public {#if[byte]?Mapped$Type$Buffer:$Type$Buffer} slice() {\n         int pos = this.position();\n         int lim = this.limit();\n         int rem = (pos <= lim ? lim - pos : 0);\n         int off = (pos << $LG_BYTES_PER_VALUE$);\n         assert (off >= 0);\n-        return new Direct$Type$Buffer$RW$$BO$(this, -1, 0, rem, rem, off, segment);\n+        return new Direct$Type$Buffer$RW$$BO$(this,\n+                                              -1,\n+                                              0,\n+                                              rem, \n+                                              rem,\n+                                              off,\n+#if[byte]\n+                                              fileDescriptor(),\n+                                              isSync(),\n+#end[byte]\n+                                              segment);\n     }\n \n     @Override\n-    public $Type$Buffer slice(int index, int length) {\n+    public {#if[byte]?Mapped$Type$Buffer:$Type$Buffer} slice(int index, int length) {\n         Objects.checkFromIndexSize(index, length, limit());\n         return new Direct$Type$Buffer$RW$$BO$(this,\n                                               -1,\n                                               0,\n                                               length,\n                                               length,\n                                               index << $LG_BYTES_PER_VALUE$,\n+#if[byte]\n+                                              fileDescriptor(),\n+                                              isSync(),\n+#end[byte]\n                                               segment);\n     }\n \n-    public $Type$Buffer duplicate() {\n+    public {#if[byte]?Mapped$Type$Buffer:$Type$Buffer} duplicate() {\n         return new Direct$Type$Buffer$RW$$BO$(this,\n                                               this.markValue(),\n                                               this.position(),\n                                               this.limit(),\n                                               this.capacity(),\n-                                              0, segment);\n+                                              0,\n+#if[byte]\n+                                              fileDescriptor(),\n+                                              isSync(),\n+#end[byte]\n+                                              segment);\n     }\n \n     public $Type$Buffer asReadOnlyBuffer() {\n@@ -257,7 +287,12 @@ class Direct$Type$Buffer$RW$$BO$\n                                            this.position(),\n                                            this.limit(),\n                                            this.capacity(),\n-                                           0, segment);\n+                                           0,\n+#if[byte]\n+                                           fileDescriptor(),\n+                                           isSync(),\n+#end[byte]\n+                                           segment);\n #else[rw]\n         return duplicate();\n #end[rw]\n@@ -506,7 +541,7 @@ class Direct$Type$Buffer$RW$$BO$\n #end[rw]\n     }\n \n-    public $Type$Buffer compact() {\n+    public {#if[byte]?Mapped$Type$Buffer:$Type$Buffer} compact() {\n #if[rw]\n         int pos = position();\n         int lim = limit();"
  },
  {
    "sha": "54fb6c869e0503606b21efd23139c8f60c7b090d",
    "filename": "src/java.base/share/classes/java/nio/MappedByteBuffer.java",
    "status": "modified",
    "additions": 52,
    "deletions": 2,
    "changes": 54,
    "blob_url": "https://github.com/openjdk/jdk/blob/3127ee0d34ecc6365ed3c87592320d4f2c412272/src/java.base/share/classes/java/nio/MappedByteBuffer.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/3127ee0d34ecc6365ed3c87592320d4f2c412272/src/java.base/share/classes/java/nio/MappedByteBuffer.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/nio/MappedByteBuffer.java?ref=3127ee0d34ecc6365ed3c87592320d4f2c412272",
    "patch": "@@ -152,10 +152,20 @@ public void unmap() {\n      * @return true if the file was mapped using one of the sync map\n      * modes, otherwise false.\n      */\n-    private boolean isSync() {\n+    final boolean isSync() { // package-private\n         return isSync;\n     }\n \n+    /**\n+     * Returns the {@code FileDescriptor} associated with this\n+     * {@code MappedByteBuffer}.\n+     *\n+     * @return the buffer's file descriptor; may be {@code null}\n+     */\n+    final FileDescriptor fileDescriptor() { // package-private\n+        return fd;\n+    }\n+\n     /**\n      * Tells whether or not this buffer's content is resident in physical\n      * memory.\n@@ -205,7 +215,10 @@ public final MappedByteBuffer load() {\n \n     /**\n      * Forces any changes made to this buffer's content to be written to the\n-     * storage device containing the mapped file.\n+     * storage device containing the mapped file.  The region starts at index\n+     * zero in this buffer and is {@code capacity()} bytes.  An invocation of\n+     * this method behaves in exactly the same way as the invocation\n+     * {@link force(int,int) force(0,capacity())}.\n      *\n      * <p> If the file mapped into this buffer resides on a local storage\n      * device then when this method returns it is guaranteed that all changes\n@@ -362,4 +375,41 @@ public final MappedByteBuffer rewind() {\n         super.rewind();\n         return this;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p> Reading bytes into physical memory by invoking {@code load()} on the\n+     * returned buffer, or writing bytes to the storage device by invoking\n+     * {@code force()} on the returned buffer, will only act on the sub-range\n+     * of this buffer that the returned buffer represents, namely\n+     * {@code [position(),limit())}.\n+     */\n+    @Override\n+    public abstract MappedByteBuffer slice();\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p> Reading bytes into physical memory by invoking {@code load()} on the\n+     * returned buffer, or writing bytes to the storage device by invoking\n+     * {@code force()} on the returned buffer, will only act on the sub-range\n+     * of this buffer that the returned buffer represents, namely\n+     * {@code [index,index+length)}, where {@code index} and {@code length} are\n+     * assumed to satisfy the preconditions.\n+     */\n+    @Override\n+    public abstract MappedByteBuffer slice(int index, int length);\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract MappedByteBuffer duplicate();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract MappedByteBuffer compact();\n }"
  },
  {
    "sha": "83727f80968598680f44cf92a63240dad7dd053e",
    "filename": "test/jdk/java/nio/MappedByteBuffer/ForceViews.java",
    "status": "added",
    "additions": 116,
    "deletions": 0,
    "changes": 116,
    "blob_url": "https://github.com/openjdk/jdk/blob/3127ee0d34ecc6365ed3c87592320d4f2c412272/test/jdk/java/nio/MappedByteBuffer/ForceViews.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/3127ee0d34ecc6365ed3c87592320d4f2c412272/test/jdk/java/nio/MappedByteBuffer/ForceViews.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/test/jdk/java/nio/MappedByteBuffer/ForceViews.java?ref=3127ee0d34ecc6365ed3c87592320d4f2c412272",
    "patch": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+/*\n+ * @test\n+ * @bug 4833719\n+ * @summary Verify MappedByteBuffer force on compact, duplicate, and slice views\n+ * @run testng ForceViews\n+ */\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.ReadOnlyBufferException;\n+import java.nio.channels.FileChannel;\n+import static java.nio.channels.FileChannel.MapMode.*;\n+import java.nio.file.Path;\n+import static java.nio.file.StandardOpenOption.*;\n+import java.util.function.BiFunction;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+public class ForceViews {\n+\n+    static record Segment(int position, int length) {}\n+\n+    private FileChannel fc;\n+\n+    @BeforeTest(alwaysRun=true)\n+    public void openChannel() throws IOException {\n+        Path file = Path.of(System.getProperty(\"test.src\", \".\"), \"junk\");\n+        fc = FileChannel.open(file, CREATE_NEW, READ, WRITE, DELETE_ON_CLOSE);\n+        ByteBuffer buf = ByteBuffer.wrap(new byte[1024]);\n+        fc.write(buf);\n+        fc.position(0);\n+    }\n+\n+    @AfterTest(alwaysRun=true)\n+    public void closeChannel() throws IOException {\n+        fc.close();\n+    }\n+\n+    @DataProvider\n+    public Object[][] provider() throws IOException {\n+        BiFunction<MappedByteBuffer,Segment,MappedByteBuffer> absSlice =\n+            (m, s) -> { return m.slice(s.position, s.length); };\n+        BiFunction<MappedByteBuffer,Segment,MappedByteBuffer> relSlice =\n+            (m, s) -> { m.position(s.position); m.limit(s.position + s.length);\n+                        return m.slice(); };\n+        BiFunction<MappedByteBuffer,Segment,MappedByteBuffer> duplicate=\n+            (m, s) -> { return m.duplicate(); };\n+        BiFunction<MappedByteBuffer,Segment,MappedByteBuffer> compact =\n+            (m, s) -> { return m.compact(); };\n+\n+        Object[][] result = new Object[][] {\n+            {\"Absolute slice\", fc, 256, 512, 128, 128, 32, 32, absSlice},\n+            {\"Relative slice\", fc, 256, 512, 0, 128, 32, 32, relSlice},\n+            {\"Duplicate\", fc, 256, 512, 0, 256, 32, 32, duplicate},\n+            {\"Compact\", fc, 256, 512, 0, 256, 32, 32, compact}\n+        };\n+\n+        return result;\n+    }\n+\n+    @Test(dataProvider = \"provider\")\n+    public void test(String tst, FileChannel fc, int mapPosition, int mapLength,\n+        int sliceIndex, int sliceLength, int regionOffset, int regionLength,\n+        BiFunction<MappedByteBuffer,Segment,MappedByteBuffer> f)\n+        throws Exception {\n+        MappedByteBuffer mbb = fc.map(READ_WRITE, mapPosition, mapLength);\n+        mbb = f.apply(mbb, new Segment(sliceIndex, sliceLength));\n+        for (int i = regionOffset; i < regionOffset + regionLength; i++) {\n+            mbb.put(i, (byte)i);\n+        }\n+        mbb.force(regionOffset, regionOffset + regionLength);\n+\n+        int fcPos = mapPosition + sliceIndex + regionOffset;\n+        int mbbPos = regionOffset;\n+        int length = regionLength;\n+\n+        ByteBuffer buf = ByteBuffer.allocate(length);\n+        fc.position(fcPos);\n+        fc.read(buf);\n+        for (int i = 0; i < length; i++) {\n+            int fcVal = buf.get(i);\n+            int mbbVal = mbb.get(mbbPos + i);\n+            int val = regionOffset + i;\n+            Assert.assertTrue(fcVal == val && mbbVal == val,\n+                String.format(\"%s: i %d, fcVal %d, mbbVal %d, val %d\",\n+                    tst, i, fcVal, mbbVal, val));\n+        }\n+    }\n+}"
  }
]
