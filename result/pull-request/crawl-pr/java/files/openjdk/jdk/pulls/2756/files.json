[
  {
    "sha": "c8a2d14ccac07ccbdfe3b22b429e15af0947a138",
    "filename": "src/java.desktop/windows/classes/sun/awt/windows/WPathGraphics.java",
    "status": "modified",
    "additions": 14,
    "deletions": 1,
    "changes": 15,
    "blob_url": "https://github.com/openjdk/jdk/blob/8105885ff50d4de6968fc806ce64c8810d91af43/src/java.desktop/windows/classes/sun/awt/windows/WPathGraphics.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/8105885ff50d4de6968fc806ce64c8810d91af43/src/java.desktop/windows/classes/sun/awt/windows/WPathGraphics.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.desktop/windows/classes/sun/awt/windows/WPathGraphics.java?ref=8105885ff50d4de6968fc806ce64c8810d91af43",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 1998, 2014, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -85,6 +85,8 @@\n     private static final float MIN_DEVICE_LINEWIDTH = 1.2f;\n     private static final float MAX_THINLINE_INCHES = 0.014f;\n \n+    private static final float precisionScale = 1000.0f;\n+\n     /* Note that preferGDITextLayout implies useGDITextLayout.\n      * \"prefer\" is used to override cases where would otherwise\n      * choose not to use it. Note that non-layout factors may\n@@ -1719,6 +1721,11 @@ protected void deviceDrawLine(int xBegin, int yBegin, int xEnd, int yEnd,\n         }\n     }\n \n+    private void precisionScaleUp(float[] values, int size) {\n+        for (int i = 0; i < size; i++) {\n+            values[i] = values[i] * precisionScale;\n+        }\n+    }\n \n     /**\n      * Given a Java2D {@code PathIterator} instance,\n@@ -1743,23 +1750,27 @@ private void convertToWPath(PathIterator pathIter) {\n         }\n         wPrinterJob.setPolyFillMode(polyFillRule);\n \n+        wPrinterJob.scaleTransform(1.0f / precisionScale);\n         wPrinterJob.beginPath();\n \n         while (pathIter.isDone() == false) {\n             segmentType = pathIter.currentSegment(segment);\n \n             switch (segmentType) {\n              case PathIterator.SEG_MOVETO:\n+                precisionScaleUp(segment, 2);\n                 wPrinterJob.moveTo(segment[0], segment[1]);\n                 break;\n \n              case PathIterator.SEG_LINETO:\n+                precisionScaleUp(segment, 2);\n                 wPrinterJob.lineTo(segment[0], segment[1]);\n                 break;\n \n             /* Convert the quad path to a bezier.\n              */\n              case PathIterator.SEG_QUADTO:\n+                precisionScaleUp(segment, 4);\n                 int lastX = wPrinterJob.getPenX();\n                 int lastY = wPrinterJob.getPenY();\n                 float c1x = lastX + (segment[0] - lastX) * 2 / 3;\n@@ -1772,6 +1783,7 @@ private void convertToWPath(PathIterator pathIter) {\n                 break;\n \n              case PathIterator.SEG_CUBICTO:\n+                precisionScaleUp(segment, 6);\n                 wPrinterJob.polyBezierTo(segment[0], segment[1],\n                                          segment[2], segment[3],\n                                          segment[4], segment[5]);\n@@ -1787,6 +1799,7 @@ private void convertToWPath(PathIterator pathIter) {\n         }\n \n         wPrinterJob.endPath();\n+        wPrinterJob.restoreTransform();\n \n     }\n "
  },
  {
    "sha": "6f4ad076a525abe0011b73ad0e6ab5d15a583ccf",
    "filename": "src/java.desktop/windows/classes/sun/awt/windows/WPrinterJob.java",
    "status": "modified",
    "additions": 86,
    "deletions": 1,
    "changes": 87,
    "blob_url": "https://github.com/openjdk/jdk/blob/8105885ff50d4de6968fc806ce64c8810d91af43/src/java.desktop/windows/classes/sun/awt/windows/WPrinterJob.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/8105885ff50d4de6968fc806ce64c8810d91af43/src/java.desktop/windows/classes/sun/awt/windows/WPrinterJob.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.desktop/windows/classes/sun/awt/windows/WPrinterJob.java?ref=8105885ff50d4de6968fc806ce64c8810d91af43",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -362,6 +362,9 @@ public void dispose() {\n \n     private java.awt.peer.ComponentPeer dialogOwnerPeer = null;\n \n+    private int graphicsMode;\n+    private double[] worldTransform = new double[6];\n+\n  /* Static Initializations */\n \n     static {\n@@ -960,6 +963,17 @@ protected void endPath() {\n         endPath(getPrintDC());\n     }\n \n+    protected void scaleTransform(float scale) {\n+        graphicsMode = setAdvancedGraphicsMode();\n+        getWorldTransform(worldTransform);\n+        scale(scale, scale);\n+    }\n+\n+    protected void restoreTransform() {\n+        setWorldTransform(worldTransform);\n+        setGraphicsMode(graphicsMode);\n+    }\n+\n     protected void closeFigure() {\n         closeFigure(getPrintDC());\n     }\n@@ -995,6 +1009,44 @@ protected void setPolyFillMode(int fillRule) {\n         setPolyFillMode(getPrintDC(), fillRule);\n     }\n \n+    /**\n+     * Set the GDI graphics mode to {@code GM_ADVANCED}.\n+     */\n+    private int setAdvancedGraphicsMode() {\n+        return setAdvancedGraphicsMode(getPrintDC());\n+    }\n+\n+    /**\n+     * Set the GDI graphics mode.\n+     * The {@code mode} should\n+     * be one of the following Windows constants:\n+     * {@code GM_COMPATIBLE} or {@code GM_ADVANCED}.\n+     */\n+    private void setGraphicsMode(int mode) {\n+        setGraphicsMode(getPrintDC(), mode);\n+    }\n+\n+    /**\n+     * Scale the GDI World Transform.\n+     */\n+    private void scale(double scaleX, double scaleY) {\n+        scale(getPrintDC(), scaleX, scaleY);\n+    }\n+\n+    /**\n+     * Get the GDI World Transform.\n+     */\n+    private void getWorldTransform(double[] transform) {\n+        getWorldTransform(getPrintDC(), transform);\n+    }\n+\n+    /**\n+     * Set the GDI World Transform.\n+     */\n+    private void setWorldTransform(double[] transform) {\n+        setWorldTransform(getPrintDC(), transform);\n+    }\n+\n     /*\n      * Create a Window's solid brush for the color specified\n      * by {@code (red, green, blue)}. Once the brush\n@@ -1470,6 +1522,39 @@ protected native void polyBezierTo(long printDC,\n      */\n     protected native void setPolyFillMode(long printDC, int fillRule);\n \n+    /**\n+     * Set the GDI graphics mode to {@code GM_ADVANCED}\n+     * into the device context {@code printDC}.\n+     */\n+    protected native int setAdvancedGraphicsMode(long printDC);\n+\n+    /**\n+     * Set the GDI graphics {@code mode}\n+     * into the device context {@code printDC}.\n+     * The {@code mode} should\n+     * be one of the following Windows constants:\n+     * {@code GM_COMPATIBLE} or {@code GM_ADVANCED}.\n+     */\n+    protected native void setGraphicsMode(long printDC, int mode);\n+\n+    /**\n+     * Scale the GDI World Transform\n+     * of the device context {@code printDC}.\n+     */\n+    protected native void scale(long printDC, double scaleX, double scaleY);\n+\n+    /**\n+     * Get the GDI World Transform\n+     * from the device context {@code printDC}.\n+     */\n+    protected native void getWorldTransform(long printDC, double[] transform);\n+\n+    /**\n+     * Set the GDI World Transform\n+     * into the device context {@code printDC}.\n+     */\n+    protected native void setWorldTransform(long printDC, double[] transform);\n+\n     /**\n      * Create a Window's solid brush for the color specified\n      * by {@code (red, green, blue)}. Once the brush"
  },
  {
    "sha": "ffba711f3da5b6ef5965e1d099c5b79b053b2d31",
    "filename": "src/java.desktop/windows/native/libawt/windows/awt_PrintJob.cpp",
    "status": "modified",
    "additions": 112,
    "deletions": 1,
    "changes": 113,
    "blob_url": "https://github.com/openjdk/jdk/blob/8105885ff50d4de6968fc806ce64c8810d91af43/src/java.desktop/windows/native/libawt/windows/awt_PrintJob.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/8105885ff50d4de6968fc806ce64c8810d91af43/src/java.desktop/windows/native/libawt/windows/awt_PrintJob.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.desktop/windows/native/libawt/windows/awt_PrintJob.cpp?ref=8105885ff50d4de6968fc806ce64c8810d91af43",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 1996, 2016, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -1932,6 +1932,117 @@ JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_setPolyFillMode\n     CATCH_BAD_ALLOC;\n }\n \n+/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    setAdvancedGraphicsMode\n+ * Signature: (J)I\n+ */\n+JNIEXPORT jint JNICALL Java_sun_awt_windows_WPrinterJob_setAdvancedGraphicsMode\n+(JNIEnv *env, jobject self, jlong printDC) {\n+    TRY;\n+\n+    int oldGraphicsMode = ::SetGraphicsMode((HDC)printDC, GM_ADVANCED);\n+    DASSERT(oldGraphicsMode != 0);\n+    return (jint) oldGraphicsMode;\n+\n+    CATCH_BAD_ALLOC_RET(0);\n+}\n+\n+/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    setGraphicsMode\n+ * Signature: (JI)V\n+ */\n+JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_setGraphicsMode\n+(JNIEnv *env, jobject self, jlong printDC, jint mode) {\n+    TRY;\n+\n+    int oldGraphicsMode = ::SetGraphicsMode((HDC)printDC, mode);\n+    DASSERT(oldGraphicsMode != 0);\n+\n+    CATCH_BAD_ALLOC;\n+}\n+\n+/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    scale\n+ * Signature: (JDD)V\n+ */\n+JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_scale\n+(JNIEnv *env, jobject self, jlong printDC, jdouble scaleX, jdouble scaleY) {\n+    TRY;\n+\n+    XFORM xForm;\n+\n+    xForm.eM11 = (FLOAT) scaleX;\n+    xForm.eM12 = (FLOAT) 0;\n+    xForm.eM21 = (FLOAT) 0;\n+    xForm.eM22 = (FLOAT) scaleY;\n+    xForm.eDx  = (FLOAT) 0;\n+    xForm.eDy  = (FLOAT) 0;\n+\n+    BOOL result = ::ModifyWorldTransform((HDC)printDC, &xForm, MWT_RIGHTMULTIPLY);\n+    DASSERT(result);\n+\n+    CATCH_BAD_ALLOC;\n+}\n+\n+/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    getWorldTransform\n+ * Signature: (J[D)V\n+ */\n+JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_getWorldTransform\n+(JNIEnv* env, jobject self, jlong printDC, jdoubleArray transform) {\n+    TRY;\n+\n+    double elems[6];\n+    XFORM xForm;\n+\n+    BOOL result = ::GetWorldTransform((HDC)printDC, &xForm);\n+    DASSERT(result);\n+\n+    elems[0] = (double) xForm.eM11;\n+    elems[1] = (double) xForm.eM12;\n+    elems[2] = (double) xForm.eM21;\n+    elems[3] = (double) xForm.eM22;\n+    elems[4] = (double) xForm.eDx;\n+    elems[5] = (double) xForm.eDy;\n+\n+    env->SetDoubleArrayRegion(transform, 0, 6, elems);\n+\n+    CATCH_BAD_ALLOC;\n+}\n+\n+/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    setWorldTransform\n+ * Signature: (J[D)V\n+ */\n+JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_setWorldTransform\n+(JNIEnv* env, jobject self, jlong printDC, jdoubleArray transform) {\n+    TRY;\n+\n+    double *elems;\n+    XFORM xForm;\n+\n+    elems = env->GetDoubleArrayElements(transform, 0);\n+\n+    xForm.eM11 = (FLOAT) elems[0];\n+    xForm.eM12 = (FLOAT) elems[1];\n+    xForm.eM21 = (FLOAT) elems[2];\n+    xForm.eM22 = (FLOAT) elems[3];\n+    xForm.eDx  = (FLOAT) elems[4];\n+    xForm.eDy  = (FLOAT) elems[5];\n+\n+    env->ReleaseDoubleArrayElements(transform, elems, 0);\n+\n+    BOOL result = ::SetWorldTransform((HDC)printDC, &xForm);\n+    DASSERT(result);\n+\n+    CATCH_BAD_ALLOC;\n+}\n+\n /*\n  * Class:     sun_awt_windows_WPrinterJob\n  * Method:    selectSolidBrush"
  },
  {
    "sha": "3b90d1e2068f3a972688365d51ab0f42702f9622",
    "filename": "test/jdk/java/awt/print/PathPrecisionScaleFactor/PathPrecisionScaleFactorShapeTest.java",
    "status": "added",
    "additions": 265,
    "deletions": 0,
    "changes": 265,
    "blob_url": "https://github.com/openjdk/jdk/blob/8105885ff50d4de6968fc806ce64c8810d91af43/test/jdk/java/awt/print/PathPrecisionScaleFactor/PathPrecisionScaleFactorShapeTest.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/8105885ff50d4de6968fc806ce64c8810d91af43/test/jdk/java/awt/print/PathPrecisionScaleFactor/PathPrecisionScaleFactorShapeTest.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/test/jdk/java/awt/print/PathPrecisionScaleFactor/PathPrecisionScaleFactorShapeTest.java?ref=8105885ff50d4de6968fc806ce64c8810d91af43",
    "patch": "@@ -0,0 +1,265 @@\n+/*\n+ * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+/**\n+ * @test\n+ * @bug 8262470\n+ * @requires (os.family == \"windows\")\n+ * @summary Check thay shapes are properly painted with the precision scale factor\n+ * @run main/othervm/manual PathPrecisionScaleFactorShapeTest\n+ */\n+\n+import javax.print.PrintServiceLookup;\n+import javax.swing.*;\n+import java.awt.*;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Line2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.geom.QuadCurve2D;\n+import java.awt.geom.CubicCurve2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+public class PathPrecisionScaleFactorShapeTest {\n+\n+    private static final String DESCRIPTION =\n+            \" 1. Setup 'Microsoft Print to PDF' printer on Windows.\\n\" +\n+                    \" 2. Press Print button to print shapes with labels to PDF.\\n\" +\n+                    \" 3. Choose 'Microsoft Print to PDF' on the print dialog and press OK\\n\" +\n+                    \" 3. Open the PDF file and check that following shapes with labels are printed:\\n\" +\n+                    \"    Line\\n\" +\n+                    \"    Line2D\\n\" +\n+                    \"    QuadCurve2D\\n\" +\n+                    \"    CubicCurve2D\\n\" +\n+                    \" 4. If so, press PASS button, otherwise press FAIL button.\\n\";\n+\n+    private static final CountDownLatch testEndedSignal = new CountDownLatch(1);\n+    private static final int testTimeout = 300000;\n+    private static volatile String testFailureMsg;\n+    private static volatile boolean testPassed;\n+    private static volatile boolean testFinished;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        SwingUtilities.invokeLater(() -> createAndShowTestDialog());\n+\n+        try {\n+            if (!testEndedSignal.await(testTimeout, TimeUnit.MILLISECONDS)) {\n+                throw new RuntimeException(String.format(\n+                        \"Test timeout '%d ms' elapsed.\", testTimeout));\n+            }\n+            if (!testPassed) {\n+                String failureMsg = testFailureMsg;\n+                if ((failureMsg != null) && (!failureMsg.trim().isEmpty())) {\n+                    throw new RuntimeException(failureMsg);\n+                } else {\n+                    throw new RuntimeException(\"Test failed.\");\n+                }\n+            }\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(ie);\n+        } finally {\n+            testFinished = true;\n+        }\n+    }\n+\n+    private static void pass() {\n+        testPassed = true;\n+        testEndedSignal.countDown();\n+    }\n+\n+    private static void fail(String failureMsg) {\n+        testFailureMsg = failureMsg;\n+        testPassed = false;\n+        testEndedSignal.countDown();\n+    }\n+\n+    private static String convertMillisToTimeStr(int millis) {\n+        if (millis < 0) {\n+            return \"00:00:00\";\n+        }\n+        int hours = millis / 3600000;\n+        int minutes = (millis - hours * 3600000) / 60000;\n+        int seconds = (millis - hours * 3600000 - minutes * 60000) / 1000;\n+        return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n+    }\n+\n+    private static void createAndShowTestDialog() {\n+\n+        final JDialog dialog = new JDialog();\n+        dialog.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n+        dialog.addWindowListener(new WindowAdapter() {\n+            @Override\n+            public void windowClosing(WindowEvent e) {\n+                dialog.dispose();\n+                fail(\"Main dialog was closed.\");\n+            }\n+        });\n+\n+        final JLabel testTimeoutLabel = new JLabel(String.format(\n+                \"Test timeout: %s\", convertMillisToTimeStr(testTimeout)));\n+        final long startTime = System.currentTimeMillis();\n+        final Timer timer = new Timer(0, null);\n+        timer.setDelay(1000);\n+        timer.addActionListener((e) -> {\n+            int leftTime = testTimeout - (int) (System.currentTimeMillis() - startTime);\n+            if ((leftTime < 0) || testFinished) {\n+                timer.stop();\n+                dialog.dispose();\n+            }\n+            testTimeoutLabel.setText(String.format(\n+                    \"Test timeout: %s\", convertMillisToTimeStr(leftTime)));\n+        });\n+        timer.start();\n+\n+        JTextArea textArea = new JTextArea(DESCRIPTION);\n+        textArea.setEditable(false);\n+\n+        final JButton testButton = new JButton(\"Print\");\n+        final JButton passButton = new JButton(\"PASS\");\n+        final JButton failButton = new JButton(\"FAIL\");\n+        testButton.addActionListener((e) -> {\n+            testButton.setEnabled(false);\n+            new Thread(() -> {\n+                try {\n+                    doTest();\n+\n+                    SwingUtilities.invokeLater(() -> {\n+                        passButton.setEnabled(true);\n+                        failButton.setEnabled(true);\n+                    });\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                    dialog.dispose();\n+                    fail(\"Exception occurred in a thread executing the test.\");\n+                }\n+            }).start();\n+        });\n+        passButton.setEnabled(false);\n+        passButton.addActionListener((e) -> {\n+            dialog.dispose();\n+            pass();\n+        });\n+        failButton.setEnabled(false);\n+        failButton.addActionListener((e) -> {\n+            dialog.dispose();\n+            fail(\"TitledBorder label is cut off\");\n+        });\n+\n+        JPanel mainPanel = new JPanel(new BorderLayout());\n+        JPanel labelPanel = new JPanel(new FlowLayout());\n+        labelPanel.add(testTimeoutLabel);\n+        mainPanel.add(labelPanel, BorderLayout.NORTH);\n+        mainPanel.add(textArea, BorderLayout.CENTER);\n+        JPanel buttonPanel = new JPanel(new FlowLayout());\n+        buttonPanel.add(testButton);\n+        buttonPanel.add(passButton);\n+        buttonPanel.add(failButton);\n+        mainPanel.add(buttonPanel, BorderLayout.SOUTH);\n+        dialog.add(mainPanel);\n+\n+        dialog.pack();\n+        dialog.setVisible(true);\n+    }\n+\n+    private static void doTest() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                new PathPrecisionScaleFactorPrintable();\n+            } catch (PrinterException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    private static class PathPrecisionScaleFactorPrintable implements Printable {\n+\n+        PathPrecisionScaleFactorPrintable() throws PrinterException {\n+            PrinterJob job = PrinterJob.getPrinterJob();\n+            job.setPrintService(PrintServiceLookup.lookupDefaultPrintService());\n+            job.setPrintable(this);\n+\n+            if (job.printDialog()) {\n+                job.print();\n+            } else {\n+                throw new RuntimeException(\"Printing was canceled!\");\n+            }\n+        }\n+\n+        void paint(Graphics2D g) {\n+\n+            Rectangle clip = g.getClipBounds();\n+\n+            int x =  (int) clip.getX() + 10;\n+            int y = (int) clip.getY() + 20;\n+            int dy = ((int) clip.getHeight() - y) / 8;\n+\n+            int l = 80;\n+            int sx = x + l + 10;\n+\n+            g.drawLine(x, y, x + l, y);\n+            drawGlyphVector(g, sx, y, \"Line\");\n+\n+            y+= dy;\n+            g.draw(new Line2D.Float(x, y, x + l, y));\n+            drawGlyphVector(g, sx, y, \"Line2D\");\n+\n+            y+= dy;\n+            g.draw(new QuadCurve2D.Float(x, y, x + l / 2, y + l / 2, x + l, y));\n+            drawGlyphVector(g, sx, y, \"QuadCurve2D\");\n+\n+            y+= dy;\n+            g.draw(new CubicCurve2D.Float(x, y, x + l / 3, y + l / 3, x + 2 * l / 3, y - l / 3, x + l, y));\n+            drawGlyphVector(g, sx, y, \"CubicCurve2D\");\n+        }\n+\n+        private static void drawGlyphVector(Graphics2D g, int x, int y, String text) {\n+\n+            Font font = new Font(\"Times New Roman\", Font.PLAIN, 8);\n+            g.setFont(font);\n+            FontRenderContext frc = new FontRenderContext(new AffineTransform(), false, true);\n+\n+            GlyphVector gv = font.createGlyphVector(frc, text);\n+            g.fill(gv.getOutline(x, y));\n+        }\n+\n+        @Override\n+        public int print(Graphics graphics, PageFormat pageFormat, int index) {\n+            if (index == 0) {\n+                paint((Graphics2D) graphics);\n+                return PAGE_EXISTS;\n+            } else {\n+                return NO_SUCH_PAGE;\n+            }\n+        }\n+    }\n+}"
  },
  {
    "sha": "9b20ab4748a225f8090077a8092c61f0f60f9eb8",
    "filename": "test/jdk/java/awt/print/PathPrecisionScaleFactor/PathPrecisionScaleFactorTextTest.java",
    "status": "added",
    "additions": 254,
    "deletions": 0,
    "changes": 254,
    "blob_url": "https://github.com/openjdk/jdk/blob/8105885ff50d4de6968fc806ce64c8810d91af43/test/jdk/java/awt/print/PathPrecisionScaleFactor/PathPrecisionScaleFactorTextTest.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/8105885ff50d4de6968fc806ce64c8810d91af43/test/jdk/java/awt/print/PathPrecisionScaleFactor/PathPrecisionScaleFactorTextTest.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/test/jdk/java/awt/print/PathPrecisionScaleFactor/PathPrecisionScaleFactorTextTest.java?ref=8105885ff50d4de6968fc806ce64c8810d91af43",
    "patch": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+/**\n+ * @test\n+ * @bug 8262470\n+ * @requires (os.family == \"windows\")\n+ * @summary Check that a GlyphVector outline is printed with good quility on low dpi printers\n+ * @run main/othervm/manual PathPrecisionScaleFactorTextTest\n+ */\n+\n+import javax.print.PrintServiceLookup;\n+import javax.swing.*;\n+import java.awt.*;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+public class PathPrecisionScaleFactorTextTest {\n+\n+    private static final String DESCRIPTION =\n+            \" 1. Setup 'Microsoft Print to PDF' printer on Windows.\\n\" +\n+                    \" 2. Press Print button to print the text to PDF.\\n\" +\n+                    \" 3. Choose 'Microsoft Print to PDF' on the print dialog and press OK\\n\" +\n+                    \"    Two strings should be printed.\\n\" +\n+                    \"    The first line is printed using drawString() method\\n\" +\n+                    \"    and the second line is printed using filling glyph vector outline.\\n\" +\n+                    \" 3. Open the PDF file, zoom in the text and check that chars on the second line\\n\" +\n+                    \"    (especially 'a' and 's') are not distorted and have the similar quality\\n\" +\n+                    \"     as on the first line.\\n\" +\n+                    \" 4. If so, press PASS button, otherwise press FAIL button.\\n\";\n+\n+    private static final CountDownLatch testEndedSignal = new CountDownLatch(1);\n+    private static final int testTimeout = 300000;\n+    private static volatile String testFailureMsg;\n+    private static volatile boolean testPassed;\n+    private static volatile boolean testFinished;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        SwingUtilities.invokeLater(() -> createAndShowTestDialog());\n+\n+        try {\n+            if (!testEndedSignal.await(testTimeout, TimeUnit.MILLISECONDS)) {\n+                throw new RuntimeException(String.format(\n+                        \"Test timeout '%d ms' elapsed.\", testTimeout));\n+            }\n+            if (!testPassed) {\n+                String failureMsg = testFailureMsg;\n+                if ((failureMsg != null) && (!failureMsg.trim().isEmpty())) {\n+                    throw new RuntimeException(failureMsg);\n+                } else {\n+                    throw new RuntimeException(\"Test failed.\");\n+                }\n+            }\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(ie);\n+        } finally {\n+            testFinished = true;\n+        }\n+    }\n+\n+    private static void pass() {\n+        testPassed = true;\n+        testEndedSignal.countDown();\n+    }\n+\n+    private static void fail(String failureMsg) {\n+        testFailureMsg = failureMsg;\n+        testPassed = false;\n+        testEndedSignal.countDown();\n+    }\n+\n+    private static String convertMillisToTimeStr(int millis) {\n+        if (millis < 0) {\n+            return \"00:00:00\";\n+        }\n+        int hours = millis / 3600000;\n+        int minutes = (millis - hours * 3600000) / 60000;\n+        int seconds = (millis - hours * 3600000 - minutes * 60000) / 1000;\n+        return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n+    }\n+\n+    private static void createAndShowTestDialog() {\n+\n+        final JDialog dialog = new JDialog();\n+        dialog.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n+        dialog.addWindowListener(new WindowAdapter() {\n+            @Override\n+            public void windowClosing(WindowEvent e) {\n+                dialog.dispose();\n+                fail(\"Main dialog was closed.\");\n+            }\n+        });\n+\n+        final JLabel testTimeoutLabel = new JLabel(String.format(\n+                \"Test timeout: %s\", convertMillisToTimeStr(testTimeout)));\n+        final long startTime = System.currentTimeMillis();\n+        final Timer timer = new Timer(0, null);\n+        timer.setDelay(1000);\n+        timer.addActionListener((e) -> {\n+            int leftTime = testTimeout - (int) (System.currentTimeMillis() - startTime);\n+            if ((leftTime < 0) || testFinished) {\n+                timer.stop();\n+                dialog.dispose();\n+            }\n+            testTimeoutLabel.setText(String.format(\n+                    \"Test timeout: %s\", convertMillisToTimeStr(leftTime)));\n+        });\n+        timer.start();\n+\n+        JTextArea textArea = new JTextArea(DESCRIPTION);\n+        textArea.setEditable(false);\n+\n+        final JButton testButton = new JButton(\"Print\");\n+        final JButton passButton = new JButton(\"PASS\");\n+        final JButton failButton = new JButton(\"FAIL\");\n+        testButton.addActionListener((e) -> {\n+            testButton.setEnabled(false);\n+            new Thread(() -> {\n+                try {\n+                    doTest();\n+\n+                    SwingUtilities.invokeLater(() -> {\n+                        passButton.setEnabled(true);\n+                        failButton.setEnabled(true);\n+                    });\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                    dialog.dispose();\n+                    fail(\"Exception occurred in a thread executing the test.\");\n+                }\n+            }).start();\n+        });\n+        passButton.setEnabled(false);\n+        passButton.addActionListener((e) -> {\n+            dialog.dispose();\n+            pass();\n+        });\n+        failButton.setEnabled(false);\n+        failButton.addActionListener((e) -> {\n+            dialog.dispose();\n+            fail(\"TitledBorder label is cut off\");\n+        });\n+\n+        JPanel mainPanel = new JPanel(new BorderLayout());\n+        JPanel labelPanel = new JPanel(new FlowLayout());\n+        labelPanel.add(testTimeoutLabel);\n+        mainPanel.add(labelPanel, BorderLayout.NORTH);\n+        mainPanel.add(textArea, BorderLayout.CENTER);\n+        JPanel buttonPanel = new JPanel(new FlowLayout());\n+        buttonPanel.add(testButton);\n+        buttonPanel.add(passButton);\n+        buttonPanel.add(failButton);\n+        mainPanel.add(buttonPanel, BorderLayout.SOUTH);\n+        dialog.add(mainPanel);\n+\n+        dialog.pack();\n+        dialog.setVisible(true);\n+    }\n+\n+    private static void doTest() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                new PathPrecisionScaleFactorPrintable();\n+            } catch (PrinterException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    private static class PathPrecisionScaleFactorPrintable implements Printable {\n+\n+        PathPrecisionScaleFactorPrintable() throws PrinterException {\n+            PrinterJob job = PrinterJob.getPrinterJob();\n+            job.setPrintService(PrintServiceLookup.lookupDefaultPrintService());\n+            job.setPrintable(this);\n+\n+            if (job.printDialog()) {\n+                job.print();\n+            } else {\n+                throw new RuntimeException(\"Printing was canceled!\");\n+            }\n+        }\n+\n+        void paint(Graphics2D g) {\n+\n+            String text = \"abcdefghijklmnopqrstuvwxyz\";\n+            Font font = new Font(\"Times New Roman\", Font.PLAIN, 8);\n+            drawText(g, font, text);\n+        }\n+\n+        private static void drawText(Graphics2D g, Font font, String text) {\n+\n+            g.setFont(font);\n+            FontRenderContext frc = new FontRenderContext(new AffineTransform(), false, true);\n+\n+            Rectangle clip = g.getClipBounds();\n+            int cx = (int) clip.getCenterX();\n+            int cy = (int) clip.getCenterY();\n+\n+            FontMetrics metrics = g.getFontMetrics();\n+            int w = metrics.stringWidth(text);\n+            int h = metrics.getHeight();\n+\n+            int x = cx - w / 2;\n+            int y = cy - h / 2;\n+\n+            g.drawString(text + \" [draw string]\", x, y);\n+            GlyphVector gv = font.createGlyphVector(frc, text + \" [glyph vector]\");\n+            g.fill(gv.getOutline(x, y + h));\n+        }\n+\n+        @Override\n+        public int print(Graphics graphics, PageFormat pageFormat, int index) {\n+            if (index == 0) {\n+                paint((Graphics2D) graphics);\n+                return PAGE_EXISTS;\n+            } else {\n+                return NO_SUCH_PAGE;\n+            }\n+        }\n+    }\n+}"
  }
]
