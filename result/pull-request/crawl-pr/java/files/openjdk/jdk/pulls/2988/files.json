[
  {
    "sha": "cc4e56a9732528b1987c4b31875ebc9de2b3c002",
    "filename": "src/java.base/share/classes/java/util/DoubleSummaryStatistics.java",
    "status": "modified",
    "additions": 4,
    "deletions": 4,
    "changes": 8,
    "blob_url": "https://github.com/openjdk/jdk/blob/eb37e7ba6c240f614c8cb9903599fa00927f9a8d/src/java.base/share/classes/java/util/DoubleSummaryStatistics.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/eb37e7ba6c240f614c8cb9903599fa00927f9a8d/src/java.base/share/classes/java/util/DoubleSummaryStatistics.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/util/DoubleSummaryStatistics.java?ref=eb37e7ba6c240f614c8cb9903599fa00927f9a8d",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -66,7 +66,7 @@\n public class DoubleSummaryStatistics implements DoubleConsumer {\n     private long count;\n     private double sum;\n-    private double sumCompensation; // Low order bits of sum\n+    private double sumCompensation; // Negative low order bits of sum\n     private double simpleSum; // Used to compute right sum for non-finite inputs\n     private double min = Double.POSITIVE_INFINITY;\n     private double max = Double.NEGATIVE_INFINITY;\n@@ -156,7 +156,7 @@ public void combine(DoubleSummaryStatistics other) {\n         count += other.count;\n         simpleSum += other.simpleSum;\n         sumWithCompensation(other.sum);\n-        sumWithCompensation(other.sumCompensation);\n+        sumWithCompensation(-other.sumCompensation);\n         min = Math.min(min, other.min);\n         max = Math.max(max, other.max);\n     }\n@@ -241,7 +241,7 @@ public final long getCount() {\n      */\n     public final double getSum() {\n         // Better error bounds to add both terms as the final sum\n-        double tmp =  sum + sumCompensation;\n+        double tmp = sum - sumCompensation;\n         if (Double.isNaN(tmp) && Double.isInfinite(simpleSum))\n             // If the compensated sum is spuriously NaN from\n             // accumulating one or more same-signed infinite values,"
  },
  {
    "sha": "bb7d9c3e49405a85bf8550403fe2abd15c885671",
    "filename": "src/java.base/share/classes/java/util/stream/Collectors.java",
    "status": "modified",
    "additions": 10,
    "deletions": 10,
    "changes": 20,
    "blob_url": "https://github.com/openjdk/jdk/blob/eb37e7ba6c240f614c8cb9903599fa00927f9a8d/src/java.base/share/classes/java/util/stream/Collectors.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/eb37e7ba6c240f614c8cb9903599fa00927f9a8d/src/java.base/share/classes/java/util/stream/Collectors.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/util/stream/Collectors.java?ref=eb37e7ba6c240f614c8cb9903599fa00927f9a8d",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -722,7 +722,7 @@ private static IllegalStateException duplicateKeyException(\n         /*\n          * In the arrays allocated for the collect operation, index 0\n          * holds the high-order bits of the running sum, index 1 holds\n-         * the low-order bits of the sum computed via compensated\n+         * the (negative) low-order bits of the sum computed via compensated\n          * summation, and index 2 holds the simple sum used to compute\n          * the proper result if the stream contains infinite values of\n          * the same sign.\n@@ -734,7 +734,7 @@ private static IllegalStateException duplicateKeyException(\n                             a[2] += val;},\n                 (a, b) -> { sumWithCompensation(a, b[0]);\n                             a[2] += b[2];\n-                            return sumWithCompensation(a, b[1]); },\n+                            return sumWithCompensation(a, -b[1]); },\n                 a -> computeFinalSum(a),\n                 CH_NOID);\n     }\n@@ -743,9 +743,9 @@ private static IllegalStateException duplicateKeyException(\n      * Incorporate a new double value using Kahan summation /\n      * compensation summation.\n      *\n-     * High-order bits of the sum are in intermediateSum[0], low-order\n-     * bits of the sum are in intermediateSum[1], any additional\n-     * elements are application-specific.\n+     * High-order bits of the sum are in intermediateSum[0],\n+     * negative low-order bits of the sum are in intermediateSum[1],\n+     * any additional elements are application-specific.\n      *\n      * @param intermediateSum the high-order and low-order words of the intermediate sum\n      * @param value the name value to be included in the running sum\n@@ -766,7 +766,7 @@ private static IllegalStateException duplicateKeyException(\n      */\n     static double computeFinalSum(double[] summands) {\n         // Better error bounds to add both terms as the final sum\n-        double tmp = summands[0] + summands[1];\n+        double tmp = summands[0] - summands[1];\n         double simpleSum = summands[summands.length - 1];\n         if (Double.isNaN(tmp) && Double.isInfinite(simpleSum))\n             return simpleSum;\n@@ -840,13 +840,13 @@ static double computeFinalSum(double[] summands) {\n         /*\n          * In the arrays allocated for the collect operation, index 0\n          * holds the high-order bits of the running sum, index 1 holds\n-         * the low-order bits of the sum computed via compensated\n+         * the (negative) low-order bits of the sum computed via compensated\n          * summation, and index 2 holds the number of values seen.\n          */\n         return new CollectorImpl<>(\n                 () -> new double[4],\n-                (a, t) -> { double val = mapper.applyAsDouble(t); sumWithCompensation(a, val); a[2]++; a[3]+= val;},\n-                (a, b) -> { sumWithCompensation(a, b[0]); sumWithCompensation(a, b[1]); a[2] += b[2]; a[3] += b[3]; return a; },\n+                (a, t) -> { double val = mapper.applyAsDouble(t); sumWithCompensation(a, val); a[2]++; a[3] += val; },\n+                (a, b) -> { sumWithCompensation(a, b[0]); sumWithCompensation(a, -b[1]); a[2] += b[2]; a[3] += b[3]; return a; },\n                 a -> (a[2] == 0) ? 0.0d : (computeFinalSum(a) / a[2]),\n                 CH_NOID);\n     }"
  },
  {
    "sha": "a000992590cf8945ec51701d1347b1b035eee389",
    "filename": "src/java.base/share/classes/java/util/stream/DoublePipeline.java",
    "status": "modified",
    "additions": 10,
    "deletions": 10,
    "changes": 20,
    "blob_url": "https://github.com/openjdk/jdk/blob/eb37e7ba6c240f614c8cb9903599fa00927f9a8d/src/java.base/share/classes/java/util/stream/DoublePipeline.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/eb37e7ba6c240f614c8cb9903599fa00927f9a8d/src/java.base/share/classes/java/util/stream/DoublePipeline.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/java/util/stream/DoublePipeline.java?ref=eb37e7ba6c240f614c8cb9903599fa00927f9a8d",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -442,10 +442,10 @@ public final double sum() {\n         /*\n          * In the arrays allocated for the collect operation, index 0\n          * holds the high-order bits of the running sum, index 1 holds\n-         * the low-order bits of the sum computed via compensated\n-         * summation, and index 2 holds the simple sum used to compute\n-         * the proper result if the stream contains infinite values of\n-         * the same sign.\n+         * the (negative) low-order bits of the sum computed via\n+         * compensated summation, and index 2 holds the simple sum used\n+         * to compute the proper result if the stream contains infinite\n+         * values of the same sign.\n          */\n         double[] summation = collect(() -> new double[3],\n                                (ll, d) -> {\n@@ -454,7 +454,7 @@ public final double sum() {\n                                },\n                                (ll, rr) -> {\n                                    Collectors.sumWithCompensation(ll, rr[0]);\n-                                   Collectors.sumWithCompensation(ll, rr[1]);\n+                                   Collectors.sumWithCompensation(ll, -rr[1]);\n                                    ll[2] += rr[2];\n                                });\n \n@@ -485,9 +485,9 @@ public final OptionalDouble average() {\n         /*\n          * In the arrays allocated for the collect operation, index 0\n          * holds the high-order bits of the running sum, index 1 holds\n-         * the low-order bits of the sum computed via compensated\n-         * summation, index 2 holds the number of values seen, index 3\n-         * holds the simple sum.\n+         * the (negative) low-order bits of the sum computed via\n+         * compensated summation, index 2 holds the number of values\n+         * seen, index 3 holds the simple sum.\n          */\n         double[] avg = collect(() -> new double[4],\n                                (ll, d) -> {\n@@ -497,7 +497,7 @@ public final OptionalDouble average() {\n                                },\n                                (ll, rr) -> {\n                                    Collectors.sumWithCompensation(ll, rr[0]);\n-                                   Collectors.sumWithCompensation(ll, rr[1]);\n+                                   Collectors.sumWithCompensation(ll, -rr[1]);\n                                    ll[2] += rr[2];\n                                    ll[3] += rr[3];\n                                });"
  },
  {
    "sha": "987477f2390ddeaa8d06e6d1be9b2133f77199d4",
    "filename": "test/jdk/java/util/DoubleSummaryStatistics/NegativeCompensation.java",
    "status": "added",
    "additions": 66,
    "deletions": 0,
    "changes": 66,
    "blob_url": "https://github.com/openjdk/jdk/blob/eb37e7ba6c240f614c8cb9903599fa00927f9a8d/test/jdk/java/util/DoubleSummaryStatistics/NegativeCompensation.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/eb37e7ba6c240f614c8cb9903599fa00927f9a8d/test/jdk/java/util/DoubleSummaryStatistics/NegativeCompensation.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/test/jdk/java/util/DoubleSummaryStatistics/NegativeCompensation.java?ref=eb37e7ba6c240f614c8cb9903599fa00927f9a8d",
    "patch": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+/*\n+ * @test\n+ * @bug 8214761\n+ * @summary When combining two DoubleSummaryStatistics, the compensation\n+ *          has to be subtracted.\n+ */\n+\n+import java.util.DoubleSummaryStatistics;\n+\n+public class NegativeCompensation {\n+    static final double VAL = 1.000000001;\n+    static final int LOG_ITER = 21;\n+\n+    public static void main(String[] args) {\n+        DoubleSummaryStatistics stat0 = new DoubleSummaryStatistics();\n+        DoubleSummaryStatistics stat1 = new DoubleSummaryStatistics();\n+        DoubleSummaryStatistics stat2 = new DoubleSummaryStatistics();\n+\n+        stat1.accept(VAL);\n+        stat1.accept(VAL);\n+        stat2.accept(VAL);\n+        stat2.accept(VAL);\n+        stat2.accept(VAL);\n+\n+        for (int i = 0; i < LOG_ITER; ++i) {\n+            stat1.combine(stat2);\n+            stat2.combine(stat1);\n+        }\n+\n+        System.out.println(\"count: \" + stat2.getCount());\n+        for (long i = 0, iend = stat2.getCount(); i < iend; ++i) {\n+            stat0.accept(VAL);\n+        }\n+\n+        double absErr = Math.abs(stat0.getSum() - stat2.getSum());\n+        System.out.println(\"serial sum: \" + stat0.getSum());\n+        System.out.println(\"combined sum: \" + stat2.getSum());\n+        System.out.println(\"abs error: \" + absErr);\n+        if (absErr > 0.00000001) {\n+            throw new RuntimeException(\"Absolute error is too big: \" + absErr);\n+        }\n+    }\n+}"
  }
]
