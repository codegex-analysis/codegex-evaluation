[
  {
    "sha": "3cd6d162a27ef61f5c0c724d73d72ef9e6487793",
    "filename": "src/java.base/share/classes/sun/security/rsa/RSAKeyFactory.java",
    "status": "modified",
    "additions": 16,
    "deletions": 18,
    "changes": 34,
    "blob_url": "https://github.com/openjdk/jdk/blob/defbf46bf2145e02d1091f5a8b343a4e0dc4bba2/src/java.base/share/classes/sun/security/rsa/RSAKeyFactory.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/defbf46bf2145e02d1091f5a8b343a4e0dc4bba2/src/java.base/share/classes/sun/security/rsa/RSAKeyFactory.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/java.base/share/classes/sun/security/rsa/RSAKeyFactory.java?ref=defbf46bf2145e02d1091f5a8b343a4e0dc4bba2",
    "patch": "@@ -405,31 +405,29 @@ private PrivateKey generatePrivate(KeySpec keySpec)\n         } else if (key instanceof RSAPrivateKey) {\n             if (keySpec.isAssignableFrom(PKCS8_KEYSPEC_CLS)) {\n                 return keySpec.cast(new PKCS8EncodedKeySpec(key.getEncoded()));\n-            } else if (keySpec.isAssignableFrom(RSA_PRIVCRT_KEYSPEC_CLS)) {\n-                if (key instanceof RSAPrivateCrtKey) {\n-                    RSAPrivateCrtKey crtKey = (RSAPrivateCrtKey)key;\n-                    return keySpec.cast(new RSAPrivateCrtKeySpec(\n-                        crtKey.getModulus(),\n-                        crtKey.getPublicExponent(),\n-                        crtKey.getPrivateExponent(),\n-                        crtKey.getPrimeP(),\n-                        crtKey.getPrimeQ(),\n-                        crtKey.getPrimeExponentP(),\n-                        crtKey.getPrimeExponentQ(),\n-                        crtKey.getCrtCoefficient(),\n-                        crtKey.getParams()\n-                    ));\n-                } else {\n-                    throw new InvalidKeySpecException\n-                    (\"RSAPrivateCrtKeySpec can only be used with CRT keys\");\n-                }\n+            } else if (keySpec.isAssignableFrom(RSA_PRIVCRT_KEYSPEC_CLS) && key instanceof RSAPrivateCrtKey) {\n+                RSAPrivateCrtKey crtKey = (RSAPrivateCrtKey)key;\n+                return keySpec.cast(new RSAPrivateCrtKeySpec(\n+                    crtKey.getModulus(),\n+                    crtKey.getPublicExponent(),\n+                    crtKey.getPrivateExponent(),\n+                    crtKey.getPrimeP(),\n+                    crtKey.getPrimeQ(),\n+                    crtKey.getPrimeExponentP(),\n+                    crtKey.getPrimeExponentQ(),\n+                    crtKey.getCrtCoefficient(),\n+                    crtKey.getParams()\n+                ));\n             } else if (keySpec.isAssignableFrom(RSA_PRIV_KEYSPEC_CLS)) {\n                 RSAPrivateKey rsaKey = (RSAPrivateKey)key;\n                 return keySpec.cast(new RSAPrivateKeySpec(\n                     rsaKey.getModulus(),\n                     rsaKey.getPrivateExponent(),\n                     rsaKey.getParams()\n                 ));\n+            } else if (keySpec.isAssignableFrom(RSA_PRIVCRT_KEYSPEC_CLS)) {\n+                throw new InvalidKeySpecException\n+                        (\"RSAPrivateCrtKeySpec can only be used with CRT keys\");\n             } else {\n                 throw new InvalidKeySpecException\n                         (\"KeySpec must be RSAPrivate(Crt)KeySpec or \""
  },
  {
    "sha": "edcaecd7353008c8767b30232144266772238c65",
    "filename": "src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/P11RSAKeyFactory.java",
    "status": "modified",
    "additions": 41,
    "deletions": 29,
    "changes": 70,
    "blob_url": "https://github.com/openjdk/jdk/blob/defbf46bf2145e02d1091f5a8b343a4e0dc4bba2/src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/P11RSAKeyFactory.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/defbf46bf2145e02d1091f5a8b343a4e0dc4bba2/src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/P11RSAKeyFactory.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/P11RSAKeyFactory.java?ref=defbf46bf2145e02d1091f5a8b343a4e0dc4bba2",
    "patch": "@@ -277,37 +277,49 @@ private PrivateKey generatePrivate(BigInteger n, BigInteger e,\n \n     <T extends KeySpec> T implGetPrivateKeySpec(P11Key key, Class<T> keySpec,\n             Session[] session) throws PKCS11Exception, InvalidKeySpecException {\n-        if (keySpec.isAssignableFrom(RSAPrivateCrtKeySpec.class)) {\n-            session[0] = token.getObjSession();\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-                new CK_ATTRIBUTE(CKA_PRIME_1),\n-                new CK_ATTRIBUTE(CKA_PRIME_2),\n-                new CK_ATTRIBUTE(CKA_EXPONENT_1),\n-                new CK_ATTRIBUTE(CKA_EXPONENT_2),\n-                new CK_ATTRIBUTE(CKA_COEFFICIENT),\n-            };\n-            long keyID = key.getKeyID();\n-            try {\n-                token.p11.C_GetAttributeValue(session[0].id(), keyID, attributes);\n-            } finally {\n-                key.releaseKeyID();\n+        // If a PKCS11Exception is thrown, then that implies that we cannot retrieve some attributes\n+        // First, if we can retrieve the CRT parameters, we do so for better efficiency\n+        try {\n+            if (keySpec.isAssignableFrom(RSAPrivateCrtKeySpec.class)) {\n+                session[0] = token.getObjSession();\n+                CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_MODULUS),\n+                    new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n+                    new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n+                    new CK_ATTRIBUTE(CKA_PRIME_1),\n+                    new CK_ATTRIBUTE(CKA_PRIME_2),\n+                    new CK_ATTRIBUTE(CKA_EXPONENT_1),\n+                    new CK_ATTRIBUTE(CKA_EXPONENT_2),\n+                    new CK_ATTRIBUTE(CKA_COEFFICIENT),\n+                };\n+                long keyID = key.getKeyID();\n+                try {\n+                    token.p11.C_GetAttributeValue(session[0].id(), keyID, attributes);\n+                } finally {\n+                    key.releaseKeyID();\n+                }\n+\n+                KeySpec spec = new RSAPrivateCrtKeySpec(\n+                    attributes[0].getBigInteger(),\n+                    attributes[1].getBigInteger(),\n+                    attributes[2].getBigInteger(),\n+                    attributes[3].getBigInteger(),\n+                    attributes[4].getBigInteger(),\n+                    attributes[5].getBigInteger(),\n+                    attributes[6].getBigInteger(),\n+                    attributes[7].getBigInteger()\n+                );\n+                return keySpec.cast(spec);\n+            }\n+        } catch (final PKCS11Exception ex) {\n+            // Fall through to RSAPrivateKeySpec if possible, else, bubble this exception up\n+            if (!keySpec.isAssignableFrom(RSAPrivateKeySpec.class)) {\n+                throw ex;\n             }\n+        }\n \n-            KeySpec spec = new RSAPrivateCrtKeySpec(\n-                attributes[0].getBigInteger(),\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger(),\n-                attributes[3].getBigInteger(),\n-                attributes[4].getBigInteger(),\n-                attributes[5].getBigInteger(),\n-                attributes[6].getBigInteger(),\n-                attributes[7].getBigInteger()\n-            );\n-            return keySpec.cast(spec);\n-        } else if (keySpec.isAssignableFrom(RSAPrivateKeySpec.class)) {\n+        // Fall back to RSAPrivateKeySpec if this was requested and all the available attributes\n+        if (keySpec.isAssignableFrom(RSAPrivateKeySpec.class)) {\n             session[0] = token.getObjSession();\n             CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n                 new CK_ATTRIBUTE(CKA_MODULUS),"
  },
  {
    "sha": "e5c4c5457f3b11c9c0549096a32747a39132adc4",
    "filename": "test/jdk/java/security/KeyFactory/KeyFactoryGetKeySpecForInvalidSpec.java",
    "status": "modified",
    "additions": 66,
    "deletions": 2,
    "changes": 68,
    "blob_url": "https://github.com/openjdk/jdk/blob/defbf46bf2145e02d1091f5a8b343a4e0dc4bba2/test/jdk/java/security/KeyFactory/KeyFactoryGetKeySpecForInvalidSpec.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/defbf46bf2145e02d1091f5a8b343a4e0dc4bba2/test/jdk/java/security/KeyFactory/KeyFactoryGetKeySpecForInvalidSpec.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/test/jdk/java/security/KeyFactory/KeyFactoryGetKeySpecForInvalidSpec.java?ref=defbf46bf2145e02d1091f5a8b343a4e0dc4bba2",
    "patch": "@@ -23,31 +23,95 @@\n \n /**\n  * @test\n- * @bug 8254717\n+ * @bug 8254717 8263404\n  * @summary isAssignableFrom checks in KeyFactorySpi.engineGetKeySpec appear to be backwards.\n  * @author Greg Rubin, Ziyi Luo\n  */\n \n+import java.math.BigInteger;\n import java.security.KeyFactory;\n import java.security.KeyPair;\n import java.security.KeyPairGenerator;\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.interfaces.RSAPrivateKey;\n import java.security.spec.*;\n \n public class KeyFactoryGetKeySpecForInvalidSpec {\n+\n+    // Test for 8263404: This method generates RSAPrivateKey (without Crt info) from a RSAPrivateCrtKey\n+    public static RSAPrivateKey privateCrtToPrivate(RSAPrivateCrtKey crtKey) {\n+        return new RSAPrivateKey() {\n+            @Override\n+            public BigInteger getPrivateExponent() {\n+                return crtKey.getPrivateExponent();\n+            }\n+\n+            @Override\n+            public String getAlgorithm() {\n+                return crtKey.getAlgorithm();\n+            }\n+\n+            @Override\n+            public String getFormat() {\n+                return crtKey.getFormat();\n+            }\n+\n+            @Override\n+            public byte[] getEncoded() {\n+                return crtKey.getEncoded();\n+            }\n+\n+            @Override\n+            public BigInteger getModulus() {\n+                return crtKey.getModulus();\n+            }\n+        };\n+    }\n+\n     public static void main(String[] args) throws Exception {\n-        KeyPairGenerator kg = KeyPairGenerator.getInstance(\"RSA\");\n+        KeyPairGenerator kg = KeyPairGenerator.getInstance(\"RSA\", \"SunRsaSign\");\n         kg.initialize(2048);\n         KeyPair pair = kg.generateKeyPair();\n \n         KeyFactory factory = KeyFactory.getInstance(\"RSA\");\n \n+        // === Case 1: private key is RSAPrivateCrtKey, keySpec is RSAPrivateKeySpec\n+        // === Expected: return RSAPrivateCrtKeySpec\n         // Since RSAPrivateCrtKeySpec inherits from RSAPrivateKeySpec, we'd expect this next line to return an instance of RSAPrivateKeySpec\n         // (because the private key has CRT parts).\n         KeySpec spec = factory.getKeySpec(pair.getPrivate(), RSAPrivateKeySpec.class);\n         if (!(spec instanceof RSAPrivateCrtKeySpec)) {\n             throw new Exception(\"Spec should be an instance of RSAPrivateCrtKeySpec\");\n         }\n \n+        // === Case 2: private key is RSAPrivateCrtKey, keySpec is RSAPrivateCrtKeySpec\n+        // === Expected: return RSAPrivateCrtKeySpec\n+        spec = factory.getKeySpec(pair.getPrivate(), RSAPrivateCrtKeySpec.class);\n+        if (!(spec instanceof RSAPrivateCrtKeySpec)) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateCrtKeySpec\");\n+        }\n+\n+        // === Case 3: private key is RSAPrivateKey, keySpec is RSAPrivateKeySpec\n+        // === Expected: return RSAPrivateKeySpec not RSAPrivateCrtKeySpec\n+        RSAPrivateKey notCrtKey = privateCrtToPrivate((RSAPrivateCrtKey)pair.getPrivate());\n+        // InvalidKeySpecException should not be thrown\n+        KeySpec notCrtSpec = factory.getKeySpec(notCrtKey, RSAPrivateKeySpec.class);\n+        if (notCrtSpec instanceof RSAPrivateCrtKeySpec) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateKeySpec not RSAPrivateCrtKeySpec\");\n+        }\n+        if (!(notCrtSpec instanceof RSAPrivateKeySpec)) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateKeySpec\");\n+        }\n+\n+        // === Case 4: private key is RSAPrivateKey, keySpec is RSAPrivateCrtKeySpec\n+        // === Expected: throw InvalidKeySpecException\n+        try {\n+            factory.getKeySpec(notCrtKey, RSAPrivateCrtKeySpec.class);\n+            throw new Exception(\"InvalidKeySpecException is expected but not thrown\");\n+        } catch (InvalidKeySpecException e) {\n+            // continue;\n+        }\n+\n         // This next line should give an InvalidKeySpec exception\n         try {\n             spec = factory.getKeySpec(pair.getPublic(), FakeX509Spec.class);"
  },
  {
    "sha": "25dd007b4658dff0978710ebe4e0cf8c220609ca",
    "filename": "test/jdk/sun/security/pkcs11/rsa/TestP11KeyFactoryGetRSAKeySpec.java",
    "status": "added",
    "additions": 73,
    "deletions": 0,
    "changes": 73,
    "blob_url": "https://github.com/openjdk/jdk/blob/defbf46bf2145e02d1091f5a8b343a4e0dc4bba2/test/jdk/sun/security/pkcs11/rsa/TestP11KeyFactoryGetRSAKeySpec.java",
    "raw_url": "https://github.com/openjdk/jdk/raw/defbf46bf2145e02d1091f5a8b343a4e0dc4bba2/test/jdk/sun/security/pkcs11/rsa/TestP11KeyFactoryGetRSAKeySpec.java",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/test/jdk/sun/security/pkcs11/rsa/TestP11KeyFactoryGetRSAKeySpec.java?ref=defbf46bf2145e02d1091f5a8b343a4e0dc4bba2",
    "patch": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright (c) 2021, Amazon.com, Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+import java.math.BigInteger;\n+import java.security.KeyFactory;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.Provider;\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.spec.*;\n+\n+/**\n+ * @test\n+ * @bug 8263404\n+ * @summary RsaPrivateKeySpec is always recognized as RSAPrivateCrtKeySpec in RSAKeyFactory.engineGetKeySpec\n+ * @author Greg Rubin, Ziyi Luo\n+ * @library /test/lib ..\n+ * @run main/othervm TestP11KeyFactoryGetRSAKeySpec\n+ * @run main/othervm TestP11KeyFactoryGetRSAKeySpec sm rsakeys.ks.policy\n+ * @modules jdk.crypto.cryptoki\n+ */\n+\n+public class TestP11KeyFactoryGetRSAKeySpec extends PKCS11Test {\n+    public static void main(String[] args) throws Exception {\n+        main(new TestP11KeyFactoryGetRSAKeySpec(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        KeyPairGenerator kg = KeyPairGenerator.getInstance(\"RSA\", p);\n+        kg.initialize(2048);\n+        KeyPair pair = kg.generateKeyPair();\n+\n+        KeyFactory factory = KeyFactory.getInstance(\"RSA\", p);\n+\n+        // === Case 1: private key is RSAPrivateCrtKey, keySpec is RSAPrivateKeySpec\n+        // === Expected: return RSAPrivateCrtKeySpec\n+        // Since RSAPrivateCrtKeySpec inherits from RSAPrivateKeySpec, we'd expect this next line to return an instance of RSAPrivateKeySpec\n+        // (because the private key has CRT parts).\n+        KeySpec spec = factory.getKeySpec(pair.getPrivate(), RSAPrivateKeySpec.class);\n+        if (!(spec instanceof RSAPrivateCrtKeySpec)) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateCrtKeySpec\");\n+        }\n+\n+        // === Case 2: private key is RSAPrivateCrtKey, keySpec is RSAPrivateCrtKeySpec\n+        // === Expected: return RSAPrivateCrtKeySpec\n+        spec = factory.getKeySpec(pair.getPrivate(), RSAPrivateCrtKeySpec.class);\n+        if (!(spec instanceof RSAPrivateCrtKeySpec)) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateCrtKeySpec\");\n+        }\n+    }\n+}"
  }
]
