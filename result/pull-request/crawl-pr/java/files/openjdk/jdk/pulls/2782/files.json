[
  {
    "sha": "156628a0aa59e4c8f59782e5a8ccc1470a30d1f6",
    "filename": "src/hotspot/share/gc/g1/g1CollectedHeap.cpp",
    "status": "modified",
    "additions": 71,
    "deletions": 118,
    "changes": 189,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/g1/g1CollectedHeap.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/g1/g1CollectedHeap.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/g1/g1CollectedHeap.cpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -3312,98 +3312,77 @@ class G1STWDrainQueueClosure: public VoidClosure {\n   }\n };\n \n-// Parallel Reference Processing closures\n-\n-// Implementation of AbstractRefProcTaskExecutor for parallel reference\n-// processing during G1 evacuation pauses.\n-\n-class G1STWRefProcTaskExecutor: public AbstractRefProcTaskExecutor {\n-private:\n-  G1CollectedHeap*          _g1h;\n-  G1ParScanThreadStateSet*  _pss;\n-  G1ScannerTasksQueueSet*   _queues;\n-  WorkGang*                 _workers;\n-\n-public:\n-  G1STWRefProcTaskExecutor(G1CollectedHeap* g1h,\n-                           G1ParScanThreadStateSet* per_thread_states,\n-                           WorkGang* workers,\n-                           G1ScannerTasksQueueSet *task_queues) :\n-    _g1h(g1h),\n-    _pss(per_thread_states),\n-    _queues(task_queues),\n-    _workers(workers)\n-  {\n-    g1h->ref_processor_stw()->set_active_mt_degree(workers->active_workers());\n-  }\n-\n-  // Executes the given task using concurrent marking worker threads.\n-  virtual void execute(ProcessTask& task, uint ergo_workers);\n-};\n-\n-// Gang task for possibly parallel reference processing\n-\n-class G1STWRefProcTaskProxy: public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-  ProcessTask&     _proc_task;\n-  G1CollectedHeap* _g1h;\n-  G1ParScanThreadStateSet* _pss;\n-  G1ScannerTasksQueueSet* _task_queues;\n-  TaskTerminator* _terminator;\n+class G1STWRefProcClosureContext : public AbstractRefProcClosureContext {\n+  uint _max_workers;\n+  uint _queues;\n+  G1CollectedHeap& _g1h;\n+  G1ParScanThreadStateSet& _pss;\n+  G1ScannerTasksQueueSet& _task_queues;\n+  TaskTerminator _terminator;\n+  G1STWIsAliveClosure _is_alive;\n+  G1CopyingKeepAliveClosure* _keep_alive;\n+  G1ParEvacuateFollowersClosure* _parallel_complete_gc;\n+  G1CopyingKeepAliveClosure _serial_keep_alive;\n+  G1STWDrainQueueClosure _serial_complete_gc;\n+  RefProcThreadModel _tm;\n \n public:\n-  G1STWRefProcTaskProxy(ProcessTask& proc_task,\n-                        G1CollectedHeap* g1h,\n-                        G1ParScanThreadStateSet* per_thread_states,\n-                        G1ScannerTasksQueueSet *task_queues,\n-                        TaskTerminator* terminator) :\n-    AbstractGangTask(\"Process reference objects in parallel\"),\n-    _proc_task(proc_task),\n-    _g1h(g1h),\n-    _pss(per_thread_states),\n-    _task_queues(task_queues),\n-    _terminator(terminator)\n-  {}\n-\n-  virtual void work(uint worker_id) {\n-    // The reference processing task executed by a single worker.\n-    ResourceMark rm;\n-\n-    G1STWIsAliveClosure is_alive(_g1h);\n-\n-    G1ParScanThreadState* pss = _pss->state_for_worker(worker_id);\n-    pss->set_ref_discoverer(NULL);\n-\n-    // Keep alive closure.\n-    G1CopyingKeepAliveClosure keep_alive(_g1h, pss);\n+  G1STWRefProcClosureContext(uint max_workers,\n+                             G1CollectedHeap& g1h,\n+                             G1ParScanThreadStateSet& pss,\n+                             G1ScannerTasksQueueSet& task_queues)\n+    : _max_workers(max_workers),\n+      _queues(0),\n+      _g1h(g1h),\n+      _pss(pss),\n+      _task_queues(task_queues),\n+      _terminator(_max_workers, &task_queues),\n+      _is_alive(&g1h),\n+      _keep_alive(NEW_C_HEAP_ARRAY(G1CopyingKeepAliveClosure, _max_workers, mtGC)),\n+      _parallel_complete_gc(NEW_C_HEAP_ARRAY(G1ParEvacuateFollowersClosure, _max_workers, mtGC)),\n+      _serial_keep_alive(&g1h, _pss.state_for_worker(0)),\n+      _serial_complete_gc(&g1h, _pss.state_for_worker(0)),\n+      _tm(RefProcThreadModel::Single) {}\n \n-    // Complete GC closure\n-    G1ParEvacuateFollowersClosure drain_queue(_g1h, pss, _task_queues, _terminator, G1GCPhaseTimes::ObjCopy);\n+  ~G1STWRefProcClosureContext() {\n+    FREE_C_HEAP_ARRAY(G1CopyingKeepAliveClosure, _keep_alive);\n+    FREE_C_HEAP_ARRAY(G1ParEvacuateFollowersClosure, _parallel_complete_gc);\n+  }\n \n-    // Call the reference processing task's work routine.\n-    _proc_task.work(worker_id, is_alive, keep_alive, drain_queue);\n+  BoolObjectClosure* is_alive(uint worker_id) {\n+    return &_is_alive;\n+  }\n \n-    // Note we cannot assert that the refs array is empty here as not all\n-    // of the processing tasks (specifically phase2 - pp2_work) execute\n-    // the complete_gc closure (which ordinarily would drain the queue) so\n-    // the queue may not be empty.\n+  OopClosure* keep_alive(uint worker_id) {\n+    assert(worker_id < _queues || _tm == RefProcThreadModel::Single, \"sanity\");\n+    if (_tm == RefProcThreadModel::Single) {\n+      return &_serial_keep_alive;\n+    } else {\n+      return ::new (&_keep_alive[worker_id]) G1CopyingKeepAliveClosure(&_g1h, _pss.state_for_worker(worker_id));\n+    }\n   }\n-};\n \n-// Driver routine for parallel reference processing.\n-// Creates an instance of the ref processing gang\n-// task and has the worker threads execute it.\n-void G1STWRefProcTaskExecutor::execute(ProcessTask& proc_task, uint ergo_workers) {\n-  assert(_workers != NULL, \"Need parallel worker threads.\");\n+  VoidClosure* complete_gc(uint worker_id) {\n+    assert(worker_id < _queues || _tm == RefProcThreadModel::Single, \"sanity\");\n+    if (_tm == RefProcThreadModel::Single) {\n+      return &_serial_complete_gc;\n+    } else {\n+      return ::new (&_parallel_complete_gc[worker_id]) G1ParEvacuateFollowersClosure(&_g1h, _pss.state_for_worker(worker_id), &_task_queues, &_terminator, G1GCPhaseTimes::ObjCopy);\n+    }\n+  }\n \n-  assert(_workers->active_workers() >= ergo_workers,\n-         \"Ergonomically chosen workers (%u) should be less than or equal to active workers (%u)\",\n-         ergo_workers, _workers->active_workers());\n-  TaskTerminator terminator(ergo_workers, _queues);\n-  G1STWRefProcTaskProxy proc_task_proxy(proc_task, _g1h, _pss, _queues, &terminator);\n+  void prepare_run_task(uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"G1STWRefProcClosureContext: prepare_run_task\");\n+    assert(queue_count <= _max_workers, \"sanity\");\n+    _queues = queue_count;\n+    _tm = tm;\n \n-  _workers->run_task(&proc_task_proxy, ergo_workers);\n-}\n+    for (uint qid = 0; qid < index(queue_count, tm); ++qid ) {\n+      _pss.state_for_worker(qid)->set_ref_discoverer(nullptr);\n+    }\n+    _terminator.reset_for_reuse(queue_count);\n+  };\n+};\n \n // End of weak reference support closures\n \n@@ -3413,53 +3392,27 @@ void G1CollectedHeap::process_discovered_references(G1ParScanThreadStateSet* per\n   ReferenceProcessor* rp = _ref_processor_stw;\n   assert(rp->discovery_enabled(), \"should have been enabled\");\n \n-  // Closure to test whether a referent is alive.\n-  G1STWIsAliveClosure is_alive(this);\n-\n-  // Even when parallel reference processing is enabled, the processing\n-  // of JNI refs is serial and performed serially by the current thread\n-  // rather than by a worker. The following PSS will be used for processing\n-  // JNI refs.\n-\n   // Use only a single queue for this PSS.\n   G1ParScanThreadState*          pss = per_thread_states->state_for_worker(0);\n   pss->set_ref_discoverer(NULL);\n   assert(pss->queue_is_empty(), \"pre-condition\");\n \n-  // Keep alive closure.\n-  G1CopyingKeepAliveClosure keep_alive(this, pss);\n-\n-  // Serial Complete GC closure\n-  G1STWDrainQueueClosure drain_queue(this, pss);\n-\n   // Setup the soft refs policy...\n   rp->setup_policy(false);\n \n-  ReferenceProcessorPhaseTimes* pt = phase_times()->ref_phase_times();\n+  ReferenceProcessorPhaseTimes& pt = *phase_times()->ref_phase_times();\n \n   ReferenceProcessorStats stats;\n-  if (!rp->processing_is_mt()) {\n-    // Serial reference processing...\n-    stats = rp->process_discovered_references(&is_alive,\n-                                              &keep_alive,\n-                                              &drain_queue,\n-                                              NULL,\n-                                              pt);\n-  } else {\n-    uint no_of_gc_workers = workers()->active_workers();\n+  uint no_of_gc_workers = workers()->active_workers();\n \n-    // Parallel reference processing\n-    assert(no_of_gc_workers <= rp->max_num_queues(),\n-           \"Mismatch between the number of GC workers %u and the maximum number of Reference process queues %u\",\n-           no_of_gc_workers,  rp->max_num_queues());\n+  // Parallel reference processing\n+  assert(no_of_gc_workers <= rp->max_num_queues(),\n+         \"Mismatch between the number of GC workers %u and the maximum number of Reference process queues %u\",\n+         no_of_gc_workers,  rp->max_num_queues());\n \n-    G1STWRefProcTaskExecutor par_task_executor(this, per_thread_states, workers(), _task_queues);\n-    stats = rp->process_discovered_references(&is_alive,\n-                                              &keep_alive,\n-                                              &drain_queue,\n-                                              &par_task_executor,\n-                                              pt);\n-  }\n+  rp->set_active_mt_degree(no_of_gc_workers);\n+  G1STWRefProcClosureContext context(rp->max_num_queues(), *this, *per_thread_states, *_task_queues);\n+  stats = rp->process_discovered_references(context, pt);\n \n   _gc_tracer_stw->report_gc_reference_stats(stats);\n "
  },
  {
    "sha": "a83066ee96c35517361463f79f79b565791a0894",
    "filename": "src/hotspot/share/gc/g1/g1ConcurrentMark.cpp",
    "status": "modified",
    "additions": 38,
    "deletions": 83,
    "changes": 121,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/g1/g1ConcurrentMark.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/g1/g1ConcurrentMark.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/g1/g1ConcurrentMark.cpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -1461,70 +1461,51 @@ class G1CMDrainMarkingStackClosure : public VoidClosure {\n   }\n };\n \n-// Implementation of AbstractRefProcTaskExecutor for parallel\n-// reference processing at the end of G1 concurrent marking\n-\n-class G1CMRefProcTaskExecutor : public AbstractRefProcTaskExecutor {\n-private:\n-  G1CollectedHeap*  _g1h;\n-  G1ConcurrentMark* _cm;\n-  WorkGang*         _workers;\n-  uint              _active_workers;\n+class G1CMRefProcClosureContext : public AbstractRefProcClosureContext {\n+  uint _max_workers;\n+  G1ConcurrentMark& _cm;\n+  G1CMIsAliveClosure _is_alive;\n+  G1CMKeepAliveAndDrainClosure* _keep_alive;\n+  G1CMDrainMarkingStackClosure* _complete_gc;\n+  RefProcThreadModel _tm;\n \n public:\n-  G1CMRefProcTaskExecutor(G1CollectedHeap* g1h,\n-                          G1ConcurrentMark* cm,\n-                          WorkGang* workers,\n-                          uint n_workers) :\n-    _g1h(g1h), _cm(cm),\n-    _workers(workers), _active_workers(n_workers) { }\n-\n-  virtual void execute(ProcessTask& task, uint ergo_workers);\n-};\n-\n-class G1CMRefProcTaskProxy : public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-  ProcessTask&      _proc_task;\n-  G1CollectedHeap*  _g1h;\n-  G1ConcurrentMark* _cm;\n+  G1CMRefProcClosureContext(uint max_workers,\n+                            G1CollectedHeap& g1h,\n+                            G1ConcurrentMark& cm)\n+    : _max_workers(max_workers),\n+      _cm(cm),\n+      _is_alive(&g1h),\n+      _keep_alive(NEW_C_HEAP_ARRAY(G1CMKeepAliveAndDrainClosure, _max_workers, mtGC)),\n+      _complete_gc(NEW_C_HEAP_ARRAY(G1CMDrainMarkingStackClosure, _max_workers, mtGC)),\n+      _tm(RefProcThreadModel::Single) {}\n \n-public:\n-  G1CMRefProcTaskProxy(ProcessTask& proc_task,\n-                       G1CollectedHeap* g1h,\n-                       G1ConcurrentMark* cm) :\n-    AbstractGangTask(\"Process reference objects in parallel\"),\n-    _proc_task(proc_task), _g1h(g1h), _cm(cm) {\n-    ReferenceProcessor* rp = _g1h->ref_processor_cm();\n-    assert(rp->processing_is_mt(), \"shouldn't be here otherwise\");\n+  ~G1CMRefProcClosureContext() {\n+    FREE_C_HEAP_ARRAY(G1CMKeepAliveAndDrainClosure, _keep_alive);\n+    FREE_C_HEAP_ARRAY(G1CMDrainMarkingStackClosure, _complete_gc);\n   }\n \n-  virtual void work(uint worker_id) {\n-    ResourceMark rm;\n-    G1CMTask* task = _cm->task(worker_id);\n-    G1CMIsAliveClosure g1_is_alive(_g1h);\n-    G1CMKeepAliveAndDrainClosure g1_par_keep_alive(_cm, task, false /* is_serial */);\n-    G1CMDrainMarkingStackClosure g1_par_drain(_cm, task, false /* is_serial */);\n-\n-    _proc_task.work(worker_id, g1_is_alive, g1_par_keep_alive, g1_par_drain);\n+  BoolObjectClosure* is_alive(uint worker_id) {\n+    return &_is_alive;\n   }\n-};\n \n-void G1CMRefProcTaskExecutor::execute(ProcessTask& proc_task, uint ergo_workers) {\n-  assert(_workers != NULL, \"Need parallel worker threads.\");\n-  assert(_g1h->ref_processor_cm()->processing_is_mt(), \"processing is not MT\");\n-  assert(_workers->active_workers() >= ergo_workers,\n-         \"Ergonomically chosen workers(%u) should be less than or equal to active workers(%u)\",\n-         ergo_workers, _workers->active_workers());\n+  OopClosure* keep_alive(uint worker_id) {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    return ::new (&_keep_alive[index(worker_id, _tm)]) G1CMKeepAliveAndDrainClosure(&_cm, _cm.task(index(worker_id, _tm)), _tm == RefProcThreadModel::Single );\n+  }\n \n-  G1CMRefProcTaskProxy proc_task_proxy(proc_task, _g1h, _cm);\n+  VoidClosure* complete_gc(uint worker_id) {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    return ::new (&_complete_gc[index(worker_id, _tm)]) G1CMDrainMarkingStackClosure(&_cm, _cm.task(index(worker_id, _tm)), _tm == RefProcThreadModel::Single);\n+  }\n \n-  // We need to reset the concurrency level before each\n-  // proxy task execution, so that the termination protocol\n-  // and overflow handling in G1CMTask::do_marking_step() knows\n-  // how many workers to wait for.\n-  _cm->set_concurrency(ergo_workers);\n-  _workers->run_task(&proc_task_proxy, ergo_workers);\n-}\n+  void prepare_run_task(uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"G1CMRefProcClosureContext: prepare_run_task\");\n+    assert(queue_count <= _max_workers, \"sanity\");\n+    _tm = tm;\n+    _cm.set_concurrency(queue_count);\n+  };\n+};\n \n void G1ConcurrentMark::weak_refs_work(bool clear_all_soft_refs) {\n   ResourceMark rm;\n@@ -1546,35 +1527,14 @@ void G1ConcurrentMark::weak_refs_work(bool clear_all_soft_refs) {\n     rp->setup_policy(clear_all_soft_refs);\n     assert(_global_mark_stack.is_empty(), \"mark stack should be empty\");\n \n-    // Instances of the 'Keep Alive' and 'Complete GC' closures used\n-    // in serial reference processing. Note these closures are also\n-    // used for serially processing (by the the current thread) the\n-    // JNI references during parallel reference processing.\n-    //\n-    // These closures do not need to synchronize with the worker\n-    // threads involved in parallel reference processing as these\n-    // instances are executed serially by the current thread (e.g.\n-    // reference processing is not multi-threaded and is thus\n-    // performed by the current thread instead of a gang worker).\n-    //\n-    // The gang tasks involved in parallel reference processing create\n-    // their own instances of these closures, which do their own\n-    // synchronization among themselves.\n-    G1CMKeepAliveAndDrainClosure g1_keep_alive(this, task(0), true /* is_serial */);\n-    G1CMDrainMarkingStackClosure g1_drain_mark_stack(this, task(0), true /* is_serial */);\n-\n     // We need at least one active thread. If reference processing\n     // is not multi-threaded we use the current (VMThread) thread,\n     // otherwise we use the work gang from the G1CollectedHeap and\n     // we utilize all the worker threads we can.\n     bool processing_is_mt = rp->processing_is_mt();\n     uint active_workers = (processing_is_mt ? _g1h->workers()->active_workers() : 1U);\n     active_workers = clamp(active_workers, 1u, _max_num_tasks);\n-\n-    // Parallel processing task executor.\n-    G1CMRefProcTaskExecutor par_task_executor(_g1h, this,\n-                                              _g1h->workers(), active_workers);\n-    AbstractRefProcTaskExecutor* executor = (processing_is_mt ? &par_task_executor : NULL);\n+    G1CMRefProcClosureContext context(rp->max_num_queues(), *_g1h, *this);\n \n     // Set the concurrency level. The phase was already set prior to\n     // executing the remark task.\n@@ -1589,12 +1549,7 @@ void G1ConcurrentMark::weak_refs_work(bool clear_all_soft_refs) {\n     ReferenceProcessorPhaseTimes pt(_gc_timer_cm, rp->max_num_queues());\n \n     // Process the weak references.\n-    const ReferenceProcessorStats& stats =\n-        rp->process_discovered_references(&g1_is_alive,\n-                                          &g1_keep_alive,\n-                                          &g1_drain_mark_stack,\n-                                          executor,\n-                                          &pt);\n+    const ReferenceProcessorStats& stats = rp->process_discovered_references(context, pt);\n     _gc_tracer_cm->report_gc_reference_stats(stats);\n     pt.print_all_references();\n "
  },
  {
    "sha": "34fe4b670c3238b95dacab8cdf684455ebc3ff37",
    "filename": "src/hotspot/share/gc/g1/g1ConcurrentMark.hpp",
    "status": "modified",
    "additions": 5,
    "deletions": 6,
    "changes": 11,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/g1/g1ConcurrentMark.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/g1/g1ConcurrentMark.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/g1/g1ConcurrentMark.hpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -278,15 +278,14 @@ class G1CMRootMemRegions {\n // This class manages data structures and methods for doing liveness analysis in\n // G1's concurrent cycle.\n class G1ConcurrentMark : public CHeapObj<mtGC> {\n-  friend class G1ConcurrentMarkThread;\n-  friend class G1CMRefProcTaskProxy;\n-  friend class G1CMRefProcTaskExecutor;\n-  friend class G1CMKeepAliveAndDrainClosure;\n-  friend class G1CMDrainMarkingStackClosure;\n   friend class G1CMBitMapClosure;\n   friend class G1CMConcurrentMarkingTask;\n+  friend class G1CMDrainMarkingStackClosure;\n+  friend class G1CMKeepAliveAndDrainClosure;\n+  friend class G1CMRefProcClosureContext;\n   friend class G1CMRemarkTask;\n   friend class G1CMTask;\n+  friend class G1ConcurrentMarkThread;\n \n   G1ConcurrentMarkThread* _cm_thread;     // The thread doing the work\n   G1CollectedHeap*        _g1h;           // The heap"
  },
  {
    "sha": "dfc010d31d7edbd2ec398baf29e96097a00cad5e",
    "filename": "src/hotspot/share/gc/g1/g1FullCollector.cpp",
    "status": "modified",
    "additions": 53,
    "deletions": 4,
    "changes": 57,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/g1/g1FullCollector.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/g1/g1FullCollector.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/g1/g1FullCollector.cpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -32,7 +32,6 @@\n #include \"gc/g1/g1FullGCMarker.inline.hpp\"\n #include \"gc/g1/g1FullGCMarkTask.hpp\"\n #include \"gc/g1/g1FullGCPrepareTask.hpp\"\n-#include \"gc/g1/g1FullGCReferenceProcessorExecutor.hpp\"\n #include \"gc/g1/g1FullGCScope.hpp\"\n #include \"gc/g1/g1OopClosures.hpp\"\n #include \"gc/g1/g1Policy.hpp\"\n@@ -230,6 +229,47 @@ void G1FullCollector::update_attribute_table(HeapRegion* hr) {\n   }\n }\n \n+class G1FullGCRefProcClosureContext : public AbstractRefProcClosureContext {\n+  uint _max_workers;\n+  G1FullCollector& _collector;\n+  G1IsAliveClosure _is_alive;\n+  G1FullKeepAliveClosure* _keep_alive;\n+  RefProcThreadModel _tm;\n+\n+public:\n+  G1FullGCRefProcClosureContext(G1FullCollector& collector, uint max_workers)\n+    : _max_workers(max_workers),\n+      _collector(collector),\n+      _is_alive(&collector),\n+      _keep_alive(NEW_C_HEAP_ARRAY(G1FullKeepAliveClosure, max_workers, mtGC)),\n+      _tm(RefProcThreadModel::Single) {}\n+\n+  ~G1FullGCRefProcClosureContext() {\n+    FREE_C_HEAP_ARRAY(G1FullKeepAliveClosure, _keep_alive);\n+  }\n+\n+  BoolObjectClosure* is_alive(uint worker_id) {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    return &_is_alive;\n+  }\n+\n+  OopClosure* keep_alive(uint worker_id) {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    return ::new (&_keep_alive[index(worker_id, _tm)]) G1FullKeepAliveClosure(_collector.marker(index(worker_id, _tm)));\n+  };\n+\n+  VoidClosure* complete_gc(uint worker_id) {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    return _collector.marker(index(worker_id, _tm))->stack_closure();\n+  }\n+\n+  void prepare_run_task(uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"G1FullGCRefProcClosureContext: prepare_run_task\");\n+    assert(queue_count <= _max_workers, \"sanity\");\n+    _tm = tm;\n+  };\n+};\n+\n void G1FullCollector::phase1_mark_live_objects() {\n   // Recursively traverse all live objects and mark them.\n   GCTraceTime(Info, gc, phases) info(\"Phase 1: Mark live objects\", scope()->timer());\n@@ -241,9 +281,18 @@ void G1FullCollector::phase1_mark_live_objects() {\n   }\n \n   {\n-    // Process references discovered during marking.\n-    G1FullGCReferenceProcessingExecutor reference_processing(this);\n-    reference_processing.execute(scope()->timer(), scope()->tracer());\n+    uint old_active_mt_degree = reference_processor()->num_queues();\n+    reference_processor()->set_active_mt_degree(workers());\n+    GCTraceTime(Debug, gc, phases) debug(\"Phase 1: Reference Processing\", scope()->timer());\n+    // Process reference objects found during marking.\n+    ReferenceProcessorPhaseTimes pt(scope()->timer(), reference_processor()->max_num_queues());\n+    G1FullGCRefProcClosureContext context(*this, reference_processor()->max_num_queues());\n+    const ReferenceProcessorStats& stats = reference_processor()->process_discovered_references(context, pt);\n+    scope()->tracer()->report_gc_reference_stats(stats);\n+    pt.print_all_references();\n+    assert(marker(0)->oop_stack()->is_empty(), \"Should be no oops on the stack\");\n+\n+    reference_processor()->set_active_mt_degree(old_active_mt_degree);\n   }\n \n   // Weak oops cleanup."
  },
  {
    "sha": "0a5af484b108690528633483ca016ebe883e0261",
    "filename": "src/hotspot/share/gc/g1/g1FullGCMarkTask.cpp",
    "status": "modified",
    "additions": 1,
    "deletions": 2,
    "changes": 3,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/g1/g1FullGCMarkTask.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/g1/g1FullGCMarkTask.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/g1/g1FullGCMarkTask.cpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -29,7 +29,6 @@\n #include \"gc/g1/g1FullGCMarker.hpp\"\n #include \"gc/g1/g1FullGCMarkTask.hpp\"\n #include \"gc/g1/g1FullGCOopClosures.inline.hpp\"\n-#include \"gc/g1/g1FullGCReferenceProcessorExecutor.hpp\"\n #include \"gc/shared/gcTraceTime.inline.hpp\"\n #include \"gc/shared/referenceProcessor.hpp\"\n #include \"memory/iterator.inline.hpp\""
  },
  {
    "sha": "a730a44e8b8b21a0d203c2772be45016cf57fe12",
    "filename": "src/hotspot/share/gc/g1/g1FullGCReferenceProcessorExecutor.cpp",
    "status": "removed",
    "additions": 0,
    "deletions": 102,
    "changes": 102,
    "blob_url": "https://github.com/openjdk/jdk/blob/22a3117d229cba10c690a4e66baf9c754a09e57c/src/hotspot/share/gc/g1/g1FullGCReferenceProcessorExecutor.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/22a3117d229cba10c690a4e66baf9c754a09e57c/src/hotspot/share/gc/g1/g1FullGCReferenceProcessorExecutor.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/g1/g1FullGCReferenceProcessorExecutor.cpp?ref=22a3117d229cba10c690a4e66baf9c754a09e57c",
    "patch": "@@ -1,102 +0,0 @@\n-/*\n- * Copyright (c) 2017, 2021, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- */\n-\n-#include \"precompiled.hpp\"\n-#include \"gc/g1/g1CollectedHeap.hpp\"\n-#include \"gc/g1/g1FullCollector.hpp\"\n-#include \"gc/g1/g1FullGCMarker.hpp\"\n-#include \"gc/g1/g1FullGCOopClosures.inline.hpp\"\n-#include \"gc/g1/g1FullGCReferenceProcessorExecutor.hpp\"\n-#include \"gc/shared/gcTraceTime.inline.hpp\"\n-#include \"gc/shared/referenceProcessor.hpp\"\n-#include \"gc/shared/referenceProcessorPhaseTimes.hpp\"\n-#include \"memory/iterator.inline.hpp\"\n-\n-G1FullGCReferenceProcessingExecutor::G1FullGCReferenceProcessingExecutor(G1FullCollector* collector) :\n-    _collector(collector),\n-    _reference_processor(collector->reference_processor()),\n-    _old_mt_degree(_reference_processor->num_queues()) {\n-  if (_reference_processor->processing_is_mt()) {\n-    _reference_processor->set_active_mt_degree(_collector->workers());\n-  }\n-}\n-\n-G1FullGCReferenceProcessingExecutor::~G1FullGCReferenceProcessingExecutor() {\n-  if (_reference_processor->processing_is_mt()) {\n-    _reference_processor->set_active_mt_degree(_old_mt_degree);\n-  }\n-}\n-\n-G1FullGCReferenceProcessingExecutor::G1RefProcTaskProxy::G1RefProcTaskProxy(ProcessTask& proc_task,\n-                                                                      G1FullCollector* collector) :\n-     AbstractGangTask(\"G1 reference processing task\"),\n-     _proc_task(proc_task),\n-     _collector(collector) { }\n-\n-void G1FullGCReferenceProcessingExecutor::G1RefProcTaskProxy::work(uint worker_id) {\n-  G1FullGCMarker* marker = _collector->marker(worker_id);\n-  G1IsAliveClosure is_alive(_collector);\n-  G1FullKeepAliveClosure keep_alive(marker);\n-  _proc_task.work(worker_id,\n-                  is_alive,\n-                  keep_alive,\n-                  *marker->stack_closure());\n-}\n-\n-void G1FullGCReferenceProcessingExecutor::run_task(AbstractGangTask* task) {\n-  G1CollectedHeap::heap()->workers()->run_task(task, _collector->workers());\n-}\n-\n-void G1FullGCReferenceProcessingExecutor::run_task(AbstractGangTask* task, uint workers) {\n-  G1CollectedHeap::heap()->workers()->run_task(task, workers);\n-}\n-\n-void G1FullGCReferenceProcessingExecutor::execute(ProcessTask& proc_task, uint ergo_workers) {\n-  G1RefProcTaskProxy proc_task_proxy(proc_task, _collector);\n-  run_task(&proc_task_proxy, ergo_workers);\n-}\n-\n-void G1FullGCReferenceProcessingExecutor::execute(STWGCTimer* timer, G1FullGCTracer* tracer) {\n-  GCTraceTime(Debug, gc, phases) debug(\"Phase 1: Reference Processing\", timer);\n-  // Process reference objects found during marking.\n-  G1FullGCMarker* marker = _collector->marker(0);\n-  G1IsAliveClosure is_alive(_collector);\n-  G1FullKeepAliveClosure keep_alive(marker);\n-  ReferenceProcessorPhaseTimes pt(timer, _reference_processor->max_num_queues());\n-  AbstractRefProcTaskExecutor* executor = _reference_processor->processing_is_mt() ? this : NULL;\n-\n-  // Process discovered references, use this executor if multi-threaded\n-  // processing is enabled.\n-  const ReferenceProcessorStats& stats =\n-      _reference_processor->process_discovered_references(&is_alive,\n-                                                          &keep_alive,\n-                                                          marker->stack_closure(),\n-                                                          executor,\n-                                                          &pt);\n-\n-  tracer->report_gc_reference_stats(stats);\n-  pt.print_all_references();\n-\n-  assert(marker->oop_stack()->is_empty(), \"Should be no oops on the stack\");\n-}"
  },
  {
    "sha": "9887d0f130ce47af518253d97a93112706c3ec05",
    "filename": "src/hotspot/share/gc/g1/g1FullGCReferenceProcessorExecutor.hpp",
    "status": "removed",
    "additions": 0,
    "deletions": 73,
    "changes": 73,
    "blob_url": "https://github.com/openjdk/jdk/blob/22a3117d229cba10c690a4e66baf9c754a09e57c/src/hotspot/share/gc/g1/g1FullGCReferenceProcessorExecutor.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/22a3117d229cba10c690a4e66baf9c754a09e57c/src/hotspot/share/gc/g1/g1FullGCReferenceProcessorExecutor.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/g1/g1FullGCReferenceProcessorExecutor.hpp?ref=22a3117d229cba10c690a4e66baf9c754a09e57c",
    "patch": "@@ -1,73 +0,0 @@\n-/*\n- * Copyright (c) 2017, 2021, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- */\n-\n-#ifndef SHARE_GC_G1_G1FULLGCREFERENCEPROCESSOREXECUTOR_HPP\n-#define SHARE_GC_G1_G1FULLGCREFERENCEPROCESSOREXECUTOR_HPP\n-\n-#include \"gc/g1/g1FullGCCompactionPoint.hpp\"\n-#include \"gc/g1/g1FullGCScope.hpp\"\n-#include \"gc/g1/g1FullGCTask.hpp\"\n-#include \"gc/g1/g1RootProcessor.hpp\"\n-#include \"gc/g1/g1StringDedup.hpp\"\n-#include \"gc/g1/heapRegionManager.hpp\"\n-#include \"gc/shared/referenceProcessor.hpp\"\n-#include \"gc/shared/taskqueue.hpp\"\n-#include \"utilities/ticks.hpp\"\n-\n-class G1FullGCTracer;\n-class STWGCTimer;\n-\n-class G1FullGCReferenceProcessingExecutor: public AbstractRefProcTaskExecutor {\n-  G1FullCollector*    _collector;\n-  ReferenceProcessor* _reference_processor;\n-  uint                _old_mt_degree;\n-\n-public:\n-  G1FullGCReferenceProcessingExecutor(G1FullCollector* collector);\n-  ~G1FullGCReferenceProcessingExecutor();\n-\n-  // Do reference processing.\n-  void execute(STWGCTimer* timer, G1FullGCTracer* tracer);\n-\n-  // Executes the given task using concurrent marking worker threads.\n-  virtual void execute(ProcessTask& task, uint ergo_workers);\n-\n-private:\n-  void run_task(AbstractGangTask* task);\n-  void run_task(AbstractGangTask* task, uint workers);\n-\n-  class G1RefProcTaskProxy : public AbstractGangTask {\n-    typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-    ProcessTask&                  _proc_task;\n-    G1FullCollector*              _collector;\n-\n-  public:\n-    G1RefProcTaskProxy(ProcessTask& proc_task,\n-                       G1FullCollector* scope);\n-\n-    virtual void work(uint worker_id);\n-  };\n-};\n-\n-#endif // SHARE_GC_G1_G1FULLGCREFERENCEPROCESSOREXECUTOR_HPP"
  },
  {
    "sha": "a38ca9296b36d1cbd72b6f2bc354fdaed3656d15",
    "filename": "src/hotspot/share/gc/parallel/psCompactionManager.hpp",
    "status": "modified",
    "additions": 11,
    "deletions": 6,
    "changes": 17,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/parallel/psCompactionManager.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/parallel/psCompactionManager.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/parallel/psCompactionManager.hpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -27,6 +27,7 @@\n \n #include \"gc/parallel/psParallelCompact.hpp\"\n #include \"gc/shared/taskqueue.hpp\"\n+#include \"gc/shared/taskTerminator.hpp\"\n #include \"memory/allocation.hpp\"\n #include \"utilities/stack.hpp\"\n \n@@ -38,14 +39,15 @@ class ParallelCompactData;\n class ParMarkBitMap;\n \n class ParCompactionManager : public CHeapObj<mtGC> {\n+  friend class CompactionWithStealingTask;\n+  friend class MarkFromRootsTask;\n   friend class ParMarkBitMap;\n+  friend class ParallelCompactRefProcClosureContext;\n   friend class PSParallelCompact;\n-  friend class CompactionWithStealingTask;\n+  friend class RefProcClosureContext;\n   friend class UpdateAndFillClosure;\n-  friend class RefProcTaskExecutor;\n-  friend class PCRefProcTask;\n-  friend class MarkFromRootsTask;\n   friend class UpdateDensePrefixAndCompactionTask;\n+\n  private:\n   typedef GenericTaskQueue<oop, mtGC>             OopTaskQueue;\n   typedef GenericTaskQueueSet<OopTaskQueue, mtGC> OopTaskQueueSet;\n@@ -187,8 +189,11 @@ class ParCompactionManager : public CHeapObj<mtGC> {\n   class FollowStackClosure: public VoidClosure {\n    private:\n     ParCompactionManager* _compaction_manager;\n+    TaskTerminator* _terminator;\n+    uint _worker_id;\n    public:\n-    FollowStackClosure(ParCompactionManager* cm) : _compaction_manager(cm) { }\n+    FollowStackClosure(ParCompactionManager* cm, TaskTerminator* terminator, uint worker_id)\n+      : _compaction_manager(cm), _terminator(terminator), _worker_id(worker_id) { }\n     virtual void do_void();\n   };\n "
  },
  {
    "sha": "02605f4fc52975cb85c7df9fcd2c8c006353b62d",
    "filename": "src/hotspot/share/gc/parallel/psCompactionManager.inline.hpp",
    "status": "modified",
    "additions": 3,
    "deletions": 0,
    "changes": 3,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/parallel/psCompactionManager.inline.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/parallel/psCompactionManager.inline.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/parallel/psCompactionManager.inline.hpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -118,6 +118,9 @@ inline void ParCompactionManager::follow_klass(Klass* klass) {\n \n inline void ParCompactionManager::FollowStackClosure::do_void() {\n   _compaction_manager->follow_marking_stacks();\n+  if (_terminator != nullptr) {\n+    steal_marking_work(*_terminator, _worker_id);\n+  }\n }\n \n template <typename T>"
  },
  {
    "sha": "e04a6fcd18c7e78f0cfe26926152dbc8d13ec5db",
    "filename": "src/hotspot/share/gc/parallel/psParallelCompact.cpp",
    "status": "modified",
    "additions": 35,
    "deletions": 48,
    "changes": 83,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/parallel/psParallelCompact.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/parallel/psParallelCompact.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/parallel/psParallelCompact.cpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -2023,7 +2023,7 @@ static void mark_from_roots_work(ParallelRootType::Value root_type, uint worker_\n   cm->follow_marking_stacks();\n }\n \n-static void steal_marking_work(TaskTerminator& terminator, uint worker_id) {\n+void steal_marking_work(TaskTerminator& terminator, uint worker_id) {\n   assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n \n   ParCompactionManager* cm =\n@@ -2044,7 +2044,6 @@ static void steal_marking_work(TaskTerminator& terminator, uint worker_id) {\n }\n \n class MarkFromRootsTask : public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n   StrongRootsScope _strong_roots_scope; // needed for Threads::possibly_parallel_threads_do\n   OopStorageSetStrongParState<false /* concurrent */, false /* is_const */> _oop_storage_set_par_state;\n   SequentialSubTasksDone _subtasks;\n@@ -2086,44 +2085,46 @@ class MarkFromRootsTask : public AbstractGangTask {\n   }\n };\n \n-class PCRefProcTask : public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-  ProcessTask& _task;\n-  uint _ergo_workers;\n+class ParallelCompactRefProcClosureContext : public AbstractRefProcClosureContext {\n+  uint _max_workers;\n   TaskTerminator _terminator;\n+  PCMarkAndPushClosure* _keep_alive;\n+  ParCompactionManager::FollowStackClosure* _complete_gc;\n+  RefProcThreadModel _tm;\n \n public:\n-  PCRefProcTask(ProcessTask& task, uint ergo_workers) :\n-      AbstractGangTask(\"PCRefProcTask\"),\n-      _task(task),\n-      _ergo_workers(ergo_workers),\n-      _terminator(_ergo_workers, ParCompactionManager::oop_task_queues()) {\n-  }\n+  ParallelCompactRefProcClosureContext(uint max_workers)\n+    : _max_workers(max_workers),\n+      _terminator(_max_workers, ParCompactionManager::oop_task_queues()),\n+      _keep_alive(NEW_C_HEAP_ARRAY(PCMarkAndPushClosure, _max_workers, mtGC)),\n+      _complete_gc(NEW_C_HEAP_ARRAY(ParCompactionManager::FollowStackClosure, _max_workers, mtGC)),\n+      _tm(RefProcThreadModel::Single) {}\n \n-  virtual void work(uint worker_id) {\n-    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-    assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n-\n-    ParCompactionManager* cm =\n-      ParCompactionManager::gc_thread_compaction_manager(worker_id);\n-    PCMarkAndPushClosure mark_and_push_closure(cm);\n-    ParCompactionManager::FollowStackClosure follow_stack_closure(cm);\n-    _task.work(worker_id, *PSParallelCompact::is_alive_closure(),\n-               mark_and_push_closure, follow_stack_closure);\n+  ~ParallelCompactRefProcClosureContext() {\n+    FREE_C_HEAP_ARRAY(PCMarkAndPushClosure, _keep_alive);\n+    FREE_C_HEAP_ARRAY(ParCompactionManager::FollowStackClosure, _complete_gc);\n+  }\n \n-    steal_marking_work(_terminator, worker_id);\n+  BoolObjectClosure* is_alive(uint worker_id) {\n+    return PSParallelCompact::is_alive_closure();\n   }\n-};\n \n-class RefProcTaskExecutor: public AbstractRefProcTaskExecutor {\n-  void execute(ProcessTask& process_task, uint ergo_workers) {\n-    assert(ParallelScavengeHeap::heap()->workers().active_workers() == ergo_workers,\n-           \"Ergonomically chosen workers (%u) must be equal to active workers (%u)\",\n-           ergo_workers, ParallelScavengeHeap::heap()->workers().active_workers());\n+  OopClosure* keep_alive(uint worker_id) {\n+    ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+    return ::new (&_keep_alive[worker_id]) PCMarkAndPushClosure(cm);\n+  }\n \n-    PCRefProcTask task(process_task, ergo_workers);\n-    ParallelScavengeHeap::heap()->workers().run_task(&task);\n+  VoidClosure* complete_gc(uint worker_id) {\n+    ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+    return ::new (&_complete_gc[worker_id]) ParCompactionManager::FollowStackClosure(cm, (_tm == RefProcThreadModel::Single) ? nullptr : &_terminator, worker_id);\n   }\n+\n+  void prepare_run_task(uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"ParallelCompactRefProcClosureContext: prepare_run_task\");\n+    assert(queue_count <= _max_workers, \"sanity\");\n+    _tm = tm;\n+   _terminator.reset_for_reuse(queue_count);\n+  };\n };\n \n void PSParallelCompact::marking_phase(ParCompactionManager* cm,\n@@ -2132,12 +2133,8 @@ void PSParallelCompact::marking_phase(ParCompactionManager* cm,\n   // Recursively traverse all live objects and mark them\n   GCTraceTime(Info, gc, phases) tm(\"Marking Phase\", &_gc_timer);\n \n-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n   uint active_gc_threads = ParallelScavengeHeap::heap()->workers().active_workers();\n \n-  PCMarkAndPushClosure mark_and_push_closure(cm);\n-  ParCompactionManager::FollowStackClosure follow_stack_closure(cm);\n-\n   // Need new claim bits before marking starts.\n   ClassLoaderDataGraph::clear_claimed_marks();\n \n@@ -2155,18 +2152,9 @@ void PSParallelCompact::marking_phase(ParCompactionManager* cm,\n     ReferenceProcessorStats stats;\n     ReferenceProcessorPhaseTimes pt(&_gc_timer, ref_processor()->max_num_queues());\n \n-    if (ref_processor()->processing_is_mt()) {\n-      ref_processor()->set_active_mt_degree(active_gc_threads);\n-\n-      RefProcTaskExecutor task_executor;\n-      stats = ref_processor()->process_discovered_references(\n-        is_alive_closure(), &mark_and_push_closure, &follow_stack_closure,\n-        &task_executor, &pt);\n-    } else {\n-      stats = ref_processor()->process_discovered_references(\n-        is_alive_closure(), &mark_and_push_closure, &follow_stack_closure, NULL,\n-        &pt);\n-    }\n+    ref_processor()->set_active_mt_degree(active_gc_threads);\n+    ParallelCompactRefProcClosureContext context(ref_processor()->max_num_queues());\n+    stats = ref_processor()->process_discovered_references(context, pt);\n \n     gc_tracer->report_gc_reference_stats(stats);\n     pt.print_all_references();\n@@ -2557,7 +2545,6 @@ static void compaction_with_stealing_work(TaskTerminator* terminator, uint worke\n }\n \n class UpdateDensePrefixAndCompactionTask: public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n   TaskQueue& _tq;\n   TaskTerminator _terminator;\n   uint _active_workers;"
  },
  {
    "sha": "d3227969a44b4687f003a91ae3c5910d6fa2c0fe",
    "filename": "src/hotspot/share/gc/parallel/psParallelCompact.hpp",
    "status": "modified",
    "additions": 4,
    "deletions": 1,
    "changes": 5,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/parallel/psParallelCompact.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/parallel/psParallelCompact.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/parallel/psParallelCompact.hpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -27,10 +27,11 @@\n \n #include \"gc/parallel/mutableSpace.hpp\"\n #include \"gc/parallel/objectStartArray.hpp\"\n-#include \"gc/parallel/parMarkBitMap.hpp\"\n #include \"gc/parallel/parallelScavengeHeap.hpp\"\n+#include \"gc/parallel/parMarkBitMap.hpp\"\n #include \"gc/shared/collectedHeap.hpp\"\n #include \"gc/shared/collectorCounters.hpp\"\n+#include \"gc/shared/taskTerminator.hpp\"\n #include \"oops/oop.hpp\"\n #include \"runtime/atomic.hpp\"\n #include \"runtime/orderAccess.hpp\"\n@@ -1389,4 +1390,6 @@ class FillClosure: public ParMarkBitMapClosure {\n   ObjectStartArray* const _start_array;\n };\n \n+void steal_marking_work(TaskTerminator& terminator, uint worker_id);\n+\n #endif // SHARE_GC_PARALLEL_PSPARALLELCOMPACT_HPP"
  },
  {
    "sha": "62a52d0ed070e9ef979ab1fb653721b51c039e10",
    "filename": "src/hotspot/share/gc/parallel/psPromotionManager.hpp",
    "status": "modified",
    "additions": 2,
    "deletions": 3,
    "changes": 5,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/parallel/psPromotionManager.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/parallel/psPromotionManager.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/parallel/psPromotionManager.hpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -50,10 +50,9 @@ class PSOldGen;\n class ParCompactionManager;\n \n class PSPromotionManager {\n+  friend class ParallelScavengeRefProcClosureContext;\n   friend class PSScavenge;\n   friend class ScavengeRootsTask;\n-  friend class PSRefProcTaskExecutor;\n-  friend class PSRefProcTask;\n \n  private:\n   typedef OverflowTaskQueue<ScannerTask, mtGC>           PSScannerTasksQueue;"
  },
  {
    "sha": "4a23fcd714166f4c454e9a6644e5d941a78c4548",
    "filename": "src/hotspot/share/gc/parallel/psScavenge.cpp",
    "status": "modified",
    "additions": 49,
    "deletions": 43,
    "changes": 92,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/parallel/psScavenge.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/parallel/psScavenge.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/parallel/psScavenge.cpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -180,54 +180,68 @@ class PSKeepAliveClosure: public OopClosure {\n class PSEvacuateFollowersClosure: public VoidClosure {\n  private:\n   PSPromotionManager* _promotion_manager;\n+  TaskTerminator* _terminator;\n+  uint _worker_id;\n+\n  public:\n-  PSEvacuateFollowersClosure(PSPromotionManager* pm) : _promotion_manager(pm) {}\n+  PSEvacuateFollowersClosure(PSPromotionManager* pm, TaskTerminator* terminator, uint worker_id)\n+    : _promotion_manager(pm), _terminator(terminator), _worker_id(worker_id) {}\n \n   virtual void do_void() {\n-    assert(_promotion_manager != NULL, \"Sanity\");\n+    assert(_promotion_manager != nullptr, \"Sanity\");\n     _promotion_manager->drain_stacks(true);\n     guarantee(_promotion_manager->stacks_empty(),\n               \"stacks should be empty at this point\");\n-  }\n-};\n \n-class PSRefProcTaskExecutor: public AbstractRefProcTaskExecutor {\n-  virtual void execute(ProcessTask& process_task, uint ergo_workers);\n+    if (_terminator != nullptr) {\n+      steal_work(*_terminator, _worker_id);\n+    }\n+  }\n };\n \n-class PSRefProcTask : public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n+class ParallelScavengeRefProcClosureContext : public AbstractRefProcClosureContext {\n+  uint _max_workers;\n   TaskTerminator _terminator;\n-  ProcessTask& _task;\n-  uint _active_workers;\n+  TaskTerminator* _nullable_terminator; // nullptr when no termination is to be done\n+  PSIsAliveClosure _is_alive;\n+  PSKeepAliveClosure* _keep_alive;\n+  PSEvacuateFollowersClosure* _complete_gc;\n \n public:\n-  PSRefProcTask(ProcessTask& task, uint active_workers)\n-    : AbstractGangTask(\"PSRefProcTask\"),\n-      _terminator(active_workers, PSPromotionManager::stack_array_depth()),\n-      _task(task),\n-      _active_workers(active_workers) {\n+  ParallelScavengeRefProcClosureContext(uint max_workers)\n+    : _max_workers(max_workers),\n+      _terminator(_max_workers, PSPromotionManager::stack_array_depth()),\n+      _nullable_terminator(nullptr),\n+      _is_alive(),\n+      _keep_alive(NEW_C_HEAP_ARRAY(PSKeepAliveClosure, _max_workers, mtGC)),\n+      _complete_gc(NEW_C_HEAP_ARRAY(PSEvacuateFollowersClosure, _max_workers, mtGC)) {}\n+\n+  ~ParallelScavengeRefProcClosureContext() {\n+    FREE_C_HEAP_ARRAY(PSKeepAliveClosure, _keep_alive);\n+    FREE_C_HEAP_ARRAY(PSEvacuateFollowersClosure, _complete_gc);\n   }\n \n-  virtual void work(uint worker_id) {\n-    PSPromotionManager* promotion_manager =\n-      PSPromotionManager::gc_thread_promotion_manager(worker_id);\n-    assert(promotion_manager != NULL, \"sanity check\");\n-    PSKeepAliveClosure keep_alive(promotion_manager);\n-    PSEvacuateFollowersClosure evac_followers(promotion_manager);\n-    PSIsAliveClosure is_alive;\n-    _task.work(worker_id, is_alive, keep_alive, evac_followers);\n-\n-    if (_task.marks_oops_alive() && _active_workers > 1) {\n-      steal_work(_terminator, worker_id);\n-    }\n+  BoolObjectClosure* is_alive(uint worker_id) {\n+    return &_is_alive;\n   }\n-};\n \n-void PSRefProcTaskExecutor::execute(ProcessTask& process_task, uint ergo_workers) {\n-  PSRefProcTask task(process_task, ergo_workers);\n-  ParallelScavengeHeap::heap()->workers().run_task(&task);\n-}\n+  OopClosure* keep_alive(uint worker_id) {\n+    PSPromotionManager* promotion_manager = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n+    return ::new (&_keep_alive[worker_id]) PSKeepAliveClosure(promotion_manager);\n+  }\n+\n+  VoidClosure* complete_gc(uint worker_id) {\n+    PSPromotionManager* promotion_manager = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n+    return ::new (&_complete_gc[worker_id]) PSEvacuateFollowersClosure(promotion_manager, _nullable_terminator, worker_id);\n+  }\n+\n+  void prepare_run_task(uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"ParallelScavengeRefProcClosureContext: prepare_run_task\");\n+    assert(queue_count <= _max_workers, \"sanity\");\n+    _terminator.reset_for_reuse(queue_count);\n+    _nullable_terminator = (marks_oops_alive && tm == RefProcThreadModel::Multi)?&_terminator:nullptr;\n+  };\n+};\n \n // This method contains all heap specific policy for invoking scavenge.\n // PSScavenge::invoke_no_policy() will do nothing but attempt to\n@@ -500,19 +514,11 @@ bool PSScavenge::invoke_no_policy() {\n \n       reference_processor()->setup_policy(false); // not always_clear\n       reference_processor()->set_active_mt_degree(active_workers);\n-      PSKeepAliveClosure keep_alive(promotion_manager);\n-      PSEvacuateFollowersClosure evac_followers(promotion_manager);\n       ReferenceProcessorStats stats;\n       ReferenceProcessorPhaseTimes pt(&_gc_timer, reference_processor()->max_num_queues());\n-      if (reference_processor()->processing_is_mt()) {\n-        PSRefProcTaskExecutor task_executor;\n-        stats = reference_processor()->process_discovered_references(\n-          &_is_alive_closure, &keep_alive, &evac_followers, &task_executor,\n-          &pt);\n-      } else {\n-        stats = reference_processor()->process_discovered_references(\n-          &_is_alive_closure, &keep_alive, &evac_followers, NULL, &pt);\n-      }\n+\n+      ParallelScavengeRefProcClosureContext context(reference_processor()->max_num_queues());\n+      stats = reference_processor()->process_discovered_references(context, pt);\n \n       _gc_tracer.report_gc_reference_stats(stats);\n       pt.print_all_references();"
  },
  {
    "sha": "544218dfc98c478a297525acc6fbdc9a951a21b3",
    "filename": "src/hotspot/share/gc/serial/defNewGeneration.cpp",
    "status": "modified",
    "additions": 4,
    "deletions": 4,
    "changes": 8,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/serial/defNewGeneration.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/serial/defNewGeneration.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/serial/defNewGeneration.cpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -24,6 +24,7 @@\n \n #include \"precompiled.hpp\"\n #include \"gc/serial/defNewGeneration.inline.hpp\"\n+#include \"gc/serial/serialGcRefProcClosureContext.hpp\"\n #include \"gc/serial/serialHeap.inline.hpp\"\n #include \"gc/serial/tenuredGeneration.hpp\"\n #include \"gc/shared/adaptiveSizePolicy.hpp\"\n@@ -37,8 +38,8 @@\n #include \"gc/shared/gcTimer.hpp\"\n #include \"gc/shared/gcTrace.hpp\"\n #include \"gc/shared/gcTraceTime.inline.hpp\"\n-#include \"gc/shared/genOopClosures.inline.hpp\"\n #include \"gc/shared/generationSpec.hpp\"\n+#include \"gc/shared/genOopClosures.inline.hpp\"\n #include \"gc/shared/preservedMarks.inline.hpp\"\n #include \"gc/shared/referencePolicy.hpp\"\n #include \"gc/shared/referenceProcessorPhaseTimes.hpp\"\n@@ -587,9 +588,8 @@ void DefNewGeneration::collect(bool   full,\n   ReferenceProcessor* rp = ref_processor();\n   rp->setup_policy(clear_all_soft_refs);\n   ReferenceProcessorPhaseTimes pt(_gc_timer, rp->max_num_queues());\n-  const ReferenceProcessorStats& stats =\n-  rp->process_discovered_references(&is_alive, &keep_alive, &evacuate_followers,\n-                                    NULL, &pt);\n+  SerialGCRefProcClosureContext closure_context(is_alive, keep_alive, evacuate_followers);\n+  const ReferenceProcessorStats& stats = rp->process_discovered_references(closure_context, pt);\n   gc_tracer.report_gc_reference_stats(stats);\n   gc_tracer.report_tenuring_threshold(tenuring_threshold());\n   pt.print_all_references();"
  },
  {
    "sha": "38bd7350f518a4ff17544f2633ea7dfba23ffbaf",
    "filename": "src/hotspot/share/gc/serial/genMarkSweep.cpp",
    "status": "modified",
    "additions": 4,
    "deletions": 4,
    "changes": 8,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/serial/genMarkSweep.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/serial/genMarkSweep.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/serial/genMarkSweep.cpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n@@ -32,6 +32,7 @@\n #include \"code/codeCache.hpp\"\n #include \"code/icBuffer.hpp\"\n #include \"gc/serial/genMarkSweep.hpp\"\n+#include \"gc/serial/serialGcRefProcClosureContext.hpp\"\n #include \"gc/shared/collectedHeap.inline.hpp\"\n #include \"gc/shared/gcHeapSummary.hpp\"\n #include \"gc/shared/gcTimer.hpp\"\n@@ -198,9 +199,8 @@ void GenMarkSweep::mark_sweep_phase1(bool clear_all_softrefs) {\n \n     ref_processor()->setup_policy(clear_all_softrefs);\n     ReferenceProcessorPhaseTimes pt(_gc_timer, ref_processor()->max_num_queues());\n-    const ReferenceProcessorStats& stats =\n-      ref_processor()->process_discovered_references(\n-        &is_alive, &keep_alive, &follow_stack_closure, NULL, &pt);\n+    SerialGCRefProcClosureContext closure_context(is_alive, keep_alive, follow_stack_closure);\n+    const ReferenceProcessorStats& stats = ref_processor()->process_discovered_references(closure_context, pt);\n     pt.print_all_references();\n     gc_tracer()->report_gc_reference_stats(stats);\n   }"
  },
  {
    "sha": "a19e13ca2cf01c5e8d55292388eeb5fcf3587bf9",
    "filename": "src/hotspot/share/gc/serial/serialGcRefProcClosureContext.hpp",
    "status": "added",
    "additions": 60,
    "deletions": 0,
    "changes": 60,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/serial/serialGcRefProcClosureContext.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/serial/serialGcRefProcClosureContext.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/serial/serialGcRefProcClosureContext.hpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+#ifndef SHARE_GC_SERIAL_SERIALGCREFPROCCLOSURECONTEXT_HPP\n+#define SHARE_GC_SERIAL_SERIALGCREFPROCCLOSURECONTEXT_HPP\n+\n+#include \"gc/shared/referenceProcessor.hpp\"\n+\n+class SerialGCRefProcClosureContext : public AbstractRefProcClosureContext {\n+  BoolObjectClosure& _is_alive;\n+  OopClosure& _keep_alive;\n+  VoidClosure& _complete_gc;\n+\n+public:\n+  SerialGCRefProcClosureContext(BoolObjectClosure& is_alive,\n+                                OopClosure& keep_alive,\n+                                VoidClosure& complete_gc)\n+    : _is_alive(is_alive),\n+      _keep_alive(keep_alive),\n+      _complete_gc(complete_gc) {}\n+\n+  BoolObjectClosure* is_alive(uint worker_id) {\n+    return &_is_alive;\n+  }\n+\n+  OopClosure* keep_alive(uint worker_id) {\n+    return &_keep_alive;\n+  }\n+\n+  VoidClosure* complete_gc(uint worker_id) {\n+    return &_complete_gc;\n+  }\n+\n+  void prepare_run_task(uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"SerialGCRefProcClosureContext: prepare_run_task\");\n+  };\n+};\n+\n+#endif /* SHARE_GC_SERIAL_SERIALGCREFPROCCLOSURECONTEXT_HPP */"
  },
  {
    "sha": "8d2665074698f7762bc64ae9516497e33366d962",
    "filename": "src/hotspot/share/gc/shared/referenceProcessor.cpp",
    "status": "modified",
    "additions": 140,
    "deletions": 177,
    "changes": 317,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/shared/referenceProcessor.cpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/shared/referenceProcessor.cpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/shared/referenceProcessor.cpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -196,12 +196,8 @@ void ReferenceProcessor::verify_total_count_zero(DiscoveredList lists[], const c\n }\n #endif\n \n-ReferenceProcessorStats ReferenceProcessor::process_discovered_references(\n-  BoolObjectClosure*            is_alive,\n-  OopClosure*                   keep_alive,\n-  VoidClosure*                  complete_gc,\n-  AbstractRefProcTaskExecutor*  task_executor,\n-  ReferenceProcessorPhaseTimes* phase_times) {\n+ReferenceProcessorStats ReferenceProcessor::process_discovered_references(AbstractRefProcClosureContext& closure_context,\n+                                                                          ReferenceProcessorPhaseTimes& phase_times) {\n \n   double start_time = os::elapsedTime();\n \n@@ -225,29 +221,28 @@ ReferenceProcessorStats ReferenceProcessor::process_discovered_references(\n                                 total_count(_discoveredPhantomRefs));\n \n   {\n-    RefProcTotalPhaseTimesTracker tt(RefPhase1, phase_times, this);\n-    process_soft_ref_reconsider(is_alive, keep_alive, complete_gc,\n-                                task_executor, phase_times);\n+    RefProcTotalPhaseTimesTracker tt(RefPhase1, &phase_times, this);\n+    process_soft_ref_reconsider(closure_context, phase_times);\n   }\n \n   update_soft_ref_master_clock();\n \n   {\n-    RefProcTotalPhaseTimesTracker tt(RefPhase2, phase_times, this);\n-    process_soft_weak_final_refs(is_alive, keep_alive, complete_gc, task_executor, phase_times);\n+    RefProcTotalPhaseTimesTracker tt(RefPhase2, &phase_times, this);\n+    process_soft_weak_final_refs(closure_context, phase_times);\n   }\n \n   {\n-    RefProcTotalPhaseTimesTracker tt(RefPhase3, phase_times, this);\n-    process_final_keep_alive(keep_alive, complete_gc, task_executor, phase_times);\n+    RefProcTotalPhaseTimesTracker tt(RefPhase3, &phase_times, this);\n+    process_final_keep_alive(closure_context, phase_times);\n   }\n \n   {\n-    RefProcTotalPhaseTimesTracker tt(RefPhase4, phase_times, this);\n-    process_phantom_refs(is_alive, keep_alive, complete_gc, task_executor, phase_times);\n+    RefProcTotalPhaseTimesTracker tt(RefPhase4, &phase_times, this);\n+    process_phantom_refs(closure_context, phase_times);\n   }\n \n-  phase_times->set_total_time_ms((os::elapsedTime() - start_time) * 1000);\n+  phase_times.set_total_time_ms((os::elapsedTime() - start_time) * 1000);\n \n   return stats;\n }\n@@ -441,9 +436,9 @@ size_t ReferenceProcessor::process_final_keep_alive_work(DiscoveredList& refs_li\n }\n \n size_t ReferenceProcessor::process_phantom_refs_work(DiscoveredList&    refs_list,\n-                                          BoolObjectClosure* is_alive,\n-                                          OopClosure*        keep_alive,\n-                                          VoidClosure*       complete_gc) {\n+                                                     BoolObjectClosure* is_alive,\n+                                                     OopClosure*        keep_alive,\n+                                                     VoidClosure*       complete_gc) {\n   DiscoveredListIterator iter(refs_list, keep_alive, is_alive);\n   while (iter.has_next()) {\n     iter.load_ptrs(DEBUG_ONLY(!discovery_is_atomic() /* allow_null_referent */));\n@@ -516,105 +511,130 @@ size_t ReferenceProcessor::total_reference_count(ReferenceType type) const {\n   return total_count(list);\n }\n \n-class RefProcPhase1Task : public AbstractRefProcTaskExecutor::ProcessTask {\n+class RefProcTask : public AbstractGangTask {\n+protected:\n+  ReferenceProcessor& _ref_processor;\n+  ReferenceProcessorPhaseTimes* _phase_times;\n+  AbstractRefProcClosureContext& _closure_context;\n+\n public:\n-  RefProcPhase1Task(ReferenceProcessor&           ref_processor,\n+  RefProcTask(const char* name,\n+              ReferenceProcessor& ref_processor,\n+              ReferenceProcessorPhaseTimes* phase_times,\n+              AbstractRefProcClosureContext& closure_context)\n+    : AbstractGangTask(name),\n+      _ref_processor(ref_processor),\n+      _phase_times(phase_times),\n+      _closure_context(closure_context) {}\n+};\n+\n+class RefProcPhase1Task : public RefProcTask {\n+public:\n+  RefProcPhase1Task(ReferenceProcessor& ref_processor,\n                     ReferenceProcessorPhaseTimes* phase_times,\n-                    ReferencePolicy*              policy)\n-    : ProcessTask(ref_processor, true /* marks_oops_alive */, phase_times),\n+                    ReferencePolicy* policy,\n+                    AbstractRefProcClosureContext& closure_context)\n+    : RefProcTask(\"RefProcPhase1Task\",\n+                  ref_processor,\n+                  phase_times,\n+                  closure_context),\n       _policy(policy) { }\n \n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc)\n+  virtual void work(uint worker_id)\n   {\n+    ResourceMark rm;\n     RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::SoftRefSubPhase1, _phase_times, worker_id);\n     size_t const removed = _ref_processor.process_soft_ref_reconsider_work(_ref_processor._discoveredSoftRefs[worker_id],\n                                                                            _policy,\n-                                                                           &is_alive,\n-                                                                           &keep_alive,\n-                                                                           &complete_gc);\n+                                                                           _closure_context.is_alive(worker_id),\n+                                                                           _closure_context.keep_alive(worker_id),\n+                                                                           _closure_context.complete_gc(worker_id));\n     _phase_times->add_ref_cleared(REF_SOFT, removed);\n   }\n private:\n   ReferencePolicy* _policy;\n };\n \n-class RefProcPhase2Task: public AbstractRefProcTaskExecutor::ProcessTask {\n+class RefProcPhase2Task: public RefProcTask {\n   void run_phase2(uint worker_id,\n                   DiscoveredList list[],\n-                  BoolObjectClosure& is_alive,\n-                  OopClosure& keep_alive,\n+                  AbstractRefProcClosureContext& closure_context,\n                   bool do_enqueue_and_clear,\n                   ReferenceType ref_type) {\n     size_t const removed = _ref_processor.process_soft_weak_final_refs_work(list[worker_id],\n-                                                                            &is_alive,\n-                                                                            &keep_alive,\n+                                                                            closure_context.is_alive(worker_id),\n+                                                                            closure_context.keep_alive(worker_id),\n                                                                             do_enqueue_and_clear);\n     _phase_times->add_ref_cleared(ref_type, removed);\n   }\n \n public:\n   RefProcPhase2Task(ReferenceProcessor& ref_processor,\n-                    ReferenceProcessorPhaseTimes* phase_times)\n-    : ProcessTask(ref_processor, false /* marks_oops_alive */, phase_times) { }\n+                    ReferenceProcessorPhaseTimes* phase_times,\n+                    AbstractRefProcClosureContext& closure_context)\n+    : RefProcTask(\"RefProcPhase2Task\",\n+                  ref_processor,\n+                  phase_times,\n+                  closure_context) { }\n \n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc) {\n+  virtual void work(uint worker_id) {\n+    ResourceMark rm;\n     RefProcWorkerTimeTracker t(_phase_times->phase2_worker_time_sec(), worker_id);\n     {\n       RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::SoftRefSubPhase2, _phase_times, worker_id);\n-      run_phase2(worker_id, _ref_processor._discoveredSoftRefs, is_alive, keep_alive, true /* do_enqueue_and_clear */, REF_SOFT);\n+      run_phase2(worker_id, _ref_processor._discoveredSoftRefs, _closure_context, true /* do_enqueue_and_clear */, REF_SOFT);\n     }\n     {\n       RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::WeakRefSubPhase2, _phase_times, worker_id);\n-      run_phase2(worker_id, _ref_processor._discoveredWeakRefs, is_alive, keep_alive, true /* do_enqueue_and_clear */, REF_WEAK);\n+      run_phase2(worker_id, _ref_processor._discoveredWeakRefs, _closure_context, true /* do_enqueue_and_clear */, REF_WEAK);\n     }\n     {\n       RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::FinalRefSubPhase2, _phase_times, worker_id);\n-      run_phase2(worker_id, _ref_processor._discoveredFinalRefs, is_alive, keep_alive, false /* do_enqueue_and_clear */, REF_FINAL);\n+      run_phase2(worker_id, _ref_processor._discoveredFinalRefs, _closure_context, false /* do_enqueue_and_clear */, REF_FINAL);\n     }\n     // Close the reachable set; needed for collectors which keep_alive_closure do\n     // not immediately complete their work.\n-    complete_gc.do_void();\n+    _closure_context.complete_gc(worker_id)->do_void();\n   }\n };\n \n-class RefProcPhase3Task: public AbstractRefProcTaskExecutor::ProcessTask {\n+class RefProcPhase3Task: public RefProcTask {\n public:\n-  RefProcPhase3Task(ReferenceProcessor&           ref_processor,\n-                    ReferenceProcessorPhaseTimes* phase_times)\n-    : ProcessTask(ref_processor, true /* marks_oops_alive */, phase_times) { }\n-\n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc)\n+  RefProcPhase3Task(ReferenceProcessor& ref_processor,\n+                    ReferenceProcessorPhaseTimes* phase_times,\n+                    AbstractRefProcClosureContext& closure_context)\n+    : RefProcTask(\"RefProcPhase3Task\",\n+                  ref_processor,\n+                  phase_times,\n+                  closure_context) { }\n+\n+\n+  virtual void work(uint worker_id)\n   {\n+    ResourceMark rm;\n     RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::FinalRefSubPhase3, _phase_times, worker_id);\n-    _ref_processor.process_final_keep_alive_work(_ref_processor._discoveredFinalRefs[worker_id], &keep_alive, &complete_gc);\n+    _ref_processor.process_final_keep_alive_work(_ref_processor._discoveredFinalRefs[worker_id], _closure_context.keep_alive(worker_id), _closure_context.complete_gc(worker_id));\n   }\n };\n \n-class RefProcPhase4Task: public AbstractRefProcTaskExecutor::ProcessTask {\n+class RefProcPhase4Task: public RefProcTask {\n public:\n-  RefProcPhase4Task(ReferenceProcessor&           ref_processor,\n-                    ReferenceProcessorPhaseTimes* phase_times)\n-    : ProcessTask(ref_processor, false /* marks_oops_alive */, phase_times) { }\n-\n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc)\n+  RefProcPhase4Task(ReferenceProcessor& ref_processor,\n+                    ReferenceProcessorPhaseTimes* phase_times,\n+                    AbstractRefProcClosureContext& closure_context)\n+    : RefProcTask(\"RefProcPhase4Task\",\n+                  ref_processor,\n+                  phase_times,\n+                  closure_context) { }\n+\n+  virtual void work(uint worker_id)\n   {\n+    ResourceMark rm;\n     RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::PhantomRefSubPhase4, _phase_times, worker_id);\n     size_t const removed = _ref_processor.process_phantom_refs_work(_ref_processor._discoveredPhantomRefs[worker_id],\n-                                                                    &is_alive,\n-                                                                    &keep_alive,\n-                                                                    &complete_gc);\n+                                                                    _closure_context.is_alive(worker_id),\n+                                                                    _closure_context.keep_alive(worker_id),\n+                                                                    _closure_context.complete_gc(worker_id));\n     _phase_times->add_ref_cleared(REF_PHANTOM, removed);\n   }\n };\n@@ -771,16 +791,33 @@ void ReferenceProcessor::balance_queues(DiscoveredList ref_lists[])\n #endif\n }\n \n-void ReferenceProcessor::process_soft_ref_reconsider(BoolObjectClosure* is_alive,\n-                                                     OopClosure* keep_alive,\n-                                                     VoidClosure* complete_gc,\n-                                                     AbstractRefProcTaskExecutor* task_executor,\n-                                                     ReferenceProcessorPhaseTimes* phase_times) {\n-  assert(!processing_is_mt() || task_executor != NULL, \"Task executor must not be NULL when mt processing is set.\");\n+void ReferenceProcessor::run_task(AbstractGangTask& task, AbstractRefProcClosureContext& closure_context, bool marks_oops_alive) {\n+  WorkGang* gang = Universe::heap()->safepoint_workers();\n+  assert(gang != NULL || !processing_is_mt(), \"can not dispatch multi threaded without a work gang\");\n+  log_debug(gc, ref)(\"ReferenceProcessor::execute queues: %d, %s, marks_oops_alive: %s\",\n+                     num_queues(),\n+                     processing_is_mt() ? \"RefProcThreadModel::Multi\" : \"RefProcThreadModel::Single\",\n+                     marks_oops_alive ? \"true\" : \"false\");\n+\n+  closure_context.prepare_run_task(num_queues(), processing_is_mt() ? RefProcThreadModel::Multi : RefProcThreadModel::Single, marks_oops_alive);\n+  if (gang != NULL && processing_is_mt()) {\n+    assert(gang->active_workers() >= num_queues(),\n+           \"Ergonomically chosen workers(%u) should be less than or equal to active workers(%u)\",\n+           num_queues(), gang->active_workers());\n+    gang->run_task(&task, num_queues());\n+  } else {\n+    for (unsigned i = 0; i < _max_num_queues; ++i) {\n+      task.work(i);\n+    }\n+  }\n+}\n+\n+void ReferenceProcessor::process_soft_ref_reconsider(AbstractRefProcClosureContext& closure_context,\n+                                                     ReferenceProcessorPhaseTimes& phase_times) {\n \n   size_t const num_soft_refs = total_count(_discoveredSoftRefs);\n-  phase_times->set_ref_discovered(REF_SOFT, num_soft_refs);\n-  phase_times->set_processing_is_mt(processing_is_mt());\n+  phase_times.set_ref_discovered(REF_SOFT, num_soft_refs);\n+  phase_times.set_processing_is_mt(processing_is_mt());\n \n   if (num_soft_refs == 0) {\n     log_debug(gc, ref)(\"Skipped phase 1 of Reference Processing: no references\");\n@@ -795,45 +832,29 @@ void ReferenceProcessor::process_soft_ref_reconsider(BoolObjectClosure* is_alive\n   RefProcMTDegreeAdjuster a(this, RefPhase1, num_soft_refs);\n \n   if (processing_is_mt()) {\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase1, phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(RefPhase1, &phase_times);\n     maybe_balance_queues(_discoveredSoftRefs);\n   }\n \n-  RefProcPhaseTimeTracker tt(RefPhase1, phase_times);\n+  RefProcPhaseTimeTracker tt(RefPhase1, &phase_times);\n \n   log_reflist(\"Phase 1 Soft before\", _discoveredSoftRefs, _max_num_queues);\n-  if (processing_is_mt()) {\n-    RefProcPhase1Task phase1(*this, phase_times, _current_soft_ref_policy);\n-    task_executor->execute(phase1, num_queues());\n-  } else {\n-    size_t removed = 0;\n-\n-    RefProcSubPhasesWorkerTimeTracker tt2(SoftRefSubPhase1, phase_times, 0);\n-    for (uint i = 0; i < _max_num_queues; i++) {\n-      removed += process_soft_ref_reconsider_work(_discoveredSoftRefs[i], _current_soft_ref_policy,\n-                                                  is_alive, keep_alive, complete_gc);\n-    }\n-\n-    phase_times->add_ref_cleared(REF_SOFT, removed);\n-  }\n+  RefProcPhase1Task phase1(*this, &phase_times, _current_soft_ref_policy, closure_context);\n+  run_task(phase1, closure_context, true);\n   log_reflist(\"Phase 1 Soft after\", _discoveredSoftRefs, _max_num_queues);\n }\n \n-void ReferenceProcessor::process_soft_weak_final_refs(BoolObjectClosure* is_alive,\n-                                                      OopClosure* keep_alive,\n-                                                      VoidClosure* complete_gc,\n-                                                      AbstractRefProcTaskExecutor*  task_executor,\n-                                                      ReferenceProcessorPhaseTimes* phase_times) {\n-  assert(!processing_is_mt() || task_executor != NULL, \"Task executor must not be NULL when mt processing is set.\");\n+void ReferenceProcessor::process_soft_weak_final_refs(AbstractRefProcClosureContext& closure_context,\n+                                                      ReferenceProcessorPhaseTimes& phase_times) {\n \n   size_t const num_soft_refs = total_count(_discoveredSoftRefs);\n   size_t const num_weak_refs = total_count(_discoveredWeakRefs);\n   size_t const num_final_refs = total_count(_discoveredFinalRefs);\n   size_t const num_total_refs = num_soft_refs + num_weak_refs + num_final_refs;\n-  phase_times->set_ref_discovered(REF_WEAK, num_weak_refs);\n-  phase_times->set_ref_discovered(REF_FINAL, num_final_refs);\n+  phase_times.set_ref_discovered(REF_WEAK, num_weak_refs);\n+  phase_times.set_ref_discovered(REF_FINAL, num_final_refs);\n \n-  phase_times->set_processing_is_mt(processing_is_mt());\n+  phase_times.set_processing_is_mt(processing_is_mt());\n \n   if (num_total_refs == 0) {\n     log_debug(gc, ref)(\"Skipped phase 2 of Reference Processing: no references\");\n@@ -843,68 +864,31 @@ void ReferenceProcessor::process_soft_weak_final_refs(BoolObjectClosure* is_aliv\n   RefProcMTDegreeAdjuster a(this, RefPhase2, num_total_refs);\n \n   if (processing_is_mt()) {\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase2, phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(RefPhase2, &phase_times);\n     maybe_balance_queues(_discoveredSoftRefs);\n     maybe_balance_queues(_discoveredWeakRefs);\n     maybe_balance_queues(_discoveredFinalRefs);\n   }\n \n-  RefProcPhaseTimeTracker tt(RefPhase2, phase_times);\n+  RefProcPhaseTimeTracker tt(RefPhase2, &phase_times);\n \n   log_reflist(\"Phase 2 Soft before\", _discoveredSoftRefs, _max_num_queues);\n   log_reflist(\"Phase 2 Weak before\", _discoveredWeakRefs, _max_num_queues);\n   log_reflist(\"Phase 2 Final before\", _discoveredFinalRefs, _max_num_queues);\n-  if (processing_is_mt()) {\n-    RefProcPhase2Task phase2(*this, phase_times);\n-    task_executor->execute(phase2, num_queues());\n-  } else {\n-    RefProcWorkerTimeTracker t(phase_times->phase2_worker_time_sec(), 0);\n-    {\n-      size_t removed = 0;\n-\n-      RefProcSubPhasesWorkerTimeTracker tt2(SoftRefSubPhase2, phase_times, 0);\n-      for (uint i = 0; i < _max_num_queues; i++) {\n-        removed += process_soft_weak_final_refs_work(_discoveredSoftRefs[i], is_alive, keep_alive, true /* do_enqueue */);\n-      }\n-\n-      phase_times->add_ref_cleared(REF_SOFT, removed);\n-    }\n-    {\n-      size_t removed = 0;\n-\n-      RefProcSubPhasesWorkerTimeTracker tt2(WeakRefSubPhase2, phase_times, 0);\n-      for (uint i = 0; i < _max_num_queues; i++) {\n-        removed += process_soft_weak_final_refs_work(_discoveredWeakRefs[i], is_alive, keep_alive, true /* do_enqueue */);\n-      }\n \n-      phase_times->add_ref_cleared(REF_WEAK, removed);\n-    }\n-    {\n-      size_t removed = 0;\n-\n-      RefProcSubPhasesWorkerTimeTracker tt2(FinalRefSubPhase2, phase_times, 0);\n-      for (uint i = 0; i < _max_num_queues; i++) {\n-        removed += process_soft_weak_final_refs_work(_discoveredFinalRefs[i], is_alive, keep_alive, false /* do_enqueue */);\n-      }\n+  RefProcPhase2Task phase2(*this, &phase_times, closure_context);\n+  run_task(phase2, closure_context, false);\n \n-      phase_times->add_ref_cleared(REF_FINAL, removed);\n-    }\n-    complete_gc->do_void();\n-  }\n   verify_total_count_zero(_discoveredSoftRefs, \"SoftReference\");\n   verify_total_count_zero(_discoveredWeakRefs, \"WeakReference\");\n   log_reflist(\"Phase 2 Final after\", _discoveredFinalRefs, _max_num_queues);\n }\n \n-void ReferenceProcessor::process_final_keep_alive(OopClosure* keep_alive,\n-                                                  VoidClosure* complete_gc,\n-                                                  AbstractRefProcTaskExecutor*  task_executor,\n-                                                  ReferenceProcessorPhaseTimes* phase_times) {\n-  assert(!processing_is_mt() || task_executor != NULL, \"Task executor must not be NULL when mt processing is set.\");\n+void ReferenceProcessor::process_final_keep_alive(AbstractRefProcClosureContext& closure_context,\n+                                                  ReferenceProcessorPhaseTimes& phase_times) {\n \n   size_t const num_final_refs = total_count(_discoveredFinalRefs);\n-\n-  phase_times->set_processing_is_mt(processing_is_mt());\n+  phase_times.set_processing_is_mt(processing_is_mt());\n \n   if (num_final_refs == 0) {\n     log_debug(gc, ref)(\"Skipped phase 3 of Reference Processing: no references\");\n@@ -914,37 +898,25 @@ void ReferenceProcessor::process_final_keep_alive(OopClosure* keep_alive,\n   RefProcMTDegreeAdjuster a(this, RefPhase3, num_final_refs);\n \n   if (processing_is_mt()) {\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase3, phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(RefPhase3, &phase_times);\n     maybe_balance_queues(_discoveredFinalRefs);\n   }\n \n   // Phase 3:\n   // . Traverse referents of final references and keep them and followers alive.\n-  RefProcPhaseTimeTracker tt(RefPhase3, phase_times);\n+  RefProcPhaseTimeTracker tt(RefPhase3, &phase_times);\n+  RefProcPhase3Task phase3(*this, &phase_times, closure_context);\n+  run_task(phase3, closure_context, true);\n \n-  if (processing_is_mt()) {\n-    RefProcPhase3Task phase3(*this, phase_times);\n-    task_executor->execute(phase3, num_queues());\n-  } else {\n-    RefProcSubPhasesWorkerTimeTracker tt2(FinalRefSubPhase3, phase_times, 0);\n-    for (uint i = 0; i < _max_num_queues; i++) {\n-      process_final_keep_alive_work(_discoveredFinalRefs[i], keep_alive, complete_gc);\n-    }\n-  }\n   verify_total_count_zero(_discoveredFinalRefs, \"FinalReference\");\n }\n \n-void ReferenceProcessor::process_phantom_refs(BoolObjectClosure* is_alive,\n-                                              OopClosure* keep_alive,\n-                                              VoidClosure* complete_gc,\n-                                              AbstractRefProcTaskExecutor* task_executor,\n-                                              ReferenceProcessorPhaseTimes* phase_times) {\n-  assert(!processing_is_mt() || task_executor != NULL, \"Task executor must not be NULL when mt processing is set.\");\n+void ReferenceProcessor::process_phantom_refs(AbstractRefProcClosureContext& closure_context,\n+                                              ReferenceProcessorPhaseTimes& phase_times) {\n \n   size_t const num_phantom_refs = total_count(_discoveredPhantomRefs);\n-\n-  phase_times->set_ref_discovered(REF_PHANTOM, num_phantom_refs);\n-  phase_times->set_processing_is_mt(processing_is_mt());\n+  phase_times.set_ref_discovered(REF_PHANTOM, num_phantom_refs);\n+  phase_times.set_processing_is_mt(processing_is_mt());\n \n   if (num_phantom_refs == 0) {\n     log_debug(gc, ref)(\"Skipped phase 4 of Reference Processing: no references\");\n@@ -954,27 +926,18 @@ void ReferenceProcessor::process_phantom_refs(BoolObjectClosure* is_alive,\n   RefProcMTDegreeAdjuster a(this, RefPhase4, num_phantom_refs);\n \n   if (processing_is_mt()) {\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase4, phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(RefPhase4, &phase_times);\n     maybe_balance_queues(_discoveredPhantomRefs);\n   }\n \n   // Phase 4: Walk phantom references appropriately.\n-  RefProcPhaseTimeTracker tt(RefPhase4, phase_times);\n+  RefProcPhaseTimeTracker tt(RefPhase4, &phase_times);\n \n   log_reflist(\"Phase 4 Phantom before\", _discoveredPhantomRefs, _max_num_queues);\n-  if (processing_is_mt()) {\n-    RefProcPhase4Task phase4(*this, phase_times);\n-    task_executor->execute(phase4, num_queues());\n-  } else {\n-    size_t removed = 0;\n \n-    RefProcSubPhasesWorkerTimeTracker tt(PhantomRefSubPhase4, phase_times, 0);\n-    for (uint i = 0; i < _max_num_queues; i++) {\n-      removed += process_phantom_refs_work(_discoveredPhantomRefs[i], is_alive, keep_alive, complete_gc);\n-    }\n+  RefProcPhase4Task phase4(*this, &phase_times, closure_context);\n+  run_task(phase4, closure_context, false);\n \n-    phase_times->add_ref_cleared(REF_PHANTOM, removed);\n-  }\n   verify_total_count_zero(_discoveredPhantomRefs, \"PhantomReference\");\n }\n "
  },
  {
    "sha": "eb001a9a666fccf79b95970800c4ce96f3c27273",
    "filename": "src/hotspot/share/gc/shared/referenceProcessor.hpp",
    "status": "modified",
    "additions": 21,
    "deletions": 59,
    "changes": 80,
    "blob_url": "https://github.com/openjdk/jdk/blob/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/shared/referenceProcessor.hpp",
    "raw_url": "https://github.com/openjdk/jdk/raw/bd25f98d13caf7f9955898bcd98e9720dc27768a/src/hotspot/share/gc/shared/referenceProcessor.hpp",
    "contents_url": "https://api.github.com/repos/openjdk/jdk/contents/src/hotspot/share/gc/shared/referenceProcessor.hpp?ref=bd25f98d13caf7f9955898bcd98e9720dc27768a",
    "patch": "@@ -28,10 +28,11 @@\n #include \"gc/shared/referenceDiscoverer.hpp\"\n #include \"gc/shared/referencePolicy.hpp\"\n #include \"gc/shared/referenceProcessorStats.hpp\"\n+#include \"gc/shared/workgroup.hpp\"\n #include \"memory/referenceType.hpp\"\n #include \"oops/instanceRefKlass.hpp\"\n \n-class AbstractRefProcTaskExecutor;\n+class AbstractRefProcClosureContext;\n class GCTimer;\n class ReferencePolicy;\n class ReferenceProcessorPhaseTimes;\n@@ -235,33 +236,24 @@ class ReferenceProcessor : public ReferenceDiscoverer {\n   DiscoveredList* _discoveredFinalRefs;\n   DiscoveredList* _discoveredPhantomRefs;\n \n+  void run_task(AbstractGangTask& task, AbstractRefProcClosureContext& closure_context, bool marks_oops_alive);\n+\n   // Phase 1: Re-evaluate soft ref policy.\n-  void process_soft_ref_reconsider(BoolObjectClosure* is_alive,\n-                                   OopClosure* keep_alive,\n-                                   VoidClosure* complete_gc,\n-                                   AbstractRefProcTaskExecutor*  task_executor,\n-                                   ReferenceProcessorPhaseTimes* phase_times);\n+  void process_soft_ref_reconsider(AbstractRefProcClosureContext& closure_context,\n+                                   ReferenceProcessorPhaseTimes& phase_times);\n \n   // Phase 2: Drop Soft/Weak/Final references with a NULL or live referent, and clear\n   // and enqueue non-Final references.\n-  void process_soft_weak_final_refs(BoolObjectClosure* is_alive,\n-                                    OopClosure* keep_alive,\n-                                    VoidClosure* complete_gc,\n-                                    AbstractRefProcTaskExecutor*  task_executor,\n-                                    ReferenceProcessorPhaseTimes* phase_times);\n+  void process_soft_weak_final_refs(AbstractRefProcClosureContext& closure_context,\n+                                    ReferenceProcessorPhaseTimes& phase_times);\n \n   // Phase 3: Keep alive followers of Final references, and enqueue.\n-  void process_final_keep_alive(OopClosure* keep_alive,\n-                                VoidClosure* complete_gc,\n-                                AbstractRefProcTaskExecutor*  task_executor,\n-                                ReferenceProcessorPhaseTimes* phase_times);\n+  void process_final_keep_alive(AbstractRefProcClosureContext& closure_context,\n+                                ReferenceProcessorPhaseTimes& phase_times);\n \n   // Phase 4: Drop and keep alive live Phantom references, or clear and enqueue if dead.\n-  void process_phantom_refs(BoolObjectClosure* is_alive,\n-                            OopClosure* keep_alive,\n-                            VoidClosure* complete_gc,\n-                            AbstractRefProcTaskExecutor*  task_executor,\n-                            ReferenceProcessorPhaseTimes* phase_times);\n+  void process_phantom_refs(AbstractRefProcClosureContext& closure_context,\n+                            ReferenceProcessorPhaseTimes& phase_times);\n \n   // Work methods used by the process_* methods. All methods return the number of\n   // removed elements.\n@@ -432,11 +424,8 @@ class ReferenceProcessor : public ReferenceDiscoverer {\n \n   // Process references found during GC (called by the garbage collector)\n   ReferenceProcessorStats\n-  process_discovered_references(BoolObjectClosure*            is_alive,\n-                                OopClosure*                   keep_alive,\n-                                VoidClosure*                  complete_gc,\n-                                AbstractRefProcTaskExecutor*  task_executor,\n-                                ReferenceProcessorPhaseTimes* phase_times);\n+  process_discovered_references(AbstractRefProcClosureContext&  closure_context,\n+                                ReferenceProcessorPhaseTimes& phase_times);\n \n   // If a discovery is in process that is being superceded, abandon it: all\n   // the discovered lists will be empty, and all the objects on them will\n@@ -596,42 +585,15 @@ class ReferenceProcessorAtomicMutator: StackObj {\n   }\n };\n \n-// This class is an interface used to implement task execution for the\n-// reference processing.\n-class AbstractRefProcTaskExecutor {\n-public:\n-\n-  // Abstract tasks to execute.\n-  class ProcessTask;\n-\n-  // Executes a task using worker threads.\n-  virtual void execute(ProcessTask& task, uint ergo_workers) = 0;\n-};\n-\n-// Abstract reference processing task to execute.\n-class AbstractRefProcTaskExecutor::ProcessTask {\n-protected:\n-  ReferenceProcessor&           _ref_processor;\n-  // Indicates whether the phase could generate work that should be balanced across\n-  // threads after execution.\n-  bool                          _marks_oops_alive;\n-  ReferenceProcessorPhaseTimes* _phase_times;\n-\n-  ProcessTask(ReferenceProcessor& ref_processor,\n-              bool marks_oops_alive,\n-              ReferenceProcessorPhaseTimes* phase_times)\n-    : _ref_processor(ref_processor),\n-      _marks_oops_alive(marks_oops_alive),\n-      _phase_times(phase_times)\n-  { }\n+enum class RefProcThreadModel { Multi, Single };\n \n+class AbstractRefProcClosureContext {\n public:\n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc) = 0;\n-\n-  bool marks_oops_alive() const { return _marks_oops_alive; }\n+  virtual BoolObjectClosure* is_alive(uint worker_id) = 0;\n+  virtual OopClosure* keep_alive(uint worker_id) = 0;\n+  virtual VoidClosure* complete_gc(uint worker_id) = 0;\n+  virtual void prepare_run_task(uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) = 0;\n+  uint index(uint id, RefProcThreadModel tm) { return (tm == RefProcThreadModel::Single) ? 0 : id; }\n };\n \n // Temporarily change the number of workers based on given reference count."
  }
]
