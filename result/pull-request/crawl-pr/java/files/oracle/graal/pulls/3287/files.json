[
  {
    "sha": "858f2f1c244dbb632980cba2b279eb7be4792cbb",
    "filename": "substratevm/src/com.oracle.graal.pointsto/src/com/oracle/graal/pointsto/reports/ReportUtils.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/oracle/graal/blob/21f5e66b7a87c2dbf26fe1630441388300c3393b/substratevm/src/com.oracle.graal.pointsto/src/com/oracle/graal/pointsto/reports/ReportUtils.java",
    "raw_url": "https://github.com/oracle/graal/raw/21f5e66b7a87c2dbf26fe1630441388300c3393b/substratevm/src/com.oracle.graal.pointsto/src/com/oracle/graal/pointsto/reports/ReportUtils.java",
    "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm/src/com.oracle.graal.pointsto/src/com/oracle/graal/pointsto/reports/ReportUtils.java?ref=21f5e66b7a87c2dbf26fe1630441388300c3393b",
    "patch": "@@ -104,7 +104,7 @@ private static void reportImpl(String description, Path folder, String fileName,\n             try (FileWriter fw = new FileWriter(Files.createFile(file).toFile())) {\n                 try (PrintWriter writer = new PrintWriter(fw)) {\n                     Path cwd = Paths.get(\"\").toAbsolutePath();\n-                    System.out.println(\"# Printing \" + description + \" to: \" + cwd.relativize(file));\n+                    System.out.println(\"# Printing \" + description + \" to: \" + cwd.relativize(file.toAbsolutePath()));\n                     reporter.accept(writer);\n                 }\n             }"
  },
  {
    "sha": "0871ac9a28c6c6033118688910a2ee59a42157f7",
    "filename": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/SubstitutionReportFeature.java",
    "status": "added",
    "additions": 208,
    "deletions": 0,
    "changes": 208,
    "blob_url": "https://github.com/oracle/graal/blob/21f5e66b7a87c2dbf26fe1630441388300c3393b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/SubstitutionReportFeature.java",
    "raw_url": "https://github.com/oracle/graal/raw/21f5e66b7a87c2dbf26fe1630441388300c3393b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/SubstitutionReportFeature.java",
    "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/SubstitutionReportFeature.java?ref=21f5e66b7a87c2dbf26fe1630441388300c3393b",
    "patch": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.hosted;\n+\n+import com.oracle.graal.pointsto.infrastructure.OriginalClassProvider;\n+import com.oracle.graal.pointsto.meta.AnalysisField;\n+import com.oracle.graal.pointsto.meta.AnalysisMethod;\n+import com.oracle.graal.pointsto.meta.AnalysisType;\n+import com.oracle.graal.pointsto.meta.AnalysisUniverse;\n+import com.oracle.graal.pointsto.reports.ReportUtils;\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.option.HostedOptionKey;\n+import com.oracle.svm.hosted.c.GraalAccess;\n+import com.oracle.svm.hosted.substitute.SubstitutionField;\n+import com.oracle.svm.hosted.substitute.SubstitutionMethod;\n+import com.oracle.svm.hosted.substitute.SubstitutionType;\n+import jdk.vm.ci.meta.ResolvedJavaField;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import jdk.vm.ci.meta.ResolvedJavaType;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.nativeimage.hosted.Feature;\n+\n+import java.security.CodeSource;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.function.Function;\n+\n+@AutomaticFeature\n+public class SubstitutionReportFeature implements Feature {\n+\n+    static class Options {\n+        @Option(help = \"Report performed substitutions\")//\n+        public static final HostedOptionKey<Boolean> ReportPerformedSubstitutions = new HostedOptionKey<>(false);\n+    }\n+\n+    private final boolean enabled = Options.ReportPerformedSubstitutions.getValue();\n+    private final Map<String, Substitutions> substitutions = new TreeMap<>();\n+\n+    @Override\n+    public boolean isInConfiguration(IsInConfigurationAccess access) {\n+        return enabled;\n+    }\n+\n+    @Override\n+    public void afterAnalysis(AfterAnalysisAccess access) {\n+        FeatureImpl.AfterAnalysisAccessImpl accessImpl = (FeatureImpl.AfterAnalysisAccessImpl) access;\n+        findSubstitutedTypes(accessImpl);\n+        findSubstitutedMethods(accessImpl);\n+        findSubstitutedFields(accessImpl);\n+        reportSubstitutions();\n+    }\n+\n+    private void findSubstitutedTypes(FeatureImpl.AfterAnalysisAccessImpl access) {\n+        AnalysisUniverse universe = access.getUniverse();\n+        for (AnalysisType type : universe.getTypes()) {\n+            if (type.isReachable() && !type.isArray()) {\n+                ResolvedJavaType t = type.getWrappedWithoutResolve();\n+                if (t instanceof SubstitutionType) {\n+                    SubstitutionType subType = (SubstitutionType) t;\n+                    if (subType.isUserSubstitution()) {\n+                        String jarLocation = getJarLocation(subType.getAnnotated());\n+                        substitutions.putIfAbsent(jarLocation, new Substitutions());\n+                        substitutions.get(jarLocation).addType(subType);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void findSubstitutedMethods(FeatureImpl.AfterAnalysisAccessImpl access) {\n+        AnalysisUniverse universe = access.getUniverse();\n+        for (AnalysisMethod method : universe.getMethods()) {\n+            if (method.wrapped instanceof SubstitutionMethod) {\n+                SubstitutionMethod subMethod = (SubstitutionMethod) method.wrapped;\n+                if (subMethod.isUserSubstitution()) {\n+                    String jarLocation = getJarLocation(subMethod.getAnnotated().getDeclaringClass());\n+                    substitutions.putIfAbsent(jarLocation, new Substitutions());\n+                    substitutions.get(jarLocation).addMethod(subMethod);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void findSubstitutedFields(FeatureImpl.AfterAnalysisAccessImpl access) {\n+        AnalysisUniverse universe = access.getUniverse();\n+        for (AnalysisField field : universe.getFields()) {\n+            if (field.wrapped instanceof SubstitutionField) {\n+                SubstitutionField subField = (SubstitutionField) field.wrapped;\n+                if (subField.isUserSubstitution()) {\n+                    String jarLocation = getJarLocation(subField.getAnnotated().getDeclaringClass());\n+                    substitutions.putIfAbsent(jarLocation, new Substitutions());\n+                    substitutions.get(jarLocation).addField(subField);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void reportSubstitutions() {\n+        ReportUtils.report(\"substitutions performed by native-image\", \"reports\", \"substitutions\", \"csv\", pw -> {\n+            pw.println(\"location , category (type/method/field) , original , annotated\");\n+            for (Map.Entry<String, Substitutions> g : substitutions.entrySet()) {\n+                for (Map.Entry<ResolvedJavaType, ResolvedJavaType> e : g.getValue().getSubstitutedTypes().entrySet()) {\n+                    pw.println(formatSubstitution(g.getKey(), \"type\", e.getKey(), e.getValue(), t -> t.toJavaName(true)));\n+                }\n+                for (Map.Entry<ResolvedJavaMethod, ResolvedJavaMethod> e : g.getValue().getSubstitutedMethods().entrySet()) {\n+                    pw.println(formatSubstitution(g.getKey(), \"method\", e.getKey(), e.getValue(), this::formatMethod));\n+                }\n+                for (Map.Entry<ResolvedJavaField, ResolvedJavaField> e : g.getValue().getSubstitutedFields().entrySet()) {\n+                    pw.println(formatSubstitution(g.getKey(), \"field\", e.getKey(), e.getValue(), this::formatField));\n+                }\n+            }\n+        });\n+    }\n+\n+    private String getJarLocation(ResolvedJavaType type) {\n+        Class<?> annotatedClass = OriginalClassProvider.getJavaClass(GraalAccess.getOriginalSnippetReflection(), type);\n+        CodeSource source = annotatedClass.getProtectionDomain().getCodeSource();\n+        return source == null ? \"unknown\" : source.getLocation().toString();\n+    }\n+\n+    private String formatMethod(ResolvedJavaMethod method) {\n+        return method.getDeclaringClass().toJavaName(true) + \"#\" + method.getName();\n+    }\n+\n+    private String formatField(ResolvedJavaField field) {\n+        return field.getDeclaringClass().toJavaName(true) + \".\" + field.getName();\n+    }\n+\n+    private <T> String formatSubstitution(String jar, String type, T original, T annotated, Function<T, String> formatter) {\n+        return '\\'' + jar + \"',\" + type + ',' + formatter.apply(original) + ',' + formatter.apply(annotated);\n+    }\n+\n+    private static class Substitutions {\n+        private final Map<ResolvedJavaType, ResolvedJavaType> substitutedTypes = new TreeMap<>(new ResolvedJavaTypeComparator());\n+        private final Map<ResolvedJavaMethod, ResolvedJavaMethod> substitutedMethods = new TreeMap<>(new ResolvedJavaMethodComparator());\n+        private final Map<ResolvedJavaField, ResolvedJavaField> substitutedFields = new TreeMap<>(new ResolvedJavaFieldComparator());\n+\n+        public void addType(SubstitutionType type) {\n+            substitutedTypes.put(type.getOriginal(), type.getAnnotated());\n+        }\n+\n+        public void addMethod(SubstitutionMethod method) {\n+            substitutedMethods.put(method.getOriginal(), method.getAnnotated());\n+        }\n+\n+        public void addField(SubstitutionField field) {\n+            substitutedFields.put(field.getOriginal(), field.getAnnotated());\n+        }\n+\n+        public Map<ResolvedJavaType, ResolvedJavaType> getSubstitutedTypes() {\n+            return substitutedTypes;\n+        }\n+\n+        public Map<ResolvedJavaMethod, ResolvedJavaMethod> getSubstitutedMethods() {\n+            return substitutedMethods;\n+        }\n+\n+        public Map<ResolvedJavaField, ResolvedJavaField> getSubstitutedFields() {\n+            return substitutedFields;\n+        }\n+\n+        private static class ResolvedJavaTypeComparator implements Comparator<ResolvedJavaType> {\n+            @Override\n+            public int compare(ResolvedJavaType t1, ResolvedJavaType t2) {\n+                return t1.toJavaName(true).compareTo(t2.toJavaName(true));\n+            }\n+        }\n+\n+        private static class ResolvedJavaMethodComparator implements Comparator<ResolvedJavaMethod> {\n+            @Override\n+            public int compare(ResolvedJavaMethod m1, ResolvedJavaMethod m2) {\n+                int cmp = m1.getDeclaringClass().toJavaName(true).compareTo(m2.getDeclaringClass().toJavaName(true));\n+                return cmp != 0 ? cmp : m1.getName().compareTo(m2.getName());\n+            }\n+        }\n+\n+        private static class ResolvedJavaFieldComparator implements Comparator<ResolvedJavaField> {\n+            @Override\n+            public int compare(ResolvedJavaField f1, ResolvedJavaField f2) {\n+                int cmp = f1.getDeclaringClass().toJavaName(true).compareTo(f2.getDeclaringClass().toJavaName(true));\n+                return cmp != 0 ? cmp : f1.getName().compareTo(f2.getName());\n+            }\n+        }\n+    }\n+}"
  },
  {
    "sha": "42a290e24657200f2a099896a8c00794e2eaa95d",
    "filename": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/AnnotationSubstitutionProcessor.java",
    "status": "modified",
    "additions": 5,
    "deletions": 5,
    "changes": 10,
    "blob_url": "https://github.com/oracle/graal/blob/21f5e66b7a87c2dbf26fe1630441388300c3393b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/AnnotationSubstitutionProcessor.java",
    "raw_url": "https://github.com/oracle/graal/raw/21f5e66b7a87c2dbf26fe1630441388300c3393b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/AnnotationSubstitutionProcessor.java",
    "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/AnnotationSubstitutionProcessor.java?ref=21f5e66b7a87c2dbf26fe1630441388300c3393b",
    "patch": "@@ -202,7 +202,7 @@ public ResolvedJavaMethod lookup(ResolvedJavaMethod method) {\n                 }\n \n                 PolymorphicSignatureWrapperMethod wrapperMethod = new PolymorphicSignatureWrapperMethod(substitutionBaseMethod, method);\n-                SubstitutionMethod substitutionMethod = new SubstitutionMethod(method, wrapperMethod);\n+                SubstitutionMethod substitutionMethod = new SubstitutionMethod(method, wrapperMethod, false, true);\n                 synchronized (methodSubstitutions) {\n                     /*\n                      * It may happen that, during analysis, two threads are trying to register the\n@@ -380,7 +380,7 @@ private void handleMethodInAliasClass(Executable annotatedMethod, Class<?> origi\n             }\n             registerAsDeleted(annotated, original, deleteAnnotation);\n         } else if (substituteAnnotation != null) {\n-            SubstitutionMethod substitution = new SubstitutionMethod(original, annotated);\n+            SubstitutionMethod substitution = new SubstitutionMethod(original, annotated, false, true);\n             if (substituteAnnotation.polymorphicSignature()) {\n                 register(polymorphicMethodSubstitutions, annotated, original, substitution);\n             }\n@@ -578,7 +578,7 @@ private void handleSubstitutionClass(Class<?> annotatedClass, Class<?> originalC\n         ResolvedJavaType annotated = metaAccess.lookupJavaType(annotatedClass);\n \n         for (int i = 0; i < ARRAY_DIMENSIONS; i++) {\n-            ResolvedJavaType substitution = new SubstitutionType(original, annotated);\n+            ResolvedJavaType substitution = new SubstitutionType(original, annotated, true);\n             register(typeSubstitutions, annotated, original, substitution);\n \n             original = original.getArrayClass();\n@@ -640,7 +640,7 @@ private void handleAnnotatedMethodInSubstitutionClass(Executable annotatedMethod\n         if (original == null) {\n             /* Optional target that is not present, so nothing to do. */\n         } else if (substituteAnnotation != null) {\n-            SubstitutionMethod substitution = new SubstitutionMethod(original, annotated, true);\n+            SubstitutionMethod substitution = new SubstitutionMethod(original, annotated, true, true);\n             if (substituteAnnotation.polymorphicSignature()) {\n                 register(polymorphicMethodSubstitutions, annotated, original, substitution);\n             }\n@@ -664,7 +664,7 @@ private void handleAnnotatedFieldInSubstitutionClass(Field annotatedField, Class\n         if (original == null) {\n             /* Optional target that is not present, so nothing to do. */\n         } else {\n-            register(fieldSubstitutions, annotated, original, new SubstitutionField(original, annotated));\n+            register(fieldSubstitutions, annotated, original, new SubstitutionField(original, annotated, true));\n         }\n     }\n "
  },
  {
    "sha": "e630cbdfc6007b4b110e0f15dc452b3911a20f5e",
    "filename": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/SubstitutionField.java",
    "status": "modified",
    "additions": 15,
    "deletions": 0,
    "changes": 15,
    "blob_url": "https://github.com/oracle/graal/blob/21f5e66b7a87c2dbf26fe1630441388300c3393b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/SubstitutionField.java",
    "raw_url": "https://github.com/oracle/graal/raw/21f5e66b7a87c2dbf26fe1630441388300c3393b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/SubstitutionField.java",
    "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/SubstitutionField.java?ref=21f5e66b7a87c2dbf26fe1630441388300c3393b",
    "patch": "@@ -41,9 +41,20 @@\n     private final ResolvedJavaField original;\n     private final ResolvedJavaField annotated;\n \n+    /**\n+     * This field is used in the {@link com.oracle.svm.hosted.SubstitutionReportFeature} class to\n+     * determine {@link SubstitutionMethod} objects which correspond to annotated substitutions.\n+     */\n+    private final boolean isUserSubstitution;\n+\n     public SubstitutionField(ResolvedJavaField original, ResolvedJavaField annotated) {\n+        this(original, annotated, false);\n+    }\n+\n+    public SubstitutionField(ResolvedJavaField original, ResolvedJavaField annotated, boolean isUserSubstitution) {\n         this.original = original;\n         this.annotated = annotated;\n+        this.isUserSubstitution = isUserSubstitution;\n     }\n \n     @Override\n@@ -70,6 +81,10 @@ public JavaConstant readValue(JavaConstant receiver) {\n         return value;\n     }\n \n+    public boolean isUserSubstitution() {\n+        return isUserSubstitution;\n+    }\n+\n     public ResolvedJavaField getOriginal() {\n         return original;\n     }"
  },
  {
    "sha": "3b1fd41aba498c25c5b68742951d661bfc8a499f",
    "filename": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/SubstitutionMethod.java",
    "status": "modified",
    "additions": 16,
    "deletions": 1,
    "changes": 17,
    "blob_url": "https://github.com/oracle/graal/blob/21f5e66b7a87c2dbf26fe1630441388300c3393b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/SubstitutionMethod.java",
    "raw_url": "https://github.com/oracle/graal/raw/21f5e66b7a87c2dbf26fe1630441388300c3393b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/SubstitutionMethod.java",
    "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/SubstitutionMethod.java?ref=21f5e66b7a87c2dbf26fe1630441388300c3393b",
    "patch": "@@ -58,14 +58,25 @@\n     private final LocalVariableTable localVariableTable;\n     private final boolean inClassSubstitution;\n \n+    /**\n+     * This field is used in the {@link com.oracle.svm.hosted.SubstitutionReportFeature} class to\n+     * determine {@link SubstitutionMethod} objects which correspond to annotated substitutions.\n+     */\n+    private final boolean isUserSubstitution;\n+\n     public SubstitutionMethod(ResolvedJavaMethod original, ResolvedJavaMethod annotated) {\n-        this(original, annotated, false);\n+        this(original, annotated, false, false);\n     }\n \n     public SubstitutionMethod(ResolvedJavaMethod original, ResolvedJavaMethod annotated, boolean inClassSubstitution) {\n+        this(original, annotated, inClassSubstitution, false);\n+    }\n+\n+    public SubstitutionMethod(ResolvedJavaMethod original, ResolvedJavaMethod annotated, boolean inClassSubstitution, boolean isUserSubstitution) {\n         this.original = original;\n         this.annotated = annotated;\n         this.inClassSubstitution = inClassSubstitution;\n+        this.isUserSubstitution = isUserSubstitution;\n \n         LocalVariableTable newLocalVariableTable = null;\n         if (annotated.getLocalVariableTable() != null) {\n@@ -86,6 +97,10 @@ public SubstitutionMethod(ResolvedJavaMethod original, ResolvedJavaMethod annota\n         localVariableTable = newLocalVariableTable;\n     }\n \n+    public boolean isUserSubstitution() {\n+        return isUserSubstitution;\n+    }\n+\n     public ResolvedJavaMethod getOriginal() {\n         return original;\n     }"
  },
  {
    "sha": "7c1f43461ff3c9966b43a92c4a4a9fa6c0b37fb0",
    "filename": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/SubstitutionType.java",
    "status": "modified",
    "additions": 15,
    "deletions": 0,
    "changes": 15,
    "blob_url": "https://github.com/oracle/graal/blob/21f5e66b7a87c2dbf26fe1630441388300c3393b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/SubstitutionType.java",
    "raw_url": "https://github.com/oracle/graal/raw/21f5e66b7a87c2dbf26fe1630441388300c3393b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/SubstitutionType.java",
    "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/SubstitutionType.java?ref=21f5e66b7a87c2dbf26fe1630441388300c3393b",
    "patch": "@@ -43,9 +43,24 @@\n     private final ResolvedJavaType original;\n     private final ResolvedJavaType annotated;\n \n+    /**\n+     * This field is used in the {@link com.oracle.svm.hosted.SubstitutionReportFeature} class to\n+     * determine {@link SubstitutionType} objects which correspond to type.\n+     */\n+    private final boolean isUserSubstitution;\n+\n     public SubstitutionType(ResolvedJavaType original, ResolvedJavaType annotated) {\n+        this(original, annotated, false);\n+    }\n+\n+    public SubstitutionType(ResolvedJavaType original, ResolvedJavaType annotated, boolean isUserSubstitution) {\n         this.annotated = annotated;\n         this.original = original;\n+        this.isUserSubstitution = isUserSubstitution;\n+    }\n+\n+    public boolean isUserSubstitution() {\n+        return isUserSubstitution;\n     }\n \n     public ResolvedJavaType getOriginal() {"
  }
]
