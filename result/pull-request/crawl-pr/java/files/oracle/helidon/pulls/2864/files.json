[
  {
    "sha": "c9eb7e44910723781ee745e8eaa43cfa2642f8e2",
    "filename": "common/reactive/src/main/java/io/helidon/common/reactive/ByteChannelSubscriber.java",
    "status": "added",
    "additions": 108,
    "deletions": 0,
    "changes": 108,
    "blob_url": "https://github.com/oracle/helidon/blob/0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76/common/reactive/src/main/java/io/helidon/common/reactive/ByteChannelSubscriber.java",
    "raw_url": "https://github.com/oracle/helidon/raw/0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76/common/reactive/src/main/java/io/helidon/common/reactive/ByteChannelSubscriber.java",
    "contents_url": "https://api.github.com/repos/oracle/helidon/contents/common/reactive/src/main/java/io/helidon/common/reactive/ByteChannelSubscriber.java?ref=0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76",
    "patch": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright (c) 2021 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package io.helidon.common.reactive;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Flow;\n+\n+class ByteChannelSubscriber extends CompletionSingle<Void> implements Flow.Subscriber<ByteBuffer> {\n+    private final ExecutorService executorService;\n+    private Flow.Subscription subscription;\n+    private final WritableByteChannel byteChannel;\n+    private final Executor executor;\n+    private final CompletableFuture<Void> completed = new CompletableFuture<>();\n+    private volatile CompletableFuture<Void> lastWriteFinished = CompletableFuture.completedFuture(null);\n+\n+    ByteChannelSubscriber(WritableByteChannel byteChannel, ExecutorService executor) {\n+        this.byteChannel = byteChannel;\n+        this.executor = executor;\n+        this.executorService = executor;\n+    }\n+\n+    ByteChannelSubscriber(WritableByteChannel byteChannel, Executor executor) {\n+        this.byteChannel = byteChannel;\n+        this.executor = executor;\n+        this.executorService = null;\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Flow.Subscription subscription) {\n+        this.subscription = subscription;\n+        this.subscription.request(1L);\n+    }\n+\n+    @Override\n+    public void onNext(final ByteBuffer nextByteBuffer) {\n+        lastWriteFinished = CompletableFuture.runAsync(() -> {\n+            try {\n+                for (;;) {\n+                    byteChannel.write(nextByteBuffer);\n+                    if (nextByteBuffer.remaining() == 0) break;\n+                    Thread.onSpinWait();\n+                }\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, executor)\n+                .exceptionally(throwable -> {\n+                    subscription.cancel();\n+                    completed.completeExceptionally(throwable);\n+                    return null;\n+                })\n+                .thenRun(() -> {\n+                    // request one by one, concurrent writes are not possible\n+                    subscription.request(1L);\n+                });\n+    }\n+\n+    @Override\n+    public void onError(final Throwable throwable) {\n+        try {\n+            byteChannel.close();\n+        } catch (IOException e) {\n+            throwable.addSuppressed(e);\n+        }\n+        completed.completeExceptionally(throwable);\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        lastWriteFinished.thenRun(() -> {\n+            try {\n+                byteChannel.close();\n+                completed.complete(null);\n+            } catch (IOException e) {\n+                completed.completeExceptionally(e);\n+            } finally {\n+                if (executorService != null) {\n+                    executorService.shutdown();\n+                }\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void subscribe(final Flow.Subscriber<? super Void> subscriber) {\n+        Single.create(completed, true).subscribe(subscriber);\n+    }\n+}"
  },
  {
    "sha": "92287fbbfd7a4a4cac489a88bb81a44b297eeff6",
    "filename": "common/reactive/src/main/java/io/helidon/common/reactive/IoMulti.java",
    "status": "modified",
    "additions": 114,
    "deletions": 1,
    "changes": 115,
    "blob_url": "https://github.com/oracle/helidon/blob/0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76/common/reactive/src/main/java/io/helidon/common/reactive/IoMulti.java",
    "raw_url": "https://github.com/oracle/helidon/raw/0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76/common/reactive/src/main/java/io/helidon/common/reactive/IoMulti.java",
    "contents_url": "https://api.github.com/repos/oracle/helidon/contents/common/reactive/src/main/java/io/helidon/common/reactive/IoMulti.java?ref=0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2020 Oracle and/or its affiliates.\n+ * Copyright (c) 2020, 2021 Oracle and/or its affiliates.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,18 +17,26 @@\n \n package io.helidon.common.reactive;\n \n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.util.Objects;\n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.BiConsumer;\n+import java.util.function.Function;\n \n import io.helidon.common.Builder;\n import io.helidon.common.LazyValue;\n@@ -164,6 +172,69 @@ static MultiFromInputStreamBuilder multiFromStreamBuilder(final InputStream inpu\n         return multiFromByteChannelBuilder(byteChannel).build();\n     }\n \n+    /**\n+     * Creates function consuming {@code Multi<ByteBuffer>} to supplied {@link WritableByteChannel}.\n+     * <br>\n+     * Example usage:\n+     * <pre>{@code\n+     * Multi.create(listOfByteBuffers)\n+     *      .map(s -> ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8)))\n+     *      .to(IoMulti.multiToByteChannel(fileChannel))\n+     *      .await();\n+     * }</pre>\n+     *\n+     * @param writableChannel for consuming ByteBuffers from upstream\n+     * @return mapper consuming {@code Multi<ByteBuffer>} and returning Single for observing asynchronous writing.\n+     */\n+    static Function<? super Multi<ByteBuffer>, ? extends Single<Void>> multiToByteChannel(WritableByteChannel writableChannel) {\n+        return multiToByteChannelBuilder(writableChannel).build();\n+    }\n+\n+    /**\n+     * Creates function consuming {@code Multi<ByteBuffer>} to supplied {@link WritableByteChannel}.\n+     * <br>\n+     * Example usage:\n+     * <pre>{@code\n+     * Multi.create(listOfByteBuffers)\n+     *      .map(s -> ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8)))\n+     *      .to(IoMulti.multiToByteChannelBuilder(fileChannel)\n+     *              .executor(customExecutor)\n+     *              .build())\n+     *      .await();\n+     * }</pre>\n+     *\n+     * @param byteChannel for consuming ByteBuffers from upstream\n+     * @return mapper consuming {@code Multi<ByteBuffer>} and returning Single for observing asynchronous writing.\n+     */\n+    static MultiToByteChannelBuilder multiToByteChannelBuilder(WritableByteChannel byteChannel) {\n+        return new MultiToByteChannelBuilder(byteChannel);\n+    }\n+\n+    /**\n+     * Creates function consuming {@code Multi<ByteBuffer>} to {@link FileChannel} opened from supplied {@link Path}.\n+     * <br>\n+     * Example usage:\n+     * <pre>{@code\n+     * Multi.create(listOfByteBuffers)\n+     *      .map(s -> ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8)))\n+     *      .to(IoMulti.writeToFile(path)\n+     *              .executor(customExecutor)\n+     *              .build())\n+     *      .await();\n+     * }</pre>\n+     *\n+     * @param filePath file for writing all ByteBuffers from upstream to\n+     * @return mapper consuming {@code Multi<ByteBuffer>} and returning Single for observing asynchronous writing.\n+     */\n+    static MultiToByteChannelBuilder writeToFile(Path filePath) {\n+        try {\n+            FileChannel fileChannel = FileChannel.open(filePath, StandardOpenOption.WRITE);\n+            return new MultiToByteChannelBuilder(fileChannel);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n     /**\n      * Creates a builder of {@link Multi} from provided {@link java.nio.channels.ReadableByteChannel}.\n      *\n@@ -268,6 +339,48 @@ boolean isExternalExecutor() {\n         }\n     }\n \n+    /**\n+     * Fluent API builder for creating a subscriber consuming {@code Multi<ByteBuffer>} to {@link WritableByteChannel}.\n+     */\n+    final class MultiToByteChannelBuilder implements Builder<Function<? super Multi<ByteBuffer>, ? extends Single<Void>>> {\n+\n+        private final WritableByteChannel writableByteChannel;\n+        private Executor executor;\n+\n+        private MultiToByteChannelBuilder(final WritableByteChannel writableByteChannel) {\n+            this.writableByteChannel = writableByteChannel;\n+        }\n+\n+        /**\n+         * Supply custom executor for handling the blocking of {@link WritableByteChannel}.\n+         *\n+         * @param executor custom executor\n+         * @return updated builder instance\n+         */\n+        public MultiToByteChannelBuilder executor(Executor executor) {\n+            this.executor = executor;\n+            return this;\n+        }\n+\n+        @Override\n+        public Function<? super Multi<ByteBuffer>, ? extends Single<Void>> build() {\n+            if (executor == null) {\n+                return byteBufferMulti -> {\n+                    ByteChannelSubscriber byteChannelSubscriber =\n+                            new ByteChannelSubscriber(writableByteChannel, Executors.newSingleThreadExecutor());\n+                    byteBufferMulti.subscribe(byteChannelSubscriber);\n+                    return byteChannelSubscriber;\n+                };\n+            }\n+\n+            return byteBufferMulti -> {\n+                ByteChannelSubscriber byteChannelSubscriber = new ByteChannelSubscriber(writableByteChannel, executor);\n+                byteBufferMulti.subscribe(byteChannelSubscriber);\n+                return byteChannelSubscriber;\n+            };\n+        }\n+    }\n+\n     /**\n      * Fluent API builder for creating a {@link io.helidon.common.reactive.Multi} from an\n      * {@link java.io.InputStream}."
  },
  {
    "sha": "733f97bb92075016d2a7855bb94a7282144b498b",
    "filename": "common/reactive/src/main/java/io/helidon/common/reactive/Multi.java",
    "status": "modified",
    "additions": 10,
    "deletions": 1,
    "changes": 11,
    "blob_url": "https://github.com/oracle/helidon/blob/0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76/common/reactive/src/main/java/io/helidon/common/reactive/Multi.java",
    "raw_url": "https://github.com/oracle/helidon/raw/0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76/common/reactive/src/main/java/io/helidon/common/reactive/Multi.java",
    "contents_url": "https://api.github.com/repos/oracle/helidon/contents/common/reactive/src/main/java/io/helidon/common/reactive/Multi.java?ref=0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021 Oracle and/or its affiliates. All rights reserved.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -1086,4 +1086,13 @@\n         return single;\n     }\n \n+    /**\n+     * Terminal stage, ignore all items and complete returned {@code Single<Void>}.\n+     *\n+     * @return Single completed when the stream terminates\n+     */\n+    default Single<Void> ignore() {\n+        return forEach(t -> {});\n+    }\n+\n }"
  },
  {
    "sha": "04d2488d759797d258ee37fdafe134d23f35e93a",
    "filename": "common/reactive/src/test/java/io/helidon/common/reactive/ByteChannelSubscriberTest.java",
    "status": "added",
    "additions": 197,
    "deletions": 0,
    "changes": 197,
    "blob_url": "https://github.com/oracle/helidon/blob/0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76/common/reactive/src/test/java/io/helidon/common/reactive/ByteChannelSubscriberTest.java",
    "raw_url": "https://github.com/oracle/helidon/raw/0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76/common/reactive/src/test/java/io/helidon/common/reactive/ByteChannelSubscriberTest.java",
    "contents_url": "https://api.github.com/repos/oracle/helidon/contents/common/reactive/src/test/java/io/helidon/common/reactive/ByteChannelSubscriberTest.java?ref=0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76",
    "patch": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright (c) 2021 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package io.helidon.common.reactive;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.Test;\n+\n+public class ByteChannelSubscriberTest {\n+\n+    final static List<String> EXPECTED_VALUES = List.of(\"line 1\", \"line 2\", \"line 3\", \"line 4\", \"line 5\", \"line 6\", \"line 7\");\n+\n+    @Test\n+    void writeToFile() throws IOException {\n+        Path filePath = Files.createTempFile(\"writeToFile\", \".tmp\");\n+        FileChannel fileChannel = FileChannel.open(filePath, StandardOpenOption.WRITE);\n+        Multi.create(EXPECTED_VALUES)\n+                .map(line -> line + \"\\n\")\n+                .map(s -> ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8)))\n+                .to(IoMulti.multiToByteChannel(fileChannel))\n+                .await();\n+\n+        assertThat(Arrays.asList(Files.readString(filePath).split(\"\\n\")), Matchers.contains(EXPECTED_VALUES.toArray(new String[0])));\n+    }\n+\n+    @Test\n+    void shutdownDefaultExecutor() throws IOException, InterruptedException {\n+        Path filePath = Files.createTempFile(\"writeToFile\", \".tmp\");\n+        FileChannel fileChannel = FileChannel.open(filePath, StandardOpenOption.WRITE);\n+        ExecutorService defaultExecutor = Executors.newSingleThreadExecutor();\n+        try {\n+            ByteChannelSubscriber byteChannelSubscriber = new ByteChannelSubscriber(fileChannel, defaultExecutor);\n+            Multi.create(EXPECTED_VALUES)\n+                    .map(line -> line + \"\\n\")\n+                    .map(s -> ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8)))\n+                    .to(m -> {\n+                        m.subscribe(byteChannelSubscriber);\n+                        return byteChannelSubscriber;\n+                    })\n+                    .await();\n+        } finally {\n+            assertThat(\"Default executor should have been shutdown on complete.\",\n+                    defaultExecutor.awaitTermination(500, TimeUnit.MILLISECONDS));\n+        }\n+        assertThat(Arrays.asList(Files.readString(filePath).split(\"\\n\")), Matchers.contains(EXPECTED_VALUES.toArray(new String[0])));\n+    }\n+\n+    @Test\n+    void writeToFileWithSuppliedExecutor() throws IOException {\n+        Path filePath = Files.createTempFile(\"writeToFile\", \".tmp\");\n+        FileChannel fileChannel = FileChannel.open(filePath, StandardOpenOption.WRITE);\n+        ExecutorService customExecutor = Executors.newSingleThreadExecutor();\n+        try {\n+            Multi.create(EXPECTED_VALUES)\n+                    .map(line -> line + \"\\n\")\n+                    .map(s -> ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8)))\n+                    .to(IoMulti.multiToByteChannelBuilder(fileChannel)\n+                            .executor(customExecutor)\n+                            .build())\n+                    .await();\n+        } finally {\n+            customExecutor.shutdown();\n+        }\n+        assertThat(Arrays.asList(Files.readString(filePath).split(\"\\n\")), Matchers.contains(EXPECTED_VALUES.toArray(new String[0])));\n+    }\n+\n+    @Test\n+    void writePartToFileBeforeError() throws IOException {\n+        RuntimeException expectedError = new RuntimeException(\"BOOM!\");\n+        AtomicReference<Throwable> resultError = new AtomicReference<>();\n+        Path filePath = Files.createTempFile(\"writePartToFileBeforeError\", \".tmp\");\n+        FileChannel fileChannel = FileChannel.open(filePath, StandardOpenOption.WRITE);\n+        Multi.create(EXPECTED_VALUES)\n+                .peek(line -> {\n+                    if (line.endsWith(\"3\")) throw expectedError;\n+                })\n+                .map(line -> line + \"\\n\")\n+                .map(s -> ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8)))\n+                .to(IoMulti.multiToByteChannel(fileChannel))\n+                .onErrorResumeWithSingle(e -> {\n+                    resultError.set(e);\n+                    return Single.empty();\n+                })\n+                .await();\n+\n+        assertThat(resultError.get(), CoreMatchers.equalTo(expectedError));\n+        assertThat(Arrays.asList(Files.readString(filePath).split(\"\\n\")), Matchers.contains(EXPECTED_VALUES.subList(0, 2).toArray(new String[0])));\n+    }\n+\n+    @Test\n+    void closesChannel() {\n+        ArrayList<String> result = new ArrayList<>(EXPECTED_VALUES.size());\n+        AtomicBoolean closed = new AtomicBoolean(false);\n+        WritableByteChannel fileChannel = new WritableByteChannel() {\n+            @Override\n+            public int write(final ByteBuffer src) {\n+                byte[] array = new byte[src.remaining()];\n+                src.get(array);\n+                result.add(new String(array));\n+                return array.length;\n+            }\n+\n+            @Override\n+            public boolean isOpen() {\n+                return !closed.get();\n+            }\n+\n+            @Override\n+            public void close() throws IOException {\n+                closed.set(true);\n+            }\n+        };\n+        Multi.create(EXPECTED_VALUES)\n+                .map(s -> ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8)))\n+                .to(IoMulti.multiToByteChannel(fileChannel))\n+                .await();\n+\n+        assertThat(\"WritableByteChannel should have been closed when stream completed.\", closed.get());\n+        assertThat(result, Matchers.contains(EXPECTED_VALUES.toArray(new String[0])));\n+    }\n+\n+    @Test\n+    void readBytesOneByOne() {\n+        String expected = String.join(\"\", EXPECTED_VALUES);\n+        ByteBuffer result = ByteBuffer.allocate(expected.getBytes(StandardCharsets.UTF_8).length);\n+        AtomicBoolean closed = new AtomicBoolean(false);\n+        WritableByteChannel fileChannel = new WritableByteChannel() {\n+\n+            final AtomicReference<ByteBuffer> lastBuffer = new AtomicReference<>();\n+\n+            @Override\n+            public int write(final ByteBuffer src) {\n+                if (src.hasRemaining()) {\n+                    lastBuffer\n+                            .updateAndGet(old -> old == null ? ByteBuffer.allocate(src.remaining()) : old)\n+                            .put(src.get());\n+                    if (!src.hasRemaining()) {\n+                        result.put(lastBuffer.getAndSet(null).flip());\n+                    }\n+                    return 1;\n+                }\n+                return 0;\n+            }\n+\n+            @Override\n+            public boolean isOpen() {\n+                return !closed.get();\n+            }\n+\n+            @Override\n+            public void close() {\n+                closed.set(true);\n+            }\n+        };\n+        Multi.create(EXPECTED_VALUES)\n+                .map(s -> ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8)))\n+                .to(IoMulti.multiToByteChannel(fileChannel))\n+                .await();\n+\n+        assertThat(\"WritableByteChannel should have been closed when stream completed.\", closed.get());\n+        assertThat(new String(result.flip().array()), Matchers.equalTo(expected));\n+    }\n+}"
  },
  {
    "sha": "f5270b9fbb46292406fd3be0dd941e21bf3a2015",
    "filename": "examples/media/multipart/src/main/java/io/helidon/examples/media/multipart/FileService.java",
    "status": "modified",
    "additions": 38,
    "deletions": 65,
    "changes": 103,
    "blob_url": "https://github.com/oracle/helidon/blob/0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76/examples/media/multipart/src/main/java/io/helidon/examples/media/multipart/FileService.java",
    "raw_url": "https://github.com/oracle/helidon/raw/0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76/examples/media/multipart/src/main/java/io/helidon/examples/media/multipart/FileService.java",
    "contents_url": "https://api.github.com/repos/oracle/helidon/contents/examples/media/multipart/src/main/java/io/helidon/examples/media/multipart/FileService.java?ref=0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76",
    "patch": "@@ -15,22 +15,20 @@\n  */\n package io.helidon.examples.media.multipart;\n \n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.ByteChannel;\n-import java.nio.file.Files;\n import java.nio.file.Path;\n-import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n \n import javax.json.Json;\n import javax.json.JsonArrayBuilder;\n import javax.json.JsonBuilderFactory;\n \n+import io.helidon.common.configurable.ThreadPoolSupplier;\n import io.helidon.common.http.DataChunk;\n import io.helidon.common.http.Http;\n import io.helidon.common.http.MediaType;\n+import io.helidon.common.reactive.IoMulti;\n import io.helidon.media.multipart.ContentDisposition;\n import io.helidon.media.multipart.ReadableBodyPart;\n import io.helidon.media.multipart.ReadableMultiPart;\n@@ -47,6 +45,8 @@\n \n     private static final JsonBuilderFactory JSON_FACTORY = Json.createBuilderFactory(Map.of());\n     private final FileStorage storage;\n+    private final ExecutorService executor = ThreadPoolSupplier.create().get();\n+\n \n     /**\n      * Create a new file upload service instance.\n@@ -58,8 +58,8 @@\n     @Override\n     public void update(Routing.Rules rules) {\n         rules.get(\"/\", this::list)\n-             .get(\"/{fname}\", this::download)\n-             .post(\"/\", this::upload);\n+                .get(\"/{fname}\", this::download)\n+                .post(\"/\", this::upload);\n     }\n \n     private void list(ServerRequest req, ServerResponse res) {\n@@ -88,72 +88,45 @@ private void upload(ServerRequest req, ServerResponse res) {\n     }\n \n     private void bufferedUpload(ServerRequest req, ServerResponse res) {\n-        req.content().as(ReadableMultiPart.class).thenAccept(multiPart -> {\n-            for (ReadableBodyPart part : multiPart.fields(\"file[]\")) {\n-                writeBytes(storage.create(part.filename()), part.as(byte[].class));\n-            }\n-            res.status(Http.Status.MOVED_PERMANENTLY_301);\n-            res.headers().put(Http.Header.LOCATION, \"/ui\");\n-            res.send();\n-        });\n+        req.content().as(ReadableMultiPart.class)\n+                .flatMapIterable(multiPart -> multiPart.fields(\"file[]\"))\n+                .flatMap(part -> part.content()\n+                        .map(DataChunk::data)\n+                        .flatMapIterable(Arrays::asList)\n+                        .to(IoMulti.writeToFile(storage.create(part.filename()))\n+                                .executor(executor)\n+                                .build())\n+                )\n+                .onError(throwable -> {\n+                    res.status(Http.Status.INTERNAL_SERVER_ERROR_500);\n+                    res.send(throwable.toString());\n+                })\n+                .onComplete(() -> {\n+                    res.status(Http.Status.MOVED_PERMANENTLY_301);\n+                    res.headers().put(Http.Header.LOCATION, \"/ui\");\n+                    res.send();\n+                })\n+                .ignore();\n     }\n \n     private void streamUpload(ServerRequest req, ServerResponse res) {\n         req.content().asStream(ReadableBodyPart.class)\n+                .filter(part -> \"file[]\".equals(part.name()))\n+                .limit(1) // FIXME: Why there is no complete?\n+                .flatMap(part -> part.content()\n+                        .map(DataChunk::data)\n+                        .flatMapIterable(Arrays::asList)\n+                        .to(IoMulti.writeToFile(storage.create(part.filename()))\n+                                .executor(executor)\n+                                .build())\n+                )\n                 .onError(res::send)\n                 .onComplete(() -> {\n                     res.status(Http.Status.MOVED_PERMANENTLY_301);\n                     res.headers().put(Http.Header.LOCATION, \"/ui\");\n                     res.send();\n-                }).forEach((part) -> {\n-                    if (\"file[]\".equals(part.name())) {\n-                        final ByteChannel channel = newByteChannel(storage.create(part.filename()));\n-                        part.content()\n-                                .forEach(chunk -> writeChunk(channel, chunk))\n-                                .thenAccept(it -> closeChannel(channel));\n-                    }\n-                });\n-    }\n-\n-    private static void writeBytes(Path file, byte[] bytes) {\n-        try {\n-            Files.write(file, bytes,\n-                    StandardOpenOption.CREATE,\n-                    StandardOpenOption.WRITE,\n-                    StandardOpenOption.TRUNCATE_EXISTING);\n-        } catch (IOException ex) {\n-            throw new UncheckedIOException(ex);\n-        }\n+                })\n+                .ignore();\n     }\n \n-    private static void writeChunk(ByteChannel channel, DataChunk chunk) {\n-        try {\n-            for (ByteBuffer byteBuffer : chunk.data()) {\n-                channel.write(byteBuffer);\n-            }\n-        } catch (IOException ex) {\n-            throw new UncheckedIOException(ex);\n-        } finally {\n-            chunk.release();\n-        }\n-    }\n-\n-    private void closeChannel(ByteChannel channel) {\n-        try {\n-            channel.close();\n-        } catch (IOException ex) {\n-            throw new UncheckedIOException(ex);\n-        }\n-    }\n-\n-    private static ByteChannel newByteChannel(Path file) {\n-        try {\n-            return Files.newByteChannel(file,\n-                    StandardOpenOption.CREATE,\n-                    StandardOpenOption.WRITE,\n-                    StandardOpenOption.TRUNCATE_EXISTING);\n-        } catch (IOException ex) {\n-            throw new UncheckedIOException(ex);\n-        }\n-    }\n }"
  },
  {
    "sha": "fc5236e47c1f2e13ee02d81ae76ababd19b2cc47",
    "filename": "examples/media/multipart/src/main/java/io/helidon/examples/media/multipart/FileStorage.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/oracle/helidon/blob/0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76/examples/media/multipart/src/main/java/io/helidon/examples/media/multipart/FileStorage.java",
    "raw_url": "https://github.com/oracle/helidon/raw/0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76/examples/media/multipart/src/main/java/io/helidon/examples/media/multipart/FileStorage.java",
    "contents_url": "https://api.github.com/repos/oracle/helidon/contents/examples/media/multipart/src/main/java/io/helidon/examples/media/multipart/FileStorage.java?ref=0efa1ef1fce4bced5dc1de3c7edbf7fb8000bb76",
    "patch": "@@ -79,6 +79,11 @@ public Path create(String fname) {\n         if (!file.getParent().equals(storageDir)) {\n             throw new BadRequestException(\"Invalid file name\");\n         }\n+        try {\n+            Files.createFile(file);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n         return file;\n     }\n "
  }
]
