[
  {
    "sha": "67179cd14f04aba5dc7eb3b2ec6dc6d7b60997b4",
    "filename": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiJmsRecovery.java",
    "status": "added",
    "additions": 353,
    "deletions": 0,
    "changes": 353,
    "blob_url": "https://github.com/oracle/weblogic-kubernetes-operator/blob/2b05e818eccc945d162e89cebddbf4627625acb2/integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiJmsRecovery.java",
    "raw_url": "https://github.com/oracle/weblogic-kubernetes-operator/raw/2b05e818eccc945d162e89cebddbf4627625acb2/integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiJmsRecovery.java",
    "contents_url": "https://api.github.com/repos/oracle/weblogic-kubernetes-operator/contents/integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiJmsRecovery.java?ref=2b05e818eccc945d162e89cebddbf4627625acb2",
    "patch": "@@ -0,0 +1,353 @@\n+// Copyright (c) 2021, Oracle and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TO_USE_IN_SPEC;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonMiiTestUtils.createDatabaseSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonMiiTestUtils.createDomainResourceWithLogHome;\n+import static oracle.weblogic.kubernetes.utils.CommonMiiTestUtils.createDomainSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonMiiTestUtils.createJobToChangePermissionsOnPvHostPath;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPV;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVC;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretForBaseImages;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getExternalServicePodName;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runClientInsidePod;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.runJavacInsidePod;\n+import static oracle.weblogic.kubernetes.utils.DbUtils.createLeasingTable;\n+import static oracle.weblogic.kubernetes.utils.DbUtils.getDBNodePort;\n+import static oracle.weblogic.kubernetes.utils.DbUtils.startOracleDB;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileToPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies JMS Service migration with JMS messages stored in \n+ * (a) Persistent FileStore (b) Persistent JDBC Store accessible from all pods.\n+ * The dynamic cluster is scaled down to trigger the Service migration from \n+ * a stopped pod/managed server to a live pod/managed server.\n+ * Configuration : \n+ *   MII cluster domain with 2 managed servers\n+ *   Two set of JMS Resources with FileStore and JDBC Store\n+ *   All resources are targeted to cluster with enabled JMS service migration\n+ *   Two Distributed Queue(s) one with FileStore and the other with JDBC Store\n+ *   Separate ORACLE Datasource for cluster leasing\n+ * UseCase :  \n+ * (a) Test client sends 100 messages to member queue@managed-server2\n+ * (b) Scale down the cluster with replica count 1 to shutdown managed-server2\n+ * (c) Make sure the JMS Service@managed-server2 is migrated to managed-server1\n+ * (d) Make sure all 100 messages got recovered once the \n+ *     JMS Service@managed-server2 is migrated to managed-server1 \n+ * Above steps are repeated for both FileStore and JDBCStore based Distributed Queue.\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test JMS service migration on cluster scale down\")\n+@IntegrationTest\n+class ItMiiJmsRecovery {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static int replicaCount = 2;\n+  private static final String domainUid = \"mii-jms-recovery\";\n+  private static String pvName = domainUid + \"-pv\"; \n+  private static String pvcName = domainUid + \"-pvc\"; \n+  private static final String adminServerPodName = domainUid + \"-admin-server\";\n+  private static final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+  private static String cpUrl;\n+  private static int dbNodePort;\n+\n+  private final Path samplePath = Paths.get(ITTESTS_DIR, \"../kubernetes/samples\");\n+  private final Path domainLifecycleSamplePath = Paths.get(samplePath + \"/scripts/domain-lifecycle\");\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource definition.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the \n+   *     JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+ \n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    //Start oracleDB\n+    assertDoesNotThrow(() -> {\n+      startOracleDB(DB_IMAGE_TO_USE_IN_SPEC, 0, domainNamespace);\n+      String.format(\"Failed to start Oracle Database Service\");\n+    });\n+    dbNodePort = getDBNodePort(domainNamespace, \"oracledb\");\n+    logger.info(\"Oracle Database Service Node Port = {0}\", dbNodePort);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    logger.info(\"Create database secret\");\n+    final String dbSecretName = domainUid  + \"-db-secret\";\n+    cpUrl = \"jdbc:oracle:thin:@//\" + K8S_NODEPORT_HOST + \":\"\n+                         + dbNodePort + \"/devpdb.k8s\";\n+    logger.info(\"ConnectionPool URL = {0}\", cpUrl);\n+    assertDoesNotThrow(() -> createDatabaseSecret(dbSecretName, \n+            \"sys as sysdba\", \"Oradoc_db1\", cpUrl, domainNamespace),\n+            String.format(\"createSecret failed for %s\", dbSecretName));\n+    String configMapName = \"jdbc-jms-recovery-configmap\";\n+\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(MODEL_DIR + \"/jms.recovery.yaml\"));\n+\n+    // this secret is used only for non-kind cluster\n+    createSecretForBaseImages(domainNamespace);\n+\n+    // create PV, PVC for logs/data\n+    createPV(pvName, domainUid, ItMiiJmsRecovery.class.getSimpleName());\n+    createPVC(pvName, pvcName, domainUid, domainNamespace);\n+\n+    // create job to change permissions on PV hostPath\n+    createJobToChangePermissionsOnPvHostPath(pvName, pvcName, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+\n+    createDomainResourceWithLogHome(domainUid, domainNamespace,\n+        MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG,\n+        adminSecretName, OCIR_SECRET_NAME, encryptionSecretName,\n+        replicaCount, pvName, pvcName, \"cluster-1\", configMapName, dbSecretName, false, false);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // create the required leasing table 'ACTIVE' before we start the cluster\n+    createLeasingTable(adminServerPodName, domainNamespace, dbNodePort); \n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Verify JMS Service is migrated to an available active server.\n+   * Here the JMS messages are stored in Filestore on PV\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Verify JMS Service migration with FileStore\")\n+  public void testMiiJmsServiceMigrationWithFileStore() {\n+   \n+    // build the standalone JMS Client on Admin pod after rolling restart\n+    String destLocation = \"/u01/JmsSendReceiveClient.java\";\n+    assertDoesNotThrow(() -> copyFileToPod(domainNamespace,\n+        adminServerPodName, \"\",\n+        Paths.get(RESOURCE_DIR, \"jms\", \"JmsSendReceiveClient.java\"),\n+        Paths.get(destLocation)));\n+    runJavacInsidePod(adminServerPodName, domainNamespace, destLocation);\n+    \n+    assertTrue(checkJmsServerRuntime(\"managed-server2\"), \n+         \"JMSService@managed-server2 is on managed-server2 before migration\");\n+\n+    runJmsClientOnAdminPod(\"send\", \n+            \"ClusterJmsServer@managed-server2@jms.testUniformQueue\");\n+\n+    boolean psuccess = assertDoesNotThrow(() ->\n+            scaleCluster(domainUid, domainNamespace, \"cluster-1\", 1),\n+        String.format(\"replica patching to 1 failed for domain %s in namespace %s\", domainUid, domainNamespace));\n+    assertTrue(psuccess,\n+        String.format(\"Cluster replica patching failed for domain %s in namespace %s\", domainUid, domainNamespace));\n+    checkPodDoesNotExist(managedServerPrefix + \"2\", domainUid, domainNamespace);\n+    // Make sure the JMSService@managed-server2 is migrated to managed-server1\n+    assertTrue(checkJmsServerRuntime(\"managed-server1\"), \n+            \"JMSService@managed-server2 is NOT migrated to managed-server1\");\n+    runJmsClientOnAdminPod(\"receive\", \n+            \"ClusterJmsServer@managed-server2@jms.testUniformQueue\");\n+  }\n+\n+  /**\n+   * Verify JMS Service is migrated to an available active server.\n+   * Here the JMS messages are stored in the JDBC store.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Verify JMS Service migration with JDBCStore\")\n+  public void testMiiJmsServiceMigrationWithJdbcStore() {\n+\n+    // Restart the managed server(2) if shutdown by previous test method \n+    // Make sure that JMS server runtime JMSService@managed-server2 is \n+    // hosted on managed server 'managed-server2'\n+    restartManagedServer(\"managed-server2\");\n+    assertTrue(checkJmsServerRuntime(\"managed-server2\"), \n+         \"JMSService@managed-server2 is on managed-server2 before migration\");\n+\n+    // build the standalone JMS Client on Admin pod after rolling restart\n+    String destLocation = \"/u01/JmsSendReceiveClient.java\";\n+    assertDoesNotThrow(() -> copyFileToPod(domainNamespace,\n+        adminServerPodName, \"\",\n+        Paths.get(RESOURCE_DIR, \"jms\", \"JmsSendReceiveClient.java\"),\n+        Paths.get(destLocation)));\n+    runJavacInsidePod(adminServerPodName, domainNamespace, destLocation);\n+    \n+    runJmsClientOnAdminPod(\"send\", \n+            \"JdbcJmsServer@managed-server2@jms.jdbcUniformQueue\");\n+    boolean psuccess3 = assertDoesNotThrow(() ->\n+            scaleCluster(domainUid, domainNamespace, \"cluster-1\", 1),\n+        String.format(\"replica patching to 1 failed for domain %s in namespace %s\", domainUid, domainNamespace));\n+    assertTrue(psuccess3,\n+        String.format(\"Cluster replica patching failed for domain %s in namespace %s\", domainUid, domainNamespace));\n+    checkPodDoesNotExist(managedServerPrefix + \"2\", domainUid, domainNamespace);\n+\n+    assertTrue(checkJmsServerRuntime(\"managed-server1\"), \n+           \"JMSService@managed-server2 is NOT migrated to managed-server1\");\n+    runJmsClientOnAdminPod(\"receive\", \n+            \"JdbcJmsServer@managed-server2@jms.jdbcUniformQueue\");\n+  }\n+\n+  private void restartManagedServer(String serverName) {\n+\n+    String commonParameters = \" -d \" + domainUid + \" -n \" + domainNamespace;\n+    boolean result;\n+    CommandParams params = new CommandParams().defaults();\n+    String script = \"startServer.sh\";\n+    params.command(\"sh \"\n+        + Paths.get(domainLifecycleSamplePath.toString(), \"/\" + script).toString() \n+        + commonParameters + \" -s \" + serverName);\n+    result = Command.withParams(params).execute();\n+    assertTrue(result, \"Failed to execute script \" + script);\n+    checkPodReadyAndServiceExists(managedServerPrefix + \"2\", domainUid, domainNamespace);\n+  }\n+\n+  // Run standalone JMS Client to send/receive message from \n+  // Distributed Destination Member\n+  private void runJmsClientOnAdminPod(String action, String queue) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for JMS Client to send/recv msg \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runClientInsidePod(adminServerPodName, domainNamespace,\n+            \"/u01\", \"JmsSendReceiveClient\", \"t3://\" + domainUid + \"-cluster-cluster-1:8001\", action, queue, \"100\"));\n+  }\n+\n+  /*\n+   * Verify the JMS Server Runtime through rest API.\n+   * Get the JMSServer Runtime ClusterJmsServer@managed-server2 found on \n+   * specified managed server.\n+   * @param managedServer name of managed server to look for JMSServerRuntime\n+   * @returns true if MBEAN is found otherwise false\n+   **/\n+  private boolean checkJmsServerRuntime(String managedServer) {\n+    ExecResult result = null;\n+    int adminServiceNodePort\n+        = getServiceNodePort(domainNamespace, getExternalServicePodName(adminServerPodName), \"default\");\n+    StringBuffer curlString = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+    curlString.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/weblogic/latest/domainRuntime/serverRuntimes/\")\n+          .append(managedServer)\n+          .append(\"/JMSRuntime/JMSServers/ClusterJmsServer@managed-server2\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+    logger.info(\"checkJmsServerRuntime: curl command {0}\", new String(curlString));\n+    withStandardRetryPolicy \n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for JMS Service to migrate \"\n+                + \"(elapsed time {0} ms, remaining time {1} ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> {\n+          return () -> {\n+            return exec(new String(curlString), true).stdout().contains(\"200\");\n+          };\n+        }));\n+    return true;\n+  }\n+\n+}"
  },
  {
    "sha": "577bd20c811e82952f01c21f437edd828859a461",
    "filename": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiUpdateDomainConfig.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/oracle/weblogic-kubernetes-operator/blob/2b05e818eccc945d162e89cebddbf4627625acb2/integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiUpdateDomainConfig.java",
    "raw_url": "https://github.com/oracle/weblogic-kubernetes-operator/raw/2b05e818eccc945d162e89cebddbf4627625acb2/integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiUpdateDomainConfig.java",
    "contents_url": "https://api.github.com/repos/oracle/weblogic-kubernetes-operator/contents/integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiUpdateDomainConfig.java?ref=2b05e818eccc945d162e89cebddbf4627625acb2",
    "patch": "@@ -851,7 +851,7 @@ public void testMiiUpdateDynamicClusterSize() {\n     boolean p4Success = assertDoesNotThrow(() ->\n             scaleCluster(domainUid, domainNamespace, \"cluster-1\", 1),\n         String.format(\"replica patching to 1 failed for domain %s in namespace %s\", domainUid, domainNamespace));\n-    assertTrue(p2Success,\n+    assertTrue(p4Success,\n         String.format(\"Cluster replica patching failed for domain %s in namespace %s\", domainUid, domainNamespace));\n \n     checkPodDoesNotExist(managedServerPrefix + \"3\", domainUid, domainNamespace);"
  },
  {
    "sha": "233f52d741fc40adc42b109dadc8d64e39ed07af",
    "filename": "integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonMiiTestUtils.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/oracle/weblogic-kubernetes-operator/blob/2b05e818eccc945d162e89cebddbf4627625acb2/integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonMiiTestUtils.java",
    "raw_url": "https://github.com/oracle/weblogic-kubernetes-operator/raw/2b05e818eccc945d162e89cebddbf4627625acb2/integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonMiiTestUtils.java",
    "contents_url": "https://api.github.com/repos/oracle/weblogic-kubernetes-operator/contents/integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonMiiTestUtils.java?ref=2b05e818eccc945d162e89cebddbf4627625acb2",
    "patch": "@@ -300,6 +300,7 @@ public static Domain createDomainResourceWithLogHome(\n             .includeServerOutInPodLog(true)\n             .logHomeEnabled(Boolean.TRUE)\n             .logHome(\"/shared/logs\")\n+            .dataHome(\"/shared/data\")\n             .serverStartPolicy(\"IF_NEEDED\")\n             .serverPod(new ServerPod()\n                 .addEnvItem(new V1EnvVar()"
  },
  {
    "sha": "29229255a0c7a106094c2634cd0eb979b5a824fc",
    "filename": "integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java",
    "status": "modified",
    "additions": 72,
    "deletions": 0,
    "changes": 72,
    "blob_url": "https://github.com/oracle/weblogic-kubernetes-operator/blob/2b05e818eccc945d162e89cebddbf4627625acb2/integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java",
    "raw_url": "https://github.com/oracle/weblogic-kubernetes-operator/raw/2b05e818eccc945d162e89cebddbf4627625acb2/integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java",
    "contents_url": "https://api.github.com/repos/oracle/weblogic-kubernetes-operator/contents/integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java?ref=2b05e818eccc945d162e89cebddbf4627625acb2",
    "patch": "@@ -4,10 +4,12 @@\n package oracle.weblogic.kubernetes.utils;\n \n import java.io.IOException;\n+import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.util.Arrays;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Callable;\n import javax.net.ssl.SSLProtocolException;\n@@ -39,14 +41,19 @@\n import oracle.weblogic.kubernetes.logging.LoggingFacade;\n import org.awaitility.core.ConditionFactory;\n \n+import static io.kubernetes.client.util.Yaml.dump;\n import static java.util.concurrent.TimeUnit.MINUTES;\n import static java.util.concurrent.TimeUnit.SECONDS;\n import static oracle.weblogic.kubernetes.TestConstants.BASE_IMAGES_REPO_SECRET;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listServices;\n import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretForBaseImages;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileToPod;\n import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n import static org.awaitility.Awaitility.with;\n import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n@@ -501,4 +508,69 @@ public static int getNewSuffixCount() {\n       return suffixCount;\n     }\n   }\n+\n+  /**\n+   * Returns a DB NodePort value .\n+   *\n+   * @param dbNamespace database namespace where pod exists\n+   * @param dbName database name\n+   * @return DB NodePort value\n+   */\n+  public static Integer getDBNodePort(String dbNamespace, String dbName) {\n+    LoggingFacade logger = getLogger();\n+    logger.info(dump(Kubernetes.listServices(dbNamespace)));\n+    List<V1Service> services = listServices(dbNamespace).getItems();\n+    for (V1Service service : services) {\n+      if (service.getMetadata().getName().startsWith(dbName)) {\n+        return service.getSpec().getPorts().get(0).getNodePort();\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  /**\n+   * Create leasing Table (ACTIVE) on an Oracle DB Instance.\n+   * Uses the WebLogic utility utils.Schema to add the table \n+   * So the command MUST be run inside a Weblogic Server pod\n+   *\n+   * @param podName the pod name\n+   * @param namespace where pod exists\n+   * @param dbNodePort NodePort for the Oracle DB service\n+   */\n+  public static void createLeasingTable(String podName, String namespace, int dbNodePort) {\n+    Path ddlFile = Paths.get(WORK_DIR + \"/leasing.ddl\");\n+    String ddlString = \"DROP TABLE ACTIVE;\\n\"\n+        + \"CREATE TABLE ACTIVE (\\n\" \n+        + \"  SERVER VARCHAR2(255) NOT NULL,\\n\" \n+        + \"  INSTANCE VARCHAR2(255) NOT NULL,\\n\" \n+        + \"  DOMAINNAME VARCHAR2(255) NOT NULL,\\n\" \n+        + \"  CLUSTERNAME VARCHAR2(255) NOT NULL,\\n\" \n+        + \"  TIMEOUT DATE,\\n\" \n+        + \"  PRIMARY KEY (SERVER, DOMAINNAME, CLUSTERNAME)\\n\" \n+        + \");\\n\";\n+\n+    assertDoesNotThrow(() -> Files.write(ddlFile, ddlString.getBytes()));\n+    String destLocation = \"/u01/leasing.ddl\";\n+    assertDoesNotThrow(() -> copyFileToPod(namespace,\n+             podName, \"\",\n+             Paths.get(WORK_DIR, \"leasing.ddl\"),\n+             Paths.get(destLocation)));\n+\n+    String cpUrl = \"jdbc:oracle:thin:@//\" + K8S_NODEPORT_HOST + \":\"\n+                         + dbNodePort + \"/devpdb.k8s\";\n+    String jarLocation = \"/u01/oracle/wlserver/server/lib/weblogic.jar\";\n+    StringBuffer ecmd = new StringBuffer(\"java -cp \");\n+    ecmd.append(jarLocation);\n+    ecmd.append(\" utils.Schema \");\n+    ecmd.append(cpUrl);\n+    ecmd.append(\" oracle.jdbc.OracleDriver\");\n+    ecmd.append(\" -verbose \");\n+    ecmd.append(\" -u \\\"sys as sysdba\\\"\");\n+    ecmd.append(\" -p Oradoc_db1\");\n+    ecmd.append(\" /u01/leasing.ddl\");\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(namespace, podName,\n+            null, true, \"/bin/sh\", \"-c\", ecmd.toString()));\n+    assertTrue(execResult.exitValue() == 0, \"Could not create the Leasing Table\");\n+  }\n }"
  },
  {
    "sha": "27da535f32127849af678ee73e045feaf4752ccb",
    "filename": "integration-tests/src/test/resources/jms/JmsSendReceiveClient.java",
    "status": "added",
    "additions": 124,
    "deletions": 0,
    "changes": 124,
    "blob_url": "https://github.com/oracle/weblogic-kubernetes-operator/blob/2b05e818eccc945d162e89cebddbf4627625acb2/integration-tests/src/test/resources/jms/JmsSendReceiveClient.java",
    "raw_url": "https://github.com/oracle/weblogic-kubernetes-operator/raw/2b05e818eccc945d162e89cebddbf4627625acb2/integration-tests/src/test/resources/jms/JmsSendReceiveClient.java",
    "contents_url": "https://api.github.com/repos/oracle/weblogic-kubernetes-operator/contents/integration-tests/src/test/resources/jms/JmsSendReceiveClient.java?ref=2b05e818eccc945d162e89cebddbf4627625acb2",
    "patch": "@@ -0,0 +1,124 @@\n+// Copyright (c) 2020, 2021, Oracle and/or its affiliates.\r\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\r\n+\r\n+import java.util.Hashtable;\r\n+import javax.naming.Context;\r\n+import javax.naming.InitialContext;\r\n+import javax.naming.NamingException;\r\n+\r\n+import javax.jms.Destination;\r\n+import javax.jms.ConnectionFactory;\r\n+import javax.jms.JMSContext;\r\n+import javax.jms.Message;\r\n+import javax.jms.JMSConsumer;\r\n+\r\n+public class JmsSendReceiveClient {\r\n+\r\n+  private String    url;\r\n+  private String    action;\r\n+  private String    qname;\r\n+  private int       mcount;\r\n+\r\n+  public JmsSendReceiveClient(String[] args)\r\n+  {\r\n+    url      = args[0];\r\n+    action   = args[1];\r\n+    qname    = args[2];\r\n+    mcount   = Integer.parseInt(args[3]);\r\n+\r\n+\r\n+    try {\r\n+     if ( action.equals(\"send\") )  {\r\n+        doSend(qname);\r\n+        System.out.println(\"Successfully sent [\" + mcount + \"] messages\");\r\n+      } else if ( action.equals(\"receive\") )  {\r\n+        int ct = doReceive(qname);\r\n+        System.out.println(\"Successfully received [\" + ct + \"] messages\");\r\n+        if ( ct != mcount ) {\r\n+         log(\"ERROR: Expected # of message [\"+mcount+\"] not found\");\r\n+         System.exit(-1);\r\n+        }\r\n+      } else {\r\n+        System.out.println(\"Usage: Unknown message option [\"+action+\"]\");\r\n+        System.out.println(\"Message option must be send|receive\");\r\n+        System.exit(-1);\r\n+      }\r\n+     } catch ( Exception  ex ) { \r\n+       ex.printStackTrace();\r\n+       System.out.println(\"Exception while Send/Receive Message:\"+ ex);\r\n+       System.exit(-1);\r\n+     } \r\n+   } \r\n+\r\n+  public void doSend(String Queue) throws Exception {\r\n+   System.out.println(\"Sending message(s) to [\" + Queue + \"]\");\r\n+   Context ctx = getInitialContext();\r\n+   Destination queue = (Destination)ctx.lookup(Queue);\r\n+   ConnectionFactory qcf= (ConnectionFactory)\r\n+        ctx.lookup(\"weblogic.jms.ConnectionFactory\");\r\n+   JMSContext context = qcf.createContext();\r\n+   for (int i=0; i<mcount; i++)\r\n+     context.createProducer().send(queue, \"Welcome to Weblogic on K8s\");\r\n+\r\n+   context.close();\r\n+   ctx.close();\r\n+\r\n+   }\r\n+\r\n+  public int doReceive(String Queue) throws Exception {\r\n+   System.out.println(\"Geting message(s) from  [\" + Queue + \"]\");\r\n+   Context ctx = getInitialContext();\r\n+   Destination queue = (Destination)ctx.lookup(Queue);\r\n+   ConnectionFactory qcf= (ConnectionFactory)\r\n+        ctx.lookup(\"weblogic.jms.ConnectionFactory\");\r\n+   JMSContext context = qcf.createContext();\r\n+   JMSConsumer consumer = (JMSConsumer) context.createConsumer(queue);\r\n+   Message msg=null;\r\n+   int count = 0;\r\n+   do {\r\n+     msg = consumer.receiveNoWait();\r\n+     if ( msg != null ) { count++; }\r\n+    } while( msg != null);\r\n+    // System.out.println(\"DRAINED [\"+count+\"] message from [\"+Queue+\"]\");\r\n+    return count;\r\n+   }\r\n+\r\n+   private Context getInitialContext()\r\n+   {\r\n+     Context jndiContext = null;\r\n+     String user=\"weblogic\";\r\n+     String password=\"welcome1\";\r\n+\r\n+     System.out.println(\"JNDI Context URL [\" + url +\"]\");\r\n+     // System.out.println(\"User[\"+user+\"] Password[******]\");\r\n+     String WLS_JNDI_FACTORY  = \"weblogic.jndi.WLInitialContextFactory\";\r\n+\r\n+     Hashtable env = new Hashtable();\r\n+     env.put(Context.INITIAL_CONTEXT_FACTORY, WLS_JNDI_FACTORY);\r\n+     env.put(Context.PROVIDER_URL, url);\r\n+     env.put(Context.SECURITY_PRINCIPAL, user);\r\n+     env.put(Context.SECURITY_CREDENTIALS, password);\r\n+     // System.out.println(\"env in getInitialContext(): \" + env);\r\n+      try {\r\n+        jndiContext = new InitialContext(env);\r\n+        System.out.println(\"Got initial JNDI Context(): \" + jndiContext);\r\n+      } catch (Exception e) {\r\n+       System.out.println(\"Unable to getInitialContext \"+e);\r\n+       System.exit(-1);\r\n+      }\r\n+      return jndiContext;\r\n+   }\r\n+\r\n+   private void log(String err)\r\n+   {\r\n+     System.out.println(err);\r\n+   }\r\n+\r\n+   public static void main(String[] args){\r\n+    if ( args.length < 4 ) {\r\n+     System.out.println(\"Usage : JmsSendReceiveClient  url action(send|receive) qname count\");\r\n+     System.exit(-1);\r\n+    }\r\n+    JmsSendReceiveClient client = new JmsSendReceiveClient(args);\r\n+   }\r\n+}\r"
  },
  {
    "sha": "cc3670ea5bd0bab99e555bf06256e30d3e3baab3",
    "filename": "integration-tests/src/test/resources/wdt-models/jms.recovery.yaml",
    "status": "added",
    "additions": 87,
    "deletions": 0,
    "changes": 87,
    "blob_url": "https://github.com/oracle/weblogic-kubernetes-operator/blob/2b05e818eccc945d162e89cebddbf4627625acb2/integration-tests/src/test/resources/wdt-models/jms.recovery.yaml",
    "raw_url": "https://github.com/oracle/weblogic-kubernetes-operator/raw/2b05e818eccc945d162e89cebddbf4627625acb2/integration-tests/src/test/resources/wdt-models/jms.recovery.yaml",
    "contents_url": "https://api.github.com/repos/oracle/weblogic-kubernetes-operator/contents/integration-tests/src/test/resources/wdt-models/jms.recovery.yaml?ref=2b05e818eccc945d162e89cebddbf4627625acb2",
    "patch": "@@ -0,0 +1,87 @@\n+# Copyright (c) 2020, 2021, Oracle and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+topology:\n+    Cluster:\n+        \"cluster-1\":\n+           DataSourceForAutomaticMigration:  LeasingDataSource\n+           AutoMigrationTableName: ACTIVE\n+resources:\n+    FileStore:\n+        ClusterFileStore:\n+           DistributionPolicy: Distributed\n+           MigrationPolicy: Always\n+           Directory: '/shared/data/ClusterFileStore'\n+           Target: 'cluster-1'\n+    JDBCStore:\n+        JdbcFileStore:\n+           DistributionPolicy: Distributed\n+           MigrationPolicy: Always\n+           DataSource: StoreDataSource\n+           Target: 'cluster-1'\n+    JMSServer:\n+        ClusterJmsServer:\n+            Target: 'cluster-1'\n+            PersistentStore: 'ClusterFileStore'\n+        JdbcJmsServer:\n+            Target: 'cluster-1'\n+            PersistentStore: 'JdbcFileStore'\n+\n+    JMSSystemResource:\n+        ClusterJmsModule:\n+            Target: 'cluster-1'\n+            SubDeployment:\n+                ClusterSubDeployment:\n+                    Target: ClusterJmsServer\n+            JmsResource:\n+              UniformDistributedQueue:\n+                testUniformQueue:\n+                   SubDeploymentName: ClusterSubDeployment\n+                   JNDIName: jms/testUniformQueue\n+        JdbcJmsModule:\n+            Target: 'cluster-1'\n+            SubDeployment:\n+                JdbcSubDeployment:\n+                    Target: JdbcJmsServer\n+            JmsResource:\n+              UniformDistributedQueue:\n+                jdbcUniformQueue:\n+                   SubDeploymentName: JdbcSubDeployment\n+                   JNDIName: jms/jdbcUniformQueue\n+\n+    JDBCSystemResource:\n+        LeasingDataSource:\n+            Target: 'cluster-1'\n+            JdbcResource:\n+                JDBCConnectionPoolParams:\n+                    InitialCapacity: 0\n+                    MinCapacity: 0\n+                    MaxCapacity: 15\n+                JDBCDataSourceParams:\n+                    GlobalTransactionsProtocol: OnePhaseCommit\n+                    RowPrefetchSize: 200\n+                    JNDIName: jdbc/LeasingDataSource\n+                JDBCDriverParams:\n+                    URL: '@@SECRET:@@ENV:DOMAIN_UID@@-db-secret:url@@'\n+                    PasswordEncrypted: '@@SECRET:@@ENV:DOMAIN_UID@@-db-secret:password@@'\n+                    DriverName: oracle.jdbc.OracleDriver\n+                    Properties:\n+                        user:\n+                            Value: '@@SECRET:@@ENV:DOMAIN_UID@@-db-secret:username@@'\n+        StoreDataSource:\n+            Target: 'cluster-1'\n+            JdbcResource:\n+                JDBCConnectionPoolParams:\n+                    InitialCapacity: 0\n+                    MinCapacity: 0\n+                    MaxCapacity: 15\n+                JDBCDataSourceParams:\n+                    GlobalTransactionsProtocol: OnePhaseCommit\n+                    RowPrefetchSize: 200\n+                    JNDIName: jdbc/StoreDataSource\n+                JDBCDriverParams:\n+                    URL: '@@SECRET:@@ENV:DOMAIN_UID@@-db-secret:url@@'\n+                    PasswordEncrypted: '@@SECRET:@@ENV:DOMAIN_UID@@-db-secret:password@@'\n+                    DriverName: oracle.jdbc.OracleDriver\n+                    Properties:\n+                        user:\n+                            Value: '@@SECRET:@@ENV:DOMAIN_UID@@-db-secret:username@@'"
  }
]
