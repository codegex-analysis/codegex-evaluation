[
  {
    "sha": "075bfc256d3fb9833d7e6cdc883b129cd56eb3b2",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/EntityConverter.java",
    "status": "added",
    "additions": 149,
    "deletions": 0,
    "changes": 149,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/EntityConverter.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/EntityConverter.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/EntityConverter.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.projectnessie.versioned.rocksdb;\n+\n+import java.util.Map;\n+\n+import org.projectnessie.versioned.store.Entity;\n+\n+import com.google.common.primitives.Ints;\n+\n+/**\n+ * Static methods to use for converting Entity objects to Rocks protobuf objects.\n+ */\n+class EntityConverter {\n+\n+  /**\n+   * This converts an Entity into Commit protobuf object.\n+   * @param entity the entity to convert\n+   * @return the object converted from the entity\n+   */\n+  static ValueProtos.Commit entityToCommit(Entity entity) {\n+    final ValueProtos.Commit.Builder builder = ValueProtos.Commit.newBuilder();\n+\n+    for (Map.Entry<String, Entity> entry : entity.getMap().entrySet()) {\n+      switch (entry.getKey()) {\n+        case RocksRef.COMMITS_ID:\n+          builder.setId(entry.getValue().getBinary());\n+          break;\n+        case RocksRef.COMMITS_PARENT:\n+          builder.setParent(entry.getValue().getBinary());\n+          break;\n+        case RocksRef.COMMITS_COMMIT:\n+          builder.setCommit(entry.getValue().getBinary());\n+          break;\n+        case RocksRef.COMMITS_DELTA:\n+          entry.getValue().getList().forEach(e -> builder.addDelta(entityToDelta(e)));\n+          break;\n+        case RocksRef.COMMITS_KEY_LIST:\n+          entry.getValue().getList().forEach(e -> builder.addKeyMutation(entityToKeyMutation(e)));\n+          break;\n+        default:\n+          throw new UnsupportedOperationException(String.format(\"Unknown field \\\"%s\\\" for commit\", entry.getKey()));\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  /**\n+   * This converts an Entity into Delta protobuf object.\n+   * @param entity the entity to convert\n+   * @return the object converted from the entity\n+   */\n+  static ValueProtos.Delta entityToDelta(Entity entity) {\n+    final ValueProtos.Delta.Builder builder = ValueProtos.Delta.newBuilder();\n+\n+    for (Map.Entry<String, Entity> entry : entity.getMap().entrySet()) {\n+      switch (entry.getKey()) {\n+        case RocksRef.COMMITS_POSITION:\n+          builder.setPosition(Ints.saturatedCast(entry.getValue().getNumber()));\n+          break;\n+        case RocksRef.COMMITS_OLD_ID:\n+          builder.setOldId(entry.getValue().getBinary());\n+          break;\n+        case RocksRef.COMMITS_NEW_ID:\n+          builder.setNewId(entry.getValue().getBinary());\n+          break;\n+        default:\n+          throw new UnsupportedOperationException(String.format(\"Unknown field \\\"%s\\\" for delta\", entry.getKey()));\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  /**\n+   * This converts an Entity into KeyMutation protobuf object.\n+   * @param entity the entity to convert\n+   * @return the object converted from the entity\n+   */\n+  static ValueProtos.KeyMutation entityToKeyMutation(Entity entity) {\n+    final ValueProtos.KeyMutation.Builder builder = ValueProtos.KeyMutation.newBuilder();\n+\n+    for (Map.Entry<String, Entity> entry : entity.getMap().entrySet()) {\n+      switch (entry.getKey()) {\n+        case RocksRef.COMMITS_KEY_ADDITION:\n+          builder.setType(ValueProtos.KeyMutation.MutationType.ADDITION);\n+          break;\n+        case RocksRef.COMMITS_KEY_REMOVAL:\n+          builder.setType(ValueProtos.KeyMutation.MutationType.REMOVAL);\n+          break;\n+        default:\n+          throw new UnsupportedOperationException(String.format(\"Unknown field \\\"%s\\\" for keyMutation\", entry.getKey()));\n+      }\n+\n+      builder.setKey(entityToKey(entry.getValue()));\n+    }\n+    return builder.build();\n+  }\n+\n+  /**\n+   * This converts an Entity into Key protobuf object.\n+   * @param entity the entity to convert\n+   * @return the object converted from the entity\n+   */\n+  static ValueProtos.Key entityToKey(Entity entity) {\n+    final ValueProtos.Key.Builder keyBuilder = ValueProtos.Key.newBuilder();\n+    entity.getList().forEach(e -> keyBuilder.addElements(e.getString()));\n+\n+    return keyBuilder.build();\n+  }\n+\n+  /**\n+   * This converts an Entity into KeyDelta protobuf object.\n+   * @param entity the entity to convert\n+   * @return the object converted from the entity\n+   */\n+  static ValueProtos.KeyDelta entityToKeyDelta(Entity entity) {\n+    final Map<String, Entity> entityMap = entity.getMap();\n+    final ValueProtos.KeyDelta.Builder keyDeltaBuilder = ValueProtos.KeyDelta.newBuilder();\n+\n+    for (Map.Entry<String, Entity> entry : entityMap.entrySet()) {\n+      switch (entry.getKey()) {\n+        case RocksL3.TREE_ID:\n+          keyDeltaBuilder.setId(entry.getValue().getBinary());\n+          break;\n+        case RocksL3.TREE_KEY:\n+          keyDeltaBuilder.setKey(entityToKey(entry.getValue()));\n+          break;\n+        default:\n+          throw new UnsupportedOperationException(String.format(\"Unknown field \\\"%s\\\" for keyDelta\", entry.getKey()));\n+      }\n+    }\n+\n+    return keyDeltaBuilder.build();\n+  }\n+}"
  },
  {
    "sha": "fc995239cf3b85e3d3311086b73648820f4f51a1",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/PathPattern.java",
    "status": "added",
    "additions": 207,
    "deletions": 0,
    "changes": 207,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/PathPattern.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/PathPattern.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/PathPattern.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.projectnessie.versioned.rocksdb;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.projectnessie.versioned.impl.condition.ExpressionFunction;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n+import org.projectnessie.versioned.impl.condition.ValueVisitor;\n+import org.projectnessie.versioned.store.Entity;\n+\n+/**\n+ * Path patterns provide a simple way to verify that an expression path matches what is expected. All\n+ * of the path will be matched against the pattern. An expression path consists of a sequence of name\n+ * and position components. For example, you could have the path \"foo[0]\". This path has the following components:\n+ * <ol>\n+ *   <li>foo - a name</li>\n+ *   <li>[0] - an index</li>\n+ *   <li>bar - a name</li>\n+ *   <li>[1] - an index</li>\n+ * </ol>\n+ * Path patterns support exact matching on parts of the path, and any matching. The following patterns all\n+ * match the example path above.\n+ * <ul>\n+ *   <li>PathPattern.exact().anyName().anyPosition()</li>\n+ *   <li>PathPattern.exact().anyName().positionEquals(0)</li>\n+ *   <li>PathPattern.exact().nameEquals(\"foo\").anyPosition()</li>\n+ *   <li>PathPattern.exact().nameEquals(\"foo\").positionEquals(0)</li>\n+ * </ul>\n+ * After building up a path pattern, you can test a path against it with the match method. ex.\n+ * <pre>\n+ *   boolean matches = PathPattern.exact().nameEquals(\"foo\").anyPosition().nameEquals(\"bar\").anyPosition().matches(path);\n+ * </pre>\n+ */\n+class PathPattern implements ValueVisitor<Boolean> {\n+  private final MatchType matchType;\n+  private final List<java.util.function.Function<ExpressionPath.PathSegment, Boolean>> pathPatternElements = new ArrayList<>();\n+\n+  enum MatchType {\n+    EXACT,\n+    PREFIX\n+  }\n+\n+  private PathPattern(MatchType matchType) {\n+    this.matchType = matchType;\n+  }\n+\n+  /**\n+   * Create a new exact match pattern starting with a provided name.\n+   * @param name the name the pattern starts with\n+   * @return the new PathPattern\n+   */\n+  static PathPattern exact(String name) {\n+    return new PathPattern(MatchType.EXACT).nameEquals(name);\n+  }\n+\n+  /**\n+   * Create a new exact match pattern starting with a provided position.\n+   * @param position the position the pattern starts with\n+   * @return the new PathPattern\n+   */\n+  static PathPattern exact(int position) {\n+    return new PathPattern(MatchType.EXACT).positionEquals(position);\n+  }\n+\n+  /**\n+   * Create a new prefix match pattern starting with a provided name.\n+   * @param name the name the pattern starts with\n+   * @return the new PathPattern\n+   */\n+  static PathPattern prefix(String name) {\n+    return new PathPattern(MatchType.PREFIX).nameEquals(name);\n+  }\n+\n+  /**\n+   * Create a new prefix match pattern starting with a provided position.\n+   * @param position the position the pattern starts with\n+   * @return the new PathPattern\n+   */\n+  static PathPattern prefix(int position) {\n+    return new PathPattern(MatchType.PREFIX).positionEquals(position);\n+  }\n+\n+  /**\n+   * Adds an exact name match path component.\n+   * @param name the name to match against\n+   * @return the object the pattern component is added to\n+   */\n+  PathPattern nameEquals(String name) {\n+    pathPatternElements.add((p) -> p.isName() && name.equals(p.asName().getName()));\n+    return this;\n+  }\n+\n+  /**\n+   * Adds an any name match path component.\n+   * @return the object the pattern component is added to\n+   */\n+  PathPattern anyName() {\n+    pathPatternElements.add(ExpressionPath.PathSegment::isName);\n+    return this;\n+  }\n+\n+  /**\n+   * Adds an exact position match component.\n+   * @param position the position to match against\n+   * @return the object the pattern component is added to\n+   */\n+  PathPattern positionEquals(int position) {\n+    pathPatternElements.add((p) -> p.isPosition() && position == p.asPosition().getPosition());\n+    return this;\n+  }\n+\n+  /**\n+   * Adds an any position match path component.\n+   * @return the object the pattern component is added to\n+   */\n+  PathPattern anyPosition() {\n+    pathPatternElements.add(ExpressionPath.PathSegment::isPosition);\n+    return this;\n+  }\n+\n+  /**\n+   * Not supported.\n+   * @param entity the Entity to visit.\n+   * @return throws an UnsupportedOperationException\n+   */\n+  @Override\n+  public Boolean visit(Entity entity) {\n+    throw new UnsupportedOperationException(\"Entity objects are not supported by PathPattern.\");\n+  }\n+\n+  /**\n+   * Not supported.\n+   * @param value the ExpressionFunction to visit.\n+   * @return throws an UnsupportedOperationException\n+   */\n+  @Override\n+  public Boolean visit(ExpressionFunction value) {\n+    throw new UnsupportedOperationException(\"ExpressionFunction objects are not supported by PathPattern.\");\n+  }\n+\n+  /**\n+   * Tests a path to see if it matches the configured pattern.\n+   * @param path the path to test\n+   * @return true if the path matches\n+   */\n+  @Override\n+  public Boolean visit(ExpressionPath path) {\n+    ExpressionPath.PathSegment currentNode = path.getRoot();\n+\n+    for (java.util.function.Function<ExpressionPath.PathSegment, Boolean> pathPatternElement : pathPatternElements) {\n+      if (currentNode == null || !pathPatternElement.apply(currentNode)) {\n+        return false;\n+      }\n+\n+      currentNode = currentNode.getChild().orElse(null);\n+    }\n+\n+    return matchType == MatchType.PREFIX || currentNode == null;\n+  }\n+\n+  ExpressionPath removePrefix(ExpressionPath path) {\n+    ExpressionPath.PathSegment currentNode = path.getRoot();\n+\n+    for (java.util.function.Function<ExpressionPath.PathSegment, Boolean> pathPatternElement : pathPatternElements) {\n+      if (currentNode == null || !pathPatternElement.apply(currentNode)) {\n+        return path;\n+      }\n+\n+      currentNode = currentNode.getChild().orElse(null);\n+    }\n+\n+    if (currentNode != null && currentNode.isName()) {\n+      ExpressionPath.PathSegment.Builder pathBuilder = ExpressionPath.builder(currentNode.asName().getName());\n+      currentNode = currentNode.getChild().orElse(null);\n+\n+      while (currentNode != null) {\n+        if (currentNode.isName()) {\n+          pathBuilder = pathBuilder.name(currentNode.asName().getName());\n+        } else {\n+          pathBuilder = pathBuilder.position(currentNode.asPosition().getPosition());\n+        }\n+\n+        currentNode = currentNode.getChild().orElse(null);\n+      }\n+\n+      return pathBuilder.build();\n+    } else {\n+      return null;\n+    }\n+  }\n+}"
  },
  {
    "sha": "fc96f59c6b168641e4047f7fb1248b0042f77ee8",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksBaseValue.java",
    "status": "modified",
    "additions": 267,
    "deletions": 2,
    "changes": 269,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksBaseValue.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksBaseValue.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksBaseValue.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -15,26 +15,35 @@\n  */\n package org.projectnessie.versioned.rocksdb;\n \n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n import java.util.NoSuchElementException;\n+import java.util.Optional;\n import java.util.stream.Collectors;\n \n import org.projectnessie.versioned.Key;\n import org.projectnessie.versioned.impl.condition.ExpressionPath;\n+import org.projectnessie.versioned.impl.condition.UpdateClause;\n+import org.projectnessie.versioned.impl.condition.UpdateExpression;\n import org.projectnessie.versioned.store.ConditionFailedException;\n import org.projectnessie.versioned.store.Entity;\n import org.projectnessie.versioned.store.Id;\n import org.projectnessie.versioned.tiered.BaseValue;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n \n /**\n  * An implementation of @{BaseValue} used for ConditionExpression and UpdateExpression evaluation.\n  * @param <C> Specialization of a specific BaseValue interface.\n  */\n-abstract class RocksBaseValue<C extends BaseValue<C>> implements BaseValue<C>, Evaluator {\n+abstract class RocksBaseValue<C extends BaseValue<C>> implements BaseValue<C>, Evaluator, Updater {\n \n   static final String ID = \"id\";\n+  static final String DATETIME = \"dt\";\n+\n   private final ValueProtos.BaseValue.Builder builder = ValueProtos.BaseValue.newBuilder();\n \n   RocksBaseValue() {\n@@ -145,7 +154,8 @@ void evaluatesId(Function function) throws ConditionFailedException {\n     }\n   }\n \n-  private Id getId() {\n+  @VisibleForTesting\n+  Id getId() {\n     return Id.of(buildBase().getId());\n   }\n \n@@ -164,6 +174,261 @@ protected static String conditionNotMatchedMessage(Function function) {\n       function.getRootPathAsNameSegment().getName());\n   }\n \n+  /**\n+   * Entry point to update this object with a series of UpdateClauses.\n+   * @param updates the updates to apply\n+   */\n+  @Override\n+  public void update(UpdateExpression updates) {\n+    final List<UpdateFunction> updatesToApply = removeUnnecessaryFunctions(updates.getClauses());\n+\n+    updatesToApply\n+        .stream()\n+        .filter(uf -> uf.getOperator() != UpdateFunction.Operator.REMOVE)\n+        .forEach(this::updateWithFunction);\n+\n+    /* Sort the PathSegments as follows\n+     * names before positions\n+     * names by string order\n+     * higher positions before lower positions\n+     * path with child before path without child\n+     * when equal, recurse in with the child segments\n+     */\n+    updatesToApply\n+        .stream()\n+        .filter(uf -> uf.getOperator() == UpdateFunction.Operator.REMOVE)\n+        .map(UpdateFunction::getPath)\n+        .sorted((path1, path2) -> compareSegments(path1.getRoot(), path2.getRoot())).forEach(this::remove);\n+  }\n+\n+  private static int compareSegments(ExpressionPath.PathSegment ps1, ExpressionPath.PathSegment ps2) {\n+    if (ps1.isName() && ps2.isName()) {\n+      if (ps1.asName().getName().equals(ps2.asName().getName())) {\n+        if (!ps1.getChild().isPresent() && ps2.getChild().isPresent()) {\n+          return 1;\n+        } else if (ps1.getChild().isPresent() && !ps2.getChild().isPresent()) {\n+          return -1;\n+        } else if (!ps1.getChild().isPresent() && !ps2.getChild().isPresent()) {\n+          return 0;\n+        } else {\n+          return compareSegments(ps1.getChild().get(), ps2.getChild().get());\n+        }\n+      } else {\n+        return ps1.asName().getName().compareTo(ps2.asName().getName());\n+      }\n+    } else if (ps1.isName()) {\n+      return -1;\n+    } else if (ps1.isPosition() && ps2.isPosition()) {\n+      return ps2.asPosition().getPosition() - ps1.asPosition().getPosition();\n+    } else {\n+      return 1;\n+    }\n+  }\n+\n+  /**\n+   * Filters through the list of UpdateClause objects to remove conflicting updates. The order of\n+   * the updates is preserved. Conflicts are defined as follows:\n+   * <ul>\n+   *   <li>Remove -&gt; Remove conflicts if latter remove is same node or a child node of former remove</li>\n+   *   <li>Remove -&gt; SetEquals conflicts if SetEquals is for the same node or a child node of Remove</li>\n+   *   <li>Remove -&gt; SetEquals conflicts if Remove is for a child node of SetEquals</li>\n+   *   <li>Remove -&gt; Append conflicts if Append is for the same node or a child node of Remove</li>\n+   *   <li>SetEquals -&gt; Remove conflicts if Remove is for a child node of SetEquals</li>\n+   *   <li>SetEquals -&gt; SetEquals conflicts if latter SetEquals is for child node of the former SetEquals</li>\n+   *   <li>SetEquals -&gt; Append conflicts if Append is for the same node or a child node of SetEquals</li>\n+   * </ul>\n+   * @param updateClauses The list of UpdateClause objects to filter\n+   * @return A safe list of UpdateFunction objects to apply\n+   */\n+  private List<UpdateFunction> removeUnnecessaryFunctions(List<UpdateClause> updateClauses) {\n+    final List<UpdateFunction> updateFunctions = updateClauses\n+        .stream()\n+        .map(uc -> uc.accept(RocksDBUpdateClauseVisitor.ROCKS_DB_UPDATE_CLAUSE_VISITOR))\n+        .collect(Collectors.toList());\n+    final boolean[] keepUpdateFunction = new boolean[updateFunctions.size()];\n+    Arrays.fill(keepUpdateFunction, true);\n+\n+    for (int i = 1; i < updateClauses.size(); i++) {\n+      final UpdateFunction currentUpdateFunction = updateFunctions.get(i);\n+      final String currentUpdatePath = currentUpdateFunction.getPath().asString();\n+      final UpdateFunction.Operator currentOperator = currentUpdateFunction.getOperator();\n+      final UpdateFunction.SetFunction.SubOperator currentSubOperator;\n+      if (currentOperator == UpdateFunction.Operator.SET) {\n+        currentSubOperator = ((UpdateFunction.SetFunction) currentUpdateFunction).getSubOperator();\n+      } else {\n+        currentSubOperator = null;\n+      }\n+\n+      for (int j = 0; j < i; j++) {\n+        if (!keepUpdateFunction[j]) {\n+          continue;\n+        }\n+\n+        final UpdateFunction earlierUpdateFunction = updateFunctions.get(j);\n+        final String earlierUpdatePath = earlierUpdateFunction.getPath().asString();\n+        final UpdateFunction.Operator earlierOperator = earlierUpdateFunction.getOperator();\n+        final UpdateFunction.SetFunction.SubOperator earlierSubOperator;\n+        if (earlierOperator == UpdateFunction.Operator.SET) {\n+          earlierSubOperator = ((UpdateFunction.SetFunction) earlierUpdateFunction).getSubOperator();\n+        } else {\n+          earlierSubOperator = null;\n+        }\n+\n+        if (currentOperator == UpdateFunction.Operator.REMOVE\n+            && earlierOperator == UpdateFunction.Operator.REMOVE) {\n+          if (currentUpdatePath.startsWith(earlierUpdatePath)) {\n+            keepUpdateFunction[i] = false;\n+          }\n+        } else if (earlierOperator == UpdateFunction.Operator.REMOVE\n+            && currentOperator == UpdateFunction.Operator.SET\n+            && currentSubOperator == UpdateFunction.SetFunction.SubOperator.EQUALS) {\n+          if (currentUpdatePath.startsWith(earlierUpdatePath)) {\n+            keepUpdateFunction[i] = false;\n+          } else if (earlierUpdatePath.startsWith(currentUpdatePath)) {\n+            keepUpdateFunction[j] = false;\n+          }\n+        } else if (earlierOperator == UpdateFunction.Operator.REMOVE\n+            && currentOperator == UpdateFunction.Operator.SET\n+            && currentSubOperator == UpdateFunction.SetFunction.SubOperator.APPEND_TO_LIST) {\n+          if (currentUpdatePath.startsWith(earlierUpdatePath)) {\n+            keepUpdateFunction[i] = false;\n+          }\n+        } else if (earlierOperator == UpdateFunction.Operator.SET\n+            && earlierSubOperator == UpdateFunction.SetFunction.SubOperator.EQUALS\n+            && currentOperator == UpdateFunction.Operator.REMOVE) {\n+          if (!currentUpdatePath.equals(earlierUpdatePath) && currentUpdatePath.startsWith(earlierUpdatePath)) {\n+            keepUpdateFunction[i] = false;\n+          }\n+        } else if (earlierOperator == UpdateFunction.Operator.SET\n+            && earlierSubOperator == UpdateFunction.SetFunction.SubOperator.EQUALS\n+            && currentOperator == UpdateFunction.Operator.SET\n+            && currentSubOperator == UpdateFunction.SetFunction.SubOperator.EQUALS) {\n+          if (!currentUpdatePath.equals(earlierUpdatePath) && currentUpdatePath.startsWith(earlierUpdatePath)) {\n+            keepUpdateFunction[i] = false;\n+          }\n+        } else if (earlierOperator == UpdateFunction.Operator.SET\n+            && earlierSubOperator == UpdateFunction.SetFunction.SubOperator.EQUALS\n+            && currentOperator == UpdateFunction.Operator.SET\n+            && currentSubOperator == UpdateFunction.SetFunction.SubOperator.APPEND_TO_LIST) {\n+          if (currentUpdatePath.startsWith(earlierUpdatePath)) {\n+            keepUpdateFunction[i] = false;\n+          }\n+        }\n+      }\n+    }\n+\n+    final List<UpdateFunction> functionsToApply = new ArrayList<>();\n+    for (int i = 0; i < keepUpdateFunction.length; i++) {\n+      if (keepUpdateFunction[i]) {\n+        functionsToApply.add(updateFunctions.get(i));\n+      }\n+    }\n+    return functionsToApply;\n+  }\n+\n+  // TODO: we might be able to provide implementation here and just have\n+  // abstract methods for SET and REMOVE, which will be implemented by the\n+  // specific classes L1, L2 etc.\n+  /**\n+   * Applies an update to the implementing class.\n+   * @param updateFunction the update to apply to the implementing class.\n+   */\n+  private void updateWithFunction(UpdateFunction updateFunction) {\n+    switch (updateFunction.getOperator()) {\n+      case REMOVE:\n+        return;\n+      case SET:\n+        updateWithSetFunction((UpdateFunction.SetFunction) updateFunction);\n+        break;\n+      default:\n+        throw new UnsupportedOperationException(String.format(\"Unknown operation \\\"%s\\\"\", updateFunction.getOperator()));\n+    }\n+  }\n+\n+  private void updateWithSetFunction(UpdateFunction.SetFunction setFunction) {\n+    switch (setFunction.getSubOperator()) {\n+      case APPEND_TO_LIST:\n+        final List<Entity> valuesToAppend;\n+        if (setFunction.getValue().getType() == Entity.EntityType.LIST) {\n+          valuesToAppend = setFunction.getValue().getList();\n+        } else {\n+          valuesToAppend = Collections.singletonList(setFunction.getValue());\n+        }\n+\n+        appendToList(setFunction.getPath(), valuesToAppend);\n+        break;\n+      case EQUALS:\n+        if (ID.equals(setFunction.getPath().getRoot().getName())) {\n+          id(Id.of(setFunction.getValue().getBinary()));\n+        } else if (DATETIME.equals(setFunction.getPath().getRoot().getName())) {\n+          dt(setFunction.getValue().getNumber());\n+        } else {\n+          set(setFunction.getPath(), setFunction.getValue());\n+        }\n+        break;\n+      default:\n+        throw new UnsupportedOperationException(String.format(\"Unknown sub operation \\\"%s\\\"\", setFunction.getSubOperator().name()));\n+    }\n+  }\n+\n+  private ExpressionPath removeLastPositionSegmentIfPosition(ExpressionPath path) {\n+    ExpressionPath.PathSegment currentNode = path.getRoot();\n+    ExpressionPath.PathSegment.Builder pathBuilder = ExpressionPath.builder(currentNode.asName().getName());\n+    currentNode = currentNode.getChild().orElse(null);\n+\n+    while (currentNode != null && (currentNode.getChild().isPresent() || currentNode.isName())) {\n+      if (currentNode.isPosition()) {\n+        pathBuilder = pathBuilder.position(currentNode.asPosition().getPosition());\n+      } else {\n+        pathBuilder = pathBuilder.name(currentNode.asName().getName());\n+      }\n+\n+      currentNode = currentNode.getChild().orElse(null);\n+    }\n+\n+    return pathBuilder.build();\n+  }\n+\n+  /**\n+   * Returns the int value nth path segment assuming it is a position segment.\n+   * @param path the path to parse\n+   * @param n index of the path segment\n+   * @return int value of the position at index n\n+   */\n+  protected int getPathSegmentAsPosition(ExpressionPath path, int n) {\n+    Optional<ExpressionPath.PathSegment> pathSegment = Optional.of(path.getRoot());\n+\n+    for (int i = 0; i < n && pathSegment.isPresent(); i++) {\n+      pathSegment = pathSegment.get().getChild();\n+    }\n+\n+    if (pathSegment.isPresent() && pathSegment.get().isPosition()) {\n+      return pathSegment.get().asPosition().getPosition();\n+    } else {\n+      throw new UnsupportedOperationException(\"Invalid expression path\");\n+    }\n+  }\n+\n+  /**\n+   * Removes a value from a field or subvalue of the field.\n+   * @param path the path of the node to remove\n+   */\n+  protected abstract void remove(ExpressionPath path);\n+\n+  /**\n+   * Adds a list of values to a node that is a list.\n+   * @param path the path of the node to append to\n+   * @param valuesToAdd list of values to add to the node\n+   */\n+  protected abstract void appendToList(ExpressionPath path, List<Entity> valuesToAdd);\n+\n+  /**\n+   * Updates the value of a node.\n+   * @param path the path of the node to update\n+   * @param newValue the new value for the node\n+   */\n+  protected abstract void set(ExpressionPath path, Entity newValue);\n+\n   /**\n    * Serialize the value to protobuf format.\n    * @return the value serialized as protobuf."
  },
  {
    "sha": "a138bc2090d29f7606cba323386c57319c4e19fc",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksCommitMetadata.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksCommitMetadata.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksCommitMetadata.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksCommitMetadata.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -24,6 +24,13 @@\n /**\n  * A RocksDB specific implementation of {@link org.projectnessie.versioned.tiered.CommitMetadata} providing\n  * SerDe and Condition evaluation.\n+ *\n+ * <p>Conceptually, this is matching the following JSON structure:</p>\n+ * <pre>{\n+ *   \"id\": &lt;ByteString&gt;,   // ID\n+ *   \"dt\": &lt;int64&gt;,        // DATETIME\n+ *   \"value\": &lt;ByteString&gt; // VALUE\n+ * }</pre>\n  */\n class RocksCommitMetadata extends RocksWrappedValue<CommitMetadata> implements CommitMetadata {\n   static CommitMetadata of(Id id, long dt, ByteString value) {"
  },
  {
    "sha": "fb4837be7d90c96a903f36dc14cc9b3b650a5fd2",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBStore.java",
    "status": "modified",
    "additions": 28,
    "deletions": 1,
    "changes": 29,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBStore.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBStore.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBStore.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -29,6 +29,7 @@\n import java.util.stream.Stream;\n import java.util.stream.StreamSupport;\n \n+import org.projectnessie.versioned.impl.EntityStoreHelper;\n import org.projectnessie.versioned.impl.condition.ConditionExpression;\n import org.projectnessie.versioned.impl.condition.UpdateExpression;\n import org.projectnessie.versioned.store.ConditionFailedException;\n@@ -106,6 +107,10 @@ public void start() {\n         }\n       }\n       valueTypeToColumnFamily = builder.build();\n+\n+      if (config.initializeDatabase()) {\n+        EntityStoreHelper.storeMinimumEntities(this::putIfAbsent);\n+      }\n     } catch (RocksDBException e) {\n       throw new RuntimeException(\"RocksDB failed to start\", e);\n     }\n@@ -246,7 +251,29 @@ public void save(List<SaveOp<?>> ops) {\n   public <C extends BaseValue<C>> boolean update(ValueType<C> type, Id id, UpdateExpression update,\n                                           Optional<ConditionExpression> condition, Optional<BaseValue<C>> consumer)\n       throws NotFoundException {\n-    throw new UnsupportedOperationException();\n+    final ColumnFamilyHandle columnFamilyHandle = getColumnFamilyHandle(type);\n+\n+    try (final Transaction transaction = rocksDB.beginTransaction(WRITE_OPTIONS)) {\n+      try {\n+        isConditionExpressionValid(transaction, columnFamilyHandle, id, type, condition, \"update\");\n+      } catch (ConditionFailedException e) {\n+        LOGGER.debug(\"Condition failed during update operation.\");\n+        return false;\n+      }\n+\n+      final RocksBaseValue<C> valueToUpdate = RocksSerDe.getConsumer(type);\n+      loadSingle(type, id, (C) valueToUpdate);\n+      valueToUpdate.update(update);\n+\n+      transaction.put(columnFamilyHandle, id.toBytes(), valueToUpdate.build());\n+      transaction.commit();\n+\n+      consumer.ifPresent(c -> RocksSerDe.deserializeToConsumer(type, valueToUpdate.build(), c));\n+    } catch (RocksDBException e) {\n+      throw new RuntimeException(String.format(\"update operation failed on %s for ID: %s\", type.name(), id), e);\n+    }\n+\n+    return true;\n   }\n \n   @Override"
  },
  {
    "sha": "267b7a72088c74237cb5faa73eee198a296d0ec8",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBStoreConfig.java",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBStoreConfig.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBStoreConfig.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBStoreConfig.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -15,10 +15,16 @@\n  */\n package org.projectnessie.versioned.rocksdb;\n \n+import org.immutables.value.Value;\n import org.immutables.value.Value.Immutable;\n \n @Immutable\n public abstract class RocksDBStoreConfig {\n \n   public abstract String getDbDirectory();\n+\n+  @Value.Default\n+  public boolean initializeDatabase() {\n+    return true;\n+  }\n }"
  },
  {
    "sha": "24aec81870e6ec20e0ca0e1bccf1769c1daea9f4",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBUpdateClauseVisitor.java",
    "status": "added",
    "additions": 70,
    "deletions": 0,
    "changes": 70,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBUpdateClauseVisitor.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBUpdateClauseVisitor.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBUpdateClauseVisitor.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.projectnessie.versioned.rocksdb;\n+\n+import org.projectnessie.versioned.impl.condition.AddClause;\n+import org.projectnessie.versioned.impl.condition.ExpressionFunction;\n+import org.projectnessie.versioned.impl.condition.RemoveClause;\n+import org.projectnessie.versioned.impl.condition.SetClause;\n+import org.projectnessie.versioned.impl.condition.UpdateClauseVisitor;\n+import org.projectnessie.versioned.store.Entity;\n+\n+/**\n+ * This provides a separation of generation of UpdateFunction from @{UpdateExpression} from the object itself.\n+ */\n+class RocksDBUpdateClauseVisitor implements UpdateClauseVisitor<UpdateFunction> {\n+  static final RocksDBUpdateClauseVisitor ROCKS_DB_UPDATE_CLAUSE_VISITOR = new RocksDBUpdateClauseVisitor();\n+\n+  @Override\n+  public UpdateFunction visit(final AddClause clause) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public UpdateFunction visit(RemoveClause clause) {\n+    return ImmutableRemoveFunction.builder().operator(UpdateFunction.Operator.REMOVE).path(clause.getPath()).build();\n+  }\n+\n+  @Override\n+  public UpdateFunction visit(SetClause clause) {\n+    switch (clause.getValue().getType()) {\n+      case VALUE:\n+        return ImmutableSetFunction.builder()\n+            .operator(UpdateFunction.Operator.SET)\n+            .subOperator(UpdateFunction.SetFunction.SubOperator.EQUALS)\n+            .path(clause.getPath())\n+            .value(clause.getValue().getValue())\n+            .build();\n+      case FUNCTION:\n+        return ImmutableSetFunction.builder()\n+            .operator(UpdateFunction.Operator.SET)\n+            .subOperator(UpdateFunction.SetFunction.SubOperator.APPEND_TO_LIST)\n+            .path(clause.getPath())\n+            .value(handleFunction(clause.getValue().getFunction()))\n+            .build();\n+      default:\n+        throw new UnsupportedOperationException(String.format(\"Unsupported SetClause type: %s\", clause.getValue().getType().name()));\n+    }\n+  }\n+\n+  private Entity handleFunction(ExpressionFunction expressionFunction) {\n+    if (ExpressionFunction.FunctionName.LIST_APPEND == expressionFunction.getName()) {\n+      return expressionFunction.getArguments().get(1).getValue();\n+    }\n+    throw new UnsupportedOperationException(String.format(\"Unsupported Set function: %s\", expressionFunction.getName()));\n+  }\n+}"
  },
  {
    "sha": "44a4930174d472c6e8b91a10a7f2debb0f17d43c",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBValueVisitor.java",
    "status": "modified",
    "additions": 11,
    "deletions": 13,
    "changes": 24,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBValueVisitor.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBValueVisitor.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksDBValueVisitor.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -64,21 +64,19 @@ public Function visit(ExpressionFunction value) {\n           arguments.size(), name.getArgCount(), name));\n     }\n \n-    switch (name) {\n-      case EQUALS:\n-        // Special case SIZE, as the object representation is not contained in one level of ExpressionFunction.\n-        if (isSize(arguments.get(0))) {\n-          return ImmutableFunction.builder().operator(Function.Operator.SIZE)\n-            .path(arguments.get(0).getFunction().getArguments().get(0).accept(EXPRESSION_PATH_VALUE_VISITOR))\n-            .value(arguments.get(1).getValue()).build();\n-        }\n-\n-        return ImmutableFunction.builder().operator(Function.Operator.EQUALS)\n-          .path(arguments.get(0).accept(EXPRESSION_PATH_VALUE_VISITOR))\n+    if (name == ExpressionFunction.FunctionName.EQUALS) {\n+      // Special case SIZE, as the object representation is not contained in one level of ExpressionFunction.\n+      if (isSize(arguments.get(0))) {\n+        return ImmutableFunction.builder().operator(Function.Operator.SIZE)\n+          .path(arguments.get(0).getFunction().getArguments().get(0).accept(EXPRESSION_PATH_VALUE_VISITOR))\n           .value(arguments.get(1).getValue()).build();\n-      default:\n-        throw new UnsupportedOperationException(String.format(\"%s is not a supported top-level RocksDB function.\", name));\n+      }\n+\n+      return ImmutableFunction.builder().operator(Function.Operator.EQUALS)\n+        .path(arguments.get(0).accept(EXPRESSION_PATH_VALUE_VISITOR))\n+        .value(arguments.get(1).getValue()).build();\n     }\n+    throw new UnsupportedOperationException(String.format(\"%s is not a supported top-level RocksDB function.\", name));\n   }\n \n   @Override"
  },
  {
    "sha": "e365fccf5df8bd7236cb121e5bd24eb2fb62e994",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksFragment.java",
    "status": "modified",
    "additions": 85,
    "deletions": 12,
    "changes": 97,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksFragment.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksFragment.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksFragment.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -22,6 +22,7 @@\n \n import org.projectnessie.versioned.ImmutableKey;\n import org.projectnessie.versioned.Key;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n import org.projectnessie.versioned.store.ConditionFailedException;\n import org.projectnessie.versioned.store.Entity;\n import org.projectnessie.versioned.store.StoreException;\n@@ -32,19 +33,33 @@\n /**\n  * A RocksDB specific implementation of {@link org.projectnessie.versioned.tiered.Fragment} providing\n  * SerDe and Condition evaluation.\n+ *\n+ * <p>Conceptually, this is matching the following JSON structure:</p>\n+ * <pre>{\n+ *   \"id\": &lt;ByteString&gt;, // ID\n+ *   \"dt\": &lt;int64&gt;,      // DATETIME\n+ *   \"keys\": [                 // KEY_LIST\n+ *     [\n+ *       &lt;String&gt;\n+ *     ]\n+ *   ]\n+ * }</pre>\n  */\n class RocksFragment extends RocksBaseValue<Fragment> implements Fragment {\n   static final String KEY_LIST = \"keys\";\n+  static final PathPattern KEY_LIST_EXACT = PathPattern.exact(KEY_LIST);\n+  static final PathPattern KEY_LIST_INDEX_EXACT = PathPattern.exact(KEY_LIST).anyPosition();\n+  static final PathPattern KEY_LIST_INNER_INDEX_EXACT = PathPattern.exact(KEY_LIST).anyPosition().anyPosition();\n \n-  private final ValueProtos.Fragment.Builder builder = ValueProtos.Fragment.newBuilder();\n+  private final ValueProtos.Fragment.Builder fragmentBuilder = ValueProtos.Fragment.newBuilder();\n \n   RocksFragment() {\n     super();\n   }\n \n   @Override\n   public Fragment keys(Stream<Key> keys) {\n-    builder\n+    fragmentBuilder\n         .clearKeys()\n         .addAllKeys(keys.map(key -> ValueProtos.Key\n             .newBuilder()\n@@ -57,9 +72,9 @@ public Fragment keys(Stream<Key> keys) {\n \n   @Override\n   byte[] build() {\n-    checkPresent(builder.getKeysList(), KEY_LIST);\n+    checkPresent(fragmentBuilder.getKeysList(), KEY_LIST);\n \n-    return builder.setBase(buildBase()).build().toByteArray();\n+    return fragmentBuilder.setBase(buildBase()).build().toByteArray();\n   }\n \n   /**\n@@ -93,7 +108,7 @@ public void evaluate(Function function) throws ConditionFailedException {\n             throw new ConditionFailedException(conditionNotMatchedMessage(function));\n           }\n         } else if (function.getOperator().equals(Function.Operator.SIZE)) {\n-          if (builder.getKeysCount() != function.getValue().getNumber()) {\n+          if (fragmentBuilder.getKeysCount() != function.getValue().getNumber()) {\n             throw new ConditionFailedException(conditionNotMatchedMessage(function));\n           }\n         } else {\n@@ -107,14 +122,13 @@ public void evaluate(Function function) throws ConditionFailedException {\n   }\n \n   private List<Key> getKeys() {\n-    return builder.getKeysList()\n+    return fragmentBuilder.getKeysList()\n       .stream()\n-      .map(key ->\n-        ImmutableKey\n-          .builder()\n-          .addAllElements(new ArrayList<>(key.getElementsList()))\n-          .build()\n-      )\n+      .map(key -> {\n+        final ImmutableKey.Builder keyBuilder = ImmutableKey.builder();\n+        key.getElementsList().forEach(keyBuilder::addElements);\n+        return keyBuilder.build();\n+      })\n       .collect(Collectors.toList());\n   }\n \n@@ -127,4 +141,63 @@ public void evaluate(Function function) throws ConditionFailedException {\n   private Entity keysAsEntityList(List<Key> keys) {\n     return Entity.ofList(keys.stream().map(k -> Entity.ofList(k.getElements().stream().map(Entity::ofString))));\n   }\n+\n+  @Override\n+  protected void remove(ExpressionPath path) {\n+    // keys[*]\n+    if (path.accept(KEY_LIST_INDEX_EXACT)) {\n+      final int i = getPathSegmentAsPosition(path, 1);\n+      fragmentBuilder.removeKeys(i);\n+    // keys[*][*]\n+    } else if (path.accept(KEY_LIST_INNER_INDEX_EXACT)) {\n+      final int outerIndex = getPathSegmentAsPosition(path, 1);\n+      final int innerIndex = getPathSegmentAsPosition(path, 2);\n+\n+      final List<String> updatedKeys = new ArrayList<>(fragmentBuilder.getKeys(outerIndex).getElementsList());\n+      updatedKeys.remove(innerIndex);\n+\n+      final ValueProtos.Key.Builder keyBuilder = ValueProtos.Key.newBuilder();\n+      updatedKeys.forEach(keyBuilder::addElements);\n+\n+      fragmentBuilder.setKeys(outerIndex, keyBuilder);\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for remove in Fragment\", path.asString()));\n+    }\n+  }\n+\n+  @Override\n+  protected void appendToList(ExpressionPath path, List<Entity> valuesToAdd) {\n+    if (path.accept(KEY_LIST_EXACT)) {\n+      valuesToAdd.forEach(v -> fragmentBuilder.addKeys(EntityConverter.entityToKey(v)));\n+    } else if (path.accept(KEY_LIST_INDEX_EXACT)) {\n+      final int i = getPathSegmentAsPosition(path, 1);\n+\n+      final ValueProtos.Key.Builder keyBuilder = ValueProtos.Key.newBuilder(fragmentBuilder.getKeys(i));\n+      valuesToAdd.forEach(e -> keyBuilder.addElements(e.getString()));\n+\n+      fragmentBuilder.setKeys(i, keyBuilder);\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for append in Fragment\", path.asString()));\n+    }\n+  }\n+\n+  @Override\n+  protected void set(ExpressionPath path, Entity newValue) {\n+    if (path.accept(KEY_LIST_EXACT)) {\n+      fragmentBuilder.clearKeys();\n+      newValue.getList().forEach(v -> fragmentBuilder.addKeys(EntityConverter.entityToKey(v)));\n+    } else if (path.accept(KEY_LIST_INDEX_EXACT)) {\n+      final int i = getPathSegmentAsPosition(path, 1);\n+      fragmentBuilder.setKeys(i, EntityConverter.entityToKey(newValue));\n+    } else if (path.accept(KEY_LIST_INNER_INDEX_EXACT)) {\n+      final int outerIndex = getPathSegmentAsPosition(path, 1);\n+      final int innerIndex = getPathSegmentAsPosition(path, 2);\n+\n+      fragmentBuilder.setKeys(outerIndex, ValueProtos.Key\n+          .newBuilder(fragmentBuilder.getKeys(outerIndex))\n+          .setElements(innerIndex, newValue.getString()));\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for set equals in Fragment\", path.asString()));\n+    }\n+  }\n }"
  },
  {
    "sha": "3210b3bd181a370ef0ddc3d64f1d4d961bf7b6b9",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksL1.java",
    "status": "modified",
    "additions": 264,
    "deletions": 64,
    "changes": 328,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksL1.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksL1.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksL1.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -15,6 +15,8 @@\n  */\n package org.projectnessie.versioned.rocksdb;\n \n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n@@ -26,73 +28,119 @@\n import org.projectnessie.versioned.store.StoreException;\n import org.projectnessie.versioned.tiered.L1;\n \n+import com.google.protobuf.ByteString;\n import com.google.protobuf.InvalidProtocolBufferException;\n \n /**\n  * A RocksDB specific implementation of {@link org.projectnessie.versioned.tiered.L1} providing\n  * SerDe and Condition evaluation.\n+ *\n+ * <p>Conceptually, this is matching the following JSON structure:</p>\n+ * <pre>{\n+ *   \"id\": &lt;ByteString&gt;,         // ID\n+ *   \"dt\": &lt;int64&gt;,              // DATETIME\n+ *   \"metadataId\": &lt;ByteString&gt;, // COMMIT_METADATA\n+ *   \"ancestors\": [                    // ANCESTORS\n+ *     &lt;ByteString&gt;\n+ *   ],\n+ *   \"tree\": [                         // TREE\n+ *     &lt;ByteString&gt;\n+ *   ],\n+ *   \"mutations\": [                    // KEY_MUTATIONS\n+ *     {\n+ *       0: [                          // Addition (any number of these)\n+ *         &lt;String&gt;\n+ *       ],\n+ *     },\n+ *     {\n+ *       1: [                          // Removal (any number of these)\n+ *         &lt;String&gt;\n+ *       ]\n+ *     }\n+ *   ],\n+ *   \"origin\": &lt;ByteString&gt;,     // CHECKPOINT_ID\n+ *   \"dist\": &lt;int32&gt;,            // DISTANCE_FROM_CHECKPOINT\n+ *   \"fragments\": [                    // COMPLETE_KEY_LIST\n+ *     &lt;ByteString&gt;\n+ *   ]\n+ * }</pre>\n+ *\n+ * <p>NOTE: Will either contain both origin and dist, or just fragments. Cannot contain all three\n+ * fields.\n  */\n class RocksL1 extends RocksBaseValue<L1> implements L1 {\n \n   static final int SIZE = 43;\n   static final String COMMIT_METADATA = \"metadataId\";\n-  static final String ANCESTORS = \"ancestors\";\n-  static final String CHILDREN = \"children\";\n-  static final String KEY_LIST = \"keylist\";\n-  static final String INCREMENTAL_KEY_LIST = \"incrementalKeyList\";\n-  static final String COMPLETE_KEY_LIST = \"completeKeyList\";\n-  static final String CHECKPOINT_ID = \"checkpointId\";\n-  static final String DISTANCE_FROM_CHECKPOINT = \"distanceFromCheckpoint\";\n+  static final String ANCESTORS = \"parents\";\n+  static final String TREE = \"tree\";\n+  static final String KEY_MUTATIONS = \"mutations\";\n+  static final String KEY_MUTATIONS_KEY = \"key\";\n+  static final String COMPLETE_KEY_LIST = \"fragments\";\n+  static final String CHECKPOINT_ID = \"origin\";\n+  static final String DISTANCE_FROM_CHECKPOINT = \"dist\";\n+  static final PathPattern ANCESTORS_EXACT = PathPattern.exact(ANCESTORS);\n+  static final PathPattern ANCESTORS_INDEX_EXACT = PathPattern.exact(ANCESTORS).anyPosition();\n+  static final PathPattern TREE_EXACT = PathPattern.exact(TREE);\n+  static final PathPattern TREE_INDEX_EXACT = PathPattern.exact(TREE).anyPosition();\n+  static final PathPattern KEY_MUTATIONS_EXACT = PathPattern.exact(KEY_MUTATIONS);\n+  static final PathPattern KEY_MUTATIONS_INDEX_EXACT = PathPattern.exact(KEY_MUTATIONS).anyPosition();\n+  static final PathPattern KEY_MUTATIONS_INDEX_PREFIX = PathPattern.prefix(KEY_MUTATIONS).anyPosition();\n+  static final PathPattern KEY_MUTATIONS_KEY_FULL_EXACT = PathPattern.exact(KEY_MUTATIONS).anyPosition().nameEquals(KEY_MUTATIONS_KEY);\n+  static final PathPattern KEY_MUTATIONS_KEY_INDEX_FULL_EXACT = PathPattern.exact(KEY_MUTATIONS).anyPosition()\n+      .nameEquals(KEY_MUTATIONS_KEY).anyPosition();\n+  static final PathPattern KEY_MUTATIONS_KEY_EXACT = PathPattern.exact(KEY_MUTATIONS_KEY);\n+  static final PathPattern KEY_MUTATIONS_KEY_INDEX_EXACT = PathPattern.exact(KEY_MUTATIONS_KEY).anyPosition();\n+  static final PathPattern COMPLETE_KEY_LIST_EXACT = PathPattern.exact(COMPLETE_KEY_LIST);\n+  static final PathPattern COMPLETE_KEY_LIST_INDEX_EXACT = PathPattern.exact(COMPLETE_KEY_LIST).anyPosition();\n+  static final PathPattern CHECKPOINT_ID_EXACT = PathPattern.exact(CHECKPOINT_ID);\n+  static final PathPattern DISTANCE_FROM_CHECKPOINT_EXACT = PathPattern.exact(DISTANCE_FROM_CHECKPOINT);\n+  static final PathPattern COMMIT_METADATA_EXACT = PathPattern.exact(COMMIT_METADATA);\n \n-  private final ValueProtos.L1.Builder builder = ValueProtos.L1.newBuilder();\n+  private final ValueProtos.L1.Builder l1Builder = ValueProtos.L1.newBuilder();\n \n   RocksL1() {\n     super();\n   }\n \n   @Override\n   public L1 commitMetadataId(Id id) {\n-    builder.setMetadataId(id.getValue());\n+    l1Builder.setMetadataId(id.getValue());\n     return this;\n   }\n \n   @Override\n   public L1 ancestors(Stream<Id> ids) {\n-    builder\n-        .clearAncestors()\n-        .addAllAncestors(ids.map(Id::getValue).collect(Collectors.toList()));\n+    l1Builder.clearAncestors();\n+    ids.forEach(id -> l1Builder.addAncestors(id.getValue()));\n     return this;\n   }\n \n   @Override\n   public L1 children(Stream<Id> ids) {\n-    builder\n-        .clearTree()\n-        .addAllTree(ids.map(Id::getValue).collect(Collectors.toList()));\n+    l1Builder.clearTree();\n+    ids.forEach(id -> l1Builder.addTree(id.getValue()));\n     return this;\n   }\n \n   @Override\n   public L1 keyMutations(Stream<Key.Mutation> keyMutations) {\n-    builder\n-        .clearKeyMutations()\n-        .addAllKeyMutations(\n-            keyMutations.map(km ->\n-                ValueProtos.KeyMutation\n-                    .newBuilder()\n-                    .setTypeValue(km.getType().ordinal())\n-                    .setKey(\n-                        ValueProtos.Key.newBuilder().addAllElements(km.getKey().getElements()).build()\n-                    )\n-                    .build())\n-            .collect(Collectors.toList())\n-        );\n+    l1Builder.clearKeyMutations();\n+\n+    keyMutations.forEach(km -> {\n+      final ValueProtos.KeyMutation.Builder keyMutationBuilder = ValueProtos.KeyMutation.newBuilder();\n+      keyMutationBuilder.setTypeValue(km.getType().ordinal());\n+      keyMutationBuilder.setKey(ValueProtos.Key.newBuilder().addAllElements(km.getKey().getElements()));\n+\n+      l1Builder.addKeyMutations(keyMutationBuilder);\n+    });\n+\n     return this;\n   }\n \n   @Override\n   public L1 incrementalKeyList(Id checkpointId, int distanceFromCheckpoint) {\n-    builder.setIncrementalList(\n+    l1Builder.setIncrementalList(\n         ValueProtos.IncrementalList\n             .newBuilder()\n             .setCheckpointId(checkpointId.getValue())\n@@ -104,12 +152,9 @@ public L1 incrementalKeyList(Id checkpointId, int distanceFromCheckpoint) {\n \n   @Override\n   public L1 completeKeyList(Stream<Id> fragmentIds) {\n-    builder.setCompleteList(\n-        ValueProtos.CompleteList\n-          .newBuilder()\n-          .addAllFragmentIds(fragmentIds.map(Id::getValue).collect(Collectors.toList()))\n-          .build()\n-    );\n+    final ValueProtos.CompleteList.Builder completeListBuilder = ValueProtos.CompleteList.newBuilder();\n+    fragmentIds.forEach(id -> completeListBuilder.addFragmentIds(id.getValue()));\n+    l1Builder.setCompleteList(completeListBuilder);\n     return this;\n   }\n \n@@ -123,59 +168,178 @@ public void evaluate(Function function) throws ConditionFailedException {\n         break;\n       case COMMIT_METADATA:\n         if (!function.isRootNameSegmentChildlessAndEquals()\n-            || !Id.of(builder.getMetadataId()).toEntity().equals(function.getValue())) {\n+            || !Id.of(l1Builder.getMetadataId()).toEntity().equals(function.getValue())) {\n           throw new ConditionFailedException(conditionNotMatchedMessage(function));\n         }\n         break;\n       case ANCESTORS:\n-        evaluate(function, builder.getAncestorsList().stream().map(Id::of).collect(Collectors.toList()));\n+        evaluate(function, l1Builder.getAncestorsList().stream().map(Id::of).collect(Collectors.toList()));\n         break;\n-      case CHILDREN:\n-        evaluate(function, builder.getTreeList().stream().map(Id::of).collect(Collectors.toList()));\n+      case TREE:\n+        evaluate(function, l1Builder.getTreeList().stream().map(Id::of).collect(Collectors.toList()));\n         break;\n-      case KEY_LIST:\n+      case KEY_MUTATIONS:\n         throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n-      case INCREMENTAL_KEY_LIST:\n-        if (!nameSegment.getChild().isPresent() || !function.getOperator().equals(Function.Operator.EQUALS)) {\n-          throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n+      case CHECKPOINT_ID:\n+        if (!Id.of(l1Builder.getIncrementalList().getCheckpointId()).toEntity().equals(function.getValue())) {\n+          throw new ConditionFailedException(conditionNotMatchedMessage(function));\n         }\n-        final String childName = nameSegment.getChild().get().asName().getName();\n-        if (childName.equals(CHECKPOINT_ID)) {\n-          if (!Id.of(builder.getIncrementalList().getCheckpointId()).toEntity().equals(function.getValue())) {\n-            throw new ConditionFailedException(conditionNotMatchedMessage(function));\n-          }\n-        } else if (childName.equals((DISTANCE_FROM_CHECKPOINT))) {\n-          if (!Entity.ofNumber(builder.getIncrementalList().getDistanceFromCheckpointId()).equals(function.getValue())) {\n-            throw new ConditionFailedException(conditionNotMatchedMessage(function));\n-          }\n-        } else {\n-          // Invalid Condition Function.\n-          throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n+        break;\n+      case DISTANCE_FROM_CHECKPOINT:\n+        if (!Entity.ofNumber(l1Builder.getIncrementalList().getDistanceFromCheckpointId()).equals(function.getValue())) {\n+          throw new ConditionFailedException(conditionNotMatchedMessage(function));\n         }\n         break;\n       case COMPLETE_KEY_LIST:\n-        evaluate(function, builder.getCompleteList().getFragmentIdsList().stream().map(Id::of).collect(Collectors.toList()));\n+        evaluate(function, l1Builder.getCompleteList().getFragmentIdsList().stream().map(Id::of).collect(Collectors.toList()));\n         break;\n       default:\n         // Invalid Condition Function.\n         throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n     }\n   }\n \n+  @Override\n+  protected void remove(ExpressionPath path) {\n+    // parents[*]\n+    if (path.accept(ANCESTORS_INDEX_EXACT)) {\n+      List<ByteString> updatedAncestors = new ArrayList<>(l1Builder.getAncestorsList());\n+      updatedAncestors.remove(getPathSegmentAsPosition(path, 1));\n+      l1Builder.clearAncestors().addAllAncestors(updatedAncestors);\n+    // tree[*]\n+    } else if (path.accept(TREE_INDEX_EXACT)) {\n+      List<ByteString> updatedChildren = new ArrayList<>(l1Builder.getTreeList());\n+      updatedChildren.remove(getPathSegmentAsPosition(path, 1));\n+      l1Builder.clearTree().addAllTree(updatedChildren);\n+    // mutations[*]\n+    } else if (path.accept(KEY_MUTATIONS_INDEX_EXACT)) {\n+      l1Builder.removeKeyMutations(getPathSegmentAsPosition(path, 1));\n+    // mutations[*]/key[*]\n+    } else if (path.accept(KEY_MUTATIONS_KEY_INDEX_FULL_EXACT)) {\n+      final int keyMutationsIndex = getPathSegmentAsPosition(path, 1);\n+      final int keyIndex = getPathSegmentAsPosition(path, 3);\n+\n+      final List<String> updatedKeysList = new ArrayList<>(l1Builder.getKeyMutations(keyMutationsIndex).getKey().getElementsList());\n+      updatedKeysList.remove(keyIndex);\n+      l1Builder.setKeyMutations(keyMutationsIndex, ValueProtos.KeyMutation\n+          .newBuilder(l1Builder.getKeyMutations(keyMutationsIndex))\n+          .setKey(ValueProtos.Key.newBuilder().addAllElements(updatedKeysList))\n+      );\n+    // fragments[*]\n+    } else if (path.accept(COMPLETE_KEY_LIST_INDEX_EXACT)) {\n+      List<ByteString> updatedKeyList = new ArrayList<>(l1Builder.getCompleteList().getFragmentIdsList());\n+      updatedKeyList.remove(getPathSegmentAsPosition(path, 1));\n+      l1Builder.setCompleteList(ValueProtos.CompleteList.newBuilder().addAllFragmentIds(updatedKeyList));\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for remove in L1\", path.asString()));\n+    }\n+  }\n+\n+  @Override\n+  protected void appendToList(ExpressionPath path, List<Entity> valuesToAdd) {\n+    if (path.accept(ANCESTORS_EXACT)) {\n+      valuesToAdd.forEach(e -> l1Builder.addAncestors(e.getBinary()));\n+    } else if (path.accept(TREE_EXACT)) {\n+      valuesToAdd.forEach(e -> l1Builder.addTree(e.getBinary()));\n+    } else if (path.accept(KEY_MUTATIONS_EXACT)) {\n+      valuesToAdd.forEach(e -> l1Builder.addTree(e.getBinary()));\n+    } else if (path.accept(KEY_MUTATIONS_KEY_FULL_EXACT)) {\n+      final int i = getPathSegmentAsPosition(path, 1);\n+\n+      final ValueProtos.Key.Builder keyBuilder = ValueProtos.Key.newBuilder(l1Builder.getKeyMutations(i).getKey());\n+      valuesToAdd.forEach(e -> keyBuilder.addElements(e.getString()));\n+      l1Builder.setKeyMutations(i, ValueProtos.KeyMutation\n+          .newBuilder(l1Builder.getKeyMutations(i))\n+          .setKey(keyBuilder));\n+    } else if (path.accept(COMPLETE_KEY_LIST_EXACT)) {\n+      List<ByteString> updatedKeyList = new ArrayList<>(l1Builder.getCompleteList().getFragmentIdsList());\n+      updatedKeyList.addAll(valuesToAdd.stream().map(Entity::getBinary).collect(Collectors.toList()));\n+\n+      final ValueProtos.CompleteList.Builder completeListBuilder = ValueProtos.CompleteList.newBuilder();\n+      updatedKeyList.forEach(completeListBuilder::addFragmentIds);\n+      l1Builder.setCompleteList(completeListBuilder);\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for append in L1\", path.asString()));\n+    }\n+  }\n+\n+  @Override\n+  protected void set(ExpressionPath path, Entity newValue) {\n+    if (path.accept(ANCESTORS_EXACT)) {\n+      l1Builder.clearAncestors();\n+      newValue.getList().forEach(e -> l1Builder.addAncestors(e.getBinary()));\n+    } else if (path.accept(ANCESTORS_INDEX_EXACT)) {\n+      l1Builder.setAncestors(getPathSegmentAsPosition(path, 1), newValue.getBinary());\n+    } else if (path.accept(TREE_EXACT)) {\n+      l1Builder.clearTree();\n+      newValue.getList().forEach(e -> l1Builder.addTree(e.getBinary()));\n+    } else if (path.accept(TREE_INDEX_EXACT)) {\n+      l1Builder.setTree(getPathSegmentAsPosition(path, 1), newValue.getBinary());\n+    } else if (path.accept(KEY_MUTATIONS_EXACT)) {\n+      l1Builder.clearKeyMutations();\n+      newValue.getList().forEach(e -> l1Builder.addKeyMutations(EntityConverter.entityToKeyMutation(e)));\n+    } else if (path.accept(KEY_MUTATIONS_INDEX_EXACT)) {\n+      final int i = getPathSegmentAsPosition(path, 1);\n+      l1Builder.setKeyMutations(i, EntityConverter.entityToKeyMutation(newValue));\n+    } else if (path.accept(KEY_MUTATIONS_INDEX_PREFIX)) {\n+      setsKeyMutations(getPathSegmentAsPosition(path, 1), KEY_MUTATIONS_INDEX_PREFIX.removePrefix(path), newValue);\n+    } else if (path.accept(COMPLETE_KEY_LIST_EXACT)) {\n+      final ValueProtos.CompleteList.Builder completeListBuilder = ValueProtos.CompleteList.newBuilder();\n+      newValue.getList().forEach(e -> completeListBuilder.addFragmentIds(e.getBinary()));\n+      l1Builder.setCompleteList(completeListBuilder);\n+    } else if (path.accept(COMPLETE_KEY_LIST_INDEX_EXACT)) {\n+      final int i = getPathSegmentAsPosition(path, 1);\n+      l1Builder.setCompleteList(ValueProtos.CompleteList.newBuilder(l1Builder.getCompleteList()).setFragmentIds(i, newValue.getBinary()));\n+    } else if (path.accept(CHECKPOINT_ID_EXACT)) {\n+      l1Builder.setIncrementalList(ValueProtos.IncrementalList\n+          .newBuilder(l1Builder.getIncrementalList())\n+          .setCheckpointId(newValue.getBinary())\n+      );\n+    } else if (path.accept(DISTANCE_FROM_CHECKPOINT_EXACT)) {\n+      l1Builder.setIncrementalList(ValueProtos.IncrementalList\n+          .newBuilder(l1Builder.getIncrementalList())\n+          .setDistanceFromCheckpointId((int)newValue.getNumber())\n+      );\n+    } else if (path.accept(COMMIT_METADATA_EXACT)) {\n+      commitMetadataId(Id.of(newValue.getBinary()));\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for set equals in L1\", path.asString()));\n+    }\n+  }\n+\n+  void setsKeyMutations(int keyMutationIndex, ExpressionPath path, Entity newValue) {\n+    if (path.accept(KEY_MUTATIONS_KEY_EXACT)) {\n+      l1Builder.setKeyMutations(keyMutationIndex, ValueProtos.KeyMutation\n+          .newBuilder(l1Builder.getKeyMutations(keyMutationIndex))\n+          .setKey(EntityConverter.entityToKey(newValue)));\n+    } else if (path.accept(KEY_MUTATIONS_KEY_INDEX_EXACT)) {\n+      final int keyIndex = getPathSegmentAsPosition(path, 1);\n+\n+      l1Builder.setKeyMutations(keyMutationIndex, ValueProtos.KeyMutation\n+          .newBuilder(l1Builder.getKeyMutations(keyMutationIndex))\n+          .setKey(ValueProtos.Key\n+            .newBuilder(l1Builder.getKeyMutations(keyMutationIndex).getKey())\n+            .setElements(keyIndex, newValue.getString())));\n+    } else {\n+      throw new UnsupportedOperationException(\n+          String.format(\"%s is not a valid path for set equals in L1.keyMutations[%d]\", path.asString(), keyMutationIndex));\n+    }\n+  }\n+\n   @Override\n   byte[] build() {\n-    checkPresent(builder.getMetadataId(), COMMIT_METADATA);\n-    checkPresent(builder.getAncestorsList(), ANCESTORS);\n-    checkPresent(builder.getTreeList(), CHILDREN);\n-    checkPresent(builder.getKeyMutationsList(), KEY_LIST);\n+    checkPresent(l1Builder.getMetadataId(), COMMIT_METADATA);\n+    checkPresent(l1Builder.getAncestorsList(), ANCESTORS);\n+    checkPresent(l1Builder.getTreeList(), TREE);\n+    checkPresent(l1Builder.getKeyMutationsList(), KEY_MUTATIONS);\n \n-    if (builder.hasIncrementalList()) {\n-      checkPresent(builder.getIncrementalList().getCheckpointId(), CHECKPOINT_ID);\n+    if (l1Builder.hasIncrementalList()) {\n+      checkPresent(l1Builder.getIncrementalList().getCheckpointId(), CHECKPOINT_ID);\n     } else {\n-      checkPresent(builder.getCompleteList().getFragmentIdsList(), COMPLETE_KEY_LIST);\n+      checkPresent(l1Builder.getCompleteList().getFragmentIdsList(), COMPLETE_KEY_LIST);\n     }\n \n-    return builder.setBase(buildBase()).build().toByteArray();\n+    return l1Builder.setBase(buildBase()).build().toByteArray();\n   }\n \n   /**\n@@ -203,4 +367,40 @@ static void toConsumer(byte[] value, L1 consumer) {\n       throw new StoreException(\"Corrupt L1 value encountered when deserializing.\", e);\n     }\n   }\n+\n+  Id getMetadataId() {\n+    return Id.of(l1Builder.getMetadataId());\n+  }\n+\n+  Id getCheckpointId() {\n+    return Id.of(l1Builder.getIncrementalList().getCheckpointId());\n+  }\n+\n+  int getDistanceFromCheckpoint() {\n+    return l1Builder.getIncrementalList().getDistanceFromCheckpointId();\n+  }\n+\n+  Stream<Id> getChildren() {\n+    return l1Builder.getTreeList().stream().map(Id::of);\n+  }\n+\n+  Stream<Id> getAncestors() {\n+    return l1Builder.getAncestorsList().stream().map(Id::of);\n+  }\n+\n+  Stream<Id> getCompleteKeyList() {\n+    return l1Builder.getCompleteList().getFragmentIdsList().stream().map(Id::of);\n+  }\n+\n+  int getKeyMutationsCount() {\n+    return l1Builder.getKeyMutationsCount();\n+  }\n+\n+  int getKeyMutationType(int index) {\n+    return l1Builder.getKeyMutations(index).getTypeValue();\n+  }\n+\n+  List<String> getKeyMutationKeys(int index) {\n+    return l1Builder.getKeyMutations(index).getKey().getElementsList();\n+  }\n }"
  },
  {
    "sha": "e61b52631735d49b91f238199d588900996a44bc",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksL2.java",
    "status": "modified",
    "additions": 63,
    "deletions": 9,
    "changes": 72,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksL2.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksL2.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksL2.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -16,34 +16,49 @@\n \n package org.projectnessie.versioned.rocksdb;\n \n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n import org.projectnessie.versioned.store.ConditionFailedException;\n+import org.projectnessie.versioned.store.Entity;\n import org.projectnessie.versioned.store.Id;\n import org.projectnessie.versioned.store.StoreException;\n import org.projectnessie.versioned.tiered.L2;\n \n+import com.google.protobuf.ByteString;\n import com.google.protobuf.InvalidProtocolBufferException;\n \n /**\n  * A RocksDB specific implementation of {@link org.projectnessie.versioned.tiered.L2} providing\n  * SerDe and Condition evaluation.\n+ *\n+ * <p>Conceptually, this is matching the following JSON structure:</p>\n+ * <pre>{\n+ *   \"id\": &lt;ByteString&gt;, // ID\n+ *   \"dt\": &lt;int64&gt;,      // DATETIME\n+ *   \"tree\": [                 // TREE\n+ *     &lt;ByteString&gt;\n+ *   ]\n+ * }</pre>\n  */\n class RocksL2 extends RocksBaseValue<L2> implements L2 {\n-  private static final String CHILDREN = \"children\";\n+  static final String TREE = \"tree\";\n+  static final PathPattern TREE_EXACT = PathPattern.exact(TREE);\n+  static final PathPattern TREE_INDEX_EXACT = PathPattern.exact(TREE).anyPosition();\n \n-  private final ValueProtos.L2.Builder builder = ValueProtos.L2.newBuilder();\n+  private final ValueProtos.L2.Builder l2Builder = ValueProtos.L2.newBuilder();\n \n   RocksL2() {\n     super();\n   }\n \n   @Override\n   public L2 children(Stream<Id> ids) {\n-    builder\n-        .clearTree()\n-        .addAllTree(ids.map(Id::getValue).collect(Collectors.toList()));\n+    l2Builder.clearTree();\n+    ids.forEach(id -> l2Builder.addTree(id.getValue()));\n     return this;\n   }\n \n@@ -54,20 +69,55 @@ public void evaluate(Function function) throws ConditionFailedException {\n       case ID:\n         evaluatesId(function);\n         break;\n-      case CHILDREN:\n-        evaluate(function, builder.getTreeList().stream().map(Id::of).collect(Collectors.toList()));\n+      case TREE:\n+        evaluate(function, l2Builder.getTreeList().stream().map(Id::of).collect(Collectors.toList()));\n         break;\n       default:\n         // Invalid Condition Function.\n         throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n     }\n+\n+  }\n+\n+  @Override\n+  protected void remove(ExpressionPath path) {\n+    if (path.accept(TREE_INDEX_EXACT)) {\n+      final List<ByteString> updatedChildren = new ArrayList<>(l2Builder.getTreeList());\n+      updatedChildren.remove(getPathSegmentAsPosition(path, 1));\n+\n+      l2Builder.clearTree();\n+      l2Builder.addAllTree(updatedChildren);\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for remove in L2\", path.asString()));\n+    }\n+  }\n+\n+  @Override\n+  protected void appendToList(ExpressionPath path, List<Entity> valuesToAdd) {\n+    if (path.accept(TREE_EXACT)) {\n+      valuesToAdd.forEach(e -> l2Builder.addTree(e.getBinary()));\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for append in L2\", path.asString()));\n+    }\n+  }\n+\n+  @Override\n+  protected void set(ExpressionPath path, Entity newValue) {\n+    if (path.accept(TREE_EXACT)) {\n+      l2Builder.clearTree();\n+      newValue.getList().forEach(e -> l2Builder.addTree(e.getBinary()));\n+    } else if (path.accept(TREE_INDEX_EXACT)) {\n+      l2Builder.setTree(getPathSegmentAsPosition(path, 1), newValue.getBinary());\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for set equals in L2\", path.asString()));\n+    }\n   }\n \n   @Override\n   byte[] build() {\n-    checkPresent(builder.getTreeList(), CHILDREN);\n+    checkPresent(l2Builder.getTreeList(), TREE);\n \n-    return builder.setBase(buildBase()).build().toByteArray();\n+    return l2Builder.setBase(buildBase()).build().toByteArray();\n   }\n \n   /**\n@@ -85,4 +135,8 @@ static void toConsumer(byte[] value, L2 consumer) {\n       throw new StoreException(\"Corrupt L2 value encountered when deserializing.\", e);\n     }\n   }\n+\n+  Stream<Id> getChildren() {\n+    return l2Builder.getTreeList().stream().map(Id::of);\n+  }\n }"
  },
  {
    "sha": "def711809e90bdc93a422c5caeb52628867dd011",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksL3.java",
    "status": "modified",
    "additions": 120,
    "deletions": 16,
    "changes": 136,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksL3.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksL3.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksL3.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -16,10 +16,14 @@\n \n package org.projectnessie.versioned.rocksdb;\n \n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n import org.projectnessie.versioned.store.ConditionFailedException;\n+import org.projectnessie.versioned.store.Entity;\n import org.projectnessie.versioned.store.Id;\n import org.projectnessie.versioned.store.KeyDelta;\n import org.projectnessie.versioned.store.StoreException;\n@@ -30,30 +34,49 @@\n /**\n  * A RocksDB specific implementation of {@link org.projectnessie.versioned.tiered.L3} providing\n  * SerDe and Condition evaluation.\n+ *\n+ * <p>Conceptually, this is matching the following JSON structure:</p>\n+ * <pre>{\n+ *   \"id\": &lt;ByteString&gt;,    // ID\n+ *   \"dt\": &lt;int64&gt;,         // DATETIME\n+ *   \"tree\": [                    // TREE\n+ *     {\n+ *       \"key\": &lt;String&gt;,   // TREE_KEY\n+ *       \"id\": &lt;ByteString&gt; // TREE_ID\n+ *     }\n+ *   ]\n+ * }</pre>\n  */\n class RocksL3 extends RocksBaseValue<L3> implements L3 {\n-  private static final String TREE = \"tree\";\n+  static final String TREE = \"tree\";\n+  static final String TREE_KEY = \"key\";\n+  static final String TREE_ID = \"id\";\n+  static final PathPattern TREE_EXACT = PathPattern.exact(TREE);\n+  static final PathPattern TREE_INDEX_EXACT = PathPattern.exact(TREE).anyPosition();\n+  static final PathPattern TREE_INDEX_PREFIX = PathPattern.prefix(TREE).anyPosition();\n+  static final PathPattern TREE_ID_EXACT = PathPattern.exact(TREE_ID);\n+  static final PathPattern TREE_KEY_EXACT = PathPattern.exact(TREE_KEY);\n+  static final PathPattern TREE_KEY_INDEX_EXACT = PathPattern.exact(TREE_KEY).anyPosition();\n+  static final PathPattern TREE_KEY_INDEX_FULL_EXACT = PathPattern.exact(TREE).anyPosition().nameEquals(TREE_KEY).anyPosition();\n \n-  private final ValueProtos.L3.Builder builder = ValueProtos.L3.newBuilder();\n+  private final ValueProtos.L3.Builder l3Builder = ValueProtos.L3.newBuilder();\n \n   RocksL3() {\n     super();\n   }\n \n-\n   @Override\n   public L3 keyDelta(Stream<KeyDelta> keyDelta) {\n-    builder\n-        .clearKeyDelta()\n-        .addAllKeyDelta(\n-            keyDelta.map(kd -> ValueProtos.KeyDelta\n-                .newBuilder()\n-                .setKey(ValueProtos.Key.newBuilder().addAllElements(kd.getKey().getElements()).build())\n-                .setId(kd.getId().getValue())\n-                .build()\n-            )\n-            .collect(Collectors.toList())\n-        );\n+    l3Builder.clearKeyDelta();\n+\n+    keyDelta.forEach(kd -> {\n+      final ValueProtos.KeyDelta.Builder keyDeltaBuilder = ValueProtos.KeyDelta.newBuilder();\n+      keyDeltaBuilder.setId(kd.getId().getValue());\n+      keyDeltaBuilder.setKey(ValueProtos.Key.newBuilder().addAllElements(kd.getKey().getElements()));\n+\n+      l3Builder.addKeyDelta(keyDeltaBuilder);\n+    });\n+\n     return this;\n   }\n \n@@ -67,11 +90,92 @@ public void evaluate(Function function) throws ConditionFailedException {\n     }\n   }\n \n+  @Override\n+  protected void remove(ExpressionPath path) {\n+    // tree[*]\n+    if (path.accept(TREE_INDEX_EXACT)) {\n+      final List<ValueProtos.KeyDelta> updatedKeyDeltas = new ArrayList<>(l3Builder.getKeyDeltaList());\n+      updatedKeyDeltas.remove(getPathSegmentAsPosition(path, 1));\n+      l3Builder.clearKeyDelta().addAllKeyDelta(updatedKeyDeltas);\n+    // tree[*]/key[*]\n+    } else if (path.accept(TREE_KEY_INDEX_FULL_EXACT)) {\n+      final int keyDeltaPosition = getPathSegmentAsPosition(path, 1);\n+      final int keyPosition = getPathSegmentAsPosition(path, 3);\n+\n+      final List<String> updatedKeys = new ArrayList<>(l3Builder.getKeyDelta(keyDeltaPosition).getKey().getElementsList());\n+      updatedKeys.remove(keyPosition);\n+\n+      final ValueProtos.KeyDelta updatedKeyDelta = ValueProtos.KeyDelta\n+          .newBuilder()\n+          .setId(l3Builder.getKeyDelta(keyDeltaPosition).getId())\n+          .setKey(ValueProtos.Key.newBuilder().addAllElements(updatedKeys))\n+          .build();\n+\n+      l3Builder.clearKeyDelta().setKeyDelta(keyDeltaPosition, updatedKeyDelta);\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for remove in L3\", path.asString()));\n+    }\n+  }\n+\n+  @Override\n+  protected void appendToList(ExpressionPath path, List<Entity> valuesToAdd) {\n+    if (path.accept(TREE_EXACT)) {\n+      valuesToAdd.forEach(e -> l3Builder.addKeyDelta(EntityConverter.entityToKeyDelta(e)));\n+    } else if (path.accept(TREE_KEY_EXACT)) {\n+      final int treePosition = getPathSegmentAsPosition(path, 1);\n+\n+      final ValueProtos.Key updatedKey = ValueProtos.Key\n+          .newBuilder(l3Builder.getKeyDelta(treePosition).getKey())\n+          .addAllElements(valuesToAdd.stream().map(Entity::toString).collect(Collectors.toList()))\n+          .build();\n+\n+      l3Builder.setKeyDelta(treePosition, ValueProtos.KeyDelta.newBuilder(l3Builder.getKeyDelta(treePosition)).setKey(updatedKey));\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for append in L3\", path.asString()));\n+    }\n+  }\n+\n+  @Override\n+  protected void set(ExpressionPath path, Entity newValue) {\n+    if (path.accept(TREE_EXACT)) {\n+      l3Builder.clearKeyDelta();\n+      newValue.getList().forEach(e -> l3Builder.addKeyDelta(EntityConverter.entityToKeyDelta(e)));\n+    } else if (path.accept(TREE_INDEX_EXACT)) {\n+      l3Builder.setKeyDelta(getPathSegmentAsPosition(path, 1), EntityConverter.entityToKeyDelta(newValue));\n+    } else if (path.accept(TREE_INDEX_PREFIX)) {\n+      setsTreeItem(getPathSegmentAsPosition(path, 1), TREE_INDEX_PREFIX.removePrefix(path), newValue);\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for set equals in L3\", path.asString()));\n+    }\n+  }\n+\n+  private void setsTreeItem(int treeIndex, ExpressionPath path, Entity newValue) {\n+    if (path.accept(TREE_ID_EXACT)) {\n+      l3Builder.setKeyDelta(treeIndex, ValueProtos.KeyDelta.newBuilder(l3Builder.getKeyDelta(treeIndex)).setId(newValue.getBinary()));\n+    } else if (path.accept(TREE_KEY_EXACT)) {\n+      l3Builder.setKeyDelta(treeIndex, ValueProtos.KeyDelta\n+          .newBuilder(l3Builder.getKeyDelta(treeIndex))\n+          .setKey(EntityConverter.entityToKey(newValue)));\n+    } else if (path.accept(TREE_KEY_INDEX_EXACT)) {\n+      final int keyIndex = getPathSegmentAsPosition(path, 1);\n+\n+      final List<String> updatedKeyValues = new ArrayList<>(l3Builder.getKeyDelta(treeIndex).getKey().getElementsList());\n+      updatedKeyValues.set(keyIndex, newValue.getString());\n+\n+      l3Builder.setKeyDelta(treeIndex, ValueProtos.KeyDelta\n+          .newBuilder(l3Builder.getKeyDelta(treeIndex))\n+          .setKey(ValueProtos.Key.newBuilder().addAllElements(updatedKeyValues)));\n+    } else {\n+      throw new UnsupportedOperationException(\n+          String.format(\"%s is not a valid path for set equals in L3.tree[%d]\", path.asString(), treeIndex));\n+    }\n+  }\n+\n   @Override\n   byte[] build() {\n-    checkPresent(builder.getKeyDeltaList(), TREE);\n+    checkPresent(l3Builder.getKeyDeltaList(), TREE);\n \n-    return builder.setBase(buildBase()).build().toByteArray();\n+    return l3Builder.setBase(buildBase()).build().toByteArray();\n   }\n \n   /**"
  },
  {
    "sha": "2e33b3488e326d1e633583093c61eee71eb09a57",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksRef.java",
    "status": "modified",
    "additions": 616,
    "deletions": 53,
    "changes": 669,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksRef.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksRef.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksRef.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -15,42 +15,122 @@\n  */\n package org.projectnessie.versioned.rocksdb;\n \n+import java.util.ArrayList;\n import java.util.List;\n import java.util.function.Consumer;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n import org.projectnessie.versioned.Key;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n import org.projectnessie.versioned.store.ConditionFailedException;\n+import org.projectnessie.versioned.store.Entity;\n import org.projectnessie.versioned.store.Id;\n import org.projectnessie.versioned.store.StoreException;\n import org.projectnessie.versioned.tiered.Ref;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.protobuf.ByteString;\n import com.google.protobuf.InvalidProtocolBufferException;\n \n /**\n  * A RocksDB specific implementation of {@link org.projectnessie.versioned.tiered.Ref} providing\n  * SerDe and Condition evaluation.\n+ *\n+ * <p>Conceptually, this is matching one of the following JSON structures:</p>\n+ * <pre>{\n+ *   \"id\": &lt;ByteString&gt;, // ID\n+ *   \"dt\": &lt;int64&gt;,      // DATETIME\n+ *   \"name\": &lt;String&gt;,   // NAME\n+ *   \"id\": &lt;ByteString&gt;  // COMMIT\n+ * }\n+ *\n+ * {\n+ *   \"id\": &lt;ByteString&gt;,           // ID\n+ *   \"dt\": &lt;int64&gt;,                // DATETIME\n+ *   \"commits\": [                        // COMMITS\n+ *     {\n+ *       \"id\": &lt;ByteString&gt;,       // COMMITS_ID\n+ *       \"commit\": &lt;ByteString&gt;,   // COMMITS_COMMIT\n+ *       \"parent\": &lt;ByteString&gt;,   // COMMITS_PARENT\n+ *       \"deltas\": [                     // COMMITS_DELTA\n+ *         {\n+ *           \"position\": &lt;int32&gt;,  // COMMITS_POSITION\n+ *           \"old\": &lt;ByteString&gt;,  // COMMITS_OLD_ID\n+ *           \"new\": &lt;ByteString&gt;,  // COMMITS_NEW_ID\n+ *         }\n+ *       ],\n+ *       \"keys\": [                       // COMMITS_KEY_LIST\n+ *         {\n+ *           \"mutationType\": \"a\" or \"b\", // COMMITS_KEY_ADDITION or COMMITS_KEY_REMOVAL\n+ *           \"key\": [\n+ *             &lt;String&gt;\n+ *           ]\n+ *         }\n+ *       ]\n+ *     }\n+ *   ],\n+ *   \"children\": [                       // CHILDREN\n+ *     &lt;ByteString&gt;\n+ *   ],\n+ *   \"metadata\": &lt;ByteString&gt;      // METADATA\n+ * }</pre>\n  */\n class RocksRef extends RocksBaseValue<Ref> implements Ref {\n \n   static final String TYPE = \"type\";\n   static final String NAME = \"name\";\n   static final String METADATA = \"metadata\";\n   static final String COMMITS = \"commits\";\n+  static final String COMMITS_ID = \"id\";\n+  static final String COMMITS_COMMIT = \"commit\";\n+  static final String COMMITS_PARENT = \"parent\";\n+  static final String COMMITS_DELTA = \"deltas\";\n+  static final String COMMITS_POSITION = \"position\";\n+  static final String COMMITS_OLD_ID = \"old\";\n+  static final String COMMITS_NEW_ID = \"new\";\n+  static final String COMMITS_KEY_LIST = \"keys\";\n+  static final String COMMITS_KEY_LIST_KEY = \"key\";\n+  static final String COMMITS_KEY_ADDITION = \"a\";\n+  static final String COMMITS_KEY_REMOVAL = \"d\";\n   static final String COMMIT = \"commit\";\n-  static final String CHILDREN = \"children\";\n-\n-  private final ValueProtos.Ref.Builder builder = ValueProtos.Ref.newBuilder();\n+  static final String CHILDREN = \"tree\";\n+  static final PathPattern NAME_EXACT = PathPattern.exact(NAME);\n+  static final PathPattern CHILDREN_EXACT = PathPattern.exact(CHILDREN);\n+  static final PathPattern CHILDREN_INDEX_EXACT = PathPattern.exact(CHILDREN).anyPosition();\n+  static final PathPattern METADATA_EXACT = PathPattern.exact(METADATA);\n+  static final PathPattern COMMITS_EXACT = PathPattern.exact(COMMITS);\n+  static final PathPattern COMMITS_INDEX_EXACT = PathPattern.exact(COMMITS).anyPosition();\n+  static final PathPattern COMMITS_INDEX_PREFIX = PathPattern.prefix(COMMITS).anyPosition();\n+  static final PathPattern COMMITS_DELTA_EXACT = PathPattern.exact(COMMITS_DELTA);\n+  static final PathPattern COMMITS_DELTA_INDEX_EXACT = PathPattern.exact(COMMITS_DELTA).anyPosition();\n+  static final PathPattern COMMITS_KEY_LIST_EXACT = PathPattern.exact(COMMITS_KEY_LIST);\n+  static final PathPattern COMMITS_KEY_LIST_INDEX_EXACT = PathPattern.exact(COMMITS_KEY_LIST).anyPosition();\n+  static final PathPattern COMMITS_KEY_LIST_KEY_EXACT = PathPattern.exact(COMMITS_KEY_LIST)\n+      .anyPosition().nameEquals(COMMITS_KEY_LIST_KEY);\n+  static final PathPattern COMMITS_KEY_LIST_KEY_INDEX_EXACT = PathPattern.exact(COMMITS_KEY_LIST)\n+      .anyPosition().nameEquals(COMMITS_KEY_LIST_KEY).anyPosition();\n+  static final PathPattern COMMITS_ID_EXACT = PathPattern.exact(COMMITS_ID);\n+  static final PathPattern COMMITS_ID_FULL_EXACT = PathPattern.exact(COMMITS).anyPosition().nameEquals(COMMITS_ID);\n+  static final PathPattern COMMITS_COMMIT_EXACT = PathPattern.exact(COMMITS_COMMIT);\n+  static final PathPattern COMMITS_PARENT_EXACT = PathPattern.exact(COMMITS_PARENT);\n+  static final PathPattern COMMITS_DELTA_INDEX_POSITION_EXACT = PathPattern.exact(COMMITS_DELTA)\n+      .anyPosition().nameEquals(COMMITS_POSITION);\n+  static final PathPattern COMMITS_DELTA_INDEX_OLD_ID_EXACT = PathPattern.exact(COMMITS_DELTA)\n+      .anyPosition().nameEquals(COMMITS_OLD_ID);\n+  static final PathPattern COMMITS_DELTA_INDEX_NEW_ID_EXACT = PathPattern.exact(COMMITS_DELTA)\n+      .anyPosition().nameEquals(COMMITS_NEW_ID);\n+  static final PathPattern COMMIT_EXACT = PathPattern.exact(COMMIT);\n+\n+  private final ValueProtos.Ref.Builder refBuilder = ValueProtos.Ref.newBuilder();\n \n   RocksRef() {\n     super();\n   }\n \n   @Override\n   public void evaluate(Function function) throws ConditionFailedException {\n-    if (builder.getRefValueCase() == ValueProtos.Ref.RefValueCase.REFVALUE_NOT_SET) {\n+    if (refBuilder.getRefValueCase() == ValueProtos.Ref.RefValueCase.REFVALUE_NOT_SET) {\n       throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n     }\n \n@@ -71,26 +151,26 @@ public void evaluate(Function function) throws ConditionFailedException {\n         }\n \n         if (!function.isRootNameSegmentChildlessAndEquals()\n-            || builder.getRefValueCase() != typeFromFunction) {\n+            || refBuilder.getRefValueCase() != typeFromFunction) {\n           throw new ConditionFailedException(conditionNotMatchedMessage(function));\n         }\n         break;\n       case NAME:\n         if (!function.isRootNameSegmentChildlessAndEquals()\n-            || !builder.getName().equals(function.getValue().getString())) {\n+            || !refBuilder.getName().equals(function.getValue().getString())) {\n           throw new ConditionFailedException(conditionNotMatchedMessage(function));\n         }\n         break;\n       case CHILDREN:\n-        if (builder.getRefValueCase() != ValueProtos.Ref.RefValueCase.BRANCH) {\n+        if (!refBuilder.hasBranch()) {\n           throw new ConditionFailedException(conditionNotMatchedMessage(function));\n         }\n-        evaluate(function, builder.getBranch().getChildrenList().stream().map(Id::of).collect(Collectors.toList()));\n+        evaluate(function, refBuilder.getBranch().getChildrenList().stream().map(Id::of).collect(Collectors.toList()));\n         break;\n       case METADATA:\n         if (!function.isRootNameSegmentChildlessAndEquals()\n-            || builder.getRefValueCase() != ValueProtos.Ref.RefValueCase.BRANCH\n-            || !Id.of(builder.getBranch().getMetadataId()).toEntity().equals(function.getValue())) {\n+            || !refBuilder.hasBranch()\n+            || !Id.of(refBuilder.getBranch().getMetadataId()).toEntity().equals(function.getValue())) {\n           throw new ConditionFailedException(conditionNotMatchedMessage(function));\n         }\n         break;\n@@ -113,14 +193,30 @@ public void evaluate(Function function) throws ConditionFailedException {\n    */\n   private void evaluateBranchCommits(Function function) {\n     // TODO: refactor once jdbc-store Store changes are available.\n-    if (function.getOperator().equals(Function.Operator.SIZE)) {\n-      if (function.getRootPathAsNameSegment().getChild().isPresent()\n-          || builder.getRefValueCase() != ValueProtos.Ref.RefValueCase.BRANCH\n-          || builder.getBranch().getCommitsCount() != function.getValue().getNumber()) {\n+    if (!refBuilder.hasBranch()) {\n+      throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+    }\n+\n+    switch (function.getOperator()) {\n+      case SIZE:\n+        if (function.getRootPathAsNameSegment().getChild().isPresent()\n+            || refBuilder.getBranch().getCommitsCount() != function.getValue().getNumber()) {\n+          throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+        }\n+        break;\n+      case EQUALS:\n+        if (function.getPath().accept(COMMITS_ID_FULL_EXACT)) {\n+          final int i = getPathSegmentAsPosition(function.getPath(), 1);\n+          if (refBuilder.getBranch().getCommitsCount() <= i\n+              || !function.getValue().getBinary().equals(refBuilder.getBranch().getCommits(i).getId())) {\n+            throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+          }\n+        } else {\n+          throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+        }\n+        break;\n+      default:\n         throw new ConditionFailedException(conditionNotMatchedMessage(function));\n-      }\n-    } else {\n-      throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n     }\n   }\n \n@@ -132,43 +228,390 @@ private void evaluateBranchCommits(Function function) {\n    */\n   private void evaluateTagCommit(Function function) {\n     if (!function.getOperator().equals(Function.Operator.EQUALS)\n-        || builder.getRefValueCase() != ValueProtos.Ref.RefValueCase.TAG\n-        || !Id.of(builder.getTag().getId()).toEntity().equals(function.getValue())) {\n+        || !refBuilder.hasTag()\n+        || !Id.of(refBuilder.getTag().getId()).toEntity().equals(function.getValue())) {\n       throw new ConditionFailedException(conditionNotMatchedMessage(function));\n     }\n   }\n \n+  @Override\n+  protected void remove(ExpressionPath path) {\n+    // tree[*]\n+    if (path.accept(CHILDREN_INDEX_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Remove \\\"%s\\\" is not supported for tags\", path.asString()));\n+      }\n+\n+      List<ByteString> updatedChildren = new ArrayList<>(refBuilder.getBranch().getChildrenList());\n+      updatedChildren.remove(getPathSegmentAsPosition(path, 1));\n+      refBuilder.setBranch(ValueProtos.Branch\n+          .newBuilder(refBuilder.getBranch())\n+          .clearChildren()\n+          .addAllChildren(updatedChildren));\n+    // commits[*]\n+    } else if (path.accept(CHILDREN_INDEX_EXACT)) {\n+      List<ValueProtos.Commit> updatedCommits = new ArrayList<>(refBuilder.getBranch().getCommitsList());\n+      updatedCommits.remove(getPathSegmentAsPosition(path, 1));\n+      refBuilder.setBranch(ValueProtos.Branch\n+          .newBuilder(refBuilder.getBranch())\n+          .clearCommits()\n+          .addAllCommits(updatedCommits));\n+    } else if (path.accept(COMMITS_INDEX_EXACT)) {\n+      List<ValueProtos.Commit> updatedCommits = new ArrayList<>(refBuilder.getBranch().getCommitsList());\n+      updatedCommits.remove(getPathSegmentAsPosition(path, 1));\n+      refBuilder.setBranch(ValueProtos.Branch\n+          .newBuilder(refBuilder.getBranch())\n+          .clearCommits()\n+          .addAllCommits(updatedCommits));\n+    // commits[*]/deltas\n+    } else if (path.accept(COMMITS_INDEX_PREFIX)) {\n+      removesCommits(getPathSegmentAsPosition(path, 1), COMMITS_INDEX_PREFIX.removePrefix(path));\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for remove in Ref\", path.asString()));\n+    }\n+  }\n+\n+  private void removesCommits(int commitIndex, ExpressionPath path) {\n+    if (path.accept(COMMITS_DELTA_EXACT)) {\n+      refBuilder.setBranch(ValueProtos.Branch\n+          .newBuilder(refBuilder.getBranch())\n+          .setCommits(commitIndex, ValueProtos.Commit\n+            .newBuilder(refBuilder.getBranch().getCommits(commitIndex))\n+            .clearDelta()));\n+    // commits[*]/deltas[*]\n+    } else if (path.accept(COMMITS_DELTA_INDEX_EXACT)) {\n+      final int deltaIndex = getPathSegmentAsPosition(path, 1);\n+\n+      refBuilder.setBranch(ValueProtos.Branch\n+          .newBuilder(refBuilder.getBranch())\n+          .setCommits(commitIndex, ValueProtos.Commit\n+            .newBuilder(refBuilder.getBranch().getCommits(commitIndex))\n+            .removeDelta(deltaIndex)));\n+    // commits[*]/keys\n+    } else if (path.accept(COMMITS_KEY_LIST_EXACT)) {\n+      refBuilder.setBranch(ValueProtos.Branch\n+          .newBuilder(refBuilder.getBranch())\n+          .setCommits(commitIndex, ValueProtos.Commit\n+            .newBuilder(refBuilder.getBranch().getCommits(commitIndex))\n+            .clearKeyMutation()));\n+    // commits[*]/keys[*]\n+    } else if (path.accept(COMMITS_KEY_LIST_INDEX_EXACT)) {\n+      final int keyMutationIndex = getPathSegmentAsPosition(path, 1);\n+\n+      refBuilder.setBranch(ValueProtos.Branch\n+          .newBuilder(refBuilder.getBranch())\n+          .setCommits(commitIndex, ValueProtos.Commit\n+            .newBuilder(refBuilder.getBranch().getCommits(commitIndex))\n+            .removeKeyMutation(keyMutationIndex)));\n+    // commits[*]/keys[*]/key[*]\n+    } else if (path.accept(COMMITS_KEY_LIST_KEY_INDEX_EXACT)) {\n+      final int keyMutationIndex = getPathSegmentAsPosition(path, 1);\n+      final int keyIndex = getPathSegmentAsPosition(path, 3);\n+\n+      final List<String> updateKeys = new ArrayList<>(refBuilder.getBranch().getCommits(commitIndex)\n+          .getKeyMutation(keyMutationIndex).getKey().getElementsList());\n+      updateKeys.remove(keyIndex);\n+\n+      refBuilder.setBranch(ValueProtos.Branch\n+          .newBuilder(refBuilder.getBranch())\n+          .setCommits(commitIndex, ValueProtos.Commit\n+            .newBuilder(refBuilder.getBranch().getCommits(commitIndex))\n+            .setKeyMutation(keyMutationIndex, ValueProtos.KeyMutation\n+              .newBuilder(refBuilder.getBranch().getCommits(commitIndex).getKeyMutation(keyMutationIndex))\n+              .setKey(ValueProtos.Key.newBuilder().addAllElements(updateKeys)))));\n+    } else {\n+      throw new UnsupportedOperationException(\n+        String.format(\"%s is not a valid path for remove in Ref.commits[%d]\", path.asString(), commitIndex));\n+    }\n+  }\n+\n+  @Override\n+  protected void appendToList(ExpressionPath path, List<Entity> valuesToAdd) {\n+    if (path.accept(CHILDREN_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Append to list \\\"%s\\\" not supported for tags\", CHILDREN));\n+      }\n+\n+      final ValueProtos.Branch.Builder branchBuilder = ValueProtos.Branch.newBuilder(refBuilder.getBranch());\n+      valuesToAdd.forEach(e -> branchBuilder.addChildren(e.getBinary()));\n+      refBuilder.setBranch(branchBuilder);\n+    // commits\n+    } else if (path.accept(COMMITS_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Append to list \\\"%s\\\" not supported for tags\", COMMITS));\n+      }\n+\n+      final ValueProtos.Branch.Builder branchBuilder = ValueProtos.Branch.newBuilder(refBuilder.getBranch());\n+      valuesToAdd.forEach(e -> branchBuilder.addCommits(EntityConverter.entityToCommit(e)));\n+      refBuilder.setBranch(branchBuilder);\n+    // commits[*]/deltas\n+    } else if (path.accept(PathPattern.exact(COMMITS).anyPosition().nameEquals(COMMITS_DELTA))) {\n+      final int commitIndex = getPathSegmentAsPosition(path, 1);\n+      List<ValueProtos.Delta> updatedDelta = new ArrayList<>(refBuilder.getBranch().getCommits(commitIndex).getDeltaList());\n+      updatedDelta.addAll(valuesToAdd.stream().map(EntityConverter::entityToDelta).collect(Collectors.toList()));\n+      refBuilder.setBranch(\n+          ValueProtos.Branch.newBuilder(refBuilder.getBranch())\n+            .setCommits(commitIndex,\n+              ValueProtos.Commit.newBuilder(refBuilder.getBranch().getCommits(commitIndex))\n+                .clearDelta()\n+                .addAllDelta(updatedDelta)));\n+    // commits[*]/keys\n+    } else if (path.accept(PathPattern.exact(COMMITS).anyPosition().nameEquals(COMMITS_KEY_LIST))) {\n+      final int commitsPosition = getPathSegmentAsPosition(path, 1);\n+      List<ValueProtos.KeyMutation> updatedKeyList =\n+          new ArrayList<>(refBuilder.getBranch().getCommits(commitsPosition).getKeyMutationList());\n+      updatedKeyList.addAll(valuesToAdd.stream().map(EntityConverter::entityToKeyMutation).collect(Collectors.toList()));\n+      refBuilder.setBranch(\n+          ValueProtos.Branch.newBuilder(refBuilder.getBranch())\n+            .setCommits(commitsPosition,\n+              ValueProtos.Commit.newBuilder(refBuilder.getBranch().getCommits(commitsPosition))\n+                .clearKeyMutation()\n+                .addAllKeyMutation(updatedKeyList)));\n+      // commits[*]/keys[*]/key\n+    } else if (path.accept(PathPattern.exact(COMMITS).anyPosition().nameEquals(COMMITS_KEY_LIST)\n+        .anyPosition().nameEquals(COMMITS_KEY_LIST_KEY))) {\n+      final int commitIndex = getPathSegmentAsPosition(path, 1);\n+      final int keyMutationIndex = getPathSegmentAsPosition(path, 3);\n+\n+      final ValueProtos.Key.Builder keyBuilder = ValueProtos.Key.newBuilder(\n+          refBuilder.getBranch().getCommits(commitIndex).getKeyMutation(keyMutationIndex).getKey());\n+      valuesToAdd.forEach(e -> keyBuilder.addElements(e.getString()));\n+      refBuilder.setBranch(\n+          ValueProtos.Branch.newBuilder(refBuilder.getBranch())\n+            .setCommits(commitIndex,\n+              ValueProtos.Commit.newBuilder(refBuilder.getBranch().getCommits(commitIndex))\n+                .setKeyMutation(keyMutationIndex,\n+                  ValueProtos.KeyMutation.newBuilder(refBuilder.getBranch().getCommits(commitIndex).getKeyMutation(keyMutationIndex))\n+                    .setKey(keyBuilder))));\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for append in Ref\", path.asString()));\n+    }\n+  }\n+\n+  @Override\n+  protected void set(ExpressionPath path, Entity newValue) {\n+    if (path.accept(NAME_EXACT)) {\n+      refBuilder.setName(newValue.getString());\n+    // tree\n+    } else if (path.accept(CHILDREN_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Cannot set \\\"%s\\\" for tags\", path.asString()));\n+      }\n+\n+      final ValueProtos.Branch.Builder branchBuilder = ValueProtos.Branch.newBuilder(refBuilder.getBranch()).clearChildren();\n+      newValue.getList().forEach(e -> branchBuilder.addChildren(e.getBinary()));\n+      refBuilder.setBranch(branchBuilder);\n+    // tree[*]\n+    } else if (path.accept(CHILDREN_INDEX_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Cannot set \\\"%s\\\" for tags\", path.asString()));\n+      }\n+\n+      final int i = getPathSegmentAsPosition(path, 1);\n+      final ValueProtos.Branch.Builder branchBuilder = ValueProtos.Branch.newBuilder(refBuilder.getBranch());\n+      branchBuilder.setChildren(i, newValue.getBinary());\n+      refBuilder.setBranch(branchBuilder);\n+    // metadata\n+    } else if (path.accept(METADATA_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Cannot set \\\"%s\\\" for tags\", path.asString()));\n+      }\n+\n+      refBuilder.setBranch(ValueProtos.Branch.newBuilder(refBuilder.getBranch()).setMetadataId(newValue.getBinary()));\n+    } else if (path.accept(COMMITS_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Cannot set \\\"%s\\\" for tags\", path.asString()));\n+      }\n+\n+      final ValueProtos.Branch.Builder branchBuilder = ValueProtos.Branch.newBuilder(refBuilder.getBranch());\n+      newValue.getList().forEach(e -> branchBuilder.addCommits(EntityConverter.entityToCommit(e)));\n+      refBuilder.setBranch(branchBuilder);\n+    } else if (path.accept(COMMITS_INDEX_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Cannot set \\\"%s\\\" for tags\", path.asString()));\n+      }\n+\n+      final ValueProtos.Branch.Builder branchBuilder = ValueProtos.Branch.newBuilder(refBuilder.getBranch());\n+      branchBuilder.setCommits(getPathSegmentAsPosition(path, 1), EntityConverter.entityToCommit(newValue));\n+      refBuilder.setBranch(branchBuilder);\n+    } else if (path.accept(COMMITS_INDEX_PREFIX)) {\n+      setsCommits(getPathSegmentAsPosition(path, 1), COMMITS_INDEX_PREFIX.removePrefix(path), newValue);\n+    } else if (path.accept(COMMIT_EXACT)) {\n+      if (!refBuilder.hasTag()) {\n+        throw new UnsupportedOperationException(String.format(\"Cannot set \\\"%s\\\" for branches\", path.asString()));\n+      }\n+\n+      refBuilder.setTag(ValueProtos.Tag.newBuilder(refBuilder.getTag()).setId(newValue.getBinary()));\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for set equals in Ref\", path.asString()));\n+    }\n+  }\n+\n+  private void setsCommits(int commitIndex, ExpressionPath path, Entity newValue) {\n+    if (path.accept(COMMITS_ID_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Cannot set \\\"%s\\\" for tags\", path.asString()));\n+      }\n+\n+      refBuilder.setBranch(ValueProtos.Branch\n+          .newBuilder(refBuilder.getBranch())\n+          .setCommits(commitIndex, ValueProtos.Commit.newBuilder(refBuilder.getBranch().getCommits(commitIndex))\n+          .setId(newValue.getBinary())));\n+\n+    // commits[*]/commit\n+    } else if (path.accept(COMMITS_COMMIT_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Cannot set \\\"%s\\\" for tags\", path.asString()));\n+      }\n+\n+      refBuilder.setBranch(ValueProtos.Branch\n+          .newBuilder(refBuilder.getBranch())\n+          .setCommits(commitIndex, ValueProtos.Commit\n+          .newBuilder(refBuilder.getBranch().getCommits(commitIndex))\n+          .setCommit(newValue.getBinary())));\n+\n+    // commits[*]/parent\n+    } else if (path.accept(COMMITS_PARENT_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Cannot set \\\"%s\\\" for tags\", path.asString()));\n+      }\n+\n+      refBuilder.setBranch(ValueProtos.Branch\n+          .newBuilder(refBuilder.getBranch())\n+          .setCommits(commitIndex, ValueProtos.Commit\n+          .newBuilder(refBuilder.getBranch().getCommits(commitIndex))\n+          .setParent(newValue.getBinary())));\n+\n+    // commits[*]/deltas[*]\n+    } else if (path.accept(COMMITS_DELTA_INDEX_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Cannot set \\\"%s\\\" for tags\", path.asString()));\n+      }\n+\n+      final int deltaPosition = getPathSegmentAsPosition(path, 1);\n+      refBuilder.setBranch(\n+          ValueProtos.Branch.newBuilder(refBuilder.getBranch())\n+            .setCommits(commitIndex,\n+              ValueProtos.Commit.newBuilder(refBuilder.getBranch().getCommits(commitIndex))\n+                .setDelta(deltaPosition, EntityConverter.entityToDelta(newValue))));\n+\n+    // commits[*]/deltas[*]/position\n+    } else if (path.accept(COMMITS_DELTA_INDEX_POSITION_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Cannot set \\\"%s\\\" for tags\", path.asString()));\n+      }\n+\n+      final int deltaPosition = getPathSegmentAsPosition(path, 1);\n+      final ValueProtos.Delta.Builder deltaBuilder = ValueProtos.Delta\n+          .newBuilder(refBuilder.getBranch().getCommits(commitIndex).getDelta(deltaPosition));\n+\n+      setDelta(commitIndex, deltaPosition, deltaBuilder.setPosition((int)newValue.getNumber()));\n+\n+    // commits[*]/deltas[*]/old\n+    } else if (path.accept(COMMITS_DELTA_INDEX_OLD_ID_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Cannot set \\\"%s\\\" for tags\", path.asString()));\n+      }\n+\n+      final int deltaPosition = getPathSegmentAsPosition(path, 1);\n+      final ValueProtos.Delta.Builder deltaBuilder = ValueProtos.Delta\n+          .newBuilder(refBuilder.getBranch().getCommits(commitIndex).getDelta(deltaPosition));\n+\n+      setDelta(commitIndex, deltaPosition, deltaBuilder.setOldId(newValue.getBinary()));\n+\n+    // commits[*]/deltas[*]/new\n+    } else if (path.accept(COMMITS_DELTA_INDEX_NEW_ID_EXACT)) {\n+      if (!refBuilder.hasBranch()) {\n+        throw new UnsupportedOperationException(String.format(\"Cannot set \\\"%s\\\" for tags\", path.asString()));\n+      }\n+\n+      final int deltaPosition = getPathSegmentAsPosition(path, 1);\n+      final ValueProtos.Delta.Builder deltaBuilder = ValueProtos.Delta\n+          .newBuilder(refBuilder.getBranch().getCommits(commitIndex).getDelta(deltaPosition));\n+\n+      setDelta(commitIndex, deltaPosition, deltaBuilder.setNewId(newValue.getBinary()));\n+\n+    // commits[*]/keys\n+    } else if (path.accept(COMMITS_KEY_LIST_EXACT)) {\n+      final int commitPosition = getPathSegmentAsPosition(path, 1);\n+      ValueProtos.Commit.Builder commitBuilder = ValueProtos.Commit.newBuilder(\n+          refBuilder.getBranch().getCommits(commitPosition)).clearKeyMutation();\n+      newValue.getList().forEach(e -> commitBuilder.addKeyMutation(EntityConverter.entityToKeyMutation(e)));\n+      refBuilder.setBranch(ValueProtos.Branch.newBuilder(refBuilder.getBranch()).setCommits(commitPosition,commitBuilder));\n+\n+    // commits[*]/keys[*]\n+    } else if (path.accept(COMMITS_KEY_LIST_INDEX_EXACT)) {\n+      final int keyMutationIndex = getPathSegmentAsPosition(path, 1);\n+      ValueProtos.Commit.Builder commitBuilder = ValueProtos.Commit.newBuilder(refBuilder.getBranch().getCommits(commitIndex));\n+      commitBuilder.setKeyMutation(keyMutationIndex, EntityConverter.entityToKeyMutation(newValue));\n+      refBuilder.setBranch(ValueProtos.Branch.newBuilder(refBuilder.getBranch()).setCommits(commitIndex, commitBuilder));\n+\n+    // commits[*]/keys[*]/key\n+    } else if (path.accept(COMMITS_KEY_LIST_KEY_EXACT)) {\n+      final int keyMutationIndex = getPathSegmentAsPosition(path, 1);\n+      ValueProtos.Commit.Builder commitBuilder = ValueProtos.Commit.newBuilder(refBuilder.getBranch().getCommits(commitIndex));\n+\n+      commitBuilder.setKeyMutation(keyMutationIndex, ValueProtos.KeyMutation.newBuilder(\n+          commitBuilder.getKeyMutation(keyMutationIndex))\n+          .setKey(EntityConverter.entityToKey(newValue)));\n+      refBuilder.setBranch(ValueProtos.Branch.newBuilder(refBuilder.getBranch()).setCommits(commitIndex,commitBuilder));\n+\n+    // commits[*]/keys[*]/key[*]\n+    } else if (path.accept(COMMITS_KEY_LIST_KEY_INDEX_EXACT)) {\n+      final int keyMutationIndex = getPathSegmentAsPosition(path, 1);\n+      final int keyIndex = getPathSegmentAsPosition(path, 3);\n+      ValueProtos.Commit.Builder commitBuilder = ValueProtos.Commit.newBuilder(refBuilder.getBranch().getCommits(commitIndex));\n+\n+      commitBuilder.setKeyMutation(keyMutationIndex, ValueProtos.KeyMutation.newBuilder(commitBuilder.getKeyMutation(keyMutationIndex))\n+          .setKey(ValueProtos.Key\n+            .newBuilder(commitBuilder.getKeyMutation(keyMutationIndex).getKey())\n+            .setElements(keyIndex, newValue.getString())));\n+      refBuilder.setBranch(ValueProtos.Branch.newBuilder(refBuilder.getBranch()).setCommits(commitIndex,commitBuilder));\n+    } else {\n+      throw new UnsupportedOperationException(\n+          String.format(\"%s is not a valid path for set equals in Ref.commits[%d]\", path.asString(), commitIndex));\n+    }\n+  }\n+\n+  private void setDelta(int commitsPosition, int deltaPosition, ValueProtos.Delta.Builder deltaBuilder) {\n+    refBuilder.setBranch(\n+        ValueProtos.Branch.newBuilder(refBuilder.getBranch())\n+          .setCommits(commitsPosition,\n+            ValueProtos.Commit.newBuilder(refBuilder.getBranch().getCommits(commitsPosition))\n+              .setDelta(deltaPosition, deltaBuilder)));\n+  }\n+\n   @Override\n   public Ref name(String name) {\n-    builder.setName(name);\n+    refBuilder.setName(name);\n     return this;\n   }\n \n   @Override\n   public Tag tag() {\n-    if (builder.getRefValueCase() != ValueProtos.Ref.RefValueCase.REFVALUE_NOT_SET) {\n+    if (refBuilder.getRefValueCase() != ValueProtos.Ref.RefValueCase.REFVALUE_NOT_SET) {\n       throw new IllegalStateException(\"branch()/tag() has already been called\");\n     }\n \n-    builder.setTag(ValueProtos.Tag.newBuilder().build());\n+    refBuilder.setTag(ValueProtos.Tag.newBuilder().build());\n     return new RocksTag();\n   }\n \n   @Override\n   public Branch branch() {\n-    if (builder.getRefValueCase() != ValueProtos.Ref.RefValueCase.REFVALUE_NOT_SET) {\n+    if (refBuilder.getRefValueCase() != ValueProtos.Ref.RefValueCase.REFVALUE_NOT_SET) {\n       throw new IllegalStateException(\"branch()/tag() has already been called\");\n     }\n \n-    builder.setBranch(ValueProtos.Branch.newBuilder().build());\n+    refBuilder.setBranch(ValueProtos.Branch.newBuilder().build());\n     return new RocksBranch();\n   }\n \n \n   class RocksTag implements Tag {\n     @Override\n     public Tag commit(Id commit) {\n-      builder.setTag(ValueProtos.Tag.newBuilder().setId(commit.getValue()).build());\n+      refBuilder.setTag(ValueProtos.Tag.newBuilder().setId(commit.getValue()).build());\n       return this;\n     }\n \n@@ -181,11 +624,11 @@ public Ref backToRef() {\n   class RocksBranch implements Branch {\n     @Override\n     public Branch metadata(Id metadata) {\n-      if (builder.getRefValueCase() != ValueProtos.Ref.RefValueCase.BRANCH) {\n-        builder.setBranch(ValueProtos.Branch.newBuilder().setMetadataId(metadata.getValue()));\n+      if (refBuilder.getRefValueCase() != ValueProtos.Ref.RefValueCase.BRANCH) {\n+        refBuilder.setBranch(ValueProtos.Branch.newBuilder().setMetadataId(metadata.getValue()));\n       } else {\n-        builder.setBranch(\n-            ValueProtos.Branch.newBuilder(builder.getBranch()).setMetadataId(metadata.getValue())\n+        refBuilder.setBranch(\n+            ValueProtos.Branch.newBuilder(refBuilder.getBranch()).setMetadataId(metadata.getValue())\n         );\n       }\n \n@@ -194,25 +637,17 @@ public Branch metadata(Id metadata) {\n \n     @Override\n     public Branch children(Stream<Id> children) {\n-      final List<ByteString> childList = children.map(Id::getValue).collect(Collectors.toList());\n-\n-      if (builder.getRefValueCase() != ValueProtos.Ref.RefValueCase.BRANCH) {\n-        builder.setBranch(\n-            ValueProtos.Branch\n-                .newBuilder()\n-                .addAllChildren(childList)\n-                .build()\n-        );\n+      final ValueProtos.Branch.Builder branchBuilder;\n+      if (!refBuilder.hasBranch()) {\n+        branchBuilder = ValueProtos.Branch.newBuilder();\n       } else {\n-        builder.setBranch(\n-            ValueProtos.Branch\n-                .newBuilder(builder.getBranch())\n-                .clearChildren()\n-                .addAllChildren(childList)\n-                .build()\n-        );\n+        branchBuilder = ValueProtos.Branch.newBuilder(refBuilder.getBranch());\n+        branchBuilder.clearChildren();\n       }\n \n+      children.forEach(id -> branchBuilder.addChildren(id.getValue()));\n+      refBuilder.setBranch(branchBuilder);\n+\n       return this;\n     }\n \n@@ -263,7 +698,7 @@ public SavedCommit parent(Id parent) {\n \n     @Override\n     public BranchCommit done() {\n-      RocksRef.this.builder.setBranch(ValueProtos.Branch.newBuilder(RocksRef.this.builder.getBranch()).addCommits(builder.build()));\n+      refBuilder.setBranch(ValueProtos.Branch.newBuilder(refBuilder.getBranch()).addCommits(builder.build()));\n       builder.clear();\n       return this;\n     }\n@@ -294,17 +729,17 @@ public UnsavedCommitMutations keyMutation(Key.Mutation keyMutation) {\n \n   @Override\n   byte[] build() {\n-    checkPresent(builder.getName(), NAME);\n+    checkPresent(refBuilder.getName(), NAME);\n \n-    if (builder.hasTag()) {\n-      checkPresent(builder.getTag().getId(), COMMIT);\n+    if (refBuilder.hasTag()) {\n+      checkPresent(refBuilder.getTag().getId(), COMMIT);\n     } else {\n-      checkPresent(builder.getBranch().getCommitsList(), COMMITS);\n-      checkPresent(builder.getBranch().getChildrenList(), CHILDREN);\n-      checkPresent(builder.getBranch().getMetadataId(), METADATA);\n+      checkPresent(refBuilder.getBranch().getCommitsList(), COMMITS);\n+      checkPresent(refBuilder.getBranch().getChildrenList(), CHILDREN);\n+      checkPresent(refBuilder.getBranch().getMetadataId(), METADATA);\n     }\n \n-    return builder.setBase(buildBase()).build().toByteArray();\n+    return refBuilder.setBase(buildBase()).build().toByteArray();\n   }\n \n   /**\n@@ -350,4 +785,132 @@ private static void deserializeCommits(BranchCommit consumer, List<ValueProtos.C\n       }\n     }\n   }\n+\n+  @VisibleForTesting\n+  String getName() {\n+    return refBuilder.getName();\n+  }\n+\n+  @VisibleForTesting\n+  Stream<Id> getChildren() {\n+    if (refBuilder.hasBranch()) {\n+      return refBuilder.getBranch().getChildrenList().stream().map(Id::of);\n+    } else {\n+      return Stream.empty();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  Id getMetadata() {\n+    if (refBuilder.hasBranch()) {\n+      return Id.of(refBuilder.getBranch().getMetadataId());\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  Id getCommit() {\n+    if (refBuilder.hasTag()) {\n+      return Id.of(refBuilder.getTag().getId());\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  List<ValueProtos.Commit> getCommits() {\n+    return refBuilder.getBranch().getCommitsList();\n+  }\n+\n+  @VisibleForTesting\n+  Id getCommitsId(int index) {\n+    if (refBuilder.hasBranch()) {\n+      return Id.of(refBuilder.getBranch().getCommits(index).getId());\n+    }\n+    return null;\n+  }\n+\n+  @VisibleForTesting\n+  Id getCommitsParent(int index) {\n+    if (refBuilder.hasBranch()) {\n+      return Id.of(refBuilder.getBranch().getCommits(index).getParent());\n+    }\n+    return null;\n+  }\n+\n+  @VisibleForTesting\n+  List<ValueProtos.Delta> getCommitsDeltaList(int commitsPosition) {\n+    if (refBuilder.hasBranch()) {\n+      return refBuilder.getBranch().getCommits(commitsPosition).getDeltaList();\n+    }\n+    return null;\n+  }\n+\n+  @VisibleForTesting\n+  ValueProtos.Delta getCommitsDelta(int commitsPosition, int deltaPosition) {\n+    if (refBuilder.hasBranch()) {\n+      return refBuilder.getBranch().getCommits(commitsPosition).getDelta(deltaPosition);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  Integer getCommitsDeltaPosition(int commitsPosition, int deltaPosition) {\n+    if (refBuilder.hasBranch()) {\n+      return refBuilder.getBranch().getCommits(commitsPosition).getDelta(deltaPosition).getPosition();\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  Id getCommitsDeltaOldId(int commitsPosition, int deltaPosition) {\n+    if (refBuilder.hasBranch()) {\n+      return Id.of(refBuilder.getBranch().getCommits(commitsPosition).getDelta(deltaPosition).getOldId());\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  Id getCommitsDeltaNewId(int commitsPosition, int deltaPosition) {\n+    if (refBuilder.hasBranch()) {\n+      return Id.of(refBuilder.getBranch().getCommits(commitsPosition).getDelta(deltaPosition).getNewId());\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  List<ValueProtos.KeyMutation> getCommitsKeysList(int commitsPosition) {\n+    if (refBuilder.hasBranch()) {\n+      return refBuilder.getBranch().getCommits(commitsPosition).getKeyMutationList();\n+    }\n+    return null;\n+  }\n+\n+  @VisibleForTesting\n+  ValueProtos.KeyMutation getCommitsKeys(int commitsPosition, int keysPosition) {\n+    if (refBuilder.hasBranch()) {\n+      return refBuilder.getBranch().getCommits(commitsPosition).getKeyMutation(keysPosition);\n+    }\n+    return null;\n+  }\n+\n+  @VisibleForTesting\n+  List<String> getCommitsKeysKey(int commitsPosition, int keysPosition) {\n+    if (refBuilder.hasBranch()) {\n+      return refBuilder.getBranch().getCommits(commitsPosition).getKeyMutation(keysPosition).getKey().getElementsList();\n+    }\n+    return null;\n+  }\n+\n+  @VisibleForTesting\n+  String getCommitsKeysKeyElement(int commitsPosition, int keysPosition, int elementPosition) {\n+    if (refBuilder.hasBranch()) {\n+      return refBuilder.getBranch().getCommits(commitsPosition).getKeyMutation(keysPosition).getKey().getElements(elementPosition);\n+    }\n+    return null;\n+  }\n }"
  },
  {
    "sha": "d9bc384f70a662f8643941919d7361e5795959e4",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksValue.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksValue.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksValue.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksValue.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -20,6 +20,13 @@\n /**\n  * A RocksDB specific implementation of {@link org.projectnessie.versioned.tiered.Value} providing\n  * SerDe and Condition evaluation.\n+ *\n+ * <p>Conceptually, this is matching the following JSON structure:</p>\n+ * <pre>{\n+ *   \"id\": &lt;ByteString&gt;,   // ID\n+ *   \"dt\": &lt;int64&gt;,        // DATETIME\n+ *   \"value\": &lt;ByteString&gt; // VALUE\n+ * }</pre>\n  */\n class RocksValue extends RocksWrappedValue<Value> implements Value {\n   RocksValue() {"
  },
  {
    "sha": "6a001529be47525ce9b5da979307be97a7a796ff",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksWrappedValue.java",
    "status": "modified",
    "additions": 29,
    "deletions": 0,
    "changes": 29,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksWrappedValue.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksWrappedValue.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/RocksWrappedValue.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -15,7 +15,11 @@\n  */\n package org.projectnessie.versioned.rocksdb;\n \n+import java.util.List;\n+\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n import org.projectnessie.versioned.store.ConditionFailedException;\n+import org.projectnessie.versioned.store.Entity;\n import org.projectnessie.versioned.store.StoreException;\n import org.projectnessie.versioned.tiered.BaseWrappedValue;\n \n@@ -29,6 +33,8 @@\n class RocksWrappedValue<C extends BaseWrappedValue<C>> extends RocksBaseValue<C> implements BaseWrappedValue<C> {\n \n   static final String VALUE = \"value\";\n+  static final PathPattern VALUE_EXACT = PathPattern.exact(VALUE);\n+\n   private final ValueProtos.WrappedValue.Builder builder = ValueProtos.WrappedValue.newBuilder();\n \n   RocksWrappedValue() {\n@@ -54,6 +60,25 @@ public void evaluate(Function function) throws ConditionFailedException {\n     }\n   }\n \n+  @Override\n+  protected void remove(ExpressionPath path) {\n+    throw new UnsupportedOperationException(String.format(\"Remove is not supported for \\\"%s\\\"\", path.asString()));\n+  }\n+\n+  @Override\n+  protected void appendToList(ExpressionPath path, List<Entity> valuesToAdd) {\n+    throw new UnsupportedOperationException(String.format(\"Append to list is not supported for \\\"%s\\\"\", path.asString()));\n+  }\n+\n+  @Override\n+  protected void set(ExpressionPath path, Entity newValue) {\n+    if (path.accept(VALUE_EXACT)) {\n+      builder.setValue(newValue.getBinary());\n+    } else {\n+      throw new UnsupportedOperationException(String.format(\"%s is not a valid path for set equals\", path.asString()));\n+    }\n+  }\n+\n   @SuppressWarnings(\"unchecked\")\n   @Override\n   public C value(ByteString value) {\n@@ -83,4 +108,8 @@ public C value(ByteString value) {\n       throw new StoreException(\"Corrupt WrappedValue value encountered when deserializing.\", e);\n     }\n   }\n+\n+  ByteString getValue() {\n+    return builder.getValue();\n+  }\n }"
  },
  {
    "sha": "de0d8217737cbbf7005605c749ff99b33e759c53",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/UpdateFunction.java",
    "status": "added",
    "additions": 117,
    "deletions": 0,
    "changes": 117,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/UpdateFunction.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/UpdateFunction.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/UpdateFunction.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.projectnessie.versioned.rocksdb;\n+\n+import java.util.Objects;\n+\n+import org.immutables.value.Value.Immutable;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n+import org.projectnessie.versioned.store.Entity;\n+\n+/**\n+ * An update that is peformed on an entity.\n+ */\n+interface UpdateFunction {\n+  /**\n+   * An enum encapsulating.\n+   */\n+  enum Operator {\n+    // An operator to remove some part or all of an entity.\n+    REMOVE,\n+\n+    // An operator to set some part or all of an entity.\n+    SET\n+  }\n+\n+  Operator getOperator();\n+\n+  ExpressionPath getPath();\n+\n+  default ExpressionPath.NameSegment getRootPathAsNameSegment() {\n+    return getPath().getRoot().asName();\n+  }\n+\n+\n+  @Immutable\n+  abstract class RemoveFunction implements UpdateFunction {\n+\n+    /**\n+     * Compares for equality with a provided UpdateFunction object.\n+     * @param object  the object to compare\n+     * @return true if this is equal to provided object\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+      if (object == this) {\n+        return true;\n+      }\n+\n+      if (!(object instanceof UpdateFunction)) {\n+        return false;\n+      }\n+\n+      final UpdateFunction function = (UpdateFunction) object;\n+      return Objects.equals(getOperator(), function.getOperator())\n+        && Objects.equals(getPath(), function.getPath());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(getOperator(), getPath());\n+    }\n+\n+  }\n+\n+  @Immutable\n+  abstract class SetFunction implements UpdateFunction {\n+    enum SubOperator {\n+      EQUALS,\n+      APPEND_TO_LIST\n+    }\n+\n+    abstract Entity getValue();\n+\n+    abstract SubOperator getSubOperator();\n+\n+    /**\n+     * Compares for equality with a provided UpdateFunction object.\n+     * @param object  the object to compare\n+     * @return true if this is equal to provided object\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+      if (object == this) {\n+        return true;\n+      }\n+\n+      if (!(object instanceof SetFunction)) {\n+        return false;\n+      }\n+\n+      final SetFunction function = (SetFunction) object;\n+      return (getOperator().equals(function.getOperator())\n+        && getPath().equals(function.getPath())\n+        && getValue().equals(function.getValue())\n+        && getSubOperator().equals(function.getSubOperator()));\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(getOperator(), getPath(), getValue());\n+    }\n+  }\n+}"
  },
  {
    "sha": "5ec9be7b99d6f044f6d2272071dc3b896e772928",
    "filename": "versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/Updater.java",
    "status": "added",
    "additions": 32,
    "deletions": 0,
    "changes": 32,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/Updater.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/Updater.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/main/java/org/projectnessie/versioned/rocksdb/Updater.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.projectnessie.versioned.rocksdb;\n+\n+import org.projectnessie.versioned.impl.condition.UpdateExpression;\n+\n+/**\n+ * Applies updates from a collection of {@link org.projectnessie.versioned.rocksdb.UpdateFunction} against the\n+ * implementing class's attributes.\n+ */\n+public interface Updater {\n+\n+  /**\n+   * Applies the updates to the implementing class.\n+   * @param updates the updates to apply\n+   */\n+  void update(UpdateExpression updates);\n+}"
  },
  {
    "sha": "f9c9ded21dcf9cf7fbf7821316e3a1be29614686",
    "filename": "versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestConditionExecutor.java",
    "status": "modified",
    "additions": 40,
    "deletions": 95,
    "changes": 135,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestConditionExecutor.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestConditionExecutor.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestConditionExecutor.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -65,9 +65,7 @@ void executorL1Empty() {\n           .value(TRUE_ENTITY)\n           .build());\n     final RocksL1 l1 = createL1(random);\n-    Assertions.assertThrows(ConditionFailedException.class, () -> {\n-      l1.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertThrows(ConditionFailedException.class, () -> l1.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -82,47 +80,40 @@ void executorL1CommitMetadata() {\n \n   @Test\n   void executorL1IncrementalKeyListCheckpointId() {\n-    final ExpressionPath expressionPath = ExpressionPath.builder(RocksL1.INCREMENTAL_KEY_LIST).name(RocksL1.CHECKPOINT_ID).build();\n+    final ExpressionPath expressionPath = ExpressionPath.builder(RocksL1.CHECKPOINT_ID).build();\n     final List<Function> expectedFunctions = ImmutableList.of(\n         ImmutableFunction.builder()\n           .operator(Function.Operator.EQUALS)\n           .path(expressionPath)\n           .value(ID.toEntity())\n           .build());\n     final RocksL1 l1 = createL1(random);\n-    Assertions.assertDoesNotThrow(() -> {\n-      l1.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> l1.evaluate(expectedFunctions));\n   }\n \n   @Test\n   void executorL1IncrementalKeyListDistanceFromCheckpoint() {\n-    final ExpressionPath expressionPath = ExpressionPath.builder(RocksL1.INCREMENTAL_KEY_LIST)\n-        .name(RocksL1.DISTANCE_FROM_CHECKPOINT).build();\n+    final ExpressionPath expressionPath = ExpressionPath.builder(RocksL1.DISTANCE_FROM_CHECKPOINT).build();\n     final List<Function> expectedFunctions = ImmutableList.of(\n         ImmutableFunction.builder()\n           .operator(Function.Operator.EQUALS)\n           .path(expressionPath)\n           .value(ONE)\n           .build());\n     final RocksL1 l1 = createL1(random);\n-    Assertions.assertDoesNotThrow(() -> {\n-      l1.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> l1.evaluate(expectedFunctions));\n   }\n \n   @Test\n   void executorL1ChildrenSize() {\n     final List<Function> expectedFunctions = ImmutableList.of(\n         ImmutableFunction.builder()\n           .operator(Function.Operator.SIZE)\n-          .path(ofPath(RocksL1.CHILDREN))\n+          .path(ofPath(RocksL1.TREE))\n           .value(Entity.ofNumber(RocksL1.SIZE))\n           .build());\n     final RocksL1 l1 = createL1(random);\n-    Assertions.assertDoesNotThrow(() -> {\n-      l1.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> l1.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -131,21 +122,19 @@ void executorL1ChildrenEqualsList() {\n     for (int i = 0; i < RocksL1.SIZE; i++) {\n       idsAsEntity.add(ID.toEntity());\n     }\n-    equalsL1(RocksL1.CHILDREN, Entity.ofList(idsAsEntity));\n+    equalsL1(RocksL1.TREE, Entity.ofList(idsAsEntity));\n   }\n \n   @Test\n   void executorL1ChildrenEqualsListPosition() {\n     final List<Function> expectedFunctions = ImmutableList.of(\n         ImmutableFunction.builder()\n           .operator(Function.Operator.EQUALS)\n-          .path(ExpressionPath.builder(RocksL1.CHILDREN).position(3).build())\n+          .path(ExpressionPath.builder(RocksL1.TREE).position(3).build())\n           .value(ID.toEntity())\n           .build());\n     final RocksL1 l1 = createL1(random);\n-    Assertions.assertDoesNotThrow(() -> {\n-      l1.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> l1.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -157,9 +146,7 @@ void executorL1AncestorsSize() {\n           .value(Entity.ofNumber(RocksL1.SIZE))\n           .build());\n     final RocksL1 l1 = createL1(random);\n-    Assertions.assertDoesNotThrow(() -> {\n-      l1.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> l1.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -180,9 +167,7 @@ void executorL1AncestorsEqualsListPosition() {\n           .value(ID.toEntity())\n           .build());\n     final RocksL1 l1 = createL1(random);\n-    Assertions.assertDoesNotThrow(() -> {\n-      l1.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> l1.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -194,9 +179,7 @@ void executorL1FragmentsSize() {\n           .value(Entity.ofNumber(RocksL1.SIZE))\n           .build());\n     final RocksL1 l1 = createL1CompleteKeyList(random);\n-    Assertions.assertDoesNotThrow(() -> {\n-      l1.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> l1.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -212,9 +195,7 @@ void executorL1FragmentsEqualsList() {\n           .value(Entity.ofList(idsAsEntity))\n           .build());\n     final RocksL1 l1 = createL1CompleteKeyList(random);\n-    Assertions.assertDoesNotThrow(() -> {\n-      l1.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> l1.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -226,9 +207,7 @@ void executorL1FragmentsEqualsListPosition() {\n           .value(ID.toEntity())\n           .build());\n     final RocksL1 l1 = createL1CompleteKeyList(random);\n-    Assertions.assertDoesNotThrow(() -> {\n-      l1.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> l1.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -241,9 +220,7 @@ void executorL2Empty() {\n           .value(TRUE_ENTITY)\n           .build());\n     final RocksL2 l2 = createL2();\n-    Assertions.assertThrows(ConditionFailedException.class, () -> {\n-      l2.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertThrows(ConditionFailedException.class, () -> l2.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -256,13 +233,11 @@ void executorL2ChildrenSize() {\n     final List<Function> expectedFunctions = ImmutableList.of(\n         ImmutableFunction.builder()\n           .operator(Function.Operator.SIZE)\n-          .path(ofPath(RocksL1.CHILDREN))\n+          .path(ofPath(RocksL1.TREE))\n           .value(Entity.ofNumber(RocksL1.SIZE))\n           .build());\n     final RocksL2 l2 = createL2();\n-    Assertions.assertDoesNotThrow(() -> {\n-      l2.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> l2.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -271,21 +246,19 @@ void executorL2ChildrenEqualsList() {\n     for (int i = 0; i < RocksL1.SIZE; i++) {\n       idsAsEntity.add(ID.toEntity());\n     }\n-    equalsL2(RocksL1.CHILDREN, Entity.ofList(idsAsEntity));\n+    equalsL2(RocksL1.TREE, Entity.ofList(idsAsEntity));\n   }\n \n   @Test\n   void executorL2ChildrenEqualsListPosition() {\n     final List<Function> expectedFunctions = ImmutableList.of(\n         ImmutableFunction.builder()\n           .operator(Function.Operator.EQUALS)\n-          .path(ExpressionPath.builder(RocksL1.CHILDREN).position(3).build())\n+          .path(ExpressionPath.builder(RocksL1.TREE).position(3).build())\n           .value(ID.toEntity())\n           .build());\n     final RocksL2 l2 = createL2();\n-    Assertions.assertDoesNotThrow(() -> {\n-      l2.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> l2.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -298,9 +271,7 @@ void executorL3Empty() {\n           .value(TRUE_ENTITY)\n           .build());\n     final RocksL3 l3 = createL3();\n-    Assertions.assertThrows(ConditionFailedException.class, () -> {\n-      l3.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertThrows(ConditionFailedException.class, () -> l3.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -312,9 +283,7 @@ void executorL3ID() {\n           .value(Id.EMPTY.toEntity())\n           .build());\n     final RocksL3 l3 = createL3();\n-    Assertions.assertDoesNotThrow(() -> {\n-      l3.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> l3.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -327,10 +296,8 @@ void executorCommitMetadataId() {\n           .value(id.toEntity())\n           .build());\n     final RocksCommitMetadata meta = (RocksCommitMetadata) RocksCommitMetadata.of(\n-        id, 0L, ByteString.EMPTY);\n-    Assertions.assertDoesNotThrow(() -> {\n-      meta.evaluate(expectedFunctions);\n-    });\n+        id, 3L, ByteString.EMPTY);\n+    Assertions.assertDoesNotThrow(() -> meta.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -342,10 +309,8 @@ void executorCommitMetadataValue() {\n           .path(ofPath(RocksCommitMetadata.VALUE))\n           .value(Entity.ofBinary(value))\n           .build());\n-    final RocksCommitMetadata meta = (RocksCommitMetadata) RocksCommitMetadata.of(Id.EMPTY, 0L, value);\n-    Assertions.assertDoesNotThrow(() -> {\n-      meta.evaluate(expectedFunctions);\n-    });\n+    final RocksCommitMetadata meta = (RocksCommitMetadata) RocksCommitMetadata.of(Id.EMPTY, 5L, value);\n+    Assertions.assertDoesNotThrow(() -> meta.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -358,10 +323,8 @@ void executorCommitMetadataIdNoMatch() {\n           .path(ofPath(RocksCommitMetadata.ID))\n           .value(searchId.toEntity())\n           .build());\n-    final RocksCommitMetadata meta = (RocksCommitMetadata) RocksCommitMetadata.of(actualId, 0L, ByteString.EMPTY);\n-    Assertions.assertThrows(ConditionFailedException.class, () -> {\n-      meta.evaluate(expectedFunctions);\n-    });\n+    final RocksCommitMetadata meta = (RocksCommitMetadata) RocksCommitMetadata.of(actualId, 10L, ByteString.EMPTY);\n+    Assertions.assertThrows(ConditionFailedException.class, () -> meta.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -374,10 +337,8 @@ void executorCommitMetadataValueNoMatch() {\n           .path(ofPath(RocksCommitMetadata.VALUE))\n           .value(Entity.ofBinary(searchValue))\n           .build());\n-    final RocksCommitMetadata meta = (RocksCommitMetadata) RocksCommitMetadata.of(Id.EMPTY, 0L, actualValue);\n-    Assertions.assertThrows(ConditionFailedException.class, () -> {\n-      meta.evaluate(expectedFunctions);\n-    });\n+    final RocksCommitMetadata meta = (RocksCommitMetadata) RocksCommitMetadata.of(Id.EMPTY, 27L, actualValue);\n+    Assertions.assertThrows(ConditionFailedException.class, () -> meta.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -390,9 +351,7 @@ void executorTagEmpty() {\n           .value(TRUE_ENTITY)\n           .build());\n     final RocksRef ref = createTag();\n-    Assertions.assertThrows(ConditionFailedException.class, () -> {\n-      ref.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertThrows(ConditionFailedException.class, () -> ref.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -404,9 +363,7 @@ void executorTagID() {\n           .value(Id.EMPTY.toEntity())\n           .build());\n     final RocksRef ref = createTag();\n-    Assertions.assertDoesNotThrow(() -> {\n-      ref.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> ref.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -429,9 +386,7 @@ void executorTagChildrenEqualsListPosition() {\n           .value(ID.toEntity())\n           .build());\n     final RocksRef ref = createTag();\n-    Assertions.assertThrows(ConditionFailedException.class, () -> {\n-      ref.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertThrows(ConditionFailedException.class, () -> ref.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -453,9 +408,7 @@ void executorBranchChildrenSize() {\n           .value(Entity.ofNumber(RocksL1.SIZE))\n           .build());\n     final RocksRef ref = createBranch(random);\n-    Assertions.assertDoesNotThrow(() -> {\n-      ref.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> ref.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -476,9 +429,7 @@ void executorBranchChildrenEqualsListPosition() {\n           .value(ID.toEntity())\n           .build());\n     final RocksRef ref = createBranch(random);\n-    Assertions.assertDoesNotThrow(() -> {\n-      ref.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> ref.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -495,9 +446,7 @@ void executorBranchCommitsSize() {\n           .value(Entity.ofNumber(2))\n           .build());\n     final RocksRef ref = createBranch(random);\n-    Assertions.assertDoesNotThrow(() -> {\n-      ref.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> ref.evaluate(expectedFunctions));\n   }\n \n   @Test\n@@ -524,9 +473,7 @@ void executorFragmentSizeKeys() {\n           .value(Entity.ofNumber(keyListSize))\n           .build());\n     final RocksFragment fragment = createFragment();\n-    Assertions.assertDoesNotThrow(() -> {\n-      fragment.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> fragment.evaluate(expectedFunctions));\n   }\n \n   private static String createPath() {\n@@ -560,9 +507,7 @@ private static void equalsRocksBaseValue(String path, Entity entity, RocksBaseVa\n           .path(ofPath(path))\n           .value(entity)\n           .build());\n-    Assertions.assertDoesNotThrow(() -> {\n-      rocksBaseValue.evaluate(expectedFunctions);\n-    });\n+    Assertions.assertDoesNotThrow(() -> rocksBaseValue.evaluate(expectedFunctions));\n   }\n \n   /**\n@@ -687,6 +632,6 @@ private static ExpressionPath ofPath(String path) {\n       }\n     }\n \n-    return builder.build();\n+    return (builder != null ? builder.build() : null);\n   }\n }"
  },
  {
    "sha": "7e073fdd3d0e5af3517a4a557ebdc2da48bb8943",
    "filename": "versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestConditionExpressions.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestConditionExpressions.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestConditionExpressions.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestConditionExpressions.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -301,7 +301,7 @@ private static ExpressionPath ofPath(String path) {\n       }\n     }\n \n-    return builder.build();\n+    return (builder != null ? builder.build() : null);\n   }\n \n   private static String createPath() {"
  },
  {
    "sha": "a43b49e640e96c2b158fdefcc31daf95a275d44e",
    "filename": "versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBStore.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBStore.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBStore.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBStore.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -91,7 +91,7 @@ private static Path getRawPath() {\n \n   @Override\n   protected boolean supportsUpdate() {\n-    return false;\n+    return true;\n   }\n \n   private static void cleanFiles() throws IOException {"
  },
  {
    "sha": "0047e72191cd4295896947601fe93cb874210e5b",
    "filename": "versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBTieredVersionStore.java",
    "status": "modified",
    "additions": 0,
    "deletions": 2,
    "changes": 2,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBTieredVersionStore.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBTieredVersionStore.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBTieredVersionStore.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -17,13 +17,11 @@\n \n import java.nio.file.Path;\n \n-import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.TestInstance;\n import org.junit.jupiter.api.io.TempDir;\n import org.projectnessie.versioned.impl.AbstractITTieredVersionStore;\n \n @TestInstance(TestInstance.Lifecycle.PER_CLASS)\n-@Disabled(\"RocksDBStore not fully implemented\")\n class TestRocksDBTieredVersionStore extends AbstractITTieredVersionStore {\n   @TempDir\n   static Path DB_PATH;"
  },
  {
    "sha": "be495ad5ab7b7993702e7f66103459435786f4a9",
    "filename": "versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBUpdateClauseVisitor.java",
    "status": "added",
    "additions": 73,
    "deletions": 0,
    "changes": 73,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBUpdateClauseVisitor.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBUpdateClauseVisitor.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBUpdateClauseVisitor.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.projectnessie.versioned.rocksdb;\n+\n+import java.util.Random;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.projectnessie.versioned.impl.SampleEntities;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n+import org.projectnessie.versioned.impl.condition.RemoveClause;\n+import org.projectnessie.versioned.impl.condition.SetClause;\n+import org.projectnessie.versioned.store.Entity;\n+import org.projectnessie.versioned.store.Id;\n+\n+@DisplayName(\"RocksDBUpdateClauseVisitor tests\")\n+public class TestRocksDBUpdateClauseVisitor {\n+  private static final Random RANDOM = new Random(getRandomSeed());\n+  private static final Id ID = SampleEntities.createId(RANDOM);\n+  private static final Entity ID_ENTITY = ID.toEntity();\n+  private static final ExpressionPath L1_ID_PATH = ExpressionPath.builder(RocksL1.ID).build();\n+\n+  @Test\n+  void setEquals() {\n+    final SetClause setClause = SetClause.equals(L1_ID_PATH, ID_ENTITY);\n+    final UpdateFunction.SetFunction function = setTest(setClause);\n+    Assertions.assertEquals(UpdateFunction.SetFunction.SubOperator.EQUALS, function.getSubOperator());\n+  }\n+\n+  @Test\n+  void setAppendToList() {\n+    final SetClause setClause = SetClause.appendToList(L1_ID_PATH, ID_ENTITY);\n+    final UpdateFunction.SetFunction function = setTest(setClause);\n+    Assertions.assertEquals(UpdateFunction.SetFunction.SubOperator.APPEND_TO_LIST, function.getSubOperator());\n+  }\n+\n+  @Test\n+  void remove() {\n+    final RemoveClause removeClause = RemoveClause.of(L1_ID_PATH);\n+    final UpdateFunction.RemoveFunction function =\n+        (UpdateFunction.RemoveFunction) removeClause.accept(RocksDBUpdateClauseVisitor.ROCKS_DB_UPDATE_CLAUSE_VISITOR);\n+    Assertions.assertEquals(UpdateFunction.Operator.REMOVE, function.getOperator());\n+    Assertions.assertEquals(L1_ID_PATH, function.getPath());\n+  }\n+\n+  protected static long getRandomSeed() {\n+    return -2938423452345L;\n+  }\n+\n+  private UpdateFunction.SetFunction setTest(SetClause setClause) {\n+    final UpdateFunction.SetFunction function =\n+        (UpdateFunction.SetFunction) setClause.accept(RocksDBUpdateClauseVisitor.ROCKS_DB_UPDATE_CLAUSE_VISITOR);\n+    Assertions.assertEquals(UpdateFunction.Operator.SET, function.getOperator());\n+    Assertions.assertEquals(L1_ID_PATH, function.getPath());\n+    Assertions.assertEquals(ID_ENTITY, function.getValue());\n+    return function;\n+  }\n+}"
  },
  {
    "sha": "4afc17142037bf2f525192333aaa9b10f84242cf",
    "filename": "versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBVersionStore.java",
    "status": "modified",
    "additions": 0,
    "deletions": 10,
    "changes": 10,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBVersionStore.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBVersionStore.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestRocksDBVersionStore.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -29,10 +29,8 @@\n import org.projectnessie.versioned.tests.AbstractITVersionStore;\n \n @TestInstance(TestInstance.Lifecycle.PER_CLASS)\n-@Disabled(\"RocksDBStore not fully implemented\")\n public class TestRocksDBVersionStore extends AbstractITVersionStore {\n   private static final String testDatabaseName = \"mydb\";\n-  private String connectionString;\n \n   private RocksDBStoreFixture fixture;\n \n@@ -51,17 +49,9 @@ void deleteResources() {\n     return fixture;\n   }\n \n-  @Disabled\n-  @Override\n-  public void commitWithInvalidReference() throws ReferenceNotFoundException,\n-      ReferenceConflictException, ReferenceAlreadyExistsException {\n-    super.commitWithInvalidReference();\n-  }\n-\n   @Nested\n   @DisplayName(\"when transplanting\")\n   class WhenTransplanting extends AbstractITVersionStore.WhenTransplanting {\n-    @Disabled\n     @Override\n     protected void checkInvalidBranchHash() throws VersionStoreException {\n       super.checkInvalidBranchHash();"
  },
  {
    "sha": "245a9926d420d0543e5a7e787fa1ecb51063cd7c",
    "filename": "versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionBase.java",
    "status": "added",
    "additions": 73,
    "deletions": 0,
    "changes": 73,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionBase.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionBase.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionBase.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.projectnessie.versioned.rocksdb;\n+\n+import java.util.Random;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.projectnessie.versioned.impl.SampleEntities;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n+import org.projectnessie.versioned.impl.condition.RemoveClause;\n+import org.projectnessie.versioned.impl.condition.SetClause;\n+import org.projectnessie.versioned.impl.condition.UpdateExpression;\n+import org.projectnessie.versioned.store.Entity;\n+import org.projectnessie.versioned.store.Id;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+public abstract class TestUpdateFunctionBase {\n+  protected static final Random RANDOM = new Random(getRandomSeed());\n+\n+  protected static final Id ID = SampleEntities.createId(RANDOM);\n+  protected static final Id ID_2 = SampleEntities.createId(RANDOM);\n+  private static final Id ID_3 = SampleEntities.createId(RANDOM);\n+  protected static final ImmutableList<Id> ID_LIST = ImmutableList.of(ID, ID_2, ID_3);\n+  protected static final Entity ID_ENTITY_LIST = Entity.ofList(ID.toEntity(), ID_2.toEntity(), ID_3.toEntity());\n+\n+  protected static long getRandomSeed() {\n+    return -2938423452345L;\n+  }\n+\n+  protected void idRemove(RocksBaseValue baseValue) {\n+    final UpdateExpression updateExpression = UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(RocksBaseValue.ID).build()));\n+    updateTestFails(baseValue, updateExpression);\n+  }\n+\n+  protected void idSetEquals(RocksBaseValue baseValue) {\n+    final Id newId = SampleEntities.createId(RANDOM);\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksBaseValue.ID).build(), newId.toEntity()));\n+    baseValue.update(updateExpression);\n+    Assertions.assertEquals(newId, baseValue.getId());\n+  }\n+\n+  protected void idSetAppendToList(RocksBaseValue baseValue) {\n+    final Id newId = SampleEntities.createId(RANDOM);\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(RocksBaseValue.ID).build(), newId.toEntity()));\n+    updateTestFails(baseValue, updateExpression);\n+  }\n+\n+  static void updateTestFails(RocksBaseValue rocksBaseValue, UpdateExpression updateExpression) {\n+    try {\n+      rocksBaseValue.update(updateExpression);\n+      Assertions.fail(\"UnsupportedOperationException should have been thrown\");\n+    } catch (UnsupportedOperationException | IllegalStateException e) {\n+      // Expected result\n+    }\n+  }\n+}"
  },
  {
    "sha": "895f22706c7719b6ec96bc3f66e01d460cee0393",
    "filename": "versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionMultiple.java",
    "status": "added",
    "additions": 435,
    "deletions": 0,
    "changes": 435,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionMultiple.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionMultiple.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionMultiple.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -0,0 +1,435 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.projectnessie.versioned.rocksdb;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n+import org.projectnessie.versioned.impl.condition.RemoveClause;\n+import org.projectnessie.versioned.impl.condition.SetClause;\n+import org.projectnessie.versioned.impl.condition.UpdateExpression;\n+import org.projectnessie.versioned.store.ConditionFailedException;\n+import org.projectnessie.versioned.store.Entity;\n+import org.projectnessie.versioned.store.Id;\n+\n+import com.google.protobuf.ByteString;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+@DisplayName(\"RocksBase update() tests with multiple functions\")\n+public class TestUpdateFunctionMultiple {\n+  private static final String LIST_VALUE = \"listValue\";\n+  private static final String NESTED_VALUE = \"nestedValue\";\n+\n+  private static class RocksValueForTest extends RocksBaseValue<RocksValueForTest> {\n+    private List<ByteString> listValue;\n+    private List<List<ByteString>> nestedValue;\n+\n+    public RocksValueForTest(List<ByteString> listValue, List<List<ByteString>> nestedValue) {\n+      this.listValue = listValue;\n+      this.nestedValue = nestedValue;\n+    }\n+\n+    @Override\n+    public void evaluate(Function function) throws ConditionFailedException {\n+    }\n+\n+    @Override\n+    protected void remove(ExpressionPath path) {\n+      if (path.accept(PathPattern.exact(LIST_VALUE).anyPosition())) {\n+        listValue.remove(getPathSegmentAsPosition(path, 1));\n+      } else if (path.accept(PathPattern.exact(NESTED_VALUE).anyPosition())) {\n+        nestedValue.remove(getPathSegmentAsPosition(path, 1));\n+      } else if (path.accept(PathPattern.exact(NESTED_VALUE).anyPosition().anyPosition())) {\n+        int innerIndex = getPathSegmentAsPosition(path, 2);\n+        nestedValue.get(getPathSegmentAsPosition(path, 1)).remove(innerIndex);\n+      }\n+    }\n+\n+    @Override\n+    protected void appendToList(ExpressionPath path, List<Entity> valuesToAdd) {\n+      if (path.accept(PathPattern.exact(LIST_VALUE))) {\n+        listValue.addAll(valuesToAdd.stream().map(Entity::getBinary).collect(Collectors.toList()));\n+      } else if (path.accept(PathPattern.exact(NESTED_VALUE))) {\n+        nestedValue.addAll(valuesToAdd.stream().map(v ->\n+            v.getList().stream().map(Entity::getBinary).collect(Collectors.toList())\n+        ).collect(Collectors.toList()));\n+      } else if (path.accept(PathPattern.exact(NESTED_VALUE).anyPosition())) {\n+        nestedValue.get(getPathSegmentAsPosition(path, 1))\n+            .addAll(valuesToAdd.stream().map(Entity::getBinary).collect(Collectors.toList()));\n+      }\n+    }\n+\n+    @Override\n+    protected void set(ExpressionPath path, Entity newValue) {\n+      if (path.accept(PathPattern.exact(LIST_VALUE))) {\n+        listValue = newValue.getList().stream().map(Entity::getBinary).collect(Collectors.toList());\n+      } else if (path.accept(PathPattern.exact(LIST_VALUE).anyPosition())) {\n+        listValue.set(getPathSegmentAsPosition(path, 1), newValue.getBinary());\n+      } else if (path.accept(PathPattern.exact(NESTED_VALUE))) {\n+        nestedValue = newValue.getList().stream().map(v ->\n+            v.getList().stream().map(Entity::getBinary).collect(Collectors.toList())\n+        ).collect(Collectors.toList());\n+      } else if (path.accept(PathPattern.exact(NESTED_VALUE).anyPosition())) {\n+        nestedValue.set(\n+            getPathSegmentAsPosition(path, 1),\n+            newValue.getList().stream().map(Entity::getBinary).collect(Collectors.toList())\n+        );\n+      } else if (path.accept(PathPattern.exact(NESTED_VALUE).anyPosition().anyPosition())) {\n+        nestedValue.get(getPathSegmentAsPosition(path, 1)).set(\n+            getPathSegmentAsPosition(path, 2),\n+            newValue.getBinary()\n+        );\n+      }\n+    }\n+\n+    @Override\n+    byte[] build() {\n+      return new byte[0];\n+    }\n+\n+    public List<ByteString> getListValue() {\n+      return listValue;\n+    }\n+\n+    public List<List<ByteString>> getNestedValue() {\n+      return nestedValue;\n+    }\n+  }\n+\n+  private RocksValueForTest testValue;\n+\n+  @BeforeEach\n+  void createTestValue() {\n+    final List<ByteString> listValue = new ArrayList<>();\n+    final List<List<ByteString>> nestedValue = new ArrayList<>();\n+    final Random random = new Random();\n+\n+    for (int i = 0; i < 20; i++) {\n+      byte[] value = new byte[20];\n+      random.nextBytes(value);\n+      listValue.add(ByteString.copyFrom(value));\n+    }\n+\n+    for (int i = 0;i < 20; i++) {\n+      nestedValue.add(new ArrayList<>());\n+\n+      for (int j = 0; j < 20; j++) {\n+        byte[] value = new byte[20];\n+        random.nextBytes(value);\n+        nestedValue.get(i).add(ByteString.copyFrom(value));\n+      }\n+    }\n+\n+    testValue = new RocksValueForTest(listValue, nestedValue);\n+  }\n+\n+  @Test\n+  void removeThenRemoveSameElement() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(LIST_VALUE).position(0).build()))\n+        .and(RemoveClause.of(ExpressionPath.builder(LIST_VALUE).position(0).build()));\n+\n+    final List<ByteString> expectedList = testValue.getListValue().stream().skip(1).collect(Collectors.toList());\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getListValue());\n+  }\n+\n+  @Test\n+  void removeThenRemoveDifferentElement() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(LIST_VALUE).position(0).build()))\n+        .and(RemoveClause.of(ExpressionPath.builder(LIST_VALUE).position(1).build()));\n+\n+    final List<ByteString> expectedList = testValue.getListValue().stream().skip(2).collect(Collectors.toList());\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getListValue());\n+  }\n+\n+  @Test\n+  void removeHigherLevelThenRemoveLowerLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(NESTED_VALUE).position(0).build()))\n+        .and(RemoveClause.of(ExpressionPath.builder(NESTED_VALUE).position(0).position(0).build()));\n+\n+    final List<List<ByteString>> expectedList = testValue.getNestedValue().stream().skip(1).collect(Collectors.toList());\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getNestedValue());\n+  }\n+\n+  @Test\n+  void removeLowerLevelThenRemoveHigherLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(NESTED_VALUE).position(0).position(0).build()))\n+        .and(RemoveClause.of(ExpressionPath.builder(NESTED_VALUE).position(0).build()));\n+\n+    final List<List<ByteString>> expectedList = testValue.getNestedValue().stream().skip(1).collect(Collectors.toList());\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getNestedValue());\n+  }\n+\n+  @Test\n+  void removeThenSetEqualsSameLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(LIST_VALUE).position(0).build()))\n+        .and(SetClause.equals(ExpressionPath.builder(LIST_VALUE).position(0).build(), Id.build(\"foo\").toEntity()));\n+\n+    final List<ByteString> expectedList = new ArrayList<>(testValue.getListValue());\n+    expectedList.remove(0);\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getListValue());\n+  }\n+\n+  @Test\n+  void removeThenSetEqualsLowerLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(NESTED_VALUE).position(0).build()))\n+        .and(SetClause.equals(ExpressionPath.builder(NESTED_VALUE).position(0).position(0).build(), Id.build(\"foo\").toEntity()));\n+\n+    final List<List<ByteString>> expectedList = testValue.getNestedValue().stream().skip(1).collect(Collectors.toList());\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getNestedValue());\n+  }\n+\n+  @Test\n+  void removeThenSetEqualsHigherLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(NESTED_VALUE).position(0).position(0).build()))\n+        .and(SetClause.equals(ExpressionPath.builder(NESTED_VALUE).position(0).build(), Entity.ofList(Id.build(\"foo\").toEntity())));\n+\n+    final List<List<ByteString>> expectedList = new ArrayList<>(testValue.getNestedValue());\n+    expectedList.set(0, Collections.singletonList(Id.build(\"foo\").getValue()));\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getNestedValue());\n+  }\n+\n+  @Test\n+  void removeThenAppendSameLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(NESTED_VALUE).position(0).build()))\n+        .and(SetClause.appendToList(ExpressionPath.builder(NESTED_VALUE).position(0).build(), Entity.ofList(Id.build(\"foo\").toEntity())));\n+\n+    final List<List<ByteString>> expectedList = testValue.getNestedValue().stream().skip(1).collect(Collectors.toList());\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getNestedValue());\n+  }\n+\n+  @Test\n+  void removeThenAppendHigherLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(NESTED_VALUE).position(0).position(0).build()))\n+        .and(SetClause.appendToList(\n+          ExpressionPath.builder(NESTED_VALUE).build(),\n+          Entity.ofList(Entity.ofList(Id.build(\"foo\").toEntity())))\n+        );\n+\n+    final List<List<ByteString>> expectedList = new ArrayList<>(testValue.getNestedValue());\n+    final List<ByteString> innerList = new ArrayList<>(testValue.getNestedValue().get(0));\n+    innerList.remove(0);\n+    expectedList.set(0, innerList);\n+    expectedList.add(Collections.singletonList(Id.build(\"foo\").getValue()));\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getNestedValue());\n+  }\n+\n+  @Test\n+  void setEqualsThenRemoveSameLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(LIST_VALUE).position(0).build(), Id.build(\"foo\").toEntity()))\n+        .and(RemoveClause.of(ExpressionPath.builder(LIST_VALUE).position(0).build()));\n+\n+    final List<ByteString> expectedList = testValue.getListValue().stream().skip(1).collect(Collectors.toList());\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getListValue());\n+  }\n+\n+  @Test\n+  void setEqualsThenRemoveLowerLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(LIST_VALUE).build(), Entity.ofList(Id.build(\"foo\").toEntity())))\n+        .and(RemoveClause.of(ExpressionPath.builder(LIST_VALUE).position(0).build()));\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(Collections.singletonList(Id.build(\"foo\").getValue()), testValue.getListValue());\n+  }\n+\n+  @Test\n+  void setEqualsThenRemoveHigherLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(\n+          ExpressionPath.builder(NESTED_VALUE).position(0).position(0).build(),\n+          Id.build(\"foo\").toEntity())\n+        ).and(RemoveClause.of(ExpressionPath.builder(NESTED_VALUE).position(0).build()));\n+\n+    final List<List<ByteString>> expectedList = testValue.getNestedValue().stream().skip(1).collect(Collectors.toList());\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getNestedValue());\n+  }\n+\n+  @Test\n+  void setEqualsThenSetEqualsSameLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(LIST_VALUE).position(0).build(), Id.build(\"foo\").toEntity()))\n+        .and(SetClause.equals(ExpressionPath.builder(LIST_VALUE).position(0).build(), Id.build(\"bar\").toEntity()));\n+\n+    final List<ByteString> expectedList = new ArrayList<>(testValue.getListValue());\n+    expectedList.set(0, Id.build(\"bar\").getValue());\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getListValue());\n+  }\n+\n+  @Test\n+  void setEqualsThenSetEqualsLowerLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(\n+          ExpressionPath.builder(NESTED_VALUE).position(0).build(),\n+          Entity.ofList(Id.build(\"foo\").toEntity()))\n+        ).and(SetClause.equals(ExpressionPath.builder(NESTED_VALUE).position(0).position(0).build(), Id.build(\"bar\").toEntity()));\n+\n+    final List<List<ByteString>> expectedList = new ArrayList<>(testValue.getNestedValue());\n+    expectedList.set(0, Collections.singletonList(Id.build(\"foo\").getValue()));\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getNestedValue());\n+  }\n+\n+  @Test\n+  void setEqualsThenSetEqualsHigherLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(\n+          ExpressionPath.builder(NESTED_VALUE).position(0).position(0).build(),\n+          Id.build(\"foo\").toEntity())\n+        ).and(SetClause.equals(ExpressionPath.builder(NESTED_VALUE).position(0).build(), Entity.ofList(Id.build(\"bar\").toEntity())));\n+\n+    final List<List<ByteString>> expectedList = new ArrayList<>(testValue.getNestedValue());\n+    expectedList.set(0, Collections.singletonList(Id.build(\"bar\").getValue()));\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getNestedValue());\n+  }\n+\n+  @Test\n+  void setEqualsThenAppendSameLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(LIST_VALUE).position(0).build(), Id.build(\"foo\").toEntity()))\n+        .and(SetClause.appendToList(ExpressionPath.builder(LIST_VALUE).build(), Id.build(\"bar\").toEntity()));\n+\n+    final List<ByteString> expectedList = new ArrayList<>(testValue.getListValue());\n+    expectedList.set(0, Id.build(\"foo\").getValue());\n+    expectedList.add(Id.build(\"bar\").getValue());\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getListValue());\n+  }\n+\n+  @Test\n+  void setEqualsThenAppendLowerLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(LIST_VALUE).build(), Entity.ofList(Id.build(\"foo\").toEntity())))\n+        .and(SetClause.appendToList(ExpressionPath.builder(LIST_VALUE).build(), Id.build(\"bar\").toEntity()));\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(Collections.singletonList(Id.build(\"foo\").getValue()), testValue.getListValue());\n+  }\n+\n+  @Test\n+  void appendThenRemoveSameLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(LIST_VALUE).build(), Id.build(\"foo\").toEntity()))\n+        .and(RemoveClause.of(ExpressionPath.builder(LIST_VALUE).position(0).build()));\n+\n+    final List<ByteString> expectedList = new ArrayList<>(testValue.getListValue());\n+    expectedList.add(Id.build(\"foo\").getValue());\n+    expectedList.remove(0);\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getListValue());\n+  }\n+\n+  @Test\n+  void appendThenRemoveHigherLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(NESTED_VALUE).position(0).build(), Id.build(\"foo\").toEntity()))\n+        .and(RemoveClause.of(ExpressionPath.builder(NESTED_VALUE).position(0).build()));\n+\n+    final List<List<ByteString>> expectedList = testValue.getNestedValue().stream().skip(1).collect(Collectors.toList());\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getNestedValue());\n+  }\n+\n+  @Test\n+  void appendThenSetEqualsSameLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(LIST_VALUE).build(), Id.build(\"foo\").toEntity()))\n+        .and(SetClause.equals(ExpressionPath.builder(LIST_VALUE).position(0).build(), Id.build(\"bar\").toEntity()));\n+\n+    final List<ByteString> expectedList = new ArrayList<>(testValue.getListValue());\n+    expectedList.set(0, Id.build(\"bar\").getValue());\n+    expectedList.add(Id.build(\"foo\").getValue());\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getListValue());\n+  }\n+\n+  @Test\n+  void appendThenSetEqualsHigherLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(NESTED_VALUE).position(0).build(), Id.build(\"foo\").toEntity()))\n+        .and(SetClause.equals(ExpressionPath.builder(NESTED_VALUE).position(0).build(), Entity.ofList(Id.build(\"bar\").toEntity())));\n+\n+    final List<List<ByteString>> expectedList = new ArrayList<>(testValue.getNestedValue());\n+    expectedList.set(0, Collections.singletonList(Id.build(\"bar\").getValue()));\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getNestedValue());\n+  }\n+\n+  @Test\n+  void appendThenAppendSameLevel() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(LIST_VALUE).build(), Id.build(\"foo\").toEntity()))\n+        .and(SetClause.appendToList(ExpressionPath.builder(LIST_VALUE).build(), Id.build(\"bar\").toEntity()));\n+\n+    final List<ByteString> expectedList = new ArrayList<>(testValue.getListValue());\n+    expectedList.add(Id.build(\"foo\").getValue());\n+    expectedList.add(Id.build(\"bar\").getValue());\n+\n+    testValue.update(updateExpression);\n+    Assertions.assertEquals(expectedList, testValue.getListValue());\n+  }\n+}"
  },
  {
    "sha": "b278a45a1c720c23c26b90c1c1555a2252e9c911",
    "filename": "versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksCommitMetadata.java",
    "status": "added",
    "additions": 92,
    "deletions": 0,
    "changes": 92,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksCommitMetadata.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksCommitMetadata.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksCommitMetadata.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.projectnessie.versioned.rocksdb;\n+\n+import java.util.Random;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.projectnessie.versioned.impl.SampleEntities;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n+import org.projectnessie.versioned.impl.condition.RemoveClause;\n+import org.projectnessie.versioned.impl.condition.SetClause;\n+import org.projectnessie.versioned.impl.condition.UpdateExpression;\n+import org.projectnessie.versioned.store.Entity;\n+import org.projectnessie.versioned.store.Id;\n+\n+import com.google.protobuf.ByteString;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+@DisplayName(\"RocksValue update() tests\")\n+public class TestUpdateFunctionRocksCommitMetadata extends TestUpdateFunctionBase {\n+  final RocksCommitMetadata rocksCommitMetadata = createCommitMetadata(RANDOM);\n+\n+  /**\n+   * Create a Sample CommitMetadata entity.\n+   * @param random object to use for randomization of entity creation.\n+   * @return sample CommitMetadata entity.\n+   */\n+  static RocksCommitMetadata createCommitMetadata(Random random) {\n+    return (RocksCommitMetadata) new RocksCommitMetadata()\n+      .id(Id.EMPTY)\n+      .value(createRandomByteString(random));\n+  }\n+\n+  static ByteString createRandomByteString(Random random) {\n+    return ByteString.copyFrom(SampleEntities.createBinary(random, 20));\n+  }\n+\n+  @Test\n+  void idRemove() {\n+    idRemove(rocksCommitMetadata);\n+  }\n+\n+  @Test\n+  void idSetEquals() {\n+    idSetEquals(rocksCommitMetadata);\n+  }\n+\n+  @Test\n+  void idSetAppendToList() {\n+    idSetAppendToList(rocksCommitMetadata);\n+  }\n+\n+  @Test\n+  void valueRemove() {\n+    final UpdateExpression updateExpression = UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(RocksWrappedValue.VALUE).build()));\n+    updateTestFails(rocksCommitMetadata, updateExpression);\n+  }\n+\n+  @Test\n+  void valueSetEquals() {\n+    final ByteString newValue = createRandomByteString(RANDOM);\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksWrappedValue.VALUE).build(), Entity.ofBinary(newValue)));\n+    rocksCommitMetadata.update(updateExpression);\n+    Assertions.assertEquals(newValue, rocksCommitMetadata.getValue());\n+  }\n+\n+  @Test\n+  void valueSetAppendToList() {\n+    final Id newId = SampleEntities.createId(RANDOM);\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(RocksWrappedValue.VALUE).build(), newId.toEntity()));\n+    updateTestFails(rocksCommitMetadata, updateExpression);\n+  }\n+}"
  },
  {
    "sha": "462391ae09f1f8399d555ab20e3f124c57e7b39c",
    "filename": "versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksFragment.java",
    "status": "added",
    "additions": 52,
    "deletions": 0,
    "changes": 52,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksFragment.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksFragment.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksFragment.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.projectnessie.versioned.rocksdb;\n+\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.projectnessie.versioned.store.Id;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+@DisplayName(\"RocksFragment update() tests\")\n+public class TestUpdateFunctionRocksFragment extends TestUpdateFunctionBase {\n+  final RocksFragment rocksFragment = createFragment();\n+\n+  /**\n+   * Create a Sample Fragment entity.\n+   * @return sample Fragment entity.\n+   */\n+  static RocksFragment createFragment() {\n+    return (RocksFragment) new RocksFragment()\n+      .id(Id.EMPTY);\n+  }\n+\n+  @Test\n+  void idRemove() {\n+    idRemove(rocksFragment);\n+  }\n+\n+  @Test\n+  void idSetEquals() {\n+    idSetEquals(rocksFragment);\n+  }\n+\n+  @Test\n+  void idSetAppendToList() {\n+    idSetAppendToList(rocksFragment);\n+  }\n+}"
  },
  {
    "sha": "ab7b1b0156d205ba5e81d35ddb7a6bc65b9c7c56",
    "filename": "versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksL1.java",
    "status": "added",
    "additions": 427,
    "deletions": 0,
    "changes": 427,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksL1.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksL1.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksL1.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.projectnessie.versioned.rocksdb;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.projectnessie.versioned.Key;\n+import org.projectnessie.versioned.impl.SampleEntities;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n+import org.projectnessie.versioned.impl.condition.RemoveClause;\n+import org.projectnessie.versioned.impl.condition.SetClause;\n+import org.projectnessie.versioned.impl.condition.UpdateExpression;\n+import org.projectnessie.versioned.store.Entity;\n+import org.projectnessie.versioned.store.Id;\n+\n+import com.google.common.collect.Lists;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+@DisplayName(\"RocksL1 update() tests\")\n+public class TestUpdateFunctionRocksL1 extends TestUpdateFunctionBase {\n+  private RocksL1 rocksL1;\n+\n+  /**\n+   * Create a Sample L1 entity.\n+   */\n+  @BeforeEach\n+  void createL1() {\n+    rocksL1 = (RocksL1) new RocksL1()\n+      .id(Id.EMPTY)\n+      .commitMetadataId(ID)\n+      .children(Stream.generate(() -> ID).limit(RocksL1.SIZE))\n+      .ancestors(Stream.generate(() -> ID).limit(RocksL1.SIZE))\n+      .keyMutations(Stream.of(Key.of(SampleEntities.createString(RANDOM, 8), SampleEntities.createString(RANDOM, 9)).asAddition()))\n+      .incrementalKeyList(ID, 1);\n+  }\n+\n+  @Test\n+  void idRemove() {\n+    idRemove(rocksL1);\n+  }\n+\n+  @Test\n+  void idSetEquals() {\n+    idSetEquals(rocksL1);\n+  }\n+\n+  @Test\n+  void idSetAppendToList() {\n+    idSetAppendToList(rocksL1);\n+  }\n+\n+  @Test\n+  void commitMetadataIdRemove() {\n+    final UpdateExpression updateExpression = UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(RocksL1.ID).build()));\n+    updateTestFails(rocksL1, updateExpression);\n+  }\n+\n+  @Test\n+  void commitMetadataIdSetEquals() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksL1.COMMIT_METADATA).build(), ID_2.toEntity()));\n+    rocksL1.update(updateExpression);\n+    Assertions.assertEquals(ID_2, rocksL1.getMetadataId());\n+  }\n+\n+  @Test\n+  void idCommitMetadataSetAppendToList() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(RocksL1.COMMIT_METADATA).build(), ID_2.toEntity()));\n+    updateTestFails(rocksL1, updateExpression);\n+  }\n+\n+  @Test\n+  void incrementalKeyListCheckpointIdRemove() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(\n+        RemoveClause.of(ExpressionPath.builder(RocksL1.CHECKPOINT_ID).build()));\n+    updateTestFails(rocksL1, updateExpression);\n+  }\n+\n+  @Test\n+  void incrementalKeyListRemove() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(\n+        RemoveClause.of(ExpressionPath.builder(RocksL1.DISTANCE_FROM_CHECKPOINT).build()));\n+    updateTestFails(rocksL1, updateExpression);\n+  }\n+\n+  @Test\n+  void incrementalKeyListDistanceFromCheckpointSetEquals() {\n+    final Long distanceFromCheckpoint = 32L;\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksL1.DISTANCE_FROM_CHECKPOINT)\n+        .build(), Entity.ofNumber(distanceFromCheckpoint)));\n+    rocksL1.update(updateExpression);\n+    Assertions.assertEquals(distanceFromCheckpoint, rocksL1.getDistanceFromCheckpoint());\n+  }\n+\n+  @Test\n+  void incrementalKeyListCheckpointIdSetEquals() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksL1.CHECKPOINT_ID)\n+        .build(), ID_2.toEntity()));\n+    rocksL1.update(updateExpression);\n+    Assertions.assertEquals(ID_2, rocksL1.getCheckpointId());\n+  }\n+\n+  @Test\n+  void incrementKeyListDistanceFromCheckpointSetEqualsExistingCompleteList() {\n+    rocksL1.completeKeyList(Stream.of(Id.build(\"id1\"), Id.build(\"id2\")));\n+    final Long distanceFromCheckpoint = 32L;\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksL1.DISTANCE_FROM_CHECKPOINT)\n+        .build(), Entity.ofNumber(distanceFromCheckpoint)));\n+    rocksL1.update(updateExpression);\n+    Assertions.assertEquals(distanceFromCheckpoint, rocksL1.getDistanceFromCheckpoint());\n+  }\n+\n+  @Test\n+  void incrementKeyListCheckpointIdSetEqualsExistingCompleteList() {\n+    rocksL1.completeKeyList(Stream.of(Id.build(\"id1\"), Id.build(\"id2\")));\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksL1.CHECKPOINT_ID).build(), ID_2.toEntity()));\n+    rocksL1.update(updateExpression);\n+    Assertions.assertEquals(ID_2, rocksL1.getCheckpointId());\n+  }\n+\n+  @Test\n+  void completeKeyListRemoveFirst() {\n+    rocksL1.completeKeyList(Stream.of(Id.build(\"id1\"), Id.build(\"id2\")));\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(RocksL1.COMPLETE_KEY_LIST)\n+        .position(0).build()));\n+    rocksL1.update(updateExpression);\n+    Assertions.assertEquals(Collections.singletonList(Id.build(\"id2\")), rocksL1.getCompleteKeyList().collect(Collectors.toList()));\n+  }\n+\n+  @Test\n+  void completeKeyListRemoveLast() {\n+    rocksL1.completeKeyList(Stream.of(Id.build(\"id1\"), Id.build(\"id2\")));\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(RocksL1.COMPLETE_KEY_LIST)\n+        .position(1).build()));\n+    rocksL1.update(updateExpression);\n+    Assertions.assertEquals(Collections.singletonList(Id.build(\"id1\")), rocksL1.getCompleteKeyList().collect(Collectors.toList()));\n+  }\n+\n+  @Test\n+  void completeKeyListSetEqualsFirst() {\n+    rocksL1.completeKeyList(Stream.of(Id.build(\"id1\"), Id.build(\"id2\")));\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksL1.COMPLETE_KEY_LIST).position(0).build(),\n+        Id.build(\"id3\").toEntity()));\n+    rocksL1.update(updateExpression);\n+\n+    final List<Id> expectedList = Lists.newArrayList(Id.build(\"id3\"), Id.build(\"id2\"));\n+    Assertions.assertEquals(expectedList, rocksL1.getCompleteKeyList().collect(Collectors.toList()));\n+  }\n+\n+  @Test\n+  void completeKeyListSetEqualsAllWithList() {\n+    rocksL1.completeKeyList(Stream.of(Id.build(\"id1\"), Id.build(\"id2\")));\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksL1.COMPLETE_KEY_LIST).build(),\n+        Entity.ofList(Id.build(\"id3\").toEntity(), Id.build(\"id4\").toEntity())));\n+    rocksL1.update(updateExpression);\n+\n+    final List<Id> expectedList = Lists.newArrayList(Id.build(\"id3\"), Id.build(\"id4\"));\n+    Assertions.assertEquals(expectedList, rocksL1.getCompleteKeyList().collect(Collectors.toList()));\n+  }\n+\n+  @Test\n+  void completeKeyListSetEqualsAllWithId() {\n+    rocksL1.completeKeyList(Stream.of(Id.build(\"id1\"), Id.build(\"id2\")));\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksL1.COMPLETE_KEY_LIST).build(),\n+        Id.build(\"id3\").toEntity()));\n+    updateTestFails(rocksL1, updateExpression);\n+  }\n+\n+  @Test\n+  void completeKeyListSetAppendToWithId() {\n+    rocksL1.completeKeyList(Stream.of(Id.build(\"id1\"), Id.build(\"id2\")));\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(RocksL1.COMPLETE_KEY_LIST).build(),\n+        Id.build(\"id3\").toEntity()));\n+    rocksL1.update(updateExpression);\n+\n+    final List<Id> expectedList = Lists.newArrayList(Id.build(\"id1\"), Id.build(\"id2\"), Id.build(\"id3\"));\n+    Assertions.assertEquals(expectedList, rocksL1.getCompleteKeyList().collect(Collectors.toList()));\n+  }\n+\n+  @Test\n+  void completeKeyListSetAppendToWithList() {\n+    rocksL1.completeKeyList(Stream.of(Id.build(\"id1\"), Id.build(\"id2\")));\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(RocksL1.COMPLETE_KEY_LIST).build(),\n+        Entity.ofList(Id.build(\"id3\").toEntity(), Id.build(\"id4\").toEntity())));\n+    rocksL1.update(updateExpression);\n+\n+    final List<Id> expectedList = Lists.newArrayList(Id.build(\"id1\"), Id.build(\"id2\"), Id.build(\"id3\"), Id.build(\"id4\"));\n+    Assertions.assertEquals(expectedList, rocksL1.getCompleteKeyList().collect(Collectors.toList()));\n+  }\n+\n+  @Test\n+  void ancestorsRemove() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(\n+            RemoveClause.of(ExpressionPath.builder(RocksL1.ANCESTORS).build()));\n+    updateTestFails(rocksL1, updateExpression);\n+  }\n+\n+  @Test\n+  void ancestorsRemoveSingle() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(RocksL1.ANCESTORS).position(0).build()));\n+    final List<Id> expectedList = rocksL1.getAncestors().skip(1).collect(Collectors.toList());\n+\n+    rocksL1.update(updateExpression);\n+    final List<Id> updatedList = rocksL1.getAncestors().collect(Collectors.toList());\n+    Assertions.assertEquals(expectedList, updatedList);\n+  }\n+\n+  @Test\n+  void ancestorsSetEquals() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksL1.ANCESTORS).build(), ID_ENTITY_LIST));\n+    rocksL1.update(updateExpression);\n+    final List<Id> updatedList = rocksL1.getAncestors().collect(Collectors.toList());\n+    Assertions.assertEquals(ID_LIST, updatedList);\n+  }\n+\n+  @Test\n+  void ancestorsSetAppendToListWithId() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(RocksL1.ANCESTORS).build(), ID_2.toEntity()));\n+    final List<Id> initialList = rocksL1.getAncestors().collect(Collectors.toList());\n+    rocksL1.update(updateExpression);\n+    final List<Id> updatedList = rocksL1.getAncestors().collect(Collectors.toList());\n+    Assertions.assertEquals(updatedList.size() - initialList.size(), 1);\n+    Assertions.assertEquals(ID_2, updatedList.get(updatedList.size() - 1));\n+  }\n+\n+  @Test\n+  void ancestorsSetAppendToListWithList() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(RocksL1.ANCESTORS).build(), ID_ENTITY_LIST));\n+    final List<Id> initialList = rocksL1.getAncestors().collect(Collectors.toList());\n+    rocksL1.update(updateExpression);\n+    final List<Id> updatedList = rocksL1.getAncestors().collect(Collectors.toList());\n+    Assertions.assertEquals(updatedList.size() - initialList.size(), ID_LIST.size());\n+    Assertions.assertEquals(ID_LIST, updatedList.subList(initialList.size(), updatedList.size()));\n+  }\n+\n+  @Test\n+  void childrenRemove() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(\n+        RemoveClause.of(ExpressionPath.builder(RocksL1.TREE).build()));\n+    updateTestFails(rocksL1, updateExpression);\n+  }\n+\n+  @Test\n+  void childrenSetEquals() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksL1.TREE).build(), ID_ENTITY_LIST));\n+    rocksL1.update(updateExpression);\n+    final List<Id> updatedList = rocksL1.getChildren().collect(Collectors.toList());\n+    Assertions.assertEquals(ID_LIST, updatedList);\n+  }\n+\n+  @Test\n+  void childrenSetAppendToListWithId() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(RocksL1.TREE).build(), ID_2.toEntity()));\n+    final List<Id> initialList = rocksL1.getChildren().collect(Collectors.toList());\n+    rocksL1.update(updateExpression);\n+    final List<Id> updatedList = rocksL1.getChildren().collect(Collectors.toList());\n+    Assertions.assertEquals(updatedList.size() - initialList.size(), 1);\n+    Assertions.assertEquals(ID_2, updatedList.get(updatedList.size() - 1));\n+  }\n+\n+  @Test\n+  void childrenSetAppendToListWithList() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(RocksL1.TREE).build(), ID_ENTITY_LIST));\n+    final List<Id> initialList = rocksL1.getChildren().collect(Collectors.toList());\n+    rocksL1.update(updateExpression);\n+    final List<Id> updatedList = rocksL1.getChildren().collect(Collectors.toList());\n+    Assertions.assertEquals(updatedList.size() - initialList.size(), ID_LIST.size());\n+    Assertions.assertEquals(ID_LIST, updatedList.subList(initialList.size(), updatedList.size()));\n+  }\n+\n+  @Test\n+  void keyMutationsRemove() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(\n+            RemoveClause.of(ExpressionPath.builder(RocksL1.KEY_MUTATIONS).build()));\n+    updateTestFails(rocksL1, updateExpression);\n+  }\n+\n+  @Test\n+  void keyMutationsRemoveSingle() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(RocksL1.KEY_MUTATIONS).position(0).build()));\n+\n+    final List<Integer> expectedKeyMutationTypes = new ArrayList<>();\n+    for (int i = 1; i < rocksL1.getKeyMutationsCount(); i++) {\n+      expectedKeyMutationTypes.add(rocksL1.getKeyMutationType(i));\n+    }\n+    final List<List<String>> expectedKeyMutationKeys = new ArrayList<>();\n+    for (int i = 1; i < rocksL1.getKeyMutationsCount(); i++) {\n+      expectedKeyMutationKeys.add(rocksL1.getKeyMutationKeys(i));\n+    }\n+\n+    rocksL1.update(updateExpression);\n+    Assertions.assertEquals(expectedKeyMutationTypes.size(), rocksL1.getKeyMutationsCount());\n+    for (int i = 0; i < expectedKeyMutationTypes.size(); i++) {\n+      Assertions.assertEquals(expectedKeyMutationTypes.get(i), rocksL1.getKeyMutationType(i));\n+      Assertions.assertEquals(expectedKeyMutationKeys.get(i), rocksL1.getKeyMutationKeys(i));\n+    }\n+  }\n+\n+  @Test\n+  void keyMutationsSetEquals() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksL1.KEY_MUTATIONS).build(), ID_ENTITY_LIST));\n+    updateTestFails(rocksL1, updateExpression);\n+  }\n+\n+  @Test\n+  void keyMutationsSetEqualsSingle() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksL1.KEY_MUTATIONS).position(0).build(), ID_ENTITY_LIST));\n+    updateTestFails(rocksL1, updateExpression);\n+  }\n+\n+  @Test\n+  void keyMutationsSetEqualsKey() {\n+    final int index = 0;\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath\n+            .builder(RocksL1.KEY_MUTATIONS)\n+            .position(index)\n+            .name(RocksL1.KEY_MUTATIONS_KEY)\n+            .build(), Entity.ofList(Entity.ofString(\"foo\"), Entity.ofString(\"bar\"))));\n+    rocksL1.update(updateExpression);\n+    Assertions.assertEquals(Lists.newArrayList(\"foo\", \"bar\"), rocksL1.getKeyMutationKeys(index));\n+  }\n+\n+  @Test\n+  void keyMutationsSetEqualsKeySingle() {\n+    final int keyMutationsIndex = 0;\n+    final int keyMutationsKeyIndex = 0;\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath\n+            .builder(RocksL1.KEY_MUTATIONS)\n+            .position(keyMutationsIndex)\n+            .name(RocksL1.KEY_MUTATIONS_KEY)\n+            .position(keyMutationsKeyIndex)\n+            .build(), Entity.ofString(\"foo\")));\n+\n+    final List<String> expectedList = new ArrayList<>(rocksL1.getKeyMutationKeys(keyMutationsIndex));\n+    expectedList.set(keyMutationsKeyIndex, \"foo\");\n+\n+    rocksL1.update(updateExpression);\n+    Assertions.assertEquals(expectedList, rocksL1.getKeyMutationKeys(keyMutationsIndex));\n+  }\n+\n+  @Test\n+  void keyMutationsSetAppendToListSingle() {\n+    final int index = 0;\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath\n+            .builder(RocksL1.KEY_MUTATIONS)\n+            .position(index)\n+            .name(RocksL1.KEY_MUTATIONS_KEY)\n+            .build(), Entity.ofString(\"foo\")));\n+\n+    final List<String> expectedList = new ArrayList<>(rocksL1.getKeyMutationKeys(index));\n+    expectedList.add(\"foo\");\n+\n+    rocksL1.update(updateExpression);\n+    Assertions.assertEquals(expectedList, rocksL1.getKeyMutationKeys(index));\n+  }\n+\n+  @Test\n+  void keyMutationsSetAppendToListWithList() {\n+    final int index = 0;\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath\n+            .builder(RocksL1.KEY_MUTATIONS)\n+            .position(index)\n+            .name(RocksL1.KEY_MUTATIONS_KEY)\n+            .build(), Entity.ofList(Entity.ofString(\"foo\"), Entity.ofString(\"bar\"))));\n+\n+    final List<String> expectedList = new ArrayList<>(rocksL1.getKeyMutationKeys(index));\n+    expectedList.add(\"foo\");\n+    expectedList.add(\"bar\");\n+\n+    rocksL1.update(updateExpression);\n+    Assertions.assertEquals(expectedList, rocksL1.getKeyMutationKeys(index));\n+  }\n+}"
  },
  {
    "sha": "cc0f09e4de73de4baee56365edf896a1c568016d",
    "filename": "versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksL2.java",
    "status": "added",
    "additions": 100,
    "deletions": 0,
    "changes": 100,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksL2.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksL2.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksL2.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.projectnessie.versioned.rocksdb;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n+import org.projectnessie.versioned.impl.condition.RemoveClause;\n+import org.projectnessie.versioned.impl.condition.SetClause;\n+import org.projectnessie.versioned.impl.condition.UpdateExpression;\n+import org.projectnessie.versioned.store.Id;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+@DisplayName(\"RocksL2 update() tests\")\n+public class TestUpdateFunctionRocksL2 extends TestUpdateFunctionBase {\n+  final RocksL2 rocksL2 = createL2();\n+\n+  /**\n+   * Create a Sample L2 entity.\n+   * @return sample L2 entity.\n+   */\n+  static RocksL2 createL2() {\n+    return (RocksL2) new RocksL2()\n+      .id(Id.EMPTY)\n+      .children(Stream.generate(() -> ID).limit(RocksL1.SIZE));\n+  }\n+\n+  @Test\n+  void idRemove() {\n+    idRemove(rocksL2);\n+  }\n+\n+  @Test\n+  void idSetEquals() {\n+    idSetEquals(rocksL2);\n+  }\n+\n+  @Test\n+  void idSetAppendToList() {\n+    idSetAppendToList(rocksL2);\n+  }\n+\n+  @Test\n+  void childrenRemove() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(RemoveClause.of(ExpressionPath.builder(RocksL2.TREE).build()));\n+    updateTestFails(rocksL2, updateExpression);\n+  }\n+\n+  @Test\n+  void childrenSetEquals() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.equals(ExpressionPath.builder(RocksL2.TREE).build(), ID_ENTITY_LIST));\n+    rocksL2.update(updateExpression);\n+    final List<Id> updatedList = rocksL2.getChildren().collect(Collectors.toList());\n+    Assertions.assertEquals(ID_LIST, updatedList);\n+  }\n+\n+  @Test\n+  void childrenSetAppendToListWithId() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(RocksL2.TREE).build(), ID_2.toEntity()));\n+    final List<Id> initialList = rocksL2.getChildren().collect(Collectors.toList());\n+    rocksL2.update(updateExpression);\n+    final List<Id> updatedList = rocksL2.getChildren().collect(Collectors.toList());\n+    Assertions.assertEquals(updatedList.size() - initialList.size(), 1);\n+    Assertions.assertEquals(ID_2, updatedList.get(updatedList.size() - 1));\n+  }\n+\n+  @Test\n+  void childrenSetAppendToListWithList() {\n+    final UpdateExpression updateExpression =\n+        UpdateExpression.of(SetClause.appendToList(ExpressionPath.builder(RocksL2.TREE).build(), ID_ENTITY_LIST));\n+    final List<Id> initialList = rocksL2.getChildren().collect(Collectors.toList());\n+    rocksL2.update(updateExpression);\n+    final List<Id> updatedList = rocksL2.getChildren().collect(Collectors.toList());\n+    Assertions.assertEquals(updatedList.size() - initialList.size(), ID_LIST.size());\n+    Assertions.assertEquals(ID_LIST, updatedList.subList(initialList.size(), updatedList.size()));\n+  }\n+}"
  },
  {
    "sha": "5a8c1f901dda5cb90b422f489138670cd1c5dca7",
    "filename": "versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksL3.java",
    "status": "added",
    "additions": 52,
    "deletions": 0,
    "changes": 52,
    "blob_url": "https://github.com/stevelorddremio/nessie/blob/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksL3.java",
    "raw_url": "https://github.com/stevelorddremio/nessie/raw/25817ca8ecd54db3accd6f838436dfb8bd2e5512/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksL3.java",
    "contents_url": "https://api.github.com/repos/stevelorddremio/nessie/contents/versioned/tiered/rocksdb/src/test/java/org/projectnessie/versioned/rocksdb/TestUpdateFunctionRocksL3.java?ref=25817ca8ecd54db3accd6f838436dfb8bd2e5512",
    "patch": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.projectnessie.versioned.rocksdb;\n+\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.projectnessie.versioned.store.Id;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+@DisplayName(\"RocksL3 update() tests\")\n+public class TestUpdateFunctionRocksL3 extends TestUpdateFunctionBase {\n+  final RocksL3 rocksL3 = createL3();\n+\n+  /**\n+   * Create a Sample L3 entity.\n+   * @return sample L3 entity.\n+   */\n+  static RocksL3 createL3() {\n+    return (RocksL3) new RocksL3()\n+      .id(Id.EMPTY);\n+  }\n+\n+  @Test\n+  void idRemove() {\n+    idRemove(rocksL3);\n+  }\n+\n+  @Test\n+  void idSetEquals() {\n+    idSetEquals(rocksL3);\n+  }\n+\n+  @Test\n+  void idSetAppendToList() {\n+    idSetAppendToList(rocksL3);\n+  }\n+}"
  }
]
