[
  {
    "sha": "cdb2b5a093c3585fd6f5bf3d7672b9d853fa3979",
    "filename": "pantheon-bundle/src/main/java/com/redhat/pantheon/servlet/MapConverters.java",
    "status": "added",
    "additions": 154,
    "deletions": 0,
    "changes": 154,
    "blob_url": "https://github.com/redhataccess/pantheon/blob/520093f3e48ce0b927331bfce642ac9e98ea47b4/pantheon-bundle/src/main/java/com/redhat/pantheon/servlet/MapConverters.java",
    "raw_url": "https://github.com/redhataccess/pantheon/raw/520093f3e48ce0b927331bfce642ac9e98ea47b4/pantheon-bundle/src/main/java/com/redhat/pantheon/servlet/MapConverters.java",
    "contents_url": "https://api.github.com/repos/redhataccess/pantheon/contents/pantheon-bundle/src/main/java/com/redhat/pantheon/servlet/MapConverters.java?ref=520093f3e48ce0b927331bfce642ac9e98ea47b4",
    "patch": "@@ -0,0 +1,154 @@\n+package com.redhat.pantheon.servlet;\n+\n+import com.google.common.base.Charsets;\n+import com.redhat.pantheon.extension.url.CustomerPortalUrlUuidProvider;\n+import com.redhat.pantheon.html.Html;\n+import com.redhat.pantheon.model.ProductVersion;\n+import com.redhat.pantheon.model.api.FileResource;\n+import com.redhat.pantheon.model.module.ModuleMetadata;\n+import com.redhat.pantheon.model.module.ModuleVariant;\n+import com.redhat.pantheon.model.module.ModuleVersion;\n+import com.redhat.pantheon.servlet.util.ServletHelper;\n+import org.apache.sling.api.SlingHttpServletRequest;\n+\n+import javax.jcr.RepositoryException;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.Maps.newHashMap;\n+import static com.redhat.pantheon.conf.GlobalConfig.CONTENT_TYPE;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;\n+\n+/**\n+ * A series of converters to map form for different business purposes.\n+ */\n+public class MapConverters {\n+\n+    private MapConverters() {\n+    }\n+\n+    /**\n+     * Converts a {@link ModuleVariant} object to a map for returning in API calls.\n+     * @param request The web request being processed.\n+     * @param mv The module variant domain object to transform to a map.\n+     * @return A map for Json conversion in API calls with the module variant's information.\n+     * @throws RepositoryException IF there is a problem fetching related data when building the map.\n+     */\n+    public static final Map<String, Object> moduleVariantToMap(final SlingHttpServletRequest request,\n+                                                               final ModuleVariant mv)\n+            throws RepositoryException {\n+        Optional<ModuleMetadata> releasedMetadata = mv.released()\n+                .toChild(ModuleVersion::metadata)\n+                .asOptional();\n+        Optional<FileResource> releasedContent = mv.released()\n+                .toChild(ModuleVersion::cachedHtml)\n+                .asOptional();\n+        Optional<ModuleVersion> releasedRevision = mv.released()\n+                .asOptional();\n+\n+        Map<String, Object> variantMap = newHashMap(mv.getValueMap());\n+        Map<String, Object> variantDetails = new HashMap<>();\n+\n+        variantDetails.put(\"status\", SC_OK);\n+        variantDetails.put(\"message\", \"Module Found\");\n+\n+        String resourcePath = mv.getPath();\n+        variantMap.put(\"locale\", ServletUtils.toLanguageTag(mv.getParentLocale().getName()));\n+        variantMap.put(\"revision_id\", releasedRevision.get().getName());\n+        variantMap.put(\"title\", releasedMetadata.get().title().get());\n+        variantMap.put(\"headline\", releasedMetadata.get().getValueMap().containsKey(\"pant:headline\") ? releasedMetadata.get().headline().get() : \"\");\n+        variantMap.put(\"description\", releasedMetadata.get().getValueMap().containsKey(\"jcr:description\") ? releasedMetadata.get().description().get() : releasedMetadata.get().mAbstract().get());\n+        variantMap.put(\"content_type\", CONTENT_TYPE);\n+        variantMap.put(\"date_published\", releasedMetadata.get().getValueMap().containsKey(\"pant:datePublished\") ? releasedMetadata.get().datePublished().get().toInstant().toString() : \"\");\n+        variantMap.put(\"date_first_published\", releasedMetadata.get().getValueMap().containsKey(\"pant:dateFirstPublished\") ? releasedMetadata.get().dateFirstPublished().get().toInstant().toString() : \"\");\n+        variantMap.put(\"status\", \"published\");\n+\n+        // Assume the path is something like: /content/<something>/my/resource/path\n+        variantMap.put(\"module_url_fragment\", resourcePath.substring(\"/content/repositories/\".length()));\n+\n+        // Striping out the jcr: from key name\n+        String variant_uuid = (String) variantMap.remove(\"jcr:uuid\");\n+        // TODO: remove uuid when there are no more consumers for it (Solr, Hydra, Customer Portal)\n+        variantMap.put(\"uuid\", variant_uuid);\n+        variantMap.put(\"variant_uuid\", variant_uuid);\n+        variantMap.put(\"document_uuid\", mv.getParentLocale().getParent().uuid().get());\n+        // Convert date string to UTC\n+        Date dateModified = new Date(mv.getResourceMetadata().getModificationTime());\n+        variantMap.put(\"date_modified\", dateModified.toInstant().toString());\n+        // Return the body content of the module ONLY\n+        variantMap.put(\"body\",\n+                Html.parse(Charsets.UTF_8.name())\n+                        .andThen(Html.rewriteUuidUrls(request.getResourceResolver(), new CustomerPortalUrlUuidProvider()))\n+                        .andThen(Html.getBody())\n+                        .apply(releasedContent.get().jcrContent().get().jcrData().get()));\n+\n+        // Fields that are part of the spec and yet to be implemented\n+        // TODO Should either of these be the variant name?\n+        variantMap.put(\"context_url_fragment\", \"\");\n+        variantMap.put(\"context_id\", \"\");\n+\n+        // Process productVersion from metadata\n+        // Making these arrays - in the future, we will have multi-product, so get the API right the first time\n+        List<Map> productList = new ArrayList<>();\n+        variantMap.put(\"products\", productList);\n+        ProductVersion pv = releasedMetadata.get().productVersion().getReference();\n+        String versionUrlFragment = \"\";\n+        String productUrlFragment = \"\";\n+        if (pv != null) {\n+            Map<String, String> productMap = new HashMap<>();\n+            productList.add(productMap);\n+            productMap.put(\"product_version\", pv.name().get());\n+            versionUrlFragment = pv.getValueMap().containsKey(\"urlFragment\") ? pv.urlFragment().get() : \"\";\n+            productMap.put(\"version_url_fragment\", versionUrlFragment);\n+            productUrlFragment = pv.getProduct().getValueMap().containsKey(\"urlFragment\") ? pv.getProduct().urlFragment().get() : \"\";\n+            productMap.put(\"product_name\", pv.getProduct().name().get());\n+            productMap.put(\"product_url_fragment\", productUrlFragment);\n+        }\n+\n+        // Process url_fragment from metadata\n+        String urlFragment = releasedMetadata.get().urlFragment().get() != null ? releasedMetadata.get().urlFragment().get() : \"\";\n+        if (!urlFragment.isEmpty()) {\n+            variantMap.put(\"vanity_url_fragment\", urlFragment);\n+        } else {\n+            variantMap.put(\"vanity_url_fragment\", \"\");\n+        }\n+\n+        String searchKeywords = releasedMetadata.get().searchKeywords().get();\n+        if (searchKeywords != null && !searchKeywords.isEmpty()) {\n+            variantMap.put(\"search_keywords\", searchKeywords.split(\", *\"));\n+        } else {\n+            variantMap.put(\"search_keywords\", new String[]{});\n+        }\n+\n+        // Process view_uri\n+        if (System.getenv(\"portal_url\") != null) {\n+            String view_uri = new CustomerPortalUrlUuidProvider().generateUrlString(mv);\n+            variantMap.put(\"view_uri\", view_uri);\n+        } else {\n+            variantMap.put(\"view_uri\", \"\");\n+        }\n+        List<HashMap<String, String>> includeAssemblies = new ArrayList<>();\n+\n+        //get the assemblies and iterate over them\n+\n+        ServletHelper.addAssemblyDetails(ServletHelper.getModuleUuidFromVariant(mv), includeAssemblies, request, false, false);\n+        variantMap.put(\"included_in_guides\", includeAssemblies);\n+        variantMap.put(\"isPartOf\", includeAssemblies);\n+        // remove unnecessary fields from the map\n+        variantMap.remove(\"jcr:lastModified\");\n+        variantMap.remove(\"jcr:lastModifiedBy\");\n+        variantMap.remove(\"jcr:createdBy\");\n+        variantMap.remove(\"jcr:created\");\n+        variantMap.remove(\"sling:resourceType\");\n+        variantMap.remove(\"jcr:primaryType\");\n+\n+        // Adding variantMap to a parent variantDetails map\n+        variantDetails.put(\"module\", variantMap);\n+\n+        return variantDetails;\n+    }\n+}"
  },
  {
    "sha": "747a8ec2e7d1aaf02b62221e7ff7d98584266dd6",
    "filename": "pantheon-bundle/src/main/java/com/redhat/pantheon/servlet/module/VanityVariantJsonServlet.java",
    "status": "added",
    "additions": 143,
    "deletions": 0,
    "changes": 143,
    "blob_url": "https://github.com/redhataccess/pantheon/blob/520093f3e48ce0b927331bfce642ac9e98ea47b4/pantheon-bundle/src/main/java/com/redhat/pantheon/servlet/module/VanityVariantJsonServlet.java",
    "raw_url": "https://github.com/redhataccess/pantheon/raw/520093f3e48ce0b927331bfce642ac9e98ea47b4/pantheon-bundle/src/main/java/com/redhat/pantheon/servlet/module/VanityVariantJsonServlet.java",
    "contents_url": "https://api.github.com/repos/redhataccess/pantheon/contents/pantheon-bundle/src/main/java/com/redhat/pantheon/servlet/module/VanityVariantJsonServlet.java?ref=520093f3e48ce0b927331bfce642ac9e98ea47b4",
    "patch": "@@ -0,0 +1,143 @@\n+package com.redhat.pantheon.servlet.module;\n+\n+import com.ibm.icu.util.ULocale;\n+import com.redhat.pantheon.jcr.JcrQueryHelper;\n+import com.redhat.pantheon.model.api.SlingModels;\n+import com.redhat.pantheon.model.module.ModuleVariant;\n+import com.redhat.pantheon.model.module.ModuleVersion;\n+import com.redhat.pantheon.servlet.MapConverters;\n+import com.redhat.pantheon.servlet.util.SlingPathSuffix;\n+import org.apache.sling.api.SlingHttpServletRequest;\n+import org.apache.sling.api.SlingHttpServletResponse;\n+import org.apache.sling.api.servlets.SlingSafeMethodsServlet;\n+import org.apache.sling.servlets.annotations.SlingServletPaths;\n+import org.jetbrains.annotations.NotNull;\n+import org.osgi.framework.Constants;\n+import org.osgi.service.component.annotations.Component;\n+\n+import javax.jcr.RepositoryException;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.redhat.pantheon.servlet.ServletUtils.writeAsJson;\n+\n+/**\n+ * An API endpoint for finding module information using a vanity url format which takes into account the content's\n+ * product metadata, and locale. The format is as follows:<br><br>\n+ *\n+ * '/api/module/vanity.json/{locale}/{product}/{version}/{vanityUrlFragment}'<br><br>\n+ *\n+ * It will also resolve content with the following format: <br><br>\n+ *\n+ * '/api/module/vanity.json/{locale}/{product}/{version}/{moduleUUID}'\n+ *\n+ * <br>\n+ * @see VariantJsonServlet for a servlet returning the same information\n+ * @author Carlos Munoz\n+ */\n+@Component(\n+        service = Servlet.class,\n+        property = {\n+                Constants.SERVICE_DESCRIPTION + \"=Servlet to facilitate GET operation which accepts several path parameters to fetch module variant data\",\n+                Constants.SERVICE_VENDOR + \"=Red Hat Content Tooling team\"\n+        })\n+@SlingServletPaths(value = \"/api/module/vanity\")\n+// /api/module/vanity.json/{locale}/{productLabel}/{versionLabel}/{vanityUrl}\n+public class VanityVariantJsonServlet extends SlingSafeMethodsServlet {\n+\n+    private final SlingPathSuffix suffix = new SlingPathSuffix(\"/{locale}/{productLabel}/{versionLabel}/{vanityUrl}\");\n+\n+    @Override\n+    protected void doGet(@NotNull SlingHttpServletRequest request, @NotNull SlingHttpServletResponse response) throws ServletException, IOException {\n+        Map<String, String> params = suffix.getParameters(request);\n+        String locale = params.get(\"locale\");\n+        String productLabel = params.get(\"productLabel\");\n+        String versionLabel = params.get(\"versionLabel\");\n+        String vanityUrl = params.get(\"vanityUrl\");\n+\n+        JcrQueryHelper queryHelper = new JcrQueryHelper(request.getResourceResolver());\n+        try {\n+\n+            // Find the metadata with the right vanity url,\n+            Optional<ModuleVersion> moduleVersion = queryHelper.query(\n+                    \"select * from [pant:moduleVersion] as v where v.[metadata/urlFragment] = '/\" + vanityUrl + \"'\")\n+                    .map(resource -> SlingModels.getModel(resource, ModuleVersion.class))\n+                    // the right locale,\n+                    .filter(modVer -> {\n+                        String normalizedLocaleCode = ULocale.canonicalize(locale);\n+                        String normalizedModuleLocaleCode = ULocale.canonicalize(modVer.getParent().getParentLocale().getName());\n+                        return normalizedLocaleCode.equals(normalizedModuleLocaleCode);\n+                    })\n+                    // the right version,\n+                    .filter(modVer -> {\n+                        try {\n+                            return modVer.metadata().get().productVersion().getReference().name().get().equals(versionLabel);\n+                        } catch (RepositoryException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    // and the right product\n+                    .filter(modVer -> {\n+                        try {\n+                            return modVer.metadata().get().productVersion().getReference().getProduct().urlFragment().get().equals(productLabel);\n+                        } catch (RepositoryException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    // There should be 1 at most, but get the first if there are more\n+                    .findFirst();\n+\n+            if(!moduleVersion.isPresent()) {\n+                // try to find by variant uuid, instead of vanity url\n+                moduleVersion = findModuleByUuid(queryHelper, productLabel, versionLabel, locale, vanityUrl);\n+            }\n+\n+            if(!moduleVersion.isPresent()) {\n+                response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Module version with vanity url '\" + vanityUrl + \"' not found\");\n+                return;\n+            }\n+            else {\n+                // TODO This is traversing up to the variant to keep the compatibility with VariantJsonServlet\n+                //  it should be revisited if/after this api is deprecated\n+                writeAsJson(response, MapConverters.moduleVariantToMap(request, moduleVersion.get().getParent()));\n+            }\n+\n+        } catch (RepositoryException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    // TODO This could just piggy back on the other variant json servlet (but then there is no validation)\n+    private Optional<ModuleVersion> findModuleByUuid(final JcrQueryHelper queryHelper,\n+                                                     final String productUrlFragment,\n+                                                     final String productVersionUrlFragment,\n+                                                     final String locale,\n+                                                     final String moduleVariantUuid) {\n+        try {\n+            return queryHelper.query(\"select * from [pant:moduleVariant] as moduleVariant WHERE moduleVariant.[jcr:uuid] = '\" +\n+                    moduleVariantUuid + \"'\")\n+                    .map(resource -> SlingModels.getModel(resource, ModuleVariant.class))\n+                    // check the other parameters match\n+                    .filter(moduleVariant -> {\n+                        try {\n+                            return ULocale.canonicalize(moduleVariant.getParentLocale().getName()).equals(ULocale.canonicalize(locale))\n+                                    && moduleVariant.released().get().metadata().get().productVersion().getReference().urlFragment().get()\n+                                    .equals(productVersionUrlFragment)\n+                                    && moduleVariant.released().get().metadata().get().productVersion().getReference().getProduct()\n+                                    .urlFragment().get().equals(productUrlFragment);\n+                        } catch (RepositoryException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    // use the released version to keep compatibility with VariantJsonServlet\n+                    .map(moduleVariant -> moduleVariant.released().get())\n+                    .findFirst();\n+        } catch (RepositoryException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}"
  }
]
