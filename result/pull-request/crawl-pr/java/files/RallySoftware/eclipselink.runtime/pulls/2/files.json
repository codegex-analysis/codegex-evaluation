[
  {
    "sha": "acc2a4182d1220d0d01aac869d056b96220444ea",
    "filename": "foundation/org.eclipse.persistence.core/src/org/eclipse/persistence/mappings/ForeignReferenceMapping.java",
    "status": "modified",
    "additions": 15,
    "deletions": 2,
    "changes": 17,
    "blob_url": "https://github.com/RallySoftware/eclipselink.runtime/blob/e04f931a6d3510da9680c45bec3db373b99ac4cc/foundation/org.eclipse.persistence.core/src/org/eclipse/persistence/mappings/ForeignReferenceMapping.java",
    "raw_url": "https://github.com/RallySoftware/eclipselink.runtime/raw/e04f931a6d3510da9680c45bec3db373b99ac4cc/foundation/org.eclipse.persistence.core/src/org/eclipse/persistence/mappings/ForeignReferenceMapping.java",
    "contents_url": "https://api.github.com/repos/RallySoftware/eclipselink.runtime/contents/foundation/org.eclipse.persistence.core/src/org/eclipse/persistence/mappings/ForeignReferenceMapping.java?ref=e04f931a6d3510da9680c45bec3db373b99ac4cc",
    "patch": "@@ -17,6 +17,8 @@\n  *       - 389090: JPA 2.1 DDL Generation Support (foreign key metadata support)\r\n  *     12/07/2012-2.5 Guy Pelletier \r\n  *       - 389090: JPA 2.1 DDL Generation Support (foreign key metadata support)\r\n+ *     04/19/2020-3.0 Alexandre Jacob\r\n+ *       - 544995: Fixed batch fetching when shared cache is activated (multithreading issue)\r\n  ******************************************************************************/  \r\n package org.eclipse.persistence.mappings;\r\n \r\n@@ -533,6 +535,9 @@ public Object extractResultFromBatchQuery(ReadQuery batchQuery, CacheKey parentC\n             // If the object is already in the cache, then just return it.\r\n             return cachedObject;\r\n         }\r\n+\r\n+        boolean shouldExecuteBatchQuery = true;\r\n+\r\n         // Ensure the query is only executed once.\r\n         synchronized (batchQuery) {\r\n             // Check if query was already executed.\r\n@@ -636,15 +641,23 @@ public Object extractResultFromBatchQuery(ReadQuery batchQuery, CacheKey parentC\n                     originalPolicy.setDataResults(this, remainingParentRows);\r\n                     translationRow = translationRow.clone();\r\n                     translationRow.put(QUERY_BATCH_PARAMETER, foreignKeyValues);\r\n+\r\n+                    if (foreignKeyValues.isEmpty()) {\r\n+                        shouldExecuteBatchQuery = false;\r\n+                    }\r\n+\r\n                     // Register each id as null, in case it has no relationship.\r\n                     for (Object foreignKey : foreignKeys) {\r\n                         batchedObjects.put(foreignKey, Helper.NULL_VALUE);\r\n                     }\r\n                 } else if (batchQuery.isReadAllQuery() && ((ReadAllQuery)batchQuery).getBatchFetchPolicy().isIN()) {\r\n                     throw QueryException.originalQueryMustUseBatchIN(this, originalQuery);\r\n                 }\r\n-                executeBatchQuery(batchQuery, parentCacheKey, batchedObjects, session, translationRow);\r\n-                batchQuery.setSession(null);\r\n+                // Bug 544995 : When the cache is populated by another thread we can end up having nothing to fetch\r\n+                if (shouldExecuteBatchQuery) {\r\n+                    executeBatchQuery(batchQuery, parentCacheKey, batchedObjects, session, translationRow);\r\n+                    batchQuery.setSession(null);\r\n+                }\r\n             }\r\n         }\r\n         result = batchedObjects.get(sourceKey);\r"
  }
]
