[
  {
    "sha": "a6d9dcb2cdd5643cf8542cad618ce0d3383ef79d",
    "filename": "runtime/src/main/java/org/corfudb/runtime/collections/ManagedTxnContext.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/CorfuDB/CorfuDB/blob/35a7a2247f07075fa3c0d6033dec4218938d42c1/runtime/src/main/java/org/corfudb/runtime/collections/ManagedTxnContext.java",
    "raw_url": "https://github.com/CorfuDB/CorfuDB/raw/35a7a2247f07075fa3c0d6033dec4218938d42c1/runtime/src/main/java/org/corfudb/runtime/collections/ManagedTxnContext.java",
    "contents_url": "https://api.github.com/repos/CorfuDB/CorfuDB/contents/runtime/src/main/java/org/corfudb/runtime/collections/ManagedTxnContext.java?ref=35a7a2247f07075fa3c0d6033dec4218938d42c1",
    "patch": "@@ -578,7 +578,7 @@ public String toString() {\n                             builder.setField(fieldDescriptor, 0L);\n                         } else {\n                             Long prevRevision = (Long) oldRecord.getMetadata().getField(fieldDescriptor);\n-                            Long givenRevision = (Long)deltaMetadata.getField(fieldDescriptor);\n+                            Long givenRevision = (Long) deltaMetadata.getField(fieldDescriptor);\n                             if (givenRevision == 0 || // Do not validate revision if field isn't set\n                                     (givenRevision > 0 && // Validate revision only if set\n                                             prevRevision.longValue() == givenRevision.longValue())) {"
  },
  {
    "sha": "d1ce74c40c9b09d670ee482ec5fb8fdbccae22f7",
    "filename": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/CorfuDB/CorfuDB/blob/35a7a2247f07075fa3c0d6033dec4218938d42c1/runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java",
    "raw_url": "https://github.com/CorfuDB/CorfuDB/raw/35a7a2247f07075fa3c0d6033dec4218938d42c1/runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java",
    "contents_url": "https://api.github.com/repos/CorfuDB/CorfuDB/contents/runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java?ref=35a7a2247f07075fa3c0d6033dec4218938d42c1",
    "patch": "@@ -10,7 +10,7 @@\n import org.corfudb.protocols.wireprotocol.ILogData;\n import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.CorfuStoreMetadata.Timestamp;\n-import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.exceptions.UnrecoverableStreamingException;\n import org.corfudb.runtime.view.Address;\n import org.corfudb.runtime.view.ObjectsView;\n import org.corfudb.runtime.view.StreamOptions;\n@@ -105,14 +105,14 @@ void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace\n             // If caller wants to allow 2 subscriptions on the same namespace+table,\n             // then hashcode and equals can just reflect the subscriber's name or other distinguishing fields.\n             // Basically we are saying, \"hey you decide if this is a re-subscription or a new subscription\"\n-            throw new StreamSubscriptionException(\n+            throw new UnrecoverableStreamingException(\n                     \"StreamManager:subscriber already registered \"\n                             + streamListener + \". Maybe call unregister first?\");\n         }\n         if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n             log.error(\"StreamManager::subscribe {} has too many {} subscribers\",\n                     streamListener, MAX_SUBSCRIBERS);\n-            throw new StreamSubscriptionException(\n+            throw new UnrecoverableStreamingException(\n                     \"StreamManager: too many (\" + MAX_SUBSCRIBERS + \") subscriptions\");\n         }\n         tablesOfInterest.forEach(t -> {"
  },
  {
    "sha": "5a83e9e014d1bafcc35b6588d45b47f372ce5429",
    "filename": "runtime/src/main/java/org/corfudb/runtime/collections/StreamNotificationTask.java",
    "status": "modified",
    "additions": 16,
    "deletions": 2,
    "changes": 18,
    "blob_url": "https://github.com/CorfuDB/CorfuDB/blob/35a7a2247f07075fa3c0d6033dec4218938d42c1/runtime/src/main/java/org/corfudb/runtime/collections/StreamNotificationTask.java",
    "raw_url": "https://github.com/CorfuDB/CorfuDB/raw/35a7a2247f07075fa3c0d6033dec4218938d42c1/runtime/src/main/java/org/corfudb/runtime/collections/StreamNotificationTask.java",
    "contents_url": "https://api.github.com/repos/CorfuDB/CorfuDB/contents/runtime/src/main/java/org/corfudb/runtime/collections/StreamNotificationTask.java?ref=35a7a2247f07075fa3c0d6033dec4218938d42c1",
    "patch": "@@ -1,6 +1,7 @@\n package org.corfudb.runtime.collections;\n \n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.exceptions.UnrecoverableStreamingException;\n \n import java.time.Duration;\n import java.util.concurrent.ExecutorService;\n@@ -35,6 +36,8 @@\n     // The Thread pool for executing client notification tasks.\n     private final ExecutorService notificationExecutor;\n \n+    private boolean isClientException = false;\n+\n     StreamNotificationTask(StreamingManager streamingManager,\n                            StreamSubscription subscription,\n                            ExecutorService notificationExecutor) {\n@@ -52,7 +55,12 @@ public void run() {\n             log.error(\"Encountered exception {} during client notification callback, \" +\n                     \"listener: {}, namespace: {}\", throwable, listener, subscription.getNamespace());\n             streamingManager.unsubscribe(listener, false);\n-            listener.onError(throwable);\n+            if (isClientException) {\n+                listener.onError(throwable);\n+            } else {\n+                // Corfu-specific exceptions are unrecoverable and client should perform a snapshot before re-attaching\n+                listener.onError(new UnrecoverableStreamingException(throwable));\n+            }\n         }\n     }\n \n@@ -84,7 +92,13 @@ private void sendNotifications() throws Exception {\n \n             // Send notification to client with the pre-registered callback.\n             startTime = endTime;\n-            subscription.getStreamingMetrics().recordDeliveryDuration(() -> listener.onNext(nextUpdate));\n+            try {\n+                subscription.getStreamingMetrics().recordDeliveryDuration(() -> listener.onNext(nextUpdate));\n+            } catch (Throwable t) {\n+                // Listener processing exception (these exceptions are not wrapped and consumer can decide to re-attach)\n+                isClientException = true;\n+                throw t;\n+            }\n             endTime = System.nanoTime();\n \n             Duration onNextElapse = Duration.ofNanos(endTime - startTime);"
  },
  {
    "sha": "241f851ccc43961c0a99172c5131cb69623cd78c",
    "filename": "runtime/src/main/java/org/corfudb/runtime/collections/StreamPollingTask.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/CorfuDB/CorfuDB/blob/35a7a2247f07075fa3c0d6033dec4218938d42c1/runtime/src/main/java/org/corfudb/runtime/collections/StreamPollingTask.java",
    "raw_url": "https://github.com/CorfuDB/CorfuDB/raw/35a7a2247f07075fa3c0d6033dec4218938d42c1/runtime/src/main/java/org/corfudb/runtime/collections/StreamPollingTask.java",
    "contents_url": "https://api.github.com/repos/CorfuDB/CorfuDB/contents/runtime/src/main/java/org/corfudb/runtime/collections/StreamPollingTask.java?ref=35a7a2247f07075fa3c0d6033dec4218938d42c1",
    "patch": "@@ -2,6 +2,7 @@\n \n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.exceptions.UnrecoverableStreamingException;\n import org.corfudb.runtime.view.stream.IStreamView;\n \n import java.time.Duration;\n@@ -59,7 +60,7 @@ public void run() {\n             log.error(\"Encountered exception {} during txn stream polling, listener: {}, \" +\n                     \"namespace: {}\", throwable, listener, subscription.getNamespace());\n             streamingManager.unsubscribe(listener, false);\n-            listener.onError(throwable);\n+            listener.onError(new UnrecoverableStreamingException(throwable));\n         }\n     }\n "
  },
  {
    "sha": "fe8d11a15f01e4d4eed23d0467b30afd13860226",
    "filename": "runtime/src/main/java/org/corfudb/runtime/collections/StreamingManager.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/CorfuDB/CorfuDB/blob/35a7a2247f07075fa3c0d6033dec4218938d42c1/runtime/src/main/java/org/corfudb/runtime/collections/StreamingManager.java",
    "raw_url": "https://github.com/CorfuDB/CorfuDB/raw/35a7a2247f07075fa3c0d6033dec4218938d42c1/runtime/src/main/java/org/corfudb/runtime/collections/StreamingManager.java",
    "contents_url": "https://api.github.com/repos/CorfuDB/CorfuDB/contents/runtime/src/main/java/org/corfudb/runtime/collections/StreamingManager.java?ref=35a7a2247f07075fa3c0d6033dec4218938d42c1",
    "patch": "@@ -4,7 +4,7 @@\n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.runtime.CorfuRuntime;\n-import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.exceptions.UnrecoverableStreamingException;\n \n import javax.annotation.Nonnull;\n import java.util.HashMap;\n@@ -93,7 +93,7 @@ synchronized void subscribe(@Nonnull StreamListener streamListener, @Nonnull Str\n         if (subscriptions.containsKey(streamListener)) {\n             // Multiple subscribers subscribing to same namespace and table is allowed\n             // as long as the hashcode() and equals() method of the listeners are different.\n-            throw new StreamSubscriptionException(\n+            throw new UnrecoverableStreamingException(\n                     \"StreamingManager::subscribe: listener already registered \" + streamListener);\n         }\n "
  },
  {
    "sha": "e3a1a22136eb7f786ee5dcfd41f03c678e356d44",
    "filename": "runtime/src/main/java/org/corfudb/runtime/exceptions/StreamSubscriptionException.java",
    "status": "removed",
    "additions": 0,
    "deletions": 12,
    "changes": 12,
    "blob_url": "https://github.com/CorfuDB/CorfuDB/blob/ed3f9f559524980abcfd95e4d9d48f2949ee11cf/runtime/src/main/java/org/corfudb/runtime/exceptions/StreamSubscriptionException.java",
    "raw_url": "https://github.com/CorfuDB/CorfuDB/raw/ed3f9f559524980abcfd95e4d9d48f2949ee11cf/runtime/src/main/java/org/corfudb/runtime/exceptions/StreamSubscriptionException.java",
    "contents_url": "https://api.github.com/repos/CorfuDB/CorfuDB/contents/runtime/src/main/java/org/corfudb/runtime/exceptions/StreamSubscriptionException.java?ref=ed3f9f559524980abcfd95e4d9d48f2949ee11cf",
    "patch": "@@ -1,12 +0,0 @@\n-package org.corfudb.runtime.exceptions;\n-\n-/**\n- * CorfuStore only allows one subscriber for a given namespace.\n- * If an attempt is made to register another subscriber without terminating or unsubscribing\n- * the existing subscriber on that namespace this exception will be thrown.\n- */\n-public class StreamSubscriptionException extends RuntimeException {\n-        public StreamSubscriptionException(String message) {\n-                super(message);\n-        }\n-}"
  },
  {
    "sha": "f19ca6fd8fbef4d5a180c6ca4b8bbd9d5a369d5f",
    "filename": "runtime/src/main/java/org/corfudb/runtime/exceptions/UnrecoverableStreamingException.java",
    "status": "added",
    "additions": 23,
    "deletions": 0,
    "changes": 23,
    "blob_url": "https://github.com/CorfuDB/CorfuDB/blob/35a7a2247f07075fa3c0d6033dec4218938d42c1/runtime/src/main/java/org/corfudb/runtime/exceptions/UnrecoverableStreamingException.java",
    "raw_url": "https://github.com/CorfuDB/CorfuDB/raw/35a7a2247f07075fa3c0d6033dec4218938d42c1/runtime/src/main/java/org/corfudb/runtime/exceptions/UnrecoverableStreamingException.java",
    "contents_url": "https://api.github.com/repos/CorfuDB/CorfuDB/contents/runtime/src/main/java/org/corfudb/runtime/exceptions/UnrecoverableStreamingException.java?ref=35a7a2247f07075fa3c0d6033dec4218938d42c1",
    "patch": "@@ -0,0 +1,23 @@\n+package org.corfudb.runtime.exceptions;\n+\n+/**\n+ * CorfuStore Streaming Exceptions are wrapped in this Exception type, so clients\n+ * can distinguish from streaming exceptions caused by their own processing logic\n+ * and those internal to Corfu, which will require a snapshot in order to recover.\n+ *\n+ * CorfuStore only allows one subscriber for a given namespace.\n+ * If an attempt is made to register another subscriber without terminating or unsubscribing\n+ * the existing subscriber on that namespace this exception will be thrown.\n+ *\n+ * @author annym\n+ */\n+public class UnrecoverableStreamingException extends RuntimeException {\n+\n+    public UnrecoverableStreamingException(Throwable throwable) {\n+        super(throwable);\n+    }\n+\n+    public UnrecoverableStreamingException(String message) {\n+        super(message);\n+    }\n+}"
  },
  {
    "sha": "169604e3de0a54b0265dec5f6758c2ec3915b713",
    "filename": "runtime/src/main/java/org/corfudb/runtime/view/stream/AddressMapStreamView.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/CorfuDB/CorfuDB/blob/35a7a2247f07075fa3c0d6033dec4218938d42c1/runtime/src/main/java/org/corfudb/runtime/view/stream/AddressMapStreamView.java",
    "raw_url": "https://github.com/CorfuDB/CorfuDB/raw/35a7a2247f07075fa3c0d6033dec4218938d42c1/runtime/src/main/java/org/corfudb/runtime/view/stream/AddressMapStreamView.java",
    "contents_url": "https://api.github.com/repos/CorfuDB/CorfuDB/contents/runtime/src/main/java/org/corfudb/runtime/view/stream/AddressMapStreamView.java?ref=35a7a2247f07075fa3c0d6033dec4218938d42c1",
    "patch": "@@ -396,7 +396,8 @@ protected long getMaxGlobalFromMaxEntries(int maxEntries) {\n \n         long size = streamAddressSpace.size();\n         if (size == 0L) {\n-            return Address.NON_ADDRESS;\n+            // The trim mark will allow to detect trimmed exceptions if the seeked address falls behind it\n+            return streamAddressSpace.getTrimMark();\n         }\n \n         if (size <= maxEntries) {"
  },
  {
    "sha": "e876998c4e73197a780202781de594d7471b24ec",
    "filename": "test/src/test/java/org/corfudb/integration/StreamingIT.java",
    "status": "modified",
    "additions": 240,
    "deletions": 7,
    "changes": 247,
    "blob_url": "https://github.com/CorfuDB/CorfuDB/blob/35a7a2247f07075fa3c0d6033dec4218938d42c1/test/src/test/java/org/corfudb/integration/StreamingIT.java",
    "raw_url": "https://github.com/CorfuDB/CorfuDB/raw/35a7a2247f07075fa3c0d6033dec4218938d42c1/test/src/test/java/org/corfudb/integration/StreamingIT.java",
    "contents_url": "https://api.github.com/repos/CorfuDB/CorfuDB/contents/test/src/test/java/org/corfudb/integration/StreamingIT.java?ref=35a7a2247f07075fa3c0d6033dec4218938d42c1",
    "patch": "@@ -1,18 +1,28 @@\n package org.corfudb.integration;\n \n \n+import com.google.common.reflect.TypeToken;\n import lombok.Getter;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.CorfuStoreMetadata.Timestamp;\n+import org.corfudb.runtime.MultiCheckpointWriter;\n+import org.corfudb.runtime.collections.CorfuRecord;\n import org.corfudb.runtime.collections.CorfuStore;\n import org.corfudb.runtime.collections.CorfuStreamEntries;\n import org.corfudb.runtime.collections.CorfuStreamEntry;\n+import org.corfudb.runtime.collections.CorfuTable;\n+import org.corfudb.runtime.collections.IsolationLevel;\n import org.corfudb.runtime.collections.StreamListener;\n import org.corfudb.runtime.collections.StreamingManager;\n import org.corfudb.runtime.collections.Table;\n import org.corfudb.runtime.collections.TableOptions;\n import org.corfudb.runtime.collections.TableSchema;\n import org.corfudb.runtime.collections.TxnContext;\n-import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.exceptions.TrimmedException;\n+import org.corfudb.runtime.exceptions.UnrecoverableStreamingException;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.test.SampleSchema;\n import org.corfudb.test.SampleSchema.SampleTableAMsg;\n import org.corfudb.test.SampleSchema.SampleTableBMsg;\n import org.corfudb.test.SampleSchema.SampleTableCMsg;\n@@ -43,6 +53,12 @@\n     private static String corfuSingleNodeHost;\n     private static int corfuStringNodePort;\n     private static String singleNodeEndpoint;\n+    private Process corfuServer;\n+    private CorfuStore store;\n+\n+    private final String namespace = \"test_namespace\";\n+    private final String defaultTableName = \"table_testA\";\n+    private final String defaultTag = \"sample_streamer_1\";\n \n     /**\n      * A helper method that takes host and port specification, start a single server and\n@@ -106,13 +122,15 @@ public void onNext(CorfuStreamEntries results) {\n             updates.add(results);\n             timestamp = results.getTimestamp();\n             if (updates.size() == updatesToError) {\n-                throw new StreamSubscriptionException(\"Artificial exception to trigger onError\");\n+                throw new IndexOutOfBoundsException(\"Artificial exception to trigger onError\");\n             }\n         }\n \n         @Override\n         public void onError(Throwable throwable) {\n-            latch.countDown();\n+            if (throwable instanceof IndexOutOfBoundsException) {\n+                latch.countDown();\n+            }\n         }\n \n         @Override\n@@ -133,7 +151,7 @@ public String toString() {\n \n     /**\n      * A StreamListener implementation to be used in the tests.\n-     * This listener blocks on a latch when executing onNext()/\n+     * This listener blocks on a latch when executing onNext()\n      */\n     private class BlockingStreamListener extends StreamListenerImpl {\n \n@@ -155,6 +173,29 @@ public void onNext(CorfuStreamEntries results) {\n         }\n     }\n \n+    /**\n+     * A StreamListener implementation to be used in the tests.\n+     *\n+     * This listener notifies on TrimmedException's, unblocking the client.\n+     *\n+     */\n+    private class TrimExceptionListener extends StreamListenerImpl {\n+\n+        private final CountDownLatch errorNotifierLatch;\n+\n+        TrimExceptionListener(String name, CountDownLatch errorNotifierLatch) {\n+            super(name);\n+            this.errorNotifierLatch = errorNotifierLatch;\n+        }\n+\n+        @Override\n+        public void onError(Throwable throwable) {\n+            if (throwable instanceof UnrecoverableStreamingException && throwable.getCause() instanceof TrimmedException) {\n+                errorNotifierLatch.countDown();\n+            }\n+        }\n+    }\n+\n     /**\n      * Basic Streaming Test with a single table.\n      * <p>\n@@ -358,7 +399,7 @@ public void testStreamingMultiTableSameListener() throws Exception {\n                 Collections.singletonList(\"tableA\"), ts1);\n \n         // Attempt to subscribe to streaming updates from tableB using same listener\n-        assertThrows(StreamSubscriptionException.class, () -> store.subscribeListener(listenerCommon, \"test_namespace\", \"sample_streamer_4\",\n+        assertThrows(UnrecoverableStreamingException.class, () -> store.subscribeListener(listenerCommon, \"test_namespace\", \"sample_streamer_4\",\n                 Collections.singletonList(\"tableB\"), ts1));\n \n         assertThat(shutdownCorfuServer(corfuServer)).isTrue();\n@@ -597,7 +638,7 @@ public void testSubscriberOnEmptyTables() throws Exception {\n         TimeUnit.SECONDS.sleep(2);\n \n         assertThatThrownBy(() -> store.subscribeListener(listener1, namespace, \"sample_streamer_1\",\n-                Collections.singletonList(tableName), ts1)).isExactlyInstanceOf(StreamSubscriptionException.class);\n+                Collections.singletonList(tableName), ts1)).isExactlyInstanceOf(UnrecoverableStreamingException.class);\n \n         // Make some updates to the table\n         final int numUpdates = 5;\n@@ -678,7 +719,7 @@ public void testSubscriberTimestamp() throws Exception {\n \n         // Confirm subscribe was successful\n         assertThatThrownBy(() -> store.subscribeListener(listener1, namespace, \"sample_streamer_1\",\n-                Collections.singletonList(tableNameA), ts1)).isExactlyInstanceOf(StreamSubscriptionException.class);\n+                Collections.singletonList(tableNameA), ts1)).isExactlyInstanceOf(UnrecoverableStreamingException.class);\n \n         // Make some updates to both tables\n         for (int index = 0; index < numUpdates; index++) {\n@@ -812,4 +853,196 @@ public void testStreamingMultiTableSingleListener() throws Exception {\n \n         assertThat(shutdownCorfuServer(corfuServer)).isTrue();\n     }\n+\n+    /**\n+     * Test the case where streaming is interrupted due to an unrecoverable TrimmedException.\n+     *\n+     * In this case we do a full log trim, such that the address space of the stream of interest is empty (0 addresses),\n+     * i.e., all updates to the stream have been trimmed and are subsumed by the checkpoint.\n+     *\n+     */\n+    @Test\n+    public void testTrimmedExceptionCompleteLogTrim() {\n+        assertThat(testStreamingTrimmedException(false)).isTrue();\n+    }\n+\n+    /**\n+     * Test the case where streaming is interrupted due to an unrecoverable TrimmedException.\n+     *\n+     * In this case we do a partial trim, such that the address space of the stream of interest reflects remaining addresses\n+     * (i.e., not all updates have been trimmed, though subsumed by a checkpoint)\n+     *\n+     */\n+    @Test\n+    public void testTrimmedExceptionPartialLogTrim() {\n+        assertThat(testStreamingTrimmedException(true)).isTrue();\n+    }\n+\n+    private boolean testStreamingTrimmedException(boolean partialTrim) {\n+        try {\n+            // Run a corfu server & initialize CorfuStore\n+            initializeCorfu();\n+\n+            // Record the initial timestamp.\n+            Timestamp ts1 = store.getTimestamp();\n+\n+            final int totalUpdates = 100;\n+\n+            writeUpdatesToDefaultTable(totalUpdates);\n+\n+            // Checkpoint and Trim\n+            Token trimPoint = checkpointAndTrim(namespace, Arrays.asList(defaultTableName), partialTrim);\n+\n+            // Subscribe listener to stream tag 'sample_streamer_1'\n+            final CountDownLatch errorListener = new CountDownLatch(1);\n+\n+            // Start Listener on Trimmed Space\n+            TrimExceptionListener listener = new TrimExceptionListener(\"stream_listener\", errorListener);\n+            store.subscribeListener(listener, namespace, defaultTag,\n+                    Collections.singletonList(defaultTableName), ts1);\n+\n+            // Wait until TrimmedException is received by listener\n+            errorListener.await();\n+\n+            // Confirm we are unsubscribed (subscribing again does not throw an error) -> subscribing beyond trim point\n+            Timestamp trimTimestamp = Timestamp.newBuilder()\n+                    .setEpoch(trimPoint.getEpoch())\n+                    .setSequence(trimPoint.getSequence())\n+                    .build();\n+            store.subscribeListener(listener, namespace, \"sample_streamer_1\",\n+                    Collections.singletonList(defaultTableName), trimTimestamp);\n+\n+            // Verify number of updates received by listener is zero (empty) as the space was trimmed.\n+            assertThat(listener.getUpdates()).isEmpty();\n+\n+            // Re-Sync the table from Snapshot and confirm all entries are present, from a different runtime\n+            readDefaultTableSnapshot(trimTimestamp, totalUpdates);\n+\n+            runtime.shutdown();\n+            assertThat(shutdownCorfuServer(corfuServer)).isTrue();\n+\n+            return true;\n+        } catch (Exception e) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Confirm client exceptions (during onNext processing) are not wrapped as corfu unrecoverable streaming exceptions.\n+     */\n+    @Test\n+    public void testClientExceptions() throws Exception {\n+        // Run a corfu server & initialize Corfu Store\n+        initializeCorfu();\n+\n+        // Write a number of updates to a certain table\n+        final int numUpdates = 20;\n+        writeUpdatesToDefaultTable(numUpdates);\n+\n+        // Subscribe to defaultTag from start of Log\n+        Timestamp startTimestamp = Timestamp.newBuilder()\n+                .setEpoch(0L)\n+                .setSequence(-1L)\n+                .build();\n+        CountDownLatch onErrorLatch = new CountDownLatch(1);\n+        StreamListenerImpl listener = new StreamListenerImpl(\"listener_client_failure\", numUpdates/2, onErrorLatch);\n+        store.subscribeListener(listener, namespace, defaultTag, Arrays.asList(defaultTableName), startTimestamp);\n+\n+        // Block until Client Exception has been received and onError has been triggered.\n+        onErrorLatch.await();\n+\n+        // Verify the expected received deltas (before trigger of exception was received)\n+        LinkedList<CorfuStreamEntries> updates1 = listener.getUpdates();\n+        assertThat(updates1).hasSize(numUpdates/2);\n+\n+        for (int index = 0; index < numUpdates/2; index++) {\n+            assertThat(updates1.get(index).getEntries()).hasSize(1);\n+            List<CorfuStreamEntry> entries = updates1.get(index).getEntries().values().stream().findFirst().get();\n+            assertThat(entries).hasSize(1);\n+            assertThat(((Uuid)entries.get(0).getKey()).getMsb()).isEqualTo(index);\n+            assertThat(((SampleTableAMsg)entries.get(0).getPayload()).getPayload()).isEqualTo(String.valueOf(index));\n+            assertThat(((Uuid)entries.get(0).getMetadata()).getMsb()).isEqualTo(index);\n+        }\n+\n+        runtime.shutdown();\n+        assertThat(shutdownCorfuServer(corfuServer)).isTrue();\n+    }\n+\n+    private void writeUpdatesToDefaultTable(int numUpdates) throws Exception {\n+        Table<Uuid, SampleTableAMsg, Uuid> tableA = store.openTable(\n+                namespace, defaultTableName,\n+                Uuid.class, SampleTableAMsg.class, Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+\n+        // Make some updates to tableA\n+        for (int index = 0; index < numUpdates; index++) {\n+            // Update TableA\n+            try (TxnContext tx = store.txn(namespace)) {\n+                Uuid uuid = Uuid.newBuilder().setMsb(index).setLsb(index).build();\n+                SampleTableAMsg msgA = SampleTableAMsg.newBuilder().setPayload(String.valueOf(index)).build();\n+                tx.putRecord(tableA, uuid, msgA, uuid);\n+                tx.commit();\n+            }\n+        }\n+    }\n+\n+    private void initializeCorfu() throws Exception {\n+        corfuServer = runSinglePersistentServer(corfuSingleNodeHost, corfuStringNodePort);\n+        runtime = createRuntime(singleNodeEndpoint);\n+        store = new CorfuStore(runtime);\n+    }\n+\n+    private void readDefaultTableSnapshot(Timestamp snapshotTimestamp, int numUpdates) throws Exception {\n+        CorfuRuntime readRuntime = createRuntime(singleNodeEndpoint);\n+        CorfuStore readStore = new CorfuStore(readRuntime);\n+\n+        readStore.openTable(namespace, defaultTableName,\n+                Uuid.class, SampleTableAMsg.class, Uuid.class,\n+                TableOptions.builder().build()\n+        );\n+\n+        try (TxnContext txn = readStore.txn(namespace, IsolationLevel.snapshot(snapshotTimestamp))) {\n+            Table<Uuid, SampleTableAMsg, Uuid> readTable = txn.getTable(defaultTableName);\n+            assertThat(readTable.count()).isEqualTo(numUpdates);\n+\n+            readTable.entryStream().forEach(entry -> entry.getKey().getMsb());\n+\n+            for (int index = 0; index < numUpdates; index++) {\n+                CorfuRecord<SampleTableAMsg, Uuid> record = readTable.get(Uuid.newBuilder().setLsb(index).setMsb(index).build());\n+                assertThat(record).isNotNull();\n+                assertThat(record.getPayload().getPayload()).isEqualTo(String.valueOf(index));\n+            }\n+        }\n+\n+        readRuntime.shutdown();\n+    }\n+\n+    private Token checkpointAndTrim(String namespace, List<String> tablesToCheckpoint, boolean partialTrim) {\n+        MultiCheckpointWriter<CorfuTable> mcw = new MultiCheckpointWriter<>();\n+        tablesToCheckpoint.forEach(tableName -> {\n+            CorfuTable<Uuid, CorfuRecord<SampleSchema.EventInfo, SampleSchema.ManagedResources>> corfuTable = runtime.getObjectsView().build()\n+                    .setTypeToken(new TypeToken<CorfuTable<Uuid, CorfuRecord<SampleSchema.EventInfo, SampleSchema.ManagedResources>>>() {\n+                    })\n+                    .setStreamName(TableRegistry.getFullyQualifiedTableName(namespace, tableName))\n+                    .open();\n+            mcw.addMap(corfuTable);\n+        });\n+\n+        // Add Registry Table\n+        mcw.addMap(runtime.getTableRegistry().getRegistryTable());\n+        // Checkpoint & Trim\n+        Token trimPoint = mcw.appendCheckpoints(runtime, \"StreamingIT\");\n+        if (partialTrim) {\n+            final int trimOffset = 5;\n+            Long sequenceModified = trimPoint.getSequence() - trimOffset;\n+            Token partialTrimMark = Token.of(trimPoint.getEpoch(), sequenceModified);\n+            runtime.getAddressSpaceView().prefixTrim(partialTrimMark);\n+        } else {\n+            runtime.getAddressSpaceView().prefixTrim(trimPoint);\n+        }\n+        runtime.getAddressSpaceView().gc();\n+        runtime.getObjectsView().getObjectCache().clear();\n+        return trimPoint;\n+    }\n }"
  }
]
