[
  {
    "sha": "f913219a1c9ab6cb94bfb5ce85e75d87b4855de8",
    "filename": "README.md",
    "status": "modified",
    "additions": 4,
    "deletions": 1,
    "changes": 5,
    "blob_url": "https://github.com/JakeWharton/dagger-reflect/blob/2f99a89ce59040a2e027655e528a017d14a75f68/README.md",
    "raw_url": "https://github.com/JakeWharton/dagger-reflect/raw/2f99a89ce59040a2e027655e528a017d14a75f68/README.md",
    "contents_url": "https://api.github.com/repos/JakeWharton/dagger-reflect/contents/README.md?ref=2f99a89ce59040a2e027655e528a017d14a75f68",
    "patch": "@@ -129,13 +129,16 @@ Unsupported Features and Limitations\n ### Abstract Classes\n \n Because Dagger Reflect is implemented using a [`Proxy`][proxy], only interface components,\n-factories, and builders are supported.\n+factories, assisted factories and builders are supported.\n \n ### Component Visibility\n \n In order for a factory or builder which is backed by a `Proxy` to create an instance of the\n enclosing component which is also backed by a `Proxy`, the component has to be public.\n \n+### AssistedInject\n+[Provision of assisted dependencies](https://github.com/google/dagger/issues/2370) is not implemented.\n+\n ### Producers\n \n Pretty sure no one but Google uses this. PRs welcome."
  },
  {
    "sha": "3fc085fc0b7bd7e88bc1885d4c403d30ca8b59df",
    "filename": "build.gradle",
    "status": "modified",
    "additions": 5,
    "deletions": 1,
    "changes": 6,
    "blob_url": "https://github.com/JakeWharton/dagger-reflect/blob/2f99a89ce59040a2e027655e528a017d14a75f68/build.gradle",
    "raw_url": "https://github.com/JakeWharton/dagger-reflect/raw/2f99a89ce59040a2e027655e528a017d14a75f68/build.gradle",
    "contents_url": "https://api.github.com/repos/JakeWharton/dagger-reflect/contents/build.gradle?ref=2f99a89ce59040a2e027655e528a017d14a75f68",
    "patch": "@@ -2,7 +2,8 @@ import net.ltgt.gradle.errorprone.CheckSeverity\n \n buildscript {\n   ext.versions = [\n-      'dagger': '2.29.1',\n+      'dagger': '2.33',\n+      'kotlin': '1.4.20',\n       'incap': '0.2',\n       'androidTools': '26.4.1',\n   ]\n@@ -15,6 +16,9 @@ buildscript {\n           'androidRuntimeJar': \"com.google.dagger:dagger-android-jarimpl:${versions.dagger}\",\n           'androidCompiler': \"com.google.dagger:dagger-android-processor:${versions.dagger}\",\n       ],\n+      'kotlin': [\n+          'gradle': \"org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin}\"\n+      ],\n       'junit': 'junit:junit:4.13',\n       'truth': 'com.google.truth.extensions:truth-java8-extension:1.0',\n       'compileTesting': 'com.google.testing.compile:compile-testing:0.18',"
  },
  {
    "sha": "6e1e19458c599aac098adb9c46993cb996991b36",
    "filename": "integration-tests/upstream/build.gradle",
    "status": "modified",
    "additions": 33,
    "deletions": 13,
    "changes": 46,
    "blob_url": "https://github.com/JakeWharton/dagger-reflect/blob/2f99a89ce59040a2e027655e528a017d14a75f68/integration-tests/upstream/build.gradle",
    "raw_url": "https://github.com/JakeWharton/dagger-reflect/raw/2f99a89ce59040a2e027655e528a017d14a75f68/integration-tests/upstream/build.gradle",
    "contents_url": "https://api.github.com/repos/JakeWharton/dagger-reflect/contents/integration-tests/upstream/build.gradle?ref=2f99a89ce59040a2e027655e528a017d14a75f68",
    "patch": "@@ -1,3 +1,14 @@\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    classpath deps.kotlin.gradle\n+  }\n+}\n+\n+apply plugin: 'kotlin'\n apply plugin: 'java-library'\n \n sourceSets.test.java {\n@@ -31,23 +42,24 @@ test.filter {\n   // dagger-reflect does not produce the exact same behavior as dagger-compiler for @Reusable.\n   excludeTest 'dagger.functional.ReusableTest', null\n \n-  // Uses nested component interfaces which are not public and thus cannot be proxied.\n-  excludeTest 'dagger.functional.ComponentDependenciesTest', 'testPolymorphicOverridesStillCompiles'\n-  excludeTest 'dagger.functional.ComponentDependenciesTest', 'testSameMethodTwice'\n-\n   // TODO reflect bug! Need something like ByteBuddy for proxying classes at runtime.\n   excludeTest 'dagger.functional.aot.PrunedFrameworkInstanceWithModuleInstanceTest', 'prunedBindingWithModuleInstance_doesntThrowDuringInitialization'\n-  excludeTest 'dagger.functional.builder.BuilderBindsInstanceParameterTest', null\n-  excludeTest 'dagger.functional.builderbinds.BuilderBindsTest', null\n-  excludeTest 'dagger.functional.factory.FactoryBindsInstanceTest', null\n-  excludeTest 'dagger.functional.factory.FactoryDependenciesTest', null\n-  excludeTest 'dagger.functional.factory.FactoryImplicitModulesTest', null\n-  excludeTest 'dagger.functional.factory.FactoryMixedParametersTest', null\n-  excludeTest 'dagger.functional.factory.FactoryRequiredModulesTest', null\n-  excludeTest 'dagger.functional.factory.SubcomponentFactoryTest', null\n+  excludeTest 'dagger.functional.BasicTest', null\n+\n+  // TODO reflect bug! Builder @Binds method inheritance\n+  excludeTest 'dagger.functional.builderbinds.BuilderBindsTest', 'builderBinds'\n+  excludeTest 'dagger.functional.builderbinds.BuilderBindsTest', 'builderBindsNullableNotSet'\n+  excludeTest 'dagger.functional.builderbinds.BuilderBindsTest', 'builderBindsNullableWithNull'\n+  // TODO nullability checks\n+  excludeTest 'dagger.functional.builderbinds.BuilderBindsTest', 'builderBindsNonNullableWithNull'\n+\n+  // TODO nullability checks\n+  excludeTest 'dagger.functional.factory.FactoryBindsInstanceTest', 'nonNullableBindsInstance_failsOnNull'\n+\n+  // TODO reflect bug! Generics don't work well.\n   excludeTest 'dagger.functional.subcomponent.SubcomponentTest', null\n+  // TODO reflect bug! something with repeated modules\n   excludeTest 'dagger.functional.subcomponent.repeat.RepeatedModuleTest', null\n-  excludeTest 'dagger.functional.BasicTest', null\n \n   // TODO reflect bug! Generics don't work well.\n   excludeTest 'dagger.functional.GenericTest', 'complexGenerics'\n@@ -75,8 +87,16 @@ test.filter {\n \n   // TODO reflect bug! Subcomponent multibindings propagation does not work.\n   excludeTest 'dagger.functional.subcomponent.SubcomponentMultibindingsTest', null\n+\n+  // TODO reflect bug! Generics...\n+  excludeTest 'dagger.functional.assisted.AssistedFactoryParameterizedTest', null\n+\n+  // a) Provision of Assisted types not implemented in dagger-reflect\n+  excludeTest 'dagger.functional.assisted.AssistedFactoryAsQualifiedBindingTest', null\n }\n \n+apply from: \"test-source-fixed.gradle\"\n+\n dependencies {\n   testImplementation project(':reflect')\n   testImplementation deps.junit"
  },
  {
    "sha": "ae991fdd84ce92e93f0481508e2392409125d266",
    "filename": "integration-tests/upstream/dagger",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": null,
    "raw_url": null,
    "contents_url": "https://api.github.com/repos/JakeWharton/dagger-reflect/contents/integration-tests/upstream/dagger?ref=2f99a89ce59040a2e027655e528a017d14a75f68",
    "patch": "@@ -1 +1 @@\n-Subproject commit f3be0a9fdbc6a31eeffd3d196c9a831ecc2c0eb7\n+Subproject commit ae991fdd84ce92e93f0481508e2392409125d266"
  },
  {
    "sha": "e3bcd3d422b6b4d2e0ef3180854c34b5f1d5dba4",
    "filename": "integration-tests/upstream/test-source-fixed.gradle",
    "status": "added",
    "additions": 123,
    "deletions": 0,
    "changes": 123,
    "blob_url": "https://github.com/JakeWharton/dagger-reflect/blob/2f99a89ce59040a2e027655e528a017d14a75f68/integration-tests/upstream/test-source-fixed.gradle",
    "raw_url": "https://github.com/JakeWharton/dagger-reflect/raw/2f99a89ce59040a2e027655e528a017d14a75f68/integration-tests/upstream/test-source-fixed.gradle",
    "contents_url": "https://api.github.com/repos/JakeWharton/dagger-reflect/contents/integration-tests/upstream/test-source-fixed.gradle?ref=2f99a89ce59040a2e027655e528a017d14a75f68",
    "patch": "@@ -0,0 +1,123 @@\n+//Tasks for \"fixing\" small things in upstream test sources and running them\n+\n+def output = file(\"$buildDir/test-source-fixed\")\n+\n+sourceSets.test.java {\n+  srcDir(output)\n+}\n+\n+def fix = { String testClassName,\n+            Class<TestSourceFix> taskClass ->\n+\n+  // We change the directory but keep the package name so we're able to replace the file\n+  // while retaining package visibility between original and replaced sources.\n+  // The downside is that ide will show package errors, but build works\n+  def fixedTestClassName = \"fixed/$testClassName\"\n+\n+  def testClassSimpleName = testClassName.substring(\n+    testClassName.lastIndexOf('/') + 1,\n+    testClassName.lastIndexOf('.')\n+  )\n+\n+  sourceSets.test.java {\n+    exclude testClassName\n+    include fixedTestClassName\n+  }\n+\n+  def testSource = file(\"dagger/javatests/$testClassName\")\n+  def fixedSource = file(\"$output/$fixedTestClassName\")\n+\n+  def task = tasks.register(testClassSimpleName, taskClass) { TestSourceFix task ->\n+    task.group = 'test-source-fixed'\n+\n+    task.testSource.set(testSource)\n+    task.fixedSource.set(fixedSource)\n+  }\n+\n+  tasks.named(\"compileTestJava\") {\n+    dependsOn(task)\n+  }\n+\n+  return task\n+}\n+\n+def replace = { String testClassName,\n+                Map<String, String> replacements ->\n+  def fixTask = fix(testClassName, TestSourceFixReplace)\n+\n+  fixTask.configure { task ->\n+    task.replacements.set(replacements)\n+  }\n+}\n+\n+abstract class TestSourceFix extends DefaultTask {\n+  @InputFile  RegularFileProperty testSource  = project.objects.fileProperty();\n+  @OutputFile RegularFileProperty fixedSource = project.objects.fileProperty();\n+\n+  @TaskAction\n+  void execute() {\n+    def from = testSource.get().asFile\n+    def to = fixedSource.get().asFile\n+\n+    def fixedSource = fixSource(from.text)\n+\n+    to.delete()\n+    to.parentFile.mkdirs()\n+\n+    to.newWriter().withCloseable { writer ->\n+      writer.write(fixedSource)\n+    }\n+  }\n+\n+  abstract String fixSource(String source)\n+}\n+\n+abstract class TestSourceFixReplace extends TestSourceFix {\n+\n+  @Input MapProperty<String, String> replacements = project.objects.mapProperty(String, String)\n+\n+  @Override\n+  String fixSource(String source) {\n+    return replacements.get().inject(source) { acc, replace, replacement ->\n+      acc.replace(replace, replacement)\n+    }\n+  }\n+}\n+\n+def publicNestedClasses = [\"static class\": \"public static class\"]\n+def intefaces = [\n+  \"interface\": \"public interface\",\n+  //fixes\n+  \"public public\": \"public\",\n+  \"@public interface\": \"@interface\",\n+]\n+\n+replace('dagger/functional/ComponentDependenciesTest.java',                               intefaces)\n+replace('dagger/functional/builder/BuilderBindsInstanceParameterTest.java',               intefaces)\n+replace('dagger/functional/builderbinds/BuilderBindsTest.java',                           intefaces)\n+replace('dagger/functional/builderbinds/TestComponent.java',                              intefaces)\n+replace('dagger/functional/factory/FactoryBindsInstanceTest.java',                        intefaces)\n+replace('dagger/functional/factory/FactoryDependenciesTest.java',                         intefaces)\n+replace('dagger/functional/factory/FactoryImplicitModulesTest.java',                      intefaces)\n+replace('dagger/functional/factory/FactoryMixedParametersTest.java',                      intefaces)\n+replace('dagger/functional/factory/FactoryRequiredModulesTest.java',                      intefaces)\n+replace('dagger/functional/factory/SubcomponentFactoryTest.java',                         intefaces + publicNestedClasses)\n+/* TODO reflect bug! Generics\n+replace('dagger/functional/subcomponent/ChildAbstractClassComponent.java',  [\n+  \"abstract class ChildAbstractClassComponent implements\": \"interface ChildAbstractClassComponent extends\"\n+])\n+replace('dagger/functional/subcomponent/SubcomponentTest.java',                           intefaces)\n+*/\n+/* TODO reflect bug! something with repeated modules\n+replace('dagger/functional/subcomponent/repeat/RepeatedModuleTest.java',                  intefaces)\n+replace('dagger/functional/subcomponent/repeat/ParentComponent.java',                     intefaces)\n+replace('dagger/functional/subcomponent/repeat/SubcomponentWithRepeatedModule.java',      intefaces)\n+replace('dagger/functional/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java',   intefaces)\n+replace('dagger/functional/subcomponent/repeat/OtherSubcomponentWithRepeatedModule.java', intefaces)\n+*/\n+\n+replace('dagger/functional/assisted/AssistedFactoryTest.java', [\n+  \"abstract static class AbstractFooFactory\": \"interface AbstractFooFactory\",\n+  \"void concreteMethod\"                     : \"default void concreteMethod\",\n+  \"Foo concreteFooMethod\"                   : \"default Foo concreteFooMethod\",\n+])\n\\ No newline at end of file"
  },
  {
    "sha": "d0d64bebde70308ceb7d3fcdba03c4c23494e90c",
    "filename": "reflect/src/main/java/dagger/reflect/ComponentScopeBuilder.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/JakeWharton/dagger-reflect/blob/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/ComponentScopeBuilder.java",
    "raw_url": "https://github.com/JakeWharton/dagger-reflect/raw/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/ComponentScopeBuilder.java",
    "contents_url": "https://api.github.com/repos/JakeWharton/dagger-reflect/contents/reflect/src/main/java/dagger/reflect/ComponentScopeBuilder.java?ref=2f99a89ce59040a2e027655e528a017d14a75f68",
    "patch": "@@ -115,6 +115,7 @@ void setDependency(Class<?> dependencyClass, Object instance) {\n     Scope.Builder scopeBuilder =\n         new Scope.Builder(parent, scopeAnnotations)\n             .addJustInTimeLookupFactory(new ReflectiveJustInTimeLookupFactory())\n+            .addJustInTimeLookupFactory(new ReflectiveAssistedFactoryLookupFactory())\n             .addJustInTimeLookupFactory(new MembersInjectorJustInTimeFactory());\n \n     for (Map.Entry<Key, Object> entry : boundInstances.entrySet()) {"
  },
  {
    "sha": "6f9bff3038d0996f532e37b77d434293334bf0f5",
    "filename": "reflect/src/main/java/dagger/reflect/LinkedJustInTimeAssistedFactoryBinding.java",
    "status": "added",
    "additions": 69,
    "deletions": 0,
    "changes": 69,
    "blob_url": "https://github.com/JakeWharton/dagger-reflect/blob/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/LinkedJustInTimeAssistedFactoryBinding.java",
    "raw_url": "https://github.com/JakeWharton/dagger-reflect/raw/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/LinkedJustInTimeAssistedFactoryBinding.java",
    "contents_url": "https://api.github.com/repos/JakeWharton/dagger-reflect/contents/reflect/src/main/java/dagger/reflect/LinkedJustInTimeAssistedFactoryBinding.java?ref=2f99a89ce59040a2e027655e528a017d14a75f68",
    "patch": "@@ -0,0 +1,69 @@\n+package dagger.reflect;\n+\n+import static dagger.reflect.Reflection.tryInstantiate;\n+\n+import dagger.MembersInjector;\n+import dagger.reflect.Binding.LinkedBinding;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+\n+public final class LinkedJustInTimeAssistedFactoryBinding<T> extends LinkedBinding<T>\n+    implements InvocationHandler {\n+  private final Class<T> factory;\n+  private final Constructor<?> constructor;\n+  private final MembersInjector<?> membersInjector;\n+\n+  /** Non-Assisted parameters are filled with null */\n+  private final Integer[] parameterToAssistedArgumentIndexes;\n+\n+  /** Assisted parameters are filled with null */\n+  private final LinkedBinding<?>[] dependencies;\n+\n+  LinkedJustInTimeAssistedFactoryBinding(\n+      Class<T> factory,\n+      Constructor<?> constructor,\n+      MembersInjector<?> membersInjector,\n+      LinkedBinding<?>[] dependencies,\n+      Integer[] parameterToAssistedArgumentIndexes) {\n+    this.factory = factory;\n+    this.constructor = constructor;\n+    this.membersInjector = membersInjector;\n+    this.dependencies = dependencies;\n+    this.parameterToAssistedArgumentIndexes = parameterToAssistedArgumentIndexes;\n+  }\n+\n+  @Override\n+  public T get() {\n+    return Reflection.newProxy(factory, this);\n+  }\n+\n+  @Override\n+  public Object invoke(Object proxy, Method method, Object[] args) {\n+    Object[] arguments = new Object[dependencies.length];\n+\n+    for (int i = 0; i < dependencies.length; i++) {\n+      // Either of those should not be null\n+      Integer assistedArgumentIndex = parameterToAssistedArgumentIndexes[i];\n+      LinkedBinding<?> nonAssistedArgumentBinding = dependencies[i];\n+\n+      if (assistedArgumentIndex != null) {\n+        arguments[i] = args[assistedArgumentIndex];\n+      } else {\n+        arguments[i] = nonAssistedArgumentBinding.get();\n+      }\n+    }\n+\n+    Object instance = tryInstantiate(constructor, arguments);\n+\n+    //noinspection unchecked\n+    ((MembersInjector<Object>) membersInjector).injectMembers(instance);\n+\n+    return instance;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"@AssistedInject[\" + constructor.getDeclaringClass().getName() + \".<init>(…)]\";\n+  }\n+}"
  },
  {
    "sha": "61aabbac446e7cc8cd802b9c5bb6c29f562e610e",
    "filename": "reflect/src/main/java/dagger/reflect/ParameterTypesResolver.java",
    "status": "added",
    "additions": 148,
    "deletions": 0,
    "changes": 148,
    "blob_url": "https://github.com/JakeWharton/dagger-reflect/blob/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/ParameterTypesResolver.java",
    "raw_url": "https://github.com/JakeWharton/dagger-reflect/raw/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/ParameterTypesResolver.java",
    "contents_url": "https://api.github.com/repos/JakeWharton/dagger-reflect/contents/reflect/src/main/java/dagger/reflect/ParameterTypesResolver.java?ref=2f99a89ce59040a2e027655e528a017d14a75f68",
    "patch": "@@ -0,0 +1,148 @@\n+package dagger.reflect;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.Arrays;\n+import org.jetbrains.annotations.Nullable;\n+\n+/** Resolves actual types of generic parameters of method/constructor */\n+final class ParameterTypesResolver<T> {\n+  private final Class<T> cls;\n+  private @Nullable Type[] concreteTypeArguments;\n+  /** type arguments of cls method/constructor from getGenericParameterTypes() */\n+  private final Type[] parameterTypes;\n+\n+  private ParameterTypesResolver(\n+      Class<T> cls, Type[] parameterTypes, @Nullable Type[] concreteTypeArguments) {\n+    this.cls = cls;\n+    this.parameterTypes = parameterTypes;\n+    this.concreteTypeArguments = concreteTypeArguments;\n+  }\n+\n+  public static <T> ParameterTypesResolver<T> ofConstructor(\n+      Type type, Constructor<T> typeConstructor) {\n+    return ofExecutable(type, typeConstructor.getGenericParameterTypes());\n+  }\n+\n+  public static <T> ParameterTypesResolver<T> ofMethod(Type type, Method typeMethod) {\n+    return ofExecutable(type, typeMethod.getGenericParameterTypes());\n+  }\n+\n+  private static <T> ParameterTypesResolver<T> ofExecutable(\n+      Type type, Type[] executableParameterTypes) {\n+\n+    Type[] typeArguments = null;\n+    if (type instanceof ParameterizedType) {\n+      typeArguments = ((ParameterizedType) type).getActualTypeArguments();\n+    }\n+\n+    Class<T> cls = Types.getRawClassOrInterface(type);\n+\n+    if (cls == null) {\n+      throw new IllegalStateException(\"Arrays are not supported\");\n+    }\n+\n+    return new ParameterTypesResolver<>(cls, executableParameterTypes, typeArguments);\n+  }\n+\n+  public Type[] getActualParameterTypes() {\n+    Type[] types = new Type[parameterTypes.length];\n+    for (int i = 0; i < parameterTypes.length; i++) {\n+      Type parameterType = parameterTypes[i];\n+      types[i] = getTypeKeyForParameter(parameterType);\n+    }\n+\n+    // TODO cache this?\n+    return types;\n+  }\n+\n+  private Type getTypeKeyForParameter(Type parameterType) {\n+    if (isTypeVariable(parameterType)) {\n+      return matchTypeToConcreteType((TypeVariable<?>) parameterType);\n+    } else if (hasParameterizedTypeVariable(parameterType)) {\n+      return findKeyForParameterizedType((ParameterizedType) parameterType);\n+    }\n+    return parameterType;\n+  }\n+\n+  private static boolean isTypeVariable(Type parameterType) {\n+    return parameterType instanceof TypeVariable;\n+  }\n+\n+  private static boolean hasParameterizedTypeVariable(Type parameterType) {\n+    if (!(parameterType instanceof ParameterizedType)) {\n+      return false;\n+    }\n+    Type[] actualTypeArguments = ((ParameterizedType) parameterType).getActualTypeArguments();\n+    for (Type type : actualTypeArguments) {\n+      if (isTypeVariable(type)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private TypeUtil.ParameterizedTypeImpl findKeyForParameterizedType(\n+      ParameterizedType parameterType) {\n+    Type[] matchingTypes = matchingParameterizedType(parameterType.getActualTypeArguments());\n+    return new TypeUtil.ParameterizedTypeImpl(null, parameterType.getRawType(), matchingTypes);\n+  }\n+\n+  /**\n+   * Find matching concrete types for a list of types. For every TypeVariable like `T` in the array\n+   * arg, we lookup the matching type in this class's concrete type arguments. If it is already a\n+   * concrete type, just return the type. Creates a new array to match parameterizd type.\n+   *\n+   * @param typeArguments The Types and TypeVariables to find matching concrete types for.\n+   * @return The matching concrete type for the placeholder.\n+   */\n+  private Type[] matchingParameterizedType(Type[] typeArguments) {\n+    Type[] matchedTypeArguments = new Type[typeArguments.length];\n+    for (int i = 0; i < typeArguments.length; i++) {\n+      if (isTypeVariable(typeArguments[i])) {\n+        matchedTypeArguments[i] = matchTypeToConcreteType((TypeVariable<?>) typeArguments[i]);\n+      } else {\n+        matchedTypeArguments[i] = typeArguments[i];\n+      }\n+    }\n+    return matchedTypeArguments;\n+  }\n+\n+  /**\n+   * Given a TypeVariable `T`, we look at this class's parameterized type declarations to see if we\n+   * can find a matching `T`. When we find a matching `T`, we use `T`'s index to find the\n+   * corresponding concrete type argument in this binding's concreteTypeArguments.\n+   *\n+   * @param typeToLookup The parameterized type placeholder to lookup.\n+   * @return The matching concrete type for the placeholder.\n+   */\n+  private Type matchTypeToConcreteType(TypeVariable<?> typeToLookup) {\n+    if (concreteTypeArguments == null) {\n+      throw new IllegalStateException(\n+          \"No concrete type arguments for \" + cls + \" but needed for \" + typeToLookup);\n+    }\n+    // Iterate through parameterized types declared in this class to find the matching index and\n+    // return the corresponding concrete type.\n+    TypeVariable<Class<T>>[] typeParameters = cls.getTypeParameters();\n+    for (int i = 0, length = typeParameters.length; i < length; i++) {\n+      if (typeParameters[i].equals(typeToLookup)) {\n+        return concreteTypeArguments[i];\n+      }\n+    }\n+    throw new IllegalStateException(\n+        \"Could not finding matching parameterized type arguments for \"\n+            + typeToLookup\n+            + \" in \"\n+            + Arrays.toString(typeParameters));\n+  }\n+\n+  String getTypeArgumentsStringOrEmpty() {\n+    if (concreteTypeArguments == null) {\n+      return \"\";\n+    }\n+    return Arrays.toString(concreteTypeArguments);\n+  }\n+}"
  },
  {
    "sha": "e420979c4ca7afa3270f3568e0bcc35f091b5f60",
    "filename": "reflect/src/main/java/dagger/reflect/Reflection.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/JakeWharton/dagger-reflect/blob/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/Reflection.java",
    "raw_url": "https://github.com/JakeWharton/dagger-reflect/raw/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/Reflection.java",
    "contents_url": "https://api.github.com/repos/JakeWharton/dagger-reflect/contents/reflect/src/main/java/dagger/reflect/Reflection.java?ref=2f99a89ce59040a2e027655e528a017d14a75f68",
    "patch": "@@ -23,6 +23,7 @@\n import java.lang.reflect.InvocationHandler;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n import java.lang.reflect.Proxy;\n import java.lang.reflect.Type;\n import java.util.Collections;\n@@ -242,6 +243,12 @@ static Type boxIfNecessary(Type type) {\n     return type;\n   }\n \n+  static boolean isDefault(Method method) {\n+    return (method.getModifiers() & (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC))\n+            == Modifier.PUBLIC\n+        && method.getDeclaringClass().isInterface();\n+  }\n+\n   private Reflection() {\n     throw new AssertionError();\n   }"
  },
  {
    "sha": "29a371abdda0afba207cbb638d4f0859ab0184ca",
    "filename": "reflect/src/main/java/dagger/reflect/ReflectiveAssistedFactoryLookupFactory.java",
    "status": "added",
    "additions": 263,
    "deletions": 0,
    "changes": 263,
    "blob_url": "https://github.com/JakeWharton/dagger-reflect/blob/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/ReflectiveAssistedFactoryLookupFactory.java",
    "raw_url": "https://github.com/JakeWharton/dagger-reflect/raw/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/ReflectiveAssistedFactoryLookupFactory.java",
    "contents_url": "https://api.github.com/repos/JakeWharton/dagger-reflect/contents/reflect/src/main/java/dagger/reflect/ReflectiveAssistedFactoryLookupFactory.java?ref=2f99a89ce59040a2e027655e528a017d14a75f68",
    "patch": "@@ -0,0 +1,263 @@\n+package dagger.reflect;\n+\n+import static dagger.reflect.Reflection.boxIfNecessary;\n+import static dagger.reflect.Reflection.findScope;\n+import static dagger.reflect.TypeUtil.canonicalize;\n+\n+import com.google.auto.value.AutoValue;\n+import dagger.assisted.Assisted;\n+import dagger.assisted.AssistedFactory;\n+import dagger.assisted.AssistedInject;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Type;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.inject.Qualifier;\n+import org.jetbrains.annotations.Nullable;\n+\n+final class ReflectiveAssistedFactoryLookupFactory implements JustInTimeLookup.Factory {\n+  @Override\n+  public @Nullable JustInTimeLookup create(Key key) {\n+    if (key.qualifier() != null) {\n+      return null; // AssistedFactory type cannot be qualified\n+    }\n+\n+    Type type = key.type();\n+\n+    try {\n+      return getJustInTimeAssistedFactoryLookup(type);\n+    } catch (IllegalStateException t) {\n+      throw new IllegalStateException(\n+          String.format(\"Failed to create @AssistedFactory %s: \\n%s\", type, t.getMessage()), t);\n+    }\n+  }\n+\n+  private @Nullable <T> JustInTimeLookup getJustInTimeAssistedFactoryLookup(Type type) {\n+    Class<T> cls = Types.getRawClassOrInterface(type);\n+\n+    if (cls == null) {\n+      return null; // Array types can't be an AssistedFactory\n+    }\n+\n+    if (!Reflection.hasAnnotation(cls.getAnnotations(), AssistedFactory.class)) {\n+      return null;\n+    }\n+\n+    @SuppressWarnings(\"UnnecessaryLocalVariable\")\n+    Class<T> factory = cls;\n+    Method factoryMethod;\n+    Class<?> assistedType;\n+    Constructor<?> assistedConstructor;\n+\n+    // dagger.internal.codegen.AssistedFactoryProcessingStep\n+    if (!Modifier.isInterface(\n+        factory.getModifiers()) /* && !Modifier.isAbstract(factory.getModifiers())*/) {\n+      throw new IllegalStateException(\n+          // \"The @AssistedFactory-annotated type must be either an abstract class or interface\"\n+          // Only interface factories are allowed because proxies\n+          \"The @AssistedFactory-annotated type must be an interface when used with dagger-reflect\");\n+    }\n+\n+    if (factory.isMemberClass() && !Modifier.isStatic(factory.getModifiers())) {\n+      throw new IllegalStateException(\"Nested @AssistedFactory-annotated types must be static. \");\n+    }\n+\n+    Set<Method> abstractFactoryMethods = new HashSet<>();\n+    for (Method method : factory.getMethods()) {\n+      if (Modifier.isAbstract(method.getModifiers()) && !Reflection.isDefault(method)) {\n+        abstractFactoryMethods.add(method);\n+      }\n+    }\n+\n+    if (abstractFactoryMethods.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"The @AssistedFactory-annotated type is missing an abstract, non-default method \"\n+              + \"whose return type matches the assisted injection type.\");\n+    }\n+\n+    if (abstractFactoryMethods.size() > 1) {\n+      throw new IllegalStateException(\n+          \"The @AssistedFactory-annotated type should contain a single abstract, non-default\"\n+              + \" method but found multiple: \"\n+              + abstractFactoryMethods);\n+    }\n+\n+    factoryMethod = abstractFactoryMethods.iterator().next();\n+    assistedType = factoryMethod.getReturnType();\n+    assistedConstructor = findSingleAssistedInjectConstructor(assistedType);\n+\n+    if (assistedConstructor == null) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Invalid return type: %s. An assisted factory's abstract method must return a \"\n+                  + \"type with an @AssistedInject-annotated constructor.\",\n+              assistedType));\n+    }\n+\n+    if (factoryMethod.getTypeParameters().length != 0) {\n+      throw new IllegalStateException(\n+          \"@AssistedFactory does not currently support type parameters in the creator \"\n+              + \"method. See https://github.com/google/dagger/issues/2279\");\n+    }\n+\n+    Map<Integer, AssistedParameter> factoryParameters =\n+        findAssistedParameters(factory, factoryMethod);\n+    Map<Integer, AssistedParameter> injectParameters =\n+        findAssistedParameters(assistedType, assistedConstructor);\n+\n+    Set<AssistedParameter> uniqueAssistedParameters = new HashSet<>();\n+    for (AssistedParameter assistedParameter : factoryParameters.values()) {\n+      if (!uniqueAssistedParameters.add(assistedParameter)) {\n+        throw new IllegalStateException(\n+            \"@AssistedFactory method has duplicate @Assisted types: \" + assistedParameter);\n+      }\n+    }\n+\n+    if (!new HashSet<>(injectParameters.values())\n+        .equals(new HashSet<>(factoryParameters.values()))) {\n+\n+      StringBuilder parameters = new StringBuilder();\n+      for (AssistedParameter value : injectParameters.values()) {\n+        parameters.append(value.type());\n+        parameters.append(\", \");\n+      }\n+\n+      throw new IllegalStateException(\n+          String.format(\n+              \"The parameters in the factory method must match the @Assisted parameters in %s.\"\n+                  + \"\\n      Actual: %s#%s\"\n+                  + \"\\n    Expected: %s#%s(%s)\",\n+              assistedType.getCanonicalName(),\n+              factory.getCanonicalName(),\n+              factoryMethod.getName(),\n+              factory.getCanonicalName(),\n+              factoryMethod.getName(),\n+              parameters.toString()));\n+    }\n+\n+    // dagger.internal.codegen.AssistedInjectProcessingStep\n+    Set<AssistedParameter> uniqueAssistedInjectParameters = new HashSet<>();\n+    for (AssistedParameter assistedParameter : injectParameters.values()) {\n+      if (!uniqueAssistedInjectParameters.add(assistedParameter)) {\n+        throw new IllegalStateException(\n+            String.format(\n+                \"@AssistedInject constructor has duplicate @Assisted type: %s. \"\n+                    + \"Consider setting an identifier on the parameter by using \"\n+                    + \"@Assisted(\\\"identifier\\\") in both the factory and @AssistedInject constructor\",\n+                assistedParameter));\n+      }\n+    }\n+\n+    // dagger.internal.codegen.AssistedProcessingStep\n+    for (Annotation[] parameterAnnotations : assistedConstructor.getParameterAnnotations()) {\n+      if (Reflection.hasAnnotation(parameterAnnotations, Assisted.class)) {\n+        for (Annotation annotation : parameterAnnotations) {\n+          for (Annotation annotationOfAnnotation : annotation.annotationType().getAnnotations()) {\n+            if (annotationOfAnnotation.annotationType() == Qualifier.class) {\n+              throw new IllegalStateException(\n+                  \"Qualifiers cannot be used with @Assisted parameters\");\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    Annotation scope = findScope(cls.getAnnotations());\n+    ParameterTypesResolver<?> parameterTypesResolver =\n+        ParameterTypesResolver.ofConstructor(assistedType, assistedConstructor);\n+    Binding binding =\n+        new UnlinkedAssistedFactoryBinding<>(\n+            factory,\n+            assistedType,\n+            assistedConstructor,\n+            factoryParameters,\n+            injectParameters,\n+            parameterTypesResolver);\n+\n+    return new JustInTimeLookup(scope, binding);\n+  }\n+\n+  @AutoValue\n+  abstract static class AssistedParameter {\n+\n+    public static AssistedParameter of(Type type, String qualifier) {\n+      return new AutoValue_ReflectiveAssistedFactoryLookupFactory_AssistedParameter(\n+          canonicalize(boxIfNecessary(type)), qualifier);\n+    }\n+\n+    abstract Type type();\n+\n+    abstract String qualifier();\n+\n+    @Override\n+    public final String toString() {\n+      return qualifier().isEmpty()\n+          ? String.format(\"@Assisted %s\", type())\n+          : String.format(\"@Assisted(\\\"%s\\\") %s\", qualifier(), type());\n+    }\n+  }\n+\n+  private static Map<Integer, AssistedParameter> findAssistedParameters(\n+      Type type, Object methodOrConstructor) {\n+\n+    boolean allParametersAreAssisted;\n+    Annotation[][] executableParameterAnnotations;\n+    Type[] actualParameterTypes;\n+\n+    if (methodOrConstructor instanceof Method) {\n+      allParametersAreAssisted = true;\n+      executableParameterAnnotations = ((Method) methodOrConstructor).getParameterAnnotations();\n+      actualParameterTypes =\n+          ParameterTypesResolver.ofMethod(type, (Method) methodOrConstructor)\n+              .getActualParameterTypes();\n+    } else if (methodOrConstructor instanceof Constructor<?>) {\n+      allParametersAreAssisted = false;\n+      executableParameterAnnotations =\n+          ((Constructor<?>) methodOrConstructor).getParameterAnnotations();\n+      actualParameterTypes =\n+          ParameterTypesResolver.ofConstructor(type, (Constructor<?>) methodOrConstructor)\n+              .getActualParameterTypes();\n+    } else {\n+      throw new RuntimeException(\n+          \"Expected method or constructor, got \" + methodOrConstructor.getClass());\n+    }\n+\n+    Map<Integer, AssistedParameter> result = new HashMap<>();\n+\n+    for (int i = 0; i < executableParameterAnnotations.length; i++) {\n+      Annotation[] parameterAnnotations = executableParameterAnnotations[i];\n+      Type parameterType = actualParameterTypes[i];\n+      Assisted assisted = Reflection.findAnnotation(parameterAnnotations, Assisted.class);\n+\n+      if (assisted != null || allParametersAreAssisted) {\n+        String qualifier = assisted == null ? \"\" : assisted.value();\n+        result.put(i, AssistedParameter.of(parameterType, qualifier));\n+      }\n+    }\n+\n+    return result;\n+  }\n+\n+  private static <T> @Nullable Constructor<T> findSingleAssistedInjectConstructor(Class<T> cls) {\n+    // Not modifying it, safe to use generics; see Class#getConstructors() for more info.\n+    @SuppressWarnings(\"unchecked\")\n+    Constructor<T>[] constructors = (Constructor<T>[]) cls.getDeclaredConstructors();\n+    Constructor<T> target = null;\n+    for (Constructor<T> constructor : constructors) {\n+      if (constructor.getAnnotation(AssistedInject.class) != null) {\n+        if (target != null) {\n+          throw new IllegalStateException(\n+              cls.getCanonicalName()\n+                  + \" defines multiple @AssistedInject-annotations constructors\");\n+        }\n+        target = constructor;\n+      }\n+    }\n+    return target;\n+  }\n+}"
  },
  {
    "sha": "5eaff86f253eecf85619a034b794ccc2fb5d322f",
    "filename": "reflect/src/main/java/dagger/reflect/ReflectiveJustInTimeLookupFactory.java",
    "status": "modified",
    "additions": 6,
    "deletions": 15,
    "changes": 21,
    "blob_url": "https://github.com/JakeWharton/dagger-reflect/blob/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/ReflectiveJustInTimeLookupFactory.java",
    "raw_url": "https://github.com/JakeWharton/dagger-reflect/raw/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/ReflectiveJustInTimeLookupFactory.java",
    "contents_url": "https://api.github.com/repos/JakeWharton/dagger-reflect/contents/reflect/src/main/java/dagger/reflect/ReflectiveJustInTimeLookupFactory.java?ref=2f99a89ce59040a2e027655e528a017d14a75f68",
    "patch": "@@ -4,7 +4,6 @@\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Constructor;\n-import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import javax.inject.Inject;\n import org.jetbrains.annotations.Nullable;\n@@ -21,19 +20,9 @@\n   }\n \n   private @Nullable <T> JustInTimeLookup getJustInTimeLookup(Type type) {\n-    Class<T> cls;\n-    Type[] typeArguments = null;\n-    if (type instanceof ParameterizedType) {\n-      // Assume that \"representing the class or interface that declared this type\" is a Class<?>.\n-      @SuppressWarnings(\"unchecked\")\n-      Class<T> rawType = (Class<T>) ((ParameterizedType) type).getRawType();\n-      cls = rawType;\n-      typeArguments = ((ParameterizedType) type).getActualTypeArguments();\n-    } else if (type instanceof Class<?>) {\n-      @SuppressWarnings(\"unchecked\")\n-      Class<T> directClass = (Class<T>) type;\n-      cls = directClass;\n-    } else {\n+    Class<T> cls = Types.getRawClassOrInterface(type);\n+\n+    if (cls == null) {\n       return null; // Array types can't be just-in-time satisfied.\n     }\n \n@@ -43,7 +32,9 @@\n     }\n \n     Annotation scope = findScope(cls.getAnnotations());\n-    Binding binding = new UnlinkedJustInTimeBinding<>(cls, target, typeArguments);\n+    ParameterTypesResolver<T> parameterTypesResolver =\n+        ParameterTypesResolver.ofConstructor(type, target);\n+    Binding binding = new UnlinkedJustInTimeBinding<>(cls, target, parameterTypesResolver);\n     return new JustInTimeLookup(scope, binding);\n   }\n "
  },
  {
    "sha": "274c8f29312bdb5a033f1b33a02850ec7b57f444",
    "filename": "reflect/src/main/java/dagger/reflect/Types.java",
    "status": "modified",
    "additions": 12,
    "deletions": 0,
    "changes": 12,
    "blob_url": "https://github.com/JakeWharton/dagger-reflect/blob/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/Types.java",
    "raw_url": "https://github.com/JakeWharton/dagger-reflect/raw/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/Types.java",
    "contents_url": "https://api.github.com/repos/JakeWharton/dagger-reflect/contents/reflect/src/main/java/dagger/reflect/Types.java?ref=2f99a89ce59040a2e027655e528a017d14a75f68",
    "patch": "@@ -28,6 +28,18 @@\n final class Types {\n   private Types() {}\n \n+  static @Nullable <T> Class<T> getRawClassOrInterface(Type type) {\n+    if (type instanceof Class<?>) {\n+      //noinspection unchecked\n+      return (Class<T>) type;\n+    } else if (type instanceof ParameterizedType) {\n+      //noinspection unchecked\n+      return (Class<T>) ((ParameterizedType) type).getRawType();\n+    } else {\n+      return null;\n+    }\n+  }\n+\n   static Class<?> getRawType(Type type) {\n     if (type instanceof Class<?>) {\n       // type is a normal class."
  },
  {
    "sha": "e09052152d16c80d6462caaeadf694d7637f438f",
    "filename": "reflect/src/main/java/dagger/reflect/UnlinkedAssistedFactoryBinding.java",
    "status": "added",
    "additions": 97,
    "deletions": 0,
    "changes": 97,
    "blob_url": "https://github.com/JakeWharton/dagger-reflect/blob/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/UnlinkedAssistedFactoryBinding.java",
    "raw_url": "https://github.com/JakeWharton/dagger-reflect/raw/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/UnlinkedAssistedFactoryBinding.java",
    "contents_url": "https://api.github.com/repos/JakeWharton/dagger-reflect/contents/reflect/src/main/java/dagger/reflect/UnlinkedAssistedFactoryBinding.java?ref=2f99a89ce59040a2e027655e528a017d14a75f68",
    "patch": "@@ -0,0 +1,97 @@\n+package dagger.reflect;\n+\n+import static dagger.reflect.Reflection.findQualifier;\n+\n+import dagger.MembersInjector;\n+import dagger.reflect.Binding.UnlinkedBinding;\n+import dagger.reflect.ReflectiveAssistedFactoryLookupFactory.AssistedParameter;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+\n+class UnlinkedAssistedFactoryBinding<T> extends UnlinkedBinding {\n+  private final Class<T> factory;\n+  private final Class<?> assistedType;\n+  private final Constructor<?> assistedConstructor;\n+  private final Map<Integer, AssistedParameter> factoryParameters;\n+  private final Map<Integer, AssistedParameter> assistedInjectParameters;\n+  private final ParameterTypesResolver<?> assistedConstructorParameterTypesResolver;\n+\n+  UnlinkedAssistedFactoryBinding(\n+      Class<T> factory,\n+      Class<?> assistedType,\n+      Constructor<?> constructor,\n+      Map<Integer, AssistedParameter> factoryParameters,\n+      Map<Integer, AssistedParameter> injectParameters,\n+      ParameterTypesResolver<?> assistedConstructorParameterTypesResolver) {\n+    this.factory = factory;\n+    this.assistedType = assistedType;\n+    this.assistedConstructor = constructor;\n+    this.factoryParameters = factoryParameters;\n+    this.assistedInjectParameters = injectParameters;\n+    this.assistedConstructorParameterTypesResolver = assistedConstructorParameterTypesResolver;\n+  }\n+\n+  @Override\n+  public LinkedBinding<T> link(Linker linker, Scope scope) {\n+    Type[] parameterTypes = assistedConstructorParameterTypesResolver.getActualParameterTypes();\n+    Annotation[][] parameterAnnotations = assistedConstructor.getParameterAnnotations();\n+\n+    Integer[] constructorParameterToFactoryParameterIndex = new Integer[parameterTypes.length];\n+    LinkedBinding<?>[] bindings = new LinkedBinding<?>[parameterTypes.length];\n+\n+    // TODO find a better way to resolve binding for the factory itself\n+    // If we get the binding from linker it leads to dependency cycle\n+    // Needed to inject factory instance into an assistedType (why would you do that though?)\n+    // and pass dagger tests\n+    Integer factoryBinding = null;\n+\n+    for (int i = 0; i < parameterTypes.length; i++) {\n+      AssistedParameter assistedParameter = assistedInjectParameters.get(i);\n+\n+      if (assistedParameter != null) {\n+        for (Map.Entry<Integer, AssistedParameter> entry : factoryParameters.entrySet()) {\n+          // One of parameters must match, because we validate assisted parameters earlier\n+          if (entry.getValue().equals(assistedParameter)) {\n+            constructorParameterToFactoryParameterIndex[i] = entry.getKey();\n+            break;\n+          }\n+        }\n+      } else {\n+        Type parameterType = parameterTypes[i];\n+        Key key = Key.of(findQualifier(parameterAnnotations[i]), parameterType);\n+\n+        if (Types.equals(parameterType, factory)) {\n+          factoryBinding = i;\n+        } else {\n+          bindings[i] = linker.get(key);\n+        }\n+      }\n+    }\n+\n+    MembersInjector<?> membersInjector = ReflectiveMembersInjector.create(assistedType, scope);\n+\n+    LinkedBinding<T> linkedBinding =\n+        new LinkedJustInTimeAssistedFactoryBinding<>(\n+            factory,\n+            assistedConstructor,\n+            membersInjector,\n+            bindings,\n+            constructorParameterToFactoryParameterIndex);\n+\n+    if (factoryBinding != null) {\n+      bindings[factoryBinding] = linkedBinding;\n+    }\n+\n+    return linkedBinding;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"@AssistedInject[\"\n+        + assistedType.getName()\n+        + assistedConstructorParameterTypesResolver.getTypeArgumentsStringOrEmpty()\n+        + \".<init>(…)]\";\n+  }\n+}"
  },
  {
    "sha": "137e2ef35d525cc7400deec2c25ed6117f5d29ed",
    "filename": "reflect/src/main/java/dagger/reflect/UnlinkedJustInTimeBinding.java",
    "status": "modified",
    "additions": 9,
    "deletions": 99,
    "changes": 108,
    "blob_url": "https://github.com/JakeWharton/dagger-reflect/blob/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/UnlinkedJustInTimeBinding.java",
    "raw_url": "https://github.com/JakeWharton/dagger-reflect/raw/2f99a89ce59040a2e027655e528a017d14a75f68/reflect/src/main/java/dagger/reflect/UnlinkedJustInTimeBinding.java",
    "contents_url": "https://api.github.com/repos/JakeWharton/dagger-reflect/contents/reflect/src/main/java/dagger/reflect/UnlinkedJustInTimeBinding.java?ref=2f99a89ce59040a2e027655e528a017d14a75f68",
    "patch": "@@ -6,35 +6,29 @@\n import dagger.reflect.Binding.UnlinkedBinding;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Constructor;\n-import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.util.Arrays;\n-import org.jetbrains.annotations.Nullable;\n \n final class UnlinkedJustInTimeBinding<T> extends UnlinkedBinding {\n   private final Class<T> cls;\n   private final Constructor<T> constructor;\n-  // Type arguments might be used as types for this binding's parameterized constructor parameters.\n-  private @Nullable Type[] concreteTypeArguments;\n+  private final ParameterTypesResolver<T> parameterTypesResolver;\n \n   UnlinkedJustInTimeBinding(\n-      Class<T> cls, Constructor<T> constructor, @Nullable Type[] concreteTypeArguments) {\n+      Class<T> cls, Constructor<T> constructor, ParameterTypesResolver<T> parameterTypesResolver) {\n     this.cls = cls;\n     this.constructor = constructor;\n-    this.concreteTypeArguments = concreteTypeArguments;\n+    this.parameterTypesResolver = parameterTypesResolver;\n   }\n \n   @Override\n   public LinkedBinding<?> link(Linker linker, Scope scope) {\n-    Type[] parameterTypes = constructor.getGenericParameterTypes();\n+    Type[] parameterTypes = parameterTypesResolver.getActualParameterTypes();\n     Annotation[][] parameterAnnotations = constructor.getParameterAnnotations();\n \n     LinkedBinding<?>[] bindings = new LinkedBinding<?>[parameterTypes.length];\n     for (int i = 0; i < parameterTypes.length; i++) {\n       Type parameterType = parameterTypes[i];\n-      Key key =\n-          Key.of(findQualifier(parameterAnnotations[i]), getTypeKeyForParameter(parameterType));\n+      Key key = Key.of(findQualifier(parameterAnnotations[i]), parameterType);\n       bindings[i] = linker.get(key);\n     }\n \n@@ -43,95 +37,11 @@\n     return new LinkedJustInTimeBinding<>(constructor, bindings, membersInjector);\n   }\n \n-  private Type getTypeKeyForParameter(Type parameterType) {\n-    if (isTypeVariable(parameterType)) {\n-      return matchTypeToConcreteType((TypeVariable<?>) parameterType);\n-    } else if (hasParameterizedTypeVariable(parameterType)) {\n-      return findKeyForParameterizedType((ParameterizedType) parameterType);\n-    }\n-    return parameterType;\n-  }\n-\n-  private static boolean isTypeVariable(Type parameterType) {\n-    return parameterType instanceof TypeVariable;\n-  }\n-\n-  private static boolean hasParameterizedTypeVariable(Type parameterType) {\n-    if (!(parameterType instanceof ParameterizedType)) {\n-      return false;\n-    }\n-    Type[] actualTypeArguments = ((ParameterizedType) parameterType).getActualTypeArguments();\n-    for (Type type : actualTypeArguments) {\n-      if (isTypeVariable(type)) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  private TypeUtil.ParameterizedTypeImpl findKeyForParameterizedType(\n-      ParameterizedType parameterType) {\n-    Type[] matchingTypes = matchingParameterizedType(parameterType.getActualTypeArguments());\n-    return new TypeUtil.ParameterizedTypeImpl(null, parameterType.getRawType(), matchingTypes);\n-  }\n-\n-  /**\n-   * Find matching concrete types for a list of types. For every TypeVariable like `T` in the array\n-   * arg, we lookup the matching type in this class's concrete type arguments. If it is already a\n-   * concrete type, just return the type. Creates a new array to match parameterizd type.\n-   *\n-   * @param typeArguments The Types and TypeVariables to find matching concrete types for.\n-   * @return The matching concrete type for the placeholder.\n-   */\n-  private Type[] matchingParameterizedType(Type[] typeArguments) {\n-    Type[] matchedTypeArguments = new Type[typeArguments.length];\n-    for (int i = 0; i < typeArguments.length; i++) {\n-      if (isTypeVariable(typeArguments[i])) {\n-        matchedTypeArguments[i] = matchTypeToConcreteType((TypeVariable<?>) typeArguments[i]);\n-      } else {\n-        matchedTypeArguments[i] = typeArguments[i];\n-      }\n-    }\n-    return matchedTypeArguments;\n-  }\n-\n-  /**\n-   * Given a TypeVariable `T`, we look at this class's parameterized type declarations to see if we\n-   * can find a matching `T`. When we find a matching `T`, we use `T`'s index to find the\n-   * corresponding concrete type argument in this binding's concreteTypeArguments.\n-   *\n-   * @param typeToLookup The parameterized type placeholder to lookup.\n-   * @return The matching concrete type for the placeholder.\n-   */\n-  private Type matchTypeToConcreteType(TypeVariable<?> typeToLookup) {\n-    if (concreteTypeArguments == null) {\n-      throw new IllegalStateException(\n-          \"No concrete type arguments for \" + cls + \" but needed for \" + typeToLookup);\n-    }\n-    // Iterate through parameterized types declared in this class to find the matching index and\n-    // return the corresponding concrete type.\n-    TypeVariable<Class<T>>[] typeParameters = cls.getTypeParameters();\n-    for (int i = 0, length = typeParameters.length; i < length; i++) {\n-      if (typeParameters[i].equals(typeToLookup)) {\n-        return concreteTypeArguments[i];\n-      }\n-    }\n-    throw new IllegalStateException(\n-        \"Could not finding matching parameterized type arguments for \"\n-            + typeToLookup\n-            + \" in \"\n-            + Arrays.toString(typeParameters));\n-  }\n-\n   @Override\n   public String toString() {\n-    return \"@Inject[\" + cls.getName() + getTypeArgumentsStringOrEmpty() + \".<init>(…)]\";\n-  }\n-\n-  private String getTypeArgumentsStringOrEmpty() {\n-    if (concreteTypeArguments == null) {\n-      return \"\";\n-    }\n-    return Arrays.toString(concreteTypeArguments);\n+    return \"@Inject[\"\n+        + cls.getName()\n+        + parameterTypesResolver.getTypeArgumentsStringOrEmpty()\n+        + \".<init>(…)]\";\n   }\n }"
  }
]
