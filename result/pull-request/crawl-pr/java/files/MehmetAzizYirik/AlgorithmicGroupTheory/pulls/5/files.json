[
  {
    "sha": "39384cbfbe688cb15cced1e77bf351b0ba9b1f4f",
    "filename": ".github/workflows/maven.yml",
    "status": "added",
    "additions": 29,
    "deletions": 0,
    "changes": 29,
    "blob_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/blob/aa507c8123f0f853206a95bbd295db556ea4e5ae/.github/workflows/maven.yml",
    "raw_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/raw/aa507c8123f0f853206a95bbd295db556ea4e5ae/.github/workflows/maven.yml",
    "contents_url": "https://api.github.com/repos/MehmetAzizYirik/AlgorithmicGroupTheory/contents/.github/workflows/maven.yml?ref=aa507c8123f0f853206a95bbd295db556ea4e5ae",
    "patch": "@@ -0,0 +1,29 @@\n+# This workflow will build a Java project with Maven\n+# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven\n+\n+name: Java CI with Maven\n+\n+on:\n+  push:\n+    branches: [ master ]\n+  pull_request:\n+    branches: [ master ]\n+\n+jobs:\n+  build:\n+\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - uses: actions/checkout@v2\n+    - name: Set up JDK 1.8\n+      uses: actions/setup-java@v1\n+      with:\n+        java-version: 1.8\n+    - name: Build with Maven\n+      run: mvn -B package jacoco:report --file pom.xml\n+\n+    - uses: codecov/codecov-action@v1\n+      with:\n+        file: ./**/target/site/jacoco/jacoco.xml\n+        name: codecov"
  },
  {
    "sha": "16b61c5d72c173df786a5b26ecc410fe3e6f24b7",
    "filename": ".gitignore",
    "status": "added",
    "additions": 3,
    "deletions": 0,
    "changes": 3,
    "blob_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/blob/aa507c8123f0f853206a95bbd295db556ea4e5ae/.gitignore",
    "raw_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/raw/aa507c8123f0f853206a95bbd295db556ea4e5ae/.gitignore",
    "contents_url": "https://api.github.com/repos/MehmetAzizYirik/AlgorithmicGroupTheory/contents/.gitignore?ref=aa507c8123f0f853206a95bbd295db556ea4e5ae",
    "patch": "@@ -0,0 +1,3 @@\n+/target/\n+/.idea/\n+*.iml"
  },
  {
    "sha": "58c221e093e3195a12788f7c7fb7fe1998e8718c",
    "filename": "README.md",
    "status": "modified",
    "additions": 3,
    "deletions": 0,
    "changes": 3,
    "blob_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/blob/aa507c8123f0f853206a95bbd295db556ea4e5ae/README.md",
    "raw_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/raw/aa507c8123f0f853206a95bbd295db556ea4e5ae/README.md",
    "contents_url": "https://api.github.com/repos/MehmetAzizYirik/AlgorithmicGroupTheory/contents/README.md?ref=aa507c8123f0f853206a95bbd295db556ea4e5ae",
    "patch": "@@ -2,6 +2,9 @@\n \n Copyright 2019 Mehmet Aziz Yirik\n \n+[![Java CI with Maven](https://github.com/javadev/AlgorithmicGroupTheory/actions/workflows/maven.yml/badge.svg)](https://github.com/javadev/AlgorithmicGroupTheory/actions/workflows/maven.yml)\n+[![codecov](https://codecov.io/gh/javadev/AlgorithmicGroupTheory/branch/master/graph/badge.svg?token=G296G5EEDG)](https://codecov.io/gh/javadev/AlgorithmicGroupTheory)\n+\n ## Introduction\n \n Algorithmic group theory functions shared in this repository, are especially developed for the implementations in mathematical chemistry.These algorithms are for the molecular structure generation problem."
  },
  {
    "sha": "623cf368269ea0abceaeae03736d9e2924b91b99",
    "filename": "exec_gen.cmd",
    "status": "added",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/blob/aa507c8123f0f853206a95bbd295db556ea4e5ae/exec_gen.cmd",
    "raw_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/raw/aa507c8123f0f853206a95bbd295db556ea4e5ae/exec_gen.cmd",
    "contents_url": "https://api.github.com/repos/MehmetAzizYirik/AlgorithmicGroupTheory/contents/exec_gen.cmd?ref=aa507c8123f0f853206a95bbd295db556ea4e5ae",
    "patch": "@@ -0,0 +1,4 @@\n+java -jar MORGEN.jar -f C3O3H4 -v -d result1\n+java -jar MORGEN.jar -f C2H5NO2 -v -d result2\n+java -jar MORGEN.jar -f C4H7NO3 -v -d result3\n+java -jar MORGEN.jar -f C5H9N3 -v -d result4"
  },
  {
    "sha": "678d03d12cb091693ef21d5a6250e1956f971a5c",
    "filename": "pom.xml",
    "status": "modified",
    "additions": 13,
    "deletions": 0,
    "changes": 13,
    "blob_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/blob/aa507c8123f0f853206a95bbd295db556ea4e5ae/pom.xml",
    "raw_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/raw/aa507c8123f0f853206a95bbd295db556ea4e5ae/pom.xml",
    "contents_url": "https://api.github.com/repos/MehmetAzizYirik/AlgorithmicGroupTheory/contents/pom.xml?ref=aa507c8123f0f853206a95bbd295db556ea4e5ae",
    "patch": "@@ -160,6 +160,19 @@\n       \t\t\t</descriptorRefs>                 \r\n     \t\t</configuration>\r\n   \t\t</plugin> \r\n+      <plugin>\r\n+        <groupId>org.jacoco</groupId>\r\n+        <artifactId>jacoco-maven-plugin</artifactId>\r\n+        <version>0.8.6</version>\r\n+        <executions>\r\n+          <execution>\r\n+            <id>prepare-agent</id>\r\n+            <goals>\r\n+              <goal>prepare-agent</goal>\r\n+            </goals>\r\n+          </execution>\r\n+        </executions>\r\n+      </plugin>\r\n \t</plugins>\r\n   </build>\r\n </project>\r"
  },
  {
    "sha": "c06cbf190fd36ead77005246bded91b7fa61d749",
    "filename": "src/main/java/AlgorithmicGroupTheory/HydrogenDistributor.java",
    "status": "modified",
    "additions": 18,
    "deletions": 21,
    "changes": 39,
    "blob_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/blob/aa507c8123f0f853206a95bbd295db556ea4e5ae/src/main/java/AlgorithmicGroupTheory/HydrogenDistributor.java",
    "raw_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/raw/aa507c8123f0f853206a95bbd295db556ea4e5ae/src/main/java/AlgorithmicGroupTheory/HydrogenDistributor.java",
    "contents_url": "https://api.github.com/repos/MehmetAzizYirik/AlgorithmicGroupTheory/contents/src/main/java/AlgorithmicGroupTheory/HydrogenDistributor.java?ref=aa507c8123f0f853206a95bbd295db556ea4e5ae",
    "patch": "@@ -78,7 +78,7 @@\n \t\r\n \tstatic {\r\n \t\t//The atom capacities from MOLGEN book. Capacity of an atom equals to \r\n-\t\tcapacities = new HashMap<Integer, Integer>();\r\n+\t\tcapacities = new HashMap<>();\r\n \t\tcapacities.put(6, 3);\r\n \t\tcapacities.put(7, 2);\r\n \t\tcapacities.put(8, 1);\r\n@@ -163,9 +163,9 @@ public static int sum(ArrayList<Integer> list, int index) {\n \t\r\n \tpublic static int sum(int[] array) {\r\n \t\tint sum=0;\r\n-\t\tfor(int i=0;i<array.length;i++) {\r\n-\t\t\tsum=sum+array[i];\r\n-\t\t}\r\n+      for (int value : array) {\r\n+        sum = sum + value;\r\n+      }\r\n \t\treturn sum;\r\n \t}\r\n \t\r\n@@ -185,7 +185,7 @@ public static int sum(int[] array) {\n \t}\r\n \t\r\n \tpublic static int[] arraySum(int[] a, int[] b) {\r\n-\t\tList<int[]> arrays= new ArrayList<int[]>();\r\n+\t\tList<int[]> arrays= new ArrayList<>();\r\n \t\tarrays.add(a);\r\n \t\tarrays.add(b);\r\n \t\treturn mergeArrays(arrays);\r\n@@ -194,19 +194,16 @@ public static int sum(int[] array) {\n \tpublic static List<List<int[]>> buildLists(int n){\r\n \t\tList<List<int[]>> lists= new ArrayList<List<int[]>>();\r\n \t\tfor (int i=0; i<n; ++i) {\r\n-\t\t\tList<int[]> ilist= new ArrayList<int[]>();\r\n+\t\t\tList<int[]> ilist= new ArrayList<>();\r\n \t\t\tlists.add(ilist);\r\n \t\t}\r\n \t\treturn lists;\r\n \t}\r\n \tpublic static List<int[]> combineArrays(LinkedList<List <int[]>> lists) {\r\n-\t\tList<int[]> comb = new ArrayList<int[]>();\r\n-\t    for (int[] s: lists.removeFirst()) {\r\n-\t    \tcomb.add(s);\r\n-\t    }\r\n+      List<int[]> comb = new ArrayList<>(lists.removeFirst());\r\n \t    while (!lists.isEmpty()) {\r\n \t        List<int[]> list = lists.removeFirst();\r\n-\t        List<int[]> newComb =  new ArrayList<int[]>();\r\n+\t        List<int[]> newComb = new ArrayList<>();\r\n \t        for (int[] arr1: comb) { \r\n \t            for (int[] arr2 : list) { \r\n \t            \tnewComb.add(arraySum(arr1,arr2));\r\n@@ -255,27 +252,27 @@ public static int sum(int[] array) {\n \t\treturn result;\r\n \t}**/\r\n \t\r\n-\tpublic static List<int[]> run(ArrayList<Integer> partition, int[] degrees) throws FileNotFoundException, UnsupportedEncodingException, CloneNotSupportedException, CDKException {\r\n+\tpublic static List<int[]> run(ArrayList<Integer> partition, int[] degrees) throws CloneNotSupportedException {\r\n \t\tint partitionSize= partition.size();\r\n \t\tint hydrogen= partition.get(partitionSize-1);\r\n \t\tHydrogenDistributor.isotopes=partitionSize-1;\r\n \t\tHydrogenDistributor.size=partitionSize-1;\r\n \t\tsetValues(partition,degrees);\r\n \t\tHydrogenDistributor.totalHydrogen=hydrogen;\r\n-\t\tList<int[]> result= new ArrayList<int[]>();\r\n+\t\tList<int[]> result= new ArrayList<>();\r\n \t\tif(isotopes==1) {\r\n-\t\t\tList<int[]> iarrays= new ArrayList<int[]>();\r\n+\t\t\tList<int[]> iarrays= new ArrayList<>();\r\n \t\t\tint[] array = new int[0];\r\n \t\t\tHydrogenDistributor.hydrogens2distribute=totalHydrogen;\r\n \t\t\tdistribute(iarrays,totalHydrogen,array,valences[0],totalAtom[0]);\r\n \t\t\tresult= iarrays;\r\n \t\t}else {\r\n-\t\t\tList<int[]> distributions= new ArrayList<int[]>();\r\n+\t\t\tList<int[]> distributions= new ArrayList<>();\r\n \t\t\tfor(int[] dene:partition(totalHydrogen,isotopes,0)){\r\n-\t\t\t\tLinkedList<List<int[]>> lists = new LinkedList<List <int[]>>();\r\n+\t\t\t\tLinkedList<List<int[]>> lists = new LinkedList<>();\r\n \t\t\t\tfor(int i=0;i<dene.length;i++) {\r\n \t\t\t\t\tHydrogenDistributor.hydrogens2distribute=dene[i];\r\n-\t\t\t\t\tList<int[]> iarrays= new ArrayList<int[]>();\r\n+\t\t\t\t\tList<int[]> iarrays= new ArrayList<>();\r\n \t\t\t\t\tint[] array = new int[0];\r\n \t\t\t\t\tdistribute(iarrays,dene[i],array,valences[i],totalAtom[i]);\r\n \t\t\t\t\tlists.add(iarrays);\r\n@@ -294,7 +291,7 @@ public static int sum(int[] array) {\n \t\r\n \tpublic static List<int[]> partition(int n, int d,int depth) {\r\n \t\tif(d==depth) {\r\n-\t\t\tList<int[]> array= new ArrayList<int[]>();\r\n+\t\t\tList<int[]> array= new ArrayList<>();\r\n \t\t\tint[] take=new int[0];\r\n \t\t\tarray.add(take);\r\n \t\t\treturn array;\r\n@@ -304,7 +301,7 @@ public static int sum(int[] array) {\n \t}\r\n \t\r\n \tpublic static List<int[]> buildArray(int n,int d, int depth){\r\n-\t\tList<int[]> array= new ArrayList<int[]>();\r\n+\t\tList<int[]> array= new ArrayList<>();\r\n \t\tIntStream range = IntStream.rangeClosed(0,n);\r\n \t\tfor(int i:range.toArray()) {\r\n \t\t\tfor(int[] item: partition(n-i,d,depth+1)) {\r\n@@ -334,7 +331,7 @@ public static int sum(int[] array) {\n \t\treturn Arrays.stream(arr).boxed().sorted().mapToInt(Integer::intValue).toArray();\r\n \t}\r\n \t\r\n-\tpublic static void distribute(List<int[]> arrays,int hydrogen,int[]arr,int valence, int numAtom) throws CloneNotSupportedException {\r\n+\tpublic static void distribute(List<int[]> arrays,int hydrogen,int[]arr,int valence, int numAtom) {\r\n \t\tif(hydrogen==0 && sum(arr)==hydrogens2distribute){\r\n \t\t\tif(arr.length!=numAtom) {\r\n \t\t\t\tarr=addZeros(arr,(numAtom-arr.length));\r\n@@ -374,7 +371,7 @@ public static void distribute(List<int[]> arrays,int hydrogen,int[]arr,int valen\n \t */\r\n \t\r\n \tpublic static List<IAtomContainer> generateAtomContainers(List<int[]> distributions) throws CloneNotSupportedException{\r\n-\t\tList<IAtomContainer> acontainers= new ArrayList<IAtomContainer>();\r\n+\t\tList<IAtomContainer> acontainers= new ArrayList<>();\r\n \t\tfor(int[] array:distributions) {\r\n \t\t\tIAtomContainer ac=acontainer.clone();\r\n \t\t\tacontainers.add(setHydrogens(ac,array));\r"
  },
  {
    "sha": "b25ec48dcf274a62dc689cf28262a22ca47bf861",
    "filename": "src/main/java/AlgorithmicGroupTheory/MORGEN.java",
    "status": "modified",
    "additions": 167,
    "deletions": 160,
    "changes": 327,
    "blob_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/blob/aa507c8123f0f853206a95bbd295db556ea4e5ae/src/main/java/AlgorithmicGroupTheory/MORGEN.java",
    "raw_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/raw/aa507c8123f0f853206a95bbd295db556ea4e5ae/src/main/java/AlgorithmicGroupTheory/MORGEN.java",
    "contents_url": "https://api.github.com/repos/MehmetAzizYirik/AlgorithmicGroupTheory/contents/src/main/java/AlgorithmicGroupTheory/MORGEN.java?ref=aa507c8123f0f853206a95bbd295db556ea4e5ae",
    "patch": "@@ -29,7 +29,6 @@\n import org.openscience.cdk.group.Permutation;\r\n import org.openscience.cdk.interfaces.IAtomContainer;\r\n import org.openscience.cdk.interfaces.IAtom;\r\n-import org.openscience.cdk.interfaces.IAtomContainer;\r\n import org.openscience.cdk.interfaces.IChemObjectBuilder;\r\n import org.openscience.cdk.interfaces.IBond.Order;\r\n import org.openscience.cdk.io.SDFWriter;\r\n@@ -47,9 +46,9 @@\n \tpublic static boolean flag=true;\r\n \tpublic static boolean biggest=true;\r\n \tpublic static boolean equalAuto=true;\r\n-\tpublic static ArrayList<int[][]> output= new ArrayList<int[][]>();\r\n-\tpublic static ArrayList<String> inchis= new ArrayList<String>();\r\n-\tpublic static List<List<Permutation>> formerPermutations= new ArrayList<List<Permutation>>();\r\n+\tpublic static ArrayList<int[][]> output= new ArrayList<>();\r\n+\tpublic static ArrayList<String> inchis= new ArrayList<>();\r\n+\tpublic static List<List<Permutation>> formerPermutations= new ArrayList<>();\r\n \tpublic static int[] degrees;\r\n \tpublic static int[] initialDegrees;\r\n \tpublic static int[] partition;\r\n@@ -58,10 +57,10 @@\n \tpublic static boolean formerPermutationsCheck=true;\r\n \tpublic static IChemObjectBuilder builder=DefaultChemObjectBuilder.getInstance();\r\n \tpublic static IAtomContainer atomContainer= builder.newInstance(IAtomContainer.class);\r\n-\tpublic static List<ArrayList<Integer>> partitionList= new ArrayList<ArrayList<Integer>>();\r\n-\tpublic static ArrayList<ArrayList<Permutation>> representatives = new ArrayList<ArrayList<Permutation>>();\r\n-\tpublic static List<String> symbols = new ArrayList<String>();\r\n-\tpublic static ArrayList<Integer> occurrences  = new ArrayList<Integer>();\r\n+\tpublic static List<ArrayList<Integer>> partitionList= new ArrayList<>();\r\n+\tpublic static ArrayList<ArrayList<Permutation>> representatives = new ArrayList<>();\r\n+\tpublic static List<String> symbols = new ArrayList<>();\r\n+\tpublic static ArrayList<Integer> occurrences  = new ArrayList<>();\r\n \tpublic static Map<String, Integer> valences; \r\n \tpublic static PrintWriter pWriter;\r\n \tpublic static boolean stripIterate=true;\r\n@@ -74,7 +73,7 @@\n \tpublic static int z=0;\r\n \tstatic {\r\n \t\t//The atom valences from CDK.\r\n-\t\tvalences = new HashMap<String, Integer>();\r\n+\t\tvalences = new HashMap<>();\r\n \t\t\t\r\n \t\tvalences.put(\"C\", 4);\r\n \t\t//valences.put(\"N\", 5);\r\n@@ -99,7 +98,7 @@\n \t * Molecule depiction \r\n \t */\r\n \t\t\r\n-\tpublic static void depict(IAtomContainer molecule, String path) throws CloneNotSupportedException, CDKException, IOException{\r\n+\tpublic static void depict(IAtomContainer molecule, String path) throws CDKException, IOException{\r\n \t\tDepictionGenerator depiction = new DepictionGenerator();\r\n \t\tdepiction.withSize(1000, 1000).withZoom(20).depict(molecule).writeTo(path);\r\n \t}\r\n@@ -112,10 +111,10 @@ public static void depict(IAtomContainer molecule, String path) throws CloneNotS\n \t\t\t\r\n \t public static int toInt(Integer[] array) {\r\n \t\t int result=0;\r\n-\t\t for(int i=0;i<array.length;i++) {\r\n-\t\t\t result=result*10;\r\n-\t\t\t result=result+array[i];\r\n-\t\t }\r\n+       for (Integer integer : array) {\r\n+         result = result * 10;\r\n+         result = result + integer;\r\n+       }\r\n \t\t return result;\r\n \t }\r\n \t \r\n@@ -135,9 +134,9 @@ public static int toInt(Integer[] array) {\n \t\r\n \tpublic static int sum(List<Integer> list) {\r\n \t\tint sum=0;\r\n-\t\tfor(int i=0;i<list.size();i++) {\r\n-\t\t\tsum=sum+list.get(i);\r\n-\t\t}\r\n+      for (Integer integer : list) {\r\n+        sum = sum + integer;\r\n+      }\r\n \t\treturn sum;\r\n \t}\r\n \t\r\n@@ -149,9 +148,9 @@ public static int sum(List<Integer> list) {\n \t\r\n \tpublic static int sum(int[] array) {\r\n \t\tint sum=0;\r\n-\t\tfor(int i=0;i<array.length;i++) {\r\n-\t\t\tsum=sum+array[i];\r\n-\t\t}\r\n+      for (int value : array) {\r\n+        sum = sum + value;\r\n+      }\r\n \t\treturn sum;\r\n \t}\r\n \t\r\n@@ -172,15 +171,19 @@ public static int atomOccurrunce(String[] info) {\n \t}\r\n \t\r\n \tpublic static int[] actArray(int[] strip, Permutation p) {\r\n+\t\treturn getInts(strip, p);\r\n+\t}\r\n+\r\n+\tstatic int[] getInts(int[] strip, Permutation p) {\r\n \t\tint permLength= p.size();\r\n \t\tint arrayLength=strip.length;\r\n \t\tint[] modified = new int[arrayLength];\r\n \t\tfor(int i=0; i<permLength;i++) {\r\n-\t\t\tmodified[p.get(i)]=strip[i]; \r\n+\t\t\tmodified[p.get(i)]=strip[i];\r\n \t\t}\r\n \t\treturn modified;\r\n \t}\r\n-\t\r\n+\r\n \t/**\r\n \t  * Values for an id permutation for a given size\r\n \t  * @param size \r\n@@ -199,8 +202,7 @@ public static int atomOccurrunce(String[] info) {\n \t  */\r\n \t \r\n \t public static Permutation idPermutation(int size) {\r\n-\t\t Permutation perm= new Permutation(size);\r\n-\t\t return perm;\r\n+\t\t return new Permutation(size);\r\n \t }\r\n \t \r\n \t /**\r\n@@ -219,8 +221,8 @@ public static Permutation idPermutation(int size) {\n \t  * @param formula  String molecular formula\r\n \t  */\r\n \t \r\n-\t public static List<String> firstSymbols= new ArrayList<String>();\r\n-\t public static ArrayList<Integer> firstOccurrences = new ArrayList<Integer>();\r\n+\t public static List<String> firstSymbols= new ArrayList<>();\r\n+\t public static ArrayList<Integer> firstOccurrences = new ArrayList<>();\r\n \t public static void getSymbolsOccurrences(String formula) {\r\n \t\t String[] atoms = formula.split(\"(?=[A-Z])\");\r\n \t\t for(String atom : atoms) {\r\n@@ -273,24 +275,25 @@ public static void initialDegrees(){\n \t  * If provided, fragments are also added.\r\n \t  * @param mol molecular information\r\n \t  * @return atom container new atom container\r\n-\t  * @throws IOException\r\n-\t  * @throws CloneNotSupportedException\r\n-\t  * @throws CDKException\r\n \t  */\r\n \t\t\r\n-\t public static void build(String mol) throws IOException, CloneNotSupportedException, CDKException {\r\n-\t\t for(int i=0;i<firstSymbols.size();i++) {\r\n-\t\t\t for(int j=0;j<firstOccurrences.get(i);j++) {\r\n-\t\t\t\t atomContainer.addAtom(new Atom(firstSymbols.get(i)));\r\n-\t\t\t }\r\n-\t\t }\r\n-\t\t    \r\n-\t\t for(IAtom atom: atomContainer.atoms()) {\r\n-\t\t\t atom.setImplicitHydrogenCount(0);\r\n-\t\t }\r\n+\t public static void build(String mol) {\r\n+\t\t generateAtom(firstSymbols, firstOccurrences, atomContainer);\r\n \t }\r\n-\t\r\n-\t /**\r\n+\r\n+\tprivate static void generateAtom(List<String> firstSymbols, ArrayList<Integer> firstOccurrences, IAtomContainer atomContainer) {\r\n+\t\tfor(int i = 0; i< firstSymbols.size(); i++) {\r\n+\t\t\tfor(int j = 0; j< firstOccurrences.get(i); j++) {\r\n+\t\t\t\tatomContainer.addAtom(new Atom(firstSymbols.get(i)));\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t\tfor(IAtom atom: atomContainer.atoms()) {\r\n+\t\t\tatom.setImplicitHydrogenCount(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n \t  * Building an atom container for an adjacency matrix\r\n \t  * @param mat int[][] adjacency matrix\r\n \t  * @return\r\n@@ -302,7 +305,7 @@ public static IAtomContainer buildC(int[][] mat) throws CloneNotSupportedExcepti\n \t\t for(int i=0;i<mat.length;i++) {\r\n \t\t\t for(int j=i+1;j<mat.length;j++) {\r\n \t\t\t\t if(mat[i][j]==1) {\r\n-\t\t\t\t\t ac2.addBond(i, j, Order.SINGLE);;\r\n+\t\t\t\t\t ac2.addBond(i, j, Order.SINGLE);\r\n \t\t\t\t }else if(mat[i][j]==2) {\r\n \t\t\t\t\t ac2.addBond(i, j, Order.DOUBLE);\r\n \t\t\t\t }else if(mat[i][j]==3) {\r\n@@ -373,35 +376,39 @@ public static boolean equalBlockCheck(ArrayList<Integer> partition, int index, i\n \t public static boolean equalCheck(int[] former, int[] current, ArrayList<Integer> partition) {\r\n \t\t boolean check=true;\r\n \t\t int i=0;\r\n-\t\t for(int k=0;k<partition.size();k++) {\r\n-\t\t\t Integer[] can= getBlocks(former,i,partition.get(k)+i);\r\n-\t\t\t Integer[] org= getBlocks(current,i,partition.get(k)+i); \r\n-\t\t\t if(!Arrays.equals(can,org)) {\r\n-\t\t\t\t check=false;\r\n-\t\t\t\t break;\r\n-\t\t\t }else {\r\n-\t\t\t\t i=i+partition.get(k);\r\n-\t\t\t\t continue;\r\n-\t\t\t }\r\n-\t\t }\r\n+       for (Integer integer : partition) {\r\n+         Integer[] can = getBlocks(former, i, integer + i);\r\n+         Integer[] org = getBlocks(current, i, integer + i);\r\n+         if (!Arrays.equals(can, org)) {\r\n+           check = false;\r\n+           break;\r\n+         } else {\r\n+           i = i + integer;\r\n+           continue;\r\n+         }\r\n+       }\r\n \t\t return check;\r\n \t }\r\n \t \r\n \t public static int[] descendingSort(int[] array, int index0, int index1) {\r\n-\t\t int temp=0;\r\n-\t\t for (int i = index0; i < index1; i++) {     \r\n-\t\t\t for (int j = i+1; j < index1; j++) {     \r\n-\t\t\t\t if(array[i] < array[j]) {    \r\n-\t\t\t\t\t temp = array[i];    \r\n-\t                 array[i] = array[j];    \r\n-\t                 array[j] = temp;    \r\n-\t             }     \r\n-\t         }     \r\n-\t\t }\r\n-\t\t return array;\r\n+\t\t return getInts(array, index0, index1);\r\n \t }\r\n-\t \r\n-\t public static int[] descendingSortWithPartition(int[] array, ArrayList<Integer> partition) {\r\n+\r\n+\tstatic int[] getInts(int[] array, int index0, int index1) {\r\n+\t\tint temp=0;\r\n+\t\tfor (int i = index0; i < index1; i++) {\r\n+\t\t\tfor (int j = i+1; j < index1; j++) {\r\n+\t\t\t\tif(array[i] < array[j]) {\r\n+\t\t\t\t\ttemp = array[i];\r\n+\t\t\t\t\tarray[i] = array[j];\r\n+\t\t\t\t\tarray[j] = temp;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn array;\r\n+\t}\r\n+\r\n+\tpublic static int[] descendingSortWithPartition(int[] array, ArrayList<Integer> partition) {\r\n \t\t int i=0;\r\n \t\t for(Integer p:partition) {\r\n \t\t\t array=descendingSort(array,i,i+p);\r\n@@ -568,36 +575,44 @@ public static void genStrip(int[] degreeList) throws IOException, CloneNotSuppor\n \t}\r\n \t\r\n     public static int[] successor(int[] indices, int size) {\r\n-    \tint i0= indices[0];\r\n-    \tint i1= indices[1];\r\n-    \tif(i1<(size-1)) {\r\n-    \t\t indices[0]=i0;\r\n-    \t\t indices[1]=(i1+1);\r\n-    \t}else if(i0<(size-2) && i1==(size-1)) {\r\n-    \t\t indices[0]=(i0+1);\r\n-    \t\t indices[1]=(i0+2);\r\n-    \t}\r\n-    \treturn indices;\r\n-    }\r\n-    \r\n-    public static int[] predecessor(int[] indices, int size) {\r\n-    \tint i0= indices[0];\r\n-   \t \tint i1= indices[1];\r\n-   \t \tif(i0==i1-1) {\r\n-   \t \t\tindices[0]=(i0-1);\r\n-   \t \t\tindices[1]=(size-1);\r\n-   \t \t}else {\r\n-   \t \t\tindices[0]=i0;\r\n-   \t \t\tindices[1]=(i1-1);\r\n-   \t \t}\r\n-   \t \treturn indices;\r\n-    }\r\n-    \r\n+\t\treturn getInts(indices, size);\r\n+\t}\r\n+\r\n+\tstatic int[] getInts(int[] indices, int size) {\r\n+\t\tint i0= indices[0];\r\n+\t\tint i1= indices[1];\r\n+\t\tif(i1<(size-1)) {\r\n+\t\t\t indices[0]=i0;\r\n+\t\t\t indices[1]=(i1+1);\r\n+\t\t}else if(i0<(size-2) && i1==(size-1)) {\r\n+\t\t\t indices[0]=(i0+1);\r\n+\t\t\t indices[1]=(i0+2);\r\n+\t\t}\r\n+\t\treturn indices;\r\n+\t}\r\n+\r\n+\tpublic static int[] predecessor(int[] indices, int size) {\r\n+\t\treturn getIndices(indices, size);\r\n+\t}\r\n+\r\n+\tstatic int[] getIndices(int[] indices, int size) {\r\n+\t\tint i0= indices[0];\r\n+\t\tint i1= indices[1];\r\n+\t\tif(i0==i1-1) {\r\n+\t\t\tindices[0]=(i0-1);\r\n+\t\t\tindices[1]=(size-1);\r\n+\t\t}else {\r\n+\t\t\tindices[0]=i0;\r\n+\t\t\tindices[1]=(i1-1);\r\n+\t\t}\r\n+\t\treturn indices;\r\n+\t}\r\n+\r\n \tpublic static int[][] nextStep(int[][] A, int[] indices,boolean callForward) throws IOException, CloneNotSupportedException, CDKException{\r\n \t\tif(callForward) {\r\n-\t\t\treturn forwardRow(A, indices,callForward);\r\n+\t\t\treturn forwardRow(A, indices);\r\n \t\t}else {\r\n-\t\t\treturn backwardDemo(A,indices,callForward);\r\n+\t\t\treturn backwardDemo(A,indices);\r\n \t\t} \r\n \t}\r\n \t\r\n@@ -666,14 +681,14 @@ public static boolean backwardCriteria(int x, int lInverse, int l) {\n \t  * \r\n \t  * Backward step in the algorithm.\r\n \t  * \r\n-\t  * @param A \t\t\tint[][] adjacency matrix\r\n-\t  * @param indices \t\tArrayList<Integer> indices\r\n-\t  * @throws IOException \r\n+\t  * @param A            int[][] adjacency matrix\r\n+\t  * @param indices        ArrayList<Integer> indices\r\n+\t  * @throws IOException\r\n \t  * @throws CloneNotSupportedException\r\n \t  * @throws CDKException\r\n \t  */\r\n \t \r\n-\t public static int[][] backwardDemo(int[][] A, int[] indices, boolean callForward) throws IOException, CloneNotSupportedException, CDKException {\r\n+\t public static int[][] backwardDemo(int[][] A, int[] indices) throws IOException, CloneNotSupportedException, CDKException {\r\n \t\tint i=indices[0];\r\n \t\tint j=indices[1];\t\t\t\r\n \t\tif(i==0 && j==1) {\r\n@@ -690,21 +705,22 @@ public static boolean backwardCriteria(int x, int lInverse, int l) {\n \t\t\t/**\r\n \t\t\t * I changed in backcriteria from x to x-1 but then I had error c6h6 was 98 not 217\r\n \t\t\t */\r\n-\t\t\tif(x>0 && (backwardCriteria((x),l2,L[i][j]) && backwardCriteria((x),c2,C[i][j]))){\r\n+          boolean callForward;\r\n+          if(x>0 && (backwardCriteria((x),l2,L[i][j]) && backwardCriteria((x),c2,C[i][j]))){\r\n \t\t\t\tA[i][j]=(x-1);\r\n \t\t\t\tA[j][i]=(x-1);\r\n \t\t\t\tindices = successor(indices,max.length);\r\n \t\t\t\tupdateR(indices);\r\n-\t\t\t\tcallForward=true;\r\n-\t\t\t\treturn nextStep(A,indices,callForward);\r\n+\t\t\t\tcallForward =true;\r\n+\t\t\t\treturn nextStep(A,indices, callForward);\r\n \t\t\t}else {\r\n-\t\t\t\tcallForward=false;\r\n-\t\t\t\treturn nextStep(A,indices,callForward);\r\n+\t\t\t\tcallForward =false;\r\n+\t\t\t\treturn nextStep(A,indices, callForward);\r\n \t\t\t}\r\n \t\t}\r\n \t }\r\n \t \r\n-\tpublic static int[][] forwardRow(int[][] A, int[] indices, boolean callForward) throws IOException, CloneNotSupportedException, CDKException {\r\n+\tpublic static int[][] forwardRow(int[][] A, int[] indices) throws IOException, CloneNotSupportedException, CDKException {\r\n \t\tint i=indices[0];\r\n \t\tint j=indices[1];\r\n \t\tint lInverse= LInverse(degrees,i,j,A);\r\n@@ -716,19 +732,19 @@ public static boolean backwardCriteria(int x, int lInverse, int l) {\n \t\t * First step in the forward method.\r\n \t\t */\r\n \t\t \r\n-\t\tint maximumValue = forwardMaximal(minimal, lInverse, L[i][j], cInverse, C[i][j]); \r\n-\t\tcallForward=true;\r\n+\t\tint maximumValue = forwardMaximal(minimal, lInverse, L[i][j], cInverse, C[i][j]);\r\n+      boolean callForward = true;\r\n \t\tif(j==(max.length-1)) {\r\n-\t\t\tint[][] newMat= forwardSubRow(lInverse, cInverse, maximumValue, i, j,A,indices,callForward);\r\n-\t\t\treturn newMat;\r\n+\t\t\treturn forwardSubRow(lInverse, cInverse, maximumValue, i, j,A,indices);\r\n \t\t}else {\r\n-\t\t\treturn forwardSubRow(lInverse, cInverse, maximumValue, i, j,A,indices,callForward); \r\n+\t\t\treturn forwardSubRow(lInverse, cInverse, maximumValue, i, j,A,indices);\r\n \t\t}  \r\n \t} \r\n \t\r\n \t\r\n-\tpublic static int[][] forwardSubRow(int lInverse, int cInverse, int maximalX,int i, int j, int[][] A, int[] indices, boolean callForward) throws CloneNotSupportedException, CDKException, IOException {\r\n-\t\t if(((lInverse-maximalX)<=L[i][j]) && ((cInverse-maximalX)<=C[i][j])) {\r\n+\tpublic static int[][] forwardSubRow(int lInverse, int cInverse, int maximalX, int i, int j, int[][] A, int[] indices) throws CloneNotSupportedException, CDKException, IOException {\r\n+      boolean callForward;\r\n+      if(((lInverse-maximalX)<=L[i][j]) && ((cInverse-maximalX)<=C[i][j])) {\r\n \t\t\t A[i][j]=maximalX;\r\n \t\t\t A[j][i]=maximalX;\r\n \t\t\t if(i==(max.length-2) && j==(max.length-1)) {\r\n@@ -737,9 +753,7 @@ public static boolean backwardCriteria(int x, int lInverse, int l) {\n \t\t\t\t\t//A=addHydrogens(A,hIndex);\r\n \t\t\t\t\tint[][] mat2= new int[A.length][A.length]; \r\n \t\t\t\t\tfor(int k=0;k<A.length;k++) {\r\n-\t\t\t\t\t\tfor(int l=0;l<A.length;l++) {\r\n-\t\t\t\t\t\t\tmat2[k][l]=A[k][l];\r\n-\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tSystem.arraycopy(A[k], 0, mat2[k], 0, A.length);\r\n \t\t\t\t\t}\r\n \t\t\t\t\t//IAtomContainer molden= buildC(addHydrogens(mat2,hIndex));\r\n \t\t\t\t\tif(connectivityTest(hIndex,addHydrogens(mat2,hIndex))){\r\n@@ -770,11 +784,11 @@ public static boolean backwardCriteria(int x, int lInverse, int l) {\n \t\t\t\t\t\tcount++;\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n-\t\t\t\tcallForward=false;\r\n+\t\t\t\tcallForward =false;\r\n \t\t\t\treturn nextStep(A, indices, callForward);\r\n \t\t\t}else {\t\r\n \t\t\t\tif(indices[0]==findZ(r) && indices[1]==(max.length-1)) {\r\n-\t\t\t\t\tcallForward=canonicalTest(A);\r\n+\t\t\t\t\tcallForward =canonicalTest(A);\r\n \t\t\t\t\tif(callForward) {\r\n \t\t\t\t\t\tindices=successor(indices,max.length);\r\n \t\t\t\t\t\tupdateR(indices);\r\n@@ -791,8 +805,8 @@ public static boolean backwardCriteria(int x, int lInverse, int l) {\n \t\t\t    }\r\n \t\t\t}\r\n \t\t }else {\r\n-\t\t\t callForward=false;\r\n-\t\t\t return nextStep(A, indices,callForward);\r\n+\t\t\t callForward =false;\r\n+\t\t\t return nextStep(A, indices, callForward);\r\n \t\t }\r\n \t }\r\n \t\r\n@@ -848,7 +862,7 @@ public static int CInverse(int[] degrees, int i, int j, int[][]A) {\n \t  */\r\n \t \r\n \t public static ArrayList<Integer> getPartition(int[] degrees, ArrayList<Integer> partition){\r\n-    \t ArrayList<Integer> newPartition = new ArrayList<Integer>();\r\n+    \t ArrayList<Integer> newPartition = new ArrayList<>();\r\n \t\t int i=0;\r\n     \t for(Integer p:partition) {\r\n     \t\t Integer[] subArray= getBlocks(degrees,i,p+i);\r\n@@ -860,7 +874,7 @@ public static int CInverse(int[] degrees, int i, int j, int[][]A) {\n \t \r\n \t\r\n \t public static ArrayList<Integer> getSubPartition(Integer[] degrees){\r\n-\t\t ArrayList<Integer> partition = new ArrayList<Integer>();\r\n+\t\t ArrayList<Integer> partition = new ArrayList<>();\r\n \t\t int i=0;\r\n \t     int size= degrees.length;\r\n \t     int count=0;\r\n@@ -883,7 +897,7 @@ public static int nextCount(int i, int size, Integer[] degrees, ArrayList<Intege\n \t\t\t partition.add(1);\r\n \t\t }else {\r\n \t\t\t for(int j = i+1; j < size; j++){  \r\n-\t         \t if(degrees[i] == degrees[j]){  \r\n+\t         \t if(degrees[i].equals(degrees[j])){\r\n \t        \t\t count++;  \r\n \t        \t\t if(j==(size-1)){\r\n \t        \t\t\t partition.add(count);\r\n@@ -929,7 +943,7 @@ public static void run() throws IOException, CDKException, CloneNotSupportedExce\n \t  */\r\n \t\t\r\n \t public static List<int[]> distributeHydrogens(ArrayList<Integer> partition, int[] degrees) throws FileNotFoundException, UnsupportedEncodingException, CloneNotSupportedException, CDKException{\r\n-\t\t List<int[]> degreeList= new ArrayList<int[]>();\r\n+\t\t List<int[]> degreeList= new ArrayList<>();\r\n \t\t List<int[]> distributions= HydrogenDistributor.run(partition,degrees);\r\n \t\t for(int[] dist: distributions) {\r\n \t\t\t int[] newDegree= new int[size];\r\n@@ -977,7 +991,7 @@ public static void canonicalBlockbasedGeneratorDemo() throws IOException, CloneN\n \t  */\r\n \t\t \r\n \t public static Set<Integer> nValues(int index, int total, int[][] mat) {\r\n-\t\t Set<Integer> nValues= new HashSet<Integer>();\r\n+\t\t Set<Integer> nValues= new HashSet<>();\r\n \t\t nValues.add(index);\r\n \t\t int[] theRow = mat[index]; \r\n \t\t for(int i=(index+1);i<total;i++) {\r\n@@ -996,7 +1010,7 @@ public static void canonicalBlockbasedGeneratorDemo() throws IOException, CloneN\n \t  */\r\n \t\t \r\n \t public static Set<Integer> wValues(Set<Integer> nValues, int[] Kformer){\r\n-\t\t Set<Integer> wValues= new HashSet<Integer>();\r\n+\t\t Set<Integer> wValues= new HashSet<>();\r\n \t\t for(Integer i:nValues) {\r\n \t\t\t wValues.add(Kformer[i]);\r\n \t\t }\r\n@@ -1048,8 +1062,8 @@ public static boolean connectivityTest(int p, int[][] mat) {\n \t\t boolean check=false;\r\n \t\t int total= mat.length;\r\n \t\t int[] kValues=initialKList(total);\r\n-\t\t Set<Integer> nValues= new HashSet<Integer>();\r\n-\t\t Set<Integer> wValues= new HashSet<Integer>();\r\n+\t\t Set<Integer> nValues= new HashSet<>();\r\n+\t\t Set<Integer> wValues= new HashSet<>();\r\n \t\t int zValue= 0;\r\n \t\t for(int i=0;i<p;i++) {\r\n \t\t\t nValues= nValues(i, total, mat);\r\n@@ -1071,12 +1085,12 @@ public static boolean connectivityTest(int p, int[][] mat) {\n \t\t \r\n \t public static boolean allIs0(int[] list) {\r\n \t\t boolean check=true;\r\n-\t\t for(int i=0;i<list.length;i++) {\r\n-\t\t\t if(list[i]!=0) {\r\n-\t\t\t\t check=false;\r\n-\t\t\t\t break;\r\n-\t\t\t }\r\n-\t\t }\r\n+       for (int value : list) {\r\n+         if (value != 0) {\r\n+           check = false;\r\n+           break;\r\n+         }\r\n+       }\r\n \t\t return check;\r\n \t }\r\n \t \t\r\n@@ -1092,13 +1106,9 @@ public static int findZ(int r) {\n \t\t return (sum(initialPartition,r)-1);\r\n \t }\r\n \t \r\n-\t public static boolean canonicalTest(int[][] matrix) throws IOException, CloneNotSupportedException, CDKException {\r\n+\t public static boolean canonicalTest(int[][] matrix) {\r\n \t\tformerPermutationsCheck=true;\r\n-\t\tif(blockTest(r,matrix)) {\r\n-\t\t\treturn true;\r\n-\t\t }else {\r\n-\t\t\treturn false;\r\n-\t\t }\r\n+\t\t return blockTest(r, matrix);\r\n \t}\r\n \t\r\n \t/**\r\n@@ -1126,7 +1136,7 @@ public static boolean blockTest(int r, int[][] A) {\n \t}\r\n \t\r\n \tpublic static void clearFormers(boolean check, int y) {\r\n-\t\t if(check==false) {\r\n+\t\t if(!check) {\r\n \t\t\t for(int i=y;i<formerPermutations.size();i++) {\r\n \t\t\t\t formerPermutations.get(i).removeAll(formerPermutations.get(i));\r\n \t\t\t }\r\n@@ -1137,8 +1147,7 @@ public static void clearFormers(boolean check, int y) {\n \t}\r\n \t\r\n \tpublic static void candidatePermutations(int index, int y, int total, List<Permutation> cycles) {\r\n-\t\t List<Permutation> newList= new ArrayList<Permutation>();\r\n-\t\t newList.addAll(cycles);\r\n+\t\tList<Permutation> newList = new ArrayList<>(cycles);\r\n \t\t formerPermutations.add(index,newList);\r\n \t\t if(index!=0) {\r\n \t\t\t List<Permutation> formers = formerPermutations.get(index-1); \r\n@@ -1147,13 +1156,13 @@ public static void candidatePermutations(int index, int y, int total, List<Permu\n \t\t\t\t\t formerPermutations.get(index).add(form);\r\n \t\t\t\t }\r\n \t\t\t }\r\n-\t\t\t List<Permutation> newForm = new ArrayList<Permutation>();\r\n+\t\t\t List<Permutation> newForm = new ArrayList<>();\r\n \t\t\t for(Permutation frm: formers) {\r\n \t\t\t\t if(!frm.isIdentity()) {\r\n \t\t\t\t\t newForm.add(frm);\r\n \t\t\t\t }\r\n \t\t\t }\r\n-\t\t\t List<Permutation> newCycles = new ArrayList<Permutation>();\r\n+\t\t\t List<Permutation> newCycles = new ArrayList<>();\r\n \t\t\t for(Permutation cyc: cycles) {\r\n \t\t\t\t if(!cyc.isIdentity()) {\r\n \t\t\t\t\t newCycles.add(cyc);\r\n@@ -1187,12 +1196,12 @@ public static boolean blockTestPerm(int index, int r,int[][] A, ArrayList<Intege\n \t\r\n \tpublic static boolean allis1(ArrayList<Integer> partition) {\r\n \t\t boolean check=true;\r\n-\t\t for(int i=0;i<partition.size();i++) {\r\n-\t\t\t if(partition.get(i)!=1) {\r\n-\t\t\t\t check=false;\r\n-\t\t\t\t break;\r\n-\t\t\t }\r\n-\t\t }\r\n+      for (Integer integer : partition) {\r\n+        if (integer != 1) {\r\n+          check = false;\r\n+          break;\r\n+        }\r\n+      }\r\n \t\t return check;\r\n \t }\r\n \t\r\n@@ -1204,7 +1213,7 @@ public static boolean allis1(ArrayList<Integer> partition) {\n \t  */\r\n \t \r\n \t public static void addPartition(int index, ArrayList<Integer> newPartition, int[][] A) {\r\n-\t\t ArrayList<Integer> refinedPartition= new ArrayList<Integer>();\r\n+\t\t ArrayList<Integer> refinedPartition= new ArrayList<>();\r\n \t\t if(allis1(newPartition)) {\r\n \t\t\t refinedPartition=newPartition;\r\n \t\t }else {\r\n@@ -1227,7 +1236,7 @@ public static void addPartition(int index, ArrayList<Integer> newPartition, int[\n \t  */\r\n \t \r\n \t public static ArrayList<Integer> refinedPartitioning(ArrayList<Integer> partition, int[] row){\r\n-\t\t ArrayList<Integer> refined= new ArrayList<Integer>();\r\n+\t\t ArrayList<Integer> refined= new ArrayList<>();\r\n \t\t int index=0;\r\n \t\t int count=1;\r\n \t\t for(Integer p:partition) {\r\n@@ -1314,9 +1323,7 @@ public static int findIndex(int index, Permutation cycle) {\n \t public static int[] cloneArray(int[] array) {\r\n \t\t int length= array.length;\r\n \t\t int[] cloned = new int[length];\r\n-\t\t for(int i=0;i<length;i++) {\r\n-\t\t\t cloned[i]=array[i];\r\n-\t\t }\r\n+\t\t System.arraycopy(array, 0, cloned, 0, length);\r\n \t\t return cloned;\r\n \t }\r\n \t \r\n@@ -1355,7 +1362,7 @@ public static int findMatch(Integer[] max, Integer[] non, int value, int start)\n     \t int index=start;\r\n     \t for(int i=start;i<size;i++) {\r\n     \t\t if(non[i]==value) {\r\n-    \t\t\t if(max[i]!=non[i]) {\r\n+    \t\t\t if(!max[i].equals(non[i])) {\r\n     \t\t\t\t index=i;\r\n         \t\t\t break; \r\n     \t\t\t }\r\n@@ -1368,7 +1375,7 @@ public static int findMatch(Integer[] max, Integer[] non, int value, int start)\n     \t int i=0;\r\n     \t int permutationIndex=0;    \t \r\n     \t while(i<max.length && max[i]!=0) {\r\n-    \t\t if(max[i]!=non[i]) {\r\n+    \t\t if(!max[i].equals(non[i])) {\r\n         \t\t permutationIndex = findMatch(max,non, max[i],i);\r\n         \t\t if(i!=permutationIndex) {\r\n         \t\t\t non=permuteArray(non, i, permutationIndex);\r\n@@ -1410,7 +1417,7 @@ public static Permutation getCanonicalCycle(int index, int y, int total, int[][]\n \t\t \r\n \tpublic static boolean check(int index, int y, int total, int[][] A, ArrayList<Integer> partition, ArrayList<Integer> newPartition) {\r\n \t\t boolean check=true;\r\n-\t\t List<Permutation> formerList= new ArrayList<Permutation>();\r\n+\t\t List<Permutation> formerList= new ArrayList<>();\r\n \t\t for(Permutation permutation:formerPermutations.get(index)) { \r\n \t\t\t Permutation canonicalPermutation= getCanonicalCycle(index, y, total, A, partition, newPartition, permutation);\r\n \t\t\t if(biggest) {\r\n@@ -1446,7 +1453,7 @@ public static boolean check(int index, int y, int total, int[][] A, ArrayList<In\n \t\r\n \tpublic static List<Permutation> cycleTranspositions(int index, ArrayList<Integer> partition) {\r\n \t\t int total=sum(partition);\r\n-\t\t List<Permutation> perms= new ArrayList<Permutation>();\r\n+\t\t List<Permutation> perms= new ArrayList<>();\r\n \t\t int lValue = LValue(partition,index);\r\n \t\t for(int i=0;i<lValue;i++) {\r\n \t    \t int[] values= idValues(total);\r\n@@ -1502,7 +1509,7 @@ public static int LValue(ArrayList<Integer> partEx, int degree) {\n \t  */\r\n \t\t \r\n \t public static ArrayList<Integer> partitionCriteria(ArrayList<Integer> partEx, int degree){\r\n-\t\t ArrayList<Integer> partNew = new ArrayList<Integer>();\r\n+\t\t ArrayList<Integer> partNew = new ArrayList<>();\r\n \t\t partNew=addOnes(partNew,degree);\r\n \t\t /**\r\n \t\t  * I had (degree-1)\r\n@@ -1520,7 +1527,7 @@ public static int LValue(ArrayList<Integer> partEx, int degree) {\n \t\t return partNew;\r\n \t }\r\n \t \r\n-\t private void parseArgs(String[] args) throws ParseException, IOException, org.apache.commons.cli.ParseException{\r\n+\t private void parseArgs(String[] args) throws org.apache.commons.cli.ParseException{\r\n \t\t Options options = setupOptions(args);\t\r\n \t\t CommandLineParser parser = new DefaultParser();\r\n \t\t try {\r\n@@ -1568,7 +1575,7 @@ private Options setupOptions(String[] args){\n \t\t return options;\r\n \t }\r\n \t \r\n-\tpublic static void main(String[] arguments) throws IOException, CDKException, CloneNotSupportedException {\r\n+\tpublic static void main(String[] arguments) {\r\n \t\tMORGEN gen= new MORGEN();\r\n \t\t//String[] argument= {\"-f\",\"C4H8\", \"-d\", \"C:\\\\Users\\\\mehme\\\\Desktop\\\\\", \"-v\"};\r\n \t\ttry {\r"
  },
  {
    "sha": "446032f22d3f37d161c93ea84134b6bdc3448ad9",
    "filename": "src/test/java/AlgorithmicGroupTheory/MorgenTest.java",
    "status": "added",
    "additions": 18,
    "deletions": 0,
    "changes": 18,
    "blob_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/blob/aa507c8123f0f853206a95bbd295db556ea4e5ae/src/test/java/AlgorithmicGroupTheory/MorgenTest.java",
    "raw_url": "https://github.com/MehmetAzizYirik/AlgorithmicGroupTheory/raw/aa507c8123f0f853206a95bbd295db556ea4e5ae/src/test/java/AlgorithmicGroupTheory/MorgenTest.java",
    "contents_url": "https://api.github.com/repos/MehmetAzizYirik/AlgorithmicGroupTheory/contents/src/test/java/AlgorithmicGroupTheory/MorgenTest.java?ref=aa507c8123f0f853206a95bbd295db556ea4e5ae",
    "patch": "@@ -0,0 +1,18 @@\n+package AlgorithmicGroupTheory;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Test;\n+\n+public class MorgenTest {\n+\n+    @Test\n+    public void main() {\n+        String[] argument = {\"-f\", \"C3O3H4\", \"-v\", \"-d\", \"result1\"};\n+//        String[] argument2 = {\"-f\", \"C2H5NO2\", \"-v\", \"-d\", \"result2\"};\n+//        String[] argument3 = {\"-f\", \"C4H7NO3\", \"-v\", \"-d\", \"result3\"};\n+//        String[] argument4 = {\"-f\", \"C5H9N3\", \"-v\", \"-d\", \"result4\"};\n+//        List<String[]> arguments = Arrays.asList(argument1, /*argument2,*/ argument3, argument4);\n+        MORGEN.main(argument);\n+    }\n+}"
  }
]
