[
  {
    "sha": "f69eeaf63612ed9dedfb8629120f04ed07642990",
    "filename": "src/BinaryTree.java",
    "status": "added",
    "additions": 338,
    "deletions": 0,
    "changes": 338,
    "blob_url": "https://github.com/kaiuerlichs/Translator/blob/ef74e1abadd3d6a738a058ffd3ee16e23d6363b7/src/BinaryTree.java",
    "raw_url": "https://github.com/kaiuerlichs/Translator/raw/ef74e1abadd3d6a738a058ffd3ee16e23d6363b7/src/BinaryTree.java",
    "contents_url": "https://api.github.com/repos/kaiuerlichs/Translator/contents/src/BinaryTree.java?ref=ef74e1abadd3d6a738a058ffd3ee16e23d6363b7",
    "patch": "@@ -0,0 +1,338 @@\n+import java.io.Serializable;\n+import java.util.Iterator;\n+import java.util.Queue;\n+\n+/**\n+  * A class representing a Binary Tree data structure \n+  * \n+  * @author Kai Uerlichs\n+  * @version 1.0\n+  */\n+public class BinaryTree<T extends Comparable<T>> implements Iterable<T>, Serializable {\n+\n+\t/**\n+\t * Class is serialisable\n+\t */\n+\tprivate static final long serialVersionUID = 3914790424687763034L;\n+\t\n+\t/**\n+\t * The root node of the tree\n+\t */\n+\tpublic TreeNode<T> root;\n+\t\n+\t/**\n+\t * Default constructor for empty Binary Tree\n+\t */\n+\tpublic BinaryTree(){\n+\t\troot = null;\n+\t}\n+\t\n+\t/**\n+\t * Add a new data node to the tree\n+\t * \n+\t * @param newData The data to add\n+\t * @throws NodeExistsAlreadyException If the node already exists in the tree\n+\t */\n+\tpublic void add(T newData) throws NodeExistsAlreadyException {\n+\t\tif(isEmpty()) {\n+\t\t\troot = new TreeNode<T>(newData);\n+\t\t}\n+\t\telse {\n+\t\t\troot.add(newData);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Find a node in the tree and return it\n+\t * @param dataKey The data to search for\n+\t * @return The data to search for\n+\t * @throws TreeIsEmptyException If no nodes are in the tree\n+\t * @throws NodeNotFoundException If the node does not exist in the tree\n+\t */\n+\tpublic T find(T dataKey) throws TreeIsEmptyException, NodeNotFoundException {\n+\t\t// If the tree is not empty\n+\t\tif(!isEmpty()) {\n+\t\t\t// Recursively search the tree for the node\n+\t\t\tTreeNode<T> temp = root.find(dataKey);\n+\t\t\tif(temp != null) {\n+\t\t\t\treturn temp.getData();\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t// Throw exception if node was not found\n+\t\t\t\tthrow new NodeNotFoundException();\n+\t\t\t}\n+\t\t}\n+\t\t// If the tree is empty\n+\t\telse {\n+\t\t\tthrow new TreeIsEmptyException();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Print the nodes of the tree in in-order\n+\t * @throws TreeIsEmptyException If the tree is empty\n+\t */\n+\tpublic void printInorder() throws TreeIsEmptyException {\n+\t\tif(!isEmpty()) {\n+\t\t\t// Use default iterator to go through each element\n+\t\t\tfor(T el : this) {\n+\t\t\t\tSystem.out.println(el);\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tthrow new TreeIsEmptyException();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Print the nodes of the tree in pre-order\n+\t * @throws TreeIsEmptyException If the tree is empty\n+\t */\n+\tpublic void printPreorder() throws TreeIsEmptyException {\n+\t\tif(!isEmpty()) {\n+\t\t\tIterator<T> i = preorderIterator();\n+\t\t\twhile(i.hasNext()) {\n+\t\t\t\tSystem.out.println(i.next());\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tthrow new TreeIsEmptyException();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Print the nodes of the tree in post-order\n+\t * @throws TreeIsEmptyException If the tree is empty\n+\t */\n+\tpublic void printPostorder() throws TreeIsEmptyException {\n+\t\tif(!isEmpty()) {\n+\t\t\tIterator<T> i = postorderIterator();\n+\t\t\twhile(i.hasNext()) {\n+\t\t\t\tSystem.out.println(i.next());\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tthrow new TreeIsEmptyException();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Check if the tree is empty or not\n+\t * @return True or false if the tree is empty or not empty respectively\n+\t */\n+\tpublic boolean isEmpty() {\n+\t\treturn root == null;\n+\t}\n+\t\n+\t/**\n+\t * Remove a node from the tree\n+\t * @param key The data to remove\n+\t * @throws NodeNotFoundException If the node does not exist\n+\t * @throws TreeIsEmptyException If the tree is empty\n+\t * @return The node that was removed\n+\t */\n+\tpublic T remove(T key) throws NodeNotFoundException, TreeIsEmptyException {\n+\t\t// If the tree is not empty\n+\t\tif(!isEmpty()) {\n+\t\t\t// Check whether root is node to remove\n+\t\t\tint cmp = root.getData().compareTo(key);\n+\t\t\tif(cmp == 0) {\n+\t\t\t\tT result = root.getData();\n+\t\t\t\t// Remove root node\n+\t\t\t\t// Two children\n+\t\t\t\tif(root.getLeft() != null && root.getRight() != null) {\n+\t\t\t\t\tT maxValue = root.getLeft().findMax().getData();\n+\t\t\t\t\tremove(maxValue);\n+\t\t\t\t\troot.setData(maxValue);\n+\t\t\t\t}\n+\t\t\t\t// One or no children\n+\t\t\t\telse {\n+\t\t\t\t\tif(root.getLeft() != null) {\n+\t\t\t\t\t\troot = root.getLeft();\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\troot = root.getRight();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t\t// If root is not the node to remove\n+\t\t\telse {\n+\t\t\t\tTreeNode<T> previous = root;\n+\t\t\t\tTreeNode<T> current = null;\n+\t\t\t\t// Select next node\n+\t\t\t\tif(cmp > 0) {\n+\t\t\t\t\tcurrent = root.getLeft();\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tcurrent = root.getRight();\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\t// Search tree using while loop\n+\t\t\t\tboolean found = false;\n+\t\t\t\twhile(!found) {\n+\t\t\t\t\t// Node does not exist\n+\t\t\t\t\tif(current == null) {\n+\t\t\t\t\t\tthrow new NodeNotFoundException();\n+\t\t\t\t\t}\n+\t\t\t\t\t// Node might exist\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tcmp = current.getData().compareTo(key);\n+\t\t\t\t\t\tif(cmp > 0) {\n+\t\t\t\t\t\t\tprevious = current;\n+\t\t\t\t\t\t\tcurrent = current.getLeft();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse if(cmp < 0) {\n+\t\t\t\t\t\t\tprevious = current;\n+\t\t\t\t\t\t\tcurrent = current.getRight();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\tfound = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\tT result = current.getData();\n+\t\t\t\t// If node has two children\n+\t\t\t\tif(current.getLeft() != null && current.getRight() != null) {\n+\t\t\t\t\tT maxValue = current.getLeft().findMax().getData();\n+\t\t\t\t\tremove(maxValue);\n+\t\t\t\t\tcurrent.setData(maxValue);\n+\t\t\t\t}\n+\t\t\t\t// If node has one or no children\n+\t\t\t\telse {\n+\t\t\t\t\tif(previous.getData().compareTo(key) > 0) {\n+\t\t\t\t\t\tif(current.getLeft() != null) {\n+\t\t\t\t\t\t\tprevious.setLeft(current.getLeft());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\tprevious.setLeft(current.getRight());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tif(current.getLeft() != null) {\n+\t\t\t\t\t\t\tprevious.setRight(current.getLeft());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\tprevious.setRight(current.getRight());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t\t// If tree is empty\n+\t\telse {\n+\t\t\tthrow new TreeIsEmptyException();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Override for the iterator() method of the Iterable interface\n+\t * and returns the iterator in in-order\n+\t */\n+\t@Override\n+\tpublic Iterator<T> iterator() {\n+\t\treturn new InorderIterator();\n+\t}\n+\t\n+\t/**\n+\t * Alternative iterator in pre-order\n+\t * @return an Iterator over type T\n+\t */\n+\tpublic Iterator<T> preorderIterator() {\n+\t\treturn new PreorderIterator();\n+\t}\n+\t\n+\t/**\n+\t * Alternative iterator in post-order\n+\t * @return an Iterator over type T\n+\t */\n+\tpublic Iterator<T> postorderIterator() {\n+\t\treturn new PostorderIterator();\n+\t}\n+\t\n+\t/**\n+\t * Class definining an in-order iterator for the BinaryTree\n+\t * @author Kai Uerlichs\n+\t * @version 1.0\n+\t */\n+\tpublic class InorderIterator implements Iterator<T> {\n+\n+\t\tprivate Queue<T> i;\n+\t\t\n+\t\t/**\n+\t\t * Default constructor\n+\t\t */\n+\t\tpublic InorderIterator(){\n+\t\t\ti = root.getInorderQueue();\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic boolean hasNext() {\n+\t\t\treturn !i.isEmpty();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic T next() {\n+\t\t\treturn i.remove();\n+\t\t}\n+\t\t\n+\t}\n+\t\n+\t/**\n+\t * Class definining an pre-order iterator for the BinaryTree\n+\t * @author Kai Uerlichs\n+\t * @version 1.0\n+\t */\n+\tpublic class PreorderIterator implements Iterator<T> {\n+\n+\t\tprivate Queue<T> i;\n+\t\t\n+\t\t/**\n+\t\t * Default constructor\n+\t\t */\n+\t\tpublic PreorderIterator(){\n+\t\t\ti = root.getPreorderQueue();\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic boolean hasNext() {\n+\t\t\treturn !i.isEmpty();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic T next() {\n+\t\t\treturn i.remove();\n+\t\t}\n+\t\t\n+\t}\n+\t\n+\t/**\n+\t * Class definining an post-order iterator for the BinaryTree\n+\t * @author Kai Uerlichs\n+\t * @version 1.0\n+\t */\n+\tpublic class PostorderIterator implements Iterator<T> {\n+\n+\t\tprivate Queue<T> i;\n+\t\t\n+\t\t/**\n+\t\t * Default constructor\n+\t\t */\n+\t\tpublic PostorderIterator(){\n+\t\t\ti = root.getPostorderQueue();\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic boolean hasNext() {\n+\t\t\treturn !i.isEmpty();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic T next() {\n+\t\t\treturn i.remove();\n+\t\t}\n+\t}\n+\t\n+}"
  },
  {
    "sha": "4e19a180cb6884e2064a3862fc7c26b9ceaa440b",
    "filename": "src/NodeExistsAlreadyException.java",
    "status": "added",
    "additions": 13,
    "deletions": 0,
    "changes": 13,
    "blob_url": "https://github.com/kaiuerlichs/Translator/blob/ef74e1abadd3d6a738a058ffd3ee16e23d6363b7/src/NodeExistsAlreadyException.java",
    "raw_url": "https://github.com/kaiuerlichs/Translator/raw/ef74e1abadd3d6a738a058ffd3ee16e23d6363b7/src/NodeExistsAlreadyException.java",
    "contents_url": "https://api.github.com/repos/kaiuerlichs/Translator/contents/src/NodeExistsAlreadyException.java?ref=ef74e1abadd3d6a738a058ffd3ee16e23d6363b7",
    "patch": "@@ -0,0 +1,13 @@\n+/**\n+ * Exception thrown upon attempting to add a node to a Binary Tree that it already contains\n+ * @author Kai Uerlichs\n+ * @version 1.0\n+ */\n+public class NodeExistsAlreadyException extends Exception {\n+\n+\t/**\n+\t * Exception is serialisable\n+\t */\n+\tprivate static final long serialVersionUID = -1312932506632288046L;\n+\n+}"
  },
  {
    "sha": "041c852081d94e50bbe894057f5a674ec4f52322",
    "filename": "src/NodeNotFoundException.java",
    "status": "added",
    "additions": 12,
    "deletions": 0,
    "changes": 12,
    "blob_url": "https://github.com/kaiuerlichs/Translator/blob/ef74e1abadd3d6a738a058ffd3ee16e23d6363b7/src/NodeNotFoundException.java",
    "raw_url": "https://github.com/kaiuerlichs/Translator/raw/ef74e1abadd3d6a738a058ffd3ee16e23d6363b7/src/NodeNotFoundException.java",
    "contents_url": "https://api.github.com/repos/kaiuerlichs/Translator/contents/src/NodeNotFoundException.java?ref=ef74e1abadd3d6a738a058ffd3ee16e23d6363b7",
    "patch": "@@ -0,0 +1,12 @@\n+/**\n+ * Exception thrown when a node is not existent in a given Binary Tree\n+ * @author Kai Uerlichs\n+ * @version 1.0\n+ */\n+public class NodeNotFoundException extends Exception {\n+\n+\t/**\n+\t * Exception is serialisable\n+\t */\n+\tprivate static final long serialVersionUID = -7198196270477398209L;\n+}"
  },
  {
    "sha": "d792e710d476d003ec41b71d1ab5890d50fe5128",
    "filename": "src/TreeIsEmptyException.java",
    "status": "added",
    "additions": 13,
    "deletions": 0,
    "changes": 13,
    "blob_url": "https://github.com/kaiuerlichs/Translator/blob/ef74e1abadd3d6a738a058ffd3ee16e23d6363b7/src/TreeIsEmptyException.java",
    "raw_url": "https://github.com/kaiuerlichs/Translator/raw/ef74e1abadd3d6a738a058ffd3ee16e23d6363b7/src/TreeIsEmptyException.java",
    "contents_url": "https://api.github.com/repos/kaiuerlichs/Translator/contents/src/TreeIsEmptyException.java?ref=ef74e1abadd3d6a738a058ffd3ee16e23d6363b7",
    "patch": "@@ -0,0 +1,13 @@\n+/**\n+ * Exception thrown when actions are performed on an empty Binary Tree\n+ * @author Kai Uerlichs\n+ * @version 1.0\n+ */\n+public class TreeIsEmptyException extends Exception {\n+\n+\t/**\n+\t * Exception is serialisable\n+\t */\n+\tprivate static final long serialVersionUID = -8636692877267652452L;\n+\n+}"
  },
  {
    "sha": "fecf122840f59a456138cd065a68c1dcea376f5d",
    "filename": "src/TreeNode.java",
    "status": "added",
    "additions": 258,
    "deletions": 0,
    "changes": 258,
    "blob_url": "https://github.com/kaiuerlichs/Translator/blob/ef74e1abadd3d6a738a058ffd3ee16e23d6363b7/src/TreeNode.java",
    "raw_url": "https://github.com/kaiuerlichs/Translator/raw/ef74e1abadd3d6a738a058ffd3ee16e23d6363b7/src/TreeNode.java",
    "contents_url": "https://api.github.com/repos/kaiuerlichs/Translator/contents/src/TreeNode.java?ref=ef74e1abadd3d6a738a058ffd3ee16e23d6363b7",
    "patch": "@@ -0,0 +1,258 @@\n+import java.io.Serializable;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+/**\n+ * Class representing a node in a Binary Tree data structures\n+ * @author Kai Uerlichs\n+ * @version 1.0\n+ */\n+public class TreeNode<T extends Comparable<T>> implements Serializable {\n+\t\n+\t/**\n+\t * Class is serialisable\n+\t */\n+\tprivate static final long serialVersionUID = -4948132557529734259L;\n+\t\n+\t/**\n+\t * The data of this node\n+\t */\n+\tprivate T data;\n+\t\n+\t/**\n+\t * Reference to the left node from this node\n+\t */\n+\tprivate TreeNode<T> left;\n+\t\n+\t/**\n+\t * Reference to the right node from this node\n+\t */\n+\tprivate TreeNode<T> right;\n+\t\n+\t/**\n+\t * Default constructor for TreeNode object\n+\t * @param newData The data to set the node data field to\n+\t */\n+\tpublic TreeNode(T newData) {\n+\t\tdata = newData;\n+\t\tleft = null;\n+\t\tright = null;\n+\t}\n+\t\n+\t/**\n+\t * Returns the data of the node\n+\t * @return the data\n+\t */\n+\tpublic T getData() {\n+\t\treturn data;\n+\t}\n+\t\n+\t/**\n+\t * Sets the data of the node\n+\t * @param newData the data to set\n+\t */\n+\tpublic void setData(T newData) {\n+\t\tdata = newData;\n+\t}\n+\t\n+\t/**\n+\t * The left child of the node\n+\t * @return The left child\n+\t */\n+\tpublic TreeNode<T> getLeft(){\n+\t\treturn left;\n+\t}\n+\t\n+\t/**\n+\t * The right child of the node\n+\t * @return The right child\n+\t */\n+\tpublic TreeNode<T> getRight(){\n+\t\treturn right;\n+\t}\n+\t\n+\t/**\n+\t * Sets the left child of the node\n+\t * @param node The node to set the left child to\n+\t */\n+\tpublic void setLeft(TreeNode<T> node){\n+\t\tleft = node;\n+\t}\n+\t\n+\t/**\n+\t * Sets the right child of the node\n+\t * @param node The node to set the right child to\n+\t */\n+\tpublic void setRight(TreeNode<T> node){\n+\t\tright = node;\n+\t}\n+\n+\t/**\n+\t * Recursive method used to add a new node to the Binary Tree\n+\t * @param newData The data to set\n+\t * @throws NodeExistsAlreadyException When the node already exists in the tree\n+\t */\n+\tpublic void add(T newData) throws NodeExistsAlreadyException {\n+\t\tint cmp = data.compareTo(newData);\n+\t\tif(cmp > 0){\n+\t\t\tif(left == null) {\n+\t\t\t\tleft = new TreeNode<T>(newData);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tleft.add(newData);\n+\t\t\t}\n+\t\t}\n+\t\telse if (cmp < 0){\n+\t\t\tif(right == null) {\n+\t\t\t\tright = new TreeNode<T>(newData);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tright.add(newData);\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tthrow new NodeExistsAlreadyException();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Recursive method to find a node in the tree\n+\t * @param dataKey The node to find\n+\t * @return The found node\n+\t */\n+\tpublic TreeNode<T> find(T dataKey) {\n+\t\tint cmp = data.compareTo(dataKey);\n+\t\tif(cmp == 0) {\n+\t\t\treturn this;\n+\t\t}\n+\t\telse if(cmp > 0) {\n+\t\t\tif(left != null) {\n+\t\t\t\treturn left.find(dataKey);\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tif(right != null) {\n+\t\t\t\treturn right.find(dataKey);\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\t\n+//\tOld print methods (deprecated due to Iterators)\n+\t\n+//\tpublic void printInorder(){\n+//\t\tif(left != null) {\n+//\t\t\tleft.printInorder();\n+//\t\t}\n+//\t\tSystem.out.println(data);\n+//\t\tif(right != null) {\n+//\t\t\tright.printInorder();\n+//\t\t}\n+//\t}\n+//\t\n+//\tpublic void printPreorder(){\n+//\t\tSystem.out.println(data);\n+//\t\tif(left != null) {\n+//\t\t\tleft.printInorder();\n+//\t\t}\n+//\t\tif(right != null) {\n+//\t\t\tright.printInorder();\n+//\t\t}\n+//\t}\n+//\t\n+//\tpublic void printPostorder(){\n+//\t\tif(left != null) {\n+//\t\t\tleft.printInorder();\n+//\t\t}\n+//\t\tif(right != null) {\n+//\t\t\tright.printInorder();\n+//\t\t}\n+//\t\tSystem.out.println(data);\n+//\t}\n+\t\n+\t/**\n+\t * Returns the tree node with the maximum data value in the tree with this object as its root\n+\t * @return The found node\n+\t */\n+\tpublic TreeNode<T> findMax() {\n+\t\tif(right != null) {\n+\t\t\treturn right.findMax();\n+\t\t}\n+\t\telse {\n+\t\t\treturn this;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Returns the tree with this node as root as an in-order Queue\n+\t * @return the Queue\n+\t */\n+\tpublic Queue<T> getInorderQueue(){\n+\t\tQueue<T> i = new LinkedList<T>();\n+\t\tthis.makeInorderQueue(i);\n+\t\treturn i;\n+\t}\n+\t\n+\t/**\n+\t * Recursive method to traverse and fill the queue in-order\n+\t * @param i The queue to fill\n+\t */\n+\tprivate void makeInorderQueue(Queue<T> i) {\n+\t\tif(left != null) {\n+\t\t\tleft.makeInorderQueue(i);\n+\t\t}\n+\t\ti.add(data);\n+\t\tif(right != null) {\n+\t\t\tright.makeInorderQueue(i);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Returns the tree with this node as root as an pre-order Queue\n+\t * @return the Queue\n+\t */\n+\tpublic Queue<T> getPreorderQueue(){\n+\t\tQueue<T> i = new LinkedList<T>();\n+\t\tthis.makePreorderQueue(i);\n+\t\treturn i;\n+\t}\n+\t\n+\t/**\n+\t * Recursive method to traverse and fill the queue pre-order\n+\t * @param i The queue to fill\n+\t */\n+\tprivate void makePreorderQueue(Queue<T> i) {\n+\t\ti.add(data);\n+\t\tif(left != null) {\n+\t\t\tleft.makePreorderQueue(i);\n+\t\t}\n+\t\tif(right != null) {\n+\t\t\tright.makePreorderQueue(i);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Returns the tree with this node as root as an post-order Queue\n+\t * @return the Queue\n+\t */\n+\tpublic Queue<T> getPostorderQueue(){\n+\t\tQueue<T> i = new LinkedList<T>();\n+\t\tthis.makePostorderQueue(i);\n+\t\treturn i;\n+\t}\n+\t\n+\t/**\n+\t * Recursive method to traverse and fill the queue post-order\n+\t * @param i The queue to fill\n+\t */\n+\tprivate void makePostorderQueue(Queue<T> i) {\n+\t\tif(left != null) {\n+\t\t\tleft.makePostorderQueue(i);\n+\t\t}\n+\t\tif(right != null) {\n+\t\t\tright.makePostorderQueue(i);\n+\t\t}\n+\t\ti.add(data);\n+\t}\n+\t\n+}"
  }
]
