[
  {
    "sha": "f4c806ad334173d33920baccff0fcb27f6eb3a5a",
    "filename": "docs/ReleaseNotes.md",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/FoundationDB/fdb-record-layer/blob/9c31967de75502bef3d6187208a1990f8a326cc7/docs/ReleaseNotes.md",
    "raw_url": "https://github.com/FoundationDB/fdb-record-layer/raw/9c31967de75502bef3d6187208a1990f8a326cc7/docs/ReleaseNotes.md",
    "contents_url": "https://api.github.com/repos/FoundationDB/fdb-record-layer/contents/docs/ReleaseNotes.md?ref=9c31967de75502bef3d6187208a1990f8a326cc7",
    "patch": "@@ -22,7 +22,7 @@ In this realase, the various implementations of the `RecordQueryPlan` interface\n * **Performance** Improvement 1 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Performance** Improvement 2 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Performance** Improvement 3 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n-* **Performance** Improvement 4 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n+* **Performance** Generalized running retriable tasks [(Issue #812)](https://github.com/FoundationDB/fdb-record-layer/issues/812)\n * **Performance** Improvement 5 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 1 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)\n * **Feature** Feature 2 [(Issue #NNN)](https://github.com/FoundationDB/fdb-record-layer/issues/NNN)"
  },
  {
    "sha": "3d7e4d8098aec514610ce27901bc1d91ba51427d",
    "filename": "fdb-extensions/src/main/java/com/apple/foundationdb/async/MoreAsyncUtil.java",
    "status": "modified",
    "additions": 25,
    "deletions": 8,
    "changes": 33,
    "blob_url": "https://github.com/FoundationDB/fdb-record-layer/blob/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-extensions/src/main/java/com/apple/foundationdb/async/MoreAsyncUtil.java",
    "raw_url": "https://github.com/FoundationDB/fdb-record-layer/raw/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-extensions/src/main/java/com/apple/foundationdb/async/MoreAsyncUtil.java",
    "contents_url": "https://api.github.com/repos/FoundationDB/fdb-record-layer/contents/fdb-extensions/src/main/java/com/apple/foundationdb/async/MoreAsyncUtil.java?ref=9c31967de75502bef3d6187208a1990f8a326cc7",
    "patch": "@@ -865,7 +865,7 @@ public static void closeIterator(@Nonnull Iterator<?> iterator) {\n      * @param exceptionMapper function for mapping the underlying exception to a {@link RuntimeException}\n      * @param <V> return type of original future\n      * @return future with same completion properties as the future returned by the handler\n-     * @see #composeWhenCompleteAndHandle(CompletableFuture, BiFunction, Function)\n+     * @see #composeWhenCompleteAndHandle(CompletableFuture, BiFunction, boolean, Function)\n      */\n     public static <V> CompletableFuture<V> composeWhenComplete(\n             @Nonnull CompletableFuture<V> future,\n@@ -874,16 +874,25 @@ public static void closeIterator(@Nonnull Iterator<?> iterator) {\n         return composeWhenCompleteAndHandle(\n                 future,\n                 (result, exception) -> handler.apply(result, exception).thenApply(vignore -> result),\n+                true,\n                 exceptionMapper);\n     }\n \n     /**\n-     * Compose a handler bi-function to the result of a future. Unlike the\n-     * {@link AsyncUtil#composeHandle(CompletableFuture, BiFunction)}, which completes exceptionally only when the\n-     * <code>handler</code> completes exceptionally, it completes exceptionally even if the supplied action itself\n-     * (<code>future</code>) encounters an exception.\n+     * Compose a handler bi-function to the result of a future. It is different from the vanilla\n+     * {@link AsyncUtil#composeHandle(CompletableFuture, BiFunction)} in two ways:\n+     * <ul>\n+     * <li>\n+     * If <code>throwFutureException</code> is set, it not only completes exceptionally when the\n+     * <code>handler</code> completes exceptionally, but also completes exceptionally when the supplied action\n+     * itself (<code>future</code>) encounters an exception. (The both encounter exceptions, throw the\n+     * <code>future</code>'s)\n+     * </li>\n+     * If <code>exceptionMapper</code> is set, it maps the underlying exception to a {@link RuntimeException}\n+     * </ul>\n      * @param future future to compose the handler onto\n      * @param handler handler bi-function to compose onto the passed future\n+     * @param throwFutureException completes exceptionally even if (<code>future</code>) encounters an exception\n      * @param exceptionMapper function for mapping the underlying exception to a {@link RuntimeException}\n      * @param <V> type of original future\n      * @param <T> type of final future\n@@ -893,12 +902,18 @@ public static void closeIterator(@Nonnull Iterator<?> iterator) {\n     public static <V, T> CompletableFuture<T> composeWhenCompleteAndHandle(\n             @Nonnull CompletableFuture<V> future,\n             @Nonnull BiFunction<V,Throwable,? extends CompletableFuture<T>> handler,\n+            boolean throwFutureException,\n             @Nullable Function<Throwable,RuntimeException> exceptionMapper) {\n         return AsyncUtil.composeHandle(future, (futureResult, futureException) -> {\n             try {\n-                return handler.apply(futureResult, futureException).handle((handlerResult, handlerAsyncException) -> {\n-                    if (futureException != null) {\n-                        throw getRuntimeException(futureException, exceptionMapper);\n+                System.out.println(\"wawawa 899 \" + futureResult + \" \" + futureException);\n+                RuntimeException mappedFutureException = futureException == null ? null : getRuntimeException(futureException, exceptionMapper);\n+                System.out.println(\"wawawa 911 \" + mappedFutureException);\n+\n+                return handler.apply(futureResult, mappedFutureException).handle((handlerResult, handlerAsyncException) -> {\n+                    System.out.println(\"wawawa 902 \" + handlerResult + \" \" + handlerAsyncException);\n+                    if (throwFutureException && mappedFutureException != null) {\n+                        throw mappedFutureException;\n                     } else if (handlerAsyncException != null) {\n                         // This is for the case where the function call handler.apply returns an exceptional future.\n                         throw getRuntimeException(handlerAsyncException, exceptionMapper);\n@@ -907,6 +922,8 @@ public static void closeIterator(@Nonnull Iterator<?> iterator) {\n                     }\n                 });\n             } catch (Exception handlerSyncException) {\n+                System.out.println(\"wawawa 913 \" + handlerSyncException);\n+\n                 // This is for the case where the function call handler.apply throws an error.\n                 throw getRuntimeException(handlerSyncException, exceptionMapper);\n             }"
  },
  {
    "sha": "2c30dc0d50d64eb5001c9903ee7d01d507b17b2f",
    "filename": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/logging/LogMessageKeys.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/FoundationDB/fdb-record-layer/blob/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/logging/LogMessageKeys.java",
    "raw_url": "https://github.com/FoundationDB/fdb-record-layer/raw/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/logging/LogMessageKeys.java",
    "contents_url": "https://api.github.com/repos/FoundationDB/fdb-record-layer/contents/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/logging/LogMessageKeys.java?ref=9c31967de75502bef3d6187208a1990f8a326cc7",
    "patch": "@@ -48,8 +48,12 @@\n     CODE(\"code\"),\n     DESCRIPTION(\"description\"),\n     UNKNOWN_FIELDS(\"unknown_fields\"),\n+    UUID(\"uuid\"),\n     CURR_ATTEMPT(\"curr_attempt\"),\n     MAX_ATTEMPTS(\"max_attempts\"),\n+    INIT_DELAY_MILLIS(\"init_delay_millis\"),\n+    MIN_DELAY_MILLIS(\"min_delay_millis\"),\n+    MAX_DELAY_MILLIS(\"max_delay_millis\"),\n     DELAY(\"delay\"),\n     COMMIT_NAME(\"commit_name\"),\n     TRANSACTION_ID(\"transaction_id\"),\n@@ -147,6 +151,7 @@\n     INDEXER_MAX_RETRIES(\"indexer_max_retries\"),\n     DIRECTOY(\"directory\"),\n     SOURCE_INDEX(\"source_index\"),\n+    LESSEN_LIMIT(\"lessen_limit\"),\n \n     // comparisons\n     COMPARISON_VALUE(\"comparison_value\"),"
  },
  {
    "sha": "d39b81b480140ef914a9cafb03da282bcfa54e59",
    "filename": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabaseRunner.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/FoundationDB/fdb-record-layer/blob/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabaseRunner.java",
    "raw_url": "https://github.com/FoundationDB/fdb-record-layer/raw/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabaseRunner.java",
    "contents_url": "https://api.github.com/repos/FoundationDB/fdb-record-layer/contents/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabaseRunner.java?ref=9c31967de75502bef3d6187208a1990f8a326cc7",
    "patch": "@@ -333,6 +333,7 @@ default void setTransactionTimeoutMillis(long transactionTimeoutMillis) {\n      * @return future that will contain the result of {@code retriable} after successful run and commit\n      * @see #run(Function)\n      */\n+    // TODO: Deprecate this.\n     @Nonnull\n     default <T> CompletableFuture<T> runAsync(@Nonnull Function<? super FDBRecordContext, CompletableFuture<? extends T>> retriable,\n                                               @Nonnull BiFunction<? super T, Throwable, ? extends Pair<? extends T, ? extends Throwable>> handlePostTransaction) {"
  },
  {
    "sha": "5d579215eb5fbd30a77d6b19bdc6c1eb716ed9fa",
    "filename": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabaseRunnerImpl.java",
    "status": "modified",
    "additions": 99,
    "deletions": 33,
    "changes": 132,
    "blob_url": "https://github.com/FoundationDB/fdb-record-layer/blob/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabaseRunnerImpl.java",
    "raw_url": "https://github.com/FoundationDB/fdb-record-layer/raw/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabaseRunnerImpl.java",
    "contents_url": "https://api.github.com/repos/FoundationDB/fdb-record-layer/contents/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabaseRunnerImpl.java?ref=9c31967de75502bef3d6187208a1990f8a326cc7",
    "patch": "@@ -38,6 +38,7 @@\n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.List;\n import java.util.Map;\n import java.util.UUID;\n@@ -69,6 +70,8 @@\n     @Nonnull\n     private final List<FDBRecordContext> contextsToClose;\n     @Nonnull\n+    private final List<RetriableTaskRunner<?>> retriableTaskRunnerToClose;\n+    @Nonnull\n     private final List<CompletableFuture<?>> futuresToCompleteExceptionally;\n \n     @API(API.Status.INTERNAL)\n@@ -83,6 +86,7 @@\n         this.initialDelayMillis = factory.getInitialDelayMillis();\n \n         contextsToClose = new ArrayList<>();\n+        retriableTaskRunnerToClose = new ArrayList<>();\n         futuresToCompleteExceptionally = new ArrayList<>();\n     }\n \n@@ -185,6 +189,7 @@ private FDBRecordContext openContext(boolean initialAttempt) {\n         return context;\n     }\n \n+    // TODO: Use RetryTask (which only supports runAsync currently) for run as well.\n     private class RunRetriable<T> {\n         private int currAttempt = 0;\n         private long currDelay = getInitialDelayMillis();\n@@ -260,38 +265,6 @@ private RunRetriable(@Nullable List<Object> additionalLogMessageKeyValues) {\n             }\n         }\n \n-        @SuppressWarnings(\"squid:S1181\")\n-        public CompletableFuture<T> runAsync(@Nonnull final Function<? super FDBRecordContext, CompletableFuture<? extends T>> retriable,\n-                                             @Nonnull final BiFunction<? super T, Throwable, ? extends Pair<? extends T, ? extends Throwable>> handlePostTransaction) {\n-            CompletableFuture<T> future = new CompletableFuture<>();\n-            addFutureToCompleteExceptionally(future);\n-            AsyncUtil.whileTrue(() -> {\n-                try {\n-                    context = openContext(currAttempt == 0);\n-                    return retriable.apply(context).thenCompose(val ->\n-                        context.commitAsync().thenApply( vignore -> val)\n-                    ).handle((result, ex) -> {\n-                        Pair<? extends T, ? extends Throwable> newResult = handlePostTransaction.apply(result, ex);\n-                        return handle(newResult.getLeft(), newResult.getRight());\n-                    }).thenCompose(Function.identity());\n-                } catch (Exception e) {\n-                    return handle(null, e);\n-                }\n-            }, getExecutor()).handle((vignore, e) -> {\n-                if (exception != null) {\n-                    future.completeExceptionally(exception);\n-                } else if (e != null) {\n-                    // This handles an uncaught exception\n-                    // showing up somewhere in the handle function.\n-                    future.completeExceptionally(e);\n-                } else {\n-                    future.complete(retVal);\n-                }\n-                return null;\n-            });\n-            return future;\n-        }\n-\n         @SuppressWarnings(\"squid:S1181\")\n         public T run(@Nonnull Function<? super FDBRecordContext, ? extends T> retriable) {\n             boolean again = true;\n@@ -318,6 +291,21 @@ public T run(@Nonnull Function<? super FDBRecordContext, ? extends T> retriable)\n         }\n     }\n \n+\n+//    @Override\n+//    @API(API.Status.EXPERIMENTAL)\n+//    public <T> T run(@Nonnull Function<? super FDBRecordContext, ? extends T> retriable,\n+//                     @Nullable List<Object> additionalLogMessageKeyValues) {\n+//        RetriableTaskRunner<T> retriableTaskRunner = gettRetriableTaskRunner(additionalLogMessageKeyValues);\n+//        return retriableTaskRunner.run(taskState -> {\n+//            try (FDBRecordContext ctx = openContext(taskState.getCurrAttempt() == 0)) {\n+//                T ret = retriable.apply(ctx);\n+//                ctx.commit();\n+//                return ret;\n+//            }\n+//        }, this);\n+//    }\n+\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n     public <T> T run(@Nonnull Function<? super FDBRecordContext, ? extends T> retriable,\n@@ -331,7 +319,75 @@ public T run(@Nonnull Function<? super FDBRecordContext, ? extends T> retriable)\n     public <T> CompletableFuture<T> runAsync(@Nonnull final Function<? super FDBRecordContext, CompletableFuture<? extends T>> retriable,\n                                              @Nonnull final BiFunction<? super T, Throwable, ? extends Pair<? extends T, ? extends Throwable>> handlePostTransaction,\n                                              @Nullable List<Object> additionalLogMessageKeyValues) {\n-        return new RunRetriable<T>(additionalLogMessageKeyValues).runAsync(retriable, handlePostTransaction);\n+        RetriableTaskRunner<T> retriableTaskRunner = gettRetriableTaskRunner(additionalLogMessageKeyValues);\n+\n+        return retriableTaskRunner.runAsync(taskState -> {\n+            FDBRecordContext ctx = openContext(taskState.getCurrAttempt() == 0);\n+            return retriable.apply(ctx).thenCompose(val ->\n+                    ctx.commitAsync().thenApply(vignore -> val)\n+            ).handleAsync((result, ex) -> {\n+                Pair<? extends T, ? extends Throwable> newResult = handlePostTransaction.apply(result, ex);\n+                ctx.close();\n+                if (newResult.getRight() == null) {\n+                    return newResult.getLeft();\n+                } else {\n+                    RuntimeException runtimeException = database.mapAsyncToSyncException(newResult.getRight());\n+                    throw runtimeException;\n+                }\n+            });\n+        });\n+    }\n+\n+    @Nonnull\n+    private <T> RetriableTaskRunner<T> gettRetriableTaskRunner(final @Nullable List<Object> additionalLogMessageKeyValues) {\n+        final RetriableTaskRunner.Builder<T> builder = RetriableTaskRunner.newBuilder(getMaxAttempts());\n+\n+        builder.setPossiblyRetry(states -> {\n+            if (closed) {\n+                // Outermost future should be cancelled, but be sure that this doesn't appear to be successful.\n+                states.setPossibleException(new RunnerClosed());\n+                return false;\n+            }\n+            final Throwable e = states.getPossibleException();\n+            if (e == null) {\n+                // Successful completion. We are done.\n+                return false;\n+            } else {\n+                Throwable t = e;\n+                String fdbMessage = null;\n+                int code = -1;\n+                boolean retry = false;\n+                while (t != null) {\n+                    if (t instanceof FDBException) {\n+                        FDBException fdbE = (FDBException)t;\n+                        retry = retry || fdbE.isRetryable();\n+                        fdbMessage = fdbE.getMessage();\n+                        code = fdbE.getCode();\n+                    } else if (t instanceof RecordCoreRetriableTransactionException) {\n+                        retry = true;\n+                    }\n+                    t = t.getCause();\n+                }\n+                states.getLocalLogs().addAll(Arrays.asList(\n+                        LogMessageKeys.MESSAGE, fdbMessage,\n+                        LogMessageKeys.CODE, code\n+                ));\n+                return retry;\n+            }\n+        });\n+\n+        RetriableTaskRunner<T> retriableTaskRunner = builder\n+                .setInitDelayMillis(getInitialDelayMillis())\n+                .setMinDelayMillis(getMinDelayMillis())\n+                .setMaxDelayMillis(getMaxDelayMillis())\n+                .setLogger(LOGGER)\n+                .setAdditionalLogMessageKeyValues(additionalLogMessageKeyValues)\n+                .setExecutor(getExecutor())\n+                .setExceptionMapper(getDatabase()::mapAsyncToSyncException)\n+                .build();\n+\n+        addRetriableTaskRunnerToClose(retriableTaskRunner);\n+        return retriableTaskRunner;\n     }\n \n     @Override\n@@ -353,6 +409,7 @@ public synchronized void close() {\n             }\n         }\n         contextsToClose.forEach(FDBRecordContext::close);\n+        retriableTaskRunnerToClose.forEach(RetriableTaskRunner::close);\n     }\n \n     @Override\n@@ -379,6 +436,15 @@ private synchronized void addContextToClose(@Nonnull FDBRecordContext context) {\n         contextsToClose.add(context);\n     }\n \n+    private synchronized void addRetriableTaskRunnerToClose(@Nonnull RetriableTaskRunner<?> retriableTaskRunner) {\n+        if (closed) {\n+            retriableTaskRunner.close();\n+            throw new RunnerClosed();\n+        }\n+        retriableTaskRunnerToClose.removeIf(RetriableTaskRunner::isClosed);\n+        retriableTaskRunnerToClose.add(retriableTaskRunner);\n+    }\n+\n     private synchronized void addFutureToCompleteExceptionally(@Nonnull CompletableFuture<?> future) {\n         if (closed) {\n             final RunnerClosed exception = new RunnerClosed();"
  },
  {
    "sha": "aac099ab4c6f4746b348a5e1e92e2c7e57bb8b84",
    "filename": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingBase.java",
    "status": "modified",
    "additions": 4,
    "deletions": 6,
    "changes": 10,
    "blob_url": "https://github.com/FoundationDB/fdb-record-layer/blob/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingBase.java",
    "raw_url": "https://github.com/FoundationDB/fdb-record-layer/raw/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingBase.java",
    "contents_url": "https://api.github.com/repos/FoundationDB/fdb-record-layer/contents/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingBase.java?ref=9c31967de75502bef3d6187208a1990f8a326cc7",
    "patch": "@@ -20,7 +20,6 @@\n \n package com.apple.foundationdb.record.provider.foundationdb;\n \n-import com.apple.foundationdb.FDBException;\n import com.apple.foundationdb.MutationType;\n import com.apple.foundationdb.Transaction;\n import com.apple.foundationdb.annotation.API;\n@@ -54,8 +53,8 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.BiConsumer;\n import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n import java.util.function.Function;\n import java.util.function.Supplier;\n \n@@ -504,14 +503,13 @@ private static void timerIncrement(@Nullable FDBStoreTimer timer, FDBStoreTimer.\n     @Nonnull\n     <R> CompletableFuture<R> throttledRunAsync(@Nonnull final Function<FDBRecordStore, CompletableFuture<R>> function,\n                                                @Nonnull final BiFunction<R, Throwable, Pair<R, Throwable>> handlePostTransaction,\n-                                               @Nullable final BiConsumer<FDBException, List<Object>> handleLessenWork,\n+                                               @Nullable final Consumer<List<Object>> handleLessenWork,\n                                                @Nullable final List<Object> additionalLogMessageKeyValues) {\n         return throttle.throttledRunAsync(function, handlePostTransaction, handleLessenWork, additionalLogMessageKeyValues);\n     }\n \n-    void decreaseLimit(@Nonnull FDBException fdbException,\n-                       @Nullable List<Object> additionalLogMessageKeyValues) {\n-        throttle.decreaseLimit(fdbException, additionalLogMessageKeyValues);\n+    void decreaseLimit(@Nullable List<Object> additionalLogMessageKeyValues) {\n+        throttle.decreaseLimit(additionalLogMessageKeyValues);\n     }\n }\n "
  },
  {
    "sha": "0fdbf5123253bebf46aaad1d92becba9275f4965",
    "filename": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingCommon.java",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/FoundationDB/fdb-record-layer/blob/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingCommon.java",
    "raw_url": "https://github.com/FoundationDB/fdb-record-layer/raw/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingCommon.java",
    "contents_url": "https://api.github.com/repos/FoundationDB/fdb-record-layer/contents/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingCommon.java?ref=9c31967de75502bef3d6187208a1990f8a326cc7",
    "patch": "@@ -29,8 +29,10 @@\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.List;\n import java.util.UUID;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.Function;\n@@ -45,6 +47,7 @@\n \n     @Nonnull private final FDBDatabaseRunner runner;\n     @Nullable private SynchronizedSessionRunner synchronizedSessionRunner = null;\n+    @Nonnull private final List<RetriableTaskRunner<?>> retriableTaskRunnerToClose = new ArrayList<>();\n \n     @Nonnull private final FDBRecordStore.Builder recordStoreBuilder;\n     @Nonnull private final Index index;\n@@ -132,6 +135,10 @@ public void setSynchronizedSessionRunner(@Nullable final SynchronizedSessionRunn\n         this.synchronizedSessionRunner = synchronizedSessionRunner;\n     }\n \n+    void addRetriableTaskRunnerToClose(RetriableTaskRunner<?> retriableTaskRunner) {\n+        retriableTaskRunnerToClose.add(retriableTaskRunner);\n+    }\n+\n     @Nonnull\n     public OnlineIndexer.IndexStatePrecondition getIndexStatePrecondition() {\n         return indexStatePrecondition;\n@@ -173,5 +180,6 @@ public void close() {\n         if (synchronizedSessionRunner != null) {\n             synchronizedSessionRunner.close();\n         }\n+        retriableTaskRunnerToClose.forEach(RetriableTaskRunner::close);\n     }\n }"
  },
  {
    "sha": "dea1f1fb535cca7001f8e6d314d5387bec02fb3b",
    "filename": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingThrottle.java",
    "status": "modified",
    "additions": 53,
    "deletions": 61,
    "changes": 114,
    "blob_url": "https://github.com/FoundationDB/fdb-record-layer/blob/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingThrottle.java",
    "raw_url": "https://github.com/FoundationDB/fdb-record-layer/raw/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingThrottle.java",
    "contents_url": "https://api.github.com/repos/FoundationDB/fdb-record-layer/contents/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexingThrottle.java?ref=9c31967de75502bef3d6187208a1990f8a326cc7",
    "patch": "@@ -24,7 +24,6 @@\n import com.apple.foundationdb.FDBException;\n import com.apple.foundationdb.annotation.API;\n import com.apple.foundationdb.async.AsyncUtil;\n-import com.apple.foundationdb.async.MoreAsyncUtil;\n import com.apple.foundationdb.record.IndexState;\n import com.apple.foundationdb.record.RecordCoreStorageException;\n import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n@@ -43,11 +42,10 @@\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.BiConsumer;\n import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n import java.util.function.Function;\n \n /**\n@@ -73,7 +71,7 @@\n             FDBError.TRANSACTION_TOO_LARGE.code()));\n \n     /**\n-     * The number of successful transactions in a row as called by {@link #throttledRunAsync(Function, BiFunction, BiConsumer, List)}.\n+     * The number of successful transactions in a row as called by {@link #throttledRunAsync(Function, BiFunction, Consumer, List)}.\n      */\n     private int successCount = 0;\n \n@@ -121,22 +119,12 @@ private synchronized void loadConfig() {\n         }\n     }\n \n-    void decreaseLimit(@Nonnull FDBException fdbException,\n-                       @Nullable List<Object> additionalLogMessageKeyValues) {\n+    void decreaseLimit(@Nonnull List<Object> logKeysAndValues) {\n         limit = Math.max(1, (3 * limit) / 4);\n-        if (LOGGER.isInfoEnabled()) {\n-            final KeyValueLogMessage message = KeyValueLogMessage.build(\"Lessening limit of online index build\",\n-                    LogMessageKeys.ERROR, fdbException.getMessage(),\n-                    LogMessageKeys.ERROR_CODE, fdbException.getCode(),\n-                    LogMessageKeys.LIMIT, limit,\n-                    LogMessageKeys.INDEX_NAME, common.getIndex().getName(),\n-                    LogMessageKeys.INDEXER_ID, common.getUuid()\n-                    );\n-            if (additionalLogMessageKeyValues != null) {\n-                message.addKeysAndValues(additionalLogMessageKeyValues);\n-            }\n-            LOGGER.info(message.toString(), fdbException);\n-        }\n+        logKeysAndValues.addAll(Arrays.asList(\n+                LogMessageKeys.LESSEN_LIMIT, true,\n+                LogMessageKeys.LIMIT, limit\n+        ));\n     }\n \n     private void tryToIncreaseLimit(@Nullable Throwable exception) {\n@@ -181,68 +169,72 @@ private FDBException getFDBException(@Nullable Throwable e) {\n         return null;\n     }\n \n-    @Nonnull\n     <R> CompletableFuture<R> throttledRunAsync(@Nonnull final Function<FDBRecordStore, CompletableFuture<R>> function,\n                                                @Nonnull final BiFunction<R, Throwable, Pair<R, Throwable>> handlePostTransaction,\n-                                               @Nullable final BiConsumer<FDBException, List<Object>> handleLessenWork,\n+                                               @Nullable final Consumer<List<Object>> handleLessenWork,\n                                                @Nullable final List<Object> additionalLogMessageKeyValues) {\n         List<Object> onlineIndexerLogMessageKeyValues = new ArrayList<>(Arrays.asList(\n                 LogMessageKeys.INDEX_NAME, common.getIndex().getName(),\n-                LogMessageKeys.INDEXER_ID, common.getUuid()));\n+                LogMessageKeys.INDEX_VERSION, common.getIndex().getLastModifiedVersion(),\n+                LogMessageKeys.INDEXER_ID, common.getUuid(),\n+                getSubspaceProvider().logKey(), getSubspaceProvider()\n+        ));\n         if (additionalLogMessageKeyValues != null) {\n             onlineIndexerLogMessageKeyValues.addAll(additionalLogMessageKeyValues);\n         }\n \n-        AtomicInteger tries = new AtomicInteger(0);\n-        CompletableFuture<R> ret = new CompletableFuture<>();\n-        AtomicLong toWait = new AtomicLong(FDBDatabaseFactory.instance().getInitialDelayMillis());\n-        AsyncUtil.whileTrue(() -> {\n+        RetriableTaskRunner.Builder<R> builder = RetriableTaskRunner.newBuilder(common.config.getMaxRetries() + 1);\n+\n+        builder.setPossiblyRetry(states -> {\n+            final Throwable e = states.getPossibleException();\n+            if (e == null) {\n+                return false;\n+            } else {\n+                FDBException fdbE = getFDBException(e);\n+                if (fdbE != null && lessenWorkCodes.contains(fdbE.getCode())) {\n+                    states.getLocalLogs().addAll(Arrays.asList(\n+                            LogMessageKeys.ERROR, fdbE.getMessage(),\n+                            LogMessageKeys.ERROR_CODE, fdbE.getCode()\n+                    ));\n+                    return true;\n+                } else {\n+                    return false;\n+                }\n+            }\n+        });\n+\n+        if (handleLessenWork != null) {\n+            builder.setHandleIfDoRetry(taskState -> handleLessenWork.accept(taskState.getLocalLogs()));\n+        }\n+\n+        RetriableTaskRunner<R> retriableTaskRunner = builder\n+                .setInitDelayMillis(FDBDatabaseFactory.instance().getInitialDelayMillis())\n+                .setMaxDelayMillis(FDBDatabaseFactory.instance().getMaxDelayMillis())\n+                .setLogger(LOGGER)\n+                .setAdditionalLogMessageKeyValues(additionalLogMessageKeyValues)\n+                .setExecutor(common.getRunner().getExecutor())\n+                .build();\n+\n+        common.addRetriableTaskRunnerToClose(retriableTaskRunner);\n+\n+        return retriableTaskRunner.runAsync(ignore -> {\n             loadConfig();\n             final Index index = common.getIndex();\n             return common.getRunner().runAsync(context -> common.getRecordStoreBuilder().copyBuilder().setContext(context).openAsync().thenCompose(store -> {\n                 IndexState indexState = store.getIndexState(index);\n                 if (indexState != IndexState.WRITE_ONLY) {\n                     throw new RecordCoreStorageException(\"Attempted to build non-write-only index\",\n                             LogMessageKeys.INDEX_NAME, index.getName(),\n-                            common.getRecordStoreBuilder().getSubspaceProvider().logKey(), common.getRecordStoreBuilder().getSubspaceProvider().toString(context),\n+                            getSubspaceProvider().logKey(), getSubspaceProvider().toString(context),\n                             LogMessageKeys.INDEX_STATE, indexState);\n                 }\n                 return function.apply(store);\n-            }), handlePostTransaction, onlineIndexerLogMessageKeyValues).handle((value, e) -> {\n-                if (e == null) {\n-                    ret.complete(value);\n-                    return AsyncUtil.READY_FALSE;\n-                } else {\n-                    int currTries = tries.getAndIncrement();\n-                    FDBException fdbE = getFDBException(e);\n-                    if (currTries < common.config.getMaxRetries() && fdbE != null && lessenWorkCodes.contains(fdbE.getCode())) {\n-                        if (handleLessenWork != null) {\n-                            handleLessenWork.accept(fdbE, onlineIndexerLogMessageKeyValues);\n-                        }\n-                        long delay = (long)(Math.random() * toWait.get());\n-                        toWait.set(Math.min(toWait.get() * 2, FDBDatabaseFactory.instance().getMaxDelayMillis()));\n-                        if (LOGGER.isWarnEnabled()) {\n-                            final KeyValueLogMessage message = KeyValueLogMessage.build(\"Retrying Runner Exception\",\n-                                    LogMessageKeys.INDEXER_CURR_RETRY, currTries,\n-                                    LogMessageKeys.INDEXER_MAX_RETRIES, common.config.getMaxRetries(),\n-                                    LogMessageKeys.DELAY, delay,\n-                                    LogMessageKeys.LIMIT, limit);\n-                            message.addKeysAndValues(onlineIndexerLogMessageKeyValues);\n-                            LOGGER.warn(message.toString(), e);\n-                        }\n-                        return MoreAsyncUtil.delayedFuture(delay, TimeUnit.MILLISECONDS).thenApply(vignore3 -> true);\n-                    } else {\n-                        return completeExceptionally(ret, e, onlineIndexerLogMessageKeyValues);\n-                    }\n-                }\n-            }).thenCompose(Function.identity());\n-        }, common.getRunner().getExecutor()).whenComplete((vignore, e) -> {\n-            if (e != null) {\n-                // Just update ret and ignore the returned future.\n-                completeExceptionally(ret, e, onlineIndexerLogMessageKeyValues);\n-            }\n+            }), handlePostTransaction, onlineIndexerLogMessageKeyValues);\n         });\n-        return ret;\n+    }\n+\n+    private SubspaceProvider getSubspaceProvider() {\n+        return common.getRecordStoreBuilder().getSubspaceProvider();\n     }\n \n     private <R> CompletableFuture<Boolean> completeExceptionally(CompletableFuture<R> ret, Throwable e, List<Object> additionalLogMessageKeyValues) {"
  },
  {
    "sha": "fe0296338ccf681b7e00262eed97d3e92e5ecd20",
    "filename": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java",
    "status": "modified",
    "additions": 9,
    "deletions": 12,
    "changes": 21,
    "blob_url": "https://github.com/FoundationDB/fdb-record-layer/blob/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java",
    "raw_url": "https://github.com/FoundationDB/fdb-record-layer/raw/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java",
    "contents_url": "https://api.github.com/repos/FoundationDB/fdb-record-layer/contents/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java?ref=9c31967de75502bef3d6187208a1990f8a326cc7",
    "patch": "@@ -20,7 +20,6 @@\n \n package com.apple.foundationdb.record.provider.foundationdb;\n \n-import com.apple.foundationdb.FDBException;\n import com.apple.foundationdb.annotation.API;\n import com.apple.foundationdb.async.AsyncUtil;\n import com.apple.foundationdb.async.RangeSet;\n@@ -55,8 +54,8 @@\n import java.util.Map;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.atomic.AtomicLong;\n-import java.util.function.BiConsumer;\n import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n import java.util.function.Function;\n import java.util.function.Supplier;\n \n@@ -267,7 +266,7 @@ int getConfigLoaderInvocationCount() {\n \n     /**\n      * Get the current number of records to process in one transaction.\n-     * This may go up or down while {@link #throttledRunAsync(Function, BiFunction, BiConsumer, List)} is running, if there are failures committing or\n+     * This may go up or down while {@link #throttledRunAsync(Function, BiFunction, Consumer, List)} is running, if there are failures committing or\n      * repeated successes.\n      * @return the current number of records to process in one transaction\n      */\n@@ -291,21 +290,20 @@ public void close() {\n      * other adjustments (given {@code handleLessenWork}) in the case that we encounter FDB errors which can occur if\n      * there is too much work to be done in a single transaction (like transaction_too_large). The error may not be\n      * retriable itself but may be addressed after applying {@code handleLessenWork} to lessen the work.\n-     *\n+     *  @param <R> return type of function to run\n      * @param function the database operation to run transactionally\n      * @param handlePostTransaction after the transaction is committed, or fails to commit, this function is called with\n-     * the result or exception respectively. This handler should return a new pair with either the result to return from\n-     * {@code runAsync} or an exception to be checked whether {@code retriable} should be retried.\n+ * the result or exception respectively. This handler should return a new pair with either the result to return from\n+ * {@code runAsync} or an exception to be checked whether {@code retriable} should be retried.\n      * @param handleLessenWork if it there is too much work to be done in a single transaction, this function is called\n-     * with the FDB exception and additional logging. It should make necessary adjustments to lessen the work.\n+* with the a list which it can log. It should make necessary adjustments to lessen the work.\n      * @param additionalLogMessageKeyValues additional key/value pairs to be included in logs\n-     * @param <R> return type of function to run\n      */\n     @Nonnull\n     @VisibleForTesting\n     <R> CompletableFuture<R> throttledRunAsync(@Nonnull final Function<FDBRecordStore, CompletableFuture<R>> function,\n                                                @Nonnull final BiFunction<R, Throwable, Pair<R, Throwable>> handlePostTransaction,\n-                                               @Nullable final BiConsumer<FDBException, List<Object>> handleLessenWork,\n+                                               @Nullable final Consumer<List<Object>> handleLessenWork,\n                                                @Nullable final List<Object> additionalLogMessageKeyValues) {\n         // test only\n         return getIndexer().throttledRunAsync(function, handlePostTransaction, handleLessenWork, additionalLogMessageKeyValues);\n@@ -319,10 +317,9 @@ public void close() {\n     }\n \n     @VisibleForTesting\n-    void decreaseLimit(@Nonnull FDBException fdbException,\n-                       @Nullable List<Object> additionalLogMessageKeyValues) {\n+    void decreaseLimit(@Nullable List<Object> additionalLogMessageKeyValues) {\n         // test only\n-        getIndexer().decreaseLimit(fdbException, additionalLogMessageKeyValues);\n+        getIndexer().decreaseLimit(additionalLogMessageKeyValues);\n     }\n \n     /**"
  },
  {
    "sha": "9c0b1d362479a818f1220cab083e476b54829831",
    "filename": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/RetriableTaskRunner.java",
    "status": "added",
    "additions": 423,
    "deletions": 0,
    "changes": 423,
    "blob_url": "https://github.com/FoundationDB/fdb-record-layer/blob/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/RetriableTaskRunner.java",
    "raw_url": "https://github.com/FoundationDB/fdb-record-layer/raw/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/RetriableTaskRunner.java",
    "contents_url": "https://api.github.com/repos/FoundationDB/fdb-record-layer/contents/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/RetriableTaskRunner.java?ref=9c31967de75502bef3d6187208a1990f8a326cc7",
    "patch": "@@ -0,0 +1,423 @@\n+/*\n+ * RetriableTaskRunner.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.FDB;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.MoreAsyncUtil;\n+import com.apple.foundationdb.record.logging.KeyValueLogMessage;\n+import com.apple.foundationdb.record.logging.LogMessageKeys;\n+import com.apple.foundationdb.util.LoggableException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+public class RetriableTaskRunner<T> implements AutoCloseable {\n+    private static final Logger DEFAULT_LOGGER = LoggerFactory.getLogger(RetriableTaskRunner.class);\n+\n+//    @Nonnull private final Function<TaskState<T>, ? extends T> retriableTaskSync;\n+    private final int maxAttempts;\n+\n+    // This can also handle other things need to be done post the retriable task.\n+    @Nonnull private final Function<TaskState<T>, Boolean> possiblyRetry;\n+    @Nonnull private final Consumer<TaskState<T>> handleIfDoRetry;\n+    private final long initDelayMillis;\n+    private final long minDelayMillis;\n+    private final long maxDelayMillis;\n+    @Nonnull private final Logger logger;\n+    @Nonnull private final List<Object> additionalLogMessageKeyValues;\n+    @Nonnull private final Executor executor;\n+    @Nullable private final Function<Throwable,RuntimeException> exceptionMapper;\n+\n+    private boolean closed = false;\n+    @Nonnull\n+    private final List<CompletableFuture<?>> futuresToCompleteExceptionally = new ArrayList<>();\n+\n+    public static <T> Builder<T> newBuilder(int maxAttempts) {\n+        return new Builder<>(maxAttempts);\n+    }\n+\n+    public T run(@Nonnull final Function<TaskState<T>, ? extends T> retriableTask, FDBDatabaseRunner runner) {\n+        final TaskState<T> taskState = initializeTaskState();\n+        boolean again = true;\n+        while (again) {\n+            T result = null;\n+            Exception ex = null;\n+            try {\n+                result = retriableTask.apply(taskState);\n+\n+            } catch (Exception taskException) {\n+                ex = taskException;\n+            }\n+            // There shouldn't be any exception coming out of handleResultOrException (it is saved in TaskState instead),\n+            // so no need wrap with try.\n+            again = runner.asyncToSync(FDBStoreTimer.Waits.WAIT_RETRY_DELAY, handleResultOrException(taskState, result, ex));\n+        }\n+        return getResultOrExceptionForRun(taskState);\n+    }\n+\n+    private T getResultOrExceptionForRun(final TaskState<T> taskState) {\n+        RuntimeException e = taskState.getPossibleException();\n+        if (e != null) {\n+            throw addLogsToException(taskState, e);\n+        } else {\n+            return taskState.getPossibleResult();\n+        }\n+    }\n+\n+\n+    public CompletableFuture<T> runAsync(@Nonnull final Function<TaskState<T>, CompletableFuture<? extends T>> retriableTask) {\n+        final TaskState<T> taskState = initializeTaskState();\n+        // There shouldn't be any exception coming out of handleResultOrException (it is saved in TaskState instead),\n+        // so just use simple AsyncUtil.composeHandle.\n+        return AsyncUtil.whileTrue(() -> AsyncUtil.composeHandle(\n+                CompletableFuture.runAsync(() -> System.out.println(\"wawawa doing \" + taskState.currAttempt + \" for \" + taskState.getUuid())).thenCompose(ignore -> retriableTask.apply(taskState)),\n+                (result, ex) -> handleResultOrException(taskState, result, ex)\n+//                true,\n+//                exceptionMapper\n+        ), executor)\n+//        .handle((vignore, eventualException) -> {\n+//            System.out.println(\"wawawa 102 \" + eventualException);\n+//            // If the possibleException is not null, it means\n+//            if (taskState.getPossibleException() == null) {\n+//                // This handles the possible exceptions in handleResultOrException.\n+//                taskState.setPossibleException(eventualException);\n+//            }\n+//            return null;\n+//        })\n+        .thenCompose(vignore -> getResultOrExceptionForRunAsync(taskState));\n+    }\n+\n+    @Nonnull\n+    private TaskState<T> initializeTaskState() {\n+        return new TaskState<>(initDelayMillis, initGlobalLogs());\n+    }\n+\n+    @Nonnull\n+    private CompletableFuture<T> getResultOrExceptionForRunAsync(final TaskState<T> taskState) {\n+        CompletableFuture<T> ret = new CompletableFuture<>();\n+        addFutureToCompleteExceptionally(ret);\n+        RuntimeException e = taskState.getPossibleException();\n+        if (e != null) {\n+            ret.completeExceptionally(addLogsToException(taskState, e));\n+        } else {\n+            ret.complete(taskState.getPossibleResult());\n+        }\n+        return ret;\n+    }\n+\n+    // It doesn't return any result or throw any exception. Result and exceptions are saved in taskState.\n+    private CompletableFuture<Boolean> handleResultOrException(final TaskState<T> taskState, final T result, final Throwable ex) {\n+        try {\n+            if (closed) {\n+                taskState.setPossibleException(new RetriableTaskRunnerClosed());\n+                return AsyncUtil.READY_FALSE;\n+            }\n+            taskState.setPossibleResult(result);\n+            taskState.setPossibleException(mapException(ex));\n+\n+            final boolean possible = possiblyRetry.apply(taskState);\n+            if (possible && (taskState.getCurrAttempt() + 1 < maxAttempts)) {\n+                handleIfDoRetry.accept(taskState); // Exceptions in handleIfDoRetry should be caught by handle later.\n+                taskState.setCurrAttempt(taskState.getCurrAttempt() + 1);\n+\n+                long delay = clampByDelayLimits((long)(Math.random() * taskState.getCurrMaxDelayMillis()));\n+                // Double the current max delay for the next iteration. Note that it should be doubled from the\n+                // iteration's max delay rather than actual delay, because multiplying by Math.random() * 2\n+                // repeatedly will converge it to 0.\n+                taskState.setCurrMaxDelayMillis(clampByDelayLimits(taskState.getCurrMaxDelayMillis() * 2));\n+\n+                logCurrentAttempt(taskState, delay);\n+                CompletableFuture<Void> delayedFuture = MoreAsyncUtil.delayedFuture(delay, TimeUnit.MILLISECONDS);\n+                addFutureToCompleteExceptionally(delayedFuture);\n+                return delayedFuture.thenApply(vignore -> {\n+                    System.out.println(\"wawawa im true\" + taskState.uuid);\n+                    return true;\n+                });\n+            } else {\n+                return AsyncUtil.READY_FALSE;\n+            }\n+        } catch (Exception handlersException) {\n+            if (taskState.getPossibleException() == null) {\n+                // This handles the possible exceptions in handleResultOrException.\n+                taskState.setPossibleException(mapException(handlersException));\n+            }\n+            return AsyncUtil.READY_FALSE;\n+        }\n+\n+//        else {\n+//            // If it's an exception and cannot retry, no need to\n+//            return AsyncUtil.READY_FALSE;\n+//        }\n+    }\n+\n+    private RuntimeException mapException(Throwable e) {\n+        if (e == null) {\n+            return null;\n+        } else if (exceptionMapper == null) {\n+            return new RuntimeException(e);\n+        } else {\n+            return exceptionMapper.apply(e);\n+        }\n+    }\n+\n+    private long clampByDelayLimits(long delay) {\n+        return Math.max(Math.min(delay, maxDelayMillis), minDelayMillis);\n+    }\n+\n+    private List<Object> initGlobalLogs() {\n+        List<Object> globalLogs = new ArrayList<>(additionalLogMessageKeyValues);\n+        globalLogs.addAll(Arrays.asList(\n+                LogMessageKeys.MAX_ATTEMPTS, maxAttempts,\n+                LogMessageKeys.INIT_DELAY_MILLIS, initDelayMillis,\n+                LogMessageKeys.MIN_DELAY_MILLIS, minDelayMillis,\n+                LogMessageKeys.MAX_DELAY_MILLIS, maxDelayMillis\n+        ));\n+        return globalLogs;\n+    }\n+\n+    private void logCurrentAttempt(TaskState<T> taskState, long delay) {\n+        if (logger.isWarnEnabled()) {\n+            final KeyValueLogMessage message = KeyValueLogMessage.build(\"Retrying Exception\",\n+                    LogMessageKeys.CURR_ATTEMPT, taskState.getCurrAttempt(),\n+                    LogMessageKeys.DELAY, delay);\n+            addOtherLogs(taskState, message);\n+            logger.warn(message.toString(), taskState.getPossibleException());\n+        }\n+        taskState.getLocalLogs().clear();\n+    }\n+\n+    private void addOtherLogs(final TaskState<T> taskState, final KeyValueLogMessage message) {\n+        message.addKeysAndValues(taskState.getLocalLogs());\n+        message.addKeysAndValues(taskState.getGlobalLogs());\n+        message.addKeysAndValues(additionalLogMessageKeyValues);\n+    }\n+\n+    private LoggableException addLogsToException(TaskState<T> taskState, RuntimeException e) {\n+        LoggableException loggableException = (e instanceof LoggableException) ?\n+                                              (LoggableException)e : new LoggableException(e);\n+        return loggableException\n+                .addLogInfo(taskState.getGlobalLogs().toArray())\n+                // Include the local logs of the last retry as well.\n+                .addLogInfo(taskState.getLocalLogs().toArray());\n+    }\n+\n+    private synchronized void addFutureToCompleteExceptionally(@Nonnull CompletableFuture<?> future) {\n+        if (closed) {\n+            final RetriableTaskRunnerClosed exception = new RetriableTaskRunnerClosed();\n+            future.completeExceptionally(exception);\n+            throw exception;\n+        }\n+        futuresToCompleteExceptionally.removeIf(CompletableFuture::isDone);\n+        futuresToCompleteExceptionally.add(future);\n+    }\n+\n+    public boolean isClosed() {\n+        return closed;\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        if (!futuresToCompleteExceptionally.stream().allMatch(CompletableFuture::isDone)) {\n+            final Exception exception = new FDBDatabaseRunner.RunnerClosed();\n+            for (CompletableFuture<?> future : futuresToCompleteExceptionally) {\n+                future.completeExceptionally(exception);\n+            }\n+        }\n+    }\n+\n+    public static class TaskState<T> {\n+        @Nullable\n+        private T possibleResult;\n+        @Nullable\n+        private RuntimeException possibleException;\n+        private int currAttempt = 0;\n+        private long currMaxDelayMillis;\n+        // Keep the logs for the current attempt.\n+        @Nonnull\n+        private final List<Object> localLogs = new ArrayList<>();\n+        // Keep the logs for the entire run, including the additional ones provided by caller.\n+        @Nonnull\n+        private final List<Object> globalLogs;\n+        @Nonnull\n+        private UUID uuid;\n+\n+        TaskState(long initDelayMillis, List<Object> globalLogs) {\n+            this.currMaxDelayMillis = initDelayMillis;\n+            this.globalLogs = new ArrayList<>(globalLogs);\n+\n+            uuid = UUID.randomUUID();\n+            this.globalLogs.addAll(Arrays.asList(\n+                    LogMessageKeys.UUID, uuid\n+            ));\n+        }\n+\n+        @Nullable\n+        public T getPossibleResult() {\n+            return possibleResult;\n+        }\n+\n+        public void setPossibleResult(@Nullable T possibleResult) {\n+            this.possibleResult = possibleResult;\n+        }\n+\n+        @Nullable\n+        public RuntimeException getPossibleException() {\n+            return possibleException;\n+        }\n+\n+        public void setPossibleException(@Nullable RuntimeException possibleException) {\n+            this.possibleException = possibleException;\n+        }\n+\n+        public int getCurrAttempt() {\n+            return currAttempt;\n+        }\n+\n+        public void setCurrAttempt(int currAttempt) {\n+            this.currAttempt = currAttempt;\n+        }\n+\n+        public long getCurrMaxDelayMillis() {\n+            return currMaxDelayMillis;\n+        }\n+\n+        public void setCurrMaxDelayMillis(long currMaxDelayMillis) {\n+            this.currMaxDelayMillis = currMaxDelayMillis;\n+        }\n+\n+        @Nonnull\n+        public List<Object> getLocalLogs() {\n+            return localLogs;\n+        }\n+\n+        @Nonnull\n+        public List<Object> getGlobalLogs() {\n+            return globalLogs;\n+        }\n+\n+        @Nonnull\n+        public UUID getUuid() {\n+            return uuid;\n+        }\n+    }\n+\n+    public static class Builder<T> {\n+        private final int maxAttempts;\n+\n+        @Nonnull private Function<TaskState<T>, Boolean> possiblyRetry =\n+                taskState -> taskState.getPossibleResult() == null;\n+        @Nonnull private Consumer<TaskState<T>> handleIfDoRetry = taskState -> { };\n+        private long initDelayMillis = 0;\n+        private long minDelayMillis = 0;\n+        private long maxDelayMillis = 0;\n+        @Nonnull private Logger logger = DEFAULT_LOGGER;\n+        @Nonnull private List<Object> additionalLogMessageKeyValues = Collections.emptyList();\n+        @Nonnull private Executor executor = FDB.DEFAULT_EXECUTOR;\n+        @Nullable private Function<Throwable,RuntimeException> exceptionMapper = FDBExceptions::wrapException;\n+\n+        private Builder(int maxAttempts) {\n+            this.maxAttempts = maxAttempts;\n+        }\n+\n+        // Note this should not be blocking.\n+        public Builder<T> setPossiblyRetry(Function<TaskState<T>, Boolean> possiblyRetry) {\n+            this.possiblyRetry = possiblyRetry;\n+            return this;\n+        }\n+\n+        // Note this should not be blocking.\n+        public Builder<T> setHandleIfDoRetry(Consumer<TaskState<T>> handleIfDoRetry) {\n+            this.handleIfDoRetry = handleIfDoRetry;\n+            return this;\n+        }\n+\n+        public Builder<T> setInitDelayMillis(long initDelayMillis) {\n+            this.initDelayMillis = initDelayMillis;\n+            return this;\n+        }\n+\n+        public Builder<T> setMinDelayMillis(long minDelayMillis) {\n+            this.minDelayMillis = minDelayMillis;\n+            return this;\n+        }\n+\n+        public Builder<T> setMaxDelayMillis(long maxDelayMillis) {\n+            this.maxDelayMillis = maxDelayMillis;\n+            return this;\n+        }\n+\n+        public Builder<T> setLogger(Logger logger) {\n+            this.logger = logger;\n+            return this;\n+        }\n+\n+        public Builder<T> setAdditionalLogMessageKeyValues(@Nullable List<Object> additionalLogMessageKeyValues) {\n+            if (additionalLogMessageKeyValues != null) {\n+                this.additionalLogMessageKeyValues = additionalLogMessageKeyValues;\n+            }\n+            return this;\n+        }\n+\n+        public Builder<T> setExecutor(Executor executor) {\n+            this.executor = executor;\n+            return this;\n+        }\n+\n+        public Builder<T> setExceptionMapper(@Nullable Function<Throwable, RuntimeException> exceptionMapper) {\n+            this.exceptionMapper = exceptionMapper;\n+            return this;\n+        }\n+\n+        public RetriableTaskRunner<T> build() {\n+            return new RetriableTaskRunner<>(this);\n+        }\n+    }\n+\n+    private RetriableTaskRunner(Builder<T> builder) {\n+        maxAttempts = builder.maxAttempts;\n+        possiblyRetry = builder.possiblyRetry;\n+        handleIfDoRetry = builder.handleIfDoRetry;\n+        initDelayMillis = builder.initDelayMillis;\n+        minDelayMillis = builder.minDelayMillis;\n+        maxDelayMillis = builder.maxDelayMillis;\n+        logger = builder.logger;\n+        additionalLogMessageKeyValues = builder.additionalLogMessageKeyValues;\n+        executor = builder.executor;\n+        exceptionMapper = builder.exceptionMapper;\n+    }\n+}"
  },
  {
    "sha": "93da3dd50a6c0d7b99d7ab2369bb2cf1fe94e365",
    "filename": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/RetriableTaskRunnerClosed.java",
    "status": "added",
    "additions": 33,
    "deletions": 0,
    "changes": 33,
    "blob_url": "https://github.com/FoundationDB/fdb-record-layer/blob/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/RetriableTaskRunnerClosed.java",
    "raw_url": "https://github.com/FoundationDB/fdb-record-layer/raw/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/RetriableTaskRunnerClosed.java",
    "contents_url": "https://api.github.com/repos/FoundationDB/fdb-record-layer/contents/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/RetriableTaskRunnerClosed.java?ref=9c31967de75502bef3d6187208a1990f8a326cc7",
    "patch": "@@ -0,0 +1,33 @@\n+/*\n+ * RetriableTaskRunnerClosed.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.RecordCoreException;\n+\n+/**\n+ * Exception thrown when {@link RetriableTaskRunner} has been closed but tries to do work.\n+ */\n+@SuppressWarnings(\"serial\")\n+public class RetriableTaskRunnerClosed extends RecordCoreException {\n+    public RetriableTaskRunnerClosed() {\n+        super(\"retriable task runner has been closed\");\n+    }\n+}"
  },
  {
    "sha": "59b5a8d1b724d96732809227c1b00f1d3bfc0469",
    "filename": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/layers/interning/ScopedInterningLayerTest.java",
    "status": "modified",
    "additions": 3,
    "deletions": 2,
    "changes": 5,
    "blob_url": "https://github.com/FoundationDB/fdb-record-layer/blob/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/layers/interning/ScopedInterningLayerTest.java",
    "raw_url": "https://github.com/FoundationDB/fdb-record-layer/raw/9c31967de75502bef3d6187208a1990f8a326cc7/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/layers/interning/ScopedInterningLayerTest.java",
    "contents_url": "https://api.github.com/repos/FoundationDB/fdb-record-layer/contents/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/layers/interning/ScopedInterningLayerTest.java?ref=9c31967de75502bef3d6187208a1990f8a326cc7",
    "patch": "@@ -68,8 +68,9 @@ public void testUpdateMetadataKeyDoesNotExist() {\n             globalScope.updateMetadataAndVersion(\"some-key-that-does-not-exist\", metadata).join();\n             fail(\"should throw NoSuchElementException\");\n         } catch (CompletionException ex) {\n-            assertThat(ex.getCause(), is(instanceOf(NoSuchElementException.class)));\n-            assertThat(ex.getCause(), hasMessageContaining(\"updateMetadata must reference key that already exists\"));\n+            Throwable cause = ex.getCause().getCause();\n+            assertThat(cause, is(instanceOf(NoSuchElementException.class)));\n+            assertThat(cause, hasMessageContaining(\"updateMetadata must reference key that already exists\"));\n         }\n     }\n "
  }
]
