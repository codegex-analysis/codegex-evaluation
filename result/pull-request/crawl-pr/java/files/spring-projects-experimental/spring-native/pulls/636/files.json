[
  {
    "sha": "d77e0af41da10d3b09535050669da50070cee15d",
    "filename": "samples/security-method/src/main/java/com/example/methodsecurity/MainController.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/spring-projects-experimental/spring-native/blob/17a73ff910d547f0515d844564e86ef11922530b/samples/security-method/src/main/java/com/example/methodsecurity/MainController.java",
    "raw_url": "https://github.com/spring-projects-experimental/spring-native/raw/17a73ff910d547f0515d844564e86ef11922530b/samples/security-method/src/main/java/com/example/methodsecurity/MainController.java",
    "contents_url": "https://api.github.com/repos/spring-projects-experimental/spring-native/contents/samples/security-method/src/main/java/com/example/methodsecurity/MainController.java?ref=17a73ff910d547f0515d844564e86ef11922530b",
    "patch": "@@ -1,4 +1,4 @@\n-package com.example.methodsecurity;\n+    package com.example.methodsecurity;\n \n import org.springframework.web.bind.annotation.GetMapping;\n import org.springframework.web.bind.annotation.RestController;"
  },
  {
    "sha": "71242467c2c418b7a010a5ca8659c0609080d730",
    "filename": "spring-aot/src/main/java/org/springframework/nativex/type/TypeSystem.java",
    "status": "modified",
    "additions": 365,
    "deletions": 301,
    "changes": 666,
    "blob_url": "https://github.com/spring-projects-experimental/spring-native/blob/17a73ff910d547f0515d844564e86ef11922530b/spring-aot/src/main/java/org/springframework/nativex/type/TypeSystem.java",
    "raw_url": "https://github.com/spring-projects-experimental/spring-native/raw/17a73ff910d547f0515d844564e86ef11922530b/spring-aot/src/main/java/org/springframework/nativex/type/TypeSystem.java",
    "contents_url": "https://api.github.com/repos/spring-projects-experimental/spring-native/contents/spring-aot/src/main/java/org/springframework/nativex/type/TypeSystem.java?ref=17a73ff910d547f0515d844564e86ef11922530b",
    "patch": "@@ -1,18 +1,18 @@\n /*\n- * Copyright 2019-2021 the original author or authors.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n+\t* Copyright 2019-2021 the original author or authors.\n+\t*\n+\t* Licensed under the Apache License, Version 2.0 (the \"License\");\n+\t* you may not use this file except in compliance with the License.\n+\t* You may obtain a copy of the License at\n+\t*\n+\t*      https://www.apache.org/licenses/LICENSE-2.0\n+\t*\n+\t* Unless required by applicable law or agreed to in writing, software\n+\t* distributed under the License is distributed on an \"AS IS\" BASIS,\n+\t* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+\t* See the License for the specific language governing permissions and\n+\t* limitations under the License.\n+\t*/\n \n package org.springframework.nativex.type;\n \n@@ -68,12 +68,12 @@\n import org.springframework.nativex.support.Utils;\n \n /**\n- * Simple type system with some rudimentary caching.\n- * \n- * @author Andy Clement\n- */\n+\t* Simple type system with some rudimentary caching.\n+\t*\n+\t* @author Andy Clement\n+\t*/\n public class TypeSystem {\n-\t\n+\n \tprivate static Log logger = LogFactory.getLog(TypeSystem.class);\n \n \tpublic static String SPRING_AT_CONFIGURATION = \"Lorg/springframework/context/annotation/Configuration;\";\n@@ -98,18 +98,18 @@\n \tprivate Map<String, List<File>> appPackages = new HashMap<>();\n \n \tprivate Map<String, ResourcesDescriptor> resourceConfigurations;\n-\t\n+\n \tprivate List<String> excludedAutoConfigurations;\n \n \tprivate Map<String, ReflectionDescriptor> reflectionConfigurations;\n-\t\n+\n \t// Map from classpaths to TypeSystems managing those classpaths\n \tprivate static Map<String, TypeSystem> typeSystems = new HashMap<>();\n \n \t// A map from the types whose clinits make isPresent checks to the types that they are checking the presence\n \t// of (the parameters to the isPresent calls)\n-\tprivate Map<String,List<String>> typesMakingIsPresentChecksInStaticInitializers;\n-\t\n+\tprivate Map<String, List<String>> typesMakingIsPresentChecksInStaticInitializers;\n+\n \tpublic AotOptions aotOptions;\n \n \tpublic static synchronized TypeSystem get(List<String> classpath) {\n@@ -132,11 +132,12 @@ public TypeSystem(List<String> classpath) {\n \t}\n \n \t/**\n-\t * Resolve the {@link Type} from this {@code TypeSystem} classpath,\n-\t * returning {@code null} if not found.\n-\t * @param typeName the name of the type to resolve\n-\t * @return the resolved type, or {@code null}.\n-\t */\n+\t\t* Resolve the {@link Type} from this {@code TypeSystem} classpath,\n+\t\t* returning {@code null} if not found.\n+\t\t*\n+\t\t* @param typeName the name of the type to resolve\n+\t\t* @return the resolved type, or {@code null}.\n+\t\t*/\n \t@Nullable\n \tpublic Type resolve(TypeName typeName) {\n \t\treturn resolveSlashed(typeName.toSlashName(), true);\n@@ -158,7 +159,8 @@ public Type resolveName(String desc, boolean silent) {\n \tpublic Type resolveDotted(String desc, boolean silent) {\n \t\ttry {\n \t\t\treturn resolveDotted(desc);\n-\t\t} catch (MissingTypeException mte) {\n+\t\t}\n+\t\tcatch (MissingTypeException mte) {\n \t\t\tif (silent)\n \t\t\t\treturn null;\n \t\t\telse\n@@ -169,7 +171,8 @@ public Type resolveDotted(String desc, boolean silent) {\n \tpublic boolean canResolveSlashed(String slashedTypeName) {\n \t\ttry {\n \t\t\treturn resolveSlashed(slashedTypeName) != null;\n-\t\t} catch (RuntimeException re) {\n+\t\t}\n+\t\tcatch (RuntimeException re) {\n \t\t\tif (re.getMessage().startsWith(\"Unable to find class file for\")) {\n \t\t\t\treturn false;\n \t\t\t}\n@@ -186,7 +189,8 @@ public Type resolveSlashed(String slashedTypeName, boolean allowNotFound) {\n \t\tif (resolvedType == Type.MISSING) {\n \t\t\tif (allowNotFound) {\n \t\t\t\treturn null;\n-\t\t\t} else {\n+\t\t\t}\n+\t\t\telse {\n \t\t\t\tthrow new MissingTypeException(slashedTypeName);\n \t\t\t}\n \t\t}\n@@ -198,8 +202,8 @@ public Type resolveSlashed(String slashedTypeName, boolean allowNotFound) {\n \t\t\t// It may be an inner type but slashedTypeName is com/foo/example/Outer/Inner\n \t\t\tString current = slashedTypeName;\n \t\t\tint lastSlash = current.lastIndexOf(\"/\");\n-\t\t\twhile (lastSlash != -1 && (lastSlash+1)<current.length()) {\n-\t\t\t\tString attempt = current.substring(0,lastSlash)+\"$\"+current.substring(lastSlash+1);\n+\t\t\twhile (lastSlash != -1 && (lastSlash + 1) < current.length()) {\n+\t\t\t\tString attempt = current.substring(0, lastSlash) + \"$\" + current.substring(lastSlash + 1);\n \t\t\t\tresolvedType = findType(attempt);\n \t\t\t\tif (resolvedType != null) {\n \t\t\t\t\tbreak;\n@@ -211,39 +215,42 @@ public Type resolveSlashed(String slashedTypeName, boolean allowNotFound) {\n \t\tif (resolvedType != null) {\n \t\t\ttypeCache.put(slashedTypeName, resolvedType);\n \t\t\treturn resolvedType;\n-\t\t} else {\n+\t\t}\n+\t\telse {\n \t\t\t// cache a missingtype so we don't go looking again!\n \t\t\ttypeCache.put(slashedTypeName, Type.MISSING);\n \t\t\tif (allowNotFound) {\n \t\t\t\treturn null;\n-\t\t\t} else {\n+\t\t\t}\n+\t\t\telse {\n \t\t\t\tthrow new MissingTypeException(slashedTypeName);\n \t\t\t}\n \t\t}\n \t}\n-\t\n+\n \tprivate Type findType(String slashedTypeName) {\n \t\tint dimensions = 0;\n \t\tString typeToLocate = slashedTypeName;\n \t\tif (slashedTypeName.endsWith(\"[]\")) {\n \t\t\tString n = slashedTypeName;\n \t\t\twhile (n.endsWith(\"[]\")) {\n \t\t\t\tdimensions++;\n-\t\t\t\tn = n.substring(0,n.length()-2);\n+\t\t\t\tn = n.substring(0, n.length() - 2);\n \t\t\t}\n \t\t\ttypeToLocate = n;\n \t\t}\n \t\tbyte[] bytes = find(typeToLocate);\n \t\tif (bytes == null) {\n \t\t\t// System class?\n \t\t\tInputStream resourceAsStream = Thread.currentThread().getContextClassLoader()\n-\t\t\t\t\t.getResourceAsStream(typeToLocate + \".class\");\n+\t\t\t\t.getResourceAsStream(typeToLocate + \".class\");\n \t\t\tif (resourceAsStream == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\ttry {\n \t\t\t\tbytes = loadFromStream(resourceAsStream);\n-\t\t\t} catch (RuntimeException e) {\n+\t\t\t}\n+\t\t\tcatch (RuntimeException e) {\n \t\t\t\tthrow new RuntimeException(\"Problems loading class from resource stream: \" + slashedTypeName, e);\n \t\t\t}\n \t\t}\n@@ -287,22 +294,27 @@ public Type resolve(org.objectweb.asm.Type type, boolean silent) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tint dims = 0;\n-\t\t\twhile (desc.charAt(dims)=='[') { dims++; }\n-\t\t\tif (dims>0) {\n+\t\t\twhile (desc.charAt(dims) == '[') {\n+\t\t\t\tdims++;\n+\t\t\t}\n+\t\t\tif (dims > 0) {\n \t\t\t\tStringBuilder s = new StringBuilder();\n-\t\t\t\ts.append(desc.substring(1+dims,desc.length()-1));\n-\t\t\t\tfor (int i=0;i<dims;i++) {\n+\t\t\t\ts.append(desc.substring(1 + dims, desc.length() - 1));\n+\t\t\t\tfor (int i = 0; i < dims; i++) {\n \t\t\t\t\ts.append(\"[]\");\n \t\t\t\t}\n-\t\t\t\tType tt = resolveSlashed(s.toString(),silent);\n+\t\t\t\tType tt = resolveSlashed(s.toString(), silent);\n \t\t\t\treturn tt;\n-\t\t\t} else {\n+\t\t\t}\n+\t\t\telse {\n \t\t\t\treturn resolve(desc.substring(1, desc.length() - 1));\n \t\t\t}\n-\t\t} catch (MissingTypeException mte) {\n+\t\t}\n+\t\tcatch (MissingTypeException mte) {\n \t\t\tif (silent) {\n \t\t\t\treturn null;\n-\t\t\t} else {\n+\t\t\t}\n+\t\t\telse {\n \t\t\t\tthrow mte;\n \t\t\t}\n \t\t}\n@@ -311,7 +323,8 @@ public Type resolve(org.objectweb.asm.Type type, boolean silent) {\n \tpublic Type Lresolve(String desc, boolean silent) {\n \t\ttry {\n \t\t\treturn resolve(desc.substring(1, desc.length() - 1));\n-\t\t} catch (MissingTypeException mte) {\n+\t\t}\n+\t\tcatch (MissingTypeException mte) {\n \t\t\tif (silent)\n \t\t\t\treturn null;\n \t\t\telse\n@@ -330,11 +343,11 @@ public Type Lresolve(String desc, boolean silent) {\n \t}\n \n \t/**\n-\t * Verifies the type plus all its super types, interfaces and any type\n-\t * references in generic specifications exist.\n-\t * \n-\t * @return List of missing types, empty if all good!\n-\t */\n+\t\t* Verifies the type plus all its super types, interfaces and any type\n+\t\t* references in generic specifications exist.\n+\t\t*\n+\t\t* @return List of missing types, empty if all good!\n+\t\t*/\n \tpublic Set<String> resolveComplete(String desc) {\n \t\tSet<String> missingTypes = new LinkedHashSet<>();\n \t\tresolveComplete(desc.substring(1, desc.length() - 1), missingTypes, new HashSet<>());\n@@ -346,7 +359,8 @@ private void resolveComplete(String slashedDescriptor, Set<String> missingTypes,\n \t\t\tType baseType = resolve(slashedDescriptor, true);\n \t\t\tif (baseType == null) {\n \t\t\t\tmissingTypes.add(slashedDescriptor);\n-\t\t\t} else {\n+\t\t\t}\n+\t\t\telse {\n \t\t\t\t// Check generics\n \t\t\t\tSet<String> typesInSignature = baseType.getTypesInSignature();\n //\t\t\t\tfor (String t: typesInSignature) {\n@@ -371,7 +385,8 @@ public void index() {\n \t\t\tFile f = new File(s);\n \t\t\tif (f.isDirectory()) {\n \t\t\t\tindexDir(f);\n-\t\t\t} else {\n+\t\t\t}\n+\t\t\telse {\n \t\t\t\tindexJar(f);\n \t\t\t}\n \t\t}\n@@ -398,7 +413,8 @@ public void indexDir(File dir) {\n \t\t\t\t\tdirs.add(dir);\n \t\t\t\t}\n \t\t\t});\n-\t\t} catch (IOException ioe) {\n+\t\t}\n+\t\tcatch (IOException ioe) {\n \t\t\tthrow new IllegalStateException(\"Unable to walk \" + dir, ioe);\n \t\t}\n \t}\n@@ -422,9 +438,11 @@ public void indexJar(File jar) {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t} catch (FileNotFoundException | NoSuchFileException fileIsntThere) {\n+\t\t}\n+\t\tcatch (FileNotFoundException | NoSuchFileException fileIsntThere) {\n \t\t\tSystem.err.println(\"WARNING: Unable to find jar '\" + jar + \"' whilst scanning filesystem\");\n-\t\t} catch (IOException ioe) {\n+\t\t}\n+\t\tcatch (IOException ioe) {\n \t\t\tthrow new RuntimeException(\"Problem during scan of \" + jar, ioe);\n \t\t}\n \t}\n@@ -447,8 +465,8 @@ public void indexJar(File jar) {\n \t\t\t\t}\n \t\t\t}\n \t\t\tSet<File> jarfiles = packageCache.get(packageName);\n-\t\t\tif (jarfiles!=null) {\n-\t\t\t\tfor (File jarfile: jarfiles) {\n+\t\t\tif (jarfiles != null) {\n+\t\t\t\tfor (File jarfile : jarfiles) {\n \t\t\t\t\ttry (ZipFile zf = new ZipFile(jarfile)) {\n \t\t\t\t\t\tEnumeration<? extends ZipEntry> entries = zf.entries();\n \t\t\t\t\t\twhile (entries.hasMoreElements()) {\n@@ -462,7 +480,8 @@ public void indexJar(File jar) {\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn null;\n-\t\t} catch (IOException ioe) {\n+\t\t}\n+\t\tcatch (IOException ioe) {\n \t\t\tthrow new RuntimeException(\"Problem finding \" + slashedTypeName, ioe);\n \t\t}\n \t}\n@@ -491,19 +510,22 @@ public void indexJar(File jar) {\n \t\t\tbyte[] returnData = new byte[dataReadSoFar];\n \t\t\tSystem.arraycopy(theData, 0, returnData, 0, dataReadSoFar);\n \t\t\treturn returnData;\n-\t\t} catch (IOException e) {\n+\t\t}\n+\t\tcatch (IOException e) {\n \t\t\tthrow new RuntimeException(\"Unexpectedly unable to load bytedata from input stream\", e);\n-\t\t} finally {\n+\t\t}\n+\t\tfinally {\n \t\t\ttry {\n \t\t\t\tstream.close();\n-\t\t\t} catch (IOException ioe) {\n+\t\t\t}\n+\t\t\tcatch (IOException ioe) {\n \t\t\t}\n \t\t}\n \t}\n \n \tpublic String toString() {\n \t\treturn \"TypeSystem for cp(\" + classpath + \")  jarPackages=#\" + packageCache.size() + \" appPackages=\"\n-\t\t\t\t+ appPackages;\n+\t\t\t+ appPackages;\n \t}\n \n \tpublic void scan() {\n@@ -512,7 +534,8 @@ public void scan() {\n \t\t\tFile f = new File(classpathEntry);\n \t\t\tif (f.isDirectory()) {\n \t\t\t\tscanFiles(f, f);\n-\t\t\t} else {\n+\t\t\t}\n+\t\t\telse {\n \t\t\t\tscanArchive(f);\n \t\t\t}\n \t\t}\n@@ -535,7 +558,8 @@ private void scanArchive(File f) {\n \t\t\t\t}\n \t\t\t\t// TODO resources?\n \t\t\t}\n-\t\t} catch (IOException ioe) {\n+\t\t}\n+\t\tcatch (IOException ioe) {\n \t\t\tthrow new IllegalStateException(ioe);\n \t\t}\n \t}\n@@ -546,7 +570,8 @@ private void scanFiles(File file, File base) {\n \t\t\tfor (File f : files) {\n \t\t\t\tscanFiles(f, base);\n \t\t\t}\n-\t\t} else if (file.getName().endsWith(\".class\")) {\n+\t\t}\n+\t\telse if (file.getName().endsWith(\".class\")) {\n \t\t\ttry {\n \t\t\t\tbyte[] bytes = Files.readAllBytes(Paths.get(file.toURI()));\n \t\t\t\tClassReader reader = new ClassReader(bytes);\n@@ -557,7 +582,8 @@ private void scanFiles(File file, File base) {\n \t\t\t\t\tlogger.debug(\"From \" + file.getName() + \" got \" + ai.toAnnotationString());\n \t\t\t\t\tannotatedTypes.put(node.name, ai);\n \t\t\t\t}\n-\t\t\t} catch (IOException ioe) {\n+\t\t\t}\n+\t\t\tcatch (IOException ioe) {\n \t\t\t\tthrow new IllegalStateException(ioe);\n \t\t\t}\n \t\t}\n@@ -656,7 +682,7 @@ private void collectMetaAnnotations() {\n \t\t\treturn annotations;\n \t\t}\n \t}\n-\t\n+\n \tprivate void ensureSpringConfigurationDiscovered() {\n \t\tif (hintLocator == null) {\n \t\t\thintLocator = new SpringConfiguration(this);\n@@ -676,10 +702,11 @@ private void ensureScanned() {\n \t\tensureScanned();\n \t\tif (metaAnnotated) {\n \t\t\treturn annotatedTypes.values().stream().filter(ai -> ai.hasDescriptorMeta(annotationDescriptor))\n-\t\t\t\t\t.map(ai -> ai.name).collect(Collectors.toList());\n-\t\t} else {\n+\t\t\t\t.map(ai -> ai.name).collect(Collectors.toList());\n+\t\t}\n+\t\telse {\n \t\t\treturn annotatedTypes.values().stream().filter(ai -> ai.hasDescriptor(annotationDescriptor))\n-\t\t\t\t\t.map(ai -> ai.name).collect(Collectors.toList());\n+\t\t\t\t.map(ai -> ai.name).collect(Collectors.toList());\n \t\t}\n \t}\n \n@@ -691,21 +718,22 @@ private void ensureScanned() {\n \t\tList<HintDeclaration> activeDefaultHints = new ArrayList<>();\n \t\tactiveDefaultHints.addAll(findHints(\"java.lang.Object\"));\n \t\tMap<String, List<HintDeclaration>> proposedhints = SpringConfiguration.getProposedhints();\n-\t\tfor (Map.Entry<String,List<HintDeclaration>> proposedhint: proposedhints.entrySet()) {\n+\t\tfor (Map.Entry<String, List<HintDeclaration>> proposedhint : proposedhints.entrySet()) {\n \t\t\tString keytype = proposedhint.getKey();\n \t\t\tif (keytype.equals(\"java.lang.Object\")) {\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tType type = resolveDotted(keytype,true);\n+\t\t\tType type = resolveDotted(keytype, true);\n \t\t\tif (type != null) {\n-\t\t\t\tif (type.isAtConfiguration() || \n-\t\t\t\t\ttype.isImportRegistrar() || type.isImportSelector() || \n+\t\t\t\tif (type.isAtConfiguration() ||\n+\t\t\t\t\ttype.isImportRegistrar() || type.isImportSelector() ||\n \t\t\t\t\ttype.isCondition() || type.isConditional() || type.isAtImport()\n-\t\t\t\t\t) {\n+\t\t\t\t) {\n \t\t\t\t\t// These are triggered by 'exploration' under default/hybrid mode\n-\t\t\t\t} else {\n-\t\t\t\t\tfor (HintDeclaration hint: proposedhint.getValue()) {\n-\t\t\t\t\t\tlogger.debug(\"Considering hint not targeting config (trigger=\"+keytype+\") as applicable: \"+hint);\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tfor (HintDeclaration hint : proposedhint.getValue()) {\n+\t\t\t\t\t\tlogger.debug(\"Considering hint not targeting config (trigger=\" + keytype + \") as applicable: \" + hint);\n \t\t\t\t\t\tactiveDefaultHints.add(hint);\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -717,9 +745,10 @@ private void ensureScanned() {\n \tpublic List<HintDeclaration> findHints(String typename) {\n \t\tif (typename.contains(\"/\")) {\n \t\t\tif (typename.endsWith(\";\")) {\n-\t\t\t\ttypename= typename.substring(1,typename.length()-1).replace(\"/\", \".\");\n-\t\t\t} else {\n-\t\t\t\ttypename= typename.replace(\"/\", \".\");\n+\t\t\t\ttypename = typename.substring(1, typename.length() - 1).replace(\"/\", \".\");\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\ttypename = typename.replace(\"/\", \".\");\n \t\t\t}\n \t\t}\n \t\tif (hintLocator == null) {\n@@ -733,244 +762,261 @@ private void ensureScanned() {\n \t\tresults.addAll(declaredHints);\n \t\treturn results;\n \t}\n-\t\n-\tstatic class Tuple<K,V> {\n+\n+\tstatic class Tuple<K, V> {\n \t\tprivate final K key;\n \t\tprivate final V value;\n-\t\tTuple(K key,V value) {\n+\n+\t\tTuple(K key, V value) {\n \t\t\tthis.key = key;\n \t\t\tthis.value = value;\n \t\t}\n+\n \t\tpublic K getKey() {\n \t\t\treturn key;\n \t\t}\n+\n \t\tpublic V getValue() {\n \t\t\treturn value;\n \t\t}\n-\t\tpublic String toString() { return key+\": hasData?\"+(value!=null); }\n+\n+\t\tpublic String toString() {\n+\t\t\treturn key + \": hasData?\" + (value != null);\n+\t\t}\n \t}\n \n \tstatic class ClassCollectorFileVisitor implements FileVisitor<Path> {\n-\t\t\n+\n \t\tprivate final List<Path> collector = new ArrayList<>();\n-\t\n+\n \t\tpublic List<Path> getClassFiles() {\n \t\t\treturn collector;\n \t\t}\n-\t\n+\n \t\t@Override\n \t\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n \t\t\treturn FileVisitResult.CONTINUE;\n \t\t}\n-\t\n+\n \t\t@Override\n \t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n \t\t\tif (file.getFileName().toString().endsWith(\".class\")) {\n \t\t\t\tcollector.add(file);\n \t\t\t}\n \t\t\treturn FileVisitResult.CONTINUE;\n \t\t}\n-\t\n+\n \t\t@Override\n \t\tpublic FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n \t\t\treturn FileVisitResult.CONTINUE;\n \t\t}\n-\t\n+\n \t\t@Override\n \t\tpublic FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n \t\t\treturn FileVisitResult.CONTINUE;\n \t\t}\n-\t\n-\t\t\n+\n+\n \t}\n \n \t/**\n-\t * Retrieve the map from files (possibly inside jar files) to {@link ResourcesDescriptor} objects parsed\n-\t * from the contents of those files. This method is looking for files that start {@code META-INF/native-image}\n-\t * and end with {@code resource-config.json}. If the file is a path into a jar it has the form\n-\t * {@code path/to/foo.jar!path/to/file}.\n-\t * \n-\t * @return map from files to @link {@link ResourcesDescriptor}\n-\t */\n+\t\t* Retrieve the map from files (possibly inside jar files) to {@link ResourcesDescriptor} objects parsed\n+\t\t* from the contents of those files. This method is looking for files that start {@code META-INF/native-image}\n+\t\t* and end with {@code resource-config.json}. If the file is a path into a jar it has the form\n+\t\t* {@code path/to/foo.jar!path/to/file}.\n+\t\t*\n+\t\t* @return map from files to @link {@link ResourcesDescriptor}\n+\t\t*/\n \tpublic Map<String, ResourcesDescriptor> getResourceConfigurationsOnClasspath() {\n \t\tif (this.resourceConfigurations == null) {\n-\t\t\tMap<String,ResourcesDescriptor> configs = new HashMap<>();\n-\t\t\tfor (String s: classpath) {\n+\t\t\tMap<String, ResourcesDescriptor> configs = new HashMap<>();\n+\t\t\tfor (String s : classpath) {\n \t\t\t\tFile f = new File(s);\n \t\t\t\tif (f.isDirectory()) {\n-\t\t\t\t\tsearchDir(f, filepath -> { \n-\t\t\t\t\t\treturn filepath.contains(\"META-INF/native-image\") && filepath.endsWith(\"resource-config.json\");\n-\t\t\t\t\t}, \n-\t\t\t\t\tResourcesJsonMarshaller::read,\n-\t\t\t\t\tconfigs);\n-\t\t\t\t} else if (f.isFile() && f.toString().endsWith(\".jar\")) {\n-\t\t\t\t\tsearchJar(f, filepath -> { \n-\t\t\t\t\t\treturn filepath.contains(\"META-INF/native-image\") && filepath.endsWith(\"resource-config.json\");\n-\t\t\t\t\t}, \n-\t\t\t\t\tResourcesJsonMarshaller::read,\n-\t\t\t\t\tconfigs);\n+\t\t\t\t\tsearchDir(f, filepath -> {\n+\t\t\t\t\t\t\treturn filepath.contains(\"META-INF/native-image\") && filepath.endsWith(\"resource-config.json\");\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tResourcesJsonMarshaller::read,\n+\t\t\t\t\t\tconfigs);\n+\t\t\t\t}\n+\t\t\t\telse if (f.isFile() && f.toString().endsWith(\".jar\")) {\n+\t\t\t\t\tsearchJar(f, filepath -> {\n+\t\t\t\t\t\t\treturn filepath.contains(\"META-INF/native-image\") && filepath.endsWith(\"resource-config.json\");\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tResourcesJsonMarshaller::read,\n+\t\t\t\t\t\tconfigs);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (configs.isEmpty()) {\n \t\t\t\tthis.resourceConfigurations = Collections.emptyMap();\n-\t\t\t} else {\n+\t\t\t}\n+\t\t\telse {\n \t\t\t\tthis.resourceConfigurations = configs;\n \t\t\t}\n \t\t}\n \t\treturn this.resourceConfigurations;\n \t}\n-\t\n+\n \tpublic Map<String, Map<String, String>> scanForApplicationProperties() {\n-\t\tMap<String, Map<String,String>> collectedProperties = new HashMap<>();\n-\t\tfor (String s: classpath) {\n+\t\tMap<String, Map<String, String>> collectedProperties = new HashMap<>();\n+\t\tfor (String s : classpath) {\n \t\t\tFile f = new File(s);\n \t\t\tif (f.isDirectory()) {\n-\t\t\t\tsearchDir(f, filepath -> { \n-\t\t\t\t\treturn filepath.contains(\"application\") && filepath.endsWith(\".properties\");\n-\t\t\t\t},\n-\t\t\t\tTypeSystem::loadApplicationProperties,\n-\t\t\t\tcollectedProperties);\n-\t\t\t} else if (f.isFile() && f.toString().endsWith(\".jar\")) {\n-\t\t\t\tsearchJar(f, filepath -> { \n-\t\t\t\t\treturn filepath.contains(\"application\") && filepath.endsWith(\".properties\");\n-\t\t\t\t}, \n-\t\t\t\tTypeSystem::loadApplicationProperties,\n-\t\t\t\tcollectedProperties);\n-\t\t\t}\n-\t\t}\t\n+\t\t\t\tsearchDir(f, filepath -> {\n+\t\t\t\t\t\treturn filepath.contains(\"application\") && filepath.endsWith(\".properties\");\n+\t\t\t\t\t},\n+\t\t\t\t\tTypeSystem::loadApplicationProperties,\n+\t\t\t\t\tcollectedProperties);\n+\t\t\t}\n+\t\t\telse if (f.isFile() && f.toString().endsWith(\".jar\")) {\n+\t\t\t\tsearchJar(f, filepath -> {\n+\t\t\t\t\t\treturn filepath.contains(\"application\") && filepath.endsWith(\".properties\");\n+\t\t\t\t\t},\n+\t\t\t\t\tTypeSystem::loadApplicationProperties,\n+\t\t\t\t\tcollectedProperties);\n+\t\t\t}\n+\t\t}\n \t\treturn collectedProperties;\n \t}\n-\t\n+\n \tpublic List<String> getExcludedAutoConfigurations() {\n \t\tif (this.excludedAutoConfigurations == null) {\n \t\t\texcludedAutoConfigurations = new ArrayList<>();\n \t\t\tMap<String, List<String>> collectedExclusions = new HashMap<>();\n-\t\t\tfor (String s: classpath) {\n+\t\t\tfor (String s : classpath) {\n \t\t\t\tFile f = new File(s);\n \t\t\t\tif (f.isDirectory()) {\n-\t\t\t\t\tsearchDir(f, filepath -> { \n-\t\t\t\t\t\treturn  filepath.contains(\"application\") && filepath.endsWith(\".properties\");\n-\t\t\t\t\t},\n-\t\t\t\t\tTypeSystem::findExcludedAutoconfigurationsInPropertiesFile,\n-\t\t\t\t\tcollectedExclusions);\n-\t\t\t\t} else if (f.isFile() && f.toString().endsWith(\".jar\")) {\n-\t\t\t\t\tsearchJar(f, filepath -> { \n-\t\t\t\t\t\treturn filepath.contains(\"application\") && filepath.endsWith(\".properties\");\n-\t\t\t\t\t}, \n-\t\t\t\t\tTypeSystem::findExcludedAutoconfigurationsInPropertiesFile,\n-\t\t\t\t\tcollectedExclusions);\n+\t\t\t\t\tsearchDir(f, filepath -> {\n+\t\t\t\t\t\t\treturn filepath.contains(\"application\") && filepath.endsWith(\".properties\");\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tTypeSystem::findExcludedAutoconfigurationsInPropertiesFile,\n+\t\t\t\t\t\tcollectedExclusions);\n+\t\t\t\t}\n+\t\t\t\telse if (f.isFile() && f.toString().endsWith(\".jar\")) {\n+\t\t\t\t\tsearchJar(f, filepath -> {\n+\t\t\t\t\t\t\treturn filepath.contains(\"application\") && filepath.endsWith(\".properties\");\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tTypeSystem::findExcludedAutoconfigurationsInPropertiesFile,\n+\t\t\t\t\t\tcollectedExclusions);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tfor (Map.Entry<String,List<String>> entry: collectedExclusions.entrySet()) {\n+\t\t\tfor (Map.Entry<String, List<String>> entry : collectedExclusions.entrySet()) {\n \t\t\t\texcludedAutoConfigurations.addAll(entry.getValue());\n \t\t\t}\n-\t\t\tlogger.debug(\"INFO: these spring auto configuration exclusions have been detected: \"+excludedAutoConfigurations);\n+\t\t\tlogger.debug(\"INFO: these spring auto configuration exclusions have been detected: \" + excludedAutoConfigurations);\n \t\t}\n \t\treturn this.excludedAutoConfigurations;\n \t}\n-\t\n+\n \tpublic static List<String> findExcludedAutoconfigurationsInPropertiesFile(InputStream is) {\n \t\ttry {\n \t\t\tProperties p = new Properties();\n \t\t\tp.load(is);\n \t\t\tString value = p.getProperty(\"spring.autoconfigure.exclude\");\n \t\t\tif (value == null) {\n \t\t\t\treturn Collections.emptyList();\n-\t\t\t} else {\n+\t\t\t}\n+\t\t\telse {\n \t\t\t\treturn Arrays.asList(value.split(\",\"));\n \t\t\t}\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new IllegalStateException(\"Unable to read properties file\",e);\n+\t\t}\n+\t\tcatch (IOException e) {\n+\t\t\tthrow new IllegalStateException(\"Unable to read properties file\", e);\n \t\t}\n \t}\n \n-\tpublic static Map<String,String> loadApplicationProperties(InputStream is) {\n+\tpublic static Map<String, String> loadApplicationProperties(InputStream is) {\n \t\ttry {\n \t\t\tProperties p = new Properties();\n \t\t\tp.load(is);\n-\t\t\tMap<String,String> ret = new HashMap<>();\n-\t\t\tfor (final String name: p.stringPropertyNames()) {\n+\t\t\tMap<String, String> ret = new HashMap<>();\n+\t\t\tfor (final String name : p.stringPropertyNames()) {\n \t\t\t\tret.put(name, p.getProperty(name));\n \t\t\t}\n \t\t\treturn ret;\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new IllegalStateException(\"Unable to read properties file\",e);\n+\t\t}\n+\t\tcatch (IOException e) {\n+\t\t\tthrow new IllegalStateException(\"Unable to read properties file\", e);\n \t\t}\n \t}\n-\t\n+\n \n \tpublic Map<String, ReflectionDescriptor> getReflectionConfigurationsOnClasspath() {\n \t\tif (this.reflectionConfigurations == null) {\n-\t\t\tMap<String,ReflectionDescriptor> configs = new HashMap<>();\n-\t\t\tfor (String s: classpath) {\n+\t\t\tMap<String, ReflectionDescriptor> configs = new HashMap<>();\n+\t\t\tfor (String s : classpath) {\n \t\t\t\tFile f = new File(s);\n \t\t\t\tif (f.isDirectory()) {\n-\t\t\t\t\tsearchDir(f, filepath -> { \n-\t\t\t\t\t\treturn filepath.contains(\"META-INF/native-image\") && filepath.endsWith(\"reflect-config.json\");\n-\t\t\t\t\t},\n-\t\t\t\t\tJsonMarshaller::read,\n-\t\t\t\t\tconfigs);\n-\t\t\t\t} else if (f.isFile() && f.toString().endsWith(\".jar\")) {\n-\t\t\t\t\tsearchJar(f, filepath -> { \n-\t\t\t\t\t\treturn filepath.contains(\"META-INF/native-image\") && filepath.endsWith(\"reflect-config.json\");\n-\t\t\t\t\t}, \n-\t\t\t\t\tJsonMarshaller::read,\n-\t\t\t\t\tconfigs);\n+\t\t\t\t\tsearchDir(f, filepath -> {\n+\t\t\t\t\t\t\treturn filepath.contains(\"META-INF/native-image\") && filepath.endsWith(\"reflect-config.json\");\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tJsonMarshaller::read,\n+\t\t\t\t\t\tconfigs);\n+\t\t\t\t}\n+\t\t\t\telse if (f.isFile() && f.toString().endsWith(\".jar\")) {\n+\t\t\t\t\tsearchJar(f, filepath -> {\n+\t\t\t\t\t\t\treturn filepath.contains(\"META-INF/native-image\") && filepath.endsWith(\"reflect-config.json\");\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tJsonMarshaller::read,\n+\t\t\t\t\t\tconfigs);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (configs.isEmpty()) {\n \t\t\t\tthis.reflectionConfigurations = Collections.emptyMap();\n-\t\t\t} else {\n+\t\t\t}\n+\t\t\telse {\n \t\t\t\tthis.reflectionConfigurations = configs;\n \t\t\t}\n \t\t}\n \t\treturn this.reflectionConfigurations;\n \t}\n-\t\n+\n \n \t/**\n-\t * Recursively search a specified directory. Any files that match the specified predicate will have\n-\t * their contents converted by the supplied function and the resultant information stored in the collector map.\n-\t * \n-\t * @param <T> The type of object produced by the converter function\n-\t * @param dir the directory to recursively search\n-\t * @param matchPredicate the predicate against which to match file paths\n-\t * @param converter the converter that processes file contents to produce something of type T\n-\t * @param collector the place to store mappings from matched file paths to T objects\n-\t */\n+\t\t* Recursively search a specified directory. Any files that match the specified predicate will have\n+\t\t* their contents converted by the supplied function and the resultant information stored in the collector map.\n+\t\t*\n+\t\t* @param <T>            The type of object produced by the converter function\n+\t\t* @param dir            the directory to recursively search\n+\t\t* @param matchPredicate the predicate against which to match file paths\n+\t\t* @param converter      the converter that processes file contents to produce something of type T\n+\t\t* @param collector      the place to store mappings from matched file paths to T objects\n+\t\t*/\n \tprivate <T> void searchDir(File dir, Predicate<String> matchPredicate, Function<InputStream, T> converter,\n-\t\t\tMap<String, T> collector) {\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tMap<String, T> collector) {\n \t\tPath root = Paths.get(dir.toURI());\n \t\ttry {\n \t\t\tList<Tuple<String, T>> found =\n-\t\t\t\t\tFiles.walk(root).filter(p -> matchPredicate.test(p.toAbsolutePath().toString())).map(p -> {\n-\t\t\t\ttry {\n-\t\t\t\t\tT t = converter.apply(Files.newInputStream(p));\n-\t\t\t\t\treturn new Tuple<>(p.toString(), t);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tSystem.err.println(\"Unexpected problem reading \" + p + \": \" + e);\n-\t\t\t\t\treturn new Tuple<>(p.toString(), (T)null);\n-\t\t\t\t}\n-\t\t\t}).collect(Collectors.toList());\n-\t\t\tfor (Tuple<String,T> t: found) {\n+\t\t\t\tFiles.walk(root).filter(p -> matchPredicate.test(p.toAbsolutePath().toString())).map(p -> {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tT t = converter.apply(Files.newInputStream(p));\n+\t\t\t\t\t\treturn new Tuple<>(p.toString(), t);\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (Exception e) {\n+\t\t\t\t\t\tSystem.err.println(\"Unexpected problem reading \" + p + \": \" + e);\n+\t\t\t\t\t\treturn new Tuple<>(p.toString(), (T) null);\n+\t\t\t\t\t}\n+\t\t\t\t}).collect(Collectors.toList());\n+\t\t\tfor (Tuple<String, T> t : found) {\n \t\t\t\tcollector.put(t.getKey(), t.getValue());\n \t\t\t}\n-\t\t} catch (IOException ioe) {\n+\t\t}\n+\t\tcatch (IOException ioe) {\n \t\t\tthrow new IllegalStateException(\"Unable to walk \" + dir, ioe);\n \t\t}\n \t}\n \n \t/**\n-\t * Scan the entries in a specified jar file. Any entry paths that match the specified predicate will have\n-\t * their contents converted by the supplied function and the resultant information stored in the collector map.\n-\t * Jar file paths are of the form {@code foo/bar/boo.jar!path/index/jar.txt}.\n-\t * \n-\t * @param <T> The type of object produced by the converter function\n-\t * @param jar the jar to scan\n-\t * @param matchPredicate the predicate against which to match file paths\n-\t * @param converter the converter that processes file contents to produce something of type T\n-\t * @param collector the place to store mappings from matched jar file paths to T objects\n-\t */\n+\t\t* Scan the entries in a specified jar file. Any entry paths that match the specified predicate will have\n+\t\t* their contents converted by the supplied function and the resultant information stored in the collector map.\n+\t\t* Jar file paths are of the form {@code foo/bar/boo.jar!path/index/jar.txt}.\n+\t\t*\n+\t\t* @param <T>            The type of object produced by the converter function\n+\t\t* @param jar            the jar to scan\n+\t\t* @param matchPredicate the predicate against which to match file paths\n+\t\t* @param converter      the converter that processes file contents to produce something of type T\n+\t\t* @param collector      the place to store mappings from matched jar file paths to T objects\n+\t\t*/\n \tprivate <T> void searchJar(File jar, Predicate<String> matchPredicate, Function<InputStream, T> converter, Map<String, T> collector) {\n \t\ttry {\n \t\t\ttry (ZipFile zf = new ZipFile(jar)) {\n@@ -979,36 +1025,39 @@ public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOEx\n \t\t\t\t\tZipEntry entry = entries.nextElement();\n \t\t\t\t\tString name = entry.getName();\n \t\t\t\t\tif (matchPredicate.test(name)) {\n-\t\t\t\t\t\tcollector.put(jar.toURI().getPath().toString()+\"!\"+name, converter.apply(zf.getInputStream(entry)));\n+\t\t\t\t\t\tcollector.put(jar.toURI().getPath().toString() + \"!\" + name, converter.apply(zf.getInputStream(entry)));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t} catch (FileNotFoundException fnfe) {\n+\t\t}\n+\t\tcatch (FileNotFoundException fnfe) {\n \t\t\tSystem.err.println(\"WARNING: Unable to find jar '\" + jar + \"' whilst scanning filesystem\");\n-\t\t} catch (IOException ioe) {\n+\t\t}\n+\t\tcatch (IOException ioe) {\n \t\t\tthrow new RuntimeException(\"Problem during scan of \" + jar, ioe);\n \t\t}\n \t}\n \n \t/**\n-\t * Discover if there is any {@code resource-config.json} on the classpath for this type system that\n-\t * contains an entry that would include {@code META-INF/spring.factories}.\n-\t * \n-\t * @return the file path to the {@code resource-config.json} containing {@code META-INF/spring.factories} or null if there is none\n-\t */\n+\t\t* Discover if there is any {@code resource-config.json} on the classpath for this type system that\n+\t\t* contains an entry that would include {@code META-INF/spring.factories}.\n+\t\t*\n+\t\t* @return the file path to the {@code resource-config.json} containing {@code META-INF/spring.factories} or null if there is none\n+\t\t*/\n \tpublic String findAnyResourceConfigIncludingSpringFactoriesPattern() {\n-\t\tString existingConfigThatIncludesSpringFactories = null; \n-\t\tMap<String,ResourcesDescriptor> resourceConfigurations = getResourceConfigurationsOnClasspath();\n-\t\touter: for (Map.Entry<String,ResourcesDescriptor> resourceConfiguration: resourceConfigurations.entrySet()) {\n+\t\tString existingConfigThatIncludesSpringFactories = null;\n+\t\tMap<String, ResourcesDescriptor> resourceConfigurations = getResourceConfigurationsOnClasspath();\n+\t\touter:\n+\t\tfor (Map.Entry<String, ResourcesDescriptor> resourceConfiguration : resourceConfigurations.entrySet()) {\n \t\t\tif (resourceConfiguration.getValue() == null) {\n-\t\t\t\tlogger.debug(\"WARNING: unexpected null resourceconfiguration loaded from spring.factories at \"+resourceConfiguration.getKey());\n+\t\t\t\tlogger.debug(\"WARNING: unexpected null resourceconfiguration loaded from spring.factories at \" + resourceConfiguration.getKey());\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tSet<String> patterns = resourceConfiguration.getValue().getPatterns();\n-\t\t\tfor (String pattern: patterns) {\n+\t\t\tfor (String pattern : patterns) {\n \t\t\t\tString slash = File.separator;\n \t\t\t\t// Catches it raw or escaped (as the agent would do) - will not currently catch funky wildcarded variants\n-\t\t\t\tif (pattern.equals(\"META-INF\"+slash+\"spring.factories\") || pattern.equals(\"\\\\QMETA-INF\"+slash+\"spring.factories\\\\E\")) {\n+\t\t\t\tif (pattern.equals(\"META-INF\" + slash + \"spring.factories\") || pattern.equals(\"\\\\QMETA-INF\" + slash + \"spring.factories\\\\E\")) {\n \t\t\t\t\texistingConfigThatIncludesSpringFactories = resourceConfiguration.getKey();\n \t\t\t\t\tbreak outer;\n \t\t\t\t}\n@@ -1018,16 +1067,18 @@ public String findAnyResourceConfigIncludingSpringFactoriesPattern() {\n \t}\n \n \t/**\n-\t * Check if there are guard type(s) for this key from a spring.factory file.  The key (and associated entries it points at)\n-\t * should only be processed if one of the guard types exists. If none of them exist, this spring.factories entry is irrelevant.\n-\t * @param key entry key from a spring.factories file\n-\t * @return true if the key and associated value should be processed\n-\t */\n+\t\t* Check if there are guard type(s) for this key from a spring.factory file.  The key (and associated entries it points at)\n+\t\t* should only be processed if one of the guard types exists. If none of them exist, this spring.factories entry is irrelevant.\n+\t\t*\n+\t\t* @param key entry key from a spring.factories file\n+\t\t* @return true if the key and associated value should be processed\n+\t\t*/\n \tpublic boolean shouldBeProcessed(String key) {\n \t\tString[] guardTypes = SpringConfiguration.findProposedFactoryGuards(key);\n \t\tif (guardTypes == null) {\n \t\t\treturn true;\n-\t\t} else {\n+\t\t}\n+\t\telse {\n \t\t\tfor (String guardType : guardTypes) {\n \t\t\t\tType resolvedType = resolveDotted(guardType, true);\n \t\t\t\tif (resolvedType != null) {\n@@ -1047,13 +1098,13 @@ public boolean shouldBeProcessed(String key) {\n \t\tensureSpringConfigurationDiscovered();\n \t\treturn hintLocator.getAccessVerifiers();\n \t}\n-\t\n+\n \tpublic List<SpringFactoriesProcessor> getSpringFactoryProcessors() {\n \t\tensureSpringConfigurationDiscovered();\n \t\treturn hintLocator.getSpringFactoriesProcessors();\n \t}\n \n-\tpublic synchronized Map<String,List<String>> getSpringClassesMakingIsPresentChecks() {\n+\tpublic synchronized Map<String, List<String>> getSpringClassesMakingIsPresentChecks() {\n \t\tif (typesMakingIsPresentChecksInStaticInitializers == null) {\n \t\t\tfor (String classpathentry : classpath) {\n \t\t\t\tif (classpathentry.endsWith(\".jar\") && classpathentry.contains(\"spring\") && !classpathentry.contains(\"test\")) {\n@@ -1069,14 +1120,16 @@ public boolean shouldBeProcessed(String key) {\n \t\t\t\t\t\t\t\t\t\tif (typesMakingIsPresentChecksInStaticInitializers == null) {\n \t\t\t\t\t\t\t\t\t\t\ttypesMakingIsPresentChecksInStaticInitializers = new HashMap<>();\n \t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\ttypesMakingIsPresentChecksInStaticInitializers.put(name.substring(0,name.length()-6).replace('/', '.'),presenceCheckedTypes);\n+\t\t\t\t\t\t\t\t\t\ttypesMakingIsPresentChecksInStaticInitializers.put(name.substring(0, name.length() - 6).replace('/', '.'), presenceCheckedTypes);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t} catch (FileNotFoundException fnfe) {\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (FileNotFoundException fnfe) {\n \t\t\t\t\t\tSystem.err.println(\"WARNING: Unable to find jar '\" + classpathentry + \"' whilst scanning filesystem for isPresent() checking Spring classes\");\n-\t\t\t\t\t} catch (IOException ioe) {\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (IOException ioe) {\n \t\t\t\t\t\tthrow new RuntimeException(\"Problem during isPresent() checking scan of \" + classpathentry, ioe);\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -1094,12 +1147,13 @@ public boolean shouldBeProcessed(String key) {\n \t\t\tFile f = new File(classpathEntry);\n \t\t\tif (f.isDirectory()) {\n \t\t\t\tresult.add(Paths.get(f.toURI()));\n-\t\t\t} else if (f.isFile() &&\n-\t\t\t\t\t   f.getName().endsWith(\".jar\") && \n-\t\t\t\t\t   (f.getParent().endsWith(File.separator+\"target\") ||\n-\t\t\t\t\t    // This pattern recognizes libs/foo.jar which occurs with gradle multi module setups\n-\t\t\t\t\t    f.getParent().endsWith(File.separator+\"libs\"))\n-\t\t\t\t\t   ) {\n+\t\t\t}\n+\t\t\telse if (f.isFile() &&\n+\t\t\t\tf.getName().endsWith(\".jar\") &&\n+\t\t\t\t(f.getParent().endsWith(File.separator + \"target\") ||\n+\t\t\t\t\t// This pattern recognizes libs/foo.jar which occurs with gradle multi module setups\n+\t\t\t\t\tf.getParent().endsWith(File.separator + \"libs\"))\n+\t\t\t) {\n \t\t\t\tresult.add(Paths.get(f.toURI()));\n \t\t\t}\n \t\t}\n@@ -1110,7 +1164,8 @@ public boolean shouldBeProcessed(String key) {\n \t\tArrayList<Path> classfiles = new ArrayList<>();\n \t\tif (Files.isDirectory(path)) {\n \t\t\twalk(path, classfiles);\n-\t\t} else {\n+\t\t}\n+\t\telse {\n \t\t\twalkJar(path, classfiles);\n \t\t}\n \t\treturn classfiles.stream();\n@@ -1121,32 +1176,35 @@ public void walk(Path dir, ArrayList<Path> classfiles) {\n \t\t\tTypeSystem.ClassCollectorFileVisitor x = new TypeSystem.ClassCollectorFileVisitor();\n \t\t\tFiles.walkFileTree(dir, x);\n \t\t\tclassfiles.addAll(x.getClassFiles());\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new IllegalStateException(\"Problem walking directory \"+dir, e);\n-\t\t\t\n+\t\t}\n+\t\tcatch (IOException e) {\n+\t\t\tthrow new IllegalStateException(\"Problem walking directory \" + dir, e);\n+\n \t\t}\n \t}\n \n \tpublic void walkJar(Path jarfile, ArrayList<Path> classfiles) {\n \t\ttry {\n-\t\t\tFileSystem jarfs = FileSystems.newFileSystem(jarfile,null);\n+\t\t\tFileSystem jarfs = FileSystems.newFileSystem(jarfile, (ClassLoader) null);\n \t\t\tIterable<Path> rootDirectories = jarfs.getRootDirectories();\n \t\t\tTypeSystem.ClassCollectorFileVisitor x = new TypeSystem.ClassCollectorFileVisitor();\n-\t\t\tfor (Path path: rootDirectories) {\n+\t\t\tfor (Path path : rootDirectories) {\n \t\t\t\tFiles.walkFileTree(path, x);\n \t\t\t}\n \t\t\tclassfiles.addAll(x.getClassFiles());\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new IllegalStateException(\"Problem opening \"+jarfile,e);\n+\t\t}\n+\t\tcatch (IOException e) {\n+\t\t\tthrow new IllegalStateException(\"Problem opening \" + jarfile, e);\n \t\t}\n \t}\n \n \t/**\n-\t * Search for any relevant stereotypes on the specified type. Return entries of\n-\t * the form:\n-\t * \"com.foo.MyType=org.springframework.stereotype.Component,javax.transaction.Transactional\"\n-\t * @param slashedClassname type upon which to locate stereotypes\n-\t */\n+\t\t* Search for any relevant stereotypes on the specified type. Return entries of\n+\t\t* the form:\n+\t\t* \"com.foo.MyType=org.springframework.stereotype.Component,javax.transaction.Transactional\"\n+\t\t*\n+\t\t* @param slashedClassname type upon which to locate stereotypes\n+\t\t*/\n \tpublic Entry<Type, List<Type>> getStereoTypesOnType(String slashedClassname) {\n \t\treturn resolveSlashed(slashedClassname).getRelevantStereotypes();\n \t}\n@@ -1157,21 +1215,23 @@ public String typenameOfClass(Path p) {\n \n \tpublic List<Entry<Type, List<Type>>> scanForSpringComponents() {\n \t\treturn findDirectoriesOrTargetDirJar(getClasspath()).flatMap(this::findClasses).map(this::typenameOfClass)\n-\t\t\t\t.map(this::getStereoTypesOnType).filter(Objects::nonNull).collect(Collectors.toList());\n+\t\t\t.map(this::getStereoTypesOnType).filter(Objects::nonNull).collect(Collectors.toList());\n \t}\n \n \tpublic Type getType_Import() {\n \t\treturn resolve(Type.fromLdescriptorToSlashed(Type.AtImports));\n \t}\n-\t\n+\n \tenum TypeId {\n \t\tINT(\"I\"), DOUBLE(\"D\"), LONG(\"J\"), SHORT(\"S\"), BYTE(\"B\"), CHAR(\"C\"), FLOAT(\"F\"), BOOLEAN(\"Z\"), REFERENCE(null);\n \t\tfinal String signature;\n \t\tfinal boolean isPrimitive;\n+\n \t\tTypeId(String signature) {\n \t\t\tthis.signature = signature;\n-\t\t\tthis.isPrimitive = (signature!=null);\n+\t\t\tthis.isPrimitive = (signature != null);\n \t\t}\n+\n \t\tpublic String getSignature() {\n \t\t\treturn signature;\n \t\t}\n@@ -1180,13 +1240,13 @@ public String getSignature() {\n \tprivate static Map<String, Map<String, String>> applicationPropertiesFiles = null;\n \tprivate static Map<String, String> mergedApplicationProperties = null;\n \n-\tpublic Map<String,String> getActiveProperties() {\n+\tpublic Map<String, String> getActiveProperties() {\n \t\tif (mergedApplicationProperties == null) {\n \t\t\tapplicationPropertiesFiles = scanForApplicationProperties();\n \t\t\tmergedApplicationProperties = new HashMap<>();\n \t\t\tCollection<Map<String, String>> propertiesFiles = applicationPropertiesFiles.values();\n-\t\t\tfor (Map<String,String> propertiesFile: propertiesFiles) {\n-\t\t\t\tfor (Map.Entry<String,String> property: propertiesFile.entrySet()) {\n+\t\t\tfor (Map<String, String> propertiesFile : propertiesFiles) {\n+\t\t\t\tfor (Map.Entry<String, String> property : propertiesFile.entrySet()) {\n \t\t\t\t\tmergedApplicationProperties.put(property.getKey(), property.getValue());\n \t\t\t\t}\n \t\t\t}\n@@ -1195,7 +1255,7 @@ public String getSignature() {\n \t}\n \n \tpublic boolean isVoidOrPrimitive(String type) {\n-\t\treturn type.length()==1;\n+\t\treturn type.length() == 1;\n \t\t/*\n \t\tswitch (type) {\n \t\tcase \"void\":\n@@ -1213,31 +1273,32 @@ public boolean isVoidOrPrimitive(String type) {\n \t\t*/\n \t}\n \n-\tpublic <T> T getJson(String string,Function<InputStream,T> reader) {\n+\tpublic <T> T getJson(String string, Function<InputStream, T> reader) {\n \t\tlong t = System.currentTimeMillis();\n-\t\tMap<String,T> configs = new HashMap<>();\n-\t\tfor (String s: classpath) {\n+\t\tMap<String, T> configs = new HashMap<>();\n+\t\tfor (String s : classpath) {\n \t\t\tFile f = new File(s);\n \t\t\tif (f.isDirectory()) {\n-\t\t\t\tsearchDir(f, filepath -> { \n-\t\t\t\t\treturn filepath.equals(string);\n-\t\t\t\t}, \n-\t\t\t\t\t\treader,\n+\t\t\t\tsearchDir(f, filepath -> {\n+\t\t\t\t\t\treturn filepath.equals(string);\n+\t\t\t\t\t},\n+\t\t\t\t\treader,\n //\t\t\t\tResourcesJsonMarshaller::read,\n-\t\t\t\tconfigs);\n-\t\t\t} else if (f.isFile() && f.toString().endsWith(\".jar\")) {\n-\t\t\t\tsearchJar(f, filepath -> { \n-\t\t\t\t\treturn filepath.equals(string);\n-\t\t\t\t}, \n-\t\t\t\treader,\n+\t\t\t\t\tconfigs);\n+\t\t\t}\n+\t\t\telse if (f.isFile() && f.toString().endsWith(\".jar\")) {\n+\t\t\t\tsearchJar(f, filepath -> {\n+\t\t\t\t\t\treturn filepath.equals(string);\n+\t\t\t\t\t},\n+\t\t\t\t\treader,\n //\t\t\t\tResourcesJsonMarshaller::read,\n-\t\t\t\tconfigs);\n+\t\t\t\t\tconfigs);\n \t\t\t}\n \t\t}\n-\t\tlogger.debug(\"Took: \"+(System.currentTimeMillis()-t)+\"ms\");\n+\t\tlogger.debug(\"Took: \" + (System.currentTimeMillis() - t) + \"ms\");\n \t\treturn configs.values().iterator().next();\n \t}\n-\t\n+\n \tprivate byte[] readInputStream(InputStream is) {\n \t\tByteArrayOutputStream data = new ByteArrayOutputStream();\n \t\tint c;\n@@ -1246,60 +1307,63 @@ public boolean isVoidOrPrimitive(String type) {\n \t\t\twhile ((c = is.read(buf, 0, buf.length)) != -1) {\n \t\t\t\tdata.write(buf, 0, c);\n \t\t\t}\n-\t\t} catch (IOException e) {\n+\t\t}\n+\t\tcatch (IOException e) {\n \t\t\tthrow new IllegalStateException(\"Problem reading input stream\", e);\n \t\t}\n \t\treturn data.toByteArray();\n \t}\n-\t\n+\n \n \tpublic Collection<String> getBundles(String prefix) {\n \t\tlong t = System.currentTimeMillis();\n \t\tMap<String, byte[]> resources = new HashMap<>();\n \t\tString filePathPrefix = prefix.replace(\".\", \"/\");\n-\t\tfor (String s: classpath) {\n+\t\tfor (String s : classpath) {\n \t\t\tFile f = new File(s);\n \t\t\tif (f.isDirectory()) {\n-\t\t\t\tsearchDir(f, filepath -> { \n-\t\t\t\t\treturn filepath.startsWith(filePathPrefix) && filepath.endsWith(\".properties\");\n-\t\t\t\t}, \n-\t\t\t\tthis::readInputStream, // InputStream to a byte array?\n-\t\t\t\tresources);\n-\t\t\t} else if (f.isFile() && f.toString().endsWith(\".jar\")) {\n-\t\t\t\tsearchJar(f, filepath -> { \n-\t\t\t\t\treturn filepath.startsWith(filePathPrefix) && filepath.endsWith(\".properties\");\n-\t\t\t\t}, \n-\t\t\t\tthis::readInputStream,\n-\t\t\t\tresources);\n-\t\t\t}\n-\t\t}\n-\t\tlogger.debug(\"Took: \"+(System.currentTimeMillis()-t)+\"ms \"+resources.size()+\" resource bundles (name: \"+prefix+\")\");\n+\t\t\t\tsearchDir(f, filepath -> {\n+\t\t\t\t\t\treturn filepath.startsWith(filePathPrefix) && filepath.endsWith(\".properties\");\n+\t\t\t\t\t},\n+\t\t\t\t\tthis::readInputStream, // InputStream to a byte array?\n+\t\t\t\t\tresources);\n+\t\t\t}\n+\t\t\telse if (f.isFile() && f.toString().endsWith(\".jar\")) {\n+\t\t\t\tsearchJar(f, filepath -> {\n+\t\t\t\t\t\treturn filepath.startsWith(filePathPrefix) && filepath.endsWith(\".properties\");\n+\t\t\t\t\t},\n+\t\t\t\t\tthis::readInputStream,\n+\t\t\t\t\tresources);\n+\t\t\t}\n+\t\t}\n+\t\tlogger.debug(\"Took: \" + (System.currentTimeMillis() - t) + \"ms \" + resources.size() + \" resource bundles (name: \" + prefix + \")\");\n \t\treturn resources.keySet();\n \t}\n \n \tpublic Collection<byte[]> getResources(String resource) {\n \t\tlong t = System.currentTimeMillis();\n \t\tMap<String, byte[]> resources = new HashMap<>();\n \t\tboolean specific = resource.startsWith(\"/\");\n-\t\tfor (String s: classpath) {\n+\t\tfor (String s : classpath) {\n \t\t\tFile f = new File(s);\n \t\t\tif (f.isDirectory()) {\n-\t\t\t\tsearchDir(f, filepath -> { \n-\t\t\t\t\treturn specific?filepath.equals(resource):filepath.endsWith(resource);\n-\t\t\t\t}, \n-\t\t\t\tthis::readInputStream, // InputStream to a byte array?\n+\t\t\t\tsearchDir(f, filepath -> {\n+\t\t\t\t\t\treturn specific ? filepath.equals(resource) : filepath.endsWith(resource);\n+\t\t\t\t\t},\n+\t\t\t\t\tthis::readInputStream, // InputStream to a byte array?\n //\t\t\t\tResourcesJsonMarshaller::read,\n-\t\t\t\tresources);\n-\t\t\t} else if (f.isFile() && f.toString().endsWith(\".jar\")) {\n-\t\t\t\tsearchJar(f, filepath -> { \n-\t\t\t\t\treturn specific?filepath.equals(resource):filepath.endsWith(resource);\n-\t\t\t\t}, \n-\t\t\t\tthis::readInputStream,\n+\t\t\t\t\tresources);\n+\t\t\t}\n+\t\t\telse if (f.isFile() && f.toString().endsWith(\".jar\")) {\n+\t\t\t\tsearchJar(f, filepath -> {\n+\t\t\t\t\t\treturn specific ? filepath.equals(resource) : filepath.endsWith(resource);\n+\t\t\t\t\t},\n+\t\t\t\t\tthis::readInputStream,\n //\t\t\t\tResourcesJsonMarshaller::read,\n-\t\t\t\tresources);\n+\t\t\t\t\tresources);\n \t\t\t}\n \t\t}\n-\t\tlogger.debug(\"Took: \"+(System.currentTimeMillis()-t)+\"ms to find \"+resource+\" returning \"+resources.values().size()+\" entries: \"+resources.keySet());\n+\t\tlogger.debug(\"Took: \" + (System.currentTimeMillis() - t) + \"ms to find \" + resource + \" returning \" + resources.values().size() + \" entries: \" + resources.keySet());\n \t\treturn resources.values();\n \t}\n "
  },
  {
    "sha": "8f40e4a3cbf3575273a9900a902c000e6d9f5c48",
    "filename": "spring-native-configuration/pom.xml",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/spring-projects-experimental/spring-native/blob/17a73ff910d547f0515d844564e86ef11922530b/spring-native-configuration/pom.xml",
    "raw_url": "https://github.com/spring-projects-experimental/spring-native/raw/17a73ff910d547f0515d844564e86ef11922530b/spring-native-configuration/pom.xml",
    "contents_url": "https://api.github.com/repos/spring-projects-experimental/spring-native/contents/spring-native-configuration/pom.xml?ref=17a73ff910d547f0515d844564e86ef11922530b",
    "patch": "@@ -78,6 +78,11 @@\n             <artifactId>h2</artifactId>\n             <scope>provided</scope>\n         </dependency>\n+        <dependency>\n+            <groupId>org.projectlombok</groupId>\n+            <artifactId>lombok</artifactId>\n+            <scope>provided</scope>\n+        </dependency>\n         <dependency>\n             <groupId>org.hsqldb</groupId>\n             <artifactId>hsqldb</artifactId>"
  },
  {
    "sha": "e8634573a3ed0534d26d823e0a87f547bda44da0",
    "filename": "spring-native-configuration/src/main/java/lombok/extern/log4j/Log4j2Hints.java",
    "status": "added",
    "additions": 19,
    "deletions": 0,
    "changes": 19,
    "blob_url": "https://github.com/spring-projects-experimental/spring-native/blob/17a73ff910d547f0515d844564e86ef11922530b/spring-native-configuration/src/main/java/lombok/extern/log4j/Log4j2Hints.java",
    "raw_url": "https://github.com/spring-projects-experimental/spring-native/raw/17a73ff910d547f0515d844564e86ef11922530b/spring-native-configuration/src/main/java/lombok/extern/log4j/Log4j2Hints.java",
    "contents_url": "https://api.github.com/repos/spring-projects-experimental/spring-native/contents/spring-native-configuration/src/main/java/lombok/extern/log4j/Log4j2Hints.java?ref=17a73ff910d547f0515d844564e86ef11922530b",
    "patch": "@@ -0,0 +1,19 @@\n+package lombok.extern.log4j;\n+\n+import org.springframework.nativex.hint.NativeHint;\n+import org.springframework.nativex.hint.TypeHint;\n+import org.springframework.nativex.type.NativeConfiguration;\n+\n+\n+/**\n+\t* @author <a href=\"mailto:josh@joshlong.com\">Josh Long</a>\n+\t*/\n+@NativeHint(\n+\ttrigger = Log4j2.class,\n+\ttypes = @TypeHint(types = {\n+\t\torg.apache.logging.log4j.message.DefaultFlowMessageFactory.class,\n+\t\torg.apache.logging.log4j.message.ReusableMessageFactory.class\n+\t})\n+)\n+public class Log4j2Hints implements NativeConfiguration {\n+}"
  },
  {
    "sha": "6e7b69a4c0306b2a9902d3dd1acf694979ea0c55",
    "filename": "spring-native-configuration/src/main/resources/META-INF/services/org.springframework.nativex.type.NativeConfiguration",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/spring-projects-experimental/spring-native/blob/17a73ff910d547f0515d844564e86ef11922530b/spring-native-configuration/src/main/resources/META-INF/services/org.springframework.nativex.type.NativeConfiguration",
    "raw_url": "https://github.com/spring-projects-experimental/spring-native/raw/17a73ff910d547f0515d844564e86ef11922530b/spring-native-configuration/src/main/resources/META-INF/services/org.springframework.nativex.type.NativeConfiguration",
    "contents_url": "https://api.github.com/repos/spring-projects-experimental/spring-native/contents/spring-native-configuration/src/main/resources/META-INF/services/org.springframework.nativex.type.NativeConfiguration?ref=17a73ff910d547f0515d844564e86ef11922530b",
    "patch": "@@ -1,3 +1,4 @@\n+lombok.extern.log4j.Log4j2Hints\n LoggingInitHints\n com.google.protobuf.ProtobufHints\n io.lettuce.LettuceHints"
  }
]
