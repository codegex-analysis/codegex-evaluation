[
  {
    "sha": "028bffe050e2305869d240b9ca91f49119e029dc",
    "filename": ".github/workflows/context-handling.yml",
    "status": "added",
    "additions": 37,
    "deletions": 0,
    "changes": 37,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/.github/workflows/context-handling.yml",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/.github/workflows/context-handling.yml",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/.github/workflows/context-handling.yml?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,37 @@\n+# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven\n+\n+name: context-handling\n+\n+on:\n+  push:\n+    paths:\n+      - 'context/**'\n+      - '.github/workflows/context-handling.yml'\n+\n+defaults:\n+  run:\n+    working-directory: context\n+\n+jobs:\n+  test:\n+\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - name: Checkout\n+      uses: actions/checkout@v2\n+\n+    - name: Set up JDK 11\n+      uses: actions/setup-java@v1\n+      with:\n+        java-version: 11\n+\n+    - name: Cache Maven Packages\n+      uses: actions/cache@v2\n+      with:\n+        path: ~/.m2\n+        key: ${{ runner.os }}-m2-${{ hashFiles('context/**/pom.xml') }}\n+        restore-keys: ${{ runner.os }}-m2\n+\n+    - name: Run Tests\n+      run: mvn --file pom.xml --batch-mode test"
  },
  {
    "sha": "4c2ff196a532e05ab2a79c9a9714a7f509fd8760",
    "filename": "README.md",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/README.md",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/README.md",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/README.md?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -1,2 +1,3 @@\n # smartclide-context\n SmartCLIDE Context Handling Component\n+"
  },
  {
    "sha": "2686b5294afa3e70ba9bbbdcffe9a5b644d0e1a0",
    "filename": "context-core/context-core/.editorconfig",
    "status": "added",
    "additions": 10,
    "deletions": 0,
    "changes": 10,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/.editorconfig",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/.editorconfig",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/.editorconfig?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,10 @@\n+# top-most EditorConfig file\n+root = true\n+\n+# Unix-style newlines with a newline ending every file\n+[*]\n+end_of_line = lf\n+insert_final_newline = true\n+charset = utf-8\n+indent_style = space\n+indent_size = 4\n\\ No newline at end of file"
  },
  {
    "sha": "d3087e4c54047062ddcc0b6ecd606711bb246ab8",
    "filename": "context-core/context-core/LICENSE.txt",
    "status": "added",
    "additions": 277,
    "deletions": 0,
    "changes": 277,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/LICENSE.txt",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/LICENSE.txt",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/LICENSE.txt?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,277 @@\n+Eclipse Public License - v 2.0\n+\n+    THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE\n+    PUBLIC LICENSE (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION\n+    OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.\n+\n+1. DEFINITIONS\n+\n+\"Contribution\" means:\n+\n+  a) in the case of the initial Contributor, the initial content\n+     Distributed under this Agreement, and\n+\n+  b) in the case of each subsequent Contributor:\n+     i) changes to the Program, and\n+     ii) additions to the Program;\n+  where such changes and/or additions to the Program originate from\n+  and are Distributed by that particular Contributor. A Contribution\n+  \"originates\" from a Contributor if it was added to the Program by\n+  such Contributor itself or anyone acting on such Contributor's behalf.\n+  Contributions do not include changes or additions to the Program that\n+  are not Modified Works.\n+\n+\"Contributor\" means any person or entity that Distributes the Program.\n+\n+\"Licensed Patents\" mean patent claims licensable by a Contributor which\n+are necessarily infringed by the use or sale of its Contribution alone\n+or when combined with the Program.\n+\n+\"Program\" means the Contributions Distributed in accordance with this\n+Agreement.\n+\n+\"Recipient\" means anyone who receives the Program under this Agreement\n+or any Secondary License (as applicable), including Contributors.\n+\n+\"Derivative Works\" shall mean any work, whether in Source Code or other\n+form, that is based on (or derived from) the Program and for which the\n+editorial revisions, annotations, elaborations, or other modifications\n+represent, as a whole, an original work of authorship.\n+\n+\"Modified Works\" shall mean any work in Source Code or other form that\n+results from an addition to, deletion from, or modification of the\n+contents of the Program, including, for purposes of clarity any new file\n+in Source Code form that contains any contents of the Program. Modified\n+Works shall not include works that contain only declarations,\n+interfaces, types, classes, structures, or files of the Program solely\n+in each case in order to link to, bind by name, or subclass the Program\n+or Modified Works thereof.\n+\n+\"Distribute\" means the acts of a) distributing or b) making available\n+in any manner that enables the transfer of a copy.\n+\n+\"Source Code\" means the form of a Program preferred for making\n+modifications, including but not limited to software source code,\n+documentation source, and configuration files.\n+\n+\"Secondary License\" means either the GNU General Public License,\n+Version 2.0, or any later versions of that license, including any\n+exceptions or additional permissions as identified by the initial\n+Contributor.\n+\n+2. GRANT OF RIGHTS\n+\n+  a) Subject to the terms of this Agreement, each Contributor hereby\n+  grants Recipient a non-exclusive, worldwide, royalty-free copyright\n+  license to reproduce, prepare Derivative Works of, publicly display,\n+  publicly perform, Distribute and sublicense the Contribution of such\n+  Contributor, if any, and such Derivative Works.\n+\n+  b) Subject to the terms of this Agreement, each Contributor hereby\n+  grants Recipient a non-exclusive, worldwide, royalty-free patent\n+  license under Licensed Patents to make, use, sell, offer to sell,\n+  import and otherwise transfer the Contribution of such Contributor,\n+  if any, in Source Code or other form. This patent license shall\n+  apply to the combination of the Contribution and the Program if, at\n+  the time the Contribution is added by the Contributor, such addition\n+  of the Contribution causes such combination to be covered by the\n+  Licensed Patents. The patent license shall not apply to any other\n+  combinations which include the Contribution. No hardware per se is\n+  licensed hereunder.\n+\n+  c) Recipient understands that although each Contributor grants the\n+  licenses to its Contributions set forth herein, no assurances are\n+  provided by any Contributor that the Program does not infringe the\n+  patent or other intellectual property rights of any other entity.\n+  Each Contributor disclaims any liability to Recipient for claims\n+  brought by any other entity based on infringement of intellectual\n+  property rights or otherwise. As a condition to exercising the\n+  rights and licenses granted hereunder, each Recipient hereby\n+  assumes sole responsibility to secure any other intellectual\n+  property rights needed, if any. For example, if a third party\n+  patent license is required to allow Recipient to Distribute the\n+  Program, it is Recipient's responsibility to acquire that license\n+  before distributing the Program.\n+\n+  d) Each Contributor represents that to its knowledge it has\n+  sufficient copyright rights in its Contribution, if any, to grant\n+  the copyright license set forth in this Agreement.\n+\n+  e) Notwithstanding the terms of any Secondary License, no\n+  Contributor makes additional grants to any Recipient (other than\n+  those set forth in this Agreement) as a result of such Recipient's\n+  receipt of the Program under the terms of a Secondary License\n+  (if permitted under the terms of Section 3).\n+\n+3. REQUIREMENTS\n+\n+3.1 If a Contributor Distributes the Program in any form, then:\n+\n+  a) the Program must also be made available as Source Code, in\n+  accordance with section 3.2, and the Contributor must accompany\n+  the Program with a statement that the Source Code for the Program\n+  is available under this Agreement, and informs Recipients how to\n+  obtain it in a reasonable manner on or through a medium customarily\n+  used for software exchange; and\n+\n+  b) the Contributor may Distribute the Program under a license\n+  different than this Agreement, provided that such license:\n+     i) effectively disclaims on behalf of all other Contributors all\n+     warranties and conditions, express and implied, including\n+     warranties or conditions of title and non-infringement, and\n+     implied warranties or conditions of merchantability and fitness\n+     for a particular purpose;\n+\n+     ii) effectively excludes on behalf of all other Contributors all\n+     liability for damages, including direct, indirect, special,\n+     incidental and consequential damages, such as lost profits;\n+\n+     iii) does not attempt to limit or alter the recipients' rights\n+     in the Source Code under section 3.2; and\n+\n+     iv) requires any subsequent distribution of the Program by any\n+     party to be under a license that satisfies the requirements\n+     of this section 3.\n+\n+3.2 When the Program is Distributed as Source Code:\n+\n+  a) it must be made available under this Agreement, or if the\n+  Program (i) is combined with other material in a separate file or\n+  files made available under a Secondary License, and (ii) the initial\n+  Contributor attached to the Source Code the notice described in\n+  Exhibit A of this Agreement, then the Program may be made available\n+  under the terms of such Secondary Licenses, and\n+\n+  b) a copy of this Agreement must be included with each copy of\n+  the Program.\n+\n+3.3 Contributors may not remove or alter any copyright, patent,\n+trademark, attribution notices, disclaimers of warranty, or limitations\n+of liability (\"notices\") contained within the Program from any copy of\n+the Program which they Distribute, provided that Contributors may add\n+their own appropriate notices.\n+\n+4. COMMERCIAL DISTRIBUTION\n+\n+Commercial distributors of software may accept certain responsibilities\n+with respect to end users, business partners and the like. While this\n+license is intended to facilitate the commercial use of the Program,\n+the Contributor who includes the Program in a commercial product\n+offering should do so in a manner which does not create potential\n+liability for other Contributors. Therefore, if a Contributor includes\n+the Program in a commercial product offering, such Contributor\n+(\"Commercial Contributor\") hereby agrees to defend and indemnify every\n+other Contributor (\"Indemnified Contributor\") against any losses,\n+damages and costs (collectively \"Losses\") arising from claims, lawsuits\n+and other legal actions brought by a third party against the Indemnified\n+Contributor to the extent caused by the acts or omissions of such\n+Commercial Contributor in connection with its distribution of the Program\n+in a commercial product offering. The obligations in this section do not\n+apply to any claims or Losses relating to any actual or alleged\n+intellectual property infringement. In order to qualify, an Indemnified\n+Contributor must: a) promptly notify the Commercial Contributor in\n+writing of such claim, and b) allow the Commercial Contributor to control,\n+and cooperate with the Commercial Contributor in, the defense and any\n+related settlement negotiations. The Indemnified Contributor may\n+participate in any such claim at its own expense.\n+\n+For example, a Contributor might include the Program in a commercial\n+product offering, Product X. That Contributor is then a Commercial\n+Contributor. If that Commercial Contributor then makes performance\n+claims, or offers warranties related to Product X, those performance\n+claims and warranties are such Commercial Contributor's responsibility\n+alone. Under this section, the Commercial Contributor would have to\n+defend claims against the other Contributors related to those performance\n+claims and warranties, and if a court requires any other Contributor to\n+pay any damages as a result, the Commercial Contributor must pay\n+those damages.\n+\n+5. NO WARRANTY\n+\n+EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT\n+PERMITTED BY APPLICABLE LAW, THE PROGRAM IS PROVIDED ON AN \"AS IS\"\n+BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR\n+IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF\n+TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR\n+PURPOSE. Each Recipient is solely responsible for determining the\n+appropriateness of using and distributing the Program and assumes all\n+risks associated with its exercise of rights under this Agreement,\n+including but not limited to the risks and costs of program errors,\n+compliance with applicable laws, damage to or loss of data, programs\n+or equipment, and unavailability or interruption of operations.\n+\n+6. DISCLAIMER OF LIABILITY\n+\n+EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT\n+PERMITTED BY APPLICABLE LAW, NEITHER RECIPIENT NOR ANY CONTRIBUTORS\n+SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST\n+PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE\n+EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGES.\n+\n+7. GENERAL\n+\n+If any provision of this Agreement is invalid or unenforceable under\n+applicable law, it shall not affect the validity or enforceability of\n+the remainder of the terms of this Agreement, and without further\n+action by the parties hereto, such provision shall be reformed to the\n+minimum extent necessary to make such provision valid and enforceable.\n+\n+If Recipient institutes patent litigation against any entity\n+(including a cross-claim or counterclaim in a lawsuit) alleging that the\n+Program itself (excluding combinations of the Program with other software\n+or hardware) infringes such Recipient's patent(s), then such Recipient's\n+rights granted under Section 2(b) shall terminate as of the date such\n+litigation is filed.\n+\n+All Recipient's rights under this Agreement shall terminate if it\n+fails to comply with any of the material terms or conditions of this\n+Agreement and does not cure such failure in a reasonable period of\n+time after becoming aware of such noncompliance. If all Recipient's\n+rights under this Agreement terminate, Recipient agrees to cease use\n+and distribution of the Program as soon as reasonably practicable.\n+However, Recipient's obligations under this Agreement and any licenses\n+granted by Recipient relating to the Program shall continue and survive.\n+\n+Everyone is permitted to copy and distribute copies of this Agreement,\n+but in order to avoid inconsistency the Agreement is copyrighted and\n+may only be modified in the following manner. The Agreement Steward\n+reserves the right to publish new versions (including revisions) of\n+this Agreement from time to time. No one other than the Agreement\n+Steward has the right to modify this Agreement. The Eclipse Foundation\n+is the initial Agreement Steward. The Eclipse Foundation may assign the\n+responsibility to serve as the Agreement Steward to a suitable separate\n+entity. Each new version of the Agreement will be given a distinguishing\n+version number. The Program (including Contributions) may always be\n+Distributed subject to the version of the Agreement under which it was\n+received. In addition, after a new version of the Agreement is published,\n+Contributor may elect to Distribute the Program (including its\n+Contributions) under the new version.\n+\n+Except as expressly stated in Sections 2(a) and 2(b) above, Recipient\n+receives no rights or licenses to the intellectual property of any\n+Contributor under this Agreement, whether expressly, by implication,\n+estoppel or otherwise. All rights in the Program not expressly granted\n+under this Agreement are reserved. Nothing in this Agreement is intended\n+to be enforceable by any entity that is not a Contributor or Recipient.\n+No third-party beneficiary rights are created under this Agreement.\n+\n+Exhibit A - Form of Secondary Licenses Notice\n+\n+\"This Source Code may also be made available under the following \n+Secondary Licenses when the conditions for such availability set forth \n+in the Eclipse Public License, v. 2.0 are satisfied: {name license(s),\n+version(s), and exceptions or additional permissions here}.\"\n+\n+  Simply including a copy of this Agreement, including this Exhibit A\n+  is not sufficient to license the Source Code under Secondary Licenses.\n+\n+  If it is not possible or desirable to put the notice in a particular\n+  file, then You may include the notice in a location (such as a LICENSE\n+  file in a relevant directory) where a recipient would be likely to\n+  look for such a notice.\n+\n+  You may add additional accurate notices of copyright ownership."
  },
  {
    "sha": "3a0305f40094818202ec118fbf9c470f9b212e50",
    "filename": "context-core/context-core/changes.txt",
    "status": "added",
    "additions": 46,
    "deletions": 0,
    "changes": 46,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/changes.txt",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/changes.txt",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/changes.txt?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,46 @@\n+2.0.0\n+=====\n+- Apache 2.0 license\n+\n+1.0.13\n+======\n+- refactor ENUMs\n+\n+1.0.12\n+======\n+-\n+\n+1.0.11\n+======\n+-update reference to lucene-core 3.1.0\n+\n+1.0.9\n+=====\n+-prepare release\n+\n+1.0.8\n+=====\n+-diversity updates\n+\n+1.0.7\n+=====\n+-update dependencies\n+-code cleanup\n+\n+1.0.6\n+=====\n+-add UI for configuration and start/stop of services\n+\n+1.0.5\n+=====\n+-clean up\n+\n+1.0.3\n+=====\n+-changed behaviour in loading configurations. In case it is not possible to load the service configuration from the\n+ PESConfiguration object, it will be tried to load the default configuration file from hard-disk\n+\n+1.0.2\n+=====\n+-add ONA ExecStatus application scenario\n+-add missing BCs\n\\ No newline at end of file"
  },
  {
    "sha": "16ed9f24be67a8846d13bcfac1edc47e60353702",
    "filename": "context-core/context-core/pom.xml",
    "status": "added",
    "additions": 236,
    "deletions": 0,
    "changes": 236,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/pom.xml",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/pom.xml",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/pom.xml?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,236 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>de.atb.context</groupId>\n+        <artifactId>parent</artifactId>\n+        <version>2.0.0</version>\n+    </parent>\n+\n+    <artifactId>context-core</artifactId>\n+\n+    <packaging>jar</packaging>\n+\n+    <name>ATB Context Extraction Core Lib</name>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-dependency-plugin</artifactId>\n+            </plugin>\n+        </plugins>\n+    </build>\n+\n+    <dependencies>\n+        <!-- log4j binding to slf4j -->\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-api</artifactId>\n+            <version>1.7.25</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>jcl-over-slf4j</artifactId>\n+            <version>1.7.25</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-log4j12</artifactId>\n+            <version>1.7.25</version>\n+            <type>jar</type>\n+        </dependency>\n+        <dependency>\n+            <groupId>commons-collections</groupId>\n+            <artifactId>commons-collections</artifactId>\n+            <version>3.2.2</version>\n+            <type>jar</type>\n+        </dependency>\n+        <dependency>\n+            <groupId>commons-io</groupId>\n+            <artifactId>commons-io</artifactId>\n+            <version>2.5</version>\n+            <type>jar</type>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.commons</groupId>\n+            <artifactId>commons-lang3</artifactId>\n+            <version>3.6</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.jgoodies</groupId>\n+            <artifactId>jgoodies-forms</artifactId>\n+            <version>1.7.2</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.logging.log4j</groupId>\n+            <artifactId>log4j-core</artifactId>\n+            <version>2.13.3</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>javax</groupId>\n+            <artifactId>javaee-web-api</artifactId>\n+            <version>8.0</version>\n+            <scope>provided</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.javatuples</groupId>\n+            <artifactId>javatuples</artifactId>\n+            <version>1.2</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>net.sf.jpathwatch</groupId>\n+            <artifactId>jpathwatch</artifactId>\n+            <version>0.95</version>\n+        </dependency>\n+        <!-- Pellet dependencies -->\n+        <dependency>\n+            <groupId>com.github.ansell.pellet</groupId>\n+            <artifactId>pellet-jena</artifactId>\n+            <version>2.3.2</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.github.ansell.pellet</groupId>\n+            <artifactId>pellet-rules</artifactId>\n+            <version>2.3.2</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.github.ansell.pellet</groupId>\n+            <artifactId>pellet-datatypes</artifactId>\n+            <version>2.3.2</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.github.ansell.pellet</groupId>\n+            <artifactId>pellet-el</artifactId>\n+            <version>2.3.2</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.github.ansell.aterms</groupId>\n+            <artifactId>aterm-java</artifactId>\n+            <version>1.8.2-p1</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.jgrapht</groupId>\n+            <artifactId>jgrapht-jdk1.5</artifactId>\n+            <version>0.7.3</version>\n+        </dependency>\n+\n+        <!-- Jena dependencies -->\n+        <dependency>\n+            <groupId>com.hp.hpl.jena</groupId>\n+            <artifactId>tdb</artifactId>\n+            <version>0.8.10</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.hp.hpl.jena</groupId>\n+            <artifactId>sdb</artifactId>\n+            <version>1.3.4</version>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.codehaus.woodstox</groupId>\n+                    <artifactId>wstx-asl</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.thewebsemantic</groupId>\n+            <artifactId>jenabean</artifactId>\n+            <version>1.0.6</version>\n+        </dependency>\n+\n+        <!-- Apache CXF ! -->\n+        <dependency>\n+            <groupId>org.apache.cxf</groupId>\n+            <artifactId>cxf-rt-frontend-jaxws</artifactId>\n+            <version>3.2.0</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.cxf</groupId>\n+            <artifactId>cxf-rt-transports-http-jetty</artifactId>\n+            <version>3.2.0</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.cxf</groupId>\n+            <artifactId>cxf-rt-transports-http-hc</artifactId>\n+            <version>3.2.0</version>\n+        </dependency>\n+        <!-- end Apache CXF ! -->\n+\n+        <!-- SimpleXMLFramework ! -->\n+        <dependency>\n+            <groupId>org.simpleframework</groupId>\n+            <artifactId>simple-xml</artifactId>\n+            <version>2.7.1</version>\n+        </dependency>\n+        <!-- End SimpleXMLFramework ! -->\n+\n+        <!-- H2DB for DataLayer ! -->\n+        <dependency>\n+            <groupId>com.h2database</groupId>\n+            <artifactId>h2</artifactId>\n+            <version>1.4.196</version>\n+        </dependency>\n+        <!-- End H2DB for DataLayer ! -->\n+\n+        <!-- SwingX ! -->\n+        <dependency>\n+            <groupId>org.swinglabs</groupId>\n+            <artifactId>swingx</artifactId>\n+            <version>1.6.1</version>\n+        </dependency>\n+        <!-- END_SwingX ! -->\n+\n+        <!-- Ontology Handlers ! -->\n+        <dependency>\n+            <groupId>net.sourceforge.owlapi</groupId>\n+            <artifactId>owlapi-distribution</artifactId>\n+            <version>5.1.1</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>edu.stanford.protege</groupId>\n+            <artifactId>org.protege.editor.owl.codegeneration</artifactId>\n+            <version>1.0.2</version>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.testng</groupId>\n+                    <artifactId>testng</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <!-- END_Ontology Handlers ! -->\n+\n+        <!-- JSON Support ! -->\n+        <dependency>\n+            <groupId>com.google.code.gson</groupId>\n+            <artifactId>gson</artifactId>\n+            <version>2.8.2</version>\n+        </dependency>\n+        <!-- END_JSON Support ! -->\n+\n+        <dependency>\n+            <groupId>net.sf.supercsv</groupId>\n+            <artifactId>super-csv</artifactId>\n+            <version>2.4.0</version>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.projectlombok</groupId>\n+            <artifactId>lombok</artifactId>\n+            <version>1.18.12</version>\n+        </dependency>\n+\n+        <!-- API, java.xml.bind module -->\n+        <dependency>\n+            <groupId>javax.xml.ws</groupId>\n+            <artifactId>jaxws-api</artifactId>\n+            <version>2.3.1</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>javax.jws</groupId>\n+            <artifactId>javax.jws-api</artifactId>\n+            <version>1.1</version>\n+        </dependency>\n+    </dependencies>\n+</project>"
  },
  {
    "sha": "bb27e7388ef804bfcf4ecd6a1fb532c76daf2a9d",
    "filename": "context-core/context-core/resources/services-config.xml",
    "status": "added",
    "additions": 41,
    "deletions": 0,
    "changes": 41,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/resources/services-config.xml",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/resources/services-config.xml",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/resources/services-config.xml?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,41 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<config xmlns=\"http://www.atb-bremen.de\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+\n+\t<services>\n+\t\t<service id=\"deployer\">\n+         <host>localhost</host>\n+         <location>http://localhost:19012</location>\n+         <name>DeployerService</name>\n+         <server>pt.uninova.context.services.infrastructure.DeployerService</server>\n+         <proxy>pt.uninova.context.services.infrastructure.IDeployerService</proxy>\n+      </service>\n+      <service id=\"registry\">\n+         <host>localhost</host>\n+\t\t <location>http://localhost:19013</location>\n+         <name>ServiceRegistryService</name>\n+         <server>pt.uninova.context.services.infrastructure.ServiceRegistryService</server>\n+         <proxy>pt.uninova.context.services.infrastructure.IServiceRegistryService</proxy>\n+      </service>\n+      <service id=\"registry-repository\">\n+         <host>localhost</host>\n+         <location>http://localhost:19014</location>\n+         <name>ServiceRegistryRepositoryService</name>\n+         <server>pt.uninova.context.services.infrastructure.datalayer.ServiceRegistryRepositoryService</server>\n+         <proxy>pt.uninova.context.services.infrastructure.datalayer.IServiceRegistryRepositoryService</proxy>\n+      </service>\n+      <service id=\"AmI-monitoring\">\n+         <host>localhost</host>\n+         <location>http://localhost:19004</location>\n+         <name>AmIMonitoringService</name>\n+         <server>de.atb.context.services.AmIMonitoringService</server>\n+         <proxy>de.atb.context.services.IAmIMonitoringService</proxy>\n+      </service>\n+      <service id=\"AmI-repository\">\n+         <host>localhost</host>\n+         <location>http://localhost:19005</location>\n+         <name>AmIRepositoryService</name>\n+         <server>de.atb.context.services.dataLayer.AmIRepositoryService</server>\n+         <proxy>de.atb.context.services.dataLayer.IAmIRepositoryService</proxy>\n+      </service>\n+\t</services>\n+</config>\n\\ No newline at end of file"
  },
  {
    "sha": "c9e1410099b619777ddc345cc6d3d785d624dc8a",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/Configuration.java",
    "status": "added",
    "additions": 120,
    "deletions": 0,
    "changes": 120,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/Configuration.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/Configuration.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/Configuration.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,120 @@\n+package de.atb.context.common;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+import de.atb.context.common.exceptions.ConfigurationException;\n+import org.simpleframework.xml.Serializer;\n+import org.simpleframework.xml.core.Persister;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import pm2.common.application.SysCaller;\n+import pm2.common.application.SysCallerImpl;\n+import de.atb.context.tools.ontology.AmIMonitoringConfiguration;\n+\n+import java.io.File;\n+\n+/**\n+ * Configuration\n+ *\n+ * @param <T> T\n+ * @author scholze\n+ * @version $LastChangedRevision: 703 $\n+ */\n+public abstract class Configuration<T> {\n+    public final Logger logger = LoggerFactory.getLogger(Configuration.class);\n+    public final SysCaller sysCaller = new SysCallerImpl(false);\n+\n+    protected static final String HOME_CONFIG_PATH = System\n+            .getProperty(\"user.home\")\n+            + File.separator\n+            + \".context\"\n+            + File.separator;\n+    protected Class<? extends T> configurationClass;\n+    protected String configurationLookupPath;\n+    protected String configurationFileName;\n+    protected String configurationName;\n+    protected T configurationBean;\n+\n+    protected Configuration(final AmIMonitoringConfiguration config,\n+                            final Class<? extends T> clazz, final String configurationName) {\n+        this.configurationClass = clazz;\n+        this.configurationName = configurationName;\n+\n+        logger.info(\"Loading %s...\", configurationName);\n+        final Serializer serializer = new Persister();\n+        try {\n+            this.configurationBean = serializer.read(this.configurationClass,\n+                    config.getServiceConfiguration());\n+            checkConsistency();\n+        } catch (final Exception e) {\n+            logger.debug(\"Could not serialize the \" + configurationName\n+                    + \" file: \" + config.getId(), e);\n+            this.configurationFileName = \"monitoring-config.xml\";\n+            logger.info(\"Trying to load \" + configurationFileName + \"...\");\n+            readConfigurationFile();\n+        }\n+    }\n+\n+    protected Configuration(final String configFileName,\n+                            final String configurationLookupPath,\n+                            final Class<? extends T> clazz, final String configurationName) {\n+        this.configurationLookupPath = configurationLookupPath;\n+        this.configurationClass = clazz;\n+        this.configurationFileName = configFileName;\n+        this.configurationName = configurationName;\n+        logger.info(\"Loading %s...\", configurationName);\n+        readConfigurationFile();\n+\n+    }\n+\n+    protected abstract void readConfigurationFile();\n+\n+    public final void save() { // TODO this should maybe replace by a call to DRM API\n+        logger.info(\"Saving configuration...\");\n+        final Serializer serializer = new Persister();\n+\n+        final File source = new File(Configuration.HOME_CONFIG_PATH\n+                + this.configurationFileName);\n+        final File sourceLocation = new File(System.getProperty(\"user.home\")\n+                + File.separator + \".context\");\n+        if (!sourceLocation.mkdir() && !sourceLocation.exists()) {\n+            logger.warn(\"Could not create directory \"\n+                    + sourceLocation.getAbsolutePath()\n+                    + \" for saving configuration file!\");\n+        }\n+        try {\n+            if (source.exists() || source.createNewFile()) {\n+                serializer.write(getConfig(), source);\n+                logger.info(\"%s saved!\", this.configurationName);\n+            } else {\n+                logger.warn(\"%s could not be saved, because the file %s could not be created!\", this.configurationName, source.getAbsolutePath());\n+            }\n+        } catch (final Exception e) {\n+            logger.error(\"Could not save the \" + this.configurationName\n+                    + \" file: \" + this.configurationFileName, e);\n+        }\n+    }\n+\n+    public final void refresh() {\n+        logger.info(\"Reloading %s...\", this.configurationName);\n+        readConfigurationFile();\n+    }\n+\n+    protected abstract void checkConsistency() throws ConfigurationException;\n+\n+    protected final T getConfig() {\n+        return this.configurationBean;\n+    }\n+}"
  },
  {
    "sha": "03ca019ce9b87782d9f0d56056a2212062bff64a",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/Version.java",
    "status": "added",
    "additions": 61,
    "deletions": 0,
    "changes": 61,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/Version.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/Version.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/Version.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,61 @@\n+package de.atb.context.common;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+/**\n+ * Version\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 417 $\n+ *\n+ */\n+public enum Version {\n+\n+\tPROSECO(0, 8, 15),\n+\n+\tINDEXER(0, 8, 15),\n+\n+\tMONITORING_DATA(0, 8, 15),\n+\n+\t;\n+\n+\tprivate final int major;\n+\tprivate final int minor;\n+\tprivate final int build;\n+\n+\tprivate Version(final int major, final int minor, final int build) {\n+\t\tthis.major = major;\n+\t\tthis.minor = minor;\n+\t\tthis.build = build;\n+\t}\n+\n+\tpublic int getMajor() {\n+\t\treturn major;\n+\t}\n+\n+\tpublic int getMinor() {\n+\t\treturn minor;\n+\t}\n+\n+\tpublic int getBuild() {\n+\t\treturn build;\n+\t}\n+\n+\tpublic String getVersionString() {\n+\t\treturn String.format(\"%d.%d.%d\", Integer.valueOf(major),\n+\t\t\t\tInteger.valueOf(minor), Integer.valueOf(build));\n+\t}\n+\n+}"
  },
  {
    "sha": "d6358531eb22bf2c19e2c88d30d30e990b5a15d4",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/authentication/Credentials.java",
    "status": "added",
    "additions": 77,
    "deletions": 0,
    "changes": 77,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/authentication/Credentials.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/authentication/Credentials.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/authentication/Credentials.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,77 @@\n+package de.atb.context.common.authentication;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+import de.atb.context.common.util.Hashing;\n+\n+/**\n+ * Credentials\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 417 $\n+ *\n+ */\n+public class Credentials {\n+\n+\tprotected String userName;\n+\tprotected String password;\n+\n+\t/**\n+\t * Creates empty Credentials which initializes username as well as password\n+\t * with a {@code null} value.\n+\t */\n+\tpublic Credentials() {\n+\t\t// default empty constructor\n+\t}\n+\n+\tpublic Credentials(final String userName, final String password) {\n+\t\tthis.userName = userName;\n+\t\tthis.password = password;\n+\t}\n+\n+\tpublic final String getUserName() {\n+\t\treturn userName;\n+\t}\n+\n+\tpublic final void setUserName(final String userName) {\n+\t\tthis.userName = userName;\n+\t}\n+\n+\tpublic final String getPassword() {\n+\t\treturn password;\n+\t}\n+\n+\tpublic final void setPassword(final String password) {\n+\t\tthis.password = password;\n+\t}\n+\n+\tpublic final String getMD5HashedPassword() {\n+\t\treturn Hashing.getMD5Hash(password);\n+\t}\n+\n+\tpublic final String getSHA1HashedPassword() {\n+\t\treturn Hashing.getSHA1Hash(password);\n+\t}\n+\n+\tpublic final String getSHA256HashedPassword() {\n+\t\treturn Hashing.getSHA256Hash(password);\n+\t}\n+\n+\t@Override\n+\tpublic final String toString() {\n+\t\treturn \"('\" + userName + \"' // '\" + password + \"')\";\n+\t}\n+\n+}"
  },
  {
    "sha": "5af599e71dcf8577e66f21cdf1949bef048e04a7",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/configuration/ApplicationScenarioConfiguration.java",
    "status": "added",
    "additions": 176,
    "deletions": 0,
    "changes": 176,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/configuration/ApplicationScenarioConfiguration.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/configuration/ApplicationScenarioConfiguration.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/configuration/ApplicationScenarioConfiguration.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,176 @@\n+package de.atb.context.common.configuration;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+import de.atb.context.common.util.ApplicationScenario;\n+import org.simpleframework.xml.Serializer;\n+import org.simpleframework.xml.core.Persister;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import pm2.common.application.SysCaller;\n+import pm2.common.application.SysCallerImpl;\n+\n+import java.io.*;\n+\n+/**\n+ * ApplicationScenarioConfiguration\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 683 $\n+ */\n+public abstract class ApplicationScenarioConfiguration<B extends IConfigurationBean>\n+        implements IConfigurationContainer<B> {\n+\n+    public static final String CONFIGURATION_FILE = \" configuration file: \";\n+    private final Logger logger = LoggerFactory\n+            .getLogger(ApplicationScenarioConfiguration.class);\n+\n+    private final SysCaller sysCaller = new SysCallerImpl(false);\n+\n+    protected ApplicationScenario scenario;\n+    protected B configurationB;\n+\n+    protected Class<? extends B> configurationClass;\n+    protected String configurationCompleteFilePath;\n+    protected String configurationFileName;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public ApplicationScenarioConfiguration(final ApplicationScenario scenario,\n+                                            final String className) throws ClassNotFoundException {\n+        this(scenario, (Class<? extends B>) Class.forName(className));\n+    }\n+\n+    public ApplicationScenarioConfiguration(final ApplicationScenario scenario,\n+                                            final Class<? extends B> clazz) {\n+        if (scenario == null) {\n+            throw new NullPointerException(\"Scenario may not be null!\");\n+        }\n+        this.scenario = scenario;\n+        this.configurationClass = clazz;\n+        this.configurationFileName = scenario.toString() + \".xml\";\n+        if (clazz != null) {\n+            try {\n+                configurationB = clazz.newInstance();\n+            } catch (InstantiationException|IllegalAccessException e) {\n+                logger.error(e.getMessage(), e);\n+            }\n+        } else {\n+            logger.error(\"Configuration bean cannot be instanciated, because bean class is null!\");\n+        }\n+    }\n+\n+    public final ApplicationScenario getApplicationScenario() {\n+        return scenario;\n+    }\n+\n+    public final String serialize() {\n+        final Serializer serializer = new Persister();\n+        final StringWriter writer = new StringWriter();\n+        try {\n+            serializer.write(configurationB, writer);\n+            return writer.toString();\n+        } catch (final Exception e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+        return null;\n+    }\n+\n+    public static <T extends ApplicationScenarioConfiguration<?>> T deserialize(\n+            final String serializedConfiguration, final Class<T> clazz) {\n+        final Serializer serializer = new Persister();\n+        final StringReader reader = new StringReader(serializedConfiguration);\n+        try {\n+            return serializer.read(clazz, reader);\n+        } catch (final Exception e) {\n+            LoggerFactory.getLogger(ApplicationScenarioConfiguration.class)\n+                    .error(e.getMessage(), e);\n+        }\n+        return null;\n+    }\n+\n+    public final void load() {\n+        load(null);\n+    }\n+\n+    public final void load(final String path) {\n+        logger.info(\"Loading %s.xml from path '%s'\", scenario.toString(), path);\n+\n+        String drmHandle = sysCaller.openDRMobject(\"appscenario-config.xml\", \"read\");\n+        if (drmHandle != null) {\n+            byte[] readConfig = sysCaller.getDRMobject(\"appscenario-config.xml\");\n+            if (readConfig != null) {\n+                try (\n+                    InputStream is = new ByteArrayInputStream(readConfig);\n+                    ) {\n+                    Serializer serializer = new Persister();\n+                    this.configurationB = serializer.read(\n+                            this.configurationClass, is);\n+                    is.close();\n+                    logger.info(\"%s loaded from '%s'\", scenario.toString(), path);\n+                } catch (final FileNotFoundException fnfe) {\n+                    logger.error(\"Could not open the \" + scenario.toString()\n+                                    + CONFIGURATION_FILE + this.configurationFileName,\n+                            fnfe);\n+                } catch (final Exception e) {\n+                    logger.error(\"Could not deserialize the \" + scenario.toString()\n+                            + CONFIGURATION_FILE + this.configurationFileName, e);\n+                }\n+            }\n+            sysCaller.closeDRMobject(drmHandle);\n+        }\n+        configurationCompleteFilePath = path;\n+    }\n+\n+    public final void save() {\n+        save(null);\n+    }\n+\n+    public final void save(final String path) {\n+        logger.info(\"Saving configuration...\");\n+        final Serializer serializer = new Persister();\n+\n+        ByteArrayOutputStream source = new ByteArrayOutputStream();\n+        try {\n+            serializer.write(getConfig(), source);\n+\n+            String drmHandle = sysCaller.openDRMobject(\"appscen-config.xml\", \"write\");\n+            sysCaller.writeDRMobject(drmHandle, source.toByteArray());\n+            sysCaller.closeDRMobject(drmHandle);\n+\n+            logger.info(\"%s configuration saved to %s\", scenario.toString(), path);\n+        } catch (final Exception e) {\n+            logger.error(\"Could not save the \" + scenario.toString()\n+                    + CONFIGURATION_FILE + this.configurationFileName, e);\n+        }\n+    }\n+\n+    public final void delete() {\n+        throw new de.atb.context.common.exceptions.NotImplementedException(\"deleting of config files is not supported!\");\n+    }\n+\n+    @Override\n+    public final void reset() {\n+        this.configurationB.reset();\n+    }\n+\n+    public final String getConfigurationFileName() {\n+        return this.configurationFileName;\n+    }\n+\n+    protected final B getConfig() {\n+        return this.configurationB;\n+    }\n+\n+}"
  },
  {
    "sha": "44ef59799de2de185b1e43a278bd9a4ae6be92b2",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/configuration/IConfigurationBean.java",
    "status": "added",
    "additions": 28,
    "deletions": 0,
    "changes": 28,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/configuration/IConfigurationBean.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/configuration/IConfigurationBean.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/configuration/IConfigurationBean.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,28 @@\n+package de.atb.context.common.configuration;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+/**\n+ * IConfigurationBean\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 417 $\n+ *\n+ */\n+public interface IConfigurationBean {\n+\n+\tvoid reset();\n+\n+}"
  },
  {
    "sha": "ccaad6b43ece322dd232389bdba2ce503a9df732",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/configuration/IConfigurationContainer.java",
    "status": "added",
    "additions": 30,
    "deletions": 0,
    "changes": 30,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/configuration/IConfigurationContainer.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/configuration/IConfigurationContainer.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/configuration/IConfigurationContainer.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,30 @@\n+package de.atb.context.common.configuration;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+/**\n+ * IConfigurationContainer\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 417 $\n+ * @param <B>\n+ *            B\n+ *\n+ */\n+public interface IConfigurationContainer<B extends IConfigurationBean> {\n+\n+\tvoid reset();\n+\n+}"
  },
  {
    "sha": "77da55c0a5309ee4c8f52f1a0501ed17e031a88d",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/exceptions/ConfigurationException.java",
    "status": "added",
    "additions": 100,
    "deletions": 0,
    "changes": 100,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/exceptions/ConfigurationException.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/exceptions/ConfigurationException.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/exceptions/ConfigurationException.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,100 @@\n+package de.atb.context.common.exceptions;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+/**\n+ * ConfigurationException\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 417 $\n+ *\n+ */\n+public class ConfigurationException extends Exception {\n+\n+\t/**\n+\t *\n+\t */\n+\tprivate static final long serialVersionUID = -1289806516067641033L;\n+\n+\t/**\n+\t * Constructs a new configuration exception with the specified detail\n+\t * message. The cause is not initialized, and may subsequently be\n+\t * initialized by a call to {@link #initCause}.\n+\t *\n+\t * @param message\n+\t *            the detail message. The detail message is saved for later\n+\t *            retrieval by the {@link #getMessage()} method.\n+\t */\n+\tpublic ConfigurationException(final String message) {\n+\t\tsuper(message);\n+\t}\n+\n+\t/**\n+\t * Constructs a new exception with the specified detail message and cause.\n+\t * <p>\n+\t * Note that the detail message associated with {@code cause} is\n+\t * <i>not</i> automatically incorporated in this exception's detail message.\n+\t *\n+\t * @param message\n+\t *            the detail message (which is saved for later retrieval by the\n+\t *            {@link #getMessage()} method).\n+\t * @param cause\n+\t *            the cause (which is saved for later retrieval by the\n+\t *            {@link #getCause()} method). (A <tt>null</tt> value is\n+\t *            permitted, and indicates that the cause is nonexistent or\n+\t *            unknown.)\n+\t * @since 1.4\n+\t */\n+\tpublic ConfigurationException(final String message, final Throwable cause) {\n+\t\tsuper(message, cause);\n+\t}\n+\n+\t/**\n+\t * Constructs a new configuration exception with the specified detail\n+\t * message. The cause is not initialized, and may subsequently be\n+\t * initialized by a call to {@link #initCause}.\n+\t *\n+\t * @param format\n+\t *            the format string for the detail message (which is saved for\n+\t *            later retrieval by the {@link #getMessage()} method).\n+\t * @param args\n+\t *            arguments to be passed to the format message string.\n+\t */\n+\tpublic ConfigurationException(final String format, final Object... args) {\n+\t\tsuper(String.format(format, args));\n+\t}\n+\n+\t/**\n+\t * Constructs a new exception with the specified detail message and cause.\n+\t * <p>\n+\t * Note that the detail message associated with {@code cause} is\n+\t * <i>not</i> automatically incorporated in this exception's detail message.\n+\t *\n+\t * @param format\n+\t *            the format string for the detail message (which is saved for\n+\t *            later retrieval by the {@link #getMessage()} method).\n+\t * @param cause\n+\t *            the cause (which is saved for later retrieval by the\n+\t *            {@link #getCause()} method). (A <tt>null</tt> value is\n+\t *            permitted, and indicates that the cause is nonexistent or\n+\t *            unknown.)\n+\t * @param args\n+\t *            arguments to be passed to the format message string.\n+\t */\n+\tpublic ConfigurationException(final String format, final Throwable cause,\n+\t\t\tfinal Object... args) {\n+\t\tsuper(String.format(format, args), cause);\n+\t}\n+}"
  },
  {
    "sha": "a442c282cef7aa0701648ee43915b7cdc27b56a1",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/exceptions/NotImplementedException.java",
    "status": "added",
    "additions": 99,
    "deletions": 0,
    "changes": 99,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/exceptions/NotImplementedException.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/exceptions/NotImplementedException.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/exceptions/NotImplementedException.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,99 @@\n+package de.atb.context.common.exceptions;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+/**\n+ * The {@code NotImplementedException} indicates that a certain method or\n+ * functionality has not been implemented. In contrast to the\n+ * {@code UnsupportedOperationException} there is a chance, that the method\n+ * throwing this exception will be implemented in the future.\n+ * <p>\n+ * {@code NotImplementedException} is one of those exceptions that can be\n+ * thrown during the normal operation of the Java Virtual Machine.\n+ * <p>\n+ * A method is not required to declare in its {@code throws} clause any\n+ * subclasses of {@code NotImplementedException} that might be thrown\n+ * during the execution of the method but not caught.\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 417 $\n+ *\n+ */\n+public class NotImplementedException extends RuntimeException {\n+\n+\tprivate static final long serialVersionUID = -8394430683381635001L;\n+\n+\t/**\n+\t * Constructs a new runtime exception with {@code null} as its detail\n+\t * message. The cause is not initialized, and may subsequently be\n+\t * initialized by a call to {@link #initCause}.\n+\t */\n+\tpublic NotImplementedException() {\n+\t\tsuper();\n+\t}\n+\n+\t/**\n+\t * Constructs a new runtime exception with the specified detail message. The\n+\t * cause is not initialized, and may subsequently be initialized by a call\n+\t * to {@link #initCause}.\n+\t *\n+\t * @param message\n+\t *            the detail message. The detail message is saved for later\n+\t *            retrieval by the {@link #getMessage()} method.\n+\t */\n+\tpublic NotImplementedException(final String message) {\n+\t\tsuper(message);\n+\t}\n+\n+\t/**\n+\t * Constructs a new runtime exception with the specified detail message and\n+\t * cause.\n+\t * <p>\n+\t * Note that the detail message associated with {@code cause} is\n+\t * <i>not</i> automatically incorporated in this runtime exception's detail\n+\t * message.\n+\t *\n+\t * @param message\n+\t *            the detail message (which is saved for later retrieval by the\n+\t *            {@link #getMessage()} method).\n+\t * @param cause\n+\t *            the cause (which is saved for later retrieval by the\n+\t *            {@link #getCause()} method). (A <tt>null</tt> value is\n+\t *            permitted, and indicates that the cause is nonexistent or\n+\t *            unknown.)\n+\t * @since 1.4\n+\t */\n+\tpublic NotImplementedException(final String message, final Throwable cause) {\n+\t\tsuper(message, cause);\n+\t}\n+\n+\t/**\n+\t * Constructs a new runtime exception with the specified cause and a detail\n+\t * message of <tt>(cause==null ? null : cause.toString())</tt> (which\n+\t * typically contains the class and detail message of <tt>cause</tt>). This\n+\t * constructor is useful for runtime exceptions that are little more than\n+\t * wrappers for other throwables.\n+\t *\n+\t * @param cause\n+\t *            the cause (which is saved for later retrieval by the\n+\t *            {@link #getCause()} method). (A <tt>null</tt> value is\n+\t *            permitted, and indicates that the cause is nonexistent or\n+\t *            unknown.)\n+\t * @since 1.4\n+\t */\n+\tpublic NotImplementedException(final Throwable cause) {\n+\t\tsuper(cause);\n+\t}\n+}"
  },
  {
    "sha": "dc7c475835dccf6533999cb2e6e371a9a017dc27",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/io/FileUtils.java",
    "status": "added",
    "additions": 133,
    "deletions": 0,
    "changes": 133,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/io/FileUtils.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/io/FileUtils.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/io/FileUtils.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,133 @@\n+package de.atb.context.common.io;\n+\n+/*-\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+\n+/**\n+ * @author Giovanni\n+ */\n+public class FileUtils {\n+    private static final Logger logger = LoggerFactory\n+            .getLogger(FileUtils.class);\n+\n+    private FileUtils() {\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T deserializeObjectFromFile(final String file) {\n+        return deserializeObjectFromFile(new File(file));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T deserializeObjectFromFile(final File file) {\n+        FileInputStream fIn = null;\n+        ObjectInputStream oIn = null;\n+\n+        try {\n+            fIn = new FileInputStream(file);\n+            oIn = new ObjectInputStream(fIn);\n+            return (T) oIn.readObject();\n+        } catch (IOException | ClassNotFoundException e) {\n+            logger.error(e.getMessage(), e);\n+        } finally {\n+            try {\n+                if (oIn != null) {\n+                    oIn.close();\n+                }\n+                if (fIn != null) {\n+                    fIn.close();\n+                }\n+            } catch (IOException e1) {\n+                logger.error(e1.getMessage(), e1);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public static <T> void serializeObjectToFile(final T object, final String file) {\n+        serializeToFile(object, new File(file));\n+    }\n+\n+    public static <T> void serializeToFile(final T object, final File file) {\n+        try (\n+            FileOutputStream fOut = new FileOutputStream(file);\n+            ObjectOutputStream oOut = new ObjectOutputStream(fOut);\n+        ) {\n+            oOut.writeObject(object);\n+        } catch (IOException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    public static String getExtension(final File file) {\n+        if (file != null) {\n+            return FilenameUtils.getExtension(file.getAbsolutePath());\n+        }\n+        return null;\n+    }\n+\n+    public static String getExtension(final String file) {\n+        return getExtension(new File(file));\n+    }\n+\n+    public static boolean hasValidExtension(final String file) {\n+        return isValidExtension(getExtension(file));\n+    }\n+\n+    public static boolean hasValidExtension(final File file) {\n+        return isValidExtension(getExtension(file));\n+    }\n+\n+    public static boolean isValidExtension(final String fileExt) {\n+        return (fileExt == null) || \"\".equals(fileExt);\n+    }\n+\n+    public static boolean ensureDirectoryExists(final String filePath) {\n+        if (filePath == null) {\n+            throw new NullPointerException(\"FilePath may not be null\");\n+        }\n+        File file = new File(filePath);\n+        if (file.exists() && file.isDirectory()) {\n+            return true;\n+        } else if (!file.exists()) {\n+            String path = file.getParent();\n+            File dir = new File(path);\n+            if (dir.exists()) {\n+                return true;\n+            }\n+            logger.info(path);\n+            return new File(path).mkdirs();\n+        } else if (file.exists()) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    // For Service Composition Editor BPMN File management\n+    public static void writeStringToFile(final String bean, final String file) {\n+        try (FileOutputStream fOut = new FileOutputStream(file);) {\n+            fOut.write(bean.getBytes());\n+            fOut.flush();\n+        } catch (IOException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+}"
  },
  {
    "sha": "0facba9b9ed6b68ee1d333cb9291fbe10b33bb4c",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/io/JsonObject.java",
    "status": "added",
    "additions": 321,
    "deletions": 0,
    "changes": 321,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/io/JsonObject.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/io/JsonObject.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/io/JsonObject.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,321 @@\n+package de.atb.context.common.io;\n+\n+/*-\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * This class holds a JSON object in a LinkedHashMap. LinkedHashMap used to keep\n+ * fields in same order as they are when reflecting them in Java. Instances of\n+ * this class hold a Map-of-Map representation of a Java object, read from the\n+ * JSON input stream.\n+ *\n+ * @param <K>\n+ *            field name in Map-of-Map\n+ * @param <V>\n+ *            Value\n+ *\n+ * @author John DeRegnaucourt (jdereg@gmail.com)\n+ *         Copyright (c) Cedar Software LLC\n+ *\n+ *         Licensed under the Apache License, Version 2.0 (the \"License\"); you\n+ *         may not use this file except in compliance with the License. You may\n+ *         obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ *         implied. See the License for the specific language governing\n+ *         permissions and limitations under the License.*\n+ */\n+@SuppressWarnings({ \"rawtypes\", \"serial\", \"unchecked\" })\n+public class JsonObject<K, V> extends LinkedHashMap<K, V> {\n+\tObject target;\n+\tboolean isMap = false;\n+\tString type;\n+\tlong id = -1;\n+\tint line;\n+\tint col;\n+\n+\tpublic final long getId() {\n+\t\treturn id;\n+\t}\n+\n+\tpublic final boolean hasId() {\n+\t\treturn id != -1;\n+\t}\n+\n+\tpublic final void setType(final String type) {\n+\t\tthis.type = type != null ? type.intern() : null;\n+\t}\n+\n+\tpublic final String getType() {\n+\t\treturn type;\n+\t}\n+\n+\tpublic final Object getTarget() {\n+\t\treturn target;\n+\t}\n+\n+\tpublic final void setTarget(final Object target) {\n+\t\tthis.target = target;\n+\t}\n+\n+\tpublic final Class getTargetClass() {\n+\t\treturn target.getClass();\n+\t}\n+\n+\tpublic final boolean isPrimitive() {\n+\t\treturn (\"int\".equals(type) || \"long\".equals(type)\n+\t\t\t\t|| \"boolean\".equals(type) || \"double\".equals(type)\n+\t\t\t\t|| \"byte\".equals(type) || \"short\".equals(type)\n+\t\t\t\t|| \"float\".equals(type) || \"char\".equals(type));\n+\t}\n+\n+\tpublic static boolean isPrimitiveWrapper(final Class c) {\n+\t\treturn Integer.class.equals(c) || Long.class.equals(c)\n+\t\t\t\t|| Boolean.class.equals(c) || Double.class.equals(c)\n+\t\t\t\t|| Byte.class.equals(c) || Short.class.equals(c)\n+\t\t\t\t|| Float.class.equals(c) || Character.class.equals(c);\n+\t}\n+\n+\tpublic final Object getPrimitiveValue() throws IOException {\n+\t\tif (\"int\".equals(type)) {\n+\t\t\tNumber integer = (Number) get(\"value\");\n+\t\t\treturn integer.intValue();\n+\t\t}\n+\t\tif (\"long\".equals(type) || \"boolean\".equals(type)\n+\t\t\t\t|| \"double\".equals(type)) {\n+\t\t\treturn get(\"value\");\n+\t\t}\n+\t\tif (\"byte\".equals(type)) {\n+\t\t\tNumber b = (Number) get(\"value\");\n+\t\t\treturn b.byteValue();\n+\t\t}\n+\t\tif (\"float\".equals(type)) {\n+\t\t\tNumber f = (Number) get(\"value\");\n+\t\t\treturn f.floatValue();\n+\t\t}\n+\t\tif (\"short\".equals(type)) {\n+\t\t\tNumber s = (Number) get(\"value\");\n+\t\t\treturn s.shortValue();\n+\t\t}\n+\t\tif (\"char\".equals(type)) {\n+\t\t\tString s = (String) get(\"value\");\n+\t\t\treturn s.charAt(0);\n+\t\t}\n+\t\treturn JsonReader.error(\"Invalid primitive type\");\n+\t}\n+\n+\t// Map APIs\n+\tpublic final boolean isMap() {\n+\t\tif (isMap || target instanceof Map) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (type == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\ttry {\n+\t\t\tClass c = JsonReader.classForName2(type);\n+\t\t\tif (Map.class.isAssignableFrom(c)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} catch (IOException ignored) {\n+\t\t\t//\n+\t\t}\n+\n+\t\treturn false;\n+\n+\t}\n+\n+\t// Collection APIs\n+\tpublic final boolean isCollection() {\n+\t\tif (containsKey(\"@items\") && !containsKey(\"@keys\")) {\n+\t\t\treturn ((target instanceof Collection) || (type != null && !type\n+\t\t\t\t\t.contains(\"[\")));\n+\t\t}\n+\n+\t\tif (type == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\ttry {\n+\t\t\tClass c = JsonReader.classForName2(type);\n+\t\t\tif (Collection.class.isAssignableFrom(c)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} catch (IOException ignored) {\n+\t\t    //\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t// Array APIs\n+\tpublic final boolean isArray() {\n+\t\tif (target == null) {\n+\t\t\tif (type != null) {\n+\t\t\t\treturn type.contains(\"[\");\n+\t\t\t}\n+\t\t\treturn containsKey(\"@items\") && !containsKey(\"@keys\");\n+\t\t}\n+\t\treturn target.getClass().isArray();\n+\t}\n+\n+\tpublic final Object[] getArray() {\n+\t\treturn (Object[]) get(\"@items\");\n+\t}\n+\n+\tpublic final int getLength() throws IOException {\n+\t\tif (isArray()) {\n+\t\t\tif (target == null) {\n+\t\t\t\tObject[] items = (Object[]) get(\"@items\");\n+\t\t\t\treturn items.length;\n+\t\t\t}\n+\t\t\treturn Array.getLength(target);\n+\t\t}\n+\t\tif (isCollection() || isMap()) {\n+\t\t\tObject[] items = (Object[]) get(\"@items\");\n+\t\t\treturn items == null ? 0 : items.length;\n+\t\t}\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"getLength() called on a non-collection, line \" + line\n+\t\t\t\t\t\t+ \", col \" + col);\n+\t}\n+\n+\tpublic final Class getComponentType() {\n+\t\treturn target.getClass().getComponentType();\n+\t}\n+\n+\tfinal void moveBytesToMate() {\n+\t\tbyte[] bytes = (byte[]) target;\n+\t\tObject[] items = getArray();\n+\t\tint len = items.length;\n+\n+\t\tfor (int i = 0; i < len; i++) {\n+\t\t\tbytes[i] = ((Number) items[i]).byteValue();\n+\t\t}\n+\t}\n+\n+\tfinal void moveCharsToMate() {\n+\t\tObject[] items = getArray();\n+\t\tif (items == null) {\n+\t\t\ttarget = null;\n+\t\t} else if (items.length == 0) {\n+\t\t\ttarget = new char[0];\n+\t\t} else if (items.length == 1) {\n+\t\t\tString s = (String) items[0];\n+\t\t\ttarget = s.toCharArray();\n+\t\t} else {\n+\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\"char[] should only have one String in the [], found \"\n+\t\t\t\t\t\t\t+ items.length + \", line \" + line + \", col \" + col);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic final V put(final K key, final V value) {\n+\t\tif (key == null) {\n+\t\t\treturn super.put(key, value);\n+\t\t}\n+\n+\t\tif (key.equals(\"@type\")) {\n+\t\t\tString oldType = type;\n+\t\t\ttype = (String) value;\n+\t\t\treturn (V) oldType;\n+\t\t} else if (key.equals(\"@id\")) {\n+\t\t\tLong oldId = id;\n+\t\t\tid = (Long) value;\n+\t\t\treturn (V) oldId;\n+\t\t} else if ((\"@items\".equals(key) && containsKey(\"@keys\"))\n+\t\t\t\t|| (\"@keys\".equals(key) && containsKey(\"@items\"))) {\n+\t\t\tisMap = true;\n+\t\t}\n+\t\treturn super.put(key, value);\n+\t}\n+\n+\t@Override\n+\tpublic final void clear() {\n+\t\tsuper.clear();\n+\t\ttype = null;\n+\t}\n+\n+\tfinal void clearArray() {\n+\t\tremove(\"@items\");\n+\t}\n+\n+\t/**\n+\t * This method is deprecated. Use getLine() and getCol() to determine where\n+\t * this object was read from in the JSON stream.\n+\t * \n+\t * @return int line number where this object was read from\n+\t */\n+\t@Deprecated\n+\tpublic final long getPos() {\n+\t\treturn line;\n+\t}\n+\n+\t/**\n+\t * @return int line where this object '{' started in the JSON stream\n+\t */\n+\tpublic final int getLine() {\n+\t\treturn line;\n+\t}\n+\n+\t/**\n+\t * @return int column where this object '{' started in the JSON stream\n+\t */\n+\tpublic final int getCol() {\n+\t\treturn col;\n+\t}\n+\n+\t@Override\n+\tpublic final int size() {\n+\t\tif (containsKey(\"@keys\")) {\n+\t\t\tObject value = get(\"@keys\");\n+\t\t\tif (value instanceof Object[]) {\n+\t\t\t\treturn ((Object[]) value).length;\n+\t\t\t} else if (value == null) {\n+\t\t\t\treturn 0;\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\t\"JsonObject with @keys, but no array [] associated to it, line \"\n+\t\t\t\t\t\t\t\t+ line + \", col \" + col);\n+\t\t\t}\n+\t\t} else if (containsKey(\"@items\")) {\n+\t\t\tObject value = get(\"@items\");\n+\t\t\tif (value instanceof Object[]) {\n+\t\t\t\treturn ((Object[]) value).length;\n+\t\t\t} else if (value == null) {\n+\t\t\t\treturn 0;\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\t\"JsonObject with @items, but no array [] associated to it, line \"\n+\t\t\t\t\t\t\t\t+ line + \", col \" + col);\n+\t\t\t}\n+\t\t} else if (containsKey(\"@ref\")) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\treturn super.size();\n+\t}\n+}"
  },
  {
    "sha": "d3daef54cdc1bbdbc97dddf88ded1bb9c8673de8",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/io/JsonReader.java",
    "status": "added",
    "additions": 3036,
    "deletions": 0,
    "changes": 3036,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/io/JsonReader.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/io/JsonReader.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/io/JsonReader.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3"
  },
  {
    "sha": "60a16e281f47394d70b1ecfe72160caf93f5883e",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/io/JsonWriter.java",
    "status": "added",
    "additions": 1740,
    "deletions": 0,
    "changes": 1740,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/io/JsonWriter.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/io/JsonWriter.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/io/JsonWriter.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,1740 @@\n+package de.atb.context.common.io;\n+\n+/*-\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+\n+import java.io.*;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.sql.Timestamp;\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+/**\n+ * Output a Java object graph in JSON format. This code handles cyclic\n+ * references and can serialize any Object graph without requiring a class to be\n+ * 'Serializeable' or have any specific methods on it.\n+ * <ul>\n+ * <li>\n+ * Call the static method: {@code JsonWriter.toJson(employee)}. This will\n+ * convert the passed in 'employee' instance into a JSON String.</li>\n+ * <li>Using streams:\n+  * <pre>\n+ * JsonWriter writer = new JsonWriter(stream);\n+ * writer.write(employee);\n+ * writer.close();\n+ * </pre>\n+ * This will write the 'employee' object to the passed in OutputStream.</li>\n+ * </ul>\n+ *\n+ * That's it. This can be used as a debugging tool. Output an object graph using\n+ * the above code. You can copy that JSON output into this site which formats it\n+ * with a lot of whitespace to make it human readable:\n+ * http://jsonformatter.curiousconcept.com\n+ *\n+ * This will output any object graph deeply (or null). Object references are\n+ * properly handled. For example, if you had A-&gt;B, B-&gt;C, and C-&gt;A, then A will\n+ * be serialized with a B object in it, B will be serialized with a C object in\n+ * it, and then C will be serialized with a reference to A (ref), not a\n+ * redefinition of A.\n+ *\n+ * @author John DeRegnaucourt (jdereg@gmail.com)\n+ *         Copyright (c) Cedar Software LLC\n+ *\n+ *         Licensed under the Apache License, Version 2.0 (the \"License\"); you\n+ *         may not use this file except in compliance with the License. You may\n+ *         obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ *         implied. See the License for the specific language governing\n+ *         permissions and limitations under the License.\n+ */\n+@SuppressWarnings({ \"rawtypes\", \"serial\", \"unchecked\" })\n+public class JsonWriter implements Closeable, Flushable {\n+\tpublic static final String DATE_FORMAT = \"DATE_FORMAT\";\n+\tpublic static final String ISO_DATE_FORMAT = \"yyyy-MM-dd\";\n+\tpublic static final String ISO_DATE_TIME_FORMAT = \"yyyy-MM-dd'T'HH:mm:ss\";\n+\tpublic static final String TYPE = \"TYPE\";\n+\tpublic static final String PRETTY_PRINT = \"PRETTY_PRINT\";\n+\tprivate static final Map<String, ClassMeta> _classMetaCache = new HashMap<>();\n+\tprivate static final List<Object[]> _writers = new ArrayList<>();\n+\tprivate static final Set<Class> _notCustom = new HashSet<>();\n+\tprivate static Object[] _byteStrings = new Object[256];\n+\tprivate static final String newLine = System.getProperty(\"line.separator\");\n+\tprivate final Map<Object, Long> _objVisited = new IdentityHashMap<>();\n+\tprivate final Map<Object, Long> _objsReferenced = new IdentityHashMap<>();\n+\tprivate final Writer _out;\n+\tprivate long _identity = 1;\n+\tprivate int depth = 0;\n+\t// _args is using ThreadLocal so that static inner classes can have access\n+\t// to them\n+\tstatic final ThreadLocal<Map<String, Object>> _args = ThreadLocal.withInitial(HashMap::new);\n+\tstatic final ThreadLocal<SimpleDateFormat> _dateFormat = ThreadLocal.withInitial(() -> new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"));\n+\n+\tstatic { // Add customer writers (these make common classes more succinct)\n+\t\taddWriter(String.class, new JsonStringWriter());\n+\t\taddWriter(Date.class, new DateWriter());\n+\t\taddWriter(BigInteger.class, new BigIntegerWriter());\n+\t\taddWriter(BigDecimal.class, new BigDecimalWriter());\n+\t\taddWriter(java.sql.Date.class, new DateWriter());\n+\t\taddWriter(Timestamp.class, new TimestampWriter());\n+\t\taddWriter(Calendar.class, new CalendarWriter());\n+\t\taddWriter(TimeZone.class, new TimeZoneWriter());\n+\t\taddWriter(Locale.class, new LocaleWriter());\n+\t\taddWriter(Class.class, new ClassWriter());\n+\t\taddWriter(StringBuilder.class, new StringBuilderWriter());\n+\t\taddWriter(StringBuffer.class, new StringBufferWriter());\n+\t}\n+\n+\tstatic {\n+\t\tfor (short i = -128; i <= 127; i++) {\n+\t\t\tchar[] chars = Integer.toString(i).toCharArray();\n+\t\t\t_byteStrings[i + 128] = chars;\n+\t\t}\n+\t}\n+\n+\tstatic class ClassMeta extends LinkedHashMap<String, Field> {\n+\t}\n+\n+\t/**\n+\t * @param item object to be converted\n+\t * @return returns an JSON String\n+\t * @throws java.io.IOException If an I/O error occurs\n+\t * @see JsonWriter#objectToJson(Object, java.util.Map)\n+\t */\n+\tpublic static String objectToJson(final Object item) throws IOException {\n+\t\treturn objectToJson(item, new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * Convert a Java Object to a JSON String.\n+\t *\n+\t * @param item\n+\t *            Object to convert to a JSON String.\n+\t * @param optionalArgs\n+\t *            (optional) Map of extra arguments indicating how dates are\n+\t *            formatted, what fields are written out (optional). For Date\n+\t *            parameters, use the public static DATE_TIME key, and then use\n+\t *            the ISO_DATE or ISO_DATE_TIME indicators. Or you can specify\n+\t *            your own custom SimpleDateFormat String, or you can associate\n+\t *            a SimpleDateFormat object, in which case it will be used. This\n+\t *            setting is for both java.util.Date and java.sql.Date. If the\n+\t *            DATE_FORMAT key is not used, then dates will be formatted as\n+\t *            longs. This long can be turned back into a date by using 'new\n+\t *            Date(longValue)'.\n+\t * @return String containing JSON representation of passed in object.\n+\t * @throws java.io.IOException\n+\t *             If an I/O error occurs\n+\t */\n+\tpublic static String objectToJson(final Object item,\n+\t\t\tfinal Map<String, Object> optionalArgs) throws IOException {\n+\t\tByteArrayOutputStream stream = new ByteArrayOutputStream();\n+\t\ttry (JsonWriter writer = new JsonWriter(stream, optionalArgs)) {\n+\t\t\twriter.write(item);\n+\t\t}\n+\t\treturn new String(stream.toByteArray(), \"UTF-8\");\n+\t}\n+\n+\t/**\n+\t * Format the passed in JSON string in a nice, human readable format.\n+\t * \n+\t * @param json\n+\t *            String input JSON\n+\t * @return String containing equivalent JSON, formatted nicely for human\n+\t *         readability.\n+\t * @throws java.io.IOException If an I/O error occurs\n+\t */\n+\tpublic static String formatJson(final String json) throws IOException {\n+\t\tMap map = JsonReader.jsonToMaps(json);\n+\t\tMap args = new HashMap();\n+\t\targs.put(PRETTY_PRINT, \"true\");\n+\t\treturn objectToJson(map, args);\n+\t}\n+\n+\t/**\n+\t * @param out writes to this stream\n+\t * @throws java.io.IOException If an I/O error occurs\n+\t * @see JsonWriter#JsonWriter(java.io.OutputStream, java.util.Map)\n+\t */\n+\tpublic JsonWriter(final OutputStream out) throws IOException {\n+\t\tthis(out, new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param out\n+\t *            OutputStream to which the JSON output will be written.\n+\t * @param optionalArgs\n+\t *            (optional) Map of extra arguments indicating how dates are\n+\t *            formatted, what fields are written out (optional). For Date\n+\t *            parameters, use the public static DATE_TIME key, and then use\n+\t *            the ISO_DATE or ISO_DATE_TIME indicators. Or you can specify\n+\t *            your own custom SimpleDateFormat String, or you can associate\n+\t *            a SimpleDateFormat object, in which case it will be used. This\n+\t *            setting is for both java.util.Date and java.sql.Date. If the\n+\t *            DATE_FORMAT key is not used, then dates will be formatted as\n+\t *            longs. This long can be turned back into a date by using 'new\n+\t *            Date(longValue)'.\n+\t * @throws IOException If an I/O error occurs\n+\t */\n+\tpublic JsonWriter(final OutputStream out, final Map<String, Object> optionalArgs)\n+\t\t\tthrows IOException {\n+\t\t_args.get().clear();\n+\t\t_args.get().putAll(optionalArgs);\n+\n+\t\ttry {\n+\t\t\t_out = new BufferedWriter(new OutputStreamWriter(out, \"UTF-8\"));\n+\t\t} catch (UnsupportedEncodingException e) {\n+\t\t\tthrow new IOException(\n+\t\t\t\t\t\"Unsupported encoding.  Get a JVM that supports UTF-8\", e);\n+\t\t}\n+\t}\n+\n+\tpublic interface JsonClassWriter {\n+\t\tvoid write(Object o, boolean showType, Writer out) throws IOException;\n+\n+\t\tboolean hasPrimitiveForm();\n+\n+\t\tvoid writePrimitiveForm(Object o, Writer out) throws IOException;\n+\t}\n+\n+\tpublic final boolean isPrettyPrint() {\n+\t\tObject setting = _args.get().get(PRETTY_PRINT);\n+\t\tif (setting instanceof Boolean) {\n+\t\t\treturn Boolean.TRUE.equals(setting);\n+\t\t} else if (setting instanceof String) {\n+\t\t\treturn \"true\".equalsIgnoreCase((String) setting);\n+\t\t} else if (setting instanceof Number) {\n+\t\t\treturn ((Number) setting).intValue() != 0;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\tprivate void tabIn(final Writer out) throws IOException {\n+\t\tif (!isPrettyPrint()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tout.write(newLine);\n+\t\tdepth++;\n+\t\tfor (int i = 0; i < depth; i++) {\n+\t\t\tout.write(\"  \");\n+\t\t}\n+\t}\n+\n+\tprivate void newLine(final Writer out) throws IOException {\n+\t\tif (!isPrettyPrint()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tout.write(newLine);\n+\t\tfor (int i = 0; i < depth; i++) {\n+\t\t\tout.write(\"  \");\n+\t\t}\n+\t}\n+\n+\tprivate void tabOut(final Writer out) throws IOException {\n+\t\tif (!isPrettyPrint()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tout.write(newLine);\n+\t\tdepth--;\n+\t\tfor (int i = 0; i < depth; i++) {\n+\t\t\tout.write(\"  \");\n+\t\t}\n+\t}\n+\n+\tpublic static int getDistance(final Class a, final Class b) {\n+\t\tClass curr = b;\n+\t\tint distance = 0;\n+\n+\t\twhile (curr != a) {\n+\t\t\tdistance++;\n+\t\t\tcurr = curr.getSuperclass();\n+\t\t\tif (curr == null) {\n+\t\t\t\treturn Integer.MAX_VALUE;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn distance;\n+\t}\n+\n+\tpublic final boolean writeIfMatching(final Object o, final boolean showType, final Writer out)\n+\t\t\tthrows IOException {\n+\t\tClass c = o.getClass();\n+\t\tif (_notCustom.contains(c)) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\treturn writeCustom(c, o, showType, out);\n+\t}\n+\n+\tpublic final boolean writeArrayElementIfMatching(final Class arrayComponentClass,\n+\t\t\tfinal Object o, final boolean showType, final Writer out) throws IOException {\n+\t\tif (!o.getClass().isAssignableFrom(arrayComponentClass)\n+\t\t\t\t|| _notCustom.contains(o.getClass())) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\treturn writeCustom(arrayComponentClass, o, showType, out);\n+\t}\n+\n+\tprivate boolean writeCustom(final Class arrayComponentClass, final Object o,\n+\t\t\tfinal boolean showType, final Writer out) throws IOException {\n+\t\tJsonClassWriter closestWriter = null;\n+\t\tint minDistance = Integer.MAX_VALUE;\n+\n+\t\tfor (Object[] item : _writers) {\n+\t\t\tClass clz = (Class) item[0];\n+\t\t\tif (clz == arrayComponentClass) {\n+\t\t\t\tclosestWriter = (JsonClassWriter) item[1];\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tint distance = getDistance(clz, arrayComponentClass);\n+\t\t\tif (distance < minDistance) {\n+\t\t\t\tminDistance = distance;\n+\t\t\t\tclosestWriter = (JsonClassWriter) item[1];\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (closestWriter == null) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (writeOptionalReference(o)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tboolean referenced = _objsReferenced.containsKey(o);\n+\n+\t\tif ((!referenced && !showType && closestWriter.hasPrimitiveForm())\n+\t\t\t\t|| closestWriter instanceof JsonStringWriter) {\n+\t\t\tclosestWriter.writePrimitiveForm(o, out);\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tout.write('{');\n+\t\ttabIn(out);\n+\t\tif (referenced) {\n+\t\t\twriteId(getId(o));\n+\t\t\tif (showType) {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (showType) {\n+\t\t\twriteType(o, out);\n+\t\t}\n+\n+\t\tif (referenced || showType) {\n+\t\t\tout.write(',');\n+\t\t\tnewLine(out);\n+\t\t}\n+\n+\t\tclosestWriter.write(o, showType || referenced, out);\n+\t\ttabOut(out);\n+\t\tout.write('}');\n+\t\treturn true;\n+\t}\n+\n+\tpublic static void addWriter(final Class c, final JsonClassWriter writer) {\n+\t\tfor (Object[] item : _writers) {\n+\t\t\tClass clz = (Class) item[0];\n+\t\t\tif (clz == c) {\n+\t\t\t\titem[1] = writer; // Replace writer\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t_writers.add(new Object[] { c, writer });\n+\t}\n+\n+\tpublic static void addNotCustomWriter(final Class c) {\n+\t\t_notCustom.add(c);\n+\t}\n+\n+\tpublic static class TimeZoneWriter implements JsonClassWriter {\n+\t\t@Override\n+\t\tpublic final void write(final Object obj, final boolean showType, final Writer out)\n+\t\t\t\tthrows IOException {\n+\t\t\tTimeZone cal = (TimeZone) obj;\n+\t\t\tout.write(\"\\\"zone\\\":\\\"\");\n+\t\t\tout.write(cal.getID());\n+\t\t\tout.write('\"');\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean hasPrimitiveForm() {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void writePrimitiveForm(final Object o, final Writer out) throws IOException {\n+\t\t}\n+\t}\n+\n+\tpublic static class CalendarWriter implements JsonClassWriter {\n+\t\t@Override\n+\t\tpublic final void write(final Object obj, final boolean showType, final Writer out)\n+\t\t\t\tthrows IOException {\n+\t\t\tCalendar cal = (Calendar) obj;\n+\t\t\t_dateFormat.get().setTimeZone(cal.getTimeZone());\n+\t\t\tout.write(\"\\\"time\\\":\\\"\");\n+\t\t\tout.write(_dateFormat.get().format(cal.getTime()));\n+\t\t\tout.write(\"\\\",\\\"zone\\\":\\\"\");\n+\t\t\tout.write(cal.getTimeZone().getID());\n+\t\t\tout.write('\"');\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean hasPrimitiveForm() {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void writePrimitiveForm(final Object o, final Writer out) throws IOException {\n+\t\t}\n+\t}\n+\n+\tpublic static class DateWriter implements JsonClassWriter {\n+\t\t@Override\n+\t\tpublic final void write(final Object obj, final boolean showType, final Writer out)\n+\t\t\t\tthrows IOException {\n+\t\t\tDate date = (Date) obj;\n+\t\t\tObject dateFormat = _args.get().get(DATE_FORMAT);\n+\t\t\tif (dateFormat instanceof String) { // Passed in as String, turn\n+\t\t\t\t\t\t\t\t\t\t\t\t// into a SimpleDateFormat\n+\t\t\t\t\t\t\t\t\t\t\t\t// instance to be used\n+\t\t\t\t\t\t\t\t\t\t\t\t// throughout this stream write.\n+\t\t\t\tdateFormat = new SimpleDateFormat((String) dateFormat);\n+\t\t\t\t_args.get().put(DATE_FORMAT, dateFormat);\n+\t\t\t}\n+\t\t\tif (showType) {\n+\t\t\t\tout.write(\"\\\"value\\\":\");\n+\t\t\t}\n+\n+\t\t\tif (dateFormat instanceof Format) {\n+\t\t\t\tout.write(\"\\\"\");\n+\t\t\t\tout.write(((Format) dateFormat).format(date));\n+\t\t\t\tout.write(\"\\\"\");\n+\t\t\t} else {\n+\t\t\t\tout.write(Long.toString(((Date) obj).getTime()));\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean hasPrimitiveForm() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final void writePrimitiveForm(final Object o, final Writer out) throws IOException {\n+\t\t\tif (_args.get().containsKey(DATE_FORMAT)) {\n+\t\t\t\twrite(o, false, out);\n+\t\t\t} else {\n+\t\t\t\tout.write(Long.toString(((Date) o).getTime()));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class TimestampWriter implements JsonClassWriter {\n+\t\t@Override\n+\t\tpublic final void write(final Object o, final boolean showType, final Writer out)\n+\t\t\t\tthrows IOException {\n+\t\t\tTimestamp tstamp = (Timestamp) o;\n+\t\t\tout.write(\"\\\"time\\\":\\\"\");\n+\t\t\tout.write(Long.toString((tstamp.getTime() / 1000) * 1000));\n+\t\t\tout.write(\"\\\",\\\"nanos\\\":\\\"\");\n+\t\t\tout.write(Integer.toString(tstamp.getNanos()));\n+\t\t\tout.write('\"');\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean hasPrimitiveForm() {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void writePrimitiveForm(final Object o, final Writer out) throws IOException {\n+\t\t}\n+\t}\n+\n+\tpublic static class ClassWriter implements JsonClassWriter {\n+\t\t@Override\n+\t\tpublic final void write(final Object obj, final boolean showType, final Writer out)\n+\t\t\t\tthrows IOException {\n+\t\t\tString value = ((Class) obj).getName();\n+\t\t\tout.write(\"\\\"value\\\":\");\n+\t\t\twriteJsonUtf8String(value, out);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean hasPrimitiveForm() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final void writePrimitiveForm(final Object o, final Writer out) throws IOException {\n+\t\t\twriteJsonUtf8String(((Class) o).getName(), out);\n+\t\t}\n+\t}\n+\n+\tpublic static class JsonStringWriter implements JsonClassWriter {\n+\t\t@Override\n+\t\tpublic final void write(final Object obj, final boolean showType, final Writer out)\n+\t\t\t\tthrows IOException {\n+\t\t\tout.write(\"\\\"value\\\":\");\n+\t\t\twriteJsonUtf8String((String) obj, out);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean hasPrimitiveForm() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final void writePrimitiveForm(final Object o, final Writer out) throws IOException {\n+\t\t\twriteJsonUtf8String((String) o, out);\n+\t\t}\n+\t}\n+\n+\tpublic static class LocaleWriter implements JsonClassWriter {\n+\t\t@Override\n+\t\tpublic final void write(final Object obj, final boolean showType, final Writer out)\n+\t\t\t\tthrows IOException {\n+\t\t\tLocale locale = (Locale) obj;\n+\n+\t\t\tout.write(\"\\\"language\\\":\\\"\");\n+\t\t\tout.write(locale.getLanguage());\n+\t\t\tout.write(\"\\\",\\\"country\\\":\\\"\");\n+\t\t\tout.write(locale.getCountry());\n+\t\t\tout.write(\"\\\",\\\"variant\\\":\\\"\");\n+\t\t\tout.write(locale.getVariant());\n+\t\t\tout.write('\"');\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean hasPrimitiveForm() {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void writePrimitiveForm(final Object o, final Writer out) throws IOException {\n+\t\t}\n+\t}\n+\n+\tpublic static class BigIntegerWriter implements JsonClassWriter {\n+\t\t@Override\n+\t\tpublic final void write(final Object obj, final boolean showType, final Writer out)\n+\t\t\t\tthrows IOException {\n+\t\t\tBigInteger big = (BigInteger) obj;\n+\t\t\tout.write(\"\\\"value\\\":\\\"\");\n+\t\t\tout.write(big.toString(10));\n+\t\t\tout.write('\"');\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean hasPrimitiveForm() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final void writePrimitiveForm(final Object o, final Writer out) throws IOException {\n+\t\t\tBigInteger big = (BigInteger) o;\n+\t\t\tout.write('\"');\n+\t\t\tout.write(big.toString(10));\n+\t\t\tout.write('\"');\n+\t\t}\n+\t}\n+\n+\tpublic static class BigDecimalWriter implements JsonClassWriter {\n+\t\t@Override\n+\t\tpublic final void write(final Object obj, final boolean showType, final Writer out)\n+\t\t\t\tthrows IOException {\n+\t\t\tBigDecimal big = (BigDecimal) obj;\n+\t\t\tout.write(\"\\\"value\\\":\\\"\");\n+\t\t\tout.write(big.toPlainString());\n+\t\t\tout.write('\"');\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean hasPrimitiveForm() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final void writePrimitiveForm(final Object o, final Writer out) throws IOException {\n+\t\t\tBigDecimal big = (BigDecimal) o;\n+\t\t\tout.write('\"');\n+\t\t\tout.write(big.toPlainString());\n+\t\t\tout.write('\"');\n+\t\t}\n+\t}\n+\n+\tpublic static class StringBuilderWriter implements JsonClassWriter {\n+\t\t@Override\n+\t\tpublic final void write(final Object obj, final boolean showType, final Writer out)\n+\t\t\t\tthrows IOException {\n+\t\t\tStringBuilder builder = (StringBuilder) obj;\n+\t\t\tout.write(\"\\\"value\\\":\\\"\");\n+\t\t\tout.write(builder.toString());\n+\t\t\tout.write('\"');\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean hasPrimitiveForm() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final void writePrimitiveForm(final Object o, final Writer out) throws IOException {\n+\t\t\tStringBuilder builder = (StringBuilder) o;\n+\t\t\tout.write('\"');\n+\t\t\tout.write(builder.toString());\n+\t\t\tout.write('\"');\n+\t\t}\n+\t}\n+\n+\tpublic static class StringBufferWriter implements JsonClassWriter {\n+\t\t@Override\n+\t\tpublic final void write(final Object obj, final boolean showType, final Writer out)\n+\t\t\t\tthrows IOException {\n+\t\t\tStringBuffer buffer = (StringBuffer) obj;\n+\t\t\tout.write(\"\\\"value\\\":\\\"\");\n+\t\t\tout.write(buffer.toString());\n+\t\t\tout.write('\"');\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final boolean hasPrimitiveForm() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic final void writePrimitiveForm(final Object o, final Writer out) throws IOException {\n+\t\t\tStringBuffer buffer = (StringBuffer) o;\n+\t\t\tout.write('\"');\n+\t\t\tout.write(buffer.toString());\n+\t\t\tout.write('\"');\n+\t\t}\n+\t}\n+\n+\tpublic final void write(final Object obj) throws IOException {\n+\t\ttraceReferences(obj);\n+\t\t_objVisited.clear();\n+\t\twriteImpl(obj, true);\n+\t\tflush();\n+\t\t_objVisited.clear();\n+\t\t_objsReferenced.clear();\n+\t\t_args.get().clear();\n+\t\t_args.remove();\n+\t}\n+\n+\tprivate void traceReferences(final Object root) {\n+\t\tLinkedList<Object> stack = new LinkedList<>();\n+\t\tstack.addFirst(root);\n+\t\tfinal Map<Object, Long> visited = _objVisited;\n+\t\tfinal Map<Object, Long> referenced = _objsReferenced;\n+\n+\t\twhile (!stack.isEmpty()) {\n+\t\t\tObject obj = stack.removeFirst();\n+\t\t\tif (obj == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tif (!JsonReader.isPrimitive(obj.getClass())\n+\t\t\t\t\t&& !(obj instanceof String) && !(obj instanceof Date)) {\n+\t\t\t\tLong id = visited.get(obj);\n+\t\t\t\tif (id != null) { // Only write an object once.\n+\t\t\t\t\treferenced.put(obj, id);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tvisited.put(obj, _identity++);\n+\t\t\t}\n+\n+\t\t\tfinal Class clazz = obj.getClass();\n+\n+\t\t\tif (clazz.isArray()) {\n+\t\t\t\tClass compType = clazz.getComponentType();\n+\t\t\t\tif (!JsonReader.isPrimitive(compType)\n+\t\t\t\t\t\t&& compType != String.class\n+\t\t\t\t\t\t&& !Date.class.isAssignableFrom(compType)) { // Speed\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// up:\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// do\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// not\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// traceReferences\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// of\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// primitives,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// they\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// cannot\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// reference\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// anything\n+\t\t\t\t\tfinal int len = Array.getLength(obj);\n+\n+\t\t\t\t\tfor (int i = 0; i < len; i++) {\n+\t\t\t\t\t\tObject o = Array.get(obj, i);\n+\t\t\t\t\t\tif (o != null) { // Slight perf gain (null is legal)\n+\t\t\t\t\t\t\tstack.addFirst(o);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\ttraceFields(stack, obj);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static void traceFields(final LinkedList<Object> stack, final Object obj) {\n+\t\tfinal ClassMeta fields = getDeepDeclaredFields(obj.getClass());\n+\n+\t\tfor (Field field : fields.values()) {\n+\t\t\ttry {\n+\t\t\t\tfinal Class<?> type = field.getType();\n+\t\t\t\tif (JsonReader.isPrimitive(type) || String.class == type\n+\t\t\t\t\t\t|| Date.class.isAssignableFrom(type)) { // speed up:\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// primitives\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// (Dates/Strings\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// considered\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// primitive by\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// json-io)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// cannot\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// reference\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// another\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// object\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tObject o = field.get(obj);\n+\t\t\t\tif (o != null) {\n+\t\t\t\t\tstack.addFirst(o);\n+\t\t\t\t}\n+\t\t\t} catch (IllegalAccessException | IllegalArgumentException ignored) {\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate boolean writeOptionalReference(final Object obj) throws IOException {\n+\t\tfinal Writer out = _out;\n+\t\tif (_objVisited.containsKey(obj)) { // Only write (define) an object\n+\t\t\t\t\t\t\t\t\t\t\t// once in the JSON stream,\n+\t\t\t\t\t\t\t\t\t\t\t// otherwise emit a @ref\n+\t\t\tString id = getId(obj);\n+\t\t\tif (id == null) { // Test for null because of Weak/Soft references\n+\t\t\t\t\t\t\t\t// being gc'd during serialization.\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tout.write(\"{\\\"@ref\\\":\");\n+\t\t\tout.write(id);\n+\t\t\tout.write('}');\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t// Mark the object as visited by putting it in the Map (this map is\n+\t\t// re-used / clear()'d after walk()).\n+\t\t_objVisited.put(obj, null);\n+\t\treturn false;\n+\t}\n+\n+\tprivate void writeImpl(final Object obj, final boolean showType) throws IOException {\n+\t\tif (obj == null) {\n+\t\t\t_out.write(\"null\");\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (obj.getClass().isArray()) {\n+\t\t\twriteArray(obj, showType);\n+\t\t} else if (obj instanceof Collection) {\n+\t\t\twriteCollection((Collection) obj, showType);\n+\t\t} else if (obj instanceof JsonObject) { // symmetric support for writing\n+\t\t\t\t\t\t\t\t\t\t\t\t// Map of Maps representation\n+\t\t\t\t\t\t\t\t\t\t\t\t// back as identical JSON\n+\t\t\t\t\t\t\t\t\t\t\t\t// format.\n+\t\t\tJsonObject jObj = (JsonObject) obj;\n+\t\t\tif (jObj.isArray()) {\n+\t\t\t\twriteJsonObjectArray(jObj, showType);\n+\t\t\t} else if (jObj.isCollection()) {\n+\t\t\t\twriteJsonObjectCollection(jObj, showType);\n+\t\t\t} else if (jObj.isMap()) {\n+\t\t\t\twriteJsonObjectMap(jObj, showType);\n+\t\t\t} else {\n+\t\t\t\twriteJsonObjectObject(jObj, showType);\n+\t\t\t}\n+\t\t} else if (obj instanceof Map) {\n+\t\t\twriteMap((Map) obj, showType);\n+\t\t} else {\n+\t\t\twriteObject(obj, showType);\n+\t\t}\n+\t}\n+\n+\tprivate void writeId(final String id) throws IOException {\n+\t\t_out.write(\"\\\"@id\\\":\");\n+\t\t_out.write(id == null ? \"0\" : id);\n+\t}\n+\n+\tprivate static void writeType(final Object obj, final Writer out) throws IOException {\n+\t\tout.write(\"\\\"@type\\\":\\\"\");\n+\t\tClass c = obj.getClass();\n+\n+\t\tif (Boolean.class == c) {\n+\t\t\tout.write(\"boolean\");\n+\t\t} else if (Byte.class == c) {\n+\t\t\tout.write(\"byte\");\n+\t\t} else if (Short.class == c) {\n+\t\t\tout.write(\"short\");\n+\t\t} else if (Integer.class == c) {\n+\t\t\tout.write(\"int\");\n+\t\t} else if (Long.class == c) {\n+\t\t\tout.write(\"long\");\n+\t\t} else if (Double.class == c) {\n+\t\t\tout.write(\"double\");\n+\t\t} else if (Float.class == c) {\n+\t\t\tout.write(\"float\");\n+\t\t} else if (Character.class == c) {\n+\t\t\tout.write(\"char\");\n+\t\t} else if (Date.class == c) {\n+\t\t\tout.write(\"date\");\n+\t\t} else if (Class.class == c) {\n+\t\t\tout.write(\"class\");\n+\t\t} else if (String.class == c) {\n+\t\t\tout.write(\"string\");\n+\t\t} else {\n+\t\t\tout.write(c.getName());\n+\t\t}\n+\t\tout.write('\"');\n+\t}\n+\n+\tprivate void writePrimitive(final Object obj) throws IOException {\n+\t\tif (obj instanceof Character) {\n+\t\t\twriteJsonUtf8String(String.valueOf(obj), _out);\n+\t\t} else {\n+\t\t\t_out.write(obj.toString());\n+\t\t}\n+\t}\n+\n+\tprivate void writeArray(final Object array, final boolean showType) throws IOException {\n+\t\tif (writeOptionalReference(array)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tClass arrayType = array.getClass();\n+\t\tint len = Array.getLength(array);\n+\t\tboolean referenced = _objsReferenced.containsKey(array);\n+\t\t// boolean typeWritten = showType && !(Object[].class == arrayType); //\n+\t\t// causes IDE warning in NetBeans 7/4 Java 1.7\n+\t\tboolean typeWritten = showType && !(arrayType.equals(Object[].class));\n+\n+\t\tfinal Writer out = _out; // performance opt: place in final local for\n+\t\t\t\t\t\t\t\t\t// quicker access\n+\t\tif (typeWritten || referenced) {\n+\t\t\tout.write('{');\n+\t\t\ttabIn(out);\n+\t\t}\n+\n+\t\tif (referenced) {\n+\t\t\twriteId(getId(array));\n+\t\t\tout.write(',');\n+\t\t\tnewLine(out);\n+\t\t}\n+\n+\t\tif (typeWritten) {\n+\t\t\twriteType(array, out);\n+\t\t\tout.write(',');\n+\t\t\tnewLine(out);\n+\t\t}\n+\n+\t\tif (len == 0) {\n+\t\t\tif (typeWritten || referenced) {\n+\t\t\t\tout.write(\"\\\"@items\\\":[]\");\n+\t\t\t\ttabOut(out);\n+\t\t\t\tout.write('}');\n+\t\t\t} else {\n+\t\t\t\tout.write(\"[]\");\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (typeWritten || referenced) {\n+\t\t\tout.write(\"\\\"@items\\\":[\");\n+\t\t} else {\n+\t\t\tout.write('[');\n+\t\t}\n+\t\ttabIn(out);\n+\n+\t\tfinal int lenMinus1 = len - 1;\n+\n+\t\t// Intentionally processing each primitive array type in separate\n+\t\t// custom loop for speed. All of them could be handled using\n+\t\t// reflective Array.get() but it is slower. I chose speed over code\n+\t\t// length.\n+\t\tif (byte[].class == arrayType) {\n+\t\t\twriteByteArray((byte[]) array, lenMinus1);\n+\t\t} else if (char[].class == arrayType) {\n+\t\t\twriteJsonUtf8String(new String((char[]) array), out);\n+\t\t} else if (short[].class == arrayType) {\n+\t\t\twriteShortArray((short[]) array, lenMinus1);\n+\t\t} else if (int[].class == arrayType) {\n+\t\t\twriteIntArray((int[]) array, lenMinus1);\n+\t\t} else if (long[].class == arrayType) {\n+\t\t\twriteLongArray((long[]) array, lenMinus1);\n+\t\t} else if (float[].class == arrayType) {\n+\t\t\twriteFloatArray((float[]) array, lenMinus1);\n+\t\t} else if (double[].class == arrayType) {\n+\t\t\twriteDoubleArray((double[]) array, lenMinus1);\n+\t\t} else if (boolean[].class == arrayType) {\n+\t\t\twriteBooleanArray((boolean[]) array, lenMinus1);\n+\t\t} else {\n+\t\t\tfinal Class componentClass = array.getClass().getComponentType();\n+\t\t\tfinal boolean isPrimitiveArray = JsonReader\n+\t\t\t\t\t.isPrimitive(componentClass);\n+\t\t\tfinal boolean isObjectArray = Object[].class == arrayType;\n+\n+\t\t\tfor (int i = 0; i < len; i++) {\n+\t\t\t\tfinal Object value = Array.get(array, i);\n+\n+\t\t\t\tif (value == null) {\n+\t\t\t\t\tout.write(\"null\");\n+\t\t\t\t} else if (isPrimitiveArray || value instanceof Boolean\n+\t\t\t\t\t\t|| value instanceof Long || value instanceof Double) {\n+\t\t\t\t\twritePrimitive(value);\n+\t\t\t\t} else if (writeArrayElementIfMatching(componentClass, value,\n+\t\t\t\t\t\tfalse, out)) {\n+\t\t\t\t} else if (isObjectArray) {\n+\t\t\t\t\tif (writeIfMatching(value, true, out)) {\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\twriteImpl(value, true);\n+\t\t\t\t\t}\n+\t\t\t\t} else { // Specific Class-type arrays - only force type when\n+\t\t\t\t\t\t\t// the instance is derived from array base class.\n+\t\t\t\t\tboolean forceType = !(value.getClass() == componentClass);\n+\t\t\t\t\twriteImpl(value, forceType || alwaysShowType());\n+\t\t\t\t}\n+\n+\t\t\t\tif (i != lenMinus1) {\n+\t\t\t\t\tout.write(',');\n+\t\t\t\t\tnewLine(out);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\ttabOut(out);\n+\t\tout.write(']');\n+\t\tif (typeWritten || referenced) {\n+\t\t\ttabOut(out);\n+\t\t\tout.write('}');\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @return true if the user set the 'TYPE' flag to true, indicating to\n+\t *         always show type.\n+\t */\n+\tprivate boolean alwaysShowType() {\n+\t\treturn Boolean.TRUE.equals(_args.get().get(TYPE));\n+\t}\n+\n+\tprivate void writeBooleanArray(final boolean[] booleans, final int lenMinus1)\n+\t\t\tthrows IOException {\n+\t\tfinal Writer out = _out;\n+\t\tfor (int i = 0; i < lenMinus1; i++) {\n+\t\t\tout.write(booleans[i] ? \"true,\" : \"false,\");\n+\t\t}\n+\t\tout.write(Boolean.toString(booleans[lenMinus1]));\n+\t}\n+\n+\tprivate void writeDoubleArray(final double[] doubles, final int lenMinus1)\n+\t\t\tthrows IOException {\n+\t\tfinal Writer out = _out;\n+\t\tfor (int i = 0; i < lenMinus1; i++) {\n+\t\t\tout.write(Double.toString(doubles[i]));\n+\t\t\tout.write(',');\n+\t\t}\n+\t\tout.write(Double.toString(doubles[lenMinus1]));\n+\t}\n+\n+\tprivate void writeFloatArray(final float[] floats, final int lenMinus1)\n+\t\t\tthrows IOException {\n+\t\tfinal Writer out = _out;\n+\t\tfor (int i = 0; i < lenMinus1; i++) {\n+\t\t\tout.write(Double.toString(floats[i]));\n+\t\t\tout.write(',');\n+\t\t}\n+\t\tout.write(Float.toString(floats[lenMinus1]));\n+\t}\n+\n+\tprivate void writeLongArray(final long[] longs, final int lenMinus1) throws IOException {\n+\t\tfinal Writer out = _out;\n+\t\tfor (int i = 0; i < lenMinus1; i++) {\n+\t\t\tout.write(Long.toString(longs[i]));\n+\t\t\tout.write(',');\n+\t\t}\n+\t\tout.write(Long.toString(longs[lenMinus1]));\n+\t}\n+\n+\tprivate void writeIntArray(final int[] ints, final int lenMinus1) throws IOException {\n+\t\tfinal Writer out = _out;\n+\t\tfor (int i = 0; i < lenMinus1; i++) {\n+\t\t\tout.write(Integer.toString(ints[i]));\n+\t\t\tout.write(',');\n+\t\t}\n+\t\tout.write(Integer.toString(ints[lenMinus1]));\n+\t}\n+\n+\tprivate void writeShortArray(final short[] shorts, final int lenMinus1)\n+\t\t\tthrows IOException {\n+\t\tfinal Writer out = _out;\n+\t\tfor (int i = 0; i < lenMinus1; i++) {\n+\t\t\tout.write(Integer.toString(shorts[i]));\n+\t\t\tout.write(',');\n+\t\t}\n+\t\tout.write(Integer.toString(shorts[lenMinus1]));\n+\t}\n+\n+\tprivate void writeByteArray(final byte[] bytes, final int lenMinus1) throws IOException {\n+\t\tfinal Writer out = _out;\n+\t\tfinal Object[] byteStrs = _byteStrings;\n+\t\tfor (int i = 0; i < lenMinus1; i++) {\n+\t\t\tout.write((char[]) byteStrs[bytes[i] + 128]);\n+\t\t\tout.write(',');\n+\t\t}\n+\t\tout.write((char[]) byteStrs[bytes[lenMinus1] + 128]);\n+\t}\n+\n+\tprivate void writeCollection(final Collection col, final boolean showType)\n+\t\t\tthrows IOException {\n+\t\tif (writeOptionalReference(col)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal Writer out = _out;\n+\t\tboolean referenced = _objsReferenced.containsKey(col);\n+\t\tboolean isEmpty = col.isEmpty();\n+\n+\t\tif (referenced || showType) {\n+\t\t\tout.write('{');\n+\t\t\ttabIn(out);\n+\t\t} else if (isEmpty) {\n+\t\t\tout.write('[');\n+\t\t}\n+\n+\t\tif (referenced) {\n+\t\t\twriteId(getId(col));\n+\t\t}\n+\n+\t\tif (showType) {\n+\t\t\tif (referenced) {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\t\t\twriteType(col, out);\n+\t\t}\n+\n+\t\tif (isEmpty) {\n+\t\t\tif (referenced || showType) {\n+\t\t\t\ttabOut(out);\n+\t\t\t\tout.write('}');\n+\t\t\t} else {\n+\t\t\t\tout.write(']');\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (showType || referenced) {\n+\t\t\tout.write(',');\n+\t\t\tnewLine(out);\n+\t\t\tout.write(\"\\\"@items\\\":[\");\n+\t\t} else {\n+\t\t\tout.write('[');\n+\t\t}\n+\t\ttabIn(out);\n+\n+\t\tIterator i = col.iterator();\n+\n+\t\twhile (i.hasNext()) {\n+\t\t\twriteCollectionElement(i.next());\n+\n+\t\t\tif (i.hasNext()) {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\ttabOut(out);\n+\t\tout.write(']');\n+\t\tif (showType || referenced) { // Finished object, as it was output as an\n+\t\t\t\t\t\t\t\t\t\t// object if @id or @type was output\n+\t\t\ttabOut(out);\n+\t\t\tout.write(\"}\");\n+\t\t}\n+\t}\n+\n+\tprivate void writeJsonObjectArray(final JsonObject jObj, final boolean showType)\n+\t\t\tthrows IOException {\n+\t\tif (writeOptionalReference(jObj)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tint len = jObj.getLength();\n+\t\tString type = jObj.type;\n+\t\tClass arrayClass;\n+\n+\t\tif (type == null || Object[].class.getName().equals(type)) {\n+\t\t\tarrayClass = Object[].class;\n+\t\t} else {\n+\t\t\tarrayClass = JsonReader.classForName2(type);\n+\t\t}\n+\n+\t\tfinal Writer out = _out;\n+\t\tfinal boolean isObjectArray = Object[].class == arrayClass;\n+\t\tfinal Class componentClass = arrayClass.getComponentType();\n+\t\tboolean referenced = _objsReferenced.containsKey(jObj) && jObj.hasId();\n+\t\tboolean typeWritten = showType && !isObjectArray;\n+\n+\t\tif (typeWritten || referenced) {\n+\t\t\tout.write('{');\n+\t\t\ttabIn(out);\n+\t\t}\n+\n+\t\tif (referenced) {\n+\t\t\twriteId(Long.toString(jObj.id));\n+\t\t\tout.write(',');\n+\t\t\tnewLine(out);\n+\t\t}\n+\n+\t\tif (typeWritten) {\n+\t\t\tout.write(\"\\\"@type\\\":\\\"\");\n+\t\t\tout.write(arrayClass.getName());\n+\t\t\tout.write(\"\\\",\");\n+\t\t\tnewLine(out);\n+\t\t}\n+\n+\t\tif (len == 0) {\n+\t\t\tif (typeWritten || referenced) {\n+\t\t\t\tout.write(\"\\\"@items\\\":[]\");\n+\t\t\t\ttabOut(out);\n+\t\t\t\tout.write(\"}\");\n+\t\t\t} else {\n+\t\t\t\tout.write(\"[]\");\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (typeWritten || referenced) {\n+\t\t\tout.write(\"\\\"@items\\\":[\");\n+\t\t} else {\n+\t\t\tout.write('[');\n+\t\t}\n+\t\ttabIn(out);\n+\n+\t\tObject[] items = (Object[]) jObj.get(\"@items\");\n+\t\tfinal int lenMinus1 = len - 1;\n+\n+\t\tfor (int i = 0; i < len; i++) {\n+\t\t\tfinal Object value = items[i];\n+\n+\t\t\tif (value == null) {\n+\t\t\t\tout.write(\"null\");\n+\t\t\t} else if (Character.class == componentClass\n+\t\t\t\t\t|| char.class == componentClass) {\n+\t\t\t\twriteJsonUtf8String((String) value, out);\n+\t\t\t} else if (value instanceof Boolean || value instanceof Long\n+\t\t\t\t\t|| value instanceof Double) {\n+\t\t\t\twritePrimitive(value);\n+\t\t\t} else if (value instanceof String) { // Have to specially treat\n+\t\t\t\t\t\t\t\t\t\t\t\t\t// String because it could\n+\t\t\t\t\t\t\t\t\t\t\t\t\t// be referenced, but we\n+\t\t\t\t\t\t\t\t\t\t\t\t\t// still want inline (no\n+\t\t\t\t\t\t\t\t\t\t\t\t\t// @type, value:)\n+\t\t\t\twriteJsonUtf8String((String) value, out);\n+\t\t\t} else if (isObjectArray) {\n+\t\t\t\tif (writeIfMatching(value, true, out)) {\n+\t\t\t\t} else {\n+\t\t\t\t\twriteImpl(value, true);\n+\t\t\t\t}\n+\t\t\t} else if (writeArrayElementIfMatching(componentClass, value,\n+\t\t\t\t\tfalse, out)) {\n+\t\t\t} else { // Specific Class-type arrays - only force type when\n+\t\t\t\t\t\t// the instance is derived from array base class.\n+\t\t\t\tboolean forceType = !(value.getClass() == componentClass);\n+\t\t\t\twriteImpl(value, forceType || alwaysShowType());\n+\t\t\t}\n+\n+\t\t\tif (i != lenMinus1) {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\t\t}\n+\n+\t\ttabOut(out);\n+\t\tout.write(']');\n+\t\tif (typeWritten || referenced) {\n+\t\t\ttabOut(out);\n+\t\t\tout.write('}');\n+\t\t}\n+\t}\n+\n+\tprivate void writeJsonObjectCollection(final JsonObject jObj, final boolean showType)\n+\t\t\tthrows IOException {\n+\t\tif (writeOptionalReference(jObj)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tString type = jObj.type;\n+\t\tClass colClass = JsonReader.classForName2(type);\n+\t\tboolean referenced = _objsReferenced.containsKey(jObj) && jObj.hasId();\n+\t\tfinal Writer out = _out;\n+\t\tint len = jObj.getLength();\n+\n+\t\tif (referenced || showType || len == 0) {\n+\t\t\tout.write('{');\n+\t\t\ttabIn(out);\n+\t\t}\n+\n+\t\tif (referenced) {\n+\t\t\twriteId(String.valueOf(jObj.id));\n+\t\t}\n+\n+\t\tif (showType) {\n+\t\t\tif (referenced) {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\t\t\tout.write(\"\\\"@type\\\":\\\"\");\n+\t\t\tout.write(colClass.getName());\n+\t\t\tout.write('\"');\n+\t\t}\n+\n+\t\tif (len == 0) {\n+\t\t\ttabOut(out);\n+\t\t\tout.write('}');\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (showType || referenced) {\n+\t\t\tout.write(',');\n+\t\t\tnewLine(out);\n+\t\t\tout.write(\"\\\"@items\\\":[\");\n+\t\t} else {\n+\t\t\tout.write('[');\n+\t\t}\n+\t\ttabIn(out);\n+\n+\t\tObject[] items = (Object[]) jObj.get(\"@items\");\n+\t\tfinal int itemsLen = items.length;\n+\t\tfinal int itemsLenMinus1 = itemsLen - 1;\n+\n+\t\tfor (int i = 0; i < itemsLen; i++) {\n+\t\t\twriteCollectionElement(items[i]);\n+\n+\t\t\tif (i != itemsLenMinus1) {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\t\t}\n+\n+\t\ttabOut(out);\n+\t\tout.write(\"]\");\n+\t\tif (showType || referenced) {\n+\t\t\ttabOut(out);\n+\t\t\tout.write('}');\n+\t\t}\n+\t}\n+\n+\tprivate void writeJsonObjectMap(final JsonObject jObj, final boolean paramShowType)\n+\t\t\tthrows IOException {\n+\t\tboolean showType = paramShowType;\n+\t\tif (writeOptionalReference(jObj)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tboolean referenced = _objsReferenced.containsKey(jObj) && jObj.hasId();\n+\t\tfinal Writer out = _out;\n+\n+\t\tout.write('{');\n+\t\ttabIn(out);\n+\t\tif (referenced) {\n+\t\t\twriteId(String.valueOf(jObj.getId()));\n+\t\t}\n+\n+\t\tif (showType) {\n+\t\t\tif (referenced) {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\t\t\tString type = jObj.getType();\n+\t\t\tif (type != null) {\n+\t\t\t\tClass mapClass = JsonReader.classForName2(type);\n+\t\t\t\tout.write(\"\\\"@type\\\":\\\"\");\n+\t\t\t\tout.write(mapClass.getName());\n+\t\t\t\tout.write('\"');\n+\t\t\t} else { // type not displayed\n+\t\t\t\tshowType = false;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (jObj.isEmpty()) { // Empty\n+\t\t\ttabOut(out);\n+\t\t\tout.write('}');\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (showType) {\n+\t\t\tout.write(',');\n+\t\t\tnewLine(out);\n+\t\t}\n+\n+\t\tout.write(\"\\\"@keys\\\":[\");\n+\t\ttabIn(out);\n+\t\tIterator i = jObj.keySet().iterator();\n+\n+\t\twhile (i.hasNext()) {\n+\t\t\twriteCollectionElement(i.next());\n+\n+\t\t\tif (i.hasNext()) {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\t\t}\n+\n+\t\ttabOut(out);\n+\t\tout.write(\"],\");\n+\t\tnewLine(out);\n+\t\tout.write(\"\\\"@items\\\":[\");\n+\t\ttabIn(out);\n+\t\ti = jObj.values().iterator();\n+\n+\t\twhile (i.hasNext()) {\n+\t\t\twriteCollectionElement(i.next());\n+\n+\t\t\tif (i.hasNext()) {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\t\t}\n+\n+\t\ttabOut(out);\n+\t\tout.write(']');\n+\t\ttabOut(out);\n+\t\tout.write('}');\n+\t}\n+\n+\tprivate void writeJsonObjectObject(final JsonObject jObj, final boolean paramShowType)\n+\t\t\tthrows IOException {\n+\t\tboolean showType = paramShowType;\n+\t\tif (writeOptionalReference(jObj)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal Writer out = _out;\n+\t\tboolean referenced = _objsReferenced.containsKey(jObj) && jObj.hasId();\n+\t\tshowType = showType && jObj.type != null;\n+\t\tClass type = null;\n+\n+\t\tout.write('{');\n+\t\ttabIn(out);\n+\t\tif (referenced) {\n+\t\t\twriteId(String.valueOf(jObj.id));\n+\t\t}\n+\n+\t\tif (showType) {\n+\t\t\tif (referenced) {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\t\t\tout.write(\"\\\"@type\\\":\\\"\");\n+\t\t\tout.write(jObj.type);\n+\t\t\tout.write('\"');\n+\t\t\ttry {\n+\t\t\t\ttype = JsonReader.classForName2(jObj.type);\n+\t\t\t} catch (IOException ignored) {\n+\t\t\t\ttype = null;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (jObj.isEmpty()) {\n+\t\t\ttabOut(out);\n+\t\t\tout.write('}');\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (showType || referenced) {\n+\t\t\tout.write(',');\n+\t\t\tnewLine(out);\n+\t\t}\n+\n+\t\tIterator<Map.Entry<String, Object>> i = jObj.entrySet().iterator();\n+\n+\t\twhile (i.hasNext()) {\n+\t\t\tMap.Entry<String, Object> entry = i.next();\n+\t\t\tfinal String fieldName = entry.getKey();\n+\t\t\tout.write('\"');\n+\t\t\tout.write(fieldName);\n+\t\t\tout.write(\"\\\":\");\n+\t\t\tObject value = entry.getValue();\n+\n+\t\t\tif (value == null) {\n+\t\t\t\tout.write(\"null\");\n+\t\t\t} else if (value instanceof BigDecimal\n+\t\t\t\t\t|| value instanceof BigInteger) {\n+\t\t\t\twriteImpl(value,\n+\t\t\t\t\t\t!doesValueTypeMatchFieldType(type, fieldName, value));\n+\t\t\t} else if (value instanceof Number || value instanceof Boolean) {\n+\t\t\t\tout.write(value.toString());\n+\t\t\t} else if (value instanceof String) {\n+\t\t\t\twriteJsonUtf8String((String) value, out);\n+\t\t\t} else if (value instanceof Character) {\n+\t\t\t\twriteJsonUtf8String(String.valueOf(value), out);\n+\t\t\t} else {\n+\t\t\t\twriteImpl(value,\n+\t\t\t\t\t\t!doesValueTypeMatchFieldType(type, fieldName, value));\n+\t\t\t}\n+\t\t\tif (i.hasNext()) {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\t\t}\n+\t\ttabOut(out);\n+\t\tout.write('}');\n+\t}\n+\n+\tprivate static boolean doesValueTypeMatchFieldType(final Class type,\n+\t\t\tfinal String fieldName, final Object value) {\n+\t\tif (type != null) {\n+\t\t\tClassMeta meta = getDeepDeclaredFields(type);\n+\t\t\tField field = meta.get(fieldName);\n+\t\t\treturn field != null && (value.getClass() == field.getType());\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprivate void writeMap(final Map map, final boolean showType) throws IOException {\n+\t\tif (writeOptionalReference(map)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal Writer out = _out;\n+\t\tboolean referenced = _objsReferenced.containsKey(map);\n+\n+\t\tout.write('{');\n+\t\ttabIn(out);\n+\t\tif (referenced) {\n+\t\t\twriteId(getId(map));\n+\t\t}\n+\n+\t\tif (showType) {\n+\t\t\tif (referenced) {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\t\t\twriteType(map, out);\n+\t\t}\n+\n+\t\tif (map.isEmpty()) {\n+\t\t\ttabOut(out);\n+\t\t\tout.write('}');\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (showType || referenced) {\n+\t\t\tout.write(',');\n+\t\t\tnewLine(out);\n+\t\t}\n+\n+\t\tout.write(\"\\\"@keys\\\":[\");\n+\t\ttabIn(out);\n+\t\tIterator i = map.keySet().iterator();\n+\n+\t\twhile (i.hasNext()) {\n+\t\t\twriteCollectionElement(i.next());\n+\n+\t\t\tif (i.hasNext()) {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\t\t}\n+\n+\t\ttabOut(out);\n+\t\tout.write(\"],\");\n+\t\tnewLine(out);\n+\t\tout.write(\"\\\"@items\\\":[\");\n+\t\ttabIn(out);\n+\t\ti = map.values().iterator();\n+\n+\t\twhile (i.hasNext()) {\n+\t\t\twriteCollectionElement(i.next());\n+\n+\t\t\tif (i.hasNext()) {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\t\t}\n+\n+\t\ttabOut(out);\n+\t\tout.write(']');\n+\t\ttabOut(out);\n+\t\tout.write('}');\n+\t}\n+\n+\t/**\n+\t * Write an element that is contained in some type of collection or Map.\n+\t * \n+\t * @param o\n+\t *            Collection element to output in JSON format.\n+\t * @throws IOException\n+\t *             if an error occurs writing to the output stream.\n+\t */\n+\tprivate void writeCollectionElement(final Object o) throws IOException {\n+\t\tif (o == null) {\n+\t\t\t_out.write(\"null\");\n+\t\t} else if (o instanceof Boolean || o instanceof Long\n+\t\t\t\t|| o instanceof Double) {\n+\t\t\t_out.write(o.toString());\n+\t\t} else if (o instanceof String) {\n+\t\t\twriteJsonUtf8String((String) o, _out);\n+\t\t} else {\n+\t\t\twriteImpl(o, true);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @param obj\n+\t *            Object to be written in JSON format\n+\t * @param showType\n+\t *            boolean true means show the \"@type\" field, false eliminates\n+\t *            it. Many times the type can be dropped because it can be\n+\t *            inferred from the field or array type.\n+\t * @throws IOException\n+\t *             if an error occurs writing to the output stream.\n+\t */\n+\tprivate void writeObject(final Object obj, final boolean showType) throws IOException {\n+\t\tif (writeIfMatching(obj, showType, _out)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (writeOptionalReference(obj)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal Writer out = _out;\n+\n+\t\tout.write('{');\n+\t\ttabIn(out);\n+\t\tboolean referenced = _objsReferenced.containsKey(obj);\n+\t\tif (referenced) {\n+\t\t\twriteId(getId(obj));\n+\t\t}\n+\n+\t\tClassMeta classInfo = getDeepDeclaredFields(obj.getClass());\n+\n+\t\tif (referenced && showType) {\n+\t\t\tout.write(',');\n+\t\t\tnewLine(out);\n+\t\t}\n+\n+\t\tif (showType) {\n+\t\t\twriteType(obj, out);\n+\t\t}\n+\n+\t\tboolean first = !showType;\n+\t\tif (referenced && !showType) {\n+\t\t\tfirst = false;\n+\t\t}\n+\n+\t\tfor (Map.Entry<String, Field> entry : classInfo.entrySet()) {\n+\t\t\tField field = entry.getValue();\n+\t\t\tif ((field.getModifiers() & Modifier.TRANSIENT) != 0) { // Do not\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// write\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// transient\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// fields\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (first) {\n+\t\t\t\tfirst = false;\n+\t\t\t} else {\n+\t\t\t\tout.write(',');\n+\t\t\t\tnewLine(out);\n+\t\t\t}\n+\n+\t\t\twriteJsonUtf8String(entry.getKey(), out);\n+\t\t\tout.write(':');\n+\n+\t\t\tObject o;\n+\t\t\ttry {\n+\t\t\t\to = field.get(obj);\n+\t\t\t} catch (IllegalArgumentException | IllegalAccessException ignored) {\n+\t\t\t\to = null;\n+\t\t\t}\n+\n+\t\t\tif (o == null) { // don't quote null\n+\t\t\t\tout.write(\"null\");\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tClass type = field.getType();\n+\t\t\tboolean forceType = o.getClass() != type; // If types are not\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t// exactly the same,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t// write \"@type\" field\n+\n+\t\t\tif (JsonReader.isPrimitive(type)) {\n+\t\t\t\twritePrimitive(o);\n+\t\t\t} else if (writeIfMatching(o, forceType, out)) {\n+\t\t\t} else {\n+\t\t\t\twriteImpl(o, forceType || alwaysShowType());\n+\t\t\t}\n+\t\t}\n+\n+\t\ttabOut(out);\n+\t\tout.write('}');\n+\t}\n+\n+\t/**\n+\t * Write out special characters \"\\b, \\f, \\t, \\n, \\r\", as such, backslash as\n+\t * \\\\ quote as \\\" and values less than an ASCII space (20hex) as \"\\\\u00xx\"\n+\t * format, characters in the range of ASCII space to a '~' as ASCII, and\n+\t * anything higher in UTF-8.\n+\t *\n+\t * @param s String to be written in utf8 format on the output stream.\n+\t * @param out the output will be written to this writer\n+\t * @throws IOException if an error occurs writing to the output stream.\n+\t */\n+\tpublic static void writeJsonUtf8String(final String s, final Writer out)\n+\t\t\tthrows IOException {\n+\t\tout.write('\\\"');\n+\t\tint len = s.length();\n+\n+\t\tfor (int i = 0; i < len; i++) {\n+\t\t\tchar c = s.charAt(i);\n+\n+\t\t\tif (c < ' ') { // Anything less than ASCII space, write either in\n+\t\t\t\t\t\t\t// \\\\u00xx form, or the special \\t, \\n, etc. form\n+\t\t\t\tif (c == '\\b') {\n+\t\t\t\t\tout.write(\"\\\\b\");\n+\t\t\t\t} else if (c == '\\t') {\n+\t\t\t\t\tout.write(\"\\\\t\");\n+\t\t\t\t} else if (c == '\\n') {\n+\t\t\t\t\tout.write(\"\\\\n\");\n+\t\t\t\t} else if (c == '\\f') {\n+\t\t\t\t\tout.write(\"\\\\f\");\n+\t\t\t\t} else if (c == '\\r') {\n+\t\t\t\t\tout.write(\"\\\\r\");\n+\t\t\t\t} else {\n+\t\t\t\t\tString hex = Integer.toHexString(c);\n+\t\t\t\t\tout.write(\"\\\\u\");\n+\t\t\t\t\tint pad = 4 - hex.length();\n+\t\t\t\t\tfor (int k = 0; k < pad; k++) {\n+\t\t\t\t\t\tout.write('0');\n+\t\t\t\t\t}\n+\t\t\t\t\tout.write(hex);\n+\t\t\t\t}\n+\t\t\t} else if (c == '\\\\' || c == '\"') {\n+\t\t\t\tout.write('\\\\');\n+\t\t\t\tout.write(c);\n+\t\t\t} else { // Anything else - write in UTF-8 form (multi-byte encoded)\n+\t\t\t\t\t\t// (OutputStreamWriter is UTF-8)\n+\t\t\t\tout.write(c);\n+\t\t\t}\n+\t\t}\n+\t\tout.write('\\\"');\n+\t}\n+\n+\t/**\n+\t * @param c\n+\t *            Class instance\n+\t * @return ClassMeta which contains fields of class. The results are cached\n+\t *         internally for performance when called again with same Class.\n+\t */\n+\tstatic ClassMeta getDeepDeclaredFields(final Class c) {\n+\t\tClassMeta classInfo = _classMetaCache.get(c.getName());\n+\t\tif (classInfo != null) {\n+\t\t\treturn classInfo;\n+\t\t}\n+\n+\t\tclassInfo = new ClassMeta();\n+\t\tClass curr = c;\n+\n+\t\twhile (curr != null) {\n+\t\t\ttry {\n+\t\t\t\tField[] local = curr.getDeclaredFields();\n+\n+\t\t\t\tfor (Field field : local) {\n+\t\t\t\t\tif ((field.getModifiers() & Modifier.STATIC) == 0) { // speed\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// up:\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// do\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// not\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// process\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// static\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// fields.\n+\t\t\t\t\t\tif (!field.isAccessible()) {\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\tfield.setAccessible(true);\n+\t\t\t\t\t\t\t} catch (SecurityException ignored) {\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (classInfo.containsKey(field.getName())) {\n+\t\t\t\t\t\t\tclassInfo.put(\n+\t\t\t\t\t\t\t\t\tcurr.getName() + '.' + field.getName(),\n+\t\t\t\t\t\t\t\t\tfield);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tclassInfo.put(field.getName(), field);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} catch (ThreadDeath t) {\n+\t\t\t\tthrow t;\n+\t\t\t} catch (SecurityException ignored) {\n+\t\t\t}\n+\n+\t\t\tcurr = curr.getSuperclass();\n+\t\t}\n+\n+\t\t_classMetaCache.put(c.getName(), classInfo);\n+\t\treturn classInfo;\n+\t}\n+\n+\t@Override\n+\tpublic final void flush() {\n+\t\ttry {\n+\t\t\tif (_out != null) {\n+\t\t\t\t_out.flush();\n+\t\t\t}\n+\t\t} catch (IOException ignored) {\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic final void close() {\n+\t\ttry {\n+\t\t\t_out.close();\n+\t\t} catch (IOException ignore) {\n+\t\t}\n+\t}\n+\n+\tprivate String getId(final Object o) {\n+\t\tif (o instanceof JsonObject) {\n+\t\t\tlong id = ((JsonObject) o).id;\n+\t\t\tif (id != -1) {\n+\t\t\t\treturn String.valueOf(id);\n+\t\t\t}\n+\t\t}\n+\t\tLong id = _objsReferenced.get(o);\n+\t\treturn id == null ? null : Long.toString(id);\n+\t}\n+}"
  },
  {
    "sha": "3ef3159a40aeeed3bbeacce52f3ccc78687ff608",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/io/NullOutputStream.java",
    "status": "added",
    "additions": 59,
    "deletions": 0,
    "changes": 59,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/io/NullOutputStream.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/io/NullOutputStream.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/io/NullOutputStream.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,59 @@\n+package de.atb.context.common.io;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+/**\n+ * NullOutputStream\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 417 $\n+ *\n+ */\n+public class NullOutputStream extends OutputStream {\n+\n+\t/*\n+\t * (non-Javadoc)\n+\t *\n+\t * @see java.io.OutputStream#write(int)\n+\t */\n+\t@Override\n+\tpublic void write(final int b) throws IOException {\n+\t\t//\n+\t}\n+\n+\t/*\n+\t * (non-Javadoc)\n+\t *\n+\t * @see java.io.OutputStream#write(byte[])\n+\t */\n+\t@Override\n+\tpublic void write(final byte[] b) throws IOException {\n+\t\t//\n+\t}\n+\n+\t/*\n+\t * (non-Javadoc)\n+\t *\n+\t * @see java.io.OutputStream#write(byte[], int, int)\n+\t */\n+\t@Override\n+\tpublic void write(final byte[] b, final int off, final int len)\n+\t\t\tthrows IOException {\n+\t\t//\n+\t}\n+}"
  },
  {
    "sha": "94e9b838e30ca8d7d67f7f326d38a45f20e70bf1",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/io/ResourceLoader.java",
    "status": "added",
    "additions": 91,
    "deletions": 0,
    "changes": 91,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/io/ResourceLoader.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/io/ResourceLoader.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/io/ResourceLoader.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,91 @@\n+package de.atb.context.common.io;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import de.atb.context.common.io.FileUtils;\n+\n+import java.io.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+\n+/**\n+ * ResourceLoader\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 703 $\n+ *\n+ */\n+public class ResourceLoader {\n+\n+\tprivate static final Logger logger = LoggerFactory\n+\t\t\t.getLogger(ResourceLoader.class);\n+\n+\tprivate ResourceLoader() {}\n+\n+\tpublic static boolean copyFileResource(final String resourcePath,\n+\t\t\tfinal File file) {\n+\t\tfinal InputStream is = ResourceLoader.getResourceStream(resourcePath);\n+\t\tif (is == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tFileUtils.ensureDirectoryExists(file.getAbsolutePath());\n+\n+\t\ttry (FileOutputStream fos = new FileOutputStream(file);) {\n+\n+\t\t\tfinal byte[] by = new byte[4096];\n+\t\t\tint bytesRead = 0;\n+\t\t\twhile ((bytesRead = is.read(by)) != -1) {\n+\t\t\t\tfos.write(by, 0, bytesRead);\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\tResourceLoader.logger.error(e.getMessage(), e);\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tpublic static boolean resourceExists(final String resourcePath) {\n+\t\treturn ResourceLoader.getResourceURI(resourcePath) != null;\n+\t}\n+\n+\tpublic static URI getResourceURI(final String resourcePath) {\n+\t\tfinal URL path = Thread.currentThread().getContextClassLoader()\n+\t\t\t\t.getResource(resourcePath);\n+\t\tif (path != null) {\n+\t\t\ttry {\n+\t\t\t\treturn path.toURI();\n+            } catch (final URISyntaxException e) {\n+\t\t\t\tResourceLoader.logger.error(e.getMessage(), e);\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic static File getResource(final String resourcePath) {\t// TODO this should maybe replace by a call to DRM API\n+\t\tfinal URI uri = ResourceLoader.getResourceURI(resourcePath);\n+\t\tif (uri != null) {\n+\t\t\treturn new File(uri);\n+\t\t}\n+\n+\t\treturn null;\n+\t}\n+\n+\tpublic static InputStream getResourceStream(final String resourcePath) {\n+\t\treturn Thread.currentThread().getContextClassLoader()\n+\t\t\t\t.getResourceAsStream(resourcePath);\n+\t}\n+}"
  },
  {
    "sha": "56be8d480d3681cb8fc38a520d3b3978bf5c92cd",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/util/ApplicationScenario.java",
    "status": "added",
    "additions": 184,
    "deletions": 0,
    "changes": 184,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/ApplicationScenario.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/ApplicationScenario.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/util/ApplicationScenario.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,184 @@\n+package de.atb.context.common.util;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+import de.atb.context.common.configuration.ApplicationScenarioConfiguration;\n+import de.atb.context.common.configuration.IConfigurationBean;\n+import de.atb.context.learning.models.IModelInitializer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * ApplicationScenario\n+ *\n+ * @author scholze, huesig\n+ * @version $LastChangedRevision: 701 $\n+ */\n+public class ApplicationScenario implements IModelInitializer {\n+    private final Logger logger = LoggerFactory\n+            .getLogger(ApplicationScenario.class);\n+\n+    private BusinessCase businessCase;\n+    private String modelInitializerClassName;\n+    private String configurationClassName;\n+    private String configurationDialogClassName;\n+    private Class<? extends ApplicationScenarioConfiguration<?>> configurationClass;\n+    private IModelInitializer initializer;\n+    private static volatile Map<String, ApplicationScenario> settings = new HashMap<String, ApplicationScenario>();\n+\n+    public static ApplicationScenario getInstance() {\n+        if (settings.get(\"DUMMY_SCENARIO\") == null) {\n+            settings.put(\"DUMMY_SCENARIO\", new ApplicationScenario(BusinessCase.getInstance(BusinessCase.NS_DUMMY_ID, BusinessCase.NS_DUMMY_URL)));\n+        }\n+        return settings.get(\"DUMMY_SCENARIO\");\n+    }\n+\n+    public static ApplicationScenario getInstance(BusinessCase businessCase) {\n+        if (settings.get(businessCase) == null) {\n+            settings.put(businessCase.toString(), new ApplicationScenario(businessCase));\n+        }\n+        return settings.get(businessCase.toString());\n+    }\n+\n+    public static ApplicationScenario getInstance(BusinessCase businessCase, String modelInitializerClassName) {\n+        if (settings.get(businessCase) == null) {\n+            settings.put(businessCase.toString(), new ApplicationScenario(businessCase, modelInitializerClassName));\n+        }\n+        return settings.get(businessCase.toString());\n+    }\n+\n+    ApplicationScenario(final BusinessCase businessCase) {\n+        this(businessCase, \"java.lang.Object\");\n+    }\n+\n+    ApplicationScenario(final BusinessCase businessCase,\n+                        final String modelInitializerClassName) {\n+        this(businessCase, modelInitializerClassName, null, null);\n+    }\n+\n+    ApplicationScenario(final BusinessCase businessCase,\n+                        final String modelInitializerClassName,\n+                        final String configurationClassName) {\n+        this(businessCase, modelInitializerClassName, configurationClassName,\n+                null);\n+    }\n+\n+    ApplicationScenario(final BusinessCase businessCase,\n+                        final String modelInitializerClassName,\n+                        final String configurationClassName,\n+                        final String configDialogClassName) {\n+        this.businessCase = businessCase;\n+        this.modelInitializerClassName = modelInitializerClassName;\n+        this.configurationClassName = configurationClassName;\n+        configurationDialogClassName = configDialogClassName;\n+    }\n+\n+    public BusinessCase getBusinessCase() {\n+        return businessCase;\n+    }\n+\n+    public static ApplicationScenario[] values() {\n+        return settings.values().toArray(new ApplicationScenario[0]);\n+    }\n+\n+    public static ApplicationScenario[] values(final BusinessCase businessCase) {\n+        final ApplicationScenario[] scenarios = ApplicationScenario.values();\n+        final List<ApplicationScenario> filteredScenarios = new ArrayList<>(\n+                scenarios.length);\n+        for (final ApplicationScenario scenario : scenarios) {\n+            if (scenario.getBusinessCase() == businessCase) {\n+                filteredScenarios.add(scenario);\n+            }\n+        }\n+        return filteredScenarios\n+                .toArray(new ApplicationScenario[filteredScenarios.size()]);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see de.atb.context.learning.models.IModelInitializer#getScenario()\n+     */\n+    @Override\n+    public ApplicationScenario getScenario() {\n+        if ((initializer != null) || createInitializer()) {\n+            return initializer.getScenario();\n+        }\n+        return null;\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see de.atb.context.learning.models.IModelInitializer#initializeModel()\n+     */\n+    @Override\n+    public boolean initializeModel(final String filePath) {\n+        if ((initializer != null) || createInitializer()) {\n+            return initializer.initializeModel(filePath);\n+        }\n+        return false;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends IConfigurationBean> Class<? extends ApplicationScenarioConfiguration<T>> getConfigurationClass() {\n+        if (configurationClass == null) {\n+            createConfigurationClass();\n+        }\n+        return (Class<? extends ApplicationScenarioConfiguration<T>>) configurationClass;\n+    }\n+\n+    public IModelInitializer getInitializer() {\n+        if (initializer == null) {\n+            createInitializer();\n+        }\n+        return initializer;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected boolean createConfigurationClass() {\n+        try {\n+            if (configurationClass == null) {\n+                final Class<? extends ApplicationScenarioConfiguration<?>> clazz = (Class<? extends ApplicationScenarioConfiguration<?>>) Class\n+                        .forName(configurationClassName);\n+                configurationClass = clazz;\n+            }\n+            return true;\n+        } catch (final ClassNotFoundException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+        return false;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected boolean createInitializer() {\n+        try {\n+            if (initializer == null) {\n+                final Class<? extends IModelInitializer> clazz = (Class<? extends IModelInitializer>) Class\n+                        .forName(modelInitializerClassName);\n+                initializer = clazz.newInstance();\n+            }\n+            return true;\n+        } catch (final ClassNotFoundException | InstantiationException | IllegalAccessException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+        return false;\n+    }\n+}"
  },
  {
    "sha": "29701cb79c53c7c47c087d9ac20c48e347b65afd",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/util/BusinessCase.java",
    "status": "added",
    "additions": 71,
    "deletions": 0,
    "changes": 71,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/BusinessCase.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/BusinessCase.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/util/BusinessCase.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,71 @@\n+package de.atb.context.common.util;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * BusinessCase\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 634 $\n+ *\n+ */\n+public class BusinessCase {\n+\tpublic static final String NS_BASE_ID = \"context\";\n+\tpublic static final String NS_BASE_URL = \"http://atb-bremen.de/\";\n+\n+\tpublic static final String NS_DUMMY_ID = \"dummy\";\n+\tpublic static final String NS_DUMMY_URL = BusinessCase.NS_BASE_URL + \"bc-dummy/\";\n+\n+\tprivate static volatile Map<String, BusinessCase> settings = new HashMap<String, BusinessCase>();\n+\tprivate String id;\n+\tprivate String url;\n+\n+\tpublic static void getInstance() {\n+\t\tif (settings.get(NS_DUMMY_ID) == null) {\n+\t\t\tsettings.put(NS_DUMMY_ID, new BusinessCase(NS_DUMMY_ID, NS_DUMMY_URL));\n+\t\t}\n+\t\tif (settings.get(NS_BASE_ID) == null) {\n+\t\t\tsettings.put(NS_BASE_ID, new BusinessCase(NS_BASE_ID, NS_BASE_URL));\n+\t\t}\n+\t}\n+\n+\tpublic static BusinessCase getInstance(String id, String url) {\n+\t\tif (settings.get(id) == null) {\n+\t\t\tsettings.put(id, new BusinessCase(id, url));\n+\t\t}\n+\t\treturn settings.get(id);\n+\t}\n+\n+\tpublic BusinessCase(String id, String url) {\n+\t\tthis.id = id;\n+\t\tthis.url = url;\n+\t}\n+\n+\tpublic BusinessCase getBusinessCase(String id) {\n+\t\treturn settings.get(id);\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn id;\n+\t}\n+\n+\tpublic static BusinessCase[] values() {\n+\t\treturn settings.values().toArray(new BusinessCase[0]);\n+\t}\n+}"
  },
  {
    "sha": "9d3c20fea00d362f03704c74759128c9fe517bcf",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/util/ClasspathHelper.java",
    "status": "added",
    "additions": 236,
    "deletions": 0,
    "changes": 236,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/ClasspathHelper.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/ClasspathHelper.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/util/ClasspathHelper.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,236 @@\n+package de.atb.context.common.util;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+import de.atb.context.services.faults.ContextFault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FilenameFilter;\n+import java.util.*;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+public abstract class ClasspathHelper {\n+\tprivate static final Logger LOGGER = LoggerFactory\n+\t\t\t.getLogger(ClasspathHelper.class);\n+\n+\tprivate ClasspathHelper() {}\n+\n+\tpublic static List<Class<?>> getAllClasses() {\n+\t\treturn ClasspathHelper.getAllClasses(false);\n+\t}\n+\n+\tpublic static List<Class<?>> getAllClasses(final boolean includeJars) {\n+\t\treturn ClasspathHelper.getAllClasses(null, includeJars);\n+\t}\n+\n+\tpublic static List<Class<?>> getMatchingClasses(final Class<?> classOrIface) {\n+\t\treturn ClasspathHelper.getMatchingClasses(null, classOrIface, false);\n+\t}\n+\n+\tpublic static List<Class<?>> getMatchingClasses(final String packagePrefix) {\n+\t\treturn ClasspathHelper.getAllClasses(packagePrefix, false);\n+\t}\n+\n+\tpublic static List<Class<?>> getMatchingClasses(final String packagePrefix,\n+\t\t\tfinal boolean includeJars) {\n+\t\treturn ClasspathHelper.getAllClasses(packagePrefix, includeJars);\n+\t}\n+\n+\tpublic static List<Class<?>> getMatchingClasses(\n+\t\t\tfinal Class<?> classOrIface, final boolean includeJars) {\n+\t\treturn ClasspathHelper.getMatchingClasses(null, classOrIface,\n+\t\t\t\tincludeJars);\n+\t}\n+\n+\tpublic static List<Class<?>> getMatchingClasses(final String packagePrefix,\n+\t\t\tfinal Class<?> classOrIface) {\n+\t\treturn ClasspathHelper.getMatchingClasses(packagePrefix, classOrIface,\n+\t\t\t\tfalse);\n+\t}\n+\n+\tpublic static List<Class<?>> getMatchingClasses(final String packagePrefix,\n+\t\t\tfinal Class<?> classOrIface, final boolean includeJars) {\n+\t\tfinal List<Class<?>> matchingClasses = new ArrayList<>();\n+\t\tfinal List<Class<?>> classes = ClasspathHelper.getAllClasses(\n+\t\t\t\tpackagePrefix, includeJars);\n+\t\tClasspathHelper.LOGGER.debug(String.format(\"checking %s classes\",\n+\t\t\t\tInteger.valueOf(classes.size())));\n+\t\tfor (final Class<?> clazz : classes) {\n+\t\t\tif (classOrIface.isAssignableFrom(clazz)) {\n+\t\t\t\tmatchingClasses.add(clazz);\n+\t\t\t\tClasspathHelper.LOGGER.debug(String.format(\n+\t\t\t\t\t\t\"class %s is assignable from %s\", classOrIface, clazz));\n+\t\t\t}\n+\t\t}\n+\t\treturn matchingClasses;\n+\t}\n+\n+\tpublic static List<File> getClassLocationsForCurrentClasspath() { // TODO this should maybe replace by a call to DRM API\n+\t\tfinal List<File> files = new ArrayList<>();\n+\t\tfinal String javaClassPath = System.getProperty(\"java.class.path\");\n+\t\tif (javaClassPath != null) {\n+\t\t\tfor (final String path : javaClassPath.split(File.pathSeparator)) {\n+\t\t\t\tfiles.add(new File(path));\n+\t\t\t}\n+\t\t}\n+\t\treturn files;\n+\t}\n+\n+\tprivate static List<Class<?>> getAllClasses(final String packagePrefix,\n+\t\t\tfinal boolean includeJars) {\n+\t\tfinal List<Class<?>> classFiles = new ArrayList<>();\n+\t\tfinal List<File> classLocations = ClasspathHelper\n+\t\t\t\t.getClassLocationsForCurrentClasspath();\n+\t\tfor (final File file : classLocations) {\n+\t\t\tclassFiles.addAll(ClasspathHelper.getClassesFromPath(file,\n+\t\t\t\t\tpackagePrefix, includeJars));\n+\t\t}\n+\t\treturn classFiles;\n+\t}\n+\n+\tprivate static Collection<? extends Class<?>> getClassesFromPath(\n+\t\t\tfinal File path, final String packagePrefix,\n+\t\t\tfinal boolean includeJars) {\n+\t\tif (path.isDirectory()) {\n+\t\t\treturn ClasspathHelper.getClassesFromDirectory(path, packagePrefix,\n+\t\t\t\t\tincludeJars);\n+\t\t} else {\n+\t\t\tif (includeJars) {\n+\t\t\t\treturn ClasspathHelper.getClassesFromJar(path, packagePrefix);\n+\t\t\t} else {\n+\t\t\t\treturn Collections.emptyList();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static String getClassName(final String fileName) {\n+\t\treturn fileName.substring(0, fileName.length() - 6).replaceAll(\n+\t\t\t\t\"/|\\\\\\\\\", \"\\\\.\");\n+\t}\n+\n+\tprivate static List<Class<?>> getClassesFromJar(final File path,\n+\t\t\tfinal String packagePrefix) { // TODO this should maybe replace by a call to DRM API\n+\t\tfinal List<Class<?>> classes = new ArrayList<>();\n+\t\tClasspathHelper.LOGGER.debug(String.format(\"Getting classes for %s\",\n+\t\t\t\tpath));\n+\t\ttry (JarFile jar = new JarFile(path);) {\n+\t\t\tif (!path.canRead()) {\n+\t\t\t\treturn classes;\n+\t\t\t}\n+\n+\t\t\tfinal Enumeration<JarEntry> en = jar.entries();\n+\t\t\twhile (en.hasMoreElements()) {\n+\t\t\t\tfinal JarEntry entry = en.nextElement();\n+\t\t\t\tif (!entry.getName().endsWith(\"class\")) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tfinal String className = ClasspathHelper.getClassName(entry\n+\t\t\t\t\t\t.getName());\n+\t\t\t\tif (packagePrefix != null) {\n+\t\t\t\t\tif (className.startsWith(packagePrefix)) {\n+\t\t\t\t\t\tClasspathHelper.LOGGER.debug(String.format(\"found %s\",\n+\t\t\t\t\t\t\t\tclassName));\n+\t\t\t\t\t\tClasspathHelper.loadClass(classes, className);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tClasspathHelper.LOGGER.debug(String.format(\"found %s\",\n+\t\t\t\t\t\t\tclassName));\n+\t\t\t\t\tClasspathHelper.loadClass(classes, className);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (final Exception e) {\n+\t\t\tthrow new ContextFault(\"Failed to read classes from jar file: \"\n+\t\t\t\t\t+ path, e);\n+\t\t}\n+\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static List<Class<?>> getClassesFromDirectory(final File path,\n+\t\t\tfinal String packagePrefix, final boolean includeJars) {\n+\t\tfinal List<Class<?>> classes = new ArrayList<>();\n+\t\tClasspathHelper.LOGGER.debug(String.format(\"Getting classes for %s\",\n+\t\t\t\tpath));\n+\n+\t\tif (includeJars) {\n+\t\t\tfinal List<File> jarFiles = ClasspathHelper.getFileList(path,\n+                    (dir, name) -> name.endsWith(\".jar\"), false);\n+\t\t\tfor (final File file : jarFiles) {\n+\t\t\t\tclasses.addAll(ClasspathHelper.getClassesFromJar(file,\n+\t\t\t\t\t\tpackagePrefix));\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal List<File> classFiles = ClasspathHelper.getFileList(path,\n+                (dir, name) -> name.endsWith(\".class\"), true);\n+\n+\t\tfinal int substringBeginIndex = path.getAbsolutePath().length() + 1;\n+\t\tfor (final File classfile : classFiles) {\n+\t\t\tString className = classfile.getAbsolutePath().substring(\n+\t\t\t\t\tsubstringBeginIndex);\n+\t\t\tclassName = ClasspathHelper.getClassName(className);\n+\t\t\tif (packagePrefix != null) {\n+\t\t\t\tif (className.startsWith(packagePrefix)) {\n+\t\t\t\t\tClasspathHelper.LOGGER.debug(String.format(\n+\t\t\t\t\t\t\t\"Found class %s in path %s: \", className, path));\n+\t\t\t\t\tClasspathHelper.loadClass(classes, className);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tClasspathHelper.LOGGER.debug(String.format(\n+\t\t\t\t\t\t\"Found class %s in path %s: \", className, path));\n+\t\t\t\tClasspathHelper.loadClass(classes, className);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static List<File> getFileList(final File directory,\n+\t\t\tfinal FilenameFilter filter, final boolean recursive) {\n+\t\tfinal List<File> fileList = new ArrayList<>();\n+\t\tfinal File[] files = directory.listFiles();\n+\n+\t\tfor (final File file : files) {\n+\t\t\tif ((filter == null) || filter.accept(directory, file.getName())) {\n+\t\t\t\tfileList.add(file);\n+\t\t\t}\n+\t\t\tif (recursive && file.isDirectory()) {\n+\t\t\t\tfileList.addAll(ClasspathHelper.getFileList(file, filter,\n+\t\t\t\t\t\trecursive));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn fileList;\n+\t}\n+\n+\tprivate static void loadClass(final List<Class<?>> classes,\n+\t\t\tfinal String className) {\n+\t\ttry {\n+\t\t\tfinal Class<?> clazz = Class.forName(className, false,\n+\t\t\t\t\tClassLoader.getSystemClassLoader());\n+\t\t\tclasses.add(clazz);\n+\t\t} catch (final ClassNotFoundException cnfe) {\n+\t\t\tClasspathHelper.LOGGER.error(cnfe.getMessage(), cnfe);\n+\t\t} catch (final NoClassDefFoundError e) {\n+\t\t\tClasspathHelper.LOGGER.error(e.getMessage(), e);\n+\t\t} catch (final VerifyError ve) {\n+\t\t\tClasspathHelper.LOGGER.error(ve.getMessage(), ve);\n+\t\t}\n+\t}\n+}"
  },
  {
    "sha": "52806da0ec71b90819f20edba604e1da4d5b977a",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/util/DynamicEnum.java",
    "status": "added",
    "additions": 131,
    "deletions": 0,
    "changes": 131,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/DynamicEnum.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/DynamicEnum.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/util/DynamicEnum.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,131 @@\n+package de.atb.context.common.util;\n+\n+/*-\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectStreamException;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+public class DynamicEnum<E extends DynamicEnum<E>> {\n+    private static Map<Class<? extends DynamicEnum<?>>, Map<String, DynamicEnum<?>>> elements =\n+            new LinkedHashMap<Class<? extends DynamicEnum<?>>, Map<String, DynamicEnum<?>>>();\n+\n+    private final String name;\n+\n+    public final String name() {\n+        return name;\n+    }\n+\n+    public final int ordinal;\n+\n+    public final int ordinal() {\n+        return ordinal;\n+    }\n+\n+    protected DynamicEnum(String name, int ordinal) {\n+        this.name = name;\n+        this.ordinal = ordinal;\n+        Map<String, DynamicEnum<?>> typeElements = elements.get(getClass());\n+        if (typeElements == null) {\n+            typeElements = new LinkedHashMap<>();\n+            elements.put(getDynaEnumClass(), typeElements);\n+        }\n+        typeElements.put(name, this);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Class<? extends DynamicEnum<?>> getDynaEnumClass() {\n+        return (Class<? extends DynamicEnum<?>>)getClass();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    @Override\n+    public final boolean equals(Object other) {\n+        return this == other;\n+    }\n+\n+    @Override\n+    public final int hashCode() {\n+        return super.hashCode();\n+    }\n+\n+    @Override\n+    protected final Object clone() throws CloneNotSupportedException {\n+        throw new CloneNotSupportedException();\n+    }\n+\n+    public final int compareTo(E other) {\n+        DynamicEnum<?> self = this;\n+        if (self.getClass() != other.getClass() && // optimization\n+                self.getDeclaringClass() != other.getDeclaringClass())\n+            throw new ClassCastException();\n+        return self.ordinal - other.ordinal;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public final Class<E> getDeclaringClass() {\n+        Class clazz = getClass();\n+        Class zuper = clazz.getSuperclass();\n+        return (zuper == DynamicEnum.class) ? clazz : zuper;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T extends DynamicEnum<T>> T valueOf(Class<T> enumType, String name) {\n+        return (T)elements.get(enumType).get(name);\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private void readObject(ObjectInputStream in) throws IOException,\n+            ClassNotFoundException {\n+        throw new InvalidObjectException(\"can't deserialize enum\");\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private void readObjectNoData() throws ObjectStreamException {\n+        throw new InvalidObjectException(\"can't deserialize enum\");\n+    }\n+\n+    @Override\n+    protected final void finalize() { }\n+\n+\n+    public static <E> DynamicEnum<? extends DynamicEnum<?>>[] values() {\n+        throw new IllegalStateException(\"Sub class of DynaEnum must implement method valus()\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> E[] values(Class<E> enumType) {\n+        Collection<DynamicEnum<?>> values =  elements.get(enumType).values();\n+        int n = values.size();\n+        E[] typedValues = (E[]) Array.newInstance(enumType, n);\n+        int i = 0;\n+        for (DynamicEnum<?> value : values) {\n+            Array.set(typedValues, i, value);\n+            i++;\n+        }\n+\n+        return typedValues;\n+    }\n+}"
  },
  {
    "sha": "f243c82c1eb5c81c1dad92a7b258245777938cd1",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/util/Hashing.java",
    "status": "added",
    "additions": 264,
    "deletions": 0,
    "changes": 264,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/Hashing.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/Hashing.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/util/Hashing.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,264 @@\n+package de.atb.context.common.util;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Formatter;\n+\n+/**\n+ * Hashing\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 417 $\n+ *\n+ */\n+public class Hashing {\n+\n+\tpublic static final String ALGORITHM_MD5 = \"MD5\";\n+\n+\tpublic static final String ALGORITHM_SHA1 = \"SHA-1\";\n+\n+\tpublic static final String ALGORITHM_SHA256 = \"SHA-256\";\n+\n+\tprivate Hashing(){}\n+\n+\t/**\n+\t * Calculates the MD5 hash sum of the given string.\n+\t *\n+\t * @param toHash\n+\t *            the string to get the MD5 hash for.\n+\t * @return the MD5 hash for the specified string.\n+\t */\n+\tpublic static String getMD5Hash(final String toHash) {\n+\t\treturn Hashing.getStringHash(toHash, Hashing.ALGORITHM_MD5);\n+\t}\n+\n+\t/**\n+\t * Calculates the SHA-1 hash sum of the given string.\n+\t *\n+\t * @param toHash\n+\t *            the string to get the SHA-1 hash for.\n+\t * @return the SHA-1 hash for the specified string.\n+\t */\n+\tpublic static String getSHA1Hash(final String toHash) {\n+\t\treturn Hashing.getStringHash(toHash, Hashing.ALGORITHM_SHA1);\n+\t}\n+\n+\t/**\n+\t * Calculates the SHA-256 hash sum of the given string.\n+\t *\n+\t * @param toHash\n+\t *            the string to get the SHA-256 hash for.\n+\t * @return the SHA-256 hash for the specified string.\n+\t */\n+\tpublic static String getSHA256Hash(final String toHash) {\n+\t\treturn Hashing.getStringHash(toHash, Hashing.ALGORITHM_SHA1);\n+\t}\n+\n+\t/**\n+\t * Calculates the hash for the given string by using the given algorithm.\n+\t *\n+\t * @param toHash\n+\t *            the string to get the hash for.\n+\t * @param algorithm\n+\t *            the message digest algorithm used for hashing (like &quot;\n+\t *            {@code MD5}&quot; or &quot;<code>SHA-1</code>&quot;).\n+\t * @return the hash for the specified string.\n+\t */\n+\tpublic static String getStringHash(final String toHash,\n+\t\t\tfinal String algorithm) {\n+\t\ttry {\n+\t\t\tfinal MessageDigest md = MessageDigest.getInstance(algorithm);\n+\t\t\tmd.update(toHash.getBytes());\n+\t\t\treturn Hashing.formatBytesArray(md.digest());\n+\t\t} catch (final NoSuchAlgorithmException e) {\n+\t\t\tLoggerFactory.getLogger(Hashing.class).error(e.getMessage(), e);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Calculates the MD5 check sum of the given file.\n+\t *\n+\t * @param fileName\n+\t *            the name (and path) of the file to calculate the MD5 checksum\n+\t *            for.\n+\t * @return the MD5 based checksum of the given file.\n+\t */\n+\tpublic static String getMD5Checksum(final String fileName) {\n+\t\treturn Hashing.getChecksum(new File(fileName), Hashing.ALGORITHM_MD5);\n+\t}\n+\n+\t/**\n+\t * Calculates the SHA-1 check sum of the given file.\n+\t *\n+\t * @param fileName\n+\t *            the name (and path) of the file to calculate the SHA-1\n+\t *            checksum for.\n+\t * @return the SHA-1 based checksum of the given file.\n+\t */\n+\tpublic static String getSHA1Checksum(final String fileName) {\n+\t\treturn Hashing.getChecksum(new File(fileName), Hashing.ALGORITHM_SHA1);\n+\t}\n+\n+\t/**\n+\t * Calculates the SHA-1 check sum of the given file.\n+\t *\n+\t * @param fileName\n+\t *            the name (and path) of the file to calculate the SHA-1\n+\t *            checksum for.\n+\t * @return the SHA-1 based checksum of the given file.\n+\t */\n+\tpublic static String getSHA256Checksum(final String fileName) {\n+\t\treturn Hashing\n+\t\t\t\t.getChecksum(new File(fileName), Hashing.ALGORITHM_SHA256);\n+\t}\n+\n+\t/**\n+\t * Calculates the MD5 check sum of the given file.\n+\t *\n+\t * @param file\n+\t *            the file to calculate the MD5 checksum for.\n+\t * @return the MD5 based checksum of the given file.\n+\t */\n+\tpublic static String getMD5Checksum(final File file) {\n+\t\treturn Hashing.getChecksum(file, Hashing.ALGORITHM_MD5);\n+\t}\n+\n+\t/**\n+\t * Calculates the SHA-1 check sum of the given file.\n+\t *\n+\t * @param file\n+\t *            the file to calculate the SHA-1 checksum for.\n+\t * @return the SHA-1 based checksum of the given file.\n+\t */\n+\tpublic static String getSHA1Checksum(final File file) {\n+\t\treturn Hashing.getChecksum(file, Hashing.ALGORITHM_SHA1);\n+\t}\n+\n+\t/**\n+\t * Calculates the SHA-1 check sum of the given file.\n+\t *\n+\t * @param file\n+\t *            the file to calculate the SHA-1 checksum for.\n+\t * @return the SHA-1 based checksum of the given file.\n+\t */\n+\tpublic static String getSHA256Checksum(final File file) {\n+\t\treturn Hashing.getChecksum(file, Hashing.ALGORITHM_SHA256);\n+\t}\n+\n+\t/**\n+\t * Calculates the check sum of the given file by using the given algorithm.\n+\t *\n+\t * @param fileName\n+\t *            the name (and path) of the file to calculate the MD5 checksum\n+\t *            for.\n+\t * @param algorithm\n+\t *            the message digest algorithm used for hashing (like &quot;\n+\t *            {@code MD5}&quot; or &quot;<code>SHA-1</code>&quot;).\n+\t * @return the checksum of the given file.\n+\t */\n+\tpublic static String getChecksum(final String fileName,\n+\t\t\tfinal String algorithm) {\n+\t\treturn Hashing.getChecksum(new File(fileName), algorithm);\n+\t}\n+\n+\t/**\n+\t * Calculates the check sum of the given file by using the given algorithm.\n+\t *\n+\t * @param file\n+\t *            the file to calculate the MD5 checksum for.\n+\t * @param algorithm\n+\t *            the message digest algorithm used for hashing (like &quot;\n+\t *            {@code MD5}&quot; or &quot;<code>SHA-1</code>&quot;).\n+\t * @return the checksum of the given file.\n+\t */\n+\tpublic static String getChecksum(final File file, final String algorithm) {\n+\t\ttry {\n+\t\t\tfinal byte[] bytes = Hashing.getFileHash(file, algorithm);\n+\t\t\treturn Hashing.formatBytesArray(bytes);\n+\t\t} catch (final Exception e) {\n+\t\t\tLoggerFactory.getLogger(Hashing.class).error(e.getMessage(), e);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Formats the given byte array as a hexadecimal string.\n+\t *\n+\t * @param bytes\n+\t *            the byte array to be converted to a hexadecimal string.\n+\t * @return the byte array as a hexadecimal string (not containing 0x at the\n+\t *         beginning).\n+\t */\n+\tprotected static String formatBytesArray(final byte[] bytes) {\n+\t\tfinal StringBuffer result = new StringBuffer(32);\n+\t\tfinal Formatter f = new Formatter(result);\n+\t\tfor (final byte b : bytes) {\n+\t\t\tf.format(\"%02x\", b);\n+\t\t}\n+\t\tf.close();\n+\t\treturn result.toString();\n+\t}\n+\n+\t/**\n+\t * Calculates the hash value for the given file, using the given digesting\n+\t * algorithm.\n+\t *\n+\t * @param file\n+\t *            the file to calulcate the hash of.\n+\t * @param algorithm\n+\t *            the message digest algorithm used for hashing (like &quot;\n+\t *            {@code MD5}&quot; or &quot;<code>SHA-1</code>&quot;).\n+\t * @return the array of bytes for the resulting hash value.\n+\t * @throws NoSuchAlgorithmException\n+\t *             if no Provider supports a MessageDigestSpi implementation for\n+\t *             the specified algorithm.\n+\t * @throws IOException\n+\t *             If the first byte cannot be read for any reason other than\n+\t *             the end of the file, if the input stream has been closed, or\n+\t *             if some other I/O error occurs.\n+\t */\n+\tprotected static byte[] getFileHash(final File file, final String algorithm)\n+\t\t\tthrows NoSuchAlgorithmException, IOException {\n+\t\tfinal byte[] buffer = new byte[1024];\n+\t\tfinal MessageDigest complete = MessageDigest.getInstance(algorithm);\n+\t\tInputStream fis = null;\n+\t\ttry {\n+\t\t\tfis = new FileInputStream(file);\n+\t\t\tint numRead;\n+\t\t\tdo {\n+\t\t\t\tnumRead = fis.read(buffer);\n+\t\t\t\tif (numRead > 0) {\n+\t\t\t\t\tcomplete.update(buffer, 0, numRead);\n+\t\t\t\t}\n+\t\t\t} while (numRead != -1);\n+\t\t\tfis.close();\n+\t\t} catch (final IOException io) {\n+\t\t\tif (fis != null) {\n+\t\t\t\tfis.close();\n+\t\t\t}\n+\t\t\tthrow io;\n+\t\t}\n+\t\treturn complete.digest();\n+\t}\n+}"
  },
  {
    "sha": "af7c34603afddc552b2ec146581967899100f6d9",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/util/IApplicationScenarioProvider.java",
    "status": "added",
    "additions": 28,
    "deletions": 0,
    "changes": 28,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/IApplicationScenarioProvider.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/IApplicationScenarioProvider.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/util/IApplicationScenarioProvider.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,28 @@\n+package de.atb.context.common.util;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+/**\n+ * IApplicationScenarioProvider\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 417 $\n+ *\n+ */\n+public interface IApplicationScenarioProvider {\n+\n+\tApplicationScenario getApplicationScenario();\n+\n+}"
  },
  {
    "sha": "cd1770416488a9c78b65256f39922d54bf8fafd9",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/util/SPARQLHelper.java",
    "status": "added",
    "additions": 83,
    "deletions": 0,
    "changes": 83,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/SPARQLHelper.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/SPARQLHelper.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/util/SPARQLHelper.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,83 @@\n+package de.atb.context.common.util;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+import com.hp.hpl.jena.rdf.model.Property;\n+import com.hp.hpl.jena.rdf.model.ResourceFactory;\n+import thewebsemantic.Namespace;\n+import thewebsemantic.RdfType;\n+\n+/**\n+ * SPARQLHelper\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 417 $\n+ *\n+ */\n+public class SPARQLHelper {\n+\tprivate SPARQLHelper() {}\n+\n+\tpublic static String appendDefaultPrefixes(final String sparqlQuery) {\n+\t\tfinal StringBuilder builder = new StringBuilder();\n+\t\tbuilder.append(SPARQLPrefixMappings.getAllAsPrefixString());\n+\t\tbuilder.append(sparqlQuery);\n+\t\treturn builder.toString();\n+\t}\n+\n+\tpublic static synchronized <T> String getRdfNamespace(\n+\t\t\tfinal Class<T> clazz) {\n+\t\tfinal Namespace namespaceAnnotation = clazz\n+\t\t\t\t.getAnnotation(Namespace.class);\n+\t\tif (namespaceAnnotation == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Clazz must be annotated with thewebsemantic.Namespace annotation.\");\n+\t\t}\n+\t\treturn namespaceAnnotation.value().endsWith(\"/\") ? namespaceAnnotation\n+\t\t\t\t.value() : namespaceAnnotation.value() + \"/\";\n+\t}\n+\n+\tpublic static synchronized <T> String getRdfType(final Class<T> clazz) {\n+\t\tfinal RdfType typeAnnotation = clazz.getAnnotation(RdfType.class);\n+\t\tif (typeAnnotation == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Clazz must be annotated with thewebsemantic.RdfType annotation.\");\n+\t\t}\n+\t\treturn typeAnnotation.value();\n+\t}\n+\n+\tpublic static synchronized <T> String getRdfPropertyQualifier(\n+            final Class<T> clazz, final String propertyName) {\n+\t\treturn String.format(\"<%s%s>\", SPARQLHelper.getRdfNamespace(clazz),\n+\t\t\t\tpropertyName);\n+\t}\n+\n+\tpublic static synchronized <T> Property createProperty(\n+            final Class<T> clazz, final String propertyName) {\n+\t\treturn ResourceFactory.createProperty(String.format(\"%s%s\",\n+\t\t\t\tSPARQLHelper.getRdfNamespace(clazz), propertyName));\n+\t}\n+\n+\tpublic static synchronized <T> String getRdfClassQualifier(\n+\t\t\tfinal Class<T> clazz) {\n+\t\treturn String.format(\"<%s%s>\", SPARQLHelper.getRdfNamespace(clazz),\n+\t\t\t\tSPARQLHelper.getRdfType(clazz));\n+\t}\n+\n+\tpublic static synchronized <T> String getRdfClassQualifierWithoutBraces(\n+\t\t\tfinal Class<T> clazz) {\n+\t\treturn String.format(\"%s%s\", SPARQLHelper.getRdfNamespace(clazz),\n+\t\t\t\tSPARQLHelper.getRdfType(clazz));\n+\t}\n+}"
  },
  {
    "sha": "e4a21d0754cb70d29a30afb0a749cf9fc6366c48",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/util/SPARQLPrefixMappings.java",
    "status": "added",
    "additions": 56,
    "deletions": 0,
    "changes": 56,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/SPARQLPrefixMappings.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/SPARQLPrefixMappings.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/util/SPARQLPrefixMappings.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,56 @@\n+package de.atb.context.common.util;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+/**\n+ * SPARQLPrefixMappings\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 417 $\n+ *\n+ */\n+public enum SPARQLPrefixMappings {\n+\n+\tXSD(\"xsd\", \"http://www.w3.org/2001/XMLSchema#\"),\n+\n+\tRDF(\"rdf\", \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"),\n+\n+\tRDFS(\"rdfs\", \"http://www.w3.org/2000/01/rdf-schema#\"),\n+\n+\t;\n+\n+\tprivate String prefix;\n+    private String url;\n+\n+\tprivate SPARQLPrefixMappings(final String prefix, final String url) {\n+\t\tthis.prefix = prefix;\n+\t\tthis.url = url;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn String.format(\"PREFIX %s: <%s>\", prefix, url);\n+\t}\n+\n+\tpublic static String getAllAsPrefixString() {\n+\t\tfinal StringBuilder builder = new StringBuilder();\n+\t\tfor (final SPARQLPrefixMappings mapping : SPARQLPrefixMappings.values()) {\n+\t\t\tbuilder.append(mapping.toString());\n+\t\t\tbuilder.append(\"\\n\");\n+\t\t}\n+\t\treturn builder.toString();\n+\t}\n+\n+}"
  },
  {
    "sha": "76611e91ba29f51fa44cbf1cdf711590c439d865",
    "filename": "context-core/context-core/src/main/java/de/atb/context/common/util/StringUtils.java",
    "status": "added",
    "additions": 52,
    "deletions": 0,
    "changes": 52,
    "blob_url": "https://github.com/eclipse-researchlabs/smartclide-context/blob/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/StringUtils.java",
    "raw_url": "https://github.com/eclipse-researchlabs/smartclide-context/raw/6e24eca586b3961971adad8b4c3b445bacd968f3/context-core/context-core/src/main/java/de/atb/context/common/util/StringUtils.java",
    "contents_url": "https://api.github.com/repos/eclipse-researchlabs/smartclide-context/contents/context-core/context-core/src/main/java/de/atb/context/common/util/StringUtils.java?ref=6e24eca586b3961971adad8b4c3b445bacd968f3",
    "patch": "@@ -0,0 +1,52 @@\n+package de.atb.context.common.util;\n+\n+/*\n+ * #%L\n+ * ATB Context Extraction Core Lib\n+ * %%\n+ * Copyright (C) 2020 ATB – Institut für angewandte Systemtechnik Bremen GmbH\n+ * %%\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * #L%\n+ */\n+\n+/**\n+ * StringUtils\n+ *\n+ * @author scholze\n+ * @version $LastChangedRevision: 417 $\n+ *\n+ */\n+public class StringUtils {\n+\n+\tprivate StringUtils() {}\n+\n+\tpublic static String capitalize(final String str) {\n+\t\tif (str == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tchar ch;\n+\t\tchar prevCh;\n+\t\tint i;\n+\t\tprevCh = '.';\n+\t\tfinal StringBuilder builder = new StringBuilder(str.length());\n+\t\tfor (i = 0; i < str.length(); i++) {\n+\t\t\tch = str.charAt(i);\n+\t\t\tif (Character.isLetter(ch) && !Character.isLetter(prevCh)) {\n+\t\t\t\tbuilder.append(Character.toUpperCase(ch));\n+\t\t\t} else {\n+\t\t\t\tbuilder.append(ch);\n+\t\t\t}\n+\t\t\tprevCh = ch;\n+\t\t}\n+\t\treturn builder.toString();\n+\t}\n+\n+\tpublic static boolean isEmpty(final String str) {\n+\t\treturn (str == null) || (str.trim().length() == 0);\n+\t}\n+}"
  }
]
