[
  {
    "sha": "225e8e0fd90e545f3be604063794386238726e58",
    "filename": "python/avi/sdk/avi_api.py",
    "status": "modified",
    "additions": 47,
    "deletions": 22,
    "changes": 69,
    "blob_url": "https://github.com/avinetworks/sdk/blob/af65406968d73e05faa654ec19bf60cb750db31c/python/avi/sdk/avi_api.py",
    "raw_url": "https://github.com/avinetworks/sdk/raw/af65406968d73e05faa654ec19bf60cb750db31c/python/avi/sdk/avi_api.py",
    "contents_url": "https://api.github.com/repos/avinetworks/sdk/contents/python/avi/sdk/avi_api.py?ref=af65406968d73e05faa654ec19bf60cb750db31c",
    "patch": "@@ -4,7 +4,7 @@\n import json\n import logging\n import time\n-\n+import enum\n if sys.version_info < (3, 5):\n     from urlparse import urlparse\n else:\n@@ -23,6 +23,11 @@\n global sessionDict\n sessionDict = {}\n \n+class AuthTypes(enum.Enum):\n+    CSRF = 'CSRF'\n+    UserManaged = 'User_Headers'\n+    SAML = 'SAML'\n+\n \n def avi_timedelta(td):\n     \"\"\"\n@@ -208,7 +213,7 @@ def __init__(self, controller_ip=None, username=None, password=None,\n                  port=None, timeout=60, api_version=None,\n                  retry_conxn_errors=True, data_log=False,\n                  avi_credentials=None, session_id=None, csrftoken=None,\n-                 lazy_authentication=False, max_api_retries=None):\n+                 lazy_authentication=False, max_api_retries=None, user_headers=None, auth_type=None):\n         \"\"\"\n          ApiSession takes ownership of avi_credentials and may update the\n          information inside it.\n@@ -227,6 +232,7 @@ def __init__(self, controller_ip=None, username=None, password=None,\n             a non-default value, then we concatenate http://ip:port in\n             the prefix.\n         \"\"\"\n+\n         super(ApiSession, self).__init__()\n         logger.debug(\"Creating session with following values:\\n \"\n                      \"controller_ip: %s, username: %s, tenant: %s, \"\n@@ -281,8 +287,13 @@ def __init__(self, controller_ip=None, username=None, password=None,\n                     x=self.avi_credentials.controller,\n                     y=self.avi_credentials.port)\n         self.timeout = timeout\n+        self.auth_type = auth_type\n         self.key = '%s:%s:%s' % (self.avi_credentials.controller,\n                                  self.avi_credentials.username, k_port)\n+\n+        if AuthTypes.UserManaged.value == auth_type:\n+            self.headers.update(user_headers)\n+            return\n         # Added api token and session id to sessionDict for handle single\n         # session\n         if self.avi_credentials.csrftoken:\n@@ -596,28 +607,36 @@ def _api(self, api_name, path, tenant, tenant_uuid, data=None,\n         :param headers: dictionary of headers that override the session\n             headers.\n         \"\"\"\n-        if self.pid != os.getpid():\n-            logger.info('pid %d change detected new %d. Closing session',\n-                        self.pid, os.getpid())\n-            self.close()\n-            self.pid = os.getpid()\n-        if timeout is None:\n-            timeout = self.timeout\n         fullpath = self._get_api_path(path)\n         fn = getattr(super(ApiSession, self), api_name)\n-        api_hdrs = self._get_api_headers(tenant, tenant_uuid, timeout, headers,\n-                                         api_version)\n         connection_error = False\n         err = None\n-        cookies = {\n-            'csrftoken': api_hdrs['X-CSRFToken'],\n-        }\n-        try:\n-            sessionid = sessionDict[self.key]['session_id']\n-            cookies['sessionid'] = sessionid\n-            cookies['avi-sessionid'] = sessionid\n-        except KeyError:\n-            pass\n+        if AuthTypes.UserManaged.value == self.auth_type:\n+            api_hdrs = self.headers\n+            api_hdrs.update({\n+                \"Referer\": self.prefix,\n+                \"Content-Type\": \"application/json\"\n+            })\n+            cookies = {}\n+        else:\n+            if self.pid != os.getpid():\n+                logger.info('pid %d change detected new %d. Closing session',\n+                            self.pid, os.getpid())\n+                self.close()\n+                self.pid = os.getpid()\n+            if timeout is None:\n+                timeout = self.timeout\n+            api_hdrs = self._get_api_headers(tenant, tenant_uuid, timeout, headers,\n+                                             api_version)\n+            cookies = {\n+                'csrftoken': api_hdrs['X-CSRFToken'],\n+            }\n+            try:\n+                sessionid = sessionDict[self.key]['session_id']\n+                cookies['sessionid'] = sessionid\n+                cookies['avi-sessionid'] = sessionid\n+            except KeyError:\n+                pass\n         try:\n             if (data is not None) and (type(data) == dict):\n                 resp = fn(fullpath, data=json.dumps(data), headers=api_hdrs,\n@@ -660,7 +679,10 @@ def _api(self, api_name, path, tenant, tenant_uuid, data=None,\n             else:\n                 logger.info('received error %d %s so resetting connection',\n                             resp.status_code, resp.text)\n-            ApiSession.reset_session(self)\n+            if AuthTypes.UserManaged.value == self.auth_type:\n+                logger.info(\"Retying using the basic authentication.\")\n+            else:\n+                ApiSession.reset_session(self)\n             self.num_api_retries += 1\n             if self.num_api_retries > self.max_session_retries:\n                 # Added this such that any code which re-tries can succeed\n@@ -742,7 +764,10 @@ def get_object_by_name(self, path, name, tenant='', tenant_uuid='',\n                         timeout=timeout,\n                         params=params, api_version=api_version, **kwargs)\n         if resp.status_code in (401, 419):\n-            ApiSession.reset_session(self)\n+            if AuthTypes.UserManaged.value == self.auth_type:\n+                logger.info(\"Retying using the basic authentication.\")\n+            else:\n+                ApiSession.reset_session(self)\n             resp = self.get_object_by_name(\n                 path, name, tenant, tenant_uuid, timeout=timeout,\n                 params=params, **kwargs)"
  }
]
