[
  {
    "sha": "fd8a94ea68a8fc5565e8e943df2b838944b95f84",
    "filename": "iec61850serversimulator/pom.xml",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/pom.xml",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/pom.xml",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/pom.xml?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -55,6 +55,11 @@\n \t\t    <version>1.12.0</version>\n \t\t</dependency>\n \t\t\n+\t\t<dependency>\n+\t\t\t<groupId>org.springframework.boot</groupId>\n+\t\t\t<artifactId>spring-boot-starter-data-jpa</artifactId>\n+\t\t</dependency>\n+\t\t\n \t</dependencies>\n \n \t<build>"
  },
  {
    "sha": "95e5b01dac27fd052b8d2b42dc42edfab585f3d6",
    "filename": "iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/ActionExecutor.java",
    "status": "modified",
    "additions": 31,
    "deletions": 32,
    "changes": 63,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/ActionExecutor.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/ActionExecutor.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/ActionExecutor.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -3,57 +3,56 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.beanit.openiec61850.internal.cli.ActionException;\n-import com.beanit.openiec61850.internal.cli.ActionListener;\n import com.beanit.openiec61850.ServerModel;\n import com.beanit.openiec61850.ServerSap;\n+import com.beanit.openiec61850.internal.cli.ActionException;\n+import com.beanit.openiec61850.internal.cli.ActionListener;\n+\n+/**\n+ * Class which takes certain button inputs for debug features during runtime.\n+ */\n \n public class ActionExecutor implements ActionListener {\n-\t\n+\n \tprivate static final Logger logger = LoggerFactory.getLogger(ServerSimulator.class);\n \tprivate static final String PRINT_SERVER_MODEL_KEY = \"p\";\n \tprivate static final String DEVICE_SHOW_MODEL = \"d\";\n \tpublic ServerSap serverSap = null;\n \tpublic ServerModel serverModel = null;\n \tpublic Device device = null;\n-\t//private static final String PRINT_SERVER_MODEL_KEY = \"p\";\n-\t//private static final String PRINT_SERVER_MODEL_KEY_DESCRIPTION = \"print server's model\";\n \n-    public ActionExecutor(ServerSap serverSap, ServerModel serverModel, Device device) {\n+\tpublic ActionExecutor(final ServerSap serverSap, final ServerModel serverModel, final Device device) {\n \t\tthis.serverSap = serverSap;\n \t\tthis.serverModel = serverModel;\n \t\tthis.device = device;\n-    }\n+\t}\n \n \t@Override\n-    public void actionCalled(String actionKey) throws ActionException {\n-      try {\n-        switch (actionKey) {\n-          case PRINT_SERVER_MODEL_KEY:\n-            logger.info(\"** Printing model.\");\n-            logger.info(\"Server model:\" + serverModel);\n-            \n-            break;\n-            \n-          case DEVICE_SHOW_MODEL:\n-        \tlogger.info(\"** Printing device.\");\n-        \tdevice.displayDevice();\n-            //logger.debug(serverModel.toString());\n-            //logger.info(\"** serverModel put into log as debug information.\");\n-        \t//device.DeviceDisplay is niet static, dus static probleem. Waarom static in actionCalled???\n-        }\n-      } catch (Exception e) {\n-        throw new ActionException(e);\n-      }\n-    }\n+\tpublic void actionCalled(final String actionKey) throws ActionException {\n+\t\ttry {\n+\t\t\tswitch (actionKey) {\n+\t\t\tcase PRINT_SERVER_MODEL_KEY:\n+\t\t\t\tlogger.info(\"** Printing model.\");\n+\t\t\t\tlogger.info(\"Server model:\" + this.serverModel);\n+\n+\t\t\t\tbreak;\n+\n+\t\t\tcase DEVICE_SHOW_MODEL:\n+\t\t\t\tlogger.info(this.device.toString());\n+\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t} catch (final Exception e) {\n+\t\t\tthrow new ActionException(e);\n+\t\t}\n+\t}\n \n \t@Override\n \tpublic void quit() {\n \t\tlogger.info(\"Shutting down application...\");\n-\t\tserverSap.stop();\n+\t\tthis.serverSap.stop();\n \t\treturn;\n-\t\t\n+\n \t}\n-\t\n-\t\n-}\n\\ No newline at end of file\n+\n+}"
  },
  {
    "sha": "5b45204072bc8d05a8ff4ea019c64b3d839437b6",
    "filename": "iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Clock.java",
    "status": "modified",
    "additions": 104,
    "deletions": 57,
    "changes": 161,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Clock.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Clock.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Clock.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -14,161 +14,208 @@\n import com.beanit.openiec61850.BdaInt16U;\n import com.beanit.openiec61850.BdaTimestamp;\n import com.beanit.openiec61850.BdaVisibleString;\n-import com.beanit.openiec61850.Fc;\n import com.beanit.openiec61850.ModelNode;\n-import com.beanit.openiec61850.ServerModel;\n \n public class Clock {\n \tprivate static final Logger logger = LoggerFactory.getLogger(Clock.class);\n-\t\n+\n \tLocalDateTime currentTime;\n-\tshort timeZoneOffset; // offset in minutes from UTC\n-\tString beginDateDST; // time zone abbreviation, in format: M<month in MM>.<which 'th' day in the month, 5 = 5th/last day of the month>.<which type of day it should switch? 0 = Sunday?>/<which hour it switches on>\n-\tString endDateDST; // time zone abbreviation, in format: M<month in MM>.<which 'th' day in the month, 5 = 5th/last day of the month>.<which type of day it should switch? 0 = Sunday?>/<which hour it switches on>\n-\tshort deviationDST; // in minutes, how many minutes will be switched over when DST is enabled/disabled (Standard = 60 minutes = 1 hour)\n+\t// Offset in minutes from UTC\n+\tshort timeZoneOffset;\n+\t// Time zone abbreviation, in format: M<month in\n+\t// MM>.<which 'th' day in the month, 5 = 5th/last day\n+\t// of the month>.<which type of day it should switch? 0\n+\t// = Sunday>/<which hour it switches on>\n+\tString beginDateDST;\n+\t// Same format for beginDateDST\n+\tString endDateDST;\n+\t// In minutes, how many minutes will be switched over\n+\t// when DST is enabled/disabled (Standard = 60 minutes =\n+\t// 1 hour)\n+\tshort deviationDST;\n \tboolean enableDST;\n \tboolean enableNTP;\n-\tString ipAddressNTP; // if multiple are in use, use ; to separate them\n-\tint timeSyncInterval; // in minutes, regarding synchronizing time with the NTP server\n-\t\n-\tpublic void initializeClock(ModelNode clockInfo){\n-\t\tList<BasicDataAttribute> bdas = clockInfo.getBasicDataAttributes();\n-\t\t\n-\t\tfor (BasicDataAttribute bda : bdas ) {\n-\t\t\tString dataAttribute = bda.getName();\n-\t\t\t\n-\t\t\tswitch(dataAttribute) {\n+\t// If multiple IP addresses are in use, use \";\" to separate them\n+\tString ipAddressNTP;\n+\t// In minutes, regarding synchronizing time with the\n+\t// NTP server\n+\tint timeSyncInterval;\n+\n+\tpublic void initializeClock(final ModelNode clockInfo) {\n+\t\tfinal List<BasicDataAttribute> bdas = clockInfo.getBasicDataAttributes();\n+\n+\t\tfor (final BasicDataAttribute bda : bdas) {\n+\t\t\tfinal String dataAttribute = bda.getName();\n+\n+\t\t\tswitch (dataAttribute) {\n \t\t\tcase \"curT\":\n \t\t\t\tlogger.info(\"Current Time value found.\");\n-\t\t\t\t\n-\t\t\t\t// For native timestamp: Epoch/UNIX timestamp format is used, from second on. Convert to native timestamp!. \n-\t\t\t\tbyte[] bytesEpochTime = ((BdaTimestamp) bda).getValue();\n-\t\t\t\tByteBuffer wrappedTime = ByteBuffer.wrap(bytesEpochTime);\n-\t\t\t\tlong longTime = wrappedTime.getLong();\t\n+\n+\t\t\t\t// For native timestamp: Epoch/UNIX timestamp format is used,\n+\t\t\t\t// from second on. Convert to native timestamp!.\n+\t\t\t\tfinal byte[] bytesEpochTime = ((BdaTimestamp) bda).getValue();\n+\t\t\t\tfinal ByteBuffer wrappedTime = ByteBuffer.wrap(bytesEpochTime);\n+\t\t\t\tfinal long longTime = wrappedTime.getLong();\n \t\t\t\tthis.currentTime = LocalDateTime.ofEpochSecond(longTime, 0, ZoneOffset.ofHours(1));\n \t\t\t\tbreak;\n-\t\t\t\t\n+\n \t\t\tcase \"tZ\":\n \t\t\t\tlogger.info(\"Time Zone value found. (Offset in minutes from UTC!)\");\n \t\t\t\tthis.timeZoneOffset = ((BdaInt16) bda).getValue();\n \t\t\t\tbreak;\n-\t\t\t\t\n+\n \t\t\tcase \"dstBegT\":\n \t\t\t\tlogger.info(\"Daylight Saving Time Start Date value found.\");\n \t\t\t\tthis.beginDateDST = ((BdaVisibleString) bda).getValueString();\n \t\t\t\tbreak;\n-\t\t\t\t\n+\n \t\t\tcase \"dstEndT\":\n \t\t\t\tlogger.info(\"Daylight Saving Time Start Date value found.\");\n \t\t\t\tthis.endDateDST = ((BdaVisibleString) bda).getValueString();\n \t\t\t\tbreak;\n-\t\t\t\t\n+\n \t\t\tcase \"dvt\":\n \t\t\t\tlogger.info(\"Daylight Saving Time Deviation value found.\");\n \t\t\t\tthis.deviationDST = ((BdaInt16) bda).getValue();\n \t\t\t\tbreak;\n-\t\t\t\t\n+\n \t\t\tcase \"enbDst\":\n \t\t\t\tlogger.info(\"Daylight Saving Time Status value found.\");\n \t\t\t\tthis.enableDST = ((BdaBoolean) bda).getValue();\n \t\t\t\tbreak;\n-\t\t\t\t\n+\n \t\t\tcase \"enbNtpC\":\n \t\t\t\tlogger.info(\"NTP Client Enabled value found.\");\n \t\t\t\tthis.enableNTP = ((BdaBoolean) bda).getValue();\n \t\t\t\tbreak;\n-\t\t\t\n+\n \t\t\tcase \"ntpSvrA\":\n \t\t\t\tlogger.info(\"NTP Server IP Address value found.\");\n \t\t\t\tthis.ipAddressNTP = ((BdaVisibleString) bda).getValueString();\n \t\t\t\tbreak;\n-\t\t\t\t\n+\n \t\t\tcase \"syncPer\":\n \t\t\t\tlogger.info(\"Time Sync Interval (in minutes) value found.\");\n \t\t\t\tthis.timeSyncInterval = ((BdaInt16U) bda).getValue();\n \t\t\t\tbreak;\n-\t\t\t\t\n+\n \t\t\tdefault:\n \t\t\t\tlogger.info(\"Unimplemented value found, \" + \"'\" + dataAttribute + \"'\" + \", skipped.\");\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t}\n+\n \tpublic void displayClock() {\n \t\tlogger.info(\"** Printing clock.\");\n \t\tlogger.info(\"Current time: \" + this.currentTime);\n \t\tlogger.info(\"Time zone offset (in minutes, from UTC): \" + this.timeZoneOffset);\n-\t\tlogger.info(\"Daylight Saving Time start date: \" + this.beginDateDST); // Making it readable for humans?\n-\t\tlogger.info(\"Daylight Saving Time end date: \" + this.endDateDST); // Making it readable for humans?\n+\t\t// Making it readable for humans?\n+\t\tlogger.info(\"Daylight Saving Time start date: \" + this.beginDateDST);\n+\t\t// Making it readable for humans?\n+\t\tlogger.info(\"Daylight Saving Time end date: \" + this.endDateDST);\n \t\tlogger.info(\"Daylight Saving Time deviation (in minutes): \" + this.deviationDST);\n \t\tlogger.info(\"Daylight Saving Time enabled: \" + this.enableDST);\n \t\tlogger.info(\"NTP client enabled: \" + this.enableNTP);\n \t\tlogger.info(\"NTP server IP address(es): \" + this.ipAddressNTP);\n-\t\t\n \t}\n-\t\n-\tpublic void changeDST(boolean enableDST) {\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tfinal StringBuilder clockStringBuilder = new StringBuilder();\n+\n+\t\tclockStringBuilder.append(\"** Printing clock.\\n\");\n+\t\tclockStringBuilder.append(\"Current time: \" + this.currentTime + '\\n');\n+\t\tclockStringBuilder.append(\"Time zone offset (in minutes, from UTC): \" + this.timeZoneOffset + '\\n');\n+\t\tclockStringBuilder.append(\"Daylight Saving Time start date: \" + this.beginDateDST + '\\n');\n+\t\tclockStringBuilder.append(\"Daylight Saving Time end date: \" + this.endDateDST + '\\n');\n+\t\tclockStringBuilder.append(\"Daylight Saving Time deviation (in minutes): \" + this.deviationDST + '\\n');\n+\t\tclockStringBuilder.append(\"Daylight Saving Time enabled: \" + this.enableDST + '\\n');\n+\t\tclockStringBuilder.append(\"NTP client enabled: \" + this.enableNTP + '\\n');\n+\t\tclockStringBuilder.append(\"NTP server IP address(es): \" + this.ipAddressNTP + '\\n');\n+\n+\t\treturn clockStringBuilder.toString();\n+\t}\n+\n+\tpublic void changeDST(final boolean enableDST) {\n \t\tthis.enableDST = enableDST;\n \t}\n-\t\n-\tpublic void configNTP(boolean enableNTP, String ipAddressNTP, short timeSyncInterval) {\n+\n+\tpublic void configNTP(final boolean enableNTP, final String ipAddressNTP, final short timeSyncInterval) {\n \t\tthis.enableNTP = enableNTP;\n \t\tthis.ipAddressNTP = ipAddressNTP;\n \t\tthis.timeSyncInterval = timeSyncInterval;\n \t}\n+\n \tpublic LocalDateTime getCurrentTime() {\n-\t\treturn currentTime;\n+\t\treturn this.currentTime;\n \t}\n-\tpublic void setCurrentTime(LocalDateTime currentTime) {\n+\n+\tpublic void setCurrentTime(final LocalDateTime currentTime) {\n \t\tthis.currentTime = currentTime;\n \t}\n+\n \tpublic short getTimeZoneOffset() {\n-\t\treturn timeZoneOffset;\n+\t\treturn this.timeZoneOffset;\n \t}\n-\tpublic void setTimeZoneOffset(short timeZoneOffset) {\n+\n+\tpublic void setTimeZoneOffset(final short timeZoneOffset) {\n \t\tthis.timeZoneOffset = timeZoneOffset;\n \t}\n+\n \tpublic String getBeginDateDST() {\n-\t\treturn beginDateDST;\n+\t\treturn this.beginDateDST;\n \t}\n-\tpublic void setBeginDateDST(String beginDateDST) {\n+\n+\tpublic void setBeginDateDST(final String beginDateDST) {\n \t\tthis.beginDateDST = beginDateDST;\n \t}\n+\n \tpublic String getEndDateDST() {\n-\t\treturn endDateDST;\n+\t\treturn this.endDateDST;\n \t}\n-\tpublic void setEndDateDST(String endDateDST) {\n+\n+\tpublic void setEndDateDST(final String endDateDST) {\n \t\tthis.endDateDST = endDateDST;\n \t}\n+\n \tpublic short getDeviationDST() {\n-\t\treturn deviationDST;\n+\t\treturn this.deviationDST;\n \t}\n-\tpublic void setDeviationDST(short deviationDST) {\n+\n+\tpublic void setDeviationDST(final short deviationDST) {\n \t\tthis.deviationDST = deviationDST;\n \t}\n+\n \tpublic boolean isEnableDST() {\n-\t\treturn enableDST;\n+\t\treturn this.enableDST;\n \t}\n-\tpublic void setEnableDST(boolean enableDST) {\n+\n+\tpublic void setEnableDST(final boolean enableDST) {\n \t\tthis.enableDST = enableDST;\n \t}\n+\n \tpublic boolean isEnableNTP() {\n-\t\treturn enableNTP;\n+\t\treturn this.enableNTP;\n \t}\n-\tpublic void setEnableNTP(boolean enableNTP) {\n+\n+\tpublic void setEnableNTP(final boolean enableNTP) {\n \t\tthis.enableNTP = enableNTP;\n \t}\n+\n \tpublic String getIpAddressNTP() {\n-\t\treturn ipAddressNTP;\n+\t\treturn this.ipAddressNTP;\n \t}\n-\tpublic void setIpAddressNTP(String ipAddressNTP) {\n+\n+\tpublic void setIpAddressNTP(final String ipAddressNTP) {\n \t\tthis.ipAddressNTP = ipAddressNTP;\n \t}\n+\n \tpublic int getTimeSyncInterval() {\n-\t\treturn timeSyncInterval;\n+\t\treturn this.timeSyncInterval;\n \t}\n-\tpublic void setTimeSyncInterval(int timeSyncInterval) {\n+\n+\tpublic void setTimeSyncInterval(final int timeSyncInterval) {\n \t\tthis.timeSyncInterval = timeSyncInterval;\n \t}\n }\n-"
  },
  {
    "sha": "5a8e46490a3ed724969f946f2714bd68adec31bc",
    "filename": "iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Device.java",
    "status": "modified",
    "additions": 50,
    "deletions": 40,
    "changes": 90,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Device.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Device.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Device.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -11,34 +11,25 @@\n import com.beanit.openiec61850.BdaInt8;\n import com.beanit.openiec61850.Fc;\n \n+/**\n+ * Class which represents a simulated device. It holds the clock and 4 relays.\n+ */\n class Device {\n-\t// TODO: Split the class up into several classes\n \tprivate static final Logger logger = LoggerFactory.getLogger(Device.class);\n \n-\t/*\n-\t * String switchType1; String switchType2; String switchType3; String\n-\t * switchType4; boolean relayLight2; boolean relayLight3; boolean relayLight4;\n-\t * String lightType;\n-\t *\n-\t * int offsetAstronomSet; int offsetAstronomRise; String sensorTransition;\n-\t */\n+\tprivate static final String SWITCH_ROOT = \"SWDeviceGenericIO/XSWC\";\n+\n \tprivate Clock clock;\n \tprivate Relay[] relays;\n-\n \tprivate ServerWrapper serverWrapper;\n \n-\t/*\n-\t * String eventFilterBitmask; boolean enableEventBuffered;\n-\t *\n-\t * // Schedule array?\n-\t *\n-\t * String functionalFirmwareVer; String securityFirmwareVer;\n-\t *\n-\t * String ipAddressGXF; int portGXF; String ipAddressNTP; int timeSyncInterval;\n-\t *\n-\t * boolean enableDHCP; String ipAddressDHCP; String netmaskDHCP; String\n-\t * gatewayDHCP;\n-\t */\n+\tpublic Relay[] getRelays() {\n+\t\treturn this.relays;\n+\t}\n+\n+\tpublic void setRelays(Relay[] relays) {\n+\t\tthis.relays = relays;\n+\t}\n \n \tpublic void displayDevice() {\n \t\tlogger.info(\"** Printing device:\");\n@@ -47,12 +38,35 @@ public void displayDevice() {\n \n \t\tlogger.info(\"** Printing relays.\\n\");\n \t\tfor (int relayNr = 0; relayNr < 4; relayNr++) {\n-\t\t\tthis.relays[relayNr].displayRelay();\n-\t\t\tfor (int scheduleNr = 0; scheduleNr < 50; scheduleNr++) {\n-\t\t\t\tlogger.info(this.getRelay(relayNr + 1).getSchedule(scheduleNr + 1).toString());\n+\t\t\tlogger.info(this.relays[relayNr].toString());\n+\t\t\tfor (int scheduleNr = 1; scheduleNr <= 50; scheduleNr++) {\n+\t\t\t\tlogger.info(\"Schedule {}: {}\", scheduleNr, this.getRelay(relayNr + 1).getSchedule(scheduleNr));\n \t\t\t}\n \t\t}\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tfinal StringBuilder deviceStringBuilder = new StringBuilder();\n \n+\t\tdeviceStringBuilder.append(\"** Printing device:\").append(System.lineSeparator()).append(System.lineSeparator());\n+\t\tdeviceStringBuilder.append(this.clock.toString()).append(System.lineSeparator()).append(System.lineSeparator());\n+\n+\t\tdeviceStringBuilder.append(\"** Printing relays:\").append(System.lineSeparator());\n+\n+\t\tfor (int relayNr = 0; relayNr < 4; relayNr++) {\n+\t\t\tdeviceStringBuilder.append(this.relays[relayNr].toString()).append(System.lineSeparator())\n+\t\t\t\t\t.append(\"Enabled schedules: \").append(System.lineSeparator()).append(System.lineSeparator());\n+\t\t\tfor (int scheduleNr = 1; scheduleNr <= 50; scheduleNr++) {\n+\t\t\t\tif (this.getRelay(relayNr + 1).getSchedule(scheduleNr).enabled) {\n+\t\t\t\t\tdeviceStringBuilder.append(this.getRelay(relayNr + 1).getSchedule(scheduleNr))\n+\t\t\t\t\t\t\t.append(System.lineSeparator());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tdeviceStringBuilder.append(System.lineSeparator());\n+\t\t}\n+\t\tdeviceStringBuilder.append(System.lineSeparator());\n+\t\treturn deviceStringBuilder.toString();\n \t}\n \n \tpublic void initalizeDevice(final ServerWrapper serverSapWrapper) {\n@@ -64,13 +78,10 @@ public void initalizeDevice(final ServerWrapper serverSapWrapper) {\n \n \t\tfor (int relayNr = 0; relayNr < 4; relayNr++) {\n \t\t\tthis.relays[relayNr] = new Relay(\n-\t\t\t\t\tthis.serverWrapper.findModelNode(\"SWDeviceGenericIO/XSWC\" + (relayNr + 1) + \".Pos\", Fc.CO),\n-\t\t\t\t\tthis.serverWrapper.findModelNode(\"SWDeviceGenericIO/XSWC\" + (relayNr + 1) + \".Sche.sche1\", Fc.CF));\n-\t\t\tthis.setCtlModel(relayNr + 1, 1);\n+\t\t\t\t\tthis.serverWrapper.findModelNode(SWITCH_ROOT + (relayNr + 1) + \".Pos\", Fc.CO),\n+\t\t\t\t\tthis.serverWrapper.findModelNode(SWITCH_ROOT + (relayNr + 1) + \".Sche.sche1\", Fc.CF));\n+\t\t\tthis.enableSwitching(relayNr + 1);\n \t\t}\n-\t\t// CTLModel naar 1 veranderen door de ServerModel te muteren\n-\t\t// Kijk naar Ruud z'n voorbeeld bij setLightStatus!\n-\n \t}\n \n \tpublic Clock getClock() {\n@@ -90,9 +101,7 @@ public void setLightStatus(final int relay, final boolean status) {\n \t\t\tlogger.info(\"Set light status for relay {} to value {}\", relay, status);\n \n \t\t\tfinal BdaBoolean lightStatus = (BdaBoolean) this.serverWrapper\n-\t\t\t\t\t.findModelNode(\"SWDeviceGenericIO/XSWC\" + relay + \".Pos.Oper.ctlVal\", Fc.CO);\n-\t\t\t// .findModelNode(\"SWDeviceGenericIO/XSWC\" + relay + \".Pos.stVal\",\n-\t\t\t// Fc.ST);\n+\t\t\t\t\t.findModelNode(SWITCH_ROOT + relay + \".Pos.Oper.ctlVal\", Fc.CO);\n \t\t\tlightStatus.setValue(status);\n \n \t\t\tfinal List<BasicDataAttribute> attributes = Arrays.asList(lightStatus);\n@@ -102,16 +111,17 @@ public void setLightStatus(final int relay, final boolean status) {\n \t\t}\n \t}\n \n-\tpublic void setCtlModel(final int relay, final int ctlModelInt) {\n+\tpublic void enableSwitching(final int relay) {\n \t\ttry {\n-\t\t\t// Necessary to have CTLModel set to 1 in the ServerModel along with having\n-\t\t\t// enbOpr enabled (enabled on default) to be able to switch the status.\n+\t\t\t// Necessary to have CTLModel set to 1 in the ServerModel along with\n+\t\t\t// having enbOpr enabled (enabled on default) to be able to switch\n+\t\t\t// the status.\n \t\t\tlogger.info(\"Setting CTLModel to 1 to enable relay control\");\n \n-\t\t\tfinal BdaInt8 ctlModel = (BdaInt8) this.serverWrapper\n-\t\t\t\t\t.findModelNode(\"SWDeviceGenericIO/XSWC\" + relay + \".Pos.ctlModel\", Fc.CF);\n-\t\t\tbyte ctlModelByte = 01;\n-\t\t\tlogger.info(\"Byte: \" + ctlModelByte);\n+\t\t\tfinal BdaInt8 ctlModel = (BdaInt8) this.serverWrapper.findModelNode(SWITCH_ROOT + relay + \".Pos.ctlModel\",\n+\t\t\t\t\tFc.CF);\n+\t\t\tfinal byte ctlModelByte = 01;\n+\t\t\tlogger.info(\"Byte: {}\", ctlModelByte);\n \t\t\tctlModel.setValue((byte) 01);\n \t\t\tlogger.info(\"CTLModel: {}\", ctlModelByte);\n "
  },
  {
    "sha": "107071a6c84ec52c9773a4f48e9cd068d246a48e",
    "filename": "iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/DeviceOld.java",
    "status": "removed",
    "additions": 0,
    "deletions": 49,
    "changes": 49,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/dd6e312e9c5b38a5df283180afd78859f6b994fe/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/DeviceOld.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/dd6e312e9c5b38a5df283180afd78859f6b994fe/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/DeviceOld.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/DeviceOld.java?ref=dd6e312e9c5b38a5df283180afd78859f6b994fe",
    "patch": "@@ -1,49 +0,0 @@\n-package com.cgi.iec61850serversimulator;\n-\n-import java.text.MessageFormat;\n-import java.time.LocalDateTime;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-\n-\n-class DeviceOld {\n-\tprivate static final Logger logger = LoggerFactory.getLogger(DeviceOld.class);\n-\t//LocalDateTime currentTime;\n-\tboolean enbDst;\n-\tint syncPer;\n-\t\n-\tpublic void deviceInit(boolean enbDst) {\n-\t//TODO: Device initialiseren gebaseerd op de serverModel dat is meegegeven\n-\t\tupdateDst(enbDst);\n-\t}\n-\t\n-\n-\tpublic void updateDeviceCheck(boolean enbDst) {\n-\t//TODO: Verder invullen om device object up te daten\n-\t//System.out.println(currentTime.toString());\n-\n-\tSystem.out.println(enbDst);\n-\t//System.out.println(syncPer);\n-\tSystem.out.println(\"test!\");\n-\t\n-\t}\n-\t\n-\tpublic void updateDst(boolean enbDst) {\n-\t\tthis.enbDst = enbDst;\n-\t\t\n-\t}\n-\t\n-\tpublic void updateSyncPer(int syncPer) {\n-\t\tthis.syncPer = syncPer;\n-\t}\n-\t\n-\t\n-\t\n-\tpublic void deviceDisplay() {\n-\t\tlogger.info(\"**Device details**\");\n-\t\tlogger.info(MessageFormat.format(\"Daylight Saving Time active: {0} \", enbDst));\n-\t\tlogger.info(MessageFormat.format(\"Time resync interval: {0}\", syncPer));\n-\t}\n-}"
  },
  {
    "sha": "ac10572eac68d27f08c1c32a6680210b46f8fd16",
    "filename": "iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/EventDataListener.java",
    "status": "modified",
    "additions": 29,
    "deletions": 4,
    "changes": 33,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/EventDataListener.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/EventDataListener.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/EventDataListener.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -10,6 +10,8 @@\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.springframework.scheduling.annotation.EnableScheduling;\n+import org.springframework.scheduling.annotation.Scheduled;\n \n import com.beanit.openiec61850.BasicDataAttribute;\n import com.beanit.openiec61850.BdaBoolean;\n@@ -24,22 +26,36 @@\n import com.beanit.openiec61850.ServerSap;\n import com.beanit.openiec61850.ServiceError;\n \n+//@Configuration\n+@EnableScheduling\n class EventDataListener implements ServerEventListener {\n \n \tprivate static final Logger logger = LoggerFactory.getLogger(EventDataListener.class);\n \n \tprivate LocalDateTime currentTime = null;\n \tprivate String syncPer;\n \tprivate Device device = null;\n+\tprivate Scheduler scheduler;\n \n \t// private OnzeScheduleScheduler scheduler;\n \n-\tpublic EventDataListener(final Device device) {\n+\tpublic Scheduler getScheduler() {\n+\t\treturn this.scheduler;\n+\t}\n+\n+\tpublic EventDataListener(final Device device, Scheduler scheduler) {\n \t\tthis.device = device;\n+\t\tthis.scheduler = scheduler;\n \n \t\t// OnzeScheduleScheduler scheduler = new ...;\n \t}\n \n+\t// TODO: Make it Single Responsibility compliant > moving Cron Job over\n+\t@Scheduled(cron = \"0 0 0 * * ?\")\n+\tpublic void dailySwitchingMomentCalculation() {\n+\t\tthis.scheduler.switchingMomentCalculation(this.device);\n+\t}\n+\n \t@Override\n \tpublic List<ServiceError> write(final List<BasicDataAttribute> bdas) {\n \t\t// TODO: Fixing relayScheduleNumbers integration to not lose connection\n@@ -162,6 +178,7 @@ public EventDataListener(final Device device) {\n \t\t\t\t\t\t// OOP Class\n \t\t\t\t\t\tthis.device.getRelay(relayIndex).getSchedule(scheduleIndex)\n \t\t\t\t\t\t\t\t.setEnabled(((BdaBoolean) bda).getValue());\n+\t\t\t\t\t\tmodified = true;\n \n \t\t\t\t\t} catch (final Exception e) {\n \t\t\t\t\t\tlogger.info(\"Schedules above 50 are not implemented in the GXF platform. Skip ...\");\n@@ -181,6 +198,7 @@ public EventDataListener(final Device device) {\n \t\t\t\t\t\t\tmodified = true;\n \t\t\t\t\t\t\tthis.device.getRelay(relayIndex).getSchedule(scheduleIndex).setDayInt(newDay);\n \t\t\t\t\t\t}\n+\t\t\t\t\t\tmodified = true;\n \t\t\t\t\t} catch (final Exception e) {\n \t\t\t\t\t\tlogger.info(\"Schedules above 50 are not implemented in the GXF platform. Skip ...\");\n \t\t\t\t\t}\n@@ -198,6 +216,7 @@ public EventDataListener(final Device device) {\n \t\t\t\t\t\tint timeMinute = timeInt % 100;\n \t\t\t\t\t\tLocalTime timeLocalTime = LocalTime.of(timeHour, timeMinute);\n \t\t\t\t\t\tthis.device.getRelay(relayIndex).getSchedule(scheduleIndex).setTimeOn(timeLocalTime);\n+\t\t\t\t\t\tmodified = true;\n \t\t\t\t\t} catch (final Exception e) {\n \t\t\t\t\t\tlogger.info(\"Schedules above 50 are not implemented in the GXF platform. Skip ...\");\n \t\t\t\t\t}\n@@ -211,6 +230,7 @@ public EventDataListener(final Device device) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tthis.device.getRelay(relayIndex).getSchedule(scheduleIndex)\n \t\t\t\t\t\t\t\t.setTimeOnTypeInt(((BdaInt8) bda).getValue());\n+\t\t\t\t\t\tmodified = true;\n \t\t\t\t\t} catch (final Exception e) {\n \t\t\t\t\t\tlogger.info(\"Schedules above 50 are not implemented in the GXF platform. Skip ...\");\n \t\t\t\t\t}\n@@ -228,6 +248,7 @@ public EventDataListener(final Device device) {\n \t\t\t\t\t\tint timeMinute = timeInt % 100;\n \t\t\t\t\t\tLocalTime timeLocalTime = LocalTime.of(timeHour, timeMinute);\n \t\t\t\t\t\tthis.device.getRelay(relayIndex).getSchedule(scheduleIndex).setTimeOff(timeLocalTime);\n+\t\t\t\t\t\tmodified = true;\n \t\t\t\t\t} catch (final Exception e) {\n \t\t\t\t\t\tlogger.info(\"Schedules above 50 are not implemented in the GXF platform. Skip ...\");\n \t\t\t\t\t}\n@@ -241,6 +262,7 @@ public EventDataListener(final Device device) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tthis.device.getRelay(relayIndex).getSchedule(scheduleIndex)\n \t\t\t\t\t\t\t\t.setTimeOffTypeInt(((BdaInt8) bda).getValue());\n+\t\t\t\t\t\tmodified = true;\n \t\t\t\t\t} catch (final Exception e) {\n \t\t\t\t\t\tlogger.info(\"Schedules above 50 are not implemented in the GXF platform. Skip ...\");\n \t\t\t\t\t}\n@@ -254,6 +276,7 @@ public EventDataListener(final Device device) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tthis.device.getRelay(relayIndex).getSchedule(scheduleIndex)\n \t\t\t\t\t\t\t\t.setBurningMinsOn((short) ((BdaInt16U) bda).getValue());\n+\t\t\t\t\t\tmodified = true;\n \t\t\t\t\t} catch (final Exception e) {\n \t\t\t\t\t\tlogger.info(\"Schedules above 50 are not implemented in the GXF platform. Skip ...\");\n \t\t\t\t\t}\n@@ -267,6 +290,7 @@ public EventDataListener(final Device device) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tthis.device.getRelay(relayIndex).getSchedule(scheduleIndex)\n \t\t\t\t\t\t\t\t.setBeforeOffset((short) ((BdaInt16U) bda).getValue());\n+\t\t\t\t\t\tmodified = true;\n \t\t\t\t\t} catch (final Exception e) {\n \t\t\t\t\t\tlogger.info(\"Schedules above 50 are not implemented in the GXF platform. Skip ...\");\n \t\t\t\t\t}\n@@ -280,6 +304,7 @@ public EventDataListener(final Device device) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tthis.device.getRelay(relayIndex).getSchedule(scheduleIndex)\n \t\t\t\t\t\t\t\t.setAfterOffset((short) ((BdaInt16U) bda).getValue());\n+\t\t\t\t\t\tmodified = true;\n \t\t\t\t\t} catch (final Exception e) {\n \t\t\t\t\t\tlogger.info(\"Schedules above 50 are not implemented in the GXF platform. Skip ...\");\n \t\t\t\t\t}\n@@ -310,12 +335,12 @@ public EventDataListener(final Device device) {\n \t\t\tlogger.warn(\"Exception EventDataListener loop\", e);\n \t\t}\n \n-\t\tlogger.info(\"**Printing device.\");\n+\t\tlogger.info(\"\\n\\n Received BDA data applied to data objects.\");\n \n \t\t// Flag for Schedule modifications\n \t\tif (modified) {\n-\t\t\t// scheduler.scheduleSwitchingMomentCalculation(this.device);\n-\n+\t\t\tlogger.info(\"Schedules are modified! Calculate switching moments...\");\n+\t\t\tthis.scheduler.switchingMomentCalculation(this.device);\n \t\t}\n \n \t\treturn null;"
  },
  {
    "sha": "8eadfc4225524872979ce42a5b0b8858cd18b9fb",
    "filename": "iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/EventListener.java",
    "status": "removed",
    "additions": 0,
    "deletions": 24,
    "changes": 24,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/dd6e312e9c5b38a5df283180afd78859f6b994fe/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/EventListener.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/dd6e312e9c5b38a5df283180afd78859f6b994fe/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/EventListener.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/EventListener.java?ref=dd6e312e9c5b38a5df283180afd78859f6b994fe",
    "patch": "@@ -1,24 +0,0 @@\n-package com.cgi.iec61850serversimulator;\n-\n-import java.util.List;\n-\n-import com.beanit.openiec61850.BasicDataAttribute;\n-import com.beanit.openiec61850.ServerEventListener;\n-import com.beanit.openiec61850.ServerSap;\n-import com.beanit.openiec61850.ServiceError;\n-\n-class EventListener implements ServerEventListener {\n-\n-    @Override\n-    public void serverStoppedListening(ServerSap serverSap) {\n-      System.out.println(\"The SAP stopped listening\");\n-    }\n-\n-    @Override\n-    public List<ServiceError> write(List<BasicDataAttribute> bdas) {\n-      for (BasicDataAttribute bda : bdas) {\n-        System.out.println(\"got a write request: \" + bda);\n-      }\n-      return null;\n-    }\n-  }"
  },
  {
    "sha": "54f3993d3715ac5383b624f343c0c786e9eece5f",
    "filename": "iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Relay.java",
    "status": "modified",
    "additions": 23,
    "deletions": 52,
    "changes": 75,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Relay.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Relay.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Relay.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -1,6 +1,5 @@\n package com.cgi.iec61850serversimulator;\n \n-import java.util.Arrays;\n import java.util.List;\n \n import org.slf4j.Logger;\n@@ -10,30 +9,27 @@\n import com.beanit.openiec61850.BdaBoolean;\n import com.beanit.openiec61850.ModelNode;\n \n+/**\n+ * Class which represents a relay. It holds 50 schedules. While 64 schedules are\n+ * possible with IEC61850, the GXF platform only 50 of them. Hence why there are\n+ * only 50 schedules attached to every relay.\n+ */\n class Relay {\n \tprivate static final Logger logger = LoggerFactory.getLogger(Relay.class);\n \n-\t// Relay 1, 2, 3, 4\n+\t// Either 1, 2, 3 or 4\n \tint indexNumber;\n \tboolean lightStatus;\n \tModelNode scheduleInfo;\n+\n \tprivate Schedule[] schedules;\n-//\tSchedule schedule1;\n-//\tSchedule schedule2;\n-//\tSchedule schedule3;\n-\t// ..\n-//\tSchedule schedule50;\n-\t// filling up to 50 of them\n+\n \tprivate ServerWrapper serverWrapper;\n \n \tpublic Relay(ModelNode relayInfo, ModelNode scheduleInfo) {\n \n \t\tthis.indexNumber = Integer.parseInt(relayInfo.getReference().toString().substring(22, 23));\n \t\tthis.scheduleInfo = scheduleInfo;\n-\n-\t\t// ModelNode relayInfo =\n-\t\t// serverModel.findModelNode(\"SWDeviceGenericIO/XSWC*.SwType.Oper\".replace(\"*\",\n-\t\t// Integer.toString(this.indexNumber)), Fc.CO);\n \t\tList<BasicDataAttribute> bdas = relayInfo.getBasicDataAttributes();\n \n \t\tfor (BasicDataAttribute bda : bdas) {\n@@ -47,66 +43,35 @@ public Relay(ModelNode relayInfo, ModelNode scheduleInfo) {\n \t\t\t}\n \t\t}\n \t\t// Changing model to 1, enables actual switching with enbOpr on\n-\t\t/*\n-\t\t * try { logger.info(\"Set CTLModel for relay {} to value {}\", this.indexNumber,\n-\t\t * 1);\n-\t\t * \n-\t\t * final BdaBoolean lightModel = (BdaBoolean) this.serverWrapper\n-\t\t * .findModelNode(\"SWDeviceGenericIO/XSWC\" + this.indexNumber +\n-\t\t * \".Pos.Oper.ctlVal\", Fc.CO); // .findModelNode(\"SWDeviceGenericIO/XSWC\" +\n-\t\t * relay + \".Pos.stVal\", // Fc.ST); lightModel.setValue(light);\n-\t\t * \n-\t\t * final List<BasicDataAttribute> attributes = Arrays.asList(lightModel);\n-\t\t * this.serverWrapper.setValues(attributes); } catch (final Exception e) {\n-\t\t * logger.error(\"Find node or set value failed\", e); }\n-\t\t */\n-\t\t// Initalize Schedules!\n \t\tthis.initializeSchedules(scheduleInfo, this.indexNumber);\n \t}\n \n \tpublic Relay(int relayNr) {\n \t\tthis.indexNumber = relayNr + 1;\n \t}\n \n-\tpublic void displayRelay() {\n-\t\tlogger.info(\"**Printing relay \" + Integer.toString(this.indexNumber) + \"**\");\n-\t\tlogger.info(\"Light status:  \" + Boolean.toString(this.lightStatus) + \"\\n\");\n-\t\t// logger.info(schedules[0].toString());\n+\tpublic Schedule[] getSchedules() {\n+\t\treturn this.schedules;\n+\t}\n+\n+\tpublic void setSchedules(Schedule[] schedules) {\n+\t\tthis.schedules = schedules;\n \t}\n \n \tpublic void initializeSchedules(ModelNode scheduleInfo, int relayNr) {\n-\t\t/*\n-\t\t * for (int scheduleNumber = 1; scheduleNumber < 51; scheduleNumber++) { //\n-\t\t * Schedule initialization up to 50 String scheduleReference =\n-\t\t * \"SWDeviceGenericIO/XSWC*.Sche.sche~\".replace(\"*\",\n-\t\t * Integer.toString(this.indexNumber)).replace(\"~\",\n-\t\t * Integer.toString(scheduleNumber));\n-\t\t *\n-\t\t * return scheduleReference;\n-\t\t */\n \t\tthis.schedules = new Schedule[50];\n \t\tfor (int scheduleNr = 0; scheduleNr < 50; scheduleNr++) {\n \t\t\tthis.schedules[scheduleNr] = new Schedule(scheduleInfo, scheduleNr, relayNr);\n \t\t}\n-\t\t/*\n-\t\t * this.schedule2 = new Schedule();\n-\t\t * this.schedule2.initializeSchedule(scheduleInfo); this.schedule3 = new\n-\t\t * Schedule(); this.schedule3.initializeSchedule(scheduleInfo); this.schedule50\n-\t\t * = new Schedule(); this.schedule50.initializeSchedule(scheduleInfo);\n-\t\t */\n \t}\n-\t// TODO: Initializing all 50 schedules to be accepted by the platform\n-\t// Using a for-loop to get all 50 initialized per device?\n-\t// Using .toString generator to get the information\n \n \tpublic Schedule getSchedule(int index) {\n \t\treturn this.schedules[index - 1];\n \t}\n \n \t@Override\n \tpublic String toString() {\n-\t\treturn \"Relay [indexNumber=\" + this.indexNumber + \", lightStatus=\" + this.lightStatus + \", scheduleInfo=\"\n-\t\t\t\t+ this.scheduleInfo + \", schedules=\" + Arrays.toString(this.schedules) + \"]\";\n+\t\treturn \"Relay \" + this.indexNumber + \"'s light status is \" + this.lightStatus + \"\\n\";\n \t}\n \n \tpublic void setLight(boolean light) {\n@@ -116,6 +81,12 @@ public void setLight(boolean light) {\n \tpublic boolean getLight() {\n \t\treturn this.lightStatus;\n \t}\n-\t// Giving proper ModelNode per schedule by constructing the reference:\n-\t// SWDeviceGenericIP/XSWC<indexNumber>.Sche.sche<scheduleNumber>\n+\n+\tpublic int getIndexNumber() {\n+\t\treturn this.indexNumber;\n+\t}\n+\n+\tpublic void setIndexNumber(int indexNumber) {\n+\t\tthis.indexNumber = indexNumber;\n+\t}\n }\n\\ No newline at end of file"
  },
  {
    "sha": "d7181aa75208bbdd22233da2d93c465ed276b8d3",
    "filename": "iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Schedule.java",
    "status": "modified",
    "additions": 21,
    "deletions": 11,
    "changes": 32,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Schedule.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Schedule.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Schedule.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -14,11 +14,15 @@\n import com.beanit.openiec61850.BdaVisibleString;\n import com.beanit.openiec61850.ModelNode;\n \n+/**\n+ * Class which represents a schedule.\n+ */\n class Schedule {\n \tprivate static final Logger logger = LoggerFactory.getLogger(Schedule.class);\n \t// TODO: SwitchingMoment related attributes and functions here.\n \n \t// Enum as prescribed in the GXF documentation for SetSchedule\n+\t// To use for clearer visualization to users?\n \tpublic enum DAY {\n \t\tEVERYDAY(0), WEEKDAY(-1), WEEKEND(-2), MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6),\n \t\tSUNDAY(7);\n@@ -35,6 +39,7 @@ public int getDay() {\n \n \t}\n \n+\t// Usage for clearer visualization to users?\n \tpublic enum TIMETYPE {\n \t\tFIXED(0), SENSOR(1), ASTRONOMIC(2);\n \n@@ -49,8 +54,7 @@ public int getTimeType() {\n \t\t}\n \t}\n \n-\t// serverModel.findModelNode(\"SWDeviceGenericIO/CSLC.Clock\", Fc.CF)\n-\tint indexNumber; // Temporarily pre-set because only the first one is implemented\n+\tint indexNumber;\n \tint relayNr;\n \tboolean enabled;\n \tString description;\n@@ -63,8 +67,9 @@ public int getTimeType() {\n \tint timeOffTypeInt;\n \t// TIMETYPE timeOffType;\n \tint burningMinsOn;\n-\tint beforeOffset; // Maximum of 150?\n-\tint afterOffset; // Maximum of 150?\n+\t// Maximum of 150 minutes for offsets, in GXF platform\n+\tint beforeOffset;\n+\tint afterOffset;\n \n \tpublic Schedule(int indexNumber) {\n \t\t// For empty schedule initialization, especially for test cases!\n@@ -141,11 +146,18 @@ public Schedule(ModelNode scheduleInfo, int scheduleNr, int relayNr) {\n \n \t@Override\n \tpublic String toString() {\n-\t\treturn \"Schedule [indexNumber=\" + this.indexNumber + \", enabled=\" + this.enabled + \", description=\"\n-\t\t\t\t+ this.description + \", day=\" + this.dayInt + \", timeOn=\" + this.timeOn + \", timeOnType=\"\n-\t\t\t\t+ this.timeOnTypeInt + \", timeOff=\" + this.timeOff + \", timeOffType=\" + this.timeOffTypeInt\n-\t\t\t\t+ \", burningMinsOn=\" + this.burningMinsOn + \", beforeOffset=\" + this.beforeOffset + \", afterOffset=\"\n-\t\t\t\t+ this.afterOffset + \"]\";\n+\t\t// TODO: Making certain raw data better visualized towards users? AKA Day,\n+\t\t// timeOn/timeOff, their types etc.\n+\t\tStringBuilder scheduleStringBuilder = new StringBuilder();\n+\t\tscheduleStringBuilder.append(\"Schedule \" + this.indexNumber + \":\\n\")\n+\t\t\t\t.append(\"Is it enabled? \" + this.enabled + '\\n').append(\"Description: \" + this.description + '\\n')\n+\t\t\t\t.append(\"Day: \" + this.dayInt + '\\n').append(\"Time On: \" + this.timeOn + '\\n')\n+\t\t\t\t.append(\"Time On type: \" + this.timeOnTypeInt + '\\n').append(\"Time Off: \" + this.timeOffTypeInt + '\\n')\n+\t\t\t\t.append(\"Burning Minutes On: \" + this.burningMinsOn + '\\n')\n+\t\t\t\t.append(\"Offset (Before): \" + this.beforeOffset + '\\n')\n+\t\t\t\t.append(\"Offset (After): \" + this.afterOffset + '\\n');\n+\n+\t\treturn scheduleStringBuilder.toString();\n \t}\n \n \tpublic int getIndexNumber() {\n@@ -178,7 +190,6 @@ public String getDescription() {\n \t}\n \n \tpublic void setDescription(String description) {\n-\n \t\tthis.description = description;\n \t}\n \n@@ -187,7 +198,6 @@ public int getDayInt() {\n \t}\n \n \tpublic void setDayInt(int dayInt) {\n-\n \t\tthis.dayInt = dayInt;\n \t}\n "
  },
  {
    "sha": "4e7837095f959260288ff2e7a0c54b186a1a8607",
    "filename": "iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Scheduler.java",
    "status": "modified",
    "additions": 79,
    "deletions": 3,
    "changes": 82,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Scheduler.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Scheduler.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/Scheduler.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -1,11 +1,87 @@\n package com.cgi.iec61850serversimulator;\n \n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+/**\n+ * Class which schedules autonomous switching moments for future activation.\n+ */\n public class Scheduler {\n-\t// Baseer het op de voorbeeld code in feature/example-scheduling! Op bepaalde\n-\t// momenten pas schakeltijden\n-\t// berekenen in plaats van continue check!\n+\t// Base it on feature/example-scheduling code! Triggering at certain\n+\t// times instead of a continuous check!\n+\n+\t// TODO: Build switching moment calculation functionality\n+\t// Read schedules from device's relays (1 * 4 * 50)\n+\t// Checks on and off times along with burning minutes to see which switching\n+\t// moments should be made for X hours\n+\t// Scheduling said tasks by calculating the relative time and using said\n+\t// relative time to set the task with ScheduledExecutorService from Java\n+\n \tprivate static final Logger logger = LoggerFactory.getLogger(Scheduler.class);\n+\n+\tScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+\t// Callables declareren ivm ScheduledFuture\n+\t// Of toch runnables?\n+\n+\t// private TaskScheduler switchingMomentScheduler;\n+\t// private ScheduledFuture<?> future;\n+\n+\t/*\n+\t * public ScheduledFuture<?> getFuture() { return this.future; }\n+\t *\n+\t * public void setFuture(ScheduledFuture<?> future) { this.future = future; }\n+\t *\n+\t * public Scheduler(final TaskScheduler scheduler) {\n+\t * this.switchingMomentScheduler = scheduler; }\n+\t */\n+\n+\tpublic void switchingMomentCalculation(final Device device) {\n+\t\tlogger.info(\"Switching moment calculation feature yet to implement.\");\n+\n+\t\t/* @formatter:off\n+\t\t * TODO: Switching moment calculation using schedules from device...\n+\t\t *\n+\t\t * Steps:\n+\t\t * - Reading schedules from device's relays\n+\t\t * - Determine from each schedule which switching moments are valid ((TimeOff - TimeOn) > burningMins);\n+\t\t * - Either add converted relative time, or Switching Moment objects to array;\n+\t\t * - (Use switchingMomentRelativeTimeConversion to convert from Switching Moment object\n+\t\t * \t to relative time;)\n+\t\t * - Use relative times to schedule tasks (using ScheduledExecutorService\n+\t\t *   or different process?)\n+\t\t * @formatter:on\n+\t\t */\n+\t}\n+\n+\tpublic void switchingMomentRelativeTimeConversion() {\n+\t\t// TODO: Switching moment --> relative time conversion for scheduled trigger\n+\t\t// actions\n+\t}\n+\n+\t// Voorbeeld voor On task\n+\tprivate Runnable onRunnableCreator(final int relayNr) {\n+\t\tRunnable onRun = new Runnable() {\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\t// functie hier met parameter\n+\t\t\t\tScheduler.this.switchingMomentRelativeTimeConversion();\n+\t\t\t}\n+\t\t};\n+\t\treturn onRun;\n+\t}\n+\n+\t// Voorbeeld voor Off task\n+\tprivate Runnable offRunnableCreator(final int relayNr) {\n+\t\tRunnable offRun = new Runnable() {\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\t// functie hier met parameter\n+\t\t\t\tScheduler.this.switchingMomentRelativeTimeConversion();\n+\t\t\t}\n+\t\t};\n+\t\treturn offRun;\n+\t}\n }"
  },
  {
    "sha": "f11707fadf6e529fc3f8730a90e98837713a3403",
    "filename": "iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/ServerSimulator.java",
    "status": "modified",
    "additions": 92,
    "deletions": 89,
    "changes": 181,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/ServerSimulator.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/ServerSimulator.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/ServerSimulator.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -3,11 +3,15 @@\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.boot.SpringApplication;\n import org.springframework.boot.autoconfigure.SpringBootApplication;\n+import org.springframework.scheduling.TaskScheduler;\n+import org.springframework.scheduling.concurrent.ConcurrentTaskScheduler;\n \n import com.beanit.openiec61850.SclParseException;\n import com.beanit.openiec61850.SclParser;\n@@ -25,94 +29,93 @@\n @SpringBootApplication\n public class ServerSimulator {\n \n-    private static final Logger logger = LoggerFactory.getLogger(ServerSimulator.class);\n-\n-    private static final String PRINT_SERVER_MODEL_KEY = \"p\";\n-    private static final String PRINT_SERVER_MODEL_KEY_DESCRIPTION = \"print server's model\";\n-    private static final String DEVICE_SHOW_MODEL = \"d\";\n-    private static final String DEVICE_SHOW_MODEL_DESCRIPTION = \"print device object\";\n-\n-    private static final IntCliParameter portParam = new CliParameterBuilder(\"-p\").setDescription(\n-            \"The port to listen on. On unix based systems you need root privilages for ports < 1000. Default: 102\")\n-            .buildIntParameter(\"port\", 10102);\n-\n-    private static final StringCliParameter modelFileParam = new CliParameterBuilder(\"-m\")\n-            .setDescription(\"The SCL file that contains the server's information model.\")\n-            .setMandatory()\n-            .buildStringParameter(\"model-file\");\n-\n-    public static ServerModel serverModel;\n-    public static ServerSap serverSap = null;\n-\n-    public static void main(final String[] args) throws IOException {\n-\n-        SpringApplication.run(ServerSimulator.class, args);\n-        logger.info(\"Applicatie starten...\");\n-\n-        final List<CliParameter> cliParameters = new ArrayList<>();\n-        cliParameters.add(modelFileParam);\n-        cliParameters.add(portParam);\n-\n-        final CliParser cliParser = new CliParser(\"iec61850bean-console-server\", \"An IEC 61850 MMS console server.\");\n-        cliParser.addParameters(cliParameters);\n-\n-        try {\n-            cliParser.parseArguments(args);\n-        } catch (final CliParseException e1) {\n-            System.err.println(\"Error parsing command line parameters: \" + e1.getMessage());\n-            System.out.println(cliParser.getUsageString());\n-            System.exit(1);\n-        }\n-\n-        List<ServerModel> serverModels = null;\n-        try {\n-            serverModels = SclParser.parse(modelFileParam.getValue());\n-        } catch (final SclParseException e) {\n-            System.out.println(\"Error parsing SCL/ICD file: \" + e.getMessage());\n-            return;\n-        }\n-        logger.info(\"ServerSap aanmaken...\");\n-        serverSap = new ServerSap(portParam.getValue(), 0, null, serverModels.get(0), null);\n-        logger.info(\"ServerSap aangemaakt met als poort: {}\", portParam.getValue());\n-        Runtime.getRuntime().addShutdownHook(new Thread() {\n-            @Override\n-            public void run() {\n-                if (serverSap != null) {\n-                    serverSap.stop();\n-                }\n-                System.out.println(\"Server was stopped.\");\n-            }\n-        });\n-        logger.info(\"Model copy gestart\");\n-        serverModel = serverSap.getModelCopy();\n-        logger.info(\"Model copy done!\");\n-\n-        // Device intialization by copying from serverModel\n-        final ServerWrapper serverWrapper = new ServerWrapper(serverSap);\n-        final Device device = new Device();\n-        device.initalizeDevice(serverWrapper);\n-        // Functie toevoegen om details van serverModel naar Device te doen\n-\n-        // ActionExecutor actionExecutor = new\n-        // ActionExecutor(PRINT_SERVER_MODEL_KEY, serverSap, serverModel);\n-\n-        logger.info(\"SERVER START LISTENING\");\n-        serverSap.startListening(new EventDataListener(device));\n-\n-        final ActionProcessor actionProcessor = new ActionProcessor(new ActionExecutor(serverSap, serverModel, device));\n-        actionProcessor.addAction(new Action(PRINT_SERVER_MODEL_KEY, PRINT_SERVER_MODEL_KEY_DESCRIPTION));\n-        actionProcessor.addAction(new Action(DEVICE_SHOW_MODEL, DEVICE_SHOW_MODEL_DESCRIPTION));\n-        // actionProcessor.addAction(new Action(WRITE_VALUE_KEY,\n-        // WRITE_VALUE_KEY_DESCRIPTION));\n-\n-        actionProcessor.start();\n-\n-        /*\n-         * logger.info(\"Applicatie starten...\");\n-         * System.out.println(\"Hallo, wereld!\");\n-         * logger.info(\"Applicatie gesloten.\");\n-         */\n-\n-    }\n+\tprivate static final Logger logger = LoggerFactory.getLogger(ServerSimulator.class);\n+\n+\tprivate static final String PRINT_SERVER_MODEL_KEY = \"p\";\n+\tprivate static final String PRINT_SERVER_MODEL_KEY_DESCRIPTION = \"print server's model\";\n+\tprivate static final String DEVICE_SHOW_MODEL = \"d\";\n+\tprivate static final String DEVICE_SHOW_MODEL_DESCRIPTION = \"print device object\";\n+\n+\tprivate static final IntCliParameter portParam = new CliParameterBuilder(\"-p\").setDescription(\n+\t\t\t\"The port to listen on. On unix based systems you need root privilages for ports < 1000. Default: 102\")\n+\t\t\t.buildIntParameter(\"port\", 10102);\n+\n+\tprivate static final StringCliParameter modelFileParam = new CliParameterBuilder(\"-m\")\n+\t\t\t.setDescription(\"The SCL file that contains the server's information model.\").setMandatory()\n+\t\t\t.buildStringParameter(\"model-file\");\n+\n+\tpublic static ServerModel serverModel;\n+\tpublic static ServerSap serverSap = null;\n+\n+\tpublic static void main(final String[] args) throws IOException {\n+\n+\t\tSpringApplication.run(ServerSimulator.class, args);\n+\t\tlogger.info(\"Applicatie starten...\");\n+\n+\t\tfinal List<CliParameter> cliParameters = new ArrayList<>();\n+\t\tcliParameters.add(modelFileParam);\n+\t\tcliParameters.add(portParam);\n+\n+\t\tfinal CliParser cliParser = new CliParser(\"iec61850bean-console-server\", \"An IEC 61850 MMS console server.\");\n+\t\tcliParser.addParameters(cliParameters);\n+\n+\t\ttry {\n+\t\t\tcliParser.parseArguments(args);\n+\t\t} catch (final CliParseException e1) {\n+\t\t\tlogger.error(\"Error parsing command line parameters: \" + e1.getMessage());\n+\t\t\tlogger.info(cliParser.getUsageString());\n+\t\t\tSystem.exit(1);\n+\t\t}\n+\n+\t\tList<ServerModel> serverModels = null;\n+\t\ttry {\n+\t\t\tserverModels = SclParser.parse(modelFileParam.getValue());\n+\t\t} catch (final SclParseException e) {\n+\t\t\tSystem.out.println(\"Error parsing SCL/ICD file: \" + e.getMessage());\n+\t\t\treturn;\n+\t\t}\n+\t\tlogger.info(\"ServerSap aanmaken...\");\n+\t\tserverSap = new ServerSap(portParam.getValue(), 0, null, serverModels.get(0), null);\n+\t\tlogger.info(\"ServerSap aangemaakt met als poort: {}\", portParam.getValue());\n+\t\tRuntime.getRuntime().addShutdownHook(new Thread() {\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tif (serverSap != null) {\n+\t\t\t\t\tserverSap.stop();\n+\t\t\t\t}\n+\t\t\t\tSystem.out.println(\"Server was stopped.\");\n+\t\t\t}\n+\t\t});\n+\t\tlogger.debug(\"Model copy gestart\");\n+\t\tserverModel = serverSap.getModelCopy();\n+\t\tlogger.debug(\"Model copy done!\");\n+\n+\t\t// Initializing Scheduler related components\n+\t\tfinal ScheduledExecutorService localExecutor = Executors.newSingleThreadScheduledExecutor();\n+\t\tfinal TaskScheduler taskScheduler = new ConcurrentTaskScheduler(localExecutor);\n+\n+\t\t// Device initialization by copying from serverModel\n+\t\tfinal ServerWrapper serverWrapper = new ServerWrapper(serverSap);\n+\t\tfinal Device device = new Device();\n+\t\tfinal Scheduler scheduler = new Scheduler();\n+\t\tdevice.initalizeDevice(serverWrapper);\n+\n+\t\tlogger.info(\"SERVER START LISTENING\");\n+\t\tEventDataListener edl = new EventDataListener(device, scheduler);\n+\t\tserverSap.startListening(edl);\n+\n+\t\t// Initial schedule\n+\t\ttry {\n+\t\t\tedl.getScheduler().switchingMomentCalculation(device);\n+\t\t} catch (Exception e) {\n+\t\t\tlogger.info(\"Initial switching moment calculation failed, try sending another schedule.\");\n+\t\t}\n+\t\tfinal ActionProcessor actionProcessor = new ActionProcessor(new ActionExecutor(serverSap, serverModel, device));\n+\t\tactionProcessor.addAction(new Action(PRINT_SERVER_MODEL_KEY, PRINT_SERVER_MODEL_KEY_DESCRIPTION));\n+\t\tactionProcessor.addAction(new Action(DEVICE_SHOW_MODEL, DEVICE_SHOW_MODEL_DESCRIPTION));\n+\n+\t\tactionProcessor.start();\n+\n+\t}\n \n }"
  },
  {
    "sha": "aabe7177a17e955df378a329bb773d1e30b2c375",
    "filename": "iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/SwitchingMoment.java",
    "status": "added",
    "additions": 72,
    "deletions": 0,
    "changes": 72,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/SwitchingMoment.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/SwitchingMoment.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/SwitchingMoment.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -0,0 +1,72 @@\n+\n+package com.cgi.iec61850serversimulator;\n+\n+import java.time.LocalDateTime;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class which represents a switching moment (a scheduled action based on a list\n+ * of actions in a schedule). It is used for storing valid switching moments\n+ * before being processed into future tasks. A valid switching moment is a\n+ * scheduled switching moment where the difference in time between TimeOn and\n+ * TimeOff is greater than BurningMins.\n+ *\n+ * Periodic switching moments will have each their own individual switching\n+ * moments instances based on how many are needed within the calculated X of\n+ * hours.\n+ *\n+ * The data being stored in this class is:\n+ * <ul>\n+ * <li>The destination relay's number</li>\n+ * <li>The date and time when to trigger the switching moment\n+ * (LocalDateTime)</li>\n+ * <li>The type of action what to trigger (On = true, Off = false)</li>\n+ * </ul>\n+ */\n+\n+public class SwitchingMoment {\n+\n+\t// TODO Use the class for switching moment calculations and:\n+\t// - have the objects in an array before conversion to relative time\n+\t// - put said relative time to use when creating scheduled tasks (using\n+\t// ScheduledExecutorService?)\n+\n+\tprivate static final Logger logger = LoggerFactory.getLogger(SwitchingMoment.class);\n+\n+\tprivate int relayNr;\n+\tprivate LocalDateTime triggerTime;\n+\tprivate boolean triggerAction;\n+\n+\tSwitchingMoment(int relayNr, LocalDateTime triggerTime, boolean triggerAction) {\n+\t\tthis.relayNr = relayNr;\n+\t\tthis.triggerTime = triggerTime;\n+\t\tthis.triggerAction = triggerAction;\n+\t}\n+\n+\tpublic int getRelayNr() {\n+\t\treturn this.relayNr;\n+\t}\n+\n+\tpublic void setRelayNr(int relayNr) {\n+\t\tthis.relayNr = relayNr;\n+\t}\n+\n+\tpublic LocalDateTime getTriggerTime() {\n+\t\treturn this.triggerTime;\n+\t}\n+\n+\tpublic void setTriggerTime(LocalDateTime triggerTime) {\n+\t\tthis.triggerTime = triggerTime;\n+\t}\n+\n+\tpublic boolean isTriggerAction() {\n+\t\treturn this.triggerAction;\n+\t}\n+\n+\tpublic void setTriggerAction(boolean triggerAction) {\n+\t\tthis.triggerAction = triggerAction;\n+\t}\n+\n+}"
  },
  {
    "sha": "049f5337e6e81cb56ac7e5a190ad58025b6c2278",
    "filename": "iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/SwitchingMomentCalculator.java",
    "status": "modified",
    "additions": 192,
    "deletions": 10,
    "changes": 202,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/SwitchingMomentCalculator.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/SwitchingMomentCalculator.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/main/java/com/cgi/iec61850serversimulator/SwitchingMomentCalculator.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -1,24 +1,206 @@\n package com.cgi.iec61850serversimulator;\n \n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class SwitchingMomentCalculator implements Runnable {\n+public class SwitchingMomentCalculator {\n+\t// Steps:\n+\t// Accept device\n+\t// Reads schedules from device\n+\t// Checks on, off time and action type to create SwitchingMoments by assigning\n+\t// relay Number, TriggerTime and TriggerType\n \n \tprivate static final Logger logger = LoggerFactory.getLogger(SwitchingMomentCalculator.class);\n \n-\tprivate Device device;\n+\tpublic List<SwitchingMoment> calculateSwitchingMoments(Device device) {\n+\t\tList<SwitchingMoment> switchingMoments = new ArrayList<SwitchingMoment>();\n+\t\t// Calculating switching moments for today and tomorrow\n+\t\tLocalDateTime now = LocalDateTime.now();\n+\t\tLocalDateTime nextDay = now.plusDays(1);\n \n-\tpublic SwitchingMomentCalculator(final Device device) {\n-\t\tthis.device = device;\n-\t}\n+\t\tfor (int relayNr = 1; relayNr <= 4; relayNr++) {\n+\t\t\ttry {\n+\t\t\t\tRelay relay = device.getRelay(relayNr);\n+\n+\t\t\t\tfor (int scheduleNr = 1; scheduleNr <= relay.getSchedules().length; scheduleNr++) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tSchedule schedule = relay.getSchedule(scheduleNr);\n+\t\t\t\t\t\tif (schedule.isEnabled()) {\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\tSwitchingMoment actualSwitchingMomentOn = this.calculateSwitchingMoment(relayNr, schedule,\n+\t\t\t\t\t\t\t\t\t\ttrue, now);\n+\t\t\t\t\t\t\t\tswitchingMoments.add(actualSwitchingMomentOn);\n+\t\t\t\t\t\t\t\tSwitchingMoment actualSwitchingMomentOn2 = this.calculateSwitchingMoment(relayNr, schedule,\n+\t\t\t\t\t\t\t\t\t\ttrue, nextDay);\n+\t\t\t\t\t\t\t\tswitchingMoments.add(actualSwitchingMomentOn2);\n+\t\t\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\t\t\tlogger.info(\"No Switching Moment for On action created...\");\n+\t\t\t\t\t\t\t\tlogger.info(e.toString());\n+\t\t\t\t\t\t\t}\n \n-\t@Override\n-\tpublic void run() {\n-\t\t// TODO Auto-generated method stub\n-\t\t// Calculating the switching moments by grabbing the schedules from the device's\n-\t\t// relays\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\tSwitchingMoment actualSwitchingMomentOff = this.calculateSwitchingMoment(relayNr, schedule,\n+\t\t\t\t\t\t\t\t\t\tfalse, now);\n+\t\t\t\t\t\t\t\tswitchingMoments.add(actualSwitchingMomentOff);\n+\t\t\t\t\t\t\t\tSwitchingMoment actualSwitchingMomentOff2 = this.calculateSwitchingMoment(relayNr, schedule,\n+\t\t\t\t\t\t\t\t\t\tfalse, nextDay);\n+\t\t\t\t\t\t\t\tswitchingMoments.add(actualSwitchingMomentOff2);\n+\t\t\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\t\t\tlogger.info(\"No Switching Moment for Off action created...\");\n+\t\t\t\t\t\t\t\tlogger.info(e.toString());\n \n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\tlogger.info(\"No enabled schedule found, number {}.\", scheduleNr);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tlogger.info(\"No relay found, number {}\", relayNr);\n+\t\t\t}\n+\t\t}\n+\t\treturn switchingMoments;\n \t}\n \n+\tprivate SwitchingMoment calculateSwitchingMoment(int relayNr, Schedule schedule, boolean triggerAction,\n+\t\t\tLocalDateTime toCheckTime) {\n+\n+\t\tSwitchingMoment actualSwitchingMoment = new SwitchingMoment(relayNr, null, triggerAction);\n+\t\tint scheduledOccurence = schedule.getDayInt();\n+\t\tDayOfWeek dayOfWeek = toCheckTime.getDayOfWeek();\n+\t\t/*\n+\t\t * LocalDateTime now = LocalDateTime.now(); LocalDateTime nextday =\n+\t\t * now.plusDays(1); DayOfWeek day1 = now.getDayOfWeek(); DayOfWeek day2 =\n+\t\t * nextday.getDayOfWeek();\n+\t\t */\n+\t\tswitch (scheduledOccurence) {\n+\t\t// Check if day is within 2 days. Always recalculate every day.\n+\t\t// TODO: Implementing every day, every week day and every weekend day\n+\t\tcase 0:\n+\t\t\t// Trigger every day? No condition check?\n+\t\t\tactualSwitchingMoment.setTriggerTime(toCheckTime);\n+\t\t\tlogger.info(\"Elke dag\");\n+\t\t\tbreak;\n+\n+\t\tcase -1:\n+\t\t\t// Check at Monday, Tuesday, Wednesday, Thursday, Friday\n+\t\t\tif (dayOfWeek == DayOfWeek.MONDAY || dayOfWeek == DayOfWeek.TUESDAY || dayOfWeek == DayOfWeek.WEDNESDAY\n+\t\t\t\t\t|| dayOfWeek == DayOfWeek.THURSDAY || dayOfWeek == DayOfWeek.FRIDAY) {\n+\t\t\t\tactualSwitchingMoment.setTriggerTime(toCheckTime);\n+\t\t\t\tlogger.info(\"Elke werkdag\");\n+\t\t\t} else {\n+\t\t\t\tlogger.info(\"Given date is not on a weekday, no switching moment.\");\n+\t\t\t}\n+\t\t\tbreak;\n+\n+\t\tcase -2:\n+\t\t\t// Check at Saturday, Sunday\n+\n+\t\t\tif (dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY) {\n+\t\t\t\tactualSwitchingMoment.setTriggerTime(toCheckTime);\n+\t\t\t\tlogger.info(\"Elke weekenddag\");\n+\t\t\t} else {\n+\t\t\t\tlogger.info(\"Given date is not on weekend day, no switching moment.\", DayOfWeek.MONDAY);\n+\t\t\t}\n+\t\t\tbreak;\n+\n+\t\tcase 1:\n+\t\t\tif (dayOfWeek == DayOfWeek.MONDAY) {\n+\t\t\t\tactualSwitchingMoment.setTriggerTime(toCheckTime);\n+\t\t\t} else {\n+\t\t\t\tlogger.info(\"Given date is not on {0}, no switching moment.\", DayOfWeek.MONDAY);\n+\t\t\t}\n+\t\t\tbreak;\n+\n+\t\tcase 2:\n+\t\t\tif (dayOfWeek == DayOfWeek.TUESDAY) {\n+\t\t\t\tactualSwitchingMoment.setTriggerTime(toCheckTime);\n+\t\t\t} else {\n+\t\t\t\tlogger.info(\"Given date is not on {0}, no switching moment.\", DayOfWeek.TUESDAY);\n+\t\t\t}\n+\t\t\tbreak;\n+\n+\t\tcase 3:\n+\t\t\tif (dayOfWeek == DayOfWeek.WEDNESDAY) {\n+\t\t\t\tactualSwitchingMoment.setTriggerTime(toCheckTime);\n+\t\t\t} else {\n+\t\t\t\tlogger.info(\"Given date is not on {0}, no switching moment.\", DayOfWeek.WEDNESDAY);\n+\t\t\t}\n+\t\t\tbreak;\n+\n+\t\tcase 4:\n+\t\t\tif (dayOfWeek == DayOfWeek.THURSDAY) {\n+\t\t\t\tactualSwitchingMoment.setTriggerTime(toCheckTime);\n+\t\t\t} else {\n+\t\t\t\tlogger.info(\"Given date is not on {0}, no switching moment.\", DayOfWeek.THURSDAY);\n+\t\t\t}\n+\t\t\tbreak;\n+\n+\t\tcase 5:\n+\t\t\tif (dayOfWeek == DayOfWeek.FRIDAY) {\n+\t\t\t\tactualSwitchingMoment.setTriggerTime(toCheckTime);\n+\t\t\t} else {\n+\t\t\t\tlogger.info(\"Given date is not on {0}, no switching moment.\", DayOfWeek.FRIDAY);\n+\t\t\t}\n+\t\t\tbreak;\n+\n+\t\tcase 6:\n+\t\t\tif (dayOfWeek == DayOfWeek.SATURDAY) {\n+\t\t\t\tactualSwitchingMoment.setTriggerTime(toCheckTime);\n+\t\t\t} else {\n+\t\t\t\tlogger.info(\"Given date is not on {0}, no switching moment.\", DayOfWeek.SATURDAY);\n+\t\t\t}\n+\t\t\tbreak;\n+\n+\t\tcase 7:\n+\t\t\tif (dayOfWeek == DayOfWeek.SUNDAY) {\n+\t\t\t\tactualSwitchingMoment.setTriggerTime(toCheckTime);\n+\t\t\t} else {\n+\t\t\t\tlogger.info(\"Given date is not on {0}, no switching moment.\", DayOfWeek.SUNDAY);\n+\t\t\t}\n+\t\t\tbreak;\n+\n+\t\t// When a static date is scheduled instead of a (set of) re-occurring day(s),\n+\t\t// use the default case\n+\t\tdefault:\n+\t\t\t// With specific date\n+\t\t\tlogger.info(\"Datum... (yyyymmdd)\");\n+\t\t\t// Look at format: Year-Month-Day\n+\n+\t\t\t// TODO: Formatting/converting should only happen when receiving a value\n+\t\t\tDateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(\"yyyyMMdd\");\n+\t\t\tString stringDate = String.valueOf(scheduledOccurence);\n+\t\t\tLocalDateTime triggerDate = LocalDateTime.parse(stringDate, dateFormat);\n+\t\t\tactualSwitchingMoment.setTriggerTime(triggerDate);\n+\n+\t\t\t// Nog doen: triggerDate returnen! Al aan SwitchingMoment geven om dat te laten\n+\t\t\t// returnen?\n+\t\t}\n+\t\tLocalDateTime triggerTime = actualSwitchingMoment.getTriggerTime();\n+\t\t// Uur/minuut optellen\n+\n+\t\tif (triggerAction) {\n+\t\t\tLocalTime timeOn = schedule.getTimeOn();\n+\t\t\tLocalDate triggerDate = triggerTime.toLocalDate();\n+\t\t\ttriggerTime = LocalDateTime.of(triggerDate, timeOn);\n+\t\t\tactualSwitchingMoment.setTriggerTime(triggerTime);\n+\t\t}\n+\n+\t\telse {\n+\t\t\tLocalTime timeOff = schedule.getTimeOff();\n+\t\t\tLocalDate triggerDate = triggerTime.toLocalDate();\n+\t\t\ttriggerTime = LocalDateTime.of(triggerDate, timeOff);\n+\t\t\tactualSwitchingMoment.setTriggerTime(triggerTime);\n+\t\t}\n+\n+\t\treturn actualSwitchingMoment;\n+\t}\n }"
  },
  {
    "sha": "f9f50ece63da2542901421dcc44e57fbab7bdacb",
    "filename": "iec61850serversimulator/src/main/resources/application.properties",
    "status": "modified",
    "additions": 12,
    "deletions": 1,
    "changes": 13,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/resources/application.properties",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/main/resources/application.properties",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/main/resources/application.properties?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -17,4 +17,15 @@ log4j.appender.FILE.DatePattern='.' yyyy-MM-dd-a\n \n # Define the layout for file appender\n log4j.appender.FILE.layout=org.apache.log4j.PatternLayout\n-log4j.appender.FILE.layout.conversionPattern=%m%n\n\\ No newline at end of file\n+log4j.appender.FILE.layout.conversionPattern=%m%n\n+\n+# PostgreSQL database configuration\n+spring.datasource.url= jdbc:postgresql://localhost:5432/iec61850_simulator\n+#spring.datasource.username = osp_admin\n+#spring.datasource.password = <navragen>\n+\n+spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation= true\n+spring.jpa.properties.hibernate.dialect= org.hibernate.dialect.PostgreSQLDialect\n+\n+# Hibernate ddl auto (create, create-drop, validate, update)\n+spring.jpa.hibernate.ddl-auto= update\n\\ No newline at end of file"
  },
  {
    "sha": "a928fc13655da71fd7dbb161711e31c40741d909",
    "filename": "iec61850serversimulator/src/test/java/com/cgi/experiments/DALDevice.java",
    "status": "added",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/test/java/com/cgi/experiments/DALDevice.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/test/java/com/cgi/experiments/DALDevice.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/test/java/com/cgi/experiments/DALDevice.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -0,0 +1,6 @@\n+package com.cgi.experiments;\n+\n+public class DALDevice {\n+\t// Data Access Layer for PostgreSQL database for Device table\n+\n+}"
  },
  {
    "sha": "0b700242bb61efb016f49ebf95908b647f3571ec",
    "filename": "iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/BdaGenerator.java",
    "status": "added",
    "additions": 21,
    "deletions": 0,
    "changes": 21,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/BdaGenerator.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/BdaGenerator.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/BdaGenerator.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -0,0 +1,21 @@\n+package com.cgi.iec61850serversimulator;\n+\n+import com.beanit.openiec61850.BdaInt16;\n+import com.beanit.openiec61850.Fc;\n+import com.beanit.openiec61850.ObjectReference;\n+\n+public class BdaGenerator {\n+\t// Methode aanmaken voor initialiseren van BdaInt16 met ObjectReference string,\n+\t// Fc en de Value\n+\n+\tpublic BdaInt16 generateBdaInt16(String objectReferenceString, String fcString, short value) {\n+\t\tObjectReference objectReference = new ObjectReference(objectReferenceString);\n+\t\tFc fc = Fc.fromString(fcString);\n+\n+\t\tBdaInt16 bda = new BdaInt16(objectReference, fc, null, false, false);\n+\t\tbda.setValue(value);\n+\n+\t\treturn bda;\n+\t}\n+\n+}"
  },
  {
    "sha": "a43a1637fc71abb9d81d863d8cbc2244e21ebc64",
    "filename": "iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/DeviceTest.java",
    "status": "added",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/DeviceTest.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/DeviceTest.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/DeviceTest.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -0,0 +1,6 @@\n+package com.cgi.iec61850serversimulator;\n+\n+public class DeviceTest {\n+\t// Mock Device test\n+\n+}"
  },
  {
    "sha": "20383b6d4f275bd1e0dc71254102031cb336c9d7",
    "filename": "iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/EventDataListenerTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/EventDataListenerTest.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/EventDataListenerTest.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/EventDataListenerTest.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -8,7 +8,7 @@\n \n public class EventDataListenerTest {\n \n-\tprivate EventDataListener eventDataListener = new EventDataListener(null);\n+\tprivate EventDataListener eventDataListener = new EventDataListener(null, null);\n \n \t@Test\n \tpublic void extractRelaySingleDigit() {"
  },
  {
    "sha": "b7f41e9167f2910e5e5a821351f2071ca95f9099",
    "filename": "iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/SchedulerTest.java",
    "status": "removed",
    "additions": 0,
    "deletions": 7,
    "changes": 7,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/dd6e312e9c5b38a5df283180afd78859f6b994fe/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/SchedulerTest.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/dd6e312e9c5b38a5df283180afd78859f6b994fe/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/SchedulerTest.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/SchedulerTest.java?ref=dd6e312e9c5b38a5df283180afd78859f6b994fe",
    "patch": "@@ -1,7 +0,0 @@\n-package com.cgi.iec61850serversimulator;\n-\n-class SchedulerTest {\n-\t// Baseer het op het ontwerp van feature/example-scheduling!\n-\t// Initializing example schedule + scheduler class\n-\tScheduler scheduler = new Scheduler();\n-}"
  },
  {
    "sha": "814a7c7a99c89cb7574bcaba20d2054c95bf41df",
    "filename": "iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/SwitchingMomentCalculatorTest.java",
    "status": "added",
    "additions": 315,
    "deletions": 0,
    "changes": 315,
    "blob_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/blob/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/SwitchingMomentCalculatorTest.java",
    "raw_url": "https://github.com/kevin-wijnen/gxf-iec61850simulator/raw/006bf1c41ee2b88d50b3cd89d7425c972ead0bcf/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/SwitchingMomentCalculatorTest.java",
    "contents_url": "https://api.github.com/repos/kevin-wijnen/gxf-iec61850simulator/contents/iec61850serversimulator/src/test/java/com/cgi/iec61850serversimulator/SwitchingMomentCalculatorTest.java?ref=006bf1c41ee2b88d50b3cd89d7425c972ead0bcf",
    "patch": "@@ -0,0 +1,315 @@\n+package com.cgi.iec61850serversimulator;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class SwitchingMomentCalculatorTest {\n+\t/**\n+\t * JUnit test class which tests the various related functions of the\n+\t * SwitchingMomentCalculator class.\n+\t *\n+\t * This includes unique functions for mocking a relay and schedule.\n+\t *\n+\t * Tests include:\n+\t * <ul>\n+\t * <li>Checking the mocked relay\n+\t * <li>Checking the mocked schedule\n+\t * <li>Checking the generated Switching Moment made out of a mocked relay and\n+\t * schedule\n+\t * </ul>\n+\t */\n+\n+\tpublic static class MockedScheduleBuilder {\n+\n+\t\tprivate int scheduleNr;\n+\t\tprivate int relayNr;\n+\t\tprivate int dayInt;\n+\t\tprivate int fixedTimeInt;\n+\t\tprivate int fixedTimeOn;\n+\t\tprivate int fixedTimeOff;\n+\t\tprivate LocalTime timeOn;\n+\t\tprivate LocalTime timeOff;\n+\t\tprivate int burningMins;\n+\n+\t\tpublic MockedScheduleBuilder(int scheduleNr) {\n+\t\t\tthis.scheduleNr = scheduleNr;\n+\t\t}\n+\n+\t\tpublic MockedScheduleBuilder setRelayNr(int relayNr) {\n+\t\t\tthis.relayNr = relayNr;\n+\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic MockedScheduleBuilder setDayInt(int dayInt) {\n+\t\t\tthis.dayInt = dayInt;\n+\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic MockedScheduleBuilder setFixedTimeInt(int fixedTimeInt) {\n+\t\t\tthis.fixedTimeInt = fixedTimeInt;\n+\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic MockedScheduleBuilder setFixedTimeOn(int fixedTimeOn) {\n+\t\t\tthis.fixedTimeOn = fixedTimeOn;\n+\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic MockedScheduleBuilder setFixedTimeOff(int fixedTimeOff) {\n+\t\t\tthis.fixedTimeOff = fixedTimeOff;\n+\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic MockedScheduleBuilder setTimeOn(LocalTime timeOn) {\n+\t\t\tthis.timeOn = timeOn;\n+\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic MockedScheduleBuilder setTimeOff(LocalTime timeOff) {\n+\t\t\tthis.timeOff = timeOff;\n+\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic MockedScheduleBuilder setBurningMins(int burningMins) {\n+\t\t\tthis.burningMins = burningMins;\n+\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Schedule buildSchedule() {\n+\t\t\tSchedule schedule = new Schedule(this.scheduleNr);\n+\t\t\tschedule.relayNr = this.relayNr;\n+\t\t\tschedule.dayInt = this.dayInt;\n+\n+\t\t\tif (this.fixedTimeOn < 0 || this.fixedTimeOff < 0) {\n+\t\t\t\tschedule.timeOnTypeInt = this.fixedTimeInt;\n+\t\t\t\tschedule.timeOffTypeInt = this.fixedTimeInt;\n+\t\t\t} else {\n+\t\t\t\tschedule.timeOnTypeInt = this.fixedTimeOn;\n+\t\t\t\tschedule.timeOffTypeInt = this.fixedTimeOff;\n+\t\t\t}\n+\n+\t\t\tschedule.timeOn = this.timeOn;\n+\t\t\tschedule.timeOff = this.timeOff;\n+\t\t\tschedule.burningMinsOn = this.burningMins;\n+\n+\t\t\treturn schedule;\n+\n+\t\t}\n+\t}\n+\n+\tprivate static final Logger logger = LoggerFactory.getLogger(SwitchingMomentCalculatorTest.class);\n+\n+\t// Initializing test Device\n+\tDevice device = new Device();\n+\n+\t@Test\n+\tpublic void checkMockRelay() {\n+\t\t// Mock Relay test\n+\t\tint relayNr = 1;\n+\n+\t\tRelay relay = this.getMockRelay(relayNr - 1, null);\n+\t\tassertEquals(relay.getIndexNumber(), 1);\n+\t}\n+\n+\t@Test\n+\tpublic void checkMockSchedule() {\n+\t\t// Mock Schedule test\n+\t\tint scheduleNr = 1;\n+\t\tint relayNr = 1;\n+\t\t// Trigger day(s), see Enum in GXF LF Energy documentation\n+\t\t// 0 = Every day\n+\t\tint dayInt = 0;\n+\t\t// General time type for both on and off times\n+\t\t// 0 = fixed time, 1 = light sensor, 2 = astronomical time\n+\t\t// -1 = disabled action\n+\t\tint fixedTimeInt = 0;\n+\t\t// Optional: Specific time type for on time (-1 = not used)\n+\t\tint fixedTimeOn = -1;\n+\t\t// Optional: Specific time type for off time (-1 = not used)\n+\t\tint fixedTimeOff = -1;\n+\t\tLocalTime timeOn = LocalTime.of(12, 00);\n+\t\tLocalTime timeOff = LocalTime.of(13, 00);\n+\t\tint burningMinutes = 30;\n+\n+\t\tSchedule schedule = new MockedScheduleBuilder(scheduleNr - 1).setRelayNr(relayNr).setDayInt(dayInt)\n+\t\t\t\t.setFixedTimeInt(fixedTimeInt).setFixedTimeOn(fixedTimeOn).setFixedTimeOff(fixedTimeOff)\n+\t\t\t\t.setTimeOn(timeOn).setTimeOff(timeOff).setBurningMins(burningMinutes).buildSchedule();\n+\n+\t\t// Schedule schedule = this.getMockSchedule(scheduleNr - 1, relayNr, dayInt,\n+\t\t// fixedTimeInt, fixedTimeOn,\n+\t\t// fixedTimeOff, timeOn, timeOff, burningMinutes);\n+\n+\t\tassertEquals(scheduleNr, schedule.getIndexNumber());\n+\t\tassertEquals(relayNr, schedule.getRelayNr());\n+\t\tassertEquals(fixedTimeInt, schedule.getTimeOnTypeInt());\n+\t\tassertEquals(fixedTimeInt, schedule.getTimeOffTypeInt());\n+\t\tassertEquals(timeOn, schedule.getTimeOn());\n+\t\tassertEquals(timeOff, schedule.getTimeOff());\n+\t\tassertEquals(burningMinutes, schedule.getBurningMinsOn());\n+\n+\t}\n+\n+\t@Test\n+\tpublic void calculateEveryDaySwitchingMoments() {\n+\n+\t\tint scheduleNr = 1;\n+\t\tint relayNr = 1;\n+\t\t// Trigger day(s), see Enum in GXF LF Energy documentation\n+\t\t// 0 = Every day\n+\t\tint dayInt = 0;\n+\t\t// General time type for both on and off times\n+\t\tint fixedTimeInt = 0;\n+\t\t// Optional: Specific time type for on time\n+\t\t// -1 = using general time type\n+\t\tint fixedTimeOn = -1;\n+\t\t// Optional: Specific time type for off time\n+\t\t// -1 = using general time type\n+\t\tint fixedTimeOff = -1;\n+\t\tLocalTime timeOn = LocalTime.of(12, 00);\n+\t\tLocalTime timeOff = LocalTime.of(13, 00);\n+\t\tint burningMinutes = 30;\n+\t\t// Optional: Custom schedule\n+\t\tSchedule customSchedule = this.getMockSchedule(scheduleNr - 1, relayNr, dayInt, fixedTimeInt, fixedTimeOn,\n+\t\t\t\tfixedTimeOff, timeOn, timeOff, burningMinutes);\n+\t\tboolean useCustomSchedule = false;\n+\n+\t\t// Initializing mock relay\n+\t\tif (!useCustomSchedule) {\n+\t\t\tSchedule schedule = this.getMockLunchTimeSchedule(scheduleNr);\n+\t\t\tRelay relay = this.getMockRelay(relayNr, schedule);\n+\t\t\tRelay[] relays = new Relay[1];\n+\t\t\trelays[0] = relay;\n+\t\t\tthis.device.setRelays(relays);\n+\t\t} else {\n+\t\t\tRelay relay = this.getMockRelay(relayNr, customSchedule);\n+\t\t\tRelay[] relays = new Relay[1];\n+\t\t\trelays[0] = relay;\n+\t\t\tthis.device.setRelays(relays);\n+\t\t}\n+\n+\t\t// Calculating switching moment\n+\n+\t\tSwitchingMomentCalculator calculator = new SwitchingMomentCalculator();\n+\t\tList<SwitchingMoment> switchingMoments = calculator.calculateSwitchingMoments(this.device);\n+\n+\t\t// Tests\n+\n+\t\tSwitchingMoment actualSwitchingMomentOn = switchingMoments.get(0);\n+\t\tSwitchingMoment actualSwitchingMomentOff = switchingMoments.get(2);\n+\t\tSwitchingMoment actualSwitchingMomentNextDayOn = switchingMoments.get(1);\n+\t\tSwitchingMoment actualSwitchingMomentNextDayOff = switchingMoments.get(3);\n+\n+\t\tLocalDateTime expectedLunchTime = LocalDateTime.now().truncatedTo(ChronoUnit.HOURS).withHour(12);\n+\t\tassertEquals(expectedLunchTime, actualSwitchingMomentOn.getTriggerTime());\n+\t\tassertTrue(actualSwitchingMomentOn.isTriggerAction());\n+\n+\t\tLocalDateTime expectedAfterLunchTime = LocalDateTime.now().truncatedTo(ChronoUnit.HOURS).withHour(13);\n+\t\tassertEquals(expectedAfterLunchTime, actualSwitchingMomentOff.getTriggerTime());\n+\t\tassertFalse(actualSwitchingMomentOff.isTriggerAction());\n+\n+\t\tLocalDateTime expectedNextLunchTime = LocalDateTime.now().plusDays(1).truncatedTo(ChronoUnit.HOURS).withHour(12);\n+\t\tassertEquals(expectedNextLunchTime, actualSwitchingMomentNextDayOn.getTriggerTime());\n+\t\tassertTrue(actualSwitchingMomentOn.isTriggerAction());\n+\n+\t\tLocalDateTime expectedNextAfterLunchTime = LocalDateTime.now().plusDays(1).truncatedTo(ChronoUnit.HOURS).withHour(13);\n+\t\tassertEquals(expectedNextAfterLunchTime, actualSwitchingMomentNextDayOff.getTriggerTime());\n+\t\tassertFalse(actualSwitchingMomentOff.isTriggerAction());\n+\n+\t}\n+\n+\tpublic Relay getMockRelay(int relayNr, Schedule customSchedule) {\n+\t\tRelay relay = new Relay(relayNr);\n+\n+\t\tSchedule[] schedules = new Schedule[1];\n+\n+\t\t// Making mock fixed time schedule.\n+\n+\t\tif (customSchedule != null) {\n+\t\t\t// Default mock schedule:\n+\t\t\t// On time: 12 PM\n+\t\t\t// Off time: 1 PM\n+\t\t\t// Burning Minutes: 30\n+\t\t\tSchedule schedule = this.getMockLunchTimeSchedule(1);\n+\t\t\tschedules[0] = schedule;\n+\t\t}\n+\n+\t\trelay.setSchedules(schedules);\n+\n+\t\treturn relay;\n+\t}\n+\n+\tpublic Schedule getMockLunchTimeSchedule(int scheduleNr) {\n+\n+\t\tSchedule schedule = new Schedule(scheduleNr);\n+\n+\t\tint relayNr = 1;\n+\t\t// Trigger day(s), see Enum in GXF LF Energy documentation\n+\t\t// 0 = Every day\n+\t\tint dayInt = 0;\n+\t\t// General time type for both on and off times\n+\t\t// 0 = fixed time, 1 = light sensor, 2 = astronomical time\n+\t\tint fixedTimeInt = 0;\n+\t\t// Optional: Specific time type for on time\n+\t\t// -1 = using general time type\n+\t\tint fixedTimeOn = -1;\n+\t\t// Optional: Specific time type for off time\n+\t\t// -1 = using general time type\n+\t\tint fixedTimeOff = -1;\n+\t\tLocalTime timeOn = LocalTime.of(12, 00);\n+\t\tLocalTime timeOff = LocalTime.of(13, 00);\n+\t\tint burningMinutes = 30;\n+\n+\t\tschedule.setRelayNr(relayNr);\n+\t\tschedule.setDayInt(dayInt);\n+\t\tschedule.setTimeOn(timeOn);\n+\t\tschedule.setTimeOff(timeOff);\n+\t\tif (fixedTimeOn < 0 || fixedTimeOff < 0) {\n+\t\t\tschedule.setTimeOnTypeInt(fixedTimeInt);\n+\t\t\tschedule.setTimeOffTypeInt(fixedTimeInt);\n+\t\t} else {\n+\t\t\tschedule.setTimeOnTypeInt(fixedTimeOn);\n+\t\t\tschedule.setTimeOffTypeInt(fixedTimeOff);\n+\t\t}\n+\t\tschedule.setBurningMinsOn(burningMinutes);\n+\t\tschedule.setEnabled(true);\n+\n+\t\treturn schedule;\n+\t}\n+\n+\t// TODO: Converting to Builder design pattern\n+\tpublic Schedule getMockSchedule(int scheduleNr, int relayNr, int dayInt, int fixedTimeInt, int fixedTimeOn,\n+\t\t\tint fixedTimeOff, LocalTime timeOn, LocalTime timeOff, int burningMinutes) {\n+\t\tSchedule schedule = new Schedule(scheduleNr);\n+\n+\t\tschedule.setRelayNr(relayNr);\n+\t\t// Day 0: Everyday of the week\n+\t\tschedule.setDayInt(dayInt);\n+\t\tschedule.setTimeOn(timeOn);\n+\t\t// Time On Type 0: Fixed time\n+\t\tschedule.setTimeOnTypeInt(0);\n+\t\tschedule.setTimeOff(timeOff);\n+\t\t// Time Off Type 0: Fixed time\n+\t\tschedule.setTimeOffTypeInt(0);\n+\t\tschedule.setBurningMinsOn(burningMinutes);\n+\n+\t\treturn schedule;\n+\t}\n+}"
  }
]
