[
  {
    "sha": "0e4df4df4e36333aeb6a72835be16ad130863042",
    "filename": ".gitignore",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/.gitignore",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/.gitignore",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/.gitignore?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -159,3 +159,4 @@ imgui.ini\n .vscode/\n \n # End of https://www.gitignore.io/api/c++,java,linux,macos,gradle,windows,visualstudiocode\n+.idea"
  },
  {
    "sha": "22e7088ea5961b2b47e7eee2d3e926df1b200364",
    "filename": ".wpilib/wpilib_preferences.json",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/.wpilib/wpilib_preferences.json",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/.wpilib/wpilib_preferences.json",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/.wpilib/wpilib_preferences.json?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -1,6 +1,6 @@\n {\n     \"enableCppIntellisense\": false,\n     \"currentLanguage\": \"java\",\n-    \"projectYear\": \"2020\",\n-    \"teamNumber\": 2078\n+    \"projectYear\": \"2021\",\n+    \"teamNumber\": 2077\n }\n\\ No newline at end of file"
  },
  {
    "sha": "51b4407276f7d186ba2f8e34736946b2b73bbf39",
    "filename": "src/main/java/org/usfirst/frc/team2077/Constants.java",
    "status": "modified",
    "additions": 3,
    "deletions": 2,
    "changes": 5,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/Constants.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/Constants.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/Constants.java?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -27,11 +27,12 @@\n     public final double STARDESTROYER_WHEELBASE = 20.375; // inches\n     public final double STARDESTROYER_TRACK_WIDTH = 22.625; // inches\n     public final double STARDESTROYER_WHEEL_RADIUS = 4.0; // inches\n+    public final double STARDESTROYER_SHOOTER_RADIUS = 2.0;\n     // TODO: move motor RPM limit back up and use acceleration and/or stick scaling to optimize driveability\n-    public final double STARDESTROYER_MOTOR_RPM_LIMIT = 3000; // (82 inches/second)\n+    public final double STARDESTROYER_MOTOR_RPM_LIMIT = 5500; // (82 inches/second)\n     // TODO: use acceleration constants where appropriate throughout other code\n     // TODO: different values for operator drive vs programmed motion vs short nudges, etc?\n-    public final double STARDESTROYER_ACCELERATION_G_LIMIT = .1;\n+    public final double STARDESTROYER_ACCELERATION_G_LIMIT = .5;\n     public final double STARDESTROYER_DECELERATION_G_LIMIT = .25;\n \n     //for autonomous"
  },
  {
    "sha": "1296d40467b7c2c25f17960378924f70bcbe92e7",
    "filename": "src/main/java/org/usfirst/frc/team2077/DriveStation.java",
    "status": "modified",
    "additions": 78,
    "deletions": 3,
    "changes": 81,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/DriveStation.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/DriveStation.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/DriveStation.java?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -6,18 +6,22 @@\n package org.usfirst.frc.team2077;\n \n import edu.wpi.first.wpilibj.Joystick;\n+import edu.wpi.first.wpilibj2.command.Command;\n+import edu.wpi.first.wpilibj2.command.CommandScheduler;\n+import edu.wpi.first.wpilibj2.command.Subsystem;\n import edu.wpi.first.wpilibj2.command.button.JoystickButton;\n import edu.wpi.first.wpilibj.XboxController;\n+import org.usfirst.frc.team2077.commands.*;\n+import org.usfirst.frc.team2077.subsystems.Crosshairs;\n+import edu.wpi.first.wpilibj2.command.button.InternalButton;\n \n-public class DriveStation {\n \n+public class DriveStation {\n     public final Joystick primaryStick_ = new Joystick(0);\n     public final Joystick secondaryStick_ = new Joystick(1);\n     public final Joystick testingStick_ = new Joystick(5);\n     public final Joystick Flight = new Joystick(2);\n \n-\n-    \n     public final JoystickButton primaryTrigger_ = new JoystickButton(primaryStick_, 1); \n     public final JoystickButton primary2_ = new JoystickButton(primaryStick_, 2);\n     public final JoystickButton primary3_ = new JoystickButton(primaryStick_, 3);\n@@ -69,6 +73,77 @@\n     public final JoystickButton testing23_ = new JoystickButton(testingStick_, 23);\n     public final JoystickButton testing24_ = new JoystickButton(testingStick_, 24);\n \n+    //    Default teleop robot drive.\n+    protected Command drive_;\n+    //    Continuous update of target range and direction based on robot motion.\n+    protected Command track_;\n+    //    Operator input of target position relative to robot.\n+    protected Command aim_;\n+    \n+    public DriveStation(Subsystem position_,\n+                        Subsystem target_,\n+                        Crosshairs crosshairs_) {\n+\n+        drive_ = new PrimaryStickDrive3Axis();\n+        aim_ = new AimCrosshairs();\n+        track_ = new TrackTarget();\n+        // range_ = new RangeToCrosshairs(constants_.UPPER_TARGET_HEIGHT - constants_.FISHEYE_CAMERA_HEIGHT);\n+\n+\n+        CommandScheduler.getInstance()\n+                        .setDefaultCommand(position_, drive_);\n+        // Uncomment the following to move rotation to secondary stick.\n+        //CommandScheduler.getInstance().setDefaultCommand(heading_, new SecondaryStickDrive());\n+        CommandScheduler.getInstance()\n+                        .setDefaultCommand(target_, track_);\n+        CommandScheduler.getInstance()\n+                        .setDefaultCommand(crosshairs_, aim_);\n+        // CommandScheduler.getInstance().setDefaultCommand(launcher_, range_);\n+\n+\n+        primaryTrigger_.whileHeld(new RunGrabber(0.6));\n+        // testing1_.whileHeld(new RunGrabber(0.3)); //for flysky controller\n+\n+\n+        secondary2_.whileHeld(new SteerToCrosshairs());\n+        //secondary3_.whenPressed(new RangeToCrosshairs(constants_.UPPER_TARGET_HEIGHT - constants_.DOUBLE_CAMERA_HEIGHT));\n+        secondary4_.whenPressed(new LoadLauncherBack());\n+        secondaryTrigger_.whileHeld(new LoadLauncher());\n+        secondary7_.whenPressed(new LauncherSpinTest(-100));\n+        secondary6_.whenPressed(new LauncherSpinTest(100));\n+        secondary8_.whenPressed(new LauncherSpinTest(-10));\n+        secondary9_.whenPressed(new LauncherSpinTest(10));\n+        secondary10_.whileHeld(new LauncherScrewTest(false));\n+        secondary11_.whileHeld(new LauncherScrewTest(true));\n+\n+        secondary3_.whenPressed(new ToggleLauncher());\n+        //secondaryTrigger_.whileHeld(new ContinousAimToTarget3());\n+\n+\n+        //----------------------------- KEYPAD COMMANDS -----------------------------//\n+        // testing1_.whenPressed(new ColorOperations());\n+        // testing1_.whenPressed(new AutonomousOperations());\n+        // testing2_.whenPressed(new ElevatorOperations());\n+        // testing3_.whileHeld(new ZPlaceHolderSensors());\n+\n+\n+        // // Test code.\n+        // (new JoystickButton(primaryStick_, 3)).whenPressed(new Move(40, 0, -180));\n+        // (new JoystickButton(primaryStick_, 4)).whenPressed(new Move(40, 0, 180));\n+        // (new JoystickButton(primaryStick_, 5)).whenPressed(new Move(20, 0, -90));\n+        // (new JoystickButton(primaryStick_, 6)).whenPressed(new Move(20, 0, 90));\n+\n+        // (new POVButton(primaryStick_, 0)).whenPressed(new Nudge(0, .1));\n+        // (new POVButton(primaryStick_, 90)).whenPressed(new Nudge(90, .15));\n+        // (new POVButton(primaryStick_, 180)).whenPressed(new Nudge(180, .1));\n+        // (new POVButton(primaryStick_, 270)).whenPressed(new Nudge(270, .15));\n+\n+        // (new JoystickButton(primaryStick_, 7)).whenPressed(new Move(12, -12));\n+        // (new JoystickButton(primaryStick_, 8)).whenPressed(new Move(12, 12));\n+        // (new JoystickButton(primaryStick_, 9)).whenPressed(new Move(270));\n+        // (new JoystickButton(primaryStick_, 10)).whenPressed(new Move(-270));\n+    }\n+\n     /**\n      * Condition control axis input to improve driveability.\n      * Each axis has a center dead band in which the output for that axis is always zero."
  },
  {
    "sha": "841b7c9758c331bbcad7e5806bf5ef0f721bfe50",
    "filename": "src/main/java/org/usfirst/frc/team2077/Robot.java",
    "status": "modified",
    "additions": 248,
    "deletions": 371,
    "changes": 619,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/Robot.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/Robot.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/Robot.java?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -8,384 +8,261 @@\n \n package org.usfirst.frc.team2077;\n \n-import org.usfirst.frc.team2077.commands.AutonomousCheck;\n-import org.usfirst.frc.team2077.commands.LauncherSpinTest;\n-import org.usfirst.frc.team2077.commands.LoadLauncher;\n-import org.usfirst.frc.team2077.commands.LoadLauncherBack;\n-import org.usfirst.frc.team2077.commands.Move2;\n-import org.usfirst.frc.team2077.commands.Nudge;\n-import org.usfirst.frc.team2077.commands.PrimaryStickDrive3Axis;\n-import org.usfirst.frc.team2077.commands.RangeToCrosshairs;\n-import org.usfirst.frc.team2077.commands.RunGrabber;\n-import org.usfirst.frc.team2077.commands.SteerToCrosshairs;\n-import org.usfirst.frc.team2077.commands.ToggleLauncher;\n-import org.usfirst.frc.team2077.commands.TrackTarget;\n-import org.usfirst.frc.team2077.commands.AimCrosshairs;\n-import org.usfirst.frc.team2077.commands.EmptyLoader;\n-import org.usfirst.frc.team2077.commands.LauncherScrewTest;\n-import org.usfirst.frc.team2077.drivetrain.DriveChassisIF;\n-import org.usfirst.frc.team2077.drivetrain.DriveModuleIF;\n-import org.usfirst.frc.team2077.drivetrain.MecanumChassis;\n-import org.usfirst.frc.team2077.drivetrain.SparkNeoDriveModule;\n-import org.usfirst.frc.team2077.sensors.AnalogSettings;\n-import org.usfirst.frc.team2077.sensors.AngleSensor;\n-import org.usfirst.frc.team2077.sensors.InfraredSensor;\n-import org.usfirst.frc.team2077.sensors.MicroSwitch;\n-import org.usfirst.frc.team2077.sensors.PotentialSensor;\n-import org.usfirst.frc.team2077.subsystems.Crosshairs;\n-import org.usfirst.frc.team2077.subsystems.Launcher;\n-import org.usfirst.frc.team2077.subsystems.LauncherIF;\n-import org.usfirst.frc.team2077.subsystems.Telemetry;\n-import org.usfirst.frc.team2077.subsystems.TestGrabber;\n-\n import edu.wpi.first.networktables.NetworkTableInstance;\n-import edu.wpi.first.wpilibj.AnalogInput;\n import edu.wpi.first.wpilibj.TimedRobot;\n import edu.wpi.first.wpilibj2.command.Command;\n import edu.wpi.first.wpilibj2.command.CommandScheduler;\n-import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;\n import edu.wpi.first.wpilibj2.command.Subsystem;\n import edu.wpi.first.wpilibj2.command.SubsystemBase;\n-import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n-\n-\n-// AJ- Changes\n-// import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;\n-// AJ- Changes\n-\n-// The default Command template from WPI splits a lot of top level declaration\n-// and initialization into a separate RobotContainer class. The main purpose of\n-// doing so seems to be to make the code less convenient to read :)\n-// In this example such code has been merged back into this file. - RAB\n-\n-// The following header comment from the template file is just plain wrong.\n-// It applies to frc.robot.Main. Probably a cut/paste error as code evolved. - RAB\n-/**\n- * The VM is configured to automatically run this class, and to call the\n- * functions corresponding to each mode, as described in the TimedRobot\n- * documentation. If you change the name of this class or the package after\n- * creating this project, you must also update the build.gradle file in the\n- * project.\n- */\n-public class Robot extends TimedRobot {\n-\n-  // Using a constructed constants object instead of statics.\n-  // Put globally accessible system constants in the Constants class.\n-  // Other code can access them through Robot.robot_.constants_.<FIELD_NAME>.\n-  public Constants constants_ = new Constants();\n-\n-\n-  // Other globally accessible objects...\n-\n-  // Drive station controls.\n-  public DriveStation driveStation_;\n-\n-  // Inter-process data exchange.\n-  public NetworkTableInstance networkTableInstance_ = NetworkTableInstance.getDefault();\n-\n-  // Sensors.\n-  public AngleSensor angleSensor_;\n-  public AnalogSettings analogSettings_;\n-  public PotentialSensor potentialSensor_;\n-  public InfraredSensor infraredSensor_;\n-  public MicroSwitch microSwitch_;\n-\n-  // Drive train, including:\n-  //   Controller/motor/wheel/encoder units for each wheel.\n-  //   Logic for applying robot level functionality to individual wheels.\n-  public DriveChassisIF chassis_;\n-\n-  // Subsystems\n-  //    The position/heading subsystems operate as flags to allow control\n-  //    of chassis rotation to move between commands independently of positioning.\n-  public Subsystem position_;\n-  public Subsystem heading_;\n-  public Subsystem target_;\n-  //    Aiming system for elevating ball launcher and pointing the robot. Displayed on DS video.\n-  public Crosshairs crosshairs_;\n-\n-  //    Ball launcher with ajustable elevation and speed based on range to target.\n-  public LauncherIF launcher_;\n-  public Launcher testLauncher_; // low-level control for testing\n-\n-  \n-  //public TestLauncher tLauncher_; // Bringing back support for the TestLauncher Class though the old instance name\n-\n-  public Telemetry telemetry_;\n-\n-  public TestGrabber tgrabber_;\n-\n-\n-  // Default commands\n-  //    Autonomous selected via drive station dashboard.\n-  protected Command autonomous_;\n-  //    Default teleop robot drive.\n-  protected Command drive_;\n-  //    Continuous update of target range and direction based on robot motion.\n-  protected Command track_;\n-  //    Operator input of target position relative to robot.\n-  protected Command aim_;\n-  //    Continuous update of launcher elevation for target range.\n-  protected Command range_;\n-  //     Keep Launcher aimed on target from crosshairs\n-  protected Command launch_;\n-\n-\n-  public Subsystem testConfig_;//AJ New\n-\n-\n-\n-  // Everything \"global\" hangs off the single instance of Robot,\n-  // either directly or under one of the above public members.\n-  public static Robot robot_ = null;\n-  // This class will be instantiated exactly once, via frc.robot.Main.\n-  // The constructor initializes the globally accessible static instance,\n-  // all other initialization happens in robotInit().\n-  public Robot() {\n-    robot_ = this;\n-  }\n-\n-  /**\n-   * Run once on startup.\n-   */\n-  @Override\n-  public void robotInit() {\n-\n-    // Container for remote control software objects.\n-    driveStation_ = new DriveStation();\n-\n-    // Communications with other processes on the DS.\n-    networkTableInstance_ = NetworkTableInstance.getDefault();\n-\n-    // Sensors.\n-\n-    angleSensor_ = new AngleSensor();\n-\n-    //analogSettings_ = new AnalogSettings(1, 2, 3);\n-\n-    potentialSensor_ = new PotentialSensor();\n-\n-    infraredSensor_ = new InfraredSensor(2, constants_.INFRARED_MAX_LOADED, constants_.INFRARED_MIN_LOADED);\n-    microSwitch_ = new MicroSwitch(2);\n-\n-    //----------------------------- DRIVETRAIN -----------------------------//\n-    DriveModuleIF[] starDestroyerDriveModules = {\n-      new SparkNeoDriveModule(SparkNeoDriveModule.DrivePosition.FRONT_RIGHT),  // northeast (right front)\n-      new SparkNeoDriveModule(SparkNeoDriveModule.DrivePosition.BACK_RIGHT),  // southeast (right rear)\n-      new SparkNeoDriveModule(SparkNeoDriveModule.DrivePosition.BACK_LEFT),  // southwest (left rear)\n-      new SparkNeoDriveModule(SparkNeoDriveModule.DrivePosition.FRONT_LEFT)   // northwest (left front)\n-    };\n-\n-    chassis_ = new MecanumChassis(starDestroyerDriveModules, constants_.STARDESTROYER_WHEELBASE, constants_.STARDESTROYER_TRACK_WIDTH, constants_.STARDESTROYER_WHEEL_RADIUS); \n-    \n-    //----------------------------- SUBSYSTEMS -----------------------------//\n-    //   These dummy subsystems support sepearable command ownership of robot motion and rotation.\n-    position_ = new SubsystemBase() {};\n-    heading_ = new SubsystemBase() {};\n-    target_ = new SubsystemBase() {};\n-\n-    telemetry_ = new Telemetry();\n-        \n-    //   Ball launcher.\n-    launcher_ = new Launcher();\n-    testLauncher_ = launcher_ instanceof Launcher ? (Launcher)launcher_ : null;\n-\n-    //(new ResetTarPos()).initialize();\n-    tgrabber_ = new TestGrabber();\n-\n-    //   Manages an operator-controlled aiming point displayed on DS and used for targeting.    \n-    crosshairs_ = new Crosshairs(); \n-\n-\n-    //----------------------------- INITIAL ROBOT AND TARGET POSITION -----------------------------//\n-    robot_.chassis_.setPosition(-180, 0, 0); // TODO: Initialize from Smart Dashboard\n-    double[] p = robot_.chassis_.getPosition();\n-    robot_.crosshairs_.set(Math.atan2(-p[1], -p[0]), Math.sqrt(p[0]*p[0] + p[1]*p[1]));\n-    \n-    System.out.println(\"CROSSHAIRS:\" + crosshairs_);\n-\n-\n-    \n-    SmartDashboard.putBoolean(\"Run Autonomous\", false);\n-\n-    SmartDashboard.putBoolean(\"Galactic Search\", false);\n-    SmartDashboard.putBoolean(\"A\", false);\n-    SmartDashboard.putBoolean(\"Red\", false);\n-\n-    SmartDashboard.putBoolean(\"Barrel Racing\", false);\n-    SmartDashboard.putBoolean(\"Slalom\", false);\n-    SmartDashboard.putBoolean(\"Bounce\", false);\n-\n-    SmartDashboard.putString(\"errors\", \"value\");\n-\n-    //----------------------------- DEFAULT TELEOP COMMANDS -----------------------------//\n-    //drive_ = new PrimaryStickDrive2Axis();\n-    drive_ = new PrimaryStickDrive3Axis();\n-    aim_ = new AimCrosshairs();\n-    track_ = new TrackTarget();\n-    // range_ = new RangeToCrosshairs(constants_.UPPER_TARGET_HEIGHT - constants_.FISHEYE_CAMERA_HEIGHT);\n-\n-\n-    CommandScheduler.getInstance().setDefaultCommand(position_, drive_);\n-    // Uncomment the following to move rotation to secondary stick.\n-    //CommandScheduler.getInstance().setDefaultCommand(heading_, new SecondaryStickDrive());\n-    CommandScheduler.getInstance().setDefaultCommand(target_, track_);\n-    CommandScheduler.getInstance().setDefaultCommand(crosshairs_, aim_);\n-    // CommandScheduler.getInstance().setDefaultCommand(launcher_, range_);\n-\n-\n-    driveStation_.primaryTrigger_.whileHeld(new RunGrabber(0.3));\n-\n-\n-    driveStation_.secondary2_.whileHeld(new SteerToCrosshairs());\n-    //driveStation_.secondary3_.whenPressed(new RangeToCrosshairs(constants_.UPPER_TARGET_HEIGHT - constants_.DOUBLE_CAMERA_HEIGHT));\n-    //driveStation_.secondary3_.whenPressed(new SetAngleTest());\n-    driveStation_.secondary4_.whenPressed(new LoadLauncherBack());\n-    driveStation_.secondary5_.whileHeld(new LoadLauncher());\n-    driveStation_.secondary6_.whenPressed(new LauncherSpinTest(200));\n-    driveStation_.secondary7_.whenPressed(new LauncherSpinTest(-200));\n-    //driveStation_.secondary8_.whileHeld(new LauncherSpinTest());\n-    driveStation_.secondary8_.whenPressed(new LauncherScrewTest(true));//launcher_.getScrewPosition() - 0.1)));\n-    driveStation_.secondary9_.whenPressed(new LauncherScrewTest(false));\n-    // driveStation_.secondary11_.whileHeld(new LauncherScrewTest(true));\n-    driveStation_.secondary11_.whileHeld(new LauncherScrewTest(false));\n-\n-    // driveStation_.secondaryTrigger_.whileHeld(new LoadLauncher());//HERE\n-    driveStation_.secondaryTrigger_.whenPressed(new ToggleLauncher());\n-    // driveStation_.secondaryTrigger_.whileHeld(new Launch());\n-    // driveStation_.secondaryTrigger_.whileHeld(new EmptyLoader());\n-    //driveStation_.secondaryTrigger_.whileActiveContinuous(new SteerToCrosshairs());\n-    //driveStation_.secondaryTrigger_.whileHeld(new ContinousAimToTarget3());\n+import org.usfirst.frc.team2077.commands.AutonomousCheck;\n+import org.usfirst.frc.team2077.drivetrain.AbstractChassis;\n+import org.usfirst.frc.team2077.drivetrain.DriveChassisIF;\n+import org.usfirst.frc.team2077.drivetrain.MecanumChassis;\n+import org.usfirst.frc.team2077.drivetrain.SparkNeoDriveModule;\n+import org.usfirst.frc.team2077.sensors.*;\n+import org.usfirst.frc.team2077.subsystems.*;\n \n+import static org.usfirst.frc.team2077.drivetrain.SparkNeoDriveModule.DrivePosition.*;\n \n-    //----------------------------- KEYPAD COMMANDS -----------------------------//\n-    // driveStation_.testing1_.whenPressed(new ColorOperations());\n-    // driveStation_.testing1_.whenPressed(new AutonomousOperations());\n-    // driveStation_.testing2_.whenPressed(new ElevatorOperations());\n-    // driveStation_.testing3_.whileHeld(new ZPlaceHolderSensors());\n-\n-\n-    // // Test code.\n-    // (new JoystickButton(driveStation_.primaryStick_, 3)).whenPressed(new Move2(40, 0, -180));\n-    // (new JoystickButton(driveStation_.primaryStick_, 4)).whenPressed(new Move2(40, 0, 180));\n-    // (new JoystickButton(driveStation_.primaryStick_, 5)).whenPressed(new Move2(20, 0, -90));\n-    // (new JoystickButton(driveStation_.primaryStick_, 6)).whenPressed(new Move2(20, 0, 90));\n-\n-    // (new POVButton(driveStation_.primaryStick_, 0)).whenPressed(new Nudge(0, .1));\n-    // (new POVButton(driveStation_.primaryStick_, 90)).whenPressed(new Nudge(90, .15));\n-    // (new POVButton(driveStation_.primaryStick_, 180)).whenPressed(new Nudge(180, .1));\n-    // (new POVButton(driveStation_.primaryStick_, 270)).whenPressed(new Nudge(270, .15));\n-\n-    // (new JoystickButton(driveStation_.primaryStick_, 7)).whenPressed(new Move2(12, -12));\n-    // (new JoystickButton(driveStation_.primaryStick_, 8)).whenPressed(new Move2(12, 12));\n-    // (new JoystickButton(driveStation_.primaryStick_, 9)).whenPressed(new Move2(270));\n-    // (new JoystickButton(driveStation_.primaryStick_, 10)).whenPressed(new Move2(-270));\n-}\n+public class Robot extends TimedRobot {\n \n-  /**\n-   * Called every robot packet (generally about 50x/second) no matter the mode.\n-   * Use this for items like diagnostics that you want run during disabled,\n-   * autonomous, teleoperated and test.\n-   * <p>\n-   * This runs after the mode specific periodic functions, but before\n-   * LiveWindow and SmartDashboard integrated updating.\n-   */\n-  @Override\n-  public void robotPeriodic() {\n-    // Runs the Scheduler.  This is responsible for polling buttons, adding newly-scheduled\n-    // commands, running already-scheduled commands, removing finished or interrupted commands,\n-    // and running subsystem periodic() methods.  This must be called from the robot's periodic\n-    // block in order for anything in the Command-based framework to work.\n-    CommandScheduler.getInstance().run();\n-  }\n-\n-  // The robot and the drive station exchange data packets around 50x/second so long\n-  // as they are connected and the robot program is running (hasn't crashed or exited).\n-  // This packet excahange is what keeps the DS related software objects, i.e. Joysticks,\n-  // in the robot code updated with their position, etc on the the actual DS, and what\n-  // keeps \"Robot Code\" indicator on the DS green.\n-  // \n-  // Each time a DS packet is received, the underlying WPILIB code calls one or more\n-  // xxxPeriodic() methods in this class, first a mode-specific one and then robotPeriodic().\n-  //\n-  // Each time the robot mode (disabled, autonomous, teleop, test) changes the appropriate\n-  // xxxInit() method is called. The robotInit() method is called only once at startup.\n-\n-  /**\n-   * Called once each time the robot enters disabled mode.\n-   * Note that in competition the robot may (or may not?) be\n-   * disabled briefly between autonomous and teleop.\n-   */\n-  @Override\n-  public void disabledInit() {\n-  }\n-\n-  /**\n-   * Called periodically while robot is disabled.\n-   */\n- @Override\n-  public void disabledPeriodic() {\n-  }\n-\n-  /**\n-   * Called once each time the robot enters autonomous mode.\n-   */\n-  @Override\n-  public void autonomousInit() {\n-  \n-    // autonomous_ = new AutonomousOperations();\n-\n-    // if (autonomous_ != null) {\n-    //   autonomous_.schedule();\n-    // }\n-    autonomous_ = new AutonomousCheck();\n-    autonomous_.schedule();\n-  }\n-\n-  /**\n-   * Called periodically during autonomous.\n-   */\n-  @Override\n-  public void autonomousPeriodic() {\n-  }\n-\n-  /**\n-   * Called once each time the robot enters teleop (operator controlled) mode.\n-   */\n-  @Override\n-  public void teleopInit() {\n-\n-    // This makes sure that the autonomous stops running when\n-    // teleop starts running. If you want the autonomous to\n-    // continue until interrupted by another command, remove\n-    // this line or comment it out.\n-    // if (autonomous_ != null) {\n-      // autonomous_.cancel();\n-    // }\n-  }\n-\n-  /**\n-   * Called periodically during teleop.\n-   */\n-  @Override\n-  public void teleopPeriodic() {\n-  }\n-\n-  /**\n-   * Called once each time the robot enters test mode.\n-   */\n-  @Override\n-  public void testInit() {\n-    // Cancels all running commands at the start of test mode.\n-    CommandScheduler.getInstance().cancelAll();\n-\n-  }\n-\n-  /**\n-   * Called periodically during test.\n-   */\n-  @Override\n-  public void testPeriodic() {\n-    \n-  }\n+\t// Everything \"global\" hangs off the single instance of Robot,\n+\t// either directly or under one of the above public members.\n+\tpublic static Robot robot_ = null;\n+\n+\n+\t// Other globally accessible objects...\n+\t// Using a constructed constants object instead of statics.\n+\t// Put globally accessible system constants in the Constants class.\n+\t// Other code can access them through Robot.robot_.constants_.<FIELD_NAME>.\n+\tpublic Constants constants_ = new Constants();\n+\t// Drive station controls.\n+\tpublic DriveStation driveStation_;\n+\t// Inter-process data exchange.\n+\tpublic NetworkTableInstance networkTableInstance_;\n+\t// Sensors.\n+\tpublic AngleSensor angleSensor_;\n+\tpublic AnalogSettings analogSettings_;\n+\tpublic PotentialSensor potentialSensor_;\n+\tpublic InfraredSensor infraredSensor_;\n+\tpublic MicroSwitch microSwitch_;\n+\t// Drive train, including:\n+\t//   Controller/motor/wheel/encoder units for each wheel.\n+\t//   Logic for applying robot level functionality to individual wheels.\n+\tpublic AbstractChassis chassis_;\n+\t// Subsystems\n+\t//    The position/heading subsystems operate as flags to allow control\n+\t//    of chassis rotation to move between commands independently of positioning.\n+\tpublic Subsystem position_;\n+\tpublic Subsystem heading_;\n+\tpublic Subsystem target_;\n+\t//    Aiming system for elevating ball launcher and pointing the robot. Displayed on DS video.\n+\tpublic Crosshairs crosshairs_;\n+\t//    Ball launcher with ajustable elevation and speed based on range to target.\n+\tpublic LauncherIF launcher_;\n+\n+\n+\t//public TestLauncher tLauncher_; // Bringing back support for the TestLauncher Class though the old instance name\n+\tpublic Launcher testLauncher_; // low-level control for testing\n+\tpublic Telemetry telemetry_;\n+\tpublic TestGrabber tgrabber_;\n+\tpublic Subsystem testConfig_;//AJ New\n+\t// Default commands\n+\t//    Autonomous selected via drive station dashboard.\n+\tprotected Command autonomous_;\n+\t//    Default teleop robot drive.\n+\tprotected Command drive_;\n+\t//    Continuous update of target range and direction based on robot motion.\n+\tprotected Command track_;\n+\t//    Operator input of target position relative to robot.\n+\tprotected Command aim_;\n+\t//    Continuous update of launcher elevation for target range.\n+\tprotected Command range_;\n+\t//     Keep Launcher aimed on target from crosshairs\n+\tprotected Command launch_;\n+\n+\t// This class will be instantiated exactly once, via frc.robot.Main.\n+\t// The constructor initializes the globally accessible static instance,\n+\t// all other initialization happens in robotInit().\n+\tpublic Robot() {\n+\t\trobot_ = this;\n+\t}\n+\n+\t/**\n+\t * Run once on startup.\n+\t */\n+\t@Override\n+\tpublic void robotInit() {\n+\t\tnetworkTableInstance_ = NetworkTableInstance.getDefault();\n+\t\tangleSensor_ = new AngleSensor();\n+\t\tpotentialSensor_ = new PotentialSensor();\n+\n+\t\t//analogSettings_ = new AnalogSettings(1, 2, 3);\n+\n+\n+\t\tinfraredSensor_ = new InfraredSensor(2, constants_.INFRARED_MAX_LOADED, constants_.INFRARED_MIN_LOADED);\n+\t\tmicroSwitch_ = new MicroSwitch(2);\n+\n+\n+\t\tsetupDriveTrain();\n+\n+\t\trobot_.chassis_.setPosition(-180, 0, 0); // TODO: Initialize from Smart Dashboard\n+\t\tdouble[] p = robot_.chassis_.getPosition();\n+\t\trobot_.crosshairs_.set(Math.atan2(-p[1], -p[0]), Math.sqrt(p[0] * p[0] + p[1] * p[1]));\n+\n+\t\tSystem.out.println(\"CROSSHAIRS:\" + crosshairs_);\n+\n+\t\tsetupController();\n+\t}\n+\n+\tpublic void setupDriveTrain() {\n+\t\tchassis_ = new MecanumChassis(constants_);\n+\n+\t\t//   These dummy subsystems support separate command ownership of robot motion and rotation.\n+\t\tposition_ = new SubsystemBase() {\n+\t\t};\n+\t\theading_ = new SubsystemBase() {\n+\t\t};\n+\t\ttarget_ = new SubsystemBase() {\n+\t\t};\n+\t\ttelemetry_ = new Telemetry();\n+\n+\t\tlauncher_ = new Launcher();\n+\t\ttestLauncher_ = launcher_ instanceof Launcher ? (Launcher) launcher_ : null;\n+\n+\t\t//(new ResetTarPos()).initialize();\n+\t\ttgrabber_ = new TestGrabber();\n+\n+\t\tcrosshairs_ = new Crosshairs();\n+\t}\n+\n+\tpublic void setupController() {\n+\t\t// Container for remote control software objects.\n+\t\tdriveStation_ = new DriveStation(position_, target_, crosshairs_);\n+\t}\n+\n+\t/**\n+\t * Called every robot packet (generally about 50x/second) no matter the mode.\n+\t * Use this for items like diagnostics that you want run during disabled,\n+\t * autonomous, teleoperated and test.\n+\t * <p>\n+\t * This runs after the mode specific periodic functions, but before\n+\t * LiveWindow and SmartDashboard integrated updating.\n+\t */\n+\t@Override\n+\tpublic void robotPeriodic() {\n+\t\t// Runs the Scheduler.  This is responsible for polling buttons, adding newly-scheduled\n+\t\t// commands, running already-scheduled commands, removing finished or interrupted commands,\n+\t\t// and running subsystem periodic() methods.  This must be called from the robot's periodic\n+\t\t// block in order for anything in the Command-based framework to work.\n+\t\tCommandScheduler.getInstance()\n+\t\t\t\t\t\t.run();\n+\t}\n+\n+\t// The robot and the drive station exchange data packets around 50x/second so long\n+\t// as they are connected and the robot program is running (hasn't crashed or exited).\n+\t// This packet excahange is what keeps the DS related software objects, i.e. Joysticks,\n+\t// in the robot code updated with their position, etc on the the actual DS, and what\n+\t// keeps \"Robot Code\" indicator on the DS green.\n+\t//\n+\t// Each time a DS packet is received, the underlying WPILIB code calls one or more\n+\t// xxxPeriodic() methods in this class, first a mode-specific one and then robotPeriodic().\n+\t//\n+\t// Each time the robot mode (disabled, autonomous, teleop, test) changes the appropriate\n+\t// xxxInit() method is called. The robotInit() method is called only once at startup.\n+\n+\t/**\n+\t * Called once each time the robot enters disabled mode.\n+\t * Note that in competition the robot may (or may not?) be\n+\t * disabled briefly between autonomous and teleop.\n+\t */\n+\t@Override\n+\tpublic void disabledInit() {\n+\t}\n+\n+\t/**\n+\t * Called periodically while robot is disabled.\n+\t */\n+\t@Override\n+\tpublic void disabledPeriodic() {\n+\t}\n+\n+\t/**\n+\t * Called once each time the robot enters autonomous mode.\n+\t */\n+\t@Override\n+\tpublic void autonomousInit() {\n+\n+\t\t// autonomous_ = new AutonomousOperations();\n+\n+\t\t// if (autonomous_ != null) {\n+\t\t//   autonomous_.schedule();\n+\t\t// }\n+\t\tautonomous_ = new AutonomousCheck();\n+\t\tautonomous_.schedule();\n+\t}\n+\n+\t/**\n+\t * Called periodically during autonomous.\n+\t */\n+\t@Override\n+\tpublic void autonomousPeriodic() {\n+\t}\n+\n+\t/**\n+\t * Called once each time the robot enters teleop (operator controlled) mode.\n+\t */\n+\t@Override\n+\tpublic void teleopInit() {\n+\n+\t\t// This makes sure that the autonomous stops running when\n+\t\t// teleop starts running. If you want the autonomous to\n+\t\t// continue until interrupted by another command, remove\n+\t\t// this line or comment it out.\n+\t\t// if (autonomous_ != null) {\n+\t\t// autonomous_.cancel();\n+\t\t// }\n+\t}\n+\n+\tprivate static void printWheelInfo(SparkNeoDriveModule.DrivePosition position) {\n+\t\tSystem.out.printf(\"[%s set RPM: %s][%s reported RPM %s]\",\n+\t\t\t\tposition.name(),\n+\t\t\t\t((SparkNeoDriveModule) robot_.chassis_.driveModule_[position.ordinal()]).getSetPoint(),\n+\t\t\t\tposition.name(),\n+\t\t\t\t((SparkNeoDriveModule) robot_.chassis_.driveModule_[position.ordinal()]).getRPM());\n+\t}\n+\n+\n+\tprivate long debug = 0;\n+\t/**\n+\t * Called periodically during teleop.\n+\t */\n+\t@Override\n+\tpublic void teleopPeriodic() {\n+//\t\tif(++debug % 100 == 0) {\n+//\t\t\tfor(SparkNeoDriveModule.DrivePosition position : SparkNeoDriveModule.DrivePosition.values()) {\n+//\t\t\t\tprintWheelInfo(position);\n+//\t\t\t}\n+//\t\t\tSystem.out.println();\n+//\t\t}\n+\t}\n+\n+\t/**\n+\t * Called once each time the robot enters test mode.\n+\t */\n+\t@Override\n+\tpublic void testInit() {\n+\t\t// Cancels all running commands at the start of test mode.\n+\t\tCommandScheduler.getInstance()\n+\t\t\t\t\t\t.cancelAll();\n+\n+\t}\n+\n+\t/**\n+\t * Called periodically during test.\n+\t */\n+\t@Override\n+\tpublic void testPeriodic() {\n+\n+\t}\n }"
  },
  {
    "sha": "5fa5e798183ec907940d31b272ef53e92900c075",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/AngleLauncher.java",
    "status": "removed",
    "additions": 0,
    "deletions": 28,
    "changes": 28,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/AngleLauncher.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/AngleLauncher.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/AngleLauncher.java?ref=32a20f41af423f2a6afe8487d648bf81d4472d2d",
    "patch": "@@ -1,28 +0,0 @@\n-/*----------------------------------------------------------------------------*/\n-/* Copyright (c) 2020 FRC Team 2077. All Rights Reserved.                     */\n-/* Open Source Software - may be modified and shared by FRC teams.            */\n-/*----------------------------------------------------------------------------*/\n-\n-package org.usfirst.frc.team2077.commands;\n-\n-import edu.wpi.first.wpilibj2.command.CommandBase;\n-\n-import static org.usfirst.frc.team2077.Robot.*;\n-\n-// Don't use if secondary stick is otherwise assigned! Use LauncherScrewTest with buttons.\n-@Deprecated\n-public class AngleLauncher extends CommandBase {\n-  public AngleLauncher() {\n-    addRequirements(robot_.testLauncher_);\n-  }\n-\n-  @Override\n-  public void execute() {\n-    robot_.testLauncher_.setScrewPosition01(-robot_.driveStation_.secondaryStick_.getY());\n-  }\n-\n-  @Override\n-  public boolean isFinished() {\n-    return false;\n-  }\n-}"
  },
  {
    "sha": "1e57363c669f6872f8c893126d1d58814a376df7",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/AngleLauncherDown.java",
    "status": "removed",
    "additions": 0,
    "deletions": 14,
    "changes": 14,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/AngleLauncherDown.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/AngleLauncherDown.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/AngleLauncherDown.java?ref=32a20f41af423f2a6afe8487d648bf81d4472d2d",
    "patch": "@@ -1,14 +0,0 @@\n-/*----------------------------------------------------------------------------*/\n-/* Copyright (c) 2020 FRC Team 2077. All Rights Reserved.                     */\n-/* Open Source Software - may be modified and shared by FRC teams.            */\n-/*----------------------------------------------------------------------------*/\n-\n-package org.usfirst.frc.team2077.commands;\n-\n-// Use LauncherScrewTest(false) directly instead.\n-@Deprecated\n-public class AngleLauncherDown extends LauncherScrewTest {\n-  public AngleLauncherDown() {\n-    super(false);\n-  }\n-}"
  },
  {
    "sha": "96de85e719448867a5b8a2c0394edcfab9f7985e",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/AngleLauncherUp.java",
    "status": "removed",
    "additions": 0,
    "deletions": 14,
    "changes": 14,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/AngleLauncherUp.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/AngleLauncherUp.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/AngleLauncherUp.java?ref=32a20f41af423f2a6afe8487d648bf81d4472d2d",
    "patch": "@@ -1,14 +0,0 @@\n-/*----------------------------------------------------------------------------*/\n-/* Copyright (c) 2020 FRC Team 2077. All Rights Reserved.                     */\n-/* Open Source Software - may be modified and shared by FRC teams.            */\n-/*----------------------------------------------------------------------------*/\n-\n-package org.usfirst.frc.team2077.commands;\n-\n-// Use LauncherScrewTest(true) directly instead.\n-@Deprecated\n-public class AngleLauncherUp extends LauncherScrewTest {\n-  public AngleLauncherUp() {\n-    super(true);\n-  }\n-}"
  },
  {
    "sha": "db022d25ca1791bca8e23cce3dc0c3cb6012e4f7",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/AutoNavRoutes.java",
    "status": "modified",
    "additions": 181,
    "deletions": 123,
    "changes": 304,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/commands/AutoNavRoutes.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/commands/AutoNavRoutes.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/AutoNavRoutes.java?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -1,171 +1,229 @@\n package org.usfirst.frc.team2077.commands;\n \n import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;\n-import edu.wpi.first.wpilibj2.command.Subsystem;\n-import org.usfirst.frc.team2077.commands.Move2;\n-\n-import edu.wpi.first.networktables.NetworkTableEntry;\n-import edu.wpi.first.networktables.NetworkTableInstance;\n-// import static org.usfirst.frc.team2077.Robot.*;\n-import edu.wpi.first.wpilibj2.command.CommandBase;\n-import edu.wpi.first.wpilibj2.command.SubsystemBase;\n-\n-import org.usfirst.frc.team2077.subsystems.Launcher;//NEW\n \n public class AutoNavRoutes extends SequentialCommandGroup {\n-    ///---Mapping---///\n-    final private static double NORTH_MULTIPLIER = 1.0;\n-    final private static double EAST_MULTIPLIER = 1.0;\n-    final private static double ROTATION_MULTIPLIER = 1.0;\n+\t///---Mapping---///\n+\tfinal private static double NORTH_MULTIPLIER = 1.0;\n+\tfinal private static double EAST_MULTIPLIER = 1.0;\n+\tfinal private static double ROTATION_MULTIPLIER = 1.0;\n ///---Mapping---///\n \n //TODO: Calabrate\n \n-//Callabration values needed.\n-private static double m3N(double north_){//move3N\n-    return north_*NORTH_MULTIPLIER;\n-}\n-private static double m3E(double east_){\n-    return east_*EAST_MULTIPLIER;\n-}\n-private static double m3R(double rotation_){\n-    return rotation_*ROTATION_MULTIPLIER;\n-}\n+\tpublic AutoNavRoutes(AutoNavRoute path) {\n+\t\tswitch (path) {\n+\t\t\tcase BARREL_RACE:\n+\t\t\t\tbarrelRace().schedule();\n+\t\t\t\tbreak;\n+\t\t\tcase SLALOM:\n+\t\t\t\tslalomPath().schedule();\n+\t\t\t\tbreak;\n+\t\t\tcase BOUNCE:\n+\t\t\t\tbouncePath().schedule();\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tSystem.out.println(\"\\n   [WARNING]: Else reached for AutoNavRoutes - '26893223421231'\\n\");//Random string of numbers, so it can be searched in the code\n+\t\t}\n+\t\t// if(pathNumber_ == 0){//barrelRace\n+\t\t//         barrelRace().schedule();\n+\t\t// }else if(pathNumber_ == 1){//slalomPath\n+\t\t//         slalomPath().schedule();\n+\t\t// }else if(pathNumber_ == 2){//bouncePath\n+\t\t//         bouncePath().schedule();\n+\t\t// }else{\n+\t\t//     System.out.println(\"\\n   [WARNING]: Else reached for AutoNavRoutes - '26893223421231'\\n\");//Random string of numbers, so it can be searched in the code\n+\t\t// }\n+\t}\n+\n+\t//Callabration values needed.\n+\tprivate static double m3N(double north_) {//move3N\n+\t\treturn north_ * NORTH_MULTIPLIER;\n+\t}\n+\n+\tprivate static double m3E(double east_) {\n+\t\treturn east_ * EAST_MULTIPLIER;\n+\t}\n //Callabration values needed.\n \n-    private static SequentialCommandGroup barrelRace() {\n+\tprivate static double m3R(double rotation_) {\n+\t\treturn rotation_ * ROTATION_MULTIPLIER;\n+\t}\n+    private static SequentialCommandGroup barrelRaceOrig() {\n         double _unit = 21.5;\n         return (new SequentialCommandGroup(\n-            // new Move2(m3N(0.0),m3E(0.0)), //North, East, Rotation\n-            new Move2(m3N(16.5+90.0),m3E(0.0)),\n-            new Move2(m3N(_unit),m3E(_unit)),\n-            new Move2(m3N(-_unit),m3E(_unit)),\n-            new Move2(m3N(-_unit),m3E(_unit)),\n-            new Move2(m3N(_unit),m3E(-_unit)),\n-            new Move2(m3R(-29.05)),\n-            new Move2(m3N(102.956),m3E(0.0)),\n-            new Move2(m3N(0.0),m3E(-_unit)),\n-            new Move2(m3N(-_unit),m3E(0.0)),\n-            new Move2(m3N(94.22),m3E(_unit)),\n-\n-            new Move2(m3N(_unit),m3E(_unit)),\n-            new Move2(m3N(_unit),m3E(-_unit)),\n-            new Move2(m3N(0.0),m3E(_unit)),\n-\n-            new Move2(m3N(300.0),m3E(300.0)) //North, East, Rotation\n+            // new Move(m3N(0.0),m3E(0.0)), //North, East, Rotation\n+            new Move(m3N(16.5+90.0),m3E(0.0)),\n+            new Move(m3N(_unit),m3E(_unit)),\n+            new Move(m3N(-_unit),m3E(_unit)),\n+            new Move(m3N(-_unit),m3E(_unit)),\n+            new Move(m3N(_unit),m3E(-_unit)),\n+            new Move(m3R(-29.05)),\n+            new Move(m3N(102.956),m3E(0.0)),\n+            new Move(m3N(0.0),m3E(-_unit)),\n+            new Move(m3N(-_unit),m3E(0.0)),\n+            new Move(m3N(94.22),m3E(_unit)),\n+\n+            new Move(m3N(_unit),m3E(_unit)),\n+            new Move(m3N(_unit),m3E(-_unit)),\n+            new Move(m3N(0.0),m3E(_unit)),\n+\n+            new Move(m3N(300.0),m3E(300.0)) //North, East, Rotation\n         // )).schedule();\n             )\n         );\n     }\n \n+    private static SequentialCommandGroup barrelRace() {\n+        return (new SequentialCommandGroup(\n+            new Move(m3N(135.0),m3E(0.0)),\n+\n+            new Move(m3N(0.0),m3E(53.0)),\n+            new Move(m3N(-50.0),m3E(0.0)),\n+            new Move(m3N(0.0),m3E(-50.0)),//Gets out of first hoop\n+            // new Move(m3N(0.0),m3E(0.0),m3R(-0.25)),\n+            // new Move(m3N(0.0),m3E(0.0),m3R(-0.125)),//\n+\n+            // new Move(m3N(0.0),m3E(0.0),m3R(-5.0)),\n+            // new Move(m3N(0.0),m3E(0.0),m3R(5.0)),\n+                // new Move(-0.15)\n+                // new Move(-1.0),\n+                // new Move(-0.09),\n+            // new Move(m3R(5.0)),\n+            new Move(m3N(147.0),m3E(0.0)),\n+\n+            new Move(m3N(0.0),m3E(-63.0)),\n+            new Move(m3N(-55.0),m3E(0.0)),\n+            new Move(m3N(0.0),m3E(127)),\n+\n+            // new Move(m3N(90.0),m3E(135.0)),\n+            new Move(m3N(105.0),m3E(0.0)),//\n+            // new Move(m3N(70.0),m3E(0.0)),//\n+            // new Move(m3N(0.0),m3E(80.0)),\n+            // new Move(m3N(100.0),m3E(58.0)),\n+            // new Move(m3N(10.0),m3E(0.0)),\n+            new Move(m3N(0.0),m3E(-47.0)),\n+            new Move(1),\n+            new Move(m3N(-290.0),m3E(0.0))\n+\n+\n+            // new Move(m3N(0.01),m3E(0.01))\n+            // new Move(m3N(0.0),m3E(300.0))\n+            // )).schedule();\n+            )\n+        );\n+    }\n+\n+\n     private static SequentialCommandGroup slalomPath() {\n+        ///The file in \n+        ///C:\\Users\\robokm\\Desktop\\Local2020\\2020\\_StarDestroyer\\STARDESTROYER_1.8_(03-5-21)-Before\n+        ///contains the last used optimised code for the slalom path.\n+\n         //Robot will start with the center 16.5in behind the ende as close to the finish zone as posssalbe\n         // return (new SequentialCommandGroup(\n-        //     new Move2(m3N(33),m3E(0)),\n-        //     new Move2(m3N(60),m3E(-(22+0+22))),\n-        //     new Move2(m3N(120),m3E(0.0)),\n-        //     new Move2(m3N(60),m3E(22+16+22)),\n-        //     new Move2(m3N((22+16+22)),m3E(-22+16+22)),\n-        //     new Move2(m3N(-(22+16+22)),m3E(-22+16+22)),\n-        //     new Move2(m3N(-(22+16+22)),m3E(-22+16+22)),\n-        //     new Move2(m3N(-120),m3E(0.0)),\n-        //     new Move2(m3N(-60),m3E(-(22+0+22))),\n-        //     new Move2(m3N(-33),m3E(0))\n+        //     new Move(m3N(33),m3E(0)),\n+        //     new Move(m3N(60),m3E(-(22+0+22))),\n+        //     new Move(m3N(120),m3E(0.0)),\n+        //     new Move(m3N(60),m3E(22+16+22)),\n+        //     new Move(m3N((22+16+22)),m3E(-22+16+22)),\n+        //     new Move(m3N(-(22+16+22)),m3E(-22+16+22)),\n+        //     new Move(m3N(-(22+16+22)),m3E(-22+16+22)),\n+        //     new Move(m3N(-120),m3E(0.0)),\n+        //     new Move(m3N(-60),m3E(-(22+0+22))),\n+        //     new Move(m3N(-33),m3E(0))\n         //     // )).schedule();\n         //     )\n         // );\n         return (new SequentialCommandGroup(\n-            new Move2(m3N(33.5),m3E(0)),\n-            new Move2(m3N(0),m3E(-(48))),\n-            // new Move2(m3N(60),m3E(0)),//\n-            // new Move2(m3N(120),m3E(0.0)),\n-            // new Move2(m3N(60),m3E(0)),\n-            // new Move2(m3N(0),m3E(22+16+22)),//\n-            new Move2(m3N(155),m3E(0)),\n+            new Move(m3N(33.5),m3E(0)),\n+            new Move(m3N(0),m3E(-(48))),\n+            // new Move(m3N(60),m3E(0)),//\n+            // new Move(m3N(120),m3E(0.0)),\n+            // new Move(m3N(60),m3E(0)),\n+            // new Move(m3N(0),m3E(22+16+22)),//\n+            new Move(m3N(155),m3E(0)),\n \n-            new Move2(m3N(0),m3E(70)),//\n+            new Move(m3N(0),m3E(70)),//\n \n-            new Move2(m3N(40),m3E(0)),\n-            new Move2(m3N(0),m3E(-50)),\n-            new Move2(m3N(-50),m3E(0)),\n-            new Move2(m3N(0),m3E(70)),\n+            new Move(m3N(40),m3E(0)),\n+            new Move(m3N(0),m3E(-50)),\n+            new Move(m3N(-50),m3E(0)),\n+            new Move(m3N(0),m3E(70)),\n \n-            new Move2(m3N(-151),m3E(0)),\n+            new Move(m3N(-151),m3E(0)),\n \n-            new Move2(m3N(0),m3E(-(69))),\n-            new Move2(m3N(-41),m3E(0))\n+            new Move(m3N(0),m3E(-(69))),\n+            new Move(m3N(-41),m3E(0))\n             \n-            // new Move2(m3N((22+16+22)),m3E(-22+16+22)),\n-            // new Move2(m3N(-(22+16+22)),m3E(-22+16+22)),\n-            // new Move2(m3N(-(22+16+22)),m3E(-22+16+22)),\n-\n-            // new Move2(m3N(-120),m3E(0.0)),\n-            // new Move2(m3N(0),m3E(-(22+0+22))),\n-            // new Move2(m3N(-60),m3E(0)),//\n-            // new Move2(m3N(-33),m3E(0))\n+            // new Move(m3N((22+16+22)),m3E(-22+16+22)),\n+            // new Move(m3N(-(22+16+22)),m3E(-22+16+22)),\n+            // new Move(m3N(-(22+16+22)),m3E(-22+16+22)),\n+\n+            // new Move(m3N(-120),m3E(0.0)),\n+            // new Move(m3N(0),m3E(-(22+0+22))),\n+            // new Move(m3N(-60),m3E(0)),//\n+            // new Move(m3N(-33),m3E(0))\n             // )).schedule();\n             )\n         );\n     }\n   \n     private static SequentialCommandGroup bouncePath() {\n+        boolean i = false;\n+        if(i){\n         return (new SequentialCommandGroup(\n-            new Move2(m3N(40.0),m3E(0.0)),//center is 20 inches out\n-            new Move2(m3N(10),m3E(-35)),//Hits first star\n-            new Move2(m3N(30),m3E(-115.0)),//25 past 60 mark verticaly\n-            new Move2(m3N(30.0),m3E(0.0)),\n-            new Move2(m3N(15.0),m3E(0.0)),\n-            new Move2(m3N(15),m3E(-115.0)),//Hits the second star\n-            new Move2(m3N(15),m3E(115.0)),\n-            new Move2(m3N(30.0),m3E(0.0)),\n-            new Move2(m3N(15),m3E(-115.0)),//Hits the third star\n-            new Move2(m3N(10),m3E(35)),//Hits first star\n-            new Move2(m3N(40.0),m3E(0.0))//center is ~20 inches out\n-            // new Move2(m3N(0),m3E(0))\n+            new Move(m3N(40.0),m3E(0.0)),//center is 20 inches out\n+            new Move(m3N(10),m3E(-35)),//Hits first star\n+            new Move(m3N(30),m3E(-115.0)),//25 past 60 mark verticaly\n+            new Move(m3N(30.0),m3E(0.0)),\n+            new Move(m3N(15.0),m3E(0.0)),\n+            new Move(m3N(15),m3E(-115.0)),//Hits the second star\n+            new Move(m3N(15),m3E(115.0)),\n+            new Move(m3N(30.0),m3E(0.0)),\n+            new Move(m3N(15),m3E(-115.0)),//Hits the third star\n+            new Move(m3N(10),m3E(15)),//Hits first star\n+            new Move(m3N(40.0),m3E(0.0))//center is ~20 inches out\n+            // new Move(m3N(0),m3E(0))\n             // )).schedule();\n             )\n         );\n-        }\n-\n+        }else{\n+        return (new SequentialCommandGroup(\n+            new Move(m3N(55.0),m3E(0.0)),\n+            new Move(m3N(0.0),m3E(-55.0)),//Hits first cone\n+            new Move(m3N(0.0),m3E(59.0)),//Out by D3\n+            new Move(m3N(27.0),m3E(0.0)),\n+            new Move(m3N(0.0),m3E(54.0)),//Below D5\n+            new Move(m3N(55.0),m3E(0.0)),\n+            new Move(m3N(0.0),m3E(-107.0)),//Hits the second spot\n+            new Move(m3N(0.0),m3E(108.0)),\n+            new Move(m3N(80.0),m3E(0.0)),//Second fill left moveup\n+            new Move(m3N(0.0),m3E(-108.0)),//Should hit thrid location\n+            new Move(m3N(0.0),m3E(63.0)),//Move to in frount of the finish zone\n+            new Move(m3N(36.0),m3E(0.0))\n+\n+\n+            // new Move(m3N(0.001),m3E(0.001))\n+            )\n+        );\n \n-    public enum AutoNavRoute {\n-        BARREL_RACE,\n-        SLALOM,\n-        BOUNCE\n+        }\n     }\n \n-    public AutoNavRoutes(AutoNavRoute path) {\n-        switch (path) {\n-            case BARREL_RACE:\n-                barrelRace().schedule();\n-                break;\n-            case SLALOM:\n-                slalomPath().schedule();\n-                break;\n-            case BOUNCE:\n-                bouncePath().schedule();\n-                break;\n-            default:\n-                System.out.println(\"\\n   [WARNING]: Else reached for AutoNavRoutes - '26893223421231'\\n\");//Random string of numbers, so it can be searched in the code\n-        }   \n-        // if(pathNumber_ == 0){//barrelRace\n-        //         barrelRace().schedule();\n-        // }else if(pathNumber_ == 1){//slalomPath\n-        //         slalomPath().schedule();\n-        // }else if(pathNumber_ == 2){//bouncePath\n-        //         bouncePath().schedule();\n-        // }else{\n-        //     System.out.println(\"\\n   [WARNING]: Else reached for AutoNavRoutes - '26893223421231'\\n\");//Random string of numbers, so it can be searched in the code\n-        // }\n-    }\n+\t@Override\n+\tpublic void execute() {\n+\t}\n \n-    // @Override\n-    // public void initialize() {\n+\t// @Override\n+\t// public void initialize() {\n \n-    // }\n+\t// }\n \n-    @Override\n-    public void execute() {\n-    }\n+\tpublic enum AutoNavRoute {\n+\t\tBARREL_RACE,\n+\t\tSLALOM,\n+\t\tBOUNCE\n+\t}\n \n }\n\\ No newline at end of file"
  },
  {
    "sha": "6fb391fb66ee0279b511491b12081b10979d99ab",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/AutonomousCheck.java",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/commands/AutonomousCheck.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/commands/AutonomousCheck.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/AutonomousCheck.java?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -16,9 +16,9 @@\n     private boolean galacticSearch;\n     private boolean a;\n     private boolean red;\n-    private boolean barrelRacing;\n-    private boolean slalom;\n-    private boolean bounce;\n+    private boolean barrelRacing = false;\n+    private boolean slalom = false;\n+    private boolean bounce = false;\n \n \n "
  },
  {
    "sha": "d783541372b3b90c292f804fe30a2860e3800953",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/ColorOperations.java.deprecated",
    "status": "removed",
    "additions": 0,
    "deletions": 246,
    "changes": 246,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/ColorOperations.java.deprecated",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/ColorOperations.java.deprecated",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/ColorOperations.java.deprecated?ref=32a20f41af423f2a6afe8487d648bf81d4472d2d",
    "patch": "@@ -1,246 +0,0 @@\n-package org.usfirst.frc.team2077.commands;\n-\n-import edu.wpi.first.wpilibj2.command.CommandBase;\n-import edu.wpi.first.wpilibj2.command.CommandScheduler;\n-\n-import static org.usfirst.frc.team2077.Robot.*;\n-import edu.wpi.first.wpilibj.I2C;\n-\n-// import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n-// import edu.wpi.first.wpilibj.util.Color;\n-import com.revrobotics.ColorSensorV3;\n-\n-import edu.wpi.first.wpilibj.Talon;//For the motor control\n-\n-import edu.wpi.first.wpilibj.DriverStation;\n-\n-\n-// import edu.wpi.first.wpilibj.DriverStation;\n-// import edu.wpi.first.wpilibj.TimedRobot;             //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-// public class ColorWithMoveWheel extends TimedRobot{  //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-\n-public class ColorOperations extends CommandBase{\n-    private final I2C.Port i2cPort = I2C.Port.kOnboard;\n-    private final ColorSensorV3 m_colorSensor = new ColorSensorV3(i2cPort);\n-    private final int[] wheelHue = {0, 90, 120, 180, 360}; // need empirical tweaking?\n-    // private final String[] wheelColor = {\"red\", \"yellow\", \"green\", \"blue\", \"red\"};\n-\n-    String gameData; //Came with examplecode \n-    int colorNum; //The stored number from the color given by the Game Data VI (nothing/error = 0, Blue = 1, Green =2, Red = 3, Yellow = 4)\n-    int currentColorNum; //The value the sensor detects the robot is currently on\n-    // static double distancePerColor = 1;\n-    // static int defaultTime = 1;//This is the ammount of time it takes per color it needs to pass\n-    // int setPlaceholdeForMotor = 0; //This is a placeholder for where the direct run motor will be\n-    // Talon robot_.colorTalonMotor_ = new Talon(9);//Initializes a Motor on PWM #\n-\n-    int numberOfSectorsPassed = 0;\n-    int neededNumberOfSectorsPassed = 24;// 24;// = setPlaceholdeForMotor;\n-    int lastColorNumber = findCurrentColorNum();\n-\n-    int stoppingColorNum = 0; //For overshoot, 0 = default value\n-\n-    // double defaultSetForColorWheel = -0.4;\n-    // double defaultSetForColorWheel = -0.7;\n-    double defaultSetForColorWheel = -0.95;\n-    double secoundSetValue_ = -0.5;\n-    // double defaultSetForColorWheel = 0.2;\n-\n-    public ColorOperations() {\n-        addRequirements(robot_.colorWheel_);\n-      }\n-    \n-    @Override\n-    public void initialize(){\n-        doEverything();\n-    }\n-\n-    @Override\n-    public void end(boolean interrupted) {\n-    }\n- \n-    @Override\n-    public boolean isFinished() {\n-      return true;\n-    }\n-\n-\n-\n-    public void doEverything(){\n-        getSentColorNum();\n-        moveColorMotorToSpot();\n-    }\n-\n-    public int getSentColorNum(){\n-        // colorNum = 1;//<<\n-        gameData = DriverStation.getInstance().getGameSpecificMessage();\n-        currentColorNum = findCurrentColorNum();\n-        if(gameData.length() > 0){\n-        switch (gameData.charAt(0))\n-            // B=4,G=3,R=1,Y=2\n-        {\n-            case 'B' :\n-                colorNum = 4;\n-                stoppingColorNum = 3;\n-            break;\n-            case 'G' :\n-                colorNum = 3;\n-                stoppingColorNum = 1;\n-            break;\n-            case 'R' :\n-                colorNum = 1;\n-                stoppingColorNum = 2;\n-            break;\n-            case 'Y' :\n-                colorNum = 2;\n-                stoppingColorNum = 4;\n-            break;\n-            default :\n-                colorNum = 0;\n-            break;\n-        }\n-        }else{//Code for no data received yet\n-        System.out.println(\"ERROR: colorNum is spesificaly set to 1, also, yes I know I am bad at spelling\");\n-        }\n-\n-        // System.out.println(\"===========================================================\");\n-        // System.out.println(\"The Required Color Number To End On Is \" + colorNum);\n-        // System.out.println(\"setPlaceholderForMotor = \" + setPlaceholdeForMotor);\n-        // System.out.println(\"gameData = \" + gameData);\n-        // System.out.println(\"currentColorNum = \" + currentColorNum);\n-        // System.out.println(\"\");\n-        // System.out.println(\"===========================================================\");\n-        return colorNum;\n-    }\n-\n-\n-    public int findCurrentColorNum(){\n-\n-        final ColorSensorV3.RawColor rawColor  = m_colorSensor.getRawColor();\n-        //System.out.println(\"\" + rawColor.red + \"\\t\" + rawColor.green +\"\\t\" + rawColor.blue);\n-        // convert raw color to HSB\n-        final double divisor = Math.max(rawColor.red,Math.max(rawColor.green,rawColor.blue));\n-        final float[] hsb = java.awt.Color.RGBtoHSB((int)(rawColor.red*255./divisor), (int)(rawColor.green*255./divisor), (int)(rawColor.blue*255./divisor), null);\n-        final int hue = (int)Math.round(360*hsb[0]); // integer hue 0 - 360\n-        // SmartDashboard.putNumber(\"Hue\", hue);\n-\n-        // compare measured hue with wheel colors, picking the closest\n-        int proximity = Integer.MAX_VALUE;\n-        int index = 0;\n-        for (int i = 0; i < wheelHue.length; i++) {\n-        final int p = Math.abs(hue - wheelHue[i]);\n-        if (p < proximity) {\n-            proximity = p;\n-            index = i;\n-            }\n-        }  \n-        //   SmartDashboard.putString(\"Color\", wheelColor[index]);\n-        // System.out.println(\"HUE:\" + hue + \"\\t\" + \"COLOR:\" + wheelColor[index]);\n-        // System.out.println(\"END OF ColorWith...\");\n-\n-        if(index == 4){//Convert to just color numbers.\n-            index = 0;\n-        }\n-        index++;\n-        return index;\n-    }\n-\n-    public void moveColorMotorToSpot(){//int desiredColorNum_){\n-        System.out.println();\n-        // B=4,G=3,R=1,Y=2\n-        \n-            robot_.colorWheel_.talon_.set(defaultSetForColorWheel);\n-\n-        while(numberOfSectorsPassed < neededNumberOfSectorsPassed){\n-            // System.out.println(findCurrentColorNum());\n-            \n-        \n-            // robot_.colorTalonMotor_.set(defaultSetForColorWheel);\n-            /// System.out.println(\"numberOfSectorsPassed = \"+numberOfSectorsPassed +\" \\t currentColorNum = \"+findCurrentColorNum()+\" \\t lastColorNumber = \"+lastColorNumber);\n-                if(lastColorNumber != findCurrentColorNum()){\n-                    if(lastColorNumber == 4){\n-                        if(findCurrentColorNum() == 2){\n-                            lastColorNumber = findCurrentColorNum();\n-                            numberOfSectorsPassed++;\n-                            System.out.println(\"numberOfSectorsPassed = \"+numberOfSectorsPassed +\" \\t currentColorNum = \"+findCurrentColorNum()+\" \\t lastColorNumber = \"+lastColorNumber);\n-\n-                        } \n-                    } else if(lastColorNumber == 1 || lastColorNumber == 5){\n-                        if(findCurrentColorNum() == 3){\n-                            lastColorNumber = findCurrentColorNum();\n-                            numberOfSectorsPassed++;\n-                            System.out.println(\"numberOfSectorsPassed = \"+numberOfSectorsPassed +\" \\t currentColorNum = \"+findCurrentColorNum()+\" \\t lastColorNumber = \"+lastColorNumber);\n-\n-                        }\n-                    } else {\n-                        lastColorNumber = findCurrentColorNum();\n-                        numberOfSectorsPassed++;\n-                        System.out.println(\"numberOfSectorsPassed = \"+numberOfSectorsPassed +\" \\t currentColorNum = \"+findCurrentColorNum()+\" \\t lastColorNumber = \"+lastColorNumber);\n-\n-                    }\n-                }\n-            }\n-        System.out.println(\"\");\n-        System.out.println(\"Searching for color num of \" + colorNum);\n-\n-        //robot_.colorTalonMotor_.set(-0.4);//defaultSetForColorWheel + 0.7);\n-        robot_.colorWheel_.talon_.set(secoundSetValue_);//defaultSetForColorWheel + 0.7);\n-        // lastColorNumber = findCurrentColorNum();\n-        stoppingColorNum = colorNum;\n-        while(stoppingColorNum != lastColorNumber){\n-        // while(stoppingColorNum != lastColorNumber){\n-                // while(movementForOvershoot != findCurrentColorNum()){\n-            // while(getSentColorNum() != lastColorNumber){\n-                \n-\n-\n-            // while(getSentColorNum() != lastColorNumber){\n-\n-            // robot_.colorTalonMotor_.set(defaultSetForColorWheel - 0.05);\n-            /// System.out.println(\"numberOfSectorsPassed = \"+numberOfSectorsPassed +\" \\t currentColorNum = \"+findCurrentColorNum()+\" \\t lastColorNumber = \"+lastColorNumber);\n-                if(lastColorNumber != findCurrentColorNum()){\n-                    if(lastColorNumber == 4){\n-                        if(findCurrentColorNum() == 2){\n-                            lastColorNumber = findCurrentColorNum();\n-                            numberOfSectorsPassed++;\n-                            System.out.println(\"numberOfSectorsPassed = \"+numberOfSectorsPassed +\" \\t currentColorNum = \"+findCurrentColorNum()+\" \\t lastColorNumber = \"+lastColorNumber);\n-\n-                        } \n-                    } else if(lastColorNumber == 1 || lastColorNumber == 5){\n-                        if(findCurrentColorNum() == 3){\n-                            lastColorNumber = findCurrentColorNum();\n-                            numberOfSectorsPassed++;\n-                            System.out.println(\"numberOfSectorsPassed = \"+numberOfSectorsPassed +\" \\t currentColorNum = \"+findCurrentColorNum()+\" \\t lastColorNumber = \"+lastColorNumber);\n-\n-                        }\n-                    } else {\n-                        lastColorNumber = findCurrentColorNum();\n-                        numberOfSectorsPassed++;\n-                        System.out.println(\"numberOfSectorsPassed = \"+numberOfSectorsPassed +\" \\t currentColorNum = \"+findCurrentColorNum()+\" \\t lastColorNumber = \"+lastColorNumber);\n-\n-                    }\n-                }\n-            // }\n-        }\n-        robot_.colorWheel_.talon_.set(0);\n-        System.out.println(\"TASK COMPLEATED\");\n-\n-        numberOfSectorsPassed = 0;\n-\n-\n-///\n-        //   if(colorWheelObject.findCurrentColorNum() == colorGoal){\n-        //     colorMotor.set(0);\n-        //     System.out.println(\"Desired color reached\");\n-        //   } else {\n-        //     colorMotor.set(0.4);\n-        //     System.out.println(\"curretColor = \"+colorWheelObject.findCurrentColorNum()+\" \\t colorGoal = \" + colorGoal);\n-    \n-        //   }\n-        // } else {\n-        //   colorMotor.set(0);\n-        // }\n-///\n-        // return 0;\n-    }\n-\n-}\n\\ No newline at end of file"
  },
  {
    "sha": "1969aa90ed05067a4d312f5ec70c526e9348cbef",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/DoNothing.java",
    "status": "removed",
    "additions": 0,
    "deletions": 42,
    "changes": 42,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/DoNothing.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/DoNothing.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/DoNothing.java?ref=32a20f41af423f2a6afe8487d648bf81d4472d2d",
    "patch": "@@ -1,42 +0,0 @@\n-/*----------------------------------------------------------------------------*/\n-/* Copyright (c) 2020 FRC Team 2077. All Rights Reserved.                     */\n-/* Open Source Software - may be modified and shared by FRC teams.            */\n-/*----------------------------------------------------------------------------*/\n-\n-package org.usfirst.frc.team2077.commands;\n-\n-import edu.wpi.first.wpilibj2.command.CommandBase;\n-\n-\n-public class DoNothing extends CommandBase {\n-\n-  @Override\n-  public boolean runsWhenDisabled() {\n-    return true;\n-  }\n-  \n-\n-  public DoNothing() {\n-    System.out.println(\"################################# DoNothing()\");\n-  }\n-\n-  @Override\n-  public void initialize() {\n-    System.out.println(\"################################# initialize()\");\n-  }\n-\n-  @Override\n-  public void execute() {\n-    System.out.println(\"################################# execute()\");\n-  }\n-\n-  @Override\n-  public void end(boolean interrupted) {\n-    System.out.println(\"################################# end(\" + interrupted + \")\");\n-  }\n-\n-  @Override\n-  public boolean isFinished() {\n-    return false;\n-  }\n-}"
  },
  {
    "sha": "294c1e5aa42c22a08278e28603ec14df4be80145",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/GalacticSearch.java",
    "status": "modified",
    "additions": 42,
    "deletions": 42,
    "changes": 84,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/commands/GalacticSearch.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/commands/GalacticSearch.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/GalacticSearch.java?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -1,30 +1,26 @@\n package org.usfirst.frc.team2077.commands;\n \n import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;\n-import edu.wpi.first.wpilibj2.command.Subsystem;\n-import org.usfirst.frc.team2077.commands.Move2;\n-import org.usfirst.frc.team2077.commands.RunGrabberToggle;\n \n \n public class GalacticSearch extends SequentialCommandGroup {\n \n     private static SequentialCommandGroup getMoveToPickUp(double north, double east, double rotation) {\n         int grabDistance = 20;\n-        if (rotation != 0) {\n-            return new SequentialCommandGroup(\n-                new Move2(rotation),  \n-                new Move2(north - grabDistance, east - grabDistance),\n-                new RunGrabberToggle(.3), //TODO: Look at this value\n-                new Move2(grabDistance, grabDistance),\n-                new RunGrabberToggle(0)\n-            );\n+        // if (rotation != 0) {\n+        //     return new SequentialCommandGroup(\n+        //         new Move(rotation),\n+        //         new Move(north - grabDistance, 0),\n+        //         new RunGrabberToggle(.3), //TODO: Look at this value\n+        //         new Move(grabDistance, 0),\n+        //         new RunGrabberToggle(0)\n+        //     );\n \n-        }\n+        // }\n         return new SequentialCommandGroup(\n-            \n-            new Move2(north - grabDistance, east - grabDistance),\n-            new RunGrabberToggle(.3), //TODO: Look at this value\n-            new Move2(grabDistance, grabDistance),\n+            new Move(north - grabDistance, 0),\n+            new RunGrabberToggle(.6), //TODO: Look at this value\n+            new Move(grabDistance, 0),\n             new RunGrabberToggle(0)\n         );\n     }\n@@ -34,61 +30,65 @@ public GalacticSearch(boolean a, boolean red) {\n     if (a) {\n         if (red) {\n             addCommands( //Path A red\n-                getMoveToPickUp(60, 0, 0),\n-                new Move2(0, 30),\n-                getMoveToPickUp(60, 0, 0),\n-                new Move2(0, -90),\n-                getMoveToPickUp(60, 0, 0),\n-                new Move2(180, 0)\n+                new RunGrabberToggle(.6),\n+                new Move(60, 0),\n+                new Move(0, 24),\n+                new Move(30, 0),\n+                new Move(-5, -70),\n+                new Move(172, 0),\n+                new RunGrabberToggle(0)\n                 // getMoveToPickUp(90, 0, 0),\n                 // getMoveToPickUp(60, 30, 30),\n                 // getMoveToPickUp(30, -90, -101.56), //tan^-1((pi/2)/(pi/6)) + 30 == tan^-1(90/30) + 30\n-                // new Move2(71.56),\n-                // new Move2(180, 0)\n+                // new Move(71.56),\n+                // new Move(180, 0)\n                 );\n         } else {\n             addCommands( //Path A blue\n                 getMoveToPickUp(150, 0, 0),\n-                new Move2(0, -90),\n+                new Move(0, -90),\n                 getMoveToPickUp(30, 0, 0),\n-                new Move2(0, 30),\n+                new Move(0, 30),\n                 getMoveToPickUp(60, 0, 0),\n-                new Move2(60, 0)\n+                new Move(30, 0)\n                 // getMoveToPickUp(180, 0, 0),\n                 // getMoveToPickUp(30, -90, -71.56),\n                 // getMoveToPickUp(60, 30, 101.56),\n-                // new Move2(-30),\n-                // new Move2(90, 0)\n+                // new Move(-30),\n+                // new Move(90, 0)\n             );\n         }\n     } else {\n         if (red) {\n             addCommands( //Path B red\n-                getMoveToPickUp(60, 0, 0),\n-                new Move2(0, 60),\n-                getMoveToPickUp(60, 0, 0),\n-                new Move2(0, -60),\n-                getMoveToPickUp(60, 0, 0),\n-                new Move2(120, 0)\n+                new RunGrabberToggle(.5),\n+                new Move(1, 0),\n+                new Move(0, -26.5),\n+                new Move(22, 0),\n+                new Move(0, 65),\n+                new Move(51, 0),\n+                new Move(0, -70),\n+                new Move(120, 0),\n+                new RunGrabberToggle(0)\n                 // getMoveToPickUp(60, 0, 0),\n                 // getMoveToPickUp(60, 60, 45),\n                 // getMoveToPickUp(60, -60, -90),\n-                // new Move2(45),\n-                // new Move2(120, 0)\n+                // new Move(45),\n+                // new Move(120, 0)\n             );\n         } else {\n             addCommands( //Path B blue\n                 getMoveToPickUp(150, 0, 0),\n-                new Move2(0, -60),\n+                new Move(0, -60),\n                 getMoveToPickUp(60, 0, 0),\n-                new Move2(0, -60),\n+                new Move(0, -60),\n                 getMoveToPickUp(60, 0, 0),\n-                new Move2(30, 0)\n+                new Move(30, 0)\n                 // getMoveToPickUp(150, 0, 0),\n                 // getMoveToPickUp(60, -60, -45),\n                 // getMoveToPickUp(60, 60, 90),\n-                // new Move2(-45),\n-                // new Move2(30, 0)\n+                // new Move(-45),\n+                // new Move(30, 0)\n             );\n         }\n     }"
  },
  {
    "sha": "f9660e33791e18148330bcbba2679470ab20be45",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/LauncherSpinTest.java",
    "status": "modified",
    "additions": 9,
    "deletions": 2,
    "changes": 11,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/commands/LauncherSpinTest.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/commands/LauncherSpinTest.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/LauncherSpinTest.java?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -21,8 +21,15 @@ public LauncherSpinTest(double increment) {\n   @Override\n   public void initialize() {\n     double i = Math.abs(increment_);\n-    double rpm = Math.round(robot_.testLauncher_.launcherRPM_ / i) * i + increment_;\n-    robot_.testLauncher_.setLauncherRPM(Math.max(i, Math.min(robot_.testLauncher_.launcherMaxRPM_, rpm)));\n+    // double rpm = Math.round(robot_.testLauncher_.launcherRPM_ / i) * i + increment_;\n+    double rpm = Math.max(robot_.testLauncher_.launcherRPM_ + increment_, 0);\n+    System.out.println(String.format(\"[LauncherSpinTest] Increment: %s, launcherRpm: %s\",\n+                                     increment_,\n+                                     robot_.testLauncher_.launcherRPM_));\n+    // robot_.testLauncher_.setLauncherRPM(Math.max(i, Math.min(robot_.testLauncher_.launcherMaxRPM_, rpm)));\n+    robot_.testLauncher_.setLauncherRPM(rpm);\n+    System.out.println(String.format(\"[LauncherSpinTest] launcherRpm: %s\",\n+                                     robot_.testLauncher_.launcherRPM_));\n   }\n \n   @Override"
  },
  {
    "sha": "31e5e3d6b50d40d7ffb3910a668ac8c5a1c25b90",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/LauncherSpinTestZ.java",
    "status": "removed",
    "additions": 0,
    "deletions": 39,
    "changes": 39,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/LauncherSpinTestZ.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/LauncherSpinTestZ.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/LauncherSpinTestZ.java?ref=32a20f41af423f2a6afe8487d648bf81d4472d2d",
    "patch": "@@ -1,39 +0,0 @@\n-/*----------------------------------------------------------------------------*/\n-/* Copyright (c) 2020 FRC Team 2077. All Rights Reserved.                     */\n-/* Open Source Software - may be modified and shared by FRC teams.            */\n-/*----------------------------------------------------------------------------*/\n-\n-package org.usfirst.frc.team2077.commands;\n-\n-import edu.wpi.first.wpilibj2.command.CommandBase;\n-\n-import static org.usfirst.frc.team2077.Robot.*;\n-\n-/**\n- * Toggles launcher wheels on or off each time it's executed.\n- * If the invoking button is held down when turning on, the wheel speed\n- * may be adjusted with the secondary joystick Z dial.\n- */\n-public class LauncherSpinTestZ extends CommandBase {\n-  \n-  public LauncherSpinTestZ() {\n-    addRequirements(robot_.testLauncher_);\n-  }\n-\n-  @Override\n-  public void initialize() {\n-    robot_.testLauncher_.setRunning(robot_.testLauncher_.isRunning());\n-  }\n-\n-  @Override\n-  public void execute() {\n-    double z = (robot_.driveStation_.secondaryStick_.getThrottle() + 1.)/ 2.;\n-    z = .1 + .8*z; // scale from 10% to 100%\n-    robot_.testLauncher_.setLauncherRPM(z * robot_.testLauncher_.launcherMaxRPM_);\n-  }\n-\n-  @Override\n-  public boolean isFinished() {\n-    return false;\n-  }\n-}"
  },
  {
    "sha": "d096964711f61c2cbef0dbcb1de65161be02c734",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/LoadLauncher.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/commands/LoadLauncher.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/commands/LoadLauncher.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/LoadLauncher.java?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -20,7 +20,7 @@ public void initialize() {\n \n   @Override\n   public void execute() {\n-    robot_.testLauncher_.runLoader(1.0);\n+    robot_.testLauncher_.runLoader(.2);\n   }\n \n   @Override"
  },
  {
    "sha": "886e0b25a749d576a1695eb15bfbc33192f3ece4",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/Move.java",
    "status": "added",
    "additions": 210,
    "deletions": 0,
    "changes": 210,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/commands/Move.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/commands/Move.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/Move.java?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -0,0 +1,210 @@\n+/*----------------------------------------------------------------------------*/\n+/* Copyright (c) 2020 FRC Team 2077. All Rights Reserved.                     */\n+/* Open Source Software - may be modified and shared by FRC teams.            */\n+/*----------------------------------------------------------------------------*/\n+\n+package org.usfirst.frc.team2077.commands;\n+\n+import edu.wpi.first.wpilibj2.command.CommandBase;\n+import edu.wpi.first.wpilibj2.command.Subsystem;\n+import org.usfirst.frc.team2077.math.Acceleration;\n+import org.usfirst.frc.team2077.math.Position;\n+\n+import static org.usfirst.frc.team2077.Robot.robot_;\n+\n+\n+public class Move extends CommandBase {\n+\n+\tpublic enum Style {\n+\t\tMOVE_AND_ROTATE,\n+\t\tMOVE,\n+\t\tROTATE\n+\t}\n+\n+\tprivate static final byte NORTH = 0, EAST = 1, CLOCKWISE = 2;\n+\tprivate final double[] distanceTotal_;\n+\tprivate final Style method_;\n+\tprivate double[] vCurrent;\n+\tprivate double[] fast_;\n+\tprivate double[] slow_;\n+\tprivate double[] distanceRemaining_;\n+\tprivate boolean[] finished_;\n+\tprivate double[][] acceleration_;\n+\tprivate Position origin_;\n+\n+\tpublic Move(double north, double east, double rotation) {\n+\t\tthis(north, east, rotation, Style.MOVE_AND_ROTATE, robot_.position_, robot_.heading_);\n+\t}\n+\n+\tpublic Move(double north, double east) {\n+\t\tthis(north, east, 0, Style.MOVE, robot_.position_);\n+\t}\n+\n+\tpublic Move(double rotation) {\n+\t\tthis(0, 0, rotation, Style.ROTATE, robot_.heading_);\n+\t}\n+\n+\tprivate Move(double north, double east, double rotation, Style method, Subsystem... requirements) {\n+\n+\t\taddRequirements(requirements);\n+\t\t// distanceTotal_ = new double[] {north, east * .68, rotation * 7/8}; //fudged values for the multipliers\n+\t\tdistanceTotal_ = new double[]{north, east, rotation}; //fudged values for the multipliers\n+\t\tmethod_ = method;\n+\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$ MOVE2 DISTANCE:\" +\n+\t\t\t\t\t\t   distanceTotal_[0] +\n+\t\t\t\t\t\t   \" \" +\n+\t\t\t\t\t\t   distanceTotal_[1] +\n+\t\t\t\t\t\t   \" \" +\n+\t\t\t\t\t\t   distanceTotal_[2] +\n+\t\t\t\t\t\t   \" (\" +\n+\t\t\t\t\t\t   method_ +\n+\t\t\t\t\t\t   \")\");\n+\t}\n+\n+\n+\t@Override\n+\tpublic void initialize() {\n+\t\tdouble[] max = robot_.chassis_.getMaximumVelocity();\n+\t\tdouble[] min = robot_.chassis_.getMinimumVelocity();\n+\n+\t\t// scale factors for north/east/rotation by fraction of maximum velocity\n+\t\tdouble[] scale = {\n+\t\t\tMath.abs(distanceTotal_[NORTH]) / max[NORTH],\n+\t\t\tMath.abs(distanceTotal_[EAST]) / max[EAST],\n+\t\t\tMath.abs(distanceTotal_[CLOCKWISE]) / max[CLOCKWISE]\n+\t\t};\n+\t\tdouble maxScale = Math.max(scale[NORTH], Math.max(scale[EAST], scale[CLOCKWISE]));\n+\t\tscale = new double[]{\n+\t\t\tscale[NORTH] / maxScale,\n+\t\t\tscale[EAST] / maxScale,\n+\t\t\tscale[CLOCKWISE] / maxScale\n+\t\t}; // NORTH - EAST\n+\t\tdouble[] sign = {\n+\t\t\tMath.signum(distanceTotal_[NORTH]),\n+\t\t\tMath.signum(distanceTotal_[EAST]),\n+\t\t\tMath.signum(distanceTotal_[CLOCKWISE])\n+\t\t};\n+\n+\t\t// scale speeds and acceleration/deceleration\n+\t\tfast_ = new double[]{\n+\t\t\tMath.max(min[NORTH], max[NORTH] * scale[NORTH]) * sign[NORTH],\n+\t\t\tMath.max(min[EAST], max[EAST] * scale[EAST]) * sign[EAST],\n+\t\t\tMath.max(min[CLOCKWISE], max[CLOCKWISE] * scale[CLOCKWISE]) * sign[CLOCKWISE]\n+\t\t}; // don't let maximum scale below minimum\n+\t\tslow_ = new double[]{\n+\t\t\tmin[NORTH] * sign[NORTH],\n+\t\t\tmin[EAST] * sign[EAST],\n+\t\t\tmin[CLOCKWISE] * sign[CLOCKWISE]\n+\t\t}; // don't scale below minimum\n+\t\tacceleration_ = (new Acceleration(\n+\t\t\trobot_.constants_.STARDESTROYER_ACCELERATION_G_LIMIT,\n+\t\t\trobot_.constants_.STARDESTROYER_DECELERATION_G_LIMIT,\n+\t\t\trobot_.chassis_,\n+\t\t\tscale\n+\t\t).get());\n+\n+\t\torigin_ = new Position(robot_.chassis_.getPosition());\n+\t\tdistanceRemaining_ = new double[]{distanceTotal_[NORTH], distanceTotal_[EAST], distanceTotal_[CLOCKWISE]};\n+\t\tfinished_ = new boolean[]{\n+\t\t\tMath.abs(distanceRemaining_[NORTH]) == 0.,\n+\t\t\tMath.abs(distanceRemaining_[EAST]) == 0.,\n+\t\t\tMath.abs(distanceRemaining_[CLOCKWISE]) == 0.\n+\t\t};\n+\n+\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$ MOVECLOCKWISE DISTANCE:\" +\n+\t\t\t\t\t\t   distanceTotal_[NORTH] +\n+\t\t\t\t\t\t   \" \" +\n+\t\t\t\t\t\t   distanceTotal_[EAST] +\n+\t\t\t\t\t\t   \" \" +\n+\t\t\t\t\t\t   distanceTotal_[CLOCKWISE] +\n+\t\t\t\t\t\t   \" (\" +\n+\t\t\t\t\t\t   method_ +\n+\t\t\t\t\t\t   \")\");\n+\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$ MOVECLOCKWISE SCALE:\" +\n+\t\t\t\t\t\t   scale[NORTH] +\n+\t\t\t\t\t\t   \" \" +\n+\t\t\t\t\t\t   scale[EAST] +\n+\t\t\t\t\t\t   \" \" +\n+\t\t\t\t\t\t   scale[CLOCKWISE]);\n+\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$ MOVECLOCKWISE FAST:\" +\n+\t\t\t\t\t\t   fast_[NORTH] +\n+\t\t\t\t\t\t   \" \" +\n+\t\t\t\t\t\t   fast_[EAST] +\n+\t\t\t\t\t\t   \" \" +\n+\t\t\t\t\t\t   fast_[CLOCKWISE]);\n+\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$ MOVECLOCKWISE SLOW:\" +\n+\t\t\t\t\t\t   slow_[NORTH] +\n+\t\t\t\t\t\t   \" \" +\n+\t\t\t\t\t\t   slow_[EAST] +\n+\t\t\t\t\t\t   \" \" +\n+\t\t\t\t\t\t   slow_[CLOCKWISE]);\n+\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$ MOVECLOCKWISE ACCEL N:\" +\n+\t\t\t\t\t\t   acceleration_[NORTH][NORTH] +\n+\t\t\t\t\t\t   \" \" +\n+\t\t\t\t\t\t   acceleration_[NORTH][EAST]);\n+\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$ MOVECLOCKWISE ACCEL E:\" +\n+\t\t\t\t\t\t   acceleration_[EAST][NORTH] +\n+\t\t\t\t\t\t   \" \" +\n+\t\t\t\t\t\t   acceleration_[EAST][EAST]);\n+\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$ MOVECLOCKWISE ACCEL R:\" +\n+\t\t\t\t\t\t   acceleration_[CLOCKWISE][NORTH] +\n+\t\t\t\t\t\t   \" \" +\n+\t\t\t\t\t\t   acceleration_[CLOCKWISE][EAST]);\n+\t}\n+\n+\t@Override\n+\tpublic void execute() {\n+\t\tvCurrent = robot_.chassis_.getVelocityCalculated();\n+\t\tdouble[] vNew = {0, 0, 0};\n+\t\tdouble[] distanceTraveled = (new Position(robot_.chassis_.getPosition())).distanceRelative(origin_);\n+\t\tboolean[] slow = {false, false, false};\n+\t\tfor(int i = 0; i < 3; i++) {\n+\t\t\tdistanceRemaining_[i] = distanceTotal_[i] - distanceTraveled[i];\n+\t\t\tdouble distanceToStop = vCurrent[i] * vCurrent[i] /\n+\t\t\t\t\t\t\t\t\tacceleration_[i][1] /\n+\t\t\t\t\t\t\t\t\t2.;// exact absolute value per physics\n+\t\t\tdistanceToStop += Math.max(\n+\t\t\t\tdistanceToStop * .05,\n+\t\t\t\tMath.abs(vCurrent[i]) * .04\n+\t\t\t); // pad just a bit to avoid overshoot\n+\t\t\tslow[i] = finished_[i] ||\n+\t\t\t\t\t  Math.abs(distanceRemaining_[i]) <= distanceToStop; // slow down within padded stopping distance\n+\t\t}\n+\t\tboolean s = Math.abs(distanceTotal_[CLOCKWISE]) > 0 ? slow[CLOCKWISE] : (slow[NORTH] && slow[EAST]);\n+\t\tfor(int i = 0; i < 3; i++) {\n+\t\t\tvNew[i] = finished_[i] ? 0. : s ? slow_[i] : fast_[i];\n+\t\t}\n+/*\n+    System.out.println(\"$$$$$$$$$$$$$$$$$$ MOVE2:\"\n+    + finished_[0] + \"/\" + finished_[1] + \"/\" + finished_[2] + \" \" + slow[0] + \"/\" + slow[1] + \"/\" + slow[2]\n+    + Math.round(distanceTraveled[0]*10)/10. + \"/\" + Math.round(distanceTotal_[0]*10)/10. + \"@\" + Math.round(vNew[0]*10)/10. + \"   \"\n+    + Math.round(distanceTraveled[1]*10)/10. + \"/\" + Math.round(distanceTotal_[1]*10)/10. + \"@\" + Math.round(vNew[1]*10)/10. + \"   \"\n+    + Math.round(distanceTraveled[2]*10)/10. + \"/\" + Math.round(distanceTotal_[2]*10)/10. + \"@\" + Math.round(vNew[2]*10)/10. + robot_.angleSensor_.getAngle());\n+*/\n+\t\tswitch(method_) {\n+\t\t\tcase MOVE_AND_ROTATE:\n+\t\t\t\trobot_.chassis_.setVelocity(vNew[NORTH], vNew[EAST], vNew[CLOCKWISE], acceleration_);\n+\t\t\t\tbreak;\n+\t\t\tcase MOVE:\n+\t\t\t\trobot_.chassis_.setVelocity(vNew[NORTH], vNew[EAST], acceleration_);\n+\t\t\t\tbreak;\n+\t\t\tcase ROTATE:\n+\t\t\t\trobot_.chassis_.setRotation(vNew[CLOCKWISE], acceleration_);\n+\t\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean isFinished() {\n+\t\tfor(int i = 0; i < 3; i++) {\n+\t\t\tfinished_[i] = finished_[i] || (Math.signum(distanceRemaining_[i]) != Math.signum(distanceTotal_[i]));\n+\t\t}\n+\t\tboolean reachedGoal = Math.abs(distanceTotal_[2]) > 0 ? finished_[2] : (finished_[0] && finished_[1]);\n+\t\tboolean stoppedMoving = false;\n+\t\tfor(double velocity : vCurrent) {\n+\t\t\tstoppedMoving = stoppedMoving || Math.abs(velocity) <= 0.1;\n+\t\t}\n+\n+\t\treturn reachedGoal && stoppedMoving;\n+\t}\n+}"
  },
  {
    "sha": "e109fba107a4f0dcaaff21f456cdf3d71f07e658",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/Move.java.deprecated",
    "status": "removed",
    "additions": 0,
    "deletions": 111,
    "changes": 111,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/Move.java.deprecated",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/Move.java.deprecated",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/Move.java.deprecated?ref=32a20f41af423f2a6afe8487d648bf81d4472d2d",
    "patch": "@@ -1,111 +0,0 @@\n-/*----------------------------------------------------------------------------*/\n-/* Copyright (c) 2020 FRC Team 2077. All Rights Reserved.                     */\n-/* Open Source Software - may be modified and shared by FRC teams.            */\n-/*----------------------------------------------------------------------------*/\n-\n-package org.usfirst.frc.team2077.commands;\n-\n-import edu.wpi.first.wpilibj2.command.CommandBase;\n-import static org.usfirst.frc.team2077.Robot.*;\n-\n-public class Move extends CommandBase {\n-  @SuppressWarnings({ \"PMD.UnusedPrivateField\", \"PMD.SingularField\" })\n-  private double north_;\n-  private double east_;\n-  private double rotation_;\n-  private double finalHeading;\n-  private double initPosition;\n-  private double finalPosition;\n-  private final double forwardAccel = 20; //constant for acceleration in inch/sec\n-  private final double deccelConst = 20;\n-\n-  public Move(double north, double east, double rotation) {\n-    addRequirements(robot_.position_, robot_.heading_);\n-    north_ = north;\n-    east_ = east;\n-    rotation_ = rotation;\n-  }\n-\n-  public Move(boolean relative, double north, double east, double rotation) {\n-    addRequirements(robot_.position_, robot_.heading_);\n-  }\n-\n-  public Move(boolean relative, double north, double east) {\n-    addRequirements(robot_.position_);\n-  }\n-\n-  public Move(boolean relative, double rotation) {\n-    addRequirements(robot_.heading_);\n-  }\n-\n-  public void initialize() {\n-    initPosition = robot_.chassis_.getPosition()[0];\n-    finalPosition = robot_.chassis_.getPosition()[0] + north_;\n-    finalHeading = robot_.chassis_.getPosition()[2] + rotation_;\n-    //distance = robot_.constants_.TESTBOT_TRACK_WIDTH;\n-  }\n-\n-  @Override\n-  public void execute() {\n-    //Calculating decceleration velocity: vInitial = Math.sqrt(-2A * dRemains)\n-    //Calculating accelerating velocity: vFinal = Math.sqrt(2A * dGone)\n-    double vAccel;\n-    double vDeccel;\n-    if (north_ > 0) {\n-      vAccel = 1 + Math.sqrt(2 * forwardAccel * (robot_.chassis_.getPosition()[0] - initPosition));\n-      vDeccel = Math.sqrt(-(2 * - deccelConst * (finalPosition - robot_.chassis_.getPosition()[0])));\n-    } else {\n-      vAccel = - 1 - Math.sqrt(2 * forwardAccel * (initPosition - robot_.chassis_.getPosition()[0]));\n-      vDeccel = - Math.sqrt(-(2 * - deccelConst * (robot_.chassis_.getPosition()[0] - finalPosition)));\n-    }\n-    double velocity;\n-    if (Math.abs(vAccel) < Math.abs(vDeccel)) {\n-      velocity = vAccel;\n-    } else {\n-      if (Math.abs(vDeccel) < 5) {\n-        velocity = Math.copySign(5, vDeccel);\n-      } else {\n-        velocity = vDeccel;\n-      }\n-    }\n-    System.out.println(velocity);\n-    //System.out.println(\"Accel: \" + vAccel + \"        Deccel: \" + vDeccel);\n-    if (rotation_ == 0) {\n-        //robot_.driveChassis_.setVelocity(Math.copySign(4, north_), 0, 0);\n-        robot_.chassis_.setVelocity(Math.copySign(velocity, north_), 0, 0);\n-    } else {\n-      if (robot_.chassis_.getPosition()[2] < finalHeading) {\n-        robot_.chassis_.setVelocity(north_ * Math.abs(2 / rotation_), 0, Math.copySign(4, rotation_));\n-      }\n-    }\n-  }\n-\n-  @Override\n-  public void end(boolean interrupted) {\n-  }\n-\n-  @Override\n-  public boolean isFinished() {\n-    //Measuring the rotation only because the angle is more important than being an inch or two off\n-    if (rotation_ == 0) {\n-      if (north_ > 0) {\n-        if (finalPosition <= robot_.chassis_.getPosition()[0]) {\n-          return true;\n-        }\n-      } else {\n-        if (finalPosition >= robot_.chassis_.getPosition()[0]) {\n-          return true;\n-        }\n-      }\n-    } else if (rotation_ > 0) {\n-      if (robot_.chassis_.getPosition()[2] >= finalHeading) {\n-        return true;\n-      }\n-    } else { //rotation is negative\n-      if (robot_.chassis_.getPosition()[2] <= finalHeading) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-}"
  },
  {
    "sha": "1e8eb80d3b3a8e9fc637865ca678e45781d6f422",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/Move2.java",
    "status": "removed",
    "additions": 0,
    "deletions": 145,
    "changes": 145,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/Move2.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/Move2.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/Move2.java?ref=32a20f41af423f2a6afe8487d648bf81d4472d2d",
    "patch": "@@ -1,145 +0,0 @@\n-/*----------------------------------------------------------------------------*/\n-/* Copyright (c) 2020 FRC Team 2077. All Rights Reserved.                     */\n-/* Open Source Software - may be modified and shared by FRC teams.            */\n-/*----------------------------------------------------------------------------*/\n-\n-package org.usfirst.frc.team2077.commands;\n-\n-import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n-import edu.wpi.first.wpilibj2.command.CommandBase;\n-import edu.wpi.first.wpilibj2.command.Subsystem;\n-\n-import org.usfirst.frc.team2077.math.Acceleration;\n-import org.usfirst.frc.team2077.math.Position;\n-\n-import static org.usfirst.frc.team2077.Robot.*;\n-\n-import java.util.Arrays;\n-\n-\n-public class Move2 extends CommandBase {\n-\n-  private final double[] distanceTotal_; // {north, east, rotation} (signed)\n-  private final int method_; // 1 2 or 3 (#args to setVelocity/setRotation)\n-\n-  private double[] fast_; // {north, east, rotation} (signed)\n-  private double[] slow_; // {north, east, rotation} (signed)\n-  private double[][] acceleration_; // like getAccelerationLimits, but scaled\n-\n-  private double[] distanceRemaining_; // {north, east, rotation} (signed)\n-\n-  private boolean[] finished_; // {north, east, rotation}\n-\n-\n-  private Position origin_;\n-\n-  public static double bestRotation(double rotation) {\n-    double remainder = Math.abs(rotation % 180);\n-    int halfTurns = (int)rotation / 180;\n-    if (halfTurns % 2 == 1) {\n-      return -180 + remainder;\n-    }\n-    return remainder;\n-  }\n-\n-\n-  public Move2(double north, double east, double rotation) {\n-    this(north, east, rotation, 3, robot_.position_, robot_.heading_);\n-    // this(north, east, ation(rotation), 3, robot_.position_, robot_.heading_);\n-  }\n-\n-  public Move2(double north, double east) {\n-    this(north, east, 0, 2, robot_.position_);\n-  }\n-\n-  public Move2(double rotation) {\n-    this(0, 0, rotation, 1, robot_.heading_);\n-  }\n-\n-  private Move2(double north, double east, double rotation, int method, Subsystem... requirements) {\n-\n-    addRequirements(requirements);\n-    distanceTotal_ = new double[] {north, east * .68, rotation * 7/8}; //fudged values for the multipliers\n-    method_ = method;\n-    System.out.println(\"$$$$$$$$$$$$$$$$$$ MOVE2 DISTANCE:\" + distanceTotal_[0] + \" \" + distanceTotal_[1] + \" \" + distanceTotal_[2] + \" (\" + method_ + \")\");\n-  }\n-\n-\n-  @Override\n-  public void initialize() {\n-\n-    double[] max = robot_.chassis_.getMaximumVelocity(); // {north, east, rotation}\n-    double[] min = robot_.chassis_.getMinimumVelocity(); // {north, east, rotation}\n-\n-    // scale factors for north/east/rotation by fraction of maximum velocity\n-    double[] scale = {Math.abs(distanceTotal_[0])/max[0], Math.abs(distanceTotal_[1])/max[1], Math.abs(distanceTotal_[2])/max[2]};\n-    double maxScale = Math.max(scale[0], Math.max(scale[1], scale[2]));\n-    scale = new double[] {scale[0]/maxScale, scale[1]/maxScale, scale[2]/maxScale}; // 0 - 1\n-    double[] sign = {Math.signum(distanceTotal_[0]), Math.signum(distanceTotal_[1]), Math.signum(distanceTotal_[02])};\n-\n-    // scale speeds and acceleration/deceleration\n-    fast_ = new double[] {\n-      Math.max(min[0], max[0]*scale[0]) * sign[0],\n-      Math.max(min[1], max[1]*scale[1]) * sign[1],\n-      Math.max(min[2], max[2]*scale[2]) * sign[2]}; // don't let maximum scale below minimum\n-    slow_ = new double[] {min[0] * sign[0], min[1] * sign[1], min[2] * sign[2]}; // don't scale below minimum\n-    acceleration_ = (new Acceleration(robot_.constants_.STARDESTROYER_ACCELERATION_G_LIMIT, robot_.constants_.STARDESTROYER_DECELERATION_G_LIMIT, robot_.chassis_, scale).get()); \n-\n-    origin_ = new Position(robot_.chassis_.getPosition());\n-    distanceRemaining_ = new double[] {distanceTotal_[0], distanceTotal_[1], distanceTotal_[2]};\n-    finished_ = new boolean[] {Math.abs(distanceRemaining_[0])==0., Math.abs(distanceRemaining_[1])==0., Math.abs(distanceRemaining_[2])==0.};\n-\n-    System.out.println(\"$$$$$$$$$$$$$$$$$$ MOVE2 DISTANCE:\" + distanceTotal_[0] + \" \" + distanceTotal_[1] + \" \" + distanceTotal_[2] + \" (\" + method_ + \")\");\n-    System.out.println(\"$$$$$$$$$$$$$$$$$$ MOVE2 SCALE:\" + scale[0] + \" \" + scale[1] + \" \" + scale[2]);\n-    System.out.println(\"$$$$$$$$$$$$$$$$$$ MOVE2 FAST:\" + fast_[0] + \" \" + fast_[1] + \" \" + fast_[2]);\n-    System.out.println(\"$$$$$$$$$$$$$$$$$$ MOVE2 SLOW:\" + slow_[0] + \" \" + slow_[1] + \" \" + slow_[2]);\n-    System.out.println(\"$$$$$$$$$$$$$$$$$$ MOVE2 ACCEL N:\" + acceleration_[0][0] + \" \" + acceleration_[0][1]);\n-    System.out.println(\"$$$$$$$$$$$$$$$$$$ MOVE2 ACCEL E:\" + acceleration_[1][0] + \" \" + acceleration_[1][1]);\n-    System.out.println(\"$$$$$$$$$$$$$$$$$$ MOVE2 ACCEL R:\" + acceleration_[2][0] + \" \" + acceleration_[2][1]);\n-  }\n-\n-  @Override\n-  public void execute() {\n-\n-    double[] vCurrent = robot_.chassis_.getVelocityCalculated();\n-    double[] vNew = {0, 0, 0};\n-    double[] distanceTraveled = (new Position(robot_.chassis_.getPosition())).distanceRelative(origin_);\n-    boolean[] slow = {false, false, false};\n-    for (int i = 0; i < 3; i++) {\n-      distanceRemaining_[i] = distanceTotal_[i] - distanceTraveled[i];\n-      double distanceToStop = vCurrent[i]*vCurrent[i] / acceleration_[i][1] / 2.;// exact absolute value per physics\n-      distanceToStop += Math.max(distanceToStop*.05, Math.abs(vCurrent[i])*.04); // pad just a bit to avoid overshoot\n-      slow[i] = finished_[i] || Math.abs(distanceRemaining_[i])<=distanceToStop; // slow down within padded stopping distance\n-    }\n-    boolean s = Math.abs(distanceTotal_[2])>0 ? slow[2] : (slow[0] && slow[1]);\n-    for (int i = 0; i < 3; i++) {\n-      vNew[i] = finished_[i] ? 0. : s ? slow_[i] : fast_[i];\n-    }\n-/*\n-    System.out.println(\"$$$$$$$$$$$$$$$$$$ MOVE2:\"\n-    + finished_[0] + \"/\" + finished_[1] + \"/\" + finished_[2] + \" \" + slow[0] + \"/\" + slow[1] + \"/\" + slow[2]\n-    + Math.round(distanceTraveled[0]*10)/10. + \"/\" + Math.round(distanceTotal_[0]*10)/10. + \"@\" + Math.round(vNew[0]*10)/10. + \"   \"\n-    + Math.round(distanceTraveled[1]*10)/10. + \"/\" + Math.round(distanceTotal_[1]*10)/10. + \"@\" + Math.round(vNew[1]*10)/10. + \"   \"\n-    + Math.round(distanceTraveled[2]*10)/10. + \"/\" + Math.round(distanceTotal_[2]*10)/10. + \"@\" + Math.round(vNew[2]*10)/10. + robot_.angleSensor_.getAngle());\n-*/\n-    switch (method_) {\n-      case 3:\n-        robot_.chassis_.setVelocity(vNew[0], vNew[1], vNew[2], acceleration_);\n-        break;\n-      case 2:\n-        robot_.chassis_.setVelocity(vNew[0], vNew[1], acceleration_);\n-        break;\n-      case 1:\n-        robot_.chassis_.setRotation(vNew[2], acceleration_);\n-        break;\n-    }\n-  }\n-\n-  @Override\n-  public boolean isFinished() {\n-    for (int i = 0; i < 3; i++) {\n-      finished_[i] = finished_[i] || (Math.signum(distanceRemaining_[i]) != Math.signum(distanceTotal_[i]));\n-    }\n-    return Math.abs(distanceTotal_[2])>0 ? finished_[2] : (finished_[0] && finished_[1]);\n-  }\n-}"
  },
  {
    "sha": "b0bb9c105d837da5ebdba4cbe125f9537462ae58",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/MoveAngle.java",
    "status": "removed",
    "additions": 0,
    "deletions": 67,
    "changes": 67,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/MoveAngle.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/MoveAngle.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/MoveAngle.java?ref=32a20f41af423f2a6afe8487d648bf81d4472d2d",
    "patch": "@@ -1,67 +0,0 @@\n-/*----------------------------------------------------------------------------*/\n-/* Copyright (c) 2020 FRC Team 2077. All Rights Reserved.                     */\n-/* Open Source Software - may be modified and shared by FRC teams.            */\n-/*----------------------------------------------------------------------------*/\n-\n-package org.usfirst.frc.team2077.commands;\n-\n-import edu.wpi.first.wpilibj2.command.CommandBase;\n-\n-import static org.usfirst.frc.team2077.Robot.*;\n-\n-\n-public class MoveAngle extends CommandBase {\n-  private double dps_;\n-  private double angle_;\n-  private double finalHeading;\n-\n-\n-  // as is degrees/second\n-  \n-  public MoveAngle(double angle) {\n-    this(angle, 5);\n-  }\n-\n-  public MoveAngle(double angle, double dps) {\n-    angle_ = angle;\n-    dps_ = dps;\n-    addRequirements(robot_.heading_);\n-  }\n-\n-  @Override\n-  public void initialize() {\n-\n-    finalHeading = robot_.chassis_.getPosition()[2] + angle_;\n-  }\n-\n-  @Override\n-  public void execute() {\n-    if (angle_ < 0) {\n-      if (robot_.chassis_.getPosition()[2] > finalHeading) {\n-        robot_.chassis_.setRotation(- dps_);  \n-      }\n-    } else {\n-      if (robot_.chassis_.getPosition()[2] < finalHeading) {\n-        robot_.chassis_.setRotation(dps_);\n-      } \n-    }\n-  }\n-\n-  @Override\n-  public void end(boolean interrupted) {\n-  }\n-\n-  @Override\n-  public boolean isFinished() {\n-    if (angle_ > 0) {\n-      if (robot_.chassis_.getPosition()[2] >= finalHeading) {\n-        return true;\n-      }\n-    } else { //rotation is negative\n-      if (robot_.chassis_.getPosition()[2] <= finalHeading) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-}"
  },
  {
    "sha": "669cdc77346deb880cd60a01b86dbcd2baaa56cd",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/MoveAngleTarget.java",
    "status": "removed",
    "additions": 0,
    "deletions": 76,
    "changes": 76,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/MoveAngleTarget.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/MoveAngleTarget.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/MoveAngleTarget.java?ref=32a20f41af423f2a6afe8487d648bf81d4472d2d",
    "patch": "@@ -1,76 +0,0 @@\n-/*----------------------------------------------------------------------------*/\n-/* Copyright (c) 2020 FRC Team 2077. All Rights Reserved.                     */\n-/* Open Source Software - may be modified and shared by FRC teams.            */\n-/*----------------------------------------------------------------------------*/\n-\n-package org.usfirst.frc.team2077.commands;\n-\n-import edu.wpi.first.wpilibj2.command.CommandBase;\n-\n-import static org.usfirst.frc.team2077.Robot.*;\n-\n-public class MoveAngleTarget extends CommandBase {\n-  private double dps_;\n-  private double angle_;\n-  private double finalHeading;\n-  private boolean moreThan;\n-\n-  // as is degrees/second\n-\n-\n-  public MoveAngleTarget() {\n-    \n-    \n-    addRequirements(robot_.heading_);\n-  }\n-\n-  @Override\n-  public void initialize() {\n-    //angle_ = robot_.chassis_.getPosition()[2] % 360 + Math.toDegrees( Math.atan2(robot_.crosshairs_.getTarget()[1] - robot_.chassis_.getPosition()[1], robot_.crosshairs_.getTarget()[0] - robot_.chassis_.getPosition()[0]));\n-    angle_ = robot_.angleSensor_.getAngle() + robot_.crosshairs_.getAzimuth();\n-    finalHeading = angle_;\n-    moreThan = false;\n-    //if (angle_ > robot_.chassis_.getPosition()[2]) {\n-      if (angle_ > robot_.angleSensor_.getAngle()) {\n-      moreThan = true;\n-    }\n-    dps_ = 35;\n-    //distance = robot_.constants_.TESTBOT_TRACK_WIDTH;\n-  }\n-\n-  @Override\n-  public void execute() {\n-    if (!moreThan) {\n-      //if (robot_.chassis_.getPosition()[2] > angle_) {\n-      if (robot_.angleSensor_.getAngle() > angle_) {\n-        robot_.chassis_.setRotation(-dps_);  \n-      }\n-    } else {\n-      \n-      //if (robot_.chassis_.getPosition()[2] < angle_) {\n-      if (robot_.angleSensor_.getAngle() < angle_) {\n-        robot_.chassis_.setRotation(dps_);\n-      } \n-    }\n-  }\n-\n-  @Override\n-  public void end(boolean interrupted) {\n-  }\n-\n-  @Override\n-  public boolean isFinished() {\n-    if (moreThan) {\n-      //if (robot_.chassis_.getPosition()[2] >= finalHeading) {\n-      if (robot_.angleSensor_.getAngle() >= finalHeading) {\n-        return true;\n-      }\n-    } else { //rotation is negative\n-      if (robot_.angleSensor_.getAngle() <= finalHeading) {\n-      //if (robot_.chassis_.getPosition()[2] <= finalHeading) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-}"
  },
  {
    "sha": "e06474ab518983686a82ba3938db5087051a435f",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/MoveArc.java",
    "status": "removed",
    "additions": 0,
    "deletions": 54,
    "changes": 54,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/MoveArc.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/MoveArc.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/MoveArc.java?ref=32a20f41af423f2a6afe8487d648bf81d4472d2d",
    "patch": "@@ -1,54 +0,0 @@\n-/*----------------------------------------------------------------------------*/\n-/* Copyright (c) 2020 FRC Team 2077. All Rights Reserved.                     */\n-/* Open Source Software - may be modified and shared by FRC teams.            */\n-/*----------------------------------------------------------------------------*/\n-\n-package org.usfirst.frc.team2077.commands;\n-\n-import edu.wpi.first.wpilibj2.command.CommandBase;\n-import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;\n-import edu.wpi.first.wpilibj2.command.Subsystem;\n-\n-import static org.usfirst.frc.team2077.Robot.*;\n-import org.usfirst.frc.team2077.commands.Move2;\n-\n-\n-public class MoveArc extends SequentialCommandGroup {\n-\n-    private double distance_;\n-    private int rotation_;\n-    private boolean direction_;\n-    private double angleIncrememnt = 1;\n-    private double distanceIncrement;\n-\n-    private MoveArc(double radius, int rotation, Subsystem requirement) {\n-        addRequirements(requirement);\n-        distance_ = radius;\n-        direction_ = Math.signum(rotation) == 1;\n-        rotation_ = (int) (rotation * Math.signum(rotation));\n-        distanceIncrement = distance_ / (rotation_);\n-    }\n-\n-    private double[] getDistance(double distance, double angle) {\n-        double north = distance * Math.sin(angle/180*Math.PI);\n-        double east = distance * Math.cos(angle/180*Math.PI);\n-        return new double[] {north, east};\n-    }\n-\n-    @Override\n-    public void initialize() {\n-        for (int i=0; i < rotation_; i++) {\n-            double[] movements = getDistance(distanceIncrement, angleIncrememnt);\n-            addCommands(new Move2(movements[0], movements[1]));\n-        }\n-    }\n-\n-    @Override\n-    public void execute() {\n-    }\n-\n-    @Override\n-    public boolean isFinished() {\n-        return false;\n-    }\n-}"
  },
  {
    "sha": "7531d5066e915926066e18969afe6c75ac508ecd",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/MoveFudged.java",
    "status": "removed",
    "additions": 0,
    "deletions": 17,
    "changes": 17,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/MoveFudged.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/MoveFudged.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/MoveFudged.java?ref=32a20f41af423f2a6afe8487d648bf81d4472d2d",
    "patch": "@@ -1,17 +0,0 @@\n-package org.usfirst.frc.team2077.commands;\n-\n-import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n-\n-import org.usfirst.frc.team2077.commands.Move2;\n-import static org.usfirst.frc.team2077.Robot.*;\n-\n-import java.util.Arrays;\n-\n-\n-public class MoveFudged {\n-\n-    public MoveFudged(double north, double east, double rotation) {\n-        \n-    }\n-\n-}\n\\ No newline at end of file"
  },
  {
    "sha": "f4fbd27bc1bc03577e7b861ee35d1b4b0254fbce",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/PrimaryStickDrive3Axis.java",
    "status": "modified",
    "additions": 72,
    "deletions": 65,
    "changes": 137,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/commands/PrimaryStickDrive3Axis.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/commands/PrimaryStickDrive3Axis.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/PrimaryStickDrive3Axis.java?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -7,80 +7,87 @@\n \n import edu.wpi.first.wpilibj2.command.CommandBase;\n import edu.wpi.first.wpilibj2.command.CommandScheduler;\n-\n-import static org.usfirst.frc.team2077.Robot.*;\n-\n import org.usfirst.frc.team2077.DriveStation;\n \n+import static org.usfirst.frc.team2077.Robot.robot_;\n+\n public class PrimaryStickDrive3Axis extends CommandBase {\n+\tpublic PrimaryStickDrive3Axis() {\n+\t\taddRequirements(robot_.position_);\n+\t}\n+\n+\t@Override\n+\tpublic void execute() {\n+\n+\t\t// Speed limit as a percentage (0.0-1.0) of maximum wheel speed\n+\t\tdouble speedLimit = 1.0;\n+\t\t// Rotation limit as a percentage (0.0-1.0) of maximum wheel speed\n+\t\tdouble rotationLimit = 1.0; // 0.3;\n+\t\t// Acceleration/deceleration limit, in Gs\n+\t\t// Should be at or below the static coefficient of friction (CoF) between the wheels and the floor\n+\t\t// Too high allows wheelspin, too low is hazardous due to slow deceleration\n+\t\t//double accelerationLimit = 1.0;\n+\t\tdouble accelerationLimit = robot_.constants_.STARDESTROYER_ACCELERATION_G_LIMIT;\n+\t\tdouble decelerationLimit = robot_.constants_.STARDESTROYER_DECELERATION_G_LIMIT;\n+\n+\t\tif(robot_.analogSettings_ != null) {\n+\t\t\tdouble[] dialSetting = { // analog input dials, scaled to 0.0 - 1.0\n+\t\t\t\trobot_.analogSettings_.get(3),\n+\t\t\t\trobot_.analogSettings_.get(2),\n+\t\t\t\trobot_.analogSettings_.get(1)\n+\t\t\t};\n \n-  public PrimaryStickDrive3Axis() {\n-    addRequirements(robot_.position_);\n-  }\n+\t\t\tdouble speedLimitMin = 0.2;\n+\t\t\tdouble speedLimitMax = 1.0;\n+\t\t\tspeedLimit = speedLimitMin + (speedLimitMax - speedLimitMin) * dialSetting[0];\n \n-  @Override\n-  public void execute() {\n+\t\t\tdouble rotationLimitMin = 0.2;\n+\t\t\tdouble rotationLimitMax = 1.0;\n+\t\t\trotationLimit = rotationLimitMin + (rotationLimitMax - rotationLimitMin) * dialSetting[1];\n \n-    // Speed limit as a percentage (0.0-1.0) of maximum wheel speed\n-    double speedLimit = 1.0;\n-    // Rotation limit as a percentage (0.0-1.0) of maximum wheel speed\n-    double rotationLimit = 1.0; // 0.3;\n-    // Acceleration/deceleration limit, in Gs\n-    // Should be at or below the static coefficient of friction (CoF) between the wheels and the floor\n-    // Too high allows wheelspin, too low is hazardous due to slow deceleration\n-    //double accelerationLimit = 1.0;\n-    double accelerationLimit = robot_.constants_.STARDESTROYER_ACCELERATION_G_LIMIT; \n-    double decelerationLimit = robot_.constants_.STARDESTROYER_DECELERATION_G_LIMIT; \n+\t\t\tdouble accelerationLimitMin = .05;\n+\t\t\tdouble accelerationLimitMax = 0.5;\n+\t\t\taccelerationLimit = accelerationLimitMin +\n+\t\t\t\t\t\t\t\t(accelerationLimitMax - accelerationLimitMin) * (1 - dialSetting[2]); // reverse dial\n+\t\t\t//decelerationLimit = Math.max(accelerationLimit, .25); // don't let this go too low for safety\n+\t\t}\n+\t\tdouble throttle = 1 - robot_.driveStation_.secondaryStick_.getRawAxis(2);\n+//\t\tdouble throttle = 1;\n \n-    if (robot_.analogSettings_ != null) {\n-      double[] dialSetting = { // analog input dials, scaled to 0.0 - 1.0\n-        robot_.analogSettings_.get(3),\n-        robot_.analogSettings_.get(2),\n-        robot_.analogSettings_.get(1)\n-      };\n+\t\trobot_.chassis_.setGLimits(accelerationLimit, decelerationLimit);\n \n-      double speedLimitMin = 0.2;\n-      double speedLimitMax = 1.0;\n-      speedLimit = speedLimitMin + (speedLimitMax-speedLimitMin) * dialSetting[0];\n-     \n-      double rotationLimitMin = 0.2;\n-      double rotationLimitMax = 1.0;\n-      rotationLimit = rotationLimitMin + (rotationLimitMax-rotationLimitMin) * dialSetting[1];\n-      \n-      double accelerationLimitMin = .05;\n-      double accelerationLimitMax = 0.5;\n-      accelerationLimit = accelerationLimitMin + (accelerationLimitMax-accelerationLimitMin) * (1 - dialSetting[2]); // reverse dial\n-      //decelerationLimit = Math.max(accelerationLimit, .25); // don't let this go too low for safety\n-    }\n-    \n-    robot_.chassis_.setGLimits(accelerationLimit, decelerationLimit);\n+\t\t// TODO: Who handles rotation updates if another command owns robot_position_?\n+\t\t// TODO: Check joystick/drive capabilities and merge w/2-axis.\n+\t\tdouble north = DriveStation.adjustInputSensitivity(robot_.driveStation_.Flight.getY(), .025, 1);\n+\t\tdouble east = DriveStation.adjustInputSensitivity(robot_.driveStation_.Flight.getX(), .01, 1);\n+//\t\tnorth = Math.abs(north) >= Math.abs(east) ? north : 0;\n+//\t\teast = Math.abs(east) > Math.abs(north) ? east : 0;\n+//\t\t double north = DriveStation.adjustInputSensitivity(-robot_.driveStation_.primaryStick_.getY(), .2, 2.5);\n+//\t\t double east = DriveStation.adjustInputSensitivity(robot_.driveStation_.primaryStick_.getX(), .2, 2.5);\n \n-    // TODO: Who handles rotation updates if another command owns robot_position_?\n-    // TODO: Check joystick/drive capabilities and merge w/2-axis.\n-    double north = DriveStation.adjustInputSensitivity( robot_.driveStation_.Flight.getY(), .025, 1);\n-    double east = DriveStation.adjustInputSensitivity(robot_.driveStation_.Flight.getX(), .01, 1);\n-    // double north = DriveStation.adjustInputSensitivity(-robot_.driveStation_.primaryStick_.getY(), .2, 2.5);\n-    // double east = DriveStation.adjustInputSensitivity(robot_.driveStation_.primaryStick_.getX(), .2, 2.5);\n-    if (CommandScheduler.getInstance().requiring(robot_.heading_) != null) {\n-      // heading controlled elsewhere, just do position here\n-      //System.out.println(\" STICK(3): \" + north + \" \\t\" + east);\n-      robot_.chassis_.setVelocity01(north * speedLimit, east * speedLimit);\n-    }\n-    else {\n-      // heading controlled here, do both position and rotation\n-      // double clockwise = DriveStation.adjustInputSensitivity(robot_.driveStation_.primaryStick_.getRawAxis(4), .2, 2.5);\n-      double clockwise = DriveStation.adjustInputSensitivity(robot_.driveStation_.Flight.getRawAxis(4), .025, 1);\n-      //System.out.println(\" STICK(2): \" + north + \" \\t\" + east + \" \\t\" + clockwise);\n-      robot_.chassis_.setVelocity01(north * speedLimit, east * speedLimit, clockwise * rotationLimit);\n-    }\n-  }\n+\t\tif(CommandScheduler.getInstance().requiring(robot_.heading_) != null) { // we don't control heading\n+\t\t\t//System.out.println(\" STICK(3): \" + north + \" \\t\" + east);\n+\t\t\tnorth = 1;\n+\t\t\teast = 0;\n+\t\t\trobot_.chassis_.setVelocity01(north * speedLimit * throttle, east * speedLimit * throttle);\n+\t\t} else { // we control heading\n+\t\t\t// double clockwise = DriveStation.adjustInputSensitivity(robot_.driveStation_.primaryStick_.getRawAxis(2), .2, 2.5);\n+\t\t\tdouble clockwise = DriveStation.adjustInputSensitivity(robot_.driveStation_.Flight.getRawAxis(4), .025, 1);\n+\t\t\t// System.out.println(\" STICK(2): \" + north + \" \\t\" + east + \" \\t\" + clockwise);\n+\t\t\trobot_.chassis_.setVelocity01(\n+\t\t\t\tnorth * speedLimit * throttle,\n+\t\t\t\teast * speedLimit * throttle,\n+\t\t\t\tclockwise * rotationLimit * throttle\n+\t\t\t);\n+\t\t}\n+\t}\n \n-  @Override\n-  public void end(boolean interrupted) {\n-  }\n+\t@Override\n+\tpublic void end(boolean interrupted) {\n+\t}\n \n-  @Override\n-  public boolean isFinished() {\n-    return false;\n-  }\n+\t@Override\n+\tpublic boolean isFinished() {\n+\t\treturn false;\n+\t}\n }"
  },
  {
    "sha": "fa3caf32cfb8731b24acd38a9f91818038e891f2",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/RangeToCrosshairsOnce.java",
    "status": "removed",
    "additions": 0,
    "deletions": 36,
    "changes": 36,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/RangeToCrosshairsOnce.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/RangeToCrosshairsOnce.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/RangeToCrosshairsOnce.java?ref=32a20f41af423f2a6afe8487d648bf81d4472d2d",
    "patch": "@@ -1,36 +0,0 @@\n-/*----------------------------------------------------------------------------*/\n-/* Copyright (c) 2020 FRC Team 2077. All Rights Reserved.                     */\n-/* Open Source Software - may be modified and shared by FRC teams.            */\n-/*----------------------------------------------------------------------------*/\n-\n-package org.usfirst.frc.team2077.commands;\n-\n-import edu.wpi.first.wpilibj2.command.CommandBase;\n-\n-import static org.usfirst.frc.team2077.Robot.*;\n-\n-public class RangeToCrosshairsOnce extends CommandBase {\n-  \n-  public RangeToCrosshairsOnce() {\n-    this(robot_.constants_.UPPER_TARGET_HEIGHT);\n-  }\n-\n-  public RangeToCrosshairsOnce(double targetHeight) {\n-    addRequirements(robot_.launcher_);\n-  }\n-\n-  @Override\n-  public void initialize() {\n-    double range = robot_.crosshairs_.getRange();\n-    boolean ok = robot_.launcher_.setRangeUpper(range);\n-  }\n-\n-  @Override\n-  public void execute() {\n-  }\n-\n-  @Override\n-  public boolean isFinished() {\n-    return true;\n-  }\n-}"
  },
  {
    "sha": "91c99e158a498011363911e8d9b9be82aa6bf243",
    "filename": "src/main/java/org/usfirst/frc/team2077/commands/Rotate.java",
    "status": "removed",
    "additions": 0,
    "deletions": 51,
    "changes": 51,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/Rotate.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/32a20f41af423f2a6afe8487d648bf81d4472d2d/src/main/java/org/usfirst/frc/team2077/commands/Rotate.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/commands/Rotate.java?ref=32a20f41af423f2a6afe8487d648bf81d4472d2d",
    "patch": "@@ -1,51 +0,0 @@\n-/*----------------------------------------------------------------------------*/\n-/* Copyright (c) 2020 FRC Team 2077. All Rights Reserved.                     */\n-/* Open Source Software - may be modified and shared by FRC teams.            */\n-/*----------------------------------------------------------------------------*/\n-\n-package org.usfirst.frc.team2077.commands;\n-\n-import edu.wpi.first.wpilibj2.command.CommandBase;\n-import static org.usfirst.frc.team2077.Robot.*;\n-\n-public class Rotate extends CommandBase {\n-  private double rotation_;\n-  private double finalHeading_;\n-  private double remainingRotation_;\n-  private double fast_;\n-  private double slow_;\n-  private double deceleration_;\n-\n-  public Rotate(double rotation) {\n-    addRequirements(robot_.heading_);\n-    rotation_ = rotation;\n-  }\n-\n-  public void initialize() {\n-    finalHeading_ = robot_.chassis_.getPosition()[2] + rotation_; // target heading\n-    fast_ = robot_.chassis_.getMaximumVelocity()[2] * Math.signum(rotation_); // full speed in desired direction\n-    slow_ = robot_.chassis_.getMinimumVelocity()[2] * Math.signum(rotation_); // creep in desired direction to ensure target is reached\n-    deceleration_ = robot_.chassis_.getAccelerationLimits()[2][1]; // in degrees/second/second\n-  }\n-\n-  @Override\n-  public void execute() {\n-    // Run pedal to the metal until last possible moment, then slam on the brakes, letting DriveChassis handle acceleration and deceleration.\n-    double velocity = robot_.chassis_.getVelocityCalculated()[2]; // current velocity\n-    double stopRotation = .5 * velocity*velocity / deceleration_; // stopping distance at deceleration limit from physics\n-    double pad = Math.max(stopRotation*.05, Math.abs(velocity)*.04); // overestimate stopping distance by 5% or distance traveled in two .02 second control cycles\n-    robot_.chassis_.setRotation(Math.abs(remainingRotation_)>(stopRotation+pad) ? fast_ : slow_); // start slowing a bit early, creep to end\n-  }\n-\n-  @Override\n-  public void end(boolean interrupted) {\n-    robot_.chassis_.setRotation(0);\n-  }\n-\n-  @Override\n-  public boolean isFinished() {\n-    // done when remaining rotation goes past zero\n-    remainingRotation_ = finalHeading_ - robot_.chassis_.getPosition()[2];\n-    return Math.signum(remainingRotation_) != Math.signum(rotation_);\n-  }\n-}"
  },
  {
    "sha": "66bee72814777f63f7265c1f12473d44bc348bcd",
    "filename": "src/main/java/org/usfirst/frc/team2077/drivetrain/AbstractChassis.java",
    "status": "modified",
    "additions": 3,
    "deletions": 4,
    "changes": 7,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/drivetrain/AbstractChassis.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/drivetrain/AbstractChassis.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/drivetrain/AbstractChassis.java?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -12,7 +12,7 @@\n \n public abstract class AbstractChassis extends SubsystemBase implements DriveChassisIF {\n \n-    protected final DriveModuleIF[] driveModule_;\n+    public final DriveModuleIF[] driveModule_;\n     protected final double wheelbase_;\n     protected final double trackWidth_;\n     protected final double wheelRadius_;\n@@ -203,16 +203,15 @@ public void setGLimits(double accelerationG, double decelerationG) {\n \n     /**\n      * Limit set point change for linear or rotational set points based on velocity or acceleration constraints.\n-     * Depends on {@link #calculateTimeSinceLastUpdate} being called at the beginning of {@link #setVelocity}\n-     * and {@link #setsetRotation}.\n+     * Depends on {@linkplain timeSinceLastUpdate_} being called at the beginning of {@link #setVelocity}\n+     * and {@link #setRotation}.\n      * @param newV\n      * @param oldV\n      * @param maxV\n      * @param accelerationLimits\n      * @return Acceleration/range constrained set point.\n      */\n     protected double limit(double newV, double oldV, double maxV, double[] accelerationLimits) {\n-\n         boolean accelerating = Math.abs(newV) > Math.abs(oldV) && Math.signum(newV) == Math.signum(oldV);\n         double deltaLimit = (accelerating ? accelerationLimits[0] : accelerationLimits[1]) * timeSinceLastUpdate_; // always positive\n         double deltaRequested = newV - oldV;"
  },
  {
    "sha": "aa96f28edcdb0174b4571ffde525dac16b52ecae",
    "filename": "src/main/java/org/usfirst/frc/team2077/drivetrain/DifferentialChassis.java",
    "status": "modified",
    "additions": 0,
    "deletions": 4,
    "changes": 4,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/drivetrain/DifferentialChassis.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/drivetrain/DifferentialChassis.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/drivetrain/DifferentialChassis.java?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -102,10 +102,6 @@ protected void updatePosition() {\n         if (debug_) {\n             double[] pS = positionSet_.get();\n             double[] pM = positionMeasured_.get();\n-            System.out.print(\"POSITION:{\"\n-                + Math.round(pS[0]*100.)/100. + \"(\" + Math.round(pM[0]*100.)/100. + \"), \"\n-                + Math.round(pS[1]*100.)/100. + \"(\" + Math.round(pM[1]*100.)/100. + \"), \"\n-                + Math.round(pS[2]*10.)/10. + \"(\" + Math.round(pM[2]*10.)/10. + \")}\");\n         }\n     }\n     "
  },
  {
    "sha": "5f8362f03c03ee5cae9b35fe8da0642019a7e500",
    "filename": "src/main/java/org/usfirst/frc/team2077/drivetrain/MecanumChassis.java",
    "status": "modified",
    "additions": 260,
    "deletions": 213,
    "changes": 473,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/drivetrain/MecanumChassis.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/drivetrain/MecanumChassis.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/drivetrain/MecanumChassis.java?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -5,220 +5,267 @@\n \n package org.usfirst.frc.team2077.drivetrain;\n \n-import static org.usfirst.frc.team2077.Robot.*;\n+import org.usfirst.frc.team2077.Constants;\n+\n+import static org.usfirst.frc.team2077.Robot.robot_;\n \n public class MecanumChassis extends AbstractChassis {\n \n-    private final MecanumMath mecanumMath_;\n-\n-    /**\n-     * @param driveModule [4]\n-     * @param wheelbase\n-     * @param trackWidth\n-     * @param wheelRadius\n-     */\n-    public MecanumChassis(DriveModuleIF[] driveModule, double wheelbase, double trackWidth, double wheelRadius) {\n-    \n-        super(driveModule, wheelbase, trackWidth, wheelRadius);\n-\n-        mecanumMath_ = new MecanumMath(wheelbase_, trackWidth_, wheelRadius_, wheelRadius_, 1, 180/Math.PI);\n-\n-        // north/south speed conversion from 0-1 range to DriveModule maximum (inches/second)\n-        maximumSpeed_ = Math.min(\n-            Math.min(driveModule_[0].getMaximumSpeed(), driveModule_[1].getMaximumSpeed()),\n-            Math.min(driveModule_[2].getMaximumSpeed(), driveModule_[3].getMaximumSpeed()));     \n-        // rotation speed conversion from 0-1 range to DriveModule maximum (degrees/second)\n-        maximumRotation_ = mecanumMath_.forward(new double[] {-maximumSpeed_, -maximumSpeed_, maximumSpeed_, maximumSpeed_})[2];\n-        \n-        // lowest chassis speeds supportable by the drive modules\n-        minimumSpeed_ = maximumSpeed_ * .1; // TODO: Test and configure.\n-        minimumRotation_ = maximumRotation_ * .1;\n-\n-        System.out.println(getClass().getName() + \"MAXIMUM SPEED:\" + Math.round(maximumSpeed_*10.)/10. + \" IN/SEC MAXIMUM ROTATION:\" + Math.round(maximumRotation_*10.)/10. + \" DEG/SEC\");\n-        System.out.println(getClass().getName() + \"MINIMUM SPEED:\" + Math.round(minimumSpeed_*10.)/10. + \" IN/SEC MINIMUM ROTATION:\" + Math.round(minimumRotation_*10.)/10. + \" DEG/SEC\");\n-        double[][] a = getAccelerationLimits();\n-        System.out.println(getClass().getName() + \"ACCELERATION:\"\n-            + Math.round(a[0][0]*10.)/10. + \"/\" + Math.round(a[0][1]*10.)/10. + \"/\"\n-            + Math.round(a[1][0]*10.)/10. + \"/\" + Math.round(a[1][1]*10.)/10. + \"/\"\n-            + Math.round(a[2][0]*10.)/10. + \"/\" + Math.round(a[2][1]*10.)/10.);\n-    }\n-\n-    @Override\n-    public void setVelocity(double north, double east, double clockwise, double[][] accelerationLimits) {\n-        northSet_ = north;\n-        eastSet_ = east;\n-        clockwiseSet_ = clockwise;\n-        northAccelerationLimit_ = accelerationLimits[0];\n-        eastAccelerationLimit_ = accelerationLimits[1];\n-        rotationAccelerationLimit_ = accelerationLimits[2];\n-    }\n-\n-    @Override\n-    public void setVelocity(double north, double east, double[][] accelerationLimits) {\n-        northSet_ = north;\n-        eastSet_ = east;\n-        northAccelerationLimit_ = accelerationLimits[0];\n-        eastAccelerationLimit_ = accelerationLimits[1];\n-     }\n-\n-    @Override\n-    public void setRotation(double clockwise, double[][] accelerationLimits) {\n-        clockwiseSet_ = clockwise;\n-        rotationAccelerationLimit_ = accelerationLimits[2];\n-    }\n-\n-    @Override\n-    public double[] getVelocitySet() {\n-        return new double[] {northSet_, eastSet_, clockwiseSet_};\n-    }\n-\n-    @Override\n-    public double[] getVelocityCalculated() {\n-        return new double[] {north_, east_, clockwise_};\n-    }\n-\n-    @Override\n-    public double[] getVelocityMeasured() {\n-        return new double[] {velocityMeasured_[0], velocityMeasured_[1], velocityMeasured_[2]};\n-    }\n-\n-    @Override\n-    protected void updatePosition() {\n-\n-        // chassis velocity from internal set point\n-        velocitySet_ = getVelocityCalculated();\n-        // chassis velocity from motor/wheel measurements\n-        double[] w = {driveModule_[0].getVelocity(), driveModule_[1].getVelocity(), driveModule_[2].getVelocity(), driveModule_[3].getVelocity()};\n-        velocityMeasured_ = mecanumMath_.forward(w);\n-\n-        // TODO: E/W velocities are consistently lower than those calculated from wheel speeds.\n-        // TODO: Measure actual vs measured E/W distances and insert an adjustment factor here.\n-        // TODO: Put the adjustment factor in constants.\n-        velocitySet_[1] *= .65; // just a guess\n-        velocityMeasured_[1] *= .65; // just a guess\n-    \n-        // update position with motion since last update\n-        double dT = timeSinceLastUpdate_;\n-        positionSet_.moveRelative(velocitySet_[0] * dT, velocitySet_[1] * dT, velocitySet_[2] * dT);\n-        positionMeasured_.moveRelative(velocityMeasured_[0] * dT, velocityMeasured_[1] * dT, velocityMeasured_[2] * dT);\n-        if (robot_.angleSensor_ != null) { // TODO: Confirm AngleSensor is actually reading. Handle bench testing.\n-            double[] pS = positionSet_.get();\n-            double[] pM = positionMeasured_.get();\n-            pS[2] = pM[2] = robot_.angleSensor_.getAngle(); // TODO: conditional on gyro availability\n-            positionSet_.set(pS[0], pS[1], pS[2]);\n-            positionMeasured_.set(pM[0], pM[1], pM[2]);        \n-        }\n-\n-        if (debug_) {\n-            double[] pS = positionSet_.get();\n-            double[] pM = positionMeasured_.get();\n-            System.out.print(\"POSITION:{\"\n-                + Math.round(pS[0]*100.)/100. + \"(\" + Math.round(pM[0]*100.)/100. + \"), \"\n-                + Math.round(pS[1]*100.)/100. + \"(\" + Math.round(pM[1]*100.)/100. + \"), \"\n-                + Math.round(pS[2]*10.)/10. + \"(\" + Math.round(pM[2]*10.)/10. + \")}\");\n-        }\n-    }\n-\n-    @Override\n-    protected void updateDriveModules() {\n-        \n-        double[] v = getVelocityCalculated();\n-    //    if (debug_ ) System.out.print(\"CHASSIS: \" + Math.round(v[0]*10.)/10. + \" \" + Math.round(v[1]*10.)/10. + \" \" + Math.round(v[2]*10.)/10.);\n-    \n-        // compute motor speeds\n-        double[] w = mecanumMath_.inverse(v);\n-\n-        // scale all motors proportionally if any are out of range\n-        double max = 1;\n-        for (double ws : w) {\n-            max = Math.max(max, Math.abs(ws)/maximumSpeed_);\n-        }\n-\n-    //    if (debug_ ) System.out.print(\" WHEELS:\");\n-        for (int i = 0; i < w.length; i++) {\n-            double ws = w[i] / max;\n-            driveModule_[i].setVelocity(ws);\n-    //        if (debug_ ) System.out.print(\" \" + Math.round(100.*ws)/100. + \"(\" + Math.round(100.*driveModule_[i].getVelocity())/100. + \")\");\n-        }\n-        if (debug_ ) System.out.println(\" \" + this);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"V:\" + Math.round(north_*10.)/10. + \"/\" + Math.round(east_*10.)/10. + \"/\" + Math.round(clockwise_*10.)/10.\n-            + \" W:\" + driveModule_[0] + \"/\" + driveModule_[1] + \"/\" + driveModule_[2] + \"/\" + driveModule_[3];\n-    }\n-\n-    /**\n-     * Test code. May be run locally in VSCode. // TODO: Local execution broken due to Subsystem dependency.\n-     */\n-    public static void main(String[] argv) {\n-\n-        // DriveChassisIF chassis;\n-\n-        // DriveModuleIF[] module;\n-\n-        // double wheelbase;\n-        // double trackWidth;\n-        // double wheelRadius;\n-\n-        // chassis = new MecanumChassis(module = new DummyDriveModule[] {\n-        //     new DummyDriveModule(100),\n-        //     new DummyDriveModule(100),\n-        //     new DummyDriveModule(100),\n-        //     new DummyDriveModule(100)\n-        // },\n-        // wheelbase = 20,\n-        // trackWidth = 20,\n-        // wheelRadius = 3\n-        // );\n-\n-        // System.out.println();\n-\n-        // chassis.setVelocity01(.5, 0, 0);\n-        // System.out.println(chassis);\n-        // System.out.println();\n-\n-        // chassis.setVelocity01(0, .5, 0);\n-        // System.out.println(chassis);\n-        // System.out.println();\n-\n-        // chassis.setVelocity01(.5, .5, 0);\n-        // System.out.println(chassis);\n-        // System.out.println();\n-\n-        // chassis.setVelocity01(0, 0, .5);\n-        // System.out.println(chassis);\n-        // System.out.println();\n-\n-        // chassis.setVelocity01(.5, 0, .5);\n-        // System.out.println(chassis);\n-        // System.out.println();\n-\n-        // chassis.setVelocity01(0, .5, .5);\n-        // System.out.println(chassis);\n-        // System.out.println();\n-\n-        // chassis.setVelocity01(.5, .5, .5);\n-        // System.out.println(chassis);\n-        // System.out.println();\n-\n-        // chassis.setVelocity(0, 0, -360);\n-        // System.out.println(chassis);\n-        // System.out.println();\n-\n-        // chassis.setRotation(360);\n-        // System.out.println(chassis);\n-        // System.out.println();\n-\n-        // chassis.setVelocity(70, 70, 0);\n-        // System.out.println(chassis);\n-        // System.out.println();\n-\n-        // chassis.setVelocity(-50,-50, -90);\n-        // System.out.println(chassis);\n-        // System.out.println();\n-\n-\n-    }\n+\tprivate final MecanumMath mecanumMath_;\n+\n+\tprivate static DriveModuleIF[] buildDriveModule() {\n+\t\treturn new DriveModuleIF[]{\n+\t\t\tnew SparkNeoDriveModule(SparkNeoDriveModule.DrivePosition.FRONT_RIGHT),  // northeast (right front)\n+\t\t\tnew SparkNeoDriveModule(SparkNeoDriveModule.DrivePosition.BACK_RIGHT),  // southeast (right rear)\n+\t\t\tnew SparkNeoDriveModule(SparkNeoDriveModule.DrivePosition.BACK_LEFT),  // southwest (left rear)\n+\t\t\tnew SparkNeoDriveModule(SparkNeoDriveModule.DrivePosition.FRONT_LEFT)   // northwest (left front)\n+\t\t};\n+\t}\n+\n+\t/**\n+\t * @param driveModule [4]\n+\t * @param wheelbase\n+\t * @param trackWidth\n+\t * @param wheelRadius\n+\t */\n+\tpublic MecanumChassis(Constants constants_) {\n+\t\tsuper(\n+\t\t\tbuildDriveModule(),\n+\t\t\tconstants_.STARDESTROYER_WHEELBASE,\n+\t\t\tconstants_.STARDESTROYER_TRACK_WIDTH,\n+\t\t\tconstants_.STARDESTROYER_WHEEL_RADIUS\n+\t\t);\n+\n+\t\tmecanumMath_ = new MecanumMath(wheelbase_, trackWidth_, wheelRadius_, wheelRadius_, 1, 180 / Math.PI);\n+\n+\t\t// north/south speed conversion from 0-1 range to DriveModule maximum (inches/second)\n+\t\tmaximumSpeed_ = Math.min(\n+\t\t\tMath.min(driveModule_[0].getMaximumSpeed(), driveModule_[1].getMaximumSpeed()),\n+\t\t\tMath.min(driveModule_[2].getMaximumSpeed(), driveModule_[3].getMaximumSpeed())\n+\t\t);\n+\t\t// rotation speed conversion from 0-1 range to DriveModule maximum (degrees/second)\n+\t\tmaximumRotation_ = mecanumMath_.forward(new double[]{\n+\t\t\t-maximumSpeed_,\n+\t\t\t-maximumSpeed_,\n+\t\t\tmaximumSpeed_,\n+\t\t\tmaximumSpeed_\n+\t\t})[2];\n+\n+\t\t// lowest chassis speeds supportable by the drive modules\n+\t\tminimumSpeed_ = maximumSpeed_ * .1; // TODO: Test and configure.\n+\t\tminimumRotation_ = maximumRotation_ * .1;\n+\n+\t\tSystem.out.println(getClass().getName() +\n+\t\t\t\t\t\t   \"MAXIMUM SPEED:\" +\n+\t\t\t\t\t\t   Math.round(maximumSpeed_ * 10.) / 10. +\n+\t\t\t\t\t\t   \" IN/SEC MAXIMUM ROTATION:\" +\n+\t\t\t\t\t\t   Math.round(maximumRotation_ * 10.) / 10. +\n+\t\t\t\t\t\t   \" DEG/SEC\");\n+\t\tSystem.out.println(getClass().getName() +\n+\t\t\t\t\t\t   \"MINIMUM SPEED:\" +\n+\t\t\t\t\t\t   Math.round(minimumSpeed_ * 10.) / 10. +\n+\t\t\t\t\t\t   \" IN/SEC MINIMUM ROTATION:\" +\n+\t\t\t\t\t\t   Math.round(minimumRotation_ * 10.) / 10. +\n+\t\t\t\t\t\t   \" DEG/SEC\");\n+\t\tdouble[][] a = getAccelerationLimits();\n+\t\tSystem.out.println(getClass().getName() + \"ACCELERATION:\"\n+\t\t\t\t\t\t   + Math.round(a[0][0] * 10.) / 10. + \"/\" + Math.round(a[0][1] * 10.) / 10. + \"/\"\n+\t\t\t\t\t\t   + Math.round(a[1][0] * 10.) / 10. + \"/\" + Math.round(a[1][1] * 10.) / 10. + \"/\"\n+\t\t\t\t\t\t   + Math.round(a[2][0] * 10.) / 10. + \"/\" + Math.round(a[2][1] * 10.) / 10.);\n+\t}\n+\n+\t@Override\n+\tpublic void setVelocity(double north, double east, double clockwise, double[][] accelerationLimits) {\n+\t\tnorthSet_ = north;\n+\t\teastSet_ = east;\n+\t\tclockwiseSet_ = clockwise;\n+\t\tnorthAccelerationLimit_ = accelerationLimits[0];\n+\t\teastAccelerationLimit_ = accelerationLimits[1];\n+\t\trotationAccelerationLimit_ = accelerationLimits[2];\n+\t}\n+\n+\t@Override\n+\tpublic void setVelocity(double north, double east, double[][] accelerationLimits) {\n+\t\tnorthSet_ = north;\n+\t\teastSet_ = east;\n+\t\tnorthAccelerationLimit_ = accelerationLimits[0];\n+\t\teastAccelerationLimit_ = accelerationLimits[1];\n+\t}\n+\n+\t@Override\n+\tpublic void setRotation(double clockwise, double[][] accelerationLimits) {\n+\t\tclockwiseSet_ = clockwise;\n+\t\trotationAccelerationLimit_ = accelerationLimits[2];\n+\t}\n+\n+\t@Override\n+\tpublic double[] getVelocitySet() {\n+\t\treturn new double[]{northSet_, eastSet_, clockwiseSet_};\n+\t}\n+\n+\t@Override\n+\tpublic double[] getVelocityCalculated() {\n+\t\treturn new double[]{north_, east_, clockwise_};\n+\t}\n+\n+\t@Override\n+\tpublic double[] getVelocityMeasured() {\n+\t\treturn new double[]{velocityMeasured_[0], velocityMeasured_[1], velocityMeasured_[2]};\n+\t}\n+\n+\t@Override\n+\tprotected void updatePosition() {\n+\n+\t\t// chassis velocity from internal set point\n+\t\tvelocitySet_ = getVelocityCalculated();\n+\t\t// chassis velocity from motor/wheel measurements\n+\t\tdouble[] w = {\n+\t\t\tdriveModule_[0].getVelocity(),\n+\t\t\tdriveModule_[1].getVelocity(),\n+\t\t\tdriveModule_[2].getVelocity(),\n+\t\t\tdriveModule_[3].getVelocity()\n+\t\t};\n+\t\tvelocityMeasured_ = mecanumMath_.forward(w);\n+\n+\t\t// TODO: E/W velocities are consistently lower than those calculated from wheel speeds.\n+\t\t// TODO: Measure actual vs measured E/W distances and insert an adjustment factor here.\n+\t\t// TODO: Put the adjustment factor in constants.\n+\t\tvelocitySet_[1] *= .65; // just a guess\n+\t\tvelocityMeasured_[1] *= .65; // just a guess\n+\n+\t\t// update position with motion since last update\n+\t\tpositionSet_.moveRelative(\n+\t\t\tvelocitySet_[0] * timeSinceLastUpdate_,\n+\t\t\tvelocitySet_[1] * timeSinceLastUpdate_,\n+\t\t\tvelocitySet_[2] * timeSinceLastUpdate_\n+\t\t);\n+\t\tpositionMeasured_.moveRelative(\n+\t\t\tvelocityMeasured_[0] * timeSinceLastUpdate_,\n+\t\t\tvelocityMeasured_[1] * timeSinceLastUpdate_,\n+\t\t\tvelocityMeasured_[2] * timeSinceLastUpdate_\n+\t\t);\n+\t\tif(robot_.angleSensor_ != null) { // TODO: Confirm AngleSensor is actually reading. Handle bench testing.\n+\t\t\tdouble[] pS = positionSet_.get();\n+\t\t\tdouble[] pM = positionMeasured_.get();\n+\t\t\tpS[2] = pM[2] = robot_.angleSensor_.getAngle(); // TODO: conditional on gyro availability\n+\t\t\tpositionSet_.set(pS[0], pS[1], pS[2]);\n+\t\t\tpositionMeasured_.set(pM[0], pM[1], pM[2]);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void updateDriveModules() {\n+\n+\t\tdouble[] v = getVelocityCalculated();\n+\t\t//    if (debug_ ) System.out.print(\"CHASSIS: \" + Math.round(v[0]*10.)/10. + \" \" + Math.round(v[1]*10.)/10. + \" \" + Math.round(v[2]*10.)/10.);\n+\n+\t\t// compute motor speeds\n+\t\tdouble[] w = mecanumMath_.inverse(v);\n+\n+\t\t// scale all motors proportionally if any are out of range\n+\t\tdouble max = 1;\n+\t\tfor(double ws : w) {\n+\t\t\tmax = Math.max(max, Math.abs(ws) / maximumSpeed_);\n+\t\t}\n+\n+\t\t//    if (debug_ ) System.out.print(\" WHEELS:\");\n+\t\tfor(int i = 0; i < w.length; i++) {\n+\t\t\tdouble ws = w[i] / max;\n+\t\t\tdriveModule_[i].setVelocity(ws);\n+\t\t\t//        if (debug_ ) System.out.print(\" \" + Math.round(100.*ws)/100. + \"(\" + Math.round(100.*driveModule_[i].getVelocity())/100. + \")\");\n+\t\t}\n+\t\t// if (debug_ ) System.out.println(\" \" + this);\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"V:\" +\n+\t\t\t   Math.round(north_ * 10.) / 10. +\n+\t\t\t   \"/\" +\n+\t\t\t   Math.round(east_ * 10.) / 10. +\n+\t\t\t   \"/\" +\n+\t\t\t   Math.round(clockwise_ * 10.) / 10.\n+\t\t\t   +\n+\t\t\t   \" W:\" +\n+\t\t\t   driveModule_[0] +\n+\t\t\t   \"/\" +\n+\t\t\t   driveModule_[1] +\n+\t\t\t   \"/\" +\n+\t\t\t   driveModule_[2] +\n+\t\t\t   \"/\" +\n+\t\t\t   driveModule_[3];\n+\t}\n+\n+\t/**\n+\t * Test code. May be run locally in VSCode. // TODO: Local execution broken due to Subsystem dependency.\n+\t */\n+\tpublic static void main(String[] argv) {\n+\n+\t\t// DriveChassisIF chassis;\n+\n+\t\t// DriveModuleIF[] module;\n+\n+\t\t// double wheelbase;\n+\t\t// double trackWidth;\n+\t\t// double wheelRadius;\n+\n+\t\t// chassis = new MecanumChassis(module = new DummyDriveModule[] {\n+\t\t//     new DummyDriveModule(100),\n+\t\t//     new DummyDriveModule(100),\n+\t\t//     new DummyDriveModule(100),\n+\t\t//     new DummyDriveModule(100)\n+\t\t// },\n+\t\t// wheelbase = 20,\n+\t\t// trackWidth = 20,\n+\t\t// wheelRadius = 3\n+\t\t// );\n+\n+\t\t// System.out.println();\n+\n+\t\t// chassis.setVelocity01(.5, 0, 0);\n+\t\t// System.out.println(chassis);\n+\t\t// System.out.println();\n+\n+\t\t// chassis.setVelocity01(0, .5, 0);\n+\t\t// System.out.println(chassis);\n+\t\t// System.out.println();\n+\n+\t\t// chassis.setVelocity01(.5, .5, 0);\n+\t\t// System.out.println(chassis);\n+\t\t// System.out.println();\n+\n+\t\t// chassis.setVelocity01(0, 0, .5);\n+\t\t// System.out.println(chassis);\n+\t\t// System.out.println();\n+\n+\t\t// chassis.setVelocity01(.5, 0, .5);\n+\t\t// System.out.println(chassis);\n+\t\t// System.out.println();\n+\n+\t\t// chassis.setVelocity01(0, .5, .5);\n+\t\t// System.out.println(chassis);\n+\t\t// System.out.println();\n+\n+\t\t// chassis.setVelocity01(.5, .5, .5);\n+\t\t// System.out.println(chassis);\n+\t\t// System.out.println();\n+\n+\t\t// chassis.setVelocity(0, 0, -360);\n+\t\t// System.out.println(chassis);\n+\t\t// System.out.println();\n+\n+\t\t// chassis.setRotation(360);\n+\t\t// System.out.println(chassis);\n+\t\t// System.out.println();\n+\n+\t\t// chassis.setVelocity(70, 70, 0);\n+\t\t// System.out.println(chassis);\n+\t\t// System.out.println();\n+\n+\t\t// chassis.setVelocity(-50,-50, -90);\n+\t\t// System.out.println(chassis);\n+\t\t// System.out.println();\n+\n+\n+\t}\n }"
  },
  {
    "sha": "102a59c41eae88c45b5d9abe9a6ff0e00690c9da",
    "filename": "src/main/java/org/usfirst/frc/team2077/drivetrain/SparkNeoDriveModule.java",
    "status": "modified",
    "additions": 32,
    "deletions": 7,
    "changes": 39,
    "blob_url": "https://github.com/kettlemorainerc/stardestroyer/blob/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/drivetrain/SparkNeoDriveModule.java",
    "raw_url": "https://github.com/kettlemorainerc/stardestroyer/raw/15f4ade3868ff1b7923f57b51d35542b502f7518/src/main/java/org/usfirst/frc/team2077/drivetrain/SparkNeoDriveModule.java",
    "contents_url": "https://api.github.com/repos/kettlemorainerc/stardestroyer/contents/src/main/java/org/usfirst/frc/team2077/drivetrain/SparkNeoDriveModule.java?ref=15f4ade3868ff1b7923f57b51d35542b502f7518",
    "patch": "@@ -10,11 +10,13 @@\n \n public class SparkNeoDriveModule extends CANSparkMax implements DriveModuleIF {\n     public enum DrivePosition {\n-        FRONT_LEFT(1, false),\n         FRONT_RIGHT(2, true), //true\n+        BACK_RIGHT(3, true), //true,\n         BACK_LEFT(4, false),\n-        BACK_RIGHT(3, true) //true\n+        FRONT_LEFT(1, false)\n         ;\n+        private static final double gearRatio = 10.714;\n+        private static final double wheelRadius = 4;\n         public final int ID;\n         public final boolean INVERSE;\n         DrivePosition(int id, boolean inverse) {\n@@ -29,20 +31,23 @@\n     private double setPoint;\n     private final double circumference;\n     private final double maxRPM = robot_.constants_.STARDESTROYER_MOTOR_RPM_LIMIT;\n-    private final double gearRatio = 10.714; // 12.75\n+    private final double gearRatio; \n     private final boolean isReverse;\n+    private final double radius;\n \n     public SparkNeoDriveModule(final DrivePosition pos) {\n-        this(pos.ID, pos.INVERSE);\n+        this(pos.ID, pos.INVERSE, DrivePosition.gearRatio, DrivePosition.wheelRadius);\n     }\n     \n \n-    public SparkNeoDriveModule(final int deviceID, final boolean isReverse_) {\n+    public SparkNeoDriveModule(final int deviceID, final boolean isReverse_, double gearRatio,double radius) {\n         super(deviceID, MotorType.kBrushless);\n-        circumference = robot_.constants_.STARDESTROYER_WHEEL_RADIUS * 2 * Math.PI;\n+        circumference = radius * 2 * Math.PI;\n         pidController = this.getPIDController();\n         encoder = this.getEncoder();\n         isReverse = isReverse_;\n+        this.gearRatio = gearRatio;\n+        this.radius = radius;\n         pidController.setP(5e-5);\n         pidController.setI(1e-6);\n         pidController.setD(0);\n@@ -55,7 +60,7 @@ public SparkNeoDriveModule(final int deviceID, final boolean isReverse_) {\n     \n     @Override\n     public double getMaximumSpeed() {\n-        return (maxRPM/gearRatio) / (60 / (2 * Math.PI * robot_.constants_.STARDESTROYER_WHEEL_RADIUS));\n+        return (maxRPM/gearRatio) / (60 / (2 * Math.PI * radius));\n     }\n \n     /**\n@@ -69,13 +74,33 @@ public void setVelocity(final double velocity) {\n         if (setPoint > maxRPM) {\n             setPoint = maxRPM;\n         }\n+        setRPM(setPoint);\n+    }\n+\n+    public void setRPM(double rpm) {\n+        setPoint = Math.min(rpm, maxRPM);\n         if (isReverse) {\n             pidController.setReference(-setPoint, ControlType.kVelocity);\n         } else {\n             pidController.setReference(setPoint, ControlType.kVelocity);\n         }\n     }\n \n+    public double getRPM() {\n+        final double velocity = encoder.getVelocity();\n+        if (isReverse) {\n+            return -velocity;\n+        } else {\n+            return velocity;\n+        }\n+    }\n+\n+    public double getSetPoint() {\n+        if (isReverse) {\n+            return -setPoint;\n+        }\n+        return setPoint;\n+    }\n \n     /**\n      * Current velocity for this wheel."
  }
]
