[
  {
    "sha": "232a360ca0c878755dba1023abca3d64d0b97b86",
    "filename": "agent/agent-tooling/src/main/java/com/microsoft/applicationinsights/agent/internal/wasbootstrap/configuration/ConfigurationBuilder.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/microsoft/ApplicationInsights-Java/blob/d2670885207514f64b6ee8fb67c71c68af859113/agent/agent-tooling/src/main/java/com/microsoft/applicationinsights/agent/internal/wasbootstrap/configuration/ConfigurationBuilder.java",
    "raw_url": "https://github.com/microsoft/ApplicationInsights-Java/raw/d2670885207514f64b6ee8fb67c71c68af859113/agent/agent-tooling/src/main/java/com/microsoft/applicationinsights/agent/internal/wasbootstrap/configuration/ConfigurationBuilder.java",
    "contents_url": "https://api.github.com/repos/microsoft/ApplicationInsights-Java/contents/agent/agent-tooling/src/main/java/com/microsoft/applicationinsights/agent/internal/wasbootstrap/configuration/ConfigurationBuilder.java?ref=d2670885207514f64b6ee8fb67c71c68af859113",
    "patch": "@@ -303,7 +303,7 @@ private void warn(Logger logger) {\n         }\n     }\n \n-    static Configuration getConfigurationFromConfigFile(Path configPath, boolean strict) throws IOException {\n+    public static Configuration getConfigurationFromConfigFile(Path configPath, boolean strict) throws IOException{\n         try (InputStream in = Files.newInputStream(configPath)) {\n             Moshi moshi = MoshiBuilderFactory.createBuilderWithAdaptor();\n             JsonAdapter<Configuration> jsonAdapter = strict ? moshi.adapter(Configuration.class).failOnUnknown() :"
  },
  {
    "sha": "2f50e2c16703bbbf86ace949a3b9e6f8ee786b26",
    "filename": "core/src/main/java/com/microsoft/applicationinsights/internal/channel/common/TransmissionNetworkOutput.java",
    "status": "modified",
    "additions": 91,
    "deletions": 20,
    "changes": 111,
    "blob_url": "https://github.com/microsoft/ApplicationInsights-Java/blob/d2670885207514f64b6ee8fb67c71c68af859113/core/src/main/java/com/microsoft/applicationinsights/internal/channel/common/TransmissionNetworkOutput.java",
    "raw_url": "https://github.com/microsoft/ApplicationInsights-Java/raw/d2670885207514f64b6ee8fb67c71c68af859113/core/src/main/java/com/microsoft/applicationinsights/internal/channel/common/TransmissionNetworkOutput.java",
    "contents_url": "https://api.github.com/repos/microsoft/ApplicationInsights-Java/contents/core/src/main/java/com/microsoft/applicationinsights/internal/channel/common/TransmissionNetworkOutput.java?ref=d2670885207514f64b6ee8fb67c71c68af859113",
    "patch": "@@ -27,7 +27,6 @@\n import java.net.UnknownHostException;\n import java.util.concurrent.atomic.AtomicBoolean;\n import javax.annotation.Nullable;\n-\n import com.google.common.base.Preconditions;\n import com.microsoft.applicationinsights.TelemetryConfiguration;\n import com.microsoft.applicationinsights.customExceptions.FriendlyException;\n@@ -46,6 +45,11 @@\n import org.apache.http.util.EntityUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static com.microsoft.applicationinsights.internal.util.Sanitizer.sanitizeUri;\n \n /**\n  * The class is responsible for the actual sending of\n@@ -58,14 +62,17 @@\n public final class TransmissionNetworkOutput implements TransmissionOutputSync {\n \n     private static final Logger logger = LoggerFactory.getLogger(TransmissionNetworkOutput.class);\n-    private static final AtomicBoolean friendlyExceptionThrown = new AtomicBoolean();\n+    private static volatile AtomicBoolean friendlyExceptionThrown = new AtomicBoolean();\n+    private static volatile AtomicInteger  stampSpecificRedirects = new AtomicInteger(0);\n+    private static volatile AtomicReference<String> stampSpecificRedirectUrl = new AtomicReference(0);\n     private static final ExceptionStats networkExceptionStats = new ExceptionStats(\n             TransmissionNetworkOutput.class,\n             \"Unable to send telemetry to the ingestion service (telemetry will be stored to disk):\");\n \n     private static final String CONTENT_TYPE_HEADER = \"Content-Type\";\n     private static final String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n     private static final String RESPONSE_THROTTLING_HEADER = \"Retry-After\";\n+    private static final int MAX_STAMP_SPECIFIC_REDIRECTS = 10;\n \n     public static final String DEFAULT_SERVER_URI = \"https://dc.services.visualstudio.com/v2/track\";\n \n@@ -161,25 +168,72 @@ public boolean sendSync(Transmission transmission) {\n             Throwable ex = null;\n             Header retryAfterHeader = null;\n             try {\n-                // POST the transmission data to the endpoint\n-                request = createTransmissionPostRequest(transmission);\n-                httpClient.enhanceRequest(request);\n-                response = httpClient.sendPostRequest(request);\n-                HttpEntity respEntity = response.getEntity();\n-                code = response.getStatusLine().getStatusCode();\n-                reason = response.getStatusLine().getReasonPhrase();\n-                respString = EntityUtils.toString(respEntity);\n-                retryAfterHeader = response.getFirstHeader(RESPONSE_THROTTLING_HEADER);\n+                if(stampSpecificRedirects.get() > 0) {\n+                    // POST the transmission data to the endpoint\n+                    request = createTransmissionPostRequest(transmission,stampSpecificRedirectUrl.get());\n+                    httpClient.enhanceRequest(request);\n+                    response = httpClient.sendPostRequest(request);\n+                    HttpEntity respEntity = response.getEntity();\n+                    code = response.getStatusLine().getStatusCode();\n+                    reason = response.getStatusLine().getReasonPhrase();\n+                    respString = EntityUtils.toString(respEntity);\n+                    retryAfterHeader = response.getFirstHeader(RESPONSE_THROTTLING_HEADER);\n \n-                // After we reach our instant retry limit we should fail to second transmission output\n-                if (code > HttpStatus.SC_PARTIAL_CONTENT && transmission.getNumberOfSends() > this.transmissionPolicyManager.getMaxInstantRetries()) {\n-                    return false;\n-                } else if (code == HttpStatus.SC_OK) {\n-                    // If we've completed then clear the back off flags as the channel does not need\n-                    // to be throttled\n-                    transmissionPolicyManager.clearBackoff();\n-                    // Increment Success Counter\n-                    networkExceptionStats.recordSuccess();\n+                    // After we reach our instant retry limit we should fail to second transmission output\n+                    if (code > HttpStatus.SC_PARTIAL_CONTENT && transmission.getNumberOfSends() > this.transmissionPolicyManager.getMaxInstantRetries()) {\n+                        return false;\n+                    } else if (code == HttpStatus.SC_OK) {\n+                        // If we've completed then clear the back off flags as the channel does not need\n+                        // to be throttled\n+                        transmissionPolicyManager.clearBackoff();\n+                        // Increment Success Counter\n+                        networkExceptionStats.recordSuccess();\n+                    } else if (code == 308) { // There is no apache http status code for permanent redirect\n+                        URI redirectUrl = sanitizeUri(response.getFirstHeader(\"location\").getValue());\n+                        if(redirectUrl !=null && !redirectUrl.toString().equals(request.getURI().toString())) {\n+                            if(stampSpecificRedirects.getAndIncrement() < MAX_STAMP_SPECIFIC_REDIRECTS) {\n+                                request = createTransmissionPostRequest(transmission, redirectUrl.toString());\n+                                httpClient.enhanceRequest(request);\n+                                response = httpClient.sendPostRequest(request);\n+                                code = response.getStatusLine().getStatusCode();\n+                                if(code == HttpStatus.SC_OK) {\n+                                    stampSpecificRedirectUrl.set(redirectUrl.toString());\n+                                }\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    // POST the transmission data to the endpoint\n+                    request = createTransmissionPostRequest(transmission);\n+                    httpClient.enhanceRequest(request);\n+                    response = httpClient.sendPostRequest(request);\n+                    HttpEntity respEntity = response.getEntity();\n+                    code = response.getStatusLine().getStatusCode();\n+                    reason = response.getStatusLine().getReasonPhrase();\n+                    respString = EntityUtils.toString(respEntity);\n+                    retryAfterHeader = response.getFirstHeader(RESPONSE_THROTTLING_HEADER);\n+                    // After we reach our instant retry limit we should fail to second transmission output\n+                    if (code > HttpStatus.SC_PARTIAL_CONTENT && transmission.getNumberOfSends() > this.transmissionPolicyManager.getMaxInstantRetries()) {\n+                        return false;\n+                    } else if (code == HttpStatus.SC_OK) {\n+                        // If we've completed then clear the back off flags as the channel does not need\n+                        // to be throttled\n+                        transmissionPolicyManager.clearBackoff();\n+                        // Increment Success Counter\n+                        networkExceptionStats.recordSuccess();\n+                    } else if (code == 308) { // There is no apache http status code for permanent redirect\n+                        URI redirectUrl = sanitizeUri(response.getFirstHeader(\"location\").getValue());\n+                        if(redirectUrl !=null && !redirectUrl.toString().equals(request.getURI().toString())) {\n+                            request = createTransmissionPostRequest(transmission, redirectUrl.toString());\n+                            httpClient.enhanceRequest(request);\n+                            response = httpClient.sendPostRequest(request);\n+                            code = response.getStatusLine().getStatusCode();\n+                            if(code == HttpStatus.SC_OK) {\n+                                stampSpecificRedirects.getAndIncrement();\n+                                stampSpecificRedirectUrl.set(redirectUrl.toString());\n+                            }\n+                        }\n+                    }\n                 }\n                 return true;\n             } catch (ConnectionPoolTimeoutException e) {\n@@ -258,6 +312,23 @@ private HttpPost createTransmissionPostRequest(Transmission transmission) {\n         return request;\n     }\n \n+    /**\n+     * Generates the HTTP POST to send to the endpoint.\n+     *\n+     * @param transmission The transmission to send.\n+     * @return The completed {@link HttpPost} object\n+     */\n+    private HttpPost createTransmissionPostRequest(Transmission transmission, String endPointUrl) {\n+        HttpPost request = new HttpPost(endPointUrl);\n+        request.addHeader(CONTENT_TYPE_HEADER, transmission.getWebContentType());\n+        request.addHeader(CONTENT_ENCODING_HEADER, transmission.getWebContentEncodingType());\n+\n+        ByteArrayEntity bae = new ByteArrayEntity(transmission.getContent());\n+        request.setEntity(bae);\n+\n+        return request;\n+    }\n+\n     private String getIngestionEndpoint() {\n         if (serverUri != null) {\n             return serverUri;"
  }
]
