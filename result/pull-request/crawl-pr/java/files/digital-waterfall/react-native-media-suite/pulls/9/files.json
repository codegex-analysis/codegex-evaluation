[
  {
    "sha": "8bcb923cd64eea0981a6b2c0b98bb882301a17e4",
    "filename": ".gitignore",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/.gitignore",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/.gitignore",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/.gitignore?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -30,3 +30,5 @@ node_modules/\n .gradle\n local.properties\n *.log\n+.project\n+.settings"
  },
  {
    "sha": "34b58e98645e262764f72796122c6fd32970f46a",
    "filename": "android/build.gradle",
    "status": "modified",
    "additions": 34,
    "deletions": 11,
    "changes": 45,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/build.gradle",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/build.gradle",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/build.gradle?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -8,22 +8,26 @@ buildscript {\n         }\n     }\n     dependencies {\n-        classpath 'com.android.tools.build:gradle:3.0.1'\n+        classpath 'com.android.tools.build:gradle:3.4.2'\n     }\n }\n \n apply plugin: 'com.android.library'\n \n android {\n-    compileSdkVersion 26\n+    compileSdkVersion 28\n     buildToolsVersion '27.0.3'\n \n     defaultConfig {\n         minSdkVersion 16\n-        targetSdkVersion 26\n+        targetSdkVersion 28\n         versionCode 1\n         versionName \"1.0\"\n     }\n+    compileOptions {\n+        sourceCompatibility JavaVersion.VERSION_1_8\n+        targetCompatibility JavaVersion.VERSION_1_8\n+    }\n     buildTypes {\n         release {\n             minifyEnabled false\n@@ -32,13 +36,32 @@ android {\n     }\n }\n \n+repositories {\n+    maven {\n+        // As RN is not updated in jcenter anymore, we'll have to grab it from npm\n+        // Make sure you have installed the react-native npm package before compiling\n+        url \"/Users/husaynarrah/projects/ekoh/EkohOnline/node_modules/react-native/android\"\n+    }\n+\n+    jcenter()\n+    google()\n+    mavenCentral()\n+}\n+\n dependencies {\n-    compile fileTree(dir: 'libs', include: ['*.jar'])\n-    testCompile 'junit:junit:4.12'\n-    compile 'com.android.support:appcompat-v7:27.0.0'\n-    compile 'com.android.support:design:27.0.0'\n-    compile 'com.android.support:support-v4:27.0.0'\n-    compile 'com.android.support:support-v13:27.0.0'\n-    compile 'com.google.android.exoplayer:exoplayer:2.8.1'\n-    compile \"com.facebook.react:react-native:+\"\n+    implementation fileTree(dir: 'libs', include: ['*.jar'])\n+    testImplementation 'junit:junit:4.12'\n+//    implementation 'com.android.support:appcompat-v7:28.0.0'\n+//    implementation 'com.android.support:design:28.0.0'\n+//    implementation 'com.android.support:support-v4:28.0.0'\n+//    implementation 'com.android.support:support-v13:28.0.0'\n+\n+    implementation 'androidx.appcompat:appcompat:1.0.2'\n+    implementation 'androidx.annotation:annotation:1.0.2'\n+    implementation 'com.google.android.exoplayer:exoplayer:2.13.2'\n+    implementation 'com.google.android.exoplayer:extension-cronet:2.13.2'\n+\n+\n+    compileOnly 'org.checkerframework:checker-qual:3.8.0'\n+    implementation \"com.facebook.react:react-native:+\"\n }"
  },
  {
    "sha": "5465fec0ecadbf086fce0db92293c8f1d5f720ff",
    "filename": "android/gradle.properties",
    "status": "added",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/gradle.properties",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/gradle.properties",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/gradle.properties?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -0,0 +1,2 @@\n+android.enableJetifier=true\n+android.useAndroidX=true\n\\ No newline at end of file"
  },
  {
    "sha": "4eff329a4b1882e079c039438149842ab25e9e99",
    "filename": "android/gradle/wrapper/gradle-wrapper.properties",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/gradle/wrapper/gradle-wrapper.properties",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/gradle/wrapper/gradle-wrapper.properties",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/gradle/wrapper/gradle-wrapper.properties?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME\n distributionPath=wrapper/dists\n zipStoreBase=GRADLE_USER_HOME\n zipStorePath=wrapper/dists\n-distributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip\n+distributionUrl=https\\://services.gradle.org/distributions/gradle-5.1.1-all.zip"
  },
  {
    "sha": null,
    "filename": "android/gradlew",
    "status": "modified",
    "additions": 0,
    "deletions": 0,
    "changes": 0,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/gradlew",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/gradlew",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/gradlew?ref=026fc039361b2c709f5f6286e7098d6274246a57"
  },
  {
    "sha": "00a7edf358e2d034b8ea5dd9acddfd5a7952812e",
    "filename": "android/src/main/AndroidManifest.xml",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/AndroidManifest.xml",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/AndroidManifest.xml",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/src/main/AndroidManifest.xml?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -1,6 +1,8 @@\n <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n           package=\"za.co.digitalwaterfall.reactnativemediasuite\">\n \n+  <uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />\n+\n   <application android:allowBackup=\"true\"\n                android:label=\"@string/app_name\"\n                android:supportsRtl=\"true\""
  },
  {
    "sha": "967078a64ff829e1b15ac3b6ba924672417695bd",
    "filename": "android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/MediaDownloaderModule.java",
    "status": "modified",
    "additions": 46,
    "deletions": 388,
    "changes": 434,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/MediaDownloaderModule.java",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/MediaDownloaderModule.java",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/MediaDownloaderModule.java?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -3,94 +3,28 @@\n import android.content.Context;\n import android.content.SharedPreferences;\n import android.net.Uri;\n-import android.support.annotation.Nullable;\n-import android.util.Log;\n \n-import com.facebook.react.bridge.Arguments;\n-import com.facebook.react.bridge.Callback;\n-import com.facebook.react.bridge.Promise;\n-import com.facebook.react.bridge.ReactApplicationContext;\n-import com.facebook.react.bridge.ReactContextBaseJavaModule;\n-import com.facebook.react.bridge.ReactMethod;\n-import com.facebook.react.bridge.ReadableArray;\n-import com.facebook.react.bridge.WritableArray;\n-import com.facebook.react.bridge.WritableMap;\n-import com.facebook.react.modules.core.DeviceEventManagerModule;\n-import com.google.android.exoplayer2.C;\n-import com.google.android.exoplayer2.offline.DownloadAction;\n-import com.google.android.exoplayer2.offline.DownloadManager;\n-import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;\n-import com.google.android.exoplayer2.offline.FilteringManifestParser;\n-import com.google.android.exoplayer2.offline.ProgressiveDownloadAction;\n-import com.google.android.exoplayer2.source.ExtractorMediaSource;\n-import com.google.android.exoplayer2.source.MediaSource;\n-import com.google.android.exoplayer2.source.dash.DashMediaSource;\n-import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;\n-import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;\n-import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;\n-import com.google.android.exoplayer2.source.dash.offline.DashDownloadAction;\n-import com.google.android.exoplayer2.source.hls.HlsMediaSource;\n-import com.google.android.exoplayer2.source.hls.offline.HlsDownloadAction;\n-import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;\n-import com.google.android.exoplayer2.source.hls.playlist.RenditionKey;\n-import com.google.android.exoplayer2.source.smoothstreaming.DefaultSsChunkSource;\n-import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;\n-import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifestParser;\n-import com.google.android.exoplayer2.source.smoothstreaming.manifest.StreamKey;\n-import com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadAction;\n-import com.google.android.exoplayer2.upstream.DataSource;\n-import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;\n-import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;\n-import com.google.android.exoplayer2.upstream.FileDataSourceFactory;\n-import com.google.android.exoplayer2.upstream.HttpDataSource;\n-import com.google.android.exoplayer2.upstream.TransferListener;\n-import com.google.android.exoplayer2.upstream.cache.Cache;\n-import com.google.android.exoplayer2.upstream.cache.CacheDataSource;\n-import com.google.android.exoplayer2.upstream.cache.CacheDataSourceFactory;\n-import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;\n-import com.google.android.exoplayer2.upstream.cache.SimpleCache;\n-import com.google.android.exoplayer2.util.Util;\n-\n-import java.io.File;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import android.nfc.Tag;\n+import com.facebook.react.bridge.*;\n+import com.google.android.exoplayer2.offline.*;\n \n+import com.google.android.exoplayer2.util.Log;\n+import com.google.android.exoplayer2.util.Util;\n import za.co.digitalwaterfall.reactnativemediasuite.mediadownloader.downloader.DownloadTracker;\n+import za.co.digitalwaterfall.reactnativemediasuite.mediadownloader.downloader.DownloadUtil;\n \n-public class MediaDownloaderModule extends ReactContextBaseJavaModule {\n-\n-    private static final String DOWNLOAD_ACTION_FILE = \"actions\";\n-    private static final String DOWNLOAD_TRACKER_ACTION_FILE = \"tracked_actions\";\n-    private static final String DOWNLOAD_CONTENT_DIRECTORY = \"downloads\";\n-    private static final int MAX_SIMULTANEOUS_DOWNLOADS = 2;\n-    private static final DownloadAction.Deserializer[] DOWNLOAD_DESERIALIZERS =\n-            new DownloadAction.Deserializer[] {\n-                    DashDownloadAction.DESERIALIZER,\n-                    HlsDownloadAction.DESERIALIZER,\n-                    SsDownloadAction.DESERIALIZER,\n-                    ProgressiveDownloadAction.DESERIALIZER\n-            };\n-    private static final String TAG = \"DownloaderModule\";\n+import static za.co.digitalwaterfall.reactnativemediasuite.mediadownloader.downloader.DownloadUtil.TAG;\n \n-    protected String userAgent;\n+public class MediaDownloaderModule extends ReactContextBaseJavaModule {\n \n-    private File downloadDirectory;\n-    private Cache downloadCache;\n-    private DownloadManager downloadManager;\n-    private DownloadTracker downloadTracker;\n-    private SharedPreferences sharedPref;\n     private static MediaDownloaderModule instance;\n-\n     ReactApplicationContext ctx = null;\n+    private DownloadTracker downloadTracker;\n \n     public MediaDownloaderModule(ReactApplicationContext reactContext) {\n         super(reactContext);\n         ctx = reactContext;\n-        sharedPref = ctx.getSharedPreferences(TAG, Context.MODE_PRIVATE);\n-        userAgent = Util.getUserAgent(reactContext, \"MediaDownloader\");\n-        downloadManager = getDownloadManager();\n+        downloadTracker = DownloadUtil.getDownloadTracker(reactContext);\n     }\n \n     public static MediaDownloaderModule newInstance(ReactApplicationContext reactContext){\n@@ -100,272 +34,6 @@ public static MediaDownloaderModule newInstance(ReactApplicationContext reactCon\n         return instance;\n     }\n \n-    public DownloadManager getDownloadManager() {\n-        initDownloadManager();\n-        return downloadManager;\n-    }\n-\n-    public DownloadTracker getDownloadTracker() {\n-        initDownloadManager();\n-        return downloadTracker;\n-    }\n-\n-    private synchronized Cache getDownloadCache() {\n-        if (downloadCache == null) {\n-            File downloadContentDirectory = new File(getDownloadDirectory(), DOWNLOAD_CONTENT_DIRECTORY);\n-            downloadCache = new SimpleCache(downloadContentDirectory, new NoOpCacheEvictor());\n-        }\n-        return downloadCache;\n-    }\n-\n-    private File getDownloadDirectory() {\n-        if (downloadDirectory == null) {\n-            downloadDirectory = ctx.getExternalFilesDir(null);\n-            if (downloadDirectory == null) {\n-                downloadDirectory = ctx.getFilesDir();\n-            }\n-        }\n-        return downloadDirectory;\n-    }\n-\n-    private void mapDownloadID(String uuid, String videoUri){\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(uuid,videoUri);\n-        editor.commit();\n-    }\n-\n-    private void removeDownloadID(String uuid){\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.remove(uuid);\n-        editor.commit();\n-    }\n-\n-    private String getUri(String uuid){\n-        return sharedPref.getString(uuid, null);\n-    }\n-\n-    private String getDownloadID(String uri) {\n-        Map<String,?> keys = sharedPref.getAll();\n-        for(Map.Entry<String,?> entry : keys.entrySet()){\n-            if(entry.getValue().toString().equals(uri)){\n-                return entry.getKey();\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private void onDownloadProgressEvent(String downloadID, float progress){\n-        WritableMap params = Arguments.createMap();\n-        params.putString(\"downloadID\", downloadID);\n-        params.putDouble(\"percentComplete\", progress);\n-        ctx.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(\"onDownloadProgress\", params);\n-    }\n-\n-    private void onDownloadFinishedEvent(String downloadID, long downloadedBytes){\n-        WritableMap params = Arguments.createMap();\n-        params.putString(\"downloadID\", downloadID);\n-        params.putDouble(\"size\", downloadedBytes);\n-        //TODO: Add local path of downloaded file\n-        params.putString(\"downloadLocation\", \"N/A\");\n-        ctx.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(\"onDownloadFinished\", params);\n-    }\n-\n-    private void onDownloadCancelledEvent(String downloadID){\n-        WritableMap params = Arguments.createMap();\n-        params.putString(\"downloadID\", downloadID);\n-        ctx.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(\"onDownloadCancelled\", params);\n-    }\n-\n-    private void onDownloadStartedEvent(String downloadID){\n-        WritableMap params = Arguments.createMap();\n-        params.putString(\"downloadID\", downloadID);\n-        ctx.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(\"onDownloadStarted\", params);\n-    }\n-\n-    private void onDownloadErrorEvent(String downloadID, String errorType, String error){\n-        WritableMap params = Arguments.createMap();\n-        params.putString(\"error\", error);\n-        params.putString(\"errorType\", errorType);\n-        params.putString(\"downloadID\", downloadID);\n-        ctx.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(\"onDownloadError\", params);\n-    }\n-\n-    private synchronized void initDownloadManager() {\n-        if (downloadManager == null) {\n-            DownloaderConstructorHelper downloaderConstructorHelper =\n-                    new DownloaderConstructorHelper(\n-                            getDownloadCache(), buildHttpDataSourceFactory(/* listener= */ null));\n-            downloadManager =\n-                    new DownloadManager(\n-                            downloaderConstructorHelper,\n-                            MAX_SIMULTANEOUS_DOWNLOADS,\n-                            DownloadManager.DEFAULT_MIN_RETRY_COUNT,\n-                            new File(getDownloadDirectory(), DOWNLOAD_ACTION_FILE),\n-                            DOWNLOAD_DESERIALIZERS);\n-            downloadTracker =\n-                    new DownloadTracker(\n-                            /* context= */ ctx,\n-                            buildDataSourceFactory(/* listener= */ null),\n-                            new File(getDownloadDirectory(), DOWNLOAD_TRACKER_ACTION_FILE),\n-                            DOWNLOAD_DESERIALIZERS);\n-            downloadManager.addListener(new DownloadManager.Listener() {\n-                @Override\n-                public void onInitialized(DownloadManager downloadManager) {\n-\n-                }\n-\n-                @Override\n-                public void onTaskStateChanged(DownloadManager downloadManager, DownloadManager.TaskState taskState) {\n-                    Log.d(TAG, taskState.toString());\n-                    String downloadID = getDownloadID(taskState.action.uri.toString());\n-                    if (ctx.hasActiveCatalystInstance()) {\n-                        if (taskState.state == DownloadManager.TaskState.STATE_COMPLETED) {\n-                            if(taskState.action.isRemoveAction){\n-                                removeDownloadID(downloadID);\n-                            } else if(taskState.downloadPercentage == 100) {\n-                                if(downloadID != null){\n-                                    onDownloadProgressEvent(downloadID, 100);\n-                                    onDownloadFinishedEvent(downloadID, taskState.downloadedBytes);\n-                                    String extension = taskState.action.uri.toString().substring(taskState.action.uri.toString().lastIndexOf(\".\"));\n-                                    downloadTracker.addDownloadTracking(downloadID, taskState.action.uri,  extension);\n-                                }\n-                            }\n-                        } else if (taskState.state == DownloadManager.TaskState.STATE_STARTED) {\n-                            if(!taskState.action.isRemoveAction && taskState.downloadPercentage == -1) {\n-                                if(downloadID != null) {\n-                                    onDownloadStartedEvent(downloadID);\n-                                }\n-                            } else {\n-                                Log.d(TAG, \"Started remove action\");\n-                            }\n-                        } else if (taskState.state == DownloadManager.TaskState.STATE_CANCELED){\n-                            if(downloadID != null) {\n-                                onDownloadCancelledEvent(downloadID);\n-                                removeDownloadID(downloadID);\n-                            }\n-                        } else {\n-                            Log.d(TAG, \"Unused state change\");\n-                        }\n-                    }\n-                }\n-\n-                @Override\n-                public void onIdle(DownloadManager downloadManager) {\n-\n-                }\n-            });\n-            downloadTracker.addListener(new DownloadTracker.Listener() {\n-                @Override\n-                public void onDownloadsChanged() {\n-                    Log.d(TAG,\"onDownloadsChanged\");\n-                }\n-\n-            });\n-            downloadManager.startDownloads();\n-            downloadProgressUpdate();\n-        }\n-\n-    }\n-\n-    /** Returns a {@link HttpDataSource.Factory}. */\n-    public HttpDataSource.Factory buildHttpDataSourceFactory(\n-            TransferListener<? super DataSource> listener) {\n-        return new DefaultHttpDataSourceFactory(userAgent, listener);\n-    }\n-\n-    /** Returns a {@link DataSource.Factory}. */\n-    public DataSource.Factory buildDataSourceFactory(TransferListener<? super DataSource> listener) {\n-        DefaultDataSourceFactory upstreamFactory =\n-                new DefaultDataSourceFactory(ctx, listener, buildHttpDataSourceFactory(listener));\n-        return buildReadOnlyCacheDataSource(upstreamFactory, getDownloadCache());\n-    }\n-\n-    public void downloadProgressUpdate(){\n-        new Timer().scheduleAtFixedRate(new TimerTask(){\n-            @Override\n-            public void run(){\n-                if (ctx.hasActiveCatalystInstance()) {\n-                    DownloadManager.TaskState[] taskStates = downloadManager.getAllTaskStates();\n-                    for (int i = 0; i < taskStates.length; i++) {\n-                        if (taskStates[i].state == DownloadManager.TaskState.STATE_STARTED && !taskStates[i].action.isRemoveAction) {\n-                            String downloadID = getDownloadID(taskStates[i].action.uri.toString());\n-                            if(downloadID != null && taskStates[i].downloadPercentage > 0) {\n-                                onDownloadProgressEvent(downloadID, taskStates[i].downloadPercentage);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-            }\n-        },0,1000);\n-    }\n-\n-    private static CacheDataSourceFactory buildReadOnlyCacheDataSource(\n-            DefaultDataSourceFactory upstreamFactory, Cache cache) {\n-        return new CacheDataSourceFactory(\n-                cache,\n-                upstreamFactory,\n-                new FileDataSourceFactory(),\n-                /* cacheWriteDataSinkFactory= */ null,\n-                CacheDataSource.FLAG_IGNORE_CACHE_ON_ERROR,\n-                /* eventListener= */ null);\n-    }\n-\n-    private DownloadManager.TaskState getActiveTaskState(Uri videoUri){\n-        DownloadManager.TaskState[] taskStates = downloadManager.getAllTaskStates();\n-        for (int i = 0; i < taskStates.length; i++) {\n-            if(taskStates[i].action.uri.equals(videoUri)){\n-                return taskStates[i];\n-            }\n-        }\n-        return null;\n-    }\n-\n-    public MediaSource getDownloadedMediaSource(String uri){\n-        Uri videoUri = Uri.parse(uri);\n-        String ext = \"mpd\";\n-        return buildMediaSource(videoUri, ext);\n-    }\n-\n-    private List<?> getOfflineStreamKeys(Uri uri) {\n-        return downloadTracker.getOfflineStreamKeys(uri );\n-    }\n-\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private MediaSource buildMediaSource(Uri uri, @Nullable String overrideExtension) {\n-        @C.ContentType int type = Util.inferContentType(uri, overrideExtension);\n-        switch (type) {\n-            case C.TYPE_DASH:\n-                return new DashMediaSource.Factory(\n-                        new DefaultDashChunkSource.Factory(buildDataSourceFactory(null)),\n-                        buildDataSourceFactory(null))\n-                        .setManifestParser(\n-                                new FilteringManifestParser<>(\n-                                        new DashManifestParser(), (List<RepresentationKey>) getOfflineStreamKeys(uri)))\n-                        .createMediaSource(uri);\n-            case C.TYPE_SS:\n-                return new SsMediaSource.Factory(\n-                        new DefaultSsChunkSource.Factory(buildDataSourceFactory(null)),\n-                        buildDataSourceFactory(null))\n-                        .setManifestParser(\n-                                new FilteringManifestParser<>(\n-                                        new SsManifestParser(), (List<StreamKey>) getOfflineStreamKeys(uri)))\n-                        .createMediaSource(uri);\n-            case C.TYPE_HLS:\n-                return new HlsMediaSource.Factory(buildDataSourceFactory(null))\n-                        .setPlaylistParser(\n-                                new FilteringManifestParser<>(\n-                                        new HlsPlaylistParser(), (List<RenditionKey>) getOfflineStreamKeys(uri)))\n-                        .createMediaSource(uri);\n-            case C.TYPE_OTHER:\n-                return new ExtractorMediaSource.Factory(buildDataSourceFactory(null)).createMediaSource(uri);\n-            default: {\n-                throw new IllegalStateException(\"Unsupported type: \" + type);\n-            }\n-        }\n-    }\n-\n     @ReactMethod\n     public void downloadStreamWithBitRate(String videoUri, String downloadID, int bitRate){\n         //TODO: Implement bitrate\n@@ -376,59 +44,49 @@ public void downloadStreamWithBitRate(String videoUri, String downloadID, int bi\n     public void downloadStream(String uri, String downloadID){\n         final Uri videoUri = Uri.parse(uri);\n \n-        String mappedDownloadID = getDownloadID(uri);\n-        if(mappedDownloadID != null && downloadID != mappedDownloadID){\n-            onDownloadErrorEvent(downloadID,\"DUPLICATE_URI\",\"Duplicate asset for the uri found.\");\n-            return;\n-        }\n+        Boolean isDownloaded = downloadTracker.isDownloaded(downloadID);\n \n-        Boolean isDownloaded = downloadTracker.isDownloaded(videoUri);\n         if(isDownloaded){\n-            onDownloadErrorEvent(downloadID,\"ALREADY_DOWNLOADED\",\"The asset is already downloaded\");\n-            onDownloadProgressEvent(downloadID, 100);\n+            Log.i(TAG, \"is downloaded\");\n+            downloadTracker.onDownloadErrorEvent(downloadID,\"ALREADY_DOWNLOADED\",\"The asset is already downloaded\");\n+            downloadTracker.onDownloadProgressEvent(downloadID, 100);\n             return;\n         }\n \n-        DownloadManager.TaskState activeTaskState = getActiveTaskState(videoUri);\n-        if(activeTaskState == null){\n-            DownloadAction downloadAction = downloadTracker.getDownloadAction(downloadID, videoUri, uri.substring(uri.lastIndexOf(\".\")));\n-            mapDownloadID(downloadID, uri);\n-            downloadManager.handleAction(downloadAction);\n-            downloadManager.startDownloads();\n-        } else if (activeTaskState.state == DownloadManager.TaskState.STATE_STARTED) {\n-            onDownloadErrorEvent(downloadID, \"ALREADY_DOWNLOADED\", \"The asset is already downloading\");\n+        Download download = downloadTracker.getDownload(downloadID);\n+        if(download == null){\n+            downloadTracker.toggleDownload(downloadID, videoUri);\n+        } else if (download.state == Download.STATE_DOWNLOADING) {\n+            Log.i(TAG, \"already downloading\");\n+            downloadTracker.onDownloadErrorEvent(downloadID, \"ALREADY_DOWNLOADED\", \"The asset is already downloading\");\n         } else {\n             Log.d(TAG, \"Download not started\");\n         }\n     }\n \n     @ReactMethod\n     public void pauseDownload(final String downloadID){\n-        String uri = getUri(downloadID);\n-        if(uri == null){\n-            onDownloadErrorEvent(downloadID,\"NOT_FOUND\",\"Download does not exist.\");\n+        Download download = downloadTracker.getDownload(downloadID);\n+        if(download == null){\n+            downloadTracker.onDownloadErrorEvent(downloadID,\"NOT_FOUND\",\"Download does not exist.\");\n             return;\n         }\n-        Uri videoUri = Uri.parse(uri);\n-        DownloadManager.TaskState activeTaskState = getActiveTaskState(videoUri);\n-        if(activeTaskState != null && activeTaskState.state == DownloadManager.TaskState.STATE_STARTED) {\n-            //TODO: Develop pause functionality per video, currently all downloads will be paused\n-            downloadManager.stopDownloads();\n+\n+        if(download.state == Download.STATE_DOWNLOADING) {\n+            downloadTracker.pauseDownload(downloadID);\n         }\n     }\n \n     @ReactMethod\n     public void resumeDownload(final String downloadID){\n-        String uri = getUri(downloadID);\n-        if(uri == null){\n-            onDownloadErrorEvent(downloadID,\"NOT_FOUND\",\"Download does not exist.\");\n+        Download download = downloadTracker.getDownload(downloadID);\n+        if(download == null){\n+            downloadTracker.onDownloadErrorEvent(downloadID,\"NOT_FOUND\",\"Download does not exist.\");\n             return;\n         }\n-        Uri videoUri = Uri.parse(uri);\n-        DownloadManager.TaskState activeTaskState = getActiveTaskState(videoUri);\n-        if(activeTaskState != null && activeTaskState.state == DownloadManager.TaskState.STATE_QUEUED){\n-            //TODO: Develop start functionality per video, currently all downloads will be started\n-            downloadManager.startDownloads();\n+\n+        if(download.state == Download.STATE_QUEUED){\n+            downloadTracker.resumeDownload(downloadID);\n         }\n     }\n \n@@ -439,34 +97,34 @@ public void cancelDownload(final String downloadID){\n \n     @ReactMethod\n     public void deleteDownloadedStream(final String downloadID){\n-        String uri = getUri(downloadID);\n-        if(uri == null){\n-            onDownloadErrorEvent(downloadID,\"NOT_FOUND\",\"Download does not exist.\");\n+        Download download = downloadTracker.getDownload(downloadID);\n+        if(download == null){\n+            downloadTracker.onDownloadErrorEvent(downloadID,\"NOT_FOUND\",\"Download does not exist.\");\n             return;\n         }\n-        Uri videoUri = Uri.parse(uri);\n-        String extension = uri.substring(uri.lastIndexOf(\".\"));\n-        DownloadAction removeDownloadAction = downloadTracker.getRemoveDownloadAction(downloadID, videoUri, extension);\n-        downloadManager.handleAction(removeDownloadAction);\n-        downloadTracker.removeDownloadTracking(downloadID, videoUri, extension);\n-        onDownloadProgressEvent(downloadID,0);\n+        downloadTracker.deleteDownload(downloadID);\n+        downloadTracker.onDownloadProgressEvent(downloadID,0);\n     }\n \n     @ReactMethod\n     public void checkIfStillDownloaded(ReadableArray downloadIDs, final Promise promise) {\n         WritableArray isDownloadedDownloadIDs = Arguments.createArray();\n         for (int i=0; i<downloadIDs.size(); i++) {\n-            String stringUri = getUri(downloadIDs.getString(i));\n-            if (stringUri != null) {\n-                Uri uri = Uri.parse(stringUri);\n-                if (downloadTracker.isDownloaded(uri)) {\n-                    isDownloadedDownloadIDs.pushString(downloadIDs.getString(i));\n+            String stringId = downloadIDs.getString(i);\n+            if (stringId != null) {\n+                if (downloadTracker.isDownloaded(stringId)) {\n+                    isDownloadedDownloadIDs.pushString(stringId);\n                 }\n             }\n         }\n         promise.resolve(isDownloadedDownloadIDs);\n     }\n \n+    @ReactMethod\n+    public void updateDownloadCreds(String downloadID, String queryParam, String cookie) {\n+        downloadTracker.setDownloadCred(downloadID, queryParam, cookie);\n+    }\n+\n     @Override\n     public String getName(){\n         return \"MediaDownloader\";"
  },
  {
    "sha": "0e254b2273bb1a3a7a4f6836fedf48e31d48e873",
    "filename": "android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/DownloadCred.java",
    "status": "added",
    "additions": 12,
    "deletions": 0,
    "changes": 12,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/DownloadCred.java",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/DownloadCred.java",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/DownloadCred.java?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -0,0 +1,12 @@\n+package za.co.digitalwaterfall.reactnativemediasuite.mediadownloader.downloader;\n+\n+public class DownloadCred {\n+\n+    public String queryParams;\n+    public String cookie;\n+\n+    public DownloadCred(String queryParams, String cookie) {\n+        this.queryParams = queryParams;\n+        this.cookie = cookie;\n+    }\n+}"
  },
  {
    "sha": "f94eaf2cdcc4d43633a277efa9026bdb97016472",
    "filename": "android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/DownloadTracker.java",
    "status": "modified",
    "additions": 205,
    "deletions": 191,
    "changes": 396,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/DownloadTracker.java",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/DownloadTracker.java",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/DownloadTracker.java?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -1,278 +1,292 @@\n package za.co.digitalwaterfall.reactnativemediasuite.mediadownloader.downloader;\n \n import android.net.Uri;\n-import android.os.Handler;\n-import android.os.HandlerThread;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n import android.util.Log;\n-import android.widget.Toast;\n \n+import static com.google.android.exoplayer2.util.Assertions.checkNotNull;\n+\n+import com.facebook.react.bridge.Arguments;\n import com.facebook.react.bridge.ReactApplicationContext;\n-import com.google.android.exoplayer2.C;\n-import com.google.android.exoplayer2.offline.ActionFile;\n-import com.google.android.exoplayer2.offline.DownloadAction;\n-import com.google.android.exoplayer2.offline.DownloadHelper;\n-import com.google.android.exoplayer2.offline.DownloadManager;\n-import com.google.android.exoplayer2.offline.DownloadManager.TaskState;\n-import com.google.android.exoplayer2.offline.DownloadService;\n-import com.google.android.exoplayer2.offline.ProgressiveDownloadHelper;\n-import com.google.android.exoplayer2.offline.SegmentDownloadAction;\n-import com.google.android.exoplayer2.offline.TrackKey;\n-import com.google.android.exoplayer2.source.TrackGroup;\n-import com.google.android.exoplayer2.source.TrackGroupArray;\n-import com.google.android.exoplayer2.source.dash.offline.DashDownloadHelper;\n-import com.google.android.exoplayer2.source.hls.offline.HlsDownloadHelper;\n-import com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadHelper;\n-import com.google.android.exoplayer2.ui.DefaultTrackNameProvider;\n-import com.google.android.exoplayer2.ui.TrackNameProvider;\n-import com.google.android.exoplayer2.upstream.DataSource;\n-import com.google.android.exoplayer2.util.Util;\n-import java.io.File;\n+import com.facebook.react.bridge.WritableMap;\n+import com.facebook.react.modules.core.DeviceEventManagerModule;\n+import com.google.android.exoplayer2.DefaultRenderersFactory;\n+import com.google.android.exoplayer2.MediaItem;\n+import com.google.android.exoplayer2.offline.*;\n+import com.google.android.exoplayer2.upstream.HttpDataSource;\n+\n import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.HashMap;\n-import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n import java.util.concurrent.CopyOnWriteArraySet;\n \n-/**\n- * Tracks media that has been downloaded.\n- *\n- * <p>Tracked downloads are persisted using an {@link ActionFile}, however in a real application\n- * it's expected that state will be stored directly in the application's media database, so that it\n- * can be queried efficiently together with other information about the media.\n- */\n-public class DownloadTracker implements DownloadManager.Listener {\n+public class DownloadTracker {\n \n-    /** Listens for changes in the tracked downloads. */\n     public interface Listener {\n-\n-        /** Called when the tracked downloads changed. */\n         void onDownloadsChanged();\n     }\n \n     private static final String TAG = \"DownloadTracker\";\n \n     private final ReactApplicationContext context;\n-    private final DataSource.Factory dataSourceFactory;\n-    private final TrackNameProvider trackNameProvider;\n+    private final HttpDataSource.Factory httpDataSourceFactory;\n     private final CopyOnWriteArraySet<Listener> listeners;\n-    private final HashMap<Uri, DownloadAction> trackedDownloadStates;\n-    private final ActionFile actionFile;\n-    private final Handler actionFileWriteHandler;\n-\n-    public DownloadTracker(\n-            ReactApplicationContext context,\n-            DataSource.Factory dataSourceFactory,\n-            File actionFile,\n-            DownloadAction.Deserializer[] deserializers) {\n+    private final HashMap<String, Download> downloads;\n+    private final HashMap<String, DownloadCred> downloadCreds;\n+    private final DownloadIndex downloadIndex;\n+    @Nullable private StartDownloadHelper startDownloadHelper;\n+\n+    public DownloadTracker(ReactApplicationContext context, HttpDataSource.Factory httpDataSourceFactory, DownloadManager downloadManager) {\n         this.context = context;\n-        this.dataSourceFactory = dataSourceFactory;\n-        this.actionFile = new ActionFile(actionFile);\n-        trackNameProvider = new DefaultTrackNameProvider(context.getResources());\n+        this.httpDataSourceFactory = httpDataSourceFactory;\n         listeners = new CopyOnWriteArraySet<>();\n-        trackedDownloadStates = new HashMap<>();\n-        HandlerThread actionFileWriteThread = new HandlerThread(\"DownloadTracker\");\n-        actionFileWriteThread.start();\n-        actionFileWriteHandler = new Handler(actionFileWriteThread.getLooper());\n-        loadTrackedActions(deserializers);\n+        downloads = new HashMap<>();\n+        downloadCreds = new HashMap<>();\n+        downloadIndex = downloadManager.getDownloadIndex();\n+        downloadManager.addListener(new DownloadManagerListener());\n+        loadDownloads();\n+        downloadProgressUpdate();\n     }\n \n     public void addListener(Listener listener) {\n+        checkNotNull(listener);\n         listeners.add(listener);\n     }\n \n-    public void removeListener(Listener listener) {\n-        listeners.remove(listener);\n+    public void setDownloadCred(String downloadID, String queryParam, String cookie) {\n+        downloadCreds.put(downloadID, new DownloadCred(queryParam, cookie));\n     }\n \n-    public boolean isDownloaded(Uri uri) {\n-        return trackedDownloadStates.containsKey(uri);\n+    public DownloadCred getDownloadCred(String downloadID) {\n+        return downloadCreds.get(downloadID);\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    public <K> List<K> getOfflineStreamKeys(Uri uri) {\n-        if (!trackedDownloadStates.containsKey(uri)) {\n-            return Collections.emptyList();\n-        }\n-        DownloadAction action = trackedDownloadStates.get(uri);\n-        if (action instanceof SegmentDownloadAction) {\n-            return ((SegmentDownloadAction) action).keys;\n-        }\n-        return Collections.emptyList();\n+    public void onDownloadProgressEvent(String downloadID, float progress){\n+        WritableMap params = Arguments.createMap();\n+        params.putString(\"downloadID\", downloadID);\n+        params.putDouble(\"percentComplete\", progress);\n+        context.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(\"onDownloadProgress\", params);\n     }\n \n-    public DownloadAction addDownloadTracking(String name, Uri uri, String extension) {\n-        DownloadAction newDownloadAction =  getDownloadAction(name, uri, extension);\n-        startDownloadTracking(newDownloadAction);\n-        return newDownloadAction;\n+    public void onDownloadFinishedEvent(String downloadID, long downloadedBytes){\n+        WritableMap params = Arguments.createMap();\n+        params.putString(\"downloadID\", downloadID);\n+        params.putDouble(\"size\", downloadedBytes);\n+        //TODO: Add local path of downloaded file\n+        params.putString(\"downloadLocation\", \"N/A\");\n+        context.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(\"onDownloadFinished\", params);\n     }\n \n-    public DownloadAction removeDownloadTracking(String name, Uri uri, String extension) {\n-        DownloadAction newDownloadAction =  getDownloadAction(name, uri, extension);\n-        stopDownloadTracking(newDownloadAction);\n-        return newDownloadAction;\n+    public void onDownloadCancelledEvent(String downloadID){\n+        WritableMap params = Arguments.createMap();\n+        params.putString(\"downloadID\", downloadID);\n+        context.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(\"onDownloadCancelled\", params);\n     }\n \n-    //DownloadManager.Listener\n+    public void onDownloadStartedEvent(String downloadID){\n+        WritableMap params = Arguments.createMap();\n+        params.putString(\"downloadID\", downloadID);\n+        context.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(\"onDownloadStarted\", params);\n+    }\n \n-    @Override\n-    public void onInitialized(DownloadManager downloadManager) {\n-        // Do nothing.\n+    public void onDownloadErrorEvent(String downloadID, String errorType, String error){\n+        WritableMap params = Arguments.createMap();\n+        params.putString(\"error\", error);\n+        params.putString(\"errorType\", errorType);\n+        params.putString(\"downloadID\", downloadID);\n+        context.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(\"onDownloadError\", params);\n     }\n \n-    @Override\n-    public void onTaskStateChanged(DownloadManager downloadManager, TaskState taskState) {\n-        DownloadAction action = taskState.action;\n-        Uri uri = action.uri;\n-        if ((action.isRemoveAction && taskState.state == TaskState.STATE_COMPLETED)\n-                || (!action.isRemoveAction && taskState.state == TaskState.STATE_FAILED)) {\n-            // A download has been removed, or has failed. Stop tracking it.\n-            if (trackedDownloadStates.remove(uri) != null) {\n-                handleTrackedDownloadStatesChanged();\n+    public Download getCurrentDownload() {\n+        for (Download download : DownloadUtil.getDownloadManager(context).getCurrentDownloads()) {\n+            if(download.state == Download.STATE_DOWNLOADING) {\n+                return download;\n             }\n         }\n+        return null;\n+    }\n+\n+\n+    private void downloadProgressUpdate(){\n+        new Timer().scheduleAtFixedRate(new TimerTask(){\n+            @Override\n+            public void run(){\n+                if (context.hasActiveCatalystInstance()) {\n+                    for (Download download : DownloadUtil.getDownloadManager(context).getCurrentDownloads()) {\n+                        if(download != null && download.getPercentDownloaded() > 0) {\n+                            onDownloadProgressEvent(download.request.id, download.getPercentDownloaded());\n+                        }\n+                    }\n+                }\n+            }\n+        },0,1000);\n+    }\n+\n+    public void removeListener(Listener listener) {\n+        listeners.remove(listener);\n     }\n \n-    @Override\n-    public void onIdle(DownloadManager downloadManager) {\n-        // Do nothing.\n+    public boolean isDownloaded(String downloadId) {\n+        @Nullable Download download = downloads.get(downloadId);\n+        return download != null && download.state != Download.STATE_FAILED;\n     }\n \n-    // Internal methods\n \n-    private void loadTrackedActions(DownloadAction.Deserializer[] deserializers) {\n+    public Download getDownload(String downloadId) {\n         try {\n-            DownloadAction[] allActions = actionFile.load(deserializers);\n-            for (DownloadAction action : allActions) {\n-                trackedDownloadStates.put(action.uri, action);\n-            }\n+            return downloadIndex.getDownload(downloadId);\n         } catch (IOException e) {\n-            Log.e(TAG, \"Failed to load tracked actions\", e);\n+            e.printStackTrace();\n         }\n+        return null;\n     }\n \n-    private void handleTrackedDownloadStatesChanged() {\n-        for (Listener listener : listeners) {\n-            listener.onDownloadsChanged();\n-        }\n-        final DownloadAction[] actions = trackedDownloadStates.values().toArray(new DownloadAction[0]);\n-        actionFileWriteHandler.post(\n-                new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        try {\n-                            actionFile.store(actions);\n-                        } catch (IOException e) {\n-                            Log.e(TAG, \"Failed to store tracked actions\", e);\n-                        }\n-                    }\n-                });\n+\n+    private DownloadHelper getDownloadHelper(Uri uri, String queryParams) {\n+        return DownloadHelper.forMediaItem(context, MediaItem.fromUri(uri), new DefaultRenderersFactory(context), DownloadUtil.getResolvingFactory(httpDataSourceFactory, queryParams));\n     }\n \n-    private void startDownloadTracking(DownloadAction action) {\n-        if (trackedDownloadStates.containsKey(action.uri)) {\n-            // This content is already being downloaded. Do nothing.\n-            return;\n+\n+    public void toggleDownload(String downloadId, Uri uri) {\n+        @Nullable Download download = downloads.get(uri);\n+        if(download != null && download.state != Download.STATE_FAILED){\n+\n+        } else {\n+            if(startDownloadHelper != null) {\n+                startDownloadHelper.release();\n+            }\n+            String queryParams = downloadCreds.get(downloadId).queryParams;\n+            DownloadHelper downloadHelper = getDownloadHelper(uri, queryParams);\n+            startDownloadHelper = new StartDownloadHelper(downloadHelper, downloadId);\n         }\n-        Log.i(TAG, \"Started Tracking Download\");\n-        trackedDownloadStates.put(action.uri, action);\n-        handleTrackedDownloadStatesChanged();\n     }\n \n-    private void stopDownloadTracking(DownloadAction action) {\n-        if (trackedDownloadStates.containsKey(action.uri)) {\n-            Log.i(TAG, \"Stopped Tracking Download\");\n-            trackedDownloadStates.remove(action.uri);\n-            handleTrackedDownloadStatesChanged();\n-        }\n-        return;\n+    public void pauseDownload(String downloadId) {\n+        DownloadService.sendSetStopReason(context, NativeDownloadService.class, downloadId, Download.STATE_STOPPED, false);\n+    }\n \n+    public void resumeDownload(String downloadId) {\n+        DownloadService.sendSetStopReason(context, NativeDownloadService.class, downloadId, Download.STOP_REASON_NONE,/* foreground= */ false);\n     }\n \n+    public void deleteDownload(String downloadId) {\n+        DownloadService.sendRemoveDownload(context, NativeDownloadService.class, downloadId, false);\n+    }\n \n-    private void startServiceWithAction(DownloadAction action) {\n-        DownloadService.startWithAction(context, NativeDownloadService.class, action, false);\n+    private void loadDownloads() {\n+        try (DownloadCursor loadedDownloads = downloadIndex.getDownloads()) {\n+            while (loadedDownloads.moveToNext()) {\n+                Download download = loadedDownloads.getDownload();\n+                downloads.put(download.request.id, download);\n+            }\n+        } catch (IOException e) {\n+            Log.w(TAG, \"Failed to query downloads\", e);\n+        }\n     }\n \n-    private DownloadHelper getDownloadHelper(Uri uri, String extension) {\n-        int type = Util.inferContentType(uri, extension);\n-        switch (type) {\n-            case C.TYPE_DASH:\n-                return new DashDownloadHelper(uri, dataSourceFactory);\n-            case C.TYPE_SS:\n-                return new SsDownloadHelper(uri, dataSourceFactory);\n-            case C.TYPE_HLS:\n-                return new HlsDownloadHelper(uri, dataSourceFactory);\n-            case C.TYPE_OTHER:\n-                return new ProgressiveDownloadHelper(uri);\n-            default:\n-                throw new IllegalStateException(\"Unsupported type: \" + type);\n+    private class DownloadManagerListener implements DownloadManager.Listener {\n+\n+        @Override\n+        public void onDownloadChanged(\n+                @NonNull DownloadManager downloadManager,\n+                @NonNull Download download,\n+                @Nullable Exception finalException) {\n+            String downloadID = download.request.id;\n+\n+            Log.i(TAG, \"Download changed\");\n+\n+\n+            if(context.hasActiveCatalystInstance()){\n+                if(download.state == Download.STATE_COMPLETED){\n+                    Log.i(TAG, \"Download Complete\");\n+                    Log.i(TAG, Float.toString(download.getPercentDownloaded()));\n+                    if(download.getPercentDownloaded() == 100) {\n+                        if(downloadID != null){\n+                            onDownloadProgressEvent(downloadID, 100);\n+                            onDownloadFinishedEvent(downloadID, download.getBytesDownloaded());\n+                        }\n+                    }\n+                } else if (download.state == Download.STATE_DOWNLOADING){\n+                    if(downloadID != null) {\n+                        onDownloadStartedEvent(downloadID);\n+                    }\n+                } else if (download.state == Download.STATE_FAILED) {\n+                    if (downloadID != null) {\n+                        Log.e(TAG, \"failed\", finalException);\n+                        onDownloadErrorEvent(downloadID, \"UNEXPECTEDLY_CANCELLED\", finalException.toString());\n+                    }\n+\n+                }\n+            }\n+\n+            downloads.put(downloadID, download);\n+            for (Listener listener : listeners) {\n+                listener.onDownloadsChanged();\n+            }\n+        }\n+\n+        @Override\n+        public void onDownloadRemoved(\n+                @NonNull DownloadManager downloadManager, @NonNull Download download) {\n+            downloads.remove(download.request.id);\n+            for (Listener listener : listeners) {\n+                listener.onDownloadsChanged();\n+            }\n+        }\n+\n+        @Override\n+        public void onInitialized(DownloadManager downloadManager) {\n+            Log.i(TAG, \"All downloads restored\");\n         }\n     }\n \n-    private final class StartDownloadHelper\n-            implements DownloadHelper.Callback {\n+\n+    private final class StartDownloadHelper implements DownloadHelper.Callback {\n \n         private final DownloadHelper downloadHelper;\n-        private final String name;\n-        private final List<TrackKey> trackKeys;\n+        private final String contentId;\n+\n \n \n-        public StartDownloadHelper(\n-                DownloadHelper downloadHelper, String name) {\n+        public StartDownloadHelper(DownloadHelper downloadHelper,String contentId) {\n             this.downloadHelper = downloadHelper;\n-            this.name = name;\n-            trackKeys = new ArrayList<>();\n+            this.contentId = contentId;\n+            downloadHelper.prepare(this);\n         }\n \n-        public void prepare() {\n-            downloadHelper.prepare(this);\n+        public void release() {\n+            downloadHelper.release();\n         }\n \n \n         @Override\n         public void onPrepared(DownloadHelper helper) {\n-            for (int i = 0; i < downloadHelper.getPeriodCount(); i++) {\n-                TrackGroupArray trackGroups = downloadHelper.getTrackGroups(i);\n-                for (int j = 0; j < trackGroups.length; j++) {\n-                    TrackGroup trackGroup = trackGroups.get(j);\n-                    for (int k = 0; k < trackGroup.length; k++) {\n-                        trackKeys.add(new TrackKey(i, j, k));\n-                        //trackTitles.add(trackNameProvider.getTrackName(trackGroup.getFormat(k)));\n-                    }\n \n-                }\n-                if (!trackKeys.isEmpty()) {\n-                    Log.d(TAG, trackKeys.toString());\n-                    DownloadAction downloadAction =\n-                            downloadHelper.getDownloadAction(Util.getUtf8Bytes(name), trackKeys);\n-                    startDownloadTracking(downloadAction);\n-                }\n-\n-            }\n+            startDownload();\n+            release();\n         }\n \n-        @Override\n-        public void onPrepareError(DownloadHelper helper, IOException e) {\n-            Toast.makeText(\n-                    context.getApplicationContext(), \"Download start error\", Toast.LENGTH_LONG)\n-                    .show();\n+\n+        private void startDownload() {\n+            startDownload(buildDownloadRequest());\n         }\n-    }\n \n+        private void startDownload(DownloadRequest downloadRequest) {\n+            DownloadService.sendAddDownload(context, NativeDownloadService.class, downloadRequest, /* foreground= */ false);\n+        }\n \n-    public DownloadAction getDownloadAction(String name, Uri uri, String extension ){\n-        DownloadHelper downloadHelper = getDownloadHelper(uri, extension);\n-        List<TrackKey> trackKeys = new ArrayList<>();\n-        DownloadAction downloadAction =\n-                downloadHelper.getDownloadAction(Util.getUtf8Bytes(name), trackKeys);\n-        return downloadAction;\n-    }\n+        private DownloadRequest buildDownloadRequest() {\n+            return downloadHelper.getDownloadRequest(contentId, null);\n+        }\n \n-    public DownloadAction getRemoveDownloadAction(String name, Uri uri, String extension){\n-        DownloadAction removeAction =\n-                getDownloadHelper(uri, extension).getRemoveAction(Util.getUtf8Bytes(name));\n-        return removeAction;\n+        @Override\n+        public void onPrepareError(DownloadHelper helper, IOException e) {\n+            Log.e(TAG,\n+                    e instanceof DownloadHelper.LiveContentUnsupportedException ? \"Downloading live content unsupported\"\n+                            : \"Failed to start download\",\n+                    e);\n+        }\n     }\n-\n }\n\\ No newline at end of file"
  },
  {
    "sha": "646dccb8e492579cd470f6dfa431bb38eb5913d9",
    "filename": "android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/DownloadUtil.java",
    "status": "added",
    "additions": 236,
    "deletions": 0,
    "changes": 236,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/DownloadUtil.java",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/DownloadUtil.java",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/DownloadUtil.java?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -0,0 +1,236 @@\n+package za.co.digitalwaterfall.reactnativemediasuite.mediadownloader.downloader;\n+\n+import android.content.Context;\n+import android.net.Uri;\n+import android.util.Log;\n+import com.facebook.react.bridge.ReactApplicationContext;\n+import com.google.android.exoplayer2.database.DatabaseProvider;\n+import com.google.android.exoplayer2.database.ExoDatabaseProvider;\n+import com.google.android.exoplayer2.ext.cronet.CronetDataSource;\n+import com.google.android.exoplayer2.ext.cronet.CronetEngineWrapper;\n+import com.google.android.exoplayer2.offline.ActionFileUpgradeUtil;\n+import com.google.android.exoplayer2.offline.DefaultDownloadIndex;\n+import com.google.android.exoplayer2.offline.Download;\n+import com.google.android.exoplayer2.offline.DownloadManager;\n+import com.google.android.exoplayer2.ui.DownloadNotificationHelper;\n+import com.google.android.exoplayer2.upstream.*;\n+import com.google.android.exoplayer2.upstream.cache.Cache;\n+import com.google.android.exoplayer2.upstream.cache.CacheDataSource;\n+import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;\n+import com.google.android.exoplayer2.upstream.cache.SimpleCache;\n+import com.google.android.exoplayer2.util.Util;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.CookieHandler;\n+import java.net.CookieManager;\n+import java.net.CookiePolicy;\n+import java.util.concurrent.Executors;\n+\n+public class DownloadUtil {\n+\n+    public static final String DOWNLOAD_NOTIFICATION_CHANNEL_ID = \"download_channel\";\n+\n+    private static final boolean USE_CRONET_FOR_NETWORKING = true;\n+\n+\n+    public static final String TAG = \"DownloaderModule\";\n+    private static final String DOWNLOAD_ACTION_FILE = \"actions\";\n+    private static final String DOWNLOAD_TRACKER_ACTION_FILE = \"tracked_actions\";\n+    private static final String DOWNLOAD_CONTENT_DIRECTORY = \"downloads\";\n+\n+    private static final int MAX_SIMULTANEOUS_DOWNLOADS = 1;\n+\n+\n+    private static DataSource.@MonotonicNonNull Factory dataSourceFactory;\n+    private static HttpDataSource.@MonotonicNonNull Factory httpDataSourceFactory;\n+    private static @MonotonicNonNull DatabaseProvider databaseProvider;\n+    private static @MonotonicNonNull File downloadDirectory;\n+    private static @MonotonicNonNull Cache downloadCache;\n+    private static @MonotonicNonNull DownloadManager downloadManager;\n+    private static @MonotonicNonNull DownloadTracker downloadTracker;\n+    private static @MonotonicNonNull DownloadNotificationHelper downloadNotificationHelper;\n+\n+\n+    private static Uri resolveUri(Uri uri, String queryParams) {\n+        String resultPath = queryParams == null ? uri.toString() : String.format(\"%s%s\", uri.toString(), queryParams);\n+        return Uri.parse(resultPath);\n+    }\n+\n+    public static ResolvingDataSource.Factory getResolvingFactory(DataSource.Factory factory, String queryParams) {\n+        return new ResolvingDataSource.Factory(factory,\n+                (DataSpec dataSpec) -> {\n+\n+            DataSpec ds = dataSpec;\n+\n+            if(dataSpec.uri.getQuery() == null) {\n+                ds = dataSpec.withUri(resolveUri(dataSpec.uri, queryParams));\n+            }\n+\n+            Log.i(TAG, ds.uri.toString());\n+            return ds;\n+        });\n+    }\n+\n+    public static synchronized HttpDataSource.Factory getHttpDataSourceFactory(Context context) {\n+        if (httpDataSourceFactory == null) {\n+            String USER_AGENT = Util.getUserAgent(context, \"MediaDownloader\");\n+            if (USE_CRONET_FOR_NETWORKING) {\n+                context = context.getApplicationContext();\n+                CronetEngineWrapper cronetEngineWrapper =\n+                        new CronetEngineWrapper(context, USER_AGENT, /* preferGMSCoreCronet= */ false);\n+                httpDataSourceFactory =\n+                        new CronetDataSource.Factory(cronetEngineWrapper, Executors.newSingleThreadExecutor());\n+            } else {\n+                CookieManager cookieManager = new CookieManager();\n+                cookieManager.setCookiePolicy(CookiePolicy.ACCEPT_ORIGINAL_SERVER);\n+                CookieHandler.setDefault(cookieManager);\n+                httpDataSourceFactory = new DefaultHttpDataSource.Factory().setUserAgent(USER_AGENT);\n+            }\n+        }\n+        return httpDataSourceFactory;\n+    }\n+\n+\n+    /** Returns a {@link DataSource.Factory}. */\n+    public static synchronized DataSource.Factory getDataSourceFactory(Context context) {\n+        if (dataSourceFactory == null) {\n+            DefaultDataSourceFactory upstreamFactory =\n+                    new DefaultDataSourceFactory(context, getHttpDataSourceFactory(context));\n+            dataSourceFactory = buildReadOnlyCacheDataSource(upstreamFactory, getDownloadCache(context));\n+        }\n+        return dataSourceFactory;\n+    }\n+\n+    public static synchronized DownloadNotificationHelper getDownloadNotificationHelper(\n+            Context context) {\n+        if (downloadNotificationHelper == null) {\n+            downloadNotificationHelper =\n+                    new DownloadNotificationHelper(context, DOWNLOAD_NOTIFICATION_CHANNEL_ID);\n+        }\n+        return downloadNotificationHelper;\n+    }\n+\n+    public static synchronized DownloadManager getDownloadManager(Context context) {\n+        ensureDownloadManagerInitialized(context);\n+        return downloadManager;\n+    }\n+\n+    public static synchronized DownloadTracker getDownloadTracker(Context context) {\n+        ensureDownloadManagerInitialized(context);\n+        return downloadTracker;\n+    }\n+\n+    private static synchronized Cache getDownloadCache(Context context) {\n+        if (downloadCache == null) {\n+            File downloadContentDirectory =\n+                    new File(getDownloadDirectory(context), DOWNLOAD_CONTENT_DIRECTORY);\n+            downloadCache =\n+                    new SimpleCache(\n+                            downloadContentDirectory, new NoOpCacheEvictor(), getDatabaseProvider(context));\n+        }\n+        return downloadCache;\n+    }\n+\n+\n+    private static synchronized void ensureDownloadManagerInitialized(Context context) {\n+        if (downloadManager == null) {\n+            DefaultDownloadIndex downloadIndex = new DefaultDownloadIndex(getDatabaseProvider(context));\n+            upgradeActionFile(\n+                    context, DOWNLOAD_ACTION_FILE, downloadIndex, /* addNewDownloadsAsCompleted= */ false);\n+            upgradeActionFile(\n+                    context,\n+                    DOWNLOAD_TRACKER_ACTION_FILE,\n+                    downloadIndex,\n+                    /* addNewDownloadsAsCompleted= */ true);\n+\n+            HttpDataSource.Factory ds = getHttpDataSourceFactory(context);\n+\n+\n+            DataSource.Factory dataSource = () -> {\n+\n+                Log.i(TAG, \"Creating new datasource\");\n+\n+                HttpDataSource.Factory newDataSource = ds;\n+                if (downloadTracker != null) {\n+                    Download download = downloadTracker.getCurrentDownload();\n+                    if (download != null) {\n+                        String downloadID = download.request.id;\n+\n+                        if (downloadID != null) {\n+                            Log.i(TAG, download.request.id);\n+                            DownloadCred downloadCred = downloadTracker.getDownloadCred(downloadID);\n+                            String queryParams = downloadCred.queryParams;\n+\n+                            if (queryParams != null) {\n+                                return getResolvingFactory(newDataSource, queryParams).createDataSource();\n+                            }\n+                        }\n+                    }\n+                }\n+                return newDataSource.createDataSource();\n+            };\n+\n+\n+            downloadManager = new DownloadManager(context, getDatabaseProvider(context),getDownloadCache(context), dataSource, Executors.newFixedThreadPool(6));\n+            downloadManager.setMaxParallelDownloads(MAX_SIMULTANEOUS_DOWNLOADS);\n+            downloadManager.setMinRetryCount(5);\n+            downloadTracker =\n+                    new DownloadTracker(\n+                            (ReactApplicationContext) context,\n+                            ds,\n+                            downloadManager);\n+\n+            downloadTracker.addListener(() -> {\n+                Log.d(TAG,\"onDownloadsChanged\");\n+            });\n+\n+            downloadManager.resumeDownloads();\n+        }\n+    }\n+\n+    private static synchronized void upgradeActionFile(\n+            Context context,\n+            String fileName,\n+            DefaultDownloadIndex downloadIndex,\n+            boolean addNewDownloadsAsCompleted) {\n+        try {\n+            ActionFileUpgradeUtil.upgradeAndDelete(\n+                    new File(getDownloadDirectory(context), fileName),\n+                    /* downloadIdProvider= */ null,\n+                    downloadIndex,\n+                    /* deleteOnFailure= */ true,\n+                    addNewDownloadsAsCompleted);\n+        } catch (IOException e) {\n+            Log.e(TAG, \"Failed to upgrade action file: \" + fileName, e);\n+        }\n+    }\n+\n+    private static synchronized DatabaseProvider getDatabaseProvider(Context context) {\n+        if (databaseProvider == null) {\n+            databaseProvider = new ExoDatabaseProvider(context);\n+        }\n+        return databaseProvider;\n+    }\n+\n+\n+    private static File getDownloadDirectory(Context context) {\n+        if (downloadDirectory == null) {\n+            downloadDirectory = context.getExternalFilesDir(null);\n+            if (downloadDirectory == null) {\n+                downloadDirectory = context.getFilesDir();\n+            }\n+        }\n+        return downloadDirectory;\n+    }\n+\n+    private static CacheDataSource.Factory buildReadOnlyCacheDataSource(\n+            DataSource.Factory upstreamFactory, Cache cache) {\n+        return new CacheDataSource.Factory()\n+                .setCache(cache)\n+                .setUpstreamDataSourceFactory(upstreamFactory)\n+                .setCacheWriteDataSinkFactory(null)\n+                .setFlags(CacheDataSource.FLAG_IGNORE_CACHE_ON_ERROR);\n+    }\n+}"
  },
  {
    "sha": "e917f6ee028edf54930be222fad6d419c48725a6",
    "filename": "android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/NativeDownloadService.java",
    "status": "modified",
    "additions": 22,
    "deletions": 48,
    "changes": 70,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/NativeDownloadService.java",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/NativeDownloadService.java",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediadownloader/downloader/NativeDownloadService.java?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -2,35 +2,35 @@\n \n import android.app.Notification;\n \n+\n+import androidx.annotation.NonNull;\n+\n+import com.google.android.exoplayer2.offline.Download;\n import com.google.android.exoplayer2.offline.DownloadManager;\n import com.google.android.exoplayer2.offline.DownloadService;\n import com.google.android.exoplayer2.scheduler.PlatformScheduler;\n-import com.google.android.exoplayer2.ui.DownloadNotificationUtil;\n-import com.google.android.exoplayer2.util.NotificationUtil;\n import com.google.android.exoplayer2.util.Util;\n \n import za.co.digitalwaterfall.reactnativemediasuite.R;\n \n+import java.util.List;\n+\n+import static za.co.digitalwaterfall.reactnativemediasuite.mediadownloader.downloader.DownloadUtil.DOWNLOAD_NOTIFICATION_CHANNEL_ID;\n+\n /** A service for downloading media. */\n public class NativeDownloadService extends DownloadService {\n \n-    private static final String CHANNEL_ID = \"download_channel\";\n-    private static final int JOB_ID = 1;\n     private static final int FOREGROUND_NOTIFICATION_ID = 1;\n-    DownloadManager downloadManager;\n+    private static final int JOB_ID = 1;\n \n-    public NativeDownloadService(DownloadManager manager) {\n-        super(\n-                FOREGROUND_NOTIFICATION_ID,\n-                DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL,\n-                CHANNEL_ID,\n-                R.string.exo_download_notification_channel_name);\n-        downloadManager = manager;\n+    public NativeDownloadService() {\n+        super(FOREGROUND_NOTIFICATION_ID, DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL, DOWNLOAD_NOTIFICATION_CHANNEL_ID, R.string.exo_download_notification_channel_name, 0);\n     }\n \n     @Override\n+    @NonNull\n     protected DownloadManager getDownloadManager() {\n-        return downloadManager;\n+        return DownloadUtil.getDownloadManager(/* context= */ this);\n     }\n \n     @Override\n@@ -39,40 +39,14 @@ protected PlatformScheduler getScheduler() {\n     }\n \n     @Override\n-    protected Notification getForegroundNotification(DownloadManager.TaskState[] taskStates) {\n-        return DownloadNotificationUtil.buildProgressNotification(\n-                /* context= */ this,\n-                R.drawable.exo_controls_play,\n-                CHANNEL_ID,\n-                /* contentIntent= */ null,\n-                /* message= */ null,\n-                taskStates);\n-    }\n-\n-    @Override\n-    protected void onTaskStateChanged(DownloadManager.TaskState taskState) {\n-        if (taskState.action.isRemoveAction) {\n-            return;\n-        }\n-        Notification notification = null;\n-        if (taskState.state == DownloadManager.TaskState.STATE_COMPLETED) {\n-            notification =\n-                    DownloadNotificationUtil.buildDownloadCompletedNotification(\n-                            /* context= */ this,\n-                            R.drawable.exo_controls_play,\n-                            CHANNEL_ID,\n-                            /* contentIntent= */ null,\n-                            Util.fromUtf8Bytes(taskState.action.data));\n-        } else if (taskState.state == DownloadManager.TaskState.STATE_FAILED) {\n-            notification =\n-                    DownloadNotificationUtil.buildDownloadFailedNotification(\n-                            /* context= */ this,\n-                            R.drawable.exo_controls_play,\n-                            CHANNEL_ID,\n-                            /* contentIntent= */ null,\n-                            Util.fromUtf8Bytes(taskState.action.data));\n-        }\n-        int notificationId = FOREGROUND_NOTIFICATION_ID + 1 + taskState.taskId;\n-        NotificationUtil.setNotification(this, notificationId, notification);\n+    @NonNull\n+    protected Notification getForegroundNotification(@NonNull List<Download> downloads) {\n+        return DownloadUtil.getDownloadNotificationHelper(/* context= */ this)\n+                .buildProgressNotification(\n+                        /* context= */ this,\n+                        R.drawable.exo_controls_play,\n+                        /* contentIntent= */ null,\n+                        /* message= */ null,\n+                        downloads);\n     }\n }"
  },
  {
    "sha": "7f84904c184adb1a14e93bd8b2684cfa1497b10f",
    "filename": "android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/DataSourceUtil.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/DataSourceUtil.java",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/DataSourceUtil.java",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/DataSourceUtil.java?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -62,7 +62,7 @@ public static void setDefaultDataSourceFactory(DataSource.Factory factory) {\n \n     /** Returns a {@link HttpDataSource.Factory}. */\n     public static HttpDataSource.Factory buildHttpDataSourceFactory(\n-            TransferListener<? super DataSource> listener) {\n+            TransferListener listener) {\n         return new DefaultHttpDataSourceFactory(userAgent, listener);\n     }\n "
  },
  {
    "sha": "9c46ce30998c7220e85626d905e9d54f6afc6f43",
    "filename": "android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/ExoPlayerView.java",
    "status": "modified",
    "additions": 9,
    "deletions": 7,
    "changes": 16,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/ExoPlayerView.java",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/ExoPlayerView.java",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/ExoPlayerView.java?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -2,7 +2,7 @@\n \n import android.annotation.TargetApi;\n import android.content.Context;\n-import android.support.v4.content.ContextCompat;\n+import androidx.core.content.ContextCompat;\n import android.util.AttributeSet;\n import android.view.Gravity;\n import android.view.SurfaceView;\n@@ -20,8 +20,10 @@\n import com.google.android.exoplayer2.source.TrackGroupArray;\n import com.google.android.exoplayer2.text.Cue;\n import com.google.android.exoplayer2.text.TextRenderer;\n+import com.google.android.exoplayer2.text.TextOutput;\n import com.google.android.exoplayer2.trackselection.TrackSelectionArray;\n import com.google.android.exoplayer2.ui.SubtitleView;\n+import com.google.android.exoplayer2.video.VideoListener;\n \n import java.util.List;\n \n@@ -117,18 +119,18 @@ public void setPlayer(SimpleExoPlayer player) {\n             return;\n         }\n         if (this.player != null) {\n-            this.player.setTextOutput(null);\n-            this.player.setVideoListener(null);\n+            this.player.addTextOutput(null);\n+            this.player.addVideoListener(null);\n             this.player.removeListener(componentListener);\n             this.player.setVideoSurface(null);\n         }\n         this.player = player;\n         shutterView.setVisibility(VISIBLE);\n         if (player != null) {\n             setVideoView();\n-            player.setVideoListener(componentListener);\n+            player.addVideoListener(componentListener);\n             player.addListener(componentListener);\n-            player.setTextOutput(componentListener);\n+            player.addVideoListener(componentListener);\n         }\n     }\n \n@@ -186,8 +188,8 @@ private void updateForCurrentTrackSelections() {\n         shutterView.setVisibility(VISIBLE);\n     }\n \n-    private final class ComponentListener implements SimpleExoPlayer.VideoListener,\n-            TextRenderer.Output, ExoPlayer.EventListener {\n+    private final class ComponentListener implements VideoListener,\n+            TextOutput, ExoPlayer.EventListener {\n \n         // TextRenderer.Output implementation\n "
  },
  {
    "sha": "0d8e5adbafce7e2a616d8b3a311dbd13bbac3de1",
    "filename": "android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/RawResourceDataSourceFactory.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/RawResourceDataSourceFactory.java",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/RawResourceDataSourceFactory.java",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/RawResourceDataSourceFactory.java?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -15,6 +15,6 @@\n \n     @Override\n     public DataSource createDataSource() {\n-        return new RawResourceDataSource(context, null);\n+        return new RawResourceDataSource(context);\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "8227e8fc6f5c2e22d6a7ade5cb677ce233295d19",
    "filename": "android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/ReactMediaPlayerView.java",
    "status": "modified",
    "additions": 93,
    "deletions": 108,
    "changes": 201,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/ReactMediaPlayerView.java",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/ReactMediaPlayerView.java",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/ReactMediaPlayerView.java?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -23,35 +23,23 @@\n import com.facebook.react.bridge.WritableMap;\n import com.facebook.react.uimanager.ThemedReactContext;\n import com.google.android.exoplayer2.C;\n-import com.google.android.exoplayer2.DefaultLoadControl;\n import com.google.android.exoplayer2.ExoPlaybackException;\n import com.google.android.exoplayer2.ExoPlayer;\n-import com.google.android.exoplayer2.ExoPlayerFactory;\n import com.google.android.exoplayer2.Format;\n import com.google.android.exoplayer2.PlaybackParameters;\n import com.google.android.exoplayer2.Player;\n import com.google.android.exoplayer2.SimpleExoPlayer;\n import com.google.android.exoplayer2.Timeline;\n-import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;\n import com.google.android.exoplayer2.mediacodec.MediaCodecRenderer;\n+import com.google.android.exoplayer2.metadata.MetadataOutput;\n import com.google.android.exoplayer2.mediacodec.MediaCodecUtil;\n import com.google.android.exoplayer2.metadata.Metadata;\n-import com.google.android.exoplayer2.metadata.MetadataRenderer;\n import com.google.android.exoplayer2.source.BehindLiveWindowException;\n-import com.google.android.exoplayer2.source.ExtractorMediaSource;\n import com.google.android.exoplayer2.source.MediaSource;\n-import com.google.android.exoplayer2.source.MergingMediaSource;\n import com.google.android.exoplayer2.source.SingleSampleMediaSource;\n import com.google.android.exoplayer2.source.TrackGroupArray;\n-import com.google.android.exoplayer2.source.dash.DashMediaSource;\n-import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;\n-import com.google.android.exoplayer2.source.hls.HlsMediaSource;\n-import com.google.android.exoplayer2.source.smoothstreaming.DefaultSsChunkSource;\n-import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;\n-import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;\n import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;\n import com.google.android.exoplayer2.trackselection.MappingTrackSelector;\n-import com.google.android.exoplayer2.trackselection.TrackSelection;\n import com.google.android.exoplayer2.trackselection.TrackSelectionArray;\n import com.google.android.exoplayer2.upstream.DataSource;\n import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;\n@@ -70,7 +58,7 @@\n         LifecycleEventListener,\n         ExoPlayer.EventListener,\n         AudioManager.OnAudioFocusChangeListener,\n-        MetadataRenderer.Output {\n+        MetadataOutput {\n \n     private static final String TAG = \"ReactExoplayerView\";\n \n@@ -224,12 +212,9 @@ public void cleanUpResources() {\n \n     private void initializePlayer() {\n         if (player == null) {\n-            TrackSelection.Factory videoTrackSelectionFactory = new AdaptiveTrackSelection.Factory(BANDWIDTH_METER);\n-            trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);\n-            trackSelector.setParameters(trackSelector.buildUponParameters().setMaxVideoBitrate(maxBitRate == 0 ? Integer.MAX_VALUE : maxBitRate));\n-            player = ExoPlayerFactory.newSimpleInstance(getContext(), trackSelector, new DefaultLoadControl());\n+            player = new SimpleExoPlayer.Builder(getContext()).build();\n             player.addListener(this);\n-            player.setMetadataOutput(this);\n+            player.addMetadataOutput(this);\n             exoPlayerView.setPlayer(player);\n             setPlayWhenReady(!isPaused);\n             playerNeedsSource = true;\n@@ -238,88 +223,88 @@ private void initializePlayer() {\n             player.setPlaybackParameters(params);\n         }\n \n-        if (playerNeedsSource && srcUri != null) {\n-            ArrayList<MediaSource> mediaSourceList = buildTextSources();\n-            MediaSource videoSource = buildMediaSource(srcUri, extension);\n-            MediaSource mediaSource;\n-            if (mediaSourceList.size() == 0) {\n-                mediaSource = videoSource;\n-            } else {\n-                mediaSourceList.add(0, videoSource);\n-                MediaSource[] textSourceArray = mediaSourceList.toArray(\n-                        new MediaSource[mediaSourceList.size()]\n-                );\n-                mediaSource = new MergingMediaSource(textSourceArray);\n-            }\n-\n-            MediaDownloaderModule downloader = MediaDownloaderModule.newInstance(reactContext);\n-            mediaSource =  downloader.getDownloadedMediaSource(srcUri.toString());\n-\n-            boolean haveResumePosition = resumeWindow != C.INDEX_UNSET;\n-            if (haveResumePosition) {\n-                player.seekTo(resumeWindow, resumePosition);\n-            }\n-            player.prepare(mediaSource, !haveResumePosition, false);\n-            playerNeedsSource = false;\n-\n-            eventEmitter.loadStart();\n-            loadVideoStarted = true;\n-        }\n-    }\n-\n-    private MediaSource buildMediaSource(Uri uri, String overrideExtension) {\n-        int type = Util.inferContentType(!TextUtils.isEmpty(overrideExtension) ? \".\" + overrideExtension\n-                : uri.getLastPathSegment());\n-        switch (type) {\n-            case C.TYPE_SS:\n-                return new SsMediaSource(uri, buildDataSourceFactory(false),\n-                        new DefaultSsChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);\n-            case C.TYPE_DASH:\n-                return new DashMediaSource(uri, buildDataSourceFactory(false),\n-                        new DefaultDashChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);\n-            case C.TYPE_HLS:\n-                return new HlsMediaSource(uri, mediaDataSourceFactory, mainHandler, null);\n-            case C.TYPE_OTHER:\n-                return new ExtractorMediaSource(uri, mediaDataSourceFactory, new DefaultExtractorsFactory(),\n-                        mainHandler, null);\n-            default: {\n-                throw new IllegalStateException(\"Unsupported type: \" + type);\n-            }\n-        }\n-    }\n-\n-    private ArrayList<MediaSource> buildTextSources() {\n-        ArrayList<MediaSource> textSources = new ArrayList<>();\n-        if (textTracks == null) {\n-            return textSources;\n-        }\n-\n-        for (int i = 0; i < textTracks.size(); ++i) {\n-            ReadableMap textTrack = textTracks.getMap(i);\n-            String language = textTrack.getString(\"language\");\n-            String title = textTrack.hasKey(\"title\")\n-                    ? textTrack.getString(\"title\") : language + \" \" + i;\n-            Uri uri = Uri.parse(textTrack.getString(\"uri\"));\n-            MediaSource textSource = buildTextSource(title, uri, textTrack.getString(\"type\"),\n-                    language);\n-            if (textSource != null) {\n-                textSources.add(textSource);\n-            }\n-        }\n-        return textSources;\n-    }\n-\n-    private MediaSource buildTextSource(String title, Uri uri, String mimeType, String language) {\n-        Format textFormat = Format.createTextSampleFormat(title, mimeType, Format.NO_VALUE, language);\n-        return new SingleSampleMediaSource(uri, mediaDataSourceFactory, textFormat, C.TIME_UNSET);\n-    }\n+//        if (playerNeedsSource && srcUri != null) {\n+//            ArrayList<MediaSource> mediaSourceList = buildTextSources();\n+//            MediaSource videoSource = buildMediaSource(srcUri, extension);\n+//            MediaSource mediaSource;\n+//            if (mediaSourceList.size() == 0) {\n+//                mediaSource = videoSource;\n+//            } else {\n+//                mediaSourceList.add(0, videoSource);\n+//                MediaSource[] textSourceArray = mediaSourceList.toArray(\n+//                        new MediaSource[mediaSourceList.size()]\n+//                );\n+//                mediaSource = new MergingMediaSource(textSourceArray);\n+//            }\n+//\n+//            MediaDownloaderModule downloader = MediaDownloaderModule.newInstance(reactContext);\n+//            mediaSource =  downloader.getDownloadedMediaSource(srcUri.toString());\n+//\n+//            boolean haveResumePosition = resumeWindow != C.INDEX_UNSET;\n+//            if (haveResumePosition) {\n+//                player.seekTo(resumeWindow, resumePosition);\n+//            }\n+//            player.prepare(mediaSource, !haveResumePosition, false);\n+//            playerNeedsSource = false;\n+//\n+//            eventEmitter.loadStart();\n+//            loadVideoStarted = true;\n+//        }\n+    }\n+\n+//    private MediaSource buildMediaSource(Uri uri, String overrideExtension) {\n+//        int type = Util.inferContentType(!TextUtils.isEmpty(overrideExtension) ? \".\" + overrideExtension\n+//                : uri.getLastPathSegment());\n+//        switch (type) {\n+//            case C.TYPE_SS:\n+//                return new SsMediaSource(uri, buildDataSourceFactory(false),\n+//                        new DefaultSsChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);\n+//            case C.TYPE_DASH:\n+//                return new DashMediaSource(uri, buildDataSourceFactory(false),\n+//                        new DefaultDashChunkSource.Factory(mediaDataSourceFactory), mainHandler, null);\n+//            case C.TYPE_HLS:\n+//                return new HlsMediaSource(uri, mediaDataSourceFactory, mainHandler, null);\n+//            case C.TYPE_OTHER:\n+//                return new ExtractorMediaSource(uri, mediaDataSourceFactory, new DefaultExtractorsFactory(),\n+//                        mainHandler, null);\n+//            default: {\n+//                throw new IllegalStateException(\"Unsupported type: \" + type);\n+//            }\n+//        }\n+//    }\n+\n+//    private ArrayList<MediaSource> buildTextSources() {\n+//        ArrayList<MediaSource> textSources = new ArrayList<>();\n+//        if (textTracks == null) {\n+//            return textSources;\n+//        }\n+//\n+//        for (int i = 0; i < textTracks.size(); ++i) {\n+//            ReadableMap textTrack = textTracks.getMap(i);\n+//            String language = textTrack.getString(\"language\");\n+//            String title = textTrack.hasKey(\"title\")\n+//                    ? textTrack.getString(\"title\") : language + \" \" + i;\n+//            Uri uri = Uri.parse(textTrack.getString(\"uri\"));\n+//            MediaSource textSource = buildTextSource(title, uri, textTrack.getString(\"type\"),\n+//                    language);\n+//            if (textSource != null) {\n+//                textSources.add(textSource);\n+//            }\n+//        }\n+//        return textSources;\n+//    }\n+\n+//    private MediaSource buildTextSource(String title, Uri uri, String mimeType, String language) {\n+//        Format textFormat = Format.createTextSampleFormat(title, mimeType, Format.NO_VALUE, language);\n+//        return new SingleSampleMediaSource(uri, mediaDataSourceFactory, textFormat, C.TIME_UNSET);\n+//    }\n \n     private void releasePlayer() {\n         if (player != null) {\n             isPaused = player.getPlayWhenReady();\n             updateResumePosition();\n             player.release();\n-            player.setMetadataOutput(null);\n+            player.addMetadataOutput(null);\n             player = null;\n             trackSelector = null;\n         }\n@@ -594,19 +579,19 @@ public void onPlayerError(ExoPlaybackException e) {\n             Exception cause = e.getRendererException();\n             if (cause instanceof MediaCodecRenderer.DecoderInitializationException) {\n                 // Special case for decoder initialization failures.\n-                MediaCodecRenderer.DecoderInitializationException decoderInitializationException =\n-                        (MediaCodecRenderer.DecoderInitializationException) cause;\n-                if (decoderInitializationException.decoderName == null) {\n-                    if (decoderInitializationException.getCause() instanceof MediaCodecUtil.DecoderQueryException) {\n-                        errorString = \"Error queying Decoders\";\n-                    } else if (decoderInitializationException.secureDecoderRequired) {\n-                        errorString = \"Error No Secure Decoder\";\n-                    } else {\n-                        errorString = \"Error no Decoder\";\n-                    }\n-                } else {\n-                    errorString = \"Error Instantiating Decoder\";\n-                }\n+//                MediaCodecRenderer.DecoderInitializationException decoderInitializationException =\n+//                        (MediaCodecRenderer.DecoderInitializationException) cause;\n+//                if (decoderInitializationException.decoderName == null) {\n+//                    if (decoderInitializationException.getCause() instanceof MediaCodecUtil.DecoderQueryException) {\n+//                        errorString = \"Error queying Decoders\";\n+//                    } else if (decoderInitializationException.secureDecoderRequired) {\n+//                        errorString = \"Error No Secure Decoder\";\n+//                    } else {\n+//                        errorString = \"Error no Decoder\";\n+//                    }\n+//                } else {\n+//                    errorString = \"Error Instantiating Decoder\";\n+//                }\n             }\n         }\n         else if (e.type == ExoPlaybackException.TYPE_SOURCE) {"
  },
  {
    "sha": "f40cde41879934769ed1e9b4000db6144ca1cd93",
    "filename": "android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/ResizeMode.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/ResizeMode.java",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/ResizeMode.java",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/ResizeMode.java?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -1,6 +1,6 @@\n package za.co.digitalwaterfall.reactnativemediasuite.mediaplayer;\n \n-import android.support.annotation.IntDef;\n+import androidx.annotation.IntDef;\n \n import java.lang.annotation.Retention;\n "
  },
  {
    "sha": "6a8c9342dcd82c4a3424b84c2529a0d6c1be7b0e",
    "filename": "android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/VideoEventEmitter.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/VideoEventEmitter.java",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/VideoEventEmitter.java",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/android/src/main/java/za/co/digitalwaterfall/reactnativemediasuite/mediaplayer/VideoEventEmitter.java?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -1,6 +1,6 @@\n package za.co.digitalwaterfall.reactnativemediasuite.mediaplayer;\n \n-import android.support.annotation.StringDef;\n+import androidx.annotation.StringDef;\n import android.view.View;\n \n import com.facebook.react.bridge.Arguments;"
  },
  {
    "sha": "ee02545235a7a80fd9fda7fad8cd51665adef01a",
    "filename": "library/media-downloader/download-manager.js",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/digital-waterfall/react-native-media-suite/blob/026fc039361b2c709f5f6286e7098d6274246a57/library/media-downloader/download-manager.js",
    "raw_url": "https://github.com/digital-waterfall/react-native-media-suite/raw/026fc039361b2c709f5f6286e7098d6274246a57/library/media-downloader/download-manager.js",
    "contents_url": "https://api.github.com/repos/digital-waterfall/react-native-media-suite/contents/library/media-downloader/download-manager.js?ref=026fc039361b2c709f5f6286e7098d6274246a57",
    "patch": "@@ -300,6 +300,10 @@ class DownloadManager {\n         });\n     }\n \n+    updateDownloadCreds(downloadID, queryParam, cookie) {\n+        this.nativeDownloader.updateDownloadCreds(downloadID, queryParam, cookie);\n+    }\n+\n     persistDownload(download) {\n         storageService.setItem(this.tenant, download.downloadID, {\n             downloadID: download.downloadID,"
  }
]
