[
  {
    "sha": "3e2fa221a8f99adde11da308049340046388e6ca",
    "filename": "airbyte-workers/src/main/java/io/airbyte/workers/DefaultSyncWorker.java",
    "status": "modified",
    "additions": 22,
    "deletions": 0,
    "changes": 22,
    "blob_url": "https://github.com/airbytehq/airbyte/blob/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/DefaultSyncWorker.java",
    "raw_url": "https://github.com/airbytehq/airbyte/raw/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/DefaultSyncWorker.java",
    "contents_url": "https://api.github.com/repos/airbytehq/airbyte/contents/airbyte-workers/src/main/java/io/airbyte/workers/DefaultSyncWorker.java?ref=214ea9c799c617a21964a0f3404b44fa24416e40",
    "patch": "@@ -145,7 +145,29 @@ public StandardSyncOutput run(StandardSyncInput syncInput, Path jobRoot) throws\n \n   @Override\n   public void cancel() {\n+    LOGGER.info(\"Cancelling sync worker...\");\n     cancelled.set(true);\n+\n+    LOGGER.info(\"Cancelling source...\");\n+    try {\n+      source.cancel();\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+    }\n+\n+    LOGGER.info(\"Cancelling destination...\");\n+    try {\n+      destination.cancel();\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+    }\n+\n+    LOGGER.info(\"Cancelling normalization runner...\");\n+    try {\n+      normalizationRunner.close();\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+    }\n   }\n \n }"
  },
  {
    "sha": "d8001f4532474730bee9623dc1725ec2aa5c06d8",
    "filename": "airbyte-workers/src/main/java/io/airbyte/workers/protocols/Destination.java",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/airbytehq/airbyte/blob/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/protocols/Destination.java",
    "raw_url": "https://github.com/airbytehq/airbyte/raw/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/protocols/Destination.java",
    "contents_url": "https://api.github.com/repos/airbytehq/airbyte/contents/airbyte-workers/src/main/java/io/airbyte/workers/protocols/Destination.java?ref=214ea9c799c617a21964a0f3404b44fa24416e40",
    "patch": "@@ -40,4 +40,6 @@\n   @Override\n   void close() throws Exception;\n \n+  void cancel() throws Exception;\n+\n }"
  },
  {
    "sha": "92b9a299be275ef005c6021c64628b7beadac029",
    "filename": "airbyte-workers/src/main/java/io/airbyte/workers/protocols/Source.java",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/airbytehq/airbyte/blob/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/protocols/Source.java",
    "raw_url": "https://github.com/airbytehq/airbyte/raw/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/protocols/Source.java",
    "contents_url": "https://api.github.com/repos/airbytehq/airbyte/contents/airbyte-workers/src/main/java/io/airbyte/workers/protocols/Source.java?ref=214ea9c799c617a21964a0f3404b44fa24416e40",
    "patch": "@@ -39,4 +39,6 @@\n   @Override\n   void close() throws Exception;\n \n+  void cancel() throws Exception;\n+\n }"
  },
  {
    "sha": "0ec538af3791972c49e8d372b81c3b8f7fdb2781",
    "filename": "airbyte-workers/src/main/java/io/airbyte/workers/protocols/airbyte/DefaultAirbyteDestination.java",
    "status": "modified",
    "additions": 13,
    "deletions": 0,
    "changes": 13,
    "blob_url": "https://github.com/airbytehq/airbyte/blob/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/protocols/airbyte/DefaultAirbyteDestination.java",
    "raw_url": "https://github.com/airbytehq/airbyte/raw/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/protocols/airbyte/DefaultAirbyteDestination.java",
    "contents_url": "https://api.github.com/repos/airbytehq/airbyte/contents/airbyte-workers/src/main/java/io/airbyte/workers/protocols/airbyte/DefaultAirbyteDestination.java?ref=214ea9c799c617a21964a0f3404b44fa24416e40",
    "patch": "@@ -109,4 +109,17 @@ public void close() throws WorkerException, IOException {\n     }\n   }\n \n+  @Override\n+  public void cancel() throws Exception {\n+    LOGGER.info(\"Attempting to cancel destination process...\");\n+\n+    if (targetProcess == null) {\n+      LOGGER.info(\"Target process no longer exists, cancellation is a no-op.\");\n+    } else {\n+      LOGGER.info(\"Target process exists, cancelling...\");\n+      WorkerUtils.cancelProcess(targetProcess);\n+      LOGGER.info(\"Cancelled destination process!\");\n+    }\n+  }\n+\n }"
  },
  {
    "sha": "4e80b3f55492e2dfeab9ed297aaf51ada1c51e78",
    "filename": "airbyte-workers/src/main/java/io/airbyte/workers/protocols/airbyte/DefaultAirbyteSource.java",
    "status": "modified",
    "additions": 13,
    "deletions": 0,
    "changes": 13,
    "blob_url": "https://github.com/airbytehq/airbyte/blob/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/protocols/airbyte/DefaultAirbyteSource.java",
    "raw_url": "https://github.com/airbytehq/airbyte/raw/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/protocols/airbyte/DefaultAirbyteSource.java",
    "contents_url": "https://api.github.com/repos/airbytehq/airbyte/contents/airbyte-workers/src/main/java/io/airbyte/workers/protocols/airbyte/DefaultAirbyteSource.java?ref=214ea9c799c617a21964a0f3404b44fa24416e40",
    "patch": "@@ -113,4 +113,17 @@ public void close() throws Exception {\n     }\n   }\n \n+  @Override\n+  public void cancel() throws Exception {\n+    LOGGER.info(\"Attempting to cancel source process...\");\n+\n+    if (tapProcess == null) {\n+      LOGGER.info(\"Source process no longer exists, cancellation is a no-op.\");\n+    } else {\n+      LOGGER.info(\"Source process exists, cancelling...\");\n+      WorkerUtils.cancelProcess(tapProcess);\n+      LOGGER.info(\"Cancelled source process!\");\n+    }\n+  }\n+\n }"
  },
  {
    "sha": "e4bc4c4f0330a2b16d2ba422879aa85b32e38332",
    "filename": "airbyte-workers/src/main/java/io/airbyte/workers/protocols/airbyte/EmptyAirbyteSource.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/airbytehq/airbyte/blob/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/protocols/airbyte/EmptyAirbyteSource.java",
    "raw_url": "https://github.com/airbytehq/airbyte/raw/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/protocols/airbyte/EmptyAirbyteSource.java",
    "contents_url": "https://api.github.com/repos/airbytehq/airbyte/contents/airbyte-workers/src/main/java/io/airbyte/workers/protocols/airbyte/EmptyAirbyteSource.java?ref=214ea9c799c617a21964a0f3404b44fa24416e40",
    "patch": "@@ -56,4 +56,9 @@ public void close() throws Exception {\n     // no op.\n   }\n \n+  @Override\n+  public void cancel() throws Exception {\n+    // no op.\n+  }\n+\n }"
  },
  {
    "sha": "9dc292216a285fbaf7d306db555123209d86724b",
    "filename": "airbyte-workers/src/main/java/io/airbyte/workers/temporal/CancellationHandler.java",
    "status": "added",
    "additions": 73,
    "deletions": 0,
    "changes": 73,
    "blob_url": "https://github.com/airbytehq/airbyte/blob/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/temporal/CancellationHandler.java",
    "raw_url": "https://github.com/airbytehq/airbyte/raw/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/temporal/CancellationHandler.java",
    "contents_url": "https://api.github.com/repos/airbytehq/airbyte/contents/airbyte-workers/src/main/java/io/airbyte/workers/temporal/CancellationHandler.java?ref=214ea9c799c617a21964a0f3404b44fa24416e40",
    "patch": "@@ -0,0 +1,73 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Airbyte\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+\n+package io.airbyte.workers.temporal;\n+\n+import io.airbyte.workers.WorkerException;\n+import io.temporal.activity.Activity;\n+import io.temporal.activity.ActivityExecutionContext;\n+import io.temporal.client.ActivityCompletionException;\n+\n+public interface CancellationHandler {\n+\n+  void checkAndHandleCancellation(Runnable onCancellationCallback) throws WorkerException;\n+\n+  class TemporalCancellationHandler implements CancellationHandler {\n+\n+    final ActivityExecutionContext context;\n+\n+    public TemporalCancellationHandler() {\n+      context = Activity.getExecutionContext();\n+    }\n+\n+    /**\n+     * Check for a cancellation/timeout status and run any callbacks necessary to shut down underlying\n+     * processes. This method should generally be run frequently within an activity so a change in\n+     * cancellation status is respected. This will only be effective if the cancellation type for the\n+     * workflow is set to\n+     * {@link io.temporal.activity.ActivityCancellationType#WAIT_CANCELLATION_COMPLETED}; otherwise, the\n+     * activity will be killed automatically as part of cleanup without removing underlying processes.\n+     *\n+     * @param onCancellationCallback a runnable that will only run when Temporal indicates the activity\n+     *        should be killed (cancellation or timeout).\n+     * @throws WorkerException\n+     */\n+    @Override\n+    public void checkAndHandleCancellation(Runnable onCancellationCallback) throws WorkerException {\n+      try {\n+        // Heartbeat is somewhat misleading here. What it does is check the current Temporal activity's\n+        // context and\n+        // throw an exception if the sync has been cancelled or timed out. The input to this heartbeat\n+        // function\n+        // is available as a field in thrown ActivityCompletionExceptions, which we aren't using for now.\n+        context.heartbeat(null);\n+      } catch (ActivityCompletionException e) {\n+        onCancellationCallback.run();\n+        throw new WorkerException(\"Worker cleaned up after exception\", e);\n+      }\n+    }\n+\n+  }\n+\n+}"
  },
  {
    "sha": "21514e7ab713b0f8ee90349e46c211a857b3751c",
    "filename": "airbyte-workers/src/main/java/io/airbyte/workers/temporal/CheckConnectionWorkflow.java",
    "status": "modified",
    "additions": 21,
    "deletions": 3,
    "changes": 24,
    "blob_url": "https://github.com/airbytehq/airbyte/blob/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/temporal/CheckConnectionWorkflow.java",
    "raw_url": "https://github.com/airbytehq/airbyte/raw/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/temporal/CheckConnectionWorkflow.java",
    "contents_url": "https://api.github.com/repos/airbytehq/airbyte/contents/airbyte-workers/src/main/java/io/airbyte/workers/temporal/CheckConnectionWorkflow.java?ref=214ea9c799c617a21964a0f3404b44fa24416e40",
    "patch": "@@ -24,11 +24,13 @@\n \n package io.airbyte.workers.temporal;\n \n+import io.airbyte.commons.functional.CheckedSupplier;\n import io.airbyte.config.StandardCheckConnectionInput;\n import io.airbyte.config.StandardCheckConnectionOutput;\n import io.airbyte.scheduler.models.IntegrationLauncherConfig;\n import io.airbyte.scheduler.models.JobRunConfig;\n import io.airbyte.workers.DefaultCheckConnectionWorker;\n+import io.airbyte.workers.Worker;\n import io.airbyte.workers.process.AirbyteIntegrationLauncher;\n import io.airbyte.workers.process.IntegrationLauncher;\n import io.airbyte.workers.process.ProcessBuilderFactory;\n@@ -40,6 +42,7 @@\n import io.temporal.workflow.WorkflowMethod;\n import java.nio.file.Path;\n import java.time.Duration;\n+import java.util.function.Supplier;\n \n @WorkflowInterface\n public interface CheckConnectionWorkflow {\n@@ -93,15 +96,30 @@ public StandardCheckConnectionOutput run(JobRunConfig jobRunConfig,\n                                              IntegrationLauncherConfig launcherConfig,\n                                              StandardCheckConnectionInput connectionConfiguration)\n         throws TemporalJobException {\n-      return new TemporalAttemptExecution<>(workspaceRoot, jobRunConfig, (jobRoot) -> {\n+\n+      final Supplier<StandardCheckConnectionInput> inputSupplier = () -> connectionConfiguration;\n+\n+      final TemporalAttemptExecution<StandardCheckConnectionInput, StandardCheckConnectionOutput> temporalAttemptExecution =\n+          new TemporalAttemptExecution<>(\n+              workspaceRoot,\n+              jobRunConfig,\n+              getWorkerFactory(launcherConfig),\n+              inputSupplier,\n+              new CancellationHandler.TemporalCancellationHandler());\n+\n+      return temporalAttemptExecution.get();\n+    }\n+\n+    private CheckedSupplier<Worker<StandardCheckConnectionInput, StandardCheckConnectionOutput>, Exception> getWorkerFactory(IntegrationLauncherConfig launcherConfig) {\n+      return () -> {\n         final IntegrationLauncher integrationLauncher = new AirbyteIntegrationLauncher(\n             launcherConfig.getJobId(),\n             Math.toIntExact(launcherConfig.getAttemptId()),\n             launcherConfig.getDockerImage(),\n             pbf);\n \n-        return new DefaultCheckConnectionWorker(integrationLauncher).run(connectionConfiguration, jobRoot);\n-      }).get();\n+        return new DefaultCheckConnectionWorker(integrationLauncher);\n+      };\n     }\n \n   }"
  },
  {
    "sha": "b6fc4a83ac2aceabe7ed7675e79fc18814b276ed",
    "filename": "airbyte-workers/src/main/java/io/airbyte/workers/temporal/DiscoverCatalogWorkflow.java",
    "status": "modified",
    "additions": 21,
    "deletions": 4,
    "changes": 25,
    "blob_url": "https://github.com/airbytehq/airbyte/blob/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/temporal/DiscoverCatalogWorkflow.java",
    "raw_url": "https://github.com/airbytehq/airbyte/raw/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/temporal/DiscoverCatalogWorkflow.java",
    "contents_url": "https://api.github.com/repos/airbytehq/airbyte/contents/airbyte-workers/src/main/java/io/airbyte/workers/temporal/DiscoverCatalogWorkflow.java?ref=214ea9c799c617a21964a0f3404b44fa24416e40",
    "patch": "@@ -24,11 +24,13 @@\n \n package io.airbyte.workers.temporal;\n \n+import io.airbyte.commons.functional.CheckedSupplier;\n import io.airbyte.config.StandardDiscoverCatalogInput;\n import io.airbyte.protocol.models.AirbyteCatalog;\n import io.airbyte.scheduler.models.IntegrationLauncherConfig;\n import io.airbyte.scheduler.models.JobRunConfig;\n import io.airbyte.workers.DefaultDiscoverCatalogWorker;\n+import io.airbyte.workers.Worker;\n import io.airbyte.workers.process.AirbyteIntegrationLauncher;\n import io.airbyte.workers.process.IntegrationLauncher;\n import io.airbyte.workers.process.ProcessBuilderFactory;\n@@ -42,6 +44,7 @@\n import io.temporal.workflow.WorkflowMethod;\n import java.nio.file.Path;\n import java.time.Duration;\n+import java.util.function.Supplier;\n \n @WorkflowInterface\n public interface DiscoverCatalogWorkflow {\n@@ -95,13 +98,27 @@ public AirbyteCatalog run(JobRunConfig jobRunConfig,\n                               IntegrationLauncherConfig launcherConfig,\n                               StandardDiscoverCatalogInput config)\n         throws TemporalJobException {\n-      return new TemporalAttemptExecution<>(workspaceRoot, jobRunConfig, (jobRoot) -> {\n+      final Supplier<StandardDiscoverCatalogInput> inputSupplier = () -> config;\n+\n+      final TemporalAttemptExecution<StandardDiscoverCatalogInput, AirbyteCatalog> temporalAttemptExecution = new TemporalAttemptExecution<>(\n+          workspaceRoot,\n+          jobRunConfig,\n+          getWorkerFactory(launcherConfig),\n+          inputSupplier,\n+          new CancellationHandler.TemporalCancellationHandler());\n+\n+      return temporalAttemptExecution.get();\n+    }\n+\n+    private CheckedSupplier<Worker<StandardDiscoverCatalogInput, AirbyteCatalog>, Exception> getWorkerFactory(IntegrationLauncherConfig launcherConfig) {\n+      return () -> {\n         final IntegrationLauncher integrationLauncher =\n-            new AirbyteIntegrationLauncher(launcherConfig.getJobId(), launcherConfig.getAttemptId().intValue(), launcherConfig.getDockerImage(), pbf);\n+            new AirbyteIntegrationLauncher(launcherConfig.getJobId(), launcherConfig.getAttemptId().intValue(), launcherConfig.getDockerImage(),\n+                pbf);\n         final AirbyteStreamFactory streamFactory = new DefaultAirbyteStreamFactory();\n \n-        return new DefaultDiscoverCatalogWorker(integrationLauncher, streamFactory).run(config, jobRoot);\n-      }).get();\n+        return new DefaultDiscoverCatalogWorker(integrationLauncher, streamFactory);\n+      };\n     }\n \n   }"
  },
  {
    "sha": "507b135025727e284cee4bc4110b97197fd8436d",
    "filename": "airbyte-workers/src/main/java/io/airbyte/workers/temporal/SpecWorkflow.java",
    "status": "modified",
    "additions": 23,
    "deletions": 6,
    "changes": 29,
    "blob_url": "https://github.com/airbytehq/airbyte/blob/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/temporal/SpecWorkflow.java",
    "raw_url": "https://github.com/airbytehq/airbyte/raw/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/temporal/SpecWorkflow.java",
    "contents_url": "https://api.github.com/repos/airbytehq/airbyte/contents/airbyte-workers/src/main/java/io/airbyte/workers/temporal/SpecWorkflow.java?ref=214ea9c799c617a21964a0f3404b44fa24416e40",
    "patch": "@@ -24,11 +24,13 @@\n \n package io.airbyte.workers.temporal;\n \n+import io.airbyte.commons.functional.CheckedSupplier;\n import io.airbyte.config.JobGetSpecConfig;\n import io.airbyte.protocol.models.ConnectorSpecification;\n import io.airbyte.scheduler.models.IntegrationLauncherConfig;\n import io.airbyte.scheduler.models.JobRunConfig;\n import io.airbyte.workers.DefaultGetSpecWorker;\n+import io.airbyte.workers.Worker;\n import io.airbyte.workers.process.AirbyteIntegrationLauncher;\n import io.airbyte.workers.process.IntegrationLauncher;\n import io.airbyte.workers.process.ProcessBuilderFactory;\n@@ -40,6 +42,7 @@\n import io.temporal.workflow.WorkflowMethod;\n import java.nio.file.Path;\n import java.time.Duration;\n+import java.util.function.Supplier;\n \n @WorkflowInterface\n public interface SpecWorkflow {\n@@ -81,14 +84,28 @@ public SpecActivityImpl(ProcessBuilderFactory pbf, Path workspaceRoot) {\n     }\n \n     public ConnectorSpecification run(JobRunConfig jobRunConfig, IntegrationLauncherConfig launcherConfig) throws TemporalJobException {\n-      return new TemporalAttemptExecution<>(workspaceRoot, jobRunConfig, (jobRoot) -> {\n+      final Supplier<JobGetSpecConfig> inputSupplier = () -> new JobGetSpecConfig().withDockerImage(launcherConfig.getDockerImage());\n \n-        final IntegrationLauncher integrationLauncher =\n-            new AirbyteIntegrationLauncher(launcherConfig.getJobId(), launcherConfig.getAttemptId().intValue(), launcherConfig.getDockerImage(), pbf);\n+      final TemporalAttemptExecution<JobGetSpecConfig, ConnectorSpecification> temporalAttemptExecution = new TemporalAttemptExecution<>(\n+          workspaceRoot,\n+          jobRunConfig,\n+          getWorkerFactory(launcherConfig),\n+          inputSupplier,\n+          new CancellationHandler.TemporalCancellationHandler());\n \n-        final JobGetSpecConfig jobGetSpecConfig = new JobGetSpecConfig().withDockerImage(launcherConfig.getDockerImage());\n-        return new DefaultGetSpecWorker(integrationLauncher).run(jobGetSpecConfig, jobRoot);\n-      }).get();\n+      return temporalAttemptExecution.get();\n+    }\n+\n+    private CheckedSupplier<Worker<JobGetSpecConfig, ConnectorSpecification>, Exception> getWorkerFactory(IntegrationLauncherConfig launcherConfig) {\n+      return () -> {\n+        final IntegrationLauncher integrationLauncher = new AirbyteIntegrationLauncher(\n+            launcherConfig.getJobId(),\n+            launcherConfig.getAttemptId().intValue(),\n+            launcherConfig.getDockerImage(),\n+            pbf);\n+\n+        return new DefaultGetSpecWorker(integrationLauncher);\n+      };\n     }\n \n   }"
  },
  {
    "sha": "8e6db7f6b8262aecaee45b66a33667c8bab6cf54",
    "filename": "airbyte-workers/src/main/java/io/airbyte/workers/temporal/SyncWorkflow.java",
    "status": "modified",
    "additions": 31,
    "deletions": 4,
    "changes": 35,
    "blob_url": "https://github.com/airbytehq/airbyte/blob/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/temporal/SyncWorkflow.java",
    "raw_url": "https://github.com/airbytehq/airbyte/raw/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/temporal/SyncWorkflow.java",
    "contents_url": "https://api.github.com/repos/airbytehq/airbyte/contents/airbyte-workers/src/main/java/io/airbyte/workers/temporal/SyncWorkflow.java?ref=214ea9c799c617a21964a0f3404b44fa24416e40",
    "patch": "@@ -24,11 +24,13 @@\n \n package io.airbyte.workers.temporal;\n \n+import io.airbyte.commons.functional.CheckedSupplier;\n import io.airbyte.config.StandardSyncInput;\n import io.airbyte.config.StandardSyncOutput;\n import io.airbyte.scheduler.models.IntegrationLauncherConfig;\n import io.airbyte.scheduler.models.JobRunConfig;\n import io.airbyte.workers.DefaultSyncWorker;\n+import io.airbyte.workers.Worker;\n import io.airbyte.workers.WorkerConstants;\n import io.airbyte.workers.normalization.NormalizationRunnerFactory;\n import io.airbyte.workers.process.AirbyteIntegrationLauncher;\n@@ -40,6 +42,7 @@\n import io.airbyte.workers.protocols.airbyte.DefaultAirbyteSource;\n import io.airbyte.workers.protocols.airbyte.EmptyAirbyteSource;\n import io.airbyte.workers.protocols.airbyte.NamespacingMapper;\n+import io.temporal.activity.ActivityCancellationType;\n import io.temporal.activity.ActivityInterface;\n import io.temporal.activity.ActivityMethod;\n import io.temporal.activity.ActivityOptions;\n@@ -48,6 +51,9 @@\n import io.temporal.workflow.WorkflowMethod;\n import java.nio.file.Path;\n import java.time.Duration;\n+import java.util.function.Supplier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n @WorkflowInterface\n public interface SyncWorkflow {\n@@ -61,10 +67,12 @@ StandardSyncOutput run(JobRunConfig jobRunConfig,\n \n   class WorkflowImpl implements SyncWorkflow {\n \n-    final ActivityOptions options = ActivityOptions.newBuilder()\n+    private final ActivityOptions options = ActivityOptions.newBuilder()\n         .setScheduleToCloseTimeout(Duration.ofDays(3))\n+        .setCancellationType(ActivityCancellationType.WAIT_CANCELLATION_COMPLETED)\n         .setRetryOptions(TemporalUtils.NO_RETRY)\n         .build();\n+\n     private final SyncActivity activity = Workflow.newActivityStub(SyncActivity.class, options);\n \n     @Override\n@@ -92,6 +100,8 @@ StandardSyncOutput run(JobRunConfig jobRunConfig,\n \n   class SyncActivityImpl implements SyncActivity {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(SyncActivityImpl.class);\n+\n     private final ProcessBuilderFactory pbf;\n     private final Path workspaceRoot;\n \n@@ -106,7 +116,24 @@ public StandardSyncOutput run(JobRunConfig jobRunConfig,\n                                   StandardSyncInput syncInput)\n         throws TemporalJobException {\n \n-      return new TemporalAttemptExecution<>(workspaceRoot, jobRunConfig, (jobRoot) -> {\n+      final Supplier<StandardSyncInput> inputSupplier = () -> syncInput;\n+\n+      final TemporalAttemptExecution<StandardSyncInput, StandardSyncOutput> temporalAttemptExecution = new TemporalAttemptExecution<>(\n+          workspaceRoot,\n+          jobRunConfig,\n+          getWorkerFactory(sourceLauncherConfig, destinationLauncherConfig, jobRunConfig, syncInput),\n+          inputSupplier,\n+          new CancellationHandler.TemporalCancellationHandler());\n+\n+      return temporalAttemptExecution.get();\n+    }\n+\n+    private CheckedSupplier<Worker<StandardSyncInput, StandardSyncOutput>, Exception> getWorkerFactory(\n+                                                                                                       IntegrationLauncherConfig sourceLauncherConfig,\n+                                                                                                       IntegrationLauncherConfig destinationLauncherConfig,\n+                                                                                                       JobRunConfig jobRunConfig,\n+                                                                                                       StandardSyncInput syncInput) {\n+      return () -> {\n         final IntegrationLauncher sourceLauncher = new AirbyteIntegrationLauncher(\n             sourceLauncherConfig.getJobId(),\n             Math.toIntExact(sourceLauncherConfig.getAttemptId()),\n@@ -133,8 +160,8 @@ public StandardSyncOutput run(JobRunConfig jobRunConfig,\n             NormalizationRunnerFactory.create(\n                 destinationLauncherConfig.getDockerImage(),\n                 pbf,\n-                syncInput.getDestinationConfiguration())).run(syncInput, jobRoot);\n-      }).get();\n+                syncInput.getDestinationConfiguration()));\n+      };\n     }\n \n   }"
  },
  {
    "sha": "bb57211d1449929f3ca4348135a00131f19970fa",
    "filename": "airbyte-workers/src/main/java/io/airbyte/workers/temporal/TemporalAttemptExecution.java",
    "status": "modified",
    "additions": 84,
    "deletions": 14,
    "changes": 98,
    "blob_url": "https://github.com/airbytehq/airbyte/blob/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/temporal/TemporalAttemptExecution.java",
    "raw_url": "https://github.com/airbytehq/airbyte/raw/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/main/java/io/airbyte/workers/temporal/TemporalAttemptExecution.java",
    "contents_url": "https://api.github.com/repos/airbytehq/airbyte/contents/airbyte-workers/src/main/java/io/airbyte/workers/temporal/TemporalAttemptExecution.java?ref=214ea9c799c617a21964a0f3404b44fa24416e40",
    "patch": "@@ -26,16 +26,23 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import io.airbyte.commons.functional.CheckedConsumer;\n-import io.airbyte.commons.functional.CheckedFunction;\n import io.airbyte.commons.functional.CheckedSupplier;\n import io.airbyte.config.EnvConfigs;\n import io.airbyte.scheduler.models.JobRunConfig;\n+import io.airbyte.workers.Worker;\n import io.airbyte.workers.WorkerConstants;\n+import io.airbyte.workers.WorkerException;\n import io.airbyte.workers.WorkerUtils;\n import java.io.IOException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n import java.util.function.BiConsumer;\n+import java.util.function.Supplier;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -44,47 +51,110 @@\n  * outputs are passed to the selected worker. It also makes sures that the outputs of the worker are\n  * persisted to the db.\n  */\n-public class TemporalAttemptExecution<T> implements CheckedSupplier<T, TemporalJobException> {\n+public class TemporalAttemptExecution<INPUT, OUTPUT> implements CheckedSupplier<OUTPUT, TemporalJobException> {\n \n   private static final Logger LOGGER = LoggerFactory.getLogger(TemporalAttemptExecution.class);\n+  private static final Duration HEARTBEAT_INTERVAL = Duration.ofSeconds(10);\n \n   private final Path jobRoot;\n-  private final CheckedFunction<Path, T, Exception> execution;\n+  private final CheckedSupplier<Worker<INPUT, OUTPUT>, Exception> workerSupplier;\n+  private final Supplier<INPUT> inputSupplier;\n   private final long jobId;\n   private final BiConsumer<Path, Long> mdcSetter;\n   private final CheckedConsumer<Path, IOException> jobRootDirCreator;\n-\n-  @VisibleForTesting\n-  TemporalAttemptExecution(Path workspaceRoot, JobRunConfig jobRunConfig, CheckedFunction<Path, T, Exception> execution) {\n-    this(workspaceRoot, jobRunConfig, execution, WorkerUtils::setJobMdc, Files::createDirectories);\n-  }\n+  private final CancellationHandler cancellationHandler;\n \n   public TemporalAttemptExecution(Path workspaceRoot,\n                                   JobRunConfig jobRunConfig,\n-                                  CheckedFunction<Path, T, Exception> execution,\n-                                  BiConsumer<Path, Long> mdcSetter,\n-                                  CheckedConsumer<Path, IOException> jobRootDirCreator) {\n+                                  CheckedSupplier<Worker<INPUT, OUTPUT>, Exception> workerSupplier,\n+                                  Supplier<INPUT> inputSupplier,\n+                                  CancellationHandler cancellationHandler) {\n+    this(workspaceRoot, jobRunConfig, workerSupplier, inputSupplier, WorkerUtils::setJobMdc, Files::createDirectories, cancellationHandler);\n+  }\n+\n+  @VisibleForTesting\n+  TemporalAttemptExecution(Path workspaceRoot,\n+                           JobRunConfig jobRunConfig,\n+                           CheckedSupplier<Worker<INPUT, OUTPUT>, Exception> workerSupplier,\n+                           Supplier<INPUT> inputSupplier,\n+                           BiConsumer<Path, Long> mdcSetter,\n+                           CheckedConsumer<Path, IOException> jobRootDirCreator,\n+                           CancellationHandler cancellationHandler) {\n     this.jobRoot = WorkerUtils.getJobRoot(workspaceRoot, jobRunConfig.getJobId(), jobRunConfig.getAttemptId());\n-    this.execution = execution;\n+    this.workerSupplier = workerSupplier;\n+    this.inputSupplier = inputSupplier;\n     this.jobId = jobRunConfig.getJobId();\n     this.mdcSetter = mdcSetter;\n     this.jobRootDirCreator = jobRootDirCreator;\n+    this.cancellationHandler = cancellationHandler;\n   }\n \n   @Override\n-  public T get() throws TemporalJobException {\n+  public OUTPUT get() throws TemporalJobException {\n     try {\n       mdcSetter.accept(jobRoot, jobId);\n \n       LOGGER.info(\"Executing worker wrapper. Airbyte version: {}\", new EnvConfigs().getAirbyteVersionOrWarning());\n       jobRootDirCreator.accept(jobRoot);\n \n-      return execution.apply(jobRoot);\n+      final Worker<INPUT, OUTPUT> worker = workerSupplier.get();\n+      final CompletableFuture<OUTPUT> outputFuture = new CompletableFuture<>();\n+      final Thread workerThread = getWorkerThread(worker, outputFuture);\n+      final ScheduledExecutorService scheduledExecutor = Executors.newSingleThreadScheduledExecutor();\n+      final Runnable cancellationChecker = getCancellationChecker(worker, workerThread, outputFuture);\n+\n+      workerThread.start();\n+      scheduledExecutor.scheduleAtFixedRate(cancellationChecker, 0, HEARTBEAT_INTERVAL.toSeconds(), TimeUnit.SECONDS);\n+\n+      try {\n+        // block and wait for the output\n+        return outputFuture.get();\n+      } finally {\n+        LOGGER.info(\"Stopping cancellation check scheduling...\");\n+        scheduledExecutor.shutdown();\n+      }\n     } catch (TemporalJobException e) {\n       throw e;\n     } catch (Exception e) {\n       throw new TemporalJobException(jobRoot.resolve(WorkerConstants.LOG_FILENAME), e);\n     }\n   }\n \n+  private Thread getWorkerThread(Worker<INPUT, OUTPUT> worker, CompletableFuture<OUTPUT> outputFuture) {\n+    return new Thread(() -> {\n+      mdcSetter.accept(jobRoot, jobId);\n+\n+      try {\n+        final OUTPUT output = worker.run(inputSupplier.get(), jobRoot);\n+        outputFuture.complete(output);\n+      } catch (Throwable e) {\n+        LOGGER.info(\"Completing future exceptionally...\", e);\n+        outputFuture.completeExceptionally(e);\n+      }\n+    });\n+  }\n+\n+  private Runnable getCancellationChecker(Worker<INPUT, OUTPUT> worker, Thread workerThread, CompletableFuture<OUTPUT> outputFuture) {\n+    return () -> {\n+      try {\n+        mdcSetter.accept(jobRoot, jobId);\n+\n+        final Runnable onCancellationCallback = () -> {\n+          LOGGER.info(\"Running sync worker cancellation...\");\n+          worker.cancel();\n+\n+          LOGGER.info(\"Interrupting worker thread...\");\n+          workerThread.interrupt();\n+\n+          LOGGER.info(\"Cancelling completable future...\");\n+          outputFuture.cancel(false);\n+        };\n+\n+        cancellationHandler.checkAndHandleCancellation(onCancellationCallback);\n+      } catch (WorkerException e) {\n+        LOGGER.error(\"Cancellation checker exception\", e);\n+      }\n+    };\n+  }\n+\n }"
  },
  {
    "sha": "84787adda12e311b8d556c75d6a2606f3f8c0ad8",
    "filename": "airbyte-workers/src/test/java/io/airbyte/workers/temporal/TemporalAttemptExecutionTest.java",
    "status": "modified",
    "additions": 27,
    "deletions": 15,
    "changes": 42,
    "blob_url": "https://github.com/airbytehq/airbyte/blob/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/test/java/io/airbyte/workers/temporal/TemporalAttemptExecutionTest.java",
    "raw_url": "https://github.com/airbytehq/airbyte/raw/214ea9c799c617a21964a0f3404b44fa24416e40/airbyte-workers/src/test/java/io/airbyte/workers/temporal/TemporalAttemptExecutionTest.java",
    "contents_url": "https://api.github.com/repos/airbytehq/airbyte/contents/airbyte-workers/src/test/java/io/airbyte/workers/temporal/TemporalAttemptExecutionTest.java?ref=214ea9c799c617a21964a0f3404b44fa24416e40",
    "patch": "@@ -27,20 +27,24 @@\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import io.airbyte.commons.functional.CheckedConsumer;\n-import io.airbyte.commons.functional.CheckedFunction;\n+import io.airbyte.commons.functional.CheckedSupplier;\n import io.airbyte.scheduler.models.JobRunConfig;\n+import io.airbyte.workers.Worker;\n import io.airbyte.workers.WorkerConstants;\n import java.io.IOException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.function.BiConsumer;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.mockito.stubbing.Answer;\n \n class TemporalAttemptExecutionTest {\n \n@@ -51,11 +55,11 @@\n   private Path jobRoot;\n   private TemporalJobException expectedException;\n \n-  private CheckedFunction<Path, String, Exception> execution;\n+  private CheckedSupplier<Worker<String, String>, Exception> execution;\n   private BiConsumer<Path, Long> mdcSetter;\n   private CheckedConsumer<Path, IOException> jobRootDirCreator;\n \n-  private TemporalAttemptExecution<String> attemptExecution;\n+  private TemporalAttemptExecution<String, String> attemptExecution;\n \n   @SuppressWarnings(\"unchecked\")\n   @BeforeEach\n@@ -64,62 +68,70 @@ void setup() throws IOException {\n     jobRoot = workspaceRoot.resolve(String.valueOf(JOB_ID)).resolve(String.valueOf(ATTEMPT_ID));\n     expectedException = new TemporalJobException(jobRoot.resolve(WorkerConstants.LOG_FILENAME));\n \n-    execution = mock(CheckedFunction.class);\n+    execution = mock(CheckedSupplier.class);\n     mdcSetter = mock(BiConsumer.class);\n     jobRootDirCreator = mock(CheckedConsumer.class);\n \n-    attemptExecution = new TemporalAttemptExecution<>(workspaceRoot, JOB_RUN_CONFIG, execution, mdcSetter, jobRootDirCreator);\n+    attemptExecution = new TemporalAttemptExecution<>(workspaceRoot, JOB_RUN_CONFIG, execution, () -> \"\", mdcSetter, jobRootDirCreator,\n+        mock(CancellationHandler.class));\n   }\n \n   @Test\n-  void testGet() throws Exception {\n+  void testSuccessfulSupplierRun() throws Exception {\n     final String expected = \"louis XVI\";\n-    when(execution.apply(jobRoot)).thenReturn(expected);\n+    Worker<String, String> worker = mock(Worker.class);\n+    when(worker.run(any(), any())).thenReturn(expected);\n+\n+    when(execution.get()).thenAnswer((Answer<Worker<String, String>>) invocation -> {\n+      // sleep to make sure the scheduled thread has time to start and execute\n+      Thread.sleep(1000);\n+      return worker;\n+    });\n \n     final String actual = attemptExecution.get();\n \n     assertEquals(expected, actual);\n-    verify(execution).apply(jobRoot);\n-    verify(mdcSetter).accept(jobRoot, JOB_ID);\n+    verify(execution).get();\n+    verify(mdcSetter, times(3)).accept(jobRoot, JOB_ID);\n     verify(jobRootDirCreator).accept(jobRoot);\n   }\n \n   @Test\n   void testThrowsCheckedException() throws Exception {\n-    when(execution.apply(jobRoot)).thenThrow(new IOException());\n+    when(execution.get()).thenThrow(new IOException());\n \n     final TemporalJobException actualException = assertThrows(TemporalJobException.class, () -> attemptExecution.get());\n     assertEquals(expectedException.getLogPath(), actualException.getLogPath());\n     assertEquals(IOException.class, actualException.getCause().getClass());\n \n-    verify(execution).apply(jobRoot);\n+    verify(execution).get();\n     verify(mdcSetter).accept(jobRoot, JOB_ID);\n     verify(jobRootDirCreator).accept(jobRoot);\n   }\n \n   @Test\n   void testThrowsUnCheckedException() throws Exception {\n-    when(execution.apply(jobRoot)).thenThrow(new IllegalArgumentException());\n+    when(execution.get()).thenThrow(new IllegalArgumentException());\n \n     final TemporalJobException actualException = assertThrows(TemporalJobException.class, () -> attemptExecution.get());\n     assertEquals(expectedException.getLogPath(), actualException.getLogPath());\n     assertEquals(IllegalArgumentException.class, actualException.getCause().getClass());\n \n-    verify(execution).apply(jobRoot);\n+    verify(execution).get();\n     verify(mdcSetter).accept(jobRoot, JOB_ID);\n     verify(jobRootDirCreator).accept(jobRoot);\n   }\n \n   @Test\n   void testThrowsTemporalJobExceptionException() throws Exception {\n     final Path otherFilePath = jobRoot.resolve(\"other file path\");\n-    when(execution.apply(jobRoot)).thenThrow(new TemporalJobException(otherFilePath));\n+    when(execution.get()).thenThrow(new TemporalJobException(otherFilePath));\n \n     final TemporalJobException actualException = assertThrows(TemporalJobException.class, () -> attemptExecution.get());\n     assertEquals(otherFilePath, actualException.getLogPath());\n     assertNull(actualException.getCause());\n \n-    verify(execution).apply(jobRoot);\n+    verify(execution).get();\n     verify(mdcSetter).accept(jobRoot, JOB_ID);\n     verify(jobRootDirCreator).accept(jobRoot);\n   }"
  }
]
