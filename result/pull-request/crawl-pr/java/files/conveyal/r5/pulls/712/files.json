[
  {
    "sha": "c2c1489838500ad952fc61e015802898389f34ca",
    "filename": "src/main/java/com/conveyal/r5/analyst/GridTransformWrapper.java",
    "status": "modified",
    "additions": 29,
    "deletions": 12,
    "changes": 41,
    "blob_url": "https://github.com/conveyal/r5/blob/fbb7a023509ab2e2522edfc59b7976ab47693a45/src/main/java/com/conveyal/r5/analyst/GridTransformWrapper.java",
    "raw_url": "https://github.com/conveyal/r5/raw/fbb7a023509ab2e2522edfc59b7976ab47693a45/src/main/java/com/conveyal/r5/analyst/GridTransformWrapper.java",
    "contents_url": "https://api.github.com/repos/conveyal/r5/contents/src/main/java/com/conveyal/r5/analyst/GridTransformWrapper.java?ref=fbb7a023509ab2e2522edfc59b7976ab47693a45",
    "patch": "@@ -3,6 +3,7 @@\n import org.locationtech.jts.geom.Envelope;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n \n /**\n  * This wraps a gridded destination pointset (the \"source\"), remapping its point indexes to match those of another grid.\n@@ -15,35 +16,51 @@\n public class GridTransformWrapper extends PointSet {\n \n     /** Defer to this PointSet for everything but opportunity counts, including grid dimensions and lat/lon. */\n-    private WebMercatorGridPointSet targetGrid;\n+    private final WebMercatorGridPointSet targetGrid;\n \n     /** Defer to this PointSet to get opportunity counts (transforming indexes to those of targetPointSet). */\n-    private Grid sourceGrid;\n+    private final Grid sourceGrid;\n+\n+    /** The difference in zoom levels between the source and target grids. Constrained positive (only upsample). */\n+    private final int dz;\n+\n+    /**\n+     * The fraction of opportunities in a sourceGrid cell that are allocated to each targetGrid cell it contains.\n+     * We uniformly distribute opportunities when upsampling, so by the definition of map tile zoom levels this should\n+     * always be the inverse of a power of two, in the range (0...1]. Total opportunities should be exactly conserved\n+     * because floating point division by powers of two is exact: in base 2 it just moves the decimal point N places.\n+     */\n+    private final double targetCellFraction;\n \n     /**\n      * Wraps the sourceGrid such that the opportunity count is read from the geographic locations of indexes in the\n-     * targetGrid. For the time being, both pointsets must be at the same zoom level. Any opportunities outside the\n-     * targetGrid cannot be indexed so are effectively zero for the purpose of accessibility calculations.\n+     * targetGrid. The targetGrid may be at a higher zoom level than the source grid, in which case opportunities will\n+     * be distributed equally among the higher-resolution cells. Any opportunities outside the targetGrid cannot be\n+     * indexed so are effectively zero for the purpose of accessibility calculations.\n      */\n     public GridTransformWrapper (WebMercatorExtents targetGridExtents, Grid sourceGrid) {\n-        checkArgument(targetGridExtents.zoom == sourceGrid.zoom, \"Zoom levels must be identical.\");\n+        checkArgument(targetGridExtents.zoom >= sourceGrid.zoom, \"We only upsample grids, not downsample them.\");\n         // Make a pointset for these extents so we can defer to its methods for lat/lon lookup, size, etc.\n         this.targetGrid = new WebMercatorGridPointSet(targetGridExtents);\n         this.sourceGrid = sourceGrid;\n+        dz = targetGrid.zoom - sourceGrid.zoom;\n+        targetCellFraction = 1.0 / (1 << (dz * 2));\n+        checkState(dz >= 0 && dz <= 3, \"Difference in zoom levels out of acceptable range: \" + dz);\n+        checkState(targetCellFraction > 0 && targetCellFraction <= 1, \"Opportunity scaling factor out of range.\");\n     }\n \n-    // Given an index in the targetPointSet, return the corresponding 1D index into the sourceGrid or -1 if the target\n+    // Given an index in the targetGrid, return the corresponding 1D index into the sourceGrid or -1 if the target\n     // index is for a point outside the source grid.\n     // This could certainly be made more efficient (but complex) by forcing sequential iteration over opportunity counts\n     // and disallowing random access, using a new PointSetIterator class that allows reading lat, lon, and counts.\n-    private int transformIndex (int i) {\n-        final int x = (i % targetGrid.width) + targetGrid.west - sourceGrid.west;\n-        final int y = (i / targetGrid.width) + targetGrid.north - sourceGrid.north;\n-        if (x < 0 || x >= sourceGrid.width || y < 0 || y >= sourceGrid.height) {\n+    private int transformIndex (int ti) {\n+        final int sx = ((ti % targetGrid.width) + targetGrid.west - (sourceGrid.west << dz)) >> dz;\n+        final int sy = ((ti / targetGrid.width) + targetGrid.north - (sourceGrid.north << dz)) >> dz;\n+        if (sx < 0 || sx >= sourceGrid.width || sy < 0 || sy >= sourceGrid.height) {\n             // Point in target grid lies outside source grid, there is no valid index. Return special value.\n             return -1;\n         }\n-        return y * sourceGrid.width + x;\n+        return sy * sourceGrid.width + sx;\n     }\n \n     @Override\n@@ -77,7 +94,7 @@ public double getOpportunityCount (int targetIndex) {\n         if (sourceindex < 0) {\n             return 0;\n         } else {\n-            return sourceGrid.getOpportunityCount(sourceindex);\n+            return sourceGrid.getOpportunityCount(sourceindex) * targetCellFraction;\n         }\n     }\n "
  },
  {
    "sha": "98158cc65308808aca02c1a297386fab70b926fc",
    "filename": "src/test/java/com/conveyal/r5/analyst/GridTransformWrapperTest.java",
    "status": "modified",
    "additions": 26,
    "deletions": 30,
    "changes": 56,
    "blob_url": "https://github.com/conveyal/r5/blob/fbb7a023509ab2e2522edfc59b7976ab47693a45/src/test/java/com/conveyal/r5/analyst/GridTransformWrapperTest.java",
    "raw_url": "https://github.com/conveyal/r5/raw/fbb7a023509ab2e2522edfc59b7976ab47693a45/src/test/java/com/conveyal/r5/analyst/GridTransformWrapperTest.java",
    "contents_url": "https://api.github.com/repos/conveyal/r5/contents/src/test/java/com/conveyal/r5/analyst/GridTransformWrapperTest.java?ref=fbb7a023509ab2e2522edfc59b7976ab47693a45",
    "patch": "@@ -17,12 +17,14 @@\n     @Test\n     void testTwoAdjacentGrids () {\n \n+        final int baseZoom = 10;\n+\n         // Two grids side by side, right one bigger than than the left, with top 20 pixels lower\n-        Grid leftGrid = new Grid(10, 200, 300, 1000, 2000);\n-        Grid rightGrid = new Grid(10, 300, 400, 1020, 2200);\n+        Grid leftGrid = new Grid(baseZoom, 200, 300, 1000, 2000);\n+        Grid rightGrid = new Grid(baseZoom, 300, 400, 1020, 2200);\n \n         // One minimum bounding grid exactly encompassing the other two.\n-        Grid superGrid = new Grid(10, 500, 400, 1000, 2000);\n+        Grid superGrid = new Grid(baseZoom, 500, 400, 1000, 2000);\n \n         // Make a column of pixel weights 2 pixels wide and 26 pixels high.\n         List<Grid.PixelWeight> weights = new ArrayList<>();\n@@ -45,34 +47,28 @@ void testTwoAdjacentGrids () {\n         superGrid.incrementFromPixelWeights(weights, 1);\n         superGrid.incrementFromPixelWeights(rightTranslatedWeights, 2);\n \n-        // Make some extents even bigger than the merged supergrid\n-        WebMercatorExtents superSuperExtents = new WebMercatorExtents(1900, 950, 600, 500, 10);\n-\n-        GridTransformWrapper leftWrapper = new GridTransformWrapper(superSuperExtents, leftGrid);\n-        GridTransformWrapper rightWrapper = new GridTransformWrapper(superSuperExtents, rightGrid);\n-        GridTransformWrapper superWrapper = new GridTransformWrapper(superSuperExtents, superGrid);\n-\n-        double totalWeight = 0;\n-        final int superSuperCellCount = superSuperExtents.width * superSuperExtents.height;\n-        for (int i = 0; i < superSuperCellCount; i++) {\n-            double superCount = superWrapper.getOpportunityCount(i);\n-            double leftCount = leftWrapper.getOpportunityCount(i);\n-            double rightCount = rightWrapper.getOpportunityCount(i);\n-            double mergedCount = leftCount + rightCount;\n-            totalWeight += mergedCount;\n-            assertEquals(superCount, mergedCount, \"Supergrid should contain the sum of left and right\");\n+        // Make some extents even bigger than the merged supergrid, at several increasing zoom levels.\n+        for (int upsample = 0; upsample < 3; upsample++) {\n+            WebMercatorExtents superSuperExtents = new WebMercatorExtents(\n+                    1900 << upsample, 950 << upsample, 600 << upsample, 500 << upsample, baseZoom + upsample\n+            );\n+            GridTransformWrapper leftWrapper = new GridTransformWrapper(superSuperExtents, leftGrid);\n+            GridTransformWrapper rightWrapper = new GridTransformWrapper(superSuperExtents, rightGrid);\n+            GridTransformWrapper superWrapper = new GridTransformWrapper(superSuperExtents, superGrid);\n+\n+            double totalWeight = 0;\n+            final int superSuperCellCount = superSuperExtents.width * superSuperExtents.height;\n+            for (int i = 0; i < superSuperCellCount; i++) {\n+                double superCount = superWrapper.getOpportunityCount(i);\n+                double leftCount = leftWrapper.getOpportunityCount(i);\n+                double rightCount = rightWrapper.getOpportunityCount(i);\n+                double mergedCount = leftCount + rightCount;\n+                totalWeight += mergedCount;\n+                assertEquals(superCount, mergedCount, \"Supergrid should contain the sum of left and right\");\n+            }\n+            // Summed weight should be exactly conserved at different zoom levels, as all upscaling is by powers of 2.\n+            assertEquals(weights.stream().mapToDouble(pw -> pw.weight).sum() * 3, totalWeight);\n         }\n-        assertEquals(weights.stream().mapToDouble(pw -> pw.weight).sum() * 3, totalWeight);\n-    }\n-\n-    /**\n-     * Ensure that we refuse to create a transform wrapper that attempts to transform across zoom levels.\n-     */\n-    @Test\n-    void testMismatchedZoomLevels () {\n-        Grid grid = new Grid(10, 10, 10, 10, 10);\n-        WebMercatorExtents webMercatorExtents = new WebMercatorExtents(10, 10, 10, 10, 11);\n-        assertThrows(IllegalArgumentException.class, () -> new GridTransformWrapper(webMercatorExtents, grid));\n     }\n \n     /*"
  }
]
