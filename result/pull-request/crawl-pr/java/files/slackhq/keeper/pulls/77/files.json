[
  {
    "sha": "f6ec9deeb01a14cf5913d74b7590185cc9314567",
    "filename": ".github/workflows/ci.yml",
    "status": "modified",
    "additions": 17,
    "deletions": 13,
    "changes": 30,
    "blob_url": "https://github.com/slackhq/keeper/blob/aa5b1067df50635869f78d74a2da8cbd438e242e/.github/workflows/ci.yml",
    "raw_url": "https://github.com/slackhq/keeper/raw/aa5b1067df50635869f78d74a2da8cbd438e242e/.github/workflows/ci.yml",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/.github/workflows/ci.yml?ref=aa5b1067df50635869f78d74a2da8cbd438e242e",
    "patch": "@@ -13,17 +13,21 @@ on:\n \n jobs:\n   build:\n-    name: ${{ matrix.job }} / JDK ${{ matrix.ci_java_version }} / AGP ${{ matrix.ci_agp_version }} / TraceRefs ${{ matrix.ci_tracerefs }}\n+    name: ${{ matrix.job }} / JDK ${{ matrix.java }} / AGP ${{ matrix.agp }} / TraceRefs ${{ matrix.tracerefs }}\n     # Use macOS for emulator hardware acceleration\n     runs-on: macOS-latest\n     timeout-minutes: 30\n     strategy:\n       fail-fast: false # We want to see all results\n       matrix:\n-        ci_java_version: [1.8]\n-        ci_agp_version: [4.0.0, 4.1.1, 4.2.0-beta02]\n-        ci_tracerefs: [true, false]\n-        job: [instrumentation, plugin]\n+        java: ['1.8', '11']\n+        agp: ['4.1.2', '4.2.0-beta05', '7.0.0-alpha08']\n+        tracerefs: [true, false]\n+        job: ['instrumentation', 'plugin']\n+        exclude:\n+          # AGP 7.x requires JDK 11+\n+          - agp: 7.0.0-alpha08\n+            java: 1.8\n     steps:\n       - name: Checkout\n         uses: actions/checkout@v2\n@@ -37,26 +41,26 @@ jobs:\n       - uses: actions/cache@v2\n         with:\n           path: ~/.gradle/caches\n-          key: ${{ runner.os }}-gradle-${{ matrix.ci_agp_version }}-${{ matrix.job }}-${{ hashFiles('checksum.txt') }}\n+          key: ${{ runner.os }}-gradle-${{ matrix.java }}-${{ hashFiles('checksum.txt') }}\n           restore-keys: |\n-            ${{ runner.os }}-gradle-${{ matrix.ci_agp_version }}-${{ matrix.job }}-\n+            ${{ runner.os }}-gradle-${{ matrix.java }}-\n \n-      - name: Install JDK ${{ matrix.ci_java_version }}\n+      - name: Install JDK ${{ matrix.java }}\n         uses: actions/setup-java@v1.4.3\n         with:\n-          java-version: ${{ matrix.ci_java_version }}\n+          java-version: ${{ matrix.java }}\n \n       - name: Test plugin\n         if: matrix.job == 'plugin'\n-        run: ./gradlew -p keeper-gradle-plugin clean check --stacktrace -PkeeperTest.agpVersion=${{ matrix.ci_agp_version }}\n+        run: ./gradlew -p keeper-gradle-plugin clean check --stacktrace -PkeeperTest.agpVersion=${{ matrix.agp }}\n \n       - name: Run instrumentation tests\n         uses: reactivecircus/android-emulator-runner@v2\n         if: matrix.job == 'instrumentation'\n         with:\n           # Run connectedCheck with both Proguard and R8.\n           # We don't want to wait for the emulator to start/stop twice, so we combine this script into the same step.\n-          script: .github/workflows/run_instrumentation_tests.sh ${{ matrix.ci_agp_version }} ${{ matrix.ci_tracerefs }}\n+          script: .github/workflows/run_instrumentation_tests.sh ${{ matrix.agp }} ${{ matrix.tracerefs }}\n           api-level: 29\n \n       - name: (Fail-only) Bundle the build report\n@@ -72,12 +76,12 @@ jobs:\n \n       - name: Reclaim memory\n         run: ./gradlew --stop && jps|grep -E 'KotlinCompileDaemon|GradleDaemon'| awk '{print $1}'| xargs kill -9 || true\n-        if: success() && github.ref == 'refs/heads/main' && github.event_name != 'pull_request' && matrix.ci_java_version == '1.8' && matrix.ci_agp_version == '4.0.0' && matrix.job == 'plugin'\n+        if: success() && github.ref == 'refs/heads/main' && github.event_name != 'pull_request' && matrix.java == '1.8' && matrix.agp == '4.1.2' && matrix.tracerefs && matrix.job == 'plugin'\n \n       - name: Upload snapshot (main only)\n         env:\n           ORG_GRADLE_PROJECT_SONATYPE_NEXUS_USERNAME: ${{ secrets.SonatypeUsername }}\n           ORG_GRADLE_PROJECT_SONATYPE_NEXUS_PASSWORD: ${{ secrets.SonatypePassword }}\n         run: |\n           ./publish.sh --snapshot\n-        if: success() && github.ref == 'refs/heads/main' && github.event_name != 'pull_request' && matrix.ci_java_version == '1.8' && matrix.ci_agp_version == '4.0.0' && matrix.job == 'plugin'\n+        if: success() && github.ref == 'refs/heads/main' && github.event_name != 'pull_request' && matrix.java == '1.8' && matrix.agp == '4.1.2' && matrix.tracerefs && matrix.job == 'plugin'"
  },
  {
    "sha": "e9fcaf7aca151543c2b55d2bf973088471be4f98",
    "filename": ".github/workflows/run_instrumentation_tests.sh",
    "status": "modified",
    "additions": 6,
    "deletions": 2,
    "changes": 8,
    "blob_url": "https://github.com/slackhq/keeper/blob/aa5b1067df50635869f78d74a2da8cbd438e242e/.github/workflows/run_instrumentation_tests.sh",
    "raw_url": "https://github.com/slackhq/keeper/raw/aa5b1067df50635869f78d74a2da8cbd438e242e/.github/workflows/run_instrumentation_tests.sh",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/.github/workflows/run_instrumentation_tests.sh?ref=aa5b1067df50635869f78d74a2da8cbd438e242e",
    "patch": "@@ -15,8 +15,12 @@ echo \"Install coreutils\" # For gtimeout\n brew install coreutils\n \n # We only run the sample with R8 as proguard infinite loops if we have java 8 libraries on the classpath ðŸ™ƒ\n+echo \"Building APK\"\n ./gradlew :sample:minifyExternalStagingWithR8 --stacktrace -PkeeperTest.agpVersion=\"${AGP_VERSION}\" -PkeeperTest.enableTraceReferences=\"${ENABLE_TRACEREFS}\"\n # Reclaim memory because Actions OOMs sometimes with having both an emulator and heavy gradle builds going on\n-./gradlew --stop && jps|grep -E 'KotlinCompileDaemon|GradleDaemon'| awk '{print $1}'| xargs kill -9 || true\n+./gradlew --stop || jps|grep -E 'KotlinCompileDaemon|GradleDaemon'| awk '{print $1}'| xargs kill -9 || true\n # Now proceed, with much of the build being cached up to this point\n-gtimeout --signal=SIGINT 10m ./gradlew connectedExternalStagingAndroidTest --stacktrace -PkeeperTest.agpVersion=\"${AGP_VERSION}\" -PkeeperTest.enableTraceReferences=\"${ENABLE_TRACEREFS}\"\n+echo \"Running instrumentation tests\"\n+# Disable the l8DexDesugarLibExternalStagingAndroidTest task because it's not cacheable and it\n+# wipes some of our diagnostic outputs in testing. We've already run it in the previous step.\n+gtimeout --signal=SIGINT 10m ./gradlew connectedExternalStagingAndroidTest -x l8DexDesugarLibExternalStagingAndroidTest --stacktrace -PkeeperTest.agpVersion=\"${AGP_VERSION}\" -PkeeperTest.enableTraceReferences=\"${ENABLE_TRACEREFS}\""
  },
  {
    "sha": "315ff34fa74645ca5a0ecd42cece57f51b67863b",
    "filename": "build.gradle",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/slackhq/keeper/blob/aa5b1067df50635869f78d74a2da8cbd438e242e/build.gradle",
    "raw_url": "https://github.com/slackhq/keeper/raw/aa5b1067df50635869f78d74a2da8cbd438e242e/build.gradle",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/build.gradle?ref=aa5b1067df50635869f78d74a2da8cbd438e242e",
    "patch": "@@ -26,7 +26,7 @@ buildscript {\n     String defaultAgpVersion = \"4.0.0\"\n     String agpVersion = findProperty(\"keeperTest.agpVersion\")?.toString() ?: defaultAgpVersion\n     dependencies {\n-        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:1.4.30\"\n+        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:1.4.31\"\n         classpath \"com.android.tools.build:gradle:$agpVersion\"\n         classpath \"com.slack.keeper:keeper\"\n     }"
  },
  {
    "sha": "48b8da00fa1f8510094c1a604311ff7ada16b94d",
    "filename": "gradle/wrapper/gradle-wrapper.properties",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/slackhq/keeper/blob/aa5b1067df50635869f78d74a2da8cbd438e242e/gradle/wrapper/gradle-wrapper.properties",
    "raw_url": "https://github.com/slackhq/keeper/raw/aa5b1067df50635869f78d74a2da8cbd438e242e/gradle/wrapper/gradle-wrapper.properties",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/gradle/wrapper/gradle-wrapper.properties?ref=aa5b1067df50635869f78d74a2da8cbd438e242e",
    "patch": "@@ -1,5 +1,5 @@\n distributionBase=GRADLE_USER_HOME\n distributionPath=wrapper/dists\n-distributionUrl=https\\://services.gradle.org/distributions/gradle-6.8.3-all.zip\n+distributionUrl=https\\://services.gradle.org/distributions/gradle-7.0-milestone-2-all.zip\n zipStoreBase=GRADLE_USER_HOME\n zipStorePath=wrapper/dists"
  },
  {
    "sha": "084b66e8dfdabeda96ded8b8e21e18aa89558294",
    "filename": "keeper-gradle-plugin/build.gradle.kts",
    "status": "modified",
    "additions": 7,
    "deletions": 17,
    "changes": 24,
    "blob_url": "https://github.com/slackhq/keeper/blob/aa5b1067df50635869f78d74a2da8cbd438e242e/keeper-gradle-plugin/build.gradle.kts",
    "raw_url": "https://github.com/slackhq/keeper/raw/aa5b1067df50635869f78d74a2da8cbd438e242e/keeper-gradle-plugin/build.gradle.kts",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/build.gradle.kts?ref=aa5b1067df50635869f78d74a2da8cbd438e242e",
    "patch": "@@ -20,10 +20,10 @@ import java.net.URL\n plugins {\n   `kotlin-dsl`\n   `java-gradle-plugin`\n-  kotlin(\"jvm\") version \"1.4.30\"\n-  kotlin(\"kapt\") version \"1.4.30\"\n+  kotlin(\"jvm\") version \"1.4.31\"\n+  kotlin(\"kapt\") version \"1.4.31\"\n   id(\"org.jetbrains.dokka\") version \"1.4.20\"\n-  id(\"com.vanniktech.maven.publish\") version \"0.13.0\"\n+  id(\"com.vanniktech.maven.publish\") version \"0.14.2\"\n }\n \n buildscript {\n@@ -78,10 +78,6 @@ gradlePlugin {\n   }\n }\n \n-kotlinDslPluginOptions {\n-  experimentalWarning.set(false)\n-}\n-\n kotlin {\n   explicitApi()\n }\n@@ -97,24 +93,18 @@ tasks.named<DokkaTask>(\"dokkaHtml\") {\n       packageListUrl.set(URL(\"https://developer.android.com/reference/tools/gradle-api/4.1/package-list\"))\n       url.set(URL(\"https://developer.android.com/reference/tools/gradle-api/4.1/classes\"))\n     }\n-\n-    // Suppress Zipflinger copy\n-    // TODO re-enable this with a proper regex\n-//    perPackageOption {\n-//      matchingRegex.set(\"com.slack.keeper.internal.zipflinger\")\n-//      suppress.set(true)\n-//    }\n   }\n }\n \n-val defaultAgpVersion = \"4.0.0\"\n+val defaultAgpVersion = \"4.1.2\"\n val agpVersion = findProperty(\"keeperTest.agpVersion\")?.toString() ?: defaultAgpVersion\n \n // See https://github.com/slackhq/keeper/pull/11#issuecomment-579544375 for context\n val releaseMode = hasProperty(\"keeper.releaseMode\")\n dependencies {\n-  implementation(\"org.jetbrains.kotlin:kotlin-gradle-plugin-api:1.4.30\")\n-  implementation(\"org.jetbrains.kotlin:kotlin-gradle-plugin:1.4.30\")\n+  implementation(\"org.jetbrains.kotlin:kotlin-gradle-plugin-api:1.4.31\")\n+  implementation(\"org.jetbrains.kotlin:kotlin-gradle-plugin:1.4.31\")\n+  implementation(\"com.android:zipflinger:4.1.2\")\n \n   if (releaseMode) {\n     compileOnly(\"com.android.tools.build:gradle:$defaultAgpVersion\")"
  },
  {
    "sha": "48b8da00fa1f8510094c1a604311ff7ada16b94d",
    "filename": "keeper-gradle-plugin/gradle/wrapper/gradle-wrapper.properties",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/slackhq/keeper/blob/aa5b1067df50635869f78d74a2da8cbd438e242e/keeper-gradle-plugin/gradle/wrapper/gradle-wrapper.properties",
    "raw_url": "https://github.com/slackhq/keeper/raw/aa5b1067df50635869f78d74a2da8cbd438e242e/keeper-gradle-plugin/gradle/wrapper/gradle-wrapper.properties",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/gradle/wrapper/gradle-wrapper.properties?ref=aa5b1067df50635869f78d74a2da8cbd438e242e",
    "patch": "@@ -1,5 +1,5 @@\n distributionBase=GRADLE_USER_HOME\n distributionPath=wrapper/dists\n-distributionUrl=https\\://services.gradle.org/distributions/gradle-6.8.3-all.zip\n+distributionUrl=https\\://services.gradle.org/distributions/gradle-7.0-milestone-2-all.zip\n zipStoreBase=GRADLE_USER_HOME\n zipStorePath=wrapper/dists"
  },
  {
    "sha": "888d6e91d62adb99a7d19e0c50e30193649b9fa8",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/InferAndroidTestKeepRules.kt",
    "status": "modified",
    "additions": 27,
    "deletions": 24,
    "changes": 51,
    "blob_url": "https://github.com/slackhq/keeper/blob/aa5b1067df50635869f78d74a2da8cbd438e242e/keeper-gradle-plugin/src/main/java/com/slack/keeper/InferAndroidTestKeepRules.kt",
    "raw_url": "https://github.com/slackhq/keeper/raw/aa5b1067df50635869f78d74a2da8cbd438e242e/keeper-gradle-plugin/src/main/java/com/slack/keeper/InferAndroidTestKeepRules.kt",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/InferAndroidTestKeepRules.kt?ref=aa5b1067df50635869f78d74a2da8cbd438e242e",
    "patch": "@@ -92,8 +92,10 @@ public abstract class InferAndroidTestKeepRules : JavaExec() {\n       val inputJvmArgs = jvmArgsProperty.get()\n       if (inputJvmArgs.isNotEmpty()) {\n         logger.lifecycle(\n-            \"Starting infer exec with jvmArgs ${inputJvmArgs.joinToString(\", \", prefix = \"[\",\n-                postfix = \"]\")}. If debugging, attach the debugger now.\"\n+            \"Starting infer exec with jvmArgs ${\n+              inputJvmArgs.joinToString(\", \", prefix = \"[\",\n+                  postfix = \"]\")\n+            }. If debugging, attach the debugger now.\"\n         )\n         jvmArgs = inputJvmArgs\n       }\n@@ -109,28 +111,28 @@ public abstract class InferAndroidTestKeepRules : JavaExec() {\n   }\n \n   private fun genPrintUsesArgs(): List<String> =\n-    listOf(\n-      \"--keeprules\",\n-      androidJar.get().asFile.absolutePath,\n-      appTargetJar.get().asFile.absolutePath,\n-      androidTestSourceJar.get().asFile.absolutePath\n-    ).also {\n-      // print-uses is using its output to print rules\n-      standardOutput = outputProguardRules.asFile.get().outputStream().buffered()\n-    }\n+      listOf(\n+          \"--keeprules\",\n+          androidJar.get().asFile.absolutePath,\n+          appTargetJar.get().asFile.absolutePath,\n+          androidTestSourceJar.get().asFile.absolutePath\n+      ).also {\n+        // print-uses is using its output to print rules\n+        standardOutput = outputProguardRules.asFile.get().outputStream().buffered()\n+      }\n \n   private fun genTraceReferencesArgs(): List<String?> =\n-    listOf(\n-      \"--keep-rules\" to \"\",\n-      \"--lib\" to androidJar.get().asFile.absolutePath,\n-      \"--lib\" to androidTestJar.get().asFile.takeIf { it.exists() }?.absolutePath,\n-      \"--target\" to appTargetJar.get().asFile.absolutePath,\n-      \"--source\" to androidTestSourceJar.get().asFile.absolutePath,\n-      \"--output\" to outputProguardRules.get().asFile.absolutePath\n-    ).map { if (it.second != null) listOf(it.first, it.second) else listOf() }\n-      .reduce { acc, any -> acc + any }\n-      // Add user provided args coming from TraceReferences.arguments after generated ones.\n-      .plus(traceReferencesArgs.getOrElse(listOf()))\n+      listOf(\n+          \"--keep-rules\" to \"\",\n+          \"--lib\" to androidJar.get().asFile.absolutePath,\n+          \"--lib\" to androidTestJar.get().asFile.takeIf { it.exists() }?.absolutePath,\n+          \"--target\" to appTargetJar.get().asFile.absolutePath,\n+          \"--source\" to androidTestSourceJar.get().asFile.absolutePath,\n+          \"--output\" to outputProguardRules.get().asFile.absolutePath\n+      ).map { if (it.second != null) listOf(it.first, it.second) else listOf() }\n+          .reduce { acc, any -> acc + any }\n+          // Add user provided args coming from TraceReferences.arguments after generated ones.\n+          .plus(traceReferencesArgs.getOrElse(listOf()))\n \n   public companion object {\n     @Suppress(\"UNCHECKED_CAST\", \"UnstableApiUsage\")\n@@ -173,8 +175,9 @@ public abstract class InferAndroidTestKeepRules : JavaExec() {\n       this.traceReferencesArgs.set(traceReferencesArgs)\n       outputProguardRules.set(\n           project.layout.buildDirectory.file(\n-              \"${KeeperPlugin.INTERMEDIATES_DIR}/inferred${variantName.capitalize(\n-                  Locale.US)}KeepRules.pro\"))\n+              \"${KeeperPlugin.INTERMEDIATES_DIR}/${\n+                variantName.capitalize(Locale.US)\n+              }/inferredKeepRules.pro\"))\n       classpath(r8Configuration)\n       mainClass.set(this.traceReferencesEnabled.map { enabled ->\n         when (enabled) {"
  },
  {
    "sha": "b7c5361332d22b7f16dec652a9fd6d3abbb68ea1",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/KeeperPlugin.kt",
    "status": "modified",
    "additions": 43,
    "deletions": 30,
    "changes": 73,
    "blob_url": "https://github.com/slackhq/keeper/blob/aa5b1067df50635869f78d74a2da8cbd438e242e/keeper-gradle-plugin/src/main/java/com/slack/keeper/KeeperPlugin.kt",
    "raw_url": "https://github.com/slackhq/keeper/raw/aa5b1067df50635869f78d74a2da8cbd438e242e/keeper-gradle-plugin/src/main/java/com/slack/keeper/KeeperPlugin.kt",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/KeeperPlugin.kt?ref=aa5b1067df50635869f78d74a2da8cbd438e242e",
    "patch": "@@ -106,16 +106,14 @@ public class KeeperPlugin : Plugin<Project> {\n     project.pluginManager.withPlugin(\"com.android.application\") {\n       val appExtension = project.extensions.getByType<AppExtension>()\n       val extension = project.extensions.create<KeeperExtension>(\"keeper\")\n-      val diagnosticOutputDir = project.layout.buildDirectory.dir(\"$INTERMEDIATES_DIR/diagnostics\")\n-      project.configureKeepRulesGeneration(appExtension, extension, diagnosticOutputDir)\n-      project.configureL8Rules(appExtension, extension, diagnosticOutputDir)\n+      project.configureKeepRulesGeneration(appExtension, extension)\n+      project.configureL8Rules(appExtension, extension)\n     }\n   }\n \n   private fun Project.configureL8Rules(\n       appExtension: AppExtension,\n-      extension: KeeperExtension,\n-      diagnosticOutputDir: Provider<Directory>\n+      extension: KeeperExtension\n   ) {\n     afterEvaluate {\n       if (extension.enableL8RuleSharing.getOrElse(false)) {\n@@ -132,8 +130,16 @@ public class KeeperPlugin : Plugin<Project> {\n             tasks\n                 .named<L8DexDesugarLibTask>(androidTestL8Task)\n                 .configure {\n+                  val taskName = name\n                   keepRulesFiles.from(inputFiles)\n                   keepRulesConfigurations.set(listOf(\"-dontobfuscate\"))\n+                  val diagnosticOutputDir = layout.buildDirectory.dir(\n+                      \"$INTERMEDIATES_DIR/l8-diagnostics/$taskName\")\n+\n+                  // We can't actually declare this because AGP's NonIncrementalTask will clear it\n+                  // during the task action\n+//                  outputs.dir(diagnosticOutputDir)\n+//                      .withPropertyName(\"diagnosticsDir\")\n \n                   if (extension.emitDebugInformation.getOrElse(false)) {\n                     doFirst {\n@@ -143,8 +149,14 @@ public class KeeperPlugin : Plugin<Project> {\n                           .joinToString(\"\\n\") {\n                             \"# Source: ${it.absolutePath}\\n${it.readText()}\"\n                           }\n-                      val configurations = keepRulesConfigurations.orNull.orEmpty().joinToString(\"\\n\", prefix = \"# Source: extra configurations\\n\")\n-                      diagnosticOutputDir.get().file(\"${testVariant.name}MergedL8Rules.pro\")\n+\n+                      val configurations = keepRulesConfigurations.orNull.orEmpty()\n+                          .joinToString(\n+                          \"\\n\",\n+                              prefix = \"# Source: extra configurations\\n\"\n+                          )\n+\n+                      diagnosticOutputDir.get().file(\"patchedL8Rules.pro\")\n                           .asFile\n                           .writeText(\"$mergedFilesContent\\n$configurations\")\n                     }\n@@ -160,8 +172,7 @@ public class KeeperPlugin : Plugin<Project> {\n \n   private fun Project.configureKeepRulesGeneration(\n       appExtension: AppExtension,\n-      extension: KeeperExtension,\n-      diagnosticOutputDir: Provider<Directory>\n+      extension: KeeperExtension\n   ) {\n     // Set up r8 configuration\n     val r8Configuration = configurations.create(CONFIGURATION_NAME) {\n@@ -180,18 +191,19 @@ public class KeeperPlugin : Plugin<Project> {\n     }\n \n     val androidJarRegularFileProvider = layout.file(provider {\n-        resolveAndroidEmbeddedJar(appExtension, \"android.jar\", checkIfExisting = true)\n+      resolveAndroidEmbeddedJar(appExtension, \"android.jar\", checkIfExisting = true)\n     })\n     val androidTestJarRegularFileProvider = layout.file(provider {\n-        resolveAndroidEmbeddedJar(appExtension, \"optional/android.test.base.jar\", checkIfExisting = false)\n+      resolveAndroidEmbeddedJar(appExtension, \"optional/android.test.base.jar\",\n+          checkIfExisting = false)\n     })\n \n     appExtension.testVariants.configureEach {\n       val appVariant = testedVariant\n       val extensionFilter = extension._variantFilter\n       val ignoredVariant = extensionFilter?.let {\n         logger.debug(\n-          \"$TAG Resolving ignored status for android variant ${appVariant.name}\")\n+            \"$TAG Resolving ignored status for android variant ${appVariant.name}\")\n         val filter = VariantFilterImpl(appVariant)\n         it.execute(filter)\n         logger.debug(\"$TAG Variant '${appVariant.name}' ignored? ${filter._ignored}\")\n@@ -219,11 +231,9 @@ public class KeeperPlugin : Plugin<Project> {\n     appExtension.onApplicableVariants(project, extension) { testVariant, appVariant ->\n       val intermediateAppJar = createIntermediateAppJar(\n           appVariant = appVariant,\n-          diagnosticOutputDir = diagnosticOutputDir,\n           emitDebugInfo = extension.emitDebugInformation\n       )\n       val intermediateAndroidTestJar = createIntermediateAndroidTestJar(\n-          diagnosticOutputDir = diagnosticOutputDir,\n           emitDebugInfo = extension.emitDebugInformation,\n           testVariant = testVariant,\n           appJarsProvider = intermediateAppJar.flatMap { it.appJarsFile }\n@@ -252,12 +262,12 @@ public class KeeperPlugin : Plugin<Project> {\n   }\n \n   private fun resolveAndroidEmbeddedJar(\n-    appExtension: AppExtension,\n-    path: String,\n-    checkIfExisting: Boolean\n+      appExtension: AppExtension,\n+      path: String,\n+      checkIfExisting: Boolean\n   ): File {\n     val compileSdkVersion = appExtension.compileSdkVersion\n-      ?: error(\"No compileSdkVersion found\")\n+        ?: error(\"No compileSdkVersion found\")\n     val file = File(\"${appExtension.sdkDirectory}/platforms/${compileSdkVersion}/${path}\")\n     check(!checkIfExisting || file.exists()) {\n       \"No $path found! Expected to find it at: ${file.absolutePath}\"\n@@ -266,9 +276,9 @@ public class KeeperPlugin : Plugin<Project> {\n   }\n \n   private fun AppExtension.onApplicableVariants(\n-    project: Project,\n-    extension: KeeperExtension,\n-    body: (TestVariant, BaseVariant) -> Unit\n+      project: Project,\n+      extension: KeeperExtension,\n+      body: (TestVariant, BaseVariant) -> Unit\n   ) {\n     testVariants.configureEach {\n       val testVariant = this\n@@ -332,7 +342,6 @@ public class KeeperPlugin : Plugin<Project> {\n    * This output is used in the inferAndroidTestUsage task.\n    */\n   private fun Project.createIntermediateAndroidTestJar(\n-      diagnosticOutputDir: Provider<Directory>,\n       emitDebugInfo: Provider<Boolean>,\n       testVariant: TestVariant,\n       appJarsProvider: Provider<RegularFile>\n@@ -341,7 +350,6 @@ public class KeeperPlugin : Plugin<Project> {\n         \"jar${testVariant.name.capitalize(Locale.US)}ClassesForKeeper\") {\n       group = KEEPER_TASK_GROUP\n       this.emitDebugInfo.value(emitDebugInfo)\n-      this.diagnosticsOutputDir.set(diagnosticOutputDir)\n       this.appJarsFile.set(appJarsProvider)\n \n       with(testVariant) {\n@@ -354,8 +362,12 @@ public class KeeperPlugin : Plugin<Project> {\n             }\n       }\n \n-      archiveFile.set(layout.buildDirectory.dir(INTERMEDIATES_DIR).map {\n-        it.file(\"${testVariant.name}.jar\")\n+      val outputDir = layout.buildDirectory.dir(\"$INTERMEDIATES_DIR/${testVariant.name}\")\n+      val diagnosticsDir = layout.buildDirectory.dir(\n+          \"$INTERMEDIATES_DIR/${testVariant.name}/diagnostics\")\n+      this.diagnosticsOutputDir.set(diagnosticsDir)\n+      archiveFile.set(outputDir.map {\n+        it.file(\"classes.jar\")\n       })\n     }\n   }\n@@ -366,13 +378,11 @@ public class KeeperPlugin : Plugin<Project> {\n    */\n   private fun Project.createIntermediateAppJar(\n       appVariant: BaseVariant,\n-      diagnosticOutputDir: Provider<Directory>,\n       emitDebugInfo: Provider<Boolean>\n   ): TaskProvider<out VariantClasspathJar> {\n     return tasks.register<VariantClasspathJar>(\n         \"jar${appVariant.name.capitalize(Locale.US)}ClassesForKeeper\") {\n       group = KEEPER_TASK_GROUP\n-      this.diagnosticsOutputDir.set(diagnosticOutputDir)\n       this.emitDebugInfo.set(emitDebugInfo)\n       with(appVariant) {\n         from(layout.dir(javaCompileProvider.map { it.destinationDir }))\n@@ -385,9 +395,12 @@ public class KeeperPlugin : Plugin<Project> {\n             }\n       }\n \n-      val intermediatesDir = layout.buildDirectory.dir(INTERMEDIATES_DIR)\n-      archiveFile.set(intermediatesDir.map { it.file(\"${appVariant.name}.jar\") })\n-      appJarsFile.set(intermediatesDir.map { it.file(\"${appVariant.name}Jars.txt\") })\n+      val outputDir = layout.buildDirectory.dir(\"$INTERMEDIATES_DIR/${appVariant.name}\")\n+      val diagnosticsDir = layout.buildDirectory.dir(\n+          \"$INTERMEDIATES_DIR/${appVariant.name}/diagnostics\")\n+      diagnosticsOutputDir.set(diagnosticsDir)\n+      archiveFile.set(outputDir.map { it.file(\"classes.jar\") })\n+      appJarsFile.set(outputDir.map { it.file(\"jars.txt\") })\n     }\n   }\n }"
  },
  {
    "sha": "31562907ef1b49eeea9f8ea9bb98255124056da8",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/VariantClasspathJar.kt",
    "status": "modified",
    "additions": 7,
    "deletions": 7,
    "changes": 14,
    "blob_url": "https://github.com/slackhq/keeper/blob/aa5b1067df50635869f78d74a2da8cbd438e242e/keeper-gradle-plugin/src/main/java/com/slack/keeper/VariantClasspathJar.kt",
    "raw_url": "https://github.com/slackhq/keeper/raw/aa5b1067df50635869f78d74a2da8cbd438e242e/keeper-gradle-plugin/src/main/java/com/slack/keeper/VariantClasspathJar.kt",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/VariantClasspathJar.kt?ref=aa5b1067df50635869f78d74a2da8cbd438e242e",
    "patch": "@@ -18,8 +18,8 @@\n \n package com.slack.keeper\n \n-import com.slack.keeper.internal.zipflinger.BytesSource\n-import com.slack.keeper.internal.zipflinger.ZipArchive\n+import com.android.zipflinger.BytesSource\n+import com.android.zipflinger.ZipArchive\n import org.gradle.api.DefaultTask\n import org.gradle.api.file.ConfigurableFileCollection\n import org.gradle.api.file.DirectoryProperty\n@@ -112,7 +112,7 @@ public abstract class VariantClasspathJar : BaseKeeperJarTask() {\n \n     appJarsFile.get().asFile.writeText(appJars.sorted().joinToString(\"\\n\"))\n \n-    diagnostic(\"${archiveFile.get().asFile.nameWithoutExtension}Classes\") {\n+    diagnostic(\"classes\") {\n       appClasses.sorted()\n           .joinToString(\"\\n\")\n     }\n@@ -156,7 +156,7 @@ public abstract class AndroidTestVariantClasspathJar : BaseKeeperJarTask() {\n     val appJars = appJarsFile.get().asFile.useLines { it.toSet() }\n \n     val androidTestClasspath = androidTestArtifactFiles.files\n-    diagnostic(\"${archiveFile.get().asFile.nameWithoutExtension}Jars\") {\n+    diagnostic(\"jars\") {\n       androidTestClasspath.sortedBy { it.canonicalPath }\n           .joinToString(\"\\n\") {\n             it.canonicalPath\n@@ -167,7 +167,7 @@ public abstract class AndroidTestVariantClasspathJar : BaseKeeperJarTask() {\n       removeAll { it.canonicalPath in appJars }\n     }\n \n-    diagnostic(\"${archiveFile.get().asFile.nameWithoutExtension}DistinctJars\") {\n+    diagnostic(\"distinctJars\") {\n       distinctAndroidTestClasspath.sortedBy { it.canonicalPath }\n           .joinToString(\"\\n\") {\n             it.canonicalPath\n@@ -195,7 +195,7 @@ public abstract class AndroidTestVariantClasspathJar : BaseKeeperJarTask() {\n           }\n     }\n \n-    diagnostic(\"${archiveFile.get().asFile.nameWithoutExtension}Classes\") {\n+    diagnostic(\"androidTestClasses\") {\n       androidTestClasses.sorted().joinToString(\"\\n\")\n     }\n \n@@ -208,7 +208,7 @@ public abstract class AndroidTestVariantClasspathJar : BaseKeeperJarTask() {\n           .filterTo(LinkedHashSet()) { it in androidTestClasses }\n \n       if (duplicateClasses.isNotEmpty()) {\n-        val output = diagnostic(\"${archiveFile.get().asFile.nameWithoutExtension}DuplicateClasses\") {\n+        val output = diagnostic(\"duplicateClasses\") {\n           duplicateClasses.sorted().joinToString(\"\\n\")\n         }\n         logger.warn(\"Duplicate classes found in androidTest APK and app APK! This\" +"
  },
  {
    "sha": "2db7a8298f5298ca9db293114136d08709400402",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/ZipFlingerExt.kt",
    "status": "modified",
    "additions": 18,
    "deletions": 3,
    "changes": 21,
    "blob_url": "https://github.com/slackhq/keeper/blob/aa5b1067df50635869f78d74a2da8cbd438e242e/keeper-gradle-plugin/src/main/java/com/slack/keeper/ZipFlingerExt.kt",
    "raw_url": "https://github.com/slackhq/keeper/raw/aa5b1067df50635869f78d74a2da8cbd438e242e/keeper-gradle-plugin/src/main/java/com/slack/keeper/ZipFlingerExt.kt",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/ZipFlingerExt.kt?ref=aa5b1067df50635869f78d74a2da8cbd438e242e",
    "patch": "@@ -1,8 +1,9 @@\n package com.slack.keeper\n \n-import com.slack.keeper.internal.zipflinger.ZipArchive\n-import com.slack.keeper.internal.zipflinger.ZipSource\n+import com.android.zipflinger.ZipArchive\n+import com.android.zipflinger.ZipSource\n import java.io.File\n+import java.nio.file.Path\n \n /**\n  * Returns a sequence of pairs representing the class files and their relative names for use in a\n@@ -20,7 +21,7 @@ internal fun File.classesSequence(): Sequence<Pair<String, File>> {\n  * Extracts classes from the target [jar] into this archive.\n  */\n internal fun ZipArchive.extractClassesFrom(jar: File, callback: (String) -> Unit) {\n-  val jarSource = ZipSource(jar)\n+  val jarSource = newZipSource(jar)\n   jarSource.entries()\n       .filterNot { \"META-INF\" in it.key }\n       .forEach { (name, entry) ->\n@@ -32,4 +33,18 @@ internal fun ZipArchive.extractClassesFrom(jar: File, callback: (String) -> Unit\n         }\n       }\n   add(jarSource)\n+}\n+\n+private fun newZipSource(jar: File): ZipSource {\n+  return try {\n+    // AGP 4.1/4.2\n+    ZipSource::class.java\n+        .getDeclaredConstructor(File::class.java)\n+        .newInstance(jar)\n+  } catch (e: NoSuchMethodException) {\n+    // AGP/ZipFlinger 7+\n+    ZipSource::class.java\n+        .getDeclaredConstructor(Path::class.java)\n+        .newInstance(jar.toPath())\n+  }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "a2f0c017c1f4cd4377416d9dca480b2e2248fedc",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Archive.java",
    "status": "removed",
    "additions": 0,
    "deletions": 55,
    "changes": 55,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Archive.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Archive.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Archive.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,55 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.io.Closeable;\n-import java.io.IOException;\n-\n-public interface Archive extends Closeable {\n-\n-    /**\n-     * Add a source to the archive.\n-     *\n-     * @param source The source to add to this zip archive.\n-     * @throws IllegalStateException if the entry name already exists in the archive.\n-     * @throws IOException if writing to the zip archive fails.\n-     */\n-    void add(@NonNull BytesSource source) throws IOException;\n-\n-    /**\n-     * Add a set of selected entries from an other zip archive.\n-     *\n-     * @param sources A zip archive with selected entries to add to this zip archive.\n-     * @throws IllegalStateException if the entry name already exists in the archive.\n-     * @throws IOException if writing to the zip archive fails.\n-     */\n-    void add(@NonNull ZipSource sources) throws IOException;\n-\n-    /**\n-     * Delete an entry from this archive. If the entry did not exist, this method does nothing. To\n-     * avoid creating \"holes\" in the archive, it is mendatory to delete all entries first and add\n-     * sources second.\n-     *\n-     * @param name The name of the entry to delete.\n-     * @throws IllegalStateException if entries have been added.\n-     */\n-    void delete(@NonNull String name) throws IOException;\n-\n-    @Override\n-    void close() throws IOException;\n-}"
  },
  {
    "sha": "d2ac4f06941fccc21ef815755f7a9308283344fc",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/BytesSource.java",
    "status": "removed",
    "additions": 0,
    "deletions": 101,
    "changes": 101,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/BytesSource.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/BytesSource.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/BytesSource.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,101 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.util.zip.Deflater;\n-\n-public class BytesSource extends Source {\n-\n-    // Bytes to be written in the zip, after the Local File Header.\n-    private ByteBuffer zipEntryPayload;\n-\n-    // Bytes as there were provided to this class (before compression if any).\n-    private ByteBuffer byteBuffer;\n-\n-    /**\n-     * @param bytes\n-     * @param name\n-     * @param compressionLevel One of java.util.zip.Deflater compression level.\n-     */\n-    public BytesSource(@NonNull byte[] bytes, @NonNull String name, int compressionLevel)\n-            throws IOException {\n-        super(name);\n-        build(bytes, bytes.length, compressionLevel);\n-    }\n-\n-    public BytesSource(@NonNull File file, @NonNull String name, int compressionLevel)\n-            throws IOException {\n-        super(name);\n-        byte[] bytes = Files.readAllBytes(file.toPath());\n-        build(bytes, bytes.length, compressionLevel);\n-    }\n-\n-    /**\n-     * @param stream BytesSource takes ownership of the InputStream and will close it after draining\n-     *     it.\n-     * @param name\n-     * @param compressionLevel\n-     * @throws IOException\n-     */\n-    public BytesSource(@NonNull InputStream stream, @NonNull String name, int compressionLevel)\n-            throws IOException {\n-        super(name);\n-        try (NoCopyByteArrayOutputStream ncbos = new NoCopyByteArrayOutputStream(16000)) {\n-            byte[] tmpBuffer = new byte[16000];\n-            int bytesRead;\n-            while ((bytesRead = stream.read(tmpBuffer)) != -1) {\n-                ncbos.write(tmpBuffer, 0, bytesRead);\n-            }\n-            stream.close();\n-            build(ncbos.buf(), ncbos.getCount(), compressionLevel);\n-        }\n-    }\n-\n-    private void build(byte[] bytes, int size, int compressionLevel) throws IOException {\n-        byteBuffer = ByteBuffer.wrap(bytes, 0, size);\n-        crc = com.slack.keeper.internal.zipflinger.Crc32.crc32(bytes, 0, size);\n-        uncompressedSize = size;\n-        if (compressionLevel == Deflater.NO_COMPRESSION) {\n-            zipEntryPayload = ByteBuffer.wrap(bytes, 0, size);\n-            compressedSize = uncompressedSize;\n-            compressionFlag = com.slack.keeper.internal.zipflinger.LocalFileHeader.COMPRESSION_NONE;\n-        } else {\n-            zipEntryPayload = Compressor.deflate(bytes, 0, size, compressionLevel);\n-            compressedSize = zipEntryPayload.limit();\n-            compressionFlag = com.slack.keeper.internal.zipflinger.LocalFileHeader.COMPRESSION_DEFLATE;\n-        }\n-    }\n-\n-    @NonNull\n-    public ByteBuffer getBuffer() {\n-        return byteBuffer;\n-    }\n-\n-    @Override\n-    void prepare() {}\n-\n-    @Override\n-    long writeTo(@NonNull com.slack.keeper.internal.zipflinger.ZipWriter writer) throws IOException {\n-        return writer.write(zipEntryPayload);\n-    }\n-}"
  },
  {
    "sha": "15bf94ba595ed59287e798a02a2976af757e97d5",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/CentralDirectory.java",
    "status": "removed",
    "additions": 0,
    "deletions": 151,
    "changes": 151,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/CentralDirectory.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/CentralDirectory.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/CentralDirectory.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,151 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import com.android.annotations.Nullable;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-class CentralDirectory {\n-\n-    // The Central Directory as it was read when an archive already existed.\n-    private final ByteBuffer buf;\n-\n-    private final List<Location> deletedLocations = new ArrayList<>();\n-    private final Map<String, Entry> entries;\n-    private final Map<String, com.slack.keeper.internal.zipflinger.CentralDirectoryRecord> addedEntries = new HashMap<>();\n-\n-    CentralDirectory(@NonNull ByteBuffer buf, @NonNull Map<String, Entry> entries) {\n-        this.buf = buf;\n-        this.entries = entries;\n-    }\n-\n-    @NonNull\n-    Location delete(@NonNull String name) {\n-        if (entries.containsKey(name)) {\n-            Entry entry = entries.get(name);\n-            deletedLocations.add(entry.getCdLocation());\n-            entries.remove(name);\n-            return entry.getLocation();\n-        }\n-        if (addedEntries.containsKey(name)) {\n-            com.slack.keeper.internal.zipflinger.CentralDirectoryRecord record = addedEntries.remove(name);\n-            return record.getLocation();\n-        }\n-        return Location.INVALID;\n-    }\n-\n-    long getNumEntries() {\n-        return entries.size() + addedEntries.size();\n-    }\n-\n-    void write(@NonNull com.slack.keeper.internal.zipflinger.ZipWriter writer) throws IOException {\n-        // Four steps operations (first write old entries then new entries):\n-        // 1/ Sort deleted entries by location.\n-        // 2/ Create a list of \"clean\" (not deleted) locations.\n-        // 3/ Write all old (non-deleted) locations.\n-        // 4/ Write all new entries.\n-\n-        // Step 1\n-        Collections.sort(deletedLocations);\n-\n-        // Step 2 (Build list of non-deleted locations).\n-        List<Location> cleanCDLocations = new ArrayList<>();\n-        long remainingStart = 0;\n-        long remainingSize = buf.capacity();\n-\n-        for (Location deletedLocation : deletedLocations) {\n-            Location cleanLoc =\n-                    new Location(remainingStart, deletedLocation.first - remainingStart);\n-\n-            // If cleanLoc is the left end of the remaining CD, cleanLoc size is 0.\n-            if (cleanLoc.size() > 0) {\n-                cleanCDLocations.add(cleanLoc);\n-            }\n-            remainingStart = deletedLocation.last + 1;\n-            remainingSize -= (deletedLocation.size() + cleanLoc.size());\n-        }\n-        // Add the remaining of the CD as a clear location\n-        if (remainingSize > 0) {\n-            cleanCDLocations.add(new Location(remainingStart, remainingSize));\n-        }\n-\n-        // Step 3: write clean CD chunks\n-        for (Location toWrite : cleanCDLocations) {\n-            buf.limit(Math.toIntExact(toWrite.first + toWrite.size()));\n-            buf.position(Math.toIntExact(toWrite.first));\n-            ByteBuffer view = buf.slice();\n-            writer.write(view);\n-        }\n-\n-        // Step 4: write new entries\n-\n-        // Assess how much data the CD requires\n-        long totalSize = 0;\n-        for (com.slack.keeper.internal.zipflinger.CentralDirectoryRecord record : addedEntries.values()) {\n-            totalSize += record.getSize();\n-        }\n-        // Generate the CD portion of new entries\n-        ByteBuffer cdBuffer =\n-                ByteBuffer.allocate(Math.toIntExact(totalSize)).order(ByteOrder.LITTLE_ENDIAN);\n-        for (com.slack.keeper.internal.zipflinger.CentralDirectoryRecord record : addedEntries.values()) {\n-            record.write(cdBuffer);\n-        }\n-\n-        // Write new entries\n-        cdBuffer.rewind();\n-        writer.write(cdBuffer);\n-    }\n-\n-    void add(@NonNull String name, @NonNull com.slack.keeper.internal.zipflinger.CentralDirectoryRecord record) {\n-        addedEntries.put(name, record);\n-    }\n-\n-    boolean contains(@NonNull String name) {\n-        return entries.containsKey(name) || addedEntries.containsKey(name);\n-    }\n-\n-    @NonNull\n-    List<String> listEntries() {\n-        List<String> list = new ArrayList<>();\n-        list.addAll(entries.keySet());\n-        list.addAll(addedEntries.keySet());\n-        return list;\n-    }\n-\n-    @Nullable\n-    public ExtractionInfo getExtractionInfo(@NonNull String name) {\n-        Entry entry = entries.get(name);\n-        if (entry != null) {\n-            return new ExtractionInfo(entry.getPayloadLocation(), entry.isCompressed());\n-        }\n-\n-        com.slack.keeper.internal.zipflinger.CentralDirectoryRecord cd = addedEntries.get(name);\n-        if (cd != null) {\n-            boolean isCompressed = cd.getCompressionFlag() != com.slack.keeper.internal.zipflinger.LocalFileHeader.COMPRESSION_NONE;\n-            return new ExtractionInfo(cd.getPayloadLocation(), isCompressed);\n-        }\n-\n-        return null;\n-    }\n-}"
  },
  {
    "sha": "bae9037a1b281fce65e39f1facc85e0bec542699",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/CentralDirectoryRecord.java",
    "status": "removed",
    "additions": 0,
    "deletions": 138,
    "changes": 138,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/CentralDirectoryRecord.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/CentralDirectoryRecord.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/CentralDirectoryRecord.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,138 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-\n-class CentralDirectoryRecord {\n-\n-    public static final int SIGNATURE = 0x02014b50;\n-    public static final int SIZE = 46;\n-    public static final int DATA_DESCRIPTOR_FLAG = 0x0008;\n-    public static final int DATA_DESCRIPTOR_SIGNATURE = 0x08074b50;\n-\n-    // JDK 9 consider time&data field with value 0 as invalid. Use 1 instead.\n-    // These are in MS-DOS 16-bit format. For actual specs, see:\n-    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms724247(v=vs.85).aspx\n-    public static final short DEFAULT_TIME = 1 | 1 << 5 | 1 << 11;\n-    public static final short DEFAULT_DATE = 1 | 1 << 5 | 1 << 9;\n-\n-    // Zip64 extra format:\n-    // uint16_t id (0x0001)\n-    // uint16_t size payload (0x18)\n-    // Payload:\n-    //    - uint64_t Uncompressed size.\n-    //    - uint64_t Compressed size.\n-    //    - uint64_t offset to LFH in archive.\n-    private static final int ZIP64_PAYLOAD_SIZE = Long.BYTES * 3;\n-    private static final int ZIP64_EXTRA_SIZE = Short.BYTES * 2 + ZIP64_PAYLOAD_SIZE;\n-\n-    private final byte[] nameBytes;\n-    private final int crc;\n-    private final long compressedSize;\n-    private final long uncompressedSize;\n-    // Location of the Local file header to end of payload in file space.\n-    private final Location location;\n-    private final short compressionFlag;\n-    private final Location payloadLocation;\n-    private final boolean isZip64;\n-\n-    CentralDirectoryRecord(\n-            @NonNull byte[] nameBytes,\n-            int crc,\n-            long compressedSize,\n-            long uncompressedSize,\n-            Location location,\n-            short compressionFlag,\n-            Location payloadLocation) {\n-        this.nameBytes = nameBytes;\n-        this.crc = crc;\n-        this.compressedSize = compressedSize;\n-        this.uncompressedSize = uncompressedSize;\n-        this.location = location;\n-        this.compressionFlag = compressionFlag;\n-        this.payloadLocation = payloadLocation;\n-        this.isZip64 =\n-                compressedSize > Zip64.LONG_MAGIC\n-                        || uncompressedSize > Zip64.LONG_MAGIC\n-                        || location.first > Zip64.LONG_MAGIC;\n-    }\n-\n-    void write(@NonNull ByteBuffer buf) {\n-        short versionNeeded = isZip64 ? Zip64.VERSION_NEEDED : 0;\n-        int size = isZip64 ? Zip64.INT_MAGIC : com.slack.keeper.internal.zipflinger.Ints.longToUint(uncompressedSize);\n-        int csize = isZip64 ? Zip64.INT_MAGIC : com.slack.keeper.internal.zipflinger.Ints.longToUint(compressedSize);\n-        int offset = isZip64 ? Zip64.INT_MAGIC : com.slack.keeper.internal.zipflinger.Ints.longToUint(location.first);\n-\n-        ByteBuffer extra = buildExtraField();\n-\n-        buf.putInt(SIGNATURE);\n-        buf.putShort((short) 0); // version made by\n-        buf.putShort(versionNeeded);\n-        buf.putShort((short) 0); // flag\n-        buf.putShort(compressionFlag);\n-        buf.putShort(DEFAULT_TIME);\n-        buf.putShort(DEFAULT_DATE);\n-        buf.putInt(crc);\n-        buf.putInt(csize); // compressed size\n-        buf.putInt(size); // size\n-        buf.putShort(com.slack.keeper.internal.zipflinger.Ints.intToUshort(nameBytes.length));\n-        buf.putShort(com.slack.keeper.internal.zipflinger.Ints.intToUshort(extra.capacity()));\n-        buf.putShort((short) 0); // comment size\n-        buf.putShort((short) 0); // disk # start\n-        buf.putShort((short) 0); // internal att\n-        buf.putInt(0); // external att\n-        buf.putInt(offset);\n-        buf.put(nameBytes);\n-        buf.put(extra);\n-    }\n-\n-    short getCompressionFlag() {\n-        return compressionFlag;\n-    }\n-\n-    long getSize() {\n-        long extraSize = isZip64 ? ZIP64_EXTRA_SIZE : 0;\n-        return SIZE + nameBytes.length + extraSize;\n-    }\n-\n-    @NonNull\n-    Location getPayloadLocation() {\n-        return payloadLocation;\n-    }\n-\n-    @NonNull\n-    Location getLocation() {\n-        return location;\n-    }\n-\n-    @NonNull\n-    private ByteBuffer buildExtraField() {\n-        if (!isZip64) {\n-            return ByteBuffer.allocate(0);\n-        }\n-        ByteBuffer buf = ByteBuffer.allocate(ZIP64_EXTRA_SIZE).order(ByteOrder.LITTLE_ENDIAN);\n-        buf.putShort(Zip64.EXTRA_ID);\n-        buf.putShort(com.slack.keeper.internal.zipflinger.Ints.intToUshort(ZIP64_PAYLOAD_SIZE));\n-        buf.putLong(uncompressedSize);\n-        buf.putLong(compressedSize);\n-        buf.putLong(location.first);\n-        buf.rewind();\n-        return buf;\n-    }\n-}"
  },
  {
    "sha": "dcbc7680fc5a6f8c283fa32a9014a9af44dc535b",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Compressor.java",
    "status": "removed",
    "additions": 0,
    "deletions": 62,
    "changes": 62,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Compressor.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Compressor.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Compressor.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,62 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.zip.Deflater;\n-import java.util.zip.DeflaterOutputStream;\n-import java.util.zip.Inflater;\n-import java.util.zip.InflaterOutputStream;\n-\n-public class Compressor {\n-\n-    @NonNull\n-    public static ByteBuffer deflate(\n-            @NonNull byte[] bytes, int offset, int size, int compressionLevel) throws IOException {\n-        NoCopyByteArrayOutputStream out = new NoCopyByteArrayOutputStream(size);\n-\n-        Deflater deflater = new Deflater(compressionLevel, true);\n-\n-        try (DeflaterOutputStream dout = new DeflaterOutputStream(out, deflater)) {\n-            dout.write(bytes, offset, size);\n-            dout.flush();\n-        }\n-\n-        return out.getByteBuffer();\n-    }\n-\n-    @NonNull\n-    public static ByteBuffer deflate(@NonNull byte[] bytes, int compressionLevel)\n-            throws IOException {\n-        return deflate(bytes, 0, bytes.length, compressionLevel);\n-    }\n-\n-    @NonNull\n-    public static ByteBuffer inflate(@NonNull byte[] bytes) throws IOException {\n-        NoCopyByteArrayOutputStream out = new NoCopyByteArrayOutputStream(bytes.length);\n-        Inflater inflater = new Inflater(true);\n-\n-        try (InflaterOutputStream dout = new InflaterOutputStream(out, inflater)) {\n-            dout.write(bytes);\n-            dout.flush();\n-        }\n-\n-        return out.getByteBuffer();\n-    }\n-}"
  },
  {
    "sha": "bedc4e6264e3b52b5f39244641040429c2d2874d",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Crc32.java",
    "status": "removed",
    "additions": 0,
    "deletions": 33,
    "changes": 33,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Crc32.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Crc32.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Crc32.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,33 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.util.zip.CRC32;\n-\n-class Crc32 {\n-\n-    public static int crc32(@NonNull byte[] bytes) {\n-        return crc32(bytes, 0, bytes.length);\n-    }\n-\n-    public static int crc32(@NonNull byte[] bytes, int offset, int size) {\n-        CRC32 crc = new CRC32();\n-        crc.update(bytes, offset, size);\n-        return com.slack.keeper.internal.zipflinger.Ints.longToUint(crc.getValue());\n-    }\n-}"
  },
  {
    "sha": "af1e26124278539aa74e63a9b10d3a5871797363",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/EndOfCentralDirectory.java",
    "status": "removed",
    "additions": 0,
    "deletions": 126,
    "changes": 126,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/EndOfCentralDirectory.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/EndOfCentralDirectory.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/EndOfCentralDirectory.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,126 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.nio.channels.FileChannel;\n-\n-class EndOfCentralDirectory {\n-    private static final int SIGNATURE = 0x06054b50;\n-    static final int SIZE = 22;\n-    private static final long MAX_SIZE = com.slack.keeper.internal.zipflinger.Ints.USHRT_MAX + SIZE;\n-    static final short DISK_NUMBER = 0;\n-\n-    private int numEntries;\n-    private Location location;\n-    private Location cdLocation;\n-\n-    private EndOfCentralDirectory() {\n-        this.numEntries = 0;\n-        this.location = Location.INVALID;\n-        this.cdLocation = Location.INVALID;\n-    }\n-\n-    private void parse(@NonNull ByteBuffer buffer) {\n-        // skip diskNumber (2) + cdDiskNumber (2) + #entries (2)\n-        buffer.position(buffer.position() + 6);\n-        numEntries = com.slack.keeper.internal.zipflinger.Ints.ushortToInt(buffer.getShort());\n-        long cdSize = com.slack.keeper.internal.zipflinger.Ints.uintToLong(buffer.getInt());\n-        long cdOffset = com.slack.keeper.internal.zipflinger.Ints.uintToLong(buffer.getInt());\n-        cdLocation = new Location(cdOffset, cdSize);\n-        buffer.position(buffer.position() + 2); // Skip comment length\n-    }\n-\n-    @NonNull\n-    public Location getLocation() {\n-        return location;\n-    }\n-\n-    @NonNull\n-    public Location getCdLocation() {\n-        return cdLocation;\n-    }\n-\n-    public int numEntries() {\n-        return numEntries;\n-    }\n-\n-    public void setLocation(@NonNull Location location) {\n-        this.location = location;\n-    }\n-\n-    // Search the EOCD. If not found the returned object location will be set to Location.INVALID.\n-    @NonNull\n-    public static EndOfCentralDirectory find(@NonNull FileChannel channel) throws IOException {\n-        long fileSize = channel.size();\n-\n-        EndOfCentralDirectory eocd = new EndOfCentralDirectory();\n-        if (fileSize < SIZE) {\n-            return eocd;\n-        }\n-\n-        int sizeToRead = Math.toIntExact(Math.min(fileSize, MAX_SIZE));\n-        long offset = fileSize - sizeToRead;\n-\n-        ByteBuffer buffer = ByteBuffer.allocate(sizeToRead).order(ByteOrder.LITTLE_ENDIAN);\n-        channel.read(buffer, offset);\n-        buffer.position(buffer.capacity() - SIZE);\n-        while (true) {\n-            int signature = buffer.getInt(); // Read 4 bytes.\n-            if (signature == EndOfCentralDirectory.SIGNATURE) {\n-                eocd.parse(buffer);\n-                eocd.setLocation(new Location(offset + buffer.position() - SIZE, SIZE));\n-                break;\n-            }\n-            if (buffer.position() <= 4) {\n-                break;\n-            }\n-            buffer.position(buffer.position() - Integer.BYTES - 1); // Backtrack  5 bytes.\n-        }\n-        return eocd;\n-    }\n-\n-    @NonNull\n-    public static Location write(\n-            @NonNull com.slack.keeper.internal.zipflinger.ZipWriter writer, @NonNull Location cdLocation, long entriesCount)\n-            throws IOException {\n-        boolean isZip64 = Zip64.needZip64Footer(entriesCount, cdLocation);\n-\n-        short numEntries = isZip64 ? Zip64.SHORT_MAGIC : com.slack.keeper.internal.zipflinger.Ints.longToUshort(entriesCount);\n-        int eocdSize = isZip64 ? Zip64.INT_MAGIC : com.slack.keeper.internal.zipflinger.Ints.longToUint(cdLocation.size());\n-        int eocdOffset = isZip64 ? Zip64.INT_MAGIC : com.slack.keeper.internal.zipflinger.Ints.longToUint(cdLocation.first);\n-\n-        ByteBuffer eocd = ByteBuffer.allocate(SIZE).order(ByteOrder.LITTLE_ENDIAN);\n-        eocd.putInt(SIGNATURE);\n-        eocd.putShort(DISK_NUMBER);\n-        eocd.putShort((short) 0); // cd disk number\n-        eocd.putShort(numEntries);\n-        eocd.putShort(numEntries);\n-        eocd.putInt(eocdSize);\n-        eocd.putInt(eocdOffset);\n-        eocd.putShort((short) 0); // comment size\n-\n-        eocd.rewind();\n-        long position = writer.position();\n-        writer.write(eocd);\n-\n-        return new Location(position, SIZE);\n-    }\n-\n-}"
  },
  {
    "sha": "91b38b64ad1ab711b9f86ba3894bd9dea730da46",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Entry.java",
    "status": "removed",
    "additions": 0,
    "deletions": 115,
    "changes": 115,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Entry.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Entry.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Entry.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,115 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.nio.charset.StandardCharsets;\n-\n-public class Entry {\n-\n-    // The location (in file space) of the zip entry which includes the LFH, payload and\n-    // Data descriptor.\n-    private Location location = Location.INVALID;\n-\n-    // The location (in CD space) of this entry in the CD.\n-    private Location cdLocation = Location.INVALID;\n-\n-    // The location (in file space) of the zip entry payload (the actual file data).\n-    private Location payloadLocation = Location.INVALID;\n-\n-    private String name = \"\";\n-    private int crc;\n-    private long compressedSize;\n-    private long uncompressedSize;\n-    private short compressionFlag;\n-\n-    Entry() {}\n-\n-    public short getCompressionFlag() {\n-        return compressionFlag;\n-    }\n-\n-    public long getCompressedSize() {\n-        return compressedSize;\n-    }\n-\n-    public long getUncompressedSize() {\n-        return uncompressedSize;\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    public int getCrc() {\n-        return crc;\n-    }\n-\n-    public boolean isDirectory() {\n-        return name.charAt(name.length() - 1) == '/';\n-    }\n-\n-    public boolean isCompressed() {\n-        return compressionFlag != com.slack.keeper.internal.zipflinger.LocalFileHeader.COMPRESSION_NONE;\n-    }\n-\n-    @NonNull\n-    Location getCdLocation() {\n-        return cdLocation;\n-    }\n-\n-    @NonNull\n-    Location getLocation() {\n-        return location;\n-    }\n-\n-    @NonNull\n-    Location getPayloadLocation() {\n-        return payloadLocation;\n-    }\n-\n-    void setCdLocation(@NonNull Location cdLocation) {\n-        this.cdLocation = cdLocation;\n-    }\n-\n-    void setNameBytes(@NonNull byte[] nameBytes) {\n-        this.name = new String(nameBytes, StandardCharsets.UTF_8);\n-    }\n-\n-    void setCrc(int crc) {\n-        this.crc = crc;\n-    }\n-\n-    void setPayloadLocation(@NonNull Location payloadLocation) {\n-        this.payloadLocation = payloadLocation;\n-    }\n-\n-    void setCompressionFlag(short compressionFlag) {\n-        this.compressionFlag = compressionFlag;\n-    }\n-\n-    void setCompressedSize(long compressedSize) {\n-        this.compressedSize = compressedSize;\n-    }\n-\n-    void setUncompressedSize(long ucompressedSize) {\n-        this.uncompressedSize = ucompressedSize;\n-    }\n-\n-    void setLocation(@NonNull Location location) {\n-        this.location = location;\n-    }\n-}"
  },
  {
    "sha": "73861187f5f6376530ec1341570dd795d12d9f89",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/ExtractionInfo.java",
    "status": "removed",
    "additions": 0,
    "deletions": 38,
    "changes": 38,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/ExtractionInfo.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/ExtractionInfo.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/ExtractionInfo.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,38 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-\n-public class ExtractionInfo {\n-    private final Location location;\n-    private final boolean isCompressed;\n-\n-    public ExtractionInfo(@NonNull Location location, boolean isCompressed) {\n-        this.location = location;\n-        this.isCompressed = isCompressed;\n-    }\n-\n-    @NonNull\n-    public Location getLocation() {\n-        return location;\n-    }\n-\n-    public boolean isCompressed() {\n-        return isCompressed;\n-    }\n-}"
  },
  {
    "sha": "a995d434752c25bc9a077e7f8c9365442221aab1",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/FreeStore.java",
    "status": "removed",
    "additions": 0,
    "deletions": 221,
    "changes": 221,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/FreeStore.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/FreeStore.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/FreeStore.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,221 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-\n-// This works like a memory allocator except it deals with file address space instead of\n-// memory address space.\n-class FreeStore {\n-\n-    static final long DEFAULT_ALIGNMENT = 4;\n-    static final long PAGE_ALIGNMENT = 4096;\n-\n-    private Zone head;\n-\n-    // A zone tracks the free file address space. Two consecutive zones are never contiguous which\n-    // mean that upon modification, if two zone \"touch\" each others, they are merged together into\n-    // a bigger free zone.\n-    //\n-    // Used space is not tracked but inferred from each gap between free zones.\n-    protected class Zone {\n-        public Zone next;\n-        public Zone prev;\n-        public Location loc;\n-\n-        public Zone() {\n-            this.next = null;\n-            this.prev = null;\n-        }\n-\n-        public void shrinkBy(long amount) {\n-            assert loc.size() > amount;\n-            loc = new Location(loc.first + amount, loc.size() - amount);\n-\n-            // If the zone is empty, remove it from the list.\n-            if (loc.size() == 0) {\n-                prev.next = next;\n-                if (next != null) {\n-                    next.prev = prev;\n-                }\n-            }\n-        }\n-    }\n-\n-    FreeStore(@NonNull Map<String, com.slack.keeper.internal.zipflinger.Entry> zipEntries) {\n-        // Create an immutable marker of unusable space which make \"insert on head\" ugly code go away.\n-        head = new Zone();\n-        head.loc = new Location(-1, 1);\n-\n-        // Use zip entries location (used space) to build the free zones list.\n-        List<Location> usedLocations = new ArrayList<>();\n-        for (Entry entry : zipEntries.values()) {\n-            usedLocations.add(entry.getLocation());\n-        }\n-        Collections.sort(usedLocations);\n-\n-        Zone prevFreeZone = head;\n-        Location prevUsedLoc = prevFreeZone.loc;\n-        for (Location usedLoc : usedLocations) {\n-            // If there is a gap, mark is as FREE space.\n-            long gap = usedLoc.first - prevUsedLoc.last - 1;\n-            if (gap > 0) {\n-                Zone free = new Zone();\n-                prevFreeZone.next = free;\n-                free.prev = prevFreeZone;\n-                free.loc = new Location(prevUsedLoc.last + 1, gap);\n-                prevFreeZone = free;\n-            }\n-            prevUsedLoc = usedLoc;\n-        }\n-\n-        // Mark everything remaining as a free zone.\n-        Zone remainingZone = new Zone();\n-        remainingZone.prev = prevFreeZone;\n-        remainingZone.next = null;\n-        prevFreeZone.next = remainingZone;\n-        remainingZone.loc =\n-                new Location(prevUsedLoc.last + 1, Long.MAX_VALUE - 1 - prevUsedLoc.last);\n-    }\n-\n-    // Performs unaligned allocation.\n-    @NonNull\n-    Location ualloc(long requestedSize) {\n-        Zone cursor;\n-        for (cursor = head.next; cursor != null; cursor = cursor.next) {\n-            // We are searching for a block big enough to contain:\n-            // - The requested size\n-            // - Post-padding space for potentially needed virtual entry to fill holes.\n-            if (cursor.loc.size() >= requestedSize + com.slack.keeper.internal.zipflinger.LocalFileHeader.VIRTUAL_HEADER_SIZE) {\n-                break;\n-            }\n-        }\n-\n-        if (cursor == null) {\n-            throw new IllegalStateException(\"Out of file address space.\");\n-        }\n-\n-        Location allocated = new Location(cursor.loc.first, requestedSize);\n-        cursor.shrinkBy(requestedSize);\n-        return allocated;\n-    }\n-\n-    // Performs aligned allocation. The offset is necessary because what needs to be aligned is not\n-    // the first byte in the allocation but the first byte in the zip entry payload.\n-    // This method may return more than requested. If it does the extra space is padding that must\n-    // be consumed by an \"extra\" field.\n-    @NonNull\n-    Location alloc(long requestedSize, long payloadOffset, long alignment) {\n-        Zone cursor;\n-        for (cursor = head.next; cursor != null; cursor = cursor.next) {\n-            long padding = padFor(cursor.loc.first, payloadOffset, alignment);\n-            // We are searching for a block big enough to contain:\n-            // - The requested size\n-            // - Pre-padding space for extra field ALIGNMENT\n-            // - Post-padding space for potentially needed virtual entry to fill holes.\n-            if (cursor.loc.size()\n-                    >= requestedSize + padding + com.slack.keeper.internal.zipflinger.LocalFileHeader.VIRTUAL_HEADER_SIZE) {\n-                requestedSize += padding;\n-                break;\n-            }\n-        }\n-\n-        if (cursor == null) {\n-            throw new IllegalStateException(\"Out of file address space.\");\n-        }\n-\n-        Location allocated = new Location(cursor.loc.first, requestedSize);\n-        cursor.shrinkBy(requestedSize);\n-        return allocated;\n-    }\n-\n-    // Mark an area of the file available for allocation. This will merge up to two zones into one\n-    // if they touch each others.\n-    void free(@NonNull Location loc) {\n-        Zone cursor = head.next;\n-        while (cursor != null) {\n-            if (loc.first > cursor.prev.loc.last && loc.last < cursor.loc.first) {\n-                break;\n-            }\n-            cursor = cursor.next;\n-        }\n-\n-        if (cursor == null) {\n-            throw new IllegalStateException(\"Double free\");\n-        }\n-\n-        // Insert a free zone\n-        Zone newFreeZone = new Zone();\n-        newFreeZone.loc = loc;\n-        newFreeZone.prev = cursor.prev;\n-        newFreeZone.next = cursor;\n-        cursor.prev.next = newFreeZone;\n-        cursor.prev = newFreeZone;\n-        cursor = newFreeZone;\n-\n-        // If previous zone is contiguous, merge this zone into previous.\n-        if (cursor.prev.loc.last + 1 == cursor.loc.first && cursor.prev != head) {\n-            Zone prev = cursor.prev;\n-            prev.next = cursor.next;\n-            cursor.next.prev = prev;\n-            prev.loc = new Location(prev.loc.first, prev.loc.size() + cursor.loc.size());\n-            cursor = prev;\n-        }\n-\n-        // If next zone is contiguous, merge this zone into next.\n-        if (cursor.next != null && cursor.next.loc.first - 1 == cursor.loc.last) {\n-            Zone next = cursor.next;\n-            next.prev = cursor.prev;\n-            cursor.prev.next = next;\n-            next.loc = new Location(cursor.loc.first, cursor.loc.size() + next.loc.size());\n-        }\n-    }\n-\n-    @NonNull\n-    Location getLastFreeLocation() {\n-        Zone zone = head.next;\n-        while (zone.next != null) {\n-            zone = zone.next;\n-        }\n-        return zone.loc;\n-    }\n-\n-    @NonNull\n-    List<Location> getFreeLocations() {\n-        List<Location> locs = new ArrayList<>();\n-        Zone cursor = head.next;\n-        while (cursor != null) {\n-            locs.add(cursor.loc);\n-            cursor = cursor.next;\n-        }\n-        return locs;\n-    }\n-\n-    // How much padding is needed if this address+offset is not aligned (a.k.a: An extra field will\n-    // have to be created in order to fill this space).\n-    static long padFor(long address, long offset, long alignment) {\n-        long pointer = address + offset;\n-        if ((pointer % alignment) == 0) {\n-            return 0;\n-        } else {\n-            return alignment - (pointer % alignment);\n-        }\n-    }\n-}"
  },
  {
    "sha": "192b35306211945b5a9f3e6c566954e48ca0b710",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Ints.java",
    "status": "removed",
    "additions": 0,
    "deletions": 57,
    "changes": 57,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Ints.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Ints.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Ints.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,57 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.slack.keeper.internal.zipflinger;\n-\n-class Ints {\n-    public static final long USHRT_MAX = 65_535L;\n-    public static final long UINT_MAX = 0xFF_FF_FF_FFL;\n-\n-    static long uintToLong(int i) {\n-        return i & 0xFF_FF_FF_FFL;\n-    }\n-\n-    static int ushortToInt(short i) {\n-        return i & 0xFF_FF;\n-    }\n-\n-    static int longToUint(long i) {\n-        if ((i & 0xFF_FF_FF_FF_00_00_00_00L) != 0) {\n-            throw new IllegalStateException(\"Long cannot fit in uint\");\n-        }\n-        return (int) i;\n-    }\n-\n-    static short intToUshort(int i) {\n-        if ((i & 0xFF_FF_00_00) != 0) {\n-            throw new IllegalStateException(\"Int cannot fit in ushort\");\n-        }\n-        return (short) i;\n-    }\n-\n-    static short longToUshort(long i) {\n-        if ((i & 0xFF_FF_FF_FF_FF_FF_00_00L) != 0) {\n-            throw new IllegalStateException(\"long cannot fit in ushort\");\n-        }\n-        return (short) i;\n-    }\n-\n-    public static long ulongToLong(long i) {\n-        if ((i & 0x80_00_00_00_00_00_00_00L) != 0) {\n-            throw new IllegalStateException(\"ulong cannot fit in long\");\n-        }\n-        return i;\n-    }\n-}"
  },
  {
    "sha": "a1f65112d95f6284f99c4e48ade2e3b5e2b36b65",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/LocalFileHeader.java",
    "status": "removed",
    "additions": 0,
    "deletions": 140,
    "changes": 140,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/LocalFileHeader.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/LocalFileHeader.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/LocalFileHeader.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,140 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-\n-class LocalFileHeader {\n-    private static final int SIGNATURE = 0x04034b50;\n-\n-    public static final int LOCAL_FILE_HEADER_SIZE = 30;\n-\n-    // Minimum number of bytes needed to create a virtual zip entry (an entry not present in\n-    // the Central Directory with name length = 0 and an extra field containing padding data).\n-    public static final long VIRTUAL_HEADER_SIZE = LOCAL_FILE_HEADER_SIZE;\n-\n-    public static final short COMPRESSION_NONE = 0;\n-    public static final short COMPRESSION_DEFLATE = 8;\n-\n-    static final long VIRTUAL_ENTRY_MAX_SIZE = LOCAL_FILE_HEADER_SIZE + com.slack.keeper.internal.zipflinger.Ints.USHRT_MAX;\n-    static final long OFFSET_TO_NAME = 26;\n-\n-    // Zip64 extra payload must only include uncompressed size and compressed size. It differs\n-    // from the Central Directory Record which also features an uint64_t offset to the LFH.\n-    private static final int ZIP64_PAYLOAD_SIZE = Long.BYTES * 2;\n-    private static final int ZIP64_EXTRA_SIZE = Short.BYTES * 2 + ZIP64_PAYLOAD_SIZE;\n-\n-    private final byte[] nameBytes;\n-    private final short compressionFlag;\n-    private final int crc;\n-    private final long compressedSize;\n-    private final long uncompressedSize;\n-    private final boolean isZip64;\n-    private int padding;\n-\n-    LocalFileHeader(Source source) {\n-        this.nameBytes = source.getNameBytes();\n-        this.compressionFlag = source.getCompressionFlag();\n-        this.crc = source.getCrc();\n-        this.compressedSize = source.getCompressedSize();\n-        this.uncompressedSize = source.getUncompressedSize();\n-        this.isZip64 = compressedSize > Zip64.LONG_MAGIC || uncompressedSize > Zip64.LONG_MAGIC;\n-        this.padding = 0;\n-    }\n-\n-    public static void fillVirtualEntry(@NonNull ByteBuffer virtualEntry) {\n-        int sizeToFill = virtualEntry.capacity();\n-        if (sizeToFill < VIRTUAL_HEADER_SIZE) {\n-            String message = String.format(\"Not enough space for virtual entry (%d)\", sizeToFill);\n-            throw new IllegalStateException(message);\n-        }\n-        virtualEntry.order(ByteOrder.LITTLE_ENDIAN);\n-        virtualEntry.putInt(SIGNATURE);\n-        virtualEntry.putShort((short) 0); // Version needed\n-        virtualEntry.putShort((short) 0); // general purpose flag\n-        virtualEntry.putShort(COMPRESSION_NONE);\n-        virtualEntry.putShort(com.slack.keeper.internal.zipflinger.CentralDirectoryRecord.DEFAULT_TIME);\n-        virtualEntry.putShort(com.slack.keeper.internal.zipflinger.CentralDirectoryRecord.DEFAULT_DATE);\n-        virtualEntry.putInt(0); // CRC-32\n-        virtualEntry.putInt(0); // compressed size\n-        virtualEntry.putInt(0); // uncompressed size\n-        virtualEntry.putShort((short) 0); // file name length\n-        // -2 for the extra length ushort we have to write\n-        virtualEntry.putShort(com.slack.keeper.internal.zipflinger.Ints.intToUshort(virtualEntry.remaining() - 2)); // extra length\n-        virtualEntry.rewind();\n-    }\n-\n-    public void setPadding(int padding) {\n-        if (padding > com.slack.keeper.internal.zipflinger.Ints.USHRT_MAX) {\n-            String err = String.format(\"Padding cannot be more than %s bytes\",\n-                com.slack.keeper.internal.zipflinger.Ints.USHRT_MAX);\n-            throw new IllegalStateException(err);\n-        }\n-        this.padding = padding;\n-    }\n-\n-    public void write(@NonNull com.slack.keeper.internal.zipflinger.ZipWriter writer) throws IOException {\n-        ByteBuffer extraField = buildExtraField();\n-        int bytesNeeded = LOCAL_FILE_HEADER_SIZE + nameBytes.length + extraField.capacity();\n-\n-        short versionNeeded = isZip64 ? Zip64.VERSION_NEEDED : 0;\n-        int size = isZip64 ? Zip64.INT_MAGIC : com.slack.keeper.internal.zipflinger.Ints.longToUint(uncompressedSize);\n-        int csize = isZip64 ? Zip64.INT_MAGIC : com.slack.keeper.internal.zipflinger.Ints.longToUint(compressedSize);\n-\n-        ByteBuffer buffer = ByteBuffer.allocate(bytesNeeded).order(ByteOrder.LITTLE_ENDIAN);\n-        buffer.putInt(SIGNATURE);\n-        buffer.putShort(versionNeeded);\n-\n-        buffer.putShort((short) 0); // general purpose flag\n-        buffer.putShort(compressionFlag);\n-        buffer.putShort(com.slack.keeper.internal.zipflinger.CentralDirectoryRecord.DEFAULT_TIME);\n-        buffer.putShort(com.slack.keeper.internal.zipflinger.CentralDirectoryRecord.DEFAULT_DATE);\n-        buffer.putInt(crc);\n-        buffer.putInt(csize); // compressed size\n-        buffer.putInt(size); // size\n-        buffer.putShort(com.slack.keeper.internal.zipflinger.Ints.intToUshort(nameBytes.length));\n-        buffer.putShort(com.slack.keeper.internal.zipflinger.Ints.intToUshort(extraField.capacity())); // Extra size\n-        buffer.put(nameBytes);\n-        buffer.put(extraField);\n-\n-        buffer.rewind();\n-        writer.write(buffer);\n-    }\n-\n-    public long getSize() {\n-        long extraSize = isZip64 ? ZIP64_EXTRA_SIZE : 0;\n-        return LOCAL_FILE_HEADER_SIZE + nameBytes.length + extraSize;\n-    }\n-\n-    @NonNull\n-    private ByteBuffer buildExtraField() {\n-        if (!isZip64) {\n-            return ByteBuffer.allocate(padding);\n-        }\n-\n-        ByteBuffer zip64extra = ByteBuffer.allocate(ZIP64_EXTRA_SIZE + padding);\n-        zip64extra.order(ByteOrder.LITTLE_ENDIAN);\n-        zip64extra.putShort(Zip64.EXTRA_ID);\n-        zip64extra.putShort(com.slack.keeper.internal.zipflinger.Ints.intToUshort(ZIP64_PAYLOAD_SIZE));\n-        zip64extra.putLong(uncompressedSize);\n-        zip64extra.putLong(compressedSize);\n-        zip64extra.rewind();\n-        return zip64extra;\n-    }\n-}"
  },
  {
    "sha": "21f59340ea97a46fa8458144b0c0302dabcf73ab",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Location.java",
    "status": "removed",
    "additions": 0,
    "deletions": 63,
    "changes": 63,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Location.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Location.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Location.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,63 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.text.NumberFormat;\n-\n-public class Location implements Comparable<Location> {\n-\n-    public static final Location INVALID = new Location(Long.MAX_VALUE, Long.MAX_VALUE);\n-\n-    public final long first;\n-    public final long last;\n-\n-    public Location(long first, long size) {\n-        this.first = first;\n-        this.last = first + size - 1;\n-    }\n-\n-    public long size() {\n-        return last - first + 1;\n-    }\n-\n-    @NonNull\n-    public String toString() {\n-        return \"(offset=\"\n-                + NumberFormat.getInstance().format(first)\n-                + \", size=\"\n-                + NumberFormat.getInstance().format(size())\n-                + \")\";\n-    }\n-\n-    @Override\n-    public boolean equals(@NonNull Object obj) {\n-        if (this == obj) {\n-            return true;\n-        }\n-\n-        if (!(obj instanceof Location)) {\n-            return false;\n-        }\n-        Location other = (Location) obj;\n-        return first == other.first && last == other.last;\n-    }\n-\n-    @Override\n-    public int compareTo(Location o) {\n-        return Math.toIntExact(this.first - o.first);\n-    }\n-}"
  },
  {
    "sha": "69ef372efd41873bd9ee8f26b1b0de9441b13a53",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/NoCopyByteArrayOutputStream.java",
    "status": "removed",
    "additions": 0,
    "deletions": 42,
    "changes": 42,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/NoCopyByteArrayOutputStream.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/NoCopyByteArrayOutputStream.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/NoCopyByteArrayOutputStream.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,42 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.io.ByteArrayOutputStream;\n-import java.nio.ByteBuffer;\n-\n-// A class which contrary to ByteArrayOutputStream allows to peek into the buffer\n-// without performing a full copy of the content. This stream does not need to be closed.\n-public class NoCopyByteArrayOutputStream extends ByteArrayOutputStream {\n-    public NoCopyByteArrayOutputStream(int size) {\n-        super(size);\n-    }\n-\n-    @NonNull\n-    public byte[] buf() {\n-        return buf;\n-    }\n-\n-    public int getCount() {\n-        return count;\n-    }\n-\n-    public ByteBuffer getByteBuffer() {\n-        return ByteBuffer.wrap(buf, 0, count);\n-    }\n-}"
  },
  {
    "sha": "b29a8381379becb93ee2d114c0301967a5c5c945",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Source.java",
    "status": "removed",
    "additions": 0,
    "deletions": 82,
    "changes": 82,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Source.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Source.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Source.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,82 +0,0 @@\n-/*\n- * Copyright (C) 2019 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.io.IOException;\n-import java.nio.charset.StandardCharsets;\n-\n-public abstract class Source {\n-    private final String name;\n-    private final byte[] nameBytes;\n-    private long alignment = 0;\n-\n-    protected long compressedSize;\n-    protected long uncompressedSize;\n-    protected int crc;\n-    protected short compressionFlag;\n-\n-    protected Source(@NonNull String name) {\n-        this.name = name;\n-        nameBytes = name.getBytes(StandardCharsets.UTF_8);\n-    }\n-\n-    @NonNull\n-    public String getName() {\n-        return name;\n-    }\n-\n-    @NonNull\n-    byte[] getNameBytes() {\n-        return nameBytes;\n-    }\n-\n-    boolean isAligned() {\n-        return alignment != 0;\n-    }\n-\n-    public void align(long alignment) {\n-        this.alignment = alignment;\n-    }\n-\n-    long getAlignment() {\n-        return alignment;\n-    }\n-\n-    int getCrc() {\n-        return crc;\n-    }\n-\n-    long getCompressedSize() {\n-        return compressedSize;\n-    }\n-\n-    long getUncompressedSize() {\n-        return uncompressedSize;\n-    }\n-\n-    short getCompressionFlag() {\n-        return compressionFlag;\n-    }\n-\n-    // Guaranteed to be called before writeTo. After this method has been called, every fields\n-    // in an entry must be known (csize, size, crc32, and compressionFlag).\n-    abstract void prepare() throws IOException;\n-\n-    // Return the number of bytes written.\n-    abstract long writeTo(@NonNull com.slack.keeper.internal.zipflinger.ZipWriter writer) throws IOException;\n-}"
  },
  {
    "sha": "a24e3dadc8b7617797b5c4a48241c4fde3c0f79e",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/StableArchive.java",
    "status": "removed",
    "additions": 0,
    "deletions": 76,
    "changes": 76,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/StableArchive.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/StableArchive.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/StableArchive.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,76 +0,0 @@\n-/*\n- * Copyright (C) 2020 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-\n-public class StableArchive implements com.slack.keeper.internal.zipflinger.Archive {\n-\n-    private final com.slack.keeper.internal.zipflinger.Archive archive;\n-    private final ArrayList<com.slack.keeper.internal.zipflinger.BytesSource> bytesSources;\n-    private final ArrayList<ZipSource> zipSources;\n-    private final ArrayList<String> deletedEntries;\n-\n-    public StableArchive(com.slack.keeper.internal.zipflinger.Archive archive) {\n-        this.archive = archive;\n-        bytesSources = new ArrayList<>();\n-        zipSources = new ArrayList<>();\n-        deletedEntries = new ArrayList<>();\n-    }\n-\n-    @Override\n-    public void add(@NonNull com.slack.keeper.internal.zipflinger.BytesSource source) {\n-        bytesSources.add(source);\n-    }\n-\n-    @Override\n-    public void add(@NonNull ZipSource sources) {\n-        zipSources.add(sources);\n-    }\n-\n-    @Override\n-    public void delete(@NonNull String name) {\n-        deletedEntries.add(name);\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-        bytesSources.sort(Comparator.comparing(com.slack.keeper.internal.zipflinger.Source::getName));\n-        zipSources.sort(Comparator.comparing(ZipSource::getName));\n-        for (ZipSource zipSource : zipSources) {\n-            zipSource.getSelectedEntries().sort(Comparator.comparing(Source::getName));\n-        }\n-        deletedEntries.sort(Comparator.naturalOrder());\n-\n-        try (Archive arch = archive) {\n-            for (String toDelete : deletedEntries) {\n-                arch.delete(toDelete);\n-            }\n-\n-            for (BytesSource source : bytesSources) {\n-                arch.add(source);\n-            }\n-\n-            for (ZipSource zipSource : zipSources) {\n-                arch.add(zipSource);\n-            }\n-        }\n-    }\n-}"
  },
  {
    "sha": "373989893542ce19da63a65b567c6bed2f215cac",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/SynchronizedArchive.java",
    "status": "removed",
    "additions": 0,
    "deletions": 57,
    "changes": 57,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/SynchronizedArchive.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/SynchronizedArchive.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/SynchronizedArchive.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,57 +0,0 @@\n-/*\n- * Copyright (C) 2020 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.io.IOException;\n-\n-public class SynchronizedArchive implements com.slack.keeper.internal.zipflinger.Archive {\n-\n-    private final com.slack.keeper.internal.zipflinger.Archive archive;\n-\n-    public SynchronizedArchive(Archive archive) throws IOException {\n-        this.archive = archive;\n-    }\n-\n-    @Override\n-    public void add(@NonNull BytesSource source) throws IOException {\n-        synchronized (archive) {\n-            archive.add(source);\n-        }\n-    }\n-\n-    @Override\n-    public void add(@NonNull ZipSource sources) throws IOException {\n-        synchronized (archive) {\n-            archive.add(sources);\n-        }\n-    }\n-\n-    @Override\n-    public void delete(@NonNull String name) throws IOException {\n-        synchronized (archive) {\n-            archive.delete(name);\n-        }\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-        synchronized (archive) {\n-            archive.close();\n-        }\n-    }\n-}"
  },
  {
    "sha": "362bbf4000df9d5e05d665621ce4e58301c7bf5a",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Zip64.java",
    "status": "removed",
    "additions": 0,
    "deletions": 38,
    "changes": 38,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Zip64.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Zip64.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Zip64.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,38 +0,0 @@\n-/*\n- * Copyright (C) 2020 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.slack.keeper.internal.zipflinger;\n-\n-public class Zip64 {\n-    static final short EXTRA_ID = 0x0001;\n-\n-    static final long LONG_MAGIC = 0xFF_FF_FF_FFL;\n-    static final int INT_MAGIC = (int) LONG_MAGIC;\n-    static final int SHORT_MAGIC = (short) LONG_MAGIC;\n-\n-    static final short VERSION_NEEDED = 0x2D;\n-\n-    public static boolean needZip64Footer(long numEntries, Location cdLocation) {\n-        return numEntries > com.slack.keeper.internal.zipflinger.Ints.USHRT_MAX\n-                || cdLocation.first > com.slack.keeper.internal.zipflinger.Ints.UINT_MAX\n-                || cdLocation.size() > com.slack.keeper.internal.zipflinger.Ints.UINT_MAX;\n-    }\n-\n-    public enum Policy {\n-        ALLOW,\n-        FORBID\n-    };\n-}"
  },
  {
    "sha": "b04df0ef3ab6fdbf6b0b701aace68dc9ba615880",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Zip64Eocd.java",
    "status": "removed",
    "additions": 0,
    "deletions": 99,
    "changes": 99,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Zip64Eocd.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Zip64Eocd.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Zip64Eocd.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,99 +0,0 @@\n-/*\n- * Copyright (C) 2020 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.nio.channels.FileChannel;\n-\n-public class Zip64Eocd {\n-    private static final int SIGNATURE = 0x06064b50;\n-    static final int SIZE = 56;\n-\n-    private long numEntries;\n-    private com.slack.keeper.internal.zipflinger.Location cdLocation;\n-\n-    public Zip64Eocd(long numEntries, @NonNull com.slack.keeper.internal.zipflinger.Location cdLocation) {\n-        this.numEntries = numEntries;\n-        this.cdLocation = cdLocation;\n-    }\n-\n-    private Zip64Eocd() {\n-        this(0, com.slack.keeper.internal.zipflinger.Location.INVALID);\n-    }\n-\n-    @NonNull\n-    public com.slack.keeper.internal.zipflinger.Location write(@NonNull com.slack.keeper.internal.zipflinger.ZipWriter writer) throws IOException {\n-        ByteBuffer eocd = ByteBuffer.allocate(SIZE).order(ByteOrder.LITTLE_ENDIAN);\n-        eocd.putInt(SIGNATURE);\n-        eocd.putLong(SIZE - 12); // Peculiar specs mandate not to include 12 bytes already written.\n-        eocd.putShort((short) 0); // Version made by\n-        eocd.putShort(Zip64.VERSION_NEEDED); // Version needed to extract\n-        eocd.putInt(0); // disk #\n-        eocd.putInt(0); // total # of disks\n-        eocd.putLong(numEntries); // # entries in cd on this disk\n-        eocd.putLong(numEntries); // total # entries in cd\n-        eocd.putLong(cdLocation.size()); // CD offset.\n-        eocd.putLong(cdLocation.first); // size of CD.\n-        eocd.rewind();\n-\n-        long position = writer.position();\n-        writer.write(eocd);\n-\n-        return new com.slack.keeper.internal.zipflinger.Location(position, SIZE);\n-    }\n-\n-    @NonNull com.slack.keeper.internal.zipflinger.Location getCdLocation() {\n-        return cdLocation;\n-    }\n-\n-    @NonNull\n-    static Zip64Eocd parse(@NonNull FileChannel channel, long eocdOffset) throws IOException {\n-        Zip64Eocd zip64Eocd = new Zip64Eocd();\n-        long fileSize = channel.size();\n-        if (eocdOffset < 0 || eocdOffset + SIZE > fileSize) {\n-            return zip64Eocd;\n-        }\n-\n-        ByteBuffer buffer = ByteBuffer.allocate(SIZE).order(ByteOrder.LITTLE_ENDIAN);\n-        channel.read(buffer, eocdOffset);\n-        buffer.rewind();\n-\n-        int signature = buffer.getInt(); // signature\n-        if (signature != SIGNATURE) {\n-            return zip64Eocd;\n-        }\n-\n-        // Skip uninteresting fields\n-        buffer.position(buffer.position() + 28);\n-        // eocd.getLong();  8 // size of zip64EOCD\n-        // eocd.getShort(); 2 // Version made by\n-        // eocd.getShort(); 2 // Version needed to extract\n-        // eocd.getInt();   4 // disk #\n-        // eocd.getInt();   4 // total # of disks\n-        // eocd.getLong();  8 // # entries in cd on this disk\n-        long numEntries = buffer.getLong(); // total # entries in cd\n-        long size = com.slack.keeper.internal.zipflinger.Ints.ulongToLong(buffer.getLong()); // size of CD.\n-        long offset = com.slack.keeper.internal.zipflinger.Ints.ulongToLong(buffer.getLong()); // CD offset.\n-\n-        zip64Eocd.numEntries = numEntries;\n-        zip64Eocd.cdLocation = new Location(offset, size);\n-        return zip64Eocd;\n-    }\n-}"
  },
  {
    "sha": "8aaf95b506be7a14f285fd3f740e4179f9d28144",
    "filename": "keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Zip64Locator.java",
    "status": "removed",
    "additions": 0,
    "deletions": 102,
    "changes": 102,
    "blob_url": "https://github.com/slackhq/keeper/blob/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Zip64Locator.java",
    "raw_url": "https://github.com/slackhq/keeper/raw/490c77f3d3202fe19a0b40ba30be40fce7da2aff/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Zip64Locator.java",
    "contents_url": "https://api.github.com/repos/slackhq/keeper/contents/keeper-gradle-plugin/src/main/java/com/slack/keeper/internal/zipflinger/Zip64Locator.java?ref=490c77f3d3202fe19a0b40ba30be40fce7da2aff",
    "patch": "@@ -1,102 +0,0 @@\n-/*\n- * Copyright (C) 2020 The Android Open Source Project\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.slack.keeper.internal.zipflinger;\n-\n-import com.android.annotations.NonNull;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.nio.channels.FileChannel;\n-\n-public class Zip64Locator {\n-\n-    private static final int SIGNATURE = 0x07064b50;\n-    public static final int SIZE = 20;\n-\n-    static final int TOTAL_NUMBER_DISK = com.slack.keeper.internal.zipflinger.EndOfCentralDirectory.DISK_NUMBER + 1;\n-\n-    private com.slack.keeper.internal.zipflinger.Location location;\n-    private long offsetToEOCD64;\n-\n-    private Zip64Locator() {\n-        location = com.slack.keeper.internal.zipflinger.Location.INVALID;\n-        offsetToEOCD64 = 0;\n-    }\n-\n-    @NonNull\n-    public com.slack.keeper.internal.zipflinger.Location getLocation() {\n-        return location;\n-    }\n-\n-    public long getOffsetToEOCD64() {\n-        return offsetToEOCD64;\n-    }\n-\n-    public static com.slack.keeper.internal.zipflinger.Location write(@NonNull\n-        com.slack.keeper.internal.zipflinger.ZipWriter writer, @NonNull\n-        com.slack.keeper.internal.zipflinger.Location eocdLocation)\n-            throws IOException {\n-        ByteBuffer buffer = ByteBuffer.allocate(SIZE).order(ByteOrder.LITTLE_ENDIAN);\n-        buffer.putInt(SIGNATURE);\n-        buffer.putInt(0); // CD disk number\n-        buffer.putLong(eocdLocation.first); // offset\n-        buffer.putInt(TOTAL_NUMBER_DISK);\n-        buffer.rewind();\n-\n-        long position = writer.position();\n-        writer.write(buffer);\n-        return new com.slack.keeper.internal.zipflinger.Location(position, SIZE);\n-    }\n-\n-    @NonNull\n-    static Zip64Locator find(@NonNull FileChannel channel, @NonNull\n-        com.slack.keeper.internal.zipflinger.EndOfCentralDirectory eocd)\n-            throws IOException {\n-        Zip64Locator locator = new Zip64Locator();\n-        com.slack.keeper.internal.zipflinger.Location\n-            locatorLocation = new Location(eocd.getLocation().first - SIZE, SIZE);\n-        long fileSize = channel.size();\n-        if (locatorLocation.last >= fileSize) {\n-            return locator;\n-        }\n-        if (locatorLocation.first < 0) {\n-            return locator;\n-        }\n-\n-        ByteBuffer locatorBuffer = ByteBuffer.allocate(SIZE).order(ByteOrder.LITTLE_ENDIAN);\n-        channel.read(locatorBuffer, locatorLocation.first);\n-        locatorBuffer.rewind();\n-\n-        if (locator.parse(locatorBuffer)) {\n-            locator.location = locatorLocation;\n-        }\n-        return locator;\n-    }\n-\n-    private boolean parse(@NonNull ByteBuffer buffer) {\n-        int signature = buffer.getInt();\n-        if (signature != SIGNATURE) {\n-            return false;\n-        }\n-\n-        buffer.position(buffer.position() + 4); // skip CD disk number\n-        offsetToEOCD64 = com.slack.keeper.internal.zipflinger.Ints.ulongToLong(buffer.getLong());\n-        // Don't read the rest, this is not needed\n-\n-        return true;\n-    }\n-}"
  }
]
