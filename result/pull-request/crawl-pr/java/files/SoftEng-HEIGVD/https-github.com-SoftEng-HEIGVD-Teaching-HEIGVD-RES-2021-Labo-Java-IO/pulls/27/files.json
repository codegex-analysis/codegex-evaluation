[
  {
    "sha": "3761b6de4ecda7540a411be72886e577aa60952a",
    "filename": "LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/Application.java",
    "status": "modified",
    "additions": 161,
    "deletions": 134,
    "changes": 295,
    "blob_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/blob/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/Application.java",
    "raw_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/raw/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/Application.java",
    "contents_url": "https://api.github.com/repos/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/contents/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/Application.java?ref=324b310dffb223396c0dfdde49950d1377d51dc9",
    "patch": "@@ -9,155 +9,182 @@\n import ch.heigvd.res.labio.quotes.QuoteClient;\n import org.apache.commons.io.FileUtils;\n \n-import java.io.File;\n-import java.io.IOException;\n-import java.io.StringWriter;\n-import java.io.Writer;\n+import java.io.*;\n import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n \n /**\n- *\n  * @author Olivier Liechti\n  */\n public class Application implements IApplication {\n \n-  /**\n-   * This constant defines where the quotes will be stored. The path is relative\n-   * to where the Java application is invoked.\n-   */\n-  public static String WORKSPACE_DIRECTORY = \"./workspace/quotes\";\n-  \n-  private static final Logger LOG = Logger.getLogger(Application.class.getName());\n-  \n-  public static void main(String[] args) {\n-    \n-    /*\n-     * I prefer to have LOG output on a single line, it's easier to read. Being able\n-     * to change the formatting of console outputs is one of the reasons why it is\n-     * better to use a Logger rather than using System.out.println\n+    /**\n+     * This constant defines where the quotes will be stored. The path is relative\n+     * to where the Java application is invoked.\n      */\n-    System.setProperty(\"java.util.logging.SimpleFormatter.format\", \"%4$s: %5$s%6$s%n\");\n-    \n-       \n-    int numberOfQuotes = 0;\n-    try {\n-      numberOfQuotes = Integer.parseInt(args[0]);\n-    } catch (Exception e) {\n-      System.err.println(\"The command accepts a single numeric argument (number of quotes to fetch)\");\n-      System.exit(-1);\n+    public static String WORKSPACE_DIRECTORY = \"./workspace/quotes\";\n+\n+    private static final Logger LOG = Logger.getLogger(Application.class.getName());\n+\n+    public static void main(String[] args) {\n+\n+        /*\n+         * I prefer to have LOG output on a single line, it's easier to read. Being able\n+         * to change the formatting of console outputs is one of the reasons why it is\n+         * better to use a Logger rather than using System.out.println\n+         */\n+        System.setProperty(\"java.util.logging.SimpleFormatter.format\", \"%4$s: %5$s%6$s%n\");\n+\n+\n+        int numberOfQuotes = 0;\n+        try {\n+            numberOfQuotes = Integer.parseInt(args[0]);\n+        } catch (Exception e) {\n+            System.err.println(\"The command accepts a single numeric argument (number of quotes to fetch)\");\n+            System.exit(-1);\n+        }\n+\n+        Application app = new Application();\n+        try {\n+            /*\n+             * Step 1 : clear the output directory\n+             */\n+            app.clearOutputDirectory();\n+\n+            /*\n+             * Step 2 : use the QuotesClient to fetch quotes; store each quote in a file\n+             */\n+            app.fetchAndStoreQuotes(numberOfQuotes);\n+\n+            /*\n+             * Step 3 : use a file explorer to traverse the file system; print the name of each directory and file\n+             */\n+            Writer writer = new StringWriter(); // we create a special writer that will send characters into a string (memory)\n+            app.printFileNames(writer);         // we hand over this writer to the printFileNames method\n+            LOG.info(writer.toString());       // we dump the whole result on the console\n+\n+            /*\n+             * Step 4 : process the quote files, by applying 2 transformations to their content\n+             *          (convert to uppercase and add line numbers)\n+             */\n+            app.processQuoteFiles();\n+\n+        } catch (IOException ex) {\n+            LOG.log(Level.SEVERE, \"Could not fetch quotes. {0}\", ex.getMessage());\n+            ex.printStackTrace();\n+        }\n     }\n-        \n-    Application app = new Application();\n-    try {\n-      /*\n-       * Step 1 : clear the output directory\n-       */\n-      app.clearOutputDirectory();\n-      \n-      /*\n-       * Step 2 : use the QuotesClient to fetch quotes; store each quote in a file\n-       */\n-      app.fetchAndStoreQuotes(numberOfQuotes);\n-      \n-      /*\n-       * Step 3 : use a file explorer to traverse the file system; print the name of each directory and file\n-       */\n-      Writer writer = new StringWriter(); // we create a special writer that will send characters into a string (memory)\n-      app.printFileNames(writer);         // we hand over this writer to the printFileNames method\n-      LOG.info(writer.toString());       // we dump the whole result on the console\n-      \n-      /*\n-       * Step 4 : process the quote files, by applying 2 transformations to their content\n-       *          (convert to uppercase and add line numbers)\n-       */\n-      app.processQuoteFiles();\n-      \n-    } catch (IOException ex) {\n-      LOG.log(Level.SEVERE, \"Could not fetch quotes. {0}\", ex.getMessage());\n-      ex.printStackTrace();\n+\n+    @Override\n+    public void fetchAndStoreQuotes(int numberOfQuotes) throws IOException {\n+        clearOutputDirectory();\n+        QuoteClient client = new QuoteClient();\n+        for (int i = 0; i < numberOfQuotes; i++) {\n+            Quote quote = null;\n+            try {\n+                quote = client.fetchQuote();\n+            } catch (URISyntaxException | InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            if (quote != null) {\n+                /* There is a missing piece here!\n+                 * As you can see, this method handles the first part of the lab. It uses the web service\n+                 * client to fetch quotes. We have removed a single line from this method. It is a call to\n+                 * one method provided by this class, which is responsible for storing the content of the\n+                 * quote in a text file (and for generating the directories based on the tags).\n+                 */\n+                storeQuote(quote, String.format(\"quote-%d\", i));\n+                LOG.info(\"Received a new joke with \" + quote.getTags().size() + \" tags.\");\n+                for (String tag : quote.getTags()) {\n+                    LOG.info(\"> \" + tag);\n+                }\n+            }\n+\n+        }\n     }\n-  }\n-\n-  @Override\n-  public void fetchAndStoreQuotes(int numberOfQuotes) throws IOException {\n-    clearOutputDirectory();\n-    QuoteClient client = new QuoteClient();\n-    for (int i = 0; i < numberOfQuotes; i++) {\n-      Quote quote = null;\n-      try {\n-        quote = client.fetchQuote();\n-      } catch (URISyntaxException | InterruptedException e) {\n-        e.printStackTrace();\n-      }\n-      if (quote != null) {\n-        /* There is a missing piece here!\n-         * As you can see, this method handles the first part of the lab. It uses the web service\n-         * client to fetch quotes. We have removed a single line from this method. It is a call to\n-         * one method provided by this class, which is responsible for storing the content of the\n-         * quote in a text file (and for generating the directories based on the tags).\n-         */\n-        LOG.info(\"Received a new joke with \" + quote.getTags().size() + \" tags.\");\n+\n+    /**\n+     * This method deletes the WORKSPACE_DIRECTORY and its content. It uses the\n+     * apache commons-io library. You should call this method in the main method.\n+     *\n+     * @throws IOException\n+     */\n+    void clearOutputDirectory() throws IOException {\n+        FileUtils.deleteDirectory(new File(WORKSPACE_DIRECTORY));\n+    }\n+\n+    /**\n+     * This method stores the content of a quote in the local file system. It has\n+     * 2 responsibilities:\n+     * <p>\n+     * - with quote.getTags(), it gets a list of tags and uses\n+     * it to create sub-folders (for instance, if a quote has three tags \"A\", \"B\" and\n+     * \"C\", it will be stored in /quotes/A/B/C/quotes-n.utf8.\n+     * <p>\n+     * - with quote.getQuote(), it has access to the text of the quote. It stores\n+     * this text in UTF-8 file.\n+     *\n+     * @param quote    the quote object, with tags and text\n+     * @param filename the name of the file to create and where to store the quote text\n+     * @throws IOException\n+     */\n+    void storeQuote(Quote quote, String filename) throws IOException {\n+        StringBuilder path = new StringBuilder(WORKSPACE_DIRECTORY + \"/\");\n+\n+        // Building the path\n         for (String tag : quote.getTags()) {\n-          LOG.info(\"> \" + tag);\n+            path.append(tag).append(\"/\");\n         }\n-      }\n \n+        String filepath = path.toString();\n+        File file = new File(filepath);\n+        file.mkdirs(); // Creating sub-folders\n+\n+        // Creating the file\n+        Writer writer = new BufferedWriter(new OutputStreamWriter(\n+                new FileOutputStream((filepath) + filename + \".utf8\"),\n+                StandardCharsets.UTF_8\n+        ));\n+\n+        // Writing the quote in the utf8 file\n+        writer.write(quote.getQuote());\n+        writer.flush();\n+        writer.close();\n+    }\n+\n+    /**\n+     * This method uses a IFileExplorer to explore the file system and prints the name of each\n+     * encountered file and directory.\n+     */\n+    void printFileNames(final Writer writer) {\n+        IFileExplorer explorer = new DFSFileExplorer();\n+        explorer.explore(new File(WORKSPACE_DIRECTORY), new IFileVisitor() {\n+            @Override\n+            public void visit(File file) {\n+                /*\n+                 * There is a missing piece here. Notice how we use an anonymous class here. We provide the implementation\n+                 * of the the IFileVisitor interface inline. You just have to add the body of the visit method, which should\n+                 * be pretty easy (we want to write the filename, including the path, to the writer passed in argument).\n+                 */\n+                if (file == null) {\n+                    //The dfs should not ask to visit null files but if we change it's here\n+                    return;\n+                }\n+                try {\n+                    writer.write(file.getPath() + \"\\n\");\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void processQuoteFiles() throws IOException {\n+        IFileExplorer explorer = new DFSFileExplorer();\n+        explorer.explore(new File(WORKSPACE_DIRECTORY), new CompleteFileTransformer());\n     }\n-  }\n-  \n-  /**\n-   * This method deletes the WORKSPACE_DIRECTORY and its content. It uses the\n-   * apache commons-io library. You should call this method in the main method.\n-   * \n-   * @throws IOException \n-   */\n-  void clearOutputDirectory() throws IOException {\n-    FileUtils.deleteDirectory(new File(WORKSPACE_DIRECTORY));    \n-  }\n-\n-  /**\n-   * This method stores the content of a quote in the local file system. It has\n-   * 2 responsibilities: \n-   * \n-   * - with quote.getTags(), it gets a list of tags and uses\n-   *   it to create sub-folders (for instance, if a quote has three tags \"A\", \"B\" and\n-   *   \"C\", it will be stored in /quotes/A/B/C/quotes-n.utf8.\n-   * \n-   * - with quote.getQuote(), it has access to the text of the quote. It stores\n-   *   this text in UTF-8 file.\n-   * \n-   * @param quote the quote object, with tags and text\n-   * @param filename the name of the file to create and where to store the quote text\n-   * @throws IOException \n-   */\n-  void storeQuote(Quote quote, String filename) throws IOException {\n-    throw new UnsupportedOperationException(\"The student has not implemented this method yet.\");\n-  }\n-  \n-  /**\n-   * This method uses a IFileExplorer to explore the file system and prints the name of each\n-   * encountered file and directory.\n-   */\n-  void printFileNames(final Writer writer) {\n-    IFileExplorer explorer = new DFSFileExplorer();\n-    explorer.explore(new File(WORKSPACE_DIRECTORY), new IFileVisitor() {\n-      @Override\n-      public void visit(File file) {\n-        /*\n-         * There is a missing piece here. Notice how we use an anonymous class here. We provide the implementation\n-         * of the the IFileVisitor interface inline. You just have to add the body of the visit method, which should\n-         * be pretty easy (we want to write the filename, including the path, to the writer passed in argument).\n-         */\n-      }\n-    });\n-  }\n-\n-  @Override\n-  public void processQuoteFiles() throws IOException {\n-    IFileExplorer explorer = new DFSFileExplorer();\n-    explorer.explore(new File(WORKSPACE_DIRECTORY), new CompleteFileTransformer());    \n-  }\n \n }"
  },
  {
    "sha": "ecb0852cdc94b8826a0c133a2cd20c86d726f682",
    "filename": "LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/Utils.java",
    "status": "modified",
    "additions": 17,
    "deletions": 1,
    "changes": 18,
    "blob_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/blob/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/Utils.java",
    "raw_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/raw/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/Utils.java",
    "contents_url": "https://api.github.com/repos/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/contents/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/Utils.java?ref=324b310dffb223396c0dfdde49950d1377d51dc9",
    "patch": "@@ -20,7 +20,23 @@\n    * contain any line separator, then the first element is an empty string.\n    */\n   public static String[] getNextLine(String lines) {\n-    throw new UnsupportedOperationException(\"The student has not implemented this method yet.\");\n+\n+      // (?m) makes ^ match the beginning of a line instead of matching the beginning of the whole input (lines) and\n+      // (?<=^) represents a positive lookbehind to match the char at the end of line and use it as the separator\n+      // limit is 2 because we want 2 elements\n+      String[] split = lines.split(\"(?m)(?<=^)\", 2);\n+\n+      if (split.length == 2){\n+        return split;\n+      }else{\n+          // ^ in multiline mode does not match the last char so we do the check ourselves\n+          if (lines.charAt(lines.length()-1) == '\\n' || lines.charAt(lines.length()-1) == '\\r'){\n+              return new String[]{split[0], \"\"};\n+          }\n+\n+        // If the argument does not contain any line separator\n+        return new String[]{\"\", split[0]};\n+      }\n   }\n \n }"
  },
  {
    "sha": "c44bfaa4bc49233fd0839cc3d0b0e6544d4c22be",
    "filename": "LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/explorers/DFSFileExplorer.java",
    "status": "modified",
    "additions": 30,
    "deletions": 4,
    "changes": 34,
    "blob_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/blob/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/explorers/DFSFileExplorer.java",
    "raw_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/raw/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/explorers/DFSFileExplorer.java",
    "contents_url": "https://api.github.com/repos/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/contents/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/explorers/DFSFileExplorer.java?ref=324b310dffb223396c0dfdde49950d1377d51dc9",
    "patch": "@@ -1,23 +1,49 @@\n package ch.heigvd.res.labio.impl.explorers;\n \n+\n import ch.heigvd.res.labio.interfaces.IFileExplorer;\n import ch.heigvd.res.labio.interfaces.IFileVisitor;\n \n import java.io.File;\n+import java.util.Arrays;\n \n /**\n  * This implementation of the IFileExplorer interface performs a depth-first\n  * exploration of the file system and invokes the visitor for every encountered\n- * node (file and directory). When the explorer reaches a directory, it visits all\n- * files in the directory and then moves into the subdirectories.\n+ * node (file and directory). When the explorer reaches a directory, it visits moves into the subdirectories and then visits all\n+ * files in the directory\n  * \n  * @author Olivier Liechti\n  */\n public class DFSFileExplorer implements IFileExplorer {\n \n   @Override\n   public void explore(File rootDirectory, IFileVisitor vistor) {\n-    throw new UnsupportedOperationException(\"The student has not implemented this method yet.\");\n-  }\n+    if(rootDirectory == null){\n+      return;\n+    }\n+    vistor.visit(rootDirectory);\n \n+    File[] children = rootDirectory.listFiles();\n+\n+    if (children != null){\n+      // Sort directories first then files\n+      Arrays.sort(children, (file, t1) -> {\n+        if (file.isDirectory() && !t1.isDirectory()){\n+          return -1;\n+        }else if (!file.isDirectory() && t1.isDirectory()){\n+          return 1;\n+        }else{\n+          return file.compareTo(t1);\n+        }\n+      });\n+      for (File f : children){\n+        if (f.isDirectory()){\n+          explore(f, vistor);\n+        }else{\n+          vistor.visit(f);\n+        }\n+      }\n+    }\n+  }\n }"
  },
  {
    "sha": "ca7a1ef1c76642592f519b11d1add94f8955cfaf",
    "filename": "LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/filters/FileNumberingFilterWriter.java",
    "status": "modified",
    "additions": 56,
    "deletions": 17,
    "changes": 73,
    "blob_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/blob/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/filters/FileNumberingFilterWriter.java",
    "raw_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/raw/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/filters/FileNumberingFilterWriter.java",
    "contents_url": "https://api.github.com/repos/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/contents/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/filters/FileNumberingFilterWriter.java?ref=324b310dffb223396c0dfdde49950d1377d51dc9",
    "patch": "@@ -10,32 +10,71 @@\n  * When filter encounters a line separator, it sends it to the decorated writer.\n  * It then sends the line number and a tab character, before resuming the write\n  * process.\n- *\n+ * <p>\n  * Hello\\n\\World -> 1\\Hello\\n2\\tWorld\n  *\n  * @author Olivier Liechti\n  */\n public class FileNumberingFilterWriter extends FilterWriter {\n \n-  private static final Logger LOG = Logger.getLogger(FileNumberingFilterWriter.class.getName());\n+    private static final Logger LOG = Logger.getLogger(FileNumberingFilterWriter.class.getName());\n+\n+    private int lineNumber;\n+    private boolean beginning;\n+    private boolean newLineFound;\n+\n+    public FileNumberingFilterWriter(Writer out) {\n+        super(out);\n+        lineNumber = 1;\n+        beginning = true;\n+        newLineFound = false;\n+    }\n \n-  public FileNumberingFilterWriter(Writer out) {\n-    super(out);\n-  }\n+    @Override\n+    public void write(String str, int off, int len) throws IOException {\n+        write(str.toCharArray(), off, len);\n+    }\n \n-  @Override\n-  public void write(String str, int off, int len) throws IOException {\n-    throw new UnsupportedOperationException(\"The student has not implemented this method yet.\");\n-  }\n+    @Override\n+    public void write(char[] cbuf, int off, int len) throws IOException {\n \n-  @Override\n-  public void write(char[] cbuf, int off, int len) throws IOException {\n-    throw new UnsupportedOperationException(\"The student has not implemented this method yet.\");\n-  }\n+        // Tests to determine if off and len are valid\n+        if(off < 0 || len < 0 || off+len < 0 || off + len >  cbuf.length){\n+            throw new IndexOutOfBoundsException();\n+        }\n+        for (int i = off; i < off + len; i++) {\n+            write(cbuf[i]);\n+        }\n+        if (newLineFound) {\n+            newLineFound = false;\n+            insertNewLine();\n+        }\n+    }\n \n-  @Override\n-  public void write(int c) throws IOException {\n-    throw new UnsupportedOperationException(\"The student has not implemented this method yet.\");\n-  }\n+    @Override\n+    public void write(int c) throws IOException {\n+        if (beginning) {\n+            beginning = false;\n+            insertNewLine();\n+        }\n+        if (c == '\\n' || c == '\\r') {\n+            newLineFound = true;\n+        } else if (newLineFound) {\n+            newLineFound = false;\n+            insertNewLine();\n+        }\n+        out.write(c);\n \n+    }\n+\n+    /**\n+     * Send the line number and a tabulation to the writer then update the line number.\n+     *\n+     * (Just here to avoid code duplication and make sure the line number is always incremented)\n+     */\n+    private void insertNewLine() throws IOException {\n+        out.write(lineNumber + \"\\t\");\n+        ++lineNumber;\n+    }\n }\n+"
  },
  {
    "sha": "f19b70c625b7f877b6781a6418a87ec2f33ae34f",
    "filename": "LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/filters/UpperCaseFilterWriter.java",
    "status": "modified",
    "additions": 26,
    "deletions": 20,
    "changes": 46,
    "blob_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/blob/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/filters/UpperCaseFilterWriter.java",
    "raw_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/raw/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/filters/UpperCaseFilterWriter.java",
    "contents_url": "https://api.github.com/repos/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/contents/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/filters/UpperCaseFilterWriter.java?ref=324b310dffb223396c0dfdde49950d1377d51dc9",
    "patch": "@@ -5,28 +5,34 @@\n import java.io.Writer;\n \n /**\n- *\n  * @author Olivier Liechti\n  */\n public class UpperCaseFilterWriter extends FilterWriter {\n-  \n-  public UpperCaseFilterWriter(Writer wrappedWriter) {\n-    super(wrappedWriter);\n-  }\n-\n-  @Override\n-  public void write(String str, int off, int len) throws IOException {\n-    throw new UnsupportedOperationException(\"The student has not implemented this method yet.\");\n-  }\n-\n-  @Override\n-  public void write(char[] cbuf, int off, int len) throws IOException {\n-    throw new UnsupportedOperationException(\"The student has not implemented this method yet.\");\n-  }\n-\n-  @Override\n-  public void write(int c) throws IOException {\n-    throw new UnsupportedOperationException(\"The student has not implemented this method yet.\");\n-  }\n+\n+    public UpperCaseFilterWriter(Writer wrappedWriter) {\n+        super(wrappedWriter);\n+    }\n+\n+    @Override\n+    public void write(String str, int off, int len) throws IOException {\n+        out.write(str.substring(off, off + len).toUpperCase());\n+    }\n+\n+    @Override\n+    public void write(char[] cbuf, int off, int len) throws IOException {\n+\n+        // Tests to determine if off and len are valid\n+        if(off < 0 || len < 0 || off+len < 0 || off + len >  cbuf.length){\n+            throw new IndexOutOfBoundsException();\n+        }\n+        for (int i = off; i < off+len; i++) {\n+            write(cbuf[i]);\n+        }\n+    }\n+\n+    @Override\n+    public void write(int c) throws IOException {\n+        out.write(Character.toUpperCase(c));\n+    }\n \n }"
  },
  {
    "sha": "ba39561400e086a486f040a70fbfc34f45dc0091",
    "filename": "LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/transformers/CompleteFileTransformer.java",
    "status": "modified",
    "additions": 5,
    "deletions": 4,
    "changes": 9,
    "blob_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/blob/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/transformers/CompleteFileTransformer.java",
    "raw_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/raw/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/transformers/CompleteFileTransformer.java",
    "contents_url": "https://api.github.com/repos/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/contents/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/transformers/CompleteFileTransformer.java?ref=324b310dffb223396c0dfdde49950d1377d51dc9",
    "patch": "@@ -1,5 +1,8 @@\n package ch.heigvd.res.labio.impl.transformers;\n \n+import ch.heigvd.res.labio.impl.filters.FileNumberingFilterWriter;\n+import ch.heigvd.res.labio.impl.filters.UpperCaseFilterWriter;\n+\n import java.io.Writer;\n \n /**\n@@ -15,16 +18,14 @@\n \n   @Override\n   public Writer decorateWithFilters(Writer writer) {\n-    if (true) {\n-      throw new UnsupportedOperationException(\"The student has not implemented this method yet.\");\n-    }\n+\n     /*\n      * If you uncomment the following line (and get rid of th 3 previous lines...), you will restore the decoration \n      * of the writer (connected to the file. You can see that you first decorate the writer with an UpperCaseFilterWriter, which you then\n      * decorate with a FileNumberingFilterWriter. The resulting writer is used by the abstract class to write the characters read from the\n      * input files. So, the input is first prefixed with line numbers, then transformed to uppercase, then sent to the output file.f\n      */\n-    //writer = new FileNumberingFilterWriter(new UpperCaseFilterWriter(writer));\n+    writer = new FileNumberingFilterWriter(new UpperCaseFilterWriter(writer));\n     return writer; \n   }\n "
  },
  {
    "sha": "1f451abdc9b356abcb8c964ee1f49bd764b4c5f0",
    "filename": "LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/transformers/FileTransformer.java",
    "status": "modified",
    "additions": 7,
    "deletions": 2,
    "changes": 9,
    "blob_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/blob/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/transformers/FileTransformer.java",
    "raw_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/raw/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/transformers/FileTransformer.java",
    "contents_url": "https://api.github.com/repos/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/contents/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/transformers/FileTransformer.java?ref=324b310dffb223396c0dfdde49950d1377d51dc9",
    "patch": "@@ -43,15 +43,20 @@ public void visit(File file) {\n       return;\n     }\n     try {\n-      Reader reader = new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8);\n-      Writer writer = new OutputStreamWriter(new FileOutputStream(file.getPath()+ \".out\"), StandardCharsets.UTF_8); // the bug fix by teacher\n+      Reader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8));\n+      Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file.getPath()+ \".out\"), StandardCharsets.UTF_8)); // the bug fix by teacher\n       writer = decorateWithFilters(writer);\n \n       /*\n        * There is a missing piece here: you have an input reader and an ouput writer (notice how the \n        * writer has been decorated by the concrete subclass!). You need to write a loop to read the\n        * characters and write them to the writer.\n        */\n+\n+      int c;\n+      while ((c = reader.read()) != -1){\n+        writer.write(c);\n+      }\n       \n       reader.close();\n       writer.flush();"
  },
  {
    "sha": "e0651e6aa0bdac1e2b9dfc3a5d0ca443afc72a96",
    "filename": "LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/transformers/NoOpFileTransformer.java",
    "status": "modified",
    "additions": 1,
    "deletions": 2,
    "changes": 3,
    "blob_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/blob/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/transformers/NoOpFileTransformer.java",
    "raw_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/raw/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/transformers/NoOpFileTransformer.java",
    "contents_url": "https://api.github.com/repos/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/contents/LabJavaIO/src/main/java/ch/heigvd/res/labio/impl/transformers/NoOpFileTransformer.java?ref=324b310dffb223396c0dfdde49950d1377d51dc9",
    "patch": "@@ -13,14 +13,13 @@\n \n   @Override\n   public Writer decorateWithFilters(Writer writer) {\n-    throw new UnsupportedOperationException(\"The student has not implemented this method yet.\");\n     /*\n      * The NoOpFileTransformer does not apply any transformation of the character stream\n      * (no uppercase, no line number, etc.). So, we don't need to decorate the writer connected to\n      * the output file at all. Just uncomment the following line and get rid of the UnsupportedOperationException and\n      * you will be all set.\n      */\n-    //return writer;\n+    return writer;\n   }\n \n }"
  },
  {
    "sha": "9c91c7e7f3ba7664aece3e2e50ff96334e57c3b1",
    "filename": "LabJavaIO/src/test/java/ch/heigvd/res/labio/impl/explorers/DFSFileExplorerTest.java",
    "status": "modified",
    "additions": 115,
    "deletions": 60,
    "changes": 175,
    "blob_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/blob/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/test/java/ch/heigvd/res/labio/impl/explorers/DFSFileExplorerTest.java",
    "raw_url": "https://github.com/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/raw/324b310dffb223396c0dfdde49950d1377d51dc9/LabJavaIO/src/test/java/ch/heigvd/res/labio/impl/explorers/DFSFileExplorerTest.java",
    "contents_url": "https://api.github.com/repos/SoftEng-HEIGVD/https-github.com-SoftEng-HEIGVD-Teaching-HEIGVD-RES-2021-Labo-Java-IO/contents/LabJavaIO/src/test/java/ch/heigvd/res/labio/impl/explorers/DFSFileExplorerTest.java?ref=324b310dffb223396c0dfdde49950d1377d51dc9",
    "patch": "@@ -15,70 +15,125 @@\n import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n \n /**\n- *\n  * @author Olivier Liechti\n  */\n public class DFSFileExplorerTest {\n \n-  private static final Logger LOG = Logger.getLogger(DFSFileExplorerTest.class.getName());\n-\n-  @Test\n-  public void dfsExplorerShouldWork() {\n-    List<String> dfsNodes = generateTestTree(5, 5, 5);\n-\n-    final List<String> directories = new ArrayList<>();\n-    IFileExplorer explorer = new DFSFileExplorer();\n-\n-    explorer.explore(new File(\"./fs-test\"), new IFileVisitor() {\n-      @Override\n-      public void visit(File file) {\n-        directories.add(file.getName());\n-      }\n-    });\n-    assertArrayEquals(dfsNodes.toArray(), directories.toArray());\n-  }\n-\n-  @Test\n-  public void dfsExplorerShouldWorkWhenThereIsNoFile() {\n-    List<String> dfsNodes = generateTestTree(0, 0, 0);\n-\n-    final List<String> directories = new ArrayList<>();\n-    IFileExplorer explorer = new DFSFileExplorer();\n-\n-    explorer.explore(new File(\"./fs-test\"), new IFileVisitor() {\n-      @Override\n-      public void visit(File file) {\n-        directories.add(file.getName());\n-      }\n-    });\n-    assertArrayEquals(dfsNodes.toArray(), directories.toArray());\n-  }\n-  \n-  private List<String> generateTestTree(int levels, int maxChildrenFolders, int maxChildrenFiles) {\n-    List<String> dfsNodes = new ArrayList<>();  \n-    File dir = new File(\"./fs-test\");\n-    try {\n-      FileUtils.deleteDirectory(dir);\n-    } catch (IOException ex) {\n-      LOG.log(Level.SEVERE, \"Could not delete {0} : {1}\", new Object[]{dir, ex.getMessage()});\n+    private static final Logger LOG = Logger.getLogger(DFSFileExplorerTest.class.getName());\n+\n+    @Test\n+    public void dfsExplorerShouldWork() {\n+        List<String> dfsNodes = generateTestTree(5, 5, 5);\n+\n+        final List<String> directories = new ArrayList<>();\n+        IFileExplorer explorer = new DFSFileExplorer();\n+\n+        explorer.explore(new File(\"./fs-test\"), new IFileVisitor() {\n+            @Override\n+            public void visit(File file) {\n+                directories.add(file.getName());\n+            }\n+        });\n+        assertArrayEquals(dfsNodes.toArray(), directories.toArray());\n+    }\n+\n+    @Test\n+    public void dfsExplorerWithFilesShouldWork() {\n+        List<String> dfsNodes = generateTestTreeWithFiles(5, 5, 5);\n+\n+        final List<String> directories = new ArrayList<>();\n+        IFileExplorer explorer = new DFSFileExplorer();\n+\n+        explorer.explore(new File(\"./fs-test\"), new IFileVisitor() {\n+            @Override\n+            public void visit(File file) {\n+                directories.add(file.getName());\n+            }\n+        });\n+        assertArrayEquals(dfsNodes.toArray(), directories.toArray());\n+    }\n+\n+    @Test\n+    public void dfsExplorerShouldWorkWhenThereIsNoFile() {\n+        List<String> dfsNodes = generateTestTree(0, 0, 0);\n+\n+        final List<String> directories = new ArrayList<>();\n+        IFileExplorer explorer = new DFSFileExplorer();\n+\n+        explorer.explore(new File(\"./fs-test\"), new IFileVisitor() {\n+            @Override\n+            public void visit(File file) {\n+                directories.add(file.getName());\n+            }\n+        });\n+        assertArrayEquals(dfsNodes.toArray(), directories.toArray());\n     }\n-    dfsNodes.add(dir.getName());\n-    generateLevel(dir, 0, levels, maxChildrenFolders, maxChildrenFiles, dfsNodes);\n-    return dfsNodes;\n-  }\n-\n-  private void generateLevel(File dir, int level, int maxLevels, int maxChildrenFolders, int maxChildrenFiles, List<String> dfsNodes) {\n-    int childrenFolders = (int) (Math.random() * maxChildrenFolders);\n-    int childrenFiles = (int) (Math.random() * maxChildrenFiles);\n-\n-    for (int i = 0; i < childrenFolders; i++) {\n-      String dirName = dir.getName() + \".\" + (i + 1);\n-      dfsNodes.add(dirName);\n-      File newDir = new File(dir, dirName);\n-      newDir.mkdirs();\n-      if (level < maxLevels) {\n-        generateLevel(newDir, level + 1, maxLevels, maxChildrenFolders, maxChildrenFiles, dfsNodes);\n-      }\n+\n+    private List<String> generateTestTree(int levels, int maxChildrenFolders, int maxChildrenFiles) {\n+        List<String> dfsNodes = new ArrayList<>();\n+        File dir = new File(\"./fs-test\");\n+        try {\n+            FileUtils.deleteDirectory(dir);\n+        } catch (IOException ex) {\n+            LOG.log(Level.SEVERE, \"Could not delete {0} : {1}\", new Object[]{dir, ex.getMessage()});\n+        }\n+        dfsNodes.add(dir.getName());\n+        generateLevel(dir, 0, levels, maxChildrenFolders, maxChildrenFiles, dfsNodes);\n+        return dfsNodes;\n+    }\n+\n+    private void generateLevel(File dir, int level, int maxLevels, int maxChildrenFolders, int maxChildrenFiles, List<String> dfsNodes) {\n+        int childrenFolders = (int) (Math.random() * maxChildrenFolders);\n+        int childrenFiles = (int) (Math.random() * maxChildrenFiles);\n+\n+        for (int i = 0; i < childrenFolders; i++) {\n+            String dirName = dir.getName() + \".\" + (i + 1);\n+            dfsNodes.add(dirName);\n+            File newDir = new File(dir, dirName);\n+            newDir.mkdirs();\n+            if (level < maxLevels) {\n+                generateLevel(newDir, level + 1, maxLevels, maxChildrenFolders, maxChildrenFiles, dfsNodes);\n+            }\n+        }\n+    }\n+\n+    private List<String> generateTestTreeWithFiles(int levels, int maxChildrenFolders, int maxChildrenFiles) {\n+        List<String> dfsNodes = new ArrayList<>();\n+        File dir = new File(\"./fs-test\");\n+        try {\n+            FileUtils.deleteDirectory(dir);\n+        } catch (IOException ex) {\n+            LOG.log(Level.SEVERE, \"Could not delete {0} : {1}\", new Object[]{dir, ex.getMessage()});\n+        }\n+        dfsNodes.add(dir.getName());\n+        generateLevelWithFiles(dir, 0, levels, maxChildrenFolders, maxChildrenFiles, dfsNodes);\n+        return dfsNodes;\n+    }\n+\n+\n+    private void generateLevelWithFiles(File dir, int level, int maxLevels, int maxChildrenFolders, int maxChildrenFiles, List<String> dfsNodes) {\n+        int childrenFolders = (int) (Math.random() * maxChildrenFolders);\n+        int childrenFiles = (int) (Math.random() * maxChildrenFiles);\n+\n+        for (int i = 0; i < childrenFolders; i++) {\n+            String dirName = dir.getName() + \".\" + (i + 1);\n+            dfsNodes.add(dirName);\n+            File newDir = new File(dir, dirName);\n+            newDir.mkdirs();\n+            if (level < maxLevels) {\n+                generateLevelWithFiles(newDir, level + 1, maxLevels, maxChildrenFolders, maxChildrenFiles, dfsNodes);\n+            }\n+        }\n+        for (int i = 0; i < childrenFiles; i++) {\n+            String fileName = dir.getName() + \".\" + (i + 1) + \"_f\";\n+            File newFile = new File(dir, fileName);\n+            try {\n+                newFile.createNewFile();\n+                dfsNodes.add(fileName);\n+            } catch (IOException e) {\n+                System.err.println(\"Error in preparing test \" + e + \" \" + dir);\n+            }\n+        }\n+\n     }\n-  }\n }"
  }
]
