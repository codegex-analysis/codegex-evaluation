[
  {
    "sha": "f29dc071a452cfe87d2c337528cb615a4407990a",
    "filename": "src/common/java/net/minecraftforge/gradle/common/util/MavenArtifactDownloader.java",
    "status": "modified",
    "additions": 88,
    "deletions": 2,
    "changes": 90,
    "blob_url": "https://github.com/MinecraftForge/ForgeGradle/blob/f8ccf0f65b63e93b8ddc0c0f613df96721680d9b/src/common/java/net/minecraftforge/gradle/common/util/MavenArtifactDownloader.java",
    "raw_url": "https://github.com/MinecraftForge/ForgeGradle/raw/f8ccf0f65b63e93b8ddc0c0f613df96721680d9b/src/common/java/net/minecraftforge/gradle/common/util/MavenArtifactDownloader.java",
    "contents_url": "https://api.github.com/repos/MinecraftForge/ForgeGradle/contents/src/common/java/net/minecraftforge/gradle/common/util/MavenArtifactDownloader.java?ref=f8ccf0f65b63e93b8ddc0c0f613df96721680d9b",
    "patch": "@@ -49,12 +49,22 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n \n import javax.xml.parsers.ParserConfigurationException;\n \n public class MavenArtifactDownloader {\n+    /**\n+     * This tracks downloads that are <b>currently</b> active. As soon as a download has finished it will be removed\n+     * from this map.\n+     */\n+    private static final Map<DownloadKey, Future<File>> ACTIVE_DOWNLOADS = new HashMap<>();\n+\n     private static final Cache<String, File> CACHE = CacheBuilder.newBuilder()\n             .expireAfterWrite(5, TimeUnit.MINUTES)\n             .build();\n@@ -87,11 +97,43 @@ public static File manual(Project project, String artifact, boolean changing) {\n         return _download(project, artifact, changing, false, false, true);\n     }\n \n-\n     private static File _download(Project project, String artifact, boolean changing, boolean generated, boolean gradle, boolean manual) {\n-        Artifact art = Artifact.from(artifact);\n+        /*\n+         * This somewhat convoluted code is necessary to avoid race-conditions when two Gradle worker threads simultaneously\n+         * try to download the same artifact.\n+         * The first thread registers a future that other threads can wait on.\n+         * Once it finishes, the future will be removed and subsequent calls will use the CACHE instead.\n+         */\n+        DownloadKey downloadKey = new DownloadKey(project, artifact, changing, generated, gradle, manual);\n+        CompletableFuture<File> future;\n+        synchronized (ACTIVE_DOWNLOADS) {\n+            Future<File> activeDownload = ACTIVE_DOWNLOADS.get(downloadKey);\n+            if (activeDownload != null) {\n+                // Some other thread is already working downloading this exact artifact, wait for it to finish\n+                try {\n+                    project.getLogger().info(\"Waiting for download of {} on other thread\", artifact);\n+                    return activeDownload.get();\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                } catch (ExecutionException e) {\n+                    if (e.getCause() instanceof RuntimeException) {\n+                        throw (RuntimeException) e.getCause();\n+                    } else {\n+                        throw new RuntimeException(e.getCause());\n+                    }\n+                }\n+            } else {\n+                project.getLogger().info(\"Downloading {}\", artifact);\n+                // We're the first thread to download the artifact, make sure concurrent downloads just wait for us\n+                future = new CompletableFuture<>();\n+                ACTIVE_DOWNLOADS.put(downloadKey, future);\n+            }\n+        }\n+\n         File ret = null;\n         try {\n+            Artifact art = Artifact.from(artifact);\n+\n             ret = CACHE.getIfPresent(artifact);\n             if (ret != null && !ret.exists()) {\n                 CACHE.invalidate(artifact);\n@@ -125,8 +167,15 @@ else if (repo instanceof GradleRepositoryAdapter)\n \n             if (ret != null)\n                 CACHE.put(artifact, ret);\n+\n+            future.complete(ret);\n         } catch (RuntimeException | IOException | URISyntaxException e) {\n+            future.completeExceptionally(e);\n             e.printStackTrace();\n+        } finally {\n+            synchronized (ACTIVE_DOWNLOADS) {\n+                ACTIVE_DOWNLOADS.remove(downloadKey);\n+            }\n         }\n         return ret;\n     }\n@@ -290,4 +339,41 @@ private static File _downloadWithCache(Project project, URI maven, String path,\n         File target = Utils.getCache(project, \"maven_downloader\", path);\n         return Utils.downloadWithCache(url, target, changing, bypassLocal);\n     }\n+\n+    /**\n+     * Key used to track active downloads and avoid downloading the same file in two threads concurrently,\n+     * leading to corrupted files on disk.\n+     */\n+    private static class DownloadKey {\n+        private final Project project;\n+        private final String artifact;\n+        private final boolean changing;\n+        private final boolean generated;\n+        private final boolean gradle;\n+        private final boolean manual;\n+\n+        DownloadKey(Project project, String artifact, boolean changing, boolean generated, boolean gradle, boolean manual) {\n+            this.project = project;\n+            this.artifact = artifact;\n+            this.changing = changing;\n+            this.generated = generated;\n+            this.gradle = gradle;\n+            this.manual = manual;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DownloadKey that = (DownloadKey) o;\n+            return changing == that.changing && generated == that.generated && gradle == that.gradle && manual == that.manual && project.equals(that.project) && artifact.equals(that.artifact);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(project, artifact, changing, generated, gradle, manual);\n+        }\n+\n+    }\n+\n }"
  }
]
