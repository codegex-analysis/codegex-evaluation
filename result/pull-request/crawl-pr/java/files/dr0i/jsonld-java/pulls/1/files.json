[
  {
    "sha": "aeafccd31c48e395e6c81e9ad276112b8c8cac6e",
    "filename": ".gitignore",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/.gitignore",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/.gitignore",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/.gitignore?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -7,3 +7,4 @@ target/\n .idea\n *~\n pom.xml.versionsBackup\n+dependency-reduced-pom.xml"
  },
  {
    "sha": "df26cdc0bf1d0619ccdabf24bddf790d1386fa5d",
    "filename": ".travis.yml",
    "status": "modified",
    "additions": 6,
    "deletions": 6,
    "changes": 12,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/.travis.yml",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/.travis.yml",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/.travis.yml?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -1,11 +1,11 @@\n language: java\n-dist: trusty\n jdk:\n-  - oraclejdk8\n-  - oraclejdk9\n+  - openjdk8\n+  - openjdk11\n notifications:\n-  email:\n-    - ansell.peter@gmail.com\n-    - tristan.king@gmail.com\n+  email: false\n after_success:\n   - mvn clean test jacoco:report coveralls:report\n+arch:\n+  - amd64\n+  - ppc64le"
  },
  {
    "sha": "c2b906009f2fe2b63441171ad795d3987f86e648",
    "filename": "README.md",
    "status": "modified",
    "additions": 91,
    "deletions": 12,
    "changes": 103,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/README.md",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/README.md",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/README.md?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -1,7 +1,9 @@\n+**JSONLD-Java is looking for a maintainer**\n+\n JSONLD-JAVA\n ===========\n \n-This is a Java implementation of the [JSON-LD specification](http://www.w3.org/TR/json-ld/) and the [JSON-LD-API specification](http://www.w3.org/TR/json-ld-api/).\n+This is a Java implementation of the [JSON-LD 1.0 specification](https://www.w3.org/TR/2014/REC-json-ld-20140116/) and the [JSON-LD-API 1.0 specification](https://www.w3.org/TR/2014/REC-json-ld-api-20140116/).\n \n [![Build Status](https://travis-ci.org/jsonld-java/jsonld-java.svg?branch=master)](https://travis-ci.org/jsonld-java/jsonld-java) [![Coverage Status](https://coveralls.io/repos/jsonld-java/jsonld-java/badge.svg?branch=master)](https://coveralls.io/r/jsonld-java/jsonld-java?branch=master)\n \n@@ -14,11 +16,12 @@ From Maven\n     <dependency>\n         <groupId>com.github.jsonld-java</groupId>\n         <artifactId>jsonld-java</artifactId>\n-        <version>0.11.0</version>\n+        <version>0.13.3</version>\n     </dependency>\n \n Code example\n ------------\n+\n ```java\n // Open a valid json(-ld) input file\n InputStream inputStream = new FileInputStream(\"input.json\");\n@@ -36,11 +39,11 @@ Object compact = JsonLdProcessor.compact(jsonObject, context, options);\n // Print out the result (or don't, it's your call!)\n System.out.println(JsonUtils.toPrettyString(compact));\n ```\n+\n Processor options\n -----------------\n \n-The Options specified by the [JSON-LD API Specification](http://json-ld.org/spec/latest/json-ld-api/#jsonldoptions) are accessible via the `com.github.jsonldjava.core.JsonLdOptions` class, and each `JsonLdProcessor.*` function has an optional input to take an instance of this class.\n-\n+The Options specified by the [JSON-LD API Specification](https://json-ld.org/spec/latest/json-ld-api/#the-jsonldoptions-type) are accessible via the `com.github.jsonldjava.core.JsonLdOptions` class, and each `JsonLdProcessor.*` function has an optional input to take an instance of this class.\n \n Controlling network traffic\n ---------------------------\n@@ -57,7 +60,6 @@ The default HTTP Client is wrapped with a\n [CachingHttpClient](https://hc.apache.org/httpcomponents-client-ga/httpclient-cache/apidocs/org/apache/http/impl/client/cache/CachingHttpClient.html) to provide a \n small memory-based cache (1000 objects, max 128 kB each) of regularly accessed contexts.\n \n-\n ### Loading contexts from classpath\n \n Your application might be parsing JSONLD documents which always use the same\n@@ -149,15 +151,15 @@ Note that if you override DocumentLoader you should also support this setting fo\n \n Your application might be parsing JSONLD documents which reference external `@context` IRIs\n that are not available as file URIs on the classpath. In this case, the `jarcache.json`\n-approch will not work. Instead you can inject the literal context file strings through\n+approach will not work. Instead you can inject the literal context file strings through\n the `JsonLdOptions` object, as follows:\n \n ```java\n // Inject a context document into the options as a literal string\n DocumentLoader dl = new DocumentLoader();\n JsonLdOptions options = new JsonLdOptions();\n // ... the contents of \"contexts/example.jsonld\"\n-String jsonContext = \"{ \\\"@contxt\\\": { ... } }\";\n+String jsonContext = \"{ \\\"@context\\\": { ... } }\";\n dl.addInjectedDoc(\"http://www.example.com/context\",  jsonContext);\n options.setDocumentLoader(dl);\n \n@@ -242,8 +244,6 @@ For Developers\n \n `jsonld-java` uses maven to compile. From the base `jsonld-java` module run `mvn clean install` to install the jar into your local maven repository.\n \n-The tests require Java-8 to compile, while the rest of the codebase is still compatible and built using the Java-6 APIs.\n-\n ### Running tests\n \n ```bash\n@@ -321,12 +321,13 @@ Here is the basic outline for what your module's pom.xml should look like\n     xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n \n   <parent>\n-    <artifactId>jsonld-java-integration</artifactId>\n-    <groupId>com.github.jsonld-java-parent</groupId>\n-    <version>0.11.0-SNAPSHOT</version>\n+    <groupId>com.github.jsonld-java</groupId>\n+    <artifactId>jsonld-java-parent</artifactId>\n+    <version>0.13.3</version>\n   </parent>\n   <modelVersion>4.0.0</modelVersion>\n   <artifactId>jsonld-java-{your module}</artifactId>\n+  <version>0.13.3-SNAPSHOT</version>\n   <name>JSONLD Java :: {your module name}</name>\n   <description>JSON-LD Java integration module for {RDF Library your module integrates}</description>\n   <packaging>jar</packaging>\n@@ -448,6 +449,84 @@ Alternatively, we can also host your repository in the jsonld-java organisation\n \n CHANGELOG\n =========\n+### 2021-03-06\n+* Release 0.13.3\n+* Fix @type when subject and object are the same (Reported by @barthanssens, Patch by @umbreak)\n+* Ignore @base if remote context is not relative (Reported by @whikloj, Patch by @dr0i)\n+* Fix throwing recursive context inclusion (Patch by @umbreak)\n+\n+### 2020-09-24\n+* Release 0.13.2\n+* Fix Guava dependency shading (Reported by @ggrasso)\n+* Fix @context issues when using a remote context (Patch by @umbreak)\n+* Deprecate Context.serialize (Patch by @umbreak)\n+\n+### 2020-09-09\n+* Release 0.13.1\n+* Fix java.net.URI resolution (Reported by @ebremer and @afs, Patch by @dr0i)\n+* Shade Guava failureaccess module (Patch by @peacekeeper)\n+* Don't minimize Guava class shading (Patch by @elahrvivaz)\n+* Follow link headers to @context files (Patch by @dr0i and @fsteeg)\n+\n+### 2019-11-28\n+* Release 0.13.0\n+* Bump Jackson versions to latest for security updates (Patch by @afs)\n+* Do not canonicalise XSD Decimal typed values (Patch by @jhg023)\n+* Bump dependency and plugin versions\n+\n+### 2019-08-03\n+* Release 0.12.5\n+* Bump Jackson versions to latest for security updates (Patches by @afs)\n+* IRI resolution fixes (Patch by @fsteeg)\n+\n+### 2019-04-20\n+* Release 0.12.4\n+* Bump Jackson version to 2.9.8\n+* Add a regression test for a past framing bug\n+* Throw error on empty key\n+* Add regression tests for workarounds to Text/URL dual definitions\n+* Persist JsonLdOptions through normalize/toRDF\n+\n+### 2018-11-24\n+* Release 0.12.3\n+* Fix NaN/Inf/-Inf raw value types on conversion to RDF\n+* Added fix for wrong rdf:type to @type conversion (Path by @umbreak)\n+* Open up Context.getTypeMapping and Context.getLanguageMapping for reuse\n+\n+### 2018-11-03\n+* W3c json ld syntax 34 allow container set on aliased type (Patch by @dr0i)\n+* Release 0.12.2\n+\n+### 2018-09-05\n+* handle omit graph flag (Patch by @eroux)\n+* Release 0.12.1\n+* Make pruneBlankNodeIdentifiers false by default in 1.0 mode and always true in 1.1 mode (Patch by @eroux)\n+* Fix issue with blank node identifier pruning when @id is aliased (Patch by @eroux)\n+* Allow wildcard {} for @id in framing (Patch by @eroux)\n+\n+### 2018-07-07\n+* Fix tests setup for schema.org with HttpURLConnection that break because of the inability of HttpURLConnection to redirect from HTTP to HTTPS\n+\n+### 2018-04-08\n+* Release 0.12.0\n+* Encapsulate RemoteDocument and make it immutable\n+\n+### 2018-04-03\n+* Fix performance issue caused by not caching schema.org and others that use ``Cache-Control: private`` (Patch by @HansBrende)\n+* Cache classpath scans for jarcache.json to fix a similar performance issue\n+* Add internal shaded dependency on Google Guava to use maintained soft and weak reference maps rather than adhoc versions\n+* Make JsonLdError a RuntimeException to improve its use in closures\n+* Bump minor version to 0.12 to reflect the API incompatibility caused by JsonLdError and protected field change and hiding in JarCacheStorage\n+\n+### 2018-01-25\n+* Fix resource leak in JsonUtils.fromURL on unsuccessful requests (Patch by @plaplaige)\n+\n+### 2017-11-15\n+* Ignore UTF BOM (Patch by @christopher-johnson)\n+\n+### 2017-08-26\n+* Release 0.11.1\n+* Fix @embed:@always support (Patch by @dr0i)\n \n ### 2017-08-24\n * Release 0.11.0"
  },
  {
    "sha": "b771cbee23509bc51d730a90dcc07adb07b42b21",
    "filename": "core/pom.xml",
    "status": "modified",
    "additions": 52,
    "deletions": 1,
    "changes": 53,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/pom.xml",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/pom.xml",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/pom.xml?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -4,7 +4,7 @@\n \t<parent>\n \t\t<artifactId>jsonld-java-parent</artifactId>\n \t\t<groupId>com.github.jsonld-java</groupId>\n-\t\t<version>0.11.1-SNAPSHOT</version>\n+\t\t<version>0.13.3-SNAPSHOT</version>\n \t</parent>\n \t<modelVersion>4.0.0</modelVersion>\n \t<artifactId>jsonld-java</artifactId>\n@@ -43,6 +43,10 @@\n \t\t\t<groupId>commons-io</groupId>\n \t\t\t<artifactId>commons-io</artifactId>\n \t\t</dependency>\n+\t\t<dependency>\n+\t\t\t<groupId>com.google.guava</groupId>\n+\t\t\t<artifactId>guava</artifactId>\n+\t\t</dependency>\n \t\t<dependency>\n \t\t\t<groupId>junit</groupId>\n \t\t\t<artifactId>junit</artifactId>\n@@ -61,6 +65,52 @@\n \t</dependencies>\n \t<build>\n \t\t<plugins>\n+\t\t\t<!-- Shade Google Guava into jsonld-java to avoid downstream incompatibilities \n+\t\t\t\tcaused by Guava's fast major release cycles. -->\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n+\t\t\t\t<artifactId>maven-shade-plugin</artifactId>\n+\t\t\t\t<configuration>\n+\t\t\t\t\t<artifactSet>\n+\t\t\t\t\t\t<includes>\n+\t\t\t\t\t\t\t<include>com.google.guava:guava</include>\n+\t\t\t\t\t\t\t<include>com.google.guava:failureaccess</include>\n+\t\t\t\t\t\t</includes>\n+\t\t\t\t\t</artifactSet>\n+\t\t\t\t\t<relocations>\n+\t\t\t\t\t\t<relocation>\n+\t\t\t\t\t\t\t<pattern>com.google.common</pattern>\n+\t\t\t\t\t\t\t<shadedPattern>com.github.jsonldjava.shaded.com.google.common</shadedPattern>\n+\t\t\t\t\t\t</relocation>\n+\t\t\t\t\t\t<relocation>\n+\t\t\t\t\t\t\t<pattern>com.google.thirdparty</pattern>\n+\t\t\t\t\t\t\t<shadedPattern>com.github.jsonldjava.shaded.com.google.thirdparty</shadedPattern>\n+\t\t\t\t\t\t</relocation>\n+\t\t\t\t\t</relocations>\n+\t\t\t\t\t<filters>\n+\t\t\t\t\t\t<filter>\n+\t\t\t\t\t\t\t<artifact>com.google.guava:guava</artifact>\n+\t\t\t\t\t\t\t<excludes>\n+\t\t\t\t\t\t\t\t<exclude>META-INF/maven/**</exclude>\n+\t\t\t\t\t\t\t</excludes>\n+\t\t\t\t\t\t</filter>\n+\t\t\t\t\t\t<filter>\n+\t\t\t\t\t\t\t<artifact>com.google.guava:failureaccess</artifact>\n+\t\t\t\t\t\t\t<excludes>\n+\t\t\t\t\t\t\t\t<exclude>META-INF/maven/**</exclude>\n+\t\t\t\t\t\t\t</excludes>\n+\t\t\t\t\t\t</filter>\n+\t\t\t\t\t</filters>\n+\t\t\t\t</configuration>\n+\t\t\t\t<executions>\n+\t\t\t\t\t<execution>\n+\t\t\t\t\t\t<phase>package</phase>\n+\t\t\t\t\t\t<goals>\n+\t\t\t\t\t\t\t<goal>shade</goal>\n+\t\t\t\t\t\t</goals>\n+\t\t\t\t\t</execution>\n+\t\t\t\t</executions>\n+\t\t\t</plugin>\n \t\t\t<plugin>\n \t\t\t\t<groupId>org.codehaus.mojo</groupId>\n \t\t\t\t<artifactId>animal-sniffer-maven-plugin</artifactId>\n@@ -72,6 +122,7 @@\n \t\t\t\t<configuration>\n \t\t\t\t\t<instructions>\n \t\t\t\t\t\t<Import-Package>\n+\t\t\t\t\t\t\t!com.google.common.*,\n \t\t\t\t\t\t\torg.slf4j.*; version=\"[1.0.0,2)\",\n \t\t\t\t\t\t\t*\n \t\t\t\t\t\t</Import-Package>"
  },
  {
    "sha": "4e563d7817a9f5b3bf10609fc46d1476d68821ba",
    "filename": "core/src/main/java/com/github/jsonldjava/core/Context.java",
    "status": "modified",
    "additions": 52,
    "deletions": 28,
    "changes": 80,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/Context.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/Context.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/Context.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -9,6 +9,7 @@\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.regex.Pattern;\n \n import com.github.jsonldjava.core.JsonLdError.Error;\n import com.github.jsonldjava.utils.JsonLdUrl;\n@@ -23,6 +24,9 @@\n  */\n public class Context extends LinkedHashMap<String, Object> {\n \n+    private static final long serialVersionUID = 2894534897574805571L;\n+\n+    private static final Pattern URL_PATTERN = Pattern.compile(\"^https?://.*$\", Pattern.CASE_INSENSITIVE);\n     private JsonLdOptions options;\n     private Map<String, Object> termDefinitions;\n     public Map<String, Object> inverse = null;\n@@ -38,11 +42,13 @@ public Context(JsonLdOptions opts) {\n \n     public Context(Map<String, Object> map, JsonLdOptions opts) {\n         super(map);\n+        checkEmptyKey(map);\n         init(opts);\n     }\n \n     public Context(Map<String, Object> map) {\n         super(map);\n+        checkEmptyKey(map);\n         init(new JsonLdOptions());\n     }\n \n@@ -137,8 +143,10 @@ public Object compactValue(String activeProperty, Map<String, Object> value) {\n      * @throws JsonLdError\n      *             If there is an error parsing the contexts.\n      */\n-    @SuppressWarnings(\"unchecked\")\n     public Context parse(Object localContext, List<String> remoteContexts) throws JsonLdError {\n+        if (remoteContexts == null) {\n+            remoteContexts = new ArrayList<String>();\n+        }\n         return parse(localContext, remoteContexts, false);\n     }\n \n@@ -159,11 +167,8 @@ public Context parse(Object localContext, List<String> remoteContexts) throws Js\n      * @throws JsonLdError\n      *             If there is an error parsing the contexts.\n      */\n-    private Context parse(Object localContext, List<String> remoteContexts,\n+    private Context parse(Object localContext, final List<String> remoteContexts,\n             boolean parsingARemoteContext) throws JsonLdError {\n-        if (remoteContexts == null) {\n-            remoteContexts = new ArrayList<String>();\n-        }\n         // 1. Initialize result to the result of cloning active context.\n         Context result = this.clone(); // TODO: clone?\n         // 2)\n@@ -183,17 +188,22 @@ private Context parse(Object localContext, List<String> remoteContexts,\n             }\n             // 3.2)\n             else if (context instanceof String) {\n-                String uri = (String) result.get(JsonLdConsts.BASE);\n+                String uri = null;\n+                // @base is ignored when processing remote contexts, https://github.com/jsonld-java/jsonld-java/issues/304\n+                if (!URL_PATTERN.matcher(context.toString()).matches()) {\n+                    uri = (String) result.get(JsonLdConsts.BASE);\n+                }\n                 uri = JsonLdUrl.resolve(uri, (String) context);\n                 // 3.2.2\n                 if (remoteContexts.contains(uri)) {\n                     throw new JsonLdError(Error.RECURSIVE_CONTEXT_INCLUSION, uri);\n                 }\n-                remoteContexts.add(uri);\n+                List<String> nextRemoteContexts = new ArrayList<>(remoteContexts);\n+                nextRemoteContexts.add(uri);\n \n                 // 3.2.3: Dereference context\n                 final RemoteDocument rd = this.options.getDocumentLoader().loadDocument(uri);\n-                final Object remoteContext = rd.document;\n+                final Object remoteContext = rd.getDocument();\n                 if (!(remoteContext instanceof Map) || !((Map<String, Object>) remoteContext)\n                         .containsKey(JsonLdConsts.CONTEXT)) {\n                     // If the dereferenced document has no top-level JSON object\n@@ -204,14 +214,14 @@ else if (context instanceof String) {\n                         .get(JsonLdConsts.CONTEXT);\n \n                 // 3.2.4\n-                result = result.parse(tempContext, remoteContexts, true);\n+                result = result.parse(tempContext, nextRemoteContexts, true);\n                 // 3.2.5\n                 continue;\n             } else if (!(context instanceof Map)) {\n                 // 3.3\n                 throw new JsonLdError(Error.INVALID_LOCAL_CONTEXT, context);\n             }\n-\n+            checkEmptyKey((Map<String, Object>) context);\n             // 3.4\n             if (!parsingARemoteContext\n                     && ((Map<String, Object>) context).containsKey(JsonLdConsts.BASE)) {\n@@ -282,6 +292,15 @@ else if (context instanceof String) {\n         return result;\n     }\n \n+    private void checkEmptyKey(final Map<String, Object> map) {\n+        if (map.containsKey(\"\")) {\n+            // the term MUST NOT be an empty string (\"\")\n+            // https://www.w3.org/TR/json-ld/#h3_terms\n+            throw new JsonLdError(Error.INVALID_TERM_DEFINITION,\n+                    String.format(\"empty key for value '%s'\", map.get(\"\")));\n+        }\n+    }\n+\n     public Context parse(Object localContext) throws JsonLdError {\n         return this.parse(localContext, new ArrayList<String>());\n     }\n@@ -291,9 +310,7 @@ public Context parse(Object localContext) throws JsonLdError {\n      *\n      * http://json-ld.org/spec/latest/json-ld-api/#create-term-definition\n      *\n-     * @param result\n      * @param context\n-     * @param key\n      * @param defined\n      * @throws JsonLdError\n      */\n@@ -308,7 +325,9 @@ private void createTermDefinition(Map<String, Object> context, String term,\n \n         defined.put(term, false);\n \n-        if (JsonLdUtils.isKeyword(term)) {\n+        if (JsonLdUtils.isKeyword(term)\n+                && !(options.getAllowContainerSetOnType() && JsonLdConsts.TYPE.equals(term)\n+                        && !(context.get(term)).toString().contains(JsonLdConsts.ID))) {\n             throw new JsonLdError(Error.KEYWORD_REDEFINITION, term);\n         }\n \n@@ -437,7 +456,7 @@ else if (term.indexOf(\":\") >= 0) {\n             // 15)\n         } else if (this.containsKey(JsonLdConsts.VOCAB)) {\n             definition.put(JsonLdConsts.ID, this.get(JsonLdConsts.VOCAB) + term);\n-        } else {\n+        } else if (!JsonLdConsts.TYPE.equals(term)) {\n             throw new JsonLdError(Error.INVALID_IRI_MAPPING,\n                     \"relative term definition without vocab mapping\");\n         }\n@@ -452,6 +471,9 @@ else if (term.indexOf(\":\") >= 0) {\n                         \"@container must be either @list, @set, @index, or @language\");\n             }\n             definition.put(JsonLdConsts.CONTAINER, container);\n+            if (JsonLdConsts.TYPE.equals(term)) {\n+                definition.put(JsonLdConsts.ID, \"type\");\n+            }\n         }\n \n         // 17)\n@@ -498,8 +520,7 @@ String expandIri(String value, boolean relative, boolean vocab, Map<String, Obje\n         }\n         // 3)\n         if (vocab && this.termDefinitions.containsKey(value)) {\n-            final Map<String, Object> td = (LinkedHashMap<String, Object>) this.termDefinitions\n-                    .get(value);\n+            final Map<String, Object> td = (Map<String, Object>) this.termDefinitions.get(value);\n             if (td != null) {\n                 return (String) td.get(JsonLdConsts.ID);\n             } else {\n@@ -523,7 +544,7 @@ String expandIri(String value, boolean relative, boolean vocab, Map<String, Obje\n             }\n             // 4.4)\n             if (this.termDefinitions.containsKey(prefix)) {\n-                return (String) ((LinkedHashMap<String, Object>) this.termDefinitions.get(prefix))\n+                return (String) ((Map<String, Object>) this.termDefinitions.get(prefix))\n                         .get(JsonLdConsts.ID) + suffix;\n             }\n             // 4.5)\n@@ -555,7 +576,7 @@ else if (relative) {\n      *            the IRI to compact.\n      * @param value\n      *            the value to check or null.\n-     * @param relativeTo\n+     * @param relativeToVocab\n      *            options for how to compact IRIs: vocab: true to split\n      *            after @vocab, false not to.\n      * @param reverse\n@@ -826,11 +847,10 @@ public static String _iriCompactionStep5point4(String iri, Object value, String\n      * \":\".\n      *\n      * @param onlyCommonPrefixes\n-     *            If <code>true</code>, the result will not include\n-     *            \"not so useful\" prefixes, such as \"term1\":\n-     *            \"http://example.com/term1\", e.g. all IRIs will end with \"/\" or\n-     *            \"#\". If <code>false</code>, all potential prefixes are\n-     *            returned.\n+     *            If <code>true</code>, the result will not include \"not so\n+     *            useful\" prefixes, such as \"term1\": \"http://example.com/term1\",\n+     *            e.g. all IRIs will end with \"/\" or \"#\". If <code>false</code>,\n+     *            all potential prefixes are returned.\n      *\n      * @return A map from prefix string to IRI string\n      */\n@@ -1044,13 +1064,16 @@ private String selectTerm(String iri, List<String> containers, String typeLangua\n      *\n      * @param property\n      *            The Property to get a container mapping for.\n-     * @return The container mapping\n+     * @return The container mapping if any, else null\n      */\n     public String getContainer(String property) {\n+        if (property == null) {\n+            return null;\n+        }\n         if (JsonLdConsts.GRAPH.equals(property)) {\n             return JsonLdConsts.SET;\n         }\n-        if (JsonLdUtils.isKeyword(property)) {\n+        if (!property.equals(JsonLdConsts.TYPE) && JsonLdUtils.isKeyword(property)) {\n             return property;\n         }\n         final Map<String, Object> td = (Map<String, Object>) termDefinitions.get(property);\n@@ -1069,15 +1092,15 @@ public Boolean isReverseProperty(String property) {\n         return reverse != null && (Boolean) reverse;\n     }\n \n-    private String getTypeMapping(String property) {\n+    public String getTypeMapping(String property) {\n         final Map<String, Object> td = (Map<String, Object>) termDefinitions.get(property);\n         if (td == null) {\n             return null;\n         }\n         return (String) td.get(JsonLdConsts.TYPE);\n     }\n \n-    private String getLanguageMapping(String property) {\n+    public String getLanguageMapping(String property) {\n         final Map<String, Object> td = (Map<String, Object>) termDefinitions.get(property);\n         if (td == null) {\n             return null;\n@@ -1128,6 +1151,7 @@ else if (this.get(JsonLdConsts.LANGUAGE) != null) {\n         return rval;\n     }\n \n+    @Deprecated\n     public Map<String, Object> serialize() {\n         final Map<String, Object> ctx = newMap();\n         if (this.get(JsonLdConsts.BASE) != null\n@@ -1180,4 +1204,4 @@ else if (this.get(JsonLdConsts.LANGUAGE) != null) {\n         return rval;\n     }\n \n-}\n\\ No newline at end of file\n+}"
  },
  {
    "sha": "55faaac77fef063c78cd8908641de0e50f6942ec",
    "filename": "core/src/main/java/com/github/jsonldjava/core/DocumentLoader.java",
    "status": "modified",
    "additions": 52,
    "deletions": 24,
    "changes": 76,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/DocumentLoader.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/DocumentLoader.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/DocumentLoader.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -8,16 +8,32 @@\n \n import com.github.jsonldjava.utils.JsonUtils;\n \n+/**\n+ * Resolves URLs to {@link RemoteDocument}s. Subclass this class to change the\n+ * behaviour of loadDocument to suit your purposes.\n+ */\n public class DocumentLoader {\n \n-    private Map<String, Object> m_injectedDocs = new HashMap<>();\n+    private final Map<String, Object> m_injectedDocs = new HashMap<>();\n \n     /**\n      * Identifies a system property that can be set to \"true\" in order to\n      * disallow remote context loading.\n      */\n     public static final String DISALLOW_REMOTE_CONTEXT_LOADING = \"com.github.jsonldjava.disallowRemoteContextLoading\";\n \n+    /**\n+     * Avoid resolving a document by instead using the given serialised\n+     * representation.\n+     *\n+     * @param url\n+     *            The URL this document represents.\n+     * @param doc\n+     *            The serialised document as a String\n+     * @return This object for fluent addition of other injected documents.\n+     * @throws JsonLdError\n+     *             If loading of the document failed for any reason.\n+     */\n     public DocumentLoader addInjectedDoc(String url, String doc) throws JsonLdError {\n         try {\n             m_injectedDocs.put(url, JsonUtils.fromString(doc));\n@@ -27,42 +43,47 @@ public DocumentLoader addInjectedDoc(String url, String doc) throws JsonLdError\n         }\n     }\n \n+    /**\n+     * Loads the URL if possible, returning it as a RemoteDocument.\n+     *\n+     * @param url\n+     *            The URL to load\n+     * @return The resolved URL as a RemoteDocument\n+     * @throws JsonLdError\n+     *             If there are errors loading or remote context loading has\n+     *             been disallowed.\n+     */\n     public RemoteDocument loadDocument(String url) throws JsonLdError {\n-        final RemoteDocument doc = new RemoteDocument(url, null);\n-\n         if (m_injectedDocs.containsKey(url)) {\n             try {\n-                doc.setDocument(m_injectedDocs.get(url));\n+                return new RemoteDocument(url, m_injectedDocs.get(url));\n             } catch (final Exception e) {\n                 throw new JsonLdError(JsonLdError.Error.LOADING_INJECTED_CONTEXT_FAILED, url, e);\n             }\n-            return doc;\n-        }\n-\n-        final String disallowRemote = System\n-                .getProperty(DocumentLoader.DISALLOW_REMOTE_CONTEXT_LOADING);\n-        if (\"true\".equalsIgnoreCase(disallowRemote)) {\n-            throw new JsonLdError(JsonLdError.Error.LOADING_REMOTE_CONTEXT_FAILED, \"Remote context loading has been disallowed (url was \" + url + \")\");\n-        }\n+        } else {\n+            final String disallowRemote = System\n+                    .getProperty(DocumentLoader.DISALLOW_REMOTE_CONTEXT_LOADING);\n+            if (\"true\".equalsIgnoreCase(disallowRemote)) {\n+                throw new JsonLdError(JsonLdError.Error.LOADING_REMOTE_CONTEXT_FAILED,\n+                        \"Remote context loading has been disallowed (url was \" + url + \")\");\n+            }\n \n-        try {\n-            doc.setDocument(JsonUtils.fromURL(new URL(url), getHttpClient()));\n-        } catch (final Exception e) {\n-            throw new JsonLdError(JsonLdError.Error.LOADING_REMOTE_CONTEXT_FAILED, url, e);\n+            try {\n+                return new RemoteDocument(url, JsonUtils.fromURL(new URL(url), getHttpClient()));\n+            } catch (final Exception e) {\n+                throw new JsonLdError(JsonLdError.Error.LOADING_REMOTE_CONTEXT_FAILED, url, e);\n+            }\n         }\n-        return doc;\n     }\n \n+    private volatile CloseableHttpClient httpClient;\n+\n     /**\n-     * An HTTP Accept header that prefers JSONLD.\n+     * Get the {@link CloseableHttpClient} which will be used by this\n+     * DocumentLoader to resolve HTTP and HTTPS resources.\n      *\n-     * @deprecated Use {@link JsonUtils#ACCEPT_HEADER} instead.\n+     * @return The {@link CloseableHttpClient} which this DocumentLoader uses.\n      */\n-    @Deprecated\n-    public static final String ACCEPT_HEADER = JsonUtils.ACCEPT_HEADER;\n-\n-    private volatile CloseableHttpClient httpClient;\n-\n     public CloseableHttpClient getHttpClient() {\n         CloseableHttpClient result = httpClient;\n         if (result == null) {\n@@ -76,6 +97,13 @@ public CloseableHttpClient getHttpClient() {\n         return result;\n     }\n \n+    /**\n+     * Call this method to override the default CloseableHttpClient provided by\n+     * JsonUtils.getDefaultHttpClient.\n+     *\n+     * @param nextHttpClient\n+     *            The {@link CloseableHttpClient} to replace the default with.\n+     */\n     public void setHttpClient(CloseableHttpClient nextHttpClient) {\n         httpClient = nextHttpClient;\n     }"
  },
  {
    "sha": "2195d09a328e033ab25b71c9331003fab04f9c24",
    "filename": "core/src/main/java/com/github/jsonldjava/core/JsonLdApi.java",
    "status": "modified",
    "additions": 156,
    "deletions": 121,
    "changes": 277,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/JsonLdApi.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/JsonLdApi.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/JsonLdApi.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -17,11 +17,8 @@\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n-import java.util.Map.Entry;\n import java.util.Set;\n import java.util.TreeMap;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -205,10 +202,12 @@ public Object compact(Context activeCtx, String activeProperty, Object element,\n             Collections.sort(keys);\n             for (final String expandedProperty : keys) {\n                 final Object expandedValue = elem.get(expandedProperty);\n-\n                 // 7.1)\n                 if (JsonLdConsts.ID.equals(expandedProperty)\n                         || JsonLdConsts.TYPE.equals(expandedProperty)) {\n+                    // TODO: Relabel these step numbers when spec changes\n+                    // 7.1.3)\n+                    final String alias = activeCtx.compactIri(expandedProperty, true);\n                     Object compactedValue;\n \n                     // 7.1.1)\n@@ -224,15 +223,16 @@ public Object compact(Context activeCtx, String activeProperty, Object element,\n                             types.add(activeCtx.compactIri(expandedType, true));\n                         }\n                         // 7.1.2.3)\n-                        if (types.size() == 1) {\n+                        if (types.size() == 1//\n+                                // see w3c/json-ld-syntax#74\n+                                && (!opts.getAllowContainerSetOnType()\n+                                        || !(activeCtx.getContainer(alias) != null && activeCtx\n+                                                .getContainer(alias).equals(JsonLdConsts.SET)))) {\n                             compactedValue = types.get(0);\n                         } else {\n                             compactedValue = types;\n                         }\n                     }\n-\n-                    // 7.1.3)\n-                    final String alias = activeCtx.compactIri(expandedProperty, true);\n                     // 7.1.4)\n                     result.put(alias, compactedValue);\n                     continue;\n@@ -508,7 +508,7 @@ public Object compact(Context activeCtx, String activeProperty, Object element)\n      */\n     public Object expand(Context activeCtx, String activeProperty, Object element)\n             throws JsonLdError {\n-        boolean frameExpansion = this.opts.getProcessingMode().equals(JsonLdOptions.JSON_LD_1_1_FRAME);\n+        final boolean frameExpansion = this.opts.getFrameExpansion();\n         // 1)\n         if (element == null) {\n             return null;\n@@ -585,8 +585,7 @@ else if (element instanceof Map) {\n                         if (value instanceof String) {\n                             expandedValue = activeCtx.expandIri((String) value, true, false, null,\n                                     null);\n-                        }\n-                        else if (frameExpansion) {\n+                        } else if (frameExpansion) {\n                             if (value instanceof Map) {\n                                 if (((Map<String, Object>) value).size() != 0) {\n                                     throw new JsonLdError(Error.INVALID_ID_VALUE,\n@@ -600,16 +599,14 @@ else if (frameExpansion) {\n                                         throw new JsonLdError(Error.INVALID_ID_VALUE,\n                                                 \"@id value must be a string, an array of strings or an empty dictionary\");\n                                     }\n-                                    ((List<String>) expandedValue).add(\n-                                            activeCtx.expandIri((String) v, true, true, null, null));\n+                                    ((List<String>) expandedValue).add(activeCtx\n+                                            .expandIri((String) v, true, true, null, null));\n                                 }\n-                            }\n-                            else {\n+                            } else {\n                                 throw new JsonLdError(Error.INVALID_ID_VALUE,\n                                         \"value of @id must be a string, an array of strings or an empty dictionary\");\n                             }\n-                        }\n-                        else {\n+                        } else {\n                             throw new JsonLdError(Error.INVALID_ID_VALUE,\n                                     \"value of @id must be a string\");\n                         }\n@@ -632,7 +629,7 @@ else if (JsonLdConsts.TYPE.equals(expandedProperty)) {\n                         }\n                         // TODO: SPEC: no mention of empty map check\n                         else if (frameExpansion && value instanceof Map) {\n-                            if (((Map<String, Object>) value).size() != 0) {\n+                            if (!((Map<String, Object>) value).isEmpty()) {\n                                 throw new JsonLdError(Error.INVALID_TYPE_VALUE,\n                                         \"@type value must be a an empty object for framing\");\n                             }\n@@ -924,7 +921,7 @@ else if (JsonLdConsts.INDEX.equals(activeCtx.getContainer(key))\n                 // 8.1)\n                 // TODO: is this method faster than just using containsKey for\n                 // each?\n-                final Set<String> keySet = new HashSet(result.keySet());\n+                final Set<String> keySet = new HashSet<>(result.keySet());\n                 keySet.remove(JsonLdConsts.VALUE);\n                 keySet.remove(JsonLdConsts.INDEX);\n                 final boolean langremoved = keySet.remove(JsonLdConsts.LANGUAGE);\n@@ -1319,7 +1316,7 @@ public FramingContext(JsonLdOptions opts) {\n     private class EmbedNode {\n         public Object parent = null;\n         public String property = null;\n-        \n+\n         public EmbedNode(Object parent, String property) {\n             this.parent = parent;\n             this.property = property;\n@@ -1353,7 +1350,8 @@ public EmbedNode(Object parent, String property) {\n         // NOTE: frame validation is done by the function not allowing anything\n         // other than list to me passed\n         // 1.\n-        // If frame is an array, set frame to the first member of the array, which MUST be a valid frame.\n+        // If frame is an array, set frame to the first member of the array,\n+        // which MUST be a valid frame.\n         frame(state, this.nodeMap,\n                 (frame != null && frame.size() > 0 ? (Map<String, Object>) frame.get(0) : newMap()),\n                 framed, null);\n@@ -1364,7 +1362,7 @@ public EmbedNode(Object parent, String property) {\n     private boolean createsCircularReference(String id, FramingContext state) {\n         return state.subjectStack.contains(id);\n     }\n-    \n+\n     /**\n      * Frames subjects according to the given frame.\n      *\n@@ -1381,15 +1379,17 @@ private boolean createsCircularReference(String id, FramingContext state) {\n      */\n     private void frame(FramingContext state, Map<String, Object> nodes, Map<String, Object> frame,\n             Object parent, String property) throws JsonLdError {\n-        \n+\n         // https://json-ld.org/spec/latest/json-ld-framing/#framing-algorithm\n \n         // 2.\n-        // Initialize flags embed, explicit, and requireAll from object embed flag, \n-        // explicit inclusion flag, and require all flag in state overriding from\n+        // Initialize flags embed, explicit, and requireAll from object embed\n+        // flag,\n+        // explicit inclusion flag, and require all flag in state overriding\n+        // from\n         // any property values for @embed, @explicit, and @requireAll in frame.\n         // TODO: handle @requireAll\n-        Embed embed = getFrameEmbed(frame, state.embed);\n+        final Embed embed = getFrameEmbed(frame, state.embed);\n         final Boolean explicitOn = getFrameFlag(frame, JsonLdConsts.EXPLICIT, state.explicit);\n         final Boolean requireAll = getFrameFlag(frame, JsonLdConsts.REQUIRE_ALL, state.requireAll);\n         final Map<String, Object> flags = newMap();\n@@ -1399,86 +1399,98 @@ private void frame(FramingContext state, Map<String, Object> nodes, Map<String,\n \n         // 3.\n         // Create a list of matched subjects by filtering subjects against frame\n-        // using the Frame Matching algorithm with state, subjects, frame, and requireAll.\n+        // using the Frame Matching algorithm with state, subjects, frame, and\n+        // requireAll.\n         final Map<String, Object> matches = filterNodes(state, nodes, frame, requireAll);\n         final List<String> ids = new ArrayList<String>(matches.keySet());\n         Collections.sort(ids);\n-        \n+\n         // 4.\n-        // Set link the the value of link in state associated with graph name in state,\n+        // Set link the the value of link in state associated with graph name in\n+        // state,\n         // creating a new empty dictionary, if necessary.\n-        Map<String,EmbedNode> link = state.uniqueEmbeds;\n-        \n+        final Map<String, EmbedNode> link = state.uniqueEmbeds;\n+\n         // 5.\n-        // For each id and associated node object node from the set of matched subjects, ordered by id: \n+        // For each id and associated node object node from the set of matched\n+        // subjects, ordered by id:\n         for (final String id : ids) {\n             final Map<String, Object> subject = (Map<String, Object>) matches.get(id);\n \n             // 5.1\n-            // Initialize output to a new dictionary with @id and id and add output to link associated with id.\n+            // Initialize output to a new dictionary with @id and id and add\n+            // output to link associated with id.\n             final Map<String, Object> output = newMap();\n             output.put(JsonLdConsts.ID, id);\n \n             // 5.2\n-            // If embed is @link and id is in link, node already exists in results.\n-            // Add the associated node object from link to parent and do not perform\n+            // If embed is @link and id is in link, node already exists in\n+            // results.\n+            // Add the associated node object from link to parent and do not\n+            // perform\n             // additional processing for this node.\n             if (embed == Embed.LINK && state.uniqueEmbeds.containsKey(id)) {\n                 addFrameOutput(state, parent, property, state.uniqueEmbeds.get(id));\n                 continue;\n             }\n-            \n+\n             // Occurs only at top level, compartmentalize each top-level match\n-            if(property == null) {\n+            if (property == null) {\n                 state.uniqueEmbeds = new HashMap<>();\n             }\n-            \n+\n             // 5.3\n-            // Otherwise, if embed is @never or if a circular reference would be created by an embed,\n-            // add output to parent and do not perform additional processing for this node.\n+            // Otherwise, if embed is @never or if a circular reference would be\n+            // created by an embed,\n+            // add output to parent and do not perform additional processing for\n+            // this node.\n             if (embed == Embed.NEVER || createsCircularReference(id, state)) {\n                 addFrameOutput(state, parent, property, output);\n                 continue;\n             }\n \n             // 5.4\n-            // Otherwise, if embed is @last, remove any existing embedded node from parent associated\n+            // Otherwise, if embed is @last, remove any existing embedded node\n+            // from parent associated\n             // with graph name in state. Requires sorting of subjects.\n             if (embed == Embed.LAST) {\n                 if (state.uniqueEmbeds.containsKey(id)) {\n                     removeEmbed(state, id);\n                 }\n                 state.uniqueEmbeds.put(id, new EmbedNode(parent, property));\n             }\n-            \n+\n             state.subjectStack.push(id);\n \n             // 5.5 If embed is @last or @always\n-            \n+\n             // Skip 5.5.1\n-            \n-            // 5.5.2 For each property and objects in node, ordered by property: \n+\n+            // 5.5.2 For each property and objects in node, ordered by property:\n             final Map<String, Object> element = (Map<String, Object>) matches.get(id);\n             List<String> props = new ArrayList<String>(element.keySet());\n             Collections.sort(props);\n             for (final String prop : props) {\n \n-                // 5.5.2.1 If property is a keyword, add property and objects to output.\n+                // 5.5.2.1 If property is a keyword, add property and objects to\n+                // output.\n                 if (isKeyword(prop)) {\n                     output.put(prop, JsonLdUtils.clone(element.get(prop)));\n                     continue;\n                 }\n \n-                // 5.5.2.2 Otherwise, if property is not in frame, and explicit is true, processors\n-                // MUST NOT add any values for property to output, and the following steps are skipped.\n+                // 5.5.2.2 Otherwise, if property is not in frame, and explicit\n+                // is true, processors\n+                // MUST NOT add any values for property to output, and the\n+                // following steps are skipped.\n                 if (explicitOn && !frame.containsKey(prop)) {\n                     continue;\n                 }\n \n                 // add objects\n                 final List<Object> value = (List<Object>) element.get(prop);\n \n-                // 5.5.2.3 For each item in objects: \n+                // 5.5.2.3 For each item in objects:\n                 for (final Object item : value) {\n                     if ((item instanceof Map)\n                             && ((Map<String, Object>) item).containsKey(JsonLdConsts.LIST)) {\n@@ -1500,7 +1512,8 @@ private void frame(FramingContext state, Map<String, Object> nodes, Map<String,\n                                 tmp.put(itemid, this.nodeMap.get(itemid));\n                                 Map<String, Object> subframe;\n                                 if (frame.containsKey(prop)) {\n-                                    subframe = (Map<String, Object>) ((List<Object>) frame.get(prop)).get(0);\n+                                    subframe = (Map<String, Object>) ((List<Object>) frame\n+                                            .get(prop)).get(0);\n                                 } else {\n                                     subframe = flags;\n                                 }\n@@ -1523,7 +1536,8 @@ else if (JsonLdUtils.isNodeReference(item)) {\n                         tmp.put(itemid, this.nodeMap.get(itemid));\n                         Map<String, Object> subframe;\n                         if (frame.containsKey(prop)) {\n-                            subframe = (Map<String, Object>) ((List<Object>) frame.get(prop)).get(0);\n+                            subframe = (Map<String, Object>) ((List<Object>) frame.get(prop))\n+                                    .get(0);\n                         } else {\n                             subframe = flags;\n                         }\n@@ -1546,13 +1560,13 @@ else if (JsonLdUtils.isNodeReference(item)) {\n                 }\n \n                 final List<Object> pf = (List<Object>) frame.get(prop);\n-                Map<String, Object> propertyFrame = pf.size() > 0\n-                        ? (Map<String, Object>) pf.get(0) : null;\n+                Map<String, Object> propertyFrame = pf.size() > 0 ? (Map<String, Object>) pf.get(0)\n+                        : null;\n                 if (propertyFrame == null) {\n                     propertyFrame = newMap();\n                 }\n-                final boolean omitDefaultOn = getFrameFlag(propertyFrame,\n-                        JsonLdConsts.OMIT_DEFAULT, state.omitDefault);\n+                final boolean omitDefaultOn = getFrameFlag(propertyFrame, JsonLdConsts.OMIT_DEFAULT,\n+                        state.omitDefault);\n                 if (!omitDefaultOn && !output.containsKey(prop)) {\n                     Object def = \"@null\";\n                     if (propertyFrame.containsKey(JsonLdConsts.DEFAULT)) {\n@@ -1572,7 +1586,7 @@ else if (JsonLdUtils.isNodeReference(item)) {\n \n             // add output to parent\n             addFrameOutput(state, parent, property, output);\n-            \n+\n             state.subjectStack.pop();\n         }\n     }\n@@ -1591,17 +1605,18 @@ private Object getFrameValue(Map<String, Object> frame, String name) {\n     }\n \n     private Boolean getFrameFlag(Map<String, Object> frame, String name, boolean thedefault) {\n-        Object value = getFrameValue(frame, name);\n+        final Object value = getFrameValue(frame, name);\n         if (value instanceof Boolean) {\n             return (Boolean) value;\n         }\n         return thedefault;\n     }\n \n     private Embed getFrameEmbed(Map<String, Object> frame, Embed thedefault) throws JsonLdError {\n-        Object value = getFrameValue(frame, JsonLdConsts.EMBED);\n-        if (value == null)\n+        final Object value = getFrameValue(frame, JsonLdConsts.EMBED);\n+        if (value == null) {\n             return thedefault;\n+        }\n         if (value instanceof Boolean) {\n             return (Boolean) value ? Embed.LAST : Embed.NEVER;\n         }\n@@ -1700,20 +1715,26 @@ private boolean filterNode(FramingContext state, Map<String, Object> node,\n         // blank node in the @id property in frame.\n         if (frameIds != null) {\n             if (frameIds instanceof String) {\n-                Object nodeId = node.get(JsonLdConsts.ID);\n-                if (nodeId == null)\n+                final Object nodeId = node.get(JsonLdConsts.ID);\n+                if (nodeId == null) {\n                     return false;\n+                }\n                 if (JsonLdUtils.deepCompare(nodeId, frameIds)) {\n                     return true;\n                 }\n-            }\n-            else if (!(frameIds instanceof List)) {\n+            } else if (frameIds instanceof LinkedHashMap\n+                    && ((LinkedHashMap) frameIds).size() == 0) {\n+                if (node.containsKey(JsonLdConsts.ID)) {\n+                    return true;\n+                }\n+                return false;\n+            } else if (!(frameIds instanceof List)) {\n                 throw new JsonLdError(Error.SYNTAX_ERROR, \"frame @id must be an array\");\n-            }\n-            else {\n-                Object nodeId = node.get(JsonLdConsts.ID);\n-                if (nodeId == null)\n+            } else {\n+                final Object nodeId = node.get(JsonLdConsts.ID);\n+                if (nodeId == null) {\n                     return false;\n+                }\n                 for (final Object j : (List<Object>) frameIds) {\n                     if (JsonLdUtils.deepCompare(nodeId, j)) {\n                         return true;\n@@ -1726,9 +1747,10 @@ else if (!(frameIds instanceof List)) {\n         // 3. If requireAll is true, node matches if all non-keyword properties\n         // (property) in frame match any of the following conditions. Or, if\n         // requireAll is false, if any of the non-keyword properties (property)\n-        // in frame match any of the following conditions. For the values of each\n-        // property from frame in node: \n-        // 3.1 If property is @type: \n+        // in frame match any of the following conditions. For the values of\n+        // each\n+        // property from frame in node:\n+        // 3.1 If property is @type:\n         if (types != null) {\n             if (!(types instanceof List)) {\n                 throw new JsonLdError(Error.SYNTAX_ERROR, \"frame @type must be an array\");\n@@ -1739,7 +1761,8 @@ else if (!(frameIds instanceof List)) {\n             } else if (!(nodeTypes instanceof List)) {\n                 throw new JsonLdError(Error.SYNTAX_ERROR, \"node @type must be an array\");\n             }\n-            // 3.1.1 Property matches if the @type property in frame includes any IRI in values.\n+            // 3.1.1 Property matches if the @type property in frame includes\n+            // any IRI in values.\n             for (final Object i : (List<Object>) nodeTypes) {\n                 for (final Object j : (List<Object>) types) {\n                     if (JsonLdUtils.deepCompare(i, j)) {\n@@ -1748,7 +1771,8 @@ else if (!(frameIds instanceof List)) {\n                 }\n             }\n             // TODO: 3.1.2\n-            // 3.1.3 Otherwise, property matches if values is empty and the @type property in frame is match none.\n+            // 3.1.3 Otherwise, property matches if values is empty and the\n+            // @type property in frame is match none.\n             if (((List<Object>) types).size() == 1 && ((List<Object>) types).get(0) instanceof Map\n                     && ((Map<String, Object>) ((List<Object>) types).get(0)).size() == 0) {\n                 return !((List<Object>) nodeTypes).isEmpty();\n@@ -1837,6 +1861,16 @@ public UsagesNode(NodeMapNode node, String property, Map<String, Object> value)\n         public Map<String, Object> value = null;\n     }\n \n+    private class Node {\n+        private final String predicate;\n+        private final RDFDataset.Node object;\n+\n+        public Node(String predicate, RDFDataset.Node object) {\n+            this.predicate = predicate;\n+            this.object = object;\n+        }\n+    }\n+\n     private class NodeMapNode extends LinkedHashMap<String, Object> {\n         public List<UsagesNode> usages = new ArrayList(4);\n \n@@ -1914,11 +1948,7 @@ public boolean isWellFormedListNode() {\n      * @return A list of JSON-LD objects found in the given dataset.\n      * @throws JsonLdError\n      *             If there was an error during conversion from RDF to JSON-LD.\n-     * @deprecated Experimental method, only use if you are sure you need to use\n-     *             this method. Most users will need to use\n-     *             {@link #fromRDF(RDFDataset)}.\n      */\n-    @Deprecated\n     public List<Object> fromRDF(final RDFDataset dataset, boolean noDuplicatesInDataset)\n             throws JsonLdError {\n         // 1)\n@@ -1934,62 +1964,65 @@ public boolean isWellFormedListNode() {\n             final List<RDFDataset.Quad> graph = dataset.getQuads(name);\n \n             // 3.2+3.4)\n-            Map<String, NodeMapNode> nodeMap;\n-            if (!graphMap.containsKey(name)) {\n-                nodeMap = new LinkedHashMap<String, NodeMapNode>();\n-                graphMap.put(name, nodeMap);\n-            } else {\n-                nodeMap = graphMap.get(name);\n-            }\n+            final Map<String, NodeMapNode> nodeMap = graphMap.computeIfAbsent(name,\n+                    k -> new LinkedHashMap<String, NodeMapNode>());\n \n             // 3.3)\n-            if (!JsonLdConsts.DEFAULT.equals(name) && !Obj.contains(defaultGraph, name)) {\n-                defaultGraph.put(name, new NodeMapNode(name));\n+            if (!JsonLdConsts.DEFAULT.equals(name)) {\n+                // Existing entries in the default graph are not overwritten\n+                defaultGraph.computeIfAbsent(name, k -> new NodeMapNode(k));\n             }\n \n             // 3.5)\n+            final Map<String, List<Node>> nodes = new HashMap<>();\n+\n             for (final RDFDataset.Quad triple : graph) {\n                 final String subject = triple.getSubject().getValue();\n                 final String predicate = triple.getPredicate().getValue();\n                 final RDFDataset.Node object = triple.getObject();\n+                nodes.computeIfAbsent(subject, k -> new ArrayList<>())\n+                        .add(new Node(predicate, object));\n+            }\n+            for (final Map.Entry<String, List<Node>> nodeEntry : nodes.entrySet()) {\n+                final String subject = nodeEntry.getKey();\n \n-                // 3.5.1+3.5.2)\n-                NodeMapNode node;\n-                if (!nodeMap.containsKey(subject)) {\n-                    node = new NodeMapNode(subject);\n-                    nodeMap.put(subject, node);\n-                } else {\n-                    node = nodeMap.get(subject);\n-                }\n+                for (final Node n : nodeEntry.getValue()) {\n+                    final String predicate = n.predicate;\n+                    final RDFDataset.Node object = n.object;\n \n-                // 3.5.3)\n-                if ((object.isIRI() || object.isBlankNode())\n-                        && !nodeMap.containsKey(object.getValue())) {\n-                    nodeMap.put(object.getValue(), new NodeMapNode(object.getValue()));\n-                }\n+                    // 3.5.1+3.5.2)\n+                    final NodeMapNode node = nodeMap.computeIfAbsent(subject,\n+                            k -> new NodeMapNode(k));\n \n-                // 3.5.4)\n-                if (RDF_TYPE.equals(predicate) && (object.isIRI() || object.isBlankNode())\n-                        && !opts.getUseRdfType()) {\n-                    JsonLdUtils.mergeValue(node, JsonLdConsts.TYPE, object.getValue());\n-                    continue;\n-                }\n+                    // 3.5.3)\n+                    if ((object.isIRI() || object.isBlankNode())) {\n+                        nodeMap.computeIfAbsent(object.getValue(), k -> new NodeMapNode(k));\n+                    }\n \n-                // 3.5.5)\n-                final Map<String, Object> value = object.toObject(opts.getUseNativeTypes());\n+                    // 3.5.4)\n+                    if (RDF_TYPE.equals(predicate) && (object.isIRI() || object.isBlankNode())\n+                            && !opts.getUseRdfType() &&\n+                            (!nodes.containsKey(object.getValue()) || subject.equals(object.getValue()))) {\n+                        JsonLdUtils.mergeValue(node, JsonLdConsts.TYPE, object.getValue());\n+                        continue;\n+                    }\n \n-                // 3.5.6+7)\n-                if (noDuplicatesInDataset) {\n-                    JsonLdUtils.laxMergeValue(node, predicate, value);\n-                } else {\n-                    JsonLdUtils.mergeValue(node, predicate, value);\n-                }\n+                    // 3.5.5)\n+                    final Map<String, Object> value = object.toObject(opts.getUseNativeTypes());\n+\n+                    // 3.5.6+7)\n+                    if (noDuplicatesInDataset) {\n+                        JsonLdUtils.laxMergeValue(node, predicate, value);\n+                    } else {\n+                        JsonLdUtils.mergeValue(node, predicate, value);\n+                    }\n \n-                // 3.5.8)\n-                if (object.isBlankNode() || object.isIRI()) {\n-                    // 3.5.8.1-3)\n-                    nodeMap.get(object.getValue()).usages\n-                            .add(new UsagesNode(node, predicate, value));\n+                    // 3.5.8)\n+                    if (object.isBlankNode() || object.isIRI()) {\n+                        // 3.5.8.1-3)\n+                        nodeMap.get(object.getValue()).usages\n+                                .add(new UsagesNode(node, predicate, value));\n+                    }\n                 }\n             }\n         }\n@@ -2069,16 +2102,18 @@ public boolean isWellFormedListNode() {\n             // 6.1)\n             if (graphMap.containsKey(subject)) {\n                 // 6.1.1)\n-                node.put(JsonLdConsts.GRAPH, new ArrayList<Object>(4));\n+                final List<Object> nextGraph = new ArrayList<Object>(4);\n+                node.put(JsonLdConsts.GRAPH, nextGraph);\n                 // 6.1.2)\n-                final List<String> keys = new ArrayList<String>(graphMap.get(subject).keySet());\n+                final Map<String, NodeMapNode> nextSubjectMap = graphMap.get(subject);\n+                final List<String> keys = new ArrayList<String>(nextSubjectMap.keySet());\n                 Collections.sort(keys);\n                 for (final String s : keys) {\n-                    final NodeMapNode n = graphMap.get(subject).get(s);\n+                    final NodeMapNode n = nextSubjectMap.get(s);\n                     if (n.size() == 1 && n.containsKey(JsonLdConsts.ID)) {\n                         continue;\n                     }\n-                    ((List<Object>) node.get(JsonLdConsts.GRAPH)).add(n.serialize());\n+                    nextGraph.add(n.serialize());\n                 }\n             }\n             // 6.2)"
  },
  {
    "sha": "9de5b76b6db52b37d67ade2b0867a30bfbc39c81",
    "filename": "core/src/main/java/com/github/jsonldjava/core/JsonLdConsts.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/JsonLdConsts.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/JsonLdConsts.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/JsonLdConsts.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -59,5 +59,7 @@\n     public static final String BASE = \"@base\";\n     public static final String REQUIRE_ALL = \"@requireAll\";\n \n-    public enum Embed {\tALWAYS,\tNEVER, LAST, LINK; }\n+    public enum Embed {\n+        ALWAYS, NEVER, LAST, LINK;\n+    }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "21ab577209328e75b490367edf485e5e4c28d584",
    "filename": "core/src/main/java/com/github/jsonldjava/core/JsonLdError.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/JsonLdError.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/JsonLdError.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/JsonLdError.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -1,6 +1,6 @@\n package com.github.jsonldjava.core;\n \n-public class JsonLdError extends Exception {\n+public class JsonLdError extends RuntimeException {\n \n     private static final long serialVersionUID = -8685402790466459014L;\n     private final Error type;"
  },
  {
    "sha": "ff0038eeec976ec80a280c451d6fa51c69285995",
    "filename": "core/src/main/java/com/github/jsonldjava/core/JsonLdOptions.java",
    "status": "modified",
    "additions": 303,
    "deletions": 220,
    "changes": 523,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/JsonLdOptions.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/JsonLdOptions.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/JsonLdOptions.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -1,220 +1,303 @@\n-package com.github.jsonldjava.core;\r\n-\r\n-import com.github.jsonldjava.core.JsonLdConsts.Embed;\r\n-\r\n-/**\r\n- * The JsonLdOptions type as specified in the\r\n- * <a href=\"http://www.w3.org/TR/json-ld-api/#the-jsonldoptions-type\">JSON-LD-\r\n- * API specification</a>.\r\n- *\r\n- * @author tristan\r\n- *\r\n- */\r\n-public class JsonLdOptions {\r\n-\r\n-    public static final String JSON_LD_1_0 = \"json-ld-1.0\";\r\n-\r\n-    public static final String JSON_LD_1_1 = \"json-ld-1.1\";\r\n-    \r\n-    public static final String JSON_LD_1_1_FRAME = \"json-ld-1.1-expand-frame\";\r\n-\r\n-    public static final boolean DEFAULT_COMPACT_ARRAYS = true;\r\n-\r\n-\t/**\r\n-     * Constructs an instance of JsonLdOptions using an empty base.\r\n-     */\r\n-    public JsonLdOptions() {\r\n-        this(\"\");\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructs an instance of JsonLdOptions using the given base.\r\n-     *\r\n-     * @param base\r\n-     *            The base IRI for the document.\r\n-     */\r\n-    public JsonLdOptions(String base) {\r\n-        this.setBase(base);\r\n-    }\r\n-\r\n-    // Base options : http://www.w3.org/TR/json-ld-api/#idl-def-JsonLdOptions\r\n-\r\n-    /**\r\n-     * http://www.w3.org/TR/json-ld-api/#widl-JsonLdOptions-base\r\n-     */\r\n-    private String base = null;\r\n-\r\n-    /**\r\n-     * http://www.w3.org/TR/json-ld-api/#widl-JsonLdOptions-compactArrays\r\n-     */\r\n-    private Boolean compactArrays = DEFAULT_COMPACT_ARRAYS;\r\n-    /**\r\n-     * http://www.w3.org/TR/json-ld-api/#widl-JsonLdOptions-expandContext\r\n-     */\r\n-    private Object expandContext = null;\r\n-    /**\r\n-     * http://www.w3.org/TR/json-ld-api/#widl-JsonLdOptions-processingMode\r\n-     */\r\n-    private String processingMode = JSON_LD_1_0;\r\n-    /**\r\n-     * http://www.w3.org/TR/json-ld-api/#widl-JsonLdOptions-documentLoader\r\n-     */\r\n-    private DocumentLoader documentLoader = new DocumentLoader();\r\n-\r\n-    // Frame options : http://json-ld.org/spec/latest/json-ld-framing/\r\n-\r\n-    private Embed embed = Embed.LAST;\r\n-    private Boolean explicit = null;\r\n-    private Boolean omitDefault = null;\r\n-    private Boolean pruneBlankNodeIdentifiers = true;\r\n-    private Boolean requireAll = false;\r\n-\r\n-    // RDF conversion options :\r\n-    // http://www.w3.org/TR/json-ld-api/#serialize-rdf-as-json-ld-algorithm\r\n-\r\n-    Boolean useRdfType = false;\r\n-    Boolean useNativeTypes = false;\r\n-    private boolean produceGeneralizedRdf = false;\r\n-\r\n-    public String getEmbed() {\r\n-        switch (this.embed) {\r\n-        case ALWAYS:\r\n-            return \"@always\";\r\n-        case NEVER:\r\n-            return \"@never\";\r\n-        case LINK:\r\n-            return \"@link\";\r\n-        default:\r\n-            return \"@last\";\r\n-        }\r\n-    }\r\n-\r\n-    Embed getEmbedVal() {\r\n-        return this.embed;\r\n-    }\r\n-\r\n-    public void setEmbed(Boolean embed) {\r\n-        this.embed = embed ? Embed.LAST : Embed.NEVER;\r\n-    }\r\n-\r\n-    public void setEmbed(String embed) throws JsonLdError {\r\n-        switch (embed) {\r\n-        case \"@always\":\r\n-            this.embed = Embed.ALWAYS;\r\n-        case \"@never\":\r\n-            this.embed = Embed.NEVER;\r\n-        case \"@last\":\r\n-            this.embed = Embed.LAST;\r\n-        case \"@link\":\r\n-            this.embed = Embed.LINK;\r\n-        default:\r\n-            throw new JsonLdError(JsonLdError.Error.INVALID_EMBED_VALUE);\r\n-        }\r\n-    }\r\n-\r\n-    public Boolean getExplicit() {\r\n-        return explicit;\r\n-    }\r\n-\r\n-    public void setExplicit(Boolean explicit) {\r\n-        this.explicit = explicit;\r\n-    }\r\n-\r\n-    public Boolean getOmitDefault() {\r\n-        return omitDefault;\r\n-    }\r\n-\r\n-    public void setOmitDefault(Boolean omitDefault) {\r\n-        this.omitDefault = omitDefault;\r\n-    }\r\n-\r\n-    public Boolean getPruneBlankNodeIdentifiers() {\r\n-        return pruneBlankNodeIdentifiers && getProcessingMode().equals(JSON_LD_1_1);\r\n-    }\r\n-\r\n-    public void setPruneBlankNodeIdentifiers(Boolean pruneBlankNodeIdentifiers) {\r\n-        if(pruneBlankNodeIdentifiers) {\r\n-            setProcessingMode(JSON_LD_1_1);\r\n-        }\r\n-        this.pruneBlankNodeIdentifiers = pruneBlankNodeIdentifiers;\r\n-    }\r\n-\r\n-    public Boolean getRequireAll() {\r\n-        return this.requireAll;\r\n-    }\r\n-\r\n-    public void setRequireAll(Boolean requireAll) {\r\n-        this.requireAll = requireAll;\r\n-    }\r\n-\r\n-    public Boolean getCompactArrays() {\r\n-        return compactArrays;\r\n-    }\r\n-\r\n-    public void setCompactArrays(Boolean compactArrays) {\r\n-        this.compactArrays = compactArrays;\r\n-    }\r\n-\r\n-    public Object getExpandContext() {\r\n-        return expandContext;\r\n-    }\r\n-\r\n-    public void setExpandContext(Object expandContext) {\r\n-        this.expandContext = expandContext;\r\n-    }\r\n-\r\n-    public String getProcessingMode() {\r\n-        return processingMode;\r\n-    }\r\n-\r\n-    public void setProcessingMode(String processingMode) {\r\n-        this.processingMode = processingMode;\r\n-    }\r\n-\r\n-    public String getBase() {\r\n-        return base;\r\n-    }\r\n-\r\n-    public void setBase(String base) {\r\n-        this.base = base;\r\n-    }\r\n-\r\n-    public Boolean getUseRdfType() {\r\n-        return useRdfType;\r\n-    }\r\n-\r\n-    public void setUseRdfType(Boolean useRdfType) {\r\n-        this.useRdfType = useRdfType;\r\n-    }\r\n-\r\n-    public Boolean getUseNativeTypes() {\r\n-        return useNativeTypes;\r\n-    }\r\n-\r\n-    public void setUseNativeTypes(Boolean useNativeTypes) {\r\n-        this.useNativeTypes = useNativeTypes;\r\n-    }\r\n-\r\n-    public boolean getProduceGeneralizedRdf() {\r\n-        return this.produceGeneralizedRdf;\r\n-    }\r\n-\r\n-    public void setProduceGeneralizedRdf(Boolean produceGeneralizedRdf) {\r\n-        this.produceGeneralizedRdf = produceGeneralizedRdf;\r\n-    }\r\n-\r\n-    public DocumentLoader getDocumentLoader() {\r\n-        return documentLoader;\r\n-    }\r\n-\r\n-    public void setDocumentLoader(DocumentLoader documentLoader) {\r\n-        this.documentLoader = documentLoader;\r\n-    }\r\n-\r\n-    // TODO: THE FOLLOWING ONLY EXIST SO I DON'T HAVE TO DELETE A LOT OF CODE,\r\n-    // REMOVE IT WHEN DONE\r\n-    public String format = null;\r\n-    public Boolean useNamespaces = false;\r\n-    public String outputForm = null;\r\n-\r\n-}\r\n+package com.github.jsonldjava.core;\n+\n+import com.github.jsonldjava.core.JsonLdConsts.Embed;\n+\n+/**\n+ * The JsonLdOptions type as specified in the\n+ * <a href=\"http://www.w3.org/TR/json-ld-api/#the-jsonldoptions-type\">JSON-LD-\n+ * API specification</a>.\n+ *\n+ * @author tristan\n+ *\n+ */\n+public class JsonLdOptions {\n+\n+    public static final String JSON_LD_1_0 = \"json-ld-1.0\";\n+\n+    public static final String JSON_LD_1_1 = \"json-ld-1.1\";\n+\n+    public static final boolean DEFAULT_COMPACT_ARRAYS = true;\n+\n+    /**\n+     * Constructs an instance of JsonLdOptions using an empty base.\n+     */\n+    public JsonLdOptions() {\n+        this(\"\");\n+    }\n+\n+    /**\n+     * Constructs an instance of JsonLdOptions using the given base.\n+     *\n+     * @param base\n+     *            The base IRI for the document.\n+     */\n+    public JsonLdOptions(String base) {\n+        this.setBase(base);\n+    }\n+\n+    /**\n+     * Creates a shallow copy of this JsonLdOptions object.\n+     *\n+     * It will share the same DocumentLoader unless that is overridden, and\n+     * other mutable objects, so it isn't immutable.\n+     *\n+     * @return A copy of this JsonLdOptions object.\n+     */\n+    public JsonLdOptions copy() {\n+        final JsonLdOptions copy = new JsonLdOptions(base);\n+\n+        copy.setCompactArrays(compactArrays);\n+        copy.setExpandContext(expandContext);\n+        copy.setProcessingMode(processingMode);\n+        copy.setDocumentLoader(documentLoader);\n+        copy.setEmbed(embed);\n+        copy.setExplicit(explicit);\n+        copy.setOmitDefault(omitDefault);\n+        copy.setOmitGraph(omitGraph);\n+        copy.setFrameExpansion(frameExpansion);\n+        copy.setPruneBlankNodeIdentifiers(pruneBlankNodeIdentifiers);\n+        copy.setRequireAll(requireAll);\n+        copy.setAllowContainerSetOnType(allowContainerSetOnType);\n+        copy.setUseRdfType(useRdfType);\n+        copy.setUseNativeTypes(useNativeTypes);\n+        copy.setProduceGeneralizedRdf(produceGeneralizedRdf);\n+        copy.format = format;\n+        copy.useNamespaces = useNamespaces;\n+        copy.outputForm = outputForm;\n+\n+        return copy;\n+    }\n+\n+    // Base options : http://www.w3.org/TR/json-ld-api/#idl-def-JsonLdOptions\n+\n+    /**\n+     * http://www.w3.org/TR/json-ld-api/#widl-JsonLdOptions-base\n+     */\n+    private String base = null;\n+\n+    /**\n+     * http://www.w3.org/TR/json-ld-api/#widl-JsonLdOptions-compactArrays\n+     */\n+    private Boolean compactArrays = DEFAULT_COMPACT_ARRAYS;\n+    /**\n+     * http://www.w3.org/TR/json-ld-api/#widl-JsonLdOptions-expandContext\n+     */\n+    private Object expandContext = null;\n+    /**\n+     * http://www.w3.org/TR/json-ld-api/#widl-JsonLdOptions-processingMode\n+     */\n+    private String processingMode = JSON_LD_1_0;\n+    /**\n+     * http://www.w3.org/TR/json-ld-api/#widl-JsonLdOptions-documentLoader\n+     */\n+    private DocumentLoader documentLoader = new DocumentLoader();\n+\n+    // Frame options : http://json-ld.org/spec/latest/json-ld-framing/\n+\n+    private Embed embed = Embed.LAST;\n+    private Boolean explicit = null;\n+    private Boolean omitDefault = null;\n+    private Boolean omitGraph = false;\n+    private Boolean frameExpansion = false;\n+    private Boolean pruneBlankNodeIdentifiers = false;\n+    private Boolean requireAll = false;\n+    private Boolean allowContainerSetOnType = false;\n+\n+    // RDF conversion options :\n+    // http://www.w3.org/TR/json-ld-api/#serialize-rdf-as-json-ld-algorithm\n+\n+    Boolean useRdfType = false;\n+    Boolean useNativeTypes = false;\n+    private boolean produceGeneralizedRdf = false;\n+\n+    public String getEmbed() {\n+        switch (this.embed) {\n+        case ALWAYS:\n+            return \"@always\";\n+        case NEVER:\n+            return \"@never\";\n+        case LINK:\n+            return \"@link\";\n+        default:\n+            return \"@last\";\n+        }\n+    }\n+\n+    Embed getEmbedVal() {\n+        return this.embed;\n+    }\n+\n+    public void setEmbed(Boolean embed) {\n+        this.embed = embed ? Embed.LAST : Embed.NEVER;\n+    }\n+\n+    public void setEmbed(String embed) throws JsonLdError {\n+        switch (embed) {\n+        case \"@always\":\n+            this.embed = Embed.ALWAYS;\n+            break;\n+        case \"@never\":\n+            this.embed = Embed.NEVER;\n+            break;\n+        case \"@last\":\n+            this.embed = Embed.LAST;\n+            break;\n+        case \"@link\":\n+            this.embed = Embed.LINK;\n+            break;\n+        default:\n+            throw new JsonLdError(JsonLdError.Error.INVALID_EMBED_VALUE);\n+        }\n+    }\n+\n+    public void setEmbed(Embed embed) throws JsonLdError {\n+        switch (embed) {\n+        case ALWAYS:\n+            this.embed = Embed.ALWAYS;\n+            break;\n+        case NEVER:\n+            this.embed = Embed.NEVER;\n+            break;\n+        case LAST:\n+            this.embed = Embed.LAST;\n+            break;\n+        case LINK:\n+            this.embed = Embed.LINK;\n+            break;\n+        default:\n+            throw new JsonLdError(JsonLdError.Error.INVALID_EMBED_VALUE);\n+        }\n+    }\n+\n+    public Boolean getExplicit() {\n+        return explicit;\n+    }\n+\n+    public void setExplicit(Boolean explicit) {\n+        this.explicit = explicit;\n+    }\n+\n+    public Boolean getOmitDefault() {\n+        return omitDefault;\n+    }\n+\n+    public void setOmitDefault(Boolean omitDefault) {\n+        this.omitDefault = omitDefault;\n+    }\n+\n+    public Boolean getFrameExpansion() {\n+        return frameExpansion;\n+    }\n+\n+    public void setFrameExpansion(Boolean frameExpansion) {\n+        this.frameExpansion = frameExpansion;\n+    }\n+\n+    public Boolean getOmitGraph() {\n+        return omitGraph;\n+    }\n+\n+    public void setOmitGraph(Boolean omitGraph) {\n+        this.omitGraph = omitGraph;\n+    }\n+\n+    public Boolean getPruneBlankNodeIdentifiers() {\n+        return pruneBlankNodeIdentifiers;\n+    }\n+\n+    public void setPruneBlankNodeIdentifiers(Boolean pruneBlankNodeIdentifiers) {\n+        this.pruneBlankNodeIdentifiers = pruneBlankNodeIdentifiers;\n+    }\n+\n+    public Boolean getRequireAll() {\n+        return this.requireAll;\n+    }\n+\n+    public void setRequireAll(Boolean requireAll) {\n+        this.requireAll = requireAll;\n+    }\n+\n+    public Boolean getAllowContainerSetOnType() {\n+        return allowContainerSetOnType;\n+    }\n+\n+    public void setAllowContainerSetOnType(Boolean allowContainerSetOnType) {\n+        this.allowContainerSetOnType = allowContainerSetOnType;\n+    }\n+\n+    public Boolean getCompactArrays() {\n+        return compactArrays;\n+    }\n+\n+    public void setCompactArrays(Boolean compactArrays) {\n+        this.compactArrays = compactArrays;\n+    }\n+\n+    public Object getExpandContext() {\n+        return expandContext;\n+    }\n+\n+    public void setExpandContext(Object expandContext) {\n+        this.expandContext = expandContext;\n+    }\n+\n+    public String getProcessingMode() {\n+        return processingMode;\n+    }\n+\n+    public void setProcessingMode(String processingMode) {\n+        this.processingMode = processingMode;\n+        if (processingMode.equals(JSON_LD_1_1)) {\n+            this.omitGraph = true;\n+            this.pruneBlankNodeIdentifiers = true;\n+            this.allowContainerSetOnType = true;\n+        }\n+    }\n+\n+    public String getBase() {\n+        return base;\n+    }\n+\n+    public void setBase(String base) {\n+        this.base = base;\n+    }\n+\n+    public Boolean getUseRdfType() {\n+        return useRdfType;\n+    }\n+\n+    public void setUseRdfType(Boolean useRdfType) {\n+        this.useRdfType = useRdfType;\n+    }\n+\n+    public Boolean getUseNativeTypes() {\n+        return useNativeTypes;\n+    }\n+\n+    public void setUseNativeTypes(Boolean useNativeTypes) {\n+        this.useNativeTypes = useNativeTypes;\n+    }\n+\n+    public boolean getProduceGeneralizedRdf() {\n+        return this.produceGeneralizedRdf;\n+    }\n+\n+    public void setProduceGeneralizedRdf(Boolean produceGeneralizedRdf) {\n+        this.produceGeneralizedRdf = produceGeneralizedRdf;\n+    }\n+\n+    public DocumentLoader getDocumentLoader() {\n+        return documentLoader;\n+    }\n+\n+    public void setDocumentLoader(DocumentLoader documentLoader) {\n+        this.documentLoader = documentLoader;\n+    }\n+\n+    // TODO: THE FOLLOWING ONLY EXIST SO I DON'T HAVE TO DELETE A LOT OF CODE,\n+    // REMOVE IT WHEN DONE\n+    public String format = null;\n+    public Boolean useNamespaces = false;\n+    public String outputForm = null;\n+\n+}"
  },
  {
    "sha": "fedff3d2400a2c0d6ab04a93483b22c2e4722dce",
    "filename": "core/src/main/java/com/github/jsonldjava/core/JsonLdProcessor.java",
    "status": "modified",
    "additions": 60,
    "deletions": 56,
    "changes": 116,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/JsonLdProcessor.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/JsonLdProcessor.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/JsonLdProcessor.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -4,15 +4,9 @@\n \n import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n-import java.util.Map.Entry;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n \n import com.github.jsonldjava.core.JsonLdError.Error;\n import com.github.jsonldjava.impl.NQuadRDFParser;\n@@ -76,19 +70,12 @@\n                 compacted = tmp;\n             }\n         }\n-        if (compacted != null && context != null) {\n-            // TODO: figure out if we can make \"@context\" appear at the start of\n-            // the keySet\n-            if ((context instanceof Map && !((Map<String, Object>) context).isEmpty())\n-                    || (context instanceof List && !((List<Object>) context).isEmpty())) {\n-\n-                if (context instanceof List && ((List<Object>) context).size() == 1\n-                        && opts.getCompactArrays()) {\n-                    ((Map<String, Object>) compacted).put(JsonLdConsts.CONTEXT,\n-                            ((List<Object>) context).get(0));\n-                } else {\n-                    ((Map<String, Object>) compacted).put(JsonLdConsts.CONTEXT, context);\n-                }\n+        if (compacted != null) {\n+            final Object returnedContext = returnedContext(context, opts);\n+            if(returnedContext != null) {\n+                // TODO: figure out if we can make \"@context\" appear at the start of\n+                // the keySet\n+                ((Map<String, Object>) compacted).put(JsonLdConsts.CONTEXT, returnedContext);\n             }\n         }\n \n@@ -118,7 +105,7 @@\n         if (input instanceof String && ((String) input).contains(\":\")) {\n             try {\n                 final RemoteDocument tmp = opts.getDocumentLoader().loadDocument((String) input);\n-                input = tmp.document;\n+                input = tmp.getDocument();\n                 // TODO: figure out how to deal with remote context\n             } catch (final Exception e) {\n                 throw new JsonLdError(Error.LOADING_DOCUMENT_FAILED, e);\n@@ -256,7 +243,11 @@ public static Object flatten(Object input, Object context, JsonLdOptions opts)\n                 compacted = tmp;\n             }\n             final String alias = activeCtx.compactIri(JsonLdConsts.GRAPH);\n-            final Map<String, Object> rval = activeCtx.serialize();\n+            final Map<String, Object> rval = newMap();\n+            final Object returnedContext = returnedContext(context, opts);\n+            if(returnedContext != null) {\n+                rval.put(JsonLdConsts.CONTEXT, returnedContext);\n+            }\n             rval.put(alias, compacted);\n             return rval;\n         }\n@@ -308,58 +299,71 @@ public static Object flatten(Object input, JsonLdOptions opts) throws JsonLdErro\n         }\n         // TODO string/IO input\n \n-        // 2. Set expanded input to the result of using the expand method using input and options. \n+        // 2. Set expanded input to the result of using the expand method using\n+        // input and options.\n         final Object expandedInput = expand(input, opts);\n-        \n-        // 3. Set expanded frame to the result of using the expand method using frame and options\n-        // with expandContext set to null and processingMode set to json-ld-1.1-expand-frame. \n-        String savedProcessingMode = opts.getProcessingMode();\n-        Object savedExpandedContext = opts.getExpandContext();\n-        opts.setProcessingMode(JsonLdOptions.JSON_LD_1_1_FRAME);\n+\n+        // 3. Set expanded frame to the result of using the expand method using\n+        // frame and options with expandContext set to null and the\n+        // frameExpansion option set to true.\n+        final Object savedExpandedContext = opts.getExpandContext();\n         opts.setExpandContext(null);\n+        opts.setFrameExpansion(true);\n         final List<Object> expandedFrame = expand(frame, opts);\n-        opts.setProcessingMode(savedProcessingMode);\n         opts.setExpandContext(savedExpandedContext);\n \n-        // 4. Set context to the value of @context from frame, if it exists, or to a new empty\n+        // 4. Set context to the value of @context from frame, if it exists, or\n+        // to a new empty\n         // context, otherwise.\n         final JsonLdApi api = new JsonLdApi(expandedInput, opts);\n-        final Context activeCtx = api.context\n-                .parse(((Map<String, Object>) frame).get(JsonLdConsts.CONTEXT));\n+        final Object context = ((Map<String, Object>) frame).get(JsonLdConsts.CONTEXT);\n+        final Context activeCtx = api.context.parse(context);\n         final List<Object> framed = api.frame(expandedInput, expandedFrame);\n-\n+        if (opts.getPruneBlankNodeIdentifiers()) {\n+            JsonLdUtils.pruneBlankNodes(framed);\n+        }\n         Object compacted = api.compact(activeCtx, null, framed, opts.getCompactArrays());\n-        if (!(compacted instanceof List)) {\n+        final Map<String, Object> rval = newMap();\n+        final Object returnedContext = returnedContext(context, opts);\n+        if(returnedContext != null) {\n+            rval.put(JsonLdConsts.CONTEXT, returnedContext);\n+        }\n+        final boolean addGraph = ((!(compacted instanceof List)) && !opts.getOmitGraph());\n+        if (addGraph && !(compacted instanceof List)) {\n             final List<Object> tmp = new ArrayList<Object>();\n             tmp.add(compacted);\n             compacted = tmp;\n         }\n-        final String alias = activeCtx.compactIri(JsonLdConsts.GRAPH);\n-        final Map<String, Object> rval = activeCtx.serialize();\n-        rval.put(alias, compacted);\n-\n-        Set<Object> toPrune = opts.getPruneBlankNodeIdentifiers() ? blankNodeIdsToPrune(rval) : Collections.emptySet();\n-        JsonLdUtils.removePreserveAndPrune(activeCtx, rval, opts, toPrune);\n+        if (addGraph || (compacted instanceof List)) {\n+            final String alias = activeCtx.compactIri(JsonLdConsts.GRAPH);\n+            rval.put(alias, compacted);\n+        } else if (!addGraph && (compacted instanceof Map)) {\n+            rval.putAll((Map) compacted);\n+        }\n+        JsonLdUtils.removePreserve(activeCtx, rval, opts);\n         return rval;\n     }\n \n-    private static Set<Object> blankNodeIdsToPrune(final Map<String, Object> rval) {\n-        return countBlankNodeIds(rval, new HashMap<>()).entrySet().stream().filter(e -> e.getValue() == 1)\n-                .map(e -> e.getKey()).collect(Collectors.toSet());\n-    }\n-\n-    private static Map<Object, Integer> countBlankNodeIds(Object input, Map<Object, Integer> frequencies) {\n-        if (input instanceof List) {\n-            ((List<?>) input).forEach(e -> countBlankNodeIds(e, frequencies));\n-        } else if (input instanceof Map) {\n-            ((Map<?, ?>) input).entrySet().forEach(e -> countBlankNodeIds(e.getValue(), frequencies));\n-        } else if (input instanceof String) {\n-            String p = (String) input;\n-            if (p.startsWith(\"_:\")) {\n-                frequencies.put(p, frequencies.containsKey(p) ? frequencies.get(p) + 1 : 1);\n+    /**\n+     * Builds the context to be returned in framing, flattening and compaction algorithms.\n+     * In cases where the context is empty or from an unexpected type, it returns null.\n+     * When JsonLdOptions compactArrays is set to true and the context contains a List with a single element,\n+     * the element is returned instead of the list\n+     */\n+    private static Object returnedContext(Object context, JsonLdOptions opts) {\n+        if (context != null &&\n+                ((context instanceof Map && !((Map<String, Object>) context).isEmpty())\n+                        || (context instanceof List && !((List<Object>) context).isEmpty())\n+                        || (context instanceof String && !((String) context).isEmpty()))) {\n+\n+            if (context instanceof List && ((List<Object>) context).size() == 1\n+                    && opts.getCompactArrays()) {\n+                return ((List<Object>) context).get(0);\n             }\n+            return context;\n+        } else {\n+            return null;\n         }\n-        return frequencies;\n     }\n \n     /**\n@@ -622,7 +626,7 @@ public static Object toRDF(Object input) throws JsonLdError {\n      */\n     public static Object normalize(Object input, JsonLdOptions options) throws JsonLdError {\n \n-        final JsonLdOptions opts = new JsonLdOptions(options.getBase());\n+        final JsonLdOptions opts = options.copy();\n         opts.format = null;\n         final RDFDataset dataset = (RDFDataset) toRDF(input, opts);\n "
  },
  {
    "sha": "e0accff7e1d9c9f483c655170e40954bb5a05490",
    "filename": "core/src/main/java/com/github/jsonldjava/core/JsonLdUtils.java",
    "status": "modified",
    "additions": 92,
    "deletions": 23,
    "changes": 115,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/JsonLdUtils.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/JsonLdUtils.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/JsonLdUtils.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -1,17 +1,11 @@\n package com.github.jsonldjava.core;\n \n-import static com.github.jsonldjava.utils.Obj.newMap;\n-\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n+import java.util.HashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n \n-import com.github.jsonldjava.utils.JsonLdUrl;\n import com.github.jsonldjava.utils.Obj;\n \n public class JsonLdUtils {\n@@ -37,7 +31,8 @@ static boolean isKeyword(Object key) {\n                 || \"@graph\".equals(key) || \"@id\".equals(key) || \"@index\".equals(key)\n                 || \"@language\".equals(key) || \"@list\".equals(key) || \"@omitDefault\".equals(key)\n                 || \"@reverse\".equals(key) || \"@preserve\".equals(key) || \"@set\".equals(key)\n-                || \"@type\".equals(key) || \"@value\".equals(key) || \"@vocab\".equals(key) || \"@requireAll\".equals(key);\n+                || \"@type\".equals(key) || \"@value\".equals(key) || \"@vocab\".equals(key)\n+                || \"@requireAll\".equals(key);\n     }\n \n     public static Boolean deepCompare(Object v1, Object v2, Boolean listOrderMatters) {\n@@ -189,25 +184,24 @@ public static boolean isRelativeIri(String value) {\n     }\n \n     /**\n-     * Removes the @preserve keywords and blank node IDs to prune as the last step of the framing algorithm.\n+     * Removes the @preserve keywords as the last step of the framing algorithm.\n      *\n      * @param ctx\n      *            the active context used to compact the input.\n      * @param input\n      *            the framed, compacted output.\n-     * @param toPrune The blank node IDs to prune.\n      * @param options\n      *            the compaction options used.\n      *\n      * @return the resulting output.\n      * @throws JsonLdError\n      */\n-    static Object removePreserveAndPrune(Context ctx, Object input, JsonLdOptions opts, Set<Object> toPrune) throws JsonLdError {\n+    static Object removePreserve(Context ctx, Object input, JsonLdOptions opts) throws JsonLdError {\n         // recurse through arrays\n         if (isArray(input)) {\n             final List<Object> output = new ArrayList<Object>();\n             for (final Object i : (List<Object>) input) {\n-                final Object result = removePreserveAndPrune(ctx, i, opts, toPrune);\n+                final Object result = removePreserve(ctx, i, opts);\n                 // drop nulls from arrays\n                 if (result != null) {\n                     output.add(result);\n@@ -231,26 +225,100 @@ static Object removePreserveAndPrune(Context ctx, Object input, JsonLdOptions op\n             // recurse through @lists\n             if (isList(input)) {\n                 ((Map<String, Object>) input).put(\"@list\",\n-                        removePreserveAndPrune(ctx, ((Map<String, Object>) input).get(\"@list\"), opts, toPrune));\n+                        removePreserve(ctx, ((Map<String, Object>) input).get(\"@list\"), opts));\n                 return input;\n             }\n \n             // recurse through properties\n-            for (final String prop : new LinkedHashSet<>(((Map<String, Object>) input).keySet())) {\n-                Object result = removePreserveAndPrune(ctx, ((Map<String, Object>) input).get(prop), opts, toPrune);\n+            for (final String prop : ((Map<String, Object>) input).keySet()) {\n+                Object result = removePreserve(ctx, ((Map<String, Object>) input).get(prop), opts);\n                 final String container = ctx.getContainer(prop);\n                 if (opts.getCompactArrays() && isArray(result)\n                         && ((List<Object>) result).size() == 1 && container == null) {\n                     result = ((List<Object>) result).get(0);\n                 }\n-                if(ctx.expandIri(prop, false, false, null, null).equals(JsonLdConsts.ID) && toPrune.contains(result)) {\n-                    ((Map<String, Object>) input).remove(prop);\n+                ((Map<String, Object>) input).put(prop, result);\n+            }\n+        }\n+        return input;\n+    }\n+\n+    /**\n+     * Removes the @id member of each node object where the member value is a\n+     * blank node identifier which appears only once in any property value\n+     * within input.\n+     *\n+     * @param input\n+     *            the framed output before compaction\n+     */\n+\n+    static void pruneBlankNodes(final Object input) {\n+        final Map<String, Object> toPrune = new HashMap<>();\n+        fillNodesToPrune(input, toPrune);\n+        for (final String id : toPrune.keySet()) {\n+            final Object node = toPrune.get(id);\n+            if (node == null) {\n+                continue;\n+            }\n+            ((Map<String, Object>) node).remove(JsonLdConsts.ID);\n+        }\n+    }\n+\n+    /**\n+     * Gets the objects on which we'll prune the blank node ID\n+     *\n+     * @param input\n+     *            the framed output before compaction\n+     * @param toPrune\n+     *            the resulting object.\n+     */\n+    static void fillNodesToPrune(Object input, final Map<String, Object> toPrune) {\n+        // recurse through arrays\n+        if (isArray(input)) {\n+            for (final Object i : (List<Object>) input) {\n+                fillNodesToPrune(i, toPrune);\n+            }\n+        } else if (isObject(input)) {\n+            // skip @values\n+            if (isValue(input)) {\n+                return;\n+            }\n+            // recurse through @lists\n+            if (isList(input)) {\n+                fillNodesToPrune(((Map<String, Object>) input).get(\"@list\"), toPrune);\n+                return;\n+            }\n+            // recurse through properties\n+            for (final String prop : new LinkedHashSet<>(((Map<String, Object>) input).keySet())) {\n+                if (prop.equals(JsonLdConsts.ID)) {\n+                    final String id = (String) ((Map<String, Object>) input).get(JsonLdConsts.ID);\n+                    if (id.startsWith(\"_:\")) {\n+                        // if toPrune contains the id already, it was already\n+                        // present somewhere else,\n+                        // so we just null the value\n+                        if (toPrune.containsKey(id)) {\n+                            toPrune.put(id, null);\n+                        } else {\n+                            // else we add the object as the value\n+                            toPrune.put(id, input);\n+                        }\n+                    }\n                 } else {\n-                    ((Map<String, Object>) input).put(prop, result);\n+                    fillNodesToPrune(((Map<String, Object>) input).get(prop), toPrune);\n                 }\n             }\n+        } else if (input instanceof String) {\n+            // this is an id, as non-id values will have been discarded by the\n+            // isValue() above\n+            final String p = (String) input;\n+            if (p.startsWith(\"_:\")) {\n+                // the id is outside of the context of an @id property, if we're\n+                // in that case,\n+                // then we're referencing a blank node id so this id should not\n+                // be removed\n+                toPrune.put(p, null);\n+            }\n         }\n-        return input;\n     }\n \n     /**\n@@ -328,11 +396,12 @@ static boolean isBlankNode(Object v) {\n         // 2. If it has an @id key its value begins with '_:'.\n         // 3. It has no keys OR is not a @value, @set, or @list.\n         if (v instanceof Map) {\n-            if (((Map) v).containsKey(\"@id\")) {\n-                return ((String) ((Map) v).get(\"@id\")).startsWith(\"_:\");\n+            final Map<String, Object> map = (Map<String, Object>) v;\n+            if (map.containsKey(\"@id\")) {\n+                return ((String) map.get(\"@id\")).startsWith(\"_:\");\n             } else {\n-                return ((Map) v).size() == 0 || !(((Map) v).containsKey(\"@value\")\n-                        || ((Map) v).containsKey(\"@set\") || ((Map) v).containsKey(\"@list\"));\n+                return map.isEmpty() || !map.containsKey(\"@value\") || map.containsKey(\"@set\")\n+                        || map.containsKey(\"@list\");\n             }\n         }\n         return false;"
  },
  {
    "sha": "7b1bd5e7ff5beedb6696557c468a8823e5bf6241",
    "filename": "core/src/main/java/com/github/jsonldjava/core/NormalizeUtils.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/NormalizeUtils.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/NormalizeUtils.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/NormalizeUtils.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -494,7 +494,8 @@ private static String encodeHex(final byte[] data) {\n     private static String getAdjacentBlankNodeName(Map<String, Object> node, String id) {\n         return \"blank node\".equals(node.get(\"type\"))\n                 && (!node.containsKey(\"value\") || !Obj.equals(node.get(\"value\"), id))\n-                        ? (String) node.get(\"value\") : null;\n+                        ? (String) node.get(\"value\")\n+                        : null;\n     }\n \n     private static class Permutator {"
  },
  {
    "sha": "8f8e18c26a5af206477620a0b0112c5d98395b62",
    "filename": "core/src/main/java/com/github/jsonldjava/core/RDFDataset.java",
    "status": "modified",
    "additions": 22,
    "deletions": 11,
    "changes": 33,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/RDFDataset.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/RDFDataset.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/RDFDataset.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -6,6 +6,7 @@\n import static com.github.jsonldjava.core.JsonLdConsts.RDF_REST;\n import static com.github.jsonldjava.core.JsonLdConsts.RDF_TYPE;\n import static com.github.jsonldjava.core.JsonLdConsts.XSD_BOOLEAN;\n+import static com.github.jsonldjava.core.JsonLdConsts.XSD_DECIMAL;\n import static com.github.jsonldjava.core.JsonLdConsts.XSD_DOUBLE;\n import static com.github.jsonldjava.core.JsonLdConsts.XSD_INTEGER;\n import static com.github.jsonldjava.core.JsonLdConsts.XSD_STRING;\n@@ -159,7 +160,7 @@ public int compareTo(Node o) {\n                     return -1; // literals < blanknode < IRI\n                 }\n             }\n-            // NOTE: Literal will also need to compare \n+            // NOTE: Literal will also need to compare\n             // language and datatype\n             return this.getValue().compareTo(o.getValue());\n         }\n@@ -275,12 +276,11 @@ public boolean isBlankNode() {\n             return false;\n         }\n \n-        @SuppressWarnings(\"rawtypes\")\n-        private static int nullSafeCompare(Comparable a, Comparable b) {\n+        private static int nullSafeCompare(String a, String b) {\n             if (a == null && b == null) {\n                 return 0;\n             }\n-            if (a == null) { \n+            if (a == null) {\n                 return 1;\n             }\n             if (b == null) {\n@@ -292,9 +292,9 @@ private static int nullSafeCompare(Comparable a, Comparable b) {\n         @Override\n         public int compareTo(Node o) {\n             // NOTE: this will also compare getValue() early!\n-            int nodeCompare = super.compareTo(o);\n+            final int nodeCompare = super.compareTo(o);\n             if (nodeCompare != 0) {\n-                // null, different type or different value \n+                // null, different type or different value\n                 return nodeCompare;\n             }\n             if (this.getLanguage() != null || o.getLanguage() != null) {\n@@ -659,11 +659,22 @@ private Node objectToRDF(Object item) {\n                             datatype == null ? XSD_BOOLEAN : (String) datatype, null);\n                 } else if (value instanceof Double || value instanceof Float\n                         || XSD_DOUBLE.equals(datatype)) {\n-                    // canonical double representation\n-                    final DecimalFormat df = new DecimalFormat(\"0.0###############E0\");\n-                    df.setDecimalFormatSymbols(DecimalFormatSymbols.getInstance(Locale.US));\n-                    return new Literal(df.format(value),\n-                            datatype == null ? XSD_DOUBLE : (String) datatype, null);\n+                    if (value instanceof Double && !Double.isFinite((double) value)) {\n+                        return new Literal(Double.toString((double) value),\n+                                datatype == null ? XSD_DOUBLE : (String) datatype, null);\n+                    } else if (value instanceof Float && !Float.isFinite((float) value)) {\n+                        return new Literal(Float.toString((float) value),\n+                                datatype == null ? XSD_DOUBLE : (String) datatype, null);\n+                    } else {\n+                        // Only canonicalize representation if datatype is not XSD_DECIMAL\n+                        if (XSD_DECIMAL.equals(datatype)) {\n+                            return new Literal(value.toString(), XSD_DECIMAL, null);\n+                        }\n+                        final DecimalFormat df = new DecimalFormat(\"0.0###############E0\");\n+                        df.setDecimalFormatSymbols(DecimalFormatSymbols.getInstance(Locale.US));\n+                        return new Literal(df.format(value),\n+                                datatype == null ? XSD_DOUBLE : (String) datatype, null);\n+                    }\n                 } else {\n                     final DecimalFormat df = new DecimalFormat(\"0\");\n                     return new Literal(df.format(value),"
  },
  {
    "sha": "a2739e6452902698157eef5c4f898a7d43518006",
    "filename": "core/src/main/java/com/github/jsonldjava/core/RDFDatasetUtils.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/RDFDatasetUtils.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/RDFDatasetUtils.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/RDFDatasetUtils.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -145,7 +145,7 @@ public static String unescape(String str) {\n                         final int w1 = 0xD800 + vh;\n                         final int w2 = 0xDC00 + v1;\n \n-                        final StringBuffer b = new StringBuffer();\n+                        final StringBuilder b = new StringBuilder();\n                         b.appendCodePoint(w1);\n                         b.appendCodePoint(w2);\n                         uni = b.toString();\n@@ -185,7 +185,7 @@ public static String unescape(String str) {\n                     }\n                 }\n                 final String pat = Pattern.quote(m.group(0));\n-                final String x = Integer.toHexString(uni.charAt(0));\n+                // final String x = Integer.toHexString(uni.charAt(0));\n                 rval = rval.replaceAll(pat, uni);\n             }\n         }"
  },
  {
    "sha": "db4ec692dabcf1f944ed2ecf53c836eceb3dcbe7",
    "filename": "core/src/main/java/com/github/jsonldjava/core/RDFParser.java",
    "status": "modified",
    "additions": 47,
    "deletions": 47,
    "changes": 94,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/RDFParser.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/RDFParser.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/RDFParser.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -1,47 +1,47 @@\n-package com.github.jsonldjava.core;\r\n-\r\n-/**\r\n- * Interface for parsing RDF into the RDF Dataset objects to be used by\r\n- * JSONLD.fromRDF\r\n- *\r\n- * @author Tristan\r\n- *\r\n- */\r\n-public interface RDFParser {\r\n-\r\n-    /**\r\n-     * Parse the input into the internal RDF Dataset format The format is a Map\r\n-     * with the following structure: { GRAPH_1: [ TRIPLE_1, TRIPLE_2, ...,\r\n-     * TRIPLE_N ], GRAPH_2: [ TRIPLE_1, TRIPLE_2, ..., TRIPLE_N ], ... GRAPH_N:\r\n-     * [ TRIPLE_1, TRIPLE_2, ..., TRIPLE_N ] }\r\n-     *\r\n-     * GRAPH: Must be the graph name/IRI. if no graph is present for a triple,\r\n-     * add it to the \"@default\" graph TRIPLE: Must be a map with the following\r\n-     * structure: { \"subject\" : SUBJECT \"predicate\" : PREDICATE \"object\" :\r\n-     * OBJECT }\r\n-     *\r\n-     * Each of the values in the triple map must also be a map with the\r\n-     * following key-value pairs: \"value\" : The value of the node. \"subject\" can\r\n-     * be an IRI or blank node id. \"predicate\" should only ever be an IRI\r\n-     * \"object\" can be and IRI or blank node id, or a literal value (represented\r\n-     * as a string) \"type\" : \"IRI\" if the value is an IRI or \"blank node\" if the\r\n-     * value is a blank node. \"object\" can also be \"literal\" in the case of\r\n-     * literals. The value of \"object\" can also contain the following optional\r\n-     * key-value pairs: \"language\" : the language value of a string literal\r\n-     * \"datatype\" : the datatype of the literal. (if not set will default to\r\n-     * XSD:string, if set to null, null will be used).\r\n-     *\r\n-     * The RDFDatasetUtils class has the following helper methods to make\r\n-     * generating this format easier: result = getInitialRDFDatasetResult();\r\n-     * triple = generateTriple(s,p,o); triple =\r\n-     * generateTriple(s,p,value,datatype,language);\r\n-     * addTripleToRDFDatasetResult(result, graphName, triple);\r\n-     *\r\n-     * @param input\r\n-     *            The RDF library specific input to parse\r\n-     * @return The input parsed using the internal RDF Dataset format\r\n-     * @throws JsonLdError\r\n-     *             If there was an error parsing the input\r\n-     */\r\n-    public RDFDataset parse(Object input) throws JsonLdError;\r\n-}\r\n+package com.github.jsonldjava.core;\n+\n+/**\n+ * Interface for parsing RDF into the RDF Dataset objects to be used by\n+ * JSONLD.fromRDF\n+ *\n+ * @author Tristan\n+ *\n+ */\n+public interface RDFParser {\n+\n+    /**\n+     * Parse the input into the internal RDF Dataset format The format is a Map\n+     * with the following structure: { GRAPH_1: [ TRIPLE_1, TRIPLE_2, ...,\n+     * TRIPLE_N ], GRAPH_2: [ TRIPLE_1, TRIPLE_2, ..., TRIPLE_N ], ... GRAPH_N:\n+     * [ TRIPLE_1, TRIPLE_2, ..., TRIPLE_N ] }\n+     *\n+     * GRAPH: Must be the graph name/IRI. if no graph is present for a triple,\n+     * add it to the \"@default\" graph TRIPLE: Must be a map with the following\n+     * structure: { \"subject\" : SUBJECT \"predicate\" : PREDICATE \"object\" :\n+     * OBJECT }\n+     *\n+     * Each of the values in the triple map must also be a map with the\n+     * following key-value pairs: \"value\" : The value of the node. \"subject\" can\n+     * be an IRI or blank node id. \"predicate\" should only ever be an IRI\n+     * \"object\" can be and IRI or blank node id, or a literal value (represented\n+     * as a string) \"type\" : \"IRI\" if the value is an IRI or \"blank node\" if the\n+     * value is a blank node. \"object\" can also be \"literal\" in the case of\n+     * literals. The value of \"object\" can also contain the following optional\n+     * key-value pairs: \"language\" : the language value of a string literal\n+     * \"datatype\" : the datatype of the literal. (if not set will default to\n+     * XSD:string, if set to null, null will be used).\n+     *\n+     * The RDFDatasetUtils class has the following helper methods to make\n+     * generating this format easier: result = getInitialRDFDatasetResult();\n+     * triple = generateTriple(s,p,o); triple =\n+     * generateTriple(s,p,value,datatype,language);\n+     * addTripleToRDFDatasetResult(result, graphName, triple);\n+     *\n+     * @param input\n+     *            The RDF library specific input to parse\n+     * @return The input parsed using the internal RDF Dataset format\n+     * @throws JsonLdError\n+     *             If there was an error parsing the input\n+     */\n+    public RDFDataset parse(Object input) throws JsonLdError;\n+}"
  },
  {
    "sha": "33f437595058d94d894a5fff63d5138936e58141",
    "filename": "core/src/main/java/com/github/jsonldjava/core/Regex.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/Regex.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/Regex.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/Regex.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -2,7 +2,7 @@\n \n import java.util.regex.Pattern;\n \n-public class Regex {\n+class Regex {\n     final public static Pattern TRICKY_UTF_CHARS = Pattern.compile(\n             // (\"1.7\".equals(System.getProperty(\"java.specification.version\")) ?\n             // \"[\\\\x{10000}-\\\\x{EFFFF}]\" :"
  },
  {
    "sha": "0af7a5cd43543aff0da113ed3cf4842f5d629422",
    "filename": "core/src/main/java/com/github/jsonldjava/core/RemoteDocument.java",
    "status": "modified",
    "additions": 32,
    "deletions": 30,
    "changes": 62,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/RemoteDocument.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/RemoteDocument.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/RemoteDocument.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -1,41 +1,43 @@\n package com.github.jsonldjava.core;\n \n+/**\n+ * Encapsulates a URL along with the parsed resource matching the URL.\n+ *\n+ * @author Tristan King\n+ */\n public class RemoteDocument {\n-    public String getDocumentUrl() {\n-        return documentUrl;\n+    private final String documentUrl;\n+    private final Object document;\n+\n+    /**\n+     * Create a new RemoteDocument with the URL and the parsed resource for the\n+     * document.\n+     *\n+     * @param url\n+     *            The URL\n+     * @param document\n+     *            The parsed resource for the document\n+     */\n+    public RemoteDocument(String url, Object document) {\n+        this.documentUrl = url;\n+        this.document = document;\n     }\n \n-    public void setDocumentUrl(String documentUrl) {\n-        this.documentUrl = documentUrl;\n+    /**\n+     * Get the URL for this document.\n+     *\n+     * @return The URL for this document, as a String\n+     */\n+    public String getDocumentUrl() {\n+        return documentUrl;\n     }\n \n+    /**\n+     * Get the parsed resource for this document.\n+     *\n+     * @return The parsed resource for this document\n+     */\n     public Object getDocument() {\n         return document;\n     }\n-\n-    public void setDocument(Object document) {\n-        this.document = document;\n-    }\n-\n-    public String getContextUrl() {\n-        return contextUrl;\n-    }\n-\n-    public void setContextUrl(String contextUrl) {\n-        this.contextUrl = contextUrl;\n-    }\n-\n-    String documentUrl;\n-    Object document;\n-    String contextUrl;\n-\n-    public RemoteDocument(String url, Object document) {\n-        this(url, document, null);\n-    }\n-\n-    public RemoteDocument(String url, Object document, String context) {\n-        this.documentUrl = url;\n-        this.document = document;\n-        this.contextUrl = context;\n-    }\n }"
  },
  {
    "sha": "0d0aa760aa4e2400ede220f3757241ce6e6fb3a4",
    "filename": "core/src/main/java/com/github/jsonldjava/core/UniqueNamer.java",
    "status": "modified",
    "additions": 71,
    "deletions": 71,
    "changes": 142,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/UniqueNamer.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/core/UniqueNamer.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/core/UniqueNamer.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -1,72 +1,72 @@\n-package com.github.jsonldjava.core;\r\n-\r\n-import java.util.LinkedHashMap;\r\n-import java.util.Map;\r\n-\r\n-public class UniqueNamer {\r\n-    private final String prefix;\r\n-    private int counter;\r\n-    private Map<String, String> existing;\r\n-\r\n-    /**\r\n-     * Creates a new UniqueNamer. A UniqueNamer issues unique names, keeping\r\n-     * track of any previously issued names.\r\n-     *\r\n-     * @param prefix\r\n-     *            the prefix to use ('&lt;prefix&gt;&lt;counter&gt;').\r\n-     */\r\n-    public UniqueNamer(String prefix) {\r\n-        this.prefix = prefix;\r\n-        this.counter = 0;\r\n-        this.existing = new LinkedHashMap<String, String>();\r\n-    }\r\n-\r\n-    /**\r\n-     * Copies this UniqueNamer.\r\n-     *\r\n-     * @return a copy of this UniqueNamer.\r\n-     */\r\n-    @Override\r\n-    public UniqueNamer clone() {\r\n-        final UniqueNamer copy = new UniqueNamer(this.prefix);\r\n-        copy.counter = this.counter;\r\n-        copy.existing = (Map<String, String>) JsonLdUtils.clone(this.existing);\r\n-        return copy;\r\n-    }\r\n-\r\n-    /**\r\n-     * Gets the new name for the given old name, where if no old name is given a\r\n-     * new name will be generated.\r\n-     *\r\n-     * @param oldName\r\n-     *            the old name to get the new name for.\r\n-     *\r\n-     * @return the new name.\r\n-     */\r\n-    public String getName(String oldName) {\r\n-        if (oldName != null && this.existing.containsKey(oldName)) {\r\n-            return this.existing.get(oldName);\r\n-        }\r\n-\r\n-        final String name = this.prefix + this.counter;\r\n-        this.counter++;\r\n-\r\n-        if (oldName != null) {\r\n-            this.existing.put(oldName, name);\r\n-        }\r\n-\r\n-        return name;\r\n-    }\r\n-\r\n-    public String getName() {\r\n-        return getName(null);\r\n-    }\r\n-\r\n-    public Boolean isNamed(String oldName) {\r\n-        return this.existing.containsKey(oldName);\r\n-    }\r\n-\r\n-    public Map<String, String> existing() {\r\n-        return existing;\r\n-    }\r\n+package com.github.jsonldjava.core;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+class UniqueNamer {\n+    private final String prefix;\n+    private int counter;\n+    private Map<String, String> existing;\n+\n+    /**\n+     * Creates a new UniqueNamer. A UniqueNamer issues unique names, keeping\n+     * track of any previously issued names.\n+     *\n+     * @param prefix\n+     *            the prefix to use ('&lt;prefix&gt;&lt;counter&gt;').\n+     */\n+    public UniqueNamer(String prefix) {\n+        this.prefix = prefix;\n+        this.counter = 0;\n+        this.existing = new LinkedHashMap<String, String>();\n+    }\n+\n+    /**\n+     * Copies this UniqueNamer.\n+     *\n+     * @return a copy of this UniqueNamer.\n+     */\n+    @Override\n+    public UniqueNamer clone() {\n+        final UniqueNamer copy = new UniqueNamer(this.prefix);\n+        copy.counter = this.counter;\n+        copy.existing = (Map<String, String>) JsonLdUtils.clone(this.existing);\n+        return copy;\n+    }\n+\n+    /**\n+     * Gets the new name for the given old name, where if no old name is given a\n+     * new name will be generated.\n+     *\n+     * @param oldName\n+     *            the old name to get the new name for.\n+     *\n+     * @return the new name.\n+     */\n+    public String getName(String oldName) {\n+        if (oldName != null && this.existing.containsKey(oldName)) {\n+            return this.existing.get(oldName);\n+        }\n+\n+        final String name = this.prefix + this.counter;\n+        this.counter++;\n+\n+        if (oldName != null) {\n+            this.existing.put(oldName, name);\n+        }\n+\n+        return name;\n+    }\n+\n+    public String getName() {\n+        return getName(null);\n+    }\n+\n+    public Boolean isNamed(String oldName) {\n+        return this.existing.containsKey(oldName);\n+    }\n+\n+    public Map<String, String> existing() {\n+        return existing;\n+    }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "5c76f8d4a88f52f4839783e884ee3f99bbc60dc7",
    "filename": "core/src/main/java/com/github/jsonldjava/utils/JarCacheResource.java",
    "status": "modified",
    "additions": 1,
    "deletions": 3,
    "changes": 4,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/utils/JarCacheResource.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/utils/JarCacheResource.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/utils/JarCacheResource.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -23,9 +23,7 @@ public JarCacheResource(URL classpath) throws IOException {\n \n     @Override\n     public long length() {\n-        // TODO should be getContentLengthLong() but this is not available in\n-        // Java 6.\n-        return connection.getContentLength();\n+        return connection.getContentLengthLong();\n     }\n \n     @Override"
  },
  {
    "sha": "137daa74c519405390c9e4f4fe3d81bceb677105",
    "filename": "core/src/main/java/com/github/jsonldjava/utils/JarCacheStorage.java",
    "status": "modified",
    "additions": 156,
    "deletions": 86,
    "changes": 242,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/utils/JarCacheStorage.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/utils/JarCacheStorage.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/utils/JarCacheStorage.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -1,18 +1,19 @@\n package com.github.jsonldjava.utils;\n \n import java.io.IOException;\n-import java.lang.ref.SoftReference;\n import java.net.MalformedURLException;\n import java.net.URI;\n import java.net.URISyntaxException;\n import java.net.URL;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.Date;\n-import java.util.Enumeration;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.concurrent.ConcurrentHashMap;\n+import java.util.Objects;\n+import java.util.Optional;\n import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ExecutionException;\n \n import org.apache.http.Header;\n import org.apache.http.HttpVersion;\n@@ -31,19 +32,48 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.MapMaker;\n \n+/**\n+ * Implementation of the Apache HttpClient {@link HttpCacheStorage} interface\n+ * using {@code jarcache.json} files on the classpath to identify static JSON-LD\n+ * resources on the classpath, to avoid retrieving them.\n+ *\n+ * @author Stian Soiland-Reyes\n+ * @author Peter Ansell p_ansell@yahoo.com\n+ */\n public class JarCacheStorage implements HttpCacheStorage {\n \n+    /**\n+     * The classpath location that is searched inside of the classloader set for\n+     * this cache. Note this search is also done on the Thread\n+     * contextClassLoader if none is explicitly set, and the System classloader\n+     * if there is no contextClassLoader.\n+     */\n     private static final String JARCACHE_JSON = \"jarcache.json\";\n \n     private final Logger log = LoggerFactory.getLogger(getClass());\n \n     private final CacheConfig cacheConfig;\n-    \n-    private ClassLoader classLoader;\n+\n+    /**\n+     * The classloader to use, defaults to null which will use the thread\n+     * context classloader.\n+     */\n+    private ClassLoader classLoader = null;\n+\n+    /**\n+     * A holder for the case where the System class loader needs to be used, but\n+     * cannot be directly identified in another way.\n+     *\n+     * Used as a key in cachedResourceList.\n+     */\n+    private static final Object NULL_CLASS_LOADER = new Object();\n \n     /**\n      * All live caching that is not found locally is delegated to this\n@@ -55,22 +85,28 @@\n \n     /**\n      * Map from uri of jarcache.json (e.g. jar://blab.jar!jarcache.json) to a\n-     * SoftReference to its content as JsonNode.\n+     * SoftReference to its parsed content as JsonNode.\n      *\n      * @see #getJarCache(URL)\n      */\n-    protected final ConcurrentMap<URI, SoftReference<JsonNode>> jarCaches = new ConcurrentHashMap<URI, SoftReference<JsonNode>>();\n-\n-    public ClassLoader getClassLoader() {\n-        if (classLoader != null) {\n-            return classLoader;\n-        }\n-        return Thread.currentThread().getContextClassLoader();\n-    }\n+    private final LoadingCache<URL, JsonNode> jarCaches = CacheBuilder.newBuilder()\n+            .concurrencyLevel(4).maximumSize(100).softValues()\n+            .build(new CacheLoader<URL, JsonNode>() {\n+                @Override\n+                public JsonNode load(URL url) throws IOException {\n+                    return mapper.readTree(url);\n+                }\n+            });\n \n-    public void setClassLoader(ClassLoader classLoader) {\n-        this.classLoader = classLoader;\n-    }\n+    /**\n+     * Cached URLs from the given ClassLoader to identified locations of\n+     * jarcache.json resources on the classpath\n+     *\n+     * Uses a Guava concurrent weak reference key map to avoid holding onto\n+     * ClassLoader instances after they are otherwise unavailable.\n+     */\n+    private static final ConcurrentMap<Object, List<URL>> cachedResourceList = new MapMaker()\n+            .concurrencyLevel(4).weakKeys().makeMap();\n \n     public JarCacheStorage(ClassLoader classLoader, CacheConfig cacheConfig) {\n         this(classLoader, cacheConfig, new BasicHttpCacheStorage(cacheConfig));\n@@ -79,8 +115,29 @@ public JarCacheStorage(ClassLoader classLoader, CacheConfig cacheConfig) {\n     public JarCacheStorage(ClassLoader classLoader, CacheConfig cacheConfig,\n             HttpCacheStorage delegate) {\n         setClassLoader(classLoader);\n-        this.cacheConfig = cacheConfig;\n-        this.delegate = delegate;\n+        this.cacheConfig = Objects.requireNonNull(cacheConfig, \"Cache config cannot be null\");\n+        this.delegate = Objects.requireNonNull(delegate, \"Delegate cannot be null\");\n+    }\n+\n+    public ClassLoader getClassLoader() {\n+        final ClassLoader nextClassLoader = classLoader;\n+        if (nextClassLoader != null) {\n+            return nextClassLoader;\n+        }\n+        return Thread.currentThread().getContextClassLoader();\n+    }\n+\n+    /**\n+     * Sets the ClassLoader used internally to a new value, or null to use\n+     * {@link Thread#currentThread()} and {@link Thread#getContextClassLoader()}\n+     * for each access.\n+     *\n+     * @param classLoader\n+     *            The classloader to use, or null to use the thread context\n+     *            classloader\n+     */\n+    public void setClassLoader(ClassLoader classLoader) {\n+        this.classLoader = classLoader;\n     }\n \n     @Override\n@@ -90,34 +147,48 @@ public void putEntry(String key, HttpCacheEntry entry) throws IOException {\n \n     @Override\n     public HttpCacheEntry getEntry(String key) throws IOException {\n-        log.trace(\"Requesting \" + key);\n-        URI requestedUri;\n+        log.trace(\"Requesting {}\", key);\n+        Optional<URI> parsedUri = Optional.empty();\n         try {\n-            requestedUri = new URI(key);\n+            parsedUri = Optional.of(new URI(key));\n         } catch (final URISyntaxException e) {\n-            return null;\n+            // Ignore, will delegate this request\n         }\n-        if ((requestedUri.getScheme().equals(\"http\") && requestedUri.getPort() == 80)\n-                || (requestedUri.getScheme().equals(\"https\") && requestedUri.getPort() == 443)) {\n-            // Strip away default http ports\n-            try {\n-                requestedUri = new URI(requestedUri.getScheme(), requestedUri.getHost(),\n-                        requestedUri.getPath(), requestedUri.getFragment());\n-            } catch (final URISyntaxException e) {\n+        if (parsedUri.isPresent()) {\n+            URI requestedUri = parsedUri.get();\n+            if ((requestedUri.getScheme().equals(\"http\") && requestedUri.getPort() == 80)\n+                    || (requestedUri.getScheme().equals(\"https\")\n+                            && requestedUri.getPort() == 443)) {\n+                // Strip away default http ports\n+                try {\n+                    requestedUri = new URI(requestedUri.getScheme(), requestedUri.getHost(),\n+                            requestedUri.getPath(), requestedUri.getFragment());\n+                } catch (final URISyntaxException e) {\n+                    if (log.isTraceEnabled()) {\n+                        log.trace(\"Failed to normalise URI port before looking in cache: \"\n+                                + requestedUri, e);\n+                    }\n+                    // Ignore syntax error and use the original URI directly\n+                    // instead\n+                    // This shouldn't happen as we already attempted to parse\n+                    // the URI earlier and\n+                    // would not come here if that failed\n+                }\n             }\n-        }\n-\n-        final Enumeration<URL> jarcaches = getResources();\n-        while (jarcaches.hasMoreElements()) {\n-            final URL url = jarcaches.nextElement();\n-\n-            final JsonNode tree = getJarCache(url);\n-            // TODO: Cache tree per URL\n-            for (final JsonNode node : tree) {\n-                final URI uri = URI.create(node.get(\"Content-Location\").asText());\n-                if (uri.equals(requestedUri)) {\n-                    return cacheEntry(requestedUri, url, node);\n \n+            // getResources uses a cache to avoid scanning the classpath again\n+            // for the\n+            // current classloader\n+            for (final URL url : getResources()) {\n+                // getJarCache attempts to use already parsed in-memory\n+                // locations to avoid\n+                // retrieving and parsing again\n+                final JsonNode tree = getJarCache(url);\n+                for (final JsonNode node : tree) {\n+                    final URI uri = URI.create(node.get(\"Content-Location\").asText());\n+                    if (uri.equals(requestedUri)) {\n+                        return cacheEntry(requestedUri, url, node);\n+                    }\n                 }\n             }\n         }\n@@ -126,60 +197,58 @@ public HttpCacheEntry getEntry(String key) throws IOException {\n         return delegate.getEntry(key);\n     }\n \n-    private Enumeration<URL> getResources() throws IOException {\n+    /**\n+     * Get all of the {@code jarcache.json} resources that exist on the\n+     * classpath\n+     *\n+     * @return A cached list of jarcache.json classpath resources as\n+     *         {@link URL}s\n+     * @throws IOException\n+     *             If there was an IO error while scanning the classpath\n+     */\n+    private List<URL> getResources() throws IOException {\n         final ClassLoader cl = getClassLoader();\n-        if (cl != null) {\n-            return cl.getResources(JARCACHE_JSON);\n-        } else {\n-            return ClassLoader.getSystemResources(JARCACHE_JSON);\n-        }\n-    }\n \n-    protected JsonNode getJarCache(URL url) throws IOException, JsonProcessingException {\n+        // ConcurrentHashMap doesn't support null keys, so substitute a pseudo\n+        // key\n+        final Object key = cl == null ? NULL_CLASS_LOADER : cl;\n \n-        URI uri;\n-        try {\n-            uri = url.toURI();\n-        } catch (final URISyntaxException e) {\n-            throw new IllegalArgumentException(\"Invalid jarCache URI \" + url, e);\n+        // computeIfAbsent requires unchecked exceptions for the creation\n+        // process, so we\n+        // cannot easily use it directly, instead using get and putIfAbsent\n+        List<URL> newValue = cachedResourceList.get(key);\n+        if (newValue != null) {\n+            return newValue;\n         }\n \n-        // Check if we have one from before - we'll use SoftReference so that\n-        // the maps reference is not counted for garbage collection purposes\n-        final SoftReference<JsonNode> jarCacheRef = jarCaches.get(uri);\n-        if (jarCacheRef != null) {\n-            final JsonNode jarCache = jarCacheRef.get();\n-            if (jarCache != null) {\n-                return jarCache;\n-            } else {\n-                jarCaches.remove(uri);\n-            }\n+        if (cl != null) {\n+            newValue = Collections\n+                    .unmodifiableList(Collections.list(cl.getResources(JARCACHE_JSON)));\n+        } else {\n+            newValue = Collections.unmodifiableList(\n+                    Collections.list(ClassLoader.getSystemResources(JARCACHE_JSON)));\n         }\n \n-        // Only parse again if the optimistic get failed\n-        final JsonNode tree = mapper.readTree(url);\n-        // Use putIfAbsent to ensure concurrent reads do not return different\n-        // JsonNode objects, for memory management purposes\n-        final SoftReference<JsonNode> putIfAbsent = jarCaches.putIfAbsent(uri,\n-                new SoftReference<JsonNode>(tree));\n-        if (putIfAbsent != null) {\n-            final JsonNode returnValue = putIfAbsent.get();\n-            if (returnValue != null) {\n-                return returnValue;\n-            } else {\n-                // Force update the reference if the existing reference had\n-                // been garbage collected\n-                jarCaches.put(uri, new SoftReference<JsonNode>(tree));\n-            }\n+        final List<URL> oldValue = cachedResourceList.putIfAbsent(key, newValue);\n+        // We are not synchronising access to the ConcurrentMap, so if there\n+        // were\n+        // multiple classpath scans, we always choose the first one\n+        return oldValue != null ? oldValue : newValue;\n+    }\n+\n+    protected JsonNode getJarCache(URL url) throws IOException {\n+        try {\n+            return jarCaches.get(url);\n+        } catch (final ExecutionException e) {\n+            throw new IOException(\"Failed to retrieve jar cache for URL: \" + url, e);\n         }\n-        return tree;\n     }\n \n     protected HttpCacheEntry cacheEntry(URI requestedUri, URL baseURL, JsonNode cacheNode)\n             throws MalformedURLException, IOException {\n         final URL classpath = new URL(baseURL, cacheNode.get(\"X-Classpath\").asText());\n-        log.debug(\"Cache hit for \" + requestedUri);\n-        log.trace(\"{}\", cacheNode);\n+        log.debug(\"Cache hit for: {}\", requestedUri);\n+        log.trace(\"Parsed cache entry: {}\", cacheNode);\n \n         final List<Header> responseHeaders = new ArrayList<Header>();\n         if (!cacheNode.has(HTTP.DATE_HEADER)) {\n@@ -195,8 +264,9 @@ protected HttpCacheEntry cacheEntry(URI requestedUri, URL baseURL, JsonNode cach\n         while (fieldNames.hasNext()) {\n             final String headerName = fieldNames.next();\n             final JsonNode header = cacheNode.get(headerName);\n-            // TODO: Support multiple headers with []\n-            responseHeaders.add(new BasicHeader(headerName, header.asText()));\n+            if (header != null) {\n+                responseHeaders.add(new BasicHeader(headerName, header.asText()));\n+            }\n         }\n \n         return new HttpCacheEntry(new Date(), new Date(),"
  },
  {
    "sha": "af5da444db24e32d4e064e480c17c69c2ea04350",
    "filename": "core/src/main/java/com/github/jsonldjava/utils/JsonLdUrl.java",
    "status": "modified",
    "additions": 328,
    "deletions": 315,
    "changes": 643,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/utils/JsonLdUrl.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/utils/JsonLdUrl.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/utils/JsonLdUrl.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -1,315 +1,328 @@\n-package com.github.jsonldjava.utils;\r\n-\r\n-import java.net.URI;\r\n-import java.net.URISyntaxException;\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.List;\r\n-import java.util.regex.Matcher;\r\n-import java.util.regex.Pattern;\r\n-\r\n-public class JsonLdUrl {\r\n-\r\n-    public String href = \"\";\r\n-    public String protocol = \"\";\r\n-    public String host = \"\";\r\n-    public String auth = \"\";\r\n-    public String user = \"\";\r\n-    public String password = \"\";\r\n-    public String hostname = \"\";\r\n-    public String port = \"\";\r\n-    public String relative = \"\";\r\n-    public String path = \"\";\r\n-    public String directory = \"\";\r\n-    public String file = \"\";\r\n-    public String query = \"\";\r\n-    public String hash = \"\";\r\n-\r\n-    // things not populated by the regex (NOTE: i don't think it matters if\r\n-    // these are null or \"\" to start with)\r\n-    public String pathname = null;\r\n-    public String normalizedPath = null;\r\n-    public String authority = null;\r\n-\r\n-    private static Pattern parser = Pattern.compile(\r\n-            \"^(?:([^:\\\\/?#]+):)?(?:\\\\/\\\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\\\/?#]*)(?::(\\\\d*))?))?((((?:[^?#\\\\/]*\\\\/)*)([^?#]*))(?:\\\\?([^#]*))?(?:#(.*))?)\");\r\n-\r\n-    public static JsonLdUrl parse(String url) {\r\n-        final JsonLdUrl rval = new JsonLdUrl();\r\n-        rval.href = url;\r\n-\r\n-        final Matcher matcher = parser.matcher(url);\r\n-        if (matcher.matches()) {\r\n-            if (matcher.group(1) != null) {\r\n-                rval.protocol = matcher.group(1);\r\n-            }\r\n-            if (matcher.group(2) != null) {\r\n-                rval.host = matcher.group(2);\r\n-            }\r\n-            if (matcher.group(3) != null) {\r\n-                rval.auth = matcher.group(3);\r\n-            }\r\n-            if (matcher.group(4) != null) {\r\n-                rval.user = matcher.group(4);\r\n-            }\r\n-            if (matcher.group(5) != null) {\r\n-                rval.password = matcher.group(5);\r\n-            }\r\n-            if (matcher.group(6) != null) {\r\n-                rval.hostname = matcher.group(6);\r\n-            }\r\n-            if (matcher.group(7) != null) {\r\n-                rval.port = matcher.group(7);\r\n-            }\r\n-            if (matcher.group(8) != null) {\r\n-                rval.relative = matcher.group(8);\r\n-            }\r\n-            if (matcher.group(9) != null) {\r\n-                rval.path = matcher.group(9);\r\n-            }\r\n-            if (matcher.group(10) != null) {\r\n-                rval.directory = matcher.group(10);\r\n-            }\r\n-            if (matcher.group(11) != null) {\r\n-                rval.file = matcher.group(11);\r\n-            }\r\n-            if (matcher.group(12) != null) {\r\n-                rval.query = matcher.group(12);\r\n-            }\r\n-            if (matcher.group(13) != null) {\r\n-                rval.hash = matcher.group(13);\r\n-            }\r\n-\r\n-            // normalize to node.js API\r\n-            if (!\"\".equals(rval.host) && \"\".equals(rval.path)) {\r\n-                rval.path = \"/\";\r\n-            }\r\n-            rval.pathname = rval.path;\r\n-            parseAuthority(rval);\r\n-            rval.normalizedPath = removeDotSegments(rval.pathname, !\"\".equals(rval.authority));\r\n-            if (!\"\".equals(rval.query)) {\r\n-                rval.path += \"?\" + rval.query;\r\n-            }\r\n-            if (!\"\".equals(rval.protocol)) {\r\n-                rval.protocol += \":\";\r\n-            }\r\n-            if (!\"\".equals(rval.hash)) {\r\n-                rval.hash = \"#\" + rval.hash;\r\n-            }\r\n-            return rval;\r\n-        }\r\n-\r\n-        return rval;\r\n-    }\r\n-\r\n-    /**\r\n-     * Removes dot segments from a JsonLdUrl path.\r\n-     *\r\n-     * @param path\r\n-     *            the path to remove dot segments from.\r\n-     * @param hasAuthority\r\n-     *            true if the JsonLdUrl has an authority, false if not.\r\n-     * @return The URL without the dot segments\r\n-     */\r\n-    public static String removeDotSegments(String path, boolean hasAuthority) {\r\n-        String rval = \"\";\r\n-\r\n-        if (path.indexOf(\"/\") == 0) {\r\n-            rval = \"/\";\r\n-        }\r\n-\r\n-        // RFC 3986 5.2.4 (reworked)\r\n-        final List<String> input = new ArrayList<String>(Arrays.asList(path.split(\"/\")));\r\n-        if (path.endsWith(\"/\")) {\r\n-            // javascript .split includes a blank entry if the string ends with\r\n-            // the delimiter, java .split does not so we need to add it manually\r\n-            input.add(\"\");\r\n-        }\r\n-        final List<String> output = new ArrayList<String>();\r\n-        for (int i = 0; i < input.size(); i++) {\r\n-            if (\".\".equals(input.get(i)) || (\"\".equals(input.get(i)) && input.size() - i > 1)) {\r\n-                // input.remove(0);\r\n-                continue;\r\n-            }\r\n-            if (\"..\".equals(input.get(i))) {\r\n-                // input.remove(0);\r\n-                if (hasAuthority\r\n-                        || (output.size() > 0 && !\"..\".equals(output.get(output.size() - 1)))) {\r\n-                    // [].pop() doesn't fail, to replicate this we need to check\r\n-                    // that there is something to remove\r\n-                    if (output.size() > 0) {\r\n-                        output.remove(output.size() - 1);\r\n-                    }\r\n-                } else {\r\n-                    output.add(\"..\");\r\n-                }\r\n-                continue;\r\n-            }\r\n-            output.add(input.get(i));\r\n-            // input.remove(0);\r\n-        }\r\n-\r\n-        if (output.size() > 0) {\r\n-            rval += output.get(0);\r\n-            for (int i = 1; i < output.size(); i++) {\r\n-                rval += \"/\" + output.get(i);\r\n-            }\r\n-        }\r\n-        return rval;\r\n-    }\r\n-\r\n-    public static String removeBase(Object baseobj, String iri) {\r\n-        if (baseobj == null) {\r\n-            return iri;\r\n-        }\r\n-\r\n-        JsonLdUrl base;\r\n-        if (baseobj instanceof String) {\r\n-            base = JsonLdUrl.parse((String) baseobj);\r\n-        } else {\r\n-            base = (JsonLdUrl) baseobj;\r\n-        }\r\n-\r\n-        // establish base root\r\n-        String root = \"\";\r\n-        if (!\"\".equals(base.href)) {\r\n-            root += (base.protocol) + \"//\" + base.authority;\r\n-        }\r\n-        // support network-path reference with empty base\r\n-        else if (iri.indexOf(\"//\") != 0) {\r\n-            root += \"//\";\r\n-        }\r\n-\r\n-        // IRI not relative to base\r\n-        if (iri.indexOf(root) != 0) {\r\n-            return iri;\r\n-        }\r\n-\r\n-        // remove root from IRI and parse remainder\r\n-        final JsonLdUrl rel = JsonLdUrl.parse(iri.substring(root.length()));\r\n-\r\n-        // remove path segments that match\r\n-        final List<String> baseSegments = new ArrayList<String>(\r\n-                Arrays.asList(base.normalizedPath.split(\"/\")));\r\n-        if (base.normalizedPath.endsWith(\"/\")) {\r\n-            baseSegments.add(\"\");\r\n-        }\r\n-        final List<String> iriSegments = new ArrayList<String>(\r\n-                Arrays.asList(rel.normalizedPath.split(\"/\")));\r\n-        if (rel.normalizedPath.endsWith(\"/\")) {\r\n-            iriSegments.add(\"\");\r\n-        }\r\n-\r\n-        while (baseSegments.size() > 0 && iriSegments.size() > 0) {\r\n-            if (!baseSegments.get(0).equals(iriSegments.get(0))) {\r\n-                break;\r\n-            }\r\n-            if (baseSegments.size() > 0) {\r\n-                baseSegments.remove(0);\r\n-            }\r\n-            if (iriSegments.size() > 0) {\r\n-                iriSegments.remove(0);\r\n-            }\r\n-        }\r\n-\r\n-        // use '../' for each non-matching base segment\r\n-        String rval = \"\";\r\n-        if (baseSegments.size() > 0) {\r\n-            // don't count the last segment if it isn't a path (doesn't end in\r\n-            // '/')\r\n-            // don't count empty first segment, it means base began with '/'\r\n-            if (!base.normalizedPath.endsWith(\"/\") || \"\".equals(baseSegments.get(0))) {\r\n-                baseSegments.remove(baseSegments.size() - 1);\r\n-            }\r\n-            for (int i = 0; i < baseSegments.size(); ++i) {\r\n-                rval += \"../\";\r\n-            }\r\n-        }\r\n-\r\n-        // prepend remaining segments\r\n-        if (iriSegments.size() > 0) {\r\n-            rval += iriSegments.get(0);\r\n-        }\r\n-        for (int i = 1; i < iriSegments.size(); i++) {\r\n-            rval += \"/\" + iriSegments.get(i);\r\n-        }\r\n-\r\n-        // add query and hash\r\n-        if (!\"\".equals(rel.query)) {\r\n-            rval += \"?\" + rel.query;\r\n-        }\r\n-        if (!\"\".equals(rel.hash)) {\r\n-            rval += rel.hash;\r\n-        }\r\n-\r\n-        if (\"\".equals(rval)) {\r\n-            rval = \"./\";\r\n-        }\r\n-\r\n-        return rval;\r\n-    }\r\n-\r\n-    public static String resolve(String baseUri, String pathToResolve) {\r\n-        // TODO: some input will need to be normalized to perform the expected\r\n-        // result with java\r\n-        // TODO: we can do this without using java URI!\r\n-        if (baseUri == null) {\r\n-            return pathToResolve;\r\n-        }\r\n-        if (pathToResolve == null || \"\".equals(pathToResolve.trim())) {\r\n-            return baseUri;\r\n-        }\r\n-        try {\r\n-            URI uri = new URI(baseUri);\r\n-            // query string parsing\r\n-            if (pathToResolve.startsWith(\"?\")) {\r\n-                // drop fragment from uri if it has one\r\n-                if (uri.getFragment() != null) {\r\n-                    uri = new URI(uri.getScheme(), uri.getAuthority(), uri.getPath(), null, null);\r\n-                }\r\n-                // add query to the end manually (as URI.resolve does it wrong)\r\n-                return uri.toString() + pathToResolve;\r\n-            }\r\n-\r\n-            uri = uri.resolve(pathToResolve);\r\n-            // java doesn't discard unnecessary dot segments\r\n-            String path = uri.getPath();\r\n-            if (path != null) {\r\n-                path = JsonLdUrl.removeDotSegments(uri.getPath(), true);\r\n-            }\r\n-            return new URI(uri.getScheme(), uri.getAuthority(), path, uri.getQuery(),\r\n-                    uri.getFragment()).toString();\r\n-        } catch (final URISyntaxException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Parses the authority for the pre-parsed given JsonLdUrl.\r\n-     *\r\n-     * @param parsed\r\n-     *            the pre-parsed JsonLdUrl.\r\n-     */\r\n-    private static void parseAuthority(JsonLdUrl parsed) {\r\n-        // parse authority for unparsed relative network-path reference\r\n-        if (parsed.href.indexOf(\":\") == -1 && parsed.href.indexOf(\"//\") == 0\r\n-                && \"\".equals(parsed.host)) {\r\n-            // must parse authority from pathname\r\n-            parsed.pathname = parsed.pathname.substring(2);\r\n-            final int idx = parsed.pathname.indexOf(\"/\");\r\n-            if (idx == -1) {\r\n-                parsed.authority = parsed.pathname;\r\n-                parsed.pathname = \"\";\r\n-            } else {\r\n-                parsed.authority = parsed.pathname.substring(0, idx);\r\n-                parsed.pathname = parsed.pathname.substring(idx);\r\n-            }\r\n-        } else {\r\n-            // construct authority\r\n-            parsed.authority = parsed.host;\r\n-            if (!\"\".equals(parsed.auth)) {\r\n-                parsed.authority = parsed.auth + \"@\" + parsed.authority;\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n+package com.github.jsonldjava.utils;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class JsonLdUrl {\n+\n+    public String href = \"\";\n+    public String protocol = \"\";\n+    public String host = \"\";\n+    public String auth = \"\";\n+    public String user = \"\";\n+    public String password = \"\";\n+    public String hostname = \"\";\n+    public String port = \"\";\n+    public String relative = \"\";\n+    public String path = \"\";\n+    public String directory = \"\";\n+    public String file = \"\";\n+    public String query = \"\";\n+    public String hash = \"\";\n+\n+    // things not populated by the regex (NOTE: i don't think it matters if\n+    // these are null or \"\" to start with)\n+    public String pathname = null;\n+    public String normalizedPath = null;\n+    public String authority = null;\n+\n+    private static Pattern parser = Pattern.compile(\n+            \"^(?:([^:\\\\/?#]+):)?(?:\\\\/\\\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\\\/?#]*)(?::(\\\\d*))?))?((((?:[^?#\\\\/]*\\\\/)*)([^?#]*))(?:\\\\?([^#]*))?(?:#(.*))?)\");\n+\n+    public static JsonLdUrl parse(String url) {\n+        final JsonLdUrl rval = new JsonLdUrl();\n+        rval.href = url;\n+\n+        final Matcher matcher = parser.matcher(url);\n+        if (matcher.matches()) {\n+            if (matcher.group(1) != null) {\n+                rval.protocol = matcher.group(1);\n+            }\n+            if (matcher.group(2) != null) {\n+                rval.host = matcher.group(2);\n+            }\n+            if (matcher.group(3) != null) {\n+                rval.auth = matcher.group(3);\n+            }\n+            if (matcher.group(4) != null) {\n+                rval.user = matcher.group(4);\n+            }\n+            if (matcher.group(5) != null) {\n+                rval.password = matcher.group(5);\n+            }\n+            if (matcher.group(6) != null) {\n+                rval.hostname = matcher.group(6);\n+            }\n+            if (matcher.group(7) != null) {\n+                rval.port = matcher.group(7);\n+            }\n+            if (matcher.group(8) != null) {\n+                rval.relative = matcher.group(8);\n+            }\n+            if (matcher.group(9) != null) {\n+                rval.path = matcher.group(9);\n+            }\n+            if (matcher.group(10) != null) {\n+                rval.directory = matcher.group(10);\n+            }\n+            if (matcher.group(11) != null) {\n+                rval.file = matcher.group(11);\n+            }\n+            if (matcher.group(12) != null) {\n+                rval.query = matcher.group(12);\n+            }\n+            if (matcher.group(13) != null) {\n+                rval.hash = matcher.group(13);\n+            }\n+\n+            // normalize to node.js API\n+            if (!\"\".equals(rval.host) && \"\".equals(rval.path)) {\n+                rval.path = \"/\";\n+            }\n+            rval.pathname = rval.path;\n+            parseAuthority(rval);\n+            rval.normalizedPath = removeDotSegments(rval.pathname, !\"\".equals(rval.authority));\n+            if (!\"\".equals(rval.query)) {\n+                rval.path += \"?\" + rval.query;\n+            }\n+            if (!\"\".equals(rval.protocol)) {\n+                rval.protocol += \":\";\n+            }\n+            if (!\"\".equals(rval.hash)) {\n+                rval.hash = \"#\" + rval.hash;\n+            }\n+            return rval;\n+        }\n+\n+        return rval;\n+    }\n+\n+    /**\n+     * Removes dot segments from a JsonLdUrl path.\n+     *\n+     * @param path\n+     *            the path to remove dot segments from.\n+     * @param hasAuthority\n+     *            true if the JsonLdUrl has an authority, false if not.\n+     * @return The URL without the dot segments\n+     */\n+    public static String removeDotSegments(String path, boolean hasAuthority) {\n+        String rval = \"\";\n+\n+        if (path.indexOf(\"/\") == 0) {\n+            rval = \"/\";\n+        }\n+\n+        // RFC 3986 5.2.4 (reworked)\n+        final List<String> input = new ArrayList<String>(Arrays.asList(path.split(\"/\")));\n+        if (path.endsWith(\"/\")) {\n+            // javascript .split includes a blank entry if the string ends with\n+            // the delimiter, java .split does not so we need to add it manually\n+            input.add(\"\");\n+        }\n+        final List<String> output = new ArrayList<String>();\n+        for (int i = 0; i < input.size(); i++) {\n+            if (\".\".equals(input.get(i)) || (\"\".equals(input.get(i)) && input.size() - i > 1)) {\n+                // input.remove(0);\n+                continue;\n+            }\n+            if (\"..\".equals(input.get(i))) {\n+                // input.remove(0);\n+                if (hasAuthority\n+                        || (output.size() > 0 && !\"..\".equals(output.get(output.size() - 1)))) {\n+                    // [].pop() doesn't fail, to replicate this we need to check\n+                    // that there is something to remove\n+                    if (output.size() > 0) {\n+                        output.remove(output.size() - 1);\n+                    }\n+                } else {\n+                    output.add(\"..\");\n+                }\n+                continue;\n+            }\n+            output.add(input.get(i));\n+            // input.remove(0);\n+        }\n+\n+        if (output.size() > 0) {\n+            rval += output.get(0);\n+            for (int i = 1; i < output.size(); i++) {\n+                rval += \"/\" + output.get(i);\n+            }\n+        }\n+        return rval;\n+    }\n+\n+    public static String removeBase(Object baseobj, String iri) {\n+        if (baseobj == null) {\n+            return iri;\n+        }\n+\n+        JsonLdUrl base;\n+        if (baseobj instanceof String) {\n+            base = JsonLdUrl.parse((String) baseobj);\n+        } else {\n+            base = (JsonLdUrl) baseobj;\n+        }\n+\n+        // establish base root\n+        String root = \"\";\n+        if (!\"\".equals(base.href)) {\n+            root += (base.protocol) + \"//\" + base.authority;\n+        }\n+        // support network-path reference with empty base\n+        else if (iri.indexOf(\"//\") != 0) {\n+            root += \"//\";\n+        }\n+\n+        // IRI not relative to base\n+        if (iri.indexOf(root) != 0) {\n+            return iri;\n+        }\n+\n+        // remove root from IRI and parse remainder\n+        final JsonLdUrl rel = JsonLdUrl.parse(iri.substring(root.length()));\n+\n+        // remove path segments that match\n+        final List<String> baseSegments = new ArrayList<String>(\n+                Arrays.asList(base.normalizedPath.split(\"/\")));\n+        if (base.normalizedPath.endsWith(\"/\")) {\n+            baseSegments.add(\"\");\n+        }\n+        final List<String> iriSegments = new ArrayList<String>(\n+                Arrays.asList(rel.normalizedPath.split(\"/\")));\n+        if (rel.normalizedPath.endsWith(\"/\")) {\n+            iriSegments.add(\"\");\n+        }\n+\n+        while (baseSegments.size() > 0 && iriSegments.size() > 0) {\n+            if (!baseSegments.get(0).equals(iriSegments.get(0))) {\n+                break;\n+            }\n+            if (baseSegments.size() > 0) {\n+                baseSegments.remove(0);\n+            }\n+            if (iriSegments.size() > 0) {\n+                iriSegments.remove(0);\n+            }\n+        }\n+\n+        // use '../' for each non-matching base segment\n+        String rval = \"\";\n+        if (baseSegments.size() > 0) {\n+            // don't count the last segment if it isn't a path (doesn't end in\n+            // '/')\n+            // don't count empty first segment, it means base began with '/'\n+            if (!base.normalizedPath.endsWith(\"/\") || \"\".equals(baseSegments.get(0))) {\n+                baseSegments.remove(baseSegments.size() - 1);\n+            }\n+            for (int i = 0; i < baseSegments.size(); ++i) {\n+                rval += \"../\";\n+            }\n+        }\n+\n+        // prepend remaining segments\n+        if (iriSegments.size() > 0) {\n+            rval += iriSegments.get(0);\n+        }\n+        for (int i = 1; i < iriSegments.size(); i++) {\n+            rval += \"/\" + iriSegments.get(i);\n+        }\n+\n+        // add query and hash\n+        if (!\"\".equals(rel.query)) {\n+            rval += \"?\" + rel.query;\n+        }\n+        if (!\"\".equals(rel.hash)) {\n+            rval += rel.hash;\n+        }\n+\n+        if (\"\".equals(rval)) {\n+            rval = \"./\";\n+        }\n+\n+        return rval;\n+    }\n+\n+    public static String resolve(String baseUri, String pathToResolve) {\n+        // TODO: some input will need to be normalized to perform the expected\n+        // result with java\n+        // TODO: we can do this without using java URI!\n+        if (baseUri == null) {\n+            return pathToResolve;\n+        }\n+        if (pathToResolve == null || \"\".equals(pathToResolve.trim())) {\n+            return baseUri;\n+        }\n+        try {\n+            URI uri = new URI(baseUri);\n+            // URI#resolve drops base scheme for opaque URIs, https://github.com/jsonld-java/jsonld-java/issues/232\n+            if (uri.isOpaque()) {\n+                String basePath = uri.getPath() != null ? uri.getPath() : uri.getSchemeSpecificPart();\n+                // Drop the last segment, see https://tools.ietf.org/html/rfc3986#section-5.2.3 (2nd bullet point)\n+                basePath = basePath.contains(\"/\") ? basePath.substring(0, basePath.lastIndexOf('/') + 1) : \"\";\n+                return new URI(uri.getScheme(), basePath + pathToResolve, null).toString();\n+            }\n+            // \"a base URI [...] does not allow a fragment\" (https://tools.ietf.org/html/rfc3986#section-4.3)\n+            uri = new URI(uri.getScheme(), uri.getAuthority(), uri.getPath(), uri.getQuery(), null);\n+            // query string parsing\n+            if (pathToResolve.startsWith(\"?\")) {\n+                // drop query, https://tools.ietf.org/html/rfc3986#section-5.2.2: T.query = R.query;\n+                uri = new URI(uri.getScheme(), uri.getAuthority(), uri.getPath(), null, null);\n+                // add query to the end manually (as URI#resolve does it wrong)\n+                return uri.toString() + pathToResolve;\n+            } else if (pathToResolve.startsWith(\"#\")) {\n+                // add fragment to the end manually (as URI#resolve does it wrong)\n+                return uri.toString() + pathToResolve;\n+            }\n+            // ensure a slash between the authority and the path of a URL\n+            if (uri.getSchemeSpecificPart().startsWith(\"//\") && !uri.getSchemeSpecificPart().matches(\"//.*/.*\")) {\n+                uri = new URI(uri + \"/\");\n+            }\n+            uri = uri.resolve(pathToResolve);\n+            // java doesn't discard unnecessary dot segments\n+            String path = uri.getPath();\n+            if (path != null) {\n+                path = JsonLdUrl.removeDotSegments(path, true);\n+            }\n+            return new URI(uri.getScheme(), uri.getAuthority(), path, uri.getQuery(),\n+                    uri.getFragment()).toString();\n+        } catch (final URISyntaxException e) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parses the authority for the pre-parsed given JsonLdUrl.\n+     *\n+     * @param parsed\n+     *            the pre-parsed JsonLdUrl.\n+     */\n+    private static void parseAuthority(JsonLdUrl parsed) {\n+        // parse authority for unparsed relative network-path reference\n+        if (parsed.href.indexOf(\":\") == -1 && parsed.href.indexOf(\"//\") == 0\n+                && \"\".equals(parsed.host)) {\n+            // must parse authority from pathname\n+            parsed.pathname = parsed.pathname.substring(2);\n+            final int idx = parsed.pathname.indexOf(\"/\");\n+            if (idx == -1) {\n+                parsed.authority = parsed.pathname;\n+                parsed.pathname = \"\";\n+            } else {\n+                parsed.authority = parsed.pathname.substring(0, idx);\n+                parsed.pathname = parsed.pathname.substring(idx);\n+            }\n+        } else {\n+            // construct authority\n+            parsed.authority = parsed.host;\n+            if (!\"\".equals(parsed.auth)) {\n+                parsed.authority = parsed.auth + \"@\" + parsed.authority;\n+            }\n+        }\n+    }\n+}"
  },
  {
    "sha": "c24c84674e9d3e25d3af499c79bb6ac97ccee3ba",
    "filename": "core/src/main/java/com/github/jsonldjava/utils/JsonUtils.java",
    "status": "modified",
    "additions": 165,
    "deletions": 51,
    "changes": 216,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/utils/JsonUtils.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/main/java/com/github/jsonldjava/utils/JsonUtils.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/main/java/com/github/jsonldjava/utils/JsonUtils.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -9,31 +9,41 @@\n import java.io.StringWriter;\n import java.io.Writer;\n import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n import java.util.List;\n import java.util.Map;\n \n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.github.jsonldjava.core.DocumentLoader;\n+import com.github.jsonldjava.core.JsonLdApi;\n+import com.github.jsonldjava.core.JsonLdProcessor;\n+\n+import org.apache.commons.io.ByteOrderMark;\n import org.apache.commons.io.IOUtils;\n+import org.apache.commons.io.input.BOMInputStream;\n+import org.apache.http.Header;\n import org.apache.http.client.methods.CloseableHttpResponse;\n import org.apache.http.client.methods.HttpGet;\n import org.apache.http.client.methods.HttpUriRequest;\n import org.apache.http.client.protocol.RequestAcceptEncoding;\n import org.apache.http.client.protocol.ResponseContentEncoding;\n import org.apache.http.impl.client.CloseableHttpClient;\n import org.apache.http.impl.client.DefaultRedirectStrategy;\n+import org.apache.http.impl.client.HttpClientBuilder;\n import org.apache.http.impl.client.cache.BasicHttpCacheStorage;\n import org.apache.http.impl.client.cache.CacheConfig;\n import org.apache.http.impl.client.cache.CachingHttpClientBuilder;\n-\n-import com.fasterxml.jackson.core.JsonFactory;\n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.core.JsonParseException;\n-import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonToken;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.github.jsonldjava.core.JsonLdApi;\n-import com.github.jsonldjava.core.JsonLdProcessor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Functions used to make loading, parsing, and serializing JSON easy using\n@@ -47,9 +57,22 @@\n      * An HTTP Accept header that prefers JSONLD.\n      */\n     public static final String ACCEPT_HEADER = \"application/ld+json, application/json;q=0.9, application/javascript;q=0.5, text/javascript;q=0.5, text/plain;q=0.2, */*;q=0.1\";\n+\n+    /**\n+     * The user agent used by the default {@link CloseableHttpClient}.\n+     *\n+     * This will not be used if\n+     * {@link DocumentLoader#setHttpClient(CloseableHttpClient)} is called with\n+     * a custom client.\n+     */\n+    public static final String JSONLD_JAVA_USER_AGENT = \"JSONLD-Java\";\n+\n     private static final ObjectMapper JSON_MAPPER = new ObjectMapper();\n     private static final JsonFactory JSON_FACTORY = new JsonFactory(JSON_MAPPER);\n+\n     private static volatile CloseableHttpClient DEFAULT_HTTP_CLIENT;\n+    // Avoid possible endless loop when following alternate locations\n+    private static final int MAX_LINKS_FOLLOW = 20;\n \n     static {\n         // Disable default Jackson behaviour to close\n@@ -77,8 +100,27 @@\n      *             If there was an IO error during parsing.\n      */\n     public static Object fromInputStream(InputStream input) throws IOException {\n-        // no readers from inputstreams w.o. encoding!!\n-        return fromInputStream(input, \"UTF-8\");\n+        // filter BOMs from InputStream\n+        try (final BOMInputStream bOMInputStream = new BOMInputStream(input, false,\n+                ByteOrderMark.UTF_8, ByteOrderMark.UTF_16BE, ByteOrderMark.UTF_16LE,\n+                ByteOrderMark.UTF_32BE, ByteOrderMark.UTF_32LE);) {\n+            Charset charset = StandardCharsets.UTF_8;\n+            // Attempt to use the BOM if it exists\n+            if (bOMInputStream.hasBOM()) {\n+                try {\n+                    charset = Charset.forName(bOMInputStream.getBOMCharsetName());\n+                } catch (final IllegalArgumentException e) {\n+                    // If there are any issues with the BOM charset, attempt to\n+                    // parse with UTF_8\n+                    charset = StandardCharsets.UTF_8;\n+                }\n+            }\n+            return fromInputStream(bOMInputStream, charset);\n+        } finally {\n+            if (input != null) {\n+                input.close();\n+            }\n+        }\n     }\n \n     /**\n@@ -98,6 +140,26 @@ public static Object fromInputStream(InputStream input) throws IOException {\n      *             If there was an IO error during parsing.\n      */\n     public static Object fromInputStream(InputStream input, String enc) throws IOException {\n+        return fromInputStream(input, Charset.forName(enc));\n+    }\n+\n+    /**\n+     * Parses a JSON-LD document from the given {@link InputStream} to an object\n+     * that can be used as input for the {@link JsonLdApi} and\n+     * {@link JsonLdProcessor} methods.\n+     *\n+     * @param input\n+     *            The JSON-LD document in an InputStream.\n+     * @param enc\n+     *            The character encoding to use when interpreting the characters\n+     *            in the InputStream.\n+     * @return A JSON Object.\n+     * @throws JsonParseException\n+     *             If there was a JSON related error during parsing.\n+     * @throws IOException\n+     *             If there was an IO error during parsing.\n+     */\n+    public static Object fromInputStream(InputStream input, Charset enc) throws IOException {\n         try (InputStreamReader in = new InputStreamReader(input, enc);\n                 BufferedReader reader = new BufferedReader(in);) {\n             return fromReader(reader);\n@@ -123,8 +185,8 @@ public static Object fromReader(Reader reader) throws IOException {\n     }\n \n     /**\n-     * Parses a JSON-LD document from the given {@link JsonParser} to an object that\n-     * can be used as input for the {@link JsonLdApi} and\n+     * Parses a JSON-LD document from the given {@link JsonParser} to an object\n+     * that can be used as input for the {@link JsonLdApi} and\n      * {@link JsonLdProcessor} methods.\n      *\n      * @param jp\n@@ -284,33 +346,69 @@ public static Object fromURL(java.net.URL url, CloseableHttpClient httpClient)\n         final String protocol = url.getProtocol();\n         // We can only use the Apache HTTPClient for HTTP/HTTPS, so use the\n         // native java client for the others\n-        InputStream in = null;\n-        try {\n-            if (!protocol.equalsIgnoreCase(\"http\") && !protocol.equalsIgnoreCase(\"https\")) {\n-                // Can't use the HTTP client for those!\n-                // Fallback to Java's built-in JsonLdUrl handler. No need for\n-                // Accept headers as it's likely to be file: or jar:\n-                in = url.openStream();\n-            } else {\n-                final HttpUriRequest request = new HttpGet(url.toExternalForm());\n-                // We prefer application/ld+json, but fallback to\n-                // application/json\n-                // or whatever is available\n-                request.addHeader(\"Accept\", ACCEPT_HEADER);\n-\n-                final CloseableHttpResponse response = httpClient.execute(request);\n-                final int status = response.getStatusLine().getStatusCode();\n-                if (status != 200 && status != 203) {\n-                    throw new IOException(\"Can't retrieve \" + url + \", status code: \" + status);\n+        if (!protocol.equalsIgnoreCase(\"http\") && !protocol.equalsIgnoreCase(\"https\")) {\n+            // Can't use the HTTP client for those!\n+            // Fallback to Java's built-in JsonLdUrl handler. No need for\n+            // Accept headers as it's likely to be file: or jar:\n+            return fromInputStream(url.openStream());\n+        } else {\n+            return fromJsonLdViaHttpUri(url, httpClient, 0);\n+        }\n+    }\n+\n+    private static Object fromJsonLdViaHttpUri(final URL url, final CloseableHttpClient httpClient, int linksFollowed)\n+            throws IOException {\n+        final HttpUriRequest request = new HttpGet(url.toExternalForm());\n+        // We prefer application/ld+json, but fallback to application/json\n+        // or whatever is available\n+        request.addHeader(\"Accept\", ACCEPT_HEADER);\n+        try (CloseableHttpResponse response = httpClient.execute(request)) {\n+            final int status = response.getStatusLine().getStatusCode();\n+            if (status != 200 && status != 203) {\n+                throw new IOException(\"Can't retrieve \" + url + \", status code: \" + status);\n+            }\n+            // follow alternate document location\n+            // https://www.w3.org/TR/json-ld11/#alternate-document-location\n+            URL alternateLink = alternateLink(url, response);\n+            if (alternateLink != null) {\n+                linksFollowed++;\n+                if (linksFollowed > MAX_LINKS_FOLLOW) {\n+                    throw new IOException(\"Too many alternate links followed. This may indicate a cycle. Aborting.\");\n                 }\n-                in = response.getEntity().getContent();\n+                return fromJsonLdViaHttpUri(alternateLink, httpClient, linksFollowed);\n             }\n-            return fromInputStream(in);\n-        } finally {\n-            if (in != null) {\n-                in.close();\n+            return fromInputStream(response.getEntity().getContent());\n+        }\n+    }\n+\n+    private static URL alternateLink(URL url, CloseableHttpResponse response)\n+            throws MalformedURLException {\n+        if (response.getEntity().getContentType() != null\n+                && !response.getEntity().getContentType().getValue().equals(\"application/ld+json\")) {\n+            for (Header header : response.getAllHeaders()) {\n+                if (header.getName().equalsIgnoreCase(\"link\")) {\n+                    String alternateLink = \"\";\n+                    boolean relAlternate = false;\n+                    boolean jsonld = false;\n+                    for (String value : header.getValue().split(\";\")) {\n+                        value=value.trim();\n+                        if (value.startsWith(\"<\") && value.endsWith(\">\")) {\n+                            alternateLink = value.substring(1, value.length() - 1);\n+                        }\n+                        if (value.startsWith(\"type=\\\"application/ld+json\\\"\")) {\n+                            jsonld = true;\n+                        }\n+                        if (value.startsWith(\"rel=\\\"alternate\\\"\")) {\n+                            relAlternate = true;\n+                        }\n+                    }\n+                    if (jsonld && relAlternate && !alternateLink.isEmpty()) {\n+                        return new URL(url.getProtocol() + \"://\" + url.getAuthority() + alternateLink);\n+                    }\n+                }\n             }\n         }\n+        return null;\n     }\n \n     /**\n@@ -326,17 +424,14 @@ public static Object fromURL(java.net.URL url, CloseableHttpClient httpClient)\n      * @throws IOException\n      *             If there was an IO error during parsing.\n      */\n-    public static Object fromURLJavaNet(java.net.URL url) throws JsonParseException, IOException {\n+    public static Object fromURLJavaNet(URL url) throws JsonParseException, IOException {\n         final HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();\n         urlConn.addRequestProperty(\"Accept\", ACCEPT_HEADER);\n \n-        final InputStream directStream = urlConn.getInputStream();\n-\n         final StringWriter output = new StringWriter();\n-        try {\n-            IOUtils.copy(directStream, output, Charset.forName(\"UTF-8\"));\n+        try (final InputStream directStream = urlConn.getInputStream();) {\n+            IOUtils.copy(directStream, output, StandardCharsets.UTF_8);\n         } finally {\n-            directStream.close();\n             output.flush();\n         }\n         final Object context = JsonUtils.fromReader(new StringReader(output.toString()));\n@@ -356,26 +451,45 @@ public static CloseableHttpClient getDefaultHttpClient() {\n         return result;\n     }\n \n-    private static CloseableHttpClient createDefaultHttpClient() {\n+    public static CloseableHttpClient createDefaultHttpClient() {\n+        final CacheConfig cacheConfig = createDefaultCacheConfig();\n+\n+        final CloseableHttpClient result = createDefaultHttpClient(cacheConfig);\n+\n+        return result;\n+    }\n+\n+    public static CacheConfig createDefaultCacheConfig() {\n+        return CacheConfig.custom().setMaxCacheEntries(500).setMaxObjectSize(1024 * 256)\n+                .setSharedCache(false).setHeuristicCachingEnabled(true)\n+                .setHeuristicDefaultLifetime(86400).build();\n+    }\n+\n+    public static CloseableHttpClient createDefaultHttpClient(final CacheConfig cacheConfig) {\n+        return createDefaultHttpClientBuilder(cacheConfig).build();\n+    }\n+\n+    public static HttpClientBuilder createDefaultHttpClientBuilder(final CacheConfig cacheConfig) {\n         // Common CacheConfig for both the JarCacheStorage and the underlying\n         // BasicHttpCacheStorage\n-        final CacheConfig cacheConfig = CacheConfig.custom().setMaxCacheEntries(1000)\n-                .setMaxObjectSize(1024 * 128).build();\n-\n-        final CloseableHttpClient result = CachingHttpClientBuilder.create()\n+        return CachingHttpClientBuilder.create()\n                 // allow caching\n                 .setCacheConfig(cacheConfig)\n                 // Wrap the local JarCacheStorage around a BasicHttpCacheStorage\n                 .setHttpCacheStorage(new JarCacheStorage(null, cacheConfig,\n                         new BasicHttpCacheStorage(cacheConfig)))\n                 // Support compressed data\n-                // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/httpagent.html#d5e1238\n+                // https://wayback.archive.org/web/20130901115452/http://hc.apache.org:80/httpcomponents-client-ga/tutorial/html/httpagent.html#d5e1238\n                 .addInterceptorFirst(new RequestAcceptEncoding())\n                 .addInterceptorFirst(new ResponseContentEncoding())\n                 .setRedirectStrategy(DefaultRedirectStrategy.INSTANCE)\n+                // User agent customisation\n+                .setUserAgent(JSONLD_JAVA_USER_AGENT)\n                 // use system defaults for proxy etc.\n-                .useSystemProperties().build();\n+                .useSystemProperties();\n+    }\n \n-        return result;\n+    private JsonUtils() {\n+        // Static class, no access to constructor\n     }\n }"
  },
  {
    "sha": "31bfc3efdbae1624c2c00a1bfbe579143000de1c",
    "filename": "core/src/test/java/com/github/jsonldjava/core/ContextCompactionTest.java",
    "status": "modified",
    "additions": 20,
    "deletions": 10,
    "changes": 30,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/test/java/com/github/jsonldjava/core/ContextCompactionTest.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/test/java/com/github/jsonldjava/core/ContextCompactionTest.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/test/java/com/github/jsonldjava/core/ContextCompactionTest.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -1,22 +1,21 @@\n package com.github.jsonldjava.core;\n \n+import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n-\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n \n+import com.github.jsonldjava.utils.JsonUtils;\n import org.junit.Test;\n \n-import com.github.jsonldjava.utils.JsonUtils;\n \n public class ContextCompactionTest {\n \n-    // @Ignore(\"Disable until schema.org is fixed\")\n     @Test\n-    public void testCompaction() throws Exception {\n+    public void testCompaction() {\n \n         final Map<String, Object> contextAbbrevs = new HashMap<String, Object>();\n         contextAbbrevs.put(\"so\", \"http://schema.org/\");\n@@ -36,19 +35,30 @@ public void testCompaction() throws Exception {\n         options.setBase(\"http://schema.org/\");\n         options.setCompactArrays(true);\n \n-        // System.out.println(\"Before compact\");\n-        // System.out.println(JsonUtils.toPrettyString(json));\n-\n         final List<String> newContexts = new LinkedList<String>();\n         newContexts.add(\"http://schema.org/\");\n         final Map<String, Object> compacted = JsonLdProcessor.compact(json, newContexts, options);\n \n-        // System.out.println(\"\\n\\nAfter compact:\");\n-        // System.out.println(JsonUtils.toPrettyString(compacted));\n-\n         assertTrue(\"Compaction removed the context\", compacted.containsKey(\"@context\"));\n         assertFalse(\"Compaction of context should be a string, not a list\",\n                 compacted.get(\"@context\") instanceof List);\n     }\n \n+    @Test\n+    public void testCompactionSingleRemoteContext() throws Exception {\n+        final String jsonString = \"[{\\\"@type\\\": [\\\"http://schema.org/Person\\\"] } ]\";\n+        final String ctxStr = \"{\\\"@context\\\": \\\"http://schema.org/\\\"}\";\n+\n+        final Object json = JsonUtils.fromString(jsonString);\n+        final Object ctx = JsonUtils.fromString(ctxStr);\n+\n+        final JsonLdOptions options = new JsonLdOptions();\n+\n+        final Map<String, Object> compacted = JsonLdProcessor.compact(json, ctx, options);\n+\n+        assertEquals(\"Wrong returned context\", \"http://schema.org/\", compacted.get(\"@context\"));\n+        assertEquals(\"Wrong type\", \"Person\", compacted.get(\"type\"));\n+        assertEquals(\"Wrong number of Json entries\",2, compacted.size());\n+    }\n+\n }"
  },
  {
    "sha": "8e3a171088313406d15303efc0e4df162a4e2d5a",
    "filename": "core/src/test/java/com/github/jsonldjava/core/ContextFlatteningTest.java",
    "status": "added",
    "additions": 66,
    "deletions": 0,
    "changes": 66,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/test/java/com/github/jsonldjava/core/ContextFlatteningTest.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/test/java/com/github/jsonldjava/core/ContextFlatteningTest.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/test/java/com/github/jsonldjava/core/ContextFlatteningTest.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -0,0 +1,66 @@\n+package com.github.jsonldjava.core;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.github.jsonldjava.utils.JsonUtils;\n+import org.junit.Test;\n+\n+public class ContextFlatteningTest {\n+\n+    @Test\n+    public void testFlatenning() throws Exception {\n+\n+        final Map<String, Object> contextAbbrevs = new HashMap<>();\n+        contextAbbrevs.put(\"so\", \"http://schema.org/\");\n+\n+        final Map<String, Object> json = new HashMap<>();\n+        json.put(\"@context\", contextAbbrevs);\n+        json.put(\"@id\", \"http://example.org/my_work\");\n+\n+        final List<Object> types = new LinkedList<>();\n+        types.add(\"so:CreativeWork\");\n+\n+        json.put(\"@type\", types);\n+        json.put(\"so:name\", \"My Work\");\n+        json.put(\"so:url\", \"http://example.org/my_work\");\n+\n+        final JsonLdOptions options = new JsonLdOptions();\n+        options.setBase(\"http://schema.org/\");\n+        options.setCompactArrays(true);\n+        options.setOmitGraph(true);\n+\n+        final String flattenStr = \"{\\\"@id\\\": \\\"http://schema.org/myid\\\", \\\"@context\\\": \\\"http://schema.org/\\\"}\";\n+        final Object flatten = JsonUtils.fromString(flattenStr);\n+\n+        final Map<String, Object> flattened = ((Map<String, Object>)JsonLdProcessor.flatten(json, flatten, options));\n+\n+        assertTrue(\"Flattening removed the context\", flattened.containsKey(\"@context\"));\n+        assertFalse(\"Flattening of context should be a string, not a list\",\n+                flattened.get(\"@context\") instanceof List);\n+    }\n+\n+    @Test\n+    public void testFlatteningRemoteContext() throws Exception {\n+        final String jsonString =\n+                \"{\\\"@context\\\": {\\\"@vocab\\\": \\\"http://schema.org/\\\"}, \\\"knows\\\": [{\\\"name\\\": \\\"a\\\"}, {\\\"name\\\": \\\"b\\\"}] }\";\n+        final String flattenStr = \"{\\\"@context\\\": \\\"http://schema.org/\\\"}\";\n+\n+        final Object json = JsonUtils.fromString(jsonString);\n+        final Object flatten = JsonUtils.fromString(flattenStr);\n+\n+        final JsonLdOptions options = new JsonLdOptions();\n+        options.setOmitGraph(true);\n+\n+        final Map<String, Object> flattened = ((Map<String, Object>)JsonLdProcessor.flatten(json, flatten, options));\n+\n+        assertEquals(\"Wrong returned context\", \"http://schema.org/\", flattened.get(\"@context\"));\n+        assertEquals(\"Wrong number of Json entries\",2, flattened.size());\n+    }\n+\n+}"
  },
  {
    "sha": "73116205cd0b44eaa0ab4a362c704c45d821b937",
    "filename": "core/src/test/java/com/github/jsonldjava/core/ContextFramingTest.java",
    "status": "added",
    "additions": 67,
    "deletions": 0,
    "changes": 67,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/test/java/com/github/jsonldjava/core/ContextFramingTest.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/test/java/com/github/jsonldjava/core/ContextFramingTest.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/test/java/com/github/jsonldjava/core/ContextFramingTest.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -0,0 +1,67 @@\n+package com.github.jsonldjava.core;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.github.jsonldjava.utils.JsonUtils;\n+import org.junit.Test;\n+\n+public class ContextFramingTest {\n+\n+    @Test\n+    public void testFraming() throws Exception {\n+\n+        final Map<String, Object> contextAbbrevs = new HashMap<>();\n+        contextAbbrevs.put(\"so\", \"http://schema.org/\");\n+\n+        final Map<String, Object> json = new HashMap<>();\n+        json.put(\"@context\", contextAbbrevs);\n+        json.put(\"@id\", \"http://example.org/my_work\");\n+\n+        final List<Object> types = new LinkedList<>();\n+        types.add(\"so:CreativeWork\");\n+\n+        json.put(\"@type\", types);\n+        json.put(\"so:name\", \"My Work\");\n+        json.put(\"so:url\", \"http://example.org/my_work\");\n+\n+        final JsonLdOptions options = new JsonLdOptions();\n+        options.setBase(\"http://schema.org/\");\n+        options.setCompactArrays(true);\n+        options.setOmitGraph(true);\n+\n+        final String frameStr = \"{\\\"@id\\\": \\\"http://schema.org/myid\\\", \\\"@context\\\": \\\"http://schema.org/\\\"}\";\n+        final Object frame = JsonUtils.fromString(frameStr);\n+\n+        final Map<String, Object> framed = JsonLdProcessor.frame(json, frame, options);\n+\n+        assertTrue(\"Framing removed the context\", framed.containsKey(\"@context\"));\n+        assertFalse(\"Framing of context should be a string, not a list\",\n+                framed.get(\"@context\") instanceof List);\n+    }\n+\n+    @Test\n+    public void testFramingRemoteContext() throws Exception {\n+        final String jsonString = \"{\\\"@id\\\": \\\"http://schema.org/myid\\\", \\\"@type\\\": [\\\"http://schema.org/Person\\\"]}\";\n+        final String frameStr = \"{\\\"@id\\\": \\\"http://schema.org/myid\\\", \\\"@context\\\": \\\"http://schema.org/\\\"}\";\n+\n+        final Object json = JsonUtils.fromString(jsonString);\n+        final Object frame = JsonUtils.fromString(frameStr);\n+\n+        final JsonLdOptions options = new JsonLdOptions();\n+        options.setOmitGraph(true);\n+\n+        final Map<String, Object> framed = JsonLdProcessor.frame(json, frame, options);\n+\n+        assertEquals(\"Wrong returned context\", \"http://schema.org/\", framed.get(\"@context\"));\n+        assertEquals(\"Wrong id\", \"schema:myid\", framed.get(\"id\"));\n+        assertEquals(\"Wrong type\", \"Person\", framed.get(\"type\"));\n+        assertEquals(\"Wrong number of Json entries\",3, framed.size());\n+    }\n+\n+}"
  },
  {
    "sha": "d661012171c7eaa55face3aef9500e5e2555fcb9",
    "filename": "core/src/test/java/com/github/jsonldjava/core/ContextRecursionTest.java",
    "status": "added",
    "additions": 75,
    "deletions": 0,
    "changes": 75,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/test/java/com/github/jsonldjava/core/ContextRecursionTest.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/test/java/com/github/jsonldjava/core/ContextRecursionTest.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/test/java/com/github/jsonldjava/core/ContextRecursionTest.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -0,0 +1,75 @@\n+package com.github.jsonldjava.core;\n+\n+import com.github.jsonldjava.utils.JsonUtils;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+\n+public class ContextRecursionTest {\n+\n+    @BeforeClass\n+    public static void setup() {\n+        System.setProperty(DocumentLoader.DISALLOW_REMOTE_CONTEXT_LOADING, \"true\");\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() {\n+        System.setProperty(DocumentLoader.DISALLOW_REMOTE_CONTEXT_LOADING, \"false\");\n+    }\n+\n+    @Test\n+    public void testIssue302_allowedRecursion() throws IOException {\n+\n+        final String contextB = \"{\\\"@context\\\": [\\\"http://localhost/d\\\", {\\\"b\\\": \\\"http://localhost/b\\\"} ] }\";\n+        final String contextC = \"{\\\"@context\\\": [\\\"http://localhost/d\\\", {\\\"c\\\": \\\"http://localhost/c\\\"} ] }\";\n+        final String contextD = \"{\\\"@context\\\": [\\\"http://localhost/e\\\", {\\\"d\\\": \\\"http://localhost/d\\\"} ] }\";\n+        final String contextE = \"{\\\"@context\\\": {\\\"e\\\": \\\"http://localhost/e\\\"} }\";\n+\n+        final DocumentLoader dl = new DocumentLoader();\n+        dl.addInjectedDoc(\"http://localhost/b\", contextB);\n+        dl.addInjectedDoc(\"http://localhost/c\", contextC);\n+        dl.addInjectedDoc(\"http://localhost/d\", contextD);\n+        dl.addInjectedDoc(\"http://localhost/e\", contextE);\n+        final JsonLdOptions options = new JsonLdOptions();\n+        options.setDocumentLoader(dl);\n+\n+        final String jsonString = \"{\\\"@context\\\": [\\\"http://localhost/d\\\", \\\"http://localhost/b\\\", \\\"http://localhost/c\\\", {\\\"a\\\": \\\"http://localhost/a\\\"} ], \\\"a\\\": \\\"A\\\", \\\"b\\\": \\\"B\\\", \\\"c\\\": \\\"C\\\", \\\"d\\\": \\\"D\\\"}\";\n+        final Object json = JsonUtils.fromString(jsonString);\n+        final Object expanded = JsonLdProcessor.expand(json, options);\n+        assertEquals(\n+                \"[{http://localhost/a=[{@value=A}], http://localhost/b=[{@value=B}], http://localhost/c=[{@value=C}], http://localhost/d=[{@value=D}]}]\",\n+                expanded.toString());\n+    }\n+\n+    @Test\n+    public void testCyclicRecursion() throws IOException {\n+\n+        final String contextC = \"{\\\"@context\\\": [\\\"http://localhost/d\\\", {\\\"c\\\": \\\"http://localhost/c\\\"} ] }\";\n+        final String contextD = \"{\\\"@context\\\": [\\\"http://localhost/e\\\", {\\\"d\\\": \\\"http://localhost/d\\\"} ] }\";\n+        final String contextE = \"{\\\"@context\\\": [\\\"http://localhost/c\\\", {\\\"e\\\": \\\"http://localhost/e\\\"} ] }\";\n+\n+        final DocumentLoader dl = new DocumentLoader();\n+        dl.addInjectedDoc(\"http://localhost/c\", contextC);\n+        dl.addInjectedDoc(\"http://localhost/d\", contextD);\n+        dl.addInjectedDoc(\"http://localhost/e\", contextE);\n+        final JsonLdOptions options = new JsonLdOptions();\n+        options.setDocumentLoader(dl);\n+\n+        final String jsonString = \"{\\\"@context\\\": [\\\"http://localhost/c\\\", {\\\"a\\\": \\\"http://localhost/a\\\"} ]}\";\n+        final Object json = JsonUtils.fromString(jsonString);\n+        try {\n+            JsonLdProcessor.expand(json, options);\n+            fail(\"it should throw\");\n+        } catch(JsonLdError err) {\n+            assertEquals(JsonLdError.Error.RECURSIVE_CONTEXT_INCLUSION, err.getType());\n+            assertEquals(\"recursive context inclusion: http://localhost/c\", err.getMessage());\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "7077f228173f78c50f9f9a50ae20cb02b9e9a981",
    "filename": "core/src/test/java/com/github/jsonldjava/core/ContextSerializationTest.java",
    "status": "added",
    "additions": 24,
    "deletions": 0,
    "changes": 24,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/test/java/com/github/jsonldjava/core/ContextSerializationTest.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/test/java/com/github/jsonldjava/core/ContextSerializationTest.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/test/java/com/github/jsonldjava/core/ContextSerializationTest.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -0,0 +1,24 @@\n+package com.github.jsonldjava.core;\n+\n+import com.github.jsonldjava.utils.JsonUtils;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class ContextSerializationTest {\n+\n+    @Test\n+    // Added in order to have some coverage on the serialize method since is not used anywhere.\n+    public void serializeTest() throws IOException {\n+        final Map<String, Object> json = (Map<String, Object>)JsonUtils\n+                .fromInputStream(getClass().getResourceAsStream(\"/custom/contexttest-0005.jsonld\"));\n+\n+        final Map<String, Object> contextValue = (Map<String, Object>)json.get(JsonLdConsts.CONTEXT);\n+        final Map<String, Object> serializedContext = new Context().parse(contextValue).serialize();\n+\n+        assertEquals(\"Wrong serialized context\", json, serializedContext);\n+    }\n+}"
  },
  {
    "sha": "2fab52c1cf8578dd94e76221a961602a9aaa62e5",
    "filename": "core/src/test/java/com/github/jsonldjava/core/ContextTest.java",
    "status": "modified",
    "additions": 70,
    "deletions": 0,
    "changes": 70,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/test/java/com/github/jsonldjava/core/ContextTest.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/test/java/com/github/jsonldjava/core/ContextTest.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/test/java/com/github/jsonldjava/core/ContextTest.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -1,11 +1,81 @@\n package com.github.jsonldjava.core;\n \n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n import org.junit.Test;\n \n+import com.google.common.collect.ImmutableMap;\n+\n public class ContextTest {\n \n     @Test\n     public void testRemoveBase() {\n         // TODO: test if Context.removeBase actually works\n     }\n+\n+    // See https://github.com/jsonld-java/jsonld-java/issues/141\n+\n+    @Test(expected = JsonLdError.class)\n+    public void testIssue141_errorOnEmptyKey_compact() {\n+        JsonLdProcessor.compact(ImmutableMap.of(), ImmutableMap.of(\"\", \"http://example.com\"),\n+                new JsonLdOptions());\n+    }\n+\n+    @Test(expected = JsonLdError.class)\n+    public void testIssue141_errorOnEmptyKey_expand() {\n+        JsonLdProcessor.expand(\n+                ImmutableMap.of(\"@context\", ImmutableMap.of(\"\", \"http://example.com\")),\n+                new JsonLdOptions());\n+    }\n+\n+    @Test(expected = JsonLdError.class)\n+    public void testIssue141_errorOnEmptyKey_newContext1() {\n+        new Context(ImmutableMap.of(\"\", \"http://example.com\"));\n+    }\n+\n+    @Test(expected = JsonLdError.class)\n+    public void testIssue141_errorOnEmptyKey_newContext2() {\n+        new Context(ImmutableMap.of(\"\", \"http://example.com\"), new JsonLdOptions());\n+    }\n+\n+    /*\n+     * schema.org documentation says some properties can be either Text or URL,\n+     * but sets `@type : @id` in the context, e.g. for\n+     * https://schema.org/roleName:\n+     */\n+    Map<String, Object> schemaOrg = ImmutableMap.of(\"roleName\",\n+            ImmutableMap.of(\"@id\", \"http://schema.org/roleName\", \"@type\", \"@id\"));\n+\n+    // See https://github.com/jsonld-java/jsonld-java/issues/248\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testIssue248_uriExpected() {\n+        JsonLdProcessor\n+                .expand(ImmutableMap.of(\"roleName\", \"Production Company\", \"@context\", schemaOrg));\n+    }\n+\n+    @Test\n+    public void testIssue248_forceValue() {\n+        final List<?> value = Arrays.asList(ImmutableMap.of(\"@value\", \"Production Company\"));\n+        final Map<String, Object> input = ImmutableMap.of(\"roleName\", value, \"@context\", schemaOrg);\n+        final Object output = JsonLdProcessor.expand(input);\n+        assertEquals(\"[{http://schema.org/roleName=[{@value=Production Company}]}]\",\n+                output.toString());\n+    }\n+\n+    @Test\n+    public void testIssue248_overrideContext() {\n+        final List<?> context = Arrays.asList(schemaOrg,\n+                ImmutableMap.of(\"roleName\", ImmutableMap.of(\"@id\", \"http://schema.org/roleName\")));\n+        final Map<String, Object> input = ImmutableMap.of(\"roleName\", \"Production Company\",\n+                \"@context\", context);\n+        final Object output = JsonLdProcessor.expand(input);\n+        assertEquals(\"[{http://schema.org/roleName=[{@value=Production Company}]}]\",\n+                output.toString());\n+    }\n+\n }"
  },
  {
    "sha": "0e05921a8e28d8e96a280061a06cb2f8a93a6284",
    "filename": "core/src/test/java/com/github/jsonldjava/core/DecimalLiteralCanonicalTest.java",
    "status": "added",
    "additions": 34,
    "deletions": 0,
    "changes": 34,
    "blob_url": "https://github.com/dr0i/jsonld-java/blob/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/test/java/com/github/jsonldjava/core/DecimalLiteralCanonicalTest.java",
    "raw_url": "https://github.com/dr0i/jsonld-java/raw/b2a8ac68ae85b5f304ce930d161e8d686780996c/core/src/test/java/com/github/jsonldjava/core/DecimalLiteralCanonicalTest.java",
    "contents_url": "https://api.github.com/repos/dr0i/jsonld-java/contents/core/src/test/java/com/github/jsonldjava/core/DecimalLiteralCanonicalTest.java?ref=b2a8ac68ae85b5f304ce930d161e8d686780996c",
    "patch": "@@ -0,0 +1,34 @@\n+package com.github.jsonldjava.core;\n+\n+import org.junit.Test;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DecimalLiteralCanonicalTest {\n+    \n+    @Test\n+    public void testDecimalIsNotCanonicalized() {\n+        double value = 6.5;\n+        \n+        Map<String, Object> innerMap = new HashMap<>();\n+        innerMap.put(\"@value\", value);\n+        innerMap.put(\"@type\", \"http://www.w3.org/2001/XMLSchema#decimal\");\n+        \n+        Map<String, Object> jsonMap = new HashMap<>();\n+        jsonMap.put(\"ex:id\", innerMap);\n+        \n+        JsonLdApi api = new JsonLdApi(jsonMap, new JsonLdOptions(\"\"));\n+        RDFDataset dataset = api.toRDF();\n+        \n+        List<Object> defaultList = (List<Object>) dataset.get(\"@default\");\n+        Map<String, Object> tripleMap = (Map<String, Object>) defaultList.get(0);\n+        Map<String, String> objectMap = (Map<String, String>) tripleMap.get(\"object\");\n+        \n+        assertEquals(\"http://www.w3.org/2001/XMLSchema#decimal\", objectMap.get(\"datatype\"));\n+        assertEquals(Double.toString(value), objectMap.get(\"value\"));\n+    }\n+}"
  }
]
