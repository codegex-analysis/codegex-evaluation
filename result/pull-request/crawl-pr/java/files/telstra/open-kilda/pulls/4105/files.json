[
  {
    "sha": "5e95ea96bcf53f722a9517aa76bef7462f8b4170",
    "filename": "src-java/blue-green/src/main/java/org/openkilda/bluegreen/ZkClient.java",
    "status": "modified",
    "additions": 1,
    "deletions": 2,
    "changes": 3,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/blue-green/src/main/java/org/openkilda/bluegreen/ZkClient.java",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/blue-green/src/main/java/org/openkilda/bluegreen/ZkClient.java",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/blue-green/src/main/java/org/openkilda/bluegreen/ZkClient.java?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -32,7 +32,6 @@\n import org.apache.zookeeper.ZooKeeper;\n \n import java.io.IOException;\n-import java.nio.file.Paths;\n import java.time.Instant;\n import java.time.temporal.ChronoUnit;\n import java.util.concurrent.TimeUnit;\n@@ -136,7 +135,7 @@ void init() {\n     }\n \n     String getPaths(String... paths) {\n-        return Paths.get(ROOT, paths).toString();\n+        return ROOT + String.join(\"/\", paths);\n     }\n \n     /**"
  },
  {
    "sha": "4d52446f9d2ec733afa38fc99fbbff5fb7f82188",
    "filename": "src-java/testing/functional-tests/build.gradle",
    "status": "modified",
    "additions": 11,
    "deletions": 4,
    "changes": 15,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/build.gradle",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/build.gradle",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/build.gradle?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -2,6 +2,12 @@ plugins {\n     id 'groovy'\n     id 'com.adarshr.test-logger' version '2.1.1'\n }\n+repositories {\n+    mavenCentral()\n+    maven {\n+        url \"https://oss.sonatype.org/content/repositories/snapshots/\"\n+    }\n+}\n \n description = 'Functional-Tests'\n dependencies {\n@@ -12,7 +18,7 @@ dependencies {\n     implementation 'com.fasterxml.jackson.core:jackson-annotations'\n     implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml'\n \n-    implementation 'org.codehaus.groovy:groovy-all:2.5.3'\n+    implementation 'org.codehaus.groovy:groovy-all:3.0.6'\n \n     implementation 'org.apache.kafka:kafka-clients'\n     implementation 'com.shazam:shazamcrest:0.9'\n@@ -25,9 +31,9 @@ dependencies {\n     implementation 'org.hibernate.validator:hibernate-validator'\n     implementation 'org.glassfish:javax.el'\n \n-    implementation 'org.spockframework:spock-spring:1.3-groovy-2.5'\n-    implementation 'org.spockframework:spock-core:1.3-groovy-2.5'\n-    implementation 'com.athaydes:spock-reports:1.7.1'\n+    implementation 'org.spockframework:spock-spring:2.0-groovy-3.0-SNAPSHOT'\n+    implementation 'org.spockframework:spock-core:2.0-groovy-3.0-SNAPSHOT'\n+//    implementation 'com.athaydes:spock-reports:2.0.1-RC3'\n     implementation 'net.jodah:failsafe'\n     implementation 'org.hamcrest:hamcrest-all:1.3'\n }\n@@ -70,6 +76,7 @@ task runTest(type: Test) {\n }\n \n tasks.withType(Test) {\n+    useJUnitPlatform()\n     outputs.upToDateWhen { false } //never cache results of functional tests\n }\n "
  },
  {
    "sha": "0f6a3cc0d746cb54419564dde67387871a8c9ff8",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/SkippedTestsLogger.groovy",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/SkippedTestsLogger.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/SkippedTestsLogger.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/SkippedTestsLogger.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,7 +1,7 @@\n package org.openkilda.functionaltests.extension\n \n import groovy.util.logging.Slf4j\n-import org.junit.AssumptionViolatedException\n+import org.opentest4j.TestAbortedException\n import org.spockframework.runtime.extension.AbstractGlobalExtension\n import org.spockframework.runtime.extension.IMethodInterceptor\n import org.spockframework.runtime.extension.IMethodInvocation\n@@ -34,8 +34,8 @@ class SkippedTestsLogger extends AbstractGlobalExtension {\n         void intercept(IMethodInvocation invocation) throws Throwable {\n             try {\n                 invocation.proceed()\n-            } catch (AssumptionViolatedException t) {\n-                log.warn(\"Skipped test: ${invocation.feature.spec.name}#${invocation.iteration.name}\\n\" +\n+            } catch (TestAbortedException t) {\n+                log.warn(\"Aborted test: ${invocation.feature.spec.name}#${invocation.iteration.name}\\n\" +\n                         \"Reason: ${t.message}\")\n                 throw t\n             }"
  },
  {
    "sha": "2ef2d9f232dcad5dbaae428e3e60587187c1038b",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/env/AssumeProfileExtension.groovy",
    "status": "modified",
    "additions": 4,
    "deletions": 3,
    "changes": 7,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/env/AssumeProfileExtension.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/env/AssumeProfileExtension.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/env/AssumeProfileExtension.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,10 +1,11 @@\n package org.openkilda.functionaltests.extension.env\n \n+import static org.junit.jupiter.api.Assumptions.assumeTrue\n+\n import org.openkilda.functionaltests.extension.spring.ContextAwareGlobalExtension\n import org.openkilda.functionaltests.extension.tags.Tag\n import org.openkilda.functionaltests.extension.tags.TagExtension\n \n-import org.junit.Assume\n import org.spockframework.runtime.extension.IMethodInterceptor\n import org.spockframework.runtime.extension.IMethodInvocation\n import org.spockframework.runtime.model.SpecInfo\n@@ -45,8 +46,8 @@ class AssumeProfileExtension extends ContextAwareGlobalExtension {\n \n     private void checkTags(Set<Tag> tags) {\n         if (tags.contains(Tag.VIRTUAL) || tags.contains(Tag.HARDWARE)) { //if test is profile-dependent\n-            Assume.assumeTrue(\"This test cannot be executed for current active profile: $profile\",\n-                    tags*.toString().contains(profile.toUpperCase()))\n+            assumeTrue(tags*.toString().contains(profile.toUpperCase()),\n+\"This test cannot be executed for current active profile: $profile\")\n         }\n     }\n }"
  },
  {
    "sha": "c94085b3e6673894554adeab605f379baddabaf7",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/env/EnvCleanupExtension.groovy",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/env/EnvCleanupExtension.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/env/EnvCleanupExtension.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/env/EnvCleanupExtension.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -3,8 +3,8 @@ package org.openkilda.functionaltests.extension.env\n import static org.openkilda.model.MeterId.MAX_SYSTEM_RULE_METER_ID\n \n import org.openkilda.functionaltests.exception.IslNotFoundException\n-import org.openkilda.functionaltests.extension.spring.SpringContextExtension\n import org.openkilda.functionaltests.extension.spring.SpringContextListener\n+import org.openkilda.functionaltests.extension.spring.SpringContextNotifier\n import org.openkilda.messaging.command.switches.DeleteRulesAction\n import org.openkilda.messaging.info.event.IslChangeType\n import org.openkilda.messaging.info.event.IslInfoData\n@@ -45,7 +45,7 @@ abstract class EnvCleanupExtension extends AbstractGlobalExtension implements Sp\n \n     @Override\n     void start() {\n-        SpringContextExtension.addListener(this)\n+        SpringContextNotifier.addListener(this)\n     }\n \n     def deleteAllFlows() {"
  },
  {
    "sha": "87ee42babf5a8ecc110f81107cbfecc2bee2b404",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/env/EnvExtension.groovy",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/env/EnvExtension.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/env/EnvExtension.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/env/EnvExtension.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -4,8 +4,8 @@ import static org.openkilda.testing.Constants.SWITCHES_ACTIVATION_TIME\n import static org.openkilda.testing.Constants.TOPOLOGY_DISCOVERING_TIME\n import static org.openkilda.testing.Constants.WAIT_OFFSET\n \n-import org.openkilda.functionaltests.extension.spring.SpringContextExtension\n import org.openkilda.functionaltests.extension.spring.SpringContextListener\n+import org.openkilda.functionaltests.extension.spring.SpringContextNotifier\n import org.openkilda.functionaltests.helpers.Wrappers\n import org.openkilda.messaging.info.event.IslChangeType\n import org.openkilda.messaging.info.event.SwitchChangeType\n@@ -58,7 +58,7 @@ class EnvExtension extends AbstractGlobalExtension implements SpringContextListe\n \n     @Override\n     void start() {\n-        SpringContextExtension.addListener(this)\n+        SpringContextNotifier.addListener(this)\n     }\n \n     @Override"
  },
  {
    "sha": "c8abe4021a6a977a4f7cf974381dcfd007ac524f",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/failfast/FailFastExtension.groovy",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/failfast/FailFastExtension.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/failfast/FailFastExtension.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/failfast/FailFastExtension.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,6 +1,6 @@\n package org.openkilda.functionaltests.extension.failfast\n \n-import org.junit.AssumptionViolatedException\n+import org.opentest4j.IncompleteExecutionException\n import org.spockframework.runtime.extension.AbstractGlobalExtension\n import org.spockframework.runtime.extension.IMethodInterceptor\n import org.spockframework.runtime.extension.IMethodInvocation\n@@ -32,7 +32,7 @@ class FailFastExtension extends AbstractGlobalExtension {\n                 try {\n                     invocation.proceed()\n                 } catch(Throwable t) {\n-                    if(!(t in AssumptionViolatedException) && !invocation.feature.featureMethod.getAnnotation(Tidy)) {\n+                    if(!(t in IncompleteExecutionException) && !invocation.feature.featureMethod.getAnnotation(Tidy)) {\n                         failedTest = invocation.iteration.name\n                     }\n                     throw t"
  },
  {
    "sha": "b68e9fd328d7ae96f07805651954f99031823cb0",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/fixture/CleanupVerifierExtension.groovy",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/fixture/CleanupVerifierExtension.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/fixture/CleanupVerifierExtension.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/fixture/CleanupVerifierExtension.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -55,7 +55,7 @@ class CleanupVerifierExtension extends ContextAwareGlobalExtension {\n                 @Override\n                 void afterSpec(SpecInfo runningSpec) {\n                     log.debug(\"Running cleanup verifier for '$runningSpec.name'\")\n-                    runVerfications()\n+                    runVerifications()\n                 }\n             })\n         } else { //run verifier after each feature\n@@ -66,14 +66,14 @@ class CleanupVerifierExtension extends ContextAwareGlobalExtension {\n                     void intercept(IMethodInvocation invocation) throws Throwable {\n                         invocation.proceed()\n                         log.debug(\"Running cleanup verifier for '$invocation.feature.name'\")\n-                        runVerfications()\n+                        runVerifications()\n                     }\n                 })\n             }\n         }\n     }\n \n-    def runVerfications() {\n+    def runVerifications() {\n         assert northboundV2.getAllFlows().empty\n         northbound.getAllSwitches().each {\n             def validation = northbound.validateSwitch(it.switchId)"
  },
  {
    "sha": "44332c5aa2a2774397a193e06eb9fceb19125dd9",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/fixture/SetupOnceExtension.groovy",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/fixture/SetupOnceExtension.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/fixture/SetupOnceExtension.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/fixture/SetupOnceExtension.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -2,7 +2,7 @@ package org.openkilda.functionaltests.extension.fixture\n \n import static org.openkilda.functionaltests.extension.ExtensionHelper.isFeatureSpecial\n \n-import org.openkilda.functionaltests.extension.spring.SpringContextExtension\n+import org.openkilda.functionaltests.extension.spring.SpringContextNotifier\n \n import groovy.util.logging.Slf4j\n import org.spockframework.runtime.extension.AbstractGlobalExtension\n@@ -41,9 +41,9 @@ class SetupOnceExtension extends AbstractGlobalExtension {\n             if (setupThrowed) {\n                 throw setupThrowed\n             }\n-            if (!setupRan && SpringContextExtension.context) {\n+            if (!setupRan && SpringContextNotifier.context) {\n                 def spec = invocation.sharedInstance\n-                SpringContextExtension.context.getAutowireCapableBeanFactory().autowireBeanProperties(\n+                SpringContextNotifier.context.getAutowireCapableBeanFactory().autowireBeanProperties(\n                         spec, AutowireCapableBeanFactory.AUTOWIRE_BY_NAME, false)\n                 if (spec instanceof SetupOnce) {\n                     log.debug \"Running fixture: setupOnce\""
  },
  {
    "sha": "b2c46bd9703384c6ba2a2ba1f124b3e1f236ea3d",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/fixture/rule/AbstractRuleExtension.groovy",
    "status": "modified",
    "additions": 3,
    "deletions": 2,
    "changes": 5,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/fixture/rule/AbstractRuleExtension.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/fixture/rule/AbstractRuleExtension.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/fixture/rule/AbstractRuleExtension.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,7 +1,8 @@\n package org.openkilda.functionaltests.extension.fixture.rule\n \n-import org.openkilda.functionaltests.extension.spring.SpringContextExtension\n+\n import org.openkilda.functionaltests.extension.spring.SpringContextListener\n+import org.openkilda.functionaltests.extension.spring.SpringContextNotifier\n \n import groovy.util.logging.Slf4j\n import org.spockframework.runtime.extension.AbstractAnnotationDrivenExtension\n@@ -53,7 +54,7 @@ abstract class AbstractRuleExtension<T extends Annotation> extends AbstractAnnot\n \n     @Override\n     void visitSpec(SpecInfo spec) {\n-        SpringContextExtension.addListener(this)\n+        SpringContextNotifier.addListener(this)\n     }\n \n     @Override"
  },
  {
    "sha": "cf04b5687c2b2b80a0adfd5b64cd4f0c36b6ebd9",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/rerun/RerunExtension.groovy",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/rerun/RerunExtension.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/rerun/RerunExtension.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/rerun/RerunExtension.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -4,6 +4,7 @@ import org.spockframework.runtime.extension.AbstractAnnotationDrivenExtension\n import org.spockframework.runtime.extension.IMethodInterceptor\n import org.spockframework.runtime.extension.IMethodInvocation\n import org.spockframework.runtime.model.FeatureInfo\n+import spock.lang.Specification\n \n /**\n  * Forces certain test to be rerun for certain amount of times. Test will be considered successful only if all"
  },
  {
    "sha": "469ec1f297f6bfbf5a7eb3aa12fe5c3cd68b4f5e",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/spring/ContextAwareGlobalExtension.groovy",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/spring/ContextAwareGlobalExtension.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/spring/ContextAwareGlobalExtension.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/spring/ContextAwareGlobalExtension.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -11,7 +11,7 @@ import org.springframework.context.ApplicationContext\n  */\n @Slf4j\n abstract class ContextAwareGlobalExtension extends AbstractGlobalExtension implements SpringContextListener {\n-    { SpringContextExtension.addListener(this) }\n+    { SpringContextNotifier.addListener(this) }\n \n     ApplicationContext context\n     List<Closure> delayedActions = []"
  },
  {
    "sha": "0f090f00bf99fe03ae32dac3274de2518d4ea032",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/spring/PrepareSpringContextDummy.groovy",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/spring/PrepareSpringContextDummy.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/spring/PrepareSpringContextDummy.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/spring/PrepareSpringContextDummy.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -9,7 +9,7 @@ import java.lang.annotation.Target\n  * Mark an empty dummy test to run before parameterized feature to ensure context setup. \n  * This is a dummy test which is ran as the first ever test to init Spring context.\n  *\n- * @see SpringContextExtension\n+ * @see SpringContextNotifier\n  */\n @Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.METHOD)"
  },
  {
    "sha": "6185e5a0a86979e174ac544fc8b6b61a70f6e81f",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/spring/SpringContextNotifier.groovy",
    "status": "renamed",
    "additions": 1,
    "deletions": 27,
    "changes": 28,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/spring/SpringContextNotifier.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/spring/SpringContextNotifier.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/spring/SpringContextNotifier.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -23,36 +23,10 @@ import org.springframework.context.ApplicationContextAware\n  * Can accept listeners that will be provided with ApplicationContext as soon as it is accessible.\n  */\n @Slf4j\n-class SpringContextExtension extends AbstractGlobalExtension implements ApplicationContextAware {\n+class SpringContextNotifier implements ApplicationContextAware {\n     public static ApplicationContext context;\n     private static List<SpringContextListener> listeners = []\n \n-    void visitSpec(SpecInfo specInfo) {\n-        //always include dummy test to properly init context for 'where' block as well as 'setupOnce'\n-        specInfo.getAllFeatures().find {\n-            it.featureMethod.getAnnotation(PrepareSpringContextDummy)\n-        }?.excluded = false\n-\n-        specInfo.allFixtureMethods*.addInterceptor(new IMethodInterceptor() {\n-            boolean autowired = false\n-\n-            @Override\n-            void intercept(IMethodInvocation invocation) throws Throwable {\n-                //this is the earliest point where Spock can have access to Spring context\n-                if (!autowired && invocation.method.kind == MethodKind.SETUP) {\n-                    context.getAutowireCapableBeanFactory().autowireBeanProperties(\n-                            invocation.sharedInstance, AutowireCapableBeanFactory.AUTOWIRE_BY_NAME, false)\n-                    autowired = true\n-                }\n-                //do not invoke any fixtures for the dummy test\n-                if (invocation?.getFeature()?.featureMethod?.getAnnotation(PrepareSpringContextDummy)) {\n-                    return\n-                }\n-                invocation.proceed()\n-            }\n-        })\n-    }\n-\n     @Override\n     void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n         log.debug(\"Setting app spring context for spock extensions\")",
    "previous_filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/spring/SpringContextExtension.groovy"
  },
  {
    "sha": "00f05837176e9a9d056bcf78ee7d3db4fb7e4734",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/tags/TagExtension.groovy",
    "status": "modified",
    "additions": 4,
    "deletions": 5,
    "changes": 9,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/tags/TagExtension.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/tags/TagExtension.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/extension/tags/TagExtension.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -3,7 +3,7 @@ package org.openkilda.functionaltests.extension.tags\n import static org.openkilda.functionaltests.extension.ExtensionHelper.isFeatureSpecial\n \n import groovy.util.logging.Slf4j\n-import org.junit.AssumptionViolatedException\n+import org.opentest4j.TestAbortedException\n import org.spockframework.runtime.extension.AbstractGlobalExtension\n import org.spockframework.runtime.extension.IMethodInterceptor\n import org.spockframework.runtime.extension.IMethodInvocation\n@@ -67,10 +67,9 @@ class TagExtension extends AbstractGlobalExtension {\n             def tags = collectAllTags(feature)\n             def iterationTags = (feature.featureMethod.getAnnotation(IterationTags)?.value()?.toList() ?: [] +\n                     feature.featureMethod.getAnnotation(IterationTag)).findAll()\n-            if(!iterationTags) {\n+            if (!iterationTags) {\n                 feature.excluded = !matches(tagsExpression, tags)\n-            }\n-            else {\n+            } else {\n                 feature.addIterationInterceptor(new IMethodInterceptor() {\n                     /*This stores how many times did we match a certain iteration tag.\n                      Use this when calculating 'take' limitation for the iteration tag*/\n@@ -94,7 +93,7 @@ class TagExtension extends AbstractGlobalExtension {\n                             }\n                             invocation.proceed()\n                         } else {\n-                            throw new AssumptionViolatedException(\"The test '$iteration.feature.spec.name#\" +\n+                            throw new TestAbortedException(\"The test '$iteration.feature.spec.name#\" +\n                                     \"$iteration.name' does not match the provided tags expression: '$tagsExpression'\")\n                         }\n                     }"
  },
  {
    "sha": "7f3254e0eabe5ff9c5516a783008a0a1249111fe",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/helpers/TestCaseReportCreator.groovy",
    "status": "modified",
    "additions": 48,
    "deletions": 48,
    "changes": 96,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/helpers/TestCaseReportCreator.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/helpers/TestCaseReportCreator.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/helpers/TestCaseReportCreator.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,48 +1,48 @@\n-package org.openkilda.functionaltests.helpers\n-\n-import com.athaydes.spockframework.report.internal.SpecData\n-import com.athaydes.spockframework.report.template.TemplateReportCreator\n-import com.athaydes.spockframework.report.util.Utils\n-\n-/**\n- * This enables a special form of spock report that will use current specifications to generate test cases \n- * in markdown format. In order to enable it pass\n- *  -Dcom.athaydes.spockframework.report.IReportCreator=org.openkilda.functionaltests.helpers.TestCaseReportCreator \n- *  when starting the build.\n- */\n-class TestCaseReportCreator extends TemplateReportCreator {\n-    boolean clearedSummary = false\n-    File summaryFile\n-    List<SpecData> specs = []\n-\n-    TestCaseReportCreator() {\n-        super()\n-        specTemplateFile = \"/test_case_template.md\"\n-        reportFileExtension = \"md\"\n-        summaryTemplateFile = \"/templateReportCreator/summary-template.md\"\n-        summaryFileName = \"summary.md\"\n-    }\n-\n-    @Override\n-    void createReportFor(SpecData data) {\n-        super.createReportFor(data)\n-        specs << data\n-        summaryFile = new File(\"$outputDir/$summaryFileName\")\n-        if (!clearedSummary) {\n-            summaryFile.delete()\n-            clearedSummary = true\n-        }\n-        summaryFile.append(reportFor(data))\n-    }\n-\n-    @Override\n-    void done() {\n-        //create table of contents at the top of the report\n-        def toc = specs.collect {\n-            def name = Utils.getSpecClassName(it).split(\"\\\\.\").last() - ~/Spec$/\n-            \"- [$name](#${name.toLowerCase()})\\n\"\n-        }.join(\"\")\n-        summaryFile.text = toc + summaryFile.text\n-\n-    }\n-}\n+//package org.openkilda.functionaltests.helpers\n+//\n+//import com.athaydes.spockframework.report.internal.SpecData\n+//import com.athaydes.spockframework.report.template.TemplateReportCreator\n+//import com.athaydes.spockframework.report.util.Utils\n+//\n+///**\n+// * This enables a special form of spock report that will use current specifications to generate test cases\n+// * in markdown format. In order to enable it pass\n+// *  -Dcom.athaydes.spockframework.report.IReportCreator=org.openkilda.functionaltests.helpers.TestCaseReportCreator\n+// *  when starting the build.\n+// */\n+//class TestCaseReportCreator extends TemplateReportCreator {\n+//    boolean clearedSummary = false\n+//    File summaryFile\n+//    List<SpecData> specs = []\n+//\n+//    TestCaseReportCreator() {\n+//        super()\n+//        specTemplateFile = \"/test_case_template.md\"\n+//        reportFileExtension = \"md\"\n+//        summaryTemplateFile = \"/templateReportCreator/summary-template.md\"\n+//        summaryFileName = \"summary.md\"\n+//    }\n+//\n+//    @Override\n+//    void createReportFor(SpecData data) {\n+//        super.createReportFor(data)\n+//        specs << data\n+//        summaryFile = new File(\"$outputDir/$summaryFileName\")\n+//        if (!clearedSummary) {\n+//            summaryFile.delete()\n+//            clearedSummary = true\n+//        }\n+//        summaryFile.append(reportFor(data))\n+//    }\n+//\n+//    @Override\n+//    void done() {\n+//        //create table of contents at the top of the report\n+//        def toc = specs.collect {\n+//            def name = Utils.getSpecClassName(it).split(\"\\\\.\").last() - ~/Spec$/\n+//            \"- [$name](#${name.toLowerCase()})\\n\"\n+//        }.join(\"\")\n+//        summaryFile.text = toc + summaryFile.text\n+//\n+//    }\n+//}"
  },
  {
    "sha": "fc6291a829bd277dd3caf468c5598131ec867c2d",
    "filename": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/helpers/Wrappers.groovy",
    "status": "modified",
    "additions": 0,
    "deletions": 3,
    "changes": 3,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/helpers/Wrappers.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/helpers/Wrappers.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/helpers/Wrappers.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -2,9 +2,6 @@ package org.openkilda.functionaltests.helpers\n \n import groovy.transform.InheritConstructors\n import groovy.util.logging.Slf4j\n-import org.junit.runners.model.MultipleFailureException\n-\n-import java.util.concurrent.TimeUnit\n \n @Slf4j\n class Wrappers {"
  },
  {
    "sha": "283336d1b0de4bbbc0bbfa89506281dad4402515",
    "filename": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/BaseSpecification.groovy",
    "status": "modified",
    "additions": 31,
    "deletions": 49,
    "changes": 80,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/BaseSpecification.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/BaseSpecification.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/BaseSpecification.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,9 +1,7 @@\n package org.openkilda.functionaltests\n \n-import static org.junit.Assume.assumeTrue\n+import static org.junit.jupiter.api.Assumptions.assumeTrue\n \n-import org.openkilda.functionaltests.extension.fixture.SetupOnce\n-import org.openkilda.functionaltests.extension.spring.PrepareSpringContextDummy\n import org.openkilda.functionaltests.helpers.FlowHelper\n import org.openkilda.functionaltests.helpers.FlowHelperV2\n import org.openkilda.functionaltests.helpers.PathHelper\n@@ -21,91 +19,75 @@ import org.openkilda.testing.service.northbound.NorthboundServiceV2\n import org.openkilda.testing.service.otsdb.OtsdbQueryService\n import org.openkilda.testing.tools.IslUtils\n \n+import org.spockframework.spring.EnableSharedInjection\n import org.springframework.beans.factory.annotation.Autowired\n import org.springframework.beans.factory.annotation.Value\n import org.springframework.test.context.ContextConfiguration\n+import spock.lang.Shared\n import spock.lang.Specification\n \n @ContextConfiguration(locations = [\"classpath:/spring-context.xml\"])\n-class BaseSpecification extends Specification implements SetupOnce {\n+@EnableSharedInjection\n+class BaseSpecification extends Specification {\n \n-    @Autowired\n+    @Autowired @Shared\n     TopologyDefinition topology\n-    @Autowired\n+    @Autowired @Shared\n     NorthboundService northbound\n-    @Autowired\n+    @Autowired @Shared\n     FloodlightsHelper flHelper\n-    @Autowired\n+    @Autowired @Shared\n     LockKeeperService lockKeeper\n-    @Autowired\n+    @Autowired @Shared\n     Database database\n-    @Autowired\n+    @Autowired @Shared\n     OtsdbQueryService otsdb\n-    @Autowired\n+    @Autowired @Shared\n     IslUtils islUtils\n-    @Autowired\n+    @Autowired @Shared\n     FlowHelper flowHelper\n-    @Autowired\n+    @Autowired @Shared\n     TopologyHelper topologyHelper\n-    @Autowired\n+    @Autowired @Shared\n     PathHelper pathHelper\n-    @Autowired\n+    @Autowired @Shared\n     SwitchHelper switchHelper\n-    @Autowired\n+    @Autowired @Shared\n     PortAntiflapHelper antiflap\n-    @Autowired\n+    @Autowired @Shared\n     NorthboundServiceV2 northboundV2\n-    @Autowired\n+    @Autowired @Shared\n     FlowHelperV2 flowHelperV2\n-    @Autowired\n+    @Autowired @Shared\n     StatsHelper statsHelper\n \n-    @Value('${spring.profiles.active}')\n+    @Value('${spring.profiles.active}') @Shared\n     String profile\n-    @Value('${reroute.delay}')\n+    @Value('${reroute.delay}') @Shared\n     int rerouteDelay\n-    @Value('${discovery.generic.interval}')\n+    @Value('${discovery.generic.interval}') @Shared\n     int discoveryInterval\n-    @Value('${discovery.timeout}')\n+    @Value('${discovery.timeout}') @Shared\n     int discoveryTimeout\n-    @Value('${discovery.exhausted.interval}')\n+    @Value('${discovery.exhausted.interval}') @Shared\n     int discoveryExhaustedInterval\n-    @Value('${discovery.auxiliary.interval}')\n+    @Value('${discovery.auxiliary.interval}') @Shared\n     int discoveryAuxiliaryInterval\n-    @Value('${antiflap.cooldown}')\n+    @Value('${antiflap.cooldown}') @Shared\n     int antiflapCooldown\n-    @Value('${antiflap.min}')\n+    @Value('${antiflap.min}') @Shared\n     int antiflapMin\n-    @Value('${use.multitable}')\n+    @Value('${use.multitable}') @Shared\n     boolean useMultitable\n \n-    /**\n-     * Use this instead of setupSpec in order to have access to Spring Context and do actions BeforeClass.\n-     * Can be overridden by inheritor specs.\n-     * @see {@link org.openkilda.functionaltests.extension.fixture.SetupOnceExtension}\n-     */\n-    def setupOnce() {\n-\n-    }\n-\n     def setup() {\n         //setup with empty body in order to trigger a SETUP invocation, which is intercepted in several extensions\n         //this can have implementation if required\n     }\n \n-\n-    /**\n-     * This is a dummy test which is ran as the first ever test to init Spring context.\n-     * @see org.openkilda.functionaltests.extension.spring.SpringContextExtension\n-     */\n-    @PrepareSpringContextDummy\n-    def \"Spring context is set UP\"() {\n-        expect: true\n-    }\n-\n     def requireProfiles(String[] profiles) {\n-        assumeTrue(\"This test requires one of these profiles: '${profiles.join(\"', '\")}'; \" +\n-                \"but current active profile is '${this.profile}'\", this.profile in profiles)\n+        assumeTrue(this.profile in profiles, \"This test requires one of these profiles: '${profiles.join(\"\")}'; \" +\n+                \"but current active profile is '${this.profile}'\")\n     }\n \n     void verifySwitchRules(SwitchId switchId) {"
  },
  {
    "sha": "74d36b3458579bdf9292ae6e31d9e99f88bf24f3",
    "filename": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/configuration/ConfigurationSpec.groovy",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/configuration/ConfigurationSpec.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/configuration/ConfigurationSpec.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/configuration/ConfigurationSpec.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,6 +1,6 @@\n package org.openkilda.functionaltests.spec.configuration\n \n-import static org.junit.Assume.assumeTrue\n+import static org.junit.jupiter.api.Assumptions.assumeTrue\n import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n import static org.openkilda.functionaltests.extension.tags.Tag.VIRTUAL\n@@ -95,7 +95,7 @@ class ConfigurationSpec extends HealthCheckSpecification {\n \n     @Tags(VIRTUAL)\n     def \"System takes into account default multi table value while connecting a new switch\"() {\n-        assumeTrue(\"Multi table is not enabled in kilda configuration\", useMultitable)\n+        assumeTrue(useMultitable, \"Multi table is not enabled in kilda configuration\")\n \n         expect: \"Already added switch was discovered according to the multi table field in kilda configuration\"\n         def initConf = northbound.getKildaConfiguration()"
  },
  {
    "sha": "0e5efdd3aaa86f0453c51d335410b76095bffdd1",
    "filename": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteSpec.groovy",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteSpec.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteSpec.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteSpec.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,6 +1,6 @@\n package org.openkilda.functionaltests.spec.flows\n \n-import static org.junit.Assume.assumeTrue\n+import static org.junit.jupiter.api.Assumptions.assumeTrue\n import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE\n@@ -303,7 +303,7 @@ class AutoRerouteSpec extends HealthCheckSpecification {\n     def \"System doesn't reroute flow to a path with not enough bandwidth available\"() {\n         given: \"A flow with alt path available\"\n         def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { it.paths.size() > 1 } ?:\n-                assumeTrue(\"No suiting switches found\", false)\n+                assumeTrue(false, \"No suiting switches found\")\n \n         def flow = flowHelper.randomFlow(switchPair)\n         flowHelper.addFlow(flow)\n@@ -382,7 +382,7 @@ class AutoRerouteSpec extends HealthCheckSpecification {\n \n     def getFlowWithPaths(List<SwitchPair> switchPairs, int minAltPathsCount) {\n         def switchPair = switchPairs.find { it.paths.size() > minAltPathsCount } ?:\n-                assumeTrue(\"No suiting switches found\", false)\n+                assumeTrue(false, \"No suiting switches found\")\n         return [flowHelper.randomFlow(switchPair), switchPair.paths]\n     }\n "
  },
  {
    "sha": "7ed37c8b62bffcdf09aa3a75c8aa1b48de30b7e9",
    "filename": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy",
    "status": "modified",
    "additions": 7,
    "deletions": 7,
    "changes": 14,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,7 +1,7 @@\n package org.openkilda.functionaltests.spec.flows\n \n import static groovyx.gpars.GParsPool.withPool\n-import static org.junit.Assume.assumeTrue\n+import static org.junit.jupiter.api.Assumptions.assumeTrue\n import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE\n import static org.openkilda.functionaltests.helpers.FlowHistoryConstants.REROUTE_ACTION\n@@ -450,10 +450,10 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n     @Tidy\n     def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n         given: \"First switch pair with two parallel links and two available paths\"\n-        assumeTrue(\"Reroute should be completed before link is FAILED\", rerouteDelay * 2 < discoveryTimeout)\n+        assumeTrue(rerouteDelay * 2 < discoveryTimeout, \"Reroute should be completed before link is FAILED\")\n         def switchPair1 = topologyHelper.getAllNeighboringSwitchPairs().find {\n             it.paths.findAll { it.size() == 2 }.size() > 1\n-        } ?: assumeTrue(\"No suiting switches found for the first flow\", false)\n+        } ?: assumeTrue(false, \"No suiting switches found for the first flow\")\n         // disable auto-reroute on islDiscovery event\n         northbound.toggleFeature(FeatureTogglesDto.builder().flowsRerouteOnIslDiscoveryEnabled(false).build())\n \n@@ -470,7 +470,7 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n                  * Because all remaining switch pairs may use switchPair1.dst.dpId as their src\n                  */\n             }\n-        } ?: assumeTrue(\"No suiting switches found for the second flow\", false)\n+        } ?: assumeTrue(false, \"No suiting switches found for the second flow\")\n \n         //Main and backup paths of firstFlow for further manipulation with them\n         def firstFlowMainPath = switchPair1.paths.min { it.size() }\n@@ -611,7 +611,7 @@ have links with enough bandwidth\"\n                     it.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n                 }\n             }\n-        } ?: assumeTrue(\"No suiting switches found.\", false)\n+        } ?: assumeTrue(false, \"No suiting switches found.\")\n \n         and: \"A flow on the given switch pair\"\n         def flow = flowHelperV2.randomFlow(switchPair)\n@@ -662,7 +662,7 @@ have links with enough bandwidth\"\n         given: \"Given a flow in DOWN status on neighboring switches\"\n         def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n             it.paths.findAll { it.size() == 2 }.size() == 1\n-        } ?: assumeTrue(\"No suiting switches found\", false)\n+        } ?: assumeTrue(false, \"No suiting switches found\")\n \n         def flowPath = switchPair.paths.min { it.size() }\n         def flow = flowHelperV2.randomFlow(switchPair)\n@@ -839,7 +839,7 @@ triggering one more reroute of the current path\"\n \n     def getFlowWithPaths(List<SwitchPair> switchPairs, int minAltPathsCount) {\n         def switchPair = switchPairs.find { it.paths.size() > minAltPathsCount } ?:\n-                assumeTrue(\"No suiting switches found\", false)\n+                assumeTrue(false, \"No suiting switches found\")\n         return [flowHelperV2.randomFlow(switchPair), switchPair.paths]\n     }\n "
  },
  {
    "sha": "f87f999e728a112248f23e368105a299039123bf",
    "filename": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/BandwidthSpec.groovy",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/BandwidthSpec.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/BandwidthSpec.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/BandwidthSpec.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,6 +1,6 @@\n package org.openkilda.functionaltests.spec.flows\n \n-import static org.junit.Assume.assumeTrue\n+import static org.junit.jupiter.api.Assumptions.assumeTrue\n import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE\n import static org.openkilda.testing.Constants.WAIT_OFFSET\n@@ -70,7 +70,7 @@ class BandwidthSpec extends HealthCheckSpecification {\n     def \"Longer path is chosen in case of not enough available bandwidth on a shorter path\"() {\n         given: \"Two active switches with two possible flow paths at least\"\n         def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { it.paths.size() > 1 } ?:\n-                assumeTrue(\"No suiting switches found\", false)\n+                assumeTrue(false, \"No suiting switches found\")\n \n         // Make the first path more preferable than others.\n         switchPair.paths[1..-1].each { pathHelper.makePathMorePreferable(switchPair.paths.first(), it) }"
  },
  {
    "sha": "6a8fe31e6e9c393f9910b75cd2a7d1a6da19986d",
    "filename": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/BandwidthV2Spec.groovy",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/BandwidthV2Spec.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/BandwidthV2Spec.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/BandwidthV2Spec.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,6 +1,6 @@\n package org.openkilda.functionaltests.spec.flows\n \n-import static org.junit.Assume.assumeTrue\n+import static org.junit.jupiter.api.Assumptions.assumeTrue\n import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE\n import static org.openkilda.functionaltests.helpers.FlowHistoryConstants.REROUTE_ACTION\n import static org.openkilda.functionaltests.helpers.FlowHistoryConstants.REROUTE_FAIL\n@@ -78,7 +78,7 @@ class BandwidthV2Spec extends HealthCheckSpecification {\n     def \"Longer path is chosen in case of not enough available bandwidth on a shorter path\"() {\n         given: \"Two active switches with two possible flow paths at least\"\n         def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { it.paths.size() > 1 } ?:\n-                assumeTrue(\"No suiting switches found\", false)\n+                assumeTrue(false, \"No suiting switches found\")\n \n         // Make the first path more preferable than others.\n         switchPair.paths[1..-1].each { pathHelper.makePathMorePreferable(switchPair.paths.first(), it) }"
  },
  {
    "sha": "a5b0954a277237f56948cc960c805e5719924cc9",
    "filename": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ConnectedDevicesSpec.groovy",
    "status": "modified",
    "additions": 20,
    "deletions": 19,
    "changes": 39,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ConnectedDevicesSpec.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ConnectedDevicesSpec.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ConnectedDevicesSpec.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,7 +1,7 @@\n package org.openkilda.functionaltests.spec.flows\n \n import static groovyx.gpars.GParsPool.withPool\n-import static org.junit.Assume.assumeTrue\n+import static org.junit.jupiter.api.Assumptions.assumeTrue\n import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE\n import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n@@ -53,6 +53,7 @@ import org.springframework.http.HttpStatus\n import org.springframework.web.client.HttpClientErrorException\n import spock.lang.Narrative\n import spock.lang.See\n+import spock.lang.Shared\n import spock.lang.Unroll\n \n import java.time.Instant\n@@ -65,7 +66,7 @@ Verify allocated Connected Devices resources and installed rules.\"\"\")\n @See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/connected-devices-lldp\")\n class ConnectedDevicesSpec extends HealthCheckSpecification {\n \n-    @Autowired\n+    @Autowired @Shared\n     Provider<TraffExamService> traffExamProvider\n \n     @Unroll\n@@ -75,8 +76,8 @@ class ConnectedDevicesSpec extends HealthCheckSpecification {\n             @IterationTag(tags = [HARDWARE], iterationNameRegex = /VXLAN/)\n     ])\n     def \"Able to create a #flowDescr flow with lldp and arp enabled on #devicesDescr\"() {\n-        assumeTrue(\"Devices+VXLAN problem https://github.com/telstra/open-kilda/issues/3199\",\n-                data.encapsulation != FlowEncapsulationType.VXLAN)\n+        assumeTrue(data.encapsulation != FlowEncapsulationType.VXLAN,\n+\"Devices+VXLAN problem https://github.com/telstra/open-kilda/issues/3199\")\n \n         given: \"A flow with enabled or disabled connected devices\"\n         def tgService = traffExamProvider.get()\n@@ -270,7 +271,7 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n     @Tags([SMOKE_SWITCHES])\n     def \"Able to detect devices on a single-switch different-port flow\"() {\n         given: \"A flow between different ports on the same switch\"\n-        assumeTrue(\"Require at least 1 switch with connected traffgen\", topology.activeTraffGens.size() > 0)\n+        assumeTrue(topology.activeTraffGens.size() > 0, \"Require at least 1 switch with connected traffgen\")\n         def sw = topology.activeTraffGens*.switchConnected.first()\n         def initialProps = enableMultiTableIfNeeded(true, sw.dpId)\n \n@@ -580,7 +581,7 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n     @Tidy\n     def \"System properly detects devices if feature is 'off' on switch level and 'on' on flow level\"() {\n         given: \"A switch with devices feature turned off\"\n-        assumeTrue(\"Require at least 1 switch with connected traffgen\", topology.activeTraffGens.size() > 0)\n+        assumeTrue(topology.activeTraffGens.size() > 0, \"Require at least 1 switch with connected traffgen\")\n         def sw = topology.activeTraffGens[0].switchConnected\n         def initialProps = enableMultiTableIfNeeded(true, sw.dpId)\n         def swProps = northbound.getSwitchProperties(sw.dpId)\n@@ -648,7 +649,7 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n     @Tidy\n     def \"System properly detects devices if feature is 'on' on switch level and 'off' on flow level\"() {\n         given: \"A switch with devices feature turned on\"\n-        assumeTrue(\"Require at least 1 switch with connected traffgen\", topology.activeTraffGens.size() > 0)\n+        assumeTrue(topology.activeTraffGens.size() > 0, \"Require at least 1 switch with connected traffgen\")\n         def tg = topology.activeTraffGens[0]\n         def sw = tg.switchConnected\n         def initialProps = northbound.getSwitchProperties(sw.dpId)\n@@ -704,7 +705,7 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n     @Tags([SMOKE_SWITCHES])\n     def \"Able to detect devices on free switch port (no flow or isl)\"() {\n         given: \"A switch with devices feature turned on\"\n-        assumeTrue(\"Require at least 1 switch with connected traffgen\", topology.activeTraffGens.size() > 0)\n+        assumeTrue(topology.activeTraffGens.size() > 0, \"Require at least 1 switch with connected traffgen\")\n         def tg = topology.activeTraffGens[0]\n         def sw = tg.switchConnected\n         def initialProps = northbound.getSwitchProperties(sw.dpId)\n@@ -742,7 +743,7 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n     @Unroll\n     def \"Able to distinguish devices between default and non-default single-switch flows (#descr)\"() {\n         given: \"A switch with devices feature turned on\"\n-        assumeTrue(\"Require at least 1 switch with connected traffgen\", topology.activeTraffGens.size() > 0)\n+        assumeTrue(topology.activeTraffGens.size() > 0, \"Require at least 1 switch with connected traffgen\")\n         def tg = topology.activeTraffGens[0]\n         def sw = tg.switchConnected\n         def initialProps = northbound.getSwitchProperties(sw.dpId)\n@@ -1076,17 +1077,17 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n     @Tags([TOPOLOGY_DEPENDENT])\n     @IterationTag(tags = [HARDWARE], iterationNameRegex = /VXLAN/)\n     def \"System detects devices for a qinq(iVlan=#vlanId oVlan=#innerVlanId) flow with lldp and arp enabled on the src switch\"() {\n-        assumeTrue(\"Devices+VXLAN problem https://github.com/telstra/open-kilda/issues/3199\",\n-                encapsulationType != FlowEncapsulationType.VXLAN)\n+        assumeTrue(encapsulationType != FlowEncapsulationType.VXLAN,\n+\"Devices+VXLAN problem https://github.com/telstra/open-kilda/issues/3199\")\n \n         given: \"Two switches connected to traffgen and they support enabled multiTable mode\"\n         def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n-        assumeTrue(\"Unable to find two active traffgens\", (allTraffGenSwitches.size() > 1))\n+        assumeTrue((allTraffGenSwitches.size() > 1), \"Unable to find two active traffgens\")\n         def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n             [it.src, it.dst].every { sw ->\n                 sw.dpId in allTraffGenSwitches*.dpId && sw.features.contains(SwitchFeature.MULTI_TABLE)\n             }\n-        } ?: assumeTrue(\"No suiting switches found\", false)\n+        } ?: assumeTrue(false, \"No suiting switches found\")\n \n         and: \"A QinQ flow with enabled connected devices\"\n         def tgService = traffExamProvider.get()\n@@ -1182,12 +1183,12 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n     def \"System doesn't detect devices only if vlan match with outerVlan of qinq flow\"() {\n         given: \"Two switches connected to traffgen and they support enabled multiTable mode\"\n         def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n-        assumeTrue(\"Unable to find two active traffgens\", (allTraffGenSwitches.size() > 1))\n+        assumeTrue((allTraffGenSwitches.size() > 1), \"Unable to find two active traffgens\")\n         def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n             [it.src, it.dst].every { sw ->\n                 sw.dpId in allTraffGenSwitches*.dpId && sw.features.contains(SwitchFeature.MULTI_TABLE)\n             }\n-        } ?: assumeTrue(\"No suiting switches found\", false)\n+        } ?: assumeTrue(false, \"No suiting switches found\")\n \n         and: \"A QinQ flow with enabled connected devices\"\n         def tgService = traffExamProvider.get()\n@@ -1248,7 +1249,7 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n     @Tags([SMOKE_SWITCHES])\n     def \"Able to detect devices on a qinq single-switch different-port flow\"() {\n         given: \"A flow between different ports on the same switch\"\n-        assumeTrue(\"Require at least 1 switch with connected traffgen\", topology.activeTraffGens.size() > 0)\n+        assumeTrue(topology.activeTraffGens.size() > 0, \"Require at least 1 switch with connected traffgen\")\n         def sw = topology.activeTraffGens*.switchConnected.first()\n         def initialProps = enableMultiTableIfNeeded(true, sw.dpId)\n \n@@ -1312,7 +1313,7 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n     @Tags([SMOKE_SWITCHES])\n     def \"Able to detect devices when two qinq single-switch different-port flows exist with the same outerVlanId\"() {\n         given: \"Two flows between different ports on the same switch with the same outerVlanId\"\n-        assumeTrue(\"Require at least 1 switch with connected traffgen\", topology.activeTraffGens.size() > 0)\n+        assumeTrue(topology.activeTraffGens.size() > 0, \"Require at least 1 switch with connected traffgen\")\n         def sw = topology.activeTraffGens*.switchConnected.first()\n         def initialProps = enableMultiTableIfNeeded(true, sw.dpId)\n \n@@ -1411,7 +1412,7 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n     private FlowPayload getFlowWithConnectedDevices(\n             boolean protectedFlow, boolean oneSwitch, boolean srcEnabled, boolean dstEnabled) {\n         def tgSwPair = getUniqueSwitchPairs()?.first()\n-        assumeTrue(\"Unable to find a switchPair with traffgens for the requested flow arguments\", tgSwPair as boolean)\n+        assumeTrue(tgSwPair as boolean, \"Unable to find a switchPair with traffgens for the requested flow arguments\")\n         getFlowWithConnectedDevices(protectedFlow, oneSwitch, srcEnabled, dstEnabled, tgSwPair)\n     }\n \n@@ -1449,7 +1450,7 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n         List<SwitchPair> switchPairs = topologyHelper.switchPairs.collectMany { [it, it.reversed] }.findAll {\n             it.src in tgSwitches && it.dst in tgSwitches\n         }\n-        assumeTrue(\"Unable to find a switchPair with traffgens on both sides\", switchPairs.size() > 0)\n+        assumeTrue(switchPairs.size() > 0, \"Unable to find a switchPair with traffgens on both sides\")\n         def result = []\n         while (!unpickedTgSwitches.empty) {\n             def pair = switchPairs.sort(false) { switchPair ->"
  },
  {
    "sha": "f23ffd3f3fc9c671edf474a173962ead41eda2cc",
    "filename": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/DefaultFlowSpec.groovy",
    "status": "modified",
    "additions": 6,
    "deletions": 5,
    "changes": 11,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/DefaultFlowSpec.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/DefaultFlowSpec.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/DefaultFlowSpec.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,7 +1,7 @@\n package org.openkilda.functionaltests.spec.flows\n \n import static groovyx.gpars.GParsPool.withPool\n-import static org.junit.Assume.assumeTrue\n+import static org.junit.jupiter.api.Assumptions.assumeTrue\n import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n \n import org.openkilda.functionaltests.HealthCheckSpecification\n@@ -15,6 +15,7 @@ import org.openkilda.testing.tools.FlowTrafficExamBuilder\n import org.springframework.beans.factory.annotation.Autowired\n import org.springframework.web.client.HttpClientErrorException\n import spock.lang.Narrative\n+import spock.lang.Shared\n \n import javax.inject.Provider\n \n@@ -24,13 +25,13 @@ Also system allows to pass tagged traffic via default flow.\"\"\")\n @Tags([LOW_PRIORITY])\n class DefaultFlowSpec extends HealthCheckSpecification {\n \n-    @Autowired\n+    @Autowired @Shared\n     Provider<TraffExamService> traffExamProvider\n \n     def \"Systems allows to pass traffic via default and vlan flow when they are on the same port\"() {\n         given: \"At least 3 traffGen switches\"\n         def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n-        assumeTrue(\"Unable to find required switches in topology\", allTraffGenSwitches.size() > 2)\n+        assumeTrue(allTraffGenSwitches.size() > 2, \"Unable to find required switches in topology\")\n \n         when: \"Create a vlan flow\"\n         def (Switch srcSwitch, Switch dstSwitch) = allTraffGenSwitches\n@@ -108,7 +109,7 @@ class DefaultFlowSpec extends HealthCheckSpecification {\n         // we can't test (0<->20, 20<->0) because iperf is not able to establish a connection\n         given: \"At least 2 traffGen switches\"\n         def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n-        assumeTrue(\"Unable to find required switches in topology\", allTraffGenSwitches.size() > 1)\n+        assumeTrue(allTraffGenSwitches.size() > 1, \"Unable to find required switches in topology\")\n \n         when: \"Create a default flow\"\n         def (Switch srcSwitch, Switch dstSwitch) = allTraffGenSwitches\n@@ -139,7 +140,7 @@ class DefaultFlowSpec extends HealthCheckSpecification {\n     def \"Unable to send traffic from simple flow into default flow and vice versa\"() {\n         given: \"At least 2 traffGen switches\"\n         def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n-        assumeTrue(\"Unable to find required switches in topology\", allTraffGenSwitches.size() > 1)\n+        assumeTrue(allTraffGenSwitches.size() > 1, \"Unable to find required switches in topology\")\n \n         and: \"A default flow\"\n         def (Switch srcSwitch, Switch dstSwitch) = allTraffGenSwitches"
  },
  {
    "sha": "b0a312dc470a178c2660e628bfcae870d8d9776a",
    "filename": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/DefaultFlowV2Spec.groovy",
    "status": "modified",
    "additions": 8,
    "deletions": 9,
    "changes": 17,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/DefaultFlowV2Spec.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/DefaultFlowV2Spec.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/DefaultFlowV2Spec.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,7 +1,7 @@\n package org.openkilda.functionaltests.spec.flows\n \n import static groovyx.gpars.GParsPool.withPool\n-import static org.junit.Assume.assumeTrue\n+import static org.junit.jupiter.api.Assumptions.assumeTrue\n import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n \n import org.openkilda.functionaltests.HealthCheckSpecification\n@@ -18,6 +18,7 @@ import org.openkilda.testing.tools.FlowTrafficExamBuilder\n import org.springframework.beans.factory.annotation.Autowired\n import org.springframework.web.client.HttpClientErrorException\n import spock.lang.Narrative\n+import spock.lang.Shared\n \n import javax.inject.Provider\n \n@@ -26,23 +27,21 @@ Default flow has lower priority than simple flow.\n Also system allows to pass tagged traffic via default flow.\"\"\")\n class DefaultFlowV2Spec extends HealthCheckSpecification {\n \n-    @Autowired\n+    @Autowired @Shared\n     Provider<TraffExamService> traffExamProvider\n \n     @Tidy\n     @Tags([SMOKE_SWITCHES])\n    def \"Systems allows to pass traffic via default/vlan and qinq flow when they are on the same port\"() {\n         given: \"At least 3 traffGen switches\"\n         def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n-        assumeTrue(\"Unable to find required switches in topology\", allTraffGenSwitches.size() > 2)\n+        assumeTrue(allTraffGenSwitches.size() > 2, \"Unable to find required switches in topology\")\n \n         when: \"Create a vlan flow\"\n         def (Switch srcSwitch, Switch dstSwitch) = allTraffGenSwitches\n         Switch newDstSwitch = allTraffGenSwitches.find { it != dstSwitch && it != srcSwitch }\n-        assumeTrue( \"MultiTable mode should be supported by the src and dst switches\",\n-        (srcSwitch.features.contains(SwitchFeature.MULTI_TABLE) &&\n-            dstSwitch.features.contains(SwitchFeature.MULTI_TABLE) &&\n-            newDstSwitch.features.contains(SwitchFeature.MULTI_TABLE)))\n+        assumeTrue([srcSwitch, dstSwitch, newDstSwitch].every { it.features.contains(SwitchFeature.MULTI_TABLE) },\n+ \"MultiTable mode should be supported by the src and dst switches\")\n \n         Map<SwitchId, SwitchPropertiesDto> initSwProps = [srcSwitch, dstSwitch, newDstSwitch].collectEntries {\n             [(it): northbound.getSwitchProperties(it.dpId)]\n@@ -127,7 +126,7 @@ class DefaultFlowV2Spec extends HealthCheckSpecification {\n         // we can't test (0<->20, 20<->0) because iperf is not able to establish a connection\n         given: \"At least 2 traffGen switches\"\n         def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n-        assumeTrue(\"Unable to find required switches in topology\", allTraffGenSwitches.size() > 1)\n+        assumeTrue(allTraffGenSwitches.size() > 1, \"Unable to find required switches in topology\")\n \n         when: \"Create a default flow\"\n         def (Switch srcSwitch, Switch dstSwitch) = allTraffGenSwitches\n@@ -169,7 +168,7 @@ class DefaultFlowV2Spec extends HealthCheckSpecification {\n     def \"Unable to send traffic from simple flow into default flow and vice versa\"() {\n         given: \"At least 2 traffGen switches\"\n         def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n-        assumeTrue(\"Unable to find required switches in topology\", allTraffGenSwitches.size() > 1)\n+        assumeTrue(allTraffGenSwitches.size() > 1, \"Unable to find required switches in topology\")\n \n         and: \"A default flow\"\n         def (Switch srcSwitch, Switch dstSwitch) = allTraffGenSwitches"
  },
  {
    "sha": "2ff6be6f817d1e38d797fd44abee275b824e166a",
    "filename": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudSpec.groovy",
    "status": "modified",
    "additions": 13,
    "deletions": 14,
    "changes": 27,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudSpec.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudSpec.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudSpec.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,7 +1,7 @@\n package org.openkilda.functionaltests.spec.flows\n \n import static groovyx.gpars.GParsPool.withPool\n-import static org.junit.Assume.assumeTrue\n+import static org.junit.jupiter.api.Assumptions.assumeTrue\n import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE\n import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n@@ -11,7 +11,6 @@ import static org.openkilda.messaging.info.event.IslChangeType.DISCOVERED\n import static org.openkilda.messaging.info.event.IslChangeType.FAILED\n import static org.openkilda.messaging.info.event.IslChangeType.MOVED\n import static org.openkilda.model.MeterId.MIN_FLOW_METER_ID\n-import static org.openkilda.model.cookie.CookieBase.CookieType.SERVICE_OR_FLOW_SEGMENT\n import static org.openkilda.testing.Constants.NON_EXISTENT_FLOW_ID\n import static org.openkilda.testing.Constants.WAIT_OFFSET\n import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n@@ -69,13 +68,13 @@ import javax.inject.Provider\n @Tags([LOW_PRIORITY])\n class FlowCrudSpec extends HealthCheckSpecification {\n \n-    @Autowired\n+    @Autowired @Shared\n     Provider<TraffExamService> traffExamProvider\n \n-    @Value(\"#{kafkaTopicsConfig.getSpeakerTopic()}\")\n+    @Value(\"#{kafkaTopicsConfig.getSpeakerTopic()}\") @Shared\n     String speakerTopic\n \n-    @Autowired\n+    @Autowired @Shared\n     @Qualifier(\"kafkaProducerProperties\")\n     Properties producerProps\n \n@@ -95,8 +94,8 @@ class FlowCrudSpec extends HealthCheckSpecification {\n (#flow.source.datapath - #flow.destination.datapath)\")\n     def \"Valid flow has no rule discrepancies\"() {\n         given: \"A flow\"\n-        assumeTrue(\"There should be at least two active traffgens for test execution\",\n-                topology.activeTraffGens.size() >= 2)\n+        assumeTrue(topology.activeTraffGens.size() >= 2,\n+\"There should be at least two active traffgens for test execution\")\n         def traffExam = traffExamProvider.get()\n         def allLinksInfoBefore = northbound.getAllLinks().collectEntries { [it.id, it.availableBandwidth] }.sort()\n         flowHelper.addFlow(flow)\n@@ -614,7 +613,7 @@ class FlowCrudSpec extends HealthCheckSpecification {\n     def \"Unable to create a flow on an isl port in case port is occupied on a #data.switchType switch\"() {\n         given: \"An isl\"\n         Isl isl = topology.islsForActiveSwitches.find { it.aswitch && it.dstSwitch }\n-        assumeTrue(\"Unable to find required isl\", isl as boolean)\n+        assumeTrue(isl as boolean, \"Unable to find required isl\")\n \n         when: \"Try to create a flow using isl port\"\n         def flow = flowHelper.randomFlow(isl.srcSwitch, isl.dstSwitch)\n@@ -661,7 +660,7 @@ class FlowCrudSpec extends HealthCheckSpecification {\n     def \"Unable to update a flow in case new port is an isl port on a #data.switchType switch\"() {\n         given: \"An isl\"\n         Isl isl = topology.islsForActiveSwitches.find { it.aswitch && it.dstSwitch }\n-        assumeTrue(\"Unable to find required isl\", isl as boolean)\n+        assumeTrue(isl as boolean, \"Unable to find required isl\")\n \n         and: \"A flow\"\n         def flow = flowHelper.randomFlow(isl.srcSwitch, isl.dstSwitch)\n@@ -703,7 +702,7 @@ class FlowCrudSpec extends HealthCheckSpecification {\n     def \"Unable to create a flow on an isl port when ISL status is FAILED\"() {\n         given: \"An inactive isl with failed state\"\n         Isl isl = topology.islsForActiveSwitches.find { it.aswitch && it.dstSwitch }\n-        assumeTrue(\"Unable to find required isl\", isl as boolean)\n+        assumeTrue(isl as boolean, \"Unable to find required isl\")\n         antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n         islUtils.waitForIslStatus([isl, isl.reversed], FAILED)\n \n@@ -729,9 +728,9 @@ class FlowCrudSpec extends HealthCheckSpecification {\n     def \"Unable to create a flow on an isl port when ISL status is MOVED\"() {\n         given: \"An inactive isl with moved state\"\n         Isl isl = topology.islsForActiveSwitches.find { it.aswitch && it.dstSwitch }\n-        assumeTrue(\"Unable to find required isl\", isl as boolean)\n+        assumeTrue(isl as boolean, \"Unable to find required isl\")\n         def notConnectedIsls = topology.notConnectedIsls\n-        assumeTrue(\"Unable to find non-connected isl\", notConnectedIsls.size() > 0)\n+        assumeTrue(notConnectedIsls.size() > 0, \"Unable to find non-connected isl\")\n         def notConnectedIsl = notConnectedIsls.first()\n         def newIsl = islUtils.replug(isl, false, notConnectedIsl, true, false)\n \n@@ -847,7 +846,7 @@ class FlowCrudSpec extends HealthCheckSpecification {\n     def \"System recreates excess meter when flow is created with the same meterId\"() {\n         given: \"A Noviflow switch\"\n         def sw = topology.activeSwitches.find { it.noviflow || it.virtual } ?:\n-                assumeTrue(\"No suiting switch found\", false)\n+                assumeTrue(false, \"No suiting switch found\")\n \n         and: \"Create excess meters on the given switch\"\n         def fakeBandwidth = 333\n@@ -899,7 +898,7 @@ class FlowCrudSpec extends HealthCheckSpecification {\n         given: \"Two active not neighboring switches\"\n         def switchPair = topologyHelper.getAllNotNeighboringSwitchPairs().find {\n             it.paths.find { it.unique(false) { it.switchId }.size() >= 4 }\n-        } ?: assumeTrue(\"No suiting switches found\", false)\n+        } ?: assumeTrue(false, \"No suiting switches found\")\n \n         and: \"Select path for further manipulation with it\"\n         def selectedPath = switchPair.paths.max { it.size() }"
  },
  {
    "sha": "67d049fae0e937eaf1b91ebdf5d5ebfca053b75a",
    "filename": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudV2Spec.groovy",
    "status": "modified",
    "additions": 12,
    "deletions": 12,
    "changes": 24,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudV2Spec.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudV2Spec.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudV2Spec.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,7 +1,7 @@\n package org.openkilda.functionaltests.spec.flows\n \n import static groovyx.gpars.GParsPool.withPool\n-import static org.junit.Assume.assumeTrue\n+import static org.junit.jupiter.api.Assumptions.assumeTrue\n import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE\n import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n@@ -63,7 +63,7 @@ More specific cases like partialUpdate/protected/diverse etc. are covered in sep\n \"\"\")\n class FlowCrudV2Spec extends HealthCheckSpecification {\n \n-    @Autowired\n+    @Autowired @Shared\n     Provider<TraffExamService> traffExamProvider\n \n     @Shared\n@@ -82,8 +82,8 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n (#flow.source.switchId - #flow.destination.switchId)\")\n     def \"Valid flow has no rule discrepancies\"() {\n         given: \"A flow\"\n-        assumeTrue(\"There should be at least two active traffgens for test execution\",\n-                topology.activeTraffGens.size() >= 2)\n+        assumeTrue(topology.activeTraffGens.size() >= 2,\n+\"There should be at least two active traffgens for test execution\")\n         def traffExam = traffExamProvider.get()\n         def allLinksInfoBefore = northbound.getAllLinks().collectEntries { [it.id, it.availableBandwidth] }.sort()\n         flowHelperV2.addFlow(flow)\n@@ -616,7 +616,7 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n     def \"Unable to create a flow on an isl port in case port is occupied on a #data.switchType switch\"() {\n         given: \"An isl\"\n         Isl isl = topology.islsForActiveSwitches.find { it.aswitch && it.dstSwitch }\n-        assumeTrue(\"Unable to find required isl\", isl as boolean)\n+        assumeTrue(isl as boolean, \"Unable to find required isl\")\n \n         when: \"Try to create a flow using isl port\"\n         def flow = flowHelperV2.randomFlow(isl.srcSwitch, isl.dstSwitch)\n@@ -662,7 +662,7 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n     def \"Unable to create a flow on an isl port when ISL status is FAILED\"() {\n         given: \"An inactive isl with failed state\"\n         Isl isl = topology.islsForActiveSwitches.find { it.aswitch && it.dstSwitch }\n-        assumeTrue(\"Unable to find required isl\", isl as boolean)\n+        assumeTrue(isl as boolean, \"Unable to find required isl\")\n         antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n         islUtils.waitForIslStatus([isl, isl.reversed], FAILED)\n \n@@ -688,9 +688,9 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n     def \"Unable to create a flow on an isl port when ISL status is MOVED\"() {\n         given: \"An inactive isl with moved state\"\n         Isl isl = topology.islsForActiveSwitches.find { it.aswitch && it.dstSwitch }\n-        assumeTrue(\"Unable to find required isl\", isl as boolean)\n+        assumeTrue(isl as boolean, \"Unable to find required isl\")\n         def notConnectedIsls = topology.notConnectedIsls\n-        assumeTrue(\"Unable to find non-connected isl\", notConnectedIsls.size() > 0)\n+        assumeTrue(notConnectedIsls.size() > 0, \"Unable to find non-connected isl\")\n         def notConnectedIsl = notConnectedIsls.first()\n         def newIsl = islUtils.replug(isl, false, notConnectedIsl, true, false)\n \n@@ -746,7 +746,7 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n         given: \"Two active not neighboring switches with two diverse paths at least\"\n         def switchPair = topologyHelper.getAllNotNeighboringSwitchPairs().find {\n             it.paths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n-        } ?: assumeTrue(\"No suiting switches found\", false)\n+        } ?: assumeTrue(false, \"No suiting switches found\")\n \n         when: \"Create flow with protected path\"\n         def flow = flowHelperV2.randomFlow(switchPair)\n@@ -928,7 +928,7 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n     def \"Able to update a flow endpoint\"() {\n         given: \"Three active switches\"\n         def allSwitches = topology.activeSwitches\n-        assumeTrue(\"Unable to find three active switches\", allSwitches.size() >= 3)\n+        assumeTrue(allSwitches.size() >= 3, \"Unable to find three active switches\")\n         def srcSwitch = allSwitches[0]\n         def dstSwitch = allSwitches[1]\n \n@@ -1071,7 +1071,7 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n         given: \"Two active not neighboring switches with two possible paths at least\"\n         def switchPair = topologyHelper.getAllNotNeighboringSwitchPairs().find {\n             it.paths.size() >= 2\n-        } ?: assumeTrue(\"No suiting switches found\", false)\n+        } ?: assumeTrue(false, \"No suiting switches found\")\n \n         and: \"A flow\"\n         def flow = flowHelperV2.randomFlow(switchPair)\n@@ -1121,7 +1121,7 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n         given: \"Two active switches connected to traffgens with two possible paths at least\"\n         def activeTraffGens = topology.activeTraffGens\n         def allTraffgenSwitches = activeTraffGens*.switchConnected ?:\n-                assumeTrue(\"Should be at least two active traffgens connected to switches\", false)\n+                assumeTrue(false, \"Should be at least two active traffgens connected to switches\")\n         def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { swP ->\n             allTraffgenSwitches*.dpId.contains(swP.src.dpId) && allTraffgenSwitches*.dpId.contains(swP.dst.dpId) &&\n                     swP.paths.size() >= 2"
  },
  {
    "sha": "24abf9ef5dc5fe7abc49ae367af398943da3de2a",
    "filename": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowDiversitySpec.groovy",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowDiversitySpec.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowDiversitySpec.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowDiversitySpec.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,6 +1,6 @@\n package org.openkilda.functionaltests.spec.flows\n \n-import static org.junit.Assume.assumeTrue\n+import static org.junit.jupiter.api.Assumptions.assumeTrue\n import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE\n import static org.openkilda.testing.Constants.WAIT_OFFSET\n@@ -397,7 +397,7 @@ class FlowDiversitySpec extends HealthCheckSpecification {\n         topologyHelper.getAllNeighboringSwitchPairs().find {\n             it.paths.collect { pathHelper.getInvolvedIsls(it) }.unique { a, b -> a.intersect(b) ? 0 : 1 }.size() >=\n                     minNotOverlappingPaths\n-        } ?: assumeTrue(\"No suiting switches found\", false)\n+        } ?: assumeTrue(false, \"No suiting switches found\")\n     }\n \n     void verifySegmentsStats(List<FlowPathPayload> flowPaths, Map expectedValuesMap) {"
  },
  {
    "sha": "78cc6b7380154ca6dc61c64c0966587c02a4ccff",
    "filename": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowDiversityV2Spec.groovy",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/telstra/open-kilda/blob/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowDiversityV2Spec.groovy",
    "raw_url": "https://github.com/telstra/open-kilda/raw/66968e20d32007b0f1c5256379587631db9038d8/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowDiversityV2Spec.groovy",
    "contents_url": "https://api.github.com/repos/telstra/open-kilda/contents/src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowDiversityV2Spec.groovy?ref=66968e20d32007b0f1c5256379587631db9038d8",
    "patch": "@@ -1,6 +1,6 @@\n package org.openkilda.functionaltests.spec.flows\n \n-import static org.junit.Assume.assumeTrue\n+import static org.junit.jupiter.api.Assumptions.assumeTrue\n import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE\n import static org.openkilda.functionaltests.helpers.FlowHistoryConstants.CREATE_ACTION\n import static org.openkilda.functionaltests.helpers.FlowHistoryConstants.DELETE_ACTION\n@@ -452,7 +452,7 @@ class FlowDiversityV2Spec extends HealthCheckSpecification {\n         topologyHelper.getAllNeighboringSwitchPairs().find {\n             it.paths.collect { pathHelper.getInvolvedIsls(it) }.unique { a, b -> a.intersect(b) ? 0 : 1 }.size() >=\n                     minNotOverlappingPaths\n-        } ?: assumeTrue(\"No suiting switches found\", false)\n+        } ?: assumeTrue(false, \"No suiting switches found\")\n     }\n \n     void verifySegmentsStats(List<FlowPathPayload> flowPaths, Map expectedValuesMap) {"
  }
]
