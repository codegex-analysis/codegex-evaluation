[
  {
    "sha": "eacd6b2a39192eca0c0fa9176624a134a82ec3b9",
    "filename": "driver/src/main/java/org/neo4j/driver/internal/BoltServerAddress.java",
    "status": "modified",
    "additions": 27,
    "deletions": 31,
    "changes": 58,
    "blob_url": "https://github.com/neo4j/neo4j-java-driver/blob/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/main/java/org/neo4j/driver/internal/BoltServerAddress.java",
    "raw_url": "https://github.com/neo4j/neo4j-java-driver/raw/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/main/java/org/neo4j/driver/internal/BoltServerAddress.java",
    "contents_url": "https://api.github.com/repos/neo4j/neo4j-java-driver/contents/driver/src/main/java/org/neo4j/driver/internal/BoltServerAddress.java?ref=8727aae5c16e4e2e6a597969a1c7f5250bc3096b",
    "patch": "@@ -18,14 +18,9 @@\n  */\n package org.neo4j.driver.internal;\n \n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.net.URI;\n-import java.util.Collections;\n-import java.util.LinkedHashSet;\n import java.util.Objects;\n-import java.util.Set;\n+import java.util.stream.Stream;\n \n import org.neo4j.driver.net.ServerAddress;\n \n@@ -39,11 +34,10 @@\n     public static final int DEFAULT_PORT = 7687;\n     public static final BoltServerAddress LOCAL_DEFAULT = new BoltServerAddress( \"localhost\", DEFAULT_PORT );\n \n-    private final String host; // This could either be the same as originalHost or it is an IP address resolved from the original host.\n-    private final int port;\n+    protected final String host; // Host or IP address.\n+    private final String connectionHost; // Either is equal to the host or is explicitly provided on creation and is expected to be a resolved IP address.\n+    protected final int port;\n     private final String stringValue;\n-    \n-    private final Set<BoltServerAddress> resolved;\n \n     public BoltServerAddress( String address )\n     {\n@@ -57,15 +51,17 @@ public BoltServerAddress( URI uri )\n \n     public BoltServerAddress( String host, int port )\n     {\n-        this( host, port, Collections.emptySet() );\n+        this( host, host, port );\n     }\n \n-    public BoltServerAddress( String host, int port, Set<BoltServerAddress> resolved )\n+    public BoltServerAddress( String host, String connectionHost, int port )\n     {\n         this.host = requireNonNull( host, \"host\" );\n+        this.connectionHost = requireNonNull( connectionHost, \"connectionHost\" );\n         this.port = requireValidPort( port );\n-        this.stringValue = String.format( \"%s:%d\", host, port );\n-        this.resolved = Collections.unmodifiableSet( new LinkedHashSet<>( resolved ) );\n+        this.stringValue = host.equals( connectionHost )\n+                           ? String.format( \"%s:%d\", host, port )\n+                           : String.format( \"%s(%s):%d\", host, connectionHost, port );\n     }\n \n     public static BoltServerAddress from( ServerAddress address )\n@@ -86,14 +82,14 @@ public boolean equals( Object o )\n         {\n             return false;\n         }\n-        BoltServerAddress that = (BoltServerAddress) o;\n-        return port == that.port && host.equals( that.host );\n+        BoltServerAddress address = (BoltServerAddress) o;\n+        return port == address.port && host.equals( address.host ) && connectionHost.equals( address.connectionHost );\n     }\n \n     @Override\n     public int hashCode()\n     {\n-        return Objects.hash( host, port );\n+        return Objects.hash( host, connectionHost, port );\n     }\n \n     @Override\n@@ -102,18 +98,6 @@ public String toString()\n         return stringValue;\n     }\n \n-    /**\n-     * Create a {@link SocketAddress} from this bolt address. This method always attempts to resolve the hostname into\n-     * an {@link InetAddress}.\n-     *\n-     * @return new socket address.\n-     * @see InetSocketAddress\n-     */\n-    public SocketAddress toSocketAddress()\n-    {\n-        return new InetSocketAddress( host, port );\n-    }\n-\n     @Override\n     public String host()\n     {\n@@ -126,9 +110,21 @@ public int port()\n         return port;\n     }\n \n-    public Set<BoltServerAddress> resolved()\n+    public String connectionHost()\n+    {\n+        return connectionHost;\n+    }\n+\n+    /**\n+     * Create a stream of unicast addresses.\n+     * <p>\n+     * While this implementation just returns a stream of itself, the subclasses may provide multiple addresses.\n+     *\n+     * @return stream of unicast addresses.\n+     */\n+    public Stream<BoltServerAddress> unicastStream()\n     {\n-        return this.resolved;\n+        return Stream.of( this );\n     }\n \n     private static String hostFrom( URI uri )"
  },
  {
    "sha": "6fa357f987022529efe5b3effce1cb8f744d0cf7",
    "filename": "driver/src/main/java/org/neo4j/driver/internal/ResolvedBoltServerAddress.java",
    "status": "added",
    "additions": 115,
    "deletions": 0,
    "changes": 115,
    "blob_url": "https://github.com/neo4j/neo4j-java-driver/blob/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/main/java/org/neo4j/driver/internal/ResolvedBoltServerAddress.java",
    "raw_url": "https://github.com/neo4j/neo4j-java-driver/raw/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/main/java/org/neo4j/driver/internal/ResolvedBoltServerAddress.java",
    "contents_url": "https://api.github.com/repos/neo4j/neo4j-java-driver/contents/driver/src/main/java/org/neo4j/driver/internal/ResolvedBoltServerAddress.java?ref=8727aae5c16e4e2e6a597969a1c7f5250bc3096b",
    "patch": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) \"Neo4j\"\n+ * Neo4j Sweden AB [http://neo4j.com]\n+ *\n+ * This file is part of Neo4j.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.neo4j.driver.internal;\n+\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * An explicitly resolved version of {@link BoltServerAddress} that always contains one or more resolved IP addresses.\n+ */\n+public class ResolvedBoltServerAddress extends BoltServerAddress\n+{\n+    private static final String HOST_ADDRESSES_FORMAT = \"%s%s:%d\";\n+    private static final int MAX_HOST_ADDRESSES_IN_STRING_VALUE = 5;\n+    private static final String HOST_ADDRESS_DELIMITER = \",\";\n+    private static final String HOST_ADDRESSES_PREFIX = \"(\";\n+    private static final String HOST_ADDRESSES_SUFFIX = \")\";\n+    private static final String TRIMMED_HOST_ADDRESSES_SUFFIX = \",...\" + HOST_ADDRESSES_SUFFIX;\n+\n+    private final Set<InetAddress> resolvedAddresses;\n+    private final String stringValue;\n+\n+    public ResolvedBoltServerAddress( String host, int port, InetAddress[] resolvedAddressesArr )\n+    {\n+        super( host, port );\n+        requireNonNull( resolvedAddressesArr, \"resolvedAddressesArr\" );\n+        if ( resolvedAddressesArr.length == 0 )\n+        {\n+            throw new IllegalArgumentException(\n+                    \"The resolvedAddressesArr must not be empty, check your DomainNameResolver is compliant with the interface contract\" );\n+        }\n+        resolvedAddresses = Collections.unmodifiableSet( new LinkedHashSet<>( Arrays.asList( resolvedAddressesArr ) ) );\n+        stringValue = createStringRepresentation();\n+    }\n+\n+    /**\n+     * Create a stream of unicast addresses.\n+     * <p>\n+     * The stream is created from the list of resolved IP addresses. Each unicast address is given a unique IP address as the connectionHost value.\n+     *\n+     * @return stream of unicast addresses.\n+     */\n+    @Override\n+    public Stream<BoltServerAddress> unicastStream()\n+    {\n+        return resolvedAddresses.stream().map( address -> new BoltServerAddress( host, address.getHostAddress(), port ) );\n+    }\n+\n+    @Override\n+    public boolean equals( Object o )\n+    {\n+        if ( this == o )\n+        {\n+            return true;\n+        }\n+        if ( o == null || getClass() != o.getClass() )\n+        {\n+            return false;\n+        }\n+        if ( !super.equals( o ) )\n+        {\n+            return false;\n+        }\n+        ResolvedBoltServerAddress that = (ResolvedBoltServerAddress) o;\n+        return resolvedAddresses.equals( that.resolvedAddresses );\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return Objects.hash( super.hashCode(), resolvedAddresses );\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return stringValue;\n+    }\n+\n+    private String createStringRepresentation()\n+    {\n+        String hostAddresses = resolvedAddresses.stream()\n+                                                .limit( MAX_HOST_ADDRESSES_IN_STRING_VALUE )\n+                                                .map( InetAddress::getHostAddress )\n+                                                .collect( joining( HOST_ADDRESS_DELIMITER, HOST_ADDRESSES_PREFIX,\n+                                                                   resolvedAddresses.size() > MAX_HOST_ADDRESSES_IN_STRING_VALUE\n+                                                                   ? TRIMMED_HOST_ADDRESSES_SUFFIX\n+                                                                   : HOST_ADDRESSES_SUFFIX ) );\n+        return String.format( HOST_ADDRESSES_FORMAT, host, hostAddresses, port );\n+    }\n+}"
  },
  {
    "sha": "0bfe976f1a6923d4b59a8409a00bb8fb58004199",
    "filename": "driver/src/main/java/org/neo4j/driver/internal/async/connection/ChannelConnectorImpl.java",
    "status": "modified",
    "additions": 15,
    "deletions": 2,
    "changes": 17,
    "blob_url": "https://github.com/neo4j/neo4j-java-driver/blob/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/main/java/org/neo4j/driver/internal/async/connection/ChannelConnectorImpl.java",
    "raw_url": "https://github.com/neo4j/neo4j-java-driver/raw/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/main/java/org/neo4j/driver/internal/async/connection/ChannelConnectorImpl.java",
    "contents_url": "https://api.github.com/repos/neo4j/neo4j-java-driver/contents/driver/src/main/java/org/neo4j/driver/internal/async/connection/ChannelConnectorImpl.java?ref=8727aae5c16e4e2e6a597969a1c7f5250bc3096b",
    "patch": "@@ -27,6 +27,7 @@\n import io.netty.resolver.AddressResolverGroup;\n \n import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n \n import org.neo4j.driver.AuthToken;\n import org.neo4j.driver.AuthTokens;\n@@ -53,6 +54,7 @@\n     private final int connectTimeoutMillis;\n     private final Logging logging;\n     private final Clock clock;\n+    private final DomainNameResolver domainNameResolver;\n     private final AddressResolverGroup<InetSocketAddress> addressResolverGroup;\n \n     public ChannelConnectorImpl( ConnectionSettings connectionSettings, SecurityPlan securityPlan, Logging logging,\n@@ -73,7 +75,8 @@ public ChannelConnectorImpl( ConnectionSettings connectionSettings, SecurityPlan\n         this.pipelineBuilder = pipelineBuilder;\n         this.logging = requireNonNull( logging );\n         this.clock = requireNonNull( clock );\n-        this.addressResolverGroup = new NettyDomainNameResolverGroup( requireNonNull( domainNameResolver ) );\n+        this.domainNameResolver = requireNonNull( domainNameResolver );\n+        this.addressResolverGroup = new NettyDomainNameResolverGroup( this.domainNameResolver );\n     }\n \n     @Override\n@@ -83,7 +86,17 @@ public ChannelFuture connect( BoltServerAddress address, Bootstrap bootstrap )\n         bootstrap.handler( new NettyChannelInitializer( address, securityPlan, connectTimeoutMillis, clock, logging ) );\n         bootstrap.resolver( addressResolverGroup );\n \n-        ChannelFuture channelConnected = bootstrap.connect( address.toSocketAddress() );\n+        SocketAddress socketAddress;\n+        try\n+        {\n+            socketAddress = new InetSocketAddress( domainNameResolver.resolve( address.connectionHost() )[0], address.port() );\n+        }\n+        catch ( Throwable t )\n+        {\n+            socketAddress = InetSocketAddress.createUnresolved( address.connectionHost(), address.port() );\n+        }\n+\n+        ChannelFuture channelConnected = bootstrap.connect( socketAddress );\n \n         Channel channel = channelConnected.channel();\n         ChannelPromise handshakeCompleted = channel.newPromise();"
  },
  {
    "sha": "52c76d784c907a5bd97fe506a1c2f3c5d65aec37",
    "filename": "driver/src/main/java/org/neo4j/driver/internal/cluster/RediscoveryImpl.java",
    "status": "modified",
    "additions": 11,
    "deletions": 12,
    "changes": 23,
    "blob_url": "https://github.com/neo4j/neo4j-java-driver/blob/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/main/java/org/neo4j/driver/internal/cluster/RediscoveryImpl.java",
    "raw_url": "https://github.com/neo4j/neo4j-java-driver/raw/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/main/java/org/neo4j/driver/internal/cluster/RediscoveryImpl.java",
    "contents_url": "https://api.github.com/repos/neo4j/neo4j-java-driver/contents/driver/src/main/java/org/neo4j/driver/internal/cluster/RediscoveryImpl.java?ref=8727aae5c16e4e2e6a597969a1c7f5250bc3096b",
    "patch": "@@ -21,18 +21,15 @@\n import io.netty.util.concurrent.EventExecutorGroup;\n \n import java.net.UnknownHostException;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.HashSet;\n-import java.util.LinkedHashSet;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CompletionException;\n import java.util.concurrent.CompletionStage;\n import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n \n import org.neo4j.driver.Bookmark;\n import org.neo4j.driver.Logger;\n@@ -42,6 +39,7 @@\n import org.neo4j.driver.exceptions.ServiceUnavailableException;\n import org.neo4j.driver.internal.BoltServerAddress;\n import org.neo4j.driver.internal.DomainNameResolver;\n+import org.neo4j.driver.internal.ResolvedBoltServerAddress;\n import org.neo4j.driver.internal.spi.ConnectionPool;\n import org.neo4j.driver.internal.util.Futures;\n import org.neo4j.driver.net.ServerAddress;\n@@ -308,7 +306,7 @@ private ClusterComposition handleRoutingProcedureError( Throwable error, Routing\n         {\n             try\n             {\n-                resolvedAddresses.addAll( resolveAllByDomainName( BoltServerAddress.from( serverAddress ) ) );\n+                resolveAllByDomainName( serverAddress ).unicastStream().forEach( resolvedAddresses::add );\n             }\n             catch ( UnknownHostException e )\n             {\n@@ -345,21 +343,22 @@ private BoltServerAddress resolveByDomainNameOrThrowCompletionException( BoltSer\n     {\n         try\n         {\n-            Set<BoltServerAddress> resolvedAddresses = resolveAllByDomainName( address );\n-            routingTable.replaceRouterIfPresent( address, new BoltServerAddress( address.host(), address.port(), resolvedAddresses ) );\n-            return resolvedAddresses.stream().findFirst().orElseThrow(\n-                    () -> new IllegalStateException( \"Domain name resolution returned empty result set and has not thrown an exception\" ) );\n+            ResolvedBoltServerAddress resolvedAddress = resolveAllByDomainName( address );\n+            routingTable.replaceRouterIfPresent( address, resolvedAddress );\n+            return resolvedAddress.unicastStream()\n+                                  .findFirst()\n+                                  .orElseThrow(\n+                                          () -> new IllegalStateException(\n+                                                  \"Unexpected condition, the ResolvedBoltServerAddress must always have at least one unicast address\" ) );\n         }\n         catch ( Throwable e )\n         {\n             throw new CompletionException( e );\n         }\n     }\n \n-    private Set<BoltServerAddress> resolveAllByDomainName( BoltServerAddress address ) throws UnknownHostException\n+    private ResolvedBoltServerAddress resolveAllByDomainName( ServerAddress address ) throws UnknownHostException\n     {\n-        return Arrays.stream( domainNameResolver.resolve( address.host() ) )\n-                     .map( inetAddress -> new BoltServerAddress( inetAddress.getHostAddress(), address.port() ) )\n-                     .collect( Collectors.toCollection( LinkedHashSet::new ) );\n+        return new ResolvedBoltServerAddress( address.host(), address.port(), domainNameResolver.resolve( address.host() ) );\n     }\n }"
  },
  {
    "sha": "7605b48ee8838e8b756e4449137293ef95b002a6",
    "filename": "driver/src/main/java/org/neo4j/driver/internal/cluster/RoutingTableHandlerImpl.java",
    "status": "modified",
    "additions": 6,
    "deletions": 8,
    "changes": 14,
    "blob_url": "https://github.com/neo4j/neo4j-java-driver/blob/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/main/java/org/neo4j/driver/internal/cluster/RoutingTableHandlerImpl.java",
    "raw_url": "https://github.com/neo4j/neo4j-java-driver/raw/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/main/java/org/neo4j/driver/internal/cluster/RoutingTableHandlerImpl.java",
    "contents_url": "https://api.github.com/repos/neo4j/neo4j-java-driver/contents/driver/src/main/java/org/neo4j/driver/internal/cluster/RoutingTableHandlerImpl.java?ref=8727aae5c16e4e2e6a597969a1c7f5250bc3096b",
    "patch": "@@ -108,20 +108,18 @@ else if ( routingTable.isStaleFor( context.mode() ) )\n         }\n     }\n \n-    private synchronized void freshClusterCompositionFetched( ClusterCompositionLookupResult composition )\n+    private synchronized void freshClusterCompositionFetched( ClusterCompositionLookupResult compositionLookupResult )\n     {\n         try\n         {\n-            routingTable.update( composition.getClusterComposition() );\n+            routingTable.update( compositionLookupResult.getClusterComposition() );\n             routingTableRegistry.removeAged();\n \n             Set<BoltServerAddress> addressesToRetain = new LinkedHashSet<>();\n-            for ( BoltServerAddress address : routingTableRegistry.allServers() )\n-            {\n-                addressesToRetain.add( address );\n-                addressesToRetain.addAll( address.resolved() );\n-            }\n-            composition.getResolvedInitialRouters().ifPresent(\n+            routingTableRegistry.allServers().stream()\n+                                .flatMap( BoltServerAddress::unicastStream )\n+                                .forEach( addressesToRetain::add );\n+            compositionLookupResult.getResolvedInitialRouters().ifPresent(\n                     addresses ->\n                     {\n                         resolvedInitialRouters.clear();"
  },
  {
    "sha": "a89d86a763cf15aa86f8176b1a23be2d486a7f9e",
    "filename": "driver/src/test/java/org/neo4j/driver/internal/cluster/ClusterCompositionTest.java",
    "status": "modified",
    "additions": 12,
    "deletions": 12,
    "changes": 24,
    "blob_url": "https://github.com/neo4j/neo4j-java-driver/blob/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/test/java/org/neo4j/driver/internal/cluster/ClusterCompositionTest.java",
    "raw_url": "https://github.com/neo4j/neo4j-java-driver/raw/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/test/java/org/neo4j/driver/internal/cluster/ClusterCompositionTest.java",
    "contents_url": "https://api.github.com/repos/neo4j/neo4j-java-driver/contents/driver/src/test/java/org/neo4j/driver/internal/cluster/ClusterCompositionTest.java?ref=8727aae5c16e4e2e6a597969a1c7f5250bc3096b",
    "patch": "@@ -27,24 +27,24 @@\n import java.util.Map;\n import java.util.Set;\n \n-import org.neo4j.driver.internal.BoltServerAddress;\n-import org.neo4j.driver.internal.InternalRecord;\n import org.neo4j.driver.Record;\n import org.neo4j.driver.Value;\n+import org.neo4j.driver.internal.BoltServerAddress;\n+import org.neo4j.driver.internal.InternalRecord;\n \n import static java.util.Arrays.asList;\n import static org.hamcrest.Matchers.contains;\n import static org.hamcrest.junit.MatcherAssert.assertThat;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.neo4j.driver.Values.value;\n import static org.neo4j.driver.internal.util.ClusterCompositionUtil.A;\n import static org.neo4j.driver.internal.util.ClusterCompositionUtil.B;\n import static org.neo4j.driver.internal.util.ClusterCompositionUtil.C;\n import static org.neo4j.driver.internal.util.ClusterCompositionUtil.D;\n import static org.neo4j.driver.internal.util.ClusterCompositionUtil.E;\n import static org.neo4j.driver.internal.util.ClusterCompositionUtil.F;\n-import static org.neo4j.driver.Values.value;\n \n class ClusterCompositionTest\n {\n@@ -150,8 +150,8 @@ void parseCorrectRecord()\n         Value[] values = {\n                 value( 42L ),\n                 value( asList( serversEntry( \"READ\", A, B ),\n-                        serversEntry( \"WRITE\", C, D ),\n-                        serversEntry( \"ROUTE\", E, F ) ) )\n+                               serversEntry( \"WRITE\", C, D ),\n+                               serversEntry( \"ROUTE\", E, F ) ) )\n         };\n         Record record = new InternalRecord( asList( \"ttl\", \"servers\" ), values );\n \n@@ -171,8 +171,8 @@ void parsePreservesOrderOfReaders()\n         Value[] values = {\n                 value( 42L ),\n                 value( asList( serversEntry( \"READ\", A, C, E, B, F, D ),\n-                        serversEntry( \"WRITE\" ),\n-                        serversEntry( \"ROUTE\" ) ) )\n+                               serversEntry( \"WRITE\" ),\n+                               serversEntry( \"ROUTE\" ) ) )\n         };\n         Record record = new InternalRecord( asList( \"ttl\", \"servers\" ), values );\n \n@@ -189,8 +189,8 @@ void parsePreservesOrderOfWriters()\n         Value[] values = {\n                 value( 42L ),\n                 value( asList( serversEntry( \"READ\" ),\n-                        serversEntry( \"WRITE\", C, F, D, A, B, E ),\n-                        serversEntry( \"ROUTE\" ) ) )\n+                               serversEntry( \"WRITE\", C, F, D, A, B, E ),\n+                               serversEntry( \"ROUTE\" ) ) )\n         };\n         Record record = new InternalRecord( asList( \"ttl\", \"servers\" ), values );\n \n@@ -207,8 +207,8 @@ void parsePreservesOrderOfRouters()\n         Value[] values = {\n                 value( 42L ),\n                 value( asList( serversEntry( \"READ\" ),\n-                        serversEntry( \"WRITE\" ),\n-                        serversEntry( \"ROUTE\", F, D, A, B, C, E ) ) )\n+                               serversEntry( \"WRITE\" ),\n+                               serversEntry( \"ROUTE\", F, D, A, B, C, E ) ) )\n         };\n         Record record = new InternalRecord( asList( \"ttl\", \"servers\" ), values );\n \n@@ -220,7 +220,7 @@ void parsePreservesOrderOfRouters()\n     }\n \n     private static ClusterComposition newComposition( long expirationTimestamp, Set<BoltServerAddress> readers,\n-            Set<BoltServerAddress> writers, Set<BoltServerAddress> routers )\n+                                                      Set<BoltServerAddress> writers, Set<BoltServerAddress> routers )\n     {\n         return new ClusterComposition( expirationTimestamp, readers, writers, routers );\n     }"
  },
  {
    "sha": "536684547d235b026210b641f837378d6b33470e",
    "filename": "driver/src/test/java/org/neo4j/driver/internal/cluster/RediscoveryTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/neo4j/neo4j-java-driver/blob/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/test/java/org/neo4j/driver/internal/cluster/RediscoveryTest.java",
    "raw_url": "https://github.com/neo4j/neo4j-java-driver/raw/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/test/java/org/neo4j/driver/internal/cluster/RediscoveryTest.java",
    "contents_url": "https://api.github.com/repos/neo4j/neo4j-java-driver/contents/driver/src/test/java/org/neo4j/driver/internal/cluster/RediscoveryTest.java?ref=8727aae5c16e4e2e6a597969a1c7f5250bc3096b",
    "patch": "@@ -430,7 +430,7 @@ void shouldResolveToIP() throws UnknownHostException\n         verify( resolver, times( 1 ) ).resolve( A );\n         verify( domainNameResolver, times( 1 ) ).resolve( A.host() );\n         assertEquals( 1, addresses.size() );\n-        assertEquals( addresses.get( 0 ), new BoltServerAddress( localhost.getHostAddress(), A.port() ) );\n+        assertEquals( new BoltServerAddress( A.host(), localhost.getHostAddress(), A.port() ), addresses.get( 0 ) );\n     }\n \n     private Rediscovery newRediscovery( BoltServerAddress initialRouter, ClusterCompositionProvider compositionProvider,"
  },
  {
    "sha": "aa7341582c6a459af8f9e6e1fa2fe96ec463da11",
    "filename": "driver/src/test/java/org/neo4j/driver/internal/net/BoltServerAddressTest.java",
    "status": "modified",
    "additions": 0,
    "deletions": 13,
    "changes": 13,
    "blob_url": "https://github.com/neo4j/neo4j-java-driver/blob/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/test/java/org/neo4j/driver/internal/net/BoltServerAddressTest.java",
    "raw_url": "https://github.com/neo4j/neo4j-java-driver/raw/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/test/java/org/neo4j/driver/internal/net/BoltServerAddressTest.java",
    "contents_url": "https://api.github.com/repos/neo4j/neo4j-java-driver/contents/driver/src/test/java/org/neo4j/driver/internal/net/BoltServerAddressTest.java?ref=8727aae5c16e4e2e6a597969a1c7f5250bc3096b",
    "patch": "@@ -20,7 +20,6 @@\n \n import org.junit.jupiter.api.Test;\n \n-import java.net.SocketAddress;\n import java.net.URI;\n \n import org.neo4j.driver.internal.BoltServerAddress;\n@@ -29,7 +28,6 @@\n import static org.hamcrest.CoreMatchers.equalTo;\n import static org.hamcrest.junit.MatcherAssert.assertThat;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertNotSame;\n import static org.junit.jupiter.api.Assertions.assertSame;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.mockito.Mockito.mock;\n@@ -50,17 +48,6 @@ void portShouldUseDefaultIfNotSupplied()\n         assertThat( new BoltServerAddress( \"localhost\" ).port(), equalTo( BoltServerAddress.DEFAULT_PORT ) );\n     }\n \n-    @Test\n-    void shouldAlwaysResolveAddress()\n-    {\n-        BoltServerAddress boltAddress = new BoltServerAddress( \"localhost\" );\n-\n-        SocketAddress socketAddress1 = boltAddress.toSocketAddress();\n-        SocketAddress socketAddress2 = boltAddress.toSocketAddress();\n-\n-        assertNotSame( socketAddress1, socketAddress2 );\n-    }\n-\n     @Test\n     void shouldHaveCorrectToString()\n     {"
  },
  {
    "sha": "4db2773451fa30f3543c526f5110765260a109a0",
    "filename": "driver/src/test/java/org/neo4j/driver/util/Neo4jRunner.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/neo4j/neo4j-java-driver/blob/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/test/java/org/neo4j/driver/util/Neo4jRunner.java",
    "raw_url": "https://github.com/neo4j/neo4j-java-driver/raw/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/driver/src/test/java/org/neo4j/driver/util/Neo4jRunner.java",
    "contents_url": "https://api.github.com/repos/neo4j/neo4j-java-driver/contents/driver/src/test/java/org/neo4j/driver/util/Neo4jRunner.java?ref=8727aae5c16e4e2e6a597969a1c7f5250bc3096b",
    "patch": "@@ -21,6 +21,7 @@\n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.InetSocketAddress;\n import java.net.StandardSocketOptions;\n import java.net.URI;\n import java.nio.channels.SocketChannel;\n@@ -286,7 +287,8 @@ private ServerStatus serverStatus()\n         {\n             SocketChannel soChannel = SocketChannel.open();\n             soChannel.setOption( StandardSocketOptions.SO_REUSEADDR, true );\n-            soChannel.connect( boltAddress().toSocketAddress() );\n+            BoltServerAddress address = boltAddress();\n+            soChannel.connect( new InetSocketAddress( address.connectionHost(), address.port() ) );\n             soChannel.close();\n             return ServerStatus.ONLINE;\n         }"
  },
  {
    "sha": "f1d24aa79fd9b5ea5e2d7d9ed4074ef90dc808f6",
    "filename": "testkit-backend/src/main/java/neo4j/org/testkit/backend/messages/requests/NewDriver.java",
    "status": "modified",
    "additions": 7,
    "deletions": 3,
    "changes": 10,
    "blob_url": "https://github.com/neo4j/neo4j-java-driver/blob/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/testkit-backend/src/main/java/neo4j/org/testkit/backend/messages/requests/NewDriver.java",
    "raw_url": "https://github.com/neo4j/neo4j-java-driver/raw/8727aae5c16e4e2e6a597969a1c7f5250bc3096b/testkit-backend/src/main/java/neo4j/org/testkit/backend/messages/requests/NewDriver.java",
    "contents_url": "https://api.github.com/repos/neo4j/neo4j-java-driver/contents/testkit-backend/src/main/java/neo4j/org/testkit/backend/messages/requests/NewDriver.java?ref=8727aae5c16e4e2e6a597969a1c7f5250bc3096b",
    "patch": "@@ -39,9 +39,10 @@\n import org.neo4j.driver.internal.DefaultDomainNameResolver;\n import org.neo4j.driver.internal.DomainNameResolver;\n import org.neo4j.driver.internal.DriverFactory;\n+import org.neo4j.driver.internal.SecuritySettings;\n import org.neo4j.driver.internal.cluster.RoutingSettings;\n import org.neo4j.driver.internal.retry.RetrySettings;\n-import org.neo4j.driver.internal.security.SecurityPlanImpl;\n+import org.neo4j.driver.internal.security.SecurityPlan;\n import org.neo4j.driver.net.ServerAddressResolver;\n \n @Setter\n@@ -93,7 +94,7 @@ private ServerAddressResolver callbackResolver( TestkitState testkitState )\n             ResolverResolutionRequired.ResolverResolutionRequiredBody body =\n                     ResolverResolutionRequired.ResolverResolutionRequiredBody.builder()\n                                                                              .id( callbackId )\n-                                                                             .address( address.toString() )\n+                                                                             .address( String.format( \"%s:%d\", address.host(), address.port() ) )\n                                                                              .build();\n             ResolverResolutionRequired response =\n                     ResolverResolutionRequired.builder()\n@@ -129,8 +130,11 @@ private DomainNameResolver callbackDomainNameResolver( TestkitState testkitState\n     {\n         RoutingSettings routingSettings = RoutingSettings.DEFAULT;\n         RetrySettings retrySettings = RetrySettings.DEFAULT;\n+        SecuritySettings.SecuritySettingsBuilder securitySettingsBuilder = new SecuritySettings.SecuritySettingsBuilder();\n+        SecuritySettings securitySettings = securitySettingsBuilder.build();\n+        SecurityPlan securityPlan = securitySettings.createSecurityPlan( uri.getScheme() );\n         return new DriverFactoryWithDomainNameResolver( domainNameResolver )\n-                .newInstance( uri, authToken, routingSettings, retrySettings, config, SecurityPlanImpl.insecure() );\n+                .newInstance( uri, authToken, routingSettings, retrySettings, config, securityPlan );\n     }\n \n     @Setter"
  }
]
