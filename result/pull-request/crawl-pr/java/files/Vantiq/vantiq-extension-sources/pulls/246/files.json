[
  {
    "sha": "4c707fa1a9144e935f9b31ae1d7fd778bf5e7682",
    "filename": "llrpConnector/LICENSE/LICENSE.txt",
    "status": "added",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/LICENSE.txt",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/LICENSE.txt",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/LICENSE/LICENSE.txt?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,14 @@\n+Copyright 2021 Vantiq, Inc.\r\n+\r\n+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\r\n+documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\r\n+rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit\r\n+persons to whom the Software is furnished to do so, subject to the following conditions:\r\n+\r\n+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\r\n+Software.\r\n+\r\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\r\n+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n+OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r"
  },
  {
    "sha": "dd06b60b8bde8f577b9a45bed777bce8b91d95b8",
    "filename": "llrpConnector/LICENSE/NOTICE.txt",
    "status": "added",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/NOTICE.txt",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/NOTICE.txt",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/LICENSE/NOTICE.txt?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,7 @@\n+LTK-JAVA NOTICE\n+\n+This product includes software developed by the JDOM Project (http://www.jdom.org/).\n+\n+This product includes software developed by The Apache Software Foundation (http://www.apache.org/).\n+\n+This product includes software developed by jargs project (http://sourceforge.net/projects/jargs).\n\\ No newline at end of file"
  },
  {
    "sha": "819a50950894e174295e45da084dcab656524b29",
    "filename": "llrpConnector/LICENSE/apache-2.txt",
    "status": "added",
    "additions": 203,
    "deletions": 0,
    "changes": 203,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/apache-2.txt",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/apache-2.txt",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/LICENSE/apache-2.txt?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,203 @@\n+\r\n+\r\n+                                     Apache License\r\n+                               Version 2.0, January 2004\r\n+                            http://www.apache.org/licenses/\r\n+     \r\n+       TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\r\n+     \r\n+       1. Definitions.\r\n+     \r\n+          \"License\" shall mean the terms and conditions for use, reproduction,\r\n+          and distribution as defined by Sections 1 through 9 of this document.\r\n+     \r\n+          \"Licensor\" shall mean the copyright owner or entity authorized by\r\n+          the copyright owner that is granting the License.\r\n+     \r\n+          \"Legal Entity\" shall mean the union of the acting entity and all\r\n+          other entities that control, are controlled by, or are under common\r\n+          control with that entity. For the purposes of this definition,\r\n+          \"control\" means (i) the power, direct or indirect, to cause the\r\n+          direction or management of such entity, whether by contract or\r\n+          otherwise, or (ii) ownership of fifty percent (50%) or more of the\r\n+          outstanding shares, or (iii) beneficial ownership of such entity.\r\n+     \r\n+          \"You\" (or \"Your\") shall mean an individual or Legal Entity\r\n+          exercising permissions granted by this License.\r\n+     \r\n+          \"Source\" form shall mean the preferred form for making modifications,\r\n+          including but not limited to software source code, documentation\r\n+          source, and configuration files.\r\n+     \r\n+          \"Object\" form shall mean any form resulting from mechanical\r\n+          transformation or translation of a Source form, including but\r\n+          not limited to compiled object code, generated documentation,\r\n+          and conversions to other media types.\r\n+     \r\n+          \"Work\" shall mean the work of authorship, whether in Source or\r\n+          Object form, made available under the License, as indicated by a\r\n+          copyright notice that is included in or attached to the work\r\n+          (an example is provided in the Appendix below).\r\n+     \r\n+          \"Derivative Works\" shall mean any work, whether in Source or Object\r\n+          form, that is based on (or derived from) the Work and for which the\r\n+          editorial revisions, annotations, elaborations, or other modifications\r\n+          represent, as a whole, an original work of authorship. For the purposes\r\n+          of this License, Derivative Works shall not include works that remain\r\n+          separable from, or merely link (or bind by name) to the interfaces of,\r\n+          the Work and Derivative Works thereof.\r\n+     \r\n+          \"Contribution\" shall mean any work of authorship, including\r\n+          the original version of the Work and any modifications or additions\r\n+          to that Work or Derivative Works thereof, that is intentionally\r\n+          submitted to Licensor for inclusion in the Work by the copyright owner\r\n+          or by an individual or Legal Entity authorized to submit on behalf of\r\n+          the copyright owner. For the purposes of this definition, \"submitted\"\r\n+          means any form of electronic, verbal, or written communication sent\r\n+          to the Licensor or its representatives, including but not limited to\r\n+          communication on electronic mailing lists, source code control systems,\r\n+          and issue tracking systems that are managed by, or on behalf of, the\r\n+          Licensor for the purpose of discussing and improving the Work, but\r\n+          excluding communication that is conspicuously marked or otherwise\r\n+          designated in writing by the copyright owner as \"Not a Contribution.\"\r\n+     \r\n+          \"Contributor\" shall mean Licensor and any individual or Legal Entity\r\n+          on behalf of whom a Contribution has been received by Licensor and\r\n+          subsequently incorporated within the Work.\r\n+     \r\n+       2. Grant of Copyright License. Subject to the terms and conditions of\r\n+          this License, each Contributor hereby grants to You a perpetual,\r\n+          worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n+          copyright license to reproduce, prepare Derivative Works of,\r\n+          publicly display, publicly perform, sublicense, and distribute the\r\n+          Work and such Derivative Works in Source or Object form.\r\n+     \r\n+       3. Grant of Patent License. Subject to the terms and conditions of\r\n+          this License, each Contributor hereby grants to You a perpetual,\r\n+          worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n+          (except as stated in this section) patent license to make, have made,\r\n+          use, offer to sell, sell, import, and otherwise transfer the Work,\r\n+          where such license applies only to those patent claims licensable\r\n+          by such Contributor that are necessarily infringed by their\r\n+          Contribution(s) alone or by combination of their Contribution(s)\r\n+          with the Work to which such Contribution(s) was submitted. If You\r\n+          institute patent litigation against any entity (including a\r\n+          cross-claim or counterclaim in a lawsuit) alleging that the Work\r\n+          or a Contribution incorporated within the Work constitutes direct\r\n+          or contributory patent infringement, then any patent licenses\r\n+          granted to You under this License for that Work shall terminate\r\n+          as of the date such litigation is filed.\r\n+     \r\n+       4. Redistribution. You may reproduce and distribute copies of the\r\n+          Work or Derivative Works thereof in any medium, with or without\r\n+          modifications, and in Source or Object form, provided that You\r\n+          meet the following conditions:\r\n+     \r\n+          (a) You must give any other recipients of the Work or\r\n+              Derivative Works a copy of this License; and\r\n+     \r\n+          (b) You must cause any modified files to carry prominent notices\r\n+              stating that You changed the files; and\r\n+     \r\n+          (c) You must retain, in the Source form of any Derivative Works\r\n+              that You distribute, all copyright, patent, trademark, and\r\n+              attribution notices from the Source form of the Work,\r\n+              excluding those notices that do not pertain to any part of\r\n+              the Derivative Works; and\r\n+     \r\n+          (d) If the Work includes a \"NOTICE\" text file as part of its\r\n+              distribution, then any Derivative Works that You distribute must\r\n+              include a readable copy of the attribution notices contained\r\n+              within such NOTICE file, excluding those notices that do not\r\n+              pertain to any part of the Derivative Works, in at least one\r\n+              of the following places: within a NOTICE text file distributed\r\n+              as part of the Derivative Works; within the Source form or\r\n+              documentation, if provided along with the Derivative Works; or,\r\n+              within a display generated by the Derivative Works, if and\r\n+              wherever such third-party notices normally appear. The contents\r\n+              of the NOTICE file are for informational purposes only and\r\n+              do not modify the License. You may add Your own attribution\r\n+              notices within Derivative Works that You distribute, alongside\r\n+              or as an addendum to the NOTICE text from the Work, provided\r\n+              that such additional attribution notices cannot be construed\r\n+              as modifying the License.\r\n+     \r\n+          You may add Your own copyright statement to Your modifications and\r\n+          may provide additional or different license terms and conditions\r\n+          for use, reproduction, or distribution of Your modifications, or\r\n+          for any such Derivative Works as a whole, provided Your use,\r\n+          reproduction, and distribution of the Work otherwise complies with\r\n+          the conditions stated in this License.\r\n+     \r\n+       5. Submission of Contributions. Unless You explicitly state otherwise,\r\n+          any Contribution intentionally submitted for inclusion in the Work\r\n+          by You to the Licensor shall be under the terms and conditions of\r\n+          this License, without any additional terms or conditions.\r\n+          Notwithstanding the above, nothing herein shall supersede or modify\r\n+          the terms of any separate license agreement you may have executed\r\n+          with Licensor regarding such Contributions.\r\n+     \r\n+       6. Trademarks. This License does not grant permission to use the trade\r\n+          names, trademarks, service marks, or product names of the Licensor,\r\n+          except as required for reasonable and customary use in describing the\r\n+          origin of the Work and reproducing the content of the NOTICE file.\r\n+     \r\n+       7. Disclaimer of Warranty. Unless required by applicable law or\r\n+          agreed to in writing, Licensor provides the Work (and each\r\n+          Contributor provides its Contributions) on an \"AS IS\" BASIS,\r\n+          WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\r\n+          implied, including, without limitation, any warranties or conditions\r\n+          of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\r\n+          PARTICULAR PURPOSE. You are solely responsible for determining the\r\n+          appropriateness of using or redistributing the Work and assume any\r\n+          risks associated with Your exercise of permissions under this License.\r\n+     \r\n+       8. Limitation of Liability. In no event and under no legal theory,\r\n+          whether in tort (including negligence), contract, or otherwise,\r\n+          unless required by applicable law (such as deliberate and grossly\r\n+          negligent acts) or agreed to in writing, shall any Contributor be\r\n+          liable to You for damages, including any direct, indirect, special,\r\n+          incidental, or consequential damages of any character arising as a\r\n+          result of this License or out of the use or inability to use the\r\n+          Work (including but not limited to damages for loss of goodwill,\r\n+          work stoppage, computer failure or malfunction, or any and all\r\n+          other commercial damages or losses), even if such Contributor\r\n+          has been advised of the possibility of such damages.\r\n+     \r\n+       9. Accepting Warranty or Additional Liability. While redistributing\r\n+          the Work or Derivative Works thereof, You may choose to offer,\r\n+          and charge a fee for, acceptance of support, warranty, indemnity,\r\n+          or other liability obligations and/or rights consistent with this\r\n+          License. However, in accepting such obligations, You may act only\r\n+          on Your own behalf and on Your sole responsibility, not on behalf\r\n+          of any other Contributor, and only if You agree to indemnify,\r\n+          defend, and hold each Contributor harmless for any liability\r\n+          incurred by, or claims asserted against, such Contributor by reason\r\n+          of your accepting any such warranty or additional liability.\r\n+     \r\n+       END OF TERMS AND CONDITIONS\r\n+     \r\n+       APPENDIX: How to apply the Apache License to your work.\r\n+     \r\n+          To apply the Apache License to your work, attach the following\r\n+          boilerplate notice, with the fields enclosed by brackets \"[]\"\r\n+          replaced with your own identifying information. (Don't include\r\n+          the brackets!)  The text should be enclosed in the appropriate\r\n+          comment syntax for the file format. We also recommend that a\r\n+          file or class name and description of purpose be included on the\r\n+          same \"printed page\" as the copyright notice for easier\r\n+          identification within third-party archives.\r\n+     \r\n+       Copyright [yyyy] [name of copyright owner]\r\n+     \r\n+       Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+       you may not use this file except in compliance with the License.\r\n+       You may obtain a copy of the License at\r\n+     \r\n+           http://www.apache.org/licenses/LICENSE-2.0\r\n+     \r\n+       Unless required by applicable law or agreed to in writing, software\r\n+       distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+       See the License for the specific language governing permissions and\r\n+       limitations under the License.\r"
  },
  {
    "sha": "05b1d266321cb058b260454beb5fc77c9503124e",
    "filename": "llrpConnector/LICENSE/jackson-databind-license.txt",
    "status": "added",
    "additions": 9,
    "deletions": 0,
    "changes": 9,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/jackson-databind-license.txt",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/jackson-databind-license.txt",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/LICENSE/jackson-databind-license.txt?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,9 @@\n+\r\n+This copy of Jackson JSON processor databind module is licensed under the\r\n+Apache (Software) License, version 2.0 (\"the License\").\r\n+See the License for details about distribution rights, and the\r\n+specific rights regarding derivative works.\r\n+\r\n+You may obtain a copy of the License at:\r\n+\r\n+http://www.apache.org/licenses/LICENSE-2.0\n\\ No newline at end of file"
  },
  {
    "sha": "509c1b7cb9c6d5c7d7890e7376b3a32ccf478291",
    "filename": "llrpConnector/LICENSE/jargs-license.txt",
    "status": "added",
    "additions": 29,
    "deletions": 0,
    "changes": 29,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/jargs-license.txt",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/jargs-license.txt",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/LICENSE/jargs-license.txt?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,29 @@\n+Copyright (c) 2001-2003 Steve Purcell.\n+Copyright (c) 2002      Vidar Holen.\n+Copyright (c) 2002      Michal Ceresna.\n+Copyright (c) 2005      Ewan Mellor.\n+\n+All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met: Redistributions of source code must retain the above copyright notice,\n+this list of conditions and the following disclaimer. Redistributions in\n+binary form must reproduce the above copyright notice, this list of\n+conditions and the following disclaimer in the documentation and/or other\n+materials provided with the distribution. Neither the name of the copyright\n+holder nor the names of its contributors may be used to endorse or promote\n+products derived from this software without specific prior written\n+permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "sha": "999383ad3c83ebd199caf313c868c337d14da208",
    "filename": "llrpConnector/LICENSE/jdom-license.txt",
    "status": "added",
    "additions": 56,
    "deletions": 0,
    "changes": 56,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/jdom-license.txt",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/jdom-license.txt",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/LICENSE/jdom-license.txt?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,56 @@\n+/*-- \r\n+\r\n+ $Id: LICENSE.txt,v 1.11 2004/02/06 09:32:57 jhunter Exp $\r\n+\r\n+ Copyright (C) 2000-2004 Jason Hunter & Brett McLaughlin.\r\n+ All rights reserved.\r\n+ \r\n+ Redistribution and use in source and binary forms, with or without\r\n+ modification, are permitted provided that the following conditions\r\n+ are met:\r\n+ \r\n+ 1. Redistributions of source code must retain the above copyright\r\n+    notice, this list of conditions, and the following disclaimer.\r\n+ \r\n+ 2. Redistributions in binary form must reproduce the above copyright\r\n+    notice, this list of conditions, and the disclaimer that follows \r\n+    these conditions in the documentation and/or other materials \r\n+    provided with the distribution.\r\n+\r\n+ 3. The name \"JDOM\" must not be used to endorse or promote products\r\n+    derived from this software without prior written permission.  For\r\n+    written permission, please contact <request_AT_jdom_DOT_org>.\r\n+ \r\n+ 4. Products derived from this software may not be called \"JDOM\", nor\r\n+    may \"JDOM\" appear in their name, without prior written permission\r\n+    from the JDOM Project Management <request_AT_jdom_DOT_org>.\r\n+ \r\n+ In addition, we request (but do not require) that you include in the \r\n+ end-user documentation provided with the redistribution and/or in the \r\n+ software itself an acknowledgement equivalent to the following:\r\n+     \"This product includes software developed by the\r\n+      JDOM Project (http://www.jdom.org/).\"\r\n+ Alternatively, the acknowledgment may be graphical using the logos \r\n+ available at http://www.jdom.org/images/logos.\r\n+\r\n+ THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\r\n+ WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n+ DISCLAIMED.  IN NO EVENT SHALL THE JDOM AUTHORS OR THE PROJECT\r\n+ CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n+ SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n+ LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\r\n+ USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n+ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n+ OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\r\n+ OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n+ SUCH DAMAGE.\r\n+\r\n+ This software consists of voluntary contributions made by many \r\n+ individuals on behalf of the JDOM Project and was originally \r\n+ created by Jason Hunter <jhunter_AT_jdom_DOT_org> and\r\n+ Brett McLaughlin <brett_AT_jdom_DOT_org>.  For more information\r\n+ on the JDOM Project, please see <http://www.jdom.org/>. \r\n+\r\n+ */\r\n+\r"
  },
  {
    "sha": "586f8535710e0694409eedf59d4e35ff9b37cfbf",
    "filename": "llrpConnector/LICENSE/json-license.txt",
    "status": "added",
    "additions": 22,
    "deletions": 0,
    "changes": 22,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/json-license.txt",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/json-license.txt",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/LICENSE/json-license.txt?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,22 @@\n+\n+Copyright (c) 2002 JSON.org\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+The Software shall be used for Good, not Evil.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n\\ No newline at end of file"
  },
  {
    "sha": "819a50950894e174295e45da084dcab656524b29",
    "filename": "llrpConnector/LICENSE/log4j-license.txt",
    "status": "added",
    "additions": 203,
    "deletions": 0,
    "changes": 203,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/log4j-license.txt",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/log4j-license.txt",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/LICENSE/log4j-license.txt?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,203 @@\n+\r\n+\r\n+                                     Apache License\r\n+                               Version 2.0, January 2004\r\n+                            http://www.apache.org/licenses/\r\n+     \r\n+       TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\r\n+     \r\n+       1. Definitions.\r\n+     \r\n+          \"License\" shall mean the terms and conditions for use, reproduction,\r\n+          and distribution as defined by Sections 1 through 9 of this document.\r\n+     \r\n+          \"Licensor\" shall mean the copyright owner or entity authorized by\r\n+          the copyright owner that is granting the License.\r\n+     \r\n+          \"Legal Entity\" shall mean the union of the acting entity and all\r\n+          other entities that control, are controlled by, or are under common\r\n+          control with that entity. For the purposes of this definition,\r\n+          \"control\" means (i) the power, direct or indirect, to cause the\r\n+          direction or management of such entity, whether by contract or\r\n+          otherwise, or (ii) ownership of fifty percent (50%) or more of the\r\n+          outstanding shares, or (iii) beneficial ownership of such entity.\r\n+     \r\n+          \"You\" (or \"Your\") shall mean an individual or Legal Entity\r\n+          exercising permissions granted by this License.\r\n+     \r\n+          \"Source\" form shall mean the preferred form for making modifications,\r\n+          including but not limited to software source code, documentation\r\n+          source, and configuration files.\r\n+     \r\n+          \"Object\" form shall mean any form resulting from mechanical\r\n+          transformation or translation of a Source form, including but\r\n+          not limited to compiled object code, generated documentation,\r\n+          and conversions to other media types.\r\n+     \r\n+          \"Work\" shall mean the work of authorship, whether in Source or\r\n+          Object form, made available under the License, as indicated by a\r\n+          copyright notice that is included in or attached to the work\r\n+          (an example is provided in the Appendix below).\r\n+     \r\n+          \"Derivative Works\" shall mean any work, whether in Source or Object\r\n+          form, that is based on (or derived from) the Work and for which the\r\n+          editorial revisions, annotations, elaborations, or other modifications\r\n+          represent, as a whole, an original work of authorship. For the purposes\r\n+          of this License, Derivative Works shall not include works that remain\r\n+          separable from, or merely link (or bind by name) to the interfaces of,\r\n+          the Work and Derivative Works thereof.\r\n+     \r\n+          \"Contribution\" shall mean any work of authorship, including\r\n+          the original version of the Work and any modifications or additions\r\n+          to that Work or Derivative Works thereof, that is intentionally\r\n+          submitted to Licensor for inclusion in the Work by the copyright owner\r\n+          or by an individual or Legal Entity authorized to submit on behalf of\r\n+          the copyright owner. For the purposes of this definition, \"submitted\"\r\n+          means any form of electronic, verbal, or written communication sent\r\n+          to the Licensor or its representatives, including but not limited to\r\n+          communication on electronic mailing lists, source code control systems,\r\n+          and issue tracking systems that are managed by, or on behalf of, the\r\n+          Licensor for the purpose of discussing and improving the Work, but\r\n+          excluding communication that is conspicuously marked or otherwise\r\n+          designated in writing by the copyright owner as \"Not a Contribution.\"\r\n+     \r\n+          \"Contributor\" shall mean Licensor and any individual or Legal Entity\r\n+          on behalf of whom a Contribution has been received by Licensor and\r\n+          subsequently incorporated within the Work.\r\n+     \r\n+       2. Grant of Copyright License. Subject to the terms and conditions of\r\n+          this License, each Contributor hereby grants to You a perpetual,\r\n+          worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n+          copyright license to reproduce, prepare Derivative Works of,\r\n+          publicly display, publicly perform, sublicense, and distribute the\r\n+          Work and such Derivative Works in Source or Object form.\r\n+     \r\n+       3. Grant of Patent License. Subject to the terms and conditions of\r\n+          this License, each Contributor hereby grants to You a perpetual,\r\n+          worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n+          (except as stated in this section) patent license to make, have made,\r\n+          use, offer to sell, sell, import, and otherwise transfer the Work,\r\n+          where such license applies only to those patent claims licensable\r\n+          by such Contributor that are necessarily infringed by their\r\n+          Contribution(s) alone or by combination of their Contribution(s)\r\n+          with the Work to which such Contribution(s) was submitted. If You\r\n+          institute patent litigation against any entity (including a\r\n+          cross-claim or counterclaim in a lawsuit) alleging that the Work\r\n+          or a Contribution incorporated within the Work constitutes direct\r\n+          or contributory patent infringement, then any patent licenses\r\n+          granted to You under this License for that Work shall terminate\r\n+          as of the date such litigation is filed.\r\n+     \r\n+       4. Redistribution. You may reproduce and distribute copies of the\r\n+          Work or Derivative Works thereof in any medium, with or without\r\n+          modifications, and in Source or Object form, provided that You\r\n+          meet the following conditions:\r\n+     \r\n+          (a) You must give any other recipients of the Work or\r\n+              Derivative Works a copy of this License; and\r\n+     \r\n+          (b) You must cause any modified files to carry prominent notices\r\n+              stating that You changed the files; and\r\n+     \r\n+          (c) You must retain, in the Source form of any Derivative Works\r\n+              that You distribute, all copyright, patent, trademark, and\r\n+              attribution notices from the Source form of the Work,\r\n+              excluding those notices that do not pertain to any part of\r\n+              the Derivative Works; and\r\n+     \r\n+          (d) If the Work includes a \"NOTICE\" text file as part of its\r\n+              distribution, then any Derivative Works that You distribute must\r\n+              include a readable copy of the attribution notices contained\r\n+              within such NOTICE file, excluding those notices that do not\r\n+              pertain to any part of the Derivative Works, in at least one\r\n+              of the following places: within a NOTICE text file distributed\r\n+              as part of the Derivative Works; within the Source form or\r\n+              documentation, if provided along with the Derivative Works; or,\r\n+              within a display generated by the Derivative Works, if and\r\n+              wherever such third-party notices normally appear. The contents\r\n+              of the NOTICE file are for informational purposes only and\r\n+              do not modify the License. You may add Your own attribution\r\n+              notices within Derivative Works that You distribute, alongside\r\n+              or as an addendum to the NOTICE text from the Work, provided\r\n+              that such additional attribution notices cannot be construed\r\n+              as modifying the License.\r\n+     \r\n+          You may add Your own copyright statement to Your modifications and\r\n+          may provide additional or different license terms and conditions\r\n+          for use, reproduction, or distribution of Your modifications, or\r\n+          for any such Derivative Works as a whole, provided Your use,\r\n+          reproduction, and distribution of the Work otherwise complies with\r\n+          the conditions stated in this License.\r\n+     \r\n+       5. Submission of Contributions. Unless You explicitly state otherwise,\r\n+          any Contribution intentionally submitted for inclusion in the Work\r\n+          by You to the Licensor shall be under the terms and conditions of\r\n+          this License, without any additional terms or conditions.\r\n+          Notwithstanding the above, nothing herein shall supersede or modify\r\n+          the terms of any separate license agreement you may have executed\r\n+          with Licensor regarding such Contributions.\r\n+     \r\n+       6. Trademarks. This License does not grant permission to use the trade\r\n+          names, trademarks, service marks, or product names of the Licensor,\r\n+          except as required for reasonable and customary use in describing the\r\n+          origin of the Work and reproducing the content of the NOTICE file.\r\n+     \r\n+       7. Disclaimer of Warranty. Unless required by applicable law or\r\n+          agreed to in writing, Licensor provides the Work (and each\r\n+          Contributor provides its Contributions) on an \"AS IS\" BASIS,\r\n+          WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\r\n+          implied, including, without limitation, any warranties or conditions\r\n+          of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\r\n+          PARTICULAR PURPOSE. You are solely responsible for determining the\r\n+          appropriateness of using or redistributing the Work and assume any\r\n+          risks associated with Your exercise of permissions under this License.\r\n+     \r\n+       8. Limitation of Liability. In no event and under no legal theory,\r\n+          whether in tort (including negligence), contract, or otherwise,\r\n+          unless required by applicable law (such as deliberate and grossly\r\n+          negligent acts) or agreed to in writing, shall any Contributor be\r\n+          liable to You for damages, including any direct, indirect, special,\r\n+          incidental, or consequential damages of any character arising as a\r\n+          result of this License or out of the use or inability to use the\r\n+          Work (including but not limited to damages for loss of goodwill,\r\n+          work stoppage, computer failure or malfunction, or any and all\r\n+          other commercial damages or losses), even if such Contributor\r\n+          has been advised of the possibility of such damages.\r\n+     \r\n+       9. Accepting Warranty or Additional Liability. While redistributing\r\n+          the Work or Derivative Works thereof, You may choose to offer,\r\n+          and charge a fee for, acceptance of support, warranty, indemnity,\r\n+          or other liability obligations and/or rights consistent with this\r\n+          License. However, in accepting such obligations, You may act only\r\n+          on Your own behalf and on Your sole responsibility, not on behalf\r\n+          of any other Contributor, and only if You agree to indemnify,\r\n+          defend, and hold each Contributor harmless for any liability\r\n+          incurred by, or claims asserted against, such Contributor by reason\r\n+          of your accepting any such warranty or additional liability.\r\n+     \r\n+       END OF TERMS AND CONDITIONS\r\n+     \r\n+       APPENDIX: How to apply the Apache License to your work.\r\n+     \r\n+          To apply the Apache License to your work, attach the following\r\n+          boilerplate notice, with the fields enclosed by brackets \"[]\"\r\n+          replaced with your own identifying information. (Don't include\r\n+          the brackets!)  The text should be enclosed in the appropriate\r\n+          comment syntax for the file format. We also recommend that a\r\n+          file or class name and description of purpose be included on the\r\n+          same \"printed page\" as the copyright notice for easier\r\n+          identification within third-party archives.\r\n+     \r\n+       Copyright [yyyy] [name of copyright owner]\r\n+     \r\n+       Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+       you may not use this file except in compliance with the License.\r\n+       You may obtain a copy of the License at\r\n+     \r\n+           http://www.apache.org/licenses/LICENSE-2.0\r\n+     \r\n+       Unless required by applicable law or agreed to in writing, software\r\n+       distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+       See the License for the specific language governing permissions and\r\n+       limitations under the License.\r"
  },
  {
    "sha": "8c1840428abf0eeb52302a925d380e6edc581338",
    "filename": "llrpConnector/LICENSE/okhttp3-license.txt",
    "status": "added",
    "additions": 13,
    "deletions": 0,
    "changes": 13,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/okhttp3-license.txt",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/okhttp3-license.txt",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/LICENSE/okhttp3-license.txt?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,13 @@\n+Copyright 2016 Square, Inc.\r\n+\r\n+Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+you may not use this file except in compliance with the License.\r\n+You may obtain a copy of the License at\r\n+\r\n+   http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+Unless required by applicable law or agreed to in writing, software\r\n+distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+See the License for the specific language governing permissions and\r\n+limitations under the License.\r"
  },
  {
    "sha": "31bb8ac9dbcf44032d779401306533427835456a",
    "filename": "llrpConnector/LICENSE/slf4j-license.txt",
    "status": "added",
    "additions": 15,
    "deletions": 0,
    "changes": 15,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/slf4j-license.txt",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/LICENSE/slf4j-license.txt",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/LICENSE/slf4j-license.txt?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,15 @@\n+Copyright (c) 2004-2017 QOS.ch\r\n+All rights reserved.\r\n+\r\n+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\r\n+documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\r\n+rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit\r\n+persons to whom the Software is furnished to do so, subject to the following conditions:\r\n+\r\n+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\r\n+Software.\r\n+\r\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\r\n+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n+OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r"
  },
  {
    "sha": "6772bac3e10e5627b118b9764b77fc79cbd5020c",
    "filename": "llrpConnector/README.md",
    "status": "added",
    "additions": 266,
    "deletions": 0,
    "changes": 266,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/README.md",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/README.md",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/README.md?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,266 @@\n+# Overview\r\n+\r\n+This document outlines the Low-Level Reader Protocol (LLRP) Connector. This connector is used to connect with an \r\n+RFID Readers supporting the LLRP Standard version 1.1.\r\n+\r\n+To incorporate this Enterprise Connector (also known as an Extension Source), you will need to create one or more\r\n+Sources in the Vantiq system. Each Vantiq Source will connect to **one** RFID Reader. The Vantiq Source configuration \r\n+contains the hostname of the RFID Reader.  Though, this Enterprise Connector may connect to multiple RFID Readers by \r\n+by creating multiple Vantiq Source(and associated Vantiq Source). The documentation has been split into two parts, [Setting Up Your Machine](#machine) and \r\n+[Setting Up Your Vantiq Source](#vantiq).\r\n+\r\n+This connector will only connect to the RFID Reader upon successful connection to the Vantiq\r\n+Source.  If the Vantiq Source is disabled or disconnected, the connection the associated RFID\r\n+Reader will also be closed.  This is done primarily to allow the RFID Reader to buffer all Tag Reads that cannot be \r\n+sent to the Vantiq Source.\r\n+\r\n+# Prerequisites <a name=\"pre\" id=\"pre\"></a>\r\n+\r\n+An understanding of the VANTIQ Extension Source SDK is assumed. Please read the [Extension Source README.md](../README.md) \r\n+for more information.\r\n+\r\n+A general understanding of the [LLRP standard v1.1](https://www.gs1.org/standards/epc-rfid/llrp/1-1) and specifics to \r\n+the desired RFID Reader is recommended.  Additional developer information is provided in the\r\n+[LLRP Toolkit](http://llrp.org/index.html), which also point to the LLRP Tool Kit [javadoc](http://llrp.org/docs/javaapidoc/).\r\n+\r\n+The user must [define the LLRP Source implementation](#vantiq) in the \r\n+Vantiq IDE. For an example of the definition, please see the \r\n+[*llrpConnectorImpl.json*](src/test/resources/llrpConnectorImpl.json) file located in the *src/test/resources* directory.\r\n+\r\n+Additionally, an example project named *llrpConnectorExample.zip* can be found in the *src/test/resources* directory.\r\n+\r\n+# Setting Up Your Machine <a name=\"machine\" id=\"machine\"></a>\r\n+\r\n+## Repository Contents\r\n+\r\n+*   **LLRPConnector** -- The main interface to the RFID reader based on the LLRP version 1.1 of the standard. Connection\r\n+    to the RFID Reader is only made after a successful connection to the Vantiq source.\r\n+*   **LLRPConnectorMain** -- The main function for the program. Connects to sources as specified in the configuration \r\n+file.\r\n+*   **LLRPConnectorCore** -- Does the work of reading RFID tags, and send the ID back to \r\n+Vantiq.\r\n+*   **LLRPConnectorHandleConfiguration** -- Processes the source configuration and calls the code to poll for data from \r\n+files if configured to do so.\r\n+\r\n+## How to Run the Program\r\n+\r\n+1.  Clone this repository (vantiq-extension-sources) and navigate into `<repo location>/vantiq-extension-sources`.\r\n+2.  Run `./gradlew llrpConnector:assemble`.\r\n+3.  Navigate to `<repo location>/vantiq-extension-sources/llrpConnector/build/distributions`. The zip and tar files \r\n+    both contain the same files, so choose whichever you prefer.\r\n+4.  Uncompress the file in the location that you would like to install the program.\r\n+6.  Run `<install location>/llrpConnector/bin/llrpConnector` with a local server.config file or specifying the \r\n+[server config file](#serverConfig) as the first argument. Note that the `server.config` file can be placed in the \r\n+`<install location>/llrpConnector/serverConfig/server.config` or `<install location>/llrpConnector/server.config` \r\n+locations.\r\n+\r\n+## Logging\r\n+To change the logging settings, edit the logging config file `<install location>/llrpConnector/src/main/resources/log4j2.xml`,\r\n+which is an [Apache Log4j configuration file](https://logging.apache.org/log4j/2.x/manual/configuration.html). The logger \r\n+name for each class is the class's fully qualified class name, *e.g.* \"io.vantiq.extjsdk.ExtensionWebSocketClient\".  \r\n+\r\n+## Server Config File\r\n+An understanding of the Vantiq Extension Source SDK is assumed. Please read the [Extension Source README.md](../README.md)\r\n+for more information.\r\n+\r\n+### Vantiq Options\r\n+*   **authToken**: Required. The authentication token to connect with. These can be obtained from the namespace admin.\r\n+*   **sources**: A comma separated list of the sources to which you wish to connect. Any whitespace will be\r\n+    removed when read.\r\n+*   **targetServer**: Required. The Vantiq server hosting the sources (e.g., \"dev.vantiq.com\").\r\n+\r\n+# Setting Up Your Vantiq Source <a name=\"vantiq\" id=\"vantiq\"></a>\r\n+\r\n+In order to incorporate this Extension Source, you will need to create the Source Implementation in the Vantiq system.\r\n+\r\n+## Source Implementation\r\n+\r\n+When creating a Vantiq source using an LLRPConnector Extension source, you must first load a source implementation.\r\n+This is done by using the `llrpConnectorImpl.json` file found in `src/test/resources/llrpConnectorImpl.json`.\r\n+To make the source type known to Vantiq, use the `vantiq` cli command\r\n+\r\n+```\r\n+vantiq -s <profileName> load sourceimpls <fileName>\r\n+```\r\n+\r\n+where `<profileName>` is replaced by the Vantiq profile name, and `<fileName>` is the file to be loaded.\r\n+\r\n+Once loaded, you will be able to create the Source in the Vantiq system.\r\n+\r\n+## Source Configuration <a name=\"sourceConfig\" id=\"sourceConfig\"></a>\r\n+\r\n+To set up the Source in the Vantiq system, you will need to add a Source to your project. Please check the [Prerequisites](#pre) \r\n+to make sure you have properly added a Source Implementation definition to your Vantiq namespace. Once this is complete, \r\n+you can select LLRP (or whatever you named your Source Implementation) as the Source Type. You will then need \r\n+to fill out the Source Configuration Document.\r\n+\r\n+The Configuration document may look similar to the following example:\r\n+\r\n+    {\r\n+       \"llrpConfig\": {\r\n+          \"general\": {\r\n+             \"hostname\": \"fx7500fcc3e9\",\r\n+             \"readerPort\": 5084,\r\n+             \"tagReadInterval\": 500,\r\n+             \"logLevel\": \"debug\"\r\n+          }\r\n+       }\r\n+    }\r\n+\r\n+### Options Available for llrpConfig\r\n+**Note:** The \"llrpConfig\" and \"general\" portions must be included in the source configuration.\r\n+*  **hostame** - Required. The hostame or IP Address of the RFID Reader\r\n+*  **readerPort** - Required. The readerPort to connect to the RFID Reader, which the LLRP protocol specification \r\n+   specifies port 5084 is used for data transfer.\r\n+*  **tagReadInterval** - Optional. Interval in milliseconds to receive collected Tag Data from the RFID Reader. \r\n+   (Default: 500)\r\n+*  **logLevel** - Optional. Indicates log level for messages to be sent to Vantiq ('info', 'warn', 'error', 'debug' \r\n+   are allowed). (Default: send no log messages)\r\n+   \r\n+## Notification Messages Sent To Vantiq Source\r\n+Once a connection is successfully made, messages will automatically be sent to Vantiq based on the Vantiq Source \r\n+configuration properties.\r\n+\r\n+### Log Messages\r\n+\r\n+Receipt of any log messages sent from the LLRP Connector will be based on the `logLevel` property in the [Vantiq Source \r\n+Configuration](#sourceConfig).  This property is optional and if not specified no messages will be sent to the Vantiq \r\n+Source. The following log level values are supported:\r\n+* **error** - Unexpected error conditions\r\n+* **warn** - Disconnection information\r\n+* **info** - Successful connection information\r\n+* **debug** - General messages sent/received to/from the RFID Reader\r\n+\r\n+The `loglevel` is hierarchical in that specififying a lower level will send all log levels up to the desired level.  \r\n+For example, specifying `info` will send `error`, `warn`, and `info` log messages.\r\n+\r\n+The JSON format of a Log message contains the following properties:\r\n+* **eventType** - Either `errorLog`, `warnLog`, `infoLog`, or `debugLog`, depending on the specified `logLevel` in the \r\n+  Vantiq source configuration.\r\n+* **sourceName** - The Vantiq source name which is used to differentiate when multiple RFID Readers are connected to \r\n+  the same LLRP Connector.\r\n+* **hostname** - The RFID Reader's hostname \r\n+* **readerId** - The RFID Reader's ID\r\n+* **msg** - Log message provided\r\n+\r\n+Log Message Example:\r\n+```\r\n+{   \"eventType\": \"errorLog\",\r\n+    \"sourceName\": \"ZebraRFID\",\r\n+    \"hostname\": \"fx7500fcc3e9\",\r\n+    \"readerId\": \"84248dfffffcc3e9\",\r\n+    \"msg\": \"DEBUG: Sending Reader: GET_READER_CAPABILITIES\"\r\n+}\r\n+```\r\n+**Note**: To capture the Reader Capabilities and Reader Configuration, set the `logLevel` to `debug`.  This information \r\n+can be used when using a new RFID Reader and want to understand the capabilities of the RFID Reader and configuration \r\n+settings it was set up to use.\r\n+\r\n+### Reader Status Message\r\n+\r\n+Whenever the connection between the LLRP Connector and the RFID Reader changes, a Reader Status message is sent to the \r\n+Vantiq Source.\r\n+\r\n+The JSON format of Reader Status message contains the following properties:\r\n+* **eventType** - `readerStatus`\r\n+* **readerId** - The RFID Reader's ID\r\n+* **readerOnline** - Boolean value where `True` is `Online` and 'False` is `Offline`\r\n+\r\n+Reader Status Message Example:\r\n+```\r\n+{   \"eventType\": \"readerStatus\",\r\n+    \"readerId\": \"84248dfffffcc3e9\",\r\n+    \"readerOnline\": True\r\n+}\r\n+```\r\n+### Reader Antenna Data Message\r\n+\r\n+This message is sent during the initial connection of the LLRP Connector to the RFID Reader.\r\n+\r\n+The JSON format of Reader Antenna Data message contains the following properties:\r\n+* **eventType** - `readerData`\r\n+* **readerId** - The RFID Reader's ID\r\n+* **antennaIds** - An array of the potential antenna IDs possible for the RFID Reader.  While an RFID Reader may \r\n+  support multiple antennas, not all ports will have an actual antenna connected to the RFID Reader.`\r\n+\r\n+Reader Antenna Data Message Example:\r\n+```\r\n+{   \"eventType\": \"readerData\",\r\n+    \"readerId\": \"84248dfffffcc3e9\",\r\n+    \"antennaIds\": [1,2,3,4]\r\n+}\r\n+```\r\n+\r\n+### RFID Reader Tag Data Message\r\n+\r\n+The RFID Reader Tag Data is sent to the Vantiq Source as the LLRP Connector receives the data from the RFID Reader.  \r\n+When the connection is down between the RFID Reader and the LLRP Connector, the RFID Reader caches any Tags found in \r\n+the antenna's Field Of View (FOV). Once reconnected, the cached tags read will be sent to the Vantiq source.\r\n+\r\n+RFID Tags will continually send their ID while charged by the RFID Reader through an antenna.  The RFID Reader will \r\n+count the number of times a tag reports since the last time it was asked to report.  The configured `tagReadInterval` \r\n+value specified in the Vantiq source, identifies the frequency the RFID Reader should report its findings from all \r\n+antennas.  This reported findings is received by the LLRP Connector and the RFID Reader Tag Data Message is sent \r\n+to the Vantiq Source.\r\n+\r\n+The JSON format of RFID Reader Tag Data message contains the following properties:\r\n+* **eventType** - `readerData`\r\n+* **readerId** - The RFID Reader's ID\r\n+* **tags** - An array of the Tags found in the FOV reported by the RFID Reader.  Properties capture include:\r\n+  * **tagId** - Tag ID\r\n+  * **antennaId** - RFID Reader's antenna ID\r\n+  * **firstSeenTimestampUTC** - When the tag was first seen in the FOV by the reporting Antenna. UTC Microseconds.\r\n+  * **lastSeenTimestampUTC** - When the tag was last seen in the FOV by the reporting Antenna. UTC Microseconds.\r\n+  * **tagSeenCount** - Number of times the tag responded during the `tagReadInterval`.\r\n+  * **peakRSSI** - The peak received power of the tag in dBm.\r\n+  * **accessSpecID** - As defined in the LLRP specification.\r\n+  * **accessSpecIDName** - As defined in the LLRP specification.\r\n+  * **ROSpecID** - As defined in the LLRP specification.\r\n+  * **ROSpecIDName** - As defined in the LLRP specification.\r\n+  * **channelIndex** - As defined in the LLRP specification.\r\n+  * **specIndex** - As defined in the LLRP specification.\r\n+\r\n+RFID Reader Tag Data Message Example:\r\n+```\r\n+{   \"eventType\": \"readerData\",\r\n+    \"readerId\": \"84248dfffffcc3e9\",\r\n+    \"tags\":   [{\"tagId\":\"ca462000045c00000000\",\r\n+                \"antennaId\":2,\r\n+                \"tagSeenCount\":18,\r\n+                \"peakRSSI\":-92,\r\n+                \"firstSeenTime\":1615962710571000,\r\n+                \"lastSeenTime\":1615962710571000,\r\n+                \"ROSpecIDName\": \"ROSpecID\", \r\n+                \"accessSpecIDName\": \"AccessSpecID\",\r\n+                \"specIndex\": 1, \r\n+                \"ROSpecID\": 1,\r\n+                \"accessSpecID\": 0, \r\n+                \"channelIndex\": 50},\r\n+                {\"tagId\":\"ca462000045c00000000\",\r\n+                \"antennaId\":3,\r\n+                \"tagSeenCount\":38,\r\n+                \"peakRSSI\":-61,\r\n+                \"firstSeenTime\":1615962711171000,\r\n+                \"lastSeenTime\":1615962711171000,\r\n+                \"ROSpecIDName\": \"ROSpecID\", \r\n+                \"accessSpecIDName\": \"AccessSpecID\",\r\n+                \"specIndex\": 1, \r\n+                \"ROSpecID\": 1,\r\n+                \"accessSpecID\": 0, \r\n+                \"channelIndex\": 50}]\r\n+}\r\n+```\r\n+\r\n+## Licensing\r\n+The source code uses the [MIT License](https://opensource.org/licenses/MIT).  \r\n+\r\n+xerces-j, mina, common-lang3, ltkjava, okhttp3, log4j, and jackson-databind are licensed under\r\n+[Apache Version 2.0 License](http://www.apache.org/licenses/LICENSE-2.0).  \r\n+\r\n+slf4j is licensed under the [MIT License](https://opensource.org/licenses/MIT).\r\n+\r\n+json is licensed under the [JSON License](https://www.json.org/license.html).\r\n+\r\n+jdom is licensed under the [JDOM License](http://jdom.org/dist/binary/archive/jdom-1.0.zip LICENSE.txt).\r\n+\r\n+jargs is licensed under the [JArgs License](https://sourceforge.net/projects/jargs/files/jargs/1.0/jargs-1.0.zip LICENSE.txt).\n\\ No newline at end of file"
  },
  {
    "sha": "a5c7e6cb761c04c9bc4434e7dd25697cee6421a3",
    "filename": "llrpConnector/build.gradle",
    "status": "added",
    "additions": 49,
    "deletions": 0,
    "changes": 49,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/build.gradle",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/build.gradle",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/build.gradle?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,49 @@\n+group 'io.vantiq'\r\n+version 'unspecified'\r\n+\r\n+apply plugin: 'java'\r\n+apply plugin: 'application'\r\n+\r\n+sourceCompatibility = 1.8\r\n+\r\n+repositories {\r\n+    mavenCentral()\r\n+    jcenter()\r\n+}\r\n+\r\n+mainClassName = 'io.vantiq.extsrc.llrpConnector.LLRPConnectorMain'\r\n+\r\n+startScripts{\r\n+    doLast{\r\n+        def windowsScriptFile = file getWindowsScript()\r\n+        def unixScriptFile = file getUnixScript()\r\n+        // Add the log Config to the top of the classpath\r\n+        windowsScriptFile.text = windowsScriptFile.text.replace(\"CLASSPATH=\", \"CLASSPATH=%APP_HOME%\\\\logConfig;\")\r\n+        unixScriptFile.text = unixScriptFile.text.replace('CLASSPATH=', 'CLASSPATH=$APP_HOME/logConfig:')\r\n+    }\r\n+}\r\n+\r\n+// Copies the logger setup into logConfig in the distribution\r\n+applicationDistribution.from(\"src/main/resources\") {\r\n+    include \"log4j2.xml\"\r\n+    into \"logConfig\"\r\n+}\r\n+\r\n+dependencies {\r\n+    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\r\n+    implementation 'com.google.guava:guava:23.0'\r\n+    implementation 'org.apache.commons:commons-lang3:3.11'\r\n+    implementation 'org.json:json:20210307'\r\n+\r\n+    compile project(':extjsdk')\r\n+\r\n+    // Used to compile additional libraries\r\n+    compile fileTree(dir: 'libs', include: ['*.jar'])\r\n+\r\n+    compile \"org.slf4j:slf4j-api:1.7.25\"\r\n+    compile \"org.apache.logging.log4j:log4j-slf4j-impl:2.11.0\"\r\n+\r\n+    // Use JUnit test framework\r\n+    testCompile 'junit:junit:4.12'\r\n+    testCompile project(path:\":extjsdk\", configuration:\"testArtifacts\")\r\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "116cce06239e75430b9de470420f63f03743ffbb",
    "filename": "llrpConnector/libs/ltkjava-1.0.0.7-with-dependencies.jar",
    "status": "added",
    "additions": 0,
    "deletions": 0,
    "changes": 0,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/libs/ltkjava-1.0.0.7-with-dependencies.jar",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/libs/ltkjava-1.0.0.7-with-dependencies.jar",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/libs/ltkjava-1.0.0.7-with-dependencies.jar?ref=1816057ce6a0bc407ac57004661ae821f6c40145"
  },
  {
    "sha": "d62b07a10400e28ced5889e366b9f01d07afc75d",
    "filename": "llrpConnector/src/main/docker/Dockerfile",
    "status": "added",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/docker/Dockerfile",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/docker/Dockerfile",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/src/main/docker/Dockerfile?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,5 @@\n+FROM openjdk:11-jre-slim\r\n+RUN mkdir /app\r\n+ADD llrpConnector.tar /app\r\n+WORKDIR /app\r\n+ENTRYPOINT [\"./llrpConnector/bin/llrpConnector\"]\n\\ No newline at end of file"
  },
  {
    "sha": "050fb4dccd4572c255e6b2a9e8b2d9269b06770c",
    "filename": "llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnector.java",
    "status": "added",
    "additions": 1531,
    "deletions": 0,
    "changes": 1531,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnector.java",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnector.java",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnector.java?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,1531 @@\n+/*\n+ * Copyright (c) 2021 VANTIQ, Inc.\n+ *\n+ * All rights reserved.\n+ *\n+ * SPDX: MIT\n+ */\n+package io.vantiq.extsrc.llrpConnector;\n+\n+import io.vantiq.extsrc.llrpConnector.exception.VantiqLLRPException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+\n+import org.apache.commons.lang3.exception.ExceptionUtils;\n+import org.json.JSONObject;\n+import org.json.JSONArray;\n+import org.json.XML;\n+import org.llrp.ltk.exceptions.InvalidLLRPMessageException;\n+import org.llrp.ltk.generated.LLRPMessageFactory;\n+import org.llrp.ltk.generated.enumerations.AISpecStopTriggerType;\n+import org.llrp.ltk.generated.enumerations.AccessReportTriggerType;\n+import org.llrp.ltk.generated.enumerations.AirProtocols;\n+import org.llrp.ltk.generated.enumerations.ConnectionAttemptStatusType;\n+import org.llrp.ltk.generated.enumerations.GetReaderCapabilitiesRequestedData;\n+import org.llrp.ltk.generated.enumerations.GetReaderConfigRequestedData;\n+import org.llrp.ltk.generated.enumerations.KeepaliveTriggerType;\n+import org.llrp.ltk.generated.enumerations.NotificationEventType;\n+import org.llrp.ltk.generated.enumerations.ROReportTriggerType;\n+import org.llrp.ltk.generated.enumerations.ROSpecStartTriggerType;\n+import org.llrp.ltk.generated.enumerations.ROSpecState;\n+import org.llrp.ltk.generated.enumerations.ROSpecStopTriggerType;\n+import org.llrp.ltk.generated.messages.ADD_ROSPEC;\n+import org.llrp.ltk.generated.messages.ADD_ROSPEC_RESPONSE;\n+import org.llrp.ltk.generated.messages.CLOSE_CONNECTION;\n+import org.llrp.ltk.generated.messages.DELETE_ROSPEC;\n+import org.llrp.ltk.generated.messages.DELETE_ROSPEC_RESPONSE;\n+import org.llrp.ltk.generated.messages.DISABLE_ROSPEC;\n+import org.llrp.ltk.generated.messages.DISABLE_ROSPEC_RESPONSE;\n+import org.llrp.ltk.generated.messages.ENABLE_EVENTS_AND_REPORTS;\n+import org.llrp.ltk.generated.messages.ENABLE_ROSPEC;\n+import org.llrp.ltk.generated.messages.ENABLE_ROSPEC_RESPONSE;\n+import org.llrp.ltk.generated.messages.GET_READER_CAPABILITIES;\n+import org.llrp.ltk.generated.messages.GET_READER_CAPABILITIES_RESPONSE;\n+import org.llrp.ltk.generated.messages.GET_READER_CONFIG_RESPONSE;\n+import org.llrp.ltk.generated.messages.KEEPALIVE_ACK;\n+import org.llrp.ltk.generated.messages.GET_READER_CONFIG;\n+import org.llrp.ltk.generated.messages.READER_EVENT_NOTIFICATION;\n+import org.llrp.ltk.generated.messages.RO_ACCESS_REPORT;\n+import org.llrp.ltk.generated.messages.SET_READER_CONFIG;\n+import org.llrp.ltk.generated.messages.SET_READER_CONFIG_RESPONSE;\n+import org.llrp.ltk.generated.messages.STOP_ROSPEC;\n+import org.llrp.ltk.generated.messages.STOP_ROSPEC_RESPONSE;\n+import org.llrp.ltk.generated.parameters.AISpec;\n+import org.llrp.ltk.generated.parameters.AISpecStopTrigger;\n+import org.llrp.ltk.generated.parameters.AccessReportSpec;\n+import org.llrp.ltk.generated.parameters.C1G2EPCMemorySelector;\n+import org.llrp.ltk.generated.parameters.EventsAndReports;\n+import org.llrp.ltk.generated.parameters.EventNotificationState;\n+import org.llrp.ltk.generated.parameters.InventoryParameterSpec;\n+import org.llrp.ltk.generated.parameters.KeepaliveSpec;\n+import org.llrp.ltk.generated.parameters.LLRPStatus;\n+import org.llrp.ltk.generated.parameters.ROBoundarySpec;\n+import org.llrp.ltk.generated.parameters.ROReportSpec;\n+import org.llrp.ltk.generated.parameters.ROSpec;\n+import org.llrp.ltk.generated.parameters.ROSpecStartTrigger;\n+import org.llrp.ltk.generated.parameters.ROSpecStopTrigger;\n+import org.llrp.ltk.generated.parameters.ReaderEventNotificationData;\n+import org.llrp.ltk.generated.parameters.ReaderEventNotificationSpec;\n+import org.llrp.ltk.generated.parameters.TagReportContentSelector;\n+import org.llrp.ltk.generated.parameters.TagReportData;\n+import org.llrp.ltk.types.Bit;\n+import org.llrp.ltk.types.LLRPMessage;\n+import org.llrp.ltk.types.UnsignedByte;\n+import org.llrp.ltk.types.UnsignedInteger;\n+import org.llrp.ltk.types.UnsignedShort;\n+import org.llrp.ltk.types.UnsignedShortArray;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * This LLRP Enterprise Connector uses the Java LLRP Toolkit (llrp.org).\n+ * It creates a connection with the reader, sets up an ROSpec (Reader Operation\n+ * Specification) to start reading tag data in Field of View (FOV) of the antenna.\n+ * It publishes all tag data found in the FOV during a configured duration.\n+ * (Default 500 milliseconds).  Some readers may not report the accurate LastSeenTime\n+ * and insteads fill it with the FirstSeenTime (use this one for storing).\n+ *\n+ * Note: Requires an Hostname/IP Address and Port to communicate with the RFID Reader.\n+ *\n+ * @author Mark Silva msilva@vantiq.com\n+ *\n+ */\n+public class LLRPConnector  {\n+    Logger              log  = LoggerFactory.getLogger(this.getClass().getCanonicalName());\n+\n+    // Valid logLevels\n+    private static ArrayList<String> LogLevels = new ArrayList<String>(Arrays.asList(\"error\", \"warn\", \"info\", \"debug\"));\n+    final static String INFO = \"info\";\n+    final static String WARN = \"warn\";\n+    final static String ERROR = \"error\";\n+    final static String DEBUG = \"debug\";\n+    final static String TAG_DATA_EVENT_NAME = \"tagData\";\n+    final static String READER_DATA_EVENT_NAME = \"readerData\";\n+    final static String READER_STATUS_EVENT_NAME = \"readerStatus\";\n+    final static String M_SUCCESS = \"M_Success\";  // String value for successful status\n+    final static Boolean READER_ONLINE = false;   // Used to set 'readerOffLine' property\n+    final static Boolean READER_OFFLINE = true;   // Used to set 'readerOffLine' property\n+\n+    // Used to reconnect if necessary\n+    private String hostname = null;\t\t    // Hostname/IP address of the reader\n+    private String sourceName = null;       // Vantiq Source name connected to\n+    private int readerPort = -1;\t\t\t// Reader communication port\n+    private int tagReadInterval = 500;\t\t// Frequency for ending AISpec\n+    private int logLevel = -1;              // Log level to send to Vantiq\n+    private static int ROSPEC_ID = 1;\t\t// ID used for collecting tags\n+\n+    private Socket connection;\t\t\t\t// Socket connection to reader\n+    private DataOutputStream out;\t\t\t// Stream when writing to reader\n+    private ReadThread rt = null;\t\t\t// Reads LLRP msg and add to queue\n+    private Thread msgThread = null;\t\t// Process regular msgs from reader\n+    private Thread tagThread = null;\t\t// Process tag data msgs from reader\n+    private Thread readerAliveThread = null;\t// Identify when reader is offline\n+    private LLRPConnectorCore llrpCore;\n+    private Boolean readerOffline = true;\t// Indicates the Reader is Offline\n+    private Boolean vantiqSourceOffline = true;\t// Indicates the connection to the Vantiq Source is Offline\n+    Instant lastKeepAlive = Instant.now();\t// Last point we rcvd from reader\n+\n+    /*\n+     * RECONNECT_INTERVAL is the duration to wait to check if Reader is online.\n+     * It may take 15-30 seconds to flush through stored messages on the reader\n+     * since we do not turn off the reading of tags (stored on reader and\n+     * processed on reconnect).\n+     * The KEEPALIVE_INTERVAL is the periodic interval the reader will use\n+     * to send a KEEPALIVE message.  If we don't receive a KEEPALIVE message\n+     * within the RECONNECT_INTERVAL, we drop the connection and try to\n+     * reconnect indefinitely.\n+     */\n+    final static int KEEPALIVE_INTERVAL = 5000;\n+    final static int RECONNECT_INTERVAL = 10000;\n+\n+    /**\n+     * Message queues for the tags and other messages\n+     */\n+    private LinkedBlockingQueue<LLRPMessage> queue\n+            = new LinkedBlockingQueue<LLRPMessage>();\n+    private LinkedBlockingQueue<LLRPMessage> tagQueue\n+            = new LinkedBlockingQueue<LLRPMessage>();\n+\n+    /**\n+     * Current reader Capabilities and Configuration information.\n+     * Captured but not used directly for now.\n+     */\n+    private JSONObject readerCapabilities = null;\n+    private JSONObject readerConfiguration = null;\n+    private String readerId = \"reader1\";\n+\n+    /**\n+     * This method creates a connection to the reader and sends LLRP\n+     * messages. Once connected, ideal communication is as follows:\n+     *     From Enterprise Connector\tFrom the Reader\n+     *  1) GET_READER_CAPABILIITIES \tGET_READER_CAPABILITIES_RESPONSE\n+     *  2) SET_READER_CONFIG \t\t\tSET_READER_CONFIG_RESPONSE\n+     *  3) GET_READER_CONFIG \t\t\tGET_READER_CONFIG_RESPONSE\n+     *  4) ADD_ROSPEC\t\t\t\t \tADD_ROSPEC_RESPONSE\n+     *  5) ENABLE_ROSPEC\t\t\t\tENABLE_ROSPEC_RESPONSE\n+     *  6) ENABLE_EVENTS_AND_REPORTS\t(NONE)\n+     *\n+     * During the above cycle, all other READER_EVENT_NOTIFICATION messages\n+     * are ignored.  After the reader starts up, it queues all messages\n+     * and processes them asynchronously.\n+     *\n+     * A KEEPALIVE message is configured to be sent from the reader\n+     * periodically and the LLRP Enterprise Connector sends back a\n+     * KEEPALIVE_ACK message to the reader.  If this ACK is not sent, the\n+     * reader will disconnect.\n+     *\n+     * Additionally, a timer task is used to assure the Reader stays alive.\n+     * If a KEEPALIVE message is not received at least once a minute the\n+     * LLRP Enterprise Connector will disconnect from the Reader and\n+     * continually attempt to reconnect with the Reader every minute.\n+     * Not all readers are alike, and it may get into a situation where\n+     * the Reader thinks another connection already exists.  In this case,\n+     * a reboot of the Reader should clear it up.\n+     *\n+     * @throws IOException\n+     * @throws VantiqLLRPException\n+     */\n+    public void setupLLRPConnector(LLRPConnectorCore llrpCore, String hostname,\n+                                   int readerPort, int tagReadInterval, String logLevel)\n+            throws IOException, VantiqLLRPException {\n+\n+        this.hostname = hostname;\n+        this.readerPort = readerPort;\n+        this.tagReadInterval = tagReadInterval;\n+        this.logLevel = LogLevels.indexOf(logLevel);\n+        this.llrpCore = llrpCore;  // Used to send messages to VANTIQ\n+        this.sourceName = llrpCore.getSourceName();\n+        this.vantiqSourceOffline = false; // We are only called if connection to Vantiq Source is up\n+        \n+        systemPrint(\"setupLLRP: hostname-\" + hostname + \":\" + readerPort + \" tagReadInterval: \" + tagReadInterval);\n+\n+        // Connect and set up the Reader in a thread - attempt every minute\n+        Thread setup = new Thread(() -> {\n+            connectAndSetupReader();\n+        });\n+        // Start up the connection/setup thread\n+        setup.start();\n+\n+        // Create the queue processing and keepalive threads for the reader\n+        createAndStartThreads();\n+    }\n+\n+    /**\n+     * Method used for initial connection and reconnecting to the Reader.\n+     * Running inside a thread to be able to pause and wait for responses to messages\n+     * which is received on blocking reads.\n+     *\n+     */\n+    private void connectAndSetupReader () {\n+\n+        try {\n+\n+            systemPrint(\"connectAndSetupReader started : \" + Thread.currentThread().getName());\n+            sendLogMessage(INFO, \"Attempting to connect to the the Reader\");\n+\n+            // If connected, nothing to do\n+            if (readerOffline && !vantiqSourceOffline) {\n+\n+                try {\n+                    // Clear any messages in the queue, keep tag messages\n+                    queue.clear();\n+\n+                    // Try to establish a connection to the reader\n+                    connection = new Socket(hostname, readerPort);\n+                    out = new DataOutputStream(connection.getOutputStream());\n+\n+                    // Start up the ReaderThread to read messages from socket to Console\n+                    rt = new ReadThread(connection);\n+                    rt.start();\n+\n+                    // ReaderEventNotificationData is sent by the Reader for a connection attempt,\n+                    // though can be sent for other reader events. List of events:\n+                    //\t\t<HoppingEventParameter>,\n+                    //\t\t<GPIEvent Parameter>,\n+                    //\t\t<ROSpecEvent Parameter>,\n+                    //\t\t<ReportBufferLevelWarningEvent Parameter>,\n+                    //\t\t<ReportBufferOverflowErrorEvent Parameter>,\n+                    //\t\t<ReaderExceptionEvent Parameter>,\n+                    //\t\t<RFSurveyEvent Parameter>,\n+                    //\t\t<AISpecEvent Parameter>,\n+                    //\t\t<AntennaEvent Parameter>,\n+                    //\t\t<ConnectionAttemptEvent Parameter>,\n+                    //\t\t<ConnectionCloseEvent Parameter> - unsolicited close by the reader\n+                    // Since we just tried to connect, we are expecting a ConnectionAttempEvent.\n+                    //\tPossible Values:\n+                    //\t\t  Value Definition\n+                    //\t\t  ----- ----------\n+                    //\t\t\t0\tSuccess\n+                    //\t\t\t1\tFailed (a Reader initiated connection already exists)\n+                    //\t\t\t2\tFailed (a Client initiated connection already exists)\n+                    //\t\t\t3\tFailed (any reason other than a connection already exists\n+                    //\t\t\t4\tAnother connection attempted\n+                    //\n+                    // We will skip all responses from the reader until a ConnectionAttempEvent is\n+                    // received.\n+                    LLRPMessage m = getNextMessage(\"CONNECTION_ATTEMPT\");\n+                    READER_EVENT_NOTIFICATION readerEventNotification = (READER_EVENT_NOTIFICATION) m;\n+                    ReaderEventNotificationData eventData = readerEventNotification\n+                            .getReaderEventNotificationData();\n+\n+                    ConnectionAttemptStatusType connectionStatus = eventData.getConnectionAttemptEvent().getStatus();\n+                    if (connectionStatus.toInteger() == ConnectionAttemptStatusType.Success) {\n+                        systemPrint(\"Connection attempt was successful\\n\");\n+                        sendLogMessage(INFO, \"Connection to Reader was successful\");\n+                    } else {\n+                        String msg = \"Reader Connection Unsuccessful: \" + connectionStatus.toString();\n+                        systemPrint(msg);\n+                        sendLogMessage(WARN, msg);\n+                        if (connection != null && !connection.isClosed())\n+                            connection.close();\n+                        return;\n+                    }\n+\n+                    // May want to get the Reader supported version and set to an appropriate version\n+\n+                    // Get the Reader Capabilities Response\n+                    readerCapabilities = getReaderCapabilities();\n+\n+                    // Create/Send the Reader Configuration and Get the Response\n+                    readerConfiguration = sendReaderConfiguration();\n+\n+                    // Create/Send ROSpec to start reading the tags\n+                    sendROSpec(tagReadInterval);\n+\n+                    // Indicate success\n+                    changeReaderStatus(READER_ONLINE);\n+\n+                    // Send an ENABLE_EVENTS_AND_REPORTS Message to start requesting tag data\n+                    ENABLE_EVENTS_AND_REPORTS report = new ENABLE_EVENTS_AND_REPORTS();\n+                    write(report, \"ENABLE_EVENTS_AND_REPORTS\");\n+\n+                } catch (VantiqLLRPException | IOException e) {\n+                    systemPrint(\"Unable to connect and startup the reader.\");\n+                    sendLogMessage(WARN, \"connectAndSetupReader: Unable to connect and startup the reader, retrying\");\n+                    if (connection != null && !connection.isClosed())\n+                        try {\n+                            connection.close();\n+                        } catch (Exception e1) {\n+                            systemPrint(\"Unable to close open connection. \");\n+                            log.error(\"Unable to close open connection. \", e);\n+                            sendLogMessage(ERROR, \"connectAndSetupReader: Unable to close open connection.\\n\"\n+                                    + ExceptionUtils.getStackTrace(e1));\n+                        }\n+                } catch (Exception e) {\n+                    systemPrint(\"Unexpected error while attempting to connect to the reader\");\n+                    log.error(\"Unexpected error while attempting to connect to the reader \", e);\n+                    sendLogMessage(ERROR, \"connectAndSetupReader: Unexpected error.\\n \"\n+                            + ExceptionUtils.getStackTrace(e));\n+                }\n+            } else {\n+                systemPrint(\"connectAndSetupReader: reader is offline\");\n+                sendLogMessage(ERROR, \"connectAndSetupReader: reader is offline\");\n+            }\n+        } catch (Exception e) {\n+            systemPrint(\"connectAndSetupReader: Unexpected error\");\n+            log.error(\"connectAndSetupReader: Unexpected error \", e);\n+            sendLogMessage(ERROR, \"connectAndSetupReader: Unexpected error.\\n\" + ExceptionUtils.getStackTrace(e));\n+        }\n+    }\n+\n+    /**\n+     *  Send the reader a \"GET_READER_CAPABILTIES\" message and wait for the response.\n+     *\n+     *  \tPossible request data values:\n+     *  \t\tValue   Definition\n+     *  \t\t-----   ----------\n+     *  \t\t  0\t    All\n+     *  \t\t  1\t\tGeneral Device Capabilities\n+     *  \t\t  2\t\tLLRP Capabilities\n+     *  \t\t  3\t\tRegulatory Capabilities\n+     *  \t\t  4\t\tAir Protocol LLRP Capabilities\n+     *\n+     * @return GET_READER_CAPABILITIES_RESPONSE with the reader capabilities\n+     * @throws VantiqLLRPException\n+     */\n+    private JSONObject getReaderCapabilities() throws VantiqLLRPException {\n+\n+       // Send the message to the reader to get it's capabilities\n+        GET_READER_CAPABILITIES getReaderCap = new GET_READER_CAPABILITIES();\n+        getReaderCap.setRequestedData(new GetReaderCapabilitiesRequestedData\n+                                            (GetReaderCapabilitiesRequestedData.LLRP_Capabilities));\n+        write(getReaderCap, \"GET_READER_CAPABILITIES\");\n+        pause(500);\n+\n+        JSONObject returnJSON = new JSONObject();\n+        try {\n+            LLRPMessage m = getNextMessage(\"GET_READER_CAPABILITIES_RESPONSE\");\n+            GET_READER_CAPABILITIES_RESPONSE readerCap = (GET_READER_CAPABILITIES_RESPONSE) m;\n+\n+            returnJSON = XML.toJSONObject(readerCap.toXMLString());\n+            sendLogMessage(DEBUG, \"READER_CAPABILITIES: \" + returnJSON);\n+        } catch (InvalidLLRPMessageException e) {\n+            reportLLRPError(e);\n+        } catch (Exception e) {\n+            log.error(\"getReaderCapabilities: Unexpected error \", e);\n+            sendLogMessage(ERROR, \"getReaderCapabilities: Unexpected error.\\n\" + ExceptionUtils.getStackTrace(e));\n+        }\n+        return returnJSON;\n+    }\n+\n+    /**\n+     *  Create and send the reader a \"SET_READER_CONFIG\" message and wait for the response.\n+     *\n+     *  \tPossible requested data values for GET_READER_CONFIG:\n+     *  \t\tValue   Definition\n+     *  \t\t-----   ----------\n+     *  \t\t  0\t    All\n+     *\t\t\t  1\t\tIdentification\n+     *\t\t\t  2\t\tAntennaProperties\n+     *\t\t\t  3\t\tAntennaConfiguration\n+     *\t\t\t  4\t\tROReportSpec\n+     *\t\t\t  5 \tReaderEventNotificationSpec\n+     *\t\t\t  6 \tAccessReportSpec\n+     *\t\t\t  7 \tLLRPConfigurationStateValue\n+     *\t\t\t  8\t\tKeepaliveSpec\n+     *\t\t\t  9\t\tGPIPortCurrentState\n+     *\t\t\t  10\tGPOWriteData\n+     *\t\t\t  11\tEventsAndReports\n+     *\n+     * @return GET_READER_CONFIG_RESPONSE with the reader configuration\n+     * @throws VantiqLLRPException\n+     */\n+    private JSONObject sendReaderConfiguration() throws VantiqLLRPException {\n+\n+        // Create and send a SET_READER_CONFIG Message with default ROReportSpec\n+        // and AccessReportSpec\n+        SET_READER_CONFIG setReaderConfig = createSetReaderConfig();\n+        write(setReaderConfig, \"SET_READER_CONFIG\");\n+        pause(250);\n+\n+        // Wait for the response\n+        LLRPMessage m = getNextMessage(\"SET_READER_CONFIG_RESPONSE\");\n+        SET_READER_CONFIG_RESPONSE resp = (SET_READER_CONFIG_RESPONSE) m;\n+        sendLogMessage(DEBUG, \"SET_READER_CONFIG_RESPONSE: \" + getLLRPStatus(resp.getLLRPStatus()));\n+\n+        // Send GET_READER_CONFIG after after set to store current settings\n+        GET_READER_CONFIG getReaderConfig = new GET_READER_CONFIG();\n+        getReaderConfig.setRequestedData(new GetReaderConfigRequestedData(\n+                GetReaderConfigRequestedData.All));\n+        getReaderConfig.setAntennaID(new UnsignedShort(0));  // get configuration on ALL antennas\n+        getReaderConfig.setGPIPortNum(new UnsignedShort(0)); // get GPI port current state for all GPI ports\n+        getReaderConfig.setGPOPortNum(new UnsignedShort(0)); // get GPO port current state for all GPO ports\n+        write(getReaderConfig, \"GET_READER_CONFIG\");\n+        pause(250);\n+\n+        JSONObject returnJSON = new JSONObject();\n+        try {\n+            LLRPMessage rm = getNextMessage(\"GET_READER_CONFIG_RESPONSE\");\n+            GET_READER_CONFIG_RESPONSE readerConfig = (GET_READER_CONFIG_RESPONSE) rm;\n+\n+            returnJSON = XML.toJSONObject(readerConfig.toXMLString());\n+            //systemPrint(\"GET_READER_CONFIG_RESPONSE: \" + returnJSON.toString(2));\n+            sendLogMessage(DEBUG, \"READER_CONFIG: \" + returnJSON);\n+\n+            // Get the reader and antennas\n+            JSONObject config = returnJSON.getJSONObject(\"llrp:GET_READER_CONFIG_RESPONSE\");\n+            Map<String, Object> tagObj = new HashMap<>();\n+            tagObj.put(\"eventType\", READER_DATA_EVENT_NAME);\n+            if (readerConfig != null) {\n+                // Get the reader ID\n+                JSONObject identification = config.getJSONObject(\"llrp:Identification\");\n+                if (identification != null) {\n+                    readerId = identification.getString(\"llrp:ReaderID\").toString();\n+                    tagObj.put(\"readerId\", readerId);\n+                }\n+                // Get the Antenna IDs\n+                JSONArray antennas = config.getJSONArray(\"llrp:AntennaProperties\");\n+                if (antennas != null) {\n+                    ArrayList<Integer> antennaArr = new ArrayList<Integer>();\n+                    for (int i = 0; i < antennas.length(); i++) {\n+                        JSONObject obj = antennas.getJSONObject(i);\n+                        Integer antenna = obj.getInt(\"llrp:AntennaID\");\n+                        antennaArr.add(antenna);\n+                    }\n+                    tagObj.put(\"antennaIds\", antennaArr);\n+                }\n+                // Send the tag data back to VANTIQ\n+                this.llrpCore.sendMessage(tagObj);\n+            }\n+        } catch (InvalidLLRPMessageException e) {\n+            reportLLRPError(e);\n+        } catch (Exception e) {\n+            log.error(\"sendReaderConfiguration: Unexpected error \", e);\n+            sendLogMessage(ERROR, \"sendReaderConfiguration: Unexpected error.\\n\" + ExceptionUtils.getStackTrace(e));\n+        }\n+        return returnJSON;\n+    }\n+\n+    /**\n+     * This method creates a SET_READER_CONFIG message to be sent to the reader.\n+     *\n+     *  \tPossible configuration data parameters for SET_READER_CONFIG:\n+     *  \t\t*ReaderEventNotificationSpec Parameter - see below\n+     *  \t\tAntenna Properties Parameter\n+     *  \t\tAntenna Configuration Parameter\n+     *  \t\t*ROReportSpec Parameter - see below\n+     *  \t\t*AccessReportSpec Parameter - see below\n+     *  \t\t*KeepaliveSpec Parameter - carries the specification for the keepalive\n+     *  \t\t\t\t\t\t\t\t\tmessage generation by the Reader. Includes\n+     *  \t\t\t\t\t\t\t\t\tperiodic trigger to send the keepalive message\n+     *  \t\tGPOWriteData Parameter\n+     *  \t\tGPIPortCurrentState Parameter\n+     *  \t\t*EventsAndReports Parameters - used to enable or disable the holding of\n+     *  \t\t\t\t\t\t\t\t\t    events and reports upon connection using\n+     *  \t\t\t\t\t\t\t\t\t    the HoldEventsAndReportsUponReconnect field\n+     *\n+     * Only the '*' parameters highlighted above are being included in the SET_READER_CONFIG\n+     *\n+     * @return SET_READER_CONFIG message\n+     */\n+    private SET_READER_CONFIG createSetReaderConfig() {\n+        SET_READER_CONFIG setReaderConfig = new SET_READER_CONFIG();\n+\n+        // ResetToFactoryDefault: If true, the Reader will set all configurable values\n+        //\t\tto factory defaults before applying the remaining parameters.\n+        setReaderConfig.setResetToFactoryDefault(new Bit(0));\n+\n+        // ReaderEventNotificationSpec Parameter - composed of a list of EventNotificationStates\n+        // -------------------------------------\n+        // The following are possible EventNotificationStates EventTypes:\n+        //      Value   Definition\n+        //      -----   -------------------------------------------\n+        //        0     Upon hopping to next channel (e.g., in FCC regulatory region)\n+        //        1     GPI event\n+        //        2     ROSpec event (start/end/preemption)\n+        //        3     Report buffer fill warning\n+        //        4     Reader exception event\n+        //        5     RFSurvey event (start/end)\n+        //        6     AISpec event (end)\n+        //        7     AISpec event (end) with singulation details\n+        //        8     Antenna event (disconnect/connect)\n+        //        9     SpecLoop event\n+        //  For each EventType, they can be enabled=true or disabled=false\n+\n+        //\t- Set up reporting for AISpec events, and ROSpec events\n+        ReaderEventNotificationSpec eventNoteSpec = new ReaderEventNotificationSpec();\n+        // GPI event - Disable\n+        EventNotificationState noteState = new EventNotificationState();\n+        noteState.setEventType(new NotificationEventType(NotificationEventType.GPI_Event));\n+        noteState.setNotificationState(new Bit(0));  // disable\n+        eventNoteSpec.addToEventNotificationStateList(noteState);\n+\n+        // ROSpec event - Enable\n+        noteState = new EventNotificationState();\n+        noteState.setEventType(new NotificationEventType(NotificationEventType.ROSpec_Event));\n+        noteState.setNotificationState(new Bit(1));  // start(0)/end(1)/preemption(2)\n+        eventNoteSpec.addToEventNotificationStateList(noteState);\n+\n+        // Report buffer fill warning - Disable (ReportBufferPercentageFull value: 0-100)\n+        noteState = new EventNotificationState();\n+        noteState.setEventType(new NotificationEventType(NotificationEventType.Report_Buffer_Fill_Warning));\n+        noteState.setNotificationState(new Bit(0));\n+        eventNoteSpec.addToEventNotificationStateList(noteState);\n+\n+        // Reader exception event - Disable\n+        noteState = new EventNotificationState();\n+        noteState.setEventType(new NotificationEventType(NotificationEventType.Reader_Exception_Event));\n+        noteState.setNotificationState(new Bit(0));\n+        eventNoteSpec.addToEventNotificationStateList(noteState);\n+\n+        // RFSurvey event - Disable\n+        noteState = new EventNotificationState();\n+        noteState.setEventType(new NotificationEventType(NotificationEventType.RFSurvey_Event));\n+        noteState.setNotificationState(new Bit(0));\n+        eventNoteSpec.addToEventNotificationStateList(noteState);\n+\n+        // AISpec event - Enable\n+        noteState = new EventNotificationState();\n+        noteState.setEventType(new NotificationEventType(NotificationEventType.AISpec_Event));\n+        noteState.setNotificationState(new Bit(1));\n+        eventNoteSpec.addToEventNotificationStateList(noteState);\n+\n+        // AISpec event (end) with singulation details - Enable\n+        noteState = new EventNotificationState();\n+        noteState.setEventType(new NotificationEventType(NotificationEventType.AISpec_Event_With_Details));\n+        noteState.setNotificationState(new Bit(1));\n+        eventNoteSpec.addToEventNotificationStateList(noteState);\n+\n+        // Antenna event - Disable\n+        noteState = new EventNotificationState();\n+        noteState.setEventType(new NotificationEventType(NotificationEventType.Antenna_Event));\n+        noteState.setNotificationState(new Bit(0));\n+        eventNoteSpec.addToEventNotificationStateList(noteState);\n+\n+        setReaderConfig.setReaderEventNotificationSpec(eventNoteSpec);\n+\n+        // ROReportSpec Parameter\n+        // ----------------------\n+        // - Create a default RoReportSpec so that reports are sent at the end of ROSpecs\n+        // - Default for ALL ROSpecs, though can be overridden as part of the ROSpec\n+        ROReportSpec roReportSpec = new ROReportSpec();\n+        roReportSpec.setN(new UnsignedShort(0));  // Unlimited tags, since ROSpec ends periodically\n+        roReportSpec.setROReportTrigger(new ROReportTriggerType(\n+                ROReportTriggerType.Upon_N_Tags_Or_End_Of_ROSpec));\n+\n+        // TagReportContentSelector: used to identify what to include in the report\n+        //\t- All options listed below, just turn on/off to identify which one.\n+        //\tNote: first/LastSeenTimestamp are epoch microseconds\n+        //\tNote: When TagReportData is returned from the reader, If an optional parameter is\n+        //\t\t  enabled, and is absent in the report, the Client SHALL assume that the value is\n+        //\t\t  identical to the last parameter of the same type received. For example, this\n+        //\t\t  allows the Readers to not send a parameter in the report whose value has not\n+        //\t\t  changed since the last time it was sent by the Reader.\n+        TagReportContentSelector tagReportContentSelector = new TagReportContentSelector();\n+        tagReportContentSelector.setEnableAccessSpecID(new Bit(1));\n+        tagReportContentSelector.setEnableAntennaID(new Bit(1));\n+        tagReportContentSelector.setEnableChannelIndex(new Bit(1));\n+        tagReportContentSelector.setEnableFirstSeenTimestamp(new Bit(1));\n+        tagReportContentSelector.setEnableInventoryParameterSpecID(new Bit(1));\n+        tagReportContentSelector.setEnableLastSeenTimestamp(new Bit(1));\n+        tagReportContentSelector.setEnablePeakRSSI(new Bit(1));\n+        tagReportContentSelector.setEnableROSpecID(new Bit(1));\n+        tagReportContentSelector.setEnableSpecIndex(new Bit(1));\n+        tagReportContentSelector.setEnableTagSeenCount(new Bit(1));\n+        C1G2EPCMemorySelector epcMemSel = new C1G2EPCMemorySelector();\n+        epcMemSel.setEnableCRC(new Bit(0));     // Only sending EPC in RO Report, disable CRC\n+        epcMemSel.setEnablePCBits(new Bit(0));  // Only sending EPC in RO Report, disable PC Bits\n+        tagReportContentSelector.addToAirProtocolEPCMemorySelectorList(epcMemSel);\n+\n+        roReportSpec.setTagReportContentSelector(tagReportContentSelector);\n+        setReaderConfig.setROReportSpec(roReportSpec);\n+\n+        // AccessReportSpec Parameter\n+        // --------------------------\n+        //\tAccessReportTrigger - 0 = Whenever ROReport is generated for the RO that triggered\n+        //\t\t\t\t\t\t\t  the execution of this AccessSpec\n+        //\t\t\t\t\t\t  1 = End of AccessSpec\n+        AccessReportSpec accessReportSpec = new AccessReportSpec();\n+        accessReportSpec.setAccessReportTrigger(new AccessReportTriggerType(\n+                AccessReportTriggerType.Whenever_ROReport_Is_Generated));\n+        setReaderConfig.setAccessReportSpec(accessReportSpec);\n+\n+        // KeepaliveSpec Parameter\n+        // -----------------------\n+        //\tkeepaliveTriggerType - (0 = Null no ack sent; 1 = Periodic, send based on Trigger Value)\n+        //\tperiodicTriggerValue - Time in milliseconds of no activity to send a Keepalive Ack message\n+        KeepaliveSpec keepaliveSpec = new KeepaliveSpec();\n+        keepaliveSpec.setKeepaliveTriggerType(new KeepaliveTriggerType (KeepaliveTriggerType.Periodic));\n+        keepaliveSpec.setPeriodicTriggerValue(new UnsignedInteger(KEEPALIVE_INTERVAL));\n+        setReaderConfig.setKeepaliveSpec(keepaliveSpec);\n+\n+        // EventsAndReports Parameter\n+        // -----------------------\n+        //\tHoldEventsAndReportsUponReconnect - (0 = do not hold reports; 1 = holds reports and events)\n+        //\n+        // The reader will not deliver any reports or events (except the ConnectionAttmptEvent)\n+        // when true.  Once the ENABLE_EVENTS_AND_REPORTS message is received the reader ceases its\n+        // hold on events and reports for the duration of the connection.\n+        //\n+        EventsAndReports eventsAndReportsSpec = new EventsAndReports();\n+        eventsAndReportsSpec.setHoldEventsAndReportsUponReconnect(new Bit(1));\n+        setReaderConfig.setEventsAndReports(eventsAndReportsSpec);\n+\n+        return setReaderConfig;\n+    }\n+\n+    /**\n+     * Create and send the ROSpec to the Reader - once this is sent, tag data will be returned\n+     *\n+     * Reader Operations (RO) define the parameters for operations such as Antenna Inventory\n+     * and RF Survey. Access Operations define the parameters for performing data access\n+     * operations to and from a tag.\n+     *\n+     * Note: If a connection terminates while currently processing an ROSpec,\n+     * \t\t that is, it wasn't deleted, then you will not be able to add a\n+     * \t\t new ROSpec with the same ID.  So, review the response and upon\n+     * \t\t errors, stop and delete before trying to add again.\n+     *\n+     * @param duration in milliseconds for returning tag data\n+     * @throws VantiqLLRPException\n+     */\n+    private void sendROSpec (int tagReadInterval) throws VantiqLLRPException {\n+\n+        // Create the ROSpec to be used\n+        ROSpec roSpec = createROSpec(new UnsignedInteger(tagReadInterval));  // Report on the tags every x milliseconds\n+\n+        // Send an ADD_ROSPEC Message with ROSpec Disabled state\n+        ADD_ROSPEC addROSpec = new ADD_ROSPEC();\n+        addROSpec.setROSpec(roSpec);\n+        write(addROSpec, \"ADD_ROSPEC\");\n+        try {\n+            sendLogMessage(DEBUG, \"Sent ADD_ROSPEC: \" + XML.toJSONObject(addROSpec.toXMLString()).toString());\n+        } catch (InvalidLLRPMessageException e) {\n+            reportLLRPError(e);\n+        } catch (Exception e) {\n+            log.error(\"sendROSpec: Unexpected error \", e);\n+            sendLogMessage(ERROR, \"sendROSpec: Unexpected error.\\n\" + ExceptionUtils.getStackTrace(e));\n+        }\n+        pause(250);\n+\n+        LLRPMessage m = getNextMessage(\"ADD_ROSPEC_RESPONSE\");\n+        ADD_ROSPEC_RESPONSE addResponse = (ADD_ROSPEC_RESPONSE) m;\n+        sendLogMessage(DEBUG, \"ADD_ROSPEC_RESPONSE: \" + getLLRPStatus(addResponse.getLLRPStatus()));\n+\n+        // if an ROSpec is still active from a previous connector start, the ADD_ROSPEC will fail.\n+        // Clear out the current ROSpec in the reader and re-add it again.\n+        if (addResponse.getLLRPStatus().getStatusCode().toString() != M_SUCCESS) {\n+            systemPrint(\"** ADD_ROSPEC NOT SUCCESS: \" + addResponse.getLLRPStatus().getStatusCode().toString()\n+                                + \", retry\");\n+\n+            // Send a STOP_ROSPEC Message to set ROSpec to InActive state\n+            STOP_ROSPEC stopROSpec = new STOP_ROSPEC();\n+            stopROSpec.setROSpecID(new UnsignedInteger(ROSPEC_ID));\n+            write(stopROSpec, \"STOP_ROSPEC\");\n+            pause(250);\n+            m = getNextMessage(\"STOP_ROSPEC_RESPONSE\");\n+            STOP_ROSPEC_RESPONSE smr = (STOP_ROSPEC_RESPONSE) m;\n+            sendLogMessage(DEBUG, \"STOP_ROSPEC_RESPONSE: \" + getLLRPStatus(smr.getLLRPStatus()));\n+\n+            // Send a DISABLE_ROSPEC Message to set ROSpec to Disabled state\n+            DISABLE_ROSPEC disableROSpec = new DISABLE_ROSPEC();\n+            disableROSpec.setROSpecID(new UnsignedInteger(ROSPEC_ID));\n+            write(disableROSpec, \"DISABLE_ROSPEC\");\n+            pause(250);\n+            m = getNextMessage(\"DISABLE_ROSPEC_RESPONSE\");\n+            DISABLE_ROSPEC_RESPONSE dmr = (DISABLE_ROSPEC_RESPONSE) m;\n+            sendLogMessage(DEBUG, \"DISABLE_ROSPEC_RESPONSE: \" + getLLRPStatus(dmr.getLLRPStatus()));\n+\n+            // Send a DELETE_ROSPEC Message to set remove ROSpec\n+            DELETE_ROSPEC deleteROSpec = new DELETE_ROSPEC();\n+            deleteROSpec.setROSpecID(new UnsignedInteger(ROSPEC_ID));\n+            write(deleteROSpec, \"DELETE_ROSPEC\");\n+            pause(250);\n+            m = getNextMessage(\"DELETE_ROSPEC_RESPONSE\");\n+            DELETE_ROSPEC_RESPONSE dlmr = (DELETE_ROSPEC_RESPONSE) m;\n+            sendLogMessage(DEBUG, \"DELETE_ROSPEC_RESPONSE: \" + getLLRPStatus(dlmr.getLLRPStatus()));\n+\n+            // Resend ADD_ROSPEC Message with ROSpec now in the Disabled state\n+            write(addROSpec, \"ADD_ROSPEC\");\n+            pause(250);\n+            m = getNextMessage(\"ADD_ROSPEC_RESPONSE\");\n+            addResponse = (ADD_ROSPEC_RESPONSE) m;\n+            sendLogMessage(DEBUG, \"ADD_ROSPEC_RESPONSE: \" + getLLRPStatus(addResponse.getLLRPStatus()));\n+            systemPrint(\"** ADD_ROSPEC_RESPONSE: \" + addResponse.getLLRPStatus().getStatusCode().toString());\n+        }\n+\n+        // Send an ENABLE_ROSPEC Message to set ROSpec to Inactive state\n+        ENABLE_ROSPEC enableROSpec = new ENABLE_ROSPEC();\n+        enableROSpec.setROSpecID(new UnsignedInteger(ROSPEC_ID));\n+        write(enableROSpec, \"ENABLE_ROSPEC\");\n+        pause(250);\n+        m = getNextMessage(\"ENABLE_ROSPEC_RESPONSE\");\n+        ENABLE_ROSPEC_RESPONSE emr = (ENABLE_ROSPEC_RESPONSE) m;\n+        sendLogMessage(DEBUG, \"ENABLE_ROSPEC_RESPONSE: \" + getLLRPStatus(emr.getLLRPStatus()));\n+    }\n+\n+    /**\n+     * Create a new ROSpec Parameter\n+     *\n+     * Reader Operations (RO) define the parameters for operations such as Antenna Inventory\n+     * and RF Survey. Access Operations define the parameters for performing data access\n+     * operations to and from a tag.\n+     *\n+     * The timing control of an operation is specified using boundary specification, which\n+     * specifies how the beginning (using start trigger) and the end (using stop trigger) of the\n+     * operation is to be determined.\n+     *\n+     *\t\tROSpecStartCondition = \tROSpecStartTrigger or START_ROSPEC received\n+     *\t\tROSpecDoneCondition  = \tAllSpecsDone or ROSpecStopTrigger or preempted or\n+     *\t\t\t\t\t\t\t\t(STOP_ROSPEC message for the ROSpec from the Client)\n+     *\t Note: Even if you have complex start/stop triggers, the reader will respond to\n+     *\t\t   START_ROSPEC and STOP_ROSPEC (useful when testing application)\n+     *\n+     * @param duration in milliseconds between each AISpec trigger\n+     * @return ROSpec message\n+     */\n+    private ROSpec createROSpec(UnsignedInteger duration) {\n+\n+        ROSpec roSpec = new ROSpec();\n+        roSpec.setPriority(new UnsignedByte(0));  // 0-7, with 0 being highest\n+        roSpec.setCurrentState(new ROSpecState(ROSpecState.Disabled));  // Must be added in Disable state\n+        roSpec.setROSpecID(new UnsignedInteger(ROSPEC_ID)); // Only using one ROSpec ID\n+\n+        //set up ROBoundary (start and stop triggers)\n+        ROBoundarySpec roBoundarySpec = new ROBoundarySpec();\n+\n+        // ROSpecStartTrigger Parameter\n+        //\tPossible Values:\n+        //\t\tValue   Definition\n+        //\t\t-----   ----------\n+        //\t\t  0\t    Null - No start trigger. The only way to start the ROSpec is with a\n+        //              START_ROSPEC from the Client.\n+        //\t\t  1\t    Immediate - Start reading tags as soon as the ROSpec is enabled\n+        //\t\t  2\t    Periodic - set period to run every 'duration' milliseconds\n+        //                  UTCTimestamp, Period (milliseconds), Offset (to UTC when msg received)\n+        //\t      3     GPI - see spec for more details\n+        //\n+        ROSpecStartTrigger startTrig = new ROSpecStartTrigger();\n+        startTrig.setROSpecStartTriggerType(new ROSpecStartTriggerType(ROSpecStartTriggerType.Immediate));\n+        roBoundarySpec.setROSpecStartTrigger(startTrig);\n+\n+        // ROSpecStopTrigger Parameter\n+        //\tPossible Values:\n+        //\t\tValue   Definition\n+        //\t\t-----   ----------\n+        //\t\t  0\t    Null - Stop when all Specs are done (including any looping as required by\n+        //\t\t\t\ta LoopSpec parameter), or when preempted, or with a STOP_ROSPEC from the\n+        //\t\t\t\tClient.\n+        //\t\t  1\t    Duration - Stop after DurationTriggerValue milliseconds, or when all Specs\n+        //\t\t\t\tare done (including any looping as required by a LoopSpec parameter), or\n+        //\t\t\t\twhen preempted, or with a STOP_ROSPEC from the Client.\n+        //\t\t  2\t    GPI with a timeout value - Stop when a GPI \"fires\", or after Timeout\n+        //\t\t\t\tmilliseconds, or when all Specs are done (including any looping as\n+        //\t\t\t\trequired by a LoopSpec parameter), or when preempted, or with a STOP_ROSPEC\n+        //\t\t\t\tfrom the Client.\n+        //\n+        ROSpecStopTrigger stopTrig = new ROSpecStopTrigger();\n+        // No stop trigger.  Respond after the AISpec completes (which is set with a duration)\n+        stopTrig.setROSpecStopTriggerType(new ROSpecStopTriggerType(ROSpecStopTriggerType.Null));\n+        stopTrig.setDurationTriggerValue(new UnsignedInteger(0)); // required, but ignored with Trigger type is Null\n+        roBoundarySpec.setROSpecStopTrigger(stopTrig);\n+        roSpec.setROBoundarySpec(roBoundarySpec);\n+\n+        // Add an Antenna Inventory Spec (AISpec) Parameter - contains the following:\n+        //      - AISpecStopTrigger - identifies the stop of the antenna inventory operation\n+        //      - AntennaIds - array of antenna IDs for operation (0=all are utilized)\n+        //      - InventoryParameterSpecs - list of inventory parameters\n+        //\n+        AISpec aispec = new AISpec();\n+\n+        // AISpecStopTrigger Parameter\n+        //\tPossible Values:\n+        //\t\tValue   Definition\n+        //\t\t-----   ----------\n+        //\t\t  0\t    Null - Stop when ROSpec is done\n+        //\t\t  1\t\tDuration - in milliseconds (reads tags for x duration)\n+        //\t\t  2\t\tGPI trigger with a timeout value\n+        //\t\t  3\t\tTag observation (i.e., seeing N tags, no tags for T ms, etc.)\n+\n+        // Sed to read based on a duration value\n+        AISpecStopTrigger aiStopTrigger = new AISpecStopTrigger();\n+        aiStopTrigger.setAISpecStopTriggerType(new AISpecStopTriggerType(AISpecStopTriggerType.Duration));\n+        aiStopTrigger.setDurationTrigger(duration);  // ignored when type is not Duration\n+        aispec.setAISpecStopTrigger(aiStopTrigger);\n+\n+        // Antenna IDs: set to 0 to utilize all antennas of the Reader\n+        UnsignedShortArray antennaIDs = new UnsignedShortArray();\n+        antennaIDs.add(new UnsignedShort(0));\n+        aispec.setAntennaIDs(antennaIDs);\n+\n+        // InventoryParameterSpec\n+        InventoryParameterSpec inventoryParam = new InventoryParameterSpec();\n+        inventoryParam.setProtocolID(new AirProtocols(AirProtocols.EPCGlobalClass1Gen2));  // Really the only valid option today\n+        inventoryParam.setInventoryParameterSpecID(new UnsignedShort(1));  // Any ID, must not be zero\n+        aispec.addToInventoryParameterSpecList(inventoryParam);\n+\n+        roSpec.addToSpecParameterList(aispec);\n+\n+        return roSpec;\n+    }\n+\n+    /**\n+     * Create and start the threads to managing the messages from the reader and\n+     * the reader connectivity.\n+     */\n+    private void createAndStartThreads() {\n+\n+        sendLogMessage(INFO, \"createAndStartThreads: Starting Threads\");\n+        if (msgThread == null) {\n+            // Thread for processing regular messages\n+            msgThread = new Thread(() -> {\n+                systemPrint(\"msgThread started : \" + Thread.currentThread().getName());\n+                while (true) {\n+                    try {\n+                        // May have to check if connection to reader is stopped\n+                        if (readerOffline) {\n+                            Thread.sleep(RECONNECT_INTERVAL);  // if not connected\n+                        } else {\n+                            LLRPMessage m = getNextMessage();\n+                            processRegularMessage (m);\n+                        }\n+                    } catch (Exception e) {\n+                        systemPrint(\"msgThread interrupted. \");\n+                        log.error(\"createAndStartThreads-msgThread: Unexpected error \", e);\n+                        sendLogMessage(ERROR, \"createAndStartThreads-msgThread: Unexpected error.\\n\"\n+                                + ExceptionUtils.getStackTrace(e));\n+                    }\n+                }\n+            });\n+            msgThread.start();\n+        }\n+\n+        if (tagThread == null) {\n+            // Thread for processing tag data messages\n+            tagThread = new Thread(() -> {\n+                systemPrint(\"tagThread started : \" + Thread.currentThread().getName());\n+                while (true) {\n+                    try {\n+                        // May have to check if connection to reader is stopped\n+                        if (readerOffline) {\n+                            Thread.sleep(RECONNECT_INTERVAL);  // if not connected\n+                        } else {\n+                            LLRPMessage m = getNextTagMessage();\n+                            processTagDataMessage (m);\n+                        }\n+                    } catch (Exception e) {\n+                        systemPrint(\"tagThread interrupted. \");\n+                        log.error(\"createAndStartThreads-tagThread: Unexpected error \", e);\n+                        sendLogMessage(ERROR, \"createAndStartThreads-tagThread: Unexpected error.\\n\"\n+                                + ExceptionUtils.getStackTrace(e));\n+                    }\n+                }\n+            });\n+            tagThread.start();\n+        }\n+\n+        if (readerAliveThread == null) {\n+            // Thread to assure connection to the reader is good\n+            readerAliveThread = new Thread(() -> {\n+                systemPrint(\"readerAliveThread started : \" + Thread.currentThread().getName());\n+                while (true) {\n+                    try {\n+                        Thread.sleep(RECONNECT_INTERVAL);\n+                        long duration = Duration.between(lastKeepAlive, Instant.now()).toMillis();\n+                        // We only want to connect if the connection to the Vantiq Source is online\n+                        // since we are not buffering any tag read messages -- letting the Reader buffer\n+                        if (duration > RECONNECT_INTERVAL && !vantiqSourceOffline) {\n+                            systemPrint(\"readerAliveThread: Reader is offline, try to reconnect\");\n+                            readerOffline = true;\n+                            changeReaderStatus(READER_OFFLINE);\n+                            try {\n+                                if (connection != null && !connection.isClosed()) {\n+                                    systemPrint(\"connection OPEN, CLOSING\");\n+                                    connection.close();\n+                                    Thread.sleep(1000);\n+                                }\n+                            } catch (Exception e) {\n+                                systemPrint(\"Prepare to reconnect, can't close socket: \" + e);\n+                                sendLogMessage(ERROR, \"createAndStartThreads-readerAliveThread: Can't close socket.\\n\"\n+                                        + ExceptionUtils.getStackTrace(e));\n+                            }\n+                            connectAndSetupReader();\n+                        }\n+                    } catch (Exception e) {\n+                        systemPrint(\"readerAliveThread interrupted. \");\n+                        log.error(\"createAndStartThreads-readerAliveThread: Unexpected error \", e);\n+                        sendLogMessage(ERROR, \"createAndStartThreads-readerAliveThread: Unexpected error.\\n\"\n+                                + ExceptionUtils.getStackTrace(e));\n+                    }\n+                }\n+            });\n+            readerAliveThread.start();\n+        }\n+    }\n+\n+    /**\n+     * This method causes the calling thread to sleep for a specified number of milliseconds\n+     * @param ms\n+     */\n+    private void pause(long ms) {\n+        try {\n+            Thread.sleep(ms);\n+        } catch (InterruptedException e) {\n+            log.error(\"pause: Unexpected error \", e);\n+            sendLogMessage(ERROR, \"pause: Unexpected error.\\n\" + ExceptionUtils.getStackTrace(e));\n+        }\n+    }\n+\n+    /**\n+     * Send an LLRP message to the reader\n+     *\n+     * @param msg - Message to be sent\n+     * @param message - Message name for logging\n+     */\n+    private void write(LLRPMessage msg, String message) {\n+        try {\n+            systemPrint(\"\\nSending message: \" + message);\n+            sendLogMessage(DEBUG, \"Sending Reader: \" + message);\n+            //systemPrint(\" Sending message: \\n\" + msg.toXMLString());\n+            out.write(msg.encodeBinary());\n+        } catch (IOException e) {\n+            systemPrint(\"Couldn't send Command \"+ e);\n+            sendLogMessage(ERROR, \"write: Couldn't send Command\\n\" + ExceptionUtils.getStackTrace(e));\n+        } catch (InvalidLLRPMessageException e) {\n+            systemPrint(\"Couldn't send Command \"+ e);\n+            sendLogMessage(ERROR, \"write: Couldn't send Command\\n\" + ExceptionUtils.getStackTrace(e));\n+        }\n+    }\n+\n+    /**\n+     * This reads LLRP messages on a separate thread and stores\n+     * Tag Data reports in one queue and other messages in another\n+     * message queue for processing.\n+     *\n+     */\n+    class ReadThread extends Thread {\n+\n+        private DataInputStream inStream = null;\t\t\t\t // Data from the reader\n+        private Socket socket = null;\t\t\t\t\t\t\t // Socket connection to the reader\n+\n+        /**\n+         * Thread used to stream data from the reader\n+         *\n+         * @param socket stream reader input\n+         */\n+        public ReadThread(Socket socket) {\n+            this.socket = socket;\n+            try {\n+                systemPrint(\"\\nAttempt to connect to DataInputStream ...\");\n+                this.inStream = new DataInputStream(socket.getInputStream());\n+                systemPrint(\"\\nDataInputStream connection made!\");\n+            } catch (IOException e) {\n+                systemPrint(\"Cannot get input stream: \" + e);\n+                sendLogMessage(ERROR, \"ReadThread: Cannot get input stream:\\n\" + ExceptionUtils.getStackTrace(e));\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            super.run();\n+            systemPrint(\"ReadThread starting\");\n+            if (socket != null && socket.isConnected()) {\n+                while (socket != null && !socket.isClosed()) {\n+                    LLRPMessage message = null;\n+                    try {\n+                        message = read();\n+                        if (message != null) {\n+                            String msgName = message.getName();\n+\t\t\t\t\t\t\tif (msgName.equalsIgnoreCase(\"CLOSE_CONNECTION_RESPONSE\") ) {\n+\t\t\t\t\t\t\t\tsystemPrint(\"\\nConnection Closed.\");\n+\t\t\t\t\t\t\t\tsocket.close();\n+                                sendLogMessage(WARN, \"ReadThread-run: Connection Closed.\");\n+\t\t\t\t\t\t\t}\n+                            // Add all \"RO_ACCESS_REPORT\" messages to the tag collection queue\n+                            if (msgName.equalsIgnoreCase(\"RO_ACCESS_REPORT\")) {\n+                                RO_ACCESS_REPORT roAccessRpt = (RO_ACCESS_REPORT) message;\n+                                List<TagReportData> tagDataList = roAccessRpt.getTagReportDataList();\n+                                if (!tagDataList.isEmpty())\n+                                    tagQueue.put(message);\n+                            } else {\n+                                queue.put(message);\n+                            }\n+                        } else {\n+                            systemPrint(\"\\nMessage is null, Connection Closed.\");\n+                            socket.close();\n+                            sendLogMessage(WARN, \"ReadThread-run: Message is null, Connection Closed:\");\n+                        }\n+\n+                    } catch (IOException | InvalidLLRPMessageException | InterruptedException e) {\n+                        systemPrint(\"Error reading message: \"+ e);\n+                        log.error(\"ReadThread-run: Unexpected error \", e);\n+                        sendLogMessage(ERROR, \"ReadThread-run: Error reading message:\\n\" + ExceptionUtils.getStackTrace(e));\n+                        break;\n+                    }\n+                }\n+            }\n+            systemPrint(\"ReadThread closed.   (msgQueue=\" + queue.size()\n+                    + \"\\ttagQueue=\" + tagQueue.size() + \")\");\n+        }\n+\n+        /**\n+         * Read everything from the stream until the socket is closed\n+         *\n+         * @throws IOException\n+         * @throws InvalidLLRPMessageException\n+         */\n+        public LLRPMessage read() throws IOException, InvalidLLRPMessageException {\n+\n+            // message header\n+            byte[] first = new byte[6];\n+\n+            // complete message\n+            byte[] msg;\n+\n+            // Read in the message header. If -1 is read, there is no more\n+            // data available, so close the socket\n+            if (inStream.read(first, 0, 6) == -1) { // read is blocking until data is available, EOF, or exception thrown\n+                return null;\n+            }\n+            int msgLength = 0;\n+\n+            try {\n+                // calculate message length\n+                msgLength = calculateLLRPMessageLength(first);\n+            } catch (IllegalArgumentException e) {\n+                throw new IOException(\"Incorrect Message Length\");\n+            }\n+\n+            /*\n+             * the rest of bytes of the message will be stored in here before\n+             * they are put in the accumulator. If the message is short, all\n+             * messageLength-6 bytes will be read in here at once. If it is\n+             * long, the data might not be available on the socket all at once,\n+             * so it make take a couple of iterations to read in all the bytes\n+             */\n+            byte[] temp = new byte[msgLength - 6]; // msgLength includes header\n+\n+            // all the rest of the bytes will be put into the accumulator\n+            ArrayList<Byte> accumulator = new ArrayList<Byte>();\n+\n+            // add the first six bytes to the accumulator so that it will\n+            // contain all the bytes at the end\n+            for (byte b : first) {\n+                accumulator.add(b);\n+            }\n+\n+            // the number of bytes read on the last call to read()\n+            int numBytesRead = 0;\n+\n+            // read from the input stream and put bytes into the accumulator\n+            // while there are still bytes left to read on the socket and\n+            // the entire message has not been read\n+            while (((msgLength - accumulator.size()) != 0)\n+                    && numBytesRead != -1) {\n+\n+                numBytesRead = inStream.read(temp, 0, msgLength\n+                        - accumulator.size());\n+\n+                for (int i = 0; i < numBytesRead; i++) {\n+                    accumulator.add(temp[i]);\n+                }\n+            }\n+\n+            if ((msgLength - accumulator.size()) != 0) {\n+                throw new IOException(\"Error: Discrepency between message size\"\n+                        + \" in header and actual number of bytes read\");\n+            }\n+\n+            msg = new byte[msgLength];\n+\n+            // copy all bytes in the accumulator to the msg byte array\n+            for (int i = 0; i < accumulator.size(); i++) {\n+                msg[i] = accumulator.get(i);\n+            }\n+\n+            // turn the byte array into an LLRP Message Object\n+            LLRPMessage m = LLRPMessageFactory.createLLRPMessage(msg);\n+            return m;\n+        }\n+\n+        /**\n+         * Send in the first 6 bytes of an LLRP Message\n+         *    Reserved(3 Bits)\n+         *    Version (3 Bits)\n+         *    Message Type (10 Bits)\n+         *    Message Length (32 Bits)|Parameters\n+         *\n+         * @param bytes\n+         * @return message length from message header (byte array)\n+         */\n+        private int calculateLLRPMessageLength(byte[] bytes) throws IllegalArgumentException {\n+            long msgLength = 0;\n+            int num1 = 0;\n+            int num2 = 0;\n+            int num3 = 0;\n+            int num4 = 0;\n+\n+            num1 = ((unsignedByteToInt(bytes[2])));\n+            num1 = num1 << 32;\n+            if (num1 > 127) {\n+                throw new RuntimeException(\n+                        \"Cannot construct a message greater than \"\n+                        + \"2147483647 bytes (2^31 - 1), due to the fact that there are \"\n+                        + \"no unsigned ints in java\");\n+            }\n+\n+            num2 = ((unsignedByteToInt(bytes[3])));\n+            num2 = num2 << 16;\n+\n+            num3 = ((unsignedByteToInt(bytes[4])));\n+            num3 = num3 << 8;\n+\n+            num4 = (unsignedByteToInt(bytes[5]));\n+\n+            msgLength = num1 + num2 + num3 + num4;\n+\n+            if (msgLength < 0) {\n+                throw new IllegalArgumentException(\n+                        \"LLRP message length is less than 0\");\n+            } else {\n+                return (int) msgLength;\n+            }\n+        }\n+\n+        /**\n+         * From http://www.rgagnon.com/javadetails/java-0026.html\n+         *\n+         * @param b\n+         * @return unsigned java byte (java bytes are signed by default)\n+         */\n+        private int unsignedByteToInt(byte b) {\n+            return (int) b & 0xFF;\n+        }\n+\n+    }  // End of the ReaderThread class\n+\n+    /**\n+     * Receive the next tag data message from the queue, blocks if no message in queue.\n+     *\n+     * @return returns the message or blocks for message\n+     */\n+    private LLRPMessage getNextTagMessage() {\n+        LLRPMessage msg = null;\n+        try {\n+            msg = tagQueue.take();\n+        } catch (InterruptedException e) {\n+        }\n+        return msg;\n+    }\n+\n+    /**\n+     * Receive the next message from the queue, blocks if no message in queue.\n+     *\n+     * @return returns the message or blocks for message\n+     */\n+    private LLRPMessage getNextMessage() {\n+        LLRPMessage msg = null;\n+        try {\n+            msg = queue.take();\n+        } catch (InterruptedException e) {\n+        }\n+        return msg;\n+    }\n+\n+    /**\n+     * Receive the next 'specific' message from the queue, blocks if no message in queue.\n+     * Ignore all other messages until desired message found\n+     *\n+     * @return returns the message or blocks for message\n+     */\n+    private LLRPMessage getNextMessage(String msgName) {\n+        LLRPMessage msg = null;\n+        Boolean connectionMsg = false;\n+        systemPrint(\"getNextMessage: \" + msgName + \"\\t (Queue=\" + queue.size() + \")\");\n+        try {\n+            // Connection Attempt is an Event Type for the READER_EVENT_NOTIFICATION message\n+            // Though there are other responses returned for READER_EVENT_NOTIFICATION, so\n+            // if looking for a CONNECTION_ATTEMPT, then only return the message when a\n+            // READER_EVENT_NOTIFICATION is received with a ConnectionAttemptEvent property\n+            if (msgName.equalsIgnoreCase(\"CONNECTION_ATTEMPT\")) {\n+                connectionMsg = true;\n+                msgName = \"READER_EVENT_NOTIFICATION\";\n+            }\n+            while (true) {\n+                msg = queue.take();\n+                // Check if it is the desired message\n+                String currentName = msg.getName();\n+                if (currentName.equalsIgnoreCase(msgName)) {\n+                    // If waiting on a CONNECTION_ATTEMPT, verify READER_EVENT_NOTIFICATION\n+                    // is the right type\n+                    if (connectionMsg) {\n+                        READER_EVENT_NOTIFICATION readerEventNotification = (READER_EVENT_NOTIFICATION) msg;\n+                        ReaderEventNotificationData eventData = readerEventNotification\n+                                .getReaderEventNotificationData();\n+                        if (eventData.getConnectionAttemptEvent() != null)\n+                            break;\n+                    } else\n+                        break;\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+        return msg;\n+    }\n+\n+    /**\n+     * Process regular queue messages\n+     */\n+    private void processRegularMessage(LLRPMessage msg) {\n+        if (!msg.getName().equalsIgnoreCase(\"READER_EVENT_NOTIFICATION\"))\n+            systemPrint(\"processRegularMessage:\" + msg.getName());\n+        try {\n+\n+            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n+            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n+\n+            InputStream stream = new ByteArrayInputStream(msg.toXMLString().getBytes(StandardCharsets.UTF_8));\n+            Document doc = dBuilder.parse(stream);\n+            doc.getDocumentElement().normalize();\n+\n+            String msgType = doc.getDocumentElement().getNodeName().substring(5);\n+            NodeList nList = null;\n+            Element eElement = null;\n+\n+            switch (msgType) {\n+                case \"KEEPALIVE\":\n+                    // Send the message to the reader for each KEEPALIVE, otherwise it closes connection\n+                    KEEPALIVE_ACK keepaliveAck = new KEEPALIVE_ACK();\n+                    write(keepaliveAck, \"KEEPALIVE_ACK\");\n+                    // Update last time we heard from reader\n+                    lastKeepAlive = Instant.now();\n+                    break;\n+\n+                case \"READER_EVENT_NOTIFICATION\":\n+                    /**\n+                     * Uncomment for debugging, though every (tagReadInterval) milliseconds a message is received.\n+                     * /\n+                    nList = doc.getDocumentElement().getElementsByTagName(\"llrp:ReaderEventNotificationData\");\n+\n+                    eElement = (Element) nList.item(0);\n+                    String timestamp = eElement.getElementsByTagName(\"llrp:UTCTimestamp\").item(0).getTextContent().trim();\n+                    Node sibling = nList.item(0).getFirstChild().getNextSibling().getNextSibling();\n+                    while (sibling != null) {\n+                        if (sibling.getNodeType() == Node.ELEMENT_NODE) {\n+                            // get node name and value - only go 1 deep for children\n+                            systemPrint(\"\\nMessage Type: \" + msgType + \"-\" + sibling.getNodeName().substring(5));\n+                            systemPrint(\"  UTCTimestamp -> \" + timestamp);\n+                            if (sibling.hasChildNodes()) {\n+                                NodeList childList = sibling.getChildNodes();\n+                                for (int i=0; i<childList.getLength(); i++) {\n+                                    if (childList.item(i).getNodeType() == Node.ELEMENT_NODE) {\n+                                        systemPrint(\"  \" + childList.item(i).getNodeName().substring(5) + \"-> \"\n+                                                            + childList.item(i).getTextContent().trim());\n+                                    }\n+                                }\n+                            }// else\n+                            //\tsystemPrint(\"Node Value =\" + sibling.getTextContent().trim());\n+\n+                        }\n+                        sibling = sibling.getNextSibling();\n+                    }*/\n+                    break;\n+\n+                case \"GET_READER_CONFIG_RESPONSE\":\n+                    systemPrint(\"Received Message: (\" + msgType + \") /n\" + msg.toXMLString());\n+                    break;\n+                default:\n+                    nList = doc.getDocumentElement().getElementsByTagName(\"llrp:LLRPStatus\");\n+                    Boolean found = false;\n+                    for ( int i = 0; i < nList.getLength(); i++ ) {\n+                        //systemPrint(\"\\nCurrent Element :\" + i + \": \" + nList.item(i).getNodeName());\n+                        if ( nList.item(i).getNodeType() == Node.ELEMENT_NODE ) {\n+                            found = true;\n+                            eElement = (Element) nList.item(i);\n+                            String statusCode = eElement.getElementsByTagName(\"llrp:StatusCode\").item(0).getTextContent().trim();\n+\n+                            systemPrint(\"\\nMessage Type: \" + msgType + \" ->\" + statusCode + \"<\");\n+                            if (!statusCode.equalsIgnoreCase(\"M_Success\") ) {\n+                                systemPrint(\"  ErrorDescription -> \"\n+                                        + eElement.getElementsByTagName(\"llrp:ErrorDescription\").item(0).getTextContent().trim());\n+                            }\n+                            break;\n+                        }\n+                    }\n+                    if (!found)\n+                        systemPrint(\"\\nMessage Type: \" + msgType);\n+                    break;\n+            }\n+\n+        } catch (Exception e) {\n+        }\n+    }\n+\n+    /**\n+     * Process tag queue messages\n+     */\n+    private void processTagDataMessage(LLRPMessage msg) {\n+\n+        if (!msg.getName().equalsIgnoreCase(\"RO_ACCESS_REPORT\"))\n+            systemPrint(\"processTagDataMessage: ERROR expecting 'RO_ACCESS_REPORT', got \" + msg.getName());\n+        else {\n+            RO_ACCESS_REPORT roAccessRpt = (RO_ACCESS_REPORT) msg;\n+            List<TagReportData> tagDataList = roAccessRpt.getTagReportDataList();\n+            if (tagDataList.isEmpty())\n+                systemPrint(\"processTagDataMessage: 'RO_ACCESS_REPORT' msg has NO Tag Data\");\n+            else {\n+                Map<String, Object> tagMessage = new HashMap<>();\n+                List<Map<String, Object>> tagList = new ArrayList<Map<String, Object>>();\n+                tagMessage.put(\"eventType\", TAG_DATA_EVENT_NAME);\n+                tagMessage.put(\"readerId\",  readerId);  // Get IDENTIFICATION for Reader Config\n+                for (TagReportData tagData: tagDataList) {\n+                    Map<String, Object> tagObj = new HashMap<>();\n+                    String epc = tagData.getEPCParameter().toString();\n+                    tagObj.put(\"tagId\", epc.substring(epc.indexOf(\"ePC: \") + 5));\n+                    tagObj.put(\"antennaID\", tagData.getAntennaID().getAntennaID().intValue());\n+                    tagObj.put(\"firstSeenTimestampUTC\", tagData.getFirstSeenTimestampUTC().getMicroseconds().toLong());\n+                    tagObj.put(\"lastSeenTimestampUTC\", tagData.getLastSeenTimestampUTC().getMicroseconds().toLong());\n+                    tagObj.put(\"tagSeenCount\", tagData.getTagSeenCount().getTagCount().intValue());\n+                    tagObj.put(\"peakRSSI\", tagData.getPeakRSSI().getPeakRSSI().intValue());\n+\n+                    // misc properties not used by Vantiq\n+                    tagObj.put(\"accessSpecID\", tagData.getAccessSpecID().getAccessSpecID().intValue());\n+                    tagObj.put(\"accessSpecIDName\", tagData.getAccessSpecID().getName());\n+                    tagObj.put(\"ROSpecID\", tagData.getROSpecID().getROSpecID().intValue());\n+                    tagObj.put(\"ROSpecIDName\", tagData.getROSpecID().getName());\n+                    tagObj.put(\"channelIndex\", tagData.getChannelIndex().getChannelIndex().intValue());\n+                    tagObj.put(\"specIndex\", tagData.getSpecIndex().getSpecIndex().intValue());\n+\n+                    tagList.add(tagObj);\n+                }\n+                tagMessage.put(\"tags\",  tagList);\n+\n+                // Send the tag data back to VANTIQ\n+                this.llrpCore.sendMessage(tagMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Stop reading tags and close the connection.  Called when Vantiq Connection\n+     * goes down.\n+     * This method will also delete the ROSpec in the reader so it stops reading.\n+     *\n+     */\n+    public void close() {\n+\n+        vantiqSourceOffline = true;\n+\n+        if (!readerOffline) {\n+            systemPrint(\"*** CLOSE LLRP PROCEDURE CALLED ****\");\n+            sendLogMessage(DEBUG, \"** Closing connection to the Reader **\");\n+\n+            // Send a STOP_ROSPEC Message to set ROSpec to InActive state\n+            STOP_ROSPEC stopROSpec = new STOP_ROSPEC();\n+            stopROSpec.setROSpecID(new UnsignedInteger(ROSPEC_ID));\n+            write(stopROSpec, \"STOP_ROSPEC\");\n+            pause(200);\n+\n+            // Send a DISABLE_ROSPEC Message to set ROSpec to Disabled state\n+            DISABLE_ROSPEC disableROSpec = new DISABLE_ROSPEC();\n+            disableROSpec.setROSpecID(new UnsignedInteger(ROSPEC_ID));\n+            write(disableROSpec, \"DISABLE_ROSPEC\");\n+            pause(200);\n+\n+            // Send a DELETE_ROSPEC Message to set remove ROSpec\n+            DELETE_ROSPEC deleteROSpec = new DELETE_ROSPEC();\n+            deleteROSpec.setROSpecID(new UnsignedInteger(ROSPEC_ID));\n+            write(deleteROSpec, \"DELETE_ROSPEC\");\n+            pause(200);\n+\n+            // Not sure if needed, but pause before shutting down\n+            pause(500);\n+\n+            // Send a CLOSE_CONNECTION to with the reader\n+            CLOSE_CONNECTION cc = new CLOSE_CONNECTION();\n+            write(cc, \"CLOSE_CONNECTION\");\n+\n+            // Wait to receive the CLOSE_CONNECTION_RESPONSE which closes the thread\n+            synchronized (rt) {\n+                try {\n+                    systemPrint(\"\\nWaiting for the Reader response of closure...\");\n+                    rt.wait();\n+                } catch (InterruptedException e) {\n+                    systemPrint(\"\\nProcess interupted, aborting...\");\n+                }\n+            }\n+\n+            // set reader to Offline\n+            readerOffline = true;\n+        }\n+    }\n+\n+    /**\n+     * Notification that the connection to the Vantiq Source is either online.\n+     *\n+     */\n+    public void vantiqSourceConnectionOnline() {\n+        vantiqSourceOffline = false;\n+    }\n+\n+    /**\n+     * Notification that the connection to the Vantiq Source is either offline.\n+     *\n+     */\n+    public void vantiqSourceConnectionOffline() {\n+        vantiqSourceOffline = true;\n+    }\n+\n+    /**\n+     * Change the status of the Reader and send a message to Vantiq if logging.\n+     *\n+     * @param offlineStatus Indicates if reader is offline (true) or online (false)\n+     */\n+    public void changeReaderStatus(Boolean offlineStatus) {\n+\n+        readerOffline = offlineStatus;\n+\n+        // send a formatted data message to Vantiq\n+        Map<String, Object> vantiqMessage = new HashMap<>();\n+        vantiqMessage.put(\"eventType\", READER_STATUS_EVENT_NAME);\n+        vantiqMessage.put(\"readerId\", readerId);\n+        vantiqMessage.put(\"readerOnline\", !readerOffline);\n+        this.llrpCore.sendMessage(vantiqMessage);\n+\n+        if (readerOffline)\n+            sendLogMessage(INFO, \"Reader is OFFLINE\");\n+        else\n+            sendLogMessage(INFO, \"Reader is ONLINE\");\n+    }\n+\n+    /**\n+     * Check the response for the LLRPStatus\n+     *\n+     * @param status    The Response message to interrogate for the LLRPStatus\n+     * @return String   Either \"Success\" or \"(StatusCode): (ErrorDescription)\"\n+     */\n+    private String getLLRPStatus(LLRPStatus status) {\n+\n+        if (status == null) {\n+            return \"Invalid Status: null\";\n+        } else if (status.getStatusCode().toString() == M_SUCCESS) {\n+            return \"Success\";\n+        } else {\n+            return status.getStatusCode().toString()+\": \" + status.getErrorDescription();\n+        }\n+    }\n+\n+    /**\n+     * Method used to include the hostname as a prefix to normally a\n+     * System.out.println message.  Since there could be multiple sources\n+     * connected to the same connector, it helps with readability of the logs.\n+     */\n+    private void systemPrint(String msg) {\n+        if (msg.startsWith(\"\\n\"))\n+            log.info(\"\\n{}: {}\", hostname, msg.substring(1));\n+        else\n+            log.info(\"{}: {}\", hostname, msg);\n+    }\n+\n+    /**\n+     * Method used to send log messages to Vantiq server.\n+     */\n+    private void sendLogMessage(String logLevel, String msg) {\n+\n+        if (LogLevels.indexOf(logLevel) <= this.logLevel) {\n+            Map<String, Object> vantiqMessage = new HashMap<>();\n+            vantiqMessage.put(\"eventType\", logLevel + \"Log\");\n+            vantiqMessage.put(\"sourceName\", sourceName);\n+            vantiqMessage.put(\"hostname\", hostname);\n+            vantiqMessage.put(\"readerId\", readerId);\n+            vantiqMessage.put(\"msg\", msg);\n+            this.llrpCore.sendMessage(vantiqMessage);\n+        }\n+    }\n+\n+    /**\n+     * Method used to throw the VantiqLLRPException whenever is necessary\n+     * @param e The Exception caught by the calling method\n+     * @throws VantiqLLRPException\n+     */\n+    public void reportLLRPError(Exception e) throws VantiqLLRPException {\n+        String message = this.getClass().getCanonicalName() + \": \" + e.getMessage() +\n+                \"\\n\" + e.getStackTrace();\n+        sendLogMessage(ERROR, message);\n+        throw new VantiqLLRPException(message);\n+    }\n+\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "fc8b03dd3632905dbcd63e79390da87775b48098",
    "filename": "llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnectorCore.java",
    "status": "added",
    "additions": 221,
    "deletions": 0,
    "changes": 221,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnectorCore.java",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnectorCore.java",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnectorCore.java?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,221 @@\n+/*\r\n+ * Copyright (c) 2021 Vantiq, Inc.\r\n+ *\r\n+ * All rights reserved.\r\n+ *\r\n+ * SPDX: MIT\r\n+ */\r\n+package io.vantiq.extsrc.llrpConnector;\r\n+\r\n+import io.vantiq.extjsdk.ExtensionServiceMessage;\r\n+import io.vantiq.extjsdk.ExtensionWebSocketClient;\r\n+import io.vantiq.extjsdk.Handler;\r\n+\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import java.util.Map;\r\n+import java.util.concurrent.TimeUnit;\r\n+import java.util.concurrent.TimeoutException;\r\n+\r\n+/**\r\n+ * This class is used to manage the connection with Vantiq.\r\n+ *\r\n+ */\r\n+public class LLRPConnectorCore {\r\n+\r\n+    String sourceName;\r\n+    String authToken;\r\n+    String targetVantiqServer;\r\n+\r\n+    LLRPConnectorHandleConfiguration llrpConnectorHandleConfiguration;\r\n+    ExtensionWebSocketClient client  = null;\r\n+    LLRPConnector            llrp    = null;\r\n+    int                      sourceTimeout = 10; // connection to Vantiq source timeout (from call to start)\r\n+\r\n+    final Logger log;\r\n+    final static int RECONNECT_INTERVAL = 5000;  // milliseconds to wait before reconnecting to Vantiq source\r\n+\r\n+    /**\r\n+     * Creates a new LLRPConnectorCore with the settings given from the server.config file.\r\n+     *\r\n+     * @param sourceName            The name of the source to connect to.\r\n+     * @param authToken             The authentication token to use to connect.\r\n+     * @param targetVantiqServer    The url to connect to.\r\n+     */\r\n+    public LLRPConnectorCore(String sourceName, String authToken, String targetVantiqServer) {\r\n+        log = LoggerFactory.getLogger(this.getClass().getCanonicalName() + '#' + sourceName);\r\n+        this.sourceName = sourceName;\r\n+        this.authToken = authToken;\r\n+        this.targetVantiqServer = targetVantiqServer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Tries to connect to a source and waits up to {@code timeout} seconds before failing and trying again.\r\n+     * @param timeout   The maximum number of seconds to wait before assuming failure and stopping.\r\n+     */\r\n+    public void start(int timeout) {\r\n+        // Save the timeout duration that will be used in the handlers when reconnecting\r\n+        sourceTimeout = timeout;\r\n+\r\n+        // Create a web socket client to communicate with the Vantiq source\r\n+        client = new ExtensionWebSocketClient(sourceName);\r\n+        // Create a handler class for messages sent/received by Vantiq source, referencing this class\r\n+        llrpConnectorHandleConfiguration = new LLRPConnectorHandleConfiguration(this);\r\n+\r\n+        // Associate the handler methods for various events (connection closing, reconnecting, etc.)\r\n+        client.setConfigHandler(llrpConnectorHandleConfiguration);\r\n+        client.setReconnectHandler(reconnectHandler);\r\n+        client.setCloseHandler(closeHandler);\r\n+\r\n+        // Looping call to client.InitiateFullConnection()\r\n+        doFullClientConnection(timeout);\r\n+    }\r\n+\r\n+    /**\r\n+     * Helper method to do the work of either initiating new connection, or doing a reconnect. This is done in a loop\r\n+     * until we get a successful connection.\r\n+     * @param timeout The maximum number of seconds to wait before assuming failure and stopping.\r\n+     */\r\n+    public void doFullClientConnection(int timeout) {\r\n+        boolean sourcesSucceeded = false;\r\n+        while (!sourcesSucceeded) {\r\n+            // Either try to reconnect, or initiate a new full connection\r\n+            if (client.isOpen() && client.isAuthed()) {\r\n+                client.doCoreReconnect();\r\n+            } else {\r\n+                client.initiateFullConnection(targetVantiqServer, authToken);\r\n+            }\r\n+\r\n+            // Now check the result\r\n+            sourcesSucceeded = exitIfConnectionFails(timeout);\r\n+            if (!sourcesSucceeded) {\r\n+                try {\r\n+                    Thread.sleep(RECONNECT_INTERVAL);\r\n+                } catch (InterruptedException e) {\r\n+                    log.error(\"An error occurred when trying to sleep the current thread. Error Message: \", e);\r\n+                }\r\n+            } else {\r\n+                if (llrp != null)\r\n+                    llrp.vantiqSourceConnectionOnline();\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Waits for the connection to succeed or fail, logs and exits if the connection does not succeed within\r\n+     * {@code timeout} seconds.\r\n+     *\r\n+     * @param timeout   The maximum number of seconds to wait before assuming failure and stopping\r\n+     * @return          true if the connection succeeded, false if it failed to connect within {@code timeout} seconds.\r\n+     */\r\n+    public boolean exitIfConnectionFails(int timeout) {\r\n+        boolean sourcesSucceeded = false;\r\n+        try {\r\n+            sourcesSucceeded = client.getSourceConnectionFuture().get(timeout, TimeUnit.SECONDS);\r\n+        }\r\n+        catch (TimeoutException e) {\r\n+            log.error(\"Timeout: full connection did not succeed within {} seconds: {}\", timeout, e);\r\n+        }\r\n+        catch (Exception e) {\r\n+            log.error(\"Exception occurred while waiting for webSocket connection\", e);\r\n+        }\r\n+        if (!sourcesSucceeded) {\r\n+            log.error(\"Failed to connect to all sources.\");\r\n+            if (!client.isOpen()) {\r\n+                log.error(\"Failed to connect to server url '\" + targetVantiqServer + \"'.\");\r\n+            } else if (!client.isAuthed()) {\r\n+                log.error(\"Failed to authenticate within \" + timeout + \" seconds using the given authentication data.\");\r\n+            } else {\r\n+                log.error(\"Failed to connect within \" + timeout + \" seconds\");\r\n+            }\r\n+            return false;\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Stops sending messages to the source and tries to reconnect indefinitely\r\n+     */\r\n+    public final Handler<ExtensionServiceMessage> reconnectHandler = new Handler<ExtensionServiceMessage>() {\r\n+        @Override\r\n+        public void handleMessage(ExtensionServiceMessage message) {\r\n+            log.trace(\"Reconnect message received. Reinitializing configuration\");\r\n+\r\n+            // Do connector-specific stuff here\r\n+            llrpConnectorHandleConfiguration.configComplete = false;\r\n+            // Stop connection with the reader, letting it buffer reads\r\n+            if (llrp != null)\r\n+                llrp.close();\r\n+\r\n+            // Looping call to client.doCoreReconnection()\r\n+            Thread reconnectThread = new Thread(() -> doFullClientConnection(sourceTimeout));\r\n+            reconnectThread.start();\r\n+        }\r\n+    };\r\n+\r\n+    /**\r\n+     * Stops sending messages to the source and tries to reconnect indefinitely\r\n+     */\r\n+    public final Handler<ExtensionWebSocketClient> closeHandler = new Handler<ExtensionWebSocketClient>() {\r\n+        @Override\r\n+        public void handleMessage(ExtensionWebSocketClient message) {\r\n+            log.trace(\"WebSocket closed unexpectedly. Attempting to reconnect\");\r\n+\r\n+            // Do connector-specific stuff here\r\n+            llrpConnectorHandleConfiguration.configComplete = false;\r\n+            // Stop connection with the reader, letting it buffer reads\r\n+            if (llrp != null)\r\n+                llrp.close();\r\n+\r\n+            // Looping call to client.initiateFullConnection()\r\n+            Thread connectThread = new Thread(() -> doFullClientConnection(sourceTimeout));\r\n+            connectThread.start();\r\n+        }\r\n+    };\r\n+\r\n+    /**\r\n+     * Returns the name of the source that it is connected to.\r\n+     * @return  The name of the source that it is connected to.\r\n+     */\r\n+    public String getSourceName() {\r\n+        return sourceName;\r\n+    }\r\n+\r\n+    /**\r\n+     * Send message from the reader to VANTIQ server\r\n+     * @param msg\r\n+     */\r\n+    public void sendMessage(Map<String, Object> msg) {\r\n+\r\n+        log.trace(\"Sending message: \" + msg);\r\n+        try {\r\n+            client.sendNotification(msg);\r\n+        } catch (Exception e) {\r\n+            log.error(\"sendMessage: unexpected error. \", e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Closes all resources held by this program except for the {@link ExtensionWebSocketClient}.\r\n+     */\r\n+    public void close() {\r\n+        log.info(\"LLRPConnectorCore: close all resources\");\r\n+        // Do connector-specific stuff here\r\n+        // Stop connection with the reader, letting it buffer reads\r\n+        if (llrp != null)\r\n+            llrp.close();\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Closes all resources held by this program and then closes the connection.\r\n+     */\r\n+    public void stop() {\r\n+        close();\r\n+        if (client != null && client.isOpen()) {\r\n+            client.stop();\r\n+            client = null;\r\n+        }\r\n+    }\r\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "025f76582affc9038afe615cea3a4fcce4524dfb",
    "filename": "llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnectorHandleConfiguration.java",
    "status": "added",
    "additions": 190,
    "deletions": 0,
    "changes": 190,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnectorHandleConfiguration.java",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnectorHandleConfiguration.java",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnectorHandleConfiguration.java?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,190 @@\n+/*\r\n+ * Copyright (c) 2021 Vantiq, Inc.\r\n+ *\r\n+ * All rights reserved.\r\n+ *\r\n+ * SPDX: MIT\r\n+ */\r\n+\r\n+package io.vantiq.extsrc.llrpConnector;\r\n+\r\n+import io.vantiq.extjsdk.ExtensionServiceMessage;\r\n+import io.vantiq.extjsdk.Handler;\r\n+\r\n+import io.vantiq.extsrc.llrpConnector.exception.VantiqLLRPException;\r\n+\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Sets up the source using the configuration document, which looks as below.\r\n+ *{\r\n+ *      llrpConfig: {\r\n+ *          general: {\r\n+ *              (general options)\r\n+ *          }\r\n+ *      }\r\n+ * }\r\n+ *\r\n+ * The options for 'general' are as follows. At least the Hostname and Reader Port MUST\r\n+ * be specified for the source to function:\r\n+ *\r\n+ *  - hostname: The hostname or ipAddress to connect to the Reader.\r\n+ *  - readerPort: The readerPort to connect to the Reader.\r\n+ *  - tagReadInterval: Interval in milliseconds to receive Tag Data*\r\n+ *  - logLevel: Indicates log messages to send to Vantiq ('info', 'warn', 'error')\r\n+ *\r\n+ */\r\n+public class LLRPConnectorHandleConfiguration extends Handler<ExtensionServiceMessage> {\r\n+    Logger log;\r\n+    String sourceName;\r\n+    LLRPConnectorCore core;\r\n+\r\n+    boolean configComplete = false;\r\n+\r\n+    private static final int DEFAULT_TAGREAD_INTERVAL = 2000;\r\n+    private static final String DEFAULT_LOG_LEVEL = \"None\";\r\n+\r\n+    // Constants for getting config options\r\n+    private static final String CONFIG = \"config\";\r\n+    private static final String LLRP_CONFIG = \"llrpConfig\";\r\n+    private static final String GENERAL = \"general\";\r\n+    private static final String HOSTNAME = \"hostname\";\r\n+    private static final String READERPORT = \"readerPort\";\r\n+    private static final String TAGREAD_INTERVAL = \"tagReadInterval\";  // if not found use default\r\n+    private static final String LOG_LEVEL = \"logLevel\";  // if not found use default\r\n+\r\n+    public LLRPConnectorHandleConfiguration(LLRPConnectorCore core) {\r\n+        this.core = core;\r\n+        this.sourceName = core.getSourceName();\r\n+        log = LoggerFactory.getLogger(this.getClass().getCanonicalName() + \"#\" + sourceName);\r\n+    }\r\n+\r\n+    /**\r\n+     * Interprets the configuration message sent by the VANTIQ server and sets up the LLRP Source.\r\n+     */\r\n+    @Override\r\n+    public void handleMessage(ExtensionServiceMessage message) {\r\n+        Map<String, Object> configObject = (Map) message.getObject();\r\n+        Map<String, Object> config;\r\n+        Map<String, Object> llrpConfig;\r\n+        Map<String, Object> general;\r\n+\r\n+        // Obtain entire config from the message object\r\n+        if (!(configObject.get(CONFIG) instanceof Map)) {\r\n+            log.error(\"Configuration failed. No configuration suitable for LLRP Connector.\");\r\n+            failConfig();\r\n+            return;\r\n+        }\r\n+        config = (Map) configObject.get(CONFIG);\r\n+\r\n+        // Retrieve the llrpConfig and the vantiq config\r\n+        if (!(config.get(LLRP_CONFIG) instanceof Map)) {\r\n+            log.error(\"Configuration failed. Configuration must contain 'llrpConfig' field.\");\r\n+            failConfig();\r\n+            return;\r\n+        }\r\n+        llrpConfig = (Map) config.get(LLRP_CONFIG);\r\n+\r\n+        // Get the general options from the llrpConfig\r\n+        if (!(llrpConfig.get(GENERAL) instanceof Map)) {\r\n+            log.error(\"Configuration failed. No general options specified.\");\r\n+            failConfig();\r\n+            return;\r\n+        }\r\n+        general = (Map) llrpConfig.get(GENERAL);\r\n+\r\n+        // Call method to setup the connector with the source configuration\r\n+        boolean success = setupLLRPConnector(general);\r\n+        if (!success) {\r\n+            log.error(\"Configuration failed. Exception occurred while setting up LLRP Connector: \");\r\n+            failConfig();\r\n+            return;\r\n+        }\r\n+\r\n+        log.trace(\"SetupLLRPConnector complete\");\r\n+        configComplete = true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Attempts to create the LLRP Connector based on the configuration document.\r\n+     * @param generalConfig     The general configuration for the LLRP Connector\r\n+     * @return                  true if the LLRP source could be created, false otherwise\r\n+     */\r\n+    boolean setupLLRPConnector(Map generalConfig) {\r\n+\r\n+        // Get Hostname/IP Address and Port\r\n+        String hostname;\r\n+        int readerPort;\r\n+        int tagReadInterval;\r\n+        String logLevel;\r\n+\r\n+        if (generalConfig.get(HOSTNAME) instanceof String) {\r\n+           hostname = (String) generalConfig.get(HOSTNAME);\r\n+        } else {\r\n+           log.error(\"Configuration failed. No hostname was specified\");\r\n+           return false;\r\n+        }\r\n+\r\n+        if (generalConfig.get(READERPORT) instanceof Integer) {\r\n+           readerPort = (int) generalConfig.get(READERPORT);\r\n+        } else {\r\n+           log.error(\"Configuration failed. No RFID Reader Port was specified\");\r\n+           return false;\r\n+        }\r\n+\r\n+        if (generalConfig.get(TAGREAD_INTERVAL) instanceof Integer) {\r\n+           tagReadInterval = (int) generalConfig.get(TAGREAD_INTERVAL);\r\n+        } else {\r\n+           log.error(\"Configuration for \" + TAGREAD_INTERVAL + \" not found, using \"\r\n+                   + DEFAULT_TAGREAD_INTERVAL + \" (milliseconds)\");\r\n+           tagReadInterval = DEFAULT_TAGREAD_INTERVAL;\r\n+        }\r\n+\r\n+        if (generalConfig.get(LOG_LEVEL) instanceof String) {\r\n+            logLevel = (String) generalConfig.get(LOG_LEVEL);\r\n+        } else {\r\n+            log.error(\"Configuration for \" + LOG_LEVEL + \" not found, using \"\r\n+                    + DEFAULT_LOG_LEVEL);\r\n+            logLevel = DEFAULT_LOG_LEVEL;\r\n+        }\r\n+\r\n+        // Initialize LLRP Connector with config values\r\n+        try {\r\n+           if (core.llrp != null) {\r\n+               core.llrp.close();\r\n+           }\r\n+           LLRPConnector llrp = new LLRPConnector();\r\n+           llrp.setupLLRPConnector(core, hostname, readerPort, tagReadInterval, logLevel);\r\n+           core.llrp = llrp;\r\n+        } catch (VantiqLLRPException | IOException e) {\r\n+           log.error(\"Configuration failed. Exception occurred while setting up LLRP Connector: {}\", e);\r\n+           return false;\r\n+        }\r\n+\r\n+        log.trace(\"LLRP Connector created\");\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Closes the source {@link LLRPConnectorCore} and marks the configuration as completed. The source will\r\n+     * be reactivated when the source reconnects, due either to a Reconnect message (likely created by an update to the\r\n+     * configuration document) or to the WebSocket connection crashing momentarily.\r\n+     */\r\n+    private void failConfig() {\r\n+        core.close();\r\n+        configComplete = true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns whether the configuration handler has completed. Necessary since the sourceConnectionFuture is completed\r\n+     * before the configuration can complete, so a program may need to wait before using configured resources.\r\n+     * @return  true when the configuration has completed (successfully or not), false otherwise\r\n+     */\r\n+    public boolean isComplete() {\r\n+        return configComplete;\r\n+    }\r\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "668905b2283abd0aff489ec92f88731867144144",
    "filename": "llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnectorMain.java",
    "status": "added",
    "additions": 132,
    "deletions": 0,
    "changes": 132,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnectorMain.java",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnectorMain.java",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/LLRPConnectorMain.java?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,132 @@\n+/*\r\n+ * Copyright (c) 2021 Vantiq, Inc.\r\n+ *\r\n+ * All rights reserved.\r\n+ *\r\n+ * SPDX: MIT\r\n+ */\r\n+\r\n+package io.vantiq.extsrc.llrpConnector;\r\n+\r\n+import io.vantiq.extjsdk.Utils;\r\n+import java.util.ArrayList;\r\n+import java.util.List;\r\n+import java.util.Properties;\r\n+\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ *  The main class of this program. It connects to sources using the specified configuration. All sources must belong to\r\n+ *  the same VANTIQ Server & Namespace (i.e. same authtoken). Options are in a file where each option has its own line,\r\n+ *  and is in the form {@code property=value} with no quotes required for Strings. Options are:\r\n+ *  <ul>\r\n+ *      <li>{@code authToken}: Required. The authentication token to connect with. These can be obtained from the\r\n+ *                      namespace admin.\r\n+ *      <li>{@code sources}: Required. A comma separated list of the sources to which you wish to connect. Whitespace\r\n+ *                      around each name will be removed when read.\r\n+ *      <li>{@code targetServer}: Required. The Vantiq server hosting the sources.\r\n+ *  </ul>\r\n+ */\r\n+\r\n+public class LLRPConnectorMain {\r\n+\r\n+    static final Logger log = LoggerFactory.getLogger(LLRPConnectorMain.class);\r\n+    static List<LLRPConnectorCore> sources;\r\n+\r\n+    static String authToken;\r\n+    static String targetVantiqServer;\r\n+\r\n+    // Exit Error Codes\r\n+\r\n+    static final int NO_AUTH_EXIT = 1;\r\n+    static final int NO_SOURCE_EXIT = 2;\r\n+    static final int NO_SERVER_EXIT = 3;\r\n+\r\n+    static final int SOURCE_TIMEOUT = 10; // seconds to wait for a connection to Vantiq source\r\n+\r\n+    /**\r\n+     * Connects to the Vantiq source and starts polling for data. Exits when all sources are done running.\r\n+     * @param args  Should be either null or the first argument as a config file\r\n+     */\r\n+    public static void main(String[] args) {\r\n+        Properties config;\r\n+        if (args != null && args.length > 0) {\r\n+            config = Utils.obtainServerConfig(args[0]);\r\n+        } else {\r\n+            config = Utils.obtainServerConfig();\r\n+        }\r\n+\r\n+        sources = createSources(config);\r\n+\r\n+        startSources(sources);\r\n+\r\n+        // Can leave now because the threads created by the sources' WebSocket connections will keep the JVM alive\r\n+    }\r\n+\r\n+    /**\r\n+     * Starts every source, giving each up to 10 seconds to connect. Starts them in new threads so they don't block.\r\n+     * @param sources   The list of sources which should be started.\r\n+     */\r\n+    private static void startSources(List<LLRPConnectorCore> sources) {\r\n+        for (LLRPConnectorCore source : sources) {\r\n+            // Starting in threads so they can all connect at once\r\n+            new Thread( () -> { source.start(SOURCE_TIMEOUT); } ).start();\r\n+            log.trace(\"Started Source: \" + source.sourceName);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Sets up the defaults for the server based on the configuration file\r\n+     *\r\n+     * @param config    The Properties obtained from the configuration file\r\n+     */\r\n+    static List<LLRPConnectorCore> createSources(Properties config) {\r\n+        authToken = config.getProperty(\"authToken\");\r\n+        if (authToken == null) {\r\n+            log.error(\"No valid authentication token in server settings\");\r\n+            log.error(\"Exiting...\");\r\n+            exit(NO_AUTH_EXIT);\r\n+        }\r\n+\r\n+        String sourceStr = config.getProperty(\"sources\");\r\n+        if (sourceStr == null || sourceStr.equals(\"\")) {\r\n+            log.error(\"No sources in server settings\");\r\n+            log.error(\"Exiting...\");\r\n+            exit(NO_SOURCE_EXIT);\r\n+        }\r\n+\r\n+        targetVantiqServer = config.getProperty(\"targetServer\");\r\n+        if (targetVantiqServer == null || targetVantiqServer.equals(\"\")) {\r\n+            log.error(\"No server URL specified in server settings\");\r\n+            log.error(\"Exiting...\");\r\n+            exit(NO_SERVER_EXIT);\r\n+        }\r\n+\r\n+        // Obtain potentially multiple sources from a comma delimited string of sources\r\n+        String[] sourceNames = sourceStr.split(\",\");\r\n+        sources = new ArrayList<>();\r\n+        for (String sourceName : sourceNames) {\r\n+            sourceName = sourceName.trim(); // remove any spacing from the name\r\n+\r\n+            LLRPConnectorCore source;\r\n+            source = new LLRPConnectorCore(sourceName, authToken, targetVantiqServer);\r\n+            sources.add(source);\r\n+        }\r\n+\r\n+        return sources;\r\n+    }\r\n+\r\n+    /**\r\n+     * Closes all sources then orders the JVM to exit\r\n+     * @param code  The exit code\r\n+     */\r\n+    public static void exit(int code) {\r\n+        if (sources != null) {\r\n+            for (LLRPConnectorCore source : sources) {\r\n+                source.stop();\r\n+            }\r\n+        }\r\n+        System.exit(code);\r\n+    }\r\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "2c7a20843a2f0261cf5d8342669cab2fef5b5772",
    "filename": "llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/VantiqLLRPException.java",
    "status": "added",
    "additions": 32,
    "deletions": 0,
    "changes": 32,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/VantiqLLRPException.java",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/VantiqLLRPException.java",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/VantiqLLRPException.java?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright (c) 2021 Vantiq, Inc.\n+ *\n+ * All rights reserved.\n+ *\n+ * SPDX: MIT\n+ */\n+\n+package io.vantiq.extsrc.llrpConnector;\n+\n+/**\n+ * A custom exception used to extract the useful information from a LLRP Exception\n+ * - InvalidLLRPMessageException\n+ * - MissingParameterException\n+ */\n+public class VantiqLLRPException extends Exception {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public VantiqLLRPException() {\n+        super();\n+    }\n+\n+    public VantiqLLRPException(String message) {\n+        super(message);\n+    }\n+\n+    public VantiqLLRPException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "6e33b6edfc0e799e62b12fb203452ae37de2b3be",
    "filename": "llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/exception/VantiqLLRPException.java",
    "status": "added",
    "additions": 32,
    "deletions": 0,
    "changes": 32,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/exception/VantiqLLRPException.java",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/exception/VantiqLLRPException.java",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/src/main/java/io/vantiq/extsrc/llrpConnector/exception/VantiqLLRPException.java?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright (c) 2021 Vantiq, Inc.\n+ *\n+ * All rights reserved.\n+ *\n+ * SPDX: MIT\n+ */\n+\n+package io.vantiq.extsrc.llrpConnector.exception;\n+\n+/**\n+ * A custom exception used to extract the useful information from a LLRP Exception\n+ * - InvalidLLRPMessageException\n+ * - MissingParameterException\n+ */\n+public class VantiqLLRPException extends Exception {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public VantiqLLRPException() {\n+        super();\n+    }\n+\n+    public VantiqLLRPException(String message) {\n+        super(message);\n+    }\n+\n+    public VantiqLLRPException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "afaed8362e787f86168c71f2a65583a7ad2d864a",
    "filename": "llrpConnector/src/main/resources/log4j2.xml",
    "status": "added",
    "additions": 38,
    "deletions": 0,
    "changes": 38,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/resources/log4j2.xml",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/main/resources/log4j2.xml",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/src/main/resources/log4j2.xml?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,38 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n+<Configuration status=\"WARN\">\r\n+    <Properties>\r\n+        <Property name=\"LOG_DIR\">./logs</Property>\r\n+    </Properties>\r\n+    <Appenders>\r\n+        <Console name=\"Console\" target=\"SYSTEM_OUT\">\r\n+            <PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\r\n+        </Console>\r\n+        <RolllingFile>\r\n+                name=\"RollingFiile\"\r\n+                filename=\"${LOG_DIR}/llrpOutput.log\"\r\n+                filepattern=\"${LOG_DIR}/%d{yyyy:MM:dd}_UTC_%i.log.zip\"\r\n+                ignoreExceptioins=\"false\"\r\n+            <PatternLayout>\r\n+                <Pattern pattern=\"%d{yyyy:MM:dd HH:mm:ss} %-5p %m%n\"</Pattern>\r\n+            </PatternLayout>\r\n+            <Policies>\r\n+                <TimeBasedTriggeringPolicy />\r\n+                <SizeBasedTriggeringPolicy size=\"50 MB\" />\r\n+            </Policies>\r\n+            <DefaultRolloverStrategy>\r\n+                <Delete basePath=\"${LOG_DIR}/\" maxDepth=\"1\">\r\n+                    <IfFileName glob=\"*.log.zip\" />\r\n+                    <IfLastModified age=\"5d\" />\r\n+                </Delete>\r\n+            </DefaultRolloverStrategy>\r\n+        </RolllingFile>\r\n+    </Appenders>\r\n+    <Loggers>\r\n+        <Logger name=\"io.vantiq.extsrc.llrpConnector\" level=\"debug\"/>\r\n+        <Logger name=\"io.vantiq.extjsdk\" level=\"info\"/>\r\n+        <Root level=\"error\">\r\n+            <AppenderRef ref=\"Console\"/>\r\n+            <AppenderRef ref=\"RollingFile\" />\r\n+        </Root>\r\n+    </Loggers>\r\n+</Configuration>\n\\ No newline at end of file"
  },
  {
    "sha": "92fa910230d388e1177e196304b189e39188ff0e",
    "filename": "llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/NoSendLLRPConnectorCore.java",
    "status": "added",
    "additions": 60,
    "deletions": 0,
    "changes": 60,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/NoSendLLRPConnectorCore.java",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/NoSendLLRPConnectorCore.java",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/NoSendLLRPConnectorCore.java?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,60 @@\n+/*\r\n+ * Copyright (c) 2021 Vantiq, Inc.\r\n+ *\r\n+ * All rights reserved.\r\n+ *\r\n+ * SPDX: MIT\r\n+ */\r\n+\r\n+package io.vantiq.extsrc.llrpConnector;\r\n+\r\n+import io.vantiq.extjsdk.FalseClient;\r\n+\r\n+public class NoSendLLRPConnectorCore extends LLRPConnectorCore {\r\n+\r\n+    FalseClient fClient;\r\n+    boolean closed = false;\r\n+\r\n+    public NoSendLLRPConnectorCore(String sourceName, String authToken, String targetVantiqServer) {\r\n+        super(sourceName, authToken, targetVantiqServer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Tries to connect to a source and waits up to {@code timeout} seconds for it to succeed or fail.\r\n+     * @return  true if the source connection succeeds, false if it fails.\r\n+     */\r\n+    @Override\r\n+    public void start(int timeout) {\r\n+        closed = false;\r\n+        fClient = new FalseClient(sourceName);\r\n+        client = fClient;\r\n+        llrpConnectorHandleConfiguration = new LLRPConnectorHandleConfiguration(this);\r\n+\r\n+        client.setConfigHandler(llrpConnectorHandleConfiguration);\r\n+        client.setReconnectHandler(reconnectHandler);\r\n+        client.setCloseHandler(closeHandler);\r\n+        client.initiateFullConnection(targetVantiqServer, authToken);\r\n+\r\n+        fClient.completeAuthentication(true);\r\n+        fClient.completeWebSocketConnection(true);\r\n+        fClient.completeSourceConnection(true);\r\n+\r\n+        exitIfConnectionFails(timeout);\r\n+    }\r\n+\r\n+    @Override\r\n+    public void close() {\r\n+        super.close();\r\n+        closed = true;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void stop() {\r\n+        super.stop();\r\n+        closed = true;\r\n+    }\r\n+\r\n+    public boolean isClosed() {\r\n+        return closed;\r\n+    }\r\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "fef395c237bb433b4c3139bcfbf3da9ad7bf251a",
    "filename": "llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/TestLLRPConnectorConfig.java",
    "status": "added",
    "additions": 105,
    "deletions": 0,
    "changes": 105,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/TestLLRPConnectorConfig.java",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/TestLLRPConnectorConfig.java",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/TestLLRPConnectorConfig.java?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,105 @@\n+/*\r\n+ * Copyright (c) 2021 Vantiq, Inc.\r\n+ *\r\n+ * All rights reserved.\r\n+ *\r\n+ * SPDX: MIT\r\n+ */\r\n+\r\n+package io.vantiq.extsrc.llrpConnector;\r\n+\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.util.LinkedHashMap;\r\n+import java.util.Map;\r\n+\r\n+import org.junit.After;\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import io.vantiq.extjsdk.ExtensionServiceMessage;\r\n+\r\n+public class TestLLRPConnectorConfig {\r\n+\r\n+    LLRPConnectorHandleConfiguration handler;\r\n+\r\n+    NoSendLLRPConnectorCore nCore;\r\n+\r\n+    String sourceName;\r\n+    String authToken;\r\n+    String targetVantiqServer;\r\n+\r\n+    Map<String, Object> general;\r\n+\r\n+    @Before\r\n+    public void setup() {\r\n+        sourceName = \"source\";\r\n+        authToken = \"token\";\r\n+        targetVantiqServer = \"dev.vantiq.com\";\r\n+\r\n+        nCore = new NoSendLLRPConnectorCore(sourceName, authToken, targetVantiqServer);\r\n+        handler = new LLRPConnectorHandleConfiguration(nCore);\r\n+    }\r\n+\r\n+    @After\r\n+    public void tearDown() {\r\n+        nCore.stop();\r\n+    }\r\n+\r\n+    @Test\r\n+    public void testEmptyConfig() {\r\n+        Map conf = new LinkedHashMap<>();\r\n+        sendConfig(conf);\r\n+        assertTrue(\"Should fail on empty configuration\", configIsFailed());\r\n+    }\r\n+\r\n+    @Test\r\n+    public void testMissingGeneral() {\r\n+        Map conf = minimalConfig();\r\n+        conf.remove(\"general\");\r\n+        sendConfig(conf);\r\n+        assertTrue(\"Should fail when missing 'general' configuration\", configIsFailed());\r\n+    }\r\n+\r\n+    @Test\r\n+    public void testMinimalConfig() {\r\n+        nCore.start(5); // Need a client to avoid NPEs on sends\r\n+\r\n+        Map conf = minimalConfig();\r\n+        sendConfig(conf);\r\n+        assertFalse(\"Should not fail with minimal configuration\", configIsFailed());\r\n+    }\r\n+\r\n+// ================================================= Helper functions =================================================\r\n+\r\n+    public void sendConfig(Map<String, ?> llrpConfig) {\r\n+        ExtensionServiceMessage m = new ExtensionServiceMessage(\"\");\r\n+\r\n+        Map<String, Object> obj = new LinkedHashMap<>();\r\n+        Map<String, Object> config = new LinkedHashMap<>();\r\n+        config.put(\"llrpConfig\", llrpConfig);\r\n+        obj.put(\"config\", config);\r\n+        m.object = obj;\r\n+\r\n+        handler.handleMessage(m);\r\n+    }\r\n+\r\n+    public Map<String, Object> minimalConfig() {\r\n+        createMinimalGeneral();\r\n+        Map<String, Object> ret = new LinkedHashMap<>();\r\n+        ret.put(\"general\", general);\r\n+\r\n+        return ret;\r\n+    }\r\n+    public void createMinimalGeneral() {\r\n+        general = new LinkedHashMap<>();\r\n+        general.put(\"hostname\", \"fx7500fcc3e9\");    // \"hostname\";\r\n+        general.put(\"readerPort\", 5084);  // \"readerPort\";\r\n+    }\r\n+\r\n+\r\n+    public boolean configIsFailed() {\r\n+        return handler.isComplete() && nCore.isClosed();\r\n+    }\r\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "8bd97ea5a0f06fdc3a677ac1b5f3aff0a835a691",
    "filename": "llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/TestLLRPConnectorCore.java",
    "status": "added",
    "additions": 80,
    "deletions": 0,
    "changes": 80,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/TestLLRPConnectorCore.java",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/TestLLRPConnectorCore.java",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/TestLLRPConnectorCore.java?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,80 @@\n+/*\r\n+ * Copyright (c) 2021 Vantiq, Inc.\r\n+ *\r\n+ * All rights reserved.\r\n+ *\r\n+ * SPDX: MIT\r\n+ */\r\n+\r\n+package io.vantiq.extsrc.llrpConnector;\r\n+\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import org.junit.After;\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import io.vantiq.extjsdk.FalseClient;\r\n+\r\n+public class TestLLRPConnectorCore {\r\n+\r\n+    NoSendLLRPConnectorCore core;\r\n+\r\n+    String sourceName;\r\n+    String authToken;\r\n+    String targetVantiqServer;\r\n+\r\n+    @Before\r\n+    public void setup() {\r\n+        sourceName = \"source\";\r\n+        authToken = \"token\";\r\n+        targetVantiqServer = \"dev.vantiq.com\";\r\n+\r\n+        core = new NoSendLLRPConnectorCore(sourceName, authToken, targetVantiqServer);\r\n+        core.start(10);\r\n+    }\r\n+\r\n+    @After\r\n+    public void tearDown() {\r\n+        core.stop();\r\n+    }\r\n+\r\n+\r\n+    @Test\r\n+    public void testExitIfConnectionFails() {\r\n+        core.start(3);\r\n+        assertTrue(\"Should have succeeded\", core.exitIfConnectionFails(3));\r\n+        assertFalse(\"Success means it shouldn't be closed\", core.isClosed());\r\n+\r\n+\r\n+        core.close();\r\n+        core = new NoSendLLRPConnectorCore(sourceName, authToken, targetVantiqServer);\r\n+        FalseClient fc = new FalseClient(sourceName);\r\n+        core.client = core.fClient = fc;\r\n+        fc.initiateFullConnection(targetVantiqServer, authToken);\r\n+        fc.completeWebSocketConnection(true);\r\n+        fc.completeAuthentication(false);\r\n+        assertFalse(\"Should fail due to authentication failing\", core.exitIfConnectionFails(3));\r\n+        assertFalse(\"Failure does not mean it should be closed\", core.isClosed());\r\n+\r\n+        core.close();\r\n+        core = new NoSendLLRPConnectorCore(sourceName, authToken, targetVantiqServer);\r\n+        fc = new FalseClient(sourceName);\r\n+        core.client = core.fClient = fc;\r\n+        fc.initiateFullConnection(targetVantiqServer, authToken);\r\n+        fc.completeWebSocketConnection(false);\r\n+        assertFalse(\"Should fail due to WebSocket failing\", core.exitIfConnectionFails(3));\r\n+        assertFalse(\"Failure does not mean it should be closed\", core.isClosed());\r\n+\r\n+        core.close();\r\n+        core = new NoSendLLRPConnectorCore(sourceName, authToken, targetVantiqServer);\r\n+        fc = new FalseClient(sourceName);\r\n+        core.client = core.fClient = fc;\r\n+        fc.initiateFullConnection(targetVantiqServer, authToken);\r\n+        fc.completeWebSocketConnection(true);\r\n+        fc.completeAuthentication(true);\r\n+        assertFalse(\"Should fail due to timeout on source connection\", core.exitIfConnectionFails(3));\r\n+        assertFalse(\"Failure does not mean it should be closed\", core.isClosed());\r\n+    }\r\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "07d727e7eb4ce642e101742ad406c18c14a74eba",
    "filename": "llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/TestLLRPConnectorMain.java",
    "status": "added",
    "additions": 138,
    "deletions": 0,
    "changes": 138,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/TestLLRPConnectorMain.java",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/TestLLRPConnectorMain.java",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/src/test/java/io/vantiq/extsrc/llrpConnector/TestLLRPConnectorMain.java?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,138 @@\n+/*\r\n+ * Copyright (c) 2021 Vantiq, Inc.\r\n+ *\r\n+ * All rights reserved.\r\n+ *\r\n+ * SPDX: MIT\r\n+ */\r\n+\r\n+package io.vantiq.extsrc.llrpConnector;\r\n+\r\n+import static org.junit.Assert.fail;\r\n+\r\n+import java.security.Permission;\r\n+import java.util.List;\r\n+import java.util.Properties;\r\n+\r\n+import org.junit.After;\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+public class TestLLRPConnectorMain {\r\n+\r\n+    @Before\r\n+    public void setup() {\r\n+        System.setSecurityManager(new NoExit());\r\n+    }\r\n+\r\n+    @After\r\n+    public void tearDown() {\r\n+        List<LLRPConnectorCore> sources = LLRPConnectorMain.sources;\r\n+        System.setSecurityManager(null);\r\n+        if (sources != null) {\r\n+            for (LLRPConnectorCore s : sources) {\r\n+                s.stop();\r\n+            }\r\n+            LLRPConnectorMain.sources = null;\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void llrpConfigs() {\r\n+        Properties props = new Properties();\r\n+\r\n+        try {\r\n+            // Fail when no props are given\r\n+            LLRPConnectorMain.createSources(props);\r\n+            fail(\"Didn't exit when missing authToken and sources\");\r\n+        } catch (ExitException e) {\r\n+            assert e.getMessage().equals(\"Exit Requested: auth token was not specified.\");\r\n+            // Expected this Exception\r\n+        }\r\n+\r\n+        try {\r\n+            // Fail when only authToken is set\r\n+            props.setProperty(\"authToken\", \"a token\");\r\n+            LLRPConnectorMain.createSources(props);\r\n+            fail(\"Didn't exit when missing sources\");\r\n+        } catch (ExitException e) {\r\n+            assert e.getMessage().equals(\"Exit Requested: source(s) not specified.\");\r\n+            // Expected this Exception\r\n+        }\r\n+\r\n+        try {\r\n+            // Fail when only authToken and sources are set\r\n+            props.setProperty(\"sources\", \"a source\");\r\n+            LLRPConnectorMain.createSources(props);\r\n+            fail(\"Didn't exit when missing server\");\r\n+        } catch (ExitException e) {\r\n+            assert e.getMessage().equals(\"Exit Requested: target server not specified.\");\r\n+            // Expected this Exception\r\n+        }\r\n+\r\n+        // Succeed when authToken, targetVantiqServer, and sources are set\r\n+        props.setProperty(\"sources\", \"s\");\r\n+        props.setProperty(\"targetServer\", \"url\");\r\n+        LLRPConnectorMain.createSources(props);\r\n+        assert LLRPConnectorMain.targetVantiqServer.equals(\"url\");\r\n+        LLRPConnectorCore s = LLRPConnectorMain.sources.get(0);\r\n+        assert s.getSourceName().equals(\"s\");\r\n+        s.stop();\r\n+\r\n+        try {\r\n+            // Fail when only sources is set\r\n+            props.remove(\"authToken\");\r\n+            LLRPConnectorMain.createSources(props);\r\n+            fail(\"Didn't exit when missing authToken\");\r\n+        } catch (ExitException e) {\r\n+            assert e.getMessage().equals(\"Exit Requested: auth token was not specified.\");\r\n+            // Expected this Exception\r\n+        }\r\n+\r\n+        String targetServer = \"internal.vantiq.com\";\r\n+        props.setProperty(\"authToken\", \"a token\");\r\n+        props.setProperty(\"sources\", \"s2, s1  \");\r\n+        props.setProperty(\"targetServer\", targetServer);\r\n+        LLRPConnectorMain.createSources(props);\r\n+        assert LLRPConnectorMain.targetVantiqServer.equals(targetServer);\r\n+        LLRPConnectorCore s1 = LLRPConnectorMain.sources.get(0);\r\n+        LLRPConnectorCore s2 = LLRPConnectorMain.sources.get(1);\r\n+        assert s1.getSourceName().equals(\"s1\") || s2.getSourceName().equals(\"s1\");\r\n+        assert s1.getSourceName().equals(\"s2\") || s2.getSourceName().equals(\"s2\");\r\n+        s1.stop();\r\n+        s2.stop();\r\n+    }\r\n+\r\n+// ================================================= Helper functions =================================================\r\n+\r\n+    private static class NoExit extends SecurityManager\r\n+    {\r\n+        @Override\r\n+        public void checkPermission(Permission perm) {}\r\n+        @Override\r\n+        public void checkPermission(Permission perm, Object context) {}\r\n+        @Override\r\n+        public void checkExit(int status)\r\n+        {\r\n+            super.checkExit(status);\r\n+            if (status == 1) {\r\n+                throw new ExitException(\"Exit Requested: auth token was not specified.\");\r\n+            } else if (status == 2) {\r\n+                throw new ExitException(\"Exit Requested: source(s) not specified.\");\r\n+            } else if (status == 3) {\r\n+                throw new ExitException(\"Exit Requested: target server not specified.\");\r\n+            } else {\r\n+                throw new ExitException(\"Exit Requested\");\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    protected static class ExitException extends SecurityException\r\n+    {\r\n+        private static final long serialVersionUID = 1L;\r\n+\r\n+        public ExitException(String string) {\r\n+            super(string);\r\n+        }\r\n+    }\r\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "1c5cb13fad067ffac1af6b499f3dce92fc553859",
    "filename": "llrpConnector/src/test/resources/LLRPConnectorExample.zip",
    "status": "added",
    "additions": 0,
    "deletions": 0,
    "changes": 0,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/test/resources/LLRPConnectorExample.zip",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/test/resources/LLRPConnectorExample.zip",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/src/test/resources/LLRPConnectorExample.zip?ref=1816057ce6a0bc407ac57004661ae821f6c40145"
  },
  {
    "sha": "753ae6c91fb59e28bbc4e9f46b5b234d8ba12d6e",
    "filename": "llrpConnector/src/test/resources/llrpConnectorImpl.json",
    "status": "added",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/test/resources/llrpConnectorImpl.json",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/llrpConnector/src/test/resources/llrpConnectorImpl.json",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/llrpConnector/src/test/resources/llrpConnectorImpl.json?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -0,0 +1,6 @@\n+{\r\n+  \"name\" : \"LLRPConnector\",\r\n+  \"baseType\" : \"EXTENSION\",\r\n+  \"verticle\" : \"service:extensionSource\",\r\n+  \"config\" : {}\r\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "884bc3c7a2771b9857fd2ebcf4b44c3d8dadf337",
    "filename": "settings.gradle",
    "status": "modified",
    "additions": 19,
    "deletions": 18,
    "changes": 37,
    "blob_url": "https://github.com/Vantiq/vantiq-extension-sources/blob/1816057ce6a0bc407ac57004661ae821f6c40145/settings.gradle",
    "raw_url": "https://github.com/Vantiq/vantiq-extension-sources/raw/1816057ce6a0bc407ac57004661ae821f6c40145/settings.gradle",
    "contents_url": "https://api.github.com/repos/Vantiq/vantiq-extension-sources/contents/settings.gradle?ref=1816057ce6a0bc407ac57004661ae821f6c40145",
    "patch": "@@ -1,18 +1,19 @@\n-rootProject.name = 'vantiq-extension-source'\n-include 'opcuaSource'\n-include 'extjsdk'\n-include 'udpSource'\n-include 'CSVSource'\n-include 'testConnector'\n-if (System.env.EASY_MODBUS_LOC) {\n-    include 'EasyModbusSource' \n-}\n-if (System.env.OPENCV_LOC) {\n-    include 'objectRecognitionSource'\n-}\n-if (System.env.JDBC_DRIVER_LOC) {\n-    include 'jdbcSource'\n-}\n-if (System.env.JMS_DRIVER_LOC) {\n-    include 'jmsSource'\n-}\n+rootProject.name = 'vantiq-extension-source'\r\n+include 'opcuaSource'\r\n+include 'extjsdk'\r\n+include 'udpSource'\r\n+include 'CSVSource'\r\n+include 'testConnector'\r\n+include 'llrpConnector'\r\n+if (System.env.EASY_MODBUS_LOC) {\r\n+    include 'EasyModbusSource' \r\n+}\r\n+if (System.env.OPENCV_LOC) {\r\n+    include 'objectRecognitionSource'\r\n+}\r\n+if (System.env.JDBC_DRIVER_LOC) {\r\n+    include 'jdbcSource'\r\n+}\r\n+if (System.env.JMS_DRIVER_LOC) {\r\n+    include 'jmsSource'\r\n+}\r"
  }
]
