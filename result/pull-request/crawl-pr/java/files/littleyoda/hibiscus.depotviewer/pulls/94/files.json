[
  {
    "sha": "20d96f92eb4e89b0cd1afe4572aedaf96d6b59a5",
    "filename": "src/de/open4me/depot/hbcijobs/HBCIDepotBestandJob.java",
    "status": "modified",
    "additions": 38,
    "deletions": 37,
    "changes": 75,
    "blob_url": "https://github.com/littleyoda/hibiscus.depotviewer/blob/93a1ae2d92fdd0eb901564d061ab727489c724a9/src/de/open4me/depot/hbcijobs/HBCIDepotBestandJob.java",
    "raw_url": "https://github.com/littleyoda/hibiscus.depotviewer/raw/93a1ae2d92fdd0eb901564d061ab727489c724a9/src/de/open4me/depot/hbcijobs/HBCIDepotBestandJob.java",
    "contents_url": "https://api.github.com/repos/littleyoda/hibiscus.depotviewer/contents/src/de/open4me/depot/hbcijobs/HBCIDepotBestandJob.java?ref=93a1ae2d92fdd0eb901564d061ab727489c724a9",
    "patch": "@@ -103,52 +103,53 @@ protected void markExecuted() throws RemoteException, ApplicationException\n \t\tif (!result.isOK()) {\n \t\t\tthrow new ApplicationException(result.getJobStatus().getErrorString());\n \t\t}\n-\t\tif (result.getEntries().length > 1) {\n-\t\t\tString out = \"\";\n-\t\t\tfor (int idx = 0; idx < result.getEntries().length; idx++) {\n-\t\t\t\tEntry depot = result.getEntries()[idx];\n-\t\t\t\tif (depot.depot != null && depot.depot.iban != null) {\n-\t\t\t\t\tout = out + \" \" + depot.depot.iban;\n-\t\t\t\t} else {\n-\t\t\t\t\tout = out + \" NULL\";\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tLogger.error(\"Folgende Depots wurden zurückgeliefert:\" + out);\n-\t\t\tthrow new ApplicationException(\"Zuviele Depots wurden zurückgeliefert (Besand)\");\n-\t\t}\n+//\t\tif (result.getEntries().length > 1) {\n+//\t\t\tString out = \"\";\n+//\t\t\tfor (int idx = 0; idx < result.getEntries().length; idx++) {\n+//\t\t\t\tEntry depot = result.getEntries()[idx];\n+//\t\t\t\tif (depot.depot != null && depot.depot.iban != null) {\n+//\t\t\t\t\tout = out + \" \" + depot.depot.iban;\n+//\t\t\t\t} else {\n+//\t\t\t\t\tout = out + \" NULL\";\n+//\t\t\t\t}\n+//\t\t\t}\n+//\t\t\tLogger.error(\"Folgende Depots wurden zurückgeliefert:\" + out);\n+//\t\t\tthrow new ApplicationException(\"Zuviele Depots wurden zurückgeliefert (Besand)\");\n+//\t\t}\n \n \t\tUmsatzeAusBestandsAenderung umsaetzeAusBestaenden = null;\n \t\t\n \t\tif (simulateOrders) {\n \t\t\tumsaetzeAusBestaenden = new UmsatzeAusBestandsAenderung(konto);\n \t\t}\n \n-\n-\n \t\tUtils.clearBestand(konto);\n-\t\tEntry depot = result.getEntries()[0];\n-\t\tkonto.setSaldo((depot.total != null) ? depot.total.getValue().doubleValue() : 0); // Bei der DKB ist depot.total == null, wenn das Depot leer ist\n-\t\tkonto.store();\n-\t\tUtils.clearBestand(konto);\n-\t\tfor (Gattung  g : depot.getEntries()) {\n-\t\t\tif (g == null) {\n-\t\t\t\tLogger.error(\"Null Entry in depot.getEntries\");\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tif (g.saldo == null || g.price == null || g.depotwert == null) {\n-\t\t\t\tLogger.error(\"Eintrag ohne Saldo oder Wert. Saldo: \" + g.saldo_type + \" \" + g.saldo + \" \" + \"Wert: \" + g.depotwert + \" Price: \" + g.pricetype + \" \" + g.pricequalifier + \" \" + g.price);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tBigDecimal anzahl = g.saldo.getValue();\n-\t\t\tif(g.getEntries().length == 1) {\n-\t\t\t\tSubSaldo sub = g.getEntries()[0];\n-\t\t\t\tif(\"TAVI\".equals(sub.qualifier)) { // TAVI = Total Available. Dies ist die eigentlich verfügbare Anzahl, falls g.saldo gerundet angegeben ist, zB. bei Depots der DKB \n-\t\t\t\t\tanzahl = sub.saldo.getValue();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tUtils.addBestand(Utils.getORcreateWKN(g.wkn, g.isin, g.name), konto, anzahl.doubleValue(), g.price.getValue().doubleValue(), \n-\t\t\t\t\tg.price.getCurr(), g.depotwert.getValue().doubleValue(),  g.depotwert.getCurr(), depot.timestamp, g.timestamp_price);\n+\t\tBigDecimal total = BigDecimal.ZERO;\n+\t\tfor(Entry depot : result.getEntries()) {\n+  \t\tfor (Gattung  g : depot.getEntries()) {\n+  \t\t\tif (g == null) {\n+  \t\t\t\tLogger.error(\"Null Entry in depot.getEntries\");\n+  \t\t\t\tcontinue;\n+  \t\t\t}\n+  \t\t\tif (g.saldo == null || g.price == null || g.depotwert == null) {\n+  \t\t\t\tLogger.error(\"Eintrag ohne Saldo oder Wert. Saldo: \" + g.saldo_type + \" \" + g.saldo + \" \" + \"Wert: \" + g.depotwert + \" Price: \" + g.pricetype + \" \" + g.pricequalifier + \" \" + g.price);\n+  \t\t\t\tcontinue;\n+  \t\t\t}\n+  \t\t\tBigDecimal anzahl = g.saldo.getValue();\n+  \t\t\tif(g.getEntries().length == 1) {\n+  \t\t\t\tSubSaldo sub = g.getEntries()[0];\n+  \t\t\t\tif(\"TAVI\".equals(sub.qualifier)) { // TAVI = Total Available. Dies ist die eigentlich verfügbare Anzahl, falls g.saldo gerundet angegeben ist, zB. bei Depots der DKB \n+  \t\t\t\t\tanzahl = sub.saldo.getValue();\n+  \t\t\t\t}\n+  \t\t\t}\n+  \t\t\tUtils.addBestand(Utils.getORcreateWKN(g.wkn, g.isin, g.name), konto, anzahl.doubleValue(), g.price.getValue().doubleValue(), \n+  \t\t\t\t\tg.price.getCurr(), g.depotwert.getValue().doubleValue(),  g.depotwert.getCurr(), depot.timestamp, g.timestamp_price);\n+  \t\t}\n+  \t\ttotal = total.add((depot.total != null) ? depot.total.getValue() : BigDecimal.ZERO); // Bei der DKB ist depot.total == null, wenn das Depot leer ist\n \t\t}\n+\t\tkonto.setSaldo(total.doubleValue());\n+\t\tkonto.store(); \n+\t\t\n \t\tif (simulateOrders) {\n \t\t\tumsaetzeAusBestaenden.erzeugeUmsaetze();\n \t\t}"
  }
]
