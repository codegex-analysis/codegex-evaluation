[
  {
    "sha": "a6b14834661cc87a6c87e4311789b29d395f985d",
    "filename": "server/src/main/java/server/ClientHandler.java",
    "status": "modified",
    "additions": 41,
    "deletions": 36,
    "changes": 77,
    "blob_url": "https://github.com/Zaytsev-Andrey/training_chat/blob/639b0fcdc5c6b1d1e95b2330ce849e15e96237b8/server/src/main/java/server/ClientHandler.java",
    "raw_url": "https://github.com/Zaytsev-Andrey/training_chat/raw/639b0fcdc5c6b1d1e95b2330ce849e15e96237b8/server/src/main/java/server/ClientHandler.java",
    "contents_url": "https://api.github.com/repos/Zaytsev-Andrey/training_chat/contents/server/src/main/java/server/ClientHandler.java?ref=639b0fcdc5c6b1d1e95b2330ce849e15e96237b8",
    "patch": "@@ -17,7 +17,7 @@\n import java.sql.SQLException;\n import java.util.List;\n \n-public class ClientHandler {\n+public class ClientHandler implements Runnable {\n     private SessionStatus status;\n     private Server server;\n     private Socket socket;\n@@ -36,45 +36,50 @@ public ClientHandler(Socket socket, Server server, UserStorage userStorage) {\n \n         status = SessionStatus.NOT_AUTH;\n \n-        new Thread(() -> {\n+//        new Thread(() -> {\n+//\n+//        }).start();\n+\n+\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            out = new ObjectOutputStream(socket.getOutputStream());\n+            in = new ObjectInputStream(socket.getInputStream());\n+            ConsoleLogger.clientConnectedToServer(socket.getInetAddress().toString());\n+            socket.setSoTimeout(120000);\n+\n+            auth();\n+            readMessage();\n+        } catch (SocketTimeoutException e) {\n+            Message msg = Message.createEndMessage();\n+            sendMsg(msg);\n+            status = SessionStatus.DISCONNECTED;\n+            ConsoleLogger.authorizationTimedOut(socket.getInetAddress().toString());\n+        } catch (IOException e) {\n+            ConsoleLogger.clientInterruptedConnection(clientNick);\n+        }\n+        finally {\n+            server.disconnectClient(this);\n+\n             try {\n-                out = new ObjectOutputStream(socket.getOutputStream());\n-                in = new ObjectInputStream(socket.getInputStream());\n-                ConsoleLogger.clientConnectedToServer(socket.getInetAddress().toString());\n-                socket.setSoTimeout(120000);\n-\n-                auth();\n-                readMessage();\n-            } catch (SocketTimeoutException e) {\n-                Message msg = Message.createEndMessage();\n-                sendMsg(msg);\n-                status = SessionStatus.DISCONNECTED;\n-                ConsoleLogger.authorizationTimedOut(socket.getInetAddress().toString());\n+                in.close();\n             } catch (IOException e) {\n-                ConsoleLogger.clientInterruptedConnection(clientNick);\n+                e.printStackTrace();\n             }\n-            finally {\n-                server.disconnectClient(this);\n-\n-                try {\n-                    in.close();\n-                } catch (IOException e) {\n-                    e.printStackTrace();\n-                }\n-                try {\n-                    out.close();\n-                } catch (IOException e) {\n-                    e.printStackTrace();\n-                }\n-                try {\n-                    socket.close();\n-                } catch (IOException e) {\n-                    e.printStackTrace();\n-                }\n+            try {\n+                out.close();\n+            } catch (IOException e) {\n+                e.printStackTrace();\n             }\n-        }).start();\n-\n-\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        }\n     }\n \n     private void auth() throws IOException {"
  },
  {
    "sha": "3fc2a0719f1a7095f1890da681ba4847b495a2a6",
    "filename": "server/src/main/java/server/Server.java",
    "status": "modified",
    "additions": 27,
    "deletions": 2,
    "changes": 29,
    "blob_url": "https://github.com/Zaytsev-Andrey/training_chat/blob/639b0fcdc5c6b1d1e95b2330ce849e15e96237b8/server/src/main/java/server/Server.java",
    "raw_url": "https://github.com/Zaytsev-Andrey/training_chat/raw/639b0fcdc5c6b1d1e95b2330ce849e15e96237b8/server/src/main/java/server/Server.java",
    "contents_url": "https://api.github.com/repos/Zaytsev-Andrey/training_chat/contents/server/src/main/java/server/Server.java?ref=639b0fcdc5c6b1d1e95b2330ce849e15e96237b8",
    "patch": "@@ -11,32 +11,57 @@\n import java.net.Socket;\n import java.sql.SQLException;\n import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.stream.Collectors;\n \n public class Server {\n     private ServerSocket serverSocket;\n     private Socket socket;\n     private CopyOnWriteArrayList<ClientHandler> activeClients;\n     private UserStorage userStorage;\n+    private ExecutorService executorService;\n \n     public Server() {\n+        // Для запуска клиентских соединений в отдельных потоках использовал реализацию интерфейса ExecutorService\n+        // создаваемую с помощью фабричного метода newCachedThreadPool() класса Executors. Данная реализация позволит\n+        // мгновенно запускать новую задачу (используя существующий поток или создавая новый). Заметное увеличение\n+        // прозводительности будет при интенсивном отключении и подключение новых клиентов в интервале 60 сек, когда\n+        // освоодившиеся потоки не будут уничтожаться и смогут принимать новые задачи. Поскольку интенсивность подключий\n+        // клиентов может быть не равномерной (в одно время суток достигать максимума, а в другое клиентских подключний\n+        // может и не быть), реализация newCachedThreadPool позволит удалить не используемые потоки и освободить ресурсы.\n+        // Большим недостатком такой реализации является фактически не ограниченное (Integer.MAX_VALUE) число возможных\n+        // потоков, что может привести к перерасходу ресурсов.\n+        //\n+        // Фабричные методы класса Executors возвращают объекты класса ThreadPoolExecutor с фиксированными\n+        // значениями конструктора, например для newCachedThreadPool: new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L,\n+        // TimeUnit.SECONDS, new SynchronousQueue<Runnable>()) где вторым параметром передается максимально число потоков,\n+        // а третьим параметром время простоя потока перед уничтожением. В случае обнаружения проблем в работе текущей\n+        // реализации ExecutorService возможно создать свой ThreadPoolExecutor настроив его более точно (ограничив\n+        // максимальное число потоков или увеличив время простоя потока перед уничтожением). При этом остальной код\n+        // программы останется неизменным.\n+        executorService = Executors.newCachedThreadPool();\n+\n         try {\n             userStorage = new SQLiteStorage();\n             activeClients = new CopyOnWriteArrayList();\n             serverSocket = new ServerSocket(ParameterApp.PORT);\n-            ConsoleLogger.serverIsRunning();\n \n+            ConsoleLogger.serverIsRunning();\n \n             while (true) {\n                 socket = serverSocket.accept();\n-                new ClientHandler(socket, this, userStorage);\n+                ClientHandler newClient = new ClientHandler(socket, this, userStorage);\n+                executorService.execute(newClient);\n             }\n \n         } catch (ClassNotFoundException | SQLException e) {\n             e.printStackTrace();\n         } catch (IOException e) {\n             e.printStackTrace();\n         } finally {\n+            executorService.shutdown();\n+\n             if (serverSocket != null) {\n                 try {\n                     serverSocket.close();"
  }
]
