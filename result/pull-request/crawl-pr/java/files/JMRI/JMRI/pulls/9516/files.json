[
  {
    "sha": "424cfd98e5acfc4d9307a72b33220df2627ff5c5",
    "filename": "help/en/releasenotes/current-draft-note.shtml",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/JMRI/JMRI/blob/6581f7169120c451cec7c0c221e90a158bdd7c72/help/en/releasenotes/current-draft-note.shtml",
    "raw_url": "https://github.com/JMRI/JMRI/raw/6581f7169120c451cec7c0c221e90a158bdd7c72/help/en/releasenotes/current-draft-note.shtml",
    "contents_url": "https://api.github.com/repos/JMRI/JMRI/contents/help/en/releasenotes/current-draft-note.shtml?ref=6581f7169120c451cec7c0c221e90a158bdd7c72",
    "patch": "@@ -132,7 +132,8 @@\n \n         <h4>SPROG</h4>\n             <ul>\n-                <li></li>\n+                <li>Increased maximum command station slots to 64 and added advanced connection preference to select.</li>\n+                <li>Added support for current CV value hint when reading (requires a future SPROG 4.5 firmware release).</li>\n             </ul>\n \n         <h4>TAMS</h4>"
  },
  {
    "sha": "c4e688c098bd560be61c879353cc33f3820e907c",
    "filename": "java/src/jmri/Programmer.java",
    "status": "modified",
    "additions": 41,
    "deletions": 0,
    "changes": 41,
    "blob_url": "https://github.com/JMRI/JMRI/blob/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/Programmer.java",
    "raw_url": "https://github.com/JMRI/JMRI/raw/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/Programmer.java",
    "contents_url": "https://api.github.com/repos/JMRI/JMRI/contents/java/src/jmri/Programmer.java?ref=6581f7169120c451cec7c0c221e90a158bdd7c72",
    "patch": "@@ -29,6 +29,8 @@\n  * <p>\n  * Starting in JMRI 3.5.5, the CV addresses are Strings for generality. The\n  * methods that use ints for CV addresses will later be deprecated.\n+ * <p>\n+ * Added possibility to supply CV value hint to the system\n  * <hr>\n  * This file is part of JMRI.\n  * <p>\n@@ -43,9 +45,16 @@\n  * @see jmri.GlobalProgrammerManager\n  * @see jmri.AddressedProgrammerManager\n  * @author Bob Jacobsen Copyright (C) 2001, 2008, 2013\n+ * @author Andrew Crosland (C) 2021\n  */\n public interface Programmer {\n \n+    /**\n+     * Use this constant for startVal to indicate no hint is available when calling\n+     * readCV(String CV, ProgListener p, int startVal)\n+     */\n+    public static final int NO_DEFAULT_CV = -1;\n+    \n     /**\n      * Perform a CV write in the system-specific manner, and using the specified\n      * programming mode.\n@@ -91,6 +100,38 @@\n      */\n     void readCV(String CV, ProgListener p) throws ProgrammerException;\n \n+    /**\n+     * Perform a CV read in the system-specific manner, and using the specified\n+     * programming mode, possibly using a hint of the current value to speed up\n+     * programming.\n+     * <p>\n+     * Handles a general address space through a String address. Each programmer\n+     * defines the acceptable formats.\n+     * <p>\n+     * On systems that support it, the startVal is a hint as to what the current\n+     * value of the CV might be (e.g. the value from the roster). This could be\n+     * verified immediately in direct byte mode to speed up the read process.\n+     * <p>\n+     * Note that this returns before the write is complete; you have to provide\n+     * a ProgListener to hear about completion. For simplicity, expect the return to be on the \n+     * <a href=\"http://jmri.org/help/en/html/doc/Technical/Threads.shtml\">GUI thread</a>.\n+     * <p>\n+     * Defaults to the normal read method if not overridden in a specific implementation.\n+     * <p>\n+     * Exceptions will only be\n+     * thrown at the start, not during the actual programming sequence. A\n+     * typical exception would be due to an invalid mode (though that should be\n+     * prevented earlier)\n+     *\n+     * @param CV the CV to read\n+     * @param p  the listener that will be notified of the read\n+     * @param startVal  a hint of what the current value might be\n+     * @throws jmri.ProgrammerException if unable to communicate\n+     */\n+    public default void readCV(String CV, ProgListener p, int startVal) throws ProgrammerException {\n+        readCV(CV, p);\n+    }\n+\n     /**\n      * Confirm the value of a CV using the specified programming mode. On some\n      * systems, this is faster than a read."
  },
  {
    "sha": "e4d68889cf6fe3c564c1539dbe93187ea9d275fc",
    "filename": "java/src/jmri/implementation/MultiIndexProgrammerFacade.java",
    "status": "modified",
    "additions": 24,
    "deletions": 4,
    "changes": 28,
    "blob_url": "https://github.com/JMRI/JMRI/blob/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/implementation/MultiIndexProgrammerFacade.java",
    "raw_url": "https://github.com/JMRI/JMRI/raw/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/implementation/MultiIndexProgrammerFacade.java",
    "contents_url": "https://api.github.com/repos/JMRI/JMRI/contents/java/src/jmri/implementation/MultiIndexProgrammerFacade.java?ref=6581f7169120c451cec7c0c221e90a158bdd7c72",
    "patch": "@@ -54,6 +54,7 @@\n  * @see jmri.implementation.ProgrammerFacadeSelector\n  *\n  * @author Bob Jacobsen Copyright (C) 2013\n+ * @author Andrew Crosland Copyright (C) 2021\n  */\n  \n /*\n@@ -111,6 +112,7 @@ public MultiIndexProgrammerFacade(Programmer prog, String indexPI, String indexS\n     String _cv; // remember the cv number being read/written\n     int valuePI;  //  value to write to PI in current operation or -1\n     int valueSI;  //  value to write to SI in current operation or -1\n+    int _startVal;  // Current CV value hint\n \n     // remember last operation for skipDupIndexWrite\n     int lastValuePI = -1;  // value written in last operation\n@@ -255,18 +257,32 @@ synchronized public void writeCV(String CV, int val, jmri.ProgListener p) throws\n \n     @Override\n     synchronized public void readCV(String CV, jmri.ProgListener p) throws jmri.ProgrammerException {\n+        readCV(_cv, this, NO_DEFAULT_CV);\n+    }\n+\n+    @Override\n+    synchronized public void readCV(String CV, jmri.ProgListener p, int startVal) throws jmri.ProgrammerException {\n         useProgrammer(p);\n         parseCV(CV);\n+        _startVal = startVal;\n         if (valuePI == -1) {\n             lastValuePI = -1;  // next indexed operation needs to write PI, SI\n             lastValueSI = -1;\n \n             state = ProgState.PROGRAMMING;\n-            prog.readCV(_cv, this);\n+            if (startVal == NO_DEFAULT_CV) {\n+                prog.readCV(_cv, this);\n+            } else {\n+                prog.readCV(_cv, this, _startVal);\n+            }\n         } else if (useCachePiSi()) {\n             // indexed operation with set values is same as non-indexed operation\n-            state = ProgState.PROGRAMMING;\n-            prog.readCV(_cv, this);\n+            if (startVal == NO_DEFAULT_CV) {\n+                prog.readCV(_cv, this);\n+            } else {\n+                prog.readCV(_cv, this, _startVal);\n+            }\n+            prog.readCV(_cv, this, _startVal);\n         } else {\n             lastValuePI = valuePI;  // after check in 'if' statement\n             lastValueSI = valueSI;\n@@ -375,7 +391,11 @@ public void programmingOpReply(int value, int status) {\n                 if (valueSI == -1) {\n                     try {\n                         state = ProgState.PROGRAMMING;\n-                        prog.readCV(_cv, this);\n+                        if (_startVal == NO_DEFAULT_CV) {\n+                            prog.readCV(_cv, this);\n+                        } else {\n+                            prog.readCV(_cv, this, _startVal);\n+                        }\n                     } catch (jmri.ProgrammerException e) {\n                         log.error(\"Exception doing final read\", e);\n                     }"
  },
  {
    "sha": "6e060f575a73b796b7b51e03345d269d463ed654",
    "filename": "java/src/jmri/jmrit/symbolicprog/CvValue.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/JMRI/JMRI/blob/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/jmrit/symbolicprog/CvValue.java",
    "raw_url": "https://github.com/JMRI/JMRI/raw/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/jmrit/symbolicprog/CvValue.java",
    "contents_url": "https://api.github.com/repos/JMRI/JMRI/contents/java/src/jmri/jmrit/symbolicprog/CvValue.java?ref=6581f7169120c451cec7c0c221e90a158bdd7c72",
    "patch": "@@ -23,6 +23,7 @@\n  *\n  * @author Bob Jacobsen Copyright (C) 2001, 2003, 2004, 2013\n  * @author Howard G. Penny Copyright (C) 2005\n+ * @author Andrew Crosland (C) 2021\n  */\n public class CvValue extends AbstractValue implements ProgListener {\n \n@@ -353,7 +354,8 @@ public void read(JLabel status) {\n             _reading = true;\n             _confirm = false;\n             try {\n-                mProgrammer.readCV(_num, this);\n+                //mProgrammer.readCV(_num, this);\n+                mProgrammer.readCV(_num, this, this.getValue());\n             } catch (Exception e) {\n                 if (status != null) {\n                     status.setText("
  },
  {
    "sha": "36b77cfd5fb92ad520d6b503402e0e52315c959c",
    "filename": "java/src/jmri/jmrix/sprog/SprogMessage.java",
    "status": "modified",
    "additions": 23,
    "deletions": 0,
    "changes": 23,
    "blob_url": "https://github.com/JMRI/JMRI/blob/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/jmrix/sprog/SprogMessage.java",
    "raw_url": "https://github.com/JMRI/JMRI/raw/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/jmrix/sprog/SprogMessage.java",
    "contents_url": "https://api.github.com/repos/JMRI/JMRI/contents/java/src/jmri/jmrix/sprog/SprogMessage.java?ref=6581f7169120c451cec7c0c221e90a158bdd7c72",
    "patch": "@@ -272,6 +272,29 @@ static public SprogMessage getReadCV(int cv, ProgrammingMode mode) {\n         return m;\n     }\n \n+    /*\n+     * CV reads can pass a hint by using different commands. The hint will first\n+     * be verified, potentially speeding up the read process.\n+     * \n+     * @param cv        CV address\n+     * @param mode      Programming mode\n+     * @param startVal  Hint\n+     * @return \n+     */\n+    static public SprogMessage getReadCV(int cv, ProgrammingMode mode, int startVal) {\n+        SprogMessage m = new SprogMessage(10);\n+        if (mode == ProgrammingMode.PAGEMODE) {\n+            m.setOpCode('U');\n+        } else { // Bit direct mode\n+            m.setOpCode('D');\n+        }\n+        addSpace(m, 1);\n+        addIntAsFour(cv, m, 2);\n+        addSpace(m, 6);\n+        addIntAsThree(startVal, m, 7);\n+        return m;\n+    }\n+\n     static public SprogMessage getWriteCV(int cv, int val, ProgrammingMode mode) {\n         SprogMessage m = new SprogMessage(10);\n         if (mode == ProgrammingMode.PAGEMODE) {"
  },
  {
    "sha": "80f833d08e903227cb11addba442e62ec199461b",
    "filename": "java/src/jmri/jmrix/sprog/SprogProgrammer.java",
    "status": "modified",
    "additions": 75,
    "deletions": 11,
    "changes": 86,
    "blob_url": "https://github.com/JMRI/JMRI/blob/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/jmrix/sprog/SprogProgrammer.java",
    "raw_url": "https://github.com/JMRI/JMRI/raw/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/jmrix/sprog/SprogProgrammer.java",
    "contents_url": "https://api.github.com/repos/JMRI/JMRI/contents/java/src/jmri/jmrix/sprog/SprogProgrammer.java?ref=6581f7169120c451cec7c0c221e90a158bdd7c72",
    "patch": "@@ -1,23 +1,26 @@\n package jmri.jmrix.sprog;\n \n import java.util.*;\n+\n import javax.annotation.Nonnull;\n \n import jmri.*;\n import jmri.jmrix.AbstractProgrammer;\n+import jmri.jmrix.sprog.update.*;\n \n /**\n  * Implement the jmri.Programmer interface via commands for the Sprog\n  * programmer. This provides a service mode programmer.\n  *\n  * @author Bob Jacobsen Copyright (C) 2001\n  */\n-public class SprogProgrammer extends AbstractProgrammer implements SprogListener {\n+public class SprogProgrammer extends AbstractProgrammer implements SprogListener, SprogVersionListener {\n \n     private SprogSystemConnectionMemo _memo = null;\n+    private SprogVersion _sv = null;\n \n     public SprogProgrammer(SprogSystemConnectionMemo memo) {\n-         _memo = memo;\n+        _memo = memo;\n     }\n \n     /** \n@@ -64,7 +67,7 @@ synchronized public void writeCV(String CVname, int val, jmri.ProgListener p) th\n         }\n         useProgrammer(p);\n         _val = val;\n-        startProgramming(_val, CV);\n+        startProgramming(_val, CV, NO_DEFAULT_CV);\n     }\n \n     /** \n@@ -80,30 +83,67 @@ synchronized public void confirmCV(String CV, int val, jmri.ProgListener p) thro\n      */\n     @Override\n     synchronized public void readCV(String CVname, jmri.ProgListener p) throws jmri.ProgrammerException {\n+        readCVWithDefault(CVname, p, NO_DEFAULT_CV);\n+    }\n+    \n+    /** \n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void readCV(String CVname, jmri.ProgListener p, int startVal) throws jmri.ProgrammerException {\n+        if (_sv != null) {\n+            if (_sv.supportsCVHints()) {\n+                // Connected hardware supports CV hint\n+                log.debug(\"Hardware supports hints\");\n+                readCVWithDefault(CVname, p, startVal);\n+            } else {\n+                // Fallback to not using a hint\n+                log.debug(\"Hardware does not support hints\");\n+                readCVWithDefault(CVname, p, NO_DEFAULT_CV);\n+            }\n+        } else {\n+            // The SPROG version is not known yet so request the version for later\n+            // and fall back to normal CV read this time\n+            log.debug(\"SPROG version is unknown\");\n+            readCVWithDefault(CVname, p, NO_DEFAULT_CV);\n+            _memo.getSprogVersionQuery().requestVersion(this);\n+        }\n+    }\n+\n+    /**\n+     * Internal method to read a CV with a possible default value\n+     * \n+     * @param CVname    Index of CV to read\n+     * @param p         Programming listener\n+     * @param startVal  CV default value, Use NO_DEFAULT_CV if no default available\n+     * @throws jmri.ProgrammerException if programming operation fails\n+     */\n+    synchronized public void readCVWithDefault(String CVname, jmri.ProgListener p, int startVal) throws jmri.ProgrammerException {\n         final int CV = Integer.parseInt(CVname);\n         if (log.isDebugEnabled()) {\n-            log.debug(\"readCV {} mode {} listens {}\", CV, getMode(), p);\n+            log.debug(\"readCV {} mode {} hint {} listens {}\", CV, getMode(), startVal, p);\n         }\n         useProgrammer(p);\n         _val = -1;\n-        startProgramming(_val, CV);\n+        startProgramming(_val, CV, startVal);\n     }\n \n     private jmri.ProgListener _usingProgrammer = null;\n \n     /**\n      * Send the command to start programming operation.\n      * \n-     * @param val   Value to be written, or -1 for read\n-     * @param CV    CV to read/write\n+     * @param val       Value to be written, or -1 for read\n+     * @param CV        CV to read/write\n+     * @param startVal  Hint of what current CV value may be\n      */\n-    private void startProgramming(int val, int CV) {\n+    private void startProgramming(int val, int CV, int startVal) {\n         // here ready to send the read/write command\n         progState = COMMANDSENT;\n         // see why waiting\n         try {\n             startLongTimer();\n-            controller().sendSprogMessage(progTaskStart(getMode(), val, CV), this);\n+            controller().sendSprogMessage(progTaskStart(getMode(), val, CV, startVal), this);\n         } catch (Exception e) {\n             // program op failed, go straight to end\n             log.error(\"program operation failed, exception {}\",e);\n@@ -134,12 +174,17 @@ protected void useProgrammer(jmri.ProgListener p) throws jmri.ProgrammerExceptio\n      * @param mode Mode to be used\n      * @param val value to be written\n      * @param cvnum CV address to write to \n+     * @param startVal Hint of what the CV may contain\n      * @return formatted message to do programming operation\n      */\n-    protected SprogMessage progTaskStart(ProgrammingMode mode, int val, int cvnum) {\n+    protected SprogMessage progTaskStart(ProgrammingMode mode, int val, int cvnum, int startVal) {\n         // val = -1 for read command; mode is direct, etc\n         if (val < 0) {\n-            return SprogMessage.getReadCV(cvnum, mode);\n+            if (startVal == NO_DEFAULT_CV) {\n+                return SprogMessage.getReadCV(cvnum, mode);\n+            } else {\n+                return SprogMessage.getReadCV(cvnum, mode, startVal);\n+            }\n         } else {\n             return SprogMessage.getWriteCV(cvnum, val, mode);\n         }\n@@ -198,6 +243,25 @@ synchronized public void notifyReply(SprogReply reply) {\n         }\n     }\n \n+    /**\n+     * Handle a SprogVersion notification.\n+     * <p>\n+     * Decode the SPROG version and populate the console gui appropriately with\n+     * the features applicable to the version.\n+     *\n+     * @param v The SprogVersion being handled\n+     */\n+    @Override\n+    synchronized public void notifyVersion(SprogVersion v) {\n+        // Save it for subsequent operations\n+        _sv = v;\n+        // Save it for others\n+        _memo.setSprogVersion(v);\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Found: {}\", v.toString());\n+        }\n+    }\n+\n     /** \n      * {@inheritDoc}\n      *"
  },
  {
    "sha": "c19b404b08c8db910b99f6fae842c7f60232d9b4",
    "filename": "java/src/jmri/jmrix/sprog/simulator/SimulatorAdapter.java",
    "status": "modified",
    "additions": 14,
    "deletions": 3,
    "changes": 17,
    "blob_url": "https://github.com/JMRI/JMRI/blob/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/jmrix/sprog/simulator/SimulatorAdapter.java",
    "raw_url": "https://github.com/JMRI/JMRI/raw/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/jmrix/sprog/simulator/SimulatorAdapter.java",
    "contents_url": "https://api.github.com/repos/JMRI/JMRI/contents/java/src/jmri/jmrix/sprog/simulator/SimulatorAdapter.java?ref=6581f7169120c451cec7c0c221e90a158bdd7c72",
    "patch": "@@ -307,7 +307,13 @@ private SprogReply generateReply(SprogMessage msg) {\n             case 'C':\n             case 'V':\n                 log.debug(\"Read/Write CV detected\");\n-                reply = new SprogReply(\"= \" + msg.toString().substring(2) + \"\\n\"); // echo CV value (hex)\n+                reply = new SprogReply(\"= h\" + msg.toString().substring(2) + \"\\n\"); // echo CV value (hex)\n+                break;\n+\n+            case 'D':\n+            case 'U':\n+                log.debug(\"Read/Write CV with hint detected\");\n+                reply = new SprogReply(\"= h\" + msg.toString().substring(2) + \"\\n\"); // echo CV hint value (hex)\n                 break;\n \n             case 'O':\n@@ -337,7 +343,7 @@ private SprogReply generateReply(SprogMessage msg) {\n \n             case '?':\n                 log.debug(\"Read_Sprog_Version detected\");\n-                String replyString = \"\\nSPROG II Ver 4.3\\n\";\n+                String replyString = \"\\nSPROG II Ver 4.5\\n\";\n                 reply = new SprogReply(replyString);\n                 break;\n \n@@ -351,6 +357,11 @@ private SprogReply generateReply(SprogMessage msg) {\n                 reply = new SprogReply(\"OK\\n\");\n                 break;\n \n+            case ' ':\n+                log.debug(\"null command detected\");\n+                reply = new SprogReply(\"\\n\");\n+                break;\n+\n             default:\n                 log.debug(\"non-reply message detected: {}\", msg.toString());\n                 reply = new SprogReply(\"!E\\n\"); // SPROG error reply\n@@ -379,7 +390,7 @@ private void writeReply(SprogReply r) {\n         for (int i = 0; i < len; i++) {\n             try {\n                 outpipe.writeByte((byte) r.getElement(i));\n-                log.debug(\"{} of {} bytes written to outpipe\", i + 1, len);\n+                //log.debug(\"{} of {} bytes written to outpipe\", i + 1, len);\n                 if (pin.available() > 0) {\n                     control.handleOneIncomingReply();\n                 }"
  },
  {
    "sha": "f9a958f32f3298b749002e4464efe07f6b4e940d",
    "filename": "java/src/jmri/jmrix/sprog/update/SprogVersion.java",
    "status": "modified",
    "additions": 25,
    "deletions": 0,
    "changes": 25,
    "blob_url": "https://github.com/JMRI/JMRI/blob/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/jmrix/sprog/update/SprogVersion.java",
    "raw_url": "https://github.com/JMRI/JMRI/raw/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/jmrix/sprog/update/SprogVersion.java",
    "contents_url": "https://api.github.com/repos/JMRI/JMRI/contents/java/src/jmri/jmrix/sprog/update/SprogVersion.java?ref=6581f7169120c451cec7c0c221e90a158bdd7c72",
    "patch": "@@ -139,6 +139,31 @@ public boolean hasZTCMode() {\n         return (this.sprogType.sprogType < SprogType.NANO);\n     }\n \n+    /**\n+     * Check if the SPROG supports use of CV hints when reading. This means\n+     * SPROG IIv4 or SPROG 3v4 version 4.5 or higher\n+     *\n+     * @return boolean if the current SPROG supports CV hints when reading\n+     */\n+    public boolean supportsCVHints() {\n+        int major = this.getMajorVersion();\n+        int minor = this.getMinorVersion();\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Major: {} Minor: {}\", major, minor);\n+        }\n+        if ((this.sprogType.sprogType == SprogType.SPROGIIv4) && (minor >= 5)\n+                || (this.sprogType.sprogType == SprogType.SPROG3) && (major == 4) && (minor >= 5)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"This version supports CV hints\");\n+            }\n+            return true;\n+        }\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"This version does not support CV hints\");\n+        }\n+        return false;\n+    }\n+\n     /**\n      *\n      * @return String representation of SPROG version"
  },
  {
    "sha": "126ad376338f15d984188f3bd7e6258f8247ce9c",
    "filename": "java/src/jmri/jmrix/sprog/update/SprogVersionQuery.java",
    "status": "modified",
    "additions": 0,
    "deletions": 12,
    "changes": 12,
    "blob_url": "https://github.com/JMRI/JMRI/blob/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/jmrix/sprog/update/SprogVersionQuery.java",
    "raw_url": "https://github.com/JMRI/JMRI/raw/6581f7169120c451cec7c0c221e90a158bdd7c72/java/src/jmri/jmrix/sprog/update/SprogVersionQuery.java",
    "contents_url": "https://api.github.com/repos/JMRI/JMRI/contents/java/src/jmri/jmrix/sprog/update/SprogVersionQuery.java?ref=6581f7169120c451cec7c0c221e90a158bdd7c72",
    "patch": "@@ -73,18 +73,6 @@ public synchronized void removeSprogVersionListener(SprogVersionListener l) {\n         return (Vector<SprogVersionListener>) versionListeners.clone();\n     }\n \n-    /**\n-     * Return the SprogVersionQuery instance to use.\n-     *\n-     * @return The registered SprogVersionQuery instance for general use, if\n-     *         need be creating one.\n-     * @deprecated JMRI Since 4.4 instance() shouldn't be used, convert to JMRI multi-system support structure\n-     */\n-    @Deprecated\n-    static public SprogVersionQuery instance() {\n-        return null;\n-    }\n-\n     synchronized public void requestVersion(SprogVersionListener l) {\n         SprogMessage m;\n         if (log.isDebugEnabled()) {"
  }
]
