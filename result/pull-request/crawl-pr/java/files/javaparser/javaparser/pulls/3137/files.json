[
  {
    "sha": "77009b74ff782ab70385e81c42d639969294587e",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
    "status": "modified",
    "additions": 37,
    "deletions": 31,
    "changes": 68,
    "blob_url": "https://github.com/javaparser/javaparser/blob/7bf2256fbb0ed7c66047dd5bd352d01fbb4ded1e/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
    "raw_url": "https://github.com/javaparser/javaparser/raw/7bf2256fbb0ed7c66047dd5bd352d01fbb4ded1e/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
    "contents_url": "https://api.github.com/repos/javaparser/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java?ref=7bf2256fbb0ed7c66047dd5bd352d01fbb4ded1e",
    "patch": "@@ -39,10 +39,7 @@\n import com.github.javaparser.ast.DataKey;\n import com.github.javaparser.ast.Node;\n import com.github.javaparser.ast.NodeList;\n-import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n-import com.github.javaparser.ast.body.EnumDeclaration;\n-import com.github.javaparser.ast.body.TypeDeclaration;\n-import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.body.*;\n import com.github.javaparser.ast.expr.AnnotationExpr;\n import com.github.javaparser.ast.expr.BinaryExpr;\n import com.github.javaparser.ast.expr.Expression;\n@@ -565,14 +562,13 @@ private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n      * @return The first class/interface/enum declaration in the Node's ancestry.\n      */\n     protected TypeDeclaration<?> findContainingTypeDecl(Node node) {\n-        if (node instanceof ClassOrInterfaceDeclaration) {\n-            return (ClassOrInterfaceDeclaration) node;\n-        }\n-        if (node instanceof EnumDeclaration) {\n-            return (EnumDeclaration) node;\n+        Node parent = node;\n+        while (true) {\n+            parent = demandParentNode(parent);\n+            if (parent instanceof TypeDeclaration) {\n+                return (TypeDeclaration<?>) parent;\n+            }\n         }\n-        return findContainingTypeDecl(demandParentNode(node));\n-\n     }\n \n     /**\n@@ -602,35 +598,45 @@ private ResolvedType getTypeConcrete(Node node, boolean solveLambdas) {\n      * the Node's ancestry.\n      */\n     protected Node findContainingTypeDeclOrObjectCreationExpr(Node node) {\n-        if (node instanceof ClassOrInterfaceDeclaration) {\n-            return node;\n-        }\n-        if (node instanceof EnumDeclaration) {\n-            return node;\n-        }\n-        Node parent = demandParentNode(node);\n-        if (parent instanceof ObjectCreationExpr && !((ObjectCreationExpr) parent).getArguments().contains(node)) {\n-            return parent;\n+        Node parent = node;\n+        boolean detachFlag = false;\n+        while (true) {\n+            parent = demandParentNode(parent);\n+            if (parent instanceof BodyDeclaration) {\n+                if (parent instanceof TypeDeclaration) {\n+                    return parent;\n+                } else {\n+                    detachFlag = true;\n+                }\n+            } else if (parent instanceof ObjectCreationExpr) {\n+                if (detachFlag) {\n+                    return parent;\n+                }\n+            }\n         }\n-        return findContainingTypeDeclOrObjectCreationExpr(parent);\n     }\n \n     /**\n      * Where a node has an interface/class/enum declaration -- or an object creation expression in an inner class\n      * references an outer class -- as its ancestor, return the declaration corresponding to the class name specified.\n      */\n     protected Node findContainingTypeDeclOrObjectCreationExpr(Node node, String className) {\n-        if (node instanceof ClassOrInterfaceDeclaration && ((ClassOrInterfaceDeclaration) node).getFullyQualifiedName().get().endsWith(className)) {\n-            return node;\n-        }\n-        if (node instanceof EnumDeclaration) {\n-            return node;\n-        }\n-        Node parent = demandParentNode(node);\n-        if (parent instanceof ObjectCreationExpr && !((ObjectCreationExpr) parent).getArguments().contains(node)) {\n-            return parent;\n+        Node parent = node;\n+        boolean detachFlag = false;\n+        while (true) {\n+            parent = demandParentNode(parent);\n+            if (parent instanceof BodyDeclaration) {\n+                if (parent instanceof TypeDeclaration && ((TypeDeclaration<?>) parent).getFullyQualifiedName().get().endsWith(className)) {\n+                    return parent;\n+                } else {\n+                    detachFlag = true;\n+                }\n+            } else if (parent instanceof ObjectCreationExpr) {\n+                if (detachFlag) {\n+                    return parent;\n+                }\n+            }\n         }\n-        return findContainingTypeDeclOrObjectCreationExpr(parent, className);\n     }\n \n "
  },
  {
    "sha": "68ef2a01dc1037ab0aeff16bbd8d74c59dd26e1d",
    "filename": "javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/Issue3136Test.java",
    "status": "added",
    "additions": 41,
    "deletions": 0,
    "changes": 41,
    "blob_url": "https://github.com/javaparser/javaparser/blob/7bf2256fbb0ed7c66047dd5bd352d01fbb4ded1e/javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/Issue3136Test.java",
    "raw_url": "https://github.com/javaparser/javaparser/raw/7bf2256fbb0ed7c66047dd5bd352d01fbb4ded1e/javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/Issue3136Test.java",
    "contents_url": "https://api.github.com/repos/javaparser/javaparser/contents/javaparser-symbol-solver-testing/src/test/java/com/github/javaparser/symbolsolver/Issue3136Test.java?ref=7bf2256fbb0ed7c66047dd5bd352d01fbb4ded1e",
    "patch": "@@ -0,0 +1,41 @@\n+package com.github.javaparser.symbolsolver;\n+\n+import com.github.javaparser.ParserConfiguration;\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.symbolsolver.resolution.AbstractResolutionTest;\n+import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class Issue3136Test extends AbstractResolutionTest {\n+\n+    @Test\n+    void test() {\n+        ParserConfiguration config = new ParserConfiguration();\n+        config.setSymbolResolver(new JavaSymbolSolver(new ReflectionTypeSolver(false)));\n+        StaticJavaParser.setConfiguration(config);\n+\n+        String s =\n+                \"public class Program {\\n\" +\n+                        \"\\n\" +\n+                        \"    public class InnerClass {\\n\" +\n+                        \"    }\\n\" +\n+                        \"\\n\" +\n+                        \"    {\\n\" +\n+                        \"        this.new InnerClass();\\n\" +\n+                        \"    }\\n\" +\n+                        \"}\";\n+\n+        CompilationUnit cu = StaticJavaParser.parse(s);\n+        List<ThisExpr> exprs = cu.findAll(ThisExpr.class);\n+        exprs.forEach(expr-> {\n+            assertEquals(\"Program\",expr.calculateResolvedType().describe());\n+            assertEquals(\"Program\",expr.resolve().getQualifiedName());\n+        });\n+    }\n+}"
  }
]
