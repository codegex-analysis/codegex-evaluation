[
  {
    "sha": "b50fa26be2f9fad148b1636d41d3012d0623909e",
    "filename": "changelog/@unreleased/pr-690.v2.yml",
    "status": "added",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/palantir/tracing-java/blob/1333a52246a8cfbb1a6230373dd68b885b822b74/changelog/@unreleased/pr-690.v2.yml",
    "raw_url": "https://github.com/palantir/tracing-java/raw/1333a52246a8cfbb1a6230373dd68b885b822b74/changelog/@unreleased/pr-690.v2.yml",
    "contents_url": "https://api.github.com/repos/palantir/tracing-java/contents/changelog/@unreleased/pr-690.v2.yml?ref=1333a52246a8cfbb1a6230373dd68b885b822b74",
    "patch": "@@ -0,0 +1,5 @@\n+type: feature\n+feature:\n+  description: Added a library to propagate traces through gRPC calls.\n+  links:\n+  - https://github.com/palantir/tracing-java/pull/690"
  },
  {
    "sha": "dc8a69d0e9fd2811be68f4001d035860b11a24c0",
    "filename": "readme.md",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/palantir/tracing-java/blob/1333a52246a8cfbb1a6230373dd68b885b822b74/readme.md",
    "raw_url": "https://github.com/palantir/tracing-java/raw/1333a52246a8cfbb1a6230373dd68b885b822b74/readme.md",
    "contents_url": "https://api.github.com/repos/palantir/tracing-java/contents/readme.md?ref=1333a52246a8cfbb1a6230373dd68b885b822b74",
    "patch": "@@ -8,6 +8,7 @@\n \n - **com.palantir.tracing:tracing** - The key `Tracer` class, which stores trace information in a ThreadLocal.  Also includes classes for convenient integration with SLF4J and executor services.\n - **com.palantir.tracing:tracing-api** - constants and pure data objects\n+- **com.palantir.tracing:tracing-grpc** - `TracingClientInterceptor`, which adds appropriate headers to outgoing gRPC requests and `TracingServerInterceptor`, which reads headers from incoming gRPC requests.\n - **com.palantir.tracing:tracing-jaxrs** - utilities to wrap `StreamingOutput` responses with a new trace.\n - **com.palantir.tracing:tracing-okhttp3** - `OkhttpTraceInterceptor`, which adds the appropriate headers to outgoing requests.\n - **com.palantir.tracing:tracing-jersey** - `TraceEnrichingFilter`, a jaxrs filter which reads headers from incoming requests and writes headers to outgoing responses.  A traceId is stored in the jaxrs request context under the key `com.palantir.tracing.traceId`."
  },
  {
    "sha": "329f44d92b33eea4886b1e1137647e7bb6fd9300",
    "filename": "settings.gradle",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/palantir/tracing-java/blob/1333a52246a8cfbb1a6230373dd68b885b822b74/settings.gradle",
    "raw_url": "https://github.com/palantir/tracing-java/raw/1333a52246a8cfbb1a6230373dd68b885b822b74/settings.gradle",
    "contents_url": "https://api.github.com/repos/palantir/tracing-java/contents/settings.gradle?ref=1333a52246a8cfbb1a6230373dd68b885b822b74",
    "patch": "@@ -4,6 +4,7 @@ include 'tracing'\n include 'tracing-api'\n include 'tracing-benchmarks'\n include 'tracing-demos'\n+include 'tracing-grpc'\n include 'tracing-jaxrs'\n include 'tracing-jersey'\n include 'tracing-okhttp3'"
  },
  {
    "sha": "4aa025e815d038c8d87a66d8f76b12a51ce72e26",
    "filename": "tracing-grpc/build.gradle",
    "status": "added",
    "additions": 42,
    "deletions": 0,
    "changes": 42,
    "blob_url": "https://github.com/palantir/tracing-java/blob/1333a52246a8cfbb1a6230373dd68b885b822b74/tracing-grpc/build.gradle",
    "raw_url": "https://github.com/palantir/tracing-java/raw/1333a52246a8cfbb1a6230373dd68b885b822b74/tracing-grpc/build.gradle",
    "contents_url": "https://api.github.com/repos/palantir/tracing-java/contents/tracing-grpc/build.gradle?ref=1333a52246a8cfbb1a6230373dd68b885b822b74",
    "patch": "@@ -0,0 +1,42 @@\n+/*\n+ * (c) Copyright 2021 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+apply from: \"${rootDir}/gradle/publish-jar.gradle\"\n+apply plugin: 'com.palantir.revapi'\n+\n+dependencies {\n+    api project(':tracing')\n+    api('io.grpc:grpc-api') {\n+        // gRPC pulls in the android version of guava, which we don't want\n+        exclude group: 'com.google.guava', module: 'guava'\n+    }\n+\n+    implementation project(':tracing-api')\n+\n+    testImplementation 'junit:junit'\n+    testImplementation 'org.assertj:assertj-core'\n+    testImplementation 'org.mockito:mockito-core'\n+\n+    testImplementation('io.grpc:grpc-testing') {\n+        exclude group: 'com.google.guava', module: 'guava'\n+    }\n+    testImplementation('io.grpc:grpc-testing-proto') {\n+        exclude group: 'com.google.guava', module: 'guava'\n+    }\n+\n+    compileOnly \"org.immutables:value::annotations\"\n+    testCompileOnly \"org.immutables:value::annotations\"\n+}"
  },
  {
    "sha": "7458a2cdc5f9c0dc4be0f1f9cdfde9401ef9d033",
    "filename": "tracing-grpc/src/main/java/com/palantir/tracing/grpc/GrpcTracing.java",
    "status": "added",
    "additions": 36,
    "deletions": 0,
    "changes": 36,
    "blob_url": "https://github.com/palantir/tracing-java/blob/1333a52246a8cfbb1a6230373dd68b885b822b74/tracing-grpc/src/main/java/com/palantir/tracing/grpc/GrpcTracing.java",
    "raw_url": "https://github.com/palantir/tracing-java/raw/1333a52246a8cfbb1a6230373dd68b885b822b74/tracing-grpc/src/main/java/com/palantir/tracing/grpc/GrpcTracing.java",
    "contents_url": "https://api.github.com/repos/palantir/tracing-java/contents/tracing-grpc/src/main/java/com/palantir/tracing/grpc/GrpcTracing.java?ref=1333a52246a8cfbb1a6230373dd68b885b822b74",
    "patch": "@@ -0,0 +1,36 @@\n+/*\n+ * (c) Copyright 2021 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.tracing.grpc;\n+\n+import com.palantir.tracing.api.TraceHttpHeaders;\n+import io.grpc.Metadata;\n+\n+/**\n+ * Internal utility class used to deduplicate logic between the client and server interceptors.\n+ *\n+ * Intentionally package-private.\n+ */\n+final class GrpcTracing {\n+    static final Metadata.Key<String> TRACE_ID =\n+            Metadata.Key.of(TraceHttpHeaders.TRACE_ID, Metadata.ASCII_STRING_MARSHALLER);\n+    static final Metadata.Key<String> SPAN_ID =\n+            Metadata.Key.of(TraceHttpHeaders.SPAN_ID, Metadata.ASCII_STRING_MARSHALLER);\n+    static final Metadata.Key<String> IS_SAMPLED =\n+            Metadata.Key.of(TraceHttpHeaders.IS_SAMPLED, Metadata.ASCII_STRING_MARSHALLER);\n+\n+    private GrpcTracing() {}\n+}"
  },
  {
    "sha": "3b510e8d91af64138aff83afd8aafeb83f8ddade",
    "filename": "tracing-grpc/src/main/java/com/palantir/tracing/grpc/TracingClientInterceptor.java",
    "status": "added",
    "additions": 116,
    "deletions": 0,
    "changes": 116,
    "blob_url": "https://github.com/palantir/tracing-java/blob/1333a52246a8cfbb1a6230373dd68b885b822b74/tracing-grpc/src/main/java/com/palantir/tracing/grpc/TracingClientInterceptor.java",
    "raw_url": "https://github.com/palantir/tracing-java/raw/1333a52246a8cfbb1a6230373dd68b885b822b74/tracing-grpc/src/main/java/com/palantir/tracing/grpc/TracingClientInterceptor.java",
    "contents_url": "https://api.github.com/repos/palantir/tracing-java/contents/tracing-grpc/src/main/java/com/palantir/tracing/grpc/TracingClientInterceptor.java?ref=1333a52246a8cfbb1a6230373dd68b885b822b74",
    "patch": "@@ -0,0 +1,116 @@\n+/*\n+ * (c) Copyright 2021 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.tracing.grpc;\n+\n+import com.palantir.tracing.CloseableSpan;\n+import com.palantir.tracing.DetachedSpan;\n+import com.palantir.tracing.Observability;\n+import com.palantir.tracing.TraceMetadata;\n+import com.palantir.tracing.Tracer;\n+import com.palantir.tracing.Tracers;\n+import com.palantir.tracing.api.SpanType;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import java.util.Optional;\n+\n+/**\n+ * A {@link ClientInterceptor} which propagates Zipkin trace information through gRPC calls.\n+ */\n+public final class TracingClientInterceptor implements ClientInterceptor {\n+    @Override\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(\n+            MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {\n+        return new TracingClientCall<>(\n+                next.newCall(method, callOptions), method, Tracer.maybeGetTraceMetadata(), Tracer.isTraceObservable());\n+    }\n+\n+    private static final class TracingClientCall<ReqT, RespT>\n+            extends ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT> {\n+        private final MethodDescriptor<ReqT, RespT> method;\n+        private final Optional<TraceMetadata> metadata;\n+        private final boolean isTraceObservable;\n+\n+        TracingClientCall(\n+                ClientCall<ReqT, RespT> delegate,\n+                MethodDescriptor<ReqT, RespT> method,\n+                Optional<TraceMetadata> metadata,\n+                boolean isTraceObservable) {\n+            super(delegate);\n+            this.method = method;\n+            this.metadata = metadata;\n+            this.isTraceObservable = isTraceObservable;\n+        }\n+\n+        @Override\n+        public void start(Listener<RespT> responseListener, Metadata headers) {\n+            DetachedSpan span = detachedSpan();\n+\n+            // the only way to get at the metadata of a detached span is to make an attached child :(\n+            try (CloseableSpan propagationSpan = span.childSpan(\"grpc: start\", SpanType.CLIENT_OUTGOING)) {\n+                TraceMetadata propagationMetadata =\n+                        Tracer.maybeGetTraceMetadata().get();\n+                headers.put(GrpcTracing.TRACE_ID, propagationMetadata.getTraceId());\n+                headers.put(GrpcTracing.SPAN_ID, propagationMetadata.getSpanId());\n+                headers.put(GrpcTracing.IS_SAMPLED, Tracer.isTraceObservable() ? \"1\" : \"0\");\n+            }\n+\n+            super.start(new TracingClientCallListener<>(responseListener, span), headers);\n+        }\n+\n+        private DetachedSpan detachedSpan() {\n+            return DetachedSpan.start(\n+                    getObservability(),\n+                    metadata.isPresent() ? metadata.get().getTraceId() : Tracers.randomId(),\n+                    metadata.map(TraceMetadata::getSpanId),\n+                    method.getFullMethodName(),\n+                    SpanType.LOCAL);\n+        }\n+\n+        private Observability getObservability() {\n+            if (!metadata.isPresent()) {\n+                return Observability.UNDECIDED;\n+            } else if (isTraceObservable) {\n+                return Observability.SAMPLE;\n+            } else {\n+                return Observability.DO_NOT_SAMPLE;\n+            }\n+        }\n+    }\n+\n+    private static final class TracingClientCallListener<RespT>\n+            extends ForwardingClientCallListener.SimpleForwardingClientCallListener<RespT> {\n+        private final DetachedSpan span;\n+\n+        TracingClientCallListener(ClientCall.Listener<RespT> delegate, DetachedSpan span) {\n+            super(delegate);\n+            this.span = span;\n+        }\n+\n+        @Override\n+        public void onClose(Status status, Metadata trailers) {\n+            span.complete();\n+            super.onClose(status, trailers);\n+        }\n+    }\n+}"
  },
  {
    "sha": "a6400c1df81f787635df4e025413ab7ce9e6aae1",
    "filename": "tracing-grpc/src/main/java/com/palantir/tracing/grpc/TracingServerInterceptor.java",
    "status": "added",
    "additions": 153,
    "deletions": 0,
    "changes": 153,
    "blob_url": "https://github.com/palantir/tracing-java/blob/1333a52246a8cfbb1a6230373dd68b885b822b74/tracing-grpc/src/main/java/com/palantir/tracing/grpc/TracingServerInterceptor.java",
    "raw_url": "https://github.com/palantir/tracing-java/raw/1333a52246a8cfbb1a6230373dd68b885b822b74/tracing-grpc/src/main/java/com/palantir/tracing/grpc/TracingServerInterceptor.java",
    "contents_url": "https://api.github.com/repos/palantir/tracing-java/contents/tracing-grpc/src/main/java/com/palantir/tracing/grpc/TracingServerInterceptor.java?ref=1333a52246a8cfbb1a6230373dd68b885b822b74",
    "patch": "@@ -0,0 +1,153 @@\n+/*\n+ * (c) Copyright 2021 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.tracing.grpc;\n+\n+import com.google.common.base.Strings;\n+import com.palantir.tracing.CloseableSpan;\n+import com.palantir.tracing.DetachedSpan;\n+import com.palantir.tracing.Observability;\n+import com.palantir.tracing.Tracers;\n+import com.palantir.tracing.api.SpanType;\n+import io.grpc.ForwardingServerCall;\n+import io.grpc.ForwardingServerCallListener;\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+import io.grpc.ServerCall.Listener;\n+import io.grpc.ServerCallHandler;\n+import io.grpc.ServerInterceptor;\n+import io.grpc.Status;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A {@link ServerInterceptor} which extracts Zipkin trace data propagated from the gRPC client and wraps the\n+ * execution of the request in spans.\n+ *\n+ * <p>Depending on the style of gRPC request, the actual server handler code will run in the\n+ * {@link #interceptCall(ServerCall, Metadata, ServerCallHandler)} method of the {@link TracingServerInterceptor}, or\n+ * in the {@link TracingServerCallListener#onHalfClose()} method of the {@link TracingServerCallListener}. Certain\n+ * user callbacks can also be invoked in other {@link TracingServerCallListener} methods, so they are all spanned.\n+ *\n+ * <p>The request is considered completed when the {@link ServerCall#close(Status, Metadata)} method is invoked.\n+ * Since the ordering of a close call and certain terminal {@link ServerCall.Listener} callbacks are not specified,\n+ * there's some extra logic to try to avoid creating child spans after the root span has already been completed.\n+ */\n+public final class TracingServerInterceptor implements ServerInterceptor {\n+    @Override\n+    public <ReqT, RespT> Listener<ReqT> interceptCall(\n+            ServerCall<ReqT, RespT> call, Metadata headers, ServerCallHandler<ReqT, RespT> next) {\n+        String maybeTraceId = headers.get(GrpcTracing.TRACE_ID);\n+        boolean newTraceId = maybeTraceId == null;\n+        String traceId = newTraceId ? Tracers.randomId() : maybeTraceId;\n+\n+        DetachedSpan span = detachedSpan(newTraceId, traceId, call, headers);\n+        AtomicReference<DetachedSpan> spanRef = new AtomicReference<>(span);\n+\n+        try (CloseableSpan guard = span.childSpan(\"grpc: interceptCall\")) {\n+            return new TracingServerCallListener<>(\n+                    next.startCall(new TracingServerCall<>(call, spanRef), headers), spanRef);\n+        }\n+    }\n+\n+    private DetachedSpan detachedSpan(boolean newTrace, String traceId, ServerCall<?, ?> call, Metadata headers) {\n+        return DetachedSpan.start(\n+                getObservabilityFromHeader(headers),\n+                traceId,\n+                newTrace ? Optional.empty() : Optional.ofNullable(headers.get(GrpcTracing.SPAN_ID)),\n+                call.getMethodDescriptor().getFullMethodName(),\n+                SpanType.SERVER_INCOMING);\n+    }\n+\n+    private Observability getObservabilityFromHeader(Metadata headers) {\n+        String header = headers.get(GrpcTracing.IS_SAMPLED);\n+        if (Strings.isNullOrEmpty(header)) {\n+            return Observability.UNDECIDED;\n+        } else {\n+            return \"1\".equals(header) ? Observability.SAMPLE : Observability.DO_NOT_SAMPLE;\n+        }\n+    }\n+\n+    private static final class TracingServerCall<ReqT, RespT>\n+            extends ForwardingServerCall.SimpleForwardingServerCall<ReqT, RespT> {\n+        private final AtomicReference<DetachedSpan> span;\n+\n+        TracingServerCall(ServerCall<ReqT, RespT> delegate, AtomicReference<DetachedSpan> span) {\n+            super(delegate);\n+            this.span = span;\n+        }\n+\n+        @Override\n+        public void close(Status status, Metadata trailers) {\n+            DetachedSpan maybeSpan = span.getAndSet(null);\n+            if (maybeSpan != null) {\n+                maybeSpan.complete();\n+            }\n+            super.close(status, trailers);\n+        }\n+    }\n+\n+    private static final class TracingServerCallListener<ReqT>\n+            extends ForwardingServerCallListener.SimpleForwardingServerCallListener<ReqT> {\n+        private final AtomicReference<DetachedSpan> span;\n+\n+        TracingServerCallListener(Listener<ReqT> delegate, AtomicReference<DetachedSpan> span) {\n+            super(delegate);\n+            this.span = span;\n+        }\n+\n+        @Override\n+        public void onMessage(ReqT message) {\n+            maybeSpanned(\"grpc: onMessage\", () -> super.onMessage(message));\n+        }\n+\n+        @Override\n+        public void onHalfClose() {\n+            maybeSpanned(\"grpc: onHalfClose\", super::onHalfClose);\n+        }\n+\n+        @Override\n+        public void onCancel() {\n+            maybeSpanned(\"grpc: onCancel\", super::onCancel);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            maybeSpanned(\"grpc: onComplete\", super::onComplete);\n+        }\n+\n+        @Override\n+        public void onReady() {\n+            maybeSpanned(\"grpc: onReady\", super::onReady);\n+        }\n+\n+        /**\n+         * Wraps a callback in a span if the root span has not already been closed. The gRPC glue can call listener\n+         * methods after the ServerCall has already been closed in some cases, and we want to avoid log spam from the\n+         * tracing internals warning about making a child off a completed span.\n+         */\n+        private void maybeSpanned(String spanName, Runnable runnable) {\n+            DetachedSpan maybeSpan = span.get();\n+            if (maybeSpan == null) {\n+                runnable.run();\n+            } else {\n+                try (CloseableSpan guard = maybeSpan.childSpan(spanName)) {\n+                    runnable.run();\n+                }\n+            }\n+        }\n+    }\n+}"
  },
  {
    "sha": "c34c6e4cad492c6276f47049fef4725d30cc0eb9",
    "filename": "tracing-grpc/src/test/java/com/palantir/tracing/grpc/TracingClientInterceptorTest.java",
    "status": "added",
    "additions": 134,
    "deletions": 0,
    "changes": 134,
    "blob_url": "https://github.com/palantir/tracing-java/blob/1333a52246a8cfbb1a6230373dd68b885b822b74/tracing-grpc/src/test/java/com/palantir/tracing/grpc/TracingClientInterceptorTest.java",
    "raw_url": "https://github.com/palantir/tracing-java/raw/1333a52246a8cfbb1a6230373dd68b885b822b74/tracing-grpc/src/test/java/com/palantir/tracing/grpc/TracingClientInterceptorTest.java",
    "contents_url": "https://api.github.com/repos/palantir/tracing-java/contents/tracing-grpc/src/test/java/com/palantir/tracing/grpc/TracingClientInterceptorTest.java?ref=1333a52246a8cfbb1a6230373dd68b885b822b74",
    "patch": "@@ -0,0 +1,134 @@\n+/*\n+ * (c) Copyright 2021 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.tracing.grpc;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import com.palantir.tracing.Observability;\n+import com.palantir.tracing.TraceSampler;\n+import com.palantir.tracing.Tracer;\n+import com.palantir.tracing.api.SpanType;\n+import io.grpc.ClientInterceptors;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+import io.grpc.ServerCall.Listener;\n+import io.grpc.ServerCallHandler;\n+import io.grpc.ServerInterceptor;\n+import io.grpc.ServerInterceptors;\n+import io.grpc.inprocess.InProcessChannelBuilder;\n+import io.grpc.inprocess.InProcessServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class TracingClientInterceptorTest {\n+    private static final SimpleServiceGrpc.SimpleServiceImplBase SERVICE =\n+            new SimpleServiceGrpc.SimpleServiceImplBase() {\n+                @Override\n+                public void unaryRpc(SimpleRequest _request, StreamObserver<SimpleResponse> responseObserver) {\n+                    responseObserver.onNext(SimpleResponse.newBuilder().build());\n+                    responseObserver.onCompleted();\n+                }\n+            };\n+\n+    @Rule\n+    public final GrpcCleanupRule grpcCleanup = new GrpcCleanupRule();\n+\n+    @Captor\n+    private ArgumentCaptor<Metadata> metadataCaptor;\n+\n+    @Mock\n+    private TraceSampler traceSampler;\n+\n+    private final ServerInterceptor mockServerInterceptor =\n+            mock(ServerInterceptor.class, delegatesTo(new ServerInterceptor() {\n+                @Override\n+                public <ReqT, RespT> Listener<ReqT> interceptCall(\n+                        ServerCall<ReqT, RespT> call, Metadata headers, ServerCallHandler<ReqT, RespT> next) {\n+                    return next.startCall(call, headers);\n+                }\n+            }));\n+\n+    private SimpleServiceGrpc.SimpleServiceBlockingStub blockingStub;\n+\n+    @Before\n+    public void before() throws Exception {\n+        Tracer.setSampler(traceSampler);\n+\n+        when(traceSampler.sample()).thenReturn(true);\n+\n+        String serverName = InProcessServerBuilder.generateName();\n+        grpcCleanup.register(InProcessServerBuilder.forName(serverName)\n+                .addService(ServerInterceptors.intercept(SERVICE, mockServerInterceptor))\n+                .build()\n+                .start());\n+        ManagedChannel channel =\n+                grpcCleanup.register(InProcessChannelBuilder.forName(serverName).build());\n+        blockingStub = SimpleServiceGrpc.newBlockingStub(\n+                ClientInterceptors.intercept(channel, new TracingClientInterceptor()));\n+    }\n+\n+    @Test\n+    public void traceIsPropagated_whenNoTraceIsPresent() {\n+        Tracer.getAndClearTrace();\n+        blockingStub.unaryRpc(SimpleRequest.newBuilder().build());\n+\n+        verify(mockServerInterceptor).interceptCall(any(), metadataCaptor.capture(), any());\n+        verifyNoMoreInteractions(mockServerInterceptor);\n+\n+        Metadata intercepted = metadataCaptor.getValue();\n+        assertThat(intercepted.getAll(GrpcTracing.TRACE_ID)).hasSize(1);\n+        assertThat(intercepted.getAll(GrpcTracing.SPAN_ID)).hasSize(1);\n+        assertThat(intercepted.getAll(GrpcTracing.IS_SAMPLED)).hasSize(1);\n+    }\n+\n+    @Test\n+    public void traceIsPropagated_whenTraceIsPresent() {\n+        Tracer.initTraceWithSpan(Observability.SAMPLE, \"id\", \"operation\", SpanType.LOCAL);\n+        try {\n+            blockingStub.unaryRpc(SimpleRequest.newBuilder().build());\n+        } finally {\n+            Tracer.fastCompleteSpan();\n+        }\n+\n+        verify(mockServerInterceptor).interceptCall(any(), metadataCaptor.capture(), any());\n+        verifyNoMoreInteractions(mockServerInterceptor);\n+\n+        Metadata intercepted = metadataCaptor.getValue();\n+        assertThat(intercepted.getAll(GrpcTracing.TRACE_ID)).containsExactly(\"id\");\n+        assertThat(intercepted.getAll(GrpcTracing.SPAN_ID)).hasSize(1);\n+        assertThat(intercepted.getAll(GrpcTracing.IS_SAMPLED)).containsExactly(\"1\");\n+    }\n+}"
  },
  {
    "sha": "577eb88b34879f0ead0d57a975a3ee8a79a2c728",
    "filename": "tracing-grpc/src/test/java/com/palantir/tracing/grpc/TracingServerInterceptorTest.java",
    "status": "added",
    "additions": 208,
    "deletions": 0,
    "changes": 208,
    "blob_url": "https://github.com/palantir/tracing-java/blob/1333a52246a8cfbb1a6230373dd68b885b822b74/tracing-grpc/src/test/java/com/palantir/tracing/grpc/TracingServerInterceptorTest.java",
    "raw_url": "https://github.com/palantir/tracing-java/raw/1333a52246a8cfbb1a6230373dd68b885b822b74/tracing-grpc/src/test/java/com/palantir/tracing/grpc/TracingServerInterceptorTest.java",
    "contents_url": "https://api.github.com/repos/palantir/tracing-java/contents/tracing-grpc/src/test/java/com/palantir/tracing/grpc/TracingServerInterceptorTest.java?ref=1333a52246a8cfbb1a6230373dd68b885b822b74",
    "patch": "@@ -0,0 +1,208 @@\n+/*\n+ * (c) Copyright 2021 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.tracing.grpc;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import com.palantir.tracing.TraceSampler;\n+import com.palantir.tracing.Tracer;\n+import com.palantir.tracing.api.Span;\n+import com.palantir.tracing.api.SpanObserver;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ClientInterceptors;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.ServerInterceptors;\n+import io.grpc.inprocess.InProcessChannelBuilder;\n+import io.grpc.inprocess.InProcessServerBuilder;\n+import io.grpc.internal.testing.StreamRecorder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import java.util.List;\n+import java.util.Optional;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class TracingServerInterceptorTest {\n+    private static final SimpleServiceGrpc.SimpleServiceImplBase SERVICE =\n+            new SimpleServiceGrpc.SimpleServiceImplBase() {\n+                @Override\n+                public void unaryRpc(SimpleRequest _request, StreamObserver<SimpleResponse> responseObserver) {\n+                    Tracer.fastStartSpan(\"handler\");\n+                    Tracer.fastCompleteSpan();\n+                    responseObserver.onNext(SimpleResponse.newBuilder().build());\n+                    responseObserver.onCompleted();\n+                }\n+\n+                @Override\n+                public StreamObserver<SimpleRequest> clientStreamingRpc(\n+                        StreamObserver<SimpleResponse> responseObserver) {\n+                    Tracer.fastStartSpan(\"handler\");\n+                    Tracer.fastCompleteSpan();\n+\n+                    return new StreamObserver<SimpleRequest>() {\n+                        @Override\n+                        public void onNext(SimpleRequest _value) {\n+                            Tracer.fastStartSpan(\"observer\");\n+                            Tracer.fastCompleteSpan();\n+                        }\n+\n+                        @Override\n+                        public void onError(Throwable _throwable) {}\n+\n+                        @Override\n+                        public void onCompleted() {\n+                            responseObserver.onNext(SimpleResponse.newBuilder().build());\n+                            responseObserver.onCompleted();\n+                        }\n+                    };\n+                }\n+            };\n+\n+    @Rule\n+    public final GrpcCleanupRule grpcCleanup = new GrpcCleanupRule();\n+\n+    @Mock\n+    private TraceSampler traceSampler;\n+\n+    @Mock\n+    private SpanObserver spanObserver;\n+\n+    @Captor\n+    private ArgumentCaptor<Span> spanCaptor;\n+\n+    private ManagedChannel channel;\n+\n+    @Before\n+    public void before() throws Exception {\n+        Tracer.subscribe(\"\", spanObserver);\n+        Tracer.setSampler(traceSampler);\n+\n+        String serverName = InProcessServerBuilder.generateName();\n+        grpcCleanup.register(InProcessServerBuilder.forName(serverName)\n+                .addService(ServerInterceptors.intercept(SERVICE, new TracingServerInterceptor()))\n+                .build()\n+                .start());\n+        channel =\n+                grpcCleanup.register(InProcessChannelBuilder.forName(serverName).build());\n+\n+        when(traceSampler.sample()).thenReturn(true);\n+    }\n+\n+    @After\n+    public void after() {\n+        Tracer.unsubscribe(\"\");\n+    }\n+\n+    @Test\n+    public void whenNoTraceIsInHeader_generatesNewTrace() {\n+        SimpleServiceGrpc.SimpleServiceBlockingStub blockingStub = SimpleServiceGrpc.newBlockingStub(channel);\n+\n+        blockingStub.unaryRpc(SimpleRequest.newBuilder().build());\n+\n+        verify(traceSampler).sample();\n+        verifyNoMoreInteractions(traceSampler);\n+\n+        verify(spanObserver, atLeastOnce()).consume(spanCaptor.capture());\n+        List<Span> spans = spanCaptor.getAllValues();\n+        assertThat(spans).map(Span::getTraceId).containsOnly(spans.get(0).getTraceId());\n+    }\n+\n+    @Test\n+    public void whenTraceIsInHeader_usesGivenTraceId() {\n+        SimpleServiceGrpc.SimpleServiceBlockingStub blockingStub =\n+                SimpleServiceGrpc.newBlockingStub(ClientInterceptors.intercept(channel, new ClientInterceptor() {\n+                    @Override\n+                    public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(\n+                            MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {\n+                        return new ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT>(\n+                                next.newCall(method, callOptions)) {\n+                            @Override\n+                            public void start(ClientCall.Listener<RespT> responseListener, Metadata headers) {\n+                                headers.put(GrpcTracing.TRACE_ID, \"traceId\");\n+                                headers.put(GrpcTracing.SPAN_ID, \"spanId\");\n+                                headers.put(GrpcTracing.IS_SAMPLED, \"1\");\n+                                super.start(responseListener, headers);\n+                            }\n+                        };\n+                    }\n+                }));\n+\n+        blockingStub.unaryRpc(SimpleRequest.newBuilder().build());\n+\n+        verifyNoInteractions(traceSampler);\n+\n+        verify(spanObserver, atLeastOnce()).consume(spanCaptor.capture());\n+        List<Span> spans = spanCaptor.getAllValues();\n+        assertThat(spans).map(Span::getTraceId).containsOnly(\"traceId\");\n+        assertThat(spans).map(Span::getParentSpanId).contains(Optional.of(\"spanId\"));\n+    }\n+\n+    @Test\n+    public void unaryCallHandlerIsSpanned() {\n+        SimpleServiceGrpc.SimpleServiceBlockingStub blockingStub = SimpleServiceGrpc.newBlockingStub(channel);\n+\n+        blockingStub.unaryRpc(SimpleRequest.newBuilder().build());\n+\n+        verify(traceSampler).sample();\n+        verifyNoMoreInteractions(traceSampler);\n+\n+        verify(spanObserver, atLeastOnce()).consume(spanCaptor.capture());\n+        List<Span> spans = spanCaptor.getAllValues();\n+        assertThat(spans).map(Span::getOperation).contains(\"handler\");\n+    }\n+\n+    @Test\n+    public void serverStreamObserverIsSpanned() throws Exception {\n+        SimpleServiceGrpc.SimpleServiceStub stub = SimpleServiceGrpc.newStub(channel);\n+\n+        StreamRecorder<SimpleResponse> responseObserver = StreamRecorder.create();\n+        StreamObserver<SimpleRequest> requestObserver = stub.clientStreamingRpc(responseObserver);\n+        requestObserver.onNext(SimpleRequest.newBuilder().build());\n+        requestObserver.onCompleted();\n+        responseObserver.awaitCompletion();\n+\n+        verify(traceSampler).sample();\n+        verifyNoMoreInteractions(traceSampler);\n+\n+        verify(spanObserver, atLeastOnce()).consume(spanCaptor.capture());\n+        List<Span> spans = spanCaptor.getAllValues();\n+        assertThat(spans).map(Span::getOperation).contains(\"handler\", \"observer\");\n+        assertThat(spans).map(Span::getTraceId).containsOnly(spans.get(0).getTraceId());\n+    }\n+}"
  },
  {
    "sha": "a82dce44ed642919e4bd8ad3ee1f15e5e49aa343",
    "filename": "versions.lock",
    "status": "modified",
    "additions": 18,
    "deletions": 3,
    "changes": 21,
    "blob_url": "https://github.com/palantir/tracing-java/blob/1333a52246a8cfbb1a6230373dd68b885b822b74/versions.lock",
    "raw_url": "https://github.com/palantir/tracing-java/raw/1333a52246a8cfbb1a6230373dd68b885b822b74/versions.lock",
    "contents_url": "https://api.github.com/repos/palantir/tracing-java/contents/versions.lock?ref=1333a52246a8cfbb1a6230373dd68b885b822b74",
    "patch": "@@ -4,8 +4,8 @@ com.fasterxml.jackson.core:jackson-core:2.10.4 (16 constraints: fe3a68dc)\n com.fasterxml.jackson.core:jackson-databind:2.10.4 (22 constraints: 19998e7a)\n com.fasterxml.jackson.datatype:jackson-datatype-jdk8:2.10.4 (3 constraints: 4130b135)\n com.fasterxml.jackson.module:jackson-module-afterburner:2.10.4 (3 constraints: 4130b135)\n-com.google.code.findbugs:jsr305:3.0.2 (16 constraints: 50e8dc30)\n-com.google.errorprone:error_prone_annotations:2.3.4 (3 constraints: 1b2b3ae9)\n+com.google.code.findbugs:jsr305:3.0.2 (22 constraints: 011f6dfc)\n+com.google.errorprone:error_prone_annotations:2.4.0 (9 constraints: c361e74c)\n com.google.guava:failureaccess:1.0.1 (1 constraints: 140ae1b4)\n com.google.guava:guava:28.2-jre (6 constraints: 5c5ba522)\n com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava (1 constraints: bd17c918)\n@@ -14,6 +14,8 @@ com.palantir.safe-logging:preconditions:1.8.2 (2 constraints: 3c19cfb5)\n com.palantir.safe-logging:safe-logging:1.8.2 (3 constraints: 422aeb21)\n com.squareup.okhttp3:okhttp:3.9.0 (1 constraints: 0e051536)\n com.squareup.okio:okio:1.13.0 (1 constraints: 7f0cb509)\n+io.grpc:grpc-api:1.35.0 (5 constraints: b32bd923)\n+io.grpc:grpc-context:1.35.0 (2 constraints: 6311050a)\n io.undertow:undertow-core:2.0.17.Final (1 constraints: 54072861)\n jakarta.annotation:jakarta.annotation-api:1.3.5 (4 constraints: c93b8593)\n jakarta.servlet:jakarta.servlet-api:4.0.4 (9 constraints: e4866913)\n@@ -22,6 +24,7 @@ jakarta.ws.rs:jakarta.ws.rs-api:2.1.6 (11 constraints: 21bc0ae5)\n net.sf.jopt-simple:jopt-simple:4.6 (1 constraints: 610a91b7)\n org.apache.commons:commons-math3:3.2 (1 constraints: 5c0a8ab7)\n org.checkerframework:checker-qual:3.4.0 (2 constraints: 411a465e)\n+org.codehaus.mojo:animal-sniffer-annotations:1.19 (6 constraints: b3359899)\n org.glassfish.hk2:osgi-resource-locator:1.0.3 (2 constraints: 7d23b265)\n org.glassfish.hk2.external:jakarta.inject:2.6.1 (11 constraints: 6ab14a97)\n org.glassfish.jersey.core:jersey-client:2.31 (4 constraints: 78509cb2)\n@@ -51,7 +54,11 @@ com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider:2.10.4 (2 constraints: 1\n com.fasterxml.jackson.module:jackson-module-jaxb-annotations:2.10.4 (1 constraints: 76175d3d)\n com.fasterxml.jackson.module:jackson-module-parameter-names:2.10.4 (1 constraints: b10e595e)\n com.github.ben-manes.caffeine:caffeine:2.8.4 (4 constraints: 633c8aa1)\n+com.google.android:annotations:4.1.1.4 (1 constraints: 6e08d68b)\n+com.google.api.grpc:proto-google-common-protos:2.0.1 (1 constraints: d109cda9)\n com.google.code.findbugs:annotations:3.0.1 (1 constraints: 9e0aafc3)\n+com.google.code.gson:gson:2.8.6 (1 constraints: 16083e7b)\n+com.google.protobuf:protobuf-java:3.12.0 (1 constraints: 040adeb3)\n com.helger:profiler:1.1.1 (1 constraints: e21053b8)\n com.palantir.conjure.java.runtime:conjure-java-jackson-serialization:4.19.0 (1 constraints: 4005563b)\n com.palantir.safe-logging:preconditions-assertj:1.8.2 (1 constraints: 0d050a36)\n@@ -80,12 +87,20 @@ io.dropwizard.metrics:metrics-json:4.1.9 (1 constraints: ed106ab8)\n io.dropwizard.metrics:metrics-jvm:4.1.9 (2 constraints: 341ee147)\n io.dropwizard.metrics:metrics-logback:4.1.9 (1 constraints: 860ee64f)\n io.dropwizard.metrics:metrics-servlets:4.1.9 (1 constraints: 480d411f)\n+io.grpc:grpc-core:1.35.0 (1 constraints: 940908a7)\n+io.grpc:grpc-protobuf:1.35.0 (1 constraints: f50b14f5)\n+io.grpc:grpc-protobuf-lite:1.35.0 (1 constraints: 070ae3b3)\n+io.grpc:grpc-stub:1.35.0 (2 constraints: 8815e6f4)\n+io.grpc:grpc-testing:1.35.0 (1 constraints: 3b05403b)\n+io.grpc:grpc-testing-proto:1.35.0 (1 constraints: 3b05403b)\n+io.opencensus:opencensus-api:0.28.0 (1 constraints: 950907a7)\n+io.perfmark:perfmark-api:0.23.0 (1 constraints: 3b085f83)\n io.zipkin.java:zipkin:1.13.1 (1 constraints: 3805333b)\n jakarta.activation:jakarta.activation-api:1.2.2 (3 constraints: 4d37e9b5)\n jakarta.xml.bind:jakarta.xml.bind-api:2.3.3 (2 constraints: c6277400)\n javax.servlet:javax.servlet-api:3.1.0 (1 constraints: 830dcc28)\n joda-time:joda-time:2.10.6 (2 constraints: 622437b1)\n-junit:junit:4.13.2 (4 constraints: b052e308)\n+junit:junit:4.13.2 (5 constraints: e35b87b2)\n net.bytebuddy:byte-buddy:1.10.20 (1 constraints: 6e0ba2e9)\n net.bytebuddy:byte-buddy-agent:1.10.20 (1 constraints: 6e0ba2e9)\n net.jcip:jcip-annotations:1.0 (1 constraints: 560ff165)"
  },
  {
    "sha": "2f8c403cc8d8f6b3d0531020521c6d5c7bc43261",
    "filename": "versions.props",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/palantir/tracing-java/blob/1333a52246a8cfbb1a6230373dd68b885b822b74/versions.props",
    "raw_url": "https://github.com/palantir/tracing-java/raw/1333a52246a8cfbb1a6230373dd68b885b822b74/versions.props",
    "contents_url": "https://api.github.com/repos/palantir/tracing-java/contents/versions.props?ref=1333a52246a8cfbb1a6230373dd68b885b822b74",
    "patch": "@@ -8,6 +8,7 @@ com.palantir.safe-logging:* = 1.8.2\n com.squareup.okhttp3:okhttp = 3.9.0\n io.dropwizard:dropwizard-* = 2.0.10\n io.undertow:undertow-core = 2.0.17.Final\n+io.grpc:* = 1.35.0\n io.zipkin.java:* = 1.13.1\n jakarta.servlet:jakarta.servlet-api = 4.0.4\n jakarta.ws.rs:jakarta.ws.rs-api = 2.1.6"
  }
]
