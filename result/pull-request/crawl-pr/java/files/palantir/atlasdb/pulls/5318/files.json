[
  {
    "sha": "3aa67c25453bf2f169ee381589ab1ba8c8677e96",
    "filename": "atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/Cell.java",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/palantir/atlasdb/blob/1dadc44e175ac8ba5b0a405800626bd438bc82e5/atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/Cell.java",
    "raw_url": "https://github.com/palantir/atlasdb/raw/1dadc44e175ac8ba5b0a405800626bd438bc82e5/atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/Cell.java",
    "contents_url": "https://api.github.com/repos/palantir/atlasdb/contents/atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/Cell.java?ref=1dadc44e175ac8ba5b0a405800626bd438bc82e5",
    "patch": "@@ -27,6 +27,7 @@\n import java.io.Serializable;\n import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n+import java.util.Comparator;\n import javax.annotation.Nonnull;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -42,6 +43,7 @@\n \n     // Oracle has an upper bound on RAW types of 2000.\n     public static final int MAX_NAME_LENGTH = 1500;\n+    public static final Comparator<Cell> COLUMN_COMPARATOR = PtBytes.BYTES_COMPARATOR.onResultOf(Cell::getColumnName);\n \n     /**\n      * Creates a key. Do not modify the rowName or the columnName arrays after passing them."
  },
  {
    "sha": "cdb7c84d541197cc9447ba5bd89fd2c07d7152e9",
    "filename": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java",
    "status": "modified",
    "additions": 21,
    "deletions": 0,
    "changes": 21,
    "blob_url": "https://github.com/palantir/atlasdb/blob/1dadc44e175ac8ba5b0a405800626bd438bc82e5/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java",
    "raw_url": "https://github.com/palantir/atlasdb/raw/1dadc44e175ac8ba5b0a405800626bd438bc82e5/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java",
    "contents_url": "https://api.github.com/repos/palantir/atlasdb/contents/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java?ref=1dadc44e175ac8ba5b0a405800626bd438bc82e5",
    "patch": "@@ -130,6 +130,27 @@\n     Map<byte[], Iterator<Map.Entry<Cell, byte[]>>> getRowsColumnRangeIterator(\n             TableReference tableRef, Iterable<byte[]> rows, BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Returns an iterator over cell-value pairs within {@code tableRef} for the specified {@code rows}, where the\n+     * columns fall within the provided  {@link BatchColumnRangeSelection}.The single provided\n+     * {@link BatchColumnRangeSelection} applies to all of the rows. The cells for a row appear exactly once even if\n+     * the same row is included multiple times in {@code rows}.\n+     *\n+     * The returned iterator is guaranteed to contain cells sorted first in lexicographical order of column on byte\n+     * ordering, then in order of row, where rows are sorted according to the provided {@code rows} {@link Iterable}.\n+     * If the {@link Iterable} does not have a stable ordering (i.e. iteration order can change across iterators\n+     * returned) then the returned iterator is sorted lexicographically with columns sorted on byte ordering, but the\n+     * ordering of rows is undefined. In case of duplicate rows, the ordering is based on the first occurrence of\n+     * the row.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply column range selection to\n+     * @param batchColumnRangeSelection range of columns and batch size to load for all rows provided\n+     * @return an iterator over cell-value pairs, guaranteed to follow the ordering outlined above\n+     */\n+    @Idempotent\n+    Iterator<Map.Entry<Cell, byte[]>> getSortedColumns(\n+            TableReference tableRef, Iterable<byte[]> rows, BatchColumnRangeSelection batchColumnRangeSelection);\n     /**\n      * Gets the values associated for each cell in {@code cells} from table specified by {@code tableRef}.\n      *"
  },
  {
    "sha": "75c09d8e52c472e3c5c0b4726d5e438bf5bb38e0",
    "filename": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/ForwardingTransaction.java",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/palantir/atlasdb/blob/1dadc44e175ac8ba5b0a405800626bd438bc82e5/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/ForwardingTransaction.java",
    "raw_url": "https://github.com/palantir/atlasdb/raw/1dadc44e175ac8ba5b0a405800626bd438bc82e5/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/ForwardingTransaction.java",
    "contents_url": "https://api.github.com/repos/palantir/atlasdb/contents/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/ForwardingTransaction.java?ref=1dadc44e175ac8ba5b0a405800626bd438bc82e5",
    "patch": "@@ -66,6 +66,12 @@ public void useTable(TableReference tableRef, ConstraintCheckable table) {\n         return delegate().getRowsColumnRangeIterator(tableRef, rows, columnRangeSelection);\n     }\n \n+    @Override\n+    public Iterator<Map.Entry<Cell, byte[]>> getSortedColumns(\n+            TableReference tableRef, Iterable<byte[]> rows, BatchColumnRangeSelection batchColumnRangeSelection) {\n+        return delegate().getSortedColumns(tableRef, rows, batchColumnRangeSelection);\n+    }\n+\n     @Override\n     public Iterator<Map.Entry<Cell, byte[]>> getRowsColumnRange(\n             TableReference tableRef, Iterable<byte[]> rows, ColumnRangeSelection columnRangeSelection, int batchHint) {"
  },
  {
    "sha": "eac361a2d103710e0fe3196c32cf5fd71e6a3c28",
    "filename": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/ReadTransaction.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/palantir/atlasdb/blob/1dadc44e175ac8ba5b0a405800626bd438bc82e5/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/ReadTransaction.java",
    "raw_url": "https://github.com/palantir/atlasdb/raw/1dadc44e175ac8ba5b0a405800626bd438bc82e5/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/ReadTransaction.java",
    "contents_url": "https://api.github.com/repos/palantir/atlasdb/contents/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/ReadTransaction.java?ref=1dadc44e175ac8ba5b0a405800626bd438bc82e5",
    "patch": "@@ -122,6 +122,13 @@ public Transaction delegate() {\n         return delegate().getRowsColumnRangeIterator(tableRef, rows, columnRangeSelection);\n     }\n \n+    @Override\n+    public Iterator<Map.Entry<Cell, byte[]>> getSortedColumns(\n+            TableReference tableRef, Iterable<byte[]> rows, BatchColumnRangeSelection batchColumnRangeSelection) {\n+        checkTableName(tableRef);\n+        return delegate().getSortedColumns(tableRef, rows, batchColumnRangeSelection);\n+    }\n+\n     @Override\n     public Iterator<Map.Entry<Cell, byte[]>> getRowsColumnRange(\n             TableReference tableRef, Iterable<byte[]> rows, ColumnRangeSelection columnRangeSelection, int batchHint) {"
  },
  {
    "sha": "8cee01f511f15db4b13842c4975c318fd2fc066b",
    "filename": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SerializableTransaction.java",
    "status": "modified",
    "additions": 9,
    "deletions": 0,
    "changes": 9,
    "blob_url": "https://github.com/palantir/atlasdb/blob/1dadc44e175ac8ba5b0a405800626bd438bc82e5/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SerializableTransaction.java",
    "raw_url": "https://github.com/palantir/atlasdb/raw/1dadc44e175ac8ba5b0a405800626bd438bc82e5/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SerializableTransaction.java",
    "contents_url": "https://api.github.com/repos/palantir/atlasdb/contents/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SerializableTransaction.java?ref=1dadc44e175ac8ba5b0a405800626bd438bc82e5",
    "patch": "@@ -217,6 +217,15 @@ public SerializableTransaction(\n                 .collectTo(() -> new TreeMap<>(UnsignedBytes.lexicographicalComparator()));\n     }\n \n+    @Override\n+    public Iterator<Map.Entry<Cell, byte[]>> getSortedColumns(\n+            TableReference tableRef, Iterable<byte[]> rows, BatchColumnRangeSelection batchColumnRangeSelection) {\n+        if (isSerializableTable(tableRef)) {\n+            throw new UnsupportedOperationException(\"This method does not support serializable conflict handling\");\n+        }\n+        return super.getSortedColumns(tableRef, rows, batchColumnRangeSelection);\n+    }\n+\n     @Override\n     @Idempotent\n     public Map<Cell, byte[]> get(TableReference tableRef, Set<Cell> cells) {"
  },
  {
    "sha": "6fb7c80967e5ce3abb59134807afd4576bb5f757",
    "filename": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java",
    "status": "modified",
    "additions": 133,
    "deletions": 26,
    "changes": 159,
    "blob_url": "https://github.com/palantir/atlasdb/blob/1dadc44e175ac8ba5b0a405800626bd438bc82e5/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java",
    "raw_url": "https://github.com/palantir/atlasdb/raw/1dadc44e175ac8ba5b0a405800626bd438bc82e5/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java",
    "contents_url": "https://api.github.com/repos/palantir/atlasdb/contents/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java?ref=1dadc44e175ac8ba5b0a405800626bd438bc82e5",
    "patch": "@@ -15,9 +15,12 @@\n  */\n package com.palantir.atlasdb.transaction.impl;\n \n+import static java.util.stream.Collectors.toList;\n+\n import com.codahale.metrics.Counter;\n import com.codahale.metrics.Histogram;\n import com.codahale.metrics.Timer;\n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Function;\n import com.google.common.base.Functions;\n import com.google.common.base.MoreObjects;\n@@ -40,6 +43,7 @@\n import com.google.common.collect.PeekingIterator;\n import com.google.common.collect.SetMultimap;\n import com.google.common.collect.Sets;\n+import com.google.common.collect.Streams;\n import com.google.common.primitives.UnsignedBytes;\n import com.google.common.util.concurrent.Futures;\n import com.google.common.util.concurrent.ListenableFuture;\n@@ -434,6 +438,111 @@ public void markTableInvolved(TableReference tableRef) {\n         return postFilteredResults;\n     }\n \n+    @Override\n+    public Iterator<Map.Entry<Cell, byte[]>> getSortedColumns(\n+            TableReference tableRef, Iterable<byte[]> rows, BatchColumnRangeSelection batchColumnRangeSelection) {\n+        checkGetPreconditions(tableRef);\n+        if (Iterables.isEmpty(rows)) {\n+            return Collections.emptyIterator();\n+        }\n+        Iterable<byte[]> distinctRows = getDistinctRows(rows);\n+\n+        hasReads = true;\n+        int batchSize = getPerRowBatchSize(batchColumnRangeSelection, Iterables.size(distinctRows));\n+        BatchColumnRangeSelection perBatchSelection = BatchColumnRangeSelection.create(\n+                batchColumnRangeSelection.getStartCol(), batchColumnRangeSelection.getEndCol(), batchSize);\n+\n+        Map<byte[], RowColumnRangeIterator> rawResults =\n+                keyValueService.getRowsColumnRange(tableRef, distinctRows, perBatchSelection, getStartTimestamp());\n+\n+        return getPostFilteredSortedColumns(tableRef, batchColumnRangeSelection, distinctRows, rawResults);\n+    }\n+\n+    private Iterator<Map.Entry<Cell, byte[]>> getPostFilteredSortedColumns(\n+            TableReference tableRef,\n+            BatchColumnRangeSelection batchColumnRangeSelection,\n+            Iterable<byte[]> distinctRows,\n+            Map<byte[], RowColumnRangeIterator> rawResults) {\n+        Comparator<Cell> cellComparator = columnOrderThenPreserveInputRowOrder(distinctRows);\n+\n+        Iterator<Map.Entry<Cell, Value>> postFilterIterator = getRowColumnRangePostFilteredWithoutSorting(\n+                tableRef,\n+                mergeByComparator(rawResults.values(), cellComparator),\n+                batchColumnRangeSelection.getBatchHint());\n+        Iterator<Map.Entry<Cell, byte[]>> remoteWrites = Iterators.transform(\n+                postFilterIterator,\n+                entry -> Maps.immutableEntry(entry.getKey(), entry.getValue().getContents()));\n+        Iterator<Map.Entry<Cell, byte[]>> localWrites =\n+                getSortedColumnsLocalWrites(tableRef, distinctRows, batchColumnRangeSelection, cellComparator);\n+        Iterator<Map.Entry<Cell, byte[]>> merged = mergeLocalAndRemoteWrites(localWrites, remoteWrites, cellComparator);\n+\n+        return filterDeletedValues(merged, tableRef);\n+    }\n+\n+    private static Iterator<Map.Entry<Cell, byte[]>> mergeLocalAndRemoteWrites(\n+            Iterator<Map.Entry<Cell, byte[]>> localWrites,\n+            Iterator<Map.Entry<Cell, byte[]>> remoteWrites,\n+            Comparator<Cell> cellComparator) {\n+        // always override remote values with locally written values\n+        return IteratorUtils.mergeIterators(\n+                localWrites,\n+                remoteWrites,\n+                Comparator.comparing(Map.Entry::getKey, cellComparator),\n+                com.palantir.util.Pair::getLhSide);\n+    }\n+\n+    private Iterator<Map.Entry<Cell, byte[]>> getSortedColumnsLocalWrites(\n+            TableReference tableRef,\n+            Iterable<byte[]> rows,\n+            BatchColumnRangeSelection columns,\n+            Comparator<Cell> cellComparator) {\n+        return mergeByComparator(\n+                Iterables.transform(rows, row -> getLocalWritesForColumnRange(tableRef, columns, row)\n+                        .entrySet()\n+                        .iterator()),\n+                cellComparator);\n+    }\n+\n+    /**\n+     * Provides comparator to sort cells by columns (sorted lexicographically on byte ordering) and then in the order\n+     * of input rows.\n+     * */\n+    @VisibleForTesting\n+    static Comparator<Cell> columnOrderThenPreserveInputRowOrder(Iterable<byte[]> rows) {\n+        return Cell.COLUMN_COMPARATOR.thenComparing(\n+                (Cell cell) -> ByteBuffer.wrap(cell.getRowName()),\n+                Ordering.explicit(Streams.stream(rows)\n+                        .map(ByteBuffer::wrap)\n+                        .distinct()\n+                        .collect(ImmutableList.toImmutableList())));\n+    }\n+\n+    private static <V> Iterator<Map.Entry<Cell, V>> mergeByComparator(\n+            Iterable<? extends Iterator<Map.Entry<Cell, V>>> iterators, Comparator<Cell> cellComparator) {\n+        Comparator<Map.Entry<Cell, V>> comp = Comparator.comparing(Map.Entry::getKey, cellComparator);\n+        return Iterators.mergeSorted(iterators, comp);\n+    }\n+\n+    /**\n+     * If the batch hint is small, ask for at least that many from each of the input rows to avoid the\n+     * possibility of needing a second batch of fetching.\n+     * If the batch hint is large, split batch size across rows to avoid loading too much data, while accepting that\n+     * second fetches may be needed to get everyone their data.\n+     * */\n+    private static int getPerRowBatchSize(BatchColumnRangeSelection columnRangeSelection, int distinctRowCount) {\n+        return Math.max(\n+                Math.min(100, columnRangeSelection.getBatchHint()),\n+                columnRangeSelection.getBatchHint() / distinctRowCount);\n+    }\n+\n+    private List<byte[]> getDistinctRows(Iterable<byte[]> inputRows) {\n+        return Streams.stream(inputRows)\n+                .map(ByteBuffer::wrap)\n+                .distinct()\n+                .map(ByteBuffer::array)\n+                .collect(toList());\n+    }\n+\n     private Iterator<Map.Entry<Cell, byte[]>> getPostFilteredColumns(\n             TableReference tableRef,\n             BatchColumnRangeSelection batchColumnRangeSelection,\n@@ -443,13 +552,8 @@ public void markTableInvolved(TableReference tableRef) {\n                 getRowColumnRangePostFiltered(tableRef, row, batchColumnRangeSelection, rawIterator);\n         SortedMap<Cell, byte[]> localWrites = getLocalWritesForColumnRange(tableRef, batchColumnRangeSelection, row);\n         Iterator<Map.Entry<Cell, byte[]>> localIterator = localWrites.entrySet().iterator();\n-        Iterator<Map.Entry<Cell, byte[]>> mergedIterator = IteratorUtils.mergeIterators(\n-                localIterator,\n-                postFilterIterator,\n-                Ordering.from(UnsignedBytes.lexicographicalComparator())\n-                        .onResultOf(entry -> entry.getKey().getColumnName()),\n-                com.palantir.util.Pair::getLhSide);\n-\n+        Iterator<Map.Entry<Cell, byte[]>> mergedIterator =\n+                mergeLocalAndRemoteWrites(localIterator, postFilterIterator, Cell.COLUMN_COMPARATOR);\n         return filterDeletedValues(mergedIterator, tableRef);\n     }\n \n@@ -469,12 +573,7 @@ public void markTableInvolved(TableReference tableRef) {\n                             Maps.immutableEntry(entry.getKey(), entry.getValue().getContents()));\n             Iterator<Map.Entry<Cell, byte[]>> localIterator =\n                     localWrites.entrySet().iterator();\n-            return IteratorUtils.mergeIterators(\n-                    localIterator,\n-                    remoteIterator,\n-                    Ordering.from(UnsignedBytes.lexicographicalComparator())\n-                            .onResultOf(entry -> entry.getKey().getColumnName()),\n-                    com.palantir.util.Pair::getLhSide);\n+            return mergeLocalAndRemoteWrites(localIterator, remoteIterator, Cell.COLUMN_COMPARATOR);\n         }));\n \n         return filterDeletedValues(merged, tableRef);\n@@ -495,15 +594,10 @@ public void markTableInvolved(TableReference tableRef) {\n     private Iterator<Map.Entry<Cell, Value>> getRowColumnRangePostFiltered(\n             TableReference tableRef, RowColumnRangeIterator iterator, int batchHint) {\n         return Iterators.concat(Iterators.transform(Iterators.partition(iterator, batchHint), batch -> {\n-            ImmutableMap.Builder<Cell, Value> rawBuilder = ImmutableMap.builder();\n-            batch.forEach(rawBuilder::put);\n-            Map<Cell, Value> raw = rawBuilder.build();\n-\n-            validatePreCommitRequirementsOnReadIfNecessary(tableRef, getStartTimestamp());\n+            Map<Cell, Value> raw = validateBatch(tableRef, batch);\n             if (raw.isEmpty()) {\n                 return Collections.emptyIterator();\n             }\n-\n             SortedMap<Cell, Value> postFiltered = ImmutableSortedMap.copyOf(\n                     getWithPostFilteringSync(tableRef, raw, x -> x), preserveInputRowOrder(batch));\n             return postFiltered.entrySet().iterator();\n@@ -525,6 +619,23 @@ public void markTableInvolved(TableReference tableRef) {\n                 raw -> getWithPostFilteringSync(tableRef, raw, Value.GET_VALUE));\n     }\n \n+    private Iterator<Map.Entry<Cell, Value>> getRowColumnRangePostFilteredWithoutSorting(\n+            TableReference tableRef, Iterator<Map.Entry<Cell, Value>> iterator, int batchHint) {\n+        return Iterators.concat(Iterators.transform(Iterators.partition(iterator, batchHint), batch -> {\n+            Map<Cell, Value> raw = validateBatch(tableRef, batch);\n+            if (raw.isEmpty()) {\n+                return Collections.emptyIterator();\n+            }\n+            Map<Cell, Value> postFiltered = ImmutableMap.copyOf(getWithPostFilteringSync(tableRef, raw, x -> x));\n+            return postFiltered.entrySet().iterator();\n+        }));\n+    }\n+\n+    private Map<Cell, Value> validateBatch(TableReference tableRef, List<Map.Entry<Cell, Value>> batch) {\n+        validatePreCommitRequirementsOnReadIfNecessary(tableRef, getStartTimestamp());\n+        return ImmutableMap.copyOf(batch);\n+    }\n+\n     private Comparator<Cell> preserveInputRowOrder(List<Map.Entry<Cell, Value>> inputEntries) {\n         // N.B. This batch could be spread across multiple rows, and those rows might extend into other\n         // batches. We are given cells for a row grouped together, so easiest way to ensure they stay together\n@@ -1020,13 +1131,9 @@ protected static int getRequestHintToKvStore(int userRequestedSize) {\n             Iterator<Map.Entry<Cell, byte[]>> postFilterIterator,\n             Iterator<Map.Entry<Cell, byte[]>> localWritesInRange,\n             boolean isReverse) {\n-        Ordering<Map.Entry<Cell, byte[]>> ordering = Ordering.natural().onResultOf(MapEntries.getKeyFunction());\n-        Iterator<Map.Entry<Cell, byte[]>> mergeIterators = IteratorUtils.mergeIterators(\n-                postFilterIterator,\n-                localWritesInRange,\n-                isReverse ? ordering.reverse() : ordering,\n-                from -> from.rhSide); // always override their value with written values\n-\n+        Comparator<Cell> cellComparator = isReverse ? Comparator.reverseOrder() : Comparator.naturalOrder();\n+        Iterator<Map.Entry<Cell, byte[]>> mergeIterators =\n+                mergeLocalAndRemoteWrites(localWritesInRange, postFilterIterator, cellComparator);\n         return postFilterEmptyValues(tableRef, mergeIterators);\n     }\n "
  },
  {
    "sha": "de95e382649e3f01dc6f2c475e38ce1918891fc0",
    "filename": "atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionTest.java",
    "status": "modified",
    "additions": 197,
    "deletions": 0,
    "changes": 197,
    "blob_url": "https://github.com/palantir/atlasdb/blob/1dadc44e175ac8ba5b0a405800626bd438bc82e5/atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionTest.java",
    "raw_url": "https://github.com/palantir/atlasdb/raw/1dadc44e175ac8ba5b0a405800626bd438bc82e5/atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionTest.java",
    "contents_url": "https://api.github.com/repos/palantir/atlasdb/contents/atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionTest.java?ref=1dadc44e175ac8ba5b0a405800626bd438bc82e5",
    "patch": "@@ -43,6 +43,7 @@\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimaps;\n import com.google.common.collect.Ordering;\n+import com.google.common.collect.Streams;\n import com.google.common.util.concurrent.Futures;\n import com.google.common.util.concurrent.ListenableFuture;\n import com.google.common.util.concurrent.MoreExecutors;\n@@ -96,6 +97,7 @@\n import com.palantir.common.base.Throwables;\n import com.palantir.common.concurrent.PTExecutors;\n import com.palantir.common.proxy.MultiDelegateProxy;\n+import com.palantir.common.streams.KeyedStream;\n import com.palantir.lock.AtlasRowLockDescriptor;\n import com.palantir.lock.HeldLocksToken;\n import com.palantir.lock.LockClient;\n@@ -136,6 +138,7 @@\n import java.util.function.Supplier;\n import java.util.stream.Collectors;\n import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n import java.util.stream.StreamSupport;\n import org.apache.commons.lang3.mutable.MutableInt;\n import org.apache.commons.lang3.mutable.MutableLong;\n@@ -293,6 +296,11 @@ public void cleanup() {}\n     static final TableReference TABLE_SWEPT_THOROUGH_MIGRATION =\n             TableReference.createFromFullyQualifiedName(\"default.table5\");\n \n+    private static final byte[] ROW_FOO = \"foo\".getBytes();\n+    private static final byte[] ROW_BAR = \"bar\".getBytes();\n+    private static final byte[] COL_A = \"a\".getBytes();\n+    private static final byte[] COL_B = \"b\".getBytes();\n+\n     private static final Cell TEST_CELL = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n     private static final Cell TEST_CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column2\"));\n \n@@ -1684,6 +1692,195 @@ public void orphanedSentinelsDoNotGetDeletedAfterDetectionInConservativelySweptT\n                 .isNotEmpty();\n     }\n \n+    @Test\n+    public void testColumnOrderThenPreserveInputRowOrder() {\n+        Cell foo_A = Cell.create(ROW_FOO, COL_A);\n+        Cell bar_A = Cell.create(ROW_BAR, COL_A);\n+        Cell foo_B = Cell.create(ROW_FOO, COL_B);\n+        Cell bar_B = Cell.create(ROW_BAR, COL_B);\n+\n+        putCellsInTable(ImmutableList.of(foo_B, bar_A, bar_B, foo_A), TABLE);\n+\n+        Assertions.assertThat(getSortedEntries(\n+                        TABLE,\n+                        ImmutableList.of(ROW_FOO, ROW_BAR),\n+                        BatchColumnRangeSelection.create(PtBytes.EMPTY_BYTE_ARRAY, PtBytes.EMPTY_BYTE_ARRAY, 1000)))\n+                .containsExactly(foo_A, bar_A, foo_B, bar_B);\n+\n+        Assertions.assertThat(getSortedEntries(\n+                        TABLE,\n+                        ImmutableList.of(ROW_BAR, ROW_FOO),\n+                        BatchColumnRangeSelection.create(PtBytes.EMPTY_BYTE_ARRAY, PtBytes.EMPTY_BYTE_ARRAY, 1000)))\n+                .containsExactly(bar_A, foo_A, bar_B, foo_B);\n+    }\n+\n+    @Test\n+    public void getSortedColumnsReturnsCellsSortedByColumn() {\n+        ImmutableList<byte[]> rows = ImmutableList.of(ROW_FOO, ROW_BAR);\n+        ImmutableList<byte[]> columns = ImmutableList.of(COL_A, COL_B);\n+\n+        List<Cell> cells = rows.stream()\n+                .map(row -> columns.stream().map(col -> Cell.create(row, col)).collect(Collectors.toList()))\n+                .flatMap(Collection::stream)\n+                .collect(Collectors.toList());\n+\n+        putCellsInTable(cells, TABLE);\n+        List<Cell> entries = getSortedEntries(\n+                TABLE,\n+                rows,\n+                BatchColumnRangeSelection.create(PtBytes.EMPTY_BYTE_ARRAY, PtBytes.EMPTY_BYTE_ARRAY, 1000));\n+\n+        List<Cell> entriesSortedByColumn = columns.stream()\n+                .map(col -> rows.stream().map(row -> Cell.create(row, col)).collect(Collectors.toList()))\n+                .flatMap(Collection::stream)\n+                .collect(Collectors.toList());\n+        Assertions.assertThat(entries).containsExactlyElementsOf(entriesSortedByColumn);\n+    }\n+\n+    @Test\n+    public void getSortedColumnsThrowsIfLockIsLost() {\n+        List<Cell> cells = ImmutableList.of(Cell.create(ROW_FOO, COL_A));\n+        putCellsInTable(cells, TABLE_SWEPT_THOROUGH);\n+\n+        TimelockService timelockService = new LegacyTimelockService(timestampService, lockService, lockClient);\n+        long transactionTs = timelockService.getFreshTimestamp();\n+        LockImmutableTimestampResponse res = timelockService.lockImmutableTimestamp();\n+        Transaction transaction =\n+                getSnapshotTransactionWith(timelockService, () -> transactionTs, res, PreCommitConditions.NO_OP, true);\n+\n+        timelockService.unlock(ImmutableSet.of(res.getLock()));\n+        Iterator<Map.Entry<Cell, byte[]>> sortedColumns = transaction.getSortedColumns(\n+                TABLE_SWEPT_THOROUGH,\n+                ImmutableList.of(ROW_FOO),\n+                BatchColumnRangeSelection.create(PtBytes.EMPTY_BYTE_ARRAY, PtBytes.EMPTY_BYTE_ARRAY, 1000));\n+        assertThatThrownBy(() -> Streams.stream(sortedColumns).forEach(Map.Entry::getKey))\n+                .isInstanceOf(TransactionLockTimeoutException.class);\n+    }\n+\n+    @Test\n+    public void getSortedColumnsThrowsIfLockIsLostMidway() {\n+        List<byte[]> rows = LongStream.range(0, 10).mapToObj(PtBytes::toBytes).collect(Collectors.toList());\n+        List<Cell> cells = rows.stream().map(row -> Cell.create(row, COL_A)).collect(Collectors.toList());\n+        putCellsInTable(cells, TABLE_SWEPT_THOROUGH);\n+\n+        TimelockService timelockService = new LegacyTimelockService(timestampService, lockService, lockClient);\n+        long transactionTs = timelockService.getFreshTimestamp();\n+        LockImmutableTimestampResponse res = timelockService.lockImmutableTimestamp();\n+\n+        Transaction transaction =\n+                getSnapshotTransactionWith(timelockService, () -> transactionTs, res, PreCommitConditions.NO_OP, true);\n+\n+        int batchHint = 5;\n+        Iterator<Map.Entry<Cell, byte[]>> sortedColumns = transaction.getSortedColumns(\n+                TABLE_SWEPT_THOROUGH,\n+                rows,\n+                BatchColumnRangeSelection.create(PtBytes.EMPTY_BYTE_ARRAY, PtBytes.EMPTY_BYTE_ARRAY, batchHint));\n+        assertThat(sortedColumns.next().getKey()).isEqualTo(cells.get(0));\n+\n+        // lock lost after getting first batch\n+        timelockService.unlock(ImmutableSet.of(res.getLock()));\n+\n+        // should still be able to get all but last element of the elements for the first batch;\n+        // next batch is preemptively fetched when last element of curr batch is retrieved\n+        List<Cell> retrievedEntries = IntStream.range(1, batchHint - 1)\n+                .mapToObj(_unused -> sortedColumns.next().getKey())\n+                .collect(Collectors.toList());\n+        assertThat(retrievedEntries).hasSameElementsAs(cells.subList(1, batchHint - 1));\n+\n+        // should throw while fetching the next batch\n+        assertThatThrownBy(sortedColumns::next).isInstanceOf(TransactionLockTimeoutException.class);\n+    }\n+\n+    @Test\n+    public void getSortedColumnsObeysColumnRangeSelection() {\n+        List<byte[]> rows = ImmutableList.of(ROW_FOO, ROW_BAR);\n+        List<Cell> colA_cells = ImmutableList.of(Cell.create(ROW_FOO, COL_A), Cell.create(ROW_BAR, COL_A));\n+\n+        putCellsInTable(colA_cells, TABLE);\n+        List<Cell> entries =\n+                getSortedEntries(TABLE, rows, BatchColumnRangeSelection.create(COL_A, \"az\".getBytes(), 1000));\n+        Assertions.assertThat(entries).containsExactlyElementsOf(colA_cells);\n+\n+        List<Cell> outOfRangeEntries =\n+                getSortedEntries(TABLE, rows, BatchColumnRangeSelection.create(\"y\".getBytes(), \"z\".getBytes(), 1000));\n+        Assertions.assertThat(outOfRangeEntries).isEmpty();\n+    }\n+\n+    @Test\n+    public void getSortedColumnsIteratesOverMultipleBatchesIfRequired() {\n+        ImmutableList<byte[]> rows = ImmutableList.of(ROW_FOO, ROW_BAR);\n+        ImmutableList<byte[]> columns = ImmutableList.of(COL_A, COL_B);\n+\n+        List<Cell> cells = rows.stream()\n+                .map(row -> columns.stream().map(col -> Cell.create(row, col)).collect(Collectors.toList()))\n+                .flatMap(Collection::stream)\n+                .collect(Collectors.toList());\n+\n+        putCellsInTable(cells, TABLE);\n+        List<Cell> entries = getSortedEntries(\n+                TABLE, rows, BatchColumnRangeSelection.create(PtBytes.EMPTY_BYTE_ARRAY, PtBytes.EMPTY_BYTE_ARRAY, 1));\n+\n+        List<Cell> entriesSortedByColumn = columns.stream()\n+                .map(col -> rows.stream().map(row -> Cell.create(row, col)).collect(Collectors.toList()))\n+                .flatMap(Collection::stream)\n+                .collect(Collectors.toList());\n+        Assertions.assertThat(entries).containsExactlyElementsOf(entriesSortedByColumn);\n+    }\n+\n+    @Test\n+    public void getSortedColumnsValidatesLocksOncePerBatch() {\n+        List<byte[]> rows = LongStream.range(0, 1000).mapToObj(PtBytes::toBytes).collect(Collectors.toList());\n+\n+        List<Cell> cells = rows.stream().map(row -> Cell.create(row, COL_A)).collect(Collectors.toList());\n+        putCellsInTable(cells, TABLE_SWEPT_THOROUGH);\n+\n+        verifyPrefetchValidations(rows, cells, 100, 10, 1000);\n+        verifyPrefetchValidations(rows, cells, 100, 3, 299);\n+        verifyPrefetchValidations(rows, cells, 100, 4, 300);\n+        verifyPrefetchValidations(rows, cells, 100, 4, 301);\n+    }\n+\n+    private void verifyPrefetchValidations(\n+            List<byte[]> rows,\n+            List<Cell> cells,\n+            int batchHint,\n+            int expectedNumberOfInvocations,\n+            int numElementsToBeAccessed) {\n+        TimelockService timelockService = spy(new LegacyTimelockService(timestampService, lockService, lockClient));\n+        long transactionTs = timelockService.getFreshTimestamp();\n+        LockImmutableTimestampResponse res = timelockService.lockImmutableTimestamp();\n+        Transaction transaction =\n+                getSnapshotTransactionWith(timelockService, () -> transactionTs, res, PreCommitConditions.NO_OP, true);\n+\n+        Iterator<Map.Entry<Cell, byte[]>> sortedColumns = transaction.getSortedColumns(\n+                TABLE_SWEPT_THOROUGH,\n+                rows,\n+                BatchColumnRangeSelection.create(PtBytes.EMPTY_BYTE_ARRAY, PtBytes.EMPTY_BYTE_ARRAY, batchHint));\n+        List<Cell> entries = IntStream.range(0, numElementsToBeAccessed)\n+                .mapToObj(_unused -> sortedColumns.next().getKey())\n+                .collect(Collectors.toList());\n+        Assertions.assertThat(entries).containsExactlyElementsOf(cells.subList(0, numElementsToBeAccessed));\n+        verify(timelockService, times(expectedNumberOfInvocations)).refreshLockLeases(ImmutableSet.of(res.getLock()));\n+    }\n+\n+    private List<Cell> getSortedEntries(\n+            TableReference table, List<byte[]> rows, BatchColumnRangeSelection batchColumnRangeSelection) {\n+        return serializableTxManager.runTaskWithRetry(tx -> {\n+            Iterator<Map.Entry<Cell, byte[]>> sortedColumns =\n+                    tx.getSortedColumns(table, rows, batchColumnRangeSelection);\n+            return Streams.stream(sortedColumns).map(Map.Entry::getKey).collect(Collectors.toList());\n+        });\n+    }\n+\n+    private void putCellsInTable(List<Cell> cells, TableReference table) {\n+        byte[] value = new byte[1];\n+        Map<Cell, byte[]> cellMap = KeyedStream.of(cells).map(_unused -> value).collectToMap();\n+        txManager.runTaskWithRetry(tx -> {\n+            tx.put(table, cellMap);\n+            return null;\n+        });\n+    }\n+\n     private void putUncommittedAtFreshTimestamp(TableReference tableRef, Cell cell) {\n         keyValueService.put(\n                 tableRef,"
  },
  {
    "sha": "f59540ce66fe9f929c77b4103a15383656b62a6f",
    "filename": "changelog/@unreleased/pr-5318.v2.yml",
    "status": "added",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/palantir/atlasdb/blob/1dadc44e175ac8ba5b0a405800626bd438bc82e5/changelog/@unreleased/pr-5318.v2.yml",
    "raw_url": "https://github.com/palantir/atlasdb/raw/1dadc44e175ac8ba5b0a405800626bd438bc82e5/changelog/@unreleased/pr-5318.v2.yml",
    "contents_url": "https://api.github.com/repos/palantir/atlasdb/contents/changelog/@unreleased/pr-5318.v2.yml?ref=1dadc44e175ac8ba5b0a405800626bd438bc82e5",
    "patch": "@@ -0,0 +1,5 @@\n+type: improvement\n+improvement:\n+  description: Adds getSortedColumns endpoint for tables with snapshot-transaction conflict checking.\n+  links:\n+  - https://github.com/palantir/atlasdb/pull/5318"
  }
]
