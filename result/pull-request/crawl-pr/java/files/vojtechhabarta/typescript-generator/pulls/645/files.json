[
  {
    "sha": "a0e49f6226ed626202db8801e495e2b46e3d4e9b",
    "filename": "typescript-generator-core/pom.xml",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/vojtechhabarta/typescript-generator/blob/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/pom.xml",
    "raw_url": "https://github.com/vojtechhabarta/typescript-generator/raw/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/pom.xml",
    "contents_url": "https://api.github.com/repos/vojtechhabarta/typescript-generator/contents/typescript-generator-core/pom.xml?ref=3de101781cdc5db08b8020b6ee3cb65a984523da",
    "patch": "@@ -59,6 +59,11 @@\n             <artifactId>javax.ws.rs-api</artifactId>\n             <version>2.1.1</version>\n         </dependency>\n+        <dependency>\n+            <groupId>jakarta.ws.rs</groupId>\n+            <artifactId>jakarta.ws.rs-api</artifactId>\n+            <version>3.0.0</version>\n+        </dependency>\n         <dependency>\n             <groupId>io.github.classgraph</groupId>\n             <artifactId>classgraph</artifactId>"
  },
  {
    "sha": "0f44be32de55dab13eae18d3ef2fae00b5cd48a7",
    "filename": "typescript-generator-core/src/main/java/cz/habarta/typescript/generator/JakartaRsApplicationScanner.java",
    "status": "added",
    "additions": 74,
    "deletions": 0,
    "changes": 74,
    "blob_url": "https://github.com/vojtechhabarta/typescript-generator/blob/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/JakartaRsApplicationScanner.java",
    "raw_url": "https://github.com/vojtechhabarta/typescript-generator/raw/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/JakartaRsApplicationScanner.java",
    "contents_url": "https://api.github.com/repos/vojtechhabarta/typescript-generator/contents/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/JakartaRsApplicationScanner.java?ref=3de101781cdc5db08b8020b6ee3cb65a984523da",
    "patch": "@@ -0,0 +1,74 @@\n+\n+package cz.habarta.typescript.generator;\n+\n+import cz.habarta.typescript.generator.parser.SourceType;\n+import io.github.classgraph.ScanResult;\n+import jakarta.ws.rs.Path;\n+import jakarta.ws.rs.core.Application;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+\n+public class JakartaRsApplicationScanner {\n+\n+    public static List<SourceType<Type>> scanJakartaRsApplication(Class<?> jaxrsApplicationClass, Predicate<String> isClassNameExcluded) {\n+        final ClassLoader originalContextClassLoader = Thread.currentThread().getContextClassLoader();\n+        try {\n+            Thread.currentThread().setContextClassLoader(jaxrsApplicationClass.getClassLoader());\n+            TypeScriptGenerator.getLogger().info(\"Scanning JAX-RS application: \" + jaxrsApplicationClass.getName());\n+            final Constructor<?> constructor = jaxrsApplicationClass.getDeclaredConstructor();\n+            constructor.setAccessible(true);\n+            final Application application = (Application) constructor.newInstance();\n+            final List<Class<?>> resourceClasses = new ArrayList<>();\n+            for (Class<?> cls : application.getClasses()) {\n+                if (cls.isAnnotationPresent(Path.class)) {\n+                    resourceClasses.add(cls);\n+                }\n+            }\n+            return new JakartaRsApplicationScanner().scanJakartaRsApplication(jaxrsApplicationClass, resourceClasses, isClassNameExcluded);\n+        } catch (ReflectiveOperationException e) {\n+            throw reportError(e);\n+        } finally {\n+            Thread.currentThread().setContextClassLoader(originalContextClassLoader);\n+        }\n+    }\n+\n+    public static List<SourceType<Type>> scanAutomaticJakartaRsApplication(ScanResult scanResult, Predicate<String> isClassNameExcluded) {\n+        final List<String> namesOfResourceClasses = scanResult.getClassesWithAnnotation(Path.class.getName()).getNames();\n+        final List<Class<?>> resourceClasses = Input.loadClasses(namesOfResourceClasses);\n+        TypeScriptGenerator.getLogger().info(String.format(\"Found %d root resources.\", resourceClasses.size()));\n+        return new JakartaRsApplicationScanner().scanJakartaRsApplication(null, resourceClasses, isClassNameExcluded);\n+    }\n+\n+    private static RuntimeException reportError(ReflectiveOperationException e) {\n+        final String url = \"https://github.com/vojtechhabarta/typescript-generator/wiki/JAX-RS-Application\";\n+        final String message = \"Cannot load JAX-RS application. For more information see \" + url + \".\";\n+        TypeScriptGenerator.getLogger().error(message);\n+        return new RuntimeException(message, e);\n+    }\n+\n+    List<SourceType<Type>> scanJakartaRsApplication(Class<?> applicationClass, List<Class<?>> resourceClasses, Predicate<String> isClassNameExcluded) {\n+        Collections.sort(resourceClasses, new Comparator<Class<?>>() {\n+            @Override\n+            public int compare(Class<?> o1, Class<?> o2) {\n+                return o1.getName().compareToIgnoreCase(o2.getName());\n+            }\n+        });\n+        final List<SourceType<Type>> sourceTypes = new ArrayList<>();\n+        if (applicationClass != null) {\n+            sourceTypes.add(new SourceType<Type>(applicationClass));\n+        }\n+        for (Class<?> resourceClass : resourceClasses) {\n+            if (isClassNameExcluded == null || !isClassNameExcluded.test(resourceClass.getName())) {\n+                sourceTypes.add(new SourceType<Type>(resourceClass));\n+            }\n+        }\n+        return sourceTypes;\n+    }\n+\n+}"
  },
  {
    "sha": "d8deeebd4d0e69e6739c454450b0d24e6de1bb51",
    "filename": "typescript-generator-core/src/main/java/cz/habarta/typescript/generator/Settings.java",
    "status": "modified",
    "additions": 17,
    "deletions": 2,
    "changes": 19,
    "blob_url": "https://github.com/vojtechhabarta/typescript-generator/blob/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/Settings.java",
    "raw_url": "https://github.com/vojtechhabarta/typescript-generator/raw/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/Settings.java",
    "contents_url": "https://api.github.com/repos/vojtechhabarta/typescript-generator/contents/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/Settings.java?ref=3de101781cdc5db08b8020b6ee3cb65a984523da",
    "patch": "@@ -8,6 +8,7 @@\n import cz.habarta.typescript.generator.compiler.SymbolTable.CustomTypeNamingFunction;\n import cz.habarta.typescript.generator.emitter.EmitterExtension;\n import cz.habarta.typescript.generator.emitter.EmitterExtensionFeatures;\n+import cz.habarta.typescript.generator.parser.JakartaRsApplicationParser;\n import cz.habarta.typescript.generator.parser.JaxrsApplicationParser;\n import cz.habarta.typescript.generator.parser.RestApplicationParser;\n import cz.habarta.typescript.generator.parser.TypeParser;\n@@ -94,6 +95,8 @@\n     public boolean disableTaggedUnions = false;\n     public boolean generateReadonlyAndWriteonlyJSDocTags = false;\n     public boolean ignoreSwaggerAnnotations = false;\n+    public boolean generateJakartaRsApplicationInterface = false;\n+    public boolean generateJakartaRsApplicationClient;\n     public boolean generateJaxrsApplicationInterface = false;\n     public boolean generateJaxrsApplicationClient = false;\n     public boolean generateSpringApplicationInterface = false;\n@@ -408,6 +411,10 @@ public void validate() {\n                         annotation.getName()));\n             }\n         }\n+        \n+        if (generateJakartaRsApplicationClient && outputFileType != TypeScriptFileType.implementationFile) {\n+            throw new RuntimeException(\"'generateJaxrsApplicationClient' can only be used when generating implementation file ('outputFileType' parameter is 'implementationFile').\");\n+        }\n         if (generateJaxrsApplicationClient && outputFileType != TypeScriptFileType.implementationFile) {\n             throw new RuntimeException(\"'generateJaxrsApplicationClient' can only be used when generating implementation file ('outputFileType' parameter is 'implementationFile').\");\n         }\n@@ -761,9 +768,13 @@ public void setRestOptionsType(String restOptionsType) {\n     public List<RestApplicationParser.Factory> getRestApplicationParserFactories() {\n         if (restApplicationParserFactories == null) {\n             final List<RestApplicationParser.Factory> factories = new ArrayList<>();\n-            if (isGenerateJaxrs() || !isGenerateSpring()) {\n+            if (isGenerateJaxrs() || (!isGenerateSpring() && !isGenerateJakartaRs())) {\n                 factories.add(new JaxrsApplicationParser.Factory());\n             }\n+            if (isGenerateJakartaRs() || (!isGenerateSpring() && !isGenerateJaxrs())) {\n+                factories.add(new JakartaRsApplicationParser.Factory());\n+            }\n+\n             if (isGenerateSpring()) {\n                 final String springClassName = \"cz.habarta.typescript.generator.spring.SpringApplicationParser$Factory\";\n                 final Class<?> springClass;\n@@ -786,6 +797,10 @@ public void setRestOptionsType(String restOptionsType) {\n         }\n         return restApplicationParserFactories;\n     }\n+    \n+    public boolean isGenerateJakartaRs() {\n+        return generateJakartaRsApplicationInterface || generateJakartaRsApplicationClient;\n+    }\n \n     public boolean isGenerateJaxrs() {\n         return generateJaxrsApplicationInterface || generateJaxrsApplicationClient;\n@@ -796,7 +811,7 @@ public boolean isGenerateSpring() {\n     }\n \n     public boolean isGenerateRest() {\n-        return isGenerateJaxrs() || isGenerateSpring();\n+        return isGenerateJakartaRs() || isGenerateJaxrs() || isGenerateSpring();\n     }\n \n     public boolean areDefaultStringEnumsOverriddenByExtension() {"
  },
  {
    "sha": "cedd58dbf078e5d35ac2dda3006aa365ac168ab4",
    "filename": "typescript-generator-core/src/main/java/cz/habarta/typescript/generator/compiler/ModelCompiler.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/vojtechhabarta/typescript-generator/blob/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/compiler/ModelCompiler.java",
    "raw_url": "https://github.com/vojtechhabarta/typescript-generator/raw/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/compiler/ModelCompiler.java",
    "contents_url": "https://api.github.com/repos/vojtechhabarta/typescript-generator/contents/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/compiler/ModelCompiler.java?ref=3de101781cdc5db08b8020b6ee3cb65a984523da",
    "patch": "@@ -637,7 +637,7 @@ private void createRestClients(TsModel tsModel, SymbolTable symbolTable, List<Re\n                 Collections.<TsStatement>emptyList(),\n                 null\n         );\n-        final boolean bothInterfacesAndClients = settings.generateJaxrsApplicationInterface || settings.generateSpringApplicationInterface;\n+        final boolean bothInterfacesAndClients = settings.generateJakartaRsApplicationInterface || settings.generateJaxrsApplicationInterface || settings.generateSpringApplicationInterface;\n         final String groupingSuffix = bothInterfacesAndClients ? null : \"Client\";\n         final Map<Symbol, List<TsMethodModel>> groupedMethods = processRestMethods(tsModel, restApplications, symbolTable, groupingSuffix, responseSymbol, optionsType, true);\n         for (Map.Entry<Symbol, List<TsMethodModel>> entry : groupedMethods.entrySet()) {"
  },
  {
    "sha": "7a6a6020a6a6a9ca87fe3c1645eedf6ea08f8da7",
    "filename": "typescript-generator-core/src/main/java/cz/habarta/typescript/generator/parser/JakartaRsApplicationParser.java",
    "status": "added",
    "additions": 346,
    "deletions": 0,
    "changes": 346,
    "blob_url": "https://github.com/vojtechhabarta/typescript-generator/blob/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/parser/JakartaRsApplicationParser.java",
    "raw_url": "https://github.com/vojtechhabarta/typescript-generator/raw/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/parser/JakartaRsApplicationParser.java",
    "contents_url": "https://api.github.com/repos/vojtechhabarta/typescript-generator/contents/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/parser/JakartaRsApplicationParser.java?ref=3de101781cdc5db08b8020b6ee3cb65a984523da",
    "patch": "@@ -0,0 +1,346 @@\n+\n+package cz.habarta.typescript.generator.parser;\n+\n+import cz.habarta.typescript.generator.JakartaRsApplicationScanner;\n+import cz.habarta.typescript.generator.Settings;\n+import cz.habarta.typescript.generator.TsType;\n+import cz.habarta.typescript.generator.TypeProcessor;\n+import cz.habarta.typescript.generator.TypeScriptGenerator;\n+import cz.habarta.typescript.generator.type.JTypeWithNullability;\n+import cz.habarta.typescript.generator.util.GenericsResolver;\n+import cz.habarta.typescript.generator.util.Pair;\n+import cz.habarta.typescript.generator.util.Utils;\n+import jakarta.ws.rs.ApplicationPath;\n+import jakarta.ws.rs.BeanParam;\n+import jakarta.ws.rs.CookieParam;\n+import jakarta.ws.rs.FormParam;\n+import jakarta.ws.rs.HeaderParam;\n+import jakarta.ws.rs.HttpMethod;\n+import jakarta.ws.rs.MatrixParam;\n+import jakarta.ws.rs.Path;\n+import jakarta.ws.rs.PathParam;\n+import jakarta.ws.rs.QueryParam;\n+import jakarta.ws.rs.container.Suspended;\n+import jakarta.ws.rs.core.Application;\n+import jakarta.ws.rs.core.Context;\n+import jakarta.ws.rs.core.GenericEntity;\n+import jakarta.ws.rs.core.MultivaluedMap;\n+import jakarta.ws.rs.core.Response;\n+import jakarta.ws.rs.core.StreamingOutput;\n+import java.beans.BeanInfo;\n+import java.beans.IntrospectionException;\n+import java.beans.Introspector;\n+import java.beans.PropertyDescriptor;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Parameter;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+public class JakartaRsApplicationParser extends RestApplicationParser {\n+\n+    public static class Factory extends RestApplicationParser.Factory {\n+\n+        @Override\n+        public TypeProcessor getSpecificTypeProcessor() {\n+            return (javaType, context) -> {\n+                final Class<?> rawClass = Utils.getRawClassOrNull(javaType);\n+                if (rawClass != null) {\n+                    for (Map.Entry<Class<?>, TsType> entry : getStandardEntityClassesMapping().entrySet()) {\n+                        final Class<?> cls = entry.getKey();\n+                        final TsType type = entry.getValue();\n+                        if (cls.isAssignableFrom(rawClass)) {\n+                            return type != null ? new TypeProcessor.Result(type) : null;\n+                        }\n+                    }\n+                    if (getDefaultExcludedClassNames().contains(rawClass.getName())) {\n+                        return new TypeProcessor.Result(TsType.Any);\n+                    }\n+                }\n+                return null;\n+            };\n+        }\n+\n+        @Override\n+        public JakartaRsApplicationParser create(Settings settings, TypeProcessor commonTypeProcessor) {\n+            return new JakartaRsApplicationParser(settings, commonTypeProcessor);\n+        }\n+\n+    };\n+\n+    public JakartaRsApplicationParser(Settings settings, TypeProcessor commonTypeProcessor) {\n+        super(settings, commonTypeProcessor, new RestApplicationModel(RestApplicationType.JakartaRs));\n+    }\n+\n+    @Override\n+    public Result tryParse(SourceType<?> sourceType) {\n+        if (!(sourceType.type instanceof Class<?>)) {\n+            return null;\n+        }\n+        final Class<?> cls = (Class<?>) sourceType.type;\n+\n+        // application\n+        if (Application.class.isAssignableFrom(cls)) {\n+            final ApplicationPath applicationPathAnnotation = cls.getAnnotation(ApplicationPath.class);\n+            if (applicationPathAnnotation != null) {\n+                model.setApplicationPath(applicationPathAnnotation.value());\n+            }\n+            model.setApplicationName(cls.getSimpleName());\n+            final List<SourceType<Type>> discoveredTypes = JakartaRsApplicationScanner.scanJakartaRsApplication(cls, isClassNameExcluded);\n+            return new Result(discoveredTypes);\n+        }\n+\n+        // resource\n+        final Path path = cls.getAnnotation(Path.class);\n+        if (path != null) {\n+            TypeScriptGenerator.getLogger().verbose(\"Parsing Jakarta RS resource: \" + cls.getName());\n+            final Result result = new Result();\n+            parseResource(result, new ResourceContext(cls, path.value()), cls);\n+            return result;\n+        }\n+\n+        return null;\n+    }\n+\n+    private void parseResource(Result result, ResourceContext context, Class<?> resourceClass) {\n+        // subContext\n+        final Map<String, Type> pathParamTypes = new LinkedHashMap<>();\n+        for (Field field : resourceClass.getDeclaredFields()) {\n+            final PathParam pathParamAnnotation = field.getAnnotation(PathParam.class);\n+            if (pathParamAnnotation != null) {\n+                pathParamTypes.put(pathParamAnnotation.value(), field.getType());\n+            }\n+        }\n+        final ResourceContext subContext = context.subPathParamTypes(pathParamTypes);\n+        // parse resource methods\n+        final List<Method> methods = Arrays.asList(resourceClass.getMethods());\n+        Collections.sort(methods, Utils.methodComparator());\n+        for (Method method : methods) {\n+            parseResourceMethod(result, subContext, resourceClass, method);\n+        }\n+    }\n+\n+    private void parseResourceMethod(Result result, ResourceContext context, Class<?> resourceClass, Method method) {\n+        final Path pathAnnotation = method.getAnnotation(Path.class);\n+        // subContext\n+        context = context.subPath(pathAnnotation != null ? pathAnnotation.value() : null);\n+        final Map<String, Type> pathParamTypes = new LinkedHashMap<>();\n+        for (Parameter parameter : method.getParameters()) {\n+            final PathParam pathParamAnnotation = parameter.getAnnotation(PathParam.class);\n+            if (pathParamAnnotation != null) {\n+                pathParamTypes.put(pathParamAnnotation.value(), parameter.getParameterizedType());\n+            }\n+        }\n+        context = context.subPathParamTypes(pathParamTypes);\n+        // JAX-RS specification - 3.3 Resource Methods\n+        final HttpMethod httpMethod = getHttpMethod(method);\n+        if (httpMethod != null) {\n+            // swagger\n+            final SwaggerOperation swaggerOperation = settings.ignoreSwaggerAnnotations\n+                    ? new SwaggerOperation()\n+                    : Swagger.parseSwaggerAnnotations(method);\n+            if (swaggerOperation.possibleResponses != null) {\n+                for (SwaggerResponse response : swaggerOperation.possibleResponses) {\n+                    if (response.responseType != null) {\n+                        foundType(result, response.responseType, resourceClass, method.getName());\n+                    }\n+                }\n+            }\n+            if (swaggerOperation.hidden) {\n+                return;\n+            }\n+            // path parameters\n+            final List<MethodParameterModel> pathParams = new ArrayList<>();\n+            final PathTemplate pathTemplate = PathTemplate.parse(context.path);\n+            for (PathTemplate.Part part : pathTemplate.getParts()) {\n+                if (part instanceof PathTemplate.Parameter) {\n+                    final PathTemplate.Parameter parameter = (PathTemplate.Parameter) part;\n+                    final Type type = context.pathParamTypes.get(parameter.getOriginalName());\n+                    final Type paramType = type != null ? type : String.class;\n+                    final Type resolvedParamType = GenericsResolver.resolveType(resourceClass, paramType, method.getDeclaringClass());\n+                    pathParams.add(new MethodParameterModel(parameter.getValidName(), resolvedParamType));\n+                    foundType(result, resolvedParamType, resourceClass, method.getName());\n+                }\n+            }\n+            // query parameters\n+            final List<RestQueryParam> queryParams = new ArrayList<>();\n+            for (Parameter param : method.getParameters()) {\n+                final QueryParam queryParamAnnotation = param.getAnnotation(QueryParam.class);\n+                if (queryParamAnnotation != null) {\n+                    queryParams.add(new RestQueryParam.Single(new MethodParameterModel(queryParamAnnotation.value(), param.getParameterizedType()), false));\n+                    foundType(result, param.getParameterizedType(), resourceClass, method.getName());\n+                }\n+                final BeanParam beanParamAnnotation = param.getAnnotation(BeanParam.class);\n+                if (beanParamAnnotation != null) {\n+                    final Class<?> beanParamClass = param.getType();\n+                    final BeanModel paramBean = getQueryParameters(beanParamClass);\n+                    if (paramBean != null) {\n+                        queryParams.add(new RestQueryParam.Bean(paramBean));\n+                        for (PropertyModel property : paramBean.getProperties()) {\n+                            foundType(result, property.getType(), beanParamClass, property.getName());\n+                        }\n+                    }\n+                }\n+            }\n+            // JAX-RS specification - 3.3.2.1 Entity Parameters\n+            final List<Type> parameterTypes = settings.getTypeParser().getMethodParameterTypes(method);\n+            final List<Pair<Parameter, Type>> parameters = Utils.zip(Arrays.asList(method.getParameters()), parameterTypes);\n+            final MethodParameterModel entityParameter = getEntityParameter(resourceClass, method, parameters);\n+            if (entityParameter != null) {\n+                foundType(result, entityParameter.getType(), resourceClass, method.getName());\n+            }\n+            // JAX-RS specification - 3.3.3 Return Type\n+            final Class<?> returnType = method.getReturnType();\n+            final Type parsedReturnType = settings.getTypeParser().getMethodReturnType(method);\n+            final Type plainReturnType = JTypeWithNullability.getPlainType(parsedReturnType);\n+            final Type modelReturnType;\n+            if (returnType == void.class) {\n+                //for async response also use swagger\n+                if (hasAnyAnnotation(method.getParameters(), Collections.singletonList(Suspended.class))) {\n+                    if (swaggerOperation.responseType != null) {\n+                        modelReturnType = swaggerOperation.responseType;\n+                    } else {\n+                        modelReturnType = Object.class;\n+                    }\n+                } else {\n+                    modelReturnType = returnType;\n+                }\n+            } else if (returnType == Response.class) {\n+                if (swaggerOperation.responseType != null) {\n+                    modelReturnType = swaggerOperation.responseType;\n+                } else {\n+                    modelReturnType = Object.class;\n+                }\n+            } else if (plainReturnType instanceof ParameterizedType && returnType == GenericEntity.class) {\n+                final ParameterizedType parameterizedReturnType = (ParameterizedType) plainReturnType;\n+                modelReturnType = parameterizedReturnType.getActualTypeArguments()[0];\n+            } else {\n+                modelReturnType = parsedReturnType;\n+            }\n+            final Type resolvedModelReturnType = GenericsResolver.resolveType(resourceClass, modelReturnType, method.getDeclaringClass());\n+            foundType(result, resolvedModelReturnType, resourceClass, method.getName());\n+            // comments\n+            final List<String> comments = Swagger.getOperationComments(swaggerOperation);\n+            // create method\n+            model.getMethods().add(new RestMethodModel(resourceClass, method.getName(), resolvedModelReturnType, method,\n+                    context.rootResource, httpMethod.value(), context.path, pathParams, queryParams, entityParameter, comments));\n+        }\n+        // JAX-RS specification - 3.4.1 Sub Resources\n+        if (pathAnnotation != null && httpMethod == null) {\n+            parseResource(result, context, method.getReturnType());\n+        }\n+    }\n+\n+    private static HttpMethod getHttpMethod(Method method) {\n+        for (Annotation annotation : method.getAnnotations()) {\n+            final HttpMethod httpMethodAnnotation = annotation.annotationType().getAnnotation(HttpMethod.class);\n+            if (httpMethodAnnotation != null) {\n+                return httpMethodAnnotation;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static BeanModel getQueryParameters(Class<?> paramBean) {\n+        final List<PropertyModel> properties = new ArrayList<>();\n+        final List<Field> fields = Utils.getAllFields(paramBean);\n+        for (Field field : fields) {\n+            final QueryParam annotation = field.getAnnotation(QueryParam.class);\n+            if (annotation != null) {\n+                properties.add(new PropertyModel(annotation.value(), field.getGenericType(), /*optional*/true, null, field, null, null, null));\n+            }\n+        }\n+        try {\n+            final BeanInfo beanInfo = Introspector.getBeanInfo(paramBean);\n+            for (PropertyDescriptor propertyDescriptor : beanInfo.getPropertyDescriptors()) {\n+                final Method writeMethod = propertyDescriptor.getWriteMethod();\n+                if (writeMethod != null) {\n+                    final QueryParam annotation = writeMethod.getAnnotation(QueryParam.class);\n+                    if (annotation != null) {\n+                        properties.add(new PropertyModel(annotation.value(), propertyDescriptor.getPropertyType(), /*optional*/true, null, writeMethod, null, null, null));\n+                    }\n+                }\n+            }\n+        } catch (IntrospectionException e) {\n+            TypeScriptGenerator.getLogger().warning(String.format(\"Cannot introspect '%s' class: \" + e.getMessage(), paramBean));\n+        }\n+        if (properties.isEmpty()) {\n+            return null;\n+        } else {\n+            return new BeanModel(paramBean, null, null, null, null, null, properties, null);\n+        }\n+    }\n+\n+    private MethodParameterModel getEntityParameter(Class<?> resourceClass, Method method, List<Pair<Parameter, Type>> parameters) {\n+        for (Pair<Parameter, Type> pair : parameters) {\n+            if (!Utils.hasAnyAnnotation(annotationClass -> pair.getValue1().getAnnotation(annotationClass), Arrays.asList(\n+                    MatrixParam.class,\n+                    QueryParam.class,\n+                    PathParam.class,\n+                    CookieParam.class,\n+                    HeaderParam.class,\n+                    Suspended.class,\n+                    Context.class,\n+                    FormParam.class,\n+                    BeanParam.class\n+            ))) {\n+                final Type resolvedType = GenericsResolver.resolveType(resourceClass, pair.getValue2(), method.getDeclaringClass());\n+                return new MethodParameterModel(pair.getValue1().getName(), resolvedType);\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    private static boolean hasAnyAnnotation(Parameter[] parameters, List<Class<? extends Annotation>> annotationClasses) {\n+        return Stream.of(parameters)\n+                .anyMatch(parameter -> Utils.hasAnyAnnotation(parameter::getAnnotation, annotationClasses));\n+    }\n+    \n+    private static Map<Class<?>, TsType> getStandardEntityClassesMapping() {\n+        // JAX-RS specification - 4.2.4 Standard Entity Providers\n+        if (standardEntityClassesMapping == null) {\n+            final Map<Class<?>, TsType> map = new LinkedHashMap<>();\n+            // null value means that class is handled by DefaultTypeProcessor\n+            map.put(byte[].class, TsType.Any);\n+            map.put(java.lang.String.class, null);\n+            map.put(java.io.InputStream.class, TsType.Any);\n+            map.put(java.io.Reader.class, TsType.Any);\n+            map.put(java.io.File.class, TsType.Any);\n+            map.put(javax.activation.DataSource.class, TsType.Any);\n+            map.put(javax.xml.transform.Source.class, TsType.Any);\n+            map.put(javax.xml.bind.JAXBElement.class, null);\n+            map.put(MultivaluedMap.class, TsType.Any);\n+            map.put(StreamingOutput.class, TsType.Any);\n+            map.put(java.lang.Boolean.class, null);\n+            map.put(java.lang.Character.class, null);\n+            map.put(java.lang.Number.class, null);\n+            map.put(long.class, null);\n+            map.put(int.class, null);\n+            map.put(short.class, null);\n+            map.put(byte.class, null);\n+            map.put(double.class, null);\n+            map.put(float.class, null);\n+            map.put(boolean.class, null);\n+            map.put(char.class, null);\n+            standardEntityClassesMapping = map;\n+        }\n+        return standardEntityClassesMapping;\n+    }\n+\n+    private static Map<Class<?>, TsType> standardEntityClassesMapping;\n+\n+    private static List<String> getDefaultExcludedClassNames() {\n+        return Arrays.asList(\n+                \"org.glassfish.jersey.media.multipart.FormDataBodyPart\"\n+        );\n+    }\n+\n+}"
  },
  {
    "sha": "ceb45acaa98370ed460d45df44473fe44c6bb07f",
    "filename": "typescript-generator-core/src/main/java/cz/habarta/typescript/generator/parser/RestApplicationType.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/vojtechhabarta/typescript-generator/blob/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/parser/RestApplicationType.java",
    "raw_url": "https://github.com/vojtechhabarta/typescript-generator/raw/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/parser/RestApplicationType.java",
    "contents_url": "https://api.github.com/repos/vojtechhabarta/typescript-generator/contents/typescript-generator-core/src/main/java/cz/habarta/typescript/generator/parser/RestApplicationType.java?ref=3de101781cdc5db08b8020b6ee3cb65a984523da",
    "patch": "@@ -8,7 +8,8 @@\n public enum RestApplicationType {\n \n     Jaxrs(settings -> settings.generateJaxrsApplicationInterface, settings -> settings.generateJaxrsApplicationClient),\n-    Spring(settings -> settings.generateSpringApplicationInterface, settings -> settings.generateSpringApplicationClient);\n+    Spring(settings -> settings.generateSpringApplicationInterface, settings -> settings.generateSpringApplicationClient),\n+    JakartaRs(settings -> settings.generateJakartaRsApplicationInterface, settings -> settings.generateJakartaRsApplicationClient);\n \n     private RestApplicationType(Function<Settings, Boolean> generateInterface, Function<Settings, Boolean> generateClient) {\n         this.generateInterface = generateInterface;"
  },
  {
    "sha": "253d4e324edb047b3fa5c5c16cb3f1f9a0c9c120",
    "filename": "typescript-generator-core/src/test/java/cz/habarta/typescript/generator/JakartaRsApplicationTest.java",
    "status": "added",
    "additions": 736,
    "deletions": 0,
    "changes": 736,
    "blob_url": "https://github.com/vojtechhabarta/typescript-generator/blob/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/src/test/java/cz/habarta/typescript/generator/JakartaRsApplicationTest.java",
    "raw_url": "https://github.com/vojtechhabarta/typescript-generator/raw/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/src/test/java/cz/habarta/typescript/generator/JakartaRsApplicationTest.java",
    "contents_url": "https://api.github.com/repos/vojtechhabarta/typescript-generator/contents/typescript-generator-core/src/test/java/cz/habarta/typescript/generator/JakartaRsApplicationTest.java?ref=3de101781cdc5db08b8020b6ee3cb65a984523da",
    "patch": "@@ -0,0 +1,736 @@\n+\n+package cz.habarta.typescript.generator;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import cz.habarta.typescript.generator.compiler.ModelCompiler;\n+import cz.habarta.typescript.generator.parser.BeanModel;\n+import cz.habarta.typescript.generator.parser.JakartaRsApplicationParser;\n+import cz.habarta.typescript.generator.parser.Model;\n+import cz.habarta.typescript.generator.parser.SourceType;\n+import cz.habarta.typescript.generator.type.JGenericArrayType;\n+import cz.habarta.typescript.generator.type.JTypeWithNullability;\n+import io.github.classgraph.ClassGraph;\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+import jakarta.ws.rs.ApplicationPath;\n+import jakarta.ws.rs.BeanParam;\n+import jakarta.ws.rs.Consumes;\n+import jakarta.ws.rs.CookieParam;\n+import jakarta.ws.rs.FormParam;\n+import jakarta.ws.rs.GET;\n+import jakarta.ws.rs.HeaderParam;\n+import jakarta.ws.rs.MatrixParam;\n+import jakarta.ws.rs.POST;\n+import jakarta.ws.rs.PUT;\n+import jakarta.ws.rs.Path;\n+import jakarta.ws.rs.PathParam;\n+import jakarta.ws.rs.Produces;\n+import jakarta.ws.rs.QueryParam;\n+import jakarta.ws.rs.container.AsyncResponse;\n+import jakarta.ws.rs.container.Suspended;\n+import jakarta.ws.rs.core.Application;\n+import jakarta.ws.rs.core.Context;\n+import jakarta.ws.rs.core.GenericEntity;\n+import jakarta.ws.rs.core.MediaType;\n+import jakarta.ws.rs.core.MultivaluedMap;\n+import jakarta.ws.rs.core.Response;\n+import jakarta.ws.rs.core.StreamingOutput;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.lang.reflect.Type;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import javax.activation.DataSource;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.dom.DOMSource;\n+import org.glassfish.jersey.jackson.JacksonFeature;\n+import org.glassfish.jersey.jdkhttp.JdkHttpServerFactory;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+@SuppressWarnings(\"unused\")\n+public class JakartaRsApplicationTest {\n+\n+    @Test\n+    public void testReturnedTypesFromApplication() {\n+        final List<SourceType<Type>> sourceTypes = JakartaRsApplicationScanner.scanJakartaRsApplication(TestApplication.class, null);\n+        List<Type> types = getTypes(sourceTypes);\n+        final List<Type> expectedTypes = Arrays.<Type>asList(\n+                TestApplication.class,\n+                TestResource1.class\n+        );\n+        assertHasSameItems(expectedTypes, types);\n+    }\n+\n+    @Test\n+    public void testReturnedTypesFromResource() {\n+        Settings settings = TestUtils.settings();\n+        settings.generateJakartaRsApplicationInterface = true;\n+        \n+        JakartaRsApplicationParser jakartaRsApplicationParser = createJakartaRsApplicationParser(settings);\n+        final JakartaRsApplicationParser.Result result = jakartaRsApplicationParser.tryParse(new SourceType<>(TestResource1.class));\n+        Assert.assertNotNull(result);\n+        List<Type> types = getTypes(result.discoveredTypes);\n+        final List<Type> expectedTypes = Arrays.asList(\n+                A.class,\n+                new TypeReference<List<B>>(){}.getType(),\n+                C.class,\n+                new TypeReference<List<D>>(){}.getType(),\n+                List.class,\n+                E.class,\n+                new TypeReference<List<F>>(){}.getType(),\n+                G.class,\n+                new TypeReference<Map<String, H>>(){}.getType(),\n+                I.class,\n+                JGenericArrayType.of(J[].class),\n+                // types handled by DefaultTypeProcessor\n+                String.class, Boolean.class, Character.class, Number.class, Integer.class, int.class, void.class\n+        );\n+        assertHasSameItems(expectedTypes, types);\n+    }\n+\n+    @Test\n+    public void testWithParsingWithExplicitApplication() {\n+        final List<SourceType<Type>> sourceTypes = JakartaRsApplicationScanner.scanJakartaRsApplication(TestApplication.class, null);\n+        testWithParsing(sourceTypes, true);\n+    }\n+\n+    @Test\n+    public void testWithParsingWithDefaultApplication() {\n+        final List<SourceType<Type>> sourceTypes = JakartaRsApplicationScanner.scanAutomaticJakartaRsApplication(new ClassGraph().enableAllInfo().scan(), null);\n+        testWithParsing(sourceTypes, false);\n+    }\n+\n+    private void testWithParsing(List<SourceType<Type>> types, boolean exactMatch) {\n+        Settings settings = TestUtils.settings();\n+        settings.generateJakartaRsApplicationInterface = true;\n+        \n+        final Model model = new TypeScriptGenerator(settings).getModelParser().parseModel(types);\n+        final ArrayList<Class<?>> classes = new ArrayList<>();\n+        for (BeanModel beanModel : model.getBeans()) {\n+            classes.add(beanModel.getOrigin());\n+        }\n+        final List<Class<?>> expectedClasses = Arrays.asList(\n+                A.class,\n+                B.class,\n+                C.class,\n+                D.class,\n+                E.class,\n+                F.class,\n+                G.class,\n+                H.class,\n+                I.class,\n+                J.class\n+        );\n+        if (exactMatch) {\n+            assertHasSameItems(expectedClasses, classes);\n+        } else {\n+            Assert.assertTrue(classes.containsAll(expectedClasses));\n+        }\n+    }\n+\n+    @Test\n+    public void testExcludedResource() {\n+        final Predicate<String> excludeFilter = Settings.createExcludeFilter(Arrays.asList(\n+                TestResource1.class.getName()\n+        ), null);\n+        final List<SourceType<Type>> sourceTypes = JakartaRsApplicationScanner.scanJakartaRsApplication(TestApplication.class, excludeFilter);\n+        final List<Type> types = getTypes(sourceTypes);\n+        Assert.assertEquals(1, types.size());\n+        Assert.assertTrue(getTypes(sourceTypes).contains(TestApplication.class));\n+    }\n+\n+    @Test\n+    public void testExcludedType() {\n+        final Settings settings = TestUtils.settings();\n+        settings.generateJakartaRsApplicationInterface = true;\n+        \n+        settings.setExcludeFilter(Arrays.asList(\n+                A.class.getName(),\n+                J.class.getName()\n+        ), null);\n+        final JakartaRsApplicationParser jakartaRsApplicationParser = createJakartaRsApplicationParser(settings);\n+        final JakartaRsApplicationParser.Result result = jakartaRsApplicationParser.tryParse(new SourceType<>(TestResource1.class));\n+        Assert.assertNotNull(result);\n+        Assert.assertTrue(!getTypes(result.discoveredTypes).contains(A.class));\n+        Assert.assertTrue(getTypes(result.discoveredTypes).contains(JGenericArrayType.of(J[].class)));\n+    }\n+\n+    private static JakartaRsApplicationParser createJakartaRsApplicationParser(Settings settings) {\n+        final TypeProcessor typeProcessor = new TypeScriptGenerator(settings).getCommonTypeProcessor();\n+        final JakartaRsApplicationParser jakartaRsApplicationParser = new JakartaRsApplicationParser(settings, typeProcessor);\n+        return jakartaRsApplicationParser;\n+    }\n+\n+    private List<Type> getTypes(final List<? extends SourceType<? extends Type>> sourceTypes) {\n+        final List<Type> types = new ArrayList<>();\n+        for (SourceType<? extends Type> sourceType : sourceTypes) {\n+            types.add(JTypeWithNullability.removeNullability(sourceType.type));\n+        }\n+        return types;\n+    }\n+\n+    private static <T> void assertHasSameItems(Collection<? extends T> expected, Collection<? extends T> actual) {\n+        for (T value : expected) {\n+            Assert.assertTrue(\"Value '\" + value + \"' is missing in \" + actual, actual.contains(value));\n+        }\n+        for (T value : actual) {\n+            Assert.assertTrue(\"Value '\" + value + \"' not expected.\", expected.contains(value));\n+        }\n+    }\n+\n+    private static class TestApplication extends Application {\n+        @Override\n+        public Set<Class<?>> getClasses() {\n+            return new LinkedHashSet<>(Arrays.asList(\n+                    TestResource1.class\n+            ));\n+        }\n+    }\n+\n+    @Path(\"test\")\n+    static class TestResource1 {\n+        @GET\n+        public void getVoid() {\n+        }\n+        @GET\n+        public Response getResponse() {\n+            return null;\n+        }\n+        @GET\n+        @Path(\"a\")\n+        public GenericEntity<A> getA() {\n+            return null;\n+        }\n+        @GET\n+        public GenericEntity<List<B>> getB() {\n+            return null;\n+        }\n+        @GET\n+        public C getC() {\n+            return null;\n+        }\n+        @GET\n+        public List<D> getD() {\n+            return null;\n+        }\n+        @SuppressWarnings(\"rawtypes\")\n+        @GET\n+        public List getRawList() {\n+            return null;\n+        }\n+        @GET\n+        @Path(\"e\")\n+        public E getE() {\n+            return null;\n+        }\n+        @Path(\"f\")\n+        public SubResource1 getSubResource1() {\n+            return null;\n+        }\n+        @POST\n+        public void setG(G g) {\n+        }\n+        @POST\n+        public void setHs(Map<String, H> hs) {\n+        }\n+        @POST\n+        public void setI(\n+                @MatrixParam(\"\") String matrixParam,\n+                @QueryParam(\"\") String queryParam,\n+                @PathParam(\"\") String pathParam,\n+                @CookieParam(\"\") String cookieParam,\n+                @Suspended AsyncResponse suspendedParam,\n+                @HeaderParam(\"\") String headerParam,\n+                @Context String context,\n+                @FormParam(\"\") String formParam,\n+                I entityI) {\n+        }\n+        @POST\n+        @ApiOperation(value = \"async\", response = String.class)\n+        public void setAsync(\n+                @Suspended AsyncResponse suspendedParam\n+        ) {\n+        }\n+        @POST\n+        public void setJs(J[] js) {\n+        }\n+        @POST\n+        public void setStandardEntity(byte[] value) {}\n+        @POST\n+        public void setStandardEntity(String value) {}\n+        @POST\n+        public void setStandardEntity(InputStream value) {}\n+        @POST\n+        public void setStandardEntity(Reader value) {}\n+        @POST\n+        public void setStandardEntity(File value) {}\n+        @POST\n+        public void setStandardEntity(DataSource value) {}\n+        @POST\n+        public void setStandardEntity(Source value) {}\n+        @POST\n+        public void setStandardEntity(DOMSource value) {}\n+        @POST\n+        public void setStandardEntity(JAXBElement<?> value) {}\n+        @POST\n+        public void setStandardEntity(MultivaluedMap<String,String> value) {}\n+        @POST\n+        public void setStandardEntity(StreamingOutput value) {}\n+        @POST\n+        public void setStandardEntity(Boolean value) {}\n+        @POST\n+        public void setStandardEntity(Character value) {}\n+        @POST\n+        public void setStandardEntity(Number value) {}\n+        @POST\n+        public void setStandardEntity(Integer value) {}\n+        @POST\n+        public void setStandardEntity(int value) {}\n+    }\n+\n+    private static class SubResource1 {\n+        @GET\n+        public List<F> getFs() {\n+            return null;\n+        }\n+    }\n+\n+    private static class A {}\n+    private static class B {}\n+    private static class C {}\n+    private static class D {}\n+    private static class E {}\n+    private static class F {}\n+    private static class G {}\n+    private static class H {}\n+    private static class I {}\n+    private static class J {}\n+\n+    @Test\n+    public void basicInterfaceTest() {\n+        final Settings settings = TestUtils.settings();\n+        settings.generateJakartaRsApplicationInterface = true;\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(TestResource1.class));\n+        final String errorMessage = \"Unexpected output: \" + output;\n+        Assert.assertTrue(errorMessage, output.contains(\"interface RestApplication\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"getA(): RestResponse<A>;\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"type RestResponse<R> = Promise<R>;\"));\n+        Assert.assertTrue(errorMessage, !output.contains(\"function uriEncoding\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"setAsync(): RestResponse<string>\"));\n+    }\n+\n+    @Test\n+    public void complexInterfaceTest() {\n+        final Settings settings = TestUtils.settings();\n+        settings.generateJakartaRsApplicationInterface = true;\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(OrganizationApplication.class));\n+        final String errorMessage = \"Unexpected output: \" + output;\n+        Assert.assertTrue(errorMessage, output.contains(\"type RestResponse<R> = Promise<R>;\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"interface Organization\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"interface OrganizationApplication\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"HTTP GET /api/organizations/{ organizationCode : [a-z]+ }/{organizationId}\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"getOrganization(organizationCode: string, organizationId: number): RestResponse<Organization>;\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"searchOrganizations(queryParams?: { name?: string; \\\"search-limit\\\"?: number; }): RestResponse<Organization[]>;\"));\n+        Assert.assertTrue(errorMessage, output.replace(\"arg1\", \"organization\").contains(\"setOrganization(organizationCode: string, organizationId: number, organization: Organization): RestResponse<void>;\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"HTTP GET /api/people/{personId}/address/{address-id}\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"getAddress(personId: number, addressId: number): RestResponse<Address>;\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"HTTP GET /api/people/{personId}\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"getPerson(personId: number): RestResponse<Person>;\"));\n+    }\n+\n+    @Test\n+    public void methodNameConflictTest() {\n+        final Settings settings = TestUtils.settings();\n+        settings.generateJakartaRsApplicationInterface = true;\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(NameConflictResource.class));\n+        final String errorMessage = \"Unexpected output: \" + output;\n+        Assert.assertTrue(errorMessage, output.contains(\"interface RestApplication\"));\n+        Assert.assertTrue(errorMessage, output.replace(\"arg0\", \"person\").contains(\"person$POST$conflict(person: Person): RestResponse<Person>;\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"person$GET$conflict(): RestResponse<Person>;\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"person$GET$conflict_search(queryParams?: { search?: string; }): RestResponse<Person>;\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"person$GET$conflict_personId(personId: number): RestResponse<Person>;\"));\n+    }\n+\n+    @Test\n+    public void customizationTest() {\n+        final Settings settings = TestUtils.settings();\n+        settings.generateJakartaRsApplicationInterface = true;\n+        settings.restResponseType = \"AxiosPromise\";\n+        settings.restOptionsType = \"AxiosRequestConfig\";\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(OrganizationApplication.class));\n+        final String errorMessage = \"Unexpected output: \" + output;\n+        Assert.assertTrue(errorMessage, output.contains(\"type RestResponse<R> = AxiosPromise;\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"searchOrganizations(queryParams?: { name?: string; \\\"search-limit\\\"?: number; }, options?: AxiosRequestConfig): RestResponse<Organization[]>;\"));\n+    }\n+\n+    @Test\n+    public void basicClientTest() {\n+        final Settings settings = TestUtils.settings();\n+        settings.outputFileType = TypeScriptFileType.implementationFile;\n+        settings.generateJakartaRsApplicationClient = true;\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(OrganizationApplication.class));\n+        final String errorMessage = \"Unexpected output: \" + output;\n+        // HttpClient\n+        Assert.assertTrue(errorMessage, output.contains(\"interface HttpClient\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"request<R>(requestConfig: { method: string; url: string; queryParams?: any; data?: any; copyFn?: (data: R) => R; }): RestResponse<R>;\"));\n+        // application client\n+        Assert.assertTrue(errorMessage, output.contains(\"class OrganizationApplicationClient\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"getPerson(personId: number): RestResponse<Person>\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"return this.httpClient.request({ method: \\\"GET\\\", url: uriEncoding`api/people/${personId}` });\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"getAddress(personId: number, addressId: number): RestResponse<Address>\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"return this.httpClient.request({ method: \\\"GET\\\", url: uriEncoding`api/people/${personId}/address/${addressId}` });\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"type RestResponse<R> = Promise<R>;\"));\n+        // helper\n+        Assert.assertTrue(errorMessage, output.contains(\"function uriEncoding\"));\n+    }\n+\n+    @Test\n+    public void clientCustomizationTest() {\n+        final Settings settings = TestUtils.settings();\n+        settings.outputFileType = TypeScriptFileType.implementationFile;\n+        settings.generateJakartaRsApplicationClient = true;\n+        settings.restResponseType = \"AxiosPromise\";\n+        settings.restOptionsType = \"AxiosRequestConfig\";\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(OrganizationApplication.class));\n+        final String errorMessage = \"Unexpected output: \" + output;\n+        // HttpClient\n+        Assert.assertTrue(errorMessage, output.contains(\"request<R>(requestConfig: { method: string; url: string; queryParams?: any; data?: any; copyFn?: (data: R) => R; options?: AxiosRequestConfig; }): RestResponse<R>;\"));\n+        // application client\n+        Assert.assertTrue(errorMessage, output.contains(\"class OrganizationApplicationClient\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"getPerson(personId: number, options?: AxiosRequestConfig): RestResponse<Person>\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"return this.httpClient.request({ method: \\\"GET\\\", url: uriEncoding`api/people/${personId}`, options: options });\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"type RestResponse<R> = AxiosPromise;\"));\n+    }\n+\n+    @Test\n+    public void testNamespacingPerResource() {\n+        final Settings settings = TestUtils.settings();\n+        settings.outputFileType = TypeScriptFileType.implementationFile;\n+        settings.generateJakartaRsApplicationInterface = true;\n+        settings.generateJakartaRsApplicationClient = true;\n+        settings.restNamespacing = RestNamespacing.perResource;\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(OrganizationApplication.class));\n+        final String errorMessage = \"Unexpected output: \" + output;\n+        Assert.assertTrue(errorMessage, !output.contains(\"class OrganizationApplicationClient\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"class OrganizationsResourceClient implements OrganizationsResource \"));\n+        Assert.assertTrue(errorMessage, !output.contains(\"class OrganizationResourceClient\"));\n+        Assert.assertTrue(errorMessage, output.contains(\"class PersonResourceClient implements PersonResource \"));\n+    }\n+\n+    @Test\n+    public void testNamespacingByAnnotation() {\n+        final Settings settings = TestUtils.settings();\n+        settings.outputFileType = TypeScriptFileType.implementationFile;\n+        settings.generateJakartaRsApplicationInterface = true;\n+        settings.generateJakartaRsApplicationClient = true;\n+        settings.restNamespacing = RestNamespacing.byAnnotation;\n+        settings.restNamespacingAnnotation = Api.class;\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(OrganizationApplication.class));\n+        final String errorMessage = \"Unexpected output: \" + output;\n+        Assert.assertTrue(errorMessage, output.contains(\"class OrgApiClient implements OrgApi \"));\n+        Assert.assertTrue(errorMessage, output.contains(\"class OrganizationApplicationClient implements OrganizationApplication \"));\n+        Assert.assertTrue(errorMessage, !output.contains(\"class OrganizationsResourceClient\"));\n+        Assert.assertTrue(errorMessage, !output.contains(\"class OrganizationResourceClient\"));\n+        Assert.assertTrue(errorMessage, !output.contains(\"class PersonResourceClient\"));\n+    }\n+\n+    @Test\n+    public void testJavadoc() {\n+        final Settings settings = TestUtils.settings();\n+        settings.outputFileType = TypeScriptFileType.implementationFile;\n+        settings.generateJakartaRsApplicationInterface = true;\n+        settings.javadocXmlFiles = Arrays.asList(new File(\"src/test/javadoc/test-javadoc.xml\"));\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(OrganizationApplication.class));\n+        Assert.assertTrue(output.contains(\"Returns person with specified ID.\"));\n+    }\n+\n+    @Test\n+    public void testSwaggerComments() {\n+        final Settings settings = TestUtils.settings();\n+        settings.outputFileType = TypeScriptFileType.implementationFile;\n+        settings.generateJakartaRsApplicationInterface = true;\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(OrganizationApplication.class));\n+        Assert.assertTrue(output.contains(\"Comment in swagger annotation\"));\n+        Assert.assertTrue(output.contains(\"Response code 200 - ok\"));\n+        Assert.assertTrue(output.contains(\"Response code 400 - not ok\"));\n+    }\n+\n+    @Test\n+    public void testDeprecatedAnnotationComment() {\n+        final Settings settings = TestUtils.settings();\n+        settings.outputFileType = TypeScriptFileType.implementationFile;\n+        settings.generateJakartaRsApplicationInterface = true;\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(OrganizationApplication.class));\n+        Assert.assertTrue(output.contains(\"@deprecated\"));\n+    }\n+\n+    @ApplicationPath(\"api\")\n+    public static class OrganizationApplication extends Application {\n+        @Override\n+        public Set<Class<?>> getClasses() {\n+            return new LinkedHashSet<>(Arrays.asList(\n+                    OrganizationsResource.class,\n+                    PersonResource.class\n+            ));\n+        }\n+    }\n+\n+    @Api(\"OrgApi\")\n+    @Path(\"organizations\")\n+    public static class OrganizationsResource {\n+        @PathParam(\"organizationId\")\n+        protected long organizationId;\n+        @GET\n+        public List<Organization> searchOrganizations(@QueryParam(\"name\") String oranizationName, @QueryParam(\"search-limit\") int searchLimit) {\n+            return null;\n+        }\n+        @Path(\"{ organizationCode : [a-z]+ }/{organizationId}\")\n+        public OrganizationResource getOrganizationResource() {\n+            return null;\n+        }\n+    }\n+\n+    public static class OrganizationResource {\n+        @GET\n+        public Organization getOrganization() {\n+            return null;\n+        }\n+        @PUT\n+        public void setOrganization(@PathParam(\"organizationCode\") String organizationCode, Organization organization) {\n+        }\n+    }\n+\n+    public static class Organization {\n+        public String name;\n+    }\n+\n+    @Path(\"people/{personId}\")\n+    public static class PersonResource {\n+\n+        @PathParam(\"personId\")\n+        protected long personId;\n+\n+        @ApiOperation(value = \"Comment in swagger annotation\")\n+        @ApiResponses({\n+            @ApiResponse(code = 200, message = \"ok\"),\n+            @ApiResponse(code = 400, message = \"not ok\"),\n+        })\n+        @GET\n+        public Person getPerson() {\n+            return null;\n+        }\n+\n+        @GET\n+        @Path(\"address/{address-id}\")\n+        @Deprecated\n+        public Address getAddress(@PathParam(\"address-id\") long addressId) {\n+            return null;\n+        }\n+    }\n+\n+    public static class Person {\n+        public String name;\n+\n+        public Person(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    public static class Address {\n+        public String name;\n+    }\n+\n+    @Path(\"conflict\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public static class NameConflictResource {\n+        @POST\n+        public Person person(Person person) {\n+            return new Person(\"POST\");\n+        }\n+        @GET\n+        public Person person() {\n+            return new Person(\"A\");\n+        }\n+        @GET\n+        @Path(\"search\")\n+        public Person person(@QueryParam(\"search\") String search) {\n+            return new Person(\"B\");\n+        }\n+        @GET\n+        @Path(\"{person-id:.+}\")\n+        public Person person(@PathParam(\"person-id\") long personId) {\n+            return new Person(\"C\");\n+        }\n+    }\n+\n+    @Test\n+    public void testGettingValidIdentifierName() {\n+        Assert.assertEquals(\"foo\", ModelCompiler.getValidIdentifierName(\"foo\"));\n+        Assert.assertEquals(\"personId\", ModelCompiler.getValidIdentifierName(\"person-id\"));\n+        Assert.assertEquals(\"veryLongParameterName\", ModelCompiler.getValidIdentifierName(\"very-long-parameter-name\"));\n+        Assert.assertEquals(\"$nameWithDollar\", ModelCompiler.getValidIdentifierName(\"$nameWithDollar\"));\n+        Assert.assertEquals(\"NameWithManyDashes\", ModelCompiler.getValidIdentifierName(\"-name--with-many---dashes-\"));\n+        Assert.assertEquals(\"a2b3c4\", ModelCompiler.getValidIdentifierName(\"1a2b3c4\"));\n+        Assert.assertEquals(\"a2b3c4\", ModelCompiler.getValidIdentifierName(\"111a2b3c4\"));\n+    }\n+\n+    @Test\n+    public void testEnumQueryParam() {\n+        final Settings settings = TestUtils.settings();\n+        settings.generateJakartaRsApplicationInterface = true;\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(EnumQueryParamResource.class));\n+        Assert.assertTrue(output.contains(\"queryParams?: { target?: TargetEnum; }\"));\n+        Assert.assertTrue(output.contains(\"type TargetEnum = \\\"Target1\\\" | \\\"Target2\\\"\"));\n+    }\n+\n+    @Path(\"enum-query-param\")\n+    public static class EnumQueryParamResource {\n+        @GET\n+        @Path(\"somePath\")\n+        public List<String> getFoo(@QueryParam(\"target\") TargetEnum target) {\n+            return Collections.emptyList();\n+        }\n+    }\n+\n+    public enum TargetEnum {\n+        Target1, Target2\n+    }\n+\n+    @Test\n+    public void testBeanParam() {\n+        final Settings settings = TestUtils.settings();\n+        settings.generateJakartaRsApplicationInterface = true;\n+        settings.generateJakartaRsApplicationClient = true;\n+        settings.outputFileType = TypeScriptFileType.implementationFile;\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(BeanParamResource.class));\n+        Assert.assertTrue(output.contains(\"interface SearchParams1QueryParams\"));\n+        Assert.assertTrue(output.contains(\"interface SearchParams2QueryParams\"));\n+        Assert.assertTrue(output.contains(\"queryParams?: SearchParams1QueryParams & SearchParams2QueryParams & { message?: string; }\"));\n+    }\n+\n+    public static class SearchParams1 {\n+        @QueryParam(\"id\")\n+        private Integer id;\n+\n+        @QueryParam(\"name\")\n+        private String name;\n+    }\n+\n+    public static class SearchParams2 {\n+        private String description;\n+        @QueryParam(\"description\")\n+        public void setDescription(String description) {\n+            this.description = description;\n+        }\n+    }\n+\n+    @Test\n+    public void testPathParameterWithReservedWord() {\n+        final Settings settings = TestUtils.settings();\n+        settings.generateJakartaRsApplicationInterface = true;\n+        settings.generateJakartaRsApplicationClient = true;\n+        settings.outputFileType = TypeScriptFileType.implementationFile;\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(ResourceWithReservedWord.class));\n+        Assert.assertTrue(output.contains(\"getLogs(_class: string): RestResponse<string[]>;\"));\n+        Assert.assertTrue(output.contains(\"getLogs(_class: string): RestResponse<string[]> {\"));\n+        Assert.assertTrue(output.contains(\"uriEncoding`logs/${_class}`\"));\n+    }\n+\n+    @Path(\"\")\n+    public static class ResourceWithReservedWord {\n+\n+        @GET\n+        @Path(\"/logs/{class}\")\n+        public Collection<String> getLogs(@PathParam(\"class\") String clazz) {\n+            return null;\n+        }\n+    }\n+\n+//    http://localhost:9998/bean-param?id=1&name=vh&description=desc&message=hello\n+\n+    @Path(\"bean-param\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public static class BeanParamResource {\n+\n+        @GET\n+        public List<String> getItems(\n+                @BeanParam SearchParams1 params1,\n+                @BeanParam SearchParams2 params2,\n+                @QueryParam(\"message\") String message\n+        ) {\n+            return Collections.emptyList();\n+        }\n+    }\n+\n+    @Test\n+    public void testRegExpInPath() {\n+        final Settings settings = TestUtils.settings();\n+        settings.generateJakartaRsApplicationClient = true;\n+        settings.outputFileType = TypeScriptFileType.implementationFile;\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(RegExpResource.class));\n+        Assert.assertTrue(output.contains(\"getWithId(id: number)\"));\n+        Assert.assertTrue(output.contains(\"url: uriEncoding`objects/${id}`\"));\n+    }\n+\n+    @Path(\"objects\")\n+    public static class RegExpResource {\n+        @GET\n+        @Path(\"{id: [0-9]{1,99}}\")\n+//        @Path(\"{id: [0-9]+}\")\n+        public String getWithId(@PathParam(\"id\") long id) {\n+            return null;\n+        }\n+    }\n+\n+    @Test\n+    public void testGenericResources() {\n+        final Settings settings = TestUtils.settings();\n+        settings.generateJakartaRsApplicationClient = true;\n+        settings.outputFileType = TypeScriptFileType.implementationFile;\n+        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(AccountResource.class));\n+        Assert.assertTrue(!output.contains(\"get(id: ID): RestResponse<ENTITY>\"));\n+        Assert.assertTrue(output.contains(\"get(id: number): RestResponse<AccountDto>\"));\n+        Assert.assertTrue(output.contains(\"interface AccountDto\"));\n+    }\n+\n+    public static class AccountDto {\n+        public Integer id;\n+        public String name;\n+    }\n+\n+    public static interface AbstractCrudResource<ENTITY, ID> {\n+        @GET\n+        @Path(\"{id}\")\n+        public ENTITY get(@PathParam(\"id\") ID id);\n+    }\n+\n+    @Path(\"/account\")\n+    public static interface AccountResource extends AbstractCrudResource<AccountDto, Integer> {\n+        @GET\n+        @Path(\"/test\")\n+        void test();\n+    }\n+\n+    public static void main(String[] args) {\n+        final ResourceConfig config = new ResourceConfig(BeanParamResource.class, JacksonFeature.class);\n+        JdkHttpServerFactory.createHttpServer(URI.create(\"http://localhost:9998/\"), config);\n+        System.out.println(\"Jersey started.\");\n+    }\n+\n+}"
  },
  {
    "sha": "8ac60d139fa7f756f30351a82031d8c1ad47b8ae",
    "filename": "typescript-generator-core/src/test/javadoc/test-javadoc.xml",
    "status": "modified",
    "additions": 43,
    "deletions": 0,
    "changes": 43,
    "blob_url": "https://github.com/vojtechhabarta/typescript-generator/blob/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/src/test/javadoc/test-javadoc.xml",
    "raw_url": "https://github.com/vojtechhabarta/typescript-generator/raw/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-core/src/test/javadoc/test-javadoc.xml",
    "contents_url": "https://api.github.com/repos/vojtechhabarta/typescript-generator/contents/typescript-generator-core/src/test/javadoc/test-javadoc.xml?ref=3de101781cdc5db08b8020b6ee3cb65a984523da",
    "patch": "@@ -2767,6 +2767,49 @@\n                 <type qualified=\"java.lang.String\"/>\n             </field>\n         </class>\n+        <class name=\"JakartaRsApplicationTest.PersonResource\" qualified=\"cz.habarta.typescript.generator.JakartaRsApplicationTest.PersonResource\" scope=\"public\" abstract=\"false\" error=\"false\" exception=\"false\" externalizable=\"false\" included=\"true\" serializable=\"false\">\n+            <class qualified=\"java.lang.Object\"/>\n+            <constructor name=\"PersonResource\" signature=\"()\" qualified=\"cz.habarta.typescript.generator.JakartaRsApplicationTest.PersonResource\" scope=\"public\" final=\"false\" included=\"true\" native=\"false\" synchronized=\"false\" static=\"false\" varArgs=\"false\"/>\n+            <method name=\"getPerson\" signature=\"()\" qualified=\"cz.habarta.typescript.generator.JakartaRsApplicationTest.PersonResource.getPerson\" scope=\"public\" abstract=\"false\" final=\"false\" included=\"true\" native=\"false\" synchronized=\"false\" static=\"false\" varArgs=\"false\">\n+                <comment>Returns person with specified ID.</comment>\n+                <return qualified=\"cz.habarta.typescript.generator.JakartaRsApplicationTest.Person\"/>\n+                <annotation name=\"GET\" qualified=\"javax.ws.rs.GET\"/>\n+            </method>\n+            <method name=\"getAddress\" signature=\"(long)\" qualified=\"cz.habarta.typescript.generator.JakartaRsApplicationTest.PersonResource.getAddress\" scope=\"public\" abstract=\"false\" final=\"false\" included=\"true\" native=\"false\" synchronized=\"false\" static=\"false\" varArgs=\"false\">\n+                <parameter name=\"addressId\">\n+                    <type qualified=\"long\"/>\n+                    <annotation name=\"PathParam\" qualified=\"javax.ws.rs.PathParam\">\n+                        <argument name=\"value\" primitive=\"false\" array=\"false\">\n+                            <type qualified=\"java.lang.String\"/>\n+                            <value>address-id</value>\n+                        </argument>\n+                    </annotation>\n+                </parameter>\n+                <return qualified=\"cz.habarta.typescript.generator.JakartaRsApplicationTest.Address\"/>\n+                <annotation name=\"GET\" qualified=\"javax.ws.rs.GET\"/>\n+                <annotation name=\"Path\" qualified=\"javax.ws.rs.Path\">\n+                    <argument name=\"value\" primitive=\"false\" array=\"false\">\n+                        <type qualified=\"java.lang.String\"/>\n+                        <value>address/{address-id}</value>\n+                    </argument>\n+                </annotation>\n+            </method>\n+            <annotation name=\"Path\" qualified=\"javax.ws.rs.Path\">\n+                <argument name=\"value\" primitive=\"false\" array=\"false\">\n+                    <type qualified=\"java.lang.String\"/>\n+                    <value>people/{personId}</value>\n+                </argument>\n+            </annotation>\n+            <field name=\"personId\" qualified=\"cz.habarta.typescript.generator.JakartaRsApplicationTest.PersonResource.personId\" scope=\"protected\" volatile=\"false\" transient=\"false\" static=\"false\" final=\"false\">\n+                <type qualified=\"long\"/>\n+                <annotation name=\"PathParam\" qualified=\"javax.ws.rs.PathParam\">\n+                    <argument name=\"value\" primitive=\"false\" array=\"false\">\n+                        <type qualified=\"java.lang.String\"/>\n+                        <value>personId</value>\n+                    </argument>\n+                </annotation>\n+            </field>\n+        </class>\n         <class name=\"CustomTypeConversionTest\" qualified=\"cz.habarta.typescript.generator.CustomTypeConversionTest\" scope=\"public\" abstract=\"false\" error=\"false\" exception=\"false\" externalizable=\"false\" included=\"true\" serializable=\"false\">\n             <class qualified=\"java.lang.Object\"/>\n             <constructor name=\"CustomTypeConversionTest\" signature=\"()\" qualified=\"cz.habarta.typescript.generator.CustomTypeConversionTest\" scope=\"public\" final=\"false\" included=\"true\" native=\"false\" synchronized=\"false\" static=\"false\" varArgs=\"false\"/>"
  },
  {
    "sha": "12d43310b36cb8a5985003e6c1b6aa3bd554b652",
    "filename": "typescript-generator-gradle-plugin/src/main/java/cz/habarta/typescript/generator/gradle/GenerateTask.java",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/vojtechhabarta/typescript-generator/blob/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-gradle-plugin/src/main/java/cz/habarta/typescript/generator/gradle/GenerateTask.java",
    "raw_url": "https://github.com/vojtechhabarta/typescript-generator/raw/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-gradle-plugin/src/main/java/cz/habarta/typescript/generator/gradle/GenerateTask.java",
    "contents_url": "https://api.github.com/repos/vojtechhabarta/typescript-generator/contents/typescript-generator-gradle-plugin/src/main/java/cz/habarta/typescript/generator/gradle/GenerateTask.java?ref=3de101781cdc5db08b8020b6ee3cb65a984523da",
    "patch": "@@ -90,6 +90,8 @@\n     public boolean disableTaggedUnions;\n     public boolean generateReadonlyAndWriteonlyJSDocTags;\n     public boolean ignoreSwaggerAnnotations;\n+    public boolean generateJakartaRsApplicationInterface;\n+    public boolean generateJakartaRsApplicationClient;\n     public boolean generateJaxrsApplicationInterface;\n     public boolean generateJaxrsApplicationClient;\n     public boolean generateSpringApplicationInterface;\n@@ -179,6 +181,8 @@ private Settings createSettings(URLClassLoader classLoader) {\n         settings.disableTaggedUnions = disableTaggedUnions;\n         settings.generateReadonlyAndWriteonlyJSDocTags = generateReadonlyAndWriteonlyJSDocTags;\n         settings.ignoreSwaggerAnnotations = ignoreSwaggerAnnotations;\n+        settings.generateJakartaRsApplicationInterface = generateJakartaRsApplicationInterface;\n+        settings.generateJakartaRsApplicationClient = generateJakartaRsApplicationClient;\n         settings.generateJaxrsApplicationInterface = generateJaxrsApplicationInterface;\n         settings.generateJaxrsApplicationClient = generateJaxrsApplicationClient;\n         settings.generateSpringApplicationInterface = generateSpringApplicationInterface;"
  },
  {
    "sha": "9f1613782d57ec1593c7789bdb9b2b619c36b980",
    "filename": "typescript-generator-maven-plugin/src/main/java/cz/habarta/typescript/generator/maven/GenerateMojo.java",
    "status": "modified",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/vojtechhabarta/typescript-generator/blob/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-maven-plugin/src/main/java/cz/habarta/typescript/generator/maven/GenerateMojo.java",
    "raw_url": "https://github.com/vojtechhabarta/typescript-generator/raw/3de101781cdc5db08b8020b6ee3cb65a984523da/typescript-generator-maven-plugin/src/main/java/cz/habarta/typescript/generator/maven/GenerateMojo.java",
    "contents_url": "https://api.github.com/repos/vojtechhabarta/typescript-generator/contents/typescript-generator-maven-plugin/src/main/java/cz/habarta/typescript/generator/maven/GenerateMojo.java?ref=3de101781cdc5db08b8020b6ee3cb65a984523da",
    "patch": "@@ -526,6 +526,18 @@\n      */\n     @Parameter\n     private boolean ignoreSwaggerAnnotations;\n+    \n+    /**\n+     * If <code>true</code> interface for Jakarta-RS REST application will be generated.\n+     */\n+    @Parameter\n+    private boolean generateJakartaRsApplicationInterface;\n+\n+    /**\n+     * If <code>true</code> client for Jakarta-RS REST application will be generated.\n+     */\n+    @Parameter\n+    private boolean generateJakartaRsApplicationClient;\n \n     /**\n      * If <code>true</code> interface for JAX-RS REST application will be generated.\n@@ -937,6 +949,8 @@ private Settings createSettings(URLClassLoader classLoader) {\n         settings.disableTaggedUnions = disableTaggedUnions;\n         settings.generateReadonlyAndWriteonlyJSDocTags = generateReadonlyAndWriteonlyJSDocTags;\n         settings.ignoreSwaggerAnnotations = ignoreSwaggerAnnotations;\n+        settings.generateJakartaRsApplicationInterface = generateJakartaRsApplicationInterface;\n+        settings.generateJakartaRsApplicationClient = generateJakartaRsApplicationClient;\n         settings.generateJaxrsApplicationInterface = generateJaxrsApplicationInterface;\n         settings.generateJaxrsApplicationClient = generateJaxrsApplicationClient;\n         settings.generateSpringApplicationInterface = generateSpringApplicationInterface;"
  }
]
