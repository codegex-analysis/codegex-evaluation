[
  {
    "sha": "233f590801aa570122e1296732026952eac98a20",
    "filename": "app/build.gradle",
    "status": "modified",
    "additions": 11,
    "deletions": 6,
    "changes": 17,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/build.gradle",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/build.gradle",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/build.gradle?ref=8e0d0d81ede9bdb136251bc6f7d497697f16d6e0",
    "patch": "@@ -109,9 +109,12 @@ ext {\n     roomVersion = '2.2.5'\n     bouncyCastleVersion = '1.66'\n     awaitilityVersion = \"3.1.6\"\n+    androidMaterialVersion = \"1.3.0\"\n+    androidXFragmentVersion = \"1.3.0\"\n+    androidXAppCompatVersion = \"1.2.0\"\n     androidXTestVersion = \"1.3.0\"\n     androidXTestExtVersion = \"1.1.2\"\n-    junitVersion = \"4.13\"\n+    junitVersion = \"4.13.2\"\n     slf4jVersion = \"1.7.25\"\n     mockitoVersion = \"3.4.4\"\n     androidBillingVersion = \"2.1.0\"\n@@ -125,9 +128,10 @@ dependencies {\n \n     implementation 'androidx.vectordrawable:vectordrawable-animated:1.1.0'\n     implementation 'androidx.legacy:legacy-support-v13:1.0.0'\n-    implementation 'com.google.android.material:material:1.1.0'\n-    implementation 'androidx.appcompat:appcompat:1.1.0'\n-    implementation 'androidx.palette:palette:1.0.0'\n+    implementation \"com.google.android.material:material:$androidMaterialVersion\"\n+    implementation \"androidx.fragment:fragment-ktx:$androidXFragmentVersion\"\n+    implementation \"androidx.appcompat:appcompat:$androidXAppCompatVersion\"\n+    implementation 'androidx.palette:palette-ktx:1.0.0'\n     implementation 'androidx.cardview:cardview:1.0.0'\n     implementation \"androidx.room:room-runtime:$roomVersion\"\n     implementation \"com.android.billingclient:billing:$androidBillingVersion\"\n@@ -150,10 +154,11 @@ dependencies {\n     testImplementation \"org.apache.sshd:sshd-core:1.7.0\"\n     testImplementation \"org.awaitility:awaitility:$awaitilityVersion\"\n     testImplementation 'org.jsoup:jsoup:1.11.2'\n-    testAnnotationProcessor \"com.google.auto.service:auto-service:1.0-rc4\"\n+    testImplementation 'commons-net:commons-net:3.6'\n+    kaptTest \"com.google.auto.service:auto-service:1.0-rc4\"\n \n     androidTestImplementation \"junit:junit:$junitVersion\"//tests the app logic\n-    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n+    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'\n     androidTestImplementation \"androidx.test:core:$androidXTestVersion\"\n     androidTestImplementation \"androidx.test:runner:$androidXTestVersion\"\n     androidTestImplementation \"androidx.test:rules:$androidXTestVersion\""
  },
  {
    "sha": "29d8af7a47ca8f1172a90b99ea56894f673b40d9",
    "filename": "app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpReceiver.java",
    "status": "removed",
    "additions": 0,
    "deletions": 49,
    "changes": 49,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/18ecde732fe93b5f10e8eed071dffda790050277/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpReceiver.java",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/18ecde732fe93b5f10e8eed071dffda790050277/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpReceiver.java",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpReceiver.java?ref=18ecde732fe93b5f10e8eed071dffda790050277",
    "patch": "@@ -1,49 +0,0 @@\n-/*\n- * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,\n- * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.\n- *\n- * This file is part of Amaze File Manager.\n- *\n- * Amaze File Manager is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- * GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License\n- * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.amaze.filemanager.asynchronous.services.ftp;\n-\n-/** Created by yashwanthreddyg on 09-06-2016. */\n-import android.content.BroadcastReceiver;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.util.Log;\n-\n-public class FtpReceiver extends BroadcastReceiver {\n-\n-  static final String TAG = FtpReceiver.class.getSimpleName();\n-\n-  @Override\n-  public void onReceive(Context context, Intent intent) {\n-    Log.v(TAG, \"Received: \" + intent.getAction());\n-\n-    try {\n-      Intent service = new Intent(context, FtpService.class);\n-      service.putExtras(intent);\n-      if (intent.getAction().equals(FtpService.ACTION_START_FTPSERVER) && !FtpService.isRunning()) {\n-        context.startService(service);\n-      } else if (intent.getAction().equals(FtpService.ACTION_STOP_FTPSERVER)) {\n-        context.stopService(service);\n-      }\n-    } catch (Exception e) {\n-      Log.e(TAG, \"Failed to start/stop on intent \" + e.getMessage());\n-    }\n-  }\n-}"
  },
  {
    "sha": "bee0985693f292816c724618f435df57a56e8c2a",
    "filename": "app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpReceiver.kt",
    "status": "added",
    "additions": 51,
    "deletions": 0,
    "changes": 51,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpReceiver.kt",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpReceiver.kt",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpReceiver.kt?ref=8e0d0d81ede9bdb136251bc6f7d497697f16d6e0",
    "patch": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,\n+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.\n+ *\n+ * This file is part of Amaze File Manager.\n+ *\n+ * Amaze File Manager is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.amaze.filemanager.asynchronous.services.ftp\n+\n+import android.content.BroadcastReceiver\n+import android.content.Context\n+import android.content.Intent\n+import android.util.Log\n+import com.amaze.filemanager.BuildConfig.DEBUG\n+import com.amaze.filemanager.asynchronous.services.ftp.FtpService.Companion.isRunning\n+\n+/** Created by yashwanthreddyg on 09-06-2016.  */\n+class FtpReceiver : BroadcastReceiver() {\n+\n+    private val TAG = FtpReceiver::class.java.simpleName\n+\n+    override fun onReceive(context: Context, intent: Intent) {\n+        if (DEBUG) {\n+            Log.v(TAG, \"Received: ${intent.action}\")\n+        }\n+        val service = Intent(context, FtpService::class.java)\n+        service.putExtras(intent)\n+        runCatching {\n+            if (intent.action == FtpService.ACTION_START_FTPSERVER && !isRunning()) {\n+                context.startService(service)\n+            } else if (intent.action == FtpService.ACTION_STOP_FTPSERVER) {\n+                context.stopService(service)\n+            } else Unit\n+        }.onFailure {\n+            Log.e(TAG, \"Failed to start/stop on intent ${it.message}\")\n+        }\n+    }\n+}"
  },
  {
    "sha": "f0da431db259bd54de74d7af3e4a4f59238ffe46",
    "filename": "app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.java",
    "status": "removed",
    "additions": 0,
    "deletions": 405,
    "changes": 405,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/18ecde732fe93b5f10e8eed071dffda790050277/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.java",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/18ecde732fe93b5f10e8eed071dffda790050277/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.java",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.java?ref=18ecde732fe93b5f10e8eed071dffda790050277",
    "patch": "@@ -1,405 +0,0 @@\n-/*\n- * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,\n- * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.\n- *\n- * This file is part of Amaze File Manager.\n- *\n- * Amaze File Manager is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- * GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License\n- * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.amaze.filemanager.asynchronous.services.ftp;\n-\n-/**\n- * Created by yashwanthreddyg on 09-06-2016.\n- *\n- * <p>Edited by zent-co on 30-07-2019 Edited by bowiechen on 2019-10-19.\n- */\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.net.InetAddress;\n-import java.net.NetworkInterface;\n-import java.net.SocketException;\n-import java.net.UnknownHostException;\n-import java.security.GeneralSecurityException;\n-import java.security.KeyStore;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-\n-import javax.net.ssl.KeyManagerFactory;\n-import javax.net.ssl.TrustManagerFactory;\n-\n-import org.apache.ftpserver.ConnectionConfigFactory;\n-import org.apache.ftpserver.FtpServer;\n-import org.apache.ftpserver.FtpServerFactory;\n-import org.apache.ftpserver.ftplet.FtpException;\n-import org.apache.ftpserver.listener.ListenerFactory;\n-import org.apache.ftpserver.ssl.ClientAuth;\n-import org.apache.ftpserver.ssl.impl.DefaultSslConfiguration;\n-import org.apache.ftpserver.usermanager.impl.BaseUser;\n-import org.apache.ftpserver.usermanager.impl.WritePermission;\n-import org.greenrobot.eventbus.EventBus;\n-\n-import com.amaze.filemanager.R;\n-import com.amaze.filemanager.filesystem.files.CryptUtil;\n-import com.amaze.filemanager.ui.notifications.FtpNotification;\n-import com.amaze.filemanager.ui.notifications.NotificationConstants;\n-import com.amaze.filemanager.utils.ObtainableServiceBinder;\n-\n-import android.app.AlarmManager;\n-import android.app.Notification;\n-import android.app.PendingIntent;\n-import android.app.Service;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.SharedPreferences;\n-import android.net.ConnectivityManager;\n-import android.net.NetworkInfo;\n-import android.net.wifi.WifiManager;\n-import android.os.Environment;\n-import android.os.IBinder;\n-import android.os.SystemClock;\n-import android.preference.PreferenceManager;\n-import android.widget.Toast;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-\n-public class FtpService extends Service implements Runnable {\n-\n-  public static final int DEFAULT_PORT = 2211;\n-  public static final String DEFAULT_USERNAME = \"\";\n-  public static final int DEFAULT_TIMEOUT = 600; // default timeout, in sec\n-  public static final boolean DEFAULT_SECURE = true;\n-  public static final String PORT_PREFERENCE_KEY = \"ftpPort\";\n-  public static final String KEY_PREFERENCE_PATH = \"ftp_path\";\n-  public static final String KEY_PREFERENCE_USERNAME = \"ftp_username\";\n-  public static final String KEY_PREFERENCE_PASSWORD = \"ftp_password_encrypted\";\n-  public static final String KEY_PREFERENCE_TIMEOUT = \"ftp_timeout\";\n-  public static final String KEY_PREFERENCE_SECURE = \"ftp_secure\";\n-  public static final String KEY_PREFERENCE_READONLY = \"ftp_readonly\";\n-  public static final String DEFAULT_PATH =\n-      Environment.getExternalStorageDirectory().getAbsolutePath();\n-  public static final String INITIALS_HOST_FTP = \"ftp://\";\n-  public static final String INITIALS_HOST_SFTP = \"ftps://\";\n-\n-  private final IBinder binder = new ObtainableServiceBinder<>(this);\n-\n-  private static final String WIFI_AP_ADDRESS_PREFIX = \"192.168.43.\";\n-  private static final char[] KEYSTORE_PASSWORD = \"vishal007\".toCharArray();\n-\n-  // Service will broadcast via event bus when server start/stop\n-  public enum FtpReceiverActions {\n-    STARTED,\n-    STARTED_FROM_TILE,\n-    STOPPED,\n-    FAILED_TO_START\n-  }\n-\n-  // RequestStartStopReceiver listens for these actions to start/stop this server\n-  public static final String ACTION_START_FTPSERVER =\n-      \"com.amaze.filemanager.services.ftpservice.FTPReceiver.ACTION_START_FTPSERVER\";\n-  public static final String ACTION_STOP_FTPSERVER =\n-      \"com.amaze.filemanager.services.ftpservice.FTPReceiver.ACTION_STOP_FTPSERVER\";\n-\n-  public static final String TAG_STARTED_BY_TILE =\n-      \"started_by_tile\"; // attribute of action_started, used by notification\n-\n-  private String username, password;\n-  private boolean isPasswordProtected = false;\n-\n-  private FtpServer server;\n-  protected static Thread serverThread = null;\n-\n-  private boolean isStartedByTile = false;\n-\n-  @Override\n-  public int onStartCommand(Intent intent, int flags, int startId) {\n-    isStartedByTile = intent.getBooleanExtra(TAG_STARTED_BY_TILE, false);\n-    int attempts = 10;\n-    while (serverThread != null) {\n-      if (attempts > 0) {\n-        attempts--;\n-        try {\n-          Thread.sleep(1000);\n-        } catch (InterruptedException ignored) {\n-        }\n-      } else {\n-        return START_STICKY;\n-      }\n-    }\n-\n-    serverThread = new Thread(this);\n-    serverThread.start();\n-\n-    Notification notification =\n-        FtpNotification.startNotification(getApplicationContext(), isStartedByTile);\n-\n-    startForeground(NotificationConstants.FTP_ID, notification);\n-\n-    return START_NOT_STICKY;\n-  }\n-\n-  @Override\n-  public IBinder onBind(Intent intent) {\n-    return binder;\n-  }\n-\n-  @Override\n-  public void run() {\n-    SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this);\n-\n-    FtpServerFactory serverFactory = new FtpServerFactory();\n-    ConnectionConfigFactory connectionConfigFactory = new ConnectionConfigFactory();\n-    connectionConfigFactory.setAnonymousLoginEnabled(true);\n-\n-    serverFactory.setConnectionConfig(connectionConfigFactory.createConnectionConfig());\n-\n-    String usernamePreference = preferences.getString(KEY_PREFERENCE_USERNAME, DEFAULT_USERNAME);\n-    if (!usernamePreference.equals(DEFAULT_USERNAME)) {\n-      username = usernamePreference;\n-      try {\n-        password =\n-            CryptUtil.decryptPassword(\n-                getApplicationContext(), preferences.getString(KEY_PREFERENCE_PASSWORD, \"\"));\n-        isPasswordProtected = true;\n-      } catch (GeneralSecurityException | IOException e) {\n-        e.printStackTrace();\n-\n-        Toast.makeText(\n-                getApplicationContext(),\n-                getResources().getString(R.string.error),\n-                Toast.LENGTH_SHORT)\n-            .show();\n-        // can't decrypt the password saved in preferences, remove the preference altogether\n-        // and start an anonymous connection instead\n-        preferences.edit().putString(FtpService.KEY_PREFERENCE_PASSWORD, \"\").apply();\n-        isPasswordProtected = false;\n-      }\n-    }\n-\n-    BaseUser user = new BaseUser();\n-    if (!isPasswordProtected) {\n-      user.setName(\"anonymous\");\n-    } else {\n-      user.setName(username);\n-      user.setPassword(password);\n-    }\n-\n-    user.setHomeDirectory(preferences.getString(KEY_PREFERENCE_PATH, DEFAULT_PATH));\n-    if (!preferences.getBoolean(KEY_PREFERENCE_READONLY, false)) {\n-      user.setAuthorities(Collections.singletonList(new WritePermission()));\n-    }\n-    try {\n-      serverFactory.getUserManager().save(user);\n-    } catch (FtpException e) {\n-      e.printStackTrace();\n-    }\n-    ListenerFactory fac = new ListenerFactory();\n-\n-    if (preferences.getBoolean(KEY_PREFERENCE_SECURE, DEFAULT_SECURE)) {\n-\n-      try {\n-        KeyStore keyStore = KeyStore.getInstance(\"BKS\");\n-        keyStore.load(getResources().openRawResource(R.raw.key), KEYSTORE_PASSWORD);\n-\n-        KeyManagerFactory keyManagerFactory =\n-            KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n-        keyManagerFactory.init(keyStore, KEYSTORE_PASSWORD);\n-\n-        TrustManagerFactory trustManagerFactory =\n-            TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n-        trustManagerFactory.init(keyStore);\n-\n-        fac.setSslConfiguration(\n-            new DefaultSslConfiguration(\n-                keyManagerFactory, trustManagerFactory, ClientAuth.WANT, \"TLS\", null, \"ftpserver\"));\n-        fac.setImplicitSsl(true);\n-      } catch (GeneralSecurityException | IOException e) {\n-        preferences.edit().putBoolean(KEY_PREFERENCE_SECURE, false).apply();\n-      }\n-    }\n-\n-    fac.setPort(getPort(preferences));\n-    fac.setIdleTimeout(preferences.getInt(KEY_PREFERENCE_TIMEOUT, DEFAULT_TIMEOUT));\n-\n-    serverFactory.addListener(\"default\", fac.createListener());\n-    try {\n-      server = serverFactory.createServer();\n-      server.start();\n-      EventBus.getDefault()\n-          .post(\n-              isStartedByTile ? FtpReceiverActions.STARTED_FROM_TILE : FtpReceiverActions.STARTED);\n-    } catch (Exception e) {\n-      EventBus.getDefault().post(FtpReceiverActions.FAILED_TO_START);\n-    }\n-  }\n-\n-  @Override\n-  public void onDestroy() {\n-    if (serverThread == null) {\n-      return;\n-    }\n-    serverThread.interrupt();\n-    try {\n-      serverThread.join(10000); // wait 10 sec for server thread to finish\n-    } catch (InterruptedException e) {\n-    }\n-    if (!serverThread.isAlive()) {\n-      serverThread = null;\n-    }\n-    if (server != null) {\n-      server.stop();\n-      EventBus.getDefault().post(FtpReceiverActions.STOPPED);\n-    }\n-  }\n-\n-  // Restart the service if the app is closed from the recent list\n-  @Override\n-  public void onTaskRemoved(Intent rootIntent) {\n-    super.onTaskRemoved(rootIntent);\n-\n-    Intent restartService = new Intent(getApplicationContext(), this.getClass());\n-    restartService.setPackage(getPackageName());\n-    PendingIntent restartServicePI =\n-        PendingIntent.getService(\n-            getApplicationContext(), 1, restartService, PendingIntent.FLAG_ONE_SHOT);\n-    AlarmManager alarmService =\n-        (AlarmManager) getApplicationContext().getSystemService(Context.ALARM_SERVICE);\n-    alarmService.set(\n-        AlarmManager.ELAPSED_REALTIME, SystemClock.elapsedRealtime() + 2000, restartServicePI);\n-  }\n-\n-  public static boolean isRunning() {\n-    return serverThread != null;\n-  }\n-\n-  public static boolean isConnectedToLocalNetwork(Context context) {\n-    ConnectivityManager cm =\n-        (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n-    boolean connected = false;\n-    NetworkInfo ni = cm.getActiveNetworkInfo();\n-    connected =\n-        ni != null\n-            && ni.isConnected()\n-            && (ni.getType() & (ConnectivityManager.TYPE_WIFI | ConnectivityManager.TYPE_ETHERNET))\n-                != 0;\n-    if (!connected) {\n-      try {\n-        for (NetworkInterface netInterface :\n-            Collections.list(NetworkInterface.getNetworkInterfaces())) {\n-          if (netInterface.getDisplayName().startsWith(\"rndis\")) {\n-            connected = true;\n-          }\n-        }\n-      } catch (SocketException e) {\n-        e.printStackTrace();\n-      }\n-    }\n-    return connected;\n-  }\n-\n-  public static boolean isConnectedToWifi(Context context) {\n-    ConnectivityManager cm =\n-        (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n-    @Nullable NetworkInfo ni = cm.getActiveNetworkInfo();\n-    return ni != null && ni.isConnected() && ni.getType() == ConnectivityManager.TYPE_WIFI;\n-  }\n-\n-  public static boolean isEnabledWifiHotspot(Context context) {\n-    WifiManager wm =\n-        (WifiManager) context.getApplicationContext().getSystemService(Context.WIFI_SERVICE);\n-    Boolean enabled = callIsWifiApEnabled(wm);\n-    return enabled != null ? enabled : false;\n-  }\n-\n-  @Nullable\n-  public static InetAddress getLocalInetAddress(Context context) {\n-    if (!isConnectedToLocalNetwork(context) && !isEnabledWifiHotspot(context)) {\n-      return null;\n-    }\n-\n-    if (isConnectedToWifi(context)) {\n-      WifiManager wm =\n-          (WifiManager) context.getApplicationContext().getSystemService(Context.WIFI_SERVICE);\n-      int ipAddress = wm.getConnectionInfo().getIpAddress();\n-      if (ipAddress == 0) return null;\n-      return intToInet(ipAddress);\n-    }\n-\n-    try {\n-      Enumeration<NetworkInterface> netinterfaces = NetworkInterface.getNetworkInterfaces();\n-      while (netinterfaces.hasMoreElements()) {\n-        NetworkInterface netinterface = netinterfaces.nextElement();\n-        Enumeration<InetAddress> addresses = netinterface.getInetAddresses();\n-        while (addresses.hasMoreElements()) {\n-          InetAddress address = addresses.nextElement();\n-          if (address == null) {\n-            continue;\n-          }\n-\n-          if (address.getHostAddress().startsWith(WIFI_AP_ADDRESS_PREFIX)\n-              && isEnabledWifiHotspot(context)) return address;\n-\n-          // this is the condition that sometimes gives problems\n-          if (!address.isLoopbackAddress()\n-              && !address.isLinkLocalAddress()\n-              && !isEnabledWifiHotspot(context)) return address;\n-        }\n-      }\n-    } catch (SocketException e) {\n-      e.printStackTrace();\n-    }\n-    return null;\n-  }\n-\n-  private static InetAddress intToInet(int value) {\n-    byte[] bytes = new byte[4];\n-    for (int i = 0; i < 4; i++) {\n-      bytes[i] = byteOfInt(value, i);\n-    }\n-    try {\n-      return InetAddress.getByAddress(bytes);\n-    } catch (UnknownHostException e) {\n-      // This only happens if the byte array has a bad length\n-      return null;\n-    }\n-  }\n-\n-  private static byte byteOfInt(int value, int which) {\n-    int shift = which * 8;\n-    return (byte) (value >> shift);\n-  }\n-\n-  private static int getPort(SharedPreferences preferences) {\n-    return preferences.getInt(PORT_PREFERENCE_KEY, DEFAULT_PORT);\n-  }\n-\n-  @Nullable\n-  private static Boolean callIsWifiApEnabled(@NonNull WifiManager wifiManager) {\n-    Boolean r = null;\n-    try {\n-      Method method = wifiManager.getClass().getDeclaredMethod(\"isWifiApEnabled\");\n-      r = (Boolean) method.invoke(wifiManager);\n-    } catch (NoSuchMethodException e) {\n-      e.printStackTrace();\n-    } catch (IllegalAccessException e) {\n-      e.printStackTrace();\n-    } catch (InvocationTargetException e) {\n-      e.printStackTrace();\n-    }\n-\n-    return r;\n-  }\n-}"
  },
  {
    "sha": "40d87fa9b78672c2ca4fd4e60085838ef13072c6",
    "filename": "app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.kt",
    "status": "added",
    "additions": 392,
    "deletions": 0,
    "changes": 392,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.kt",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.kt",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.kt?ref=8e0d0d81ede9bdb136251bc6f7d497697f16d6e0",
    "patch": "@@ -0,0 +1,392 @@\n+/*\n+ * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,\n+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.\n+ *\n+ * This file is part of Amaze File Manager.\n+ *\n+ * Amaze File Manager is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.amaze.filemanager.asynchronous.services.ftp\n+\n+import android.app.AlarmManager\n+import android.app.PendingIntent\n+import android.app.Service\n+import android.content.Context\n+import android.content.Intent\n+import android.content.SharedPreferences\n+import android.net.ConnectivityManager\n+import android.net.NetworkCapabilities\n+import android.net.wifi.WifiManager\n+import android.os.Build\n+import android.os.Build.VERSION_CODES.KITKAT\n+import android.os.Build.VERSION_CODES.M\n+import android.os.Environment\n+import android.os.IBinder\n+import android.os.SystemClock\n+import android.preference.PreferenceManager\n+import com.amaze.filemanager.R\n+import com.amaze.filemanager.application.AppConfig\n+import com.amaze.filemanager.filesystem.files.CryptUtil\n+import com.amaze.filemanager.filesystem.ftpserver.AndroidFileSystemFactory\n+import com.amaze.filemanager.ui.notifications.FtpNotification\n+import com.amaze.filemanager.ui.notifications.NotificationConstants\n+import com.amaze.filemanager.utils.ObtainableServiceBinder\n+import org.apache.ftpserver.ConnectionConfigFactory\n+import org.apache.ftpserver.FtpServer\n+import org.apache.ftpserver.FtpServerFactory\n+import org.apache.ftpserver.listener.ListenerFactory\n+import org.apache.ftpserver.ssl.ClientAuth\n+import org.apache.ftpserver.ssl.impl.DefaultSslConfiguration\n+import org.apache.ftpserver.usermanager.impl.BaseUser\n+import org.apache.ftpserver.usermanager.impl.WritePermission\n+import org.greenrobot.eventbus.EventBus\n+import java.io.IOException\n+import java.net.InetAddress\n+import java.net.NetworkInterface\n+import java.net.UnknownHostException\n+import java.security.GeneralSecurityException\n+import java.security.KeyStore\n+import java.util.*\n+import javax.net.ssl.KeyManagerFactory\n+import javax.net.ssl.TrustManagerFactory\n+\n+/**\n+ * Created by yashwanthreddyg on 09-06-2016.\n+ *\n+ *\n+ * Edited by zent-co on 30-07-2019 Edited by bowiechen on 2019-10-19.\n+ */\n+class FtpService : Service(), Runnable {\n+    private val binder: IBinder = ObtainableServiceBinder(this)\n+\n+    // Service will broadcast via event bus when server start/stop\n+    enum class FtpReceiverActions {\n+        STARTED, STARTED_FROM_TILE, STOPPED, FAILED_TO_START\n+    }\n+\n+    private var username: String? = null\n+    private var password: String? = null\n+    private var isPasswordProtected = false\n+    private var server: FtpServer? = null\n+    private var isStartedByTile = false\n+\n+    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {\n+        isStartedByTile = intent.getBooleanExtra(TAG_STARTED_BY_TILE, false)\n+        var attempts = 10\n+        while (serverThread != null) {\n+            if (attempts > 0) {\n+                attempts--\n+                try {\n+                    Thread.sleep(1000)\n+                } catch (ignored: InterruptedException) {\n+                }\n+            } else {\n+                return START_STICKY\n+            }\n+        }\n+        serverThread = Thread(this)\n+        serverThread!!.start()\n+        val notification = FtpNotification.startNotification(applicationContext, isStartedByTile)\n+        startForeground(NotificationConstants.FTP_ID, notification)\n+        return START_NOT_STICKY\n+    }\n+\n+    override fun onBind(intent: Intent): IBinder {\n+        return binder\n+    }\n+\n+    @Suppress(\"LongMethod\")\n+    override fun run() {\n+        val preferences = PreferenceManager.getDefaultSharedPreferences(this)\n+        FtpServerFactory().run {\n+            val connectionConfigFactory = ConnectionConfigFactory()\n+            if (Build.VERSION.SDK_INT >= KITKAT) {\n+                fileSystem = AndroidFileSystemFactory(applicationContext)\n+            }\n+\n+            val usernamePreference = preferences.getString(\n+                KEY_PREFERENCE_USERNAME,\n+                DEFAULT_USERNAME\n+            )\n+            if (usernamePreference != DEFAULT_USERNAME) {\n+                username = usernamePreference\n+                runCatching {\n+                    password = CryptUtil.decryptPassword(\n+                        applicationContext, preferences.getString(KEY_PREFERENCE_PASSWORD, \"\")\n+                    )\n+                    isPasswordProtected = true\n+                }.onFailure {\n+                    it.printStackTrace()\n+                    AppConfig.toast(applicationContext, R.string.error)\n+                    preferences.edit().putString(KEY_PREFERENCE_PASSWORD, \"\").apply()\n+                    isPasswordProtected = false\n+                }\n+            }\n+            val user = BaseUser()\n+            if (!isPasswordProtected) {\n+                user.name = \"anonymous\"\n+                connectionConfigFactory.isAnonymousLoginEnabled = true\n+            } else {\n+                user.name = username\n+                user.password = password\n+            }\n+            user.homeDirectory = preferences.getString(KEY_PREFERENCE_PATH, DEFAULT_PATH)\n+            if (!preferences.getBoolean(KEY_PREFERENCE_READONLY, false)) {\n+                user.authorities = listOf(WritePermission())\n+            }\n+\n+            connectionConfig = connectionConfigFactory.createConnectionConfig()\n+            userManager.save(user)\n+\n+            val fac = ListenerFactory()\n+            if (preferences.getBoolean(KEY_PREFERENCE_SECURE, DEFAULT_SECURE)) {\n+                try {\n+                    val keyStore = KeyStore.getInstance(\"BKS\")\n+                    keyStore.load(resources.openRawResource(R.raw.key), KEYSTORE_PASSWORD)\n+                    val keyManagerFactory = KeyManagerFactory\n+                        .getInstance(KeyManagerFactory.getDefaultAlgorithm())\n+                    keyManagerFactory.init(keyStore, KEYSTORE_PASSWORD)\n+                    val trustManagerFactory = TrustManagerFactory\n+                        .getInstance(TrustManagerFactory.getDefaultAlgorithm())\n+                    trustManagerFactory.init(keyStore)\n+                    fac.sslConfiguration = DefaultSslConfiguration(\n+                        keyManagerFactory,\n+                        trustManagerFactory,\n+                        ClientAuth.WANT,\n+                        \"TLS\",\n+                        null,\n+                        \"ftpserver\"\n+                    )\n+                    fac.isImplicitSsl = true\n+                } catch (e: GeneralSecurityException) {\n+                    preferences.edit().putBoolean(KEY_PREFERENCE_SECURE, false).apply()\n+                } catch (e: IOException) {\n+                    preferences.edit().putBoolean(KEY_PREFERENCE_SECURE, false).apply()\n+                }\n+            }\n+            fac.port = getPort(preferences)\n+            fac.idleTimeout = preferences.getInt(KEY_PREFERENCE_TIMEOUT, DEFAULT_TIMEOUT)\n+\n+            addListener(\"default\", fac.createListener())\n+            runCatching {\n+                server = createServer().apply {\n+                    start()\n+                    EventBus.getDefault()\n+                        .post(\n+                            if (isStartedByTile)\n+                                FtpReceiverActions.STARTED_FROM_TILE\n+                            else\n+                                FtpReceiverActions.STARTED\n+                        )\n+                }\n+            }.onFailure {\n+                EventBus.getDefault().post(FtpReceiverActions.FAILED_TO_START)\n+            }\n+        }\n+    }\n+\n+    override fun onDestroy() {\n+        serverThread?.interrupt().also {\n+            // wait 10 sec for server thread to finish\n+            serverThread!!.join(10000)\n+\n+            if (!serverThread!!.isAlive) {\n+                serverThread = null\n+            }\n+            server?.stop().also {\n+                EventBus.getDefault().post(FtpReceiverActions.STOPPED)\n+            }\n+        }\n+    }\n+\n+    // Restart the service if the app is closed from the recent list\n+    override fun onTaskRemoved(rootIntent: Intent) {\n+        super.onTaskRemoved(rootIntent)\n+        val restartService = Intent(applicationContext, this.javaClass).setPackage(packageName)\n+        val restartServicePI = PendingIntent.getService(\n+            applicationContext, 1, restartService, PendingIntent.FLAG_ONE_SHOT\n+        )\n+        val alarmService = applicationContext.getSystemService(ALARM_SERVICE) as AlarmManager\n+        alarmService[AlarmManager.ELAPSED_REALTIME, SystemClock.elapsedRealtime() + 2000] =\n+            restartServicePI\n+    }\n+\n+    companion object {\n+        const val DEFAULT_PORT = 2211\n+        const val DEFAULT_USERNAME = \"\"\n+        const val DEFAULT_TIMEOUT = 600 // default timeout, in sec\n+        const val DEFAULT_SECURE = true\n+        const val PORT_PREFERENCE_KEY = \"ftpPort\"\n+        const val KEY_PREFERENCE_PATH = \"ftp_path\"\n+        const val KEY_PREFERENCE_USERNAME = \"ftp_username\"\n+        const val KEY_PREFERENCE_PASSWORD = \"ftp_password_encrypted\"\n+        const val KEY_PREFERENCE_TIMEOUT = \"ftp_timeout\"\n+        const val KEY_PREFERENCE_SECURE = \"ftp_secure\"\n+        const val KEY_PREFERENCE_READONLY = \"ftp_readonly\"\n+        const val INITIALS_HOST_FTP = \"ftp://\"\n+        const val INITIALS_HOST_SFTP = \"ftps://\"\n+        private const val WIFI_AP_ADDRESS_PREFIX = \"192.168.43.\"\n+        private val KEYSTORE_PASSWORD = \"vishal007\".toCharArray()\n+\n+        val DEFAULT_PATH: String = if (Build.VERSION.SDK_INT < M) {\n+            Environment.getExternalStorageDirectory().absolutePath\n+        } else {\n+            \"content://com.android.externalstorage.documents/tree/primary%3A\"\n+        }\n+\n+        // RequestStartStopReceiver listens for these actions to start/stop this server\n+        const val ACTION_START_FTPSERVER =\n+            \"com.amaze.filemanager.services.ftpservice.FTPReceiver.ACTION_START_FTPSERVER\"\n+        const val ACTION_STOP_FTPSERVER =\n+            \"com.amaze.filemanager.services.ftpservice.FTPReceiver.ACTION_STOP_FTPSERVER\"\n+        const val TAG_STARTED_BY_TILE = \"started_by_tile\"\n+        // attribute of action_started, used by notification\n+\n+        var serverThread: Thread? = null\n+\n+        /**\n+         * Indicator whether FTP service is running\n+         */\n+        @JvmStatic\n+        fun isRunning(): Boolean = serverThread != null\n+\n+        /**\n+         * Is the device connected to local network, either Ethernet or Wifi?\n+         */\n+        @JvmStatic\n+        fun isConnectedToLocalNetwork(context: Context): Boolean {\n+            val cm = context.getSystemService(CONNECTIVITY_SERVICE) as ConnectivityManager\n+            var connected: Boolean\n+            if (Build.VERSION.SDK_INT >= M) {\n+                return cm.activeNetwork?.let { activeNetwork ->\n+                    cm.getNetworkCapabilities(activeNetwork)?.let { ni ->\n+                        ni.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) or\n+                            ni.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)\n+                    } ?: false\n+                } ?: false\n+            } else {\n+                connected = cm.activeNetworkInfo?.let { ni ->\n+                    ni.isConnected && (\n+                        ni.type and (\n+                            ConnectivityManager.TYPE_WIFI\n+                                or ConnectivityManager.TYPE_ETHERNET\n+                            ) != 0\n+                        )\n+                } ?: false\n+                if (!connected) {\n+                    connected = runCatching {\n+                        NetworkInterface.getNetworkInterfaces().toList().find { netInterface ->\n+                            netInterface.displayName.startsWith(\"rndis\")\n+                        }\n+                    }.getOrElse { null } != null\n+                }\n+            }\n+\n+            return connected\n+        }\n+\n+        /**\n+         * Is the device connected to Wifi?\n+         */\n+        @JvmStatic\n+        fun isConnectedToWifi(context: Context): Boolean {\n+            val cm = context.getSystemService(CONNECTIVITY_SERVICE) as ConnectivityManager\n+            return if (Build.VERSION.SDK_INT >= M) {\n+                cm.activeNetwork?.let {\n+                    cm.getNetworkCapabilities(it)?.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)\n+                } ?: false\n+            } else {\n+                cm.activeNetworkInfo?.let {\n+                    it.isConnected && it.type == ConnectivityManager.TYPE_WIFI\n+                } ?: false\n+            }\n+        }\n+\n+        /**\n+         * Is the device's wifi hotspot enabled?\n+         */\n+        @JvmStatic\n+        fun isEnabledWifiHotspot(context: Context): Boolean {\n+            val wm = context.applicationContext.getSystemService(WIFI_SERVICE) as WifiManager\n+            return callIsWifiApEnabled(wm)\n+        }\n+\n+        /**\n+         * Determine device's IP address\n+         */\n+        @JvmStatic\n+        fun getLocalInetAddress(context: Context): InetAddress? {\n+            if (!isConnectedToLocalNetwork(context) && !isEnabledWifiHotspot(context)) {\n+                return null\n+            }\n+            if (isConnectedToWifi(context)) {\n+                val wm = context.applicationContext.getSystemService(WIFI_SERVICE) as WifiManager\n+                val ipAddress = wm.connectionInfo.ipAddress\n+                return if (ipAddress == 0) null else intToInet(ipAddress)\n+            }\n+            runCatching {\n+                NetworkInterface.getNetworkInterfaces().iterator().forEach { netinterface ->\n+                    netinterface.inetAddresses.iterator().forEach { address ->\n+                        if (address.hostAddress.startsWith(WIFI_AP_ADDRESS_PREFIX) &&\n+                            isEnabledWifiHotspot(context)\n+                        ) {\n+                            return address\n+                        }\n+\n+                        // this is the condition that sometimes gives problems\n+                        if (!address.isLoopbackAddress &&\n+                            !address.isLinkLocalAddress &&\n+                            !isEnabledWifiHotspot(context)\n+                        ) {\n+                            return address\n+                        }\n+                    }\n+                }\n+            }.onFailure { e ->\n+                e.printStackTrace()\n+            }\n+            return null\n+        }\n+\n+        private fun intToInet(value: Int): InetAddress? {\n+            val bytes = ByteArray(4)\n+            for (i in 0..3) {\n+                bytes[i] = byteOfInt(value, i)\n+            }\n+            return try {\n+                InetAddress.getByAddress(bytes)\n+            } catch (e: UnknownHostException) {\n+                // This only happens if the byte array has a bad length\n+                null\n+            }\n+        }\n+\n+        private fun byteOfInt(value: Int, which: Int): Byte {\n+            val shift = which * 8\n+            return (value shr shift).toByte()\n+        }\n+\n+        private fun getPort(preferences: SharedPreferences): Int {\n+            return preferences.getInt(PORT_PREFERENCE_KEY, DEFAULT_PORT)\n+        }\n+\n+        private fun callIsWifiApEnabled(wifiManager: WifiManager): Boolean = runCatching {\n+            val method = wifiManager.javaClass.getDeclaredMethod(\"isWifiApEnabled\")\n+            method.invoke(wifiManager) as Boolean\n+        }.getOrElse {\n+            false\n+        }\n+    }\n+}"
  },
  {
    "sha": "f7cdb433f68493f5322ee5bf70bee888798fa473",
    "filename": "app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFileSystemFactory.kt",
    "status": "added",
    "additions": 36,
    "deletions": 0,
    "changes": 36,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFileSystemFactory.kt",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFileSystemFactory.kt",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFileSystemFactory.kt?ref=8e0d0d81ede9bdb136251bc6f7d497697f16d6e0",
    "patch": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,\n+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.\n+ *\n+ * This file is part of Amaze File Manager.\n+ *\n+ * Amaze File Manager is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.amaze.filemanager.filesystem.ftpserver\n+\n+import android.content.Context\n+import android.os.Build.VERSION_CODES.KITKAT\n+import androidx.annotation.RequiresApi\n+import com.amaze.filemanager.asynchronous.services.ftp.FtpService\n+import org.apache.ftpserver.ftplet.FileSystemFactory\n+import org.apache.ftpserver.ftplet.FileSystemView\n+import org.apache.ftpserver.ftplet.User\n+\n+@RequiresApi(KITKAT)\n+class AndroidFileSystemFactory(private val context: Context) : FileSystemFactory {\n+\n+    override fun createFileSystemView(user: User?): FileSystemView =\n+        AndroidFtpFileSystemView(context, user?.homeDirectory ?: FtpService.DEFAULT_PATH)\n+}"
  },
  {
    "sha": "3bc7621c2ae28b2b8cfadaf473ef8210fa5b855a",
    "filename": "app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFtpFile.kt",
    "status": "added",
    "additions": 215,
    "deletions": 0,
    "changes": 215,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFtpFile.kt",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFtpFile.kt",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFtpFile.kt?ref=8e0d0d81ede9bdb136251bc6f7d497697f16d6e0",
    "patch": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,\n+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.\n+ *\n+ * This file is part of Amaze File Manager.\n+ *\n+ * Amaze File Manager is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.amaze.filemanager.filesystem.ftpserver\n+\n+import android.content.ContentResolver\n+import android.content.ContentValues\n+import android.content.Context\n+import android.net.Uri\n+import android.os.Build.VERSION_CODES.KITKAT\n+import android.provider.DocumentsContract\n+import androidx.annotation.RequiresApi\n+import androidx.documentfile.provider.DocumentFile\n+import org.apache.ftpserver.ftplet.FtpFile\n+import java.io.FileNotFoundException\n+import java.io.IOException\n+import java.io.InputStream\n+import java.io.OutputStream\n+import java.lang.ref.WeakReference\n+\n+@RequiresApi(KITKAT)\n+@Suppress(\"TooManyFunctions\") // Don't ask me. Ask Apache why.\n+class AndroidFtpFile(\n+    context: Context,\n+    private val parentDocument: DocumentFile,\n+    private val backingDocument: DocumentFile?,\n+    private val path: String\n+) : FtpFile {\n+\n+    private val _context: WeakReference<Context> = WeakReference(context)\n+    private val context: Context\n+        get() = _context.get()!!\n+\n+    override fun getAbsolutePath(): String {\n+        return path\n+    }\n+\n+    /**\n+     * @see FtpFile.getName\n+     * @see DocumentFile.getName\n+     */\n+    override fun getName(): String = backingDocument?.name ?: path.substringAfterLast('/')\n+\n+    /**\n+     * @see FtpFile.isHidden\n+     */\n+    override fun isHidden(): Boolean = name.startsWith(\".\") && name != \".\"\n+\n+    /**\n+     * @see FtpFile.isDirectory\n+     * @see DocumentFile.isDirectory\n+     */\n+    override fun isDirectory(): Boolean = backingDocument?.isDirectory ?: false\n+\n+    /**\n+     * @see FtpFile.isFile\n+     * @see DocumentFile.isFile\n+     */\n+    override fun isFile(): Boolean = backingDocument?.isFile ?: false\n+\n+    /**\n+     * @see FtpFile.doesExist\n+     * @see DocumentFile.exists\n+     */\n+    override fun doesExist(): Boolean = backingDocument?.exists() ?: false\n+\n+    /**\n+     * @see FtpFile.isReadable\n+     * @see DocumentFile.canRead\n+     */\n+    override fun isReadable(): Boolean = backingDocument?.canRead() ?: false\n+\n+    /**\n+     * @see FtpFile.isWritable\n+     * @see DocumentFile.canWrite\n+     */\n+    override fun isWritable(): Boolean = backingDocument?.canWrite() ?: true\n+\n+    /**\n+     * @see FtpFile.isRemovable\n+     * @see DocumentFile.canWrite\n+     */\n+    override fun isRemovable(): Boolean = backingDocument?.canWrite() ?: true\n+\n+    /**\n+     * @see FtpFile.getOwnerName\n+     */\n+    override fun getOwnerName(): String = \"user\"\n+\n+    /**\n+     * @see FtpFile.getGroupName\n+     */\n+    override fun getGroupName(): String = \"user\"\n+\n+    /**\n+     * @see FtpFile.getLinkCount\n+     */\n+    override fun getLinkCount(): Int = 0\n+\n+    /**\n+     * @see FtpFile.getLastModified\n+     * @see DocumentFile.lastModified\n+     */\n+    override fun getLastModified(): Long = backingDocument?.lastModified() ?: 0L\n+\n+    /**\n+     * @see FtpFile.setLastModified\n+     * @see DocumentsContract.Document.COLUMN_LAST_MODIFIED\n+     * @see ContentResolver.update\n+     */\n+    override fun setLastModified(time: Long): Boolean {\n+        return if (doesExist()) {\n+            val updateValues = ContentValues().also {\n+                it.put(DocumentsContract.Document.COLUMN_LAST_MODIFIED, time)\n+            }\n+            val docUri: Uri = backingDocument!!.uri\n+            val updated: Int = context.contentResolver.update(\n+                docUri,\n+                updateValues,\n+                null,\n+                null\n+            )\n+            return updated == 1\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /**\n+     * @see FtpFile.getSize\n+     * @see DocumentFile.length\n+     */\n+    override fun getSize(): Long = backingDocument?.length() ?: 0L\n+\n+    /**\n+     * @see FtpFile.getPhysicalFile\n+     */\n+    override fun getPhysicalFile(): Any = backingDocument!!\n+\n+    /**\n+     * @see FtpFile.mkdir\n+     * @see DocumentFile.createDirectory\n+     */\n+    override fun mkdir(): Boolean = parentDocument.createDirectory(name) != null\n+\n+    /**\n+     * @see FtpFile.delete\n+     * @see DocumentFile.delete\n+     */\n+    override fun delete(): Boolean = backingDocument?.delete() ?: false\n+\n+    /**\n+     * @see FtpFile.move\n+     * @see DocumentFile.renameTo\n+     */\n+    override fun move(destination: FtpFile): Boolean =\n+        backingDocument?.renameTo(destination.name) ?: false\n+\n+    /**\n+     * @see FtpFile.listFiles\n+     * @see DocumentFile.listFiles\n+     */\n+    override fun listFiles(): MutableList<out FtpFile> = if (doesExist()) {\n+        backingDocument!!.listFiles().map {\n+            AndroidFtpFile(context, backingDocument, it, it.name!!)\n+        }.toMutableList()\n+    } else {\n+        mutableListOf()\n+    }\n+\n+    /**\n+     * @see FtpFile.createOutputStream\n+     * @see ContentResolver.openOutputStream\n+     */\n+    override fun createOutputStream(offset: Long): OutputStream? = runCatching {\n+        val uri = if (doesExist()) {\n+            backingDocument!!.uri\n+        } else {\n+            val newFile = parentDocument.createFile(\"\", name)\n+            newFile?.uri ?: throw IOException(\"Cannot create file at $path\")\n+        }\n+        context.contentResolver.openOutputStream(uri)\n+    }.getOrThrow()\n+\n+    /**\n+     * @see FtpFile.createInputStream\n+     * @see ContentResolver.openInputStream\n+     */\n+    override fun createInputStream(offset: Long): InputStream? = runCatching {\n+        if (doesExist()) {\n+            context.contentResolver.openInputStream(backingDocument!!.uri).also {\n+                it?.skip(offset)\n+            }\n+        } else {\n+            throw FileNotFoundException(path)\n+        }\n+    }.getOrThrow()\n+}"
  },
  {
    "sha": "a97a8bb4f892072689ab1c017123c012e3a27d8d",
    "filename": "app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFtpFileSystemView.kt",
    "status": "added",
    "additions": 126,
    "deletions": 0,
    "changes": 126,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFtpFileSystemView.kt",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFtpFileSystemView.kt",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFtpFileSystemView.kt?ref=8e0d0d81ede9bdb136251bc6f7d497697f16d6e0",
    "patch": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,\n+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.\n+ *\n+ * This file is part of Amaze File Manager.\n+ *\n+ * Amaze File Manager is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.amaze.filemanager.filesystem.ftpserver\n+\n+import android.content.Context\n+import android.net.Uri\n+import android.os.Build\n+import android.os.Build.VERSION_CODES.KITKAT\n+import android.os.Build.VERSION_CODES.M\n+import androidx.annotation.RequiresApi\n+import androidx.documentfile.provider.DocumentFile\n+import org.apache.ftpserver.ftplet.FileSystemView\n+import org.apache.ftpserver.ftplet.FtpFile\n+import java.io.File\n+import java.net.URI\n+\n+@RequiresApi(KITKAT)\n+class AndroidFtpFileSystemView(private var context: Context, root: String) : FileSystemView {\n+\n+    private val rootPath = root\n+    private val rootDocumentFile = createDocumentFileFrom(rootPath)\n+    private var currentPath: String? = \"/\"\n+\n+    override fun getHomeDirectory(): FtpFile =\n+        AndroidFtpFile(context, rootDocumentFile, resolveDocumentFileFromRoot(\"/\"), \"/\")\n+\n+    override fun getWorkingDirectory(): FtpFile {\n+        return AndroidFtpFile(\n+            context, rootDocumentFile,\n+            resolveDocumentFileFromRoot(currentPath!!), currentPath!!\n+        )\n+    }\n+\n+    override fun changeWorkingDirectory(dir: String?): Boolean {\n+        return when {\n+            dir.isNullOrBlank() -> false\n+            dir == \"/\" -> {\n+                currentPath = \"/\"\n+                true\n+            }\n+            dir.startsWith(\"..\") -> {\n+                if (currentPath.isNullOrEmpty() || currentPath == \"/\")\n+                    false\n+                else {\n+                    currentPath = URI(\"$currentPath/$dir\").normalize().toString()\n+                    resolveDocumentFileFromRoot(currentPath) != null\n+                }\n+            }\n+            else -> {\n+                currentPath = if (currentPath.isNullOrEmpty() || currentPath == \"/\") {\n+                    dir\n+                } else {\n+                    URI(\"$currentPath/$dir\").normalize().toString()\n+                }\n+                resolveDocumentFileFromRoot(currentPath) != null\n+            }\n+        }\n+    }\n+\n+    override fun getFile(file: String): FtpFile {\n+        val path = if (currentPath.isNullOrEmpty() || currentPath == \"/\") {\n+            \"/$file\"\n+        } else if (file.startsWith('/')) {\n+            file\n+        } else {\n+            \"$currentPath/$file\"\n+        }\n+        return URI(path).normalize().toString().let { normalizedPath ->\n+            AndroidFtpFile(\n+                context,\n+                rootDocumentFile,\n+                resolveDocumentFileFromRoot(normalizedPath), normalizedPath\n+            )\n+        }\n+    }\n+\n+    override fun isRandomAccessible(): Boolean = false\n+\n+    override fun dispose() {\n+        // context = null!!\n+    }\n+\n+    private fun createDocumentFileFrom(path: String): DocumentFile {\n+        return if (Build.VERSION.SDK_INT in KITKAT until M) {\n+            DocumentFile.fromFile(File(path))\n+        } else {\n+            DocumentFile.fromTreeUri(context, Uri.parse(path))!!\n+        }\n+    }\n+\n+    private fun resolveDocumentFileFromRoot(path: String?): DocumentFile? {\n+        return if (path.isNullOrBlank() or (\"/\" == path) or (\"./\" == path))\n+            rootDocumentFile\n+        else {\n+            val pathElements = path!!.split('/')\n+            if (pathElements.isEmpty()) {\n+                rootDocumentFile\n+            } else {\n+                var retval: DocumentFile? = rootDocumentFile\n+                pathElements.forEach { pathElement ->\n+                    if (pathElement.isNotBlank())\n+                        retval = retval?.findFile(pathElement)\n+                }\n+                retval\n+            }\n+        }\n+    }\n+}"
  },
  {
    "sha": "a6bd5201fe070da342c5ea1114c63231c5c8a3d5",
    "filename": "app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java",
    "status": "modified",
    "additions": 54,
    "deletions": 29,
    "changes": 83,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java?ref=8e0d0d81ede9bdb136251bc6f7d497697f16d6e0",
    "patch": "@@ -21,6 +21,14 @@\n package com.amaze.filemanager.ui.activities;\n \n import static android.os.Build.VERSION.SDK_INT;\n+import static android.os.Build.VERSION_CODES.JELLY_BEAN;\n+import static android.os.Build.VERSION_CODES.JELLY_BEAN_MR1;\n+import static android.os.Build.VERSION_CODES.JELLY_BEAN_MR2;\n+import static android.os.Build.VERSION_CODES.KITKAT;\n+import static android.os.Build.VERSION_CODES.KITKAT_WATCH;\n+import static android.os.Build.VERSION_CODES.LOLLIPOP;\n+import static android.os.Build.VERSION_CODES.M;\n+import static android.os.Build.VERSION_CODES.N;\n import static com.amaze.filemanager.filesystem.FolderStateKt.WRITABLE_OR_ON_SDCARD;\n import static com.amaze.filemanager.filesystem.OperationTypeKt.COMPRESS;\n import static com.amaze.filemanager.filesystem.OperationTypeKt.COPY;\n@@ -32,6 +40,7 @@\n import static com.amaze.filemanager.filesystem.OperationTypeKt.RENAME;\n import static com.amaze.filemanager.filesystem.OperationTypeKt.SAVE_FILE;\n import static com.amaze.filemanager.filesystem.OperationTypeKt.UNDEFINED;\n+import static com.amaze.filemanager.ui.fragments.FtpServerFragment.REQUEST_CODE_SAF_FTP;\n import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_BOOKMARKS_ADDED;\n import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_COLORED_NAVIGATION;\n import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_NEED_TO_SET_HOME;\n@@ -128,7 +137,6 @@\n import android.media.RingtoneManager;\n import android.net.Uri;\n import android.os.AsyncTask;\n-import android.os.Build;\n import android.os.Bundle;\n import android.os.Environment;\n import android.os.Handler;\n@@ -417,7 +425,7 @@ private void invalidateFragmentAndBundle(Bundle savedInstanceState) {\n \n   private void checkForExternalPermission() {\n \n-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && !checkStoragePermission()) {\n+    if (SDK_INT >= M && !checkStoragePermission()) {\n       requestStoragePermission(\n           () -> {\n             drawer.refreshDrawer();\n@@ -538,7 +546,7 @@ private void initFabToSave(final ArrayList<Uri> uris) {\n \n   private void saveExternalIntent(final ArrayList<Uri> uris) {\n     if (uris != null && uris.size() > 0) {\n-      if (SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+      if (SDK_INT >= LOLLIPOP) {\n         File folder = new File(getCurrentMainFragment().getCurrentPath());\n         int result = mainActivityHelper.checkFolder(folder, MainActivity.this);\n         if (result == WRITABLE_OR_ON_SDCARD) {\n@@ -617,7 +625,7 @@ private void initializeInteractiveShell() {\n   /** @return paths to all available volumes in the system (include emulated) */\n   public synchronized ArrayList<StorageDirectoryParcelable> getStorageDirectories() {\n     ArrayList<StorageDirectoryParcelable> volumes;\n-    if (SDK_INT >= Build.VERSION_CODES.N) {\n+    if (SDK_INT >= N) {\n       volumes = getStorageDirectoriesNew();\n     } else {\n       volumes = getStorageDirectoriesLegacy();\n@@ -635,7 +643,7 @@ private void initializeInteractiveShell() {\n   /**\n    * @return All available storage volumes (including internal storage, SD-Cards and USB devices)\n    */\n-  @TargetApi(Build.VERSION_CODES.N)\n+  @TargetApi(N)\n   public synchronized ArrayList<StorageDirectoryParcelable> getStorageDirectoriesNew() {\n     // Final set of paths\n     ArrayList<StorageDirectoryParcelable> volumes = new ArrayList<>();\n@@ -702,7 +710,7 @@ private void initializeInteractiveShell() {\n       // Device has emulated storage; external storage paths should have\n       // userId burned into them.\n       final String rawUserId;\n-      if (SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\n+      if (SDK_INT < JELLY_BEAN_MR1) {\n         rawUserId = \"\";\n       } else {\n         final String path = Environment.getExternalStorageDirectory().getAbsolutePath();\n@@ -729,8 +737,8 @@ private void initializeInteractiveShell() {\n       final String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\n       Collections.addAll(rv, rawSecondaryStorages);\n     }\n-    if (SDK_INT >= Build.VERSION_CODES.M && checkStoragePermission()) rv.clear();\n-    if (SDK_INT >= Build.VERSION_CODES.KITKAT) {\n+    if (SDK_INT >= M && checkStoragePermission()) rv.clear();\n+    if (SDK_INT >= KITKAT) {\n       String strings[] = FileUtil.getExtSdCardPathsForActivity(this);\n       for (String s : strings) {\n         File f = new File(s);\n@@ -740,7 +748,7 @@ private void initializeInteractiveShell() {\n     File usb = getUsbDrive();\n     if (usb != null && !rv.contains(usb.getPath())) rv.add(usb.getPath());\n \n-    if (SDK_INT >= Build.VERSION_CODES.KITKAT) {\n+    if (SDK_INT >= KITKAT) {\n       if (SingletonUsbOtg.getInstance().isDeviceConnected()) {\n         rv.add(OTGUtil.PREFIX_OTG + \"/\");\n       }\n@@ -1186,7 +1194,7 @@ protected void onPause() {\n     unregisterReceiver(mainActivityHelper.mNotificationReceiver);\n     unregisterReceiver(receiver2);\n \n-    if (SDK_INT >= Build.VERSION_CODES.KITKAT) {\n+    if (SDK_INT >= KITKAT) {\n       unregisterReceiver(mOtgReceiver);\n     }\n     killToast();\n@@ -1210,13 +1218,13 @@ public void onResume() {\n     registerReceiver(mainActivityHelper.mNotificationReceiver, newFilter);\n     registerReceiver(receiver2, new IntentFilter(TAG_INTENT_FILTER_GENERAL));\n \n-    if (SDK_INT >= Build.VERSION_CODES.KITKAT) {\n+    if (SDK_INT >= KITKAT) {\n       updateUsbInformation();\n     }\n   }\n \n   /** Updates everything related to USB devices MUST ALWAYS be called after onResume() */\n-  @RequiresApi(api = Build.VERSION_CODES.KITKAT)\n+  @RequiresApi(api = KITKAT)\n   private void updateUsbInformation() {\n     boolean isInformationUpdated = false;\n     List<UsbOtgRepresentation> connectedDevices = OTGUtil.getMassStorageDevicesConnected(this);\n@@ -1305,7 +1313,7 @@ protected void onDestroy() {\n   private void closeInteractiveShell() {\n     if (isRootExplorer()) {\n       // close interactive shell and handler thread associated with it\n-      if (SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {\n+      if (SDK_INT >= JELLY_BEAN_MR2) {\n         // let it finish up first with what it's doing\n         handlerThread.quitSafely();\n       } else handlerThread.quit();\n@@ -1407,7 +1415,7 @@ protected void onActivityResult(int requestCode, int responseCode, Intent intent\n       // After confirmation, update stored value of folder.\n       // Persist access permissions.\n \n-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n+      if (SDK_INT >= KITKAT) {\n         getContentResolver()\n             .takePersistableUriPermission(\n                 treeUri,\n@@ -1491,6 +1499,11 @@ protected void onActivityResult(int requestCode, int responseCode, Intent intent\n         getCurrentMainFragment().loadlist(OTGUtil.PREFIX_OTG, false, OpenMode.OTG);\n         drawer.closeIfNotLocked();\n         if (drawer.isLocked()) drawer.onDrawerClosed();\n+      } else if (requestCode == REQUEST_CODE_SAF_FTP) {\n+        FtpServerFragment ftpServerFragment = (FtpServerFragment) getFragmentAtFrame();\n+        ftpServerFragment.changeFTPServerPath(intent.getData().toString());\n+        Toast.makeText(this, R.string.ftp_path_change_success, Toast.LENGTH_SHORT).show();\n+\n       } else {\n         Toast.makeText(this, R.string.error, Toast.LENGTH_SHORT).show();\n         // otg access not provided\n@@ -1555,15 +1568,14 @@ public void updateViews(ColorDrawable colorDrawable) {\n \n     drawer.setBackgroundColor(colorDrawable.getColor());\n \n-    if (SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+    if (SDK_INT >= LOLLIPOP) {\n       // for lollipop devices, the status bar color\n       mainActivity.getWindow().setStatusBarColor(colorDrawable.getColor());\n       if (getBoolean(PREFERENCE_COLORED_NAVIGATION))\n         mainActivity\n             .getWindow()\n             .setNavigationBarColor(PreferenceUtils.getStatusColor(colorDrawable.getColor()));\n-    } else if (SDK_INT == Build.VERSION_CODES.KITKAT_WATCH\n-        || SDK_INT == Build.VERSION_CODES.KITKAT) {\n+    } else if (SDK_INT == KITKAT_WATCH || SDK_INT == KITKAT) {\n \n       // for kitkat devices, the status bar color\n       SystemBarTintManager tintManager = new SystemBarTintManager(this);\n@@ -1683,7 +1695,7 @@ public void onNewIntent(Intent i) {\n     } else if (intent.getAction() != null) {\n       checkForExternalIntent(intent);\n \n-      if (SDK_INT >= Build.VERSION_CODES.KITKAT) {\n+      if (SDK_INT >= KITKAT) {\n         if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_DETACHED)) {\n           SingletonUsbOtg.getInstance().resetUsbOtgRoot();\n           drawer.refreshDrawer();\n@@ -2079,31 +2091,44 @@ public boolean onActionSelected(SpeedDialActionItem actionItem) {\n   /**\n    * Invoke {@link FtpServerFragment#changeFTPServerPath(String)} to change FTP server share path.\n    *\n+   * <p>TODO: move back to FtpServerFragment when material-dialogs is updated\n+   *\n    * @see FtpServerFragment#changeFTPServerPath(String)\n    * @see FolderChooserDialog\n    * @see com.afollestad.materialdialogs.folderselector.FolderChooserDialog.FolderCallback\n    * @param dialog\n    * @param folder selected folder\n    */\n   @Override\n+  @RequiresApi(JELLY_BEAN)\n   public void onFolderSelection(@NonNull FolderChooserDialog dialog, @NonNull File folder) {\n     switch (dialog.getTag()) {\n       case FtpServerFragment.TAG:\n         FtpServerFragment ftpServerFragment = (FtpServerFragment) getFragmentAtFrame();\n-        if (folder.exists() && folder.isDirectory()) {\n-          ftpServerFragment.changeFTPServerPath(folder.getPath());\n-          Toast.makeText(this, R.string.ftp_path_change_success, Toast.LENGTH_SHORT).show();\n-        } else {\n-          // try to get parent\n-          File pathParentFile = new File(folder.getParent());\n-          if (pathParentFile.exists() && pathParentFile.isDirectory()) {\n+        File selectedFolder = folder;\n+        if (!folder.exists() || !folder.isDirectory()) {\n+          selectedFolder = folder.getParentFile();\n+        }\n \n-            ftpServerFragment.changeFTPServerPath(pathParentFile.getPath());\n-            Toast.makeText(this, R.string.ftp_path_change_success, Toast.LENGTH_SHORT).show();\n+        if (selectedFolder.exists() && selectedFolder.isDirectory()) {\n+          if (SDK_INT >= LOLLIPOP\n+              && FileUtil.isOnExtSdCard(selectedFolder, getApplicationContext())) {\n+            // Trigger SAF, let onActivityResult handle the rest.\n+            // Only external SD cards will go this way, since Lollipop DocumentsUI won't show the\n+            // internal storage\n+            mainActivityHelper.guideDialogForLEXA(\n+                selectedFolder.getAbsolutePath(), REQUEST_CODE_SAF_FTP);\n           } else {\n-            // don't have access, print error\n-            Toast.makeText(this, R.string.ftp_path_change_error_invalid, Toast.LENGTH_SHORT).show();\n+            String folderPath =\n+                (SDK_INT < KITKAT)\n+                    ? selectedFolder.getAbsolutePath()\n+                    : Uri.fromFile(selectedFolder).toString();\n+            ftpServerFragment.changeFTPServerPath(folderPath);\n+            Toast.makeText(this, R.string.ftp_path_change_success, Toast.LENGTH_SHORT).show();\n           }\n+        } else {\n+          // don't have access, print error\n+          Toast.makeText(this, R.string.ftp_path_change_error_invalid, Toast.LENGTH_SHORT).show();\n         }\n         dialog.dismiss();\n         break;"
  },
  {
    "sha": "7a9144593fcf394b33b9e6034a484dc3b4d074ac",
    "filename": "app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.java",
    "status": "removed",
    "additions": 0,
    "deletions": 728,
    "changes": 728,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/18ecde732fe93b5f10e8eed071dffda790050277/app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.java",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/18ecde732fe93b5f10e8eed071dffda790050277/app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.java",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.java?ref=18ecde732fe93b5f10e8eed071dffda790050277",
    "patch": "@@ -1,728 +0,0 @@\n-/*\n- * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,\n- * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.\n- *\n- * This file is part of Amaze File Manager.\n- *\n- * Amaze File Manager is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- * GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License\n- * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.amaze.filemanager.ui.fragments;\n-\n-import static android.provider.Settings.ACTION_WIFI_SETTINGS;\n-import static com.amaze.filemanager.asynchronous.services.ftp.FtpService.FtpReceiverActions.STARTED_FROM_TILE;\n-\n-import java.io.IOException;\n-import java.net.InetAddress;\n-import java.security.GeneralSecurityException;\n-\n-import org.greenrobot.eventbus.EventBus;\n-import org.greenrobot.eventbus.Subscribe;\n-import org.greenrobot.eventbus.ThreadMode;\n-\n-import com.afollestad.materialdialogs.MaterialDialog;\n-import com.afollestad.materialdialogs.folderselector.FolderChooserDialog;\n-import com.amaze.filemanager.R;\n-import com.amaze.filemanager.application.AppConfig;\n-import com.amaze.filemanager.asynchronous.services.ftp.FtpService;\n-import com.amaze.filemanager.filesystem.files.CryptUtil;\n-import com.amaze.filemanager.ui.activities.MainActivity;\n-import com.amaze.filemanager.ui.notifications.FtpNotification;\n-import com.amaze.filemanager.utils.OneCharacterCharSequence;\n-import com.amaze.filemanager.utils.Utils;\n-import com.google.android.material.snackbar.BaseTransientBottomBar;\n-import com.google.android.material.snackbar.Snackbar;\n-import com.google.android.material.textfield.TextInputLayout;\n-\n-import android.content.BroadcastReceiver;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.IntentFilter;\n-import android.content.SharedPreferences;\n-import android.graphics.drawable.ColorDrawable;\n-import android.net.ConnectivityManager;\n-import android.net.NetworkInfo;\n-import android.os.Bundle;\n-import android.preference.PreferenceManager;\n-import android.text.Html;\n-import android.text.InputType;\n-import android.text.Spanned;\n-import android.view.LayoutInflater;\n-import android.view.Menu;\n-import android.view.MenuInflater;\n-import android.view.MenuItem;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.widget.Button;\n-import android.widget.EditText;\n-import android.widget.ImageButton;\n-import android.widget.TextView;\n-import android.widget.Toast;\n-\n-import androidx.annotation.Nullable;\n-import androidx.appcompat.widget.AppCompatCheckBox;\n-import androidx.appcompat.widget.AppCompatEditText;\n-import androidx.fragment.app.Fragment;\n-\n-/**\n- * Created by yashwanthreddyg on 10-06-2016. Edited by Luca D'Amico (Luca91) on 25 Jul 2017 (Fixed\n- * FTP Server while usi\n- */\n-public class FtpServerFragment extends Fragment {\n-\n-  private TextView statusText, url, username, password, port, sharedPath;\n-  public static final String TAG = \"FTPServerFragment\";\n-\n-  private AppCompatEditText usernameEditText, passwordEditText;\n-  private TextInputLayout usernameTextInput, passwordTextInput;\n-  private AppCompatCheckBox anonymousCheckBox;\n-  private Button ftpBtn;\n-  private int accentColor;\n-  private Spanned spannedStatusNoConnection, spannedStatusConnected, spannedStatusUrl;\n-  private Spanned spannedStatusSecure, spannedStatusNotRunning;\n-  private ImageButton ftpPasswordVisibleButton;\n-  private Snackbar snackbar;\n-\n-  @Override\n-  public void onCreate(Bundle savedInstanceState) {\n-    super.onCreate(savedInstanceState);\n-    setHasOptionsMenu(true);\n-  }\n-\n-  @Override\n-  public View onCreateView(\n-      LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n-    View rootView = inflater.inflate(R.layout.fragment_ftp, container, false);\n-    statusText = rootView.findViewById(R.id.text_view_ftp_status);\n-    url = rootView.findViewById(R.id.text_view_ftp_url);\n-    username = rootView.findViewById(R.id.text_view_ftp_username);\n-    password = rootView.findViewById(R.id.text_view_ftp_password);\n-    port = rootView.findViewById(R.id.text_view_ftp_port);\n-    sharedPath = rootView.findViewById(R.id.text_view_ftp_path);\n-    ftpBtn = rootView.findViewById(R.id.startStopButton);\n-    View startDividerView = rootView.findViewById(R.id.divider_ftp_start);\n-    View statusDividerView = rootView.findViewById(R.id.divider_ftp_status);\n-    ftpPasswordVisibleButton = rootView.findViewById(R.id.ftp_password_visible);\n-    accentColor = getMainActivity().getAccent();\n-\n-    updateSpans();\n-    updateStatus();\n-\n-    switch (getMainActivity().getAppTheme().getSimpleTheme()) {\n-      case LIGHT:\n-        startDividerView.setBackgroundColor(Utils.getColor(getContext(), R.color.divider));\n-        statusDividerView.setBackgroundColor(Utils.getColor(getContext(), R.color.divider));\n-        break;\n-      case DARK:\n-      case BLACK:\n-        startDividerView.setBackgroundColor(\n-            Utils.getColor(getContext(), R.color.divider_dark_card));\n-        statusDividerView.setBackgroundColor(\n-            Utils.getColor(getContext(), R.color.divider_dark_card));\n-        break;\n-      default:\n-        break;\n-    }\n-\n-    ftpBtn.setOnClickListener(\n-        v -> {\n-          if (!FtpService.isRunning()) {\n-            if (FtpService.isConnectedToWifi(getContext())\n-                || FtpService.isConnectedToLocalNetwork(getContext())\n-                || FtpService.isEnabledWifiHotspot(getContext())) startServer();\n-            else {\n-              // no Wi-Fi and no eth, we shouldn't be here in the first place, because of broadcast\n-              // receiver, but just to be sure\n-              statusText.setText(spannedStatusNoConnection);\n-            }\n-          } else {\n-            stopServer();\n-          }\n-        });\n-\n-    return rootView;\n-  }\n-\n-  @Override\n-  public void onActivityCreated(Bundle savedInstanceState) {\n-    super.onActivityCreated(savedInstanceState);\n-    setRetainInstance(true);\n-    getMainActivity().getAppbar().setTitle(R.string.ftp);\n-    getMainActivity().getFAB().hide();\n-    getMainActivity().getAppbar().getBottomBar().setVisibility(View.GONE);\n-    getMainActivity().supportInvalidateOptionsMenu();\n-\n-    int skin_color = getMainActivity().getCurrentColorPreference().primaryFirstTab;\n-    int skinTwoColor = getMainActivity().getCurrentColorPreference().primarySecondTab;\n-\n-    getMainActivity()\n-        .updateViews(\n-            new ColorDrawable(getMainActivity().currentTab == 1 ? skinTwoColor : skin_color));\n-  }\n-\n-  @Override\n-  public boolean onOptionsItemSelected(MenuItem item) {\n-\n-    switch (item.getItemId()) {\n-      case R.id.choose_ftp_port:\n-        int currentFtpPort = getDefaultPortFromPreferences();\n-\n-        new MaterialDialog.Builder(getContext())\n-            .input(\n-                getString(R.string.ftp_port_edit_menu_title),\n-                Integer.toString(currentFtpPort),\n-                true,\n-                (dialog, input) -> {})\n-            .inputType(InputType.TYPE_CLASS_NUMBER)\n-            .onPositive(\n-                (dialog, which) -> {\n-                  EditText editText = dialog.getInputEditText();\n-                  if (editText != null) {\n-                    String name = editText.getText().toString();\n-\n-                    int portNumber = Integer.parseInt(name);\n-                    if (portNumber < 1024) {\n-                      Toast.makeText(\n-                              getActivity(),\n-                              R.string.ftp_port_change_error_invalid,\n-                              Toast.LENGTH_SHORT)\n-                          .show();\n-                    } else {\n-                      changeFTPServerPort(portNumber);\n-                      Toast.makeText(\n-                              getActivity(), R.string.ftp_port_change_success, Toast.LENGTH_SHORT)\n-                          .show();\n-                    }\n-                  }\n-                })\n-            .positiveText(getString(R.string.change).toUpperCase())\n-            .negativeText(R.string.cancel)\n-            .build()\n-            .show();\n-        return true;\n-      case R.id.ftp_path:\n-        FolderChooserDialog.Builder dialogBuilder = new FolderChooserDialog.Builder(getActivity());\n-        dialogBuilder\n-            .chooseButton(R.string.choose_folder)\n-            .initialPath(getDefaultPathFromPreferences())\n-            .goUpLabel(getString(R.string.folder_go_up_one_level))\n-            .cancelButton(R.string.cancel)\n-            .tag(TAG)\n-            .build()\n-            .show(getActivity());\n-        return true;\n-      case R.id.ftp_login:\n-        MaterialDialog.Builder loginDialogBuilder = new MaterialDialog.Builder(getContext());\n-\n-        LayoutInflater inflater = getActivity().getLayoutInflater();\n-        View rootView = inflater.inflate(R.layout.dialog_ftp_login, null);\n-        initLoginDialogViews(rootView);\n-\n-        loginDialogBuilder.customView(rootView, true);\n-\n-        loginDialogBuilder.title(getString(R.string.ftp_login));\n-\n-        loginDialogBuilder.onPositive(\n-            (dialog, which) -> {\n-              if (anonymousCheckBox.isChecked()) {\n-\n-                // remove preferences\n-                setFTPUsername(\"\");\n-                setFTPPassword(\"\");\n-              } else {\n-\n-                if (passwordEditText.getText().toString().equals(\"\")) {\n-                  passwordTextInput.setError(getString(R.string.field_empty));\n-                } else if (usernameEditText.getText().toString().equals(\"\")) {\n-                  usernameTextInput.setError(getString(R.string.field_empty));\n-                } else {\n-\n-                  // password and username field not empty, let's set them to preferences\n-                  setFTPUsername(usernameEditText.getText().toString());\n-                  setFTPPassword(passwordEditText.getText().toString());\n-                }\n-              }\n-            });\n-\n-        loginDialogBuilder\n-            .positiveText(getString(R.string.set).toUpperCase())\n-            .negativeText(getString(R.string.cancel))\n-            .build()\n-            .show();\n-\n-        return true;\n-      case R.id.checkbox_ftp_readonly:\n-        boolean shouldReadonly = !item.isChecked();\n-        item.setChecked(shouldReadonly);\n-        setReadonlyPreference(shouldReadonly);\n-        updatePathText();\n-        promptUserToRestartServer();\n-        return true;\n-      case R.id.checkbox_ftp_secure:\n-        boolean shouldSecure = !item.isChecked();\n-        item.setChecked(shouldSecure);\n-        setSecurePreference(shouldSecure);\n-        promptUserToRestartServer();\n-        return true;\n-      case R.id.ftp_timeout:\n-        MaterialDialog.Builder timeoutBuilder = new MaterialDialog.Builder(getActivity());\n-\n-        timeoutBuilder.title(\n-            getString(R.string.ftp_timeout)\n-                + \" (\"\n-                + getResources().getString(R.string.ftp_seconds)\n-                + \")\");\n-        timeoutBuilder.input(\n-            String.valueOf(\n-                FtpService.DEFAULT_TIMEOUT + \" \" + getResources().getString(R.string.ftp_seconds)),\n-            String.valueOf(getFTPTimeout()),\n-            true,\n-            (dialog, input) -> {\n-              boolean isInputInteger;\n-              try {\n-                // try parsing for integer check\n-                Integer.parseInt(input.toString());\n-                isInputInteger = true;\n-              } catch (NumberFormatException e) {\n-                isInputInteger = false;\n-              }\n-\n-              if (input.length() == 0 || !isInputInteger) setFTPTimeout(FtpService.DEFAULT_TIMEOUT);\n-              else setFTPTimeout(Integer.valueOf(input.toString()));\n-            });\n-        timeoutBuilder\n-            .positiveText(getResources().getString(R.string.set).toUpperCase())\n-            .negativeText(getResources().getString(R.string.cancel))\n-            .build()\n-            .show();\n-        return true;\n-    }\n-\n-    return false;\n-  }\n-\n-  @Override\n-  public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n-    getMainActivity().getMenuInflater().inflate(R.menu.ftp_server_menu, menu);\n-    menu.findItem(R.id.checkbox_ftp_readonly).setChecked(getReadonlyPreference());\n-    menu.findItem(R.id.checkbox_ftp_secure).setChecked(getSecurePreference());\n-  }\n-\n-  private BroadcastReceiver mWifiReceiver =\n-      new BroadcastReceiver() {\n-\n-        @Override\n-        public void onReceive(Context context, Intent intent) {\n-          ConnectivityManager conMan =\n-              (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n-          NetworkInfo netInfo = conMan.getActiveNetworkInfo();\n-          if ((netInfo != null\n-                  && (netInfo.getType() == ConnectivityManager.TYPE_WIFI\n-                      || netInfo.getType() == ConnectivityManager.TYPE_ETHERNET))\n-              || FtpService.isEnabledWifiHotspot(getContext())) {\n-            // connected to Wi-Fi or eth\n-            ftpBtn.setEnabled(true);\n-            dismissSnackbar();\n-          } else {\n-            // Wi-Fi or eth connection lost\n-            stopServer();\n-            statusText.setText(spannedStatusNoConnection);\n-            ftpBtn.setEnabled(true);\n-            ftpBtn.setEnabled(false);\n-            ftpBtn.setText(getResources().getString(R.string.start_ftp).toUpperCase());\n-            promptUserToEnableWireless(netInfo);\n-          }\n-        }\n-      };\n-\n-  @Subscribe(threadMode = ThreadMode.MAIN_ORDERED)\n-  public void onFtpReceiveActions(FtpService.FtpReceiverActions signal) {\n-    updateSpans();\n-    switch (signal) {\n-      case STARTED:\n-      case STARTED_FROM_TILE:\n-        if (getSecurePreference()) {\n-          statusText.setText(spannedStatusSecure);\n-        } else {\n-          statusText.setText(spannedStatusConnected);\n-        }\n-        url.setText(spannedStatusUrl);\n-        ftpBtn.setText(getResources().getString(R.string.stop_ftp).toUpperCase());\n-        FtpNotification.updateNotification(getContext(), STARTED_FROM_TILE.equals(signal));\n-        break;\n-      case FAILED_TO_START:\n-        statusText.setText(spannedStatusNotRunning);\n-        Toast.makeText(\n-                getContext(), getResources().getString(R.string.unknown_error), Toast.LENGTH_LONG)\n-            .show();\n-        ftpBtn.setText(getResources().getString(R.string.start_ftp).toUpperCase());\n-        url.setText(\"URL: \");\n-        break;\n-\n-      case STOPPED:\n-        statusText.setText(spannedStatusNotRunning);\n-        url.setText(\"URL: \");\n-        ftpBtn.setText(getResources().getString(R.string.start_ftp).toUpperCase());\n-        break;\n-    }\n-  }\n-\n-  /** Sends a broadcast to start ftp server */\n-  private void startServer() {\n-    getContext()\n-        .sendBroadcast(\n-            new Intent(FtpService.ACTION_START_FTPSERVER)\n-                .setPackage(getContext().getPackageName()));\n-  }\n-\n-  /** Sends a broadcast to stop ftp server */\n-  private void stopServer() {\n-    getContext()\n-        .sendBroadcast(\n-            new Intent(FtpService.ACTION_STOP_FTPSERVER).setPackage(getContext().getPackageName()));\n-  }\n-\n-  @Override\n-  public void onResume() {\n-    super.onResume();\n-\n-    IntentFilter wifiFilter = new IntentFilter();\n-    wifiFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);\n-    getContext().registerReceiver(mWifiReceiver, wifiFilter);\n-    EventBus.getDefault().register(this);\n-  }\n-\n-  @Override\n-  public void onPause() {\n-    super.onPause();\n-    getContext().unregisterReceiver(mWifiReceiver);\n-    EventBus.getDefault().unregister(this);\n-    dismissSnackbar();\n-  }\n-\n-  private MainActivity getMainActivity() {\n-    return (MainActivity) getActivity();\n-  }\n-\n-  /** Update UI widgets after change in shared preferences */\n-  private void updateStatus() {\n-\n-    if (!FtpService.isRunning()) {\n-      if (!FtpService.isConnectedToWifi(getContext())\n-          && !FtpService.isConnectedToLocalNetwork(getContext())\n-          && !FtpService.isEnabledWifiHotspot(getContext())) {\n-        statusText.setText(spannedStatusNoConnection);\n-        ftpBtn.setEnabled(false);\n-      } else {\n-        statusText.setText(spannedStatusNotRunning);\n-        ftpBtn.setEnabled(true);\n-      }\n-      url.setText(\"URL: \");\n-      ftpBtn.setText(getResources().getString(R.string.start_ftp).toUpperCase());\n-\n-    } else {\n-      accentColor = getMainActivity().getAccent();\n-      url.setText(spannedStatusUrl);\n-      statusText.setText(spannedStatusConnected);\n-      ftpBtn.setEnabled(true);\n-      ftpBtn.setText(getResources().getString(R.string.stop_ftp).toUpperCase());\n-    }\n-\n-    final String passwordDecrypted = getPasswordFromPreferences();\n-    final CharSequence passwordBulleted =\n-        new OneCharacterCharSequence('\\u25CF', passwordDecrypted.length());\n-\n-    username.setText(\n-        getResources().getString(R.string.username) + \": \" + getUsernameFromPreferences());\n-    password.setText(getResources().getString(R.string.password) + \": \" + passwordBulleted);\n-\n-    ftpPasswordVisibleButton.setImageDrawable(\n-        getResources().getDrawable(R.drawable.ic_eye_grey600_24dp));\n-\n-    if (passwordDecrypted.equals(\"\")) {\n-      ftpPasswordVisibleButton.setVisibility(View.GONE);\n-    } else {\n-      ftpPasswordVisibleButton.setVisibility(View.VISIBLE);\n-    }\n-\n-    ftpPasswordVisibleButton.setOnClickListener(\n-        v -> {\n-          if (password.getText().toString().contains(\"\\u25CF\")) {\n-            // password was not visible, let's make it visible\n-            password.setText(\n-                getResources().getString(R.string.password) + \": \" + passwordDecrypted);\n-            ftpPasswordVisibleButton.setImageDrawable(\n-                getResources().getDrawable(R.drawable.ic_eye_off_grey600_24dp));\n-          } else {\n-            // password was visible, let's hide it\n-            password.setText(getResources().getString(R.string.password) + \": \" + passwordBulleted);\n-            ftpPasswordVisibleButton.setImageDrawable(\n-                getResources().getDrawable(R.drawable.ic_eye_grey600_24dp));\n-          }\n-        });\n-\n-    port.setText(\n-        getResources().getString(R.string.ftp_port) + \": \" + getDefaultPortFromPreferences());\n-    updatePathText();\n-  }\n-\n-  private void updatePathText() {\n-    StringBuilder sb =\n-        new StringBuilder(getResources().getString(R.string.ftp_path))\n-            .append(\": \")\n-            .append(getDefaultPathFromPreferences());\n-    if (getReadonlyPreference()) sb.append(\" \\uD83D\\uDD12\");\n-    sharedPath.setText(sb.toString());\n-  }\n-\n-  /** Updates the status spans */\n-  private void updateSpans() {\n-\n-    String ftpAddress = getFTPAddressString();\n-\n-    if (ftpAddress == null) {\n-      ftpAddress = \"\";\n-      Toast.makeText(\n-              getContext(),\n-              getResources().getString(R.string.local_inet_addr_error),\n-              Toast.LENGTH_SHORT)\n-          .show();\n-    }\n-\n-    String statusHead = getResources().getString(R.string.ftp_status_title) + \": \";\n-\n-    spannedStatusConnected =\n-        Html.fromHtml(\n-            statusHead\n-                + \"<b>&nbsp;&nbsp;\"\n-                + \"<font color='\"\n-                + accentColor\n-                + \"'>\"\n-                + getResources().getString(R.string.ftp_status_running)\n-                + \"</font></b>\");\n-    spannedStatusUrl = Html.fromHtml(\"URL:&nbsp;\" + ftpAddress);\n-    spannedStatusNoConnection =\n-        Html.fromHtml(\n-            statusHead\n-                + \"<b>&nbsp;&nbsp;&nbsp;&nbsp;\"\n-                + \"<font color='\"\n-                + Utils.getColor(getContext(), android.R.color.holo_red_light)\n-                + \"'>\"\n-                + getResources().getString(R.string.ftp_status_no_connection)\n-                + \"</font></b>\");\n-\n-    spannedStatusNotRunning =\n-        Html.fromHtml(\n-            statusHead\n-                + \"<b>&nbsp;&nbsp;&nbsp;&nbsp;\"\n-                + getResources().getString(R.string.ftp_status_not_running)\n-                + \"</b>\");\n-    spannedStatusSecure =\n-        Html.fromHtml(\n-            statusHead\n-                + \"<b>&nbsp;&nbsp;&nbsp;&nbsp;\"\n-                + \"<font color='\"\n-                + Utils.getColor(getContext(), android.R.color.holo_green_light)\n-                + \"'>\"\n-                + getResources().getString(R.string.ftp_status_secure_connection)\n-                + \"</font></b>\");\n-    spannedStatusUrl = Html.fromHtml(\"URL:&nbsp;\" + ftpAddress);\n-  }\n-\n-  private void initLoginDialogViews(View loginDialogView) {\n-\n-    usernameEditText = loginDialogView.findViewById(R.id.edit_text_dialog_ftp_username);\n-    passwordEditText = loginDialogView.findViewById(R.id.edit_text_dialog_ftp_password);\n-    usernameTextInput = loginDialogView.findViewById(R.id.text_input_dialog_ftp_username);\n-    passwordTextInput = loginDialogView.findViewById(R.id.text_input_dialog_ftp_password);\n-    anonymousCheckBox = loginDialogView.findViewById(R.id.checkbox_ftp_anonymous);\n-\n-    anonymousCheckBox.setOnCheckedChangeListener(\n-        (buttonView, isChecked) -> {\n-          if (isChecked) {\n-            usernameEditText.setEnabled(false);\n-            passwordEditText.setEnabled(false);\n-          } else {\n-            usernameEditText.setEnabled(true);\n-            passwordEditText.setEnabled(true);\n-          }\n-        });\n-\n-    // init dialog views as per preferences\n-    if (getUsernameFromPreferences().equals(FtpService.DEFAULT_USERNAME)) {\n-      anonymousCheckBox.setChecked(true);\n-    } else {\n-\n-      usernameEditText.setText(getUsernameFromPreferences());\n-      passwordEditText.setText(getPasswordFromPreferences());\n-    }\n-  }\n-\n-  /** @return address at which server is running */\n-  @Nullable\n-  private String getFTPAddressString() {\n-    InetAddress ia = FtpService.getLocalInetAddress(getContext());\n-    if (ia == null) return null;\n-\n-    return (getSecurePreference() ? FtpService.INITIALS_HOST_SFTP : FtpService.INITIALS_HOST_FTP)\n-        + ia.getHostAddress()\n-        + \":\"\n-        + getDefaultPortFromPreferences();\n-  }\n-\n-  private int getDefaultPortFromPreferences() {\n-    return getMainActivity()\n-        .getPrefs()\n-        .getInt(FtpService.PORT_PREFERENCE_KEY, FtpService.DEFAULT_PORT);\n-  }\n-\n-  private String getUsernameFromPreferences() {\n-    return getMainActivity()\n-        .getPrefs()\n-        .getString(FtpService.KEY_PREFERENCE_USERNAME, FtpService.DEFAULT_USERNAME);\n-  }\n-\n-  private String getPasswordFromPreferences() {\n-    try {\n-      String encryptedPassword =\n-          getMainActivity().getPrefs().getString(FtpService.KEY_PREFERENCE_PASSWORD, \"\");\n-\n-      if (encryptedPassword.equals(\"\")) {\n-        return \"\";\n-      } else {\n-        return CryptUtil.decryptPassword(getContext(), encryptedPassword);\n-      }\n-    } catch (GeneralSecurityException | IOException e) {\n-      e.printStackTrace();\n-\n-      Toast.makeText(getContext(), getResources().getString(R.string.error), Toast.LENGTH_SHORT)\n-          .show();\n-      // can't decrypt the password saved in preferences, remove the preference altogether\n-      getMainActivity().getPrefs().edit().putString(FtpService.KEY_PREFERENCE_PASSWORD, \"\").apply();\n-      return \"\";\n-    }\n-  }\n-\n-  private String getDefaultPathFromPreferences() {\n-    SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(getActivity());\n-\n-    return preferences.getString(FtpService.KEY_PREFERENCE_PATH, FtpService.DEFAULT_PATH);\n-  }\n-\n-  private void changeFTPServerPort(int port) {\n-    getMainActivity().getPrefs().edit().putInt(FtpService.PORT_PREFERENCE_KEY, port).apply();\n-\n-    // first update spans which will point to an updated status\n-    updateSpans();\n-    updateStatus();\n-  }\n-\n-  public void changeFTPServerPath(String path) {\n-    SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(getActivity());\n-    preferences.edit().putString(FtpService.KEY_PREFERENCE_PATH, path).apply();\n-\n-    updateStatus();\n-  }\n-\n-  private void setFTPUsername(String username) {\n-    getMainActivity()\n-        .getPrefs()\n-        .edit()\n-        .putString(FtpService.KEY_PREFERENCE_USERNAME, username)\n-        .apply();\n-    updateStatus();\n-  }\n-\n-  private void setFTPPassword(String password) {\n-    try {\n-      getMainActivity()\n-          .getPrefs()\n-          .edit()\n-          .putString(\n-              FtpService.KEY_PREFERENCE_PASSWORD, CryptUtil.encryptPassword(getContext(), password))\n-          .apply();\n-    } catch (GeneralSecurityException | IOException e) {\n-      e.printStackTrace();\n-      Toast.makeText(getContext(), getResources().getString(R.string.error), Toast.LENGTH_LONG)\n-          .show();\n-    }\n-    updateStatus();\n-  }\n-\n-  /**\n-   * Returns timeout from preferences\n-   *\n-   * @return timeout in seconds\n-   */\n-  private int getFTPTimeout() {\n-    return getMainActivity()\n-        .getPrefs()\n-        .getInt(FtpService.KEY_PREFERENCE_TIMEOUT, FtpService.DEFAULT_TIMEOUT);\n-  }\n-\n-  private void setFTPTimeout(int seconds) {\n-    getMainActivity().getPrefs().edit().putInt(FtpService.KEY_PREFERENCE_TIMEOUT, seconds).apply();\n-  }\n-\n-  private boolean getSecurePreference() {\n-    return getMainActivity()\n-        .getPrefs()\n-        .getBoolean(FtpService.KEY_PREFERENCE_SECURE, FtpService.DEFAULT_SECURE);\n-  }\n-\n-  private void setSecurePreference(boolean isSecureEnabled) {\n-    getMainActivity()\n-        .getPrefs()\n-        .edit()\n-        .putBoolean(FtpService.KEY_PREFERENCE_SECURE, isSecureEnabled)\n-        .apply();\n-  }\n-\n-  private boolean getReadonlyPreference() {\n-    return getMainActivity().getPrefs().getBoolean(FtpService.KEY_PREFERENCE_READONLY, false);\n-  }\n-\n-  private void setReadonlyPreference(boolean isReadonly) {\n-    getMainActivity()\n-        .getPrefs()\n-        .edit()\n-        .putBoolean(FtpService.KEY_PREFERENCE_READONLY, isReadonly)\n-        .apply();\n-  }\n-\n-  private void promptUserToRestartServer() {\n-    if (FtpService.isRunning()) AppConfig.toast(getContext(), R.string.ftp_prompt_restart_server);\n-  }\n-\n-  private void promptUserToEnableWireless(@Nullable NetworkInfo ni) {\n-    // No wifi, no data, no connection at all\n-    if (ni == null || !ni.isConnected()) {\n-      snackbar =\n-          Utils.showThemedSnackbar(\n-              (MainActivity) getActivity(),\n-              getString(R.string.ftp_server_prompt_connect_to_network),\n-              BaseTransientBottomBar.LENGTH_INDEFINITE,\n-              R.string.ftp_server_open_settings,\n-              () -> startActivity(new Intent(ACTION_WIFI_SETTINGS)));\n-      snackbar.show();\n-    }\n-  }\n-\n-  private void dismissSnackbar() {\n-    if (snackbar != null) {\n-      snackbar.dismiss();\n-      snackbar = null;\n-    }\n-  }\n-}"
  },
  {
    "sha": "988ba0ce925f7ec437939412dc0718dbbdd47586",
    "filename": "app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.kt",
    "status": "added",
    "additions": 724,
    "deletions": 0,
    "changes": 724,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.kt",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.kt",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.kt?ref=8e0d0d81ede9bdb136251bc6f7d497697f16d6e0",
    "patch": "@@ -0,0 +1,724 @@\n+/*\n+ * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,\n+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.\n+ *\n+ * This file is part of Amaze File Manager.\n+ *\n+ * Amaze File Manager is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.amaze.filemanager.ui.fragments\n+\n+import android.app.Activity.RESULT_OK\n+import android.content.BroadcastReceiver\n+import android.content.Context\n+import android.content.Intent\n+import android.content.IntentFilter\n+import android.graphics.drawable.ColorDrawable\n+import android.net.ConnectivityManager\n+import android.net.Uri\n+import android.os.Build\n+import android.os.Build.VERSION_CODES.LOLLIPOP\n+import android.os.Build.VERSION_CODES.M\n+import android.os.Bundle\n+import android.os.Environment\n+import android.preference.PreferenceManager\n+import android.provider.Settings\n+import android.text.InputType\n+import android.text.Spanned\n+import android.view.*\n+import android.widget.*\n+import androidx.activity.result.contract.ActivityResultContracts\n+import androidx.core.text.HtmlCompat\n+import androidx.core.text.HtmlCompat.FROM_HTML_MODE_COMPACT\n+import androidx.fragment.app.Fragment\n+import com.afollestad.materialdialogs.DialogAction\n+import com.afollestad.materialdialogs.MaterialDialog\n+import com.afollestad.materialdialogs.folderselector.FolderChooserDialog\n+import com.amaze.filemanager.R\n+import com.amaze.filemanager.application.AppConfig\n+import com.amaze.filemanager.asynchronous.services.ftp.FtpService\n+import com.amaze.filemanager.asynchronous.services.ftp.FtpService.Companion.getLocalInetAddress\n+import com.amaze.filemanager.asynchronous.services.ftp.FtpService.Companion.isConnectedToLocalNetwork\n+import com.amaze.filemanager.asynchronous.services.ftp.FtpService.Companion.isConnectedToWifi\n+import com.amaze.filemanager.asynchronous.services.ftp.FtpService.Companion.isEnabledWifiHotspot\n+import com.amaze.filemanager.asynchronous.services.ftp.FtpService.Companion.isRunning\n+import com.amaze.filemanager.asynchronous.services.ftp.FtpService.FtpReceiverActions\n+import com.amaze.filemanager.databinding.DialogFtpLoginBinding\n+import com.amaze.filemanager.databinding.FragmentFtpBinding\n+import com.amaze.filemanager.filesystem.files.CryptUtil\n+import com.amaze.filemanager.ui.activities.MainActivity\n+import com.amaze.filemanager.ui.notifications.FtpNotification\n+import com.amaze.filemanager.ui.theme.AppTheme\n+import com.amaze.filemanager.utils.OneCharacterCharSequence\n+import com.amaze.filemanager.utils.Utils\n+import com.google.android.material.snackbar.BaseTransientBottomBar\n+import com.google.android.material.snackbar.Snackbar\n+import org.greenrobot.eventbus.EventBus\n+import org.greenrobot.eventbus.Subscribe\n+import org.greenrobot.eventbus.ThreadMode\n+import java.io.IOException\n+import java.security.GeneralSecurityException\n+import java.util.*\n+\n+/**\n+ * Created by yashwanthreddyg on 10-06-2016. Edited by Luca D'Amico (Luca91) on 25 Jul 2017 (Fixed\n+ * FTP Server while usi\n+ */\n+@Suppress(\"TooManyFunctions\")\n+class FtpServerFragment : Fragment(R.layout.fragment_ftp) {\n+\n+    private val statusText: TextView get() = binding.textViewFtpStatus\n+    private val url: TextView get() = binding.textViewFtpUrl\n+    private val username: TextView get() = binding.textViewFtpUsername\n+    private val password: TextView get() = binding.textViewFtpPassword\n+    private val port: TextView get() = binding.textViewFtpPort\n+    private val sharedPath: TextView get() = binding.textViewFtpPath\n+    private val ftpBtn: Button get() = binding.startStopButton\n+    private val ftpPasswordVisibleButton: ImageButton get() = binding.ftpPasswordVisible\n+    private var accentColor = 0\n+    private var spannedStatusNoConnection: Spanned? = null\n+    private var spannedStatusConnected: Spanned? = null\n+    private var spannedStatusUrl: Spanned? = null\n+    private var spannedStatusSecure: Spanned? = null\n+    private var spannedStatusNotRunning: Spanned? = null\n+    private var snackbar: Snackbar? = null\n+\n+    private var _binding: FragmentFtpBinding? = null\n+    private val binding get() = _binding!!\n+\n+    private val mainActivity: MainActivity get() = requireActivity() as MainActivity\n+\n+    @Suppress(\"LabeledExpression\")\n+    private val activityResultHandler = registerForActivityResult(\n+        ActivityResultContracts.StartActivityForResult()\n+    ) {\n+        if (it.resultCode == RESULT_OK && Build.VERSION.SDK_INT >= LOLLIPOP) {\n+            val directoryUri = it.data?.data ?: return@registerForActivityResult\n+            requireContext().contentResolver.takePersistableUriPermission(\n+                directoryUri,\n+                Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n+            )\n+            mainActivity\n+                .prefs\n+                .edit()\n+                .putString(FtpService.KEY_PREFERENCE_PATH, directoryUri.toString()).apply()\n+            updatePathText()\n+        }\n+    }\n+\n+    override fun onCreate(savedInstanceState: Bundle?) {\n+        super.onCreate(savedInstanceState)\n+        setHasOptionsMenu(true)\n+        retainInstance = true\n+        mainActivity.appbar.setTitle(R.string.ftp)\n+        mainActivity.fab.hide()\n+        mainActivity.appbar.bottomBar.setVisibility(View.GONE)\n+        mainActivity.invalidateOptionsMenu()\n+        val skin_color = mainActivity.currentColorPreference.primaryFirstTab\n+        val skinTwoColor = mainActivity.currentColorPreference.primarySecondTab\n+        mainActivity.updateViews(\n+            ColorDrawable(\n+                if (MainActivity.currentTab == 1) {\n+                    skinTwoColor\n+                } else {\n+                    skin_color\n+                }\n+            )\n+        )\n+    }\n+\n+    override fun onDestroyView() {\n+        super.onDestroyView()\n+        _binding = null\n+    }\n+\n+    override fun onCreateView(\n+        inflater: LayoutInflater,\n+        container: ViewGroup?,\n+        savedInstanceState: Bundle?\n+    ): View {\n+        _binding = FragmentFtpBinding.inflate(inflater)\n+        val startDividerView = binding.dividerFtpStart\n+        val statusDividerView = binding.dividerFtpStatus\n+        accentColor = mainActivity.accent\n+        updateSpans()\n+        updateStatus()\n+        when (mainActivity.appTheme.simpleTheme) {\n+            AppTheme.LIGHT -> {\n+                startDividerView.setBackgroundColor(Utils.getColor(context, R.color.divider))\n+                statusDividerView.setBackgroundColor(Utils.getColor(context, R.color.divider))\n+            }\n+            AppTheme.DARK, AppTheme.BLACK -> {\n+                startDividerView.setBackgroundColor(\n+                    Utils.getColor(context, R.color.divider_dark_card)\n+                )\n+                statusDividerView.setBackgroundColor(\n+                    Utils.getColor(context, R.color.divider_dark_card)\n+                )\n+            }\n+            else -> {}\n+        }\n+        ftpBtn.setOnClickListener {\n+            if (!isRunning()) {\n+                if (isConnectedToWifi(requireContext()) ||\n+                    isConnectedToLocalNetwork(requireContext()) ||\n+                    isEnabledWifiHotspot(requireContext())\n+                ) {\n+                    startServer()\n+                } else {\n+                    // no Wi-Fi and no eth, we shouldn't be here in the first place,\n+                    // because of broadcast receiver, but just to be sure\n+                    statusText.text = spannedStatusNoConnection\n+                }\n+            } else {\n+                stopServer()\n+            }\n+        }\n+        return binding.root\n+    }\n+\n+    // Pending upgrading material-dialogs to simplify the logic here.\n+    @Suppress(\"ComplexMethod\", \"LongMethod\")\n+    override fun onOptionsItemSelected(item: MenuItem): Boolean {\n+        when (item.itemId) {\n+            R.id.choose_ftp_port -> {\n+                val currentFtpPort = defaultPortFromPreferences\n+                MaterialDialog.Builder(requireContext())\n+                    .input(\n+                        getString(R.string.ftp_port_edit_menu_title),\n+                        currentFtpPort.toString(),\n+                        true\n+                    ) { _: MaterialDialog?, _: CharSequence? -> }\n+                    .inputType(InputType.TYPE_CLASS_NUMBER)\n+                    .onPositive { dialog: MaterialDialog, which: DialogAction? ->\n+                        val editText = dialog.inputEditText\n+                        if (editText != null) {\n+                            val name = editText.text.toString()\n+                            val portNumber = name.toInt()\n+                            if (portNumber < 1024) {\n+                                Toast.makeText(\n+                                    activity,\n+                                    R.string.ftp_port_change_error_invalid,\n+                                    Toast.LENGTH_SHORT\n+                                )\n+                                    .show()\n+                            } else {\n+                                changeFTPServerPort(portNumber)\n+                                Toast.makeText(\n+                                    activity, R.string.ftp_port_change_success, Toast.LENGTH_SHORT\n+                                )\n+                                    .show()\n+                            }\n+                        }\n+                    }\n+                    .positiveText(getString(R.string.change).toUpperCase())\n+                    .negativeText(R.string.cancel)\n+                    .build()\n+                    .show()\n+                return true\n+            }\n+            R.id.ftp_path -> {\n+                if (Build.VERSION.SDK_INT >= M) {\n+                    activityResultHandler.launch(Intent(Intent.ACTION_OPEN_DOCUMENT_TREE))\n+                } else {\n+                    val dialogBuilder = FolderChooserDialog.Builder(requireActivity())\n+                    dialogBuilder\n+                        .chooseButton(R.string.choose_folder)\n+                        .initialPath(defaultPathFromPreferences)\n+                        .goUpLabel(getString(R.string.folder_go_up_one_level))\n+                        .cancelButton(R.string.cancel)\n+                        .tag(TAG)\n+                        .build()\n+                        .show(activity)\n+                }\n+\n+                return true\n+            }\n+            R.id.ftp_login -> {\n+                val loginDialogBuilder = MaterialDialog.Builder(requireContext())\n+                val loginDialogView =\n+                    DialogFtpLoginBinding.inflate(LayoutInflater.from(requireContext())).apply {\n+                        initLoginDialogViews(this)\n+                        loginDialogBuilder.onPositive { dialog: MaterialDialog, _: DialogAction ->\n+                            if (checkboxFtpAnonymous.isChecked) {\n+                                // remove preferences\n+                                setFTPUsername(\"\")\n+                                setFTPPassword(\"\")\n+                            } else {\n+                                // password and username field not empty, let's set them to preferences\n+                                setFTPUsername(editTextDialogFtpUsername.text.toString())\n+                                setFTPPassword(editTextDialogFtpPassword.text.toString())\n+                            }\n+                        }\n+                    }\n+                val dialog = loginDialogBuilder.customView(loginDialogView.root, true)\n+                    .title(getString(R.string.ftp_login))\n+                    .positiveText(getString(R.string.set).toUpperCase())\n+                    .negativeText(getString(R.string.cancel))\n+                    .build()\n+\n+                // TextWatcher for port number was deliberately removed. It didn't work anyway, so\n+                // no reason to keep here. Pending reimplementation when material-dialogs lib is\n+                // upgraded.\n+\n+                dialog.show()\n+                return true\n+            }\n+            R.id.checkbox_ftp_readonly -> {\n+                val shouldReadonly = !item.isChecked\n+                item.isChecked = shouldReadonly\n+                readonlyPreference = shouldReadonly\n+                updatePathText()\n+                promptUserToRestartServer()\n+                return true\n+            }\n+            R.id.checkbox_ftp_secure -> {\n+                val shouldSecure = !item.isChecked\n+                item.isChecked = shouldSecure\n+                securePreference = shouldSecure\n+                promptUserToRestartServer()\n+                return true\n+            }\n+            R.id.ftp_timeout -> {\n+                val timeoutBuilder = MaterialDialog.Builder(requireActivity())\n+                timeoutBuilder.title(\n+                    getString(R.string.ftp_timeout) +\n+                        \" (\" +\n+                        resources.getString(R.string.ftp_seconds) +\n+                        \")\"\n+                )\n+                timeoutBuilder.input(\n+                    (\n+                        FtpService.DEFAULT_TIMEOUT.toString() +\n+                            \" \" +\n+                            resources.getString(R.string.ftp_seconds)\n+                        ),\n+                    ftpTimeout.toString(),\n+                    true\n+                ) { _: MaterialDialog?, input: CharSequence ->\n+                    val isInputInteger: Boolean = try {\n+                        // try parsing for integer check\n+                        input.toString().toInt()\n+                        true\n+                    } catch (e: NumberFormatException) {\n+                        false\n+                    }\n+                    ftpTimeout = if (input.isEmpty() || !isInputInteger) {\n+                        FtpService.DEFAULT_TIMEOUT\n+                    } else {\n+                        Integer.valueOf(input.toString())\n+                    }\n+                }\n+                timeoutBuilder\n+                    .positiveText(resources.getString(R.string.set).toUpperCase())\n+                    .negativeText(resources.getString(R.string.cancel))\n+                    .build()\n+                    .show()\n+                return true\n+            }\n+        }\n+        return false\n+    }\n+\n+    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {\n+        mainActivity.menuInflater.inflate(R.menu.ftp_server_menu, menu)\n+        menu.findItem(R.id.checkbox_ftp_readonly).isChecked = readonlyPreference\n+        menu.findItem(R.id.checkbox_ftp_secure).isChecked = securePreference\n+    }\n+\n+    private val mWifiReceiver: BroadcastReceiver = object : BroadcastReceiver() {\n+        override fun onReceive(context: Context, intent: Intent) {\n+            // connected to Wi-Fi or eth\n+            if (isConnectedToLocalNetwork(context)) {\n+                ftpBtn.isEnabled = true\n+                dismissSnackbar()\n+            } else {\n+                // Wi-Fi or eth connection lost\n+                stopServer()\n+                statusText.text = spannedStatusNoConnection\n+                ftpBtn.isEnabled = false\n+                ftpBtn.text = resources.getString(R.string.start_ftp).toUpperCase()\n+                promptUserToEnableWireless()\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles messages sent from [EventBus].\n+     *\n+     * @param signal as [FtpReceiverActions]\n+     */\n+    @Subscribe(threadMode = ThreadMode.MAIN_ORDERED)\n+    @Suppress(\"StringLiteralDuplication\")\n+    fun onFtpReceiveActions(signal: FtpReceiverActions) {\n+        updateSpans()\n+        when (signal) {\n+            FtpReceiverActions.STARTED, FtpReceiverActions.STARTED_FROM_TILE -> {\n+                statusText.text = if (securePreference) spannedStatusSecure\n+                else spannedStatusConnected\n+\n+                url.text = spannedStatusUrl\n+                ftpBtn.text = resources.getString(R.string.stop_ftp).toUpperCase()\n+                FtpNotification.updateNotification(\n+                    context,\n+                    FtpReceiverActions.STARTED_FROM_TILE == signal\n+                )\n+            }\n+            FtpReceiverActions.FAILED_TO_START -> {\n+                statusText.text = spannedStatusNotRunning\n+                Toast.makeText(context, R.string.unknown_error, Toast.LENGTH_LONG).show()\n+                ftpBtn.text = resources.getString(R.string.start_ftp).toUpperCase()\n+                url.text = \"URL: \"\n+            }\n+            FtpReceiverActions.STOPPED -> {\n+                statusText.text = spannedStatusNotRunning\n+                url.text = \"URL: \"\n+                ftpBtn.text = resources.getString(R.string.start_ftp).toUpperCase()\n+            }\n+        }\n+    }\n+\n+    /** Sends a broadcast to start ftp server  */\n+    private fun startServer() {\n+        requireContext().sendBroadcast(\n+            Intent(FtpService.ACTION_START_FTPSERVER)\n+                .setPackage(requireContext().packageName)\n+        )\n+    }\n+\n+    /** Sends a broadcast to stop ftp server  */\n+    private fun stopServer() {\n+        requireContext().sendBroadcast(\n+            Intent(FtpService.ACTION_STOP_FTPSERVER)\n+                .setPackage(requireContext().packageName)\n+        )\n+    }\n+\n+    override fun onResume() {\n+        super.onResume()\n+        val wifiFilter = IntentFilter()\n+        wifiFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION)\n+        requireContext().registerReceiver(mWifiReceiver, wifiFilter)\n+        EventBus.getDefault().register(this)\n+    }\n+\n+    override fun onPause() {\n+        super.onPause()\n+        requireContext().unregisterReceiver(mWifiReceiver)\n+        EventBus.getDefault().unregister(this)\n+        dismissSnackbar()\n+    }\n+\n+    /** Update UI widgets after change in shared preferences  */\n+    private fun updateStatus() {\n+        if (!isRunning()) {\n+            if (!isConnectedToWifi(requireContext()) &&\n+                !isConnectedToLocalNetwork(requireContext()) &&\n+                !isEnabledWifiHotspot(requireContext())\n+            ) {\n+                statusText.text = spannedStatusNoConnection\n+                ftpBtn.isEnabled = false\n+            } else {\n+                statusText.text = spannedStatusNotRunning\n+                ftpBtn.isEnabled = true\n+            }\n+            url.text = \"URL: \"\n+            ftpBtn.text = resources.getString(R.string.start_ftp).toUpperCase()\n+        } else {\n+            accentColor = mainActivity.accent\n+            url.text = spannedStatusUrl\n+            statusText.text = spannedStatusConnected\n+            ftpBtn.isEnabled = true\n+            ftpBtn.text = resources.getString(R.string.stop_ftp).toUpperCase()\n+        }\n+        val passwordDecrypted = passwordFromPreferences\n+        val passwordBulleted: CharSequence = OneCharacterCharSequence(\n+            '\\u25CF',\n+            passwordDecrypted!!.length\n+        )\n+        username.text = \"${resources.getString(R.string.username)}: $usernameFromPreferences\"\n+        password.text = \"${resources.getString(R.string.password)}: $passwordBulleted\"\n+        ftpPasswordVisibleButton.setImageDrawable(\n+            resources.getDrawable(R.drawable.ic_eye_grey600_24dp)\n+        )\n+        ftpPasswordVisibleButton.visibility = if (passwordDecrypted.isEmpty()) {\n+            View.GONE\n+        } else {\n+            View.VISIBLE\n+        }\n+        ftpPasswordVisibleButton.setOnClickListener { v: View? ->\n+            if (password.text.toString().contains(\"\\u25CF\")) {\n+                // password was not visible, let's make it visible\n+                password.text = resources.getString(R.string.password) + \": \" + passwordDecrypted\n+                ftpPasswordVisibleButton.setImageDrawable(\n+                    resources.getDrawable(R.drawable.ic_eye_off_grey600_24dp)\n+                )\n+            } else {\n+                // password was visible, let's hide it\n+                password.text = resources.getString(R.string.password) + \": \" + passwordBulleted\n+                ftpPasswordVisibleButton.setImageDrawable(\n+                    resources.getDrawable(R.drawable.ic_eye_grey600_24dp)\n+                )\n+            }\n+        }\n+        port.text = \"${resources.getString(R.string.ftp_port)}: $defaultPortFromPreferences\"\n+        updatePathText()\n+    }\n+\n+    private fun updatePathText() {\n+        val sb = StringBuilder(resources.getString(R.string.ftp_path))\n+            .append(\": \")\n+            .append(defaultPathFromPreferences)\n+        if (readonlyPreference) sb.append(\" \\uD83D\\uDD12\")\n+        sharedPath.text = sb.toString()\n+    }\n+\n+    /** Updates the status spans  */\n+    private fun updateSpans() {\n+        var ftpAddress = ftpAddressString\n+        if (ftpAddress == null) {\n+            ftpAddress = \"\"\n+            Toast.makeText(\n+                context,\n+                resources.getString(R.string.local_inet_addr_error),\n+                Toast.LENGTH_SHORT\n+            )\n+                .show()\n+        }\n+        val statusHead = \"${resources.getString(R.string.ftp_status_title)}: \"\n+        spannedStatusConnected = HtmlCompat.fromHtml(\n+            \"$statusHead<b>&nbsp;&nbsp;<font color='$accentColor'>\" +\n+                \"${resources.getString(R.string.ftp_status_running)}</font></b>\",\n+            FROM_HTML_MODE_COMPACT\n+        )\n+        spannedStatusUrl = HtmlCompat.fromHtml(\n+            \"URL:&nbsp;$ftpAddress\",\n+            FROM_HTML_MODE_COMPACT\n+        )\n+        spannedStatusNoConnection = HtmlCompat.fromHtml(\n+            \"$statusHead<b>&nbsp;&nbsp;&nbsp;&nbsp;\" +\n+                \"<font color='${Utils.getColor(context, android.R.color.holo_red_light)}'>\" +\n+                \"${resources.getString(R.string.ftp_status_no_connection)}</font></b>\",\n+            FROM_HTML_MODE_COMPACT\n+        )\n+        spannedStatusNotRunning = HtmlCompat.fromHtml(\n+            \"$statusHead<b>&nbsp;&nbsp;&nbsp;&nbsp;\" +\n+                \"${resources.getString(R.string.ftp_status_not_running)}</b>\",\n+            FROM_HTML_MODE_COMPACT\n+        )\n+        spannedStatusSecure = HtmlCompat.fromHtml(\n+            \"$statusHead<b>&nbsp;&nbsp;&nbsp;&nbsp;<font color='${Utils.getColor(\n+                context,\n+                android.R.color.holo_green_light\n+            )}'>\" +\n+                \"${resources.getString(R.string.ftp_status_secure_connection)}</font></b>\",\n+            FROM_HTML_MODE_COMPACT\n+        )\n+        spannedStatusUrl = HtmlCompat.fromHtml(\n+            \"URL:&nbsp;$ftpAddress\",\n+            FROM_HTML_MODE_COMPACT\n+        )\n+    }\n+\n+    private fun initLoginDialogViews(loginDialogView: DialogFtpLoginBinding) {\n+        val usernameEditText = loginDialogView.editTextDialogFtpUsername\n+        val passwordEditText = loginDialogView.editTextDialogFtpPassword\n+        val anonymousCheckBox = loginDialogView.checkboxFtpAnonymous\n+        anonymousCheckBox.setOnCheckedChangeListener { _: CompoundButton?, isChecked: Boolean ->\n+            usernameEditText.isEnabled = !isChecked\n+            passwordEditText.isEnabled = !isChecked\n+        }\n+\n+        // init dialog views as per preferences\n+        if (usernameFromPreferences == FtpService.DEFAULT_USERNAME) {\n+            anonymousCheckBox.isChecked = true\n+        } else {\n+            usernameEditText.setText(usernameFromPreferences)\n+            passwordEditText.setText(passwordFromPreferences)\n+        }\n+    }\n+\n+    // return address the FTP server is running\n+    private val ftpAddressString: String?\n+        get() {\n+            val ia = getLocalInetAddress(requireContext()) ?: return null\n+            return (\n+                (\n+                    if (securePreference) {\n+                        FtpService.INITIALS_HOST_SFTP\n+                    } else {\n+                        FtpService.INITIALS_HOST_FTP\n+                    }\n+                    ) +\n+                    ia.hostAddress +\n+                    \":\" +\n+                    defaultPortFromPreferences\n+                )\n+        }\n+\n+    private val defaultPortFromPreferences: Int\n+        get() = mainActivity.prefs\n+            .getInt(FtpService.PORT_PREFERENCE_KEY, FtpService.DEFAULT_PORT)\n+    private val usernameFromPreferences: String\n+        get() = mainActivity.prefs\n+            .getString(FtpService.KEY_PREFERENCE_USERNAME, FtpService.DEFAULT_USERNAME)!!\n+\n+    // can't decrypt the password saved in preferences, remove the preference altogether\n+    private val passwordFromPreferences: String?\n+        get() = runCatching {\n+            val encryptedPassword = mainActivity.prefs.getString(\n+                FtpService.KEY_PREFERENCE_PASSWORD, \"\"\n+            )\n+            if (encryptedPassword == \"\") {\n+                \"\"\n+            } else {\n+                CryptUtil.decryptPassword(requireContext(), encryptedPassword)\n+            }\n+        }.onFailure {\n+            it.printStackTrace()\n+            Toast.makeText(requireContext(), R.string.error, Toast.LENGTH_SHORT).show()\n+            mainActivity.prefs.edit().putString(FtpService.KEY_PREFERENCE_PASSWORD, \"\").apply()\n+        }.getOrNull()\n+\n+    private val defaultPathFromPreferences: String\n+        get() {\n+            return pathToDisplayString(\n+                PreferenceManager.getDefaultSharedPreferences(activity)\n+                    .getString(FtpService.KEY_PREFERENCE_PATH, FtpService.DEFAULT_PATH)!!\n+            )\n+        }\n+\n+    private fun pathToDisplayString(path: String): String {\n+        return when {\n+            path == FtpService.DEFAULT_PATH -> {\n+                Environment.getExternalStorageDirectory().absolutePath\n+            }\n+            path.startsWith(\"file:///\") -> {\n+                path.substringAfter(\"file://\")\n+            }\n+            path.startsWith(\"content://\") -> {\n+                return Uri.parse(path).let {\n+                    \"/storage${it.path?.replace(':', '/')}\"\n+                }\n+            }\n+            else -> {\n+                path\n+            }\n+        }\n+    }\n+\n+    private fun changeFTPServerPort(port: Int) {\n+        mainActivity.prefs.edit().putInt(FtpService.PORT_PREFERENCE_KEY, port).apply()\n+\n+        // first update spans which will point to an updated status\n+        updateSpans()\n+        updateStatus()\n+    }\n+\n+    /**\n+     * Update FTP server shared path in [android.content.SharedPreferences].\n+     *\n+     * @param path new shared path. Can be either absolute path (pre 4.4) or URI, which can be\n+     * <code>file:///</code> or <code>content://</code> as prefix\n+     */\n+    fun changeFTPServerPath(path: String) {\n+        val preferences = PreferenceManager.getDefaultSharedPreferences(activity)\n+        preferences.edit().putString(FtpService.KEY_PREFERENCE_PATH, path).apply()\n+        updateStatus()\n+    }\n+\n+    private fun setFTPUsername(username: String) {\n+        mainActivity\n+            .prefs\n+            .edit()\n+            .putString(FtpService.KEY_PREFERENCE_USERNAME, username)\n+            .apply()\n+        updateStatus()\n+    }\n+\n+    private fun setFTPPassword(password: String) {\n+        try {\n+            mainActivity\n+                .prefs\n+                .edit()\n+                .putString(\n+                    FtpService.KEY_PREFERENCE_PASSWORD, CryptUtil.encryptPassword(context, password)\n+                )\n+                .apply()\n+        } catch (e: GeneralSecurityException) {\n+            e.printStackTrace()\n+            Toast.makeText(context, resources.getString(R.string.error), Toast.LENGTH_LONG)\n+                .show()\n+        } catch (e: IOException) {\n+            e.printStackTrace()\n+            Toast.makeText(context, resources.getString(R.string.error), Toast.LENGTH_LONG)\n+                .show()\n+        }\n+        updateStatus()\n+    }\n+\n+    // Returns timeout from preferences, in seconds\n+    private var ftpTimeout: Int\n+        get() = mainActivity\n+            .prefs\n+            .getInt(FtpService.KEY_PREFERENCE_TIMEOUT, FtpService.DEFAULT_TIMEOUT)\n+        private set(seconds) {\n+            mainActivity.prefs.edit().putInt(FtpService.KEY_PREFERENCE_TIMEOUT, seconds).apply()\n+        }\n+\n+    private var securePreference: Boolean\n+        get() = mainActivity\n+            .prefs\n+            .getBoolean(FtpService.KEY_PREFERENCE_SECURE, FtpService.DEFAULT_SECURE)\n+        private set(isSecureEnabled) {\n+            mainActivity\n+                .prefs\n+                .edit()\n+                .putBoolean(FtpService.KEY_PREFERENCE_SECURE, isSecureEnabled)\n+                .apply()\n+        }\n+\n+    private var readonlyPreference: Boolean\n+        get() = mainActivity.prefs.getBoolean(FtpService.KEY_PREFERENCE_READONLY, false)\n+        private set(isReadonly) {\n+            mainActivity\n+                .prefs\n+                .edit()\n+                .putBoolean(FtpService.KEY_PREFERENCE_READONLY, isReadonly)\n+                .apply()\n+        }\n+\n+    private fun promptUserToRestartServer() {\n+        if (isRunning()) AppConfig.toast(context, R.string.ftp_prompt_restart_server)\n+    }\n+\n+    private fun promptUserToEnableWireless() {\n+        // No wifi, no data, no connection at all\n+        snackbar = Utils.showThemedSnackbar(\n+            activity as MainActivity?,\n+            getString(R.string.ftp_server_prompt_connect_to_network),\n+            BaseTransientBottomBar.LENGTH_INDEFINITE,\n+            R.string.ftp_server_open_settings\n+        ) { startActivity(Intent(Settings.ACTION_WIFI_SETTINGS)) }\n+        snackbar!!.show()\n+    }\n+\n+    private fun dismissSnackbar() = snackbar?.dismiss()\n+\n+    companion object {\n+        const val TAG = \"FtpServerFragment\"\n+        const val REQUEST_CODE_SAF_FTP = 225\n+    }\n+}"
  },
  {
    "sha": "e2be6fe4a73cd082a900f20e7719fba8b09c01e6",
    "filename": "app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java",
    "status": "modified",
    "additions": 7,
    "deletions": 3,
    "changes": 10,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java?ref=8e0d0d81ede9bdb136251bc6f7d497697f16d6e0",
    "patch": "@@ -281,6 +281,10 @@ public String getIntegralNames(String path) {\n   }\n \n   public void guideDialogForLEXA(String path) {\n+    guideDialogForLEXA(path, 3);\n+  }\n+\n+  public void guideDialogForLEXA(String path, int requestCode) {\n     final MaterialDialog.Builder x = new MaterialDialog.Builder(mainActivity);\n     x.theme(mainActivity.getAppTheme().getMaterialDialogTheme());\n     x.title(R.string.needs_access);\n@@ -299,17 +303,17 @@ public void guideDialogForLEXA(String path) {\n         .negativeText(R.string.cancel)\n         .positiveColor(accentColor)\n         .negativeColor(accentColor)\n-        .onPositive((dialog, which) -> triggerStorageAccessFramework())\n+        .onPositive((dialog, which) -> triggerStorageAccessFramework(requestCode))\n         .onNegative(\n             (dialog, which) ->\n                 Toast.makeText(mainActivity, R.string.error, Toast.LENGTH_SHORT).show());\n     final MaterialDialog y = x.build();\n     y.show();\n   }\n \n-  private void triggerStorageAccessFramework() {\n+  private void triggerStorageAccessFramework(int requestCode) {\n     Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT_TREE);\n-    mainActivity.startActivityForResult(intent, 3);\n+    mainActivity.startActivityForResult(intent, requestCode);\n   }\n \n   public void rename("
  },
  {
    "sha": "709da970679d2e3fbf71a3dffcc2a33e68f872fb",
    "filename": "app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/AbstractDeleteTaskTestBase.kt",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/AbstractDeleteTaskTestBase.kt",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/AbstractDeleteTaskTestBase.kt",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/AbstractDeleteTaskTestBase.kt?ref=8e0d0d81ede9bdb136251bc6f7d497697f16d6e0",
    "patch": "@@ -128,7 +128,7 @@ abstract class AbstractDeleteTaskTestBase {\n                     )\n                         .run {\n                             assertTrue(size > 0)\n-                            assertEquals(file.path, this[0].path)\n+                            assertEquals(file.path, this!![0].path)\n                         }\n                 }\n             }"
  },
  {
    "sha": "b52df8aa47dc35edd2b1c574b5949d014af3d8ee",
    "filename": "app/src/test/java/com/amaze/filemanager/asynchronous/services/FtpServiceTest.kt",
    "status": "added",
    "additions": 250,
    "deletions": 0,
    "changes": 250,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/test/java/com/amaze/filemanager/asynchronous/services/FtpServiceTest.kt",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/test/java/com/amaze/filemanager/asynchronous/services/FtpServiceTest.kt",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/test/java/com/amaze/filemanager/asynchronous/services/FtpServiceTest.kt?ref=8e0d0d81ede9bdb136251bc6f7d497697f16d6e0",
    "patch": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,\n+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.\n+ *\n+ * This file is part of Amaze File Manager.\n+ *\n+ * Amaze File Manager is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.amaze.filemanager.asynchronous.services\n+\n+import android.content.Context\n+import android.net.ConnectivityManager\n+import android.net.NetworkInfo\n+import android.net.Uri\n+import android.net.wifi.WifiInfo\n+import android.net.wifi.WifiManager\n+import android.os.Build.VERSION_CODES.KITKAT\n+import android.os.Environment\n+import android.preference.PreferenceManager\n+import androidx.test.core.app.ApplicationProvider\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import com.amaze.filemanager.asynchronous.services.ftp.FtpService\n+import com.amaze.filemanager.filesystem.ftpserver.AndroidFileSystemFactory\n+import com.amaze.filemanager.shadows.ShadowMultiDex\n+import org.apache.commons.net.ftp.FTPClient\n+import org.apache.ftpserver.ConnectionConfigFactory\n+import org.apache.ftpserver.FtpServer\n+import org.apache.ftpserver.FtpServerFactory\n+import org.apache.ftpserver.listener.ListenerFactory\n+import org.apache.ftpserver.usermanager.impl.BaseUser\n+import org.junit.After\n+import org.junit.Assert.*\n+import org.junit.Before\n+import org.junit.BeforeClass\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import org.robolectric.Shadows.shadowOf\n+import org.robolectric.annotation.Config\n+import org.robolectric.annotation.LooperMode\n+import org.robolectric.shadows.ShadowNetworkInfo\n+import org.robolectric.util.ReflectionHelpers\n+import java.io.ByteArrayInputStream\n+import java.io.File\n+import java.io.FileInputStream\n+import java.io.FileOutputStream\n+import java.net.InetAddress\n+import kotlin.random.Random\n+\n+@RunWith(AndroidJUnit4::class)\n+@Config(sdk = [KITKAT], shadows = [ShadowMultiDex::class])\n+@LooperMode(LooperMode.Mode.PAUSED)\n+@Suppress(\"StringLiteralDuplication\")\n+class FtpServiceTest {\n+\n+    private val FTP_PORT = 62222\n+\n+    private var server: FtpServer? = null\n+\n+    private val randomContent = Random.nextBytes(16)\n+\n+    companion object {\n+\n+        val directories = arrayOf(\n+            Environment.DIRECTORY_MUSIC,\n+            Environment.DIRECTORY_PODCASTS,\n+            Environment.DIRECTORY_RINGTONES,\n+            Environment.DIRECTORY_ALARMS,\n+            Environment.DIRECTORY_NOTIFICATIONS,\n+            Environment.DIRECTORY_PICTURES,\n+            Environment.DIRECTORY_MOVIES,\n+            Environment.DIRECTORY_DOWNLOADS,\n+            Environment.DIRECTORY_DCIM,\n+            Environment.DIRECTORY_DOCUMENTS,\n+            \"1/2/3/4/5/6/7\"\n+        )\n+\n+        /**\n+         * Create directories before tests start\n+         */\n+        @BeforeClass @JvmStatic\n+        fun bootstrap() {\n+            Environment.getExternalStorageDirectory().run {\n+                directories.forEach { dir ->\n+                    File(this, dir).mkdirs()\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test setup\n+     */\n+    @Before\n+    fun setUp() {\n+        setupNetwork()\n+        PreferenceManager.getDefaultSharedPreferences(ApplicationProvider.getApplicationContext())\n+            .run {\n+                edit().putString(\n+                    FtpService.KEY_PREFERENCE_PATH,\n+                    Environment.getExternalStorageDirectory().absolutePath\n+                )\n+                    .apply()\n+            }\n+\n+        File(Environment.getExternalStorageDirectory(), \"test.bin\").let { file ->\n+            file.writeBytes(randomContent)\n+            shadowOf(ApplicationProvider.getApplicationContext<Context>().contentResolver)\n+                .registerInputStream(Uri.fromFile(file), FileInputStream(file))\n+        }\n+\n+        FtpServerFactory().run {\n+            val connectionConfigFactory = ConnectionConfigFactory()\n+            val user = BaseUser()\n+            user.name = \"anonymous\"\n+            user.homeDirectory = Environment.getExternalStorageDirectory().absolutePath\n+            connectionConfigFactory.isAnonymousLoginEnabled = true\n+            connectionConfig = connectionConfigFactory.createConnectionConfig()\n+            userManager.save(user)\n+\n+            fileSystem = AndroidFileSystemFactory(\n+                ApplicationProvider.getApplicationContext()\n+            )\n+            addListener(\n+                \"default\",\n+                ListenerFactory().also {\n+                    it.port = FTP_PORT\n+                }.createListener()\n+            )\n+\n+            server = createServer().apply {\n+                start()\n+            }\n+        }\n+    }\n+\n+    private fun setupNetwork() {\n+        val cm = shadowOf(\n+            ApplicationProvider.getApplicationContext<Context>()\n+                .getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager\n+        )\n+        val wifiManager = shadowOf(\n+            ApplicationProvider.getApplicationContext<Context>()\n+                .getSystemService(Context.WIFI_SERVICE) as WifiManager\n+        )\n+        cm.setActiveNetworkInfo(\n+            ShadowNetworkInfo.newInstance(\n+                NetworkInfo.DetailedState.CONNECTED,\n+                ConnectivityManager.TYPE_WIFI,\n+                -1,\n+                true,\n+                NetworkInfo.State.CONNECTED\n+            )\n+        )\n+        ReflectionHelpers.callInstanceMethod<Any>(\n+            wifiManager,\n+            \"setWifiEnabled\",\n+            ReflectionHelpers.ClassParameter.from(Boolean::class.java, true)\n+        )\n+        ReflectionHelpers.callInstanceMethod<WifiInfo>(\n+            wifiManager,\n+            \"getConnectionInfo\"\n+        ).run {\n+            ReflectionHelpers.callInstanceMethod<Any>(\n+                this,\n+                \"setInetAddress\",\n+                ReflectionHelpers.ClassParameter.from(\n+                    InetAddress::class.java,\n+                    InetAddress.getLoopbackAddress()\n+                )\n+            )\n+        }\n+    }\n+\n+    /**\n+     * Kill FTP server if there is one running\n+     */\n+    @After\n+    fun tearDown() {\n+        server?.stop()\n+    }\n+\n+    /**\n+     * FIXME: documentation, making sense on the test cases\n+     */\n+    @Test\n+    fun testBasicFunctions() {\n+        assertEquals(2, 1 + 1)\n+        FTPClient().run {\n+            connect(\"127.0.0.1\", FTP_PORT)\n+            login(\"anonymous\", \"no@e.mail\")\n+            enterLocalPassiveMode()\n+            assertEquals(directories.size + 1, listFiles().size)\n+            assertTrue(changeWorkingDirectory(\"Download\"))\n+            assertEquals(0, listFiles().size)\n+            assertTrue(changeWorkingDirectory(\"..\"))\n+            assertEquals(directories.size + 1, listFiles().size)\n+            assertTrue(changeWorkingDirectory(\"/1/2/3/4/5/6/7\"))\n+            assertEquals(0, listFiles().size)\n+            assertTrue(changeWorkingDirectory(\"../\"))\n+            assertTrue(printWorkingDirectory().startsWith(\"/1/2/3/4/5/6\"))\n+            assertTrue(changeToParentDirectory())\n+            assertTrue(printWorkingDirectory().startsWith(\"/1/2/3/4/5\"))\n+            assertTrue(changeWorkingDirectory(\"../../..\"))\n+            assertTrue(printWorkingDirectory().startsWith(\"/1/2\"))\n+            assertTrue(changeWorkingDirectory(\"/\"))\n+            assertTrue(makeDirectory(\"foobar\"))\n+            assertEquals(directories.size + 2, listFiles().size)\n+            assertTrue(removeDirectory(\"foobar\"))\n+            assertEquals(directories.size + 1, listFiles().size)\n+            assertFalse(changeWorkingDirectory(\"foobar\"))\n+            assertTrue(listFiles(\"/foobar\").isNullOrEmpty())\n+            assertFalse(deleteFile(\"/nonexist.file.txt\"))\n+            assertNull(retrieveFileStream(\"/not/existing/file\"))\n+            assertFalse(\n+                retrieveFile(\n+                    \"/barrier/nonexist.file.jpg\",\n+                    FileOutputStream(File.createTempFile(\"notused\", \"output\"))\n+                )\n+            )\n+            assertTrue(changeWorkingDirectory(\"/\"))\n+            retrieveFileStream(\"test.bin\").let {\n+                assertNotNull(it)\n+                it.close()\n+            }\n+            completePendingCommand()\n+            assertTrue(printWorkingDirectory() == \"/\")\n+            assertTrue(printWorkingDirectory() == \"/\")\n+            storeFileStream(\"/test2.bin\").let {\n+                ByteArrayInputStream(Random.nextBytes(24)).copyTo(it)\n+                it.flush()\n+                it.close()\n+            }\n+            completePendingCommand()\n+            assertTrue(rename(\"/test2.bin\", \"/test2.arc.bin\"))\n+            logout()\n+        }\n+    }\n+}"
  },
  {
    "sha": "b926ba753dabbcd1e80ca49e08b6f66507068ce7",
    "filename": "app/src/test/java/com/amaze/filemanager/filesystem/AbstractOperationsTestBase.kt",
    "status": "modified",
    "additions": 7,
    "deletions": 1,
    "changes": 8,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/test/java/com/amaze/filemanager/filesystem/AbstractOperationsTestBase.kt",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/test/java/com/amaze/filemanager/filesystem/AbstractOperationsTestBase.kt",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/test/java/com/amaze/filemanager/filesystem/AbstractOperationsTestBase.kt?ref=8e0d0d81ede9bdb136251bc6f7d497697f16d6e0",
    "patch": "@@ -32,6 +32,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4\n import com.amaze.filemanager.file_operations.filesystem.OpenMode\n import com.amaze.filemanager.shadows.ShadowMultiDex\n import com.amaze.filemanager.shadows.ShadowSmbUtil\n+import com.amaze.filemanager.test.ShadowCryptUtil\n import com.amaze.filemanager.test.ShadowTabHandler\n import com.amaze.filemanager.test.TestUtils\n import com.amaze.filemanager.ui.activities.MainActivity\n@@ -52,7 +53,12 @@ import org.robolectric.shadows.ShadowSQLiteConnection\n @RunWith(AndroidJUnit4::class)\n @LooperMode(LooperMode.Mode.PAUSED)\n @Config(\n-    shadows = [ShadowSmbUtil::class, ShadowMultiDex::class, ShadowTabHandler::class],\n+    shadows = [\n+        ShadowSmbUtil::class,\n+        ShadowMultiDex::class,\n+        ShadowTabHandler::class,\n+        ShadowCryptUtil::class\n+    ],\n     sdk = [JELLY_BEAN, KITKAT, P]\n )\n abstract class AbstractOperationsTestBase {"
  },
  {
    "sha": "d8dceb60cf202cd7570f19b8d4dd7c749d2f718c",
    "filename": "app/src/test/resources/simplelogger.properties",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/TeamAmaze/AmazeFileManager/blob/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/test/resources/simplelogger.properties",
    "raw_url": "https://github.com/TeamAmaze/AmazeFileManager/raw/8e0d0d81ede9bdb136251bc6f7d497697f16d6e0/app/src/test/resources/simplelogger.properties",
    "contents_url": "https://api.github.com/repos/TeamAmaze/AmazeFileManager/contents/app/src/test/resources/simplelogger.properties?ref=8e0d0d81ede9bdb136251bc6f7d497697f16d6e0",
    "patch": "@@ -1 +1 @@\n-org.slf4j.simpleLogger.defaultLogLevel=debug\n+org.slf4j.simpleLogger.defaultLogLevel=info"
  }
]
