[
  {
    "sha": "bf56e3f08b37d0f1deca0c38618ae034b0382c71",
    "filename": "flink-tutorial-base/src/main/java/com/getindata/tutorial/base/model/Song.java",
    "status": "modified",
    "additions": 18,
    "deletions": 0,
    "changes": 18,
    "blob_url": "https://github.com/getindata/flink-tutorial/blob/4d654668273a9e03771d4601cae83f5f0f31b49c/flink-tutorial-base/src/main/java/com/getindata/tutorial/base/model/Song.java",
    "raw_url": "https://github.com/getindata/flink-tutorial/raw/4d654668273a9e03771d4601cae83f5f0f31b49c/flink-tutorial-base/src/main/java/com/getindata/tutorial/base/model/Song.java",
    "contents_url": "https://api.github.com/repos/getindata/flink-tutorial/contents/flink-tutorial-base/src/main/java/com/getindata/tutorial/base/model/Song.java?ref=4d654668273a9e03771d4601cae83f5f0f31b49c",
    "patch": "@@ -1,5 +1,7 @@\n package com.getindata.tutorial.base.model;\n \n+import java.util.Objects;\n+\n public class Song {\n \n     public static SongBuilder builder() {\n@@ -40,6 +42,7 @@ public String getAuthor() {\n     public void setId(long id) {\n         this.id = id;\n     }\n+\n     public void setLength(int length) {\n         this.length = length;\n     }\n@@ -62,4 +65,19 @@ public String toString() {\n                 '}';\n     }\n \n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        Song song = (Song) o;\n+        return id == song.id &&\n+                length == song.length &&\n+                Objects.equals(name, song.name) &&\n+                Objects.equals(author, song.author);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id, length, name, author);\n+    }\n }"
  },
  {
    "sha": "28b77177273f5ff14b873fea49f0c95c3f8fe3fe",
    "filename": "tasks/task2/src/main/java/com/getindata/solved/TopSongsRanking.java",
    "status": "added",
    "additions": 198,
    "deletions": 0,
    "changes": 198,
    "blob_url": "https://github.com/getindata/flink-tutorial/blob/4d654668273a9e03771d4601cae83f5f0f31b49c/tasks/task2/src/main/java/com/getindata/solved/TopSongsRanking.java",
    "raw_url": "https://github.com/getindata/flink-tutorial/raw/4d654668273a9e03771d4601cae83f5f0f31b49c/tasks/task2/src/main/java/com/getindata/solved/TopSongsRanking.java",
    "contents_url": "https://api.github.com/repos/getindata/flink-tutorial/contents/tasks/task2/src/main/java/com/getindata/solved/TopSongsRanking.java?ref=4d654668273a9e03771d4601cae83f5f0f31b49c",
    "patch": "@@ -0,0 +1,198 @@\n+package com.getindata.solved;\n+\n+import com.getindata.tutorial.base.input.EnrichedSongsSource;\n+import com.getindata.tutorial.base.model.EnrichedSongEvent;\n+import com.getindata.tutorial.base.model.Song;\n+import org.apache.flink.api.common.eventtime.TimestampAssigner;\n+import org.apache.flink.api.common.eventtime.TimestampAssignerSupplier;\n+import org.apache.flink.api.common.eventtime.Watermark;\n+import org.apache.flink.api.common.eventtime.WatermarkGenerator;\n+import org.apache.flink.api.common.eventtime.WatermarkGeneratorSupplier;\n+import org.apache.flink.api.common.eventtime.WatermarkOutput;\n+import org.apache.flink.api.common.eventtime.WatermarkStrategy;\n+import org.apache.flink.api.common.functions.AggregateFunction;\n+import org.apache.flink.api.java.functions.KeySelector;\n+import org.apache.flink.streaming.api.datastream.DataStream;\n+import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n+import org.apache.flink.streaming.api.functions.windowing.ProcessAllWindowFunction;\n+import org.apache.flink.streaming.api.functions.windowing.WindowFunction;\n+import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;\n+import org.apache.flink.streaming.api.windowing.time.Time;\n+import org.apache.flink.streaming.api.windowing.windows.TimeWindow;\n+import org.apache.flink.util.Collector;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.PriorityQueue;\n+\n+import static java.util.Comparator.comparing;\n+\n+public class TopSongsRanking {\n+\n+    public static void main(String[] args) throws Exception {\n+        final StreamExecutionEnvironment sEnv = StreamExecutionEnvironment.getExecutionEnvironment();\n+\n+        // create a stream of events from source\n+        final DataStream<EnrichedSongEvent> events = sEnv.addSource(new EnrichedSongsSource());\n+        // In order not to copy the whole pipeline code from production to test, we made sources and sinks pluggable in\n+        // the production code so that we can now inject test sources and test sinks in the tests.\n+        final DataStream<SongsRanking> statistics = pipeline(events);\n+\n+        // print results\n+        statistics.print();\n+\n+        // execute streams\n+        sEnv.execute();\n+    }\n+\n+    static DataStream<SongsRanking> pipeline(DataStream<EnrichedSongEvent> source) {\n+        return source\n+                .assignTimestampsAndWatermarks(new SongWatermarkStrategy())\n+                .keyBy(new SongKeySelector())\n+                .window(TumblingEventTimeWindows.of(Time.hours(1L)))\n+                .aggregate(new SongAggregationFunction(), new SongWindowFunction())\n+                .windowAll(TumblingEventTimeWindows.of(Time.hours(1L)))\n+                .process(new TopNSongsFunction(3));\n+    }\n+\n+    static class SongWatermarkStrategy implements WatermarkStrategy<EnrichedSongEvent> {\n+\n+        private static final long FIVE_MINUTES = 5 * 1000 * 60L;\n+\n+        @Override\n+        public WatermarkGenerator<EnrichedSongEvent> createWatermarkGenerator(WatermarkGeneratorSupplier.Context context) {\n+            return new WatermarkGenerator<EnrichedSongEvent>() {\n+                @Override\n+                public void onEvent(EnrichedSongEvent songEvent, long eventTimestamp, WatermarkOutput output) {\n+                    Watermark watermark = songEvent.getUserId() % 2 == 1\n+                            ? new Watermark(songEvent.getTimestamp())\n+                            : new Watermark(songEvent.getTimestamp() - FIVE_MINUTES);\n+                    output.emitWatermark(watermark);\n+                }\n+\n+                @Override\n+                public void onPeriodicEmit(WatermarkOutput output) {\n+                    // don't need to do anything because we emit in reaction to events above\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public TimestampAssigner<EnrichedSongEvent> createTimestampAssigner(TimestampAssignerSupplier.Context context) {\n+            return (element, recordTimestamp) -> element.getTimestamp();\n+        }\n+    }\n+\n+    static class SongKeySelector implements KeySelector<EnrichedSongEvent, Song> {\n+        @Override\n+        public Song getKey(EnrichedSongEvent songEvent) {\n+            return songEvent.getSong();\n+        }\n+    }\n+\n+    static class SongAggregationFunction implements AggregateFunction<EnrichedSongEvent, Long, Long> {\n+        @Override\n+        public Long createAccumulator() {\n+            return 0L;\n+        }\n+\n+        @Override\n+        public Long add(EnrichedSongEvent songEvent, Long count) {\n+            return count + 1;\n+        }\n+\n+        @Override\n+        public Long getResult(Long count) {\n+            return count;\n+\n+        }\n+\n+        @Override\n+        public Long merge(Long count1, Long count2) {\n+            return count1 + count2;\n+        }\n+\n+    }\n+\n+    static class SongWindowFunction implements WindowFunction<Long, SongAndCount, Song, TimeWindow> {\n+        @Override\n+        public void apply(Song song, TimeWindow window, Iterable<Long> input, Collector<SongAndCount> out) {\n+            long sum = 0;\n+            for (Long l : input) {\n+                sum += l;\n+            }\n+\n+            out.collect(new SongAndCount(song, sum));\n+        }\n+    }\n+\n+    static class TopNSongsFunction extends ProcessAllWindowFunction<SongAndCount, SongsRanking, TimeWindow> {\n+\n+        private final int n;\n+\n+        TopNSongsFunction(int n) {\n+            this.n = n;\n+        }\n+\n+        @Override\n+        public void process(Context context,\n+                            Iterable<SongAndCount> elements,\n+                            Collector<SongsRanking> out) throws Exception {\n+            // Iterate over elements and keep on-line topN elements in a priority queue\n+            // This is more efficient than loading all elements and sorting all of them.\n+            PriorityQueue<SongAndCount> topNElementsQueue = new PriorityQueue<>(\n+                    comparing(SongAndCount::getCount)\n+            );\n+            elements.forEach(element -> {\n+                if (topNElementsQueue.size() < this.n) {\n+                    topNElementsQueue.add(element);\n+                } else if (topNElementsQueue.peek().getCount() < element.getCount()) {\n+                    topNElementsQueue.poll();\n+                    topNElementsQueue.add(element);\n+                }\n+            });\n+\n+            List<SongAndCount> topNElements = new ArrayList<>(topNElementsQueue);\n+            Collections.reverse(topNElements);\n+\n+            out.collect(new SongsRanking(context.window(), topNElements));\n+        }\n+    }\n+\n+    static class SongAndCount {\n+        private Song song;\n+        private long count;\n+\n+        public SongAndCount(Song song, long count) {\n+            this.song = song;\n+            this.count = count;\n+        }\n+\n+        public Song getSong() {\n+            return song;\n+        }\n+\n+        public long getCount() {\n+            return count;\n+        }\n+    }\n+\n+    static class SongsRanking {\n+        private TimeWindow timeWindow;\n+        private List<SongAndCount> topSongs;\n+\n+        public SongsRanking(TimeWindow timeWindow, List<SongAndCount> topSongs) {\n+            this.timeWindow = timeWindow;\n+            this.topSongs = topSongs;\n+        }\n+\n+        public TimeWindow getTimeWindow() {\n+            return timeWindow;\n+        }\n+\n+        public List<SongAndCount> getTopSongs() {\n+            return topSongs;\n+        }\n+    }\n+}"
  },
  {
    "sha": "830f21841fab3db33efc9ddad2c96cbb7e21e543",
    "filename": "tasks/task2/src/test/java/com/getindata/solved/TopSongsRankingTest.java",
    "status": "added",
    "additions": 118,
    "deletions": 0,
    "changes": 118,
    "blob_url": "https://github.com/getindata/flink-tutorial/blob/4d654668273a9e03771d4601cae83f5f0f31b49c/tasks/task2/src/test/java/com/getindata/solved/TopSongsRankingTest.java",
    "raw_url": "https://github.com/getindata/flink-tutorial/raw/4d654668273a9e03771d4601cae83f5f0f31b49c/tasks/task2/src/test/java/com/getindata/solved/TopSongsRankingTest.java",
    "contents_url": "https://api.github.com/repos/getindata/flink-tutorial/contents/tasks/task2/src/test/java/com/getindata/solved/TopSongsRankingTest.java?ref=4d654668273a9e03771d4601cae83f5f0f31b49c",
    "patch": "@@ -0,0 +1,118 @@\n+package com.getindata.solved;\n+\n+import com.getindata.solved.TopSongsRanking.SongsRanking;\n+import com.getindata.tutorial.base.model.EnrichedSongEvent;\n+import org.apache.flink.runtime.testutils.MiniClusterResourceConfiguration;\n+import org.apache.flink.streaming.api.datastream.DataStream;\n+import org.apache.flink.streaming.api.datastream.DataStreamSource;\n+import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n+import org.apache.flink.streaming.api.functions.sink.SinkFunction;\n+import org.apache.flink.test.util.MiniClusterWithClientResource;\n+import org.junit.ClassRule;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.getindata.tutorial.base.model.TestDataBuilders.aSong;\n+import static com.getindata.tutorial.base.model.TestDataBuilders.aSongEvent;\n+import static com.google.common.collect.Lists.newArrayList;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class TopSongsRankingTest {\n+\n+    @ClassRule\n+    public static MiniClusterWithClientResource flinkCluster = new MiniClusterWithClientResource(\n+            new MiniClusterResourceConfiguration.Builder()\n+                    // It is recommended to always test your pipelines locally with a parallelism > 1 to identify bugs\n+                    // which only surface for the pipelines executed in parallel.\n+                    .setNumberSlotsPerTaskManager(2)\n+                    .setNumberTaskManagers(1)\n+                    .build()\n+    );\n+\n+    @BeforeEach\n+    void setup() {\n+        CollectSink.values.clear();\n+    }\n+\n+    @Test\n+    void shouldReturnTopThreeSongs() throws Exception {\n+        // given\n+        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n+\n+        List<EnrichedSongEvent> input = newArrayList(\n+                aSongEvent()\n+                        .setUserId(1)\n+                        .setSong(aSong().name(\"Song 3\").build())\n+                        .setTimestamp(Instant.parse(\"2012-02-10T12:00:00.0Z\").toEpochMilli())\n+                        .build(),\n+                aSongEvent()\n+                        .setUserId(2)\n+                        .setSong(aSong().name(\"Song 2\").build())\n+                        .setTimestamp(Instant.parse(\"2012-02-10T12:01:00.0Z\").toEpochMilli())\n+                        .build(),\n+                aSongEvent()\n+                        .setUserId(3)\n+                        .setSong(aSong().name(\"Song 1\").build())\n+                        .setTimestamp(Instant.parse(\"2012-02-10T12:02:00.0Z\").toEpochMilli())\n+                        .build(),\n+                aSongEvent()\n+                        .setUserId(4)\n+                        .setSong(aSong().name(\"Song 3\").build())\n+                        .setTimestamp(Instant.parse(\"2012-02-10T12:03:00.0Z\").toEpochMilli())\n+                        .build(),\n+                aSongEvent()\n+                        .setUserId(5)\n+                        .setSong(aSong().name(\"Song 2\").build())\n+                        .setTimestamp(Instant.parse(\"2012-02-10T12:04:00.0Z\").toEpochMilli())\n+                        .build(),\n+                aSongEvent()\n+                        .setUserId(6)\n+                        .setSong(aSong().name(\"Song 2\").build())\n+                        .setTimestamp(Instant.parse(\"2012-02-10T12:05:00.0Z\").toEpochMilli())\n+                        .build()\n+\n+        );\n+\n+        DataStreamSource<EnrichedSongEvent> inputEvents = env.fromCollection(input);\n+        DataStream<SongsRanking> rankings = TopSongsRanking.pipeline(inputEvents);\n+        rankings.addSink(new CollectSink());\n+\n+        // when\n+        env.execute();\n+\n+        // then\n+        // there is one ranking generated\n+        assertEquals(CollectSink.values.size(), 1);\n+\n+        // and the ranking contains songs in proper order\n+        SongsRanking ranking = CollectSink.values.get(0);\n+        assertEquals(\"Song 2\", ranking.getTopSongs().get(0).getSong().getName());\n+        assertEquals(3L, ranking.getTopSongs().get(0).getCount());\n+        assertEquals(\"Song 3\", ranking.getTopSongs().get(1).getSong().getName());\n+        assertEquals(2L, ranking.getTopSongs().get(1).getCount());\n+        assertEquals(\"Song 1\", ranking.getTopSongs().get(2).getSong().getName());\n+        assertEquals(1L, ranking.getTopSongs().get(2).getCount());\n+    }\n+\n+    /**\n+     * The static variable in CollectSink is used here because Flink serializes all operators before distributing them\n+     * across a cluster. Communicating with operators instantiated by a local Flink mini cluster via static variables\n+     * is one way around this issue. Alternatively, you could write the data to files in a temporary directory with\n+     * your test sink.\n+     */\n+    private static class CollectSink implements SinkFunction<SongsRanking> {\n+\n+        // must be static\n+        static final List<SongsRanking> values = new ArrayList<>();\n+\n+        @Override\n+        public synchronized void invoke(SongsRanking value, Context context) {\n+            values.add(value);\n+        }\n+    }\n+\n+}"
  }
]
