[
  {
    "sha": "1a2cffbc85caed718f3f83af3db2886866ad35fb",
    "filename": "src/main/java/org/fxconnector/ConnectorUtils.java",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/JonathanGiles/scenic-view/blob/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/fxconnector/ConnectorUtils.java",
    "raw_url": "https://github.com/JonathanGiles/scenic-view/raw/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/fxconnector/ConnectorUtils.java",
    "contents_url": "https://api.github.com/repos/JonathanGiles/scenic-view/contents/src/main/java/org/fxconnector/ConnectorUtils.java?ref=ef3da38c12143ef69fb4317a683a33769588a7a1",
    "patch": "@@ -101,6 +101,10 @@ public static String formatSize(final double size) {\n         return DFMT.format(size);\r\n     }\r\n \r\n+    public static String nodeIdentityCode(final  Object node) {\r\n+        return Integer.toHexString(System.identityHashCode(node));\r\n+    }\r\n+\r\n     public static String nodeClass(final Object node) {\r\n         final String value = classNames.get(node.getClass());\r\n         if (value == null) {\r"
  },
  {
    "sha": "a4cbe41f319bd0f72cfe6d12dcf7b6a419067c2e",
    "filename": "src/main/java/org/fxconnector/helper/WorkerThread.java",
    "status": "modified",
    "additions": 67,
    "deletions": 54,
    "changes": 121,
    "blob_url": "https://github.com/JonathanGiles/scenic-view/blob/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/fxconnector/helper/WorkerThread.java",
    "raw_url": "https://github.com/JonathanGiles/scenic-view/raw/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/fxconnector/helper/WorkerThread.java",
    "contents_url": "https://api.github.com/repos/JonathanGiles/scenic-view/contents/src/main/java/org/fxconnector/helper/WorkerThread.java?ref=ef3da38c12143ef69fb4317a683a33769588a7a1",
    "patch": "@@ -1,54 +1,67 @@\n-/*\r\n- * Scenic View, \r\n- * Copyright (C) 2012 Jonathan Giles, Ander Ruiz, Amy Fowler \r\n- *\r\n- * This program is free software: you can redistribute it and/or modify\r\n- * it under the terms of the GNU General Public License as published by\r\n- * the Free Software Foundation, either version 3 of the License, or\r\n- * (at your option) any later version.\r\n- *\r\n- * This program is distributed in the hope that it will be useful,\r\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n- * GNU General Public License for more details.\r\n- *\r\n- * You should have received a copy of the GNU General Public License\r\n- * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n- */\r\n-package org.fxconnector.helper;\r\n-\r\n-import org.scenicview.utils.ExceptionLogger;\r\n-\r\n-public abstract class WorkerThread extends Thread {\r\n-\r\n-    protected boolean running = true;\r\n-    protected final int sleepTime;\r\n-\r\n-    public WorkerThread(final String name, final int sleepTime) {\r\n-        super(name);\r\n-        setDaemon(true);\r\n-        this.sleepTime = sleepTime;\r\n-    }\r\n-\r\n-    public void finish() {\r\n-        this.running = false;\r\n-        interrupt();\r\n-    }\r\n-\r\n-    @Override public void run() {\r\n-        long sleepTime = 0;\r\n-        while (running) {\r\n-            try {\r\n-                Thread.sleep(sleepTime);\r\n-                work();\r\n-            } catch (final Exception e) {\r\n-                if (running) {\r\n-                    ExceptionLogger.submitException(e);\r\n-                }\r\n-            }\r\n-            sleepTime = this.sleepTime;\r\n-        }\r\n-    }\r\n-\r\n-    protected abstract void work();\r\n-}\r\n+/*\n+ * Scenic View, \n+ * Copyright (C) 2012 Jonathan Giles, Ander Ruiz, Amy Fowler \n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package org.fxconnector.helper;\n+\n+import org.scenicview.utils.ExceptionLogger;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public abstract class WorkerThread extends Thread {\n+\n+    protected boolean running = true;\n+    protected final int sleepTime;\n+    protected AtomicBoolean workEnabled = new AtomicBoolean(true);\n+\n+    public WorkerThread(final String name, final int sleepTime) {\n+        super(name);\n+        setDaemon(true);\n+        this.sleepTime = sleepTime;\n+    }\n+\n+    public void finish() {\n+        this.running = false;\n+        interrupt();\n+    }\n+\n+    @Override public void run() {\n+        long sleepTime = 0;\n+        while (running) {\n+            try {\n+                Thread.sleep(sleepTime);\n+                if (isEnabled()) {\n+                    work();\n+                }\n+            } catch (final Exception e) {\n+                if (running) {\n+                    ExceptionLogger.submitException(e);\n+                }\n+            }\n+            sleepTime = this.sleepTime;\n+        }\n+    }\n+\n+    public void setEnabled(Boolean enabled) {\n+        workEnabled.set(enabled);\n+    }\n+\n+    public boolean isEnabled() {\n+        return workEnabled.get();\n+    }\n+\n+    protected abstract void work();\n+}"
  },
  {
    "sha": "f72c3aaf8573e818707b6ee1b9d07ce2897ad8dd",
    "filename": "src/main/java/org/fxconnector/node/SVDummyNode.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/JonathanGiles/scenic-view/blob/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/fxconnector/node/SVDummyNode.java",
    "raw_url": "https://github.com/JonathanGiles/scenic-view/raw/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/fxconnector/node/SVDummyNode.java",
    "contents_url": "https://api.github.com/repos/JonathanGiles/scenic-view/contents/src/main/java/org/fxconnector/node/SVDummyNode.java?ref=ef3da38c12143ef69fb4317a683a33769588a7a1",
    "patch": "@@ -50,7 +50,7 @@ public SVDummyNode() {\n     }\r\n \r\n     public SVDummyNode(final String name, final String nodeClass, final int nodeID, final NodeType nodeType) {\r\n-        super(nodeClass, null);\r\n+        super(nodeClass, null, null);\r\n         this.name = name;\r\n         this.nodeID = nodeID;\r\n         this.nodeType = nodeType;\r"
  },
  {
    "sha": "d54296edd8c178f0b1bdb9e9e75c3f1d92e4dd4d",
    "filename": "src/main/java/org/fxconnector/node/SVNode.java",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/JonathanGiles/scenic-view/blob/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/fxconnector/node/SVNode.java",
    "raw_url": "https://github.com/JonathanGiles/scenic-view/raw/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/fxconnector/node/SVNode.java",
    "contents_url": "https://api.github.com/repos/JonathanGiles/scenic-view/contents/src/main/java/org/fxconnector/node/SVNode.java?ref=ef3da38c12143ef69fb4317a683a33769588a7a1",
    "patch": "@@ -30,6 +30,8 @@\n \r\n     String getNodeClass();\r\n \r\n+    String getNodeIdentityCode();\r\n+\r\n     String getExtendedId();\r\n \r\n     SVNode getParent();\r"
  },
  {
    "sha": "973558cec7cdd27b058608fd4a66f239a7f54226",
    "filename": "src/main/java/org/fxconnector/node/SVNodeImpl.java",
    "status": "modified",
    "additions": 6,
    "deletions": 1,
    "changes": 7,
    "blob_url": "https://github.com/JonathanGiles/scenic-view/blob/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/fxconnector/node/SVNodeImpl.java",
    "raw_url": "https://github.com/JonathanGiles/scenic-view/raw/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/fxconnector/node/SVNodeImpl.java",
    "contents_url": "https://api.github.com/repos/JonathanGiles/scenic-view/contents/src/main/java/org/fxconnector/node/SVNodeImpl.java?ref=ef3da38c12143ef69fb4317a683a33769588a7a1",
    "patch": "@@ -32,14 +32,16 @@\n     boolean expanded;\r\n     protected String nodeClass;\r\n     protected String nodeClassName;\r\n+    protected String nodeIdentityCode;\r\n \r\n     protected SVNodeImpl() {\r\n \r\n     }\r\n \r\n-    protected SVNodeImpl(final String nodeClass, final String nodeClassName) {\r\n+    protected SVNodeImpl(final String nodeClass, final String nodeClassName, final String nodeIdentityCode) {\r\n         this.nodeClass = nodeClass;\r\n         this.nodeClassName = nodeClassName;\r\n+        this.nodeIdentityCode = nodeIdentityCode;\r\n     }\r\n \r\n     @Override public final void setInvalidForFilter(final boolean invalid) {\r\n@@ -74,4 +76,7 @@ protected SVNodeImpl(final String nodeClass, final String nodeClassName) {\n         return nodeClassName;\r\n     }\r\n \r\n+    public String getNodeIdentityCode() {\r\n+        return nodeIdentityCode;\r\n+    }\r\n }\r"
  },
  {
    "sha": "7cadf6f0126c5e1ce7c2332129e870f70b6e8957",
    "filename": "src/main/java/org/fxconnector/node/SVRealNodeAdapter.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/JonathanGiles/scenic-view/blob/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/fxconnector/node/SVRealNodeAdapter.java",
    "raw_url": "https://github.com/JonathanGiles/scenic-view/raw/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/fxconnector/node/SVRealNodeAdapter.java",
    "contents_url": "https://api.github.com/repos/JonathanGiles/scenic-view/contents/src/main/java/org/fxconnector/node/SVRealNodeAdapter.java?ref=ef3da38c12143ef69fb4317a683a33769588a7a1",
    "patch": "@@ -46,7 +46,7 @@ public SVRealNodeAdapter(final Node node) {\n     }\r\n \r\n     public SVRealNodeAdapter(final Node node, final boolean collapseControls, final boolean collapseContentControls) {\r\n-        super(ConnectorUtils.nodeClass(node), node.getClass().getName());\r\n+        super(ConnectorUtils.nodeClass(node), node.getClass().getName(), ConnectorUtils.nodeIdentityCode(node));\r\n         this.node = node;\r\n         this.collapseControls = collapseControls;\r\n         this.collapseContentControls = collapseContentControls;\r"
  },
  {
    "sha": "69b183141c5b53a2f76488e932158c08682be204",
    "filename": "src/main/java/org/fxconnector/node/SVRemoteNodeAdapter.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/JonathanGiles/scenic-view/blob/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/fxconnector/node/SVRemoteNodeAdapter.java",
    "raw_url": "https://github.com/JonathanGiles/scenic-view/raw/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/fxconnector/node/SVRemoteNodeAdapter.java",
    "contents_url": "https://api.github.com/repos/JonathanGiles/scenic-view/contents/src/main/java/org/fxconnector/node/SVRemoteNodeAdapter.java?ref=ef3da38c12143ef69fb4317a683a33769588a7a1",
    "patch": "@@ -48,7 +48,7 @@ public SVRemoteNodeAdapter(final Node node, final boolean collapseControls, fina\n     }\r\n \r\n     public SVRemoteNodeAdapter(final Node node, final boolean collapseControls, final boolean collapseContentControls, final boolean fillChildren, final SVRemoteNodeAdapter parent) {\r\n-        super(ConnectorUtils.nodeClass(node), node.getClass().getName());\r\n+        super(ConnectorUtils.nodeClass(node), node.getClass().getName(), ConnectorUtils.nodeIdentityCode(node));\r\n         boolean mustBeExpanded = !(node instanceof Control) || !collapseControls;\r\n         if (!mustBeExpanded && !collapseContentControls) {\r\n             mustBeExpanded = node instanceof TabPane || node instanceof SplitPane || node instanceof ScrollPane || node instanceof Accordion || node instanceof TitledPane;\r"
  },
  {
    "sha": "a0e9cb5cb18160da4ed220297f0082b66fc61e08",
    "filename": "src/main/java/org/scenicview/view/ScenegraphTreeView.java",
    "status": "modified",
    "additions": 20,
    "deletions": 5,
    "changes": 25,
    "blob_url": "https://github.com/JonathanGiles/scenic-view/blob/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/scenicview/view/ScenegraphTreeView.java",
    "raw_url": "https://github.com/JonathanGiles/scenic-view/raw/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/scenicview/view/ScenegraphTreeView.java",
    "contents_url": "https://api.github.com/repos/JonathanGiles/scenic-view/contents/src/main/java/org/scenicview/view/ScenegraphTreeView.java?ref=ef3da38c12143ef69fb4317a683a33769588a7a1",
    "patch": "@@ -35,7 +35,9 @@\n import javafx.scene.control.TreeView;\r\n import javafx.scene.image.ImageView;\r\n import javafx.scene.input.MouseEvent;\r\n+import javafx.scene.layout.HBox;\r\n import javafx.scene.paint.Color;\r\n+import javafx.scene.text.Text;\r\n import javafx.stage.WindowEvent;\r\n \r\n import org.fxconnector.AppController;\r\n@@ -86,11 +88,24 @@ public ScenegraphTreeView(final List<NodeFilter> activeNodeFilters, final Scenic\n         setCellFactory(node -> new TreeCell<SVNode>() {\r\n             @Override public void updateItem(final SVNode item, final boolean empty) {\r\n                 super.updateItem(item, empty);\r\n-\r\n-                TreeItem<SVNode> treeItem = getTreeItem();\r\n-                setGraphic(treeItem == null ? null : treeItem.getGraphic());\r\n-\r\n-                setText(item == null ? null : item.toString());\r\n+                if (item != null) {\r\n+                    Text txtName = new Text(item.toString());\r\n+                    txtName.getStyleClass().add(\"text\");\r\n+                    Text txtCode = new Text(item.getNodeIdentityCode());\r\n+                    txtCode.getStyleClass().add(\"text\");\r\n+                    txtCode.getStyleClass().add(\"textIdentityCode\");\r\n+                    HBox hbox = new HBox(5.0);\r\n+                    if (getTreeItem() != null) {\r\n+                        hbox.getChildren().add(getTreeItem().getGraphic());\r\n+                    }\r\n+                    hbox.getChildren().add(txtName);\r\n+                    hbox.getChildren().add(txtCode);\r\n+                    setGraphic(hbox);\r\n+                } else {\r\n+                    setGraphic(null);\r\n+                }\r\n+                //setText(item == null ? null : item.toString());\r\n+                setText(null);\r\n                 setOpacity(1);\r\n \r\n                 if (item == null) return;\r"
  },
  {
    "sha": "29ce314a744d4f308f4dcfc0eedf7d1b3698e97f",
    "filename": "src/main/java/org/scenicview/view/ScenicViewGui.java",
    "status": "modified",
    "additions": 1181,
    "deletions": 1154,
    "changes": 2335,
    "blob_url": "https://github.com/JonathanGiles/scenic-view/blob/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/scenicview/view/ScenicViewGui.java",
    "raw_url": "https://github.com/JonathanGiles/scenic-view/raw/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/java/org/scenicview/view/ScenicViewGui.java",
    "contents_url": "https://api.github.com/repos/JonathanGiles/scenic-view/contents/src/main/java/org/scenicview/view/ScenicViewGui.java?ref=ef3da38c12143ef69fb4317a683a33769588a7a1",
    "patch": "@@ -1,1154 +1,1181 @@\n-/*\r\n- * Scenic View, \r\n- * Copyright (C) 2012 Jonathan Giles, Ander Ruiz, Amy Fowler \r\n- *\r\n- * This program is free software: you can redistribute it and/or modify\r\n- * it under the terms of the GNU General Public License as published by\r\n- * the Free Software Foundation, either version 3 of the License, or\r\n- * (at your option) any later version.\r\n- *\r\n- * This program is distributed in the hope that it will be useful,\r\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n- * GNU General Public License for more details.\r\n- *\r\n- * You should have received a copy of the GNU General Public License\r\n- * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n- */\r\n-package org.scenicview.view;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.function.Consumer;\r\n-\r\n-import javafx.animation.Animation;\r\n-import javafx.animation.KeyFrame;\r\n-import javafx.animation.Timeline;\r\n-import javafx.beans.value.ChangeListener;\r\n-import javafx.beans.value.ObservableValue;\r\n-import javafx.event.EventHandler;\r\n-import javafx.geometry.Insets;\r\n-import javafx.geometry.Pos;\r\n-import javafx.scene.Node;\r\n-import javafx.scene.Scene;\r\n-import javafx.scene.control.CheckMenuItem;\r\n-import javafx.scene.control.Label;\r\n-import javafx.scene.control.Menu;\r\n-import javafx.scene.control.MenuBar;\r\n-import javafx.scene.control.MenuItem;\r\n-import javafx.scene.control.ProgressIndicator;\r\n-import javafx.scene.control.SeparatorMenuItem;\r\n-import javafx.scene.control.SplitPane;\r\n-import javafx.scene.control.Tab;\r\n-import javafx.scene.control.TabPane;\r\n-import javafx.scene.image.Image;\r\n-import javafx.scene.input.KeyCode;\r\n-import javafx.scene.input.KeyCombination;\r\n-import javafx.scene.input.KeyEvent;\r\n-import javafx.scene.layout.BorderPane;\r\n-import javafx.scene.layout.GridPane;\r\n-import javafx.scene.layout.Priority;\r\n-import javafx.scene.layout.StackPane;\r\n-import javafx.scene.layout.VBox;\r\n-import javafx.stage.Stage;\r\n-import javafx.stage.WindowEvent;\r\n-import javafx.util.Duration;\r\n-\r\n-import org.fxconnector.AppController;\r\n-import org.fxconnector.Configuration;\r\n-import org.fxconnector.ConnectorUtils;\r\n-import org.fxconnector.StageController;\r\n-import org.fxconnector.StageControllerImpl;\r\n-import org.fxconnector.StageID;\r\n-import org.fxconnector.event.AnimationsCountEvent;\r\n-import org.fxconnector.event.DetailsEvent;\r\n-import org.fxconnector.event.EvLogEvent;\r\n-import org.fxconnector.event.FXConnectorEvent;\r\n-import org.fxconnector.event.FXConnectorEvent.SVEventType;\r\n-import org.fxconnector.event.FXConnectorEventDispatcher;\r\n-import org.fxconnector.event.MousePosEvent;\r\n-import org.fxconnector.event.NodeAddRemoveEvent;\r\n-import org.fxconnector.event.NodeCountEvent;\r\n-import org.fxconnector.event.NodeSelectedEvent;\r\n-import org.fxconnector.event.SceneDetailsEvent;\r\n-import org.fxconnector.event.ShortcutEvent;\r\n-import org.fxconnector.event.WindowDetailsEvent;\r\n-import org.fxconnector.node.SVNode;\r\n-import org.scenicview.model.Persistence;\r\n-import org.scenicview.model.update.AppsRepository;\r\n-import org.scenicview.model.update.UpdateStrategy;\r\n-import org.scenicview.utils.ExceptionLogger;\r\n-import org.scenicview.utils.Logger;\r\n-import org.scenicview.view.control.FilterTextField;\r\n-import org.scenicview.view.dialog.AboutBox;\r\n-import org.scenicview.view.dialog.HelpBox;\r\n-import org.scenicview.view.tabs.AnimationsTab;\r\n-import org.scenicview.view.tabs.CSSFXTab;\r\n-import org.scenicview.view.tabs.DetailsTab;\r\n-import org.scenicview.view.tabs.EventLogTab;\r\n-import org.scenicview.view.tabs.JavaDocTab;\r\n-import org.scenicview.view.tabs.ThreeDOMTab;\r\n-\r\n-/**\r\n- * The base UI\r\n- */\r\n-public class ScenicViewGui {\r\n-    \r\n-    private static final String HELP_URL = \"http://fxexperience.com/scenic-view/help\";\r\n-    public static final String STYLESHEETS = ScenicViewGui.class.getResource(\"scenicview.css\").toExternalForm();\r\n-    public static final Image APP_ICON = DisplayUtils.getUIImage(\"mglass.png\");\r\n-\r\n-    public static final String VERSION = \"11.0.2\";\r\n-\r\n-    private final Thread shutdownHook = new Thread() {\r\n-        @Override public void run() {\r\n-            // We can't use close() because we are not in FXThread\r\n-            saveProperties();\r\n-        }\r\n-    };\r\n-\r\n-    // Scenic View UI\r\n-    private final Stage scenicViewStage;\r\n-    private BorderPane rootBorderPane;\r\n-    private SplitPane splitPane;\r\n-    \r\n-    // menu bar area\r\n-    private MenuBar menuBar;\r\n-    private CheckMenuItem showFilteredNodesInTree;\r\n-    private CheckMenuItem showNodesIdInTree;\r\n-    private CheckMenuItem autoRefreshStyleSheets;\r\n-    private CheckMenuItem componentSelectOnClick;\r\n-    private CheckMenuItem showInvisibleNodes;\r\n-    private CheckMenuItem showSearchBar;\r\n-    \r\n-    // filter area\r\n-//    private TitledPane filtersPane;\r\n-    private FilterTextField propertyFilterField;\r\n-    private List<NodeFilter> activeNodeFilters;\r\n-    \r\n-    // tree area\r\n-    private Node treeViewScanningPlaceholder;\r\n-    private ScenegraphTreeView treeView;\r\n-    \r\n-    // search bar area\r\n-    private GridPane searchBar;\r\n-    \r\n-    // status bar area\r\n-    private StatusBar statusBar;\r\n-    \r\n-    private VBox bottomVBox;\r\n-\r\n-    \r\n-\r\n-    public final Configuration configuration = new Configuration();\r\n-    private final List<FXConnectorEvent> eventQueue = new LinkedList<>();\r\n-\r\n-    private UpdateStrategy updateStrategy;\r\n-    private long lastMousePosition;\r\n-\r\n-    private final FXConnectorEventDispatcher stageModelListener = new FXConnectorEventDispatcher() {\r\n-        @Override public void dispatchEvent(final FXConnectorEvent appEvent) {\r\n-            if (isValid(appEvent)) {\r\n-                // doDispatchEvent(appEvent);\r\n-                switch (appEvent.getType()) {\r\n-\r\n-                    case ROOT_UPDATED:\r\n-                        doDispatchEvent(appEvent);\r\n-                        break;\r\n-\r\n-                    case MOUSE_POSITION:\r\n-                        if (System.currentTimeMillis() - lastMousePosition > 500) {\r\n-                            lastMousePosition = System.currentTimeMillis();\r\n-                            // No need to synchronize here\r\n-                            eventQueue.add(appEvent);\r\n-                        }\r\n-                        break;\r\n-\r\n-                    default:\r\n-                        // No need to synchronize here\r\n-                        eventQueue.add(appEvent);\r\n-                        break;\r\n-                }\r\n-\r\n-            } else {\r\n-                Logger.print(\"Unused event \" + appEvent);\r\n-            }\r\n-        }\r\n-\r\n-        private boolean isValid(final FXConnectorEvent appEvent) {\r\n-            for (int i = 0; i < appRepository.getApps().size(); i++) {\r\n-                if (appRepository.getApps().get(i).getID() == appEvent.getStageID().getAppID()) {\r\n-                    final List<StageController> stages = appRepository.getApps().get(i).getStages();\r\n-                    for (int j = 0; j < stages.size(); j++) {\r\n-                        if (stages.get(j).getID().getStageID() == appEvent.getStageID().getStageID()) {\r\n-                            return true;\r\n-                        }\r\n-                    }\r\n-                    break;\r\n-                }\r\n-            }\r\n-            return false;\r\n-        }\r\n-    };\r\n-\r\n-//    private final List<AppController> apps = new ArrayList<AppController>();\r\n-    private final AppsRepository appRepository; \r\n-    \r\n-    public StageController activeStage;\r\n-    private SVNode selectedNode;\r\n-    \r\n-    private TabPane tabPane;\r\n-    private DetailsTab detailsTab;\r\n-    private EventLogTab eventsTab;\r\n-    private AnimationsTab animationsTab;\r\n-    private JavaDocTab javadocTab;\r\n-    private ThreeDOMTab threeDOMTab;\r\n-    private CSSFXTab cssfxTab;\r\n-\r\n-    public ScenicViewGui(final UpdateStrategy updateStrategy, final Stage scenicViewStage) {\r\n-        this.scenicViewStage = scenicViewStage;\r\n-        Persistence.loadProperties();\r\n-        Runtime.getRuntime().addShutdownHook(shutdownHook);\r\n-        buildUI();\r\n-//        checkNewVersion(false);\r\n-        \r\n-        this.appRepository = new AppsRepository(this);\r\n-        this.updateStrategy = updateStrategy;\r\n-        this.updateStrategy.start(appRepository);\r\n-        \r\n-        // we update Scenic View on a separate thread, based on events coming\r\n-        // in from FX Connector. The events arrive into the eventQueue, and\r\n-        // are processed here\r\n-        Timeline eventDispatcher = new Timeline(new KeyFrame(Duration.millis(60), event -> {\r\n-            // No need to synchronize\r\n-            while (!eventQueue.isEmpty()) {\r\n-                try {\r\n-                    doDispatchEvent(eventQueue.remove(0));\r\n-                } catch (final Exception e) {\r\n-                    ExceptionLogger.submitException(e);\r\n-                }\r\n-            }\r\n-        }));\r\n-        eventDispatcher.setCycleCount(Animation.INDEFINITE);\r\n-        eventDispatcher.play();\r\n-    }\r\n-    \r\n-    private void buildUI() {\r\n-        rootBorderPane = new BorderPane();\r\n-        rootBorderPane.setId(StageController.FX_CONNECTOR_BASE_ID + \"scenic-view\");\r\n-        \r\n-        // search bar\r\n-        buildFiltersBox();\r\n-\r\n-        // menubar\r\n-        buildMenuBar();\r\n-\r\n-        // main splitpane\r\n-        splitPane = new SplitPane();\r\n-        splitPane.setId(\"main-splitpane\");\r\n-\r\n-        \r\n-        // treeview\r\n-        treeView = new ScenegraphTreeView(activeNodeFilters, this);\r\n-        treeViewScanningPlaceholder = new VBox(10) {\r\n-            {\r\n-                ProgressIndicator progress = new ProgressIndicator();\r\n-                Label label = new Label(\"Scanning for JavaFX applications\");\r\n-                label.getStyleClass().add(\"scanning-label\");\r\n-                getChildren().addAll(progress, label);\r\n-                \r\n-                setAlignment(Pos.CENTER);\r\n-                \r\n-                treeView.expandedItemCountProperty().addListener(o -> {\r\n-                    setVisible(treeView.getExpandedItemCount() == 0);\r\n-                });\r\n-                \r\n-            }\r\n-        };\r\n-        \r\n-        StackPane treeViewStackPane = new StackPane(treeView, treeViewScanningPlaceholder);\r\n-        treeViewStackPane.setStyle(\" -fx-padding: 0\");\r\n-\r\n-        treeView.setMaxHeight(Double.MAX_VALUE);\r\n-        \r\n-        // right side\r\n-        detailsTab = new DetailsTab(this, new Consumer<String>() {\r\n-            @Override public void accept(String property) {\r\n-                ScenicViewGui.this.loadAPI(property);\r\n-            }\r\n-        });\r\n-\r\n-        animationsTab = new AnimationsTab(this);\r\n-\r\n-        tabPane = new TabPane();\r\n-        tabPane.getSelectionModel().selectedItemProperty().addListener((ov, oldValue, newValue) -> updateMenuBar(oldValue, newValue));\r\n-\r\n-        javadocTab = new JavaDocTab(this); \r\n-        \r\n-        eventsTab = new EventLogTab(this);\r\n-        eventsTab.activeProperty().addListener((ov, oldValue, newValue) -> {\r\n-            configuration.setEventLogEnabled(newValue);\r\n-            configurationUpdated();\r\n-        });\r\n-        \r\n-        // 3Dom\r\n-        threeDOMTab = new ThreeDOMTab(this); \r\n-        \r\n-        // CSSFX\r\n-        cssfxTab = new CSSFXTab(this);\r\n-        \r\n-        tabPane.getTabs().addAll(detailsTab, eventsTab, /*animationsTab,*/ javadocTab, threeDOMTab, cssfxTab);\r\n-        // /3Dom\r\n-        \r\n-        Persistence.loadProperty(\"splitPaneDividerPosition\", splitPane, 0.3);\r\n-\r\n-        // putting it all together\r\n-        splitPane.getItems().addAll(treeViewStackPane, tabPane);\r\n-\r\n-        rootBorderPane.setCenter(splitPane);\r\n-        \r\n-        // status bar\r\n-        statusBar = new StatusBar();\r\n-        \r\n-        bottomVBox = new VBox(searchBar, statusBar);\r\n-\r\n-        rootBorderPane.setBottom(bottomVBox);\r\n-\r\n-        Persistence.loadProperty(\"stageWidth\", scenicViewStage, 800);\r\n-        Persistence.loadProperty(\"stageHeight\", scenicViewStage, 800);\r\n-    }\r\n-    \r\n-    private void buildFiltersBox() {\r\n-        propertyFilterField = createFilterField(\"Type property names or values here\", null);\r\n-        propertyFilterField.setOnKeyReleased(new EventHandler<KeyEvent>() {\r\n-            @Override public void handle(final KeyEvent arg0) {\r\n-                filterProperties(propertyFilterField.getText());\r\n-            }\r\n-        });\r\n-        propertyFilterField.setDisable(true);\r\n-        \r\n-        final FilterTextField idFilterField = createFilterField(\"Type Node ID's here\");\r\n-        idFilterField.setOnButtonClick(() -> {\r\n-            idFilterField.setText(\"\");\r\n-            update();\r\n-        });\r\n-        \r\n-        final FilterTextField classNameFilterField = createFilterField(\"Type class names here\");\r\n-        classNameFilterField.setOnButtonClick(() -> {\r\n-            classNameFilterField.setText(\"\");\r\n-            update();\r\n-        });\r\n-        \r\n-        searchBar = new GridPane();\r\n-        searchBar.setVgap(5);\r\n-        searchBar.setHgap(5);\r\n-        searchBar.setSnapToPixel(true);\r\n-        searchBar.setPadding(new Insets(0, 5, 5, 0));\r\n-        searchBar.getStyleClass().add(\"search-bar\");\r\n-\r\n-        GridPane.setHgrow(idFilterField, Priority.ALWAYS);\r\n-        GridPane.setHgrow(classNameFilterField, Priority.ALWAYS);\r\n-        GridPane.setHgrow(propertyFilterField, Priority.ALWAYS);\r\n-\r\n-        int column = 1;\r\n-        \r\n-        Label nodeIdFilterLabel = new Label(\"Node ID Filter:\");\r\n-        Label classNameFilterLabel = new Label(\"Class Name Filter:\");\r\n-        Label propertyFilterLabel = new Label(\"Property Filter:\");\r\n-        \r\n-        searchBar.add(nodeIdFilterLabel, column++, 1);\r\n-        searchBar.add(idFilterField, column++, 1);\r\n-        searchBar.add(classNameFilterLabel, column++, 1);\r\n-        searchBar.add(classNameFilterField, column++, 1);\r\n-        searchBar.add(propertyFilterLabel, column++, 1);\r\n-        searchBar.add(propertyFilterField, column++, 1);\r\n-\r\n-        // create filters for nodes\r\n-        activeNodeFilters = new ArrayList<>();\r\n-\r\n-        /**\r\n-         * Create a filter for our own nodes\r\n-         */\r\n-        activeNodeFilters.add(new NodeFilter() {\r\n-            @Override public boolean allowChildrenOnRejection() {\r\n-                return false;\r\n-            }\r\n-\r\n-            @Override public boolean accept(final SVNode node) {\r\n-                // do not create tree nodes for our bounds rectangles\r\n-                return ConnectorUtils.isNormalNode(node);\r\n-            }\r\n-\r\n-            @Override public boolean ignoreShowFilteredNodesInTree() {\r\n-                return true;\r\n-            }\r\n-\r\n-            @Override public boolean expandAllNodes() {\r\n-                return false;\r\n-            }\r\n-        });\r\n-        \r\n-        activeNodeFilters.add(new NodeFilter() {\r\n-            @Override public boolean allowChildrenOnRejection() {\r\n-                return false;\r\n-            }\r\n-\r\n-            @Override public boolean accept(final SVNode node) {\r\n-                return showInvisibleNodes.isSelected() || node.isVisible();\r\n-            }\r\n-\r\n-            @Override public boolean ignoreShowFilteredNodesInTree() {\r\n-                return false;\r\n-            }\r\n-\r\n-            @Override public boolean expandAllNodes() {\r\n-                return false;\r\n-            }\r\n-        });\r\n-        \r\n-        activeNodeFilters.add(new NodeFilter() {\r\n-            @Override public boolean allowChildrenOnRejection() {\r\n-                return true;\r\n-            }\r\n-\r\n-            @Override public boolean accept(final SVNode node) {\r\n-                if (idFilterField.getText().equals(\"\"))\r\n-                    return true;\r\n-                return node.getId() != null && node.getId().toLowerCase().indexOf(idFilterField.getText().toLowerCase()) != -1;\r\n-            }\r\n-\r\n-            @Override public boolean ignoreShowFilteredNodesInTree() {\r\n-                return false;\r\n-            }\r\n-\r\n-            @Override public boolean expandAllNodes() {\r\n-                return !idFilterField.getText().equals(\"\");\r\n-            }\r\n-        });\r\n-        \r\n-        activeNodeFilters.add(new NodeFilter() {\r\n-            @Override public boolean allowChildrenOnRejection() {\r\n-                return true;\r\n-            }\r\n-\r\n-            @Override public boolean accept(final SVNode node) {\r\n-                if (classNameFilterField.getText().equals(\"\"))\r\n-                    return true;\r\n-\r\n-                // Allow reduces or complete className\r\n-                return node.getNodeClass().toLowerCase().indexOf(classNameFilterField.getText().toLowerCase()) != -1;\r\n-            }\r\n-\r\n-            @Override public boolean ignoreShowFilteredNodesInTree() {\r\n-                return false;\r\n-            }\r\n-\r\n-            @Override public boolean expandAllNodes() {\r\n-                return !classNameFilterField.getText().equals(\"\");\r\n-            }\r\n-        });\r\n-    }\r\n-    \r\n-    private void buildMenuBar() {\r\n-        menuBar = new MenuBar();\r\n-        menuBar.setUseSystemMenuBar(true);\r\n-        // menuBar.setId(\"main-menubar\");\r\n-\r\n-        // ---- File Menu\r\n-//        final MenuItem classpathItem = new MenuItem(\"Configure Classpath\");\r\n-//        classpathItem.setOnAction(new EventHandler<ActionEvent>() {\r\n-//            @Override public void handle(final ActionEvent arg0) {\r\n-//                final Properties properties = PropertiesUtils.getProperties();\r\n-//\r\n-//                final String toolsPath = properties.getProperty(ScenicViewBooter.JDK_PATH_KEY);\r\n-//                final File jdkPathFile = new ClassPathDialog(toolsPath).show(scenicViewStage);\r\n-//                \r\n-//                if (jdkPathFile != null) {\r\n-//                    properties.setProperty(ScenicViewBooter.JDK_PATH_KEY, jdkPathFile.getAbsolutePath());\r\n-//                    PropertiesUtils.saveProperties();\r\n-//                }\r\n-//            }\r\n-//        });\r\n-\r\n-        final MenuItem exitItem = new MenuItem(\"E_xit Scenic View\");\r\n-        exitItem.setAccelerator(KeyCombination.keyCombination(\"CTRL+Q\"));\r\n-        exitItem.setOnAction(event -> {\r\n-            Runtime.getRuntime().removeShutdownHook(shutdownHook);\r\n-            close();\r\n-            // TODO Why closing the Stage does not dispatch\r\n-            // WINDOW_CLOSE_REQUEST??\r\n-            scenicViewStage.close();\r\n-        });\r\n-\r\n-        final Menu fileMenu = new Menu(\"File\");\r\n-//        if (updateStrategy.needsClassPathConfiguration()) {\r\n-//            fileMenu.getItems().addAll(classpathItem, new SeparatorMenuItem());\r\n-//        }\r\n-        fileMenu.getItems().add(exitItem);\r\n-\r\n-        // ---- Options Menu\r\n-        final CheckMenuItem showBoundsCheckbox = buildCheckMenuItem(\"Show Bounds Overlays\", \"Show the bound overlays on selected\",\r\n-                \"Do not show bound overlays on selected\", \"showBounds\", Boolean.TRUE);\r\n-        showBoundsCheckbox.setId(\"show-bounds-checkbox\");\r\n-        // showBoundsCheckbox.setTooltip(new\r\n-        // Tooltip(\"Display a yellow highlight for boundsInParent and green outline for layoutBounds.\"));\r\n-        configuration.setShowBounds(showBoundsCheckbox.isSelected());\r\n-        showBoundsCheckbox.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\r\n-            configuration.setShowBounds(newValue);\r\n-            configurationUpdated();\r\n-        });\r\n-\r\n-        final CheckMenuItem collapseControls = buildCheckMenuItem(\"Collapse controls In Tree\", \"Controls will be collapsed\", \"Controls will be expanded\",\r\n-                \"collapseControls\", Boolean.TRUE);\r\n-        collapseControls.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\r\n-            configuration.setCollapseControls(newValue);\r\n-            configurationUpdated();\r\n-        });\r\n-        configuration.setCollapseControls(collapseControls.isSelected());\r\n-\r\n-        final CheckMenuItem collapseContentControls = buildCheckMenuItem(\"Collapse container controls In Tree\", \"Container controls will be collapsed\",\r\n-                \"Container controls will be expanded\", \"collapseContainerControls\", Boolean.FALSE);\r\n-        collapseContentControls.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\r\n-            configuration.setCollapseContentControls(newValue);\r\n-            configurationUpdated();\r\n-        });\r\n-        collapseContentControls.disableProperty().bind(collapseControls.selectedProperty().not());\r\n-        configuration.setCollapseContentControls(collapseContentControls.isSelected());\r\n-\r\n-        final CheckMenuItem showBaselineCheckbox = buildCheckMenuItem(\"Show Baseline Overlay\", \"Display a red line at the current node's baseline offset\",\r\n-                \"Do not show baseline overlay\", \"showBaseline\", Boolean.FALSE);\r\n-        showBaselineCheckbox.setId(\"show-baseline-overlay\");\r\n-        configuration.setShowBaseline(showBaselineCheckbox.isSelected());\r\n-        showBaselineCheckbox.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\r\n-            configuration.setShowBaseline(newValue);\r\n-            configurationUpdated();\r\n-        });\r\n-\r\n-        final CheckMenuItem automaticScenegraphStructureRefreshing = buildCheckMenuItem(\"Auto-Refresh Scenegraph\",\r\n-                \"Scenegraph structure will be automatically updated on change\", \"Scenegraph structure will NOT be automatically updated on change\",\r\n-                \"automaticScenegraphStructureRefreshing\", Boolean.TRUE);\r\n-        automaticScenegraphStructureRefreshing.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\r\n-            configuration.setAutoRefreshSceneGraph(automaticScenegraphStructureRefreshing.isSelected());\r\n-            configurationUpdated();\r\n-        });\r\n-        configuration.setAutoRefreshSceneGraph(automaticScenegraphStructureRefreshing.isSelected());\r\n-        \r\n-        \r\n-        // --- show search bar\r\n-        showSearchBar = buildCheckMenuItem(\"Show Search Bar\", \"Shows a search bar to allow you to filter the displayed information\",\r\n-                \"Shows a search bar to allow you to filter the displayed information\", \"showSearchBar\", Boolean.TRUE);\r\n-        searchBar.visibleProperty().bind(showSearchBar.selectedProperty());\r\n-        searchBar.managedProperty().bind(showSearchBar.selectedProperty());\r\n-\r\n-        \r\n-        // --- show invisible nodes\r\n-        showInvisibleNodes = buildCheckMenuItem(\"Show Invisible Nodes In Tree\", \"Invisible nodes will be faded in the scenegraph tree\",\r\n-                \"Invisible nodes will not be shown in the scenegraph tree\", \"showInvisibleNodes\", Boolean.FALSE);\r\n-        final ChangeListener<Boolean> visilityListener = (o, oldValue, newValue) -> {\r\n-            configuration.setVisibilityFilteringActive(!showInvisibleNodes.isSelected() && !showFilteredNodesInTree.isSelected());\r\n-            configurationUpdated();\r\n-        };\r\n-        showInvisibleNodes.selectedProperty().addListener(visilityListener);\r\n-\r\n-        \r\n-        // --- show node IDs in tree\r\n-        showNodesIdInTree = buildCheckMenuItem(\"Show Node IDs\", \"Node IDs will be shown on the scenegraph tree\",\r\n-                \"Node IDs will not be shown the Scenegraph tree\", \"showNodesIdInTree\", Boolean.FALSE);\r\n-        showNodesIdInTree.selectedProperty().addListener(o -> update());\r\n-\r\n-        \r\n-        // --- show filtered nodes in tree\r\n-        showFilteredNodesInTree = buildCheckMenuItem(\"Show Filtered Nodes In Tree\", \"Filtered nodes will be faded in the tree\",\r\n-                \"Filtered nodes will not be shown in tree (unless they are parents of non-filtered nodes)\", \"showFilteredNodesInTree\", Boolean.TRUE);\r\n-\r\n-        showFilteredNodesInTree.selectedProperty().addListener(visilityListener);\r\n-        configuration.setVisibilityFilteringActive(!showInvisibleNodes.isSelected() && !showFilteredNodesInTree.isSelected());\r\n-\r\n-        /**\r\n-         * Filter invisible nodes only makes sense if showFilteredNodesInTree is not selected\r\n-         */\r\n-        showInvisibleNodes.disableProperty().bind(showFilteredNodesInTree.selectedProperty());\r\n-\r\n-        componentSelectOnClick = buildCheckMenuItem(\"Component highlight/select on click\", \"Click on the scene to select a component\", \"\", null, null);\r\n-        componentSelectOnClick.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> selectOnClick(newValue));\r\n-\r\n-        final CheckMenuItem ignoreMouseTransparentNodes = buildCheckMenuItem(\"Ignore MouseTransparent Nodes\", \"Transparent nodes will not be selectable\",\r\n-                \"Transparent nodes can be selected\", \"ignoreMouseTransparentNodes\", Boolean.TRUE);\r\n-        ignoreMouseTransparentNodes.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\r\n-            configuration.setIgnoreMouseTransparent(newValue);\r\n-            configurationUpdated();\r\n-        });\r\n-        configuration.setIgnoreMouseTransparent(ignoreMouseTransparentNodes.isSelected());\r\n-\r\n-        final CheckMenuItem registerShortcuts = buildCheckMenuItem(\"Register shortcuts\", \"SV Keyboard shortcuts will be registered on your app\",\r\n-                \"SV Keyboard shortcuts will be removed on your app\", \"registerShortcuts\", Boolean.TRUE);\r\n-        registerShortcuts.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\r\n-            configuration.setRegisterShortcuts(newValue);\r\n-            configurationUpdated();\r\n-        });\r\n-        configuration.setRegisterShortcuts(registerShortcuts.isSelected());\r\n-\r\n-        autoRefreshStyleSheets = buildCheckMenuItem(\"Auto-Refresh StyleSheets\",\r\n-                \"A background thread will check modifications on the css files to reload them if needed\", \"StyleSheets autorefreshing disabled\",\r\n-                \"autoRefreshStyleSheets\", Boolean.FALSE);\r\n-        autoRefreshStyleSheets.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\r\n-            configuration.setAutoRefreshStyles(newValue);\r\n-            configurationUpdated();\r\n-        });\r\n-        configuration.setAutoRefreshStyles(autoRefreshStyleSheets.isSelected());\r\n-\r\n-        final Menu scenegraphMenu = new Menu(\"Scenegraph\");\r\n-        scenegraphMenu.getItems().addAll(automaticScenegraphStructureRefreshing, autoRefreshStyleSheets, registerShortcuts, new SeparatorMenuItem(),\r\n-                componentSelectOnClick, ignoreMouseTransparentNodes);\r\n-\r\n-        final Menu displayOptionsMenu = new Menu(\"Display Options\");\r\n-\r\n-//        final Menu ruler = new Menu(\"Ruler\");\r\n-//        final CheckMenuItem showRuler = buildCheckMenuItem(\"Show Ruler\", \"Show ruler in the scene for alignment purposes\", \"\", null, null);\r\n-//        showRuler.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\r\n-//            configuration.setShowRuler(newValue.booleanValue());\r\n-//            configurationUpdated();\r\n-//        });\r\n-//\r\n-//        final RulerConfigurationMenuItem rulerConfig = new RulerConfigurationMenuItem();\r\n-//        rulerConfig.colorProperty().addListener(new ChangeListener<Color>() {\r\n-//\r\n-//            @Override public void changed(final ObservableValue<? extends Color> arg0, final Color arg1, final Color newValue) {\r\n-//                final int red = (int) (newValue.getRed() * 255);\r\n-//                final int green = (int) (newValue.getGreen() * 255);\r\n-//                final int blue = (int) (newValue.getBlue() * 255);\r\n-//                configuration.setRulerColor(toHexByte(red) + toHexByte(green) + toHexByte(blue));\r\n-//                configurationUpdated();\r\n-//            }\r\n-//\r\n-//            private String toHexByte(final int value) {\r\n-//                return (value < 16) ? \"0\" + Integer.toString(value, 16) : Integer.toString(value, 16);\r\n-//            }\r\n-//        });\r\n-//        rulerConfig.rulerSeparationProperty().addListener((ChangeListener<Number>) (o, oldValue, newValue) -> {\r\n-//            configuration.setRulerSeparation(newValue.intValue());\r\n-//            configurationUpdated();\r\n-//        });\r\n-//        configuration.setRulerSeparation(rulerConfig.rulerSeparationProperty().get());\r\n-//        ruler.getItems().addAll(showRuler, rulerConfig);\r\n-\r\n-        displayOptionsMenu.getItems().addAll(showBoundsCheckbox, \r\n-                                             showBaselineCheckbox, \r\n-//                                             showRuler,\r\n-                                             showSearchBar, \r\n-                                             showFilteredNodesInTree, \r\n-                                             showInvisibleNodes, \r\n-                                             showNodesIdInTree, \r\n-                                             collapseControls, \r\n-                                             collapseContentControls);\r\n-\r\n-        final Menu aboutMenu = new Menu(\"Help\");\r\n-\r\n-        final MenuItem help = new MenuItem(\"Help Contents\");\r\n-        help.setOnAction(event -> HelpBox.make(\"Help Contents\", HELP_URL, scenicViewStage));\r\n-\r\n-//        final MenuItem newVersion = new MenuItem(\"Check For New Version\");\r\n-//        newVersion.setOnAction(new EventHandler<ActionEvent>() {\r\n-//            @Override public void handle(final ActionEvent arg0) {\r\n-//                checkNewVersion(true);\r\n-//            }\r\n-//        });\r\n-\r\n-        final MenuItem about = new MenuItem(\"About\");\r\n-        about.setOnAction(event -> AboutBox.make(\"About\", scenicViewStage));\r\n-\r\n-        aboutMenu.getItems().addAll(help/*, newVersion*/, about);\r\n-\r\n-        menuBar.getMenus().addAll(fileMenu, displayOptionsMenu, scenegraphMenu, aboutMenu);\r\n-\r\n-        rootBorderPane.setTop(menuBar);\r\n-    }\r\n-    \r\n-    private void updateMenuBar(final Tab oldValue, final Tab newValue) {\r\n-        if (oldValue != null && oldValue instanceof ContextMenuContainer) {\r\n-            Menu menu = ((ContextMenuContainer) oldValue).getMenu();\r\n-            menuBar.getMenus().remove(menu);\r\n-        }\r\n-        if (newValue != null && newValue instanceof ContextMenuContainer) {\r\n-            Menu newMenu = ((ContextMenuContainer) newValue).getMenu();\r\n-            if (newMenu != null) {\r\n-                menuBar.getMenus().add(menuBar.getMenus().size() - 1, newMenu);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    protected void selectOnClick(final boolean newValue) {\r\n-        if (configuration.isComponentSelectOnClick() != newValue) {\r\n-            configuration.setComponentSelectOnClick(newValue);\r\n-            configurationUpdated();\r\n-        }\r\n-    }\r\n-\r\n-//    private void checkNewVersion(final boolean forced) {\r\n-//        final SimpleDateFormat format = new SimpleDateFormat(\"ddMMyyyy\");\r\n-//        final String value = Persistence.loadProperty(\"lastVersionCheck\", null);\r\n-//        try {\r\n-//            if (forced || value == null || ((System.currentTimeMillis() - format.parse(value).getTime()) > 86400000)) {\r\n-//                Platform.runLater(new Runnable() {\r\n-//                    @Override public void run() {\r\n-//                        final String newVersion = VersionChecker.checkVersion(VERSION);\r\n-//                        String versionNum = null;\r\n-//                        if (newVersion != null) {\r\n-//                            // For now the version is on the first line\r\n-//                            versionNum = newVersion;\r\n-//                            if (newVersion.indexOf('\\n') != -1) {\r\n-//                                versionNum = newVersion.substring(0, newVersion.indexOf('\\n'));\r\n-//                            }\r\n-//                            // Now check whether our version is newer\r\n-//                            if (versionNum.compareTo(ScenicView.VERSION) < 0) {\r\n-//                                versionNum = null;\r\n-//                            }\r\n-//                        }\r\n-//\r\n-//                        if (versionNum != null) {\r\n-//                            new InfoBox(\"Version check\", \"New version found:\" + versionNum + \" (Yours is:\" + ScenicView.VERSION + \")\", newVersion, 400, 200);\r\n-//                        } else if (forced) {\r\n-//                            new InfoBox(\"Version check\", \"You already have the latest version of Scenic View.\", null, 400, 150);\r\n-//                        }\r\n-//\r\n-//                        Persistence.saveProperty(\"lastVersionCheck\", format.format(new Date()));\r\n-//                    }\r\n-//                });\r\n-//\r\n-//            }\r\n-//        } catch (final Exception e) {\r\n-//            ExceptionLogger.submitException(e);\r\n-//        }\r\n-//    }\r\n-    \r\n-    public void removeApp(final AppController appController) {\r\n-        treeView.removeApp(appController);\r\n-    }\r\n-    \r\n-    public void removeStage(final StageController stageController) {\r\n-        treeView.removeStage(stageController);\r\n-    }\r\n-    \r\n-    public void setActiveStage(final StageController activeStage) {\r\n-        this.activeStage = activeStage;\r\n-        cssfxTab.setActiveStage(activeStage.getID());\r\n-    }\r\n-    \r\n-    public FXConnectorEventDispatcher getStageModelListener() {\r\n-        return stageModelListener;\r\n-    }\r\n-\r\n-    public void configurationUpdated() {\r\n-        for (int i = 0; i < appRepository.getApps().size(); i++) {\r\n-            final List<StageController> stages = appRepository.getApps().get(i).getStages();\r\n-            for (int j = 0; j < stages.size(); j++) {\r\n-                if (stages.get(j).isOpened()) {\r\n-                    stages.get(j).configurationUpdated(configuration);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void animationsEnabled(final boolean enabled) {\r\n-        for (int i = 0; i < appRepository.getApps().size(); i++) {\r\n-            final List<StageController> stages = appRepository.getApps().get(i).getStages();\r\n-            for (int j = 0; j < stages.size(); j++) {\r\n-                if (stages.get(j).isOpened()) {\r\n-                    stages.get(j).animationsEnabled(enabled);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void updateAnimations() {\r\n-        animationsTab.clear();\r\n-        for (int i = 0; i < appRepository.getApps().size(); i++) {\r\n-            /**\r\n-             * Only first stage\r\n-             */\r\n-            final List<StageController> stages = appRepository.getApps().get(i).getStages();\r\n-            for (int j = 0; j < stages.size(); j++) {\r\n-                if (stages.get(j).isOpened()) {\r\n-                    stages.get(j).updateAnimations();\r\n-                    break;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void pauseAnimation(final StageID id, final int animationID) {\r\n-        for (int i = 0; i < appRepository.getApps().size(); i++) {\r\n-            final List<StageController> stages = appRepository.getApps().get(i).getStages();\r\n-            for (int j = 0; j < stages.size(); j++) {\r\n-                if (stages.get(j).getID().equals(id)) {\r\n-                    stages.get(j).pauseAnimation(animationID);\r\n-                }\r\n-            }\r\n-        }\r\n-        updateAnimations();\r\n-    }\r\n-\r\n-    private void loadAPI(final String property) {\r\n-        if (tabPane.getTabs().contains(javadocTab)) {\r\n-            if (property != null) {\r\n-                goToTab(JavaDocTab.TAB_NAME);\r\n-            }\r\n-            if (javadocTab.isSelected()) {\r\n-                javadocTab.loadAPI(property);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) \r\n-    public String findProperty(final String className, final String property) {\r\n-        Class node = null;\r\n-        try {\r\n-            node = Class.forName(className);\r\n-            node.getDeclaredMethod(property + \"Property\");\r\n-\r\n-            return className;\r\n-        } catch (final Exception e) {\r\n-            return findProperty(node.getSuperclass().getName(), property);\r\n-        }\r\n-    }\r\n-\r\n-    public void update() {\r\n-        for (int i = 0; i < appRepository.getApps().size(); i++) {\r\n-            final List<StageController> stages = appRepository.getApps().get(i).getStages();\r\n-            for (int j = 0; j < stages.size(); j++) {\r\n-                if (stages.get(j).isOpened()) {\r\n-                    stages.get(j).update();\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    StageController getStageController(final StageID id) {\r\n-        for (int i = 0; i < appRepository.getApps().size(); i++) {\r\n-            final List<StageController> stages = appRepository.getApps().get(i).getStages();\r\n-            for (int j = 0; j < stages.size(); j++) {\r\n-                if (stages.get(j).getID().equals(id)) {\r\n-                    return stages.get(j);\r\n-                }\r\n-            }\r\n-        }\r\n-        return appRepository.getApps().get(0).getStages().get(0);\r\n-        // return null;\r\n-    }\r\n-\r\n-    protected void filterProperties(final String text) {\r\n-        detailsTab.filterProperties(text);\r\n-    }\r\n-\r\n-    public void setSelectedNode(final StageController controller, final SVNode value) {\r\n-        if (value != selectedNode) {\r\n-            if (controller != null && activeStage != controller) {\r\n-                /**\r\n-                 * Remove selected from previous active\r\n-                 */\r\n-                activeStage.setSelectedNode(null);\r\n-                activeStage = controller;\r\n-            }\r\n-            storeSelectedNode(value);\r\n-            eventsTab.setSelectedNode(value);\r\n-            loadAPI(null);\r\n-            propertyFilterField.setText(\"\");\r\n-            propertyFilterField.setDisable(value == null);\r\n-            filterProperties(propertyFilterField.getText());\r\n-            threeDOMTab.setSelectedNode(value); // 3D addition\r\n-            cssfxTab.setActiveStage((controller==null)?null:controller.getID());\r\n-        }\r\n-    }\r\n-\r\n-    public SVNode getSelectedNode() {\r\n-        return selectedNode;\r\n-    }\r\n-    \r\n-    public void removeNode() {\r\n-        activeStage.removeSelectedNode();\r\n-    }\r\n-\r\n-    private void storeSelectedNode(final SVNode value) {\r\n-        selectedNode = value;\r\n-        if (selectedNode != null && detailsTab.isSelected())\r\n-            setStatusText(\"Click on the labels to modify its values. The panel could have different capabilities. When changed the values will be highlighted\",\r\n-                    8000);\r\n-        activeStage.setSelectedNode(value);\r\n-    }\r\n-\r\n-    public CheckMenuItem buildCheckMenuItem(final String text, final String toolTipSelected, final String toolTipNotSelected, final String property,\r\n-            final Boolean value) {\r\n-        final CheckMenuItem menuItem = new CheckMenuItem(text);\r\n-        if (property != null) {\r\n-            Persistence.loadProperty(property, menuItem, value);\r\n-        } else if (value != null) {\r\n-            menuItem.setSelected(value);\r\n-        }\r\n-        menuItem.selectedProperty().addListener(new ChangeListener<Boolean>() {\r\n-            @Override public void changed(final ObservableValue<? extends Boolean> arg0, final Boolean arg1, final Boolean newValue) {\r\n-                setStatusText(newValue ? toolTipSelected : toolTipNotSelected, 4000);\r\n-            }\r\n-        });\r\n-\r\n-        return menuItem;\r\n-    }\r\n-\r\n-    private FilterTextField createFilterField(final String prompt) {\r\n-        return createFilterField(prompt, event -> update());\r\n-    }\r\n-\r\n-    private FilterTextField createFilterField(final String prompt, final EventHandler<KeyEvent> keyHandler) {\r\n-        final FilterTextField filterField = new FilterTextField();\r\n-        filterField.setPromptText(prompt);\r\n-        if (keyHandler != null) {\r\n-            filterField.setOnKeyReleased(keyHandler);\r\n-        }\r\n-        filterField.focusedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\r\n-            if (newValue) {\r\n-                setStatusText(\"Type any text for filtering\");\r\n-            } else {\r\n-                clearStatusText();\r\n-            }\r\n-        });\r\n-        return filterField;\r\n-    }\r\n-\r\n-    private void closeApps() {\r\n-        for (final Iterator<AppController> iterator = appRepository.getApps().iterator(); iterator.hasNext();) {\r\n-            final AppController stage = iterator.next();\r\n-            stage.close();\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        closeApps();\r\n-        saveProperties();\r\n-        updateStrategy.finish();\r\n-    }\r\n-\r\n-    private void saveProperties() {\r\n-        Persistence.saveProperties();\r\n-    }\r\n-\r\n-    public void setStatusText(final String text) {\r\n-        statusBar.setStatusText(text);\r\n-    }\r\n-\r\n-    public void setStatusText(final String text, final long timeout) {\r\n-        statusBar.setStatusText(text, timeout);\r\n-    }\r\n-\r\n-    public void clearStatusText() {\r\n-        statusBar.clearStatusText();\r\n-    }\r\n-\r\n-    public boolean hasStatusText() {\r\n-        return statusBar.hasStatus();\r\n-    }\r\n-\r\n-//    @Override protected double computePrefWidth(final double height) {\r\n-//        return 600;\r\n-//    }\r\n-//\r\n-//    @Override protected double computePrefHeight(final double width) {\r\n-//        return 600;\r\n-//    }\r\n-//\r\n-//    @Override protected void layoutChildren() {\r\n-//        layoutInArea(borderPane, getPadding().getLeft(), getPadding().getTop(), getWidth() - getPadding().getLeft() - getPadding().getRight(), getHeight()\r\n-//                - getPadding().getTop() - getPadding().getBottom(), 0, HPos.LEFT, VPos.TOP);\r\n-//    }\r\n-\r\n-    public final BorderPane getBorderPane() {\r\n-        return rootBorderPane;\r\n-    }\r\n-\r\n-//    /**\r\n-//     * For autoTesting purposes\r\n-//     */\r\n-//    @Override public ObservableList<Node> getChildren() {\r\n-//        return super.getChildren();\r\n-//    }\r\n-\r\n-    public static void show(final ScenicViewGui scenicview, final Stage stage) {\r\n-        final Scene scene = new Scene(scenicview.rootBorderPane);\r\n-        scene.getStylesheets().addAll(STYLESHEETS);\r\n-        stage.setScene(scene);\r\n-        stage.getIcons().add(APP_ICON);\r\n-        if (scenicview.activeStage != null && scenicview.activeStage instanceof StageControllerImpl)\r\n-            ((StageControllerImpl) scenicview.activeStage).placeStage(stage);\r\n-\r\n-        stage.addEventHandler(WindowEvent.WINDOW_CLOSE_REQUEST, event -> {\r\n-            Runtime.getRuntime().removeShutdownHook(scenicview.shutdownHook);\r\n-            scenicview.close();\r\n-        });\r\n-        stage.show();\r\n-    }\r\n-\r\n-    public void openStage(final StageController controller) {\r\n-        controller.setEventDispatcher(stageModelListener);\r\n-        controller.configurationUpdated(configuration);\r\n-    }\r\n-\r\n-    public void forceUpdate() {\r\n-        update();\r\n-    }\r\n-    \r\n-    public void goToTab(String tabName) {\r\n-        Tab switchToTab = null;\r\n-        for (Tab tab : tabPane.getTabs()) {\r\n-            if (tabName == tab.getText()) {\r\n-                switchToTab = tab;\r\n-                break;\r\n-            }\r\n-        }\r\n-        \r\n-        if (switchToTab != null) {\r\n-            tabPane.getSelectionModel().select(switchToTab);\r\n-        }\r\n-    }\r\n-    \r\n-    private void doDispatchEvent(final FXConnectorEvent appEvent) {\r\n-        switch (appEvent.getType()) {\r\n-            case EVENT_LOG: {\r\n-                eventsTab.trace((EvLogEvent) appEvent);\r\n-                break;\r\n-            }                \r\n-            case MOUSE_POSITION: {\r\n-                if (isActive(appEvent.getStageID()))\r\n-                    statusBar.updateMousePosition(((MousePosEvent) appEvent).getPosition());\r\n-                break;\r\n-            }\r\n-            case SHORTCUT: {\r\n-                final KeyCode c = ((ShortcutEvent) appEvent).getCode();\r\n-                switch (c) {\r\n-                    case S:\r\n-                        componentSelectOnClick.setSelected(!configuration.isComponentSelectOnClick());\r\n-                        break;\r\n-                    case R:\r\n-                        configuration.setShowRuler(!configuration.isShowRuler());\r\n-                        configurationUpdated();\r\n-                        break;\r\n-                    case D:\r\n-                        treeView.getSelectionModel().clearSelection();\r\n-                        break;\r\n-                    default:\r\n-                        break;\r\n-                }\r\n-                break;\r\n-            }\r\n-            case WINDOW_DETAILS: {\r\n-                final WindowDetailsEvent wevent = (WindowDetailsEvent) appEvent;\r\n-                autoRefreshStyleSheets.setDisable(!wevent.isStylesRefreshable());\r\n-\r\n-                if (isActive(wevent.getStageID())) {\r\n-                    statusBar.updateWindowDetails(wevent.getWindowType(), wevent.getBounds(), wevent.isFocused());\r\n-                }\r\n-                break;\r\n-            }\r\n-            case NODE_SELECTED: {\r\n-                componentSelectOnClick.setSelected(false);\r\n-                treeView.nodeSelected(((NodeSelectedEvent) appEvent).getNode());\r\n-                cssfxTab.setActiveStage(appEvent.getStageID());\r\n-\r\n-                scenicViewStage.toFront();\r\n-                break;\r\n-            }\r\n-            case NODE_COUNT: {\r\n-                statusBar.updateNodeCount(((NodeCountEvent) appEvent).getNodeCount());\r\n-                break;\r\n-            }\r\n-            case SCENE_DETAILS: {\r\n-                if (isActive(appEvent.getStageID())) {\r\n-                    final SceneDetailsEvent sEvent = (SceneDetailsEvent) appEvent;\r\n-                    statusBar.updateSceneDetails(sEvent.getSize(), sEvent.getNodeCount());\r\n-                }\r\n-                break;\r\n-            }\r\n-            case ROOT_UPDATED: {\r\n-                treeView.updateStageModel(getStageController(appEvent.getStageID()), \r\n-                                         ((NodeAddRemoveEvent) appEvent).getNode(), \r\n-                                         showNodesIdInTree.isSelected(),\r\n-                                         showFilteredNodesInTree.isSelected());\r\n-                threeDOMTab.placeNewRoot(((NodeAddRemoveEvent) appEvent).getNode());\r\n-                cssfxTab.registerStage(appEvent.getStageID());\r\n-                break;\r\n-            }\r\n-            case NODE_ADDED: {\r\n-                /**\r\n-                 * First check if a we have a NODE_REMOVED in the queue\r\n-                 */\r\n-                final int removedPos = indexOfNode(((NodeAddRemoveEvent) appEvent).getNode(), true);\r\n-                if (removedPos == -1) {\r\n-                    treeView.addNewNode(((NodeAddRemoveEvent) appEvent).getNode(), showNodesIdInTree.isSelected(), showFilteredNodesInTree.isSelected());\r\n-                    threeDOMTab.reload();   // 3D addition\r\n-                } else {\r\n-                    eventQueue.remove(removedPos);\r\n-                }\r\n-               \r\n-                break;\r\n-            }\r\n-            case NODE_REMOVED: {\r\n-                final int addedPos = indexOfNode(((NodeAddRemoveEvent) appEvent).getNode(), false);\r\n-                if (addedPos == -1) {\r\n-                    treeView.removeNode(((NodeAddRemoveEvent) appEvent).getNode());\r\n-                    threeDOMTab.removeNode(((NodeAddRemoveEvent) appEvent).getNode());   // 3D addition\r\n-                } else {\r\n-                    eventQueue.remove(addedPos);\r\n-                }\r\n-                break;\r\n-            }\r\n-            case DETAILS: {\r\n-                final DetailsEvent ev = (DetailsEvent) appEvent;\r\n-                detailsTab.updateDetails(ev.getPaneType(), ev.getPaneName(), ev.getDetails(), (detail, value) -> {\r\n-                    getStageController(appEvent.getStageID()).setDetail(detail.getDetailType(), detail.getDetailID(), value);   \r\n-                });\r\n-                break;\r\n-            }\r\n-            case DETAIL_UPDATED: {\r\n-                final DetailsEvent ev2 = (DetailsEvent) appEvent;\r\n-                detailsTab.updateDetail(ev2.getPaneType(), ev2.getPaneName(), ev2.getDetails().get(0));\r\n-                break;\r\n-            }\r\n-            case ANIMATIONS_UPDATED: {\r\n-                animationsTab.update(appEvent.getStageID(), ((AnimationsCountEvent) appEvent).getAnimations());\r\n-                break;\r\n-            }\r\n-            case CSS_ADDED: \r\n-            case CSS_REMOVED: \r\n-            case CSS_REPLACED: \r\n-                cssfxTab.handleEvent(appEvent);\r\n-                break;\r\n-            default: {\r\n-                Logger.print(\"Unused event for type \" + appEvent);\r\n-                break;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private int indexOfNode(final SVNode node, final boolean add) {\r\n-        for (int i = 0; i < eventQueue.size(); i++) {\r\n-            final FXConnectorEvent ev = eventQueue.get(i);\r\n-            if ((add && ev.getType() == SVEventType.NODE_REMOVED) || (!add && ev.getType() == SVEventType.NODE_ADDED)) {\r\n-                final NodeAddRemoveEvent ev2 = (NodeAddRemoveEvent) ev;\r\n-                if (ev2.getNode().equals(node)) {\r\n-                    return i;\r\n-                }\r\n-            }\r\n-        }\r\n-        return -1;\r\n-    }\r\n-\r\n-    private boolean isActive(final StageID stageID) {\r\n-        return activeStage.getID().equals(stageID);\r\n-    }\r\n-    /**\r\n-     * 3D additions\r\n-     * @return scene graph treeview\r\n-     */\r\n-    public ScenegraphTreeView getTreeView(){\r\n-         return treeView;\r\n-     }\r\n-}\r\n+/*\n+ * Scenic View, \n+ * Copyright (C) 2012 Jonathan Giles, Ander Ruiz, Amy Fowler \n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package org.scenicview.view;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import javafx.animation.Animation;\n+import javafx.animation.KeyFrame;\n+import javafx.animation.Timeline;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+import javafx.event.EventHandler;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Pos;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.CheckBox;\n+import javafx.scene.control.CheckMenuItem;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Menu;\n+import javafx.scene.control.MenuBar;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.ProgressIndicator;\n+import javafx.scene.control.SeparatorMenuItem;\n+import javafx.scene.control.SplitPane;\n+import javafx.scene.control.Tab;\n+import javafx.scene.control.TabPane;\n+import javafx.scene.image.Image;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyCombination;\n+import javafx.scene.input.KeyEvent;\n+import javafx.scene.layout.AnchorPane;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.Priority;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.layout.VBox;\n+import javafx.stage.Stage;\n+import javafx.stage.WindowEvent;\n+import javafx.util.Duration;\n+\n+import org.fxconnector.AppController;\n+import org.fxconnector.Configuration;\n+import org.fxconnector.ConnectorUtils;\n+import org.fxconnector.StageController;\n+import org.fxconnector.StageControllerImpl;\n+import org.fxconnector.StageID;\n+import org.fxconnector.event.AnimationsCountEvent;\n+import org.fxconnector.event.DetailsEvent;\n+import org.fxconnector.event.EvLogEvent;\n+import org.fxconnector.event.FXConnectorEvent;\n+import org.fxconnector.event.FXConnectorEvent.SVEventType;\n+import org.fxconnector.event.FXConnectorEventDispatcher;\n+import org.fxconnector.event.MousePosEvent;\n+import org.fxconnector.event.NodeAddRemoveEvent;\n+import org.fxconnector.event.NodeCountEvent;\n+import org.fxconnector.event.NodeSelectedEvent;\n+import org.fxconnector.event.SceneDetailsEvent;\n+import org.fxconnector.event.ShortcutEvent;\n+import org.fxconnector.event.WindowDetailsEvent;\n+import org.fxconnector.helper.WorkerThread;\n+import org.fxconnector.node.SVNode;\n+import org.scenicview.model.Persistence;\n+import org.scenicview.model.update.AppsRepository;\n+import org.scenicview.model.update.UpdateStrategy;\n+import org.scenicview.utils.ExceptionLogger;\n+import org.scenicview.utils.Logger;\n+import org.scenicview.view.control.FilterTextField;\n+import org.scenicview.view.dialog.AboutBox;\n+import org.scenicview.view.dialog.HelpBox;\n+import org.scenicview.view.tabs.AnimationsTab;\n+import org.scenicview.view.tabs.CSSFXTab;\n+import org.scenicview.view.tabs.DetailsTab;\n+import org.scenicview.view.tabs.EventLogTab;\n+import org.scenicview.view.tabs.JavaDocTab;\n+import org.scenicview.view.tabs.ThreeDOMTab;\n+\n+/**\n+ * The base UI\n+ */\n+public class ScenicViewGui {\n+    \n+    private static final String HELP_URL = \"http://fxexperience.com/scenic-view/help\";\n+    public static final String STYLESHEETS = ScenicViewGui.class.getResource(\"scenicview.css\").toExternalForm();\n+    public static final Image APP_ICON = DisplayUtils.getUIImage(\"mglass.png\");\n+\n+    public static final String VERSION = \"11.0.2\";\n+\n+    private final Thread shutdownHook = new Thread() {\n+        @Override public void run() {\n+            // We can't use close() because we are not in FXThread\n+            saveProperties();\n+        }\n+    };\n+\n+    // Scenic View UI\n+    private final Stage scenicViewStage;\n+    private BorderPane rootBorderPane;\n+    private SplitPane splitPane;\n+    \n+    // menu bar area\n+    private MenuBar menuBar;\n+    private CheckMenuItem showFilteredNodesInTree;\n+    private CheckMenuItem showNodesIdInTree;\n+    private CheckMenuItem autoRefreshStyleSheets;\n+    private CheckMenuItem componentSelectOnClick;\n+    private CheckMenuItem showInvisibleNodes;\n+    private CheckMenuItem showSearchBar;\n+    \n+    // filter area\n+//    private TitledPane filtersPane;\n+    private FilterTextField propertyFilterField;\n+    private List<NodeFilter> activeNodeFilters;\n+    \n+    // tree area\n+    private Node treeViewScanningPlaceholder;\n+    private ScenegraphTreeView treeView;\n+    \n+    // search bar area\n+    private GridPane searchBar;\n+    \n+    // status bar area\n+    private StatusBar statusBar;\n+    \n+    private VBox bottomVBox;\n+\n+    private ProgressIndicator progressScanning = new ProgressIndicator();\n+    private Label labelScanning = new Label(\"Scanning for JavaFX applications\");\n+\n+    public final Configuration configuration = new Configuration();\n+    private final List<FXConnectorEvent> eventQueue = new LinkedList<>();\n+\n+    private UpdateStrategy updateStrategy;\n+    private long lastMousePosition;\n+\n+    private final FXConnectorEventDispatcher stageModelListener = new FXConnectorEventDispatcher() {\n+        @Override public void dispatchEvent(final FXConnectorEvent appEvent) {\n+            if (isValid(appEvent)) {\n+                // doDispatchEvent(appEvent);\n+                switch (appEvent.getType()) {\n+\n+                    case ROOT_UPDATED:\n+                        doDispatchEvent(appEvent);\n+                        break;\n+\n+                    case MOUSE_POSITION:\n+                        if (System.currentTimeMillis() - lastMousePosition > 500) {\n+                            lastMousePosition = System.currentTimeMillis();\n+                            // No need to synchronize here\n+                            eventQueue.add(appEvent);\n+                        }\n+                        break;\n+\n+                    default:\n+                        // No need to synchronize here\n+                        eventQueue.add(appEvent);\n+                        break;\n+                }\n+\n+            } else {\n+                Logger.print(\"Unused event \" + appEvent);\n+            }\n+        }\n+\n+        private boolean isValid(final FXConnectorEvent appEvent) {\n+            for (int i = 0; i < appRepository.getApps().size(); i++) {\n+                if (appRepository.getApps().get(i).getID() == appEvent.getStageID().getAppID()) {\n+                    final List<StageController> stages = appRepository.getApps().get(i).getStages();\n+                    for (int j = 0; j < stages.size(); j++) {\n+                        if (stages.get(j).getID().getStageID() == appEvent.getStageID().getStageID()) {\n+                            return true;\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+            return false;\n+        }\n+    };\n+\n+//    private final List<AppController> apps = new ArrayList<AppController>();\n+    private final AppsRepository appRepository; \n+    \n+    public StageController activeStage;\n+    private SVNode selectedNode;\n+    \n+    private TabPane tabPane;\n+    private DetailsTab detailsTab;\n+    private EventLogTab eventsTab;\n+    private AnimationsTab animationsTab;\n+    private JavaDocTab javadocTab;\n+    private ThreeDOMTab threeDOMTab;\n+    private CSSFXTab cssfxTab;\n+\n+    public ScenicViewGui(final UpdateStrategy updateStrategy, final Stage scenicViewStage) {\n+        this.scenicViewStage = scenicViewStage;\n+        Persistence.loadProperties();\n+        Runtime.getRuntime().addShutdownHook(shutdownHook);\n+        this.updateStrategy = updateStrategy;\n+        buildUI();\n+//        checkNewVersion(false);\n+        \n+        this.appRepository = new AppsRepository(this);\n+        this.updateStrategy.start(appRepository);\n+        \n+        // we update Scenic View on a separate thread, based on events coming\n+        // in from FX Connector. The events arrive into the eventQueue, and\n+        // are processed here\n+        Timeline eventDispatcher = new Timeline(new KeyFrame(Duration.millis(60), event -> {\n+            // No need to synchronize\n+            while (!eventQueue.isEmpty()) {\n+                try {\n+                    doDispatchEvent(eventQueue.remove(0));\n+                } catch (final Exception e) {\n+                    ExceptionLogger.submitException(e);\n+                }\n+            }\n+        }));\n+        eventDispatcher.setCycleCount(Animation.INDEFINITE);\n+        eventDispatcher.play();\n+    }\n+    \n+    private void buildUI() {\n+        rootBorderPane = new BorderPane();\n+        rootBorderPane.setId(StageController.FX_CONNECTOR_BASE_ID + \"scenic-view\");\n+        \n+        // search bar\n+        buildFiltersBox();\n+\n+        // menubar\n+        buildMenuBar();\n+\n+        // main splitpane\n+        splitPane = new SplitPane();\n+        splitPane.setId(\"main-splitpane\");\n+\n+        \n+        // treeview\n+        treeView = new ScenegraphTreeView(activeNodeFilters, this);\n+        treeViewScanningPlaceholder = new VBox(10) {\n+            {\n+\n+                labelScanning.getStyleClass().add(\"scanning-label\");\n+                getChildren().addAll(progressScanning, labelScanning);\n+\n+                setAlignment(Pos.CENTER);\n+                \n+                treeView.expandedItemCountProperty().addListener(o -> {\n+                    setVisible(treeView.getExpandedItemCount() == 0);\n+                });\n+                \n+            }\n+        };\n+        \n+        StackPane treeViewStackPane = new StackPane(treeView, treeViewScanningPlaceholder);\n+        treeViewStackPane.setStyle(\" -fx-padding: 0\");\n+\n+        treeView.setMaxHeight(Double.MAX_VALUE);\n+        \n+        // right side\n+        detailsTab = new DetailsTab(this, new Consumer<String>() {\n+            @Override public void accept(String property) {\n+                ScenicViewGui.this.loadAPI(property);\n+            }\n+        });\n+\n+        animationsTab = new AnimationsTab(this);\n+\n+        tabPane = new TabPane();\n+        tabPane.getSelectionModel().selectedItemProperty().addListener((ov, oldValue, newValue) -> updateMenuBar(oldValue, newValue));\n+\n+        javadocTab = new JavaDocTab(this); \n+        \n+        eventsTab = new EventLogTab(this);\n+        eventsTab.activeProperty().addListener((ov, oldValue, newValue) -> {\n+            configuration.setEventLogEnabled(newValue);\n+            configurationUpdated();\n+        });\n+        \n+        // 3Dom\n+        threeDOMTab = new ThreeDOMTab(this); \n+        \n+        // CSSFX\n+        cssfxTab = new CSSFXTab(this);\n+        \n+        tabPane.getTabs().addAll(detailsTab, eventsTab, /*animationsTab,*/ javadocTab, threeDOMTab, cssfxTab);\n+        // /3Dom\n+        \n+        Persistence.loadProperty(\"splitPaneDividerPosition\", splitPane, 0.3);\n+\n+        // putting it all together\n+        splitPane.getItems().addAll(treeViewStackPane, tabPane);\n+\n+        rootBorderPane.setCenter(splitPane);\n+        \n+        // status bar\n+        statusBar = new StatusBar();\n+        \n+        bottomVBox = new VBox(searchBar, statusBar);\n+\n+        rootBorderPane.setBottom(bottomVBox);\n+\n+        Persistence.loadProperty(\"stageWidth\", scenicViewStage, 800);\n+        Persistence.loadProperty(\"stageHeight\", scenicViewStage, 800);\n+    }\n+    \n+    private void buildFiltersBox() {\n+        propertyFilterField = createFilterField(\"Type property names or values here\", null);\n+        propertyFilterField.setOnKeyReleased(new EventHandler<KeyEvent>() {\n+            @Override public void handle(final KeyEvent arg0) {\n+                filterProperties(propertyFilterField.getText());\n+            }\n+        });\n+        propertyFilterField.setDisable(true);\n+        \n+        final FilterTextField idFilterField = createFilterField(\"Type Node ID's here\");\n+        idFilterField.setOnButtonClick(() -> {\n+            idFilterField.setText(\"\");\n+            update();\n+        });\n+        \n+        final FilterTextField classNameFilterField = createFilterField(\"Type class names here\");\n+        classNameFilterField.setOnButtonClick(() -> {\n+            classNameFilterField.setText(\"\");\n+            update();\n+        });\n+        \n+        searchBar = new GridPane();\n+        searchBar.setVgap(5);\n+        searchBar.setHgap(5);\n+        searchBar.setSnapToPixel(true);\n+        searchBar.setPadding(new Insets(0, 5, 5, 0));\n+        searchBar.getStyleClass().add(\"search-bar\");\n+\n+        GridPane.setHgrow(idFilterField, Priority.ALWAYS);\n+        GridPane.setHgrow(classNameFilterField, Priority.ALWAYS);\n+        GridPane.setHgrow(propertyFilterField, Priority.ALWAYS);\n+\n+        int column = 1;\n+        \n+        Label nodeIdFilterLabel = new Label(\"Node ID Filter:\");\n+        Label classNameFilterLabel = new Label(\"Class Name Filter:\");\n+        Label propertyFilterLabel = new Label(\"Property Filter:\");\n+        \n+        searchBar.add(nodeIdFilterLabel, column++, 1);\n+        searchBar.add(idFilterField, column++, 1);\n+        searchBar.add(classNameFilterLabel, column++, 1);\n+        searchBar.add(classNameFilterField, column++, 1);\n+        searchBar.add(propertyFilterLabel, column++, 1);\n+        searchBar.add(propertyFilterField, column++, 1);\n+\n+        // create filters for nodes\n+        activeNodeFilters = new ArrayList<>();\n+\n+        /**\n+         * Create a filter for our own nodes\n+         */\n+        activeNodeFilters.add(new NodeFilter() {\n+            @Override public boolean allowChildrenOnRejection() {\n+                return false;\n+            }\n+\n+            @Override public boolean accept(final SVNode node) {\n+                // do not create tree nodes for our bounds rectangles\n+                return ConnectorUtils.isNormalNode(node);\n+            }\n+\n+            @Override public boolean ignoreShowFilteredNodesInTree() {\n+                return true;\n+            }\n+\n+            @Override public boolean expandAllNodes() {\n+                return false;\n+            }\n+        });\n+        \n+        activeNodeFilters.add(new NodeFilter() {\n+            @Override public boolean allowChildrenOnRejection() {\n+                return false;\n+            }\n+\n+            @Override public boolean accept(final SVNode node) {\n+                return showInvisibleNodes.isSelected() || node.isVisible();\n+            }\n+\n+            @Override public boolean ignoreShowFilteredNodesInTree() {\n+                return false;\n+            }\n+\n+            @Override public boolean expandAllNodes() {\n+                return false;\n+            }\n+        });\n+        \n+        activeNodeFilters.add(new NodeFilter() {\n+            @Override public boolean allowChildrenOnRejection() {\n+                return true;\n+            }\n+\n+            @Override public boolean accept(final SVNode node) {\n+                if (idFilterField.getText().equals(\"\"))\n+                    return true;\n+                return node.getId() != null && node.getId().toLowerCase().indexOf(idFilterField.getText().toLowerCase()) != -1;\n+            }\n+\n+            @Override public boolean ignoreShowFilteredNodesInTree() {\n+                return false;\n+            }\n+\n+            @Override public boolean expandAllNodes() {\n+                return !idFilterField.getText().equals(\"\");\n+            }\n+        });\n+        \n+        activeNodeFilters.add(new NodeFilter() {\n+            @Override public boolean allowChildrenOnRejection() {\n+                return true;\n+            }\n+\n+            @Override public boolean accept(final SVNode node) {\n+                if (classNameFilterField.getText().equals(\"\"))\n+                    return true;\n+\n+                // Allow reduces or complete className\n+                return node.getNodeClass().toLowerCase().indexOf(classNameFilterField.getText().toLowerCase()) != -1;\n+            }\n+\n+            @Override public boolean ignoreShowFilteredNodesInTree() {\n+                return false;\n+            }\n+\n+            @Override public boolean expandAllNodes() {\n+                return !classNameFilterField.getText().equals(\"\");\n+            }\n+        });\n+    }\n+    \n+    private void buildMenuBar() {\n+        menuBar = new MenuBar();\n+        menuBar.setUseSystemMenuBar(true);\n+        // menuBar.setId(\"main-menubar\");\n+\n+        // ---- File Menu\n+//        final MenuItem classpathItem = new MenuItem(\"Configure Classpath\");\n+//        classpathItem.setOnAction(new EventHandler<ActionEvent>() {\n+//            @Override public void handle(final ActionEvent arg0) {\n+//                final Properties properties = PropertiesUtils.getProperties();\n+//\n+//                final String toolsPath = properties.getProperty(ScenicViewBooter.JDK_PATH_KEY);\n+//                final File jdkPathFile = new ClassPathDialog(toolsPath).show(scenicViewStage);\n+//                \n+//                if (jdkPathFile != null) {\n+//                    properties.setProperty(ScenicViewBooter.JDK_PATH_KEY, jdkPathFile.getAbsolutePath());\n+//                    PropertiesUtils.saveProperties();\n+//                }\n+//            }\n+//        });\n+\n+        final MenuItem exitItem = new MenuItem(\"E_xit Scenic View\");\n+        exitItem.setAccelerator(KeyCombination.keyCombination(\"CTRL+Q\"));\n+        exitItem.setOnAction(event -> {\n+            Runtime.getRuntime().removeShutdownHook(shutdownHook);\n+            close();\n+            // TODO Why closing the Stage does not dispatch\n+            // WINDOW_CLOSE_REQUEST??\n+            scenicViewStage.close();\n+        });\n+\n+        final Menu fileMenu = new Menu(\"File\");\n+//        if (updateStrategy.needsClassPathConfiguration()) {\n+//            fileMenu.getItems().addAll(classpathItem, new SeparatorMenuItem());\n+//        }\n+        fileMenu.getItems().add(exitItem);\n+\n+        // ---- Options Menu\n+        final CheckMenuItem showBoundsCheckbox = buildCheckMenuItem(\"Show Bounds Overlays\", \"Show the bound overlays on selected\",\n+                \"Do not show bound overlays on selected\", \"showBounds\", Boolean.TRUE);\n+        showBoundsCheckbox.setId(\"show-bounds-checkbox\");\n+        // showBoundsCheckbox.setTooltip(new\n+        // Tooltip(\"Display a yellow highlight for boundsInParent and green outline for layoutBounds.\"));\n+        configuration.setShowBounds(showBoundsCheckbox.isSelected());\n+        showBoundsCheckbox.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\n+            configuration.setShowBounds(newValue);\n+            configurationUpdated();\n+        });\n+\n+        final CheckMenuItem collapseControls = buildCheckMenuItem(\"Collapse controls In Tree\", \"Controls will be collapsed\", \"Controls will be expanded\",\n+                \"collapseControls\", Boolean.TRUE);\n+        collapseControls.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\n+            configuration.setCollapseControls(newValue);\n+            configurationUpdated();\n+        });\n+        configuration.setCollapseControls(collapseControls.isSelected());\n+\n+        final CheckMenuItem collapseContentControls = buildCheckMenuItem(\"Collapse container controls In Tree\", \"Container controls will be collapsed\",\n+                \"Container controls will be expanded\", \"collapseContainerControls\", Boolean.FALSE);\n+        collapseContentControls.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\n+            configuration.setCollapseContentControls(newValue);\n+            configurationUpdated();\n+        });\n+        collapseContentControls.disableProperty().bind(collapseControls.selectedProperty().not());\n+        configuration.setCollapseContentControls(collapseContentControls.isSelected());\n+\n+        final CheckMenuItem showBaselineCheckbox = buildCheckMenuItem(\"Show Baseline Overlay\", \"Display a red line at the current node's baseline offset\",\n+                \"Do not show baseline overlay\", \"showBaseline\", Boolean.FALSE);\n+        showBaselineCheckbox.setId(\"show-baseline-overlay\");\n+        configuration.setShowBaseline(showBaselineCheckbox.isSelected());\n+        showBaselineCheckbox.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\n+            configuration.setShowBaseline(newValue);\n+            configurationUpdated();\n+        });\n+\n+        final CheckMenuItem automaticScenegraphStructureRefreshing = buildCheckMenuItem(\"Auto-Refresh Scenegraph\",\n+                \"Scenegraph structure will be automatically updated on change\", \"Scenegraph structure will NOT be automatically updated on change\",\n+                \"automaticScenegraphStructureRefreshing\", Boolean.TRUE);\n+        automaticScenegraphStructureRefreshing.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\n+            configuration.setAutoRefreshSceneGraph(automaticScenegraphStructureRefreshing.isSelected());\n+            configurationUpdated();\n+        });\n+        configuration.setAutoRefreshSceneGraph(automaticScenegraphStructureRefreshing.isSelected());\n+        \n+        \n+        // --- show search bar\n+        showSearchBar = buildCheckMenuItem(\"Show Search Bar\", \"Shows a search bar to allow you to filter the displayed information\",\n+                \"Shows a search bar to allow you to filter the displayed information\", \"showSearchBar\", Boolean.TRUE);\n+        searchBar.visibleProperty().bind(showSearchBar.selectedProperty());\n+        searchBar.managedProperty().bind(showSearchBar.selectedProperty());\n+\n+        \n+        // --- show invisible nodes\n+        showInvisibleNodes = buildCheckMenuItem(\"Show Invisible Nodes In Tree\", \"Invisible nodes will be faded in the scenegraph tree\",\n+                \"Invisible nodes will not be shown in the scenegraph tree\", \"showInvisibleNodes\", Boolean.FALSE);\n+        final ChangeListener<Boolean> visilityListener = (o, oldValue, newValue) -> {\n+            configuration.setVisibilityFilteringActive(!showInvisibleNodes.isSelected() && !showFilteredNodesInTree.isSelected());\n+            configurationUpdated();\n+        };\n+        showInvisibleNodes.selectedProperty().addListener(visilityListener);\n+\n+        \n+        // --- show node IDs in tree\n+        showNodesIdInTree = buildCheckMenuItem(\"Show Node IDs\", \"Node IDs will be shown on the scenegraph tree\",\n+                \"Node IDs will not be shown the Scenegraph tree\", \"showNodesIdInTree\", Boolean.FALSE);\n+        showNodesIdInTree.selectedProperty().addListener(o -> update());\n+\n+        \n+        // --- show filtered nodes in tree\n+        showFilteredNodesInTree = buildCheckMenuItem(\"Show Filtered Nodes In Tree\", \"Filtered nodes will be faded in the tree\",\n+                \"Filtered nodes will not be shown in tree (unless they are parents of non-filtered nodes)\", \"showFilteredNodesInTree\", Boolean.TRUE);\n+\n+        showFilteredNodesInTree.selectedProperty().addListener(visilityListener);\n+        configuration.setVisibilityFilteringActive(!showInvisibleNodes.isSelected() && !showFilteredNodesInTree.isSelected());\n+\n+        /**\n+         * Filter invisible nodes only makes sense if showFilteredNodesInTree is not selected\n+         */\n+        showInvisibleNodes.disableProperty().bind(showFilteredNodesInTree.selectedProperty());\n+\n+        componentSelectOnClick = buildCheckMenuItem(\"Component highlight/select on click\", \"Click on the scene to select a component\", \"\", null, null);\n+        componentSelectOnClick.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> selectOnClick(newValue));\n+\n+        final CheckMenuItem ignoreMouseTransparentNodes = buildCheckMenuItem(\"Ignore MouseTransparent Nodes\", \"Transparent nodes will not be selectable\",\n+                \"Transparent nodes can be selected\", \"ignoreMouseTransparentNodes\", Boolean.TRUE);\n+        ignoreMouseTransparentNodes.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\n+            configuration.setIgnoreMouseTransparent(newValue);\n+            configurationUpdated();\n+        });\n+        configuration.setIgnoreMouseTransparent(ignoreMouseTransparentNodes.isSelected());\n+\n+        final CheckMenuItem registerShortcuts = buildCheckMenuItem(\"Register shortcuts\", \"SV Keyboard shortcuts will be registered on your app\",\n+                \"SV Keyboard shortcuts will be removed on your app\", \"registerShortcuts\", Boolean.TRUE);\n+        registerShortcuts.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\n+            configuration.setRegisterShortcuts(newValue);\n+            configurationUpdated();\n+        });\n+        configuration.setRegisterShortcuts(registerShortcuts.isSelected());\n+\n+        autoRefreshStyleSheets = buildCheckMenuItem(\"Auto-Refresh StyleSheets\",\n+                \"A background thread will check modifications on the css files to reload them if needed\", \"StyleSheets autorefreshing disabled\",\n+                \"autoRefreshStyleSheets\", Boolean.FALSE);\n+        autoRefreshStyleSheets.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\n+            configuration.setAutoRefreshStyles(newValue);\n+            configurationUpdated();\n+        });\n+        configuration.setAutoRefreshStyles(autoRefreshStyleSheets.isSelected());\n+\n+        final Menu scenegraphMenu = new Menu(\"Scenegraph\");\n+        scenegraphMenu.getItems().addAll(automaticScenegraphStructureRefreshing, autoRefreshStyleSheets, registerShortcuts, new SeparatorMenuItem(),\n+                componentSelectOnClick, ignoreMouseTransparentNodes);\n+\n+        final Menu displayOptionsMenu = new Menu(\"Display Options\");\n+\n+//        final Menu ruler = new Menu(\"Ruler\");\n+//        final CheckMenuItem showRuler = buildCheckMenuItem(\"Show Ruler\", \"Show ruler in the scene for alignment purposes\", \"\", null, null);\n+//        showRuler.selectedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\n+//            configuration.setShowRuler(newValue.booleanValue());\n+//            configurationUpdated();\n+//        });\n+//\n+//        final RulerConfigurationMenuItem rulerConfig = new RulerConfigurationMenuItem();\n+//        rulerConfig.colorProperty().addListener(new ChangeListener<Color>() {\n+//\n+//            @Override public void changed(final ObservableValue<? extends Color> arg0, final Color arg1, final Color newValue) {\n+//                final int red = (int) (newValue.getRed() * 255);\n+//                final int green = (int) (newValue.getGreen() * 255);\n+//                final int blue = (int) (newValue.getBlue() * 255);\n+//                configuration.setRulerColor(toHexByte(red) + toHexByte(green) + toHexByte(blue));\n+//                configurationUpdated();\n+//            }\n+//\n+//            private String toHexByte(final int value) {\n+//                return (value < 16) ? \"0\" + Integer.toString(value, 16) : Integer.toString(value, 16);\n+//            }\n+//        });\n+//        rulerConfig.rulerSeparationProperty().addListener((ChangeListener<Number>) (o, oldValue, newValue) -> {\n+//            configuration.setRulerSeparation(newValue.intValue());\n+//            configurationUpdated();\n+//        });\n+//        configuration.setRulerSeparation(rulerConfig.rulerSeparationProperty().get());\n+//        ruler.getItems().addAll(showRuler, rulerConfig);\n+\n+        displayOptionsMenu.getItems().addAll(showBoundsCheckbox, \n+                                             showBaselineCheckbox, \n+//                                             showRuler,\n+                                             showSearchBar, \n+                                             showFilteredNodesInTree, \n+                                             showInvisibleNodes, \n+                                             showNodesIdInTree, \n+                                             collapseControls, \n+                                             collapseContentControls);\n+\n+        final Menu aboutMenu = new Menu(\"Help\");\n+\n+        final MenuItem help = new MenuItem(\"Help Contents\");\n+        help.setOnAction(event -> HelpBox.make(\"Help Contents\", HELP_URL, scenicViewStage));\n+\n+//        final MenuItem newVersion = new MenuItem(\"Check For New Version\");\n+//        newVersion.setOnAction(new EventHandler<ActionEvent>() {\n+//            @Override public void handle(final ActionEvent arg0) {\n+//                checkNewVersion(true);\n+//            }\n+//        });\n+\n+        final MenuItem about = new MenuItem(\"About\");\n+        about.setOnAction(event -> AboutBox.make(\"About\", scenicViewStage));\n+\n+        aboutMenu.getItems().addAll(help/*, newVersion*/, about);\n+\n+        menuBar.getMenus().addAll(fileMenu, displayOptionsMenu, scenegraphMenu, aboutMenu);\n+\n+        CheckBox btnSearchRemoteJVM = new CheckBox(\"Search remote FX JVM\");\n+        btnSearchRemoteJVM.selectedProperty().addListener((observable, oldValue, newValue) -> {\n+            if (updateStrategy instanceof WorkerThread) {\n+                WorkerThread wt = (WorkerThread) updateStrategy;\n+                wt.setEnabled(newValue);\n+                progressScanning.setVisible(newValue);\n+                labelScanning.setText(newValue ? \"Scanning for JavaFX applications\" : \"Scanner is paused\");\n+            }\n+        });\n+        if (updateStrategy instanceof WorkerThread) {\n+            WorkerThread wt = (WorkerThread) updateStrategy;\n+            btnSearchRemoteJVM.setSelected(wt.isEnabled());\n+            btnSearchRemoteJVM.setVisible(true);\n+        } else {\n+            btnSearchRemoteJVM.setVisible(false);\n+        }\n+        AnchorPane pane = new AnchorPane( menuBar, btnSearchRemoteJVM);\n+        AnchorPane.setTopAnchor(menuBar, 0.0);\n+        AnchorPane.setRightAnchor(menuBar, 0.0);\n+        AnchorPane.setBottomAnchor(menuBar, 0.0);\n+        AnchorPane.setLeftAnchor(menuBar, 0.0);\n+        AnchorPane.setTopAnchor(btnSearchRemoteJVM,0.0);\n+        AnchorPane.setRightAnchor(btnSearchRemoteJVM,10.0);\n+        AnchorPane.setBottomAnchor(btnSearchRemoteJVM,0.0);\n+        rootBorderPane.setTop(pane);\n+    }\n+    \n+    private void updateMenuBar(final Tab oldValue, final Tab newValue) {\n+        if (oldValue != null && oldValue instanceof ContextMenuContainer) {\n+            Menu menu = ((ContextMenuContainer) oldValue).getMenu();\n+            menuBar.getMenus().remove(menu);\n+        }\n+        if (newValue != null && newValue instanceof ContextMenuContainer) {\n+            Menu newMenu = ((ContextMenuContainer) newValue).getMenu();\n+            if (newMenu != null) {\n+                menuBar.getMenus().add(menuBar.getMenus().size() - 1, newMenu);\n+            }\n+        }\n+    }\n+\n+    protected void selectOnClick(final boolean newValue) {\n+        if (configuration.isComponentSelectOnClick() != newValue) {\n+            configuration.setComponentSelectOnClick(newValue);\n+            configurationUpdated();\n+        }\n+    }\n+\n+//    private void checkNewVersion(final boolean forced) {\n+//        final SimpleDateFormat format = new SimpleDateFormat(\"ddMMyyyy\");\n+//        final String value = Persistence.loadProperty(\"lastVersionCheck\", null);\n+//        try {\n+//            if (forced || value == null || ((System.currentTimeMillis() - format.parse(value).getTime()) > 86400000)) {\n+//                Platform.runLater(new Runnable() {\n+//                    @Override public void run() {\n+//                        final String newVersion = VersionChecker.checkVersion(VERSION);\n+//                        String versionNum = null;\n+//                        if (newVersion != null) {\n+//                            // For now the version is on the first line\n+//                            versionNum = newVersion;\n+//                            if (newVersion.indexOf('\\n') != -1) {\n+//                                versionNum = newVersion.substring(0, newVersion.indexOf('\\n'));\n+//                            }\n+//                            // Now check whether our version is newer\n+//                            if (versionNum.compareTo(ScenicView.VERSION) < 0) {\n+//                                versionNum = null;\n+//                            }\n+//                        }\n+//\n+//                        if (versionNum != null) {\n+//                            new InfoBox(\"Version check\", \"New version found:\" + versionNum + \" (Yours is:\" + ScenicView.VERSION + \")\", newVersion, 400, 200);\n+//                        } else if (forced) {\n+//                            new InfoBox(\"Version check\", \"You already have the latest version of Scenic View.\", null, 400, 150);\n+//                        }\n+//\n+//                        Persistence.saveProperty(\"lastVersionCheck\", format.format(new Date()));\n+//                    }\n+//                });\n+//\n+//            }\n+//        } catch (final Exception e) {\n+//            ExceptionLogger.submitException(e);\n+//        }\n+//    }\n+    \n+    public void removeApp(final AppController appController) {\n+        treeView.removeApp(appController);\n+    }\n+    \n+    public void removeStage(final StageController stageController) {\n+        treeView.removeStage(stageController);\n+    }\n+    \n+    public void setActiveStage(final StageController activeStage) {\n+        this.activeStage = activeStage;\n+        cssfxTab.setActiveStage(activeStage.getID());\n+    }\n+    \n+    public FXConnectorEventDispatcher getStageModelListener() {\n+        return stageModelListener;\n+    }\n+\n+    public void configurationUpdated() {\n+        for (int i = 0; i < appRepository.getApps().size(); i++) {\n+            final List<StageController> stages = appRepository.getApps().get(i).getStages();\n+            for (int j = 0; j < stages.size(); j++) {\n+                if (stages.get(j).isOpened()) {\n+                    stages.get(j).configurationUpdated(configuration);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void animationsEnabled(final boolean enabled) {\n+        for (int i = 0; i < appRepository.getApps().size(); i++) {\n+            final List<StageController> stages = appRepository.getApps().get(i).getStages();\n+            for (int j = 0; j < stages.size(); j++) {\n+                if (stages.get(j).isOpened()) {\n+                    stages.get(j).animationsEnabled(enabled);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void updateAnimations() {\n+        animationsTab.clear();\n+        for (int i = 0; i < appRepository.getApps().size(); i++) {\n+            /**\n+             * Only first stage\n+             */\n+            final List<StageController> stages = appRepository.getApps().get(i).getStages();\n+            for (int j = 0; j < stages.size(); j++) {\n+                if (stages.get(j).isOpened()) {\n+                    stages.get(j).updateAnimations();\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void pauseAnimation(final StageID id, final int animationID) {\n+        for (int i = 0; i < appRepository.getApps().size(); i++) {\n+            final List<StageController> stages = appRepository.getApps().get(i).getStages();\n+            for (int j = 0; j < stages.size(); j++) {\n+                if (stages.get(j).getID().equals(id)) {\n+                    stages.get(j).pauseAnimation(animationID);\n+                }\n+            }\n+        }\n+        updateAnimations();\n+    }\n+\n+    private void loadAPI(final String property) {\n+        if (tabPane.getTabs().contains(javadocTab)) {\n+            if (property != null) {\n+                goToTab(JavaDocTab.TAB_NAME);\n+            }\n+            if (javadocTab.isSelected()) {\n+                javadocTab.loadAPI(property);\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) \n+    public String findProperty(final String className, final String property) {\n+        Class node = null;\n+        try {\n+            node = Class.forName(className);\n+            node.getDeclaredMethod(property + \"Property\");\n+\n+            return className;\n+        } catch (final Exception e) {\n+            return findProperty(node.getSuperclass().getName(), property);\n+        }\n+    }\n+\n+    public void update() {\n+        for (int i = 0; i < appRepository.getApps().size(); i++) {\n+            final List<StageController> stages = appRepository.getApps().get(i).getStages();\n+            for (int j = 0; j < stages.size(); j++) {\n+                if (stages.get(j).isOpened()) {\n+                    stages.get(j).update();\n+                }\n+            }\n+        }\n+    }\n+\n+    StageController getStageController(final StageID id) {\n+        for (int i = 0; i < appRepository.getApps().size(); i++) {\n+            final List<StageController> stages = appRepository.getApps().get(i).getStages();\n+            for (int j = 0; j < stages.size(); j++) {\n+                if (stages.get(j).getID().equals(id)) {\n+                    return stages.get(j);\n+                }\n+            }\n+        }\n+        return appRepository.getApps().get(0).getStages().get(0);\n+        // return null;\n+    }\n+\n+    protected void filterProperties(final String text) {\n+        detailsTab.filterProperties(text);\n+    }\n+\n+    public void setSelectedNode(final StageController controller, final SVNode value) {\n+        if (value != selectedNode) {\n+            if (controller != null && activeStage != controller) {\n+                /**\n+                 * Remove selected from previous active\n+                 */\n+                activeStage.setSelectedNode(null);\n+                activeStage = controller;\n+            }\n+            storeSelectedNode(value);\n+            eventsTab.setSelectedNode(value);\n+            loadAPI(null);\n+            propertyFilterField.setText(\"\");\n+            propertyFilterField.setDisable(value == null);\n+            filterProperties(propertyFilterField.getText());\n+            threeDOMTab.setSelectedNode(value); // 3D addition\n+            cssfxTab.setActiveStage((controller==null)?null:controller.getID());\n+        }\n+    }\n+\n+    public SVNode getSelectedNode() {\n+        return selectedNode;\n+    }\n+    \n+    public void removeNode() {\n+        activeStage.removeSelectedNode();\n+    }\n+\n+    private void storeSelectedNode(final SVNode value) {\n+        selectedNode = value;\n+        if (selectedNode != null && detailsTab.isSelected())\n+            setStatusText(\"Click on the labels to modify its values. The panel could have different capabilities. When changed the values will be highlighted\",\n+                    8000);\n+        activeStage.setSelectedNode(value);\n+    }\n+\n+    public CheckMenuItem buildCheckMenuItem(final String text, final String toolTipSelected, final String toolTipNotSelected, final String property,\n+            final Boolean value) {\n+        final CheckMenuItem menuItem = new CheckMenuItem(text);\n+        if (property != null) {\n+            Persistence.loadProperty(property, menuItem, value);\n+        } else if (value != null) {\n+            menuItem.setSelected(value);\n+        }\n+        menuItem.selectedProperty().addListener(new ChangeListener<Boolean>() {\n+            @Override public void changed(final ObservableValue<? extends Boolean> arg0, final Boolean arg1, final Boolean newValue) {\n+                setStatusText(newValue ? toolTipSelected : toolTipNotSelected, 4000);\n+            }\n+        });\n+\n+        return menuItem;\n+    }\n+\n+    private FilterTextField createFilterField(final String prompt) {\n+        return createFilterField(prompt, event -> update());\n+    }\n+\n+    private FilterTextField createFilterField(final String prompt, final EventHandler<KeyEvent> keyHandler) {\n+        final FilterTextField filterField = new FilterTextField();\n+        filterField.setPromptText(prompt);\n+        if (keyHandler != null) {\n+            filterField.setOnKeyReleased(keyHandler);\n+        }\n+        filterField.focusedProperty().addListener((ChangeListener<Boolean>) (o, oldValue, newValue) -> {\n+            if (newValue) {\n+                setStatusText(\"Type any text for filtering\");\n+            } else {\n+                clearStatusText();\n+            }\n+        });\n+        return filterField;\n+    }\n+\n+    private void closeApps() {\n+        for (final Iterator<AppController> iterator = appRepository.getApps().iterator(); iterator.hasNext();) {\n+            final AppController stage = iterator.next();\n+            stage.close();\n+        }\n+    }\n+\n+    public void close() {\n+        closeApps();\n+        saveProperties();\n+        updateStrategy.finish();\n+    }\n+\n+    private void saveProperties() {\n+        Persistence.saveProperties();\n+    }\n+\n+    public void setStatusText(final String text) {\n+        statusBar.setStatusText(text);\n+    }\n+\n+    public void setStatusText(final String text, final long timeout) {\n+        statusBar.setStatusText(text, timeout);\n+    }\n+\n+    public void clearStatusText() {\n+        statusBar.clearStatusText();\n+    }\n+\n+    public boolean hasStatusText() {\n+        return statusBar.hasStatus();\n+    }\n+\n+//    @Override protected double computePrefWidth(final double height) {\n+//        return 600;\n+//    }\n+//\n+//    @Override protected double computePrefHeight(final double width) {\n+//        return 600;\n+//    }\n+//\n+//    @Override protected void layoutChildren() {\n+//        layoutInArea(borderPane, getPadding().getLeft(), getPadding().getTop(), getWidth() - getPadding().getLeft() - getPadding().getRight(), getHeight()\n+//                - getPadding().getTop() - getPadding().getBottom(), 0, HPos.LEFT, VPos.TOP);\n+//    }\n+\n+    public final BorderPane getBorderPane() {\n+        return rootBorderPane;\n+    }\n+\n+//    /**\n+//     * For autoTesting purposes\n+//     */\n+//    @Override public ObservableList<Node> getChildren() {\n+//        return super.getChildren();\n+//    }\n+\n+    public static void show(final ScenicViewGui scenicview, final Stage stage) {\n+        final Scene scene = new Scene(scenicview.rootBorderPane);\n+        scene.getStylesheets().addAll(STYLESHEETS);\n+        stage.setScene(scene);\n+        stage.getIcons().add(APP_ICON);\n+        if (scenicview.activeStage != null && scenicview.activeStage instanceof StageControllerImpl)\n+            ((StageControllerImpl) scenicview.activeStage).placeStage(stage);\n+\n+        stage.addEventHandler(WindowEvent.WINDOW_CLOSE_REQUEST, event -> {\n+            Runtime.getRuntime().removeShutdownHook(scenicview.shutdownHook);\n+            scenicview.close();\n+        });\n+        stage.show();\n+    }\n+\n+    public void openStage(final StageController controller) {\n+        controller.setEventDispatcher(stageModelListener);\n+        controller.configurationUpdated(configuration);\n+    }\n+\n+    public void forceUpdate() {\n+        update();\n+    }\n+    \n+    public void goToTab(String tabName) {\n+        Tab switchToTab = null;\n+        for (Tab tab : tabPane.getTabs()) {\n+            if (tabName == tab.getText()) {\n+                switchToTab = tab;\n+                break;\n+            }\n+        }\n+        \n+        if (switchToTab != null) {\n+            tabPane.getSelectionModel().select(switchToTab);\n+        }\n+    }\n+    \n+    private void doDispatchEvent(final FXConnectorEvent appEvent) {\n+        switch (appEvent.getType()) {\n+            case EVENT_LOG: {\n+                eventsTab.trace((EvLogEvent) appEvent);\n+                break;\n+            }                \n+            case MOUSE_POSITION: {\n+                if (isActive(appEvent.getStageID()))\n+                    statusBar.updateMousePosition(((MousePosEvent) appEvent).getPosition());\n+                break;\n+            }\n+            case SHORTCUT: {\n+                final KeyCode c = ((ShortcutEvent) appEvent).getCode();\n+                switch (c) {\n+                    case S:\n+                        componentSelectOnClick.setSelected(!configuration.isComponentSelectOnClick());\n+                        break;\n+                    case R:\n+                        configuration.setShowRuler(!configuration.isShowRuler());\n+                        configurationUpdated();\n+                        break;\n+                    case D:\n+                        treeView.getSelectionModel().clearSelection();\n+                        break;\n+                    default:\n+                        break;\n+                }\n+                break;\n+            }\n+            case WINDOW_DETAILS: {\n+                final WindowDetailsEvent wevent = (WindowDetailsEvent) appEvent;\n+                autoRefreshStyleSheets.setDisable(!wevent.isStylesRefreshable());\n+\n+                if (isActive(wevent.getStageID())) {\n+                    statusBar.updateWindowDetails(wevent.getWindowType(), wevent.getBounds(), wevent.isFocused());\n+                }\n+                break;\n+            }\n+            case NODE_SELECTED: {\n+                componentSelectOnClick.setSelected(false);\n+                treeView.nodeSelected(((NodeSelectedEvent) appEvent).getNode());\n+                cssfxTab.setActiveStage(appEvent.getStageID());\n+\n+                scenicViewStage.toFront();\n+                break;\n+            }\n+            case NODE_COUNT: {\n+                statusBar.updateNodeCount(((NodeCountEvent) appEvent).getNodeCount());\n+                break;\n+            }\n+            case SCENE_DETAILS: {\n+                if (isActive(appEvent.getStageID())) {\n+                    final SceneDetailsEvent sEvent = (SceneDetailsEvent) appEvent;\n+                    statusBar.updateSceneDetails(sEvent.getSize(), sEvent.getNodeCount());\n+                }\n+                break;\n+            }\n+            case ROOT_UPDATED: {\n+                treeView.updateStageModel(getStageController(appEvent.getStageID()), \n+                                         ((NodeAddRemoveEvent) appEvent).getNode(), \n+                                         showNodesIdInTree.isSelected(),\n+                                         showFilteredNodesInTree.isSelected());\n+                threeDOMTab.placeNewRoot(((NodeAddRemoveEvent) appEvent).getNode());\n+                cssfxTab.registerStage(appEvent.getStageID());\n+                break;\n+            }\n+            case NODE_ADDED: {\n+                /**\n+                 * First check if a we have a NODE_REMOVED in the queue\n+                 */\n+                final int removedPos = indexOfNode(((NodeAddRemoveEvent) appEvent).getNode(), true);\n+                if (removedPos == -1) {\n+                    treeView.addNewNode(((NodeAddRemoveEvent) appEvent).getNode(), showNodesIdInTree.isSelected(), showFilteredNodesInTree.isSelected());\n+                    threeDOMTab.reload();   // 3D addition\n+                } else {\n+                    eventQueue.remove(removedPos);\n+                }\n+               \n+                break;\n+            }\n+            case NODE_REMOVED: {\n+                final int addedPos = indexOfNode(((NodeAddRemoveEvent) appEvent).getNode(), false);\n+                if (addedPos == -1) {\n+                    treeView.removeNode(((NodeAddRemoveEvent) appEvent).getNode());\n+                    threeDOMTab.removeNode(((NodeAddRemoveEvent) appEvent).getNode());   // 3D addition\n+                } else {\n+                    eventQueue.remove(addedPos);\n+                }\n+                break;\n+            }\n+            case DETAILS: {\n+                final DetailsEvent ev = (DetailsEvent) appEvent;\n+                detailsTab.updateDetails(ev.getPaneType(), ev.getPaneName(), ev.getDetails(), (detail, value) -> {\n+                    getStageController(appEvent.getStageID()).setDetail(detail.getDetailType(), detail.getDetailID(), value);   \n+                });\n+                break;\n+            }\n+            case DETAIL_UPDATED: {\n+                final DetailsEvent ev2 = (DetailsEvent) appEvent;\n+                detailsTab.updateDetail(ev2.getPaneType(), ev2.getPaneName(), ev2.getDetails().get(0));\n+                break;\n+            }\n+            case ANIMATIONS_UPDATED: {\n+                animationsTab.update(appEvent.getStageID(), ((AnimationsCountEvent) appEvent).getAnimations());\n+                break;\n+            }\n+            case CSS_ADDED: \n+            case CSS_REMOVED: \n+            case CSS_REPLACED: \n+                cssfxTab.handleEvent(appEvent);\n+                break;\n+            default: {\n+                Logger.print(\"Unused event for type \" + appEvent);\n+                break;\n+            }\n+        }\n+    }\n+\n+    private int indexOfNode(final SVNode node, final boolean add) {\n+        for (int i = 0; i < eventQueue.size(); i++) {\n+            final FXConnectorEvent ev = eventQueue.get(i);\n+            if ((add && ev.getType() == SVEventType.NODE_REMOVED) || (!add && ev.getType() == SVEventType.NODE_ADDED)) {\n+                final NodeAddRemoveEvent ev2 = (NodeAddRemoveEvent) ev;\n+                if (ev2.getNode().equals(node)) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private boolean isActive(final StageID stageID) {\n+        return activeStage.getID().equals(stageID);\n+    }\n+    /**\n+     * 3D additions\n+     * @return scene graph treeview\n+     */\n+    public ScenegraphTreeView getTreeView(){\n+         return treeView;\n+     }\n+}"
  },
  {
    "sha": "472a70bfad65f2cb8f378049a627ac7ce06a88b9",
    "filename": "src/main/resources/org/scenicview/view/scenicview.css",
    "status": "modified",
    "additions": 9,
    "deletions": 2,
    "changes": 11,
    "blob_url": "https://github.com/JonathanGiles/scenic-view/blob/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/resources/org/scenicview/view/scenicview.css",
    "raw_url": "https://github.com/JonathanGiles/scenic-view/raw/ef3da38c12143ef69fb4317a683a33769588a7a1/src/main/resources/org/scenicview/view/scenicview.css",
    "contents_url": "https://api.github.com/repos/JonathanGiles/scenic-view/contents/src/main/resources/org/scenicview/view/scenicview.css?ref=ef3da38c12143ef69fb4317a683a33769588a7a1",
    "patch": "@@ -123,10 +123,17 @@\n      -fx-alignment: BASELINE_RIGHT;\r\n  }\r\n \r\n+.text {\r\n+    -fx-fill: #000000;\r\n+}\r\n \r\n+.textIdentityCode {\r\n+    -fx-fill: #AA4400;\r\n+}\r\n \r\n-\r\n-\r\n+.tree-view .tree-cell:filled:selected {\r\n+    -fx-background-color: #9AD5FF;\r\n+}\r\n \r\n .tab-pane > .tab-header-area > .tab-header-background {\r\n     -fx-effect: null;\r"
  }
]
