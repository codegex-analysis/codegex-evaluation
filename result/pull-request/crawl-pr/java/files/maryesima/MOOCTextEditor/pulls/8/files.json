[
  {
    "sha": "5bd7439d066eb547c7d03856cfc65d8791240a88",
    "filename": "src/spelling/AutoCompleteDictionaryTrie.java",
    "status": "modified",
    "additions": 55,
    "deletions": 15,
    "changes": 70,
    "blob_url": "https://github.com/maryesima/MOOCTextEditor/blob/39bca7dd88526cb8c4564f0b0667c185c60a73d5/src/spelling/AutoCompleteDictionaryTrie.java",
    "raw_url": "https://github.com/maryesima/MOOCTextEditor/raw/39bca7dd88526cb8c4564f0b0667c185c60a73d5/src/spelling/AutoCompleteDictionaryTrie.java",
    "contents_url": "https://api.github.com/repos/maryesima/MOOCTextEditor/contents/src/spelling/AutoCompleteDictionaryTrie.java?ref=39bca7dd88526cb8c4564f0b0667c185c60a73d5",
    "patch": "@@ -1,10 +1,7 @@\n package spelling;\r\n \r\n-import java.util.List;\r\n-import java.util.Set;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.LinkedList;\r\n+\r\n+import java.util.*;\r\n \r\n /** \r\n  * An trie data structure that implements the Dictionary and the AutoComplete ADT\r\n@@ -39,8 +36,23 @@ public AutoCompleteDictionaryTrie()\n \t */\r\n \tpublic boolean addWord(String word)\r\n \t{\r\n-\t    //TODO: Implement this method.\r\n-\t    return false;\r\n+\t\tTrieNode currentWord = root;\r\n+\t\tchar[] wordToLetters = word.toLowerCase().toCharArray();\r\n+\t\tfor (int i = 0; i < word.length(); i++) {\r\n+\t\t  TrieNode nextWord = currentWord.insert(wordToLetters[i]);\r\n+\t\t  if (nextWord != null) {\r\n+\t\t  \tcurrentWord = nextWord;\r\n+\t\t  }\r\n+\t\t  else {\r\n+\t\t  \tcurrentWord = currentWord.getChild(wordToLetters[i]);\r\n+\t\t  }\r\n+\t\t}\r\n+\t\tif (!currentWord.endsWord()) {\r\n+\t\t\tsize++;\r\n+\t\t\tcurrentWord.setEndsWord(true);\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\treturn false;\r\n \t}\r\n \t\r\n \t/** \r\n@@ -49,18 +61,26 @@ public boolean addWord(String word)\n \t */\r\n \tpublic int size()\r\n \t{\r\n-\t    //TODO: Implement this method\r\n-\t    return 0;\r\n+\t    return size;\r\n \t}\r\n \t\r\n \t\r\n \t/** Returns whether the string is a word in the trie, using the algorithm\r\n \t * described in the videos for this week. */\r\n \t@Override\r\n-\tpublic boolean isWord(String s) \r\n-\t{\r\n-\t    // TODO: Implement this method\r\n-\t\treturn false;\r\n+\tpublic boolean isWord(String s) {\r\n+\t\tif (s == null) {\r\n+\t\t\treturn false;\r\n+\t\t}\r\n+\t\tTrieNode currentWord = root;\r\n+\t\tchar[] wordToLetters = s.toLowerCase().toCharArray();\r\n+\t\tfor (int i = 0; i < s.length(); i++) {\r\n+\t\t\tcurrentWord = currentWord.getChild(wordToLetters[i]);\r\n+\t\t\tif (currentWord == null) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn currentWord.endsWord();\r\n \t}\r\n \r\n \t/** \r\n@@ -100,8 +120,28 @@ public boolean isWord(String s)\n     \t //       If it is a word, add it to the completions list\r\n     \t //       Add all of its child nodes to the back of the queue\r\n     \t // Return the list of completions\r\n-    \t \r\n-         return null;\r\n+         List<String> completions = new LinkedList();\r\n+         //looking for completions\r\n+\t\t char[] pre = prefix.toLowerCase().toCharArray();\r\n+\t\t TrieNode node = root;\r\n+         for (int i = 0; i < pre.length; i++) {\r\n+\t\t\t node = node.getChild(pre[i]);\r\n+\t\t\t if (node == null) {\r\n+\t\t\t \treturn completions;\r\n+\t\t\t }\r\n+\t\t }\r\n+\t\t LinkedList queue = new LinkedList();\r\n+         queue.add(node);\r\n+         while (!queue.isEmpty() && numCompletions > completions.size()) {\r\n+         \tTrieNode checkWord  = (TrieNode) queue.removeFirst();\r\n+         \tif (checkWord.endsWord()) {\r\n+         \t\tcompletions.add(checkWord.getText());\r\n+\t\t\t}\r\n+         \tfor (Character c : checkWord.getValidNextCharacters()) {\r\n+         \t\tqueue.add(checkWord.getChild(c));\r\n+\t\t\t}\r\n+\t\t }\r\n+         return completions;\r\n      }\r\n \r\n  \t// For debugging\r"
  },
  {
    "sha": "459402ad566c7f947d759ccb98d6898f48986bdc",
    "filename": "src/spelling/DictionaryBST.java",
    "status": "modified",
    "additions": 16,
    "deletions": 12,
    "changes": 28,
    "blob_url": "https://github.com/maryesima/MOOCTextEditor/blob/39bca7dd88526cb8c4564f0b0667c185c60a73d5/src/spelling/DictionaryBST.java",
    "raw_url": "https://github.com/maryesima/MOOCTextEditor/raw/39bca7dd88526cb8c4564f0b0667c185c60a73d5/src/spelling/DictionaryBST.java",
    "contents_url": "https://api.github.com/repos/maryesima/MOOCTextEditor/contents/src/spelling/DictionaryBST.java?ref=39bca7dd88526cb8c4564f0b0667c185c60a73d5",
    "patch": "@@ -1,5 +1,6 @@\n package spelling;\n \n+import java.util.LinkedList;\n import java.util.TreeSet;\n \n /**\n@@ -9,33 +10,36 @@\n public class DictionaryBST implements Dictionary \n {\n    private TreeSet<String> dict;\n-\t\n-    // TODO: Implement the dictionary interface using a TreeSet.  \n- \t// You'll need a constructor here\n-\t\n-    \n+\n+    public DictionaryBST() {\n+        dict = new TreeSet<>();\n+    }\n+\n     /** Add this word to the dictionary.  Convert it to lowercase first\n      * for the assignment requirements.\n      * @param word The word to add\n      * @return true if the word was added to the dictionary \n      * (it wasn't already there). */\n     public boolean addWord(String word) {\n-    \t// TODO: Implement this method\n-        return false;\n+        if (dict.contains(word.toLowerCase())) {\n+            return false;\n+        } else {\n+            dict.add(word.toLowerCase());\n+            return true;\n+        }\n     }\n \n-\n     /** Return the number of words in the dictionary */\n     public int size()\n     {\n-    \t// TODO: Implement this method\n-        return 0;\n+        return dict.size();\n     }\n \n     /** Is this a word according to this dictionary? */\n     public boolean isWord(String s) {\n-    \t//TODO: Implement this method\n+        if (dict.contains(s.toLowerCase())) {\n+            return true;\n+        }\n         return false;\n     }\n-\n }"
  },
  {
    "sha": "036fc6faf17bf94b8ba9ec37974afc7207fff88c",
    "filename": "src/spelling/DictionaryLL.java",
    "status": "modified",
    "additions": 13,
    "deletions": 10,
    "changes": 23,
    "blob_url": "https://github.com/maryesima/MOOCTextEditor/blob/39bca7dd88526cb8c4564f0b0667c185c60a73d5/src/spelling/DictionaryLL.java",
    "raw_url": "https://github.com/maryesima/MOOCTextEditor/raw/39bca7dd88526cb8c4564f0b0667c185c60a73d5/src/spelling/DictionaryLL.java",
    "contents_url": "https://api.github.com/repos/maryesima/MOOCTextEditor/contents/src/spelling/DictionaryLL.java?ref=39bca7dd88526cb8c4564f0b0667c185c60a73d5",
    "patch": "@@ -8,35 +8,38 @@\n  */\r\n public class DictionaryLL implements Dictionary \r\n {\r\n-\r\n \tprivate LinkedList<String> dict;\r\n-\t\r\n-    // TODO: Add a constructor\r\n \r\n+    public DictionaryLL() {\r\n+        dict = new LinkedList<String>();\r\n+    }\r\n \r\n     /** Add this word to the dictionary.  Convert it to lowercase first\r\n      * for the assignment requirements.\r\n      * @param word The word to add\r\n      * @return true if the word was added to the dictionary \r\n      * (it wasn't already there). */\r\n     public boolean addWord(String word) {\r\n-    \t// TODO: Implement this method\r\n-        return false;\r\n+        if (dict.contains(word.toLowerCase())) {\r\n+            return false;\r\n+      } else {\r\n+          dict.add(word.toLowerCase());\r\n+          return true;\r\n+        }\r\n     }\r\n \r\n \r\n     /** Return the number of words in the dictionary */\r\n     public int size()\r\n     {\r\n-        // TODO: Implement this method\r\n-        return 0;\r\n+        return dict.size();\r\n     }\r\n \r\n     /** Is this a word according to this dictionary? */\r\n     public boolean isWord(String s) {\r\n-        //TODO: Implement this method\r\n+        if (dict.contains(s.toLowerCase())) {\r\n+            return true;\r\n+        }\r\n         return false;\r\n     }\r\n-\r\n-    \r\n }\r"
  }
]
