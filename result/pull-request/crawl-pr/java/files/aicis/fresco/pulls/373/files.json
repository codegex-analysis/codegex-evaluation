[
  {
    "sha": "bf05d436868760fd7fcf52cae747e76dfadbbb71",
    "filename": "core/pom.xml",
    "status": "modified",
    "additions": 0,
    "deletions": 10,
    "changes": 10,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/core/pom.xml",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/core/pom.xml",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/core/pom.xml?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -14,16 +14,6 @@\n     <version>1.3.1-SNAPSHOT</version>\n   </parent>\n \n-  <dependencies>\n-    <dependency>\n-      <groupId>org.mockito</groupId>\n-      <artifactId>mockito-core</artifactId>\n-      <version>3.3.3</version>\n-      <scope>test</scope>\n-    </dependency>\n-\n-  </dependencies>\n-\n   <!-- ================ FRESCO BUILD ========================== -->\n \n   <build>"
  },
  {
    "sha": "494557a3684744ede17602847e3a23d0e7dc19fa",
    "filename": "core/src/main/java/dk/alexandra/fresco/framework/builder/numeric/field/BigIntegerFieldElement.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/core/src/main/java/dk/alexandra/fresco/framework/builder/numeric/field/BigIntegerFieldElement.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/core/src/main/java/dk/alexandra/fresco/framework/builder/numeric/field/BigIntegerFieldElement.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/core/src/main/java/dk/alexandra/fresco/framework/builder/numeric/field/BigIntegerFieldElement.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -64,6 +64,11 @@ public FieldElement modInverse() {\n     return create(value.modInverse(getModulus()));\n   }\n \n+  @Override\n+  public boolean isZero() {\n+    return BigInteger.ZERO.equals(value);\n+  }\n+\n   static BigInteger extractValue(FieldElement element) {\n     return ((BigIntegerFieldElement) element).value;\n   }"
  },
  {
    "sha": "dc30f2d2b2dca6a080b06a28e95e5277fb6dd2a0",
    "filename": "core/src/main/java/dk/alexandra/fresco/framework/builder/numeric/field/FieldElement.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/core/src/main/java/dk/alexandra/fresco/framework/builder/numeric/field/FieldElement.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/core/src/main/java/dk/alexandra/fresco/framework/builder/numeric/field/FieldElement.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/core/src/main/java/dk/alexandra/fresco/framework/builder/numeric/field/FieldElement.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -45,4 +45,11 @@\n    * @return <code>this<sup>-1</sup> mod modulus</code>\n    */\n   FieldElement modInverse();\n+\n+  /**\n+   * Checks whether the element is zero\n+   * @return true if element is zero, false otherwise\n+   */\n+\n+  boolean isZero();\n }"
  },
  {
    "sha": "2a62dcd31d539ff2f622f694ff56170a85d9e2ec",
    "filename": "core/src/main/java/dk/alexandra/fresco/framework/builder/numeric/field/MersennePrimeFieldElement.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/core/src/main/java/dk/alexandra/fresco/framework/builder/numeric/field/MersennePrimeFieldElement.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/core/src/main/java/dk/alexandra/fresco/framework/builder/numeric/field/MersennePrimeFieldElement.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/core/src/main/java/dk/alexandra/fresco/framework/builder/numeric/field/MersennePrimeFieldElement.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -64,6 +64,11 @@ public FieldElement modInverse() {\n     return create(modulus.inverse(value));\n   }\n \n+  @Override\n+  public boolean isZero() {\n+    return BigInteger.ZERO.equals(value);\n+  }\n+\n   static BigInteger extractValue(FieldElement element) {\n     return ((MersennePrimeFieldElement) element).value;\n   }"
  },
  {
    "sha": "509feec8879fed8a34885dc1068509ecb75e75e9",
    "filename": "core/src/test/java/dk/alexandra/fresco/framework/builder/numeric/field/BigIntegerFieldElementTest.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/core/src/test/java/dk/alexandra/fresco/framework/builder/numeric/field/BigIntegerFieldElementTest.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/core/src/test/java/dk/alexandra/fresco/framework/builder/numeric/field/BigIntegerFieldElementTest.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/core/src/test/java/dk/alexandra/fresco/framework/builder/numeric/field/BigIntegerFieldElementTest.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -1,6 +1,7 @@\n package dk.alexandra.fresco.framework.builder.numeric.field;\n \n import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n \n import java.math.BigInteger;\n import org.hamcrest.core.Is;\n@@ -129,4 +130,10 @@ public void toStringTest() {\n     FieldElement element = BigIntegerFieldElement.create(BigInteger.valueOf(7854), bigModulus);\n     assertThat(element.toString(), StringContains.containsString(\"7854\"));\n   }\n+\n+  @Test\n+  public void testIsZero() {\n+    FieldElement element = BigIntegerFieldElement.create(BigInteger.valueOf(0), bigModulus);\n+    assertTrue(element.isZero());\n+  }\n }"
  },
  {
    "sha": "3e192d759598d5a7c64603b623f8f7e1afd00bc5",
    "filename": "core/src/test/java/dk/alexandra/fresco/framework/builder/numeric/field/MersennePrimeFieldElementTest.java",
    "status": "modified",
    "additions": 9,
    "deletions": 1,
    "changes": 10,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/core/src/test/java/dk/alexandra/fresco/framework/builder/numeric/field/MersennePrimeFieldElementTest.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/core/src/test/java/dk/alexandra/fresco/framework/builder/numeric/field/MersennePrimeFieldElementTest.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/core/src/test/java/dk/alexandra/fresco/framework/builder/numeric/field/MersennePrimeFieldElementTest.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -1,6 +1,7 @@\n package dk.alexandra.fresco.framework.builder.numeric.field;\n \n import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n \n import java.math.BigInteger;\n import java.util.Arrays;\n@@ -114,4 +115,11 @@ public void toStringTest() {\n     FieldElement element = MersennePrimeFieldElement.create(BigInteger.valueOf(7854), bigModulus);\n     assertThat(element.toString(), StringContains.containsString(\"7854\"));\n   }\n-}\n\\ No newline at end of file\n+\n+  @Test\n+  public void testIsZero() {\n+    FieldElement element = MersennePrimeFieldElement.create(BigInteger.valueOf(0), bigModulus);\n+    assertTrue(element.isZero());\n+\n+  }\n+}"
  },
  {
    "sha": "ede239a4cd83c00592f60df5ddbd495d7a579edf",
    "filename": "pom.xml",
    "status": "modified",
    "additions": 6,
    "deletions": 6,
    "changes": 12,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/pom.xml",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/pom.xml",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/pom.xml?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -57,6 +57,12 @@\n \t\t\t<version>1.2.3</version>\n \t\t\t<scope>test</scope>\n \t\t</dependency>\n+\t\t<dependency>\n+\t\t\t<groupId>org.mockito</groupId>\n+\t\t\t<artifactId>mockito-core</artifactId>\n+\t\t\t<version>3.3.3</version>\n+\t\t\t<scope>test</scope>\n+\t\t</dependency>\n \t\t<dependency>\n \t\t\t<groupId>junit</groupId>\n \t\t\t<artifactId>junit</artifactId>\n@@ -182,12 +188,6 @@\n \t\t\t\t\t\t\t\t<goals>\n \t\t\t\t\t\t\t\t\t<goal>sign</goal>\n \t\t\t\t\t\t\t\t</goals>\n-\t\t\t\t\t\t\t\t<configuration>\n-\t\t\t\t\t\t\t\t\t<gpgArguments>\n-\t\t\t\t\t\t\t\t\t\t<arg>--pinentry-mode</arg>\n-\t\t\t\t\t\t\t\t\t\t<arg>loopback</arg>\n-\t\t\t\t\t\t\t\t\t</gpgArguments>\n-\t\t\t\t\t\t\t\t</configuration>\n \t\t\t\t\t\t\t</execution>\n \t\t\t\t\t\t</executions>\n \t\t\t\t\t</plugin>"
  },
  {
    "sha": "bf3c45aaf28502e6cefeb1427d5d3f1f15b24f0c",
    "filename": "suite/tinytables/src/main/java/dk/alexandra/fresco/suite/tinytables/prepro/TinyTablesPreproProtocolSuite.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/suite/tinytables/src/main/java/dk/alexandra/fresco/suite/tinytables/prepro/TinyTablesPreproProtocolSuite.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/suite/tinytables/src/main/java/dk/alexandra/fresco/suite/tinytables/prepro/TinyTablesPreproProtocolSuite.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/suite/tinytables/src/main/java/dk/alexandra/fresco/suite/tinytables/prepro/TinyTablesPreproProtocolSuite.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -16,7 +16,7 @@\n  * </p>\n  *\n  * <p>\n- * The TinyTables protocol has to phases - a <i>preprocessing</i> and an <i>online</i> phase. In the\n+ * The TinyTables protocol has two phases - a <i>preprocessing</i> and an <i>online</i> phase. In the\n  * preprocessing phase, each of the two players picks his additive share of a mask for each input\n  * wire of a protocol. Furthermore, for each AND protocol each of the two players must also\n  * calculate a so-called <i>TinyTable</i> which is used in the online phase (see {@link"
  },
  {
    "sha": "297dadfab5f919d44134dc8aa803d2b8a47c26d6",
    "filename": "suite/tinytables/src/main/java/dk/alexandra/fresco/suite/tinytables/prepro/protocols/TinyTablesPreproANDProtocol.java",
    "status": "modified",
    "additions": 4,
    "deletions": 7,
    "changes": 11,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/suite/tinytables/src/main/java/dk/alexandra/fresco/suite/tinytables/prepro/protocols/TinyTablesPreproANDProtocol.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/suite/tinytables/src/main/java/dk/alexandra/fresco/suite/tinytables/prepro/protocols/TinyTablesPreproANDProtocol.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/suite/tinytables/src/main/java/dk/alexandra/fresco/suite/tinytables/prepro/protocols/TinyTablesPreproANDProtocol.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -9,15 +9,13 @@\n import dk.alexandra.fresco.suite.tinytables.prepro.datatypes.TinyTablesPreproSBool;\n \n /**\n- * <p>\n  * This class represents an AND protocol in the preprocessing phase of the TinyTables protocol.\n- * </p>\n  *\n- * <p>\n- * Here, each of the two players picks random shares for the mask of the output wire, <i>r\n+ * <p>Here, each of the two players picks random shares for the mask of the output wire, <i>r\n  * <sub>O</sub></i>. Each player also has to calculate a so called <i>TinyTable</i> for this\n  * protocol, which are 2x2 matrices such that the <i>(c,d)</i>'th entries from the two tables is an\n  * additive secret sharing of <i>(r<sub>u</sub> + c)(r<sub>v</sub> + d) + r<sub>o</sub></i>.\n+ *\n  * <p>\n  *\n  * @author Jonas Lindstrøm (jonas.lindstrom@alexandra.dk)\n@@ -48,8 +46,8 @@ public SBool out() {\n   }\n \n   @Override\n-  public EvaluationStatus evaluate(int round, TinyTablesPreproResourcePool resourcePool,\n-      Network network) {\n+  public EvaluationStatus evaluate(\n+      int round, TinyTablesPreproResourcePool resourcePool, Network network) {\n \n     /*\n      * Here we only pick the mask of the output wire. The TinyTable is calculated after all AND\n@@ -82,5 +80,4 @@ public TinyTable calculateTinyTable(int playerId, TinyTablesElement product) {\n     entries[3] = entries[0].add(getInLeft().getValue()).add(getInRight().getValue()).not(playerId);\n     return new TinyTable(entries);\n   }\n-\n }"
  },
  {
    "sha": "58b73f6044c04b2d685816337da0568c15c3afc8",
    "filename": "tools/bitTriples/pom.xml",
    "status": "added",
    "additions": 37,
    "deletions": 0,
    "changes": 37,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/pom.xml",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/pom.xml",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/pom.xml?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,37 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <parent>\n+    <artifactId>tools-master-pom</artifactId>\n+    <groupId>dk.alexandra.fresco</groupId>\n+    <version>1.3.1-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>bitTriples</artifactId>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>dk.alexandra.fresco</groupId>\n+      <artifactId>core</artifactId>\n+      <version>${project.version}</version>\n+      <type>test-jar</type>\n+      <scope>test</scope>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>dk.alexandra.fresco</groupId>\n+      <artifactId>ot</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>dk.alexandra.fresco</groupId>\n+      <artifactId>commitment</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>\n+  </dependencies>\n+\n+\n+</project>"
  },
  {
    "sha": "02abad87fbe1fbe28194478b39a3522c4d91f7cd",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTriple.java",
    "status": "added",
    "additions": 47,
    "deletions": 0,
    "changes": 47,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTriple.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTriple.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTriple.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,47 @@\n+package dk.alexandra.fresco.tools.bitTriples;\n+\n+import dk.alexandra.fresco.framework.network.Network;\n+import dk.alexandra.fresco.framework.util.StrictBitVector;\n+import dk.alexandra.fresco.tools.bitTriples.cointossing.CoinTossingMpc;\n+import dk.alexandra.fresco.tools.bitTriples.elements.MultiplicationTriple;\n+import dk.alexandra.fresco.tools.bitTriples.prg.BytePrg;\n+import dk.alexandra.fresco.tools.bitTriples.prg.BytePrgImpl;\n+import dk.alexandra.fresco.tools.bitTriples.triple.TripleGeneration;\n+import java.util.List;\n+\n+/**\n+ * Implementation of the main MASCOT protocol (<a href=\"https://eprint.iacr.org/2016/505.pdf\">https://eprint.iacr.org/2016/505.pdf</a>)\n+ * which can be used for the SPDZ pre-processing phase. <br> Supports generation of multiplication\n+ * triples, random authenticated elements, and random authenticated bits.\n+ */\n+public class BitTriple {\n+\n+  private final TripleGeneration tripleGeneration;\n+  //private final BitConverter bitConverter;\n+  private final BitTripleResourcePool resourcePool;\n+\n+  /**\n+   * Creates new {@link BitTriple}.\n+   */\n+  public BitTriple(BitTripleResourcePool resourcePool, Network network, StrictBitVector macKeyShareLeft,StrictBitVector macKeyShareRight) {\n+    this.resourcePool = resourcePool;\n+    // agree on joint seed\n+    StrictBitVector jointSeed = new CoinTossingMpc(resourcePool, network)\n+        .generateJointSeed(resourcePool.getPrgSeedBitLength());\n+    BytePrg jointSampler = new BytePrgImpl(jointSeed);\n+    this.tripleGeneration =\n+        new TripleGeneration(\n+            resourcePool, network, resourcePool.getComputationalSecurityBitParameter(), jointSampler, macKeyShareLeft, macKeyShareRight);\n+  }\n+\n+  /**\n+   * Generates a batch of multiplication triples.\n+   *\n+   * @param numTriples number of triples in batch\n+   * @return multiplication triples\n+   */\n+  public List<MultiplicationTriple> getTriples(int numTriples) {\n+    return tripleGeneration.triple(numTriples);\n+  }\n+\n+}"
  },
  {
    "sha": "238520e6146cdddb9c91442a86d05546cfa31064",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTripleResourcePool.java",
    "status": "added",
    "additions": 86,
    "deletions": 0,
    "changes": 86,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTripleResourcePool.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTripleResourcePool.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTripleResourcePool.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,86 @@\n+package dk.alexandra.fresco.tools.bitTriples;\n+\n+import dk.alexandra.fresco.framework.sce.resources.ResourcePool;\n+import dk.alexandra.fresco.tools.commitment.HashBasedCommitment;\n+import dk.alexandra.fresco.tools.commitment.HashBasedCommitmentSerializer;\n+import dk.alexandra.fresco.framework.builder.numeric.NumericResourcePool;\n+import dk.alexandra.fresco.framework.builder.numeric.field.FieldDefinition;\n+import dk.alexandra.fresco.framework.network.Network;\n+import dk.alexandra.fresco.framework.network.serializers.ByteSerializer;\n+import dk.alexandra.fresco.framework.network.serializers.StrictBitVectorSerializer;\n+import dk.alexandra.fresco.framework.util.Drbg;\n+import dk.alexandra.fresco.framework.util.StrictBitVector;\n+import dk.alexandra.fresco.tools.bitTriples.prg.BytePrg;\n+import dk.alexandra.fresco.tools.ot.base.RotBatch;\n+import dk.alexandra.fresco.tools.ot.otextension.CoteFactory;\n+import java.security.MessageDigest;\n+\n+public interface BitTripleResourcePool extends ResourcePool {\n+\n+  /**\n+   * Returns the instance ID which is unique for this particular resource pool object, but only in\n+   * the given execution.\n+   *\n+   * @return the instance ID of this particular object\n+   */\n+  int getInstanceId();\n+\n+  /**\n+   * {@link BitTripleSecurityParameters#getComputationalSecurityBitParameter()}.\n+   */\n+  int getComputationalSecurityBitParameter();\n+\n+  /**\n+   * {@link BitTripleSecurityParameters#getStatisticalSecurityByteParameter()}.\n+   */\n+  int getStatisticalSecurityByteParameter();\n+\n+  /**\n+   * {@link BitTripleSecurityParameters#getPrgSeedBitLength()}.\n+   */\n+  int getPrgSeedBitLength();\n+\n+  /**\n+   * Gets PRG for generating random field elements locally (for this party only).\n+   *\n+   * @return PRG\n+   */\n+  BytePrg getLocalSampler();\n+\n+  /**\n+   * Gets serializer for {@link StrictBitVector}.\n+   *\n+   * @return serializer\n+   */\n+  default ByteSerializer<StrictBitVector> getStrictBitVectorSerializer() {\n+    return new StrictBitVectorSerializer();\n+  }\n+\n+  /**\n+   * Gets serializer for {@link HashBasedCommitment}.\n+   *\n+   * @return serializer\n+   */\n+  default ByteSerializer<HashBasedCommitment> getCommitmentSerializer() {\n+    return new HashBasedCommitmentSerializer();\n+  }\n+\n+  /**\n+   * Gets the message digest for this protocol suite invocation.\n+   *\n+   * @return the message digest\n+   */\n+  MessageDigest getMessageDigest();\n+\n+  CoteFactory createCote(int otherId, Network network, StrictBitVector choices);\n+\n+  /**\n+   * The DRBG is useful for protocols which needs a form of shared randomness where the random bytes\n+   * are not easily guessed by an adversary. This generator will provide exactly that. For explicit\n+   * security guarantees, we refer to implementations of\n+   * {@link dk.alexandra.fresco.framework.util.Drbg}.\n+   *\n+   * @return An instance of a DRBG.\n+   */\n+  Drbg getRandomGenerator();\n+}"
  },
  {
    "sha": "5a2494952ef01a38b5e4c15bca00cc576d4ca685",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTripleResourcePoolImpl.java",
    "status": "added",
    "additions": 120,
    "deletions": 0,
    "changes": 120,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTripleResourcePoolImpl.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTripleResourcePoolImpl.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTripleResourcePoolImpl.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,120 @@\n+package dk.alexandra.fresco.tools.bitTriples;\n+\n+import dk.alexandra.fresco.framework.network.Network;\n+import dk.alexandra.fresco.framework.sce.resources.ResourcePoolImpl;\n+import dk.alexandra.fresco.framework.util.Drbg;\n+import dk.alexandra.fresco.framework.util.ExceptionConverter;\n+import dk.alexandra.fresco.framework.util.StrictBitVector;\n+import dk.alexandra.fresco.tools.bitTriples.prg.BytePrg;\n+import dk.alexandra.fresco.tools.bitTriples.prg.BytePrgImpl;\n+import dk.alexandra.fresco.tools.cointossing.CoinTossing;\n+import dk.alexandra.fresco.tools.ot.base.DhParameters;\n+import dk.alexandra.fresco.tools.ot.base.NaorPinkasOt;\n+import dk.alexandra.fresco.tools.ot.otextension.CoteFactory;\n+import dk.alexandra.fresco.tools.ot.otextension.OtExtensionResourcePool;\n+import dk.alexandra.fresco.tools.ot.otextension.OtExtensionResourcePoolImpl;\n+import dk.alexandra.fresco.tools.ot.otextension.RotList;\n+import java.security.MessageDigest;\n+\n+public class BitTripleResourcePoolImpl extends ResourcePoolImpl implements BitTripleResourcePool {\n+\n+  private final int instanceId;\n+  private final BytePrg localSampler;\n+  private final MessageDigest messageDigest;\n+  private final BitTripleSecurityParameters bitTripleSecurityParameters;\n+  private final Drbg drbg;\n+\n+  /**\n+   * Creates new {@link BitTripleResourcePoolImpl}.\n+   *\n+   * @param myId this party's id\n+   * @param noOfParties number of parties\n+   * @param instanceId the instance ID which is unique for this particular resource pool object, but\n+   *     only in the given execution.\n+   * @param drbg source of randomness - Must be initiated with same seed\n+   * @param bitTripleSecurityParameters mascot security parameters ({@link\n+   *     BitTripleSecurityParameters})\n+   */\n+  public BitTripleResourcePoolImpl(\n+      int myId,\n+      int noOfParties,\n+      int instanceId,\n+      Drbg drbg,\n+      BitTripleSecurityParameters bitTripleSecurityParameters) {\n+    super(myId, noOfParties);\n+    this.drbg = drbg;\n+    this.instanceId = instanceId;\n+    this.bitTripleSecurityParameters = bitTripleSecurityParameters;\n+    this.localSampler = new BytePrgImpl(drbg);\n+    this.messageDigest =\n+        ExceptionConverter.safe(\n+            () -> MessageDigest.getInstance(\"SHA-256\"),\n+            \"Configuration error, SHA-256 is needed for Mascot\");\n+  }\n+\n+  @Override\n+  public int getInstanceId() {\n+    return instanceId;\n+  }\n+\n+  @Override\n+  public int getComputationalSecurityBitParameter() {\n+    return bitTripleSecurityParameters.getComputationalSecurityBitParameter();\n+  }\n+\n+  @Override\n+  public int getStatisticalSecurityByteParameter() {\n+    return bitTripleSecurityParameters.getStatisticalSecurityByteParameter();\n+  }\n+\n+  @Override\n+  public BytePrg getLocalSampler() {\n+    return localSampler;\n+  }\n+\n+  @Override\n+  public CoteFactory createCote(int otherId, Network network, StrictBitVector choices) {\n+    if (getMyId() == otherId) {\n+      throw new IllegalArgumentException(\"Cannot initialize with self\");\n+    }\n+    CoinTossing ct = new CoinTossing(getMyId(), otherId, getRandomGenerator());\n+    ct.initialize(network);\n+    NaorPinkasOt ot =\n+        new NaorPinkasOt(otherId, getRandomGenerator(), network, DhParameters.getStaticDhParams());\n+    RotList currentSeedOts = new RotList(drbg, choices.getSize(), choices);\n+    if (getMyId() < otherId) {\n+      currentSeedOts.send(ot);\n+      currentSeedOts.receive(ot);\n+    } else {\n+      currentSeedOts.receive(ot);\n+      currentSeedOts.send(ot);\n+    }\n+    OtExtensionResourcePool otResources =\n+        new OtExtensionResourcePoolImpl(\n+            getMyId(),\n+            otherId,\n+            choices.getSize(),\n+            getStatisticalSecurityByteParameter(),\n+            getInstanceId(),\n+            getRandomGenerator(),\n+            ct,\n+            currentSeedOts);\n+\n+    return new CoteFactory(otResources, network);\n+  }\n+\n+  @Override\n+  public Drbg getRandomGenerator() {\n+    return drbg;\n+  }\n+\n+  @Override\n+  public MessageDigest getMessageDigest() {\n+    return messageDigest;\n+  }\n+\n+  @Override\n+  public int getPrgSeedBitLength() {\n+    return bitTripleSecurityParameters.getPrgSeedBitLength();\n+  }\n+}"
  },
  {
    "sha": "604ab1ac70793fb1fa16a4074e3eb9c249674894",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTripleSecurityParameters.java",
    "status": "added",
    "additions": 63,
    "deletions": 0,
    "changes": 63,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTripleSecurityParameters.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTripleSecurityParameters.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/BitTripleSecurityParameters.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,63 @@\n+package dk.alexandra.fresco.tools.bitTriples;\n+\n+/**\n+ * The security parameters used throughout the MASCOT protocol MASCOT protocol (<a\n+ * href=\"https://eprint.iacr.org/2016/505.pdf\">https://eprint.iacr.org/2016/505.pdf</a>).\n+ */\n+public class BitTripleSecurityParameters {\n+\n+  private final int computationalSecurityBitParameter;\n+  private final int statisticalSecurityParameterBytes;\n+  private final int prgSeedLength;\n+\n+  /**\n+   * Creates new {@link BitTripleSecurityParameters}.\n+   *\n+   * @param computationalSecurityBitParameter OT security parameter in bits (lambda in Mascot paper)\n+   * @param prgSeedBitLength bit length of seed used to underlying prg\n+   *     (tau in Mascot paper) For each triple we generate, we will generate and\n+   *     numCandidatesPerTriple - 1 triples for a single right factor and sacrifice these to\n+   *     authenticate the triple.\n+   */\n+  public BitTripleSecurityParameters(\n+      int computationalSecurityBitParameter, int statisticalSecurityByteParameter, int prgSeedBitLength) {\n+    this.computationalSecurityBitParameter = computationalSecurityBitParameter;\n+    this.statisticalSecurityParameterBytes = statisticalSecurityByteParameter;\n+    this.prgSeedLength = prgSeedBitLength;\n+  }\n+\n+  /**\n+   * Creates new {@link BitTripleSecurityParameters} with realistic parameters (based on paper\n+   * recommendations).\n+   */\n+  public BitTripleSecurityParameters() {\n+    this(256, 40, 256);\n+  }\n+\n+  /**\n+   * Gets OT security parameter num bits (lambda in Mascot paper).\n+   *\n+   * @return lambda security parameter\n+   */\n+  public int getComputationalSecurityBitParameter() {\n+    return computationalSecurityBitParameter;\n+  }\n+\n+  /**\n+   * Gets OT security parameter num bits (lambda in Mascot paper).\n+   *\n+   * @return lambda security parameter\n+   */\n+  public int getStatisticalSecurityByteParameter() {\n+    return statisticalSecurityParameterBytes;\n+  }\n+\n+  /**\n+   * Gets bit length of seed used to underlying prg.\n+   *\n+   * @return prg seed bit length\n+   */\n+  public int getPrgSeedBitLength() {\n+    return prgSeedLength;\n+  }\n+}"
  },
  {
    "sha": "649d1807aba3d51f0556ab1504cbc3fe372b4d66",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/bracket/Bracket.java",
    "status": "added",
    "additions": 145,
    "deletions": 0,
    "changes": 145,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/bracket/Bracket.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/bracket/Bracket.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/bracket/Bracket.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,145 @@\n+package dk.alexandra.fresco.tools.bitTriples.bracket;\n+\n+import dk.alexandra.fresco.framework.network.Network;\n+import dk.alexandra.fresco.framework.util.StrictBitVector;\n+import dk.alexandra.fresco.tools.bitTriples.BitTripleResourcePool;\n+import dk.alexandra.fresco.tools.bitTriples.cote.CoteInstances;\n+import dk.alexandra.fresco.tools.bitTriples.maccheck.MacCheck;\n+import dk.alexandra.fresco.tools.bitTriples.prg.BytePrg;\n+import dk.alexandra.fresco.tools.bitTriples.utils.VectorOperations;\n+import dk.alexandra.fresco.tools.ot.otextension.CoteFactory;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Actively-secure protocol for authenticating secret shared bits (described in fig. 6).\n+ */\n+public class Bracket {\n+\n+  private final Network network;\n+  private final BitTripleResourcePool resourcePool;\n+  private final CoteInstances COTeInstances;\n+  private final BytePrg jointSampler;\n+  private final StrictBitVector mac;\n+\n+  /**\n+   * Create a new []-protocol.\n+   * @param resourcePool The resource pool\n+   * @param network The network\n+   * @param jointSampler a sampler constructed with a joint seed\n+   */\n+  public Bracket(BitTripleResourcePool resourcePool, Network network, BytePrg jointSampler) {\n+    this(resourcePool, network, resourcePool.getLocalSampler().getNext(resourcePool.getComputationalSecurityBitParameter()), jointSampler);\n+  }\n+\n+  public Bracket(BitTripleResourcePool resourcePool, Network network, StrictBitVector mac, BytePrg jointSampler) {\n+    this.resourcePool = resourcePool;\n+    this.network = network;\n+    this.jointSampler = jointSampler;\n+    this.mac = mac;\n+    COTeInstances = new CoteInstances(resourcePool,network,mac);\n+  }\n+\n+  /**\n+   * Constructs a sharing for a set of random elements.\n+   * @param amountOfElements the amount of elements\n+   * @return a list of sharings\n+   */\n+\n+  public List<StrictBitVector> input(int amountOfElements) {\n+    // Sample random input\n+    StrictBitVector randomInput = resourcePool.getLocalSampler().getNext(amountOfElements);\n+    return input(randomInput);\n+  }\n+\n+  /**\n+   * Constructs a sharing for the given elements.\n+   * @param input input elements\n+   * @return a list of sharings\n+   */\n+\n+  public List<StrictBitVector> input(StrictBitVector input) {\n+    // Step 1. n-share to obtain shares\n+    List<StrictBitVector> shares = nShare(input);\n+    // Step 2. broadcast own input\n+    StrictBitVector openInput = VectorOperations.openVector(input,resourcePool,network);\n+    // Step 3. Check macs\n+    MacCheck macCheckShares = new MacCheck(resourcePool, network, jointSampler);\n+\n+    macCheckShares.check(openInput, shares, mac);\n+\n+    return shares;\n+  }\n+\n+  /**\n+   * Runs n-Share described in Figure 6 and 7. where every party randomly pick a number of shares as\n+   * input.\n+   *\n+   * @param myInput the choice bits as an input vector x^(i)_1,...,x^(i)_k\n+   * @return\n+   */\n+  protected List<StrictBitVector> nShare(StrictBitVector myInput) {\n+    List<List<StrictBitVector>> sharesWithMac = new ArrayList<>();\n+    for (int receiverId = 1; receiverId <= resourcePool.getNoOfParties(); receiverId++) {\n+      List<StrictBitVector> resultFromShare = share(receiverId, myInput);\n+      sharesWithMac.add(resultFromShare);\n+    }\n+\n+    return VectorOperations.sumMatchingIndices(sharesWithMac, myInput.getSize());\n+  }\n+\n+  /**\n+   * shares input among the parties\n+   *\n+   * @param receiver party to input\n+   * @param receiverInput the input\n+   * @return list of bitvectors - the sum of the vector is the share of all kappa bits.\n+   */\n+  protected List<StrictBitVector> share(int receiver, StrictBitVector receiverInput) {\n+    List<List<StrictBitVector>> tResults = new ArrayList<>();\n+    List<StrictBitVector> qs = new ArrayList<>();\n+    for (int sender = 1; sender <= resourcePool.getNoOfParties(); sender++) {\n+      if (sender != receiver) {\n+        CoteFactory instance = COTeInstances.get(receiver,sender);\n+        if (resourcePool.getMyId() == sender) {\n+          qs = instance.getSender().extend(receiverInput.getSize());\n+        } else if (resourcePool.getMyId() == receiver) {\n+          tResults.add(instance.getReceiver().extend(receiverInput));\n+        }\n+      }\n+    }\n+    if (resourcePool.getMyId() == receiver) {\n+      return constructUs(receiverInput, tResults);\n+    } else {\n+      return qs;\n+    }\n+  }\n+\n+  /**\n+   * Constructs the <i>u</i>'s describes in Fig. 7 step 2.\n+   * @param receiverInput the input of the receiving party\n+   * @param tResults the <i>t</i>'s resulting from extending COTe\n+   * @return the list of <i>u</i>'s\n+   */\n+  protected List<StrictBitVector> constructUs(\n+      StrictBitVector receiverInput, List<List<StrictBitVector>> tResults) {\n+    List<StrictBitVector> us = new ArrayList<>();\n+    for (int l = 0; l < receiverInput.getSize(); l++) {\n+      StrictBitVector sumOfTs = VectorOperations.xorAtIndex(tResults, l);\n+      if (receiverInput.getBit(l, false)) {\n+        sumOfTs.xor(mac);\n+      }\n+      us.add(sumOfTs);\n+    }\n+    return us;\n+  }\n+\n+  /**\n+   * Returns the COTe instances used in this protocol\n+   * @return COTe instances\n+   */\n+  public CoteInstances getCOTeInstances() {\n+    return COTeInstances;\n+  }\n+\n+}"
  },
  {
    "sha": "33112fc3505c5bd138c67befa2bcdefa4c36256f",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/broadcast/BroadcastValidation.java",
    "status": "added",
    "additions": 66,
    "deletions": 0,
    "changes": 66,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/broadcast/BroadcastValidation.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/broadcast/BroadcastValidation.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/broadcast/BroadcastValidation.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,66 @@\n+package dk.alexandra.fresco.tools.bitTriples.broadcast;\n+\n+import dk.alexandra.fresco.framework.MaliciousException;\n+import dk.alexandra.fresco.framework.network.Network;\n+import dk.alexandra.fresco.tools.bitTriples.BitTripleResourcePool;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Actively-secure protocol for performing hash-based broadcast validation. Allows participating\n+ * parties to ensure that a list of messages is consistent across all parties.\n+ */\n+public class BroadcastValidation {\n+\n+  private final BitTripleResourcePool resourcePool;\n+  private final Network network;\n+\n+  public BroadcastValidation(BitTripleResourcePool resourcePool, Network network) {\n+    this.resourcePool = resourcePool;\n+    this.network = network;\n+  }\n+\n+  /**\n+   * Computes digest of messages and resets md.\n+   */\n+  private byte[] computeDigest(List<byte[]> messages) {\n+    for (byte[] message : messages) {\n+      resourcePool.getMessageDigest().update(message);\n+    }\n+    byte[] digest = resourcePool.getMessageDigest().digest();\n+    resourcePool.getMessageDigest().reset();\n+    return digest;\n+  }\n+\n+  /**\n+   * Compares all other digests with own digest and throws if any are not equal.\n+   *\n+   * @param ownDigest hash of messages sent\n+   * @param otherDigests hashes received from other parties\n+   * @throws MaliciousException if validation fails\n+   */\n+  protected void validateDigests(byte[] ownDigest, List<byte[]> otherDigests) {\n+    for (byte[] otherDigest : otherDigests) {\n+      if (!Arrays.equals(ownDigest, otherDigest)) {\n+        throw new MaliciousException(\"Broadcast validation failed\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Performs broadcast validation on a list of messages.\n+   *\n+   * @param messages messages to validate\n+   */\n+  public void validate(List<byte[]> messages) {\n+    // compute digest\n+    byte[] digest = computeDigest(messages);\n+    // send it to others\n+    network.sendToAll(digest);\n+    // receive others' digests\n+    List<byte[]> digests = network.receiveFromAll();\n+    // validate digests\n+    validateDigests(digest, digests);\n+  }\n+\n+}"
  },
  {
    "sha": "cee199b8cfbd1458b019094e7c3fb159930b3718",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/broadcast/BroadcastingNetworkProxy.java",
    "status": "added",
    "additions": 68,
    "deletions": 0,
    "changes": 68,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/broadcast/BroadcastingNetworkProxy.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/broadcast/BroadcastingNetworkProxy.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/broadcast/BroadcastingNetworkProxy.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,68 @@\n+package dk.alexandra.fresco.tools.bitTriples.broadcast;\n+\n+import dk.alexandra.fresco.framework.network.Network;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * A network proxy which provides actively-secure broadcast functionality. Hash-based broadcast\n+ * validation is performed on all received messages.\n+ */\n+public class BroadcastingNetworkProxy implements Network {\n+\n+  private final Network network;\n+  private final BroadcastValidation validator;\n+\n+  /**\n+   * Decorates a regular network with actively secure broadcast functionality.\n+   * \n+   * @param network raw network\n+   * @param validator the broadcast validation protocol\n+   */\n+  public BroadcastingNetworkProxy(Network network, BroadcastValidation validator) {\n+    if (network.getNoOfParties() < 3) {\n+      throw new IllegalArgumentException(\"Broadcast only needed for three or more parties\");\n+    }\n+    this.network = network;\n+    this.validator = validator;\n+  }\n+\n+  /**\n+   * Point-to-point networking is not supported for broadcast.\n+   */\n+  @Override\n+  public void send(int partyId, byte[] data) {\n+    throw new UnsupportedOperationException(\"Broadcast network can only send to all\");\n+  }\n+\n+  /**\n+   * Runs broadcast validation upon receiving messages to ensure consistency.\n+   */\n+  @Override\n+  public byte[] receive(int partyId) {\n+    byte[] received = network.receive(partyId);\n+    validator.validate(Arrays.asList(received));\n+    return received;\n+  }\n+\n+  @Override\n+  public int getNoOfParties() {\n+    return network.getNoOfParties();\n+  }\n+\n+  @Override\n+  public void sendToAll(byte[] data) {\n+    network.sendToAll(data);\n+  }\n+\n+  /**\n+   * Runs broadcast validation upon receiving messages to ensure consistency.\n+   */\n+  @Override\n+  public List<byte[]> receiveFromAll() {\n+    List<byte[]> received = network.receiveFromAll();\n+    validator.validate(received);\n+    return received;\n+  }\n+\n+}"
  },
  {
    "sha": "f2467e4d9293103c5018abb708bc26c02da6635f",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/cointossing/CoinTossingMpc.java",
    "status": "added",
    "additions": 59,
    "deletions": 0,
    "changes": 59,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/cointossing/CoinTossingMpc.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/cointossing/CoinTossingMpc.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/cointossing/CoinTossingMpc.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,59 @@\n+package dk.alexandra.fresco.tools.bitTriples.cointossing;\n+\n+import dk.alexandra.fresco.framework.network.Network;\n+import dk.alexandra.fresco.framework.util.StrictBitVector;\n+import dk.alexandra.fresco.tools.bitTriples.BitTripleResourcePool;\n+import dk.alexandra.fresco.tools.bitTriples.commit.CommitmentBasedInput;\n+import java.util.List;\n+\n+/**\n+ * Actively-secure protocol for agreeing on a common random seed.\n+ */\n+public class CoinTossingMpc extends CommitmentBasedInput<StrictBitVector> {\n+\n+  /**\n+   * Creates new coin-tossing protocol.\n+   */\n+  public CoinTossingMpc(BitTripleResourcePool resourcePool, Network network) {\n+    super(resourcePool, network, resourcePool.getStrictBitVectorSerializer());\n+  }\n+\n+  /**\n+   * Computes all parties seeds into one by xoring.\n+   * \n+   * @param seeds all parties' seeds\n+   * @return shared seed\n+   */\n+  private StrictBitVector combine(List<StrictBitVector> seeds) {\n+    StrictBitVector acc = seeds.get(0);\n+    for (StrictBitVector seed : seeds.subList(1, seeds.size())) {\n+      acc.xor(seed);\n+    }\n+    return acc;\n+  }\n+\n+  /**\n+   * Generates random seed and calls {@link CoinTossingMpc#generateJointSeed(StrictBitVector)}.\n+   * \n+   * @param bitLengthSeed bit length of seed\n+   * @return shared seed\n+   */\n+  public StrictBitVector generateJointSeed(int bitLengthSeed) {\n+    // generate own seed\n+    return generateJointSeed(new StrictBitVector(bitLengthSeed, super.getResourcePool().getRandomGenerator()));\n+  }\n+\n+  /**\n+   * Distribute seeds and combine into single, joint seed.\n+   * \n+   * @param ownSeed own random seed\n+   * @return shared seed\n+   */\n+  public StrictBitVector generateJointSeed(StrictBitVector ownSeed) {\n+    // distribute seeds\n+    List<StrictBitVector> allSeeds = allCommit(ownSeed);\n+    // combine seeds\n+    return combine(allSeeds);\n+  }\n+\n+}"
  },
  {
    "sha": "2a1684d01878e40993c0d9e71b726bc1eb03ecd2",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/commit/CommitmentBasedInput.java",
    "status": "added",
    "additions": 124,
    "deletions": 0,
    "changes": 124,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/commit/CommitmentBasedInput.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/commit/CommitmentBasedInput.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/commit/CommitmentBasedInput.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,124 @@\n+package dk.alexandra.fresco.tools.bitTriples.commit;\n+\n+import dk.alexandra.fresco.tools.commitment.HashBasedCommitment;\n+import dk.alexandra.fresco.framework.network.Network;\n+import dk.alexandra.fresco.framework.network.serializers.ByteSerializer;\n+import dk.alexandra.fresco.tools.bitTriples.BitTripleResourcePool;\n+import dk.alexandra.fresco.tools.bitTriples.broadcast.BroadcastValidation;\n+import dk.alexandra.fresco.tools.bitTriples.broadcast.BroadcastingNetworkProxy;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Actively-secure protocol for binding input. <p>Allows each party to distribute a value to the\n+ * other parties using commitments. Extended by protocols such as {@link\n+ * dk.alexandra.fresco.tools.bitTriples.maccheck.MacCheck} which consist of a binding input phase of\n+ * public values followed by a computation on these values.</p>\n+ *\n+ * @param <T> type of value to commit to\n+ */\n+public abstract class CommitmentBasedInput<T> {\n+\n+  private final ByteSerializer<T> serializer;\n+  private final Network broadcaster;\n+  private final BitTripleResourcePool resourcePool;\n+  private final Network network;\n+\n+  /**\n+   * Creates new {@link CommitmentBasedInput}.\n+   */\n+  public CommitmentBasedInput(BitTripleResourcePool resourcePool, Network network,\n+      ByteSerializer<T> serializer) {\n+    this.resourcePool = resourcePool;\n+    this.network = network;\n+    this.serializer = serializer;\n+    // for more than two parties, we need to use broadcast\n+    if (resourcePool.getNoOfParties() > 2) {\n+      this.broadcaster =\n+          new BroadcastingNetworkProxy(network, new BroadcastValidation(resourcePool, network));\n+    } else {\n+      // if we have two parties or less we can just use the regular network\n+      this.broadcaster = this.network;\n+    }\n+  }\n+\n+  /**\n+   * Sends own commitment to others and receives others' commitments.\n+   *\n+   * @param comm own commitment\n+   */\n+  private List<HashBasedCommitment> distributeCommitments(HashBasedCommitment comm) {\n+    // broadcast own commitment\n+    broadcaster.sendToAll(getResourcePool().getCommitmentSerializer().serialize(comm));\n+    // receive other parties' commitments from broadcast\n+    List<byte[]> rawComms = broadcaster.receiveFromAll();\n+    // parse\n+    return rawComms.stream()\n+        .map(getResourcePool().getCommitmentSerializer()::deserialize)\n+        .collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Sends own opening info to others and receives others' opening info.\n+   *\n+   * @param opening own opening info\n+   */\n+  private List<byte[]> distributeOpenings(byte[] opening) {\n+    // send (over regular network) own opening info\n+    network.sendToAll(opening);\n+    // receive opening info from others\n+    return network.receiveFromAll();\n+  }\n+\n+  /**\n+   * Attempts to open commitments using opening info, will throw if opening fails.\n+   *\n+   * @param commitments commitments\n+   * @param openings opening information\n+   * @return values from opened commitments\n+   * @throws dk.alexandra.fresco.framework.MaliciousException if opening fails\n+   */\n+  protected List<T> open(List<HashBasedCommitment> commitments, List<byte[]> openings) {\n+    if (commitments.size() != openings.size()) {\n+      throw new IllegalArgumentException(\"Lists must be same size\");\n+    }\n+    List<T> result = new ArrayList<>(commitments.size());\n+    for (int i = 0; i < commitments.size(); i++) {\n+      HashBasedCommitment comm = commitments.get(i);\n+      byte[] opening = openings.get(i);\n+      T el = serializer.deserialize(comm.open(opening));\n+      result.add(el);\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Uses commitments to securely distribute the given value to the other parties and receive their\n+   * inputs.\n+   *\n+   * @param value value to commit to\n+   * @return the other parties' values\n+   */\n+  protected List<T> allCommit(T value) {\n+    // commit to sigma\n+    HashBasedCommitment ownComm = new HashBasedCommitment();\n+\n+    // commit to value locally\n+    byte[] ownOpening = ownComm\n+        .commit(getResourcePool().getRandomGenerator(), serializer.serialize(value));\n+\n+    // all parties commit\n+    List<HashBasedCommitment> comms = distributeCommitments(ownComm);\n+\n+    // all parties send opening info\n+    List<byte[]> openings = distributeOpenings(ownOpening);\n+\n+    // open commitments using received opening info\n+    return open(comms, openings);\n+  }\n+\n+  protected BitTripleResourcePool getResourcePool() {\n+    return resourcePool;\n+  }\n+}"
  },
  {
    "sha": "89eb2c9081b209da630596ac9304c0a7d934af40",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/cote/CoteInstances.java",
    "status": "added",
    "additions": 76,
    "deletions": 0,
    "changes": 76,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/cote/CoteInstances.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/cote/CoteInstances.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/cote/CoteInstances.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,76 @@\n+package dk.alexandra.fresco.tools.bitTriples.cote;\n+\n+import dk.alexandra.fresco.framework.network.Network;\n+import dk.alexandra.fresco.framework.util.StrictBitVector;\n+import dk.alexandra.fresco.tools.bitTriples.BitTripleResourcePool;\n+import dk.alexandra.fresco.tools.ot.otextension.CoteFactory;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\n+/**\n+ * Container for a set of COTe instances\n+ */\n+public class CoteInstances {\n+\n+    private final BitTripleResourcePool resourcePool;\n+    private final StrictBitVector mac;\n+    private final Network network;\n+    private final Map<Integer, Map<Integer, CoteFactory>> coteMap;\n+\n+    /**\n+     * Constructs a set of COTe instances, between each party, using the given mac as input to the initialization.\n+     * @param resourcePool the resource pool\n+     * @param network the network\n+     * @param mac the mac to be used as input\n+     */\n+\n+    public CoteInstances(BitTripleResourcePool resourcePool, Network network, StrictBitVector mac) {\n+        this.resourcePool = resourcePool;\n+        this.network = network;\n+        this.mac = mac;\n+        this.coteMap = initializeCote();\n+    }\n+\n+    /**\n+     * Creates a CoteFactory instance between the party, and every other party.\n+     * @return a map, mapping every other party to an CoteFactory instance\n+     */\n+\n+    private Map<Integer, Map<Integer, CoteFactory>> initializeCote() {\n+        Map<Integer, Map<Integer, CoteFactory>> COTeInstances = new HashMap<>();\n+        for (int receiverId = 1; receiverId <= resourcePool.getNoOfParties(); receiverId++) {\n+            for (int senderId = 1; senderId <= resourcePool.getNoOfParties(); senderId++) {\n+                if (receiverId != senderId) {\n+                    if (resourcePool.getMyId() == senderId) {\n+                        CoteFactory cote = resourcePool.createCote(receiverId, network, mac);\n+                        Map<Integer, CoteFactory> map = new HashMap<>();\n+                        map.put(senderId, cote);\n+                        COTeInstances.put(receiverId, map);\n+                    } else if (resourcePool.getMyId() == receiverId) {\n+                        CoteFactory cote = resourcePool.createCote(senderId, network, mac);\n+\n+                        Map<Integer, CoteFactory> map = COTeInstances.get(receiverId);\n+                        if (map == null) {\n+                            map = new HashMap<>();\n+                        }\n+                        map.put(senderId, cote);\n+                        COTeInstances.put(receiverId, map);\n+                    }\n+                }\n+            }\n+        }\n+        return COTeInstances;\n+    }\n+\n+    /**\n+     * Returns a CoteFactory instance\n+     * @param receiverId id of the receiving party\n+     * @param senderId id of the sending party\n+     * @return the instance\n+     */\n+\n+    public CoteFactory get(int receiverId, int senderId){\n+        return coteMap.get(receiverId).get(senderId);\n+    }\n+}"
  },
  {
    "sha": "91196145f2a1c8e43df98fea29eaa96a05f33316",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/elements/AuthenticatedElement.java",
    "status": "added",
    "additions": 61,
    "deletions": 0,
    "changes": 61,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/elements/AuthenticatedElement.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/elements/AuthenticatedElement.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/elements/AuthenticatedElement.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,61 @@\n+package dk.alexandra.fresco.tools.bitTriples.elements;\n+\n+import dk.alexandra.fresco.framework.util.StrictBitVector;\n+\n+public class AuthenticatedElement {\n+\n+  private final boolean bit;\n+  private final StrictBitVector mac;\n+\n+  /**\n+   * Creates new authenticated element.\n+   *\n+   * @param share this party's share\n+   * @param mac this party's share of the mac\n+   */\n+  public AuthenticatedElement(boolean share, StrictBitVector mac) {\n+    this.bit = share;\n+    this.mac = mac;\n+  }\n+\n+  /**\n+   * Adds other to this and returns result.\n+   *\n+   * @param other value to be added\n+   * @return sum\n+   */\n+  public AuthenticatedElement xor(AuthenticatedElement other) {\n+    StrictBitVector xorOfMacs =  new StrictBitVector(mac.toByteArray().clone());\n+    xorOfMacs.xor(other.mac);\n+    return new AuthenticatedElement(bit ^ other.bit, xorOfMacs);\n+  }\n+\n+  /**\n+   * Adds other to this and returns result.\n+   *\n+   * @return sum\n+   */\n+  public AuthenticatedElement and(boolean bool) {\n+    StrictBitVector macShare = new StrictBitVector(mac.getSize());\n+    if(bool){\n+      macShare = new StrictBitVector(mac.toByteArray().clone());\n+    }\n+    return new AuthenticatedElement(bit && bool, macShare);\n+  }\n+\n+  public StrictBitVector getMac() {\n+    return mac;\n+  }\n+\n+  public boolean getBit() {\n+    return bit;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"AuthenticatedElement [\"\n+        + \"share=\" + bit\n+        + \", mac=\" + mac\n+        + ']';\n+  }\n+}"
  },
  {
    "sha": "17652c62688b7713ea0a6c39a118fcde283a1dee",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/elements/MultiplicationTriple.java",
    "status": "added",
    "additions": 55,
    "deletions": 0,
    "changes": 55,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/elements/MultiplicationTriple.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/elements/MultiplicationTriple.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/elements/MultiplicationTriple.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,55 @@\n+package dk.alexandra.fresco.tools.bitTriples.elements;\n+\n+import dk.alexandra.fresco.framework.builder.numeric.Addable;\n+\n+/**\n+ * A secret-shared authenticated multiplication triple. <p>Holds three elements [a],[b],[c] such\n+ * that [a * b] = [c]</p>\n+ */\n+public class MultiplicationTriple implements Addable<MultiplicationTriple> {\n+\n+  private final AuthenticatedElement left;\n+  private final AuthenticatedElement right;\n+  private final AuthenticatedElement product;\n+\n+  /**\n+   * Creates new multiplication triple.\n+   *\n+   * @param left left factor\n+   * @param right right factor\n+   * @param product product\n+   */\n+  public MultiplicationTriple(AuthenticatedElement left, AuthenticatedElement right,\n+      AuthenticatedElement product) {\n+    super();\n+    this.left = left;\n+    this.right = right;\n+    this.product = product;\n+  }\n+\n+  public AuthenticatedElement getLeft() {\n+    return left;\n+  }\n+\n+  public AuthenticatedElement getRight() {\n+    return right;\n+  }\n+\n+  public AuthenticatedElement getProduct() {\n+    return product;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"MultiplicationTriple [left=\" + left.toString() + \", right=\" + right.toString() + \", product=\" + product.toString() + \"]\";\n+  }\n+\n+  @Override\n+  public MultiplicationTriple add(MultiplicationTriple other) {\n+    AuthenticatedElement leftSum = left.xor(other.left);\n+    AuthenticatedElement rightSum = right.xor(other.right);\n+    AuthenticatedElement productSum = product.xor(other.product);\n+    return new MultiplicationTriple(leftSum, rightSum, productSum);\n+  }\n+\n+}"
  },
  {
    "sha": "a6041c14f44e7dda901cc89aa080eeedfb025090",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/maccheck/MacCheck.java",
    "status": "added",
    "additions": 63,
    "deletions": 0,
    "changes": 63,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/maccheck/MacCheck.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/maccheck/MacCheck.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/maccheck/MacCheck.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,63 @@\n+package dk.alexandra.fresco.tools.bitTriples.maccheck;\n+\n+import dk.alexandra.fresco.framework.MaliciousException;\n+import dk.alexandra.fresco.framework.network.Network;\n+import dk.alexandra.fresco.framework.util.StrictBitVector;\n+import dk.alexandra.fresco.tools.bitTriples.BitTripleResourcePool;\n+import dk.alexandra.fresco.tools.bitTriples.prg.BytePrg;\n+import dk.alexandra.fresco.tools.bitTriples.utils.VectorOperations;\n+import java.util.List;\n+\n+/**\n+ * Actively-secure protocol for performing a batched MAC check on a set of public bits x. <br> Each\n+ * party p_i a share of the MAC m_i, and a share of the key d_i. <br> This protocol validates that\n+ * m_x = (m_1 + ... + m_n) = x * (d_1 + ... + d_n), for every x in the batch.\n+ */\n+public class MacCheck {\n+\n+  private final Network network;\n+  private final BitTripleResourcePool resourcePool;\n+  private final BytePrg jointSampler;\n+\n+  /**\n+   * Creates a new Mac Check protocol (described in fig. 16).\n+   *\n+   * @param resourcePool\n+   * @param network\n+   * @param jointSampler\n+   */\n+  public MacCheck(BitTripleResourcePool resourcePool, Network network, BytePrg jointSampler) {\n+    this.resourcePool = resourcePool;\n+    this.network = network;\n+    this.jointSampler = jointSampler;\n+  }\n+\n+  /**\n+   * Runs protocol, checking if a set of values and mac shares are valid.\n+   *\n+   * @param opened    The public values\n+   * @param macShares the mac values\n+   * @param myMac     the mac of the party\n+   * @return true if mac check was accepted\n+   */\n+  public boolean check(\n+      StrictBitVector opened, List<StrictBitVector> macShares, StrictBitVector myMac) {\n+\n+    //Step 4\n+    StrictBitVector randomElement = jointSampler.getNext(opened.getSize());\n+\n+    //Step 5\n+    boolean b = VectorOperations.sum(VectorOperations.and(randomElement, opened));\n+    //Step 6\n+    StrictBitVector sigma = VectorOperations\n+        .sum(VectorOperations.multiply(macShares, randomElement));\n+    sigma.xor(VectorOperations.multiply(myMac, b));\n+\n+    // step 7-9\n+    StrictBitVector openSigma = VectorOperations.openVector(sigma, resourcePool, network);\n+    if (!VectorOperations.isZero(openSigma)) {\n+      throw new MaliciousException(\"Mac check failed\");\n+    }\n+    return true;\n+  }\n+}"
  },
  {
    "sha": "923c6d5b33fb26f6ce9cc06a7fe50e90a41bdfda",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/prg/BytePrg.java",
    "status": "added",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/prg/BytePrg.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/prg/BytePrg.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/prg/BytePrg.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,14 @@\n+package dk.alexandra.fresco.tools.bitTriples.prg;\n+\n+import dk.alexandra.fresco.framework.util.StrictBitVector;\n+\n+public interface BytePrg {\n+\n+  /**\n+   * Deterministically generates random field element.\n+   *\n+   * @return random field element\n+   */\n+  StrictBitVector getNext(int size);\n+\n+}"
  },
  {
    "sha": "01225a31806e5b05daa068991c50b73584ee4b2a",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/prg/BytePrgImpl.java",
    "status": "added",
    "additions": 33,
    "deletions": 0,
    "changes": 33,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/prg/BytePrgImpl.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/prg/BytePrgImpl.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/prg/BytePrgImpl.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,33 @@\n+package dk.alexandra.fresco.tools.bitTriples.prg;\n+\n+import dk.alexandra.fresco.framework.util.AesCtrDrbgFactory;\n+import dk.alexandra.fresco.framework.util.Drbg;\n+import dk.alexandra.fresco.framework.util.StrictBitVector;\n+\n+public class BytePrgImpl implements BytePrg {\n+\n+  private final Drbg drbg;\n+\n+  /**\n+   * Creates new byte prg.\n+   *\n+   * @param seed seed to the underlying DRNG.\n+   */\n+  public BytePrgImpl(StrictBitVector seed) {\n+    byte[] bytes = seed.toByteArray();\n+    drbg = AesCtrDrbgFactory.fromDerivedSeed(bytes);\n+  }\n+  /**\n+   * Creates new byte prg.\n+   *\n+   * @param drbg the drbg.\n+   */\n+  public BytePrgImpl(Drbg drbg) {\n+    this.drbg = drbg;\n+  }\n+\n+  @Override\n+  public StrictBitVector getNext(int size) {\n+    return new StrictBitVector(size, drbg);\n+  }\n+}"
  },
  {
    "sha": "3cf74b6416dbc30c331bed5ecae43420f3aa91e5",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/triple/TripleGeneration.java",
    "status": "added",
    "additions": 597,
    "deletions": 0,
    "changes": 597,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/triple/TripleGeneration.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/triple/TripleGeneration.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/triple/TripleGeneration.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,597 @@\n+package dk.alexandra.fresco.tools.bitTriples.triple;\n+\n+import dk.alexandra.fresco.framework.MaliciousException;\n+import dk.alexandra.fresco.framework.network.Network;\n+import dk.alexandra.fresco.framework.util.ByteArrayHelper;\n+import dk.alexandra.fresco.framework.util.ExceptionConverter;\n+import dk.alexandra.fresco.framework.util.Pair;\n+import dk.alexandra.fresco.framework.util.StrictBitVector;\n+import dk.alexandra.fresco.tools.bitTriples.BitTripleResourcePool;\n+import dk.alexandra.fresco.tools.bitTriples.bracket.Bracket;\n+import dk.alexandra.fresco.tools.bitTriples.cote.CoteInstances;\n+import dk.alexandra.fresco.tools.bitTriples.elements.AuthenticatedElement;\n+import dk.alexandra.fresco.tools.bitTriples.elements.MultiplicationTriple;\n+import dk.alexandra.fresco.tools.bitTriples.maccheck.MacCheck;\n+import dk.alexandra.fresco.tools.bitTriples.prg.BytePrg;\n+import dk.alexandra.fresco.tools.bitTriples.utils.VectorOperations;\n+import dk.alexandra.fresco.tools.ot.otextension.CoteFactory;\n+import java.security.SecureRandom;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Actively-secure protocol for computing authenticated, secret-shared multiplication bit triples based\n+ * on the protocol described in Fig. 15 in <a\n+ * href=\"https://eprint.iacr.org/2016/505.pdf\">https://eprint.iacr.org/2016/505.pdf</a>.\n+ */\n+public class TripleGeneration {\n+\n+  private final BitTripleResourcePool resourcePool;\n+  private final Network network;\n+  private final StrictBitVector macLeft;\n+  private final StrictBitVector macRight;\n+  private final Bracket bracket;\n+  private final CoteInstances coTeInstances;\n+  private final int kappa;\n+  private final MacCheck macChecker;\n+  private final BytePrg jointSampler;\n+  private int c;\n+\n+  /**\n+   * Creates new triple generation protocol.\n+   * @param resourcePool the Resource pool\n+   * @param network the network\n+   * @param kappa the security parameter\n+   * @param jointSampler the joint sampler\n+   * @param macLeft the left part of the mac\n+   * @param macRight the right part of the mac\n+   */\n+  public TripleGeneration(\n+      BitTripleResourcePool resourcePool, Network network, int kappa, BytePrg jointSampler,\n+      StrictBitVector macLeft, StrictBitVector macRight) {\n+    this.resourcePool = resourcePool;\n+    this.network = network;\n+    this.kappa = kappa;\n+    this.macChecker = new MacCheck(resourcePool, network, jointSampler);\n+    this.jointSampler = jointSampler;\n+\n+    this.macLeft = macLeft;\n+    this.macRight = macRight;\n+    StrictBitVector macConcat = StrictBitVector.concat(macLeft, macRight);\n+\n+    Bracket bracket = new Bracket(resourcePool, network, macConcat, jointSampler); //\n+    bracket.input(kappa); //\n+    // Step 2 of Initialization\n+    this.coTeInstances = bracket.getCOTeInstances();\n+    this.bracket = new Bracket(resourcePool, network, macRight, jointSampler);\n+    // Step 3 of Initialization - Check consistency of macs\n+  }\n+\n+  public TripleGeneration(BitTripleResourcePool resourcePool, Network network, int kappa, BytePrg jointSampler){\n+    this(resourcePool,network,kappa,jointSampler,resourcePool.getLocalSampler().getNext(kappa),resourcePool.getLocalSampler().getNext(kappa));\n+  }\n+\n+  /**\n+   * Generates numTriples valid authenticated multiplication triples in a batch.\n+   *\n+   * <p>Implements the protocol described in fig. 15 (all steps).\n+   *\n+   * @param noOfTriples number of triples to generate\n+   * @return valid multiplication triples\n+   */\n+  public List<MultiplicationTriple> triple(int noOfTriples) {\n+    c = getBucketSize(noOfTriples, resourcePool.getStatisticalSecurityByteParameter());\n+    int triplesToGenerate = nearestPowerOfEight(noOfTriples * c * c + c);\n+\n+    // Extend cote\n+    StrictBitVector xs = resourcePool.getLocalSampler().getNext(triplesToGenerate);\n+    Pair<Map<Integer, List<StrictBitVector>>,Map<Integer, List<StrictBitVector>>> qsTs = extend(xs);\n+\n+    Pair<StrictBitVector, StrictBitVector> yz = generateTriples(xs,qsTs);\n+\n+    // Authenticate triples\n+    List<StrictBitVector> xShares = bracket.input(xs);\n+    List<StrictBitVector> yShares = bracket.input(yz.getFirst());\n+    List<StrictBitVector> zShares = bracket.input(yz.getSecond());\n+\n+    List<AuthenticatedCandidate> authenticatedCandidate =\n+        toAuthenticatedCandidate(\n+            toAuthenticatedElement(xShares, xs),\n+            toAuthenticatedElement(yShares, yz.getFirst()),\n+            toAuthenticatedElement(zShares, yz.getSecond()));\n+\n+    return checkTriples(\n+        authenticatedCandidate,\n+        getBucketSize(noOfTriples, resourcePool.getStatisticalSecurityByteParameter()));\n+  }\n+\n+  /**\n+   * Runs COTe.extend with each other party.\n+   * @param input the input\n+   * @return maps qs and ts, mapping party id to the respective output of COTe.\n+   */\n+\n+  private Pair<Map<Integer, List<StrictBitVector>>,Map<Integer, List<StrictBitVector>>> extend(StrictBitVector input) {\n+    Map<Integer, List<StrictBitVector>> qs = new HashMap<>();\n+    Map<Integer, List<StrictBitVector>> ts = new HashMap<>();\n+    for (int receiver = 1; receiver <= network.getNoOfParties(); receiver++) {\n+      for (int sender = 1; sender <= network.getNoOfParties(); sender++) {\n+        if (receiver != sender) {\n+          CoteFactory instance = coTeInstances.get(receiver, sender);\n+          if (resourcePool.getMyId() == sender) {\n+            qs.put(receiver, instance.getSender().extend(input.getSize()));\n+          } else if (resourcePool.getMyId() == receiver) {\n+            ts.put(sender, instance.getReceiver().extend(input));\n+          }\n+        }\n+      }\n+    }\n+    return new Pair<>(qs,ts);\n+  }\n+\n+  /**\n+   * Implements the Triple generation step of the protocol.\n+   * @param xs a vector\n+   * @param qsTs the qs and the ts from COTe.extend\n+   * @return ys and zs, such that xs * ys = zs.\n+   */\n+\n+  private Pair<StrictBitVector, StrictBitVector> generateTriples(StrictBitVector xs,\n+      Pair<Map<Integer, List<StrictBitVector>>, Map<Integer, List<StrictBitVector>>> qsTs) {\n+    // Step 1\n+    StrictBitVector ys = resourcePool.getLocalSampler().getNext(xs.getSize());\n+    // Step 2a\n+    Map<Integer, StrictBitVector> ws = breakCorrelation(qsTs.getFirst(), null);\n+    Map<Integer, StrictBitVector> v0s = breakCorrelation(qsTs.getSecond(), null);\n+    Map<Integer, StrictBitVector> v1s = breakCorrelation(qsTs.getSecond(), macLeft);\n+    // Step 2b\n+    List<StrictBitVector> ns = createNewCorrelations(ys, xs, v0s, v1s, ws);\n+    // Step 3\n+    StrictBitVector zs = computeZs(ns, xs, ys, v0s);\n+\n+    return new Pair<>(ys, zs);\n+  }\n+\n+  /**\n+   * Implements step 2a.\n+   */\n+  private Map<Integer, StrictBitVector> breakCorrelation(\n+      Map<Integer, List<StrictBitVector>> toBreak, StrictBitVector mac) {\n+    Map<Integer, StrictBitVector> result = new HashMap<>();\n+    for (int j = 1; j <= resourcePool.getNoOfParties(); j++) {\n+      if (resourcePool.getMyId() != j) {\n+        // For each party\n+        List<StrictBitVector> listForPartyJ = toBreak.get(j);\n+        StrictBitVector resultingVector = new StrictBitVector(listForPartyJ.size());\n+        for (int h = 0; h < listForPartyJ.size(); h++) {\n+          // For each vector, hash to single bit.\n+          StrictBitVector toHash =\n+              new StrictBitVector(\n+                  Arrays.copyOfRange(listForPartyJ.get(h).toByteArray().clone(), 0, kappa / 8));\n+          if (mac != null) {\n+            toHash.xor(mac);\n+          }\n+          byte[] hashed = resourcePool.getMessageDigest().digest(toHash.toByteArray());\n+          resultingVector.setBit(h, ByteArrayHelper.getBit(hashed, 0), false);\n+        }\n+        result.put(j, resultingVector);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Implements step 2b.\n+   */\n+\n+  private List<StrictBitVector> createNewCorrelations(\n+      StrictBitVector ys,\n+      StrictBitVector xs,\n+      Map<Integer, StrictBitVector> v0s,\n+      Map<Integer, StrictBitVector> v1s,\n+      Map<Integer, StrictBitVector> ws) {\n+    Map<Integer, StrictBitVector> correlatedVectors = new HashMap<>();\n+    for (int j = 1; j <= resourcePool.getNoOfParties(); j++) {\n+      if (resourcePool.getMyId() != j) {\n+        StrictBitVector s = VectorOperations.xor(v1s.get(j), VectorOperations.xor(ys, v0s.get(j)));\n+        correlatedVectors.put(j, s);\n+      }\n+    }\n+    HashMap<Integer, StrictBitVector> sReceived = new HashMap<>();\n+    for (int otherId = 1; otherId <= resourcePool.getNoOfParties(); otherId++) {\n+      if (resourcePool.getMyId() != otherId) {\n+        if (resourcePool.getMyId() < otherId) {\n+          network.send(\n+              otherId,\n+              resourcePool\n+                  .getStrictBitVectorSerializer()\n+                  .serialize(correlatedVectors.get(otherId)));\n+          sReceived.put(\n+              otherId,\n+              resourcePool.getStrictBitVectorSerializer().deserialize(network.receive(otherId)));\n+\n+        } else {\n+          sReceived.put(\n+              otherId,\n+              resourcePool.getStrictBitVectorSerializer().deserialize(network.receive(otherId)));\n+          network.send(\n+              otherId,\n+              resourcePool\n+                  .getStrictBitVectorSerializer()\n+                  .serialize(correlatedVectors.get(otherId)));\n+        }\n+      }\n+    }\n+\n+    List<StrictBitVector> ns = new ArrayList<>();\n+    for (int j = 1; j <= resourcePool.getNoOfParties(); j++) {\n+      if (resourcePool.getMyId() != j) {\n+        StrictBitVector nj =\n+            VectorOperations.xor(VectorOperations.and(xs, sReceived.get(j)), ws.get(j));\n+        ns.add(nj);\n+      }\n+    }\n+    return ns;\n+  }\n+\n+  /**\n+   * Implements step 3.\n+   */\n+\n+  private StrictBitVector computeZs(\n+      List<StrictBitVector> ns,\n+      StrictBitVector xs,\n+      StrictBitVector ys,\n+      Map<Integer, StrictBitVector> v0s) {\n+\n+    StrictBitVector u =\n+        VectorOperations.xor(VectorOperations.sum(ns), VectorOperations.and(xs, ys));\n+\n+    return VectorOperations.xor(u, VectorOperations.sum(VectorOperations.mapToList(v0s)));\n+  }\n+\n+  /** Implements sub-protocol CheckTriples of Figure 23 */\n+  private List<MultiplicationTriple> checkTriples(\n+      List<AuthenticatedCandidate> candidates, int bucketSize) {\n+\n+    List<OpenedElement> openedElements = new ArrayList<>();\n+    // Phase 1\n+    List<AuthenticatedCandidate> cutCandidates = cutAndChoose(candidates, c, openedElements);\n+    // Phase 2\n+    List<AuthenticatedCandidate> sacrificedBuckets =\n+        bucketSacrifice(cutCandidates, bucketSize, openedElements);\n+\n+    // Phase 3\n+    List<AuthenticatedCandidate> combinedBuckets =\n+        combineBuckets(sacrificedBuckets, bucketSize, openedElements);\n+\n+    // Phase 4\n+    checkOpenedValues(openedElements);\n+\n+    // convert candidates to valid triples and return\n+    return toMultTriples(combinedBuckets);\n+  }\n+\n+\n+\n+  /**\n+   * Implements the cut and choose step described in Phase-I.\n+   */\n+\n+  private List<AuthenticatedCandidate> cutAndChoose(\n+      List<AuthenticatedCandidate> candidates, int c, List<OpenedElement> openedElements) {\n+\n+    StrictBitVector randomIndices =\n+        VectorOperations.generateRandomIndices(c, candidates.size(), resourcePool, jointSampler);\n+    List<AuthenticatedCandidate> candidatesToCheck = new ArrayList<>();\n+    List<AuthenticatedCandidate> unopenedCandidates = new ArrayList<>();\n+    for (int i = 0; i < randomIndices.getSize(); i++) {\n+      if (randomIndices.getBit(i, false)) {\n+        candidatesToCheck.add(candidates.get(i));\n+      } else {\n+        unopenedCandidates.add(candidates.get(i));\n+      }\n+    }\n+\n+    checkMultiplicationPredicate(candidatesToCheck, openedElements);\n+    return unopenedCandidates;\n+  }\n+\n+  /**\n+   * Validates the multiplication predicate of the given candidates.\n+   */\n+  protected void checkMultiplicationPredicate(\n+      List<AuthenticatedCandidate> candidates, List<OpenedElement> openedElements) {\n+    StrictBitVector xs = new StrictBitVector(nearestMultipleOfEight(candidates.size()));\n+    StrictBitVector ys = new StrictBitVector(nearestMultipleOfEight(candidates.size()));\n+    StrictBitVector zs = new StrictBitVector(nearestMultipleOfEight(candidates.size()));\n+    for (int i = 0; i < candidates.size(); i++) { //\n+      xs.setBit(i, candidates.get(i).leftFactor.getBit(), false);\n+      ys.setBit(i, candidates.get(i).rightFactor.getBit(), false);\n+      zs.setBit(i, candidates.get(i).product.getBit(), false);\n+    }\n+\n+    StrictBitVector xOpen = VectorOperations.openVector(xs, resourcePool, network);\n+    StrictBitVector yOpen = VectorOperations.openVector(ys, resourcePool, network);\n+    StrictBitVector zOpen = VectorOperations.openVector(zs, resourcePool, network);\n+\n+    for (int i = 0; i < candidates.size(); i++) {\n+      openedElements.add(new OpenedElement(xOpen.getBit(i, false), candidates.get(i).leftFactor.getMac()));\n+      openedElements.add(new OpenedElement(yOpen.getBit(i, false), candidates.get(i).rightFactor.getMac()));\n+      openedElements.add(new OpenedElement(zOpen.getBit(i, false), candidates.get(i).product.getMac()));\n+    }\n+\n+    if (!VectorOperations.and(xOpen, yOpen).equals(zOpen)) {\n+      throw new MaliciousException(\"Aborting - multiplication predicates were not satisfied\");\n+    }\n+  }\n+\n+\n+  /**\n+   * Implements the bucket-sacrifice step described in Phase-II\n+   */\n+\n+  private List<AuthenticatedCandidate> bucketSacrifice(\n+      List<AuthenticatedCandidate> candidates, int bucketSize, List<OpenedElement> openedElements) {\n+    int noOfBuckets = candidates.size() / bucketSize;\n+\n+    List<AuthenticatedCandidate> permuted = randomPermute(candidates);\n+\n+    // construct buckets\n+    List<AuthenticatedCandidate> resultingCandidates = new ArrayList<>();\n+    for (int i = 0; i < noOfBuckets; i++) {\n+      List<AuthenticatedCandidate> bucket = new ArrayList<>();\n+      for (int j = 0; j < bucketSize; j++) {\n+        bucket.add(permuted.get(i * bucketSize + j));\n+      }\n+      AuthenticatedCandidate sacrificed =\n+          sacrificeBucket(bucket.subList(1, bucketSize), bucket.get(0), openedElements);\n+      resultingCandidates.add(sacrificed);\n+    }\n+    return resultingCandidates;\n+  }\n+\n+  private List<AuthenticatedCandidate> randomPermute(List<AuthenticatedCandidate> candidates) {\n+    SecureRandom random = ExceptionConverter.safe(\n+        () -> SecureRandom.getInstance(\"SHA1PRNG\"),\n+        \"Configuration error, SHA1PRNG is needed for BitTriple\");\n+    StrictBitVector v = jointSampler.getNext(resourcePool.getPrgSeedBitLength());\n+    random.setSeed(v.toByteArray());\n+    Collections.shuffle(candidates, random);\n+    return candidates;\n+  }\n+\n+  private AuthenticatedCandidate sacrificeBucket(\n+      List<AuthenticatedCandidate> candidates,\n+      AuthenticatedCandidate bucketHead,\n+      List<OpenedElement> openedElements) {\n+    for (AuthenticatedCandidate candidate : candidates) {\n+      checkR(bucketHead, candidate, openedElements);\n+    }\n+    return bucketHead;\n+  }\n+\n+  /**\n+   * Implements the CheckR functionality described in phase-II of the protocol.\n+   */\n+  protected void checkR(\n+      AuthenticatedCandidate bucketHead,\n+      AuthenticatedCandidate candidate,\n+      List<OpenedElement> openedElements) {\n+\n+    // a=[x_i]+[x_j]\n+    AuthenticatedElement a = bucketHead.leftFactor.xor(candidate.leftFactor);\n+    OpenedElement aOpen = openElement(a);\n+    // b=[y_i]+[y_j]\n+    AuthenticatedElement b = bucketHead.rightFactor.xor(candidate.rightFactor);\n+    OpenedElement bOpen = openElement(b);\n+    // c = [z_j]+[z_i]+[x_i] * b+[y_i] * a\n+    AuthenticatedElement c =\n+        bucketHead\n+            .product\n+            .xor(candidate.product)\n+            .xor(bucketHead.leftFactor.and(bOpen.value))\n+            .xor(bucketHead.rightFactor.and(aOpen.value));\n+    openedElements.add(aOpen);\n+    openedElements.add(bOpen);\n+    OpenedElement cOpen = openElement(c);\n+    if (cOpen.value != (aOpen.value && bOpen.value)) {\n+      throw new MaliciousException(\"Verification of bucket head failed\");\n+    }\n+  }\n+\n+\n+  /**\n+   * Implements the Combine step described in Phase-III.\n+   */\n+  private List<AuthenticatedCandidate> combineBuckets(\n+      List<AuthenticatedCandidate> candidates, int bucketSize, List<OpenedElement> openedElements) {\n+    int noOfBuckets = candidates.size() / bucketSize;\n+\n+    List<AuthenticatedCandidate> permuted = randomPermute(candidates);\n+    // construct buckets of size noPerBucket\n+    List<List<AuthenticatedCandidate>> buckets = new ArrayList<>();\n+    for (int i = 0; i < noOfBuckets; i++) {\n+      List<AuthenticatedCandidate> bucket = new ArrayList<>();\n+      for (int j = 0; j < bucketSize; j++) {\n+        bucket.add(permuted.get(i * bucketSize + j));\n+      }\n+      buckets.add(bucket);\n+    }\n+    List<AuthenticatedCandidate> triples = new ArrayList<>();\n+    for (List<AuthenticatedCandidate> bucket : buckets) {\n+      triples.add(combineSingleBucket(bucket, openedElements));\n+    }\n+    return triples;\n+  }\n+\n+  private AuthenticatedCandidate combineSingleBucket(\n+      List<AuthenticatedCandidate> bucket, List<OpenedElement> openedElements) {\n+    AuthenticatedCandidate firstCandidate = bucket.remove(0);\n+    return recursivelyCombine(firstCandidate, bucket, openedElements);\n+  }\n+\n+  private AuthenticatedCandidate recursivelyCombine(\n+      AuthenticatedCandidate accumulatedCombination,\n+      List<AuthenticatedCandidate> bucket,\n+      List<OpenedElement> openedElements) {\n+    if (bucket.size() <= 0) {\n+      return accumulatedCombination;\n+    } else {\n+      AuthenticatedCandidate accumulate =\n+          combineTwoTriples(accumulatedCombination, bucket.remove(0), openedElements);\n+      return recursivelyCombine(accumulate, bucket, openedElements);\n+    }\n+  }\n+\n+  private AuthenticatedCandidate combineTwoTriples(\n+      AuthenticatedCandidate left,\n+      AuthenticatedCandidate right,\n+      List<OpenedElement> openedElements) {\n+    AuthenticatedElement ys = left.rightFactor.xor(right.rightFactor);\n+    OpenedElement openedYs = openElement(ys);\n+    AuthenticatedElement xNew = left.leftFactor.xor(right.leftFactor);\n+    AuthenticatedElement zNew =\n+        left.product.xor(right.product).xor(right.leftFactor.and(openedYs.value));\n+    openedElements.add(openedYs);\n+    return new AuthenticatedCandidate(xNew, left.rightFactor, zNew);\n+  }\n+\n+  /**\n+   * Implements the Mac Check step described in Phase-IV\n+   */\n+  private void checkOpenedValues(List<OpenedElement> openedElements) {\n+    int nearestPower = nearestMultipleOfEight(openedElements.size());\n+    StrictBitVector values = new StrictBitVector(nearestPower);\n+    List<StrictBitVector> macShares = new ArrayList<>(nearestPower);\n+    for (int i = 0; i < openedElements.size(); i++) {\n+      values.setBit(i, openedElements.get(i).value, false);\n+      macShares.add(openedElements.get(i).share);\n+    }\n+    for (int i = 0; i < nearestPower - openedElements.size(); i++) {\n+      macShares.add(new StrictBitVector(kappa));\n+    }\n+    macChecker.check(values, macShares, macRight);\n+  }\n+\n+  private int nearestMultipleOfEight(int size) {\n+    return size + (8 - size % 8);\n+  }\n+\n+  private OpenedElement openElement(AuthenticatedElement element) {\n+    StrictBitVector toSend = new StrictBitVector(8);\n+    toSend.setBit(0, element.getBit(), false);\n+    return new OpenedElement(VectorOperations.openVector(toSend, resourcePool, network).getBit(0, false), element.getMac());\n+  }\n+\n+  private List<MultiplicationTriple> toMultTriples(List<AuthenticatedCandidate> candidates) {\n+    return candidates.stream().map(AuthenticatedCandidate::toTriple).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Returns the bucket size for given parameters (described in Table 2).\n+   */\n+\n+  protected static int getBucketSize(int numberOfTriples, int securityParameter) {\n+    if (securityParameter <= 40) {\n+      if (numberOfTriples <= 1024) {\n+        return 5;\n+      } else if (numberOfTriples <= 16384) {\n+        return 4;\n+      } else {\n+        return 3;\n+      }\n+    } else {\n+      if (numberOfTriples <= 1024) {\n+        return 8;\n+      } else if (numberOfTriples <= 16384) {\n+        return 6;\n+      } else {\n+        return 5;\n+      }\n+    }\n+  }\n+\n+  private int nearestPowerOfEight(int noOfTriples) {\n+    int power = 8;\n+    while (power < noOfTriples) {\n+      power = power * 8;\n+    }\n+    return power;\n+  }\n+\n+\n+  protected static List<AuthenticatedElement> toAuthenticatedElement(\n+      List<StrictBitVector> macs, StrictBitVector shares) {\n+    if (macs.size() != shares.getSize()) {\n+      throw new IllegalArgumentException(\"There must be the same number of shares and macs.\");\n+    }\n+    List<AuthenticatedElement> toReturn = new ArrayList<>();\n+    for (int i = 0; i < macs.size(); i++) {\n+      toReturn.add(new AuthenticatedElement(shares.getBit(i, false), macs.get(i)));\n+    }\n+    return toReturn;\n+  }\n+\n+  protected static List<AuthenticatedCandidate> toAuthenticatedCandidate(\n+      List<AuthenticatedElement> xs, List<AuthenticatedElement> ys, List<AuthenticatedElement> zs) {\n+    if (xs.size() != ys.size() || xs.size() != zs.size()) {\n+      throw new IllegalArgumentException(\"There must be the same number of shares.\");\n+    }\n+    List<AuthenticatedCandidate> toReturn = new ArrayList<>();\n+    for (int i = 0; i < xs.size(); i++) {\n+      toReturn.add(new AuthenticatedCandidate(xs.get(i), ys.get(i), zs.get(i)));\n+    }\n+    return toReturn;\n+  }\n+\n+\n+  /**\n+   * Represents single authenticated triple candidate (<i>[[a]]</i>, <i>[[b]]</i>, <i>[[c]]</i>).\n+   */\n+  protected static final class AuthenticatedCandidate extends TripleCandidate<AuthenticatedElement> {\n+\n+    AuthenticatedCandidate(\n+        AuthenticatedElement left, AuthenticatedElement right, AuthenticatedElement product) {\n+      super(left, right, product);\n+    }\n+\n+    MultiplicationTriple toTriple() {\n+      return new MultiplicationTriple(leftFactor, rightFactor, product);\n+    }\n+  }\n+\n+  private static class TripleCandidate<T> {\n+\n+    final T leftFactor;\n+    final T rightFactor;\n+    final T product;\n+\n+    TripleCandidate(T leftFactor, T rightFactor, T product) {\n+      this.leftFactor = leftFactor;\n+      this.rightFactor = rightFactor;\n+      this.product = product;\n+    }\n+\n+  }\n+\n+  /**\n+   * Represents a partially opened element.\n+   */\n+\n+  private static final class OpenedElement {\n+\n+    private final boolean value;\n+    private final StrictBitVector share;\n+\n+    public OpenedElement(boolean openedValue, StrictBitVector share) {\n+      this.value = openedValue;\n+      this.share = share;\n+    }\n+  }\n+}"
  },
  {
    "sha": "dc92762251b1a4113e4b99b0def1cd45a175e399",
    "filename": "tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/utils/VectorOperations.java",
    "status": "added",
    "additions": 190,
    "deletions": 0,
    "changes": 190,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/utils/VectorOperations.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/utils/VectorOperations.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/main/java/dk/alexandra/fresco/tools/bitTriples/utils/VectorOperations.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,190 @@\n+package dk.alexandra.fresco.tools.bitTriples.utils;\n+\n+import dk.alexandra.fresco.framework.network.Network;\n+import dk.alexandra.fresco.framework.util.ExceptionConverter;\n+import dk.alexandra.fresco.framework.util.StrictBitVector;\n+import dk.alexandra.fresco.tools.bitTriples.BitTripleResourcePool;\n+import dk.alexandra.fresco.tools.bitTriples.prg.BytePrg;\n+import java.security.SecureRandom;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+\n+public final class VectorOperations {\n+\n+  private VectorOperations(){\n+    throw new RuntimeException(\"Instantiation of VectorOperations is not allowed.\");\n+  }\n+\n+  /**\n+   * Checks whether the vector is zero.\n+   */\n+  public static boolean isZero(StrictBitVector vector) {\n+    return vector.equals(new StrictBitVector(vector.getSize()));\n+  }\n+\n+  public static StrictBitVector multiply(StrictBitVector vector, boolean bit) {\n+    if (bit) {\n+      return vector;\n+    } else {\n+      return new StrictBitVector(vector.getSize());\n+    }\n+  }\n+\n+  public static List<StrictBitVector> multiply(List<StrictBitVector> list, StrictBitVector r) {\n+    if (r.getSize() != list.size()) {\n+      throw new IllegalStateException(\"List and vector must be the same size\");\n+    }\n+    List<StrictBitVector> result = new ArrayList<>();\n+    for (int i = 0; i < r.getSize(); i++) {\n+      result.add(multiply(list.get(i), r.getBit(i, false)));\n+    }\n+    return result;\n+  }\n+\n+  public static StrictBitVector sum(List<StrictBitVector> toSum) {\n+    StrictBitVector sum = new StrictBitVector(toSum.get(0).toByteArray().clone());\n+    for (int i = 1; i < toSum.size(); i++) {\n+      sum.xor(toSum.get(i));\n+    }\n+    return sum;\n+  }\n+\n+  public static StrictBitVector xor(StrictBitVector a, StrictBitVector b){\n+    StrictBitVector result = new StrictBitVector(a.toByteArray().clone());\n+    result.xor(b);\n+    return result;\n+  }\n+\n+  public static boolean sum(StrictBitVector toSum) {\n+    boolean accumulator = toSum.getBit(0,false);\n+    for (int i = 1; i<toSum.getSize(); i++){\n+      accumulator ^= toSum.getBit(i,false);\n+    }\n+    return accumulator;\n+  }\n+\n+  public static StrictBitVector xorAtIndex(List<List<StrictBitVector>> toSum, int index) {\n+    int size = toSum.get(0).size();\n+    for(List<StrictBitVector> l : toSum){\n+      if (l.size() != size){\n+        throw new IllegalStateException(\"Vectors must be the same size\");\n+      }\n+    }\n+    List<StrictBitVector> atIndex = toSum.stream().map(l -> l.get(index)).collect(Collectors.toList());\n+    return sum(atIndex);\n+  }\n+\n+  public static StrictBitVector and(StrictBitVector a, StrictBitVector b) {\n+    if (a.getSize() != b.getSize()) {\n+      throw new IllegalStateException(\"Vectors must be the same size\");\n+    }\n+    StrictBitVector result = new StrictBitVector(a.getSize());\n+    for (int i = 0; i < a.getSize(); i++) {\n+      result.setBit(i, a.getBit(i,false) && b.getBit(i,false),false);\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Takes a List of Lists of vectors, and sum the vectors at matching indices.\n+   * @param vectors matrix of vectors\n+   * @param length the length of the inner lists\n+   * @return list of the sums\n+   */\n+  public static List<StrictBitVector> sumMatchingIndices(List<List<StrictBitVector>> vectors, int length) {\n+    List<StrictBitVector> resultingVectors = new ArrayList<>();\n+    for (int i = 0; i < length; i++) {\n+      StrictBitVector newVector = null;\n+      for (List<StrictBitVector> list : vectors) {\n+        if (newVector == null) {\n+          newVector = list.get(i);\n+        } else {\n+          newVector.xor(list.get(i));\n+        }\n+      }\n+      resultingVectors.add(newVector);\n+    }\n+    return resultingVectors;\n+  }\n+\n+\n+  /**\n+   * Sends vector to others and receives others' vector.\n+   *\n+   * @param vector own vector\n+   */\n+  public static StrictBitVector openVector(StrictBitVector vector, BitTripleResourcePool resourcePool, Network network) {\n+\n+    List<byte[]> rawComms = new ArrayList<>();\n+    for (int otherId = 1; otherId <= resourcePool.getNoOfParties(); otherId++) {\n+      if (resourcePool.getMyId() != otherId) {\n+        if (resourcePool.getMyId() < otherId) {\n+          network.send(otherId,resourcePool.getStrictBitVectorSerializer().serialize(vector));\n+          rawComms.add(network.receive(otherId));\n+        } else {\n+          rawComms.add(network.receive(otherId));\n+          network.send(otherId,resourcePool.getStrictBitVectorSerializer().serialize(vector));\n+        }\n+      }\n+    }\n+\n+    StrictBitVector received = sum(rawComms.stream()\n+        .map(resourcePool.getStrictBitVectorSerializer()::deserialize)\n+        .collect(Collectors.toList()));\n+    received.xor(vector);\n+    return received;\n+  }\n+\n+  public static List<StrictBitVector> mapToList(Map<Integer, StrictBitVector> map) {\n+    List<StrictBitVector> result = new ArrayList<>();\n+    for(int i = 1; i<= map.size()+1; i++){\n+        StrictBitVector toAdd = map.get(i);\n+        if(toAdd != null){\n+          result.add(map.get(i));\n+        }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Generates a random StrictBitVector with exactly c 1's, and the rest 0's.\n+   *\n+   * @param c number of 1's.\n+   * @param size size of .\n+   * @return A vector with c bits set.\n+   */\n+  public static StrictBitVector generateRandomIndices(int c, int size, BitTripleResourcePool resourcePool, BytePrg jointSampler) {\n+      SecureRandom random = ExceptionConverter.safe(\n+          () -> SecureRandom.getInstance(\"SHA1PRNG\"),\n+          \"Configuration error, SHA1PRNG is needed for BitTriple\");\n+      StrictBitVector v = jointSampler.getNext(resourcePool.getPrgSeedBitLength());\n+      random.setSeed(v.toByteArray());\n+\n+      StrictBitVector strictBitVector = new StrictBitVector(size);\n+      return setBits(strictBitVector, random, c);\n+  }\n+\n+  /**\n+   * Sets c bits in the given vector that was previously not set.\n+   *\n+   * @param vector vector\n+   * @param random random\n+   * @param c number of bits to be set\n+   * @return The vector with c new bits set.\n+   */\n+  public static StrictBitVector setBits(StrictBitVector vector, Random random, int c) {\n+    if (c <= 0) {\n+      return vector;\n+    }\n+    int index = random.nextInt(vector.getSize());\n+    if (vector.getBit(index, false)) {\n+      return setBits(vector, random, c);\n+    } else {\n+      vector.setBit(index, true, false);\n+      return setBits(vector, random, c - 1);\n+    }\n+  }\n+}"
  },
  {
    "sha": "7da08bc79f7df6765a6fbf3fc6ce193635e6ebb0",
    "filename": "tools/bitTriples/src/test/java/dk/alexandra/fresco/tools/bitTriples/BitTripleResourcePoolImplTest.java",
    "status": "added",
    "additions": 18,
    "deletions": 0,
    "changes": 18,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/test/java/dk/alexandra/fresco/tools/bitTriples/BitTripleResourcePoolImplTest.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/test/java/dk/alexandra/fresco/tools/bitTriples/BitTripleResourcePoolImplTest.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/test/java/dk/alexandra/fresco/tools/bitTriples/BitTripleResourcePoolImplTest.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,18 @@\n+package dk.alexandra.fresco.tools.bitTriples;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.mock;\n+\n+import dk.alexandra.fresco.framework.network.Network;\n+import dk.alexandra.fresco.framework.util.Drbg;\n+import dk.alexandra.fresco.framework.util.StrictBitVector;\n+import org.junit.Test;\n+\n+public class BitTripleResourcePoolImplTest {\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void createCote() {\n+        BitTripleResourcePoolImpl impl = new BitTripleResourcePoolImpl(1,2,3,mock(Drbg.class), mock(BitTripleSecurityParameters.class));\n+        impl.createCote(1,mock(Network.class),new StrictBitVector(8));\n+    }\n+}"
  },
  {
    "sha": "3eb72c799f945f75edd6f78a73cae0fb5101931e",
    "filename": "tools/bitTriples/src/test/java/dk/alexandra/fresco/tools/bitTriples/BitTripleTest.java",
    "status": "added",
    "additions": 62,
    "deletions": 0,
    "changes": 62,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/test/java/dk/alexandra/fresco/tools/bitTriples/BitTripleTest.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/test/java/dk/alexandra/fresco/tools/bitTriples/BitTripleTest.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/test/java/dk/alexandra/fresco/tools/bitTriples/BitTripleTest.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,62 @@\n+package dk.alexandra.fresco.tools.bitTriples;\n+\n+import dk.alexandra.fresco.tools.bitTriples.elements.MultiplicationTriple;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import org.junit.Test;\n+\n+public class BitTripleTest extends NetworkedTest{\n+\n+\n+    private List<MultiplicationTriple> runBitTriple(BitTriplesTestContext ctx){\n+    BitTriple bitTriple =\n+        new BitTriple(\n+            ctx.getResourcePool(),\n+            ctx.getNetwork(),\n+            ctx.getResourcePool().getLocalSampler().getNext(ctx.getComputationalSecurityBitParameter()),\n+            ctx.getResourcePool().getLocalSampler().getNext(ctx.getComputationalSecurityBitParameter()));\n+        return  bitTriple.getTriples(1024);\n+    }\n+\n+    private List<MultiplicationTriple> runBitTripleRealisticParameters(BitTriplesTestContext ctx){\n+    BitTriple bitTriple =\n+        new BitTriple(\n+            ctx.getResourcePool(),\n+            ctx.getNetwork(),\n+            ctx.getResourcePool().getLocalSampler().getNext(ctx.getComputationalSecurityBitParameter()),\n+            ctx.getResourcePool().getLocalSampler().getNext(ctx.getComputationalSecurityBitParameter()));\n+        return  bitTriple.getTriples(1024);\n+    }\n+\n+    @Test\n+    public void getTriplesTwoParties() {\n+        initContexts(2);\n+        List<Callable<List<MultiplicationTriple>>> tasks = new ArrayList<>();\n+        tasks.add(() -> runBitTriple(contexts.get(1)));\n+        tasks.add(() -> runBitTriple(contexts.get(2)));\n+\n+        testRuntime.runPerPartyTasks(tasks);\n+    }\n+\n+    @Test\n+    public void getTriplesTwoPartiesRealisticParameters() {\n+        initContexts(2, new BitTripleSecurityParameters());\n+        List<Callable<List<MultiplicationTriple>>> tasks = new ArrayList<>();\n+        tasks.add(() -> runBitTriple(contexts.get(1)));\n+        tasks.add(() -> runBitTriple(contexts.get(2)));\n+\n+        testRuntime.runPerPartyTasks(tasks);\n+    }\n+\n+    @Test\n+    public void getTriplesThreeParties() {\n+        initContexts(3);\n+        List<Callable<List<MultiplicationTriple>>> tasks = new ArrayList<>();\n+        tasks.add(() -> runBitTriple(contexts.get(1)));\n+        tasks.add(() -> runBitTriple(contexts.get(2)));\n+        tasks.add(() -> runBitTriple(contexts.get(3)));\n+\n+        testRuntime.runPerPartyTasks(tasks);\n+    }\n+}"
  },
  {
    "sha": "188ba542a42d1333c9b850723beaed4cab481c6b",
    "filename": "tools/bitTriples/src/test/java/dk/alexandra/fresco/tools/bitTriples/BitTriplesTestContext.java",
    "status": "added",
    "additions": 70,
    "deletions": 0,
    "changes": 70,
    "blob_url": "https://github.com/aicis/fresco/blob/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/test/java/dk/alexandra/fresco/tools/bitTriples/BitTriplesTestContext.java",
    "raw_url": "https://github.com/aicis/fresco/raw/69bc3962293db50424c815b14523615def7c9502/tools/bitTriples/src/test/java/dk/alexandra/fresco/tools/bitTriples/BitTriplesTestContext.java",
    "contents_url": "https://api.github.com/repos/aicis/fresco/contents/tools/bitTriples/src/test/java/dk/alexandra/fresco/tools/bitTriples/BitTriplesTestContext.java?ref=69bc3962293db50424c815b14523615def7c9502",
    "patch": "@@ -0,0 +1,70 @@\n+package dk.alexandra.fresco.tools.bitTriples;\n+\n+import dk.alexandra.fresco.framework.Party;\n+import dk.alexandra.fresco.framework.configuration.NetworkConfiguration;\n+import dk.alexandra.fresco.framework.configuration.NetworkConfigurationImpl;\n+import dk.alexandra.fresco.framework.network.Network;\n+import dk.alexandra.fresco.framework.network.socket.SocketNetwork;\n+import dk.alexandra.fresco.framework.util.AesCtrDrbgFactory;\n+import dk.alexandra.fresco.framework.util.Drbg;\n+import dk.alexandra.fresco.tools.ot.base.DummyOt;\n+import dk.alexandra.fresco.tools.ot.base.Ot;\n+import dk.alexandra.fresco.tools.ot.otextension.RotList;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+\n+/**\n+ * Context for a single party to participate in networked test. Holds a resource pool and network.\n+ */\n+public class BitTriplesTestContext {\n+\n+  private final BitTripleResourcePool resourcePool;\n+  private final Network network;\n+\n+  /**\n+   * Creates new test context.\n+   */\n+  public BitTriplesTestContext(int myId, int noOfParties, int instanceId,\n+      BitTripleSecurityParameters securityParameters) {\n+    this.network = new SocketNetwork(defaultNetworkConfiguration(myId, noOfParties));\n+    byte[] drbgSeed = new byte[securityParameters.getPrgSeedBitLength() / 8];\n+    new Random(myId).nextBytes(drbgSeed); // Parties need to have same seed.\n+    Drbg drbg = AesCtrDrbgFactory.fromDerivedSeed(drbgSeed);\n+    this.resourcePool = new BitTripleResourcePoolImpl(myId, noOfParties, instanceId, drbg,\n+        securityParameters);\n+  }\n+\n+  public BitTripleResourcePool getResourcePool() {\n+    return resourcePool;\n+  }\n+\n+  public int getMyId() {\n+    return resourcePool.getMyId();\n+  }\n+\n+  public int getNoOfParties() {\n+    return resourcePool.getNoOfParties();\n+  }\n+\n+  public int getPrgSeedLength() {\n+    return resourcePool.getPrgSeedBitLength();\n+  }\n+  public int getComputationalSecurityBitParameter() {\n+    return resourcePool.getComputationalSecurityBitParameter();\n+  }\n+\n+  public Network getNetwork() {\n+    return network;\n+  }\n+\n+  private static NetworkConfiguration defaultNetworkConfiguration(int myId,\n+      int noOfParties) {\n+    Map<Integer, Party> parties = new HashMap<>();\n+    for (int partyId = 1; partyId <= noOfParties; partyId++) {\n+      parties.put(partyId, new Party(partyId, \"localhost\", 8000 + partyId));\n+    }\n+    return new NetworkConfigurationImpl(myId, parties);\n+  }\n+\n+}"
  }
]
