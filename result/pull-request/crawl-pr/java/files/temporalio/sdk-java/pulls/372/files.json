[
  {
    "sha": "10a59fc8e5bdeb308dcde43068767b4db98785b3",
    "filename": "temporal-sdk/src/main/java/io/temporal/activity/Activity.java",
    "status": "modified",
    "additions": 23,
    "deletions": 210,
    "changes": 233,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/c424064d011ad2aba5ce09347216cdedb5db9fdd/temporal-sdk/src/main/java/io/temporal/activity/Activity.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/c424064d011ad2aba5ce09347216cdedb5db9fdd/temporal-sdk/src/main/java/io/temporal/activity/Activity.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/main/java/io/temporal/activity/Activity.java?ref=c424064d011ad2aba5ce09347216cdedb5db9fdd",
    "patch": "@@ -17,6 +17,9 @@\n  *  permissions and limitations under the License.\n  */\n \n+/**\n+ * @package io.temporal.activity\n+ */\n package io.temporal.activity;\n \n import io.temporal.common.converter.DataConverter;\n@@ -26,230 +29,40 @@\n import io.temporal.internal.sync.WorkflowInternal;\n \n /**\n- * An activity is the implementation of a particular task in the business logic.\n- *\n- * <h2>Activity Interface</h2>\n- *\n- * <p>Activities are defined as methods of a plain Java interface annotated with {@literal @}{@link\n- * ActivityInterface}. Each method defines a single activity type. A single workflow can use more\n- * than one activity interface and call more than one activity method from the same interface. The\n- * only requirement is that activity method arguments and return values are serializable to a byte\n- * array using the provided {@link io.temporal.common.converter.DataConverter} implementation. The\n- * default implementation uses JSON serializer, but an alternative implementation can be configured\n- * through {@link io.temporal.client.WorkflowClientOptions.Builder#setDataConverter(DataConverter)}.\n- *\n- * <p>Example of an interface that defines four activities:\n- *\n- * <pre><code>\n- * {@literal @}ActivityInterface\n- * public interface FileProcessingActivities {\n- *\n- *     void upload(String bucketName, String localName, String targetName);\n- *\n- *     String download(String bucketName, String remoteName);\n- *\n- *     {@literal @}ActivityMethod(name = \"Transcode\")\n- *     String processFile(String localName);\n- *\n- *     void deleteLocalFile(String fileName);\n- * }\n- *\n- * </code></pre>\n- *\n- * An optional {@literal @}{@link ActivityMethod} annotation can be used to specify activity name.\n- * By default the method name with the first letter capitalized is used as an activity name. So the\n- * above interface defines the following activities: \"Upload\", \"Download\", \"Transcode\" and\n- * \"DeleteLocalFile\".\n- *\n- * <h2>Activity Implementation</h2>\n- *\n- * <p>Activity implementation is an implementation of an activity interface. A single instance of\n- * the activity's implementation is shared across multiple simultaneous activity invocations.\n- * Therefore, the activity implementation code must be <i>thread safe</i>.\n- *\n- * <p>The values passed to activities through invocation parameters or returned through a result\n- * value are recorded in the execution history. The entire execution history is transferred from the\n- * Temporal service to workflow workers when a workflow state needs to recover. A large execution\n- * history can thus adversely impact the performance of your workflow. Therefore, be mindful of the\n- * amount of data you transfer via activity invocation parameters or return values. Other than that,\n- * no additional limitations exist on activity implementations.\n- *\n- * <pre><code>\n- * public class FileProcessingActivitiesImpl implements FileProcessingActivities {\n- *\n- *     private final AmazonS3 s3Client;\n- *\n- *     private final String localDirectory;\n- *\n- *     void upload(String bucketName, String localName, String targetName) {\n- *         File f = new File(localName);\n- *         s3Client.putObject(bucket, remoteName, f);\n- *     }\n- *\n- *     String download(String bucketName, String remoteName, String localName) {\n- *         // Implementation omitted for brevity.\n- *         return downloadFileFromS3(bucketName, remoteName, localDirectory + localName);\n- *     }\n- *\n- *     String processFile(String localName) {\n- *         // Implementation omitted for brevity.\n- *         return compressFile(localName);\n- *     }\n- *\n- *     void deleteLocalFile(String fileName) {\n- *         File f = new File(localDirectory + fileName);\n- *         f.delete();\n- *     }\n- * }\n- * </code></pre>\n- *\n- * <h3>Accessing Activity Info</h3>\n- *\n- * <p>The {@link Activity#getExecutionContext()} returns {@link ActivityExecutionContext} which\n- * provides static getters to access information about the workflow that invoked it. Note that the\n- * activity context information is stored in a thread-local variable. Therefore, calls to {@link\n- * Activity#getExecutionContext()} succeeds only in the thread that invoked the activity function.\n- *\n- * <pre><code>\n- * public class FileProcessingActivitiesImpl implements FileProcessingActivities {\n- *\n- *      {@literal @}Override\n- *      public String download(String bucketName, String remoteName, String localName) {\n- *         ActivityExecutionContext ctx = Activity.getExecutionContext();\n- *         ActivityInfo info = ctx.getInfo();\n- *         log.info(\"namespace=\" +  info.getActivityNamespace());\n- *         log.info(\"workflowId=\" + info.getWorkflowId());\n- *         log.info(\"runId=\" + info.getRunId());\n- *         log.info(\"activityId=\" + info.getActivityId());\n- *         log.info(\"activityTimeout=\" + info.getStartToCloseTimeoutSeconds());\n- *         return downloadFileFromS3(bucketName, remoteName, localDirectory + localName);\n- *      }\n- *      ...\n- *  }\n- * </code></pre>\n- *\n- * <h3>Asynchronous Activity Completion</h3>\n- *\n- * <p>Sometimes an activity lifecycle goes beyond a synchronous method invocation. For example, a\n- * request can be put in a queue and later a reply comes and is picked up by a different worker\n- * process. The whole request-reply interaction can be modeled as a single Temporal activity.\n- *\n- * <p>To indicate that an activity should not be completed upon its method return, call {@link\n- * ActivityExecutionContext#doNotCompleteOnReturn()} from the original activity thread. Then later,\n- * when replies come, complete the activity using {@link\n- * io.temporal.client.ActivityCompletionClient}. To correlate activity invocation with completion\n- * use either {@code TaskToken} or workflow and activity IDs.\n- *\n- * <pre><code>\n- * public class FileProcessingActivitiesImpl implements FileProcessingActivities {\n- *\n- *      public String download(String bucketName, String remoteName, String localName) {\n- *          ActivityExecutionContext ctx = Activity.getExecutionContext();\n- *          byte[] taskToken = ctx.getInfo().getTaskToken(); // Used to correlate reply\n- *          asyncDownloadFileFromS3(taskToken, bucketName, remoteName, localDirectory + localName);\n- *          ctx.doNotCompleteOnReturn();\n- *          return \"ignored\"; // Return value is ignored when doNotCompleteOnReturn was called.\n- *      }\n- *      ...\n- * }\n- * </code></pre>\n- *\n- * When the download is complete, the download service potentially calls back from a different\n- * process:\n- *\n- * <pre><code>\n- *     public <R> void completeActivity(byte[] taskToken, R result) {\n- *         completionClient.complete(taskToken, result);\n- *     }\n- *\n- *     public void failActivity(byte[] taskToken, Exception failure) {\n- *         completionClient.completeExceptionally(taskToken, failure);\n- *     }\n- * </code></pre>\n- *\n- * <h3>Activity Heartbeating</h3>\n- *\n- * <p>Some activities are long running. To react to their crashes quickly, use a heartbeat\n- * mechanism. Use the {@link ActivityExecutionContext#heartbeat(Object)} function to let the\n- * Temporal service know that the activity is still alive. You can piggyback `details` on an\n- * activity heartbeat. If an activity times out, the last value of `details` is included in the\n- * ActivityTimeoutException delivered to a workflow. Then the workflow can pass the details to the\n- * next activity invocation. This acts as a periodic checkpointing mechanism of an activity's\n- * progress.\n- *\n- * <pre><code>\n- * public class FileProcessingActivitiesImpl implements FileProcessingActivities {\n- *\n- *      {@literal @}Override\n- *      public String download(String bucketName, String remoteName, String localName) {\n- *         InputStream inputStream = openInputStream(file);\n- *         try {\n- *             byte[] bytes = new byte[MAX_BUFFER_SIZE];\n- *             while ((read = inputStream.read(bytes)) != -1) {\n- *                 totalRead += read;\n- *                 f.write(bytes, 0, read);\n- *                 // Let the service know about the download progress.\n- *                 Activity.getExecutionContext().heartbeat(totalRead);\n- *             }\n- *         }finally{\n- *             inputStream.close();\n- *         }\n- *      }\n- *      ...\n- * }\n- * </code></pre>\n- *\n- * @see io.temporal.worker.Worker\n- * @see io.temporal.workflow.Workflow\n- * @see io.temporal.client.WorkflowClient\n+ * @entity Activity\n+ * @entity.type Class\n+ * @entity.headline Defines Activity objects\n+ * @entity.description This class defines the non-deterministic business logic methods that\n+ * are defined by the {@link ActivityInterface} annotation.\n  */\n public final class Activity {\n \n   /**\n-   * Activity execution context. It can be used to get information about activity invocation as well\n-   * for heartbeating.\n-   *\n-   * <p>Note: This static method relies on a thread local and works only in the original activity\n+   * @feature getExecutionContext\n+   * @feature.headline Get the ActvityExecutionContext of the Activity\n+   * @feature.description Used to get information about the Activity invocation.\n+   * And can be used for Activity Heartbeats.\n+   * This static method relies on a local thread and only works in the original Activity\n    * thread.\n+   * @feature.type Method\n+   * @feature.return {@link ActivityExecutionContext}\n    */\n   public static ActivityExecutionContext getExecutionContext() {\n     return ActivityInternal.getExecutionContext();\n   }\n \n-  /**\n-   * If there is a need to return a checked exception from an activity do not add the exception to a\n-   * method signature but rethrow it using this method. The library code will unwrap it\n-   * automatically when propagating exception to the caller. There is no need to wrap unchecked\n-   * exceptions, but it is safe to call this method on them.\n-   *\n-   * <p>The reason for such design is that returning originally thrown exception from a remote call\n-   * (which child workflow and activity invocations are ) would not allow adding context information\n-   * about a failure, like activity and child workflow id. So stubs always throw a subclass of\n-   * {@link ActivityFailure} from calls to an activity and subclass of {@link ChildWorkflowFailure}\n-   * from calls to a child workflow. The original exception is attached as a cause to these wrapper\n-   * exceptions. So as exceptions are always wrapped adding checked ones to method signature causes\n-   * more pain than benefit.\n-   *\n-   * <p>Throws original exception if e is {@link RuntimeException} or {@link Error}. Never returns.\n-   * But return type is not empty to be able to use it as:\n-   *\n-   * <pre>\n-   * try {\n-   *     return someCall();\n-   * } catch (Exception e) {\n-   *     throw Activity.wrap(e);\n-   * }\n-   * </pre>\n-   *\n-   * If wrap returned void it wouldn't be possible to write <code>\n-   * throw Activity.wrap</code> and compiler would complain about missing return.\n-   *\n-   * @return never returns as always throws.\n+  /*\n+   * @feature wrap\n+   * @feature.type Method\n+   * @feature.headline Throws a wrapped error\n+   * @feature.throws Throwable error\n+   * feature.return never returns as always throws.\n+   * @feature.description Throws original exception if e is {@link RuntimeException} or {@link Error}\n    */\n   public static RuntimeException wrap(Throwable e) {\n     return WorkflowInternal.wrap(e);\n   }\n-\n+  \n   /** Prohibit instantiation */\n   private Activity() {}\n }"
  },
  {
    "sha": "829be14321d8b477daa84be505a690d691429ec4",
    "filename": "temporal-sdk/src/main/java/io/temporal/activity/ActivityCancellationType.java",
    "status": "modified",
    "additions": 30,
    "deletions": 8,
    "changes": 38,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/c424064d011ad2aba5ce09347216cdedb5db9fdd/temporal-sdk/src/main/java/io/temporal/activity/ActivityCancellationType.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/c424064d011ad2aba5ce09347216cdedb5db9fdd/temporal-sdk/src/main/java/io/temporal/activity/ActivityCancellationType.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/main/java/io/temporal/activity/ActivityCancellationType.java?ref=c424064d011ad2aba5ce09347216cdedb5db9fdd",
    "patch": "@@ -17,29 +17,51 @@\n  *  permissions and limitations under the License.\n  */\n \n+/**\n+ * @package io.temporal.activity\n+ */\n package io.temporal.activity;\n \n import io.temporal.failure.CanceledFailure;\n import io.temporal.workflow.CancellationScope;\n \n /**\n- * Defines behaviour of the parent workflow when {@link CancellationScope} that wraps child workflow\n- * execution request is canceled. The result of the cancellation independently of the type is a\n- * {@link CanceledFailure} thrown from the child workflow method.\n+ * @entity ActivityCancellationType\n+ * @entity.type Enum\n+ * @entity.headline Defines behavior of the cancellation\n+ * @entity.description Defines behavior of the parent Workflow when {@link CancellationScope},\n+ * that wraps the child Workflow execution request, is canceled.\n+ * The result of the cancellation, independent of the type, is {@link CanceledFailure}\n+ * which is thrown from the child Workflow method.\n  */\n public enum ActivityCancellationType {\n+\n   /**\n-   * Wait for activity cancellation completion. Note that activity must heartbeat to receive a\n-   * cancellation notification. This can block the cancellation for a long time if activity doesn't\n+   * @feature WAIT_CANCELLATION_COMPLETED\n+   * @feature.type Value\n+   * @feature.headline Wait for Activity cancellation completion\n+   * @feature.description Use this to wait for an Activity cancellation to be completed.\n+   * The Activity must heartbeat to receive a cancellation notification.\n+   * This can block the cancellation for a long time if the Activity doesn't\n    * heartbeat or chooses to ignore the cancellation request.\n    */\n   WAIT_CANCELLATION_COMPLETED,\n \n-  /** Initiate a cancellation request and immediately report cancellation to the workflow. */\n+  /**\n+   * @feature TRY_CANCEL\n+   * @feature.type Value\n+   * @feature.headline Initiates a cancellation request\n+   * @feature.description Initiates a cancellation request\n+   * and immediately reports cancellation to the Workflow.\n+   */\n   TRY_CANCEL,\n-\n+  \n   /**\n-   * Do not request cancellation of the activity and immediately report cancellation to the workflow\n+   * @feature ABANDON\n+   * @feature.type Value\n+   * @feature.headline Does not initiate a cancellation\n+   * @feature.description  Does not initiate a cancellation of the Activity,\n+   * but immediately report cancellation to the Workflow.\n    */\n   ABANDON,\n }"
  },
  {
    "sha": "961c3808f159df0b5da17c4549f99c13d6675b16",
    "filename": "temporal-sdk/src/main/java/io/temporal/activity/ActivityExecutionContext.java",
    "status": "modified",
    "additions": 94,
    "deletions": 50,
    "changes": 144,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/c424064d011ad2aba5ce09347216cdedb5db9fdd/temporal-sdk/src/main/java/io/temporal/activity/ActivityExecutionContext.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/c424064d011ad2aba5ce09347216cdedb5db9fdd/temporal-sdk/src/main/java/io/temporal/activity/ActivityExecutionContext.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/main/java/io/temporal/activity/ActivityExecutionContext.java?ref=c424064d011ad2aba5ce09347216cdedb5db9fdd",
    "patch": "@@ -17,6 +17,9 @@\n  *  permissions and limitations under the License.\n  */\n \n+/**\n+ * @package io.temporal.activity\n+ */\n package io.temporal.activity;\n \n import com.uber.m3.tally.Scope;\n@@ -26,93 +29,134 @@\n import java.util.Optional;\n \n /**\n- * Context object passed to an activity implementation. Use {@link Activity#getExecutionContext()}\n- * from an activity implementation to access.\n- *\n- * @author fateev\n+ * @entity ActivityExecutionContext\n+ * @entity.type Interface\n+ * @entity.headline Context object passed to an Activity implementation\n+ * @entity.description Use {@link Activity.getExecutionContext}\n+ * from an Activity implementation to access.\n  */\n public interface ActivityExecutionContext {\n \n-  /** Information about activity invocation and the caller workflow */\n+  /**\n+   * @feature getInfo\n+   * @feature.type Method\n+   * @feature.headline Get Information about an Activity\n+   * @feature.description Implementations of this interface can be used to retrieve information\n+   * about the Activity invocation and the calling Workflow.\n+   * @feature.returns {@link ActivityInfo}\n+   */\n   ActivityInfo getInfo();\n \n   /**\n-   * Use to notify Simple Workflow that activity execution is alive.\n-   *\n-   * @param details In case of activity timeout details are returned as a field of the exception\n-   *     thrown.\n-   * @throws ActivityCompletionException Indicates that activity cancellation was requested by the\n-   *     workflow or any other reason for activity to stop execution. Should be rethrown from\n-   *     activity implementation to indicate successful cancellation.\n+   * @feature heartbeat\n+   * @feature.type Method\n+   * @feature.headline Use to notify simple Workflow that an Activity execution is alive\n+   * @feature.description\n+   * @feature.param Any Details in case of Activity timeout, details are returned\n+   * as a field of the exception that is thrown.\n+   * @feature.throws ActivityCompletionException Indicates that Activity cancellation\n+   * was requested by the Workflow, or there is another reason for the Activity to stop execution.\n+   * Should be rethrown from Activity implementation to indicate a successful cancellation.\n    */\n   <V> void heartbeat(V details) throws ActivityCompletionException;\n \n   /**\n-   * Extracts heartbeat details from the last failed attempt. This is used in combination with retry\n-   * options. An activity could be scheduled with an optional {@link\n-   * io.temporal.common.RetryOptions} on {@link io.temporal.activity.ActivityOptions}. If an\n-   * activity failed then the server would attempt to dispatch another activity task to retry\n-   * according to the retry options. If there was heartbeat details reported by the activity from\n-   * the failed attempt, the details would be delivered along with the activity task for the retry\n-   * attempt. The activity could extract the details by {@link #getHeartbeatDetails(Class)}() and\n-   * resume from the progress.\n-   *\n-   * @param detailsClass type of the heartbeat details\n+   * @feature getHeartbeatDetails\n+   * @feature.type Method\n+   * @feature.headline Extracts heartbeat details from the last failed attempt.\n+   * @feature.description This is used in combination with retry options.\n+   * An Activity could be scheduled with optional {@link RetryOptions} via {@link ActivityOptions}.\n+   * If an Activity failed then the server would attempt to dispatch another Activity task to retry\n+   * according to the retry options. If there was heartbeat details reported by the Activity from\n+   * the failed attempt, the details would be delivered along with the Activity task for the retry\n+   * attempt. The Activity could extract the details via this method and resume from the progress.\n+   * @feature.param Class Class of the heartbeat details\n+   * @feature.param Type Optional. Type of the heartbeat details\n    */\n   <V> Optional<V> getHeartbeatDetails(Class<V> detailsClass);\n \n   /**\n-   * Extracts heartbeat details from the last failed attempt. This is used in combination with retry\n-   * options. An activity could be scheduled with an optional {@link\n+   * Extracts heartbeat details from the last failed attempt.\n+   * This is used in combination with retry options.\n+   * An Activity could be scheduled with an optional {@link\n    * io.temporal.common.RetryOptions} on {@link io.temporal.activity.ActivityOptions}. If an\n-   * activity failed then the server would attempt to dispatch another activity task to retry\n-   * according to the retry options. If there was heartbeat details reported by the activity from\n-   * the failed attempt, the details would be delivered along with the activity task for the retry\n-   * attempt. The activity could extract the details by {@link #getHeartbeatDetails(Class)}() and\n+   * Activity failed then the server would attempt to dispatch another Activity task to retry\n+   * according to the retry options. If there was heartbeat details reported by the Activity from\n+   * the failed attempt, the details would be delivered along with the Activity task for the retry\n+   * attempt. The Activity could extract the details by {@link #getHeartbeatDetails(Class)}() and\n    * resume from the progress.\n    *\n    * @param detailsClass type of the heartbeat details\n    */\n   <V> Optional<V> getHeartbeatDetails(Class<V> detailsClass, Type detailsType);\n \n   /**\n-   * A correlation token that can be used to complete the activity asynchronously through {@link\n-   * io.temporal.client.ActivityCompletionClient#complete(byte[], Object)}.\n+   * @feature getTaskToken\n+   * @feature.type Method\n+   * @feature.headline A correlation token\n+   * @feature.description The token can be used to complete an Activity asynchronously\n+   * via {@link ActivityCompletionClient.complete}.\n+   * @feature.return byte[]\n    */\n   byte[] getTaskToken();\n \n   /**\n-   * If this method is called during an activity execution then activity is not going to complete\n-   * when its method returns. It is expected to be completed asynchronously using {@link\n-   * io.temporal.client.ActivityCompletionClient}. Note that async activities that have {@link\n-   * #isUseLocalManualCompletion()} set to false would not respect the limit defined by {@link\n-   * WorkerOptions#getMaxConcurrentActivityExecutionSize()}. If you want to limit the number of\n-   * concurrent async activities and if you always complete those activities from the same activity\n-   * worker you should use {@link #useLocalManualCompletion()} instead.\n+   * @feature doNotCompleteOnReturn\n+   * @feature.type Method\n+   * @feature.headline Activity will not complete when it returns\n+   * @feature.description If this method is called during an Activity execution,\n+   * then Activity is not going to complete when its method returns.\n+   * It is expected to be completed asynchronously using the {@link ActivityCompletionClient}.\n+   * Async Activities that have {@link ActivityExecutionContext.isUseLocalManualCompletion} set to false\n+   * would not respect the limit defined by {@link WorkerOptions.getMaxConcurrentActivityExecutionSize}.\n+   * If you want to limit the number of concurrent async Activities\n+   * and if you always complete those Activities from the same Activity Worker\n+   * you should use {@link ActivityExecutionContext.useLocalManualCompletion} instead.\n+   * @feature.return Void\n    */\n   void doNotCompleteOnReturn();\n \n+  /**\n+   * @feature isDoNotCompleteOnReturn\n+   * @feature.type Method\n+   * @feature.headline Returns true if {@link ActivityExecutionContext.doNotCompleteOnReturn} has been called\n+   * @feature.return boolean\n+   */\n   boolean isDoNotCompleteOnReturn();\n \n   /**\n-   * Returns true if {@link #useLocalManualCompletion()} method has been called on this context. If\n-   * this flag is set to true, {@link io.temporal.internal.worker.ActivityWorker} would not release\n-   * concurrency semaphore and delegate release function to the manual activity client returned by\n-   * {@link #useLocalManualCompletion()}\n+   * @feature isUseLocalManualCompletion\n+   * @feature.type Method\n+   * @feature.headline Returns true if {@link ActivityExecutionContext.useLocalManualCompletion} method has been called on this context\n+   * @feature.description . If this flag is set to true, {@link ActivityWorker} would not release\n+   * concurrency semaphore and delegate the release function to the manual Activity client returned by\n+   * {@link ActivityExecutionContext.useLocalManualCompletion}\n+   * @feature.return boolean\n    */\n   boolean isUseLocalManualCompletion();\n \n   /**\n-   * Local manual completion, sets {@link #doNotCompleteOnReturn()} flag making activity completion\n-   * asynchronous, also returns completion client. Returned completion client must be used to\n-   * complete the activity on the same machine. Main difference from calling {@link\n-   * #doNotCompleteOnReturn()} directly is that by using this method maximum number of concurrent\n-   * activities defined by {@link WorkerOptions#getMaxConcurrentActivityExecutionSize()} will be\n-   * respected. Users must be careful and always call completion method on the {@link\n-   * ManualActivityCompletionClient} otherwise activity worker could stop polling new work as it\n-   * will consider all activities that didn't explicitly finish as still running.\n+   * @feature useLocalManualCompletion\n+   * @feature.type Method\n+   * @feature.headline Local manual completion\n+   * @feature.description Sets {@link ActivityExecutionContext.doNotCompleteOnReturn} flag\n+   * making Activity completion asynchronous. It also returns the completion client.\n+   * Returned completion client must be used to complete the Activity on the same machine.\n+   * Main difference from calling {@link ActivityExecutionContext.doNotCompleteOnReturn()} directly\n+   * is that by using this method the maximum number of concurrent Activities defined by\n+   * {@link WorkerOptions.getMaxConcurrentActivityExecutionSize} will be respected.\n+   * Users must be careful and always call completion method on the {@link ManualActivityCompletionClient}\n+   * otherwise Activity Worker could stop polling new Tasks as it will consider all Activities\n+   * that didn't explicitly finish as still running.\n+   * @feature.return {@link ManualActivityCompletionClient}\n    */\n   ManualActivityCompletionClient useLocalManualCompletion();\n-\n+  \n+  /**\n+   * @feature getMetricsScope\n+   * @feature.type Method\n+   * @feature.headline Gets the metrics scope\n+   * @feature.return com.uber.m3.tally.Scope\n+   */\n   Scope getMetricsScope();\n }"
  },
  {
    "sha": "c7824c646ea5e9c7158fc5d7916679bc1ba914de",
    "filename": "temporal-sdk/src/main/java/io/temporal/activity/ActivityInfo.java",
    "status": "modified",
    "additions": 95,
    "deletions": 14,
    "changes": 109,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/c424064d011ad2aba5ce09347216cdedb5db9fdd/temporal-sdk/src/main/java/io/temporal/activity/ActivityInfo.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/c424064d011ad2aba5ce09347216cdedb5db9fdd/temporal-sdk/src/main/java/io/temporal/activity/ActivityInfo.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/main/java/io/temporal/activity/ActivityInfo.java?ref=c424064d011ad2aba5ce09347216cdedb5db9fdd",
    "patch": "@@ -17,63 +17,144 @@\n  *  permissions and limitations under the License.\n  */\n \n+/**\n+ * @package io.temporal.activity\n+ */\n package io.temporal.activity;\n \n import io.temporal.api.common.v1.Payloads;\n import java.time.Duration;\n import java.util.Optional;\n \n /**\n- * The information about the activity task that the current activity is handling. Use {@link\n- * ActivityExecutionContext#getInfo()} to access.\n+ * @entity ActivityInfo\n+ * @entity.type Interface\n+ * @entity.headline Information about the Activity Task\n+ * @entity.description Information about the Activity Task that the current Activity is handling.\n+ * Use {@link ActivityExecutionContext.getInfo} to access.\n  */\n public interface ActivityInfo {\n \n   /**\n-   * A correlation token that can be used to complete the activity asynchronously through {@link\n-   * io.temporal.client.ActivityCompletionClient#complete(byte[], Object)}.\n+   * @feature getTaskToken\n+   * @feature.type Method\n+   * @feature.headline Gets a correlation token that can be used to\n+   * complete an Ativity asynchronously via {@link ActivityCompletionClient.complete}\n+   * @feature.return byte[]\n    */\n   byte[] getTaskToken();\n \n-  /** WorkflowId of the workflow that scheduled the activity. */\n+  /**\n+   * @feature getWorkflowId\n+   * @feature.type Method\n+   * @feature.headline WorkflowId of the Workflow that scheduled the Activity\n+   * @feature.return String\n+   */\n   String getWorkflowId();\n \n-  /** RunId of the workflow that scheduled the activity. */\n+  /**\n+   * @feature getRunId\n+   * @feature.type Method\n+   * @feature.headline RunId of the Workflow that scheduled the Activity\n+   * @feature.return String\n+   */\n   String getRunId();\n \n   /**\n-   * ID of the activity. This ID can be used to complete the activity asynchronously through {@link\n-   * io.temporal.client.ActivityCompletionClient#complete(String, Optional, String, Object)}.\n+   * @feature getActivityId\n+   * @feature.type Method\n+   * @feature.headline Id of the Activity\n+   * @feature.description This Id can be used to complete the Activity Asynchronously\n+   * via {@link ActivityCompletionClient.complete}\n+   * @feature.return String\n    */\n   String getActivityId();\n \n-  /** Type of the activity. */\n+  /**\n+   * @feature getActivityType\n+   * @feature.type Method\n+   * @feature.headline Retrieves the Activity type\n+   * @feature.return String\n+   */\n   String getActivityType();\n \n   /**\n-   * Time when the activity was initially scheduled by the workflow.\n-   *\n-   * @return timestamp in milliseconds\n+   * @feature getScheduledTimestamp\n+   * @feature.type Method\n+   * @feature.headline Time of when the Activity was initially scheduled by the Workflow\n+   * @feature.return long Timestamp in milliseconds\n    */\n   long getScheduledTimestamp();\n \n+  /**\n+   * @feature getScheduleToCloseTimeout\n+   * @feature.type Method\n+   * @feature.headline Retrieves the schedule-to-close timeout for the Activity\n+   * @feature.return java.time.Duration\n+   */\n   Duration getScheduleToCloseTimeout();\n \n+  /**\n+   * @feature getStartToCloseTimeout\n+   * @feature.type Method\n+   * @feature.headline Retrieves the start-to-close timeout for the Activity\n+   * @feature.return java.time.Duration\n+   */\n   Duration getStartToCloseTimeout();\n \n+  /**\n+   * @feature getHeartbeatTimeout\n+   * @feature.type Method\n+   * @feature.headline Retrieves the heartbeat timeout for the Activity\n+   * @feature.return java.time.Duration\n+   */\n   Duration getHeartbeatTimeout();\n \n+  /**\n+   * @feature getHeartbeatDetails\n+   * @feature.type Method\n+   * @feature.headline Retrieves the heartbeat details for the Activity\n+   * @feature.return custom payload\n+   */\n   Optional<Payloads> getHeartbeatDetails();\n \n+  /**\n+   * @feature getWorkflowType\n+   * @feature.type Method\n+   * @feature.headline Retrieves the Workflow type that invoked the Activity\n+   * @feature.return String\n+   */\n   String getWorkflowType();\n \n+  /**\n+   * @feature getWorkflowNamespace\n+   * @feature.type Method\n+   * @feature.headline Retrieves the Namespace of the Workflow that invoked the Activity\n+   * @feature.return String\n+   */\n   String getWorkflowNamespace();\n \n+  /**\n+   * @feature getActivityNamespace\n+   * @feature.type Method\n+   * @feature.headline Retrieves the Namespace of the Activity\n+   * @feature.return String\n+   */\n   String getActivityNamespace();\n \n-  /** Activity execution attempt starting from 1. */\n+  /**\n+   * @feature getAttempt\n+   * @feature.type Method\n+   * @feature.headline Activity execution attempt starting from 1\n+   * @feature.return int\n+   */\n   int getAttempt();\n \n-  /** Is this activity invoked as a local activity? */\n+  /**\n+   * @feature isLocal\n+   * @feature.type Method\n+   * @feature.headline Is the Activity invoked as a local Activity?\n+   * @feature.return boolean\n+   */\n   boolean isLocal();\n }"
  },
  {
    "sha": "64278d6f512e32bf568b1b4a799bc7f6e8feb904",
    "filename": "temporal-sdk/src/main/java/io/temporal/activity/ActivityOptions.java",
    "status": "modified",
    "additions": 49,
    "deletions": 10,
    "changes": 59,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/c424064d011ad2aba5ce09347216cdedb5db9fdd/temporal-sdk/src/main/java/io/temporal/activity/ActivityOptions.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/c424064d011ad2aba5ce09347216cdedb5db9fdd/temporal-sdk/src/main/java/io/temporal/activity/ActivityOptions.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/main/java/io/temporal/activity/ActivityOptions.java?ref=c424064d011ad2aba5ce09347216cdedb5db9fdd",
    "patch": "@@ -17,6 +17,9 @@\n  *  permissions and limitations under the License.\n  */\n \n+/**\n+ * @package io.temporal.activity\n+ */\n package io.temporal.activity;\n \n import com.google.common.base.Objects;\n@@ -27,9 +30,24 @@\n import java.time.Duration;\n import java.util.List;\n \n-/** Options used to configure how an activity is invoked. */\n+/**\n+ * @entity ActivityOptions\n+ * @entity.headline Options to configure how an Activity is invoked.\n+ * @entity.description ActivityOptions can be used to configure many aspects of\n+ * how an Activity is executed, such as when to time out, how frequently to retry,\n+ * context propagation, and more.\n+ * @entity.type Class\n+ */\n public final class ActivityOptions {\n \n+  /**\n+   * @feature newBuilder\n+   * @feature.headline newBuilder returns an {@link ActivityOptions.Builder}\n+   * @feature.description This method returns an ActivityOptions Builder that\n+   * can be used to chain together ActivityOption setter methods.\n+   * @feature.type Method\n+   * @feature.param Optional {@link ActivityOptions}\n+   */\n   public static Builder newBuilder() {\n     return new Builder();\n   }\n@@ -47,7 +65,12 @@ public static ActivityOptions getDefaultInstance() {\n   static {\n     DEFAULT_INSTANCE = ActivityOptions.newBuilder().build();\n   }\n-\n+  /**\n+   * @feature Builder\n+   * @feature.headline Builder is used to build the ActivityOptions\n+   * @feature.description Builder is the subclass where options are set.\n+   * @feature.type Class\n+   */\n   public static final class Builder {\n \n     private Duration heartbeatTimeout;\n@@ -83,20 +106,28 @@ private Builder(ActivityOptions options) {\n     }\n \n     /**\n-     * Overall timeout workflow is willing to wait for activity to complete. It includes time in a\n-     * task queue (use {@link #setScheduleToStartTimeout(Duration)} to limit it) plus activity\n-     * execution time (use {@link #setStartToCloseTimeout(Duration)} to limit it). Either this\n-     * option or both schedule to start and start to close are required.\n+     * @feature Builder.setScheduleToCloseTimeout\n+     * @feature.type Method\n+     * @feature.headline Sets the schedule to close timeout\n+     * @feature.description Overall timeout workflow is willing to wait for activity to complete.\n+     * It includes time in a Task Queue (use {@link ActivityOptions.Builder.setScheduleToStartTimeout} to limit it)\n+     * plus activity execution time (use {@link ActivityOptions.Builder.setStartToCloseTimeout} to limit it).\n+     * Either this option or both schedule to start and start to close are required.\n+     * @feature.param Duration Amount of time to wait\n      */\n     public Builder setScheduleToCloseTimeout(Duration scheduleToCloseTimeout) {\n       this.scheduleToCloseTimeout = scheduleToCloseTimeout;\n       return this;\n     }\n \n-    /**\n-     * Time activity can stay in task queue before it is picked up by a worker. If schedule to close\n-     * is not provided then both this and start to close are required.\n-     */\n+     /**\n+      * @feature Builder.setScheduleToStartTimeout\n+      * @feature.type Method\n+      * @feature.headline Sets the schedule to start timeout\n+      * @feature.description Time Activity can stay in Task Queue before it is picked up by a Worker.\n+      * If schedule to close is not provided then both this and start to close are required.\n+      * @feature.param Duration Amount of time to wait\n+      */\n     public Builder setScheduleToStartTimeout(Duration scheduleToStartTimeout) {\n       this.scheduleToStartTimeout = scheduleToStartTimeout;\n       return this;\n@@ -106,6 +137,14 @@ public Builder setScheduleToStartTimeout(Duration scheduleToStartTimeout) {\n      * Maximum activity execution time after it was sent to a worker. If schedule to close is not\n      * provided then both this and schedule to start are required.\n      */\n+    /**\n+     * @feature Builder.setStartToCloseTimeout\n+     * @feature.type Method\n+     * @feature.headline Sets the start to close timeout\n+     * @feature.description Maximum Activity execution time after it was sent to a Worker.\n+     * If schedule to close is not provided then both this and schedule to start are required.\n+     * @feature.param Duration Amount of time to wait\n+     */\n     public Builder setStartToCloseTimeout(Duration startToCloseTimeout) {\n       this.startToCloseTimeout = startToCloseTimeout;\n       return this;"
  },
  {
    "sha": "146dd3ce3a1f0bb1ad24ebce6ec1c9fc03745213",
    "filename": "temporal-sdk/src/main/java/io/temporal/client/WorkflowOptions.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/c424064d011ad2aba5ce09347216cdedb5db9fdd/temporal-sdk/src/main/java/io/temporal/client/WorkflowOptions.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/c424064d011ad2aba5ce09347216cdedb5db9fdd/temporal-sdk/src/main/java/io/temporal/client/WorkflowOptions.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/main/java/io/temporal/client/WorkflowOptions.java?ref=c424064d011ad2aba5ce09347216cdedb5db9fdd",
    "patch": "@@ -17,6 +17,9 @@\n  *  permissions and limitations under the License.\n  */\n \n+/**\n+ * @package io.temporal.client\n+ */\n package io.temporal.client;\n \n import com.google.common.base.Objects;\n@@ -30,6 +33,10 @@\n import java.util.List;\n import java.util.Map;\n \n+/**\n+ * @entity WorkflowOptions\n+ * @entity.type Class\n+ */\n public final class WorkflowOptions {\n \n   public static Builder newBuilder() {"
  }
]
