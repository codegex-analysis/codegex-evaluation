[
  {
    "sha": "dca9a2ffba569b3d4850ad24ccb6f845e28c3a70",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/BinaryChecksumSetWhenTaskCompletedTest.java",
    "status": "added",
    "additions": 97,
    "deletions": 0,
    "changes": 97,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/BinaryChecksumSetWhenTaskCompletedTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/BinaryChecksumSetWhenTaskCompletedTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/BinaryChecksumSetWhenTaskCompletedTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,97 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import io.temporal.activity.ActivityOptions;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryRequest;\n+import io.temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryResponse;\n+import io.temporal.client.WorkflowClient;\n+import io.temporal.client.WorkflowStub;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestOptions;\n+import io.temporal.workflow.shared.TestWorkflows;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class BinaryChecksumSetWhenTaskCompletedTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(SimpleTestWorkflow.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testBinaryChecksumSetWhenTaskCompleted() {\n+    TestWorkflows.TestWorkflow1 client =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(TestWorkflows.TestWorkflow1.class);\n+    WorkflowExecution execution =\n+        WorkflowClient.start(client::execute, testWorkflowRule.getTaskQueue());\n+    WorkflowStub stub = WorkflowStub.fromTyped(client);\n+    SDKTestWorkflowRule.waitForOKQuery(stub);\n+    GetWorkflowExecutionHistoryRequest request =\n+        GetWorkflowExecutionHistoryRequest.newBuilder()\n+            .setNamespace(SDKTestWorkflowRule.NAMESPACE)\n+            .setExecution(execution)\n+            .build();\n+    GetWorkflowExecutionHistoryResponse response =\n+        testWorkflowRule\n+            .getTestEnvironment()\n+            .getWorkflowService()\n+            .blockingStub()\n+            .getWorkflowExecutionHistory(request);\n+\n+    boolean foundCompletedTask = false;\n+    for (HistoryEvent event : response.getHistory().getEventsList()) {\n+      if (event.getEventType() == EventType.EVENT_TYPE_WORKFLOW_TASK_COMPLETED) {\n+        assertEquals(\n+            SDKTestWorkflowRule.BINARY_CHECKSUM,\n+            event.getWorkflowTaskCompletedEventAttributes().getBinaryChecksum());\n+        foundCompletedTask = true;\n+      }\n+    }\n+    assertTrue(foundCompletedTask);\n+  }\n+\n+  public static class SimpleTestWorkflow implements TestWorkflows.TestWorkflow1 {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      TestActivities testActivities =\n+          Workflow.newActivityStub(\n+              TestActivities.class,\n+              ActivityOptions.newBuilder(TestOptions.newActivityOptionsForTaskQueue(taskQueue))\n+                  .build());\n+      testActivities.activity();\n+      return \"done\";\n+    }\n+  }\n+}"
  },
  {
    "sha": "4c4b2048fab1f33709ef842825f2ee818e6774d4",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/ContinueAsNewNoArgsTest.java",
    "status": "added",
    "additions": 79,
    "deletions": 0,
    "changes": 79,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/ContinueAsNewNoArgsTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/ContinueAsNewNoArgsTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/ContinueAsNewNoArgsTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,79 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.testing.TracingWorkerInterceptor;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class ContinueAsNewNoArgsTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestContinueAsNewNoArgsImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .setWorkerInterceptors(\n+              new TracingWorkerInterceptor(new TracingWorkerInterceptor.FilteredTrace()))\n+          .build();\n+\n+  @Test\n+  public void testContinueAsNewNoArgs() {\n+\n+    NoArgsWorkflow client = testWorkflowRule.newWorkflowStubTimeoutOptions(NoArgsWorkflow.class);\n+    String result = client.execute();\n+    Assert.assertEquals(\"done\", result);\n+    testWorkflowRule\n+        .getInterceptor(TracingWorkerInterceptor.class)\n+        .setExpected(\n+            \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+            \"newThread workflow-method\",\n+            \"continueAsNew\",\n+            \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+            \"newThread workflow-method\");\n+  }\n+\n+  @WorkflowInterface\n+  public interface NoArgsWorkflow {\n+    @WorkflowMethod\n+    String execute();\n+  }\n+\n+  public static class TestContinueAsNewNoArgsImpl implements NoArgsWorkflow {\n+\n+    @Override\n+    public String execute() {\n+      NoArgsWorkflow next = Workflow.newContinueAsNewStub(NoArgsWorkflow.class);\n+      WorkflowInfo info = Workflow.getInfo();\n+      if (!info.getContinuedExecutionRunId().isPresent()) {\n+        next.execute();\n+        throw new RuntimeException(\"unreachable\");\n+      } else {\n+        return \"done\";\n+      }\n+    }\n+  }\n+}"
  },
  {
    "sha": "396c915b6f0395485cabbde482794189597f8676",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/ContinueAsNewTest.java",
    "status": "added",
    "additions": 108,
    "deletions": 0,
    "changes": 108,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/ContinueAsNewTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/ContinueAsNewTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/ContinueAsNewTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,108 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import io.temporal.testing.TracingWorkerInterceptor;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class ContinueAsNewTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestContinueAsNewImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .setWorkerInterceptors(\n+              new TracingWorkerInterceptor(new TracingWorkerInterceptor.FilteredTrace()))\n+          .setDoNotStart(true)\n+          .build();\n+\n+  @Test\n+  public void testContinueAsNew() {\n+    String continuedTaskQueue = testWorkflowRule.getTaskQueue() + \"_continued\";\n+    testWorkflowRule.getTestEnvironment().newWorker(continuedTaskQueue);\n+    testWorkflowRule.getTestEnvironment().start();\n+\n+    TestContinueAsNew client =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(TestContinueAsNew.class);\n+    int result = client.execute(4, continuedTaskQueue);\n+    Assert.assertEquals(111, result);\n+    testWorkflowRule\n+        .getInterceptor(TracingWorkerInterceptor.class)\n+        .setExpected(\n+            \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+            \"newThread workflow-method\",\n+            \"continueAsNew\",\n+            \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+            \"newThread workflow-method\",\n+            \"continueAsNew\",\n+            \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+            \"newThread workflow-method\",\n+            \"continueAsNew\",\n+            \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+            \"newThread workflow-method\",\n+            \"continueAsNew\",\n+            \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+            \"newThread workflow-method\");\n+  }\n+\n+  @WorkflowInterface\n+  public interface TestContinueAsNew {\n+\n+    @WorkflowMethod\n+    int execute(int count, String continueAsNewTaskQueue);\n+  }\n+\n+  public static class TestContinueAsNewImpl implements TestContinueAsNew {\n+\n+    @Override\n+    public int execute(int count, String continueAsNewTaskQueue) {\n+      String taskQueue = Workflow.getInfo().getTaskQueue();\n+      if (count == 0) {\n+        assertEquals(continueAsNewTaskQueue, taskQueue);\n+        return 111;\n+      }\n+      Map<String, Object> memo = new HashMap<>();\n+      memo.put(\"myKey\", \"MyValue\");\n+      Map<String, Object> searchAttributes = new HashMap<>();\n+      searchAttributes.put(\"CustomKeywordField\", \"foo1\");\n+      ContinueAsNewOptions options =\n+          ContinueAsNewOptions.newBuilder()\n+              .setTaskQueue(continueAsNewTaskQueue)\n+              .setMemo(memo)\n+              .setSearchAttributes(searchAttributes)\n+              .build();\n+      TestContinueAsNew next = Workflow.newContinueAsNewStub(TestContinueAsNew.class, options);\n+      next.execute(count - 1, continueAsNewTaskQueue);\n+      throw new RuntimeException(\"unreachable\");\n+    }\n+  }\n+}"
  },
  {
    "sha": "d68806a62f6c220f46032f586eef7a50c8e0925b",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/DetachedScopeTest.java",
    "status": "added",
    "additions": 98,
    "deletions": 0,
    "changes": 98,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/DetachedScopeTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/DetachedScopeTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/DetachedScopeTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,98 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import static org.junit.Assert.*;\n+\n+import io.temporal.client.WorkflowFailedException;\n+import io.temporal.client.WorkflowStub;\n+import io.temporal.failure.ActivityFailure;\n+import io.temporal.failure.CanceledFailure;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestOptions;\n+import io.temporal.workflow.shared.TestWorkflows;\n+import java.time.Duration;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class DetachedScopeTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestDetachedCancellationScope.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testDetachedScope() {\n+    WorkflowStub client = testWorkflowRule.newUntypedWorkflowStubTimeoutOptions(\"TestWorkflow1\");\n+    client.start(testWorkflowRule.getTaskQueue());\n+    testWorkflowRule.sleep(Duration.ofMillis(500)); // To let activityWithDelay start.\n+    client.cancel();\n+    try {\n+      client.getResult(String.class);\n+      Assert.fail(\"unreachable\");\n+    } catch (WorkflowFailedException e) {\n+      Assert.assertTrue(e.getCause() instanceof CanceledFailure);\n+    }\n+    activitiesImpl.assertInvocations(\"activityWithDelay\", \"activity1\", \"activity2\", \"activity3\");\n+  }\n+\n+  public static class TestDetachedCancellationScope implements TestWorkflows.TestWorkflow1 {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      TestActivities testActivities =\n+          Workflow.newActivityStub(\n+              TestActivities.class, TestOptions.newActivityOptionsForTaskQueue(taskQueue));\n+      try {\n+        testActivities.activityWithDelay(100000, true);\n+        fail(\"unreachable\");\n+      } catch (ActivityFailure e) {\n+        assertTrue(e.getCause() instanceof CanceledFailure);\n+        Workflow.newDetachedCancellationScope(() -> assertEquals(1, testActivities.activity1(1)))\n+            .run();\n+      }\n+      try {\n+        Workflow.sleep(Duration.ofHours(1));\n+        fail(\"unreachable\");\n+      } catch (CanceledFailure e) {\n+        Workflow.newDetachedCancellationScope(\n+                () -> assertEquals(\"a12\", testActivities.activity2(\"a1\", 2)))\n+            .run();\n+      }\n+      try {\n+        Workflow.newTimer(Duration.ofHours(1)).get();\n+        fail(\"unreachable\");\n+      } catch (CanceledFailure e) {\n+        Workflow.newDetachedCancellationScope(\n+                () -> assertEquals(\"a123\", testActivities.activity3(\"a1\", 2, 3)))\n+            .run();\n+      }\n+      return \"result\";\n+    }\n+  }\n+}"
  },
  {
    "sha": "3ca66f22a1f68d06f00de6736c7e08415394c2db",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/ExceptionPropagationTest.java",
    "status": "added",
    "additions": 204,
    "deletions": 0,
    "changes": 204,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/ExceptionPropagationTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/ExceptionPropagationTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/ExceptionPropagationTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,204 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import static org.junit.Assert.*;\n+\n+import io.temporal.client.WorkflowFailedException;\n+import io.temporal.common.RetryOptions;\n+import io.temporal.failure.ActivityFailure;\n+import io.temporal.failure.ApplicationFailure;\n+import io.temporal.failure.ChildWorkflowFailure;\n+import io.temporal.worker.WorkflowImplementationOptions;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestOptions;\n+import io.temporal.workflow.shared.TestWorkflows;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.time.Duration;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class ExceptionPropagationTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(\n+              WorkflowImplementationOptions.newBuilder()\n+                  .setFailWorkflowExceptionTypes(\n+                      NumberFormatException.class, FileNotFoundException.class)\n+                  .build(),\n+              ThrowingChild.class,\n+              TestExceptionPropagationImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  /**\n+   * Test that an NPE thrown in an activity executed from a child workflow results in the following\n+   * chain of exceptions when an exception is received in an external client that executed workflow\n+   * through a WorkflowClient:\n+   *\n+   * <pre>\n+   * {@link WorkflowFailedException}\n+   *     ->{@link ChildWorkflowFailure}\n+   *         ->{@link ActivityFailure}\n+   *             ->OriginalActivityException\n+   * </pre>\n+   *\n+   * <p>This test also tests that Checked exception wrapping and unwrapping works producing a nice\n+   * exception chain without the wrappers.\n+   */\n+  @Test\n+  public void testExceptionPropagation() {\n+    TestExceptionPropagation client =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(TestExceptionPropagation.class);\n+    try {\n+      client.execute(testWorkflowRule.getTaskQueue());\n+      Assert.fail(\"Unreachable\");\n+    } catch (WorkflowFailedException e) {\n+      // Rethrow the assertion failure\n+      Throwable c1 = e.getCause();\n+      Throwable c2 = c1.getCause();\n+      Throwable c3 = c2.getCause();\n+      Throwable c4 = c3.getCause();\n+      Throwable c5 = c4.getCause();\n+      Throwable c6 = c5.getCause();\n+      if (c2 instanceof AssertionError) {\n+        throw (AssertionError) c2;\n+      }\n+      assertNoEmptyStacks(e);\n+      // Uncomment to see the actual trace.\n+      //            e.printStackTrace();\n+      Assert.assertTrue(e.getMessage(), e.getMessage().contains(\"TestExceptionPropagation\"));\n+      Assert.assertTrue(e.getStackTrace().length > 0);\n+      Assert.assertTrue(c1 instanceof ApplicationFailure);\n+      Assert.assertEquals(\n+          FileNotFoundException.class.getName(), ((ApplicationFailure) c1).getType());\n+      Assert.assertTrue(c2 instanceof ChildWorkflowFailure);\n+      Assert.assertTrue(c3 instanceof ApplicationFailure);\n+      Assert.assertEquals(\n+          NumberFormatException.class.getName(), ((ApplicationFailure) c3).getType());\n+      Assert.assertEquals(Throwable.class.getName(), ((ApplicationFailure) c4).getType());\n+      Assert.assertTrue(c5 instanceof ActivityFailure);\n+      Assert.assertTrue(c6 instanceof ApplicationFailure);\n+      Assert.assertEquals(IOException.class.getName(), ((ApplicationFailure) c6).getType());\n+      Assert.assertEquals(\n+          \"message='simulated IO problem', type='java.io.IOException', nonRetryable=false\",\n+          c6.getMessage());\n+    }\n+  }\n+\n+  private static void assertNoEmptyStacks(RuntimeException e) {\n+    // Check that there are no empty stacks\n+    Throwable c = e;\n+    while (c != null) {\n+      assertTrue(c.getStackTrace().length > 0);\n+      c = c.getCause();\n+    }\n+  }\n+\n+  @WorkflowInterface\n+  public interface TestExceptionPropagation {\n+    @WorkflowMethod\n+    void execute(String taskQueue);\n+  }\n+\n+  public static class ThrowingChild implements TestWorkflows.TestWorkflow1 {\n+\n+    @Override\n+    @SuppressWarnings(\"AssertionFailureIgnored\")\n+    public String execute(String taskQueue) {\n+      TestActivities testActivities =\n+          Workflow.newActivityStub(\n+              TestActivities.class,\n+              TestOptions.newActivityOptions20sScheduleToClose()\n+                  .toBuilder()\n+                  .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())\n+                  .build());\n+      try {\n+        testActivities.throwIO();\n+        fail(\"unreachable\");\n+        return \"ignored\";\n+      } catch (ActivityFailure e) {\n+        try {\n+          assertTrue(e.getMessage().contains(\"ThrowIO\"));\n+          assertTrue(e.getCause() instanceof ApplicationFailure);\n+          assertEquals(IOException.class.getName(), ((ApplicationFailure) e.getCause()).getType());\n+          assertEquals(\n+              \"message='simulated IO problem', type='java.io.IOException', nonRetryable=false\",\n+              e.getCause().getMessage());\n+        } catch (AssertionError ae) {\n+          // Errors cause workflow task to fail. But we want workflow to fail in this case.\n+          throw new RuntimeException(ae);\n+        }\n+        Exception ee = new NumberFormatException();\n+        ee.initCause(new Throwable(\"simulated throwable\", e));\n+        throw Workflow.wrap(ee);\n+      }\n+    }\n+  }\n+\n+  public static class TestExceptionPropagationImpl implements TestExceptionPropagation {\n+\n+    @Override\n+    @SuppressWarnings(\"AssertionFailureIgnored\")\n+    public void execute(String taskQueue) {\n+      ChildWorkflowOptions options =\n+          ChildWorkflowOptions.newBuilder().setWorkflowRunTimeout(Duration.ofHours(1)).build();\n+      TestWorkflows.TestWorkflow1 child =\n+          Workflow.newChildWorkflowStub(TestWorkflows.TestWorkflow1.class, options);\n+      try {\n+        child.execute(taskQueue);\n+        fail(\"unreachable\");\n+      } catch (RuntimeException e) {\n+        Throwable c1 = e.getCause();\n+        Throwable c2 = c1.getCause();\n+        Throwable c3 = c2.getCause();\n+        Throwable c4 = c3.getCause();\n+        try {\n+          assertNoEmptyStacks(e);\n+          assertTrue(e.getMessage().contains(\"TestWorkflow1\"));\n+          assertTrue(e instanceof ChildWorkflowFailure);\n+          assertTrue(c1 instanceof ApplicationFailure);\n+          assertEquals(NumberFormatException.class.getName(), ((ApplicationFailure) c1).getType());\n+          assertEquals(Throwable.class.getName(), ((ApplicationFailure) c2).getType());\n+          assertTrue(c3 instanceof ActivityFailure);\n+          assertTrue(c4 instanceof ApplicationFailure);\n+          assertEquals(IOException.class.getName(), ((ApplicationFailure) c4).getType());\n+          assertEquals(\n+              \"message='simulated IO problem', type='java.io.IOException', nonRetryable=false\",\n+              c4.getMessage());\n+        } catch (AssertionError ae) {\n+          // Errors cause workflow task to fail. But we want workflow to fail in this case.\n+          throw new RuntimeException(ae);\n+        }\n+        Exception fnf = new FileNotFoundException(\"simulated exception\");\n+        fnf.initCause(e);\n+        throw Workflow.wrap(fnf);\n+      }\n+    }\n+  }\n+}"
  },
  {
    "sha": "769065949be0cc43eb830d528c16f8e45b87dd14",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/ExecuteTest.java",
    "status": "added",
    "additions": 111,
    "deletions": 0,
    "changes": 111,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/ExecuteTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/ExecuteTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/ExecuteTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,111 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.client.WorkflowClient;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestMultiargdsWorkflowFunctions;\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class ExecuteTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testExecute() throws ExecutionException, InterruptedException {\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc stubF =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(\n+            TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc.class);\n+    Assert.assertEquals(\"func\", WorkflowClient.execute(stubF::func).get());\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc1 stubF1 =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(\n+            TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc1.class);\n+    Assert.assertEquals(1, (int) WorkflowClient.execute(stubF1::func1, 1).get());\n+    Assert.assertEquals(1, stubF1.func1(1)); // Check that duplicated start just returns the result.\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc2 stubF2 =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(\n+            TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc2.class);\n+    Assert.assertEquals(\"12\", WorkflowClient.execute(stubF2::func2, \"1\", 2).get());\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc3 stubF3 =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(\n+            TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc3.class);\n+    Assert.assertEquals(\"123\", WorkflowClient.execute(stubF3::func3, \"1\", 2, 3).get());\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc4 stubF4 =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(\n+            TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc4.class);\n+    Assert.assertEquals(\"1234\", WorkflowClient.execute(stubF4::func4, \"1\", 2, 3, 4).get());\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc5 stubF5 =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(\n+            TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc5.class);\n+    Assert.assertEquals(\"12345\", WorkflowClient.execute(stubF5::func5, \"1\", 2, 3, 4, 5).get());\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc6 stubF6 =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(\n+            TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc6.class);\n+    Assert.assertEquals(\"123456\", WorkflowClient.execute(stubF6::func6, \"1\", 2, 3, 4, 5, 6).get());\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc stubP =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(\n+            TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc.class);\n+    WorkflowClient.execute(stubP::proc).get();\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc1 stubP1 =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(\n+            TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc1.class);\n+    WorkflowClient.execute(stubP1::proc1, \"1\").get();\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc2 stubP2 =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(\n+            TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc2.class);\n+    WorkflowClient.execute(stubP2::proc2, \"1\", 2).get();\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc3 stubP3 =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(\n+            TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc3.class);\n+    WorkflowClient.execute(stubP3::proc3, \"1\", 2, 3).get();\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc4 stubP4 =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(\n+            TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc4.class);\n+    WorkflowClient.execute(stubP4::proc4, \"1\", 2, 3, 4).get();\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc5 stubP5 =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(\n+            TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc5.class);\n+    WorkflowClient.execute(stubP5::proc5, \"1\", 2, 3, 4, 5).get();\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc6 stubP6 =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(\n+            TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc6.class);\n+    WorkflowClient.execute(stubP6::proc6, \"1\", 2, 3, 4, 5, 6).get();\n+\n+    Assert.assertEquals(\"proc\", stubP.query());\n+    Assert.assertEquals(\"1\", stubP1.query());\n+    Assert.assertEquals(\"12\", stubP2.query());\n+    Assert.assertEquals(\"123\", stubP3.query());\n+    Assert.assertEquals(\"1234\", stubP4.query());\n+    Assert.assertEquals(\"12345\", stubP5.query());\n+    Assert.assertEquals(\"123456\", stubP6.query());\n+  }\n+}"
  },
  {
    "sha": "16db2cdb9fc67f5fa9e4acb4a70da953eec30e1b",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/GenericParametersWorkflowTest.java",
    "status": "added",
    "additions": 141,
    "deletions": 0,
    "changes": 141,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/GenericParametersWorkflowTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/GenericParametersWorkflowTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/GenericParametersWorkflowTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,141 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.activity.ActivityInterface;\n+import io.temporal.client.WorkflowClient;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestOptions;\n+import java.time.Duration;\n+import java.util.*;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class GenericParametersWorkflowTest {\n+\n+  private final GenericParametersActivityImpl activitiesImpl = new GenericParametersActivityImpl();\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(GenericParametersWorkflowImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testGenericParametersWorkflow() throws ExecutionException, InterruptedException {\n+    GenericParametersWorkflow workflowStub =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(GenericParametersWorkflow.class);\n+    List<UUID> uuidList = new ArrayList<UUID>();\n+    uuidList.add(UUID.randomUUID());\n+    uuidList.add(UUID.randomUUID());\n+    Set<UUID> uuidSet = new HashSet<UUID>();\n+    uuidSet.add(UUID.randomUUID());\n+    uuidSet.add(UUID.randomUUID());\n+    uuidSet.add(UUID.randomUUID());\n+    CompletableFuture<List<UUID>> resultF =\n+        WorkflowClient.execute(\n+            workflowStub::execute, testWorkflowRule.getTaskQueue(), uuidList, uuidSet);\n+    // Test signal and query serialization\n+    workflowStub.signal(uuidList);\n+    testWorkflowRule.sleep(Duration.ofSeconds(1));\n+    List<UUID> queryArg = new ArrayList<UUID>();\n+    queryArg.add(UUID.randomUUID());\n+    queryArg.add(UUID.randomUUID());\n+    List<UUID> queryResult = workflowStub.query(queryArg);\n+    List<UUID> expectedQueryResult = new ArrayList<UUID>();\n+    expectedQueryResult.addAll(queryArg);\n+    expectedQueryResult.addAll(uuidList);\n+    expectedQueryResult.sort(UUID::compareTo);\n+    queryResult.sort(UUID::compareTo);\n+    Assert.assertEquals(expectedQueryResult, queryResult);\n+    workflowStub.signal(new ArrayList<UUID>()); // empty list unblocks workflow await.\n+    // test workflow result serialization\n+    List<UUID> expectedResult = new ArrayList<UUID>();\n+    expectedResult.addAll(uuidList);\n+    expectedResult.addAll(uuidSet);\n+    List<UUID> result = resultF.get();\n+    result.sort(UUID::compareTo);\n+    expectedResult.sort(UUID::compareTo);\n+    Assert.assertEquals(expectedResult, result);\n+  }\n+\n+  @ActivityInterface\n+  public interface GenericParametersActivity {\n+\n+    List<UUID> execute(List<UUID> arg1, Set<UUID> arg2);\n+  }\n+\n+  @WorkflowInterface\n+  public interface GenericParametersWorkflow {\n+\n+    @WorkflowMethod\n+    List<UUID> execute(String taskQueue, List<UUID> arg1, Set<UUID> arg2);\n+\n+    @SignalMethod\n+    void signal(List<UUID> arg);\n+\n+    @QueryMethod\n+    List<UUID> query(List<UUID> arg);\n+  }\n+\n+  public static class GenericParametersActivityImpl implements GenericParametersActivity {\n+\n+    @Override\n+    public List<UUID> execute(List<UUID> arg1, Set<UUID> arg2) {\n+      List<UUID> result = new ArrayList<>();\n+      result.addAll(arg1);\n+      result.addAll(arg2);\n+      return result;\n+    }\n+  }\n+\n+  public static class GenericParametersWorkflowImpl implements GenericParametersWorkflow {\n+\n+    private List<UUID> signaled;\n+    private GenericParametersActivity activity;\n+\n+    @Override\n+    public List<UUID> execute(String taskQueue, List<UUID> arg1, Set<UUID> arg2) {\n+      Workflow.await(() -> signaled != null && signaled.size() == 0);\n+      activity =\n+          Workflow.newActivityStub(\n+              GenericParametersActivity.class,\n+              TestOptions.newActivityOptionsForTaskQueue(taskQueue));\n+      return activity.execute(arg1, arg2);\n+    }\n+\n+    @Override\n+    public void signal(List<UUID> arg) {\n+      signaled = arg;\n+    }\n+\n+    @Override\n+    public List<UUID> query(List<UUID> arg) {\n+      List<UUID> result = new ArrayList<>();\n+      result.addAll(arg);\n+      result.addAll(signaled);\n+      return result;\n+    }\n+  }\n+}"
  },
  {
    "sha": "cd85c06adcb3b0fc774293dd2fa53b628676e082",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/GetAttemptFromWorkflowInfoTest.java",
    "status": "added",
    "additions": 74,
    "deletions": 0,
    "changes": 74,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/GetAttemptFromWorkflowInfoTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/GetAttemptFromWorkflowInfoTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/GetAttemptFromWorkflowInfoTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,74 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestOptions;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class GetAttemptFromWorkflowInfoTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(\n+              WorkflowTest.TestMultiargsWorkflowsFuncParent.class,\n+              TestAttemptReturningWorkflowFunc.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testGetAttemptFromWorkflowInfo() {\n+    String workflowId = \"testGetAttemptWorkflow\";\n+    WorkflowOptions workflowOptions =\n+        TestOptions.newWorkflowOptionsWithTimeouts(testWorkflowRule.getTaskQueue())\n+            .toBuilder()\n+            .setWorkflowId(workflowId)\n+            .build();\n+    TestGetAttemptWorkflowsFunc workflow =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(TestGetAttemptWorkflowsFunc.class, workflowOptions);\n+    int attempt = workflow.func();\n+    Assert.assertEquals(1, attempt);\n+  }\n+\n+  @WorkflowInterface\n+  public interface TestGetAttemptWorkflowsFunc {\n+\n+    @WorkflowMethod\n+    int func();\n+  }\n+\n+  public static class TestAttemptReturningWorkflowFunc implements TestGetAttemptWorkflowsFunc {\n+    @Override\n+    public int func() {\n+      WorkflowInfo wi = Workflow.getInfo();\n+      return wi.getAttempt();\n+    }\n+  }\n+}"
  },
  {
    "sha": "85da1f6e4c04d884e084db721c272554dc57d4c6",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/HeartbeatTimeoutDetailsTest.java",
    "status": "added",
    "additions": 87,
    "deletions": 0,
    "changes": 87,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/HeartbeatTimeoutDetailsTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/HeartbeatTimeoutDetailsTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/HeartbeatTimeoutDetailsTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,87 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import io.temporal.activity.ActivityOptions;\n+import io.temporal.api.enums.v1.TimeoutType;\n+import io.temporal.failure.ActivityFailure;\n+import io.temporal.failure.TimeoutFailure;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestWorkflows;\n+import java.time.Duration;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class HeartbeatTimeoutDetailsTest {\n+\n+  private static final Logger log = LoggerFactory.getLogger(HeartbeatTimeoutDetailsTest.class);\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestHeartbeatTimeoutDetails.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testHeartbeatTimeoutDetails() {\n+    TestWorkflows.TestWorkflow1 workflowStub =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(TestWorkflows.TestWorkflow1.class);\n+    String result = workflowStub.execute(testWorkflowRule.getTaskQueue());\n+    Assert.assertEquals(\"heartbeatValue\", result);\n+  }\n+\n+  public static class TestHeartbeatTimeoutDetails implements TestWorkflows.TestWorkflow1 {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      ActivityOptions options =\n+          ActivityOptions.newBuilder()\n+              .setTaskQueue(taskQueue)\n+              .setHeartbeatTimeout(Duration.ofSeconds(1)) // short heartbeat timeout;\n+              .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n+              .build();\n+\n+      TestActivities activities = Workflow.newActivityStub(TestActivities.class, options);\n+      try {\n+        // false for second argument means to heartbeat once to set details and then stop.\n+        activities.activityWithDelay(5000, false);\n+      } catch (ActivityFailure e) {\n+        TimeoutFailure te = (TimeoutFailure) e.getCause();\n+        log.info(\"TestHeartbeatTimeoutDetails expected timeout\", e);\n+        assertEquals(TimeoutType.TIMEOUT_TYPE_SCHEDULE_TO_CLOSE, te.getTimeoutType());\n+        assertTrue(te.getCause() instanceof TimeoutFailure);\n+        assertEquals(\n+            TimeoutType.TIMEOUT_TYPE_HEARTBEAT, ((TimeoutFailure) te.getCause()).getTimeoutType());\n+        return (te.getLastHeartbeatDetails().get(String.class));\n+      }\n+      throw new RuntimeException(\"unreachable\");\n+    }\n+  }\n+}"
  },
  {
    "sha": "d219b1e3e671eabface494e865c4d8f97c1d87ac",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/LargeHistoryTest.java",
    "status": "added",
    "additions": 102,
    "deletions": 0,
    "changes": 102,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/LargeHistoryTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/LargeHistoryTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/LargeHistoryTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,102 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.activity.ActivityInterface;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestOptions;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.junit.Assert;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class LargeHistoryTest {\n+\n+  private static final Logger log = LoggerFactory.getLogger(LargeHistoryTest.class);\n+  private final TestLargeWorkflowActivityImpl activitiesImpl = new TestLargeWorkflowActivityImpl();\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestLargeHistory.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  @Ignore // Requires DEBUG_TIMEOUTS=true\n+  public void testLargeHistory() {\n+    final int activityCount = 1000;\n+    TestLargeWorkflow workflowStub =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestLargeWorkflow.class,\n+                TestOptions.newWorkflowOptionsWithTimeouts(testWorkflowRule.getTaskQueue())\n+                    .toBuilder()\n+                    .setWorkflowTaskTimeout(Duration.ofSeconds(30))\n+                    .build());\n+    long start = System.currentTimeMillis();\n+    String result = workflowStub.execute(activityCount, testWorkflowRule.getTaskQueue());\n+    long duration = System.currentTimeMillis() - start;\n+    log.info(testWorkflowRule.getTestEnvironment().getNamespace() + \" duration is \" + duration);\n+    Assert.assertEquals(\"done\", result);\n+  }\n+\n+  @WorkflowInterface\n+  public interface TestLargeWorkflow {\n+    @WorkflowMethod\n+    String execute(int activityCount, String taskQueue);\n+  }\n+\n+  @ActivityInterface\n+  public interface TestLargeWorkflowActivity {\n+    String activity();\n+  }\n+\n+  public static class TestLargeWorkflowActivityImpl implements TestLargeWorkflowActivity {\n+    @Override\n+    public String activity() {\n+      return \"done\";\n+    }\n+  }\n+\n+  public static class TestLargeHistory implements TestLargeWorkflow {\n+\n+    @Override\n+    public String execute(int activityCount, String taskQueue) {\n+      TestLargeWorkflowActivity activities =\n+          Workflow.newActivityStub(\n+              TestLargeWorkflowActivity.class,\n+              TestOptions.newActivityOptionsForTaskQueue(taskQueue));\n+      List<Promise<String>> results = new ArrayList<>();\n+      for (int i = 0; i < activityCount; i++) {\n+        Promise<String> result = Async.function(activities::activity);\n+        results.add(result);\n+      }\n+      Promise.allOf(results).get();\n+      return \"done\";\n+    }\n+  }\n+}"
  },
  {
    "sha": "3c1fe83d4febbb163df3f9ad4ace33b59fc23f53",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/MemoTest.java",
    "status": "added",
    "additions": 91,
    "deletions": 0,
    "changes": 91,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/MemoTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/MemoTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/MemoTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,91 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import com.google.protobuf.ByteString;\n+import com.uber.m3.tally.NoopScope;\n+import io.temporal.api.common.v1.Memo;\n+import io.temporal.api.common.v1.Payload;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryResponse;\n+import io.temporal.client.WorkflowClient;\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.common.converter.GsonJsonPayloadConverter;\n+import io.temporal.internal.common.WorkflowExecutionUtils;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestMultiargdsWorkflowFunctions;\n+import io.temporal.workflow.shared.TestOptions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class MemoTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testMemo() {\n+    if (testWorkflowRule.getTestEnvironment() != null) {\n+      String testMemoKey = \"testKey\";\n+      String testMemoValue = \"testValue\";\n+      Map<String, Object> memo = new HashMap<String, Object>();\n+      memo.put(testMemoKey, testMemoValue);\n+\n+      WorkflowOptions workflowOptions =\n+          TestOptions.newWorkflowOptionsWithTimeouts(testWorkflowRule.getTaskQueue())\n+              .toBuilder()\n+              .setMemo(memo)\n+              .build();\n+      TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc stubF =\n+          testWorkflowRule\n+              .getWorkflowClient()\n+              .newWorkflowStub(\n+                  TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc.class,\n+                  workflowOptions);\n+      WorkflowExecution executionF = WorkflowClient.start(stubF::func);\n+\n+      GetWorkflowExecutionHistoryResponse historyResp =\n+          WorkflowExecutionUtils.getHistoryPage(\n+              testWorkflowRule.getTestEnvironment().getWorkflowService(),\n+              SDKTestWorkflowRule.NAMESPACE,\n+              executionF,\n+              ByteString.EMPTY,\n+              new NoopScope());\n+      HistoryEvent startEvent = historyResp.getHistory().getEvents(0);\n+      Memo memoFromEvent = startEvent.getWorkflowExecutionStartedEventAttributes().getMemo();\n+      Payload memoBytes = memoFromEvent.getFieldsMap().get(testMemoKey);\n+      String memoRetrieved =\n+          GsonJsonPayloadConverter.getInstance().fromData(memoBytes, String.class, String.class);\n+      Assert.assertEquals(testMemoValue, memoRetrieved);\n+    }\n+  }\n+}"
  },
  {
    "sha": "2fa1f1846d79ef610464ec0a034ffbbf372573c3",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/MultipleTimersTest.java",
    "status": "added",
    "additions": 67,
    "deletions": 0,
    "changes": 67,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/MultipleTimersTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/MultipleTimersTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/MultipleTimersTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,67 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import java.time.Duration;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class MultipleTimersTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestMultipleTimersImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testMultipleTimers() {\n+    TestMultipleTimers workflowStub =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(TestMultipleTimers.class);\n+    long result = workflowStub.execute();\n+    Assert.assertTrue(\"should be around 1 second: \" + result, result < 2000);\n+  }\n+\n+  @WorkflowInterface\n+  public interface TestMultipleTimers {\n+    @WorkflowMethod\n+    long execute();\n+  }\n+\n+  public static class TestMultipleTimersImpl implements TestMultipleTimers {\n+\n+    @Override\n+    public long execute() {\n+      Promise<Void> t1 = Async.procedure(() -> Workflow.sleep(Duration.ofSeconds(1)));\n+      Promise<Void> t2 = Async.procedure(() -> Workflow.sleep(Duration.ofSeconds(2)));\n+      long start = Workflow.currentTimeMillis();\n+      Promise.anyOf(t1, t2).get();\n+      long elapsed = Workflow.currentTimeMillis() - start;\n+      return elapsed;\n+    }\n+  }\n+}"
  },
  {
    "sha": "6ae3960e1130baf368479f7e279ee40435158a49",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/MutableSideEffectTest.java",
    "status": "added",
    "additions": 89,
    "deletions": 0,
    "changes": 89,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/MutableSideEffectTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/MutableSideEffectTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/MutableSideEffectTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,89 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestWorkflows;\n+import java.time.Duration;\n+import java.util.*;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class MutableSideEffectTest {\n+\n+  private static final Map<String, Queue<Long>> mutableSideEffectValue =\n+      Collections.synchronizedMap(new HashMap<>());\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestMutableSideEffectWorkflowImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testMutableSideEffect() {\n+    TestWorkflows.TestWorkflow1 workflowStub =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(TestWorkflows.TestWorkflow1.class);\n+    ArrayDeque<Long> values = new ArrayDeque<Long>();\n+    values.add(1234L);\n+    values.add(1234L);\n+    values.add(123L); // expected to be ignored as it is smaller than 1234.\n+    values.add(3456L);\n+    values.add(1234L); // expected to be ignored as it is smaller than 3456L.\n+    values.add(4234L);\n+    values.add(4234L);\n+    values.add(3456L); // expected to be ignored as it is smaller than 4234L.\n+    mutableSideEffectValue.put(testWorkflowRule.getTaskQueue(), values);\n+    String result = workflowStub.execute(testWorkflowRule.getTaskQueue());\n+    Assert.assertEquals(\"1234, 1234, 1234, 3456, 3456, 4234, 4234, 4234\", result);\n+  }\n+\n+  public static class TestMutableSideEffectWorkflowImpl implements TestWorkflows.TestWorkflow1 {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      StringBuilder result = new StringBuilder();\n+      for (int j = 0; j < 1; j++) {\n+        for (int i = 0; i < 8; i++) {\n+          long value =\n+              Workflow.mutableSideEffect(\n+                  \"id1\",\n+                  Long.class,\n+                  (o, n) -> n > o,\n+                  () -> mutableSideEffectValue.get(taskQueue).poll());\n+          if (result.length() > 0) {\n+            result.append(\", \");\n+          }\n+          result.append(value);\n+          // Sleep is here to ensure that mutableSideEffect works when replaying a history.\n+          if (i >= 8) {\n+            Workflow.sleep(Duration.ofSeconds(1));\n+          }\n+        }\n+      }\n+      return result.toString();\n+    }\n+  }\n+}"
  },
  {
    "sha": "e618014ecac29f4eb74b1b3a108efb94b66ff73d",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/NoQueryThreadLeakTest.java",
    "status": "added",
    "additions": 87,
    "deletions": 0,
    "changes": 87,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/NoQueryThreadLeakTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/NoQueryThreadLeakTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/NoQueryThreadLeakTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,87 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.client.WorkflowClient;\n+import io.temporal.client.WorkflowStub;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import java.lang.management.ManagementFactory;\n+import java.time.Duration;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class NoQueryThreadLeakTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestNoQueryWorkflowImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testNoQueryThreadLeak() throws InterruptedException {\n+    int threadCount = ManagementFactory.getThreadMXBean().getThreadCount();\n+    WorkflowTest.QueryableWorkflow client =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(WorkflowTest.QueryableWorkflow.class);\n+    WorkflowClient.start(client::execute);\n+    testWorkflowRule.sleep(Duration.ofSeconds(1));\n+    // Calls query multiple times to check at the end of the method that if it doesn't leak threads\n+    int queryCount = 100;\n+    for (int i = 0; i < queryCount; i++) {\n+      Assert.assertEquals(\"some state\", client.getState());\n+      if (SDKTestWorkflowRule.useExternalService) {\n+        // Sleep a little bit to avoid server throttling error.\n+        Thread.sleep(50);\n+      }\n+    }\n+    client.mySignal(\"Hello \");\n+    WorkflowStub.fromTyped(client).getResult(String.class);\n+    // Ensures that no threads were leaked due to query\n+    int threadsCreated = ManagementFactory.getThreadMXBean().getThreadCount() - threadCount;\n+    Assert.assertTrue(\"query leaks threads: \" + threadsCreated, threadsCreated < queryCount);\n+  }\n+\n+  public static class TestNoQueryWorkflowImpl implements WorkflowTest.QueryableWorkflow {\n+\n+    CompletablePromise<Void> promise = Workflow.newPromise();\n+\n+    @Override\n+    public String execute() {\n+      promise.get();\n+      return \"done\";\n+    }\n+\n+    @Override\n+    public String getState() {\n+      return \"some state\";\n+    }\n+\n+    @Override\n+    public void mySignal(String value) {\n+      promise.complete(null);\n+    }\n+  }\n+}"
  },
  {
    "sha": "ba7fb3dee89cc1ddef999f0f92d7de7dd4d7683c",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/NonDeterministicWorkflowPolicyBlockWorkflowTest.java",
    "status": "added",
    "additions": 76,
    "deletions": 0,
    "changes": 76,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/NonDeterministicWorkflowPolicyBlockWorkflowTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/NonDeterministicWorkflowPolicyBlockWorkflowTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/NonDeterministicWorkflowPolicyBlockWorkflowTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,76 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.client.WorkflowFailedException;\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.failure.TimeoutFailure;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.time.Duration;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class NonDeterministicWorkflowPolicyBlockWorkflowTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(WorkflowTest.DeterminismFailingWorkflowImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testNonDeterministicWorkflowPolicyBlockWorkflow() {\n+    WorkflowOptions options =\n+        WorkflowOptions.newBuilder()\n+            .setWorkflowRunTimeout(Duration.ofSeconds(5))\n+            .setWorkflowTaskTimeout(Duration.ofSeconds(1))\n+            .setTaskQueue(testWorkflowRule.getTaskQueue())\n+            .build();\n+    WorkflowTest.DeterminismFailingWorkflow workflowStub =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(WorkflowTest.DeterminismFailingWorkflow.class, options);\n+    try {\n+      workflowStub.execute(testWorkflowRule.getTaskQueue());\n+      Assert.fail(\"unreachable\");\n+    } catch (WorkflowFailedException e) {\n+      // expected to timeout as workflow is going get blocked.\n+      Assert.assertTrue(e.getCause() instanceof TimeoutFailure);\n+    }\n+\n+    int workflowRootThreads = 0;\n+    ThreadInfo[] threads = ManagementFactory.getThreadMXBean().dumpAllThreads(false, false);\n+    for (ThreadInfo thread : threads) {\n+      if (thread.getThreadName().contains(\"workflow-root\")) {\n+        workflowRootThreads++;\n+      }\n+    }\n+\n+    Assert.assertTrue(\"workflow threads might leak\", workflowRootThreads < 10);\n+  }\n+}"
  },
  {
    "sha": "475c900c74132c9c9e1e4202c1d2c1d385a84cfa",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/NonDeterministicWorkflowPolicyFailWorkflowTest.java",
    "status": "added",
    "additions": 73,
    "deletions": 0,
    "changes": 73,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/NonDeterministicWorkflowPolicyFailWorkflowTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/NonDeterministicWorkflowPolicyFailWorkflowTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/NonDeterministicWorkflowPolicyFailWorkflowTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,73 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.client.WorkflowFailedException;\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.failure.ApplicationFailure;\n+import io.temporal.internal.replay.InternalWorkflowTaskException;\n+import io.temporal.worker.WorkflowImplementationOptions;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import java.time.Duration;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class NonDeterministicWorkflowPolicyFailWorkflowTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(\n+              WorkflowImplementationOptions.newBuilder()\n+                  .setFailWorkflowExceptionTypes(Throwable.class)\n+                  .build(),\n+              WorkflowTest.DeterminismFailingWorkflowImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testNonDeterministicWorkflowPolicyFailWorkflow() {\n+    WorkflowOptions options =\n+        WorkflowOptions.newBuilder()\n+            .setWorkflowRunTimeout(Duration.ofSeconds(1))\n+            .setWorkflowTaskTimeout(Duration.ofSeconds(1))\n+            .setTaskQueue(testWorkflowRule.getTaskQueue())\n+            .build();\n+    WorkflowTest.DeterminismFailingWorkflow workflowStub =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(WorkflowTest.DeterminismFailingWorkflow.class, options);\n+    try {\n+      workflowStub.execute(testWorkflowRule.getTaskQueue());\n+      Assert.fail(\"unreachable\");\n+    } catch (WorkflowFailedException e) {\n+      // expected to fail on non deterministic error\n+      Assert.assertTrue(e.getCause() instanceof ApplicationFailure);\n+      Assert.assertEquals(\n+          InternalWorkflowTaskException.class.getName(),\n+          ((ApplicationFailure) e.getCause()).getType());\n+    }\n+  }\n+}"
  },
  {
    "sha": "1288c9b9bc79c13e55593ae34ae9ad4df38196dd",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/ParentContinueAsNewTest.java",
    "status": "added",
    "additions": 82,
    "deletions": 0,
    "changes": 82,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/ParentContinueAsNewTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/ParentContinueAsNewTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/ParentContinueAsNewTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,82 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.api.enums.v1.WorkflowIdReusePolicy;\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestWorkflows;\n+import java.time.Duration;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class ParentContinueAsNewTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestParentWorkflowContinueAsNew.class, WorkflowTest.TestChild.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  /** Reproduction of a bug when a child of continued as new workflow has the same UUID ID. */\n+  @Test\n+  public void testParentContinueAsNew() {\n+\n+    WorkflowOptions options =\n+        WorkflowOptions.newBuilder()\n+            .setWorkflowRunTimeout(Duration.ofSeconds(200))\n+            .setWorkflowTaskTimeout(Duration.ofSeconds(60))\n+            .setTaskQueue(testWorkflowRule.getTaskQueue())\n+            .build();\n+    TestWorkflows.TestWorkflow1 client =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(TestWorkflows.TestWorkflow1.class, options);\n+    Assert.assertEquals(\"foo\", client.execute(\"not empty\"));\n+  }\n+\n+  public static class TestParentWorkflowContinueAsNew implements TestWorkflows.TestWorkflow1 {\n+\n+    private final WorkflowTest.ITestChild child1 =\n+        Workflow.newChildWorkflowStub(\n+            WorkflowTest.ITestChild.class,\n+            ChildWorkflowOptions.newBuilder()\n+                .setWorkflowIdReusePolicy(\n+                    WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE)\n+                .build());\n+    private final TestWorkflows.TestWorkflow1 self =\n+        Workflow.newContinueAsNewStub(TestWorkflows.TestWorkflow1.class);\n+\n+    @Override\n+    public String execute(String arg) {\n+      child1.execute(\"Hello\", 0);\n+      if (arg.length() > 0) {\n+        self.execute(\"\"); // continue as new\n+      }\n+      return \"foo\";\n+    }\n+  }\n+}"
  },
  {
    "sha": "f109e40aa3bd836793a4fff43f1058f607858009",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/PolymorphicStartTest.java",
    "status": "added",
    "additions": 75,
    "deletions": 0,
    "changes": 75,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/PolymorphicStartTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/PolymorphicStartTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/PolymorphicStartTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,75 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class PolymorphicStartTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(WorkflowAImpl.class, WorkflowBImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testPolymorphicStart() {\n+    WorkflowBase[] stubs =\n+        new WorkflowBase[] {\n+          testWorkflowRule.newWorkflowStubTimeoutOptions(WorkflowA.class),\n+          testWorkflowRule.newWorkflowStubTimeoutOptions(WorkflowB.class)\n+        };\n+    String results = stubs[0].execute(\"0\") + \", \" + stubs[1].execute(\"1\");\n+    Assert.assertEquals(\"WorkflowAImpl0, WorkflowBImpl1\", results);\n+  }\n+\n+  public interface WorkflowBase {\n+    @WorkflowMethod\n+    String execute(String arg);\n+  }\n+\n+  @WorkflowInterface\n+  public interface WorkflowA extends WorkflowBase {}\n+\n+  @WorkflowInterface\n+  public interface WorkflowB extends WorkflowBase {}\n+\n+  public static class WorkflowBImpl implements WorkflowB {\n+    @Override\n+    public String execute(String arg) {\n+      return \"WorkflowBImpl\" + arg;\n+    }\n+  }\n+\n+  public static class WorkflowAImpl implements WorkflowA {\n+    @Override\n+    public String execute(String arg) {\n+      return \"WorkflowAImpl\" + arg;\n+    }\n+  }\n+}"
  },
  {
    "sha": "843f0745f83f9806e9d4525e8c40f914bdf53d21",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/SagaTest.java",
    "status": "added",
    "additions": 151,
    "deletions": 0,
    "changes": 151,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/SagaTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/SagaTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/SagaTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,151 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.common.RetryOptions;\n+import io.temporal.testing.TracingWorkerInterceptor;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestMultiargdsWorkflowFunctions;\n+import io.temporal.workflow.shared.TestOptions;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class SagaTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(\n+              TestSagaWorkflowImpl.class,\n+              TestCompensationWorkflowImpl.class,\n+              TestMultiargsWorkflowsFuncImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .setWorkerInterceptors(\n+              new TracingWorkerInterceptor(new TracingWorkerInterceptor.FilteredTrace()))\n+          .build();\n+\n+  @Test\n+  public void testSaga() {\n+    TestSagaWorkflow sagaWorkflow =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(TestSagaWorkflow.class);\n+    sagaWorkflow.execute(testWorkflowRule.getTaskQueue(), false);\n+    testWorkflowRule\n+        .getInterceptor(TracingWorkerInterceptor.class)\n+        .setExpected(\n+            \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+            \"newThread workflow-method\",\n+            \"executeActivity customActivity1\",\n+            \"activity customActivity1\",\n+            \"executeChildWorkflow TestMultiargsWorkflowsFunc\",\n+            \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+            \"newThread workflow-method\",\n+            \"executeActivity ThrowIO\",\n+            \"activity ThrowIO\",\n+            \"executeChildWorkflow TestCompensationWorkflow\",\n+            \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+            \"newThread workflow-method\",\n+            \"executeActivity Activity2\",\n+            \"activity Activity2\");\n+  }\n+\n+  @Test\n+  public void testSagaParallelCompensation() {\n+    TestSagaWorkflow sagaWorkflow =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(TestSagaWorkflow.class);\n+    sagaWorkflow.execute(testWorkflowRule.getTaskQueue(), true);\n+    String trace = testWorkflowRule.getInterceptor(TracingWorkerInterceptor.class).getTrace();\n+    Assert.assertTrue(trace, trace.contains(\"executeChildWorkflow TestCompensationWorkflow\"));\n+    Assert.assertTrue(trace, trace.contains(\"executeActivity Activity2\"));\n+  }\n+\n+  @WorkflowInterface\n+  public interface TestSagaWorkflow {\n+    @WorkflowMethod\n+    String execute(String taskQueue, boolean parallelCompensation);\n+  }\n+\n+  @WorkflowInterface\n+  public interface TestCompensationWorkflow {\n+    @WorkflowMethod\n+    void compensate();\n+  }\n+\n+  public static class TestCompensationWorkflowImpl implements TestCompensationWorkflow {\n+    @Override\n+    public void compensate() {}\n+  }\n+\n+  public static class TestSagaWorkflowImpl implements TestSagaWorkflow {\n+\n+    @Override\n+    public String execute(String taskQueue, boolean parallelCompensation) {\n+      TestActivities testActivities =\n+          Workflow.newActivityStub(\n+              TestActivities.class,\n+              TestOptions.newActivityOptionsForTaskQueue(taskQueue)\n+                  .toBuilder()\n+                  .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())\n+                  .build());\n+\n+      ChildWorkflowOptions workflowOptions =\n+          ChildWorkflowOptions.newBuilder().setTaskQueue(taskQueue).build();\n+      TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc stubF1 =\n+          Workflow.newChildWorkflowStub(\n+              TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc.class, workflowOptions);\n+\n+      Saga saga =\n+          new Saga(\n+              new Saga.Options.Builder().setParallelCompensation(parallelCompensation).build());\n+      try {\n+        testActivities.activity1(10);\n+        saga.addCompensation(testActivities::activity2, \"compensate\", -10);\n+\n+        stubF1.func();\n+\n+        TestCompensationWorkflow compensationWorkflow =\n+            Workflow.newChildWorkflowStub(TestCompensationWorkflow.class, workflowOptions);\n+        saga.addCompensation(compensationWorkflow::compensate);\n+\n+        testActivities.throwIO();\n+        saga.addCompensation(\n+            () -> {\n+              throw new RuntimeException(\"unreachable\");\n+            });\n+      } catch (Exception e) {\n+        saga.compensate();\n+      }\n+      return \"done\";\n+    }\n+  }\n+\n+  public static class TestMultiargsWorkflowsFuncImpl\n+      implements TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc {\n+\n+    @Override\n+    public String func() {\n+      return \"done\";\n+    }\n+  }\n+}"
  },
  {
    "sha": "2da852cb258c2e04ef7e6f3c762de0c76f330784",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/SearchAttributesTest.java",
    "status": "added",
    "additions": 126,
    "deletions": 0,
    "changes": 126,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/SearchAttributesTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/SearchAttributesTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/SearchAttributesTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,126 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import com.google.protobuf.ByteString;\n+import com.uber.m3.tally.NoopScope;\n+import io.temporal.api.common.v1.Payload;\n+import io.temporal.api.common.v1.SearchAttributes;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryResponse;\n+import io.temporal.client.WorkflowClient;\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.internal.common.WorkflowExecutionUtils;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestMultiargdsWorkflowFunctions;\n+import io.temporal.workflow.shared.TestOptions;\n+import java.time.LocalDateTime;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class SearchAttributesTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testSearchAttributes() {\n+    if (testWorkflowRule.getTestEnvironment() != null) {\n+      String testKeyString = \"CustomKeywordField\";\n+      String testValueString = \"testKeyword\";\n+      String testKeyInteger = \"CustomIntField\";\n+      Integer testValueInteger = 1;\n+      String testKeyDateTime = \"CustomDateTimeField\";\n+      LocalDateTime testValueDateTime = LocalDateTime.now();\n+      String testKeyBool = \"CustomBoolField\";\n+      Boolean testValueBool = true;\n+      String testKeyDouble = \"CustomDoubleField\";\n+      Double testValueDouble = 1.23;\n+\n+      // add more type to test\n+      Map<String, Object> searchAttr = new HashMap<String, Object>();\n+      searchAttr.put(testKeyString, testValueString);\n+      searchAttr.put(testKeyInteger, testValueInteger);\n+      searchAttr.put(testKeyDateTime, testValueDateTime);\n+      searchAttr.put(testKeyBool, testValueBool);\n+      searchAttr.put(testKeyDouble, testValueDouble);\n+\n+      WorkflowOptions workflowOptions =\n+          TestOptions.newWorkflowOptionsWithTimeouts(testWorkflowRule.getTaskQueue())\n+              .toBuilder()\n+              .setSearchAttributes(searchAttr)\n+              .build();\n+      TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc stubF =\n+          testWorkflowRule\n+              .getWorkflowClient()\n+              .newWorkflowStub(\n+                  TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc.class,\n+                  workflowOptions);\n+      WorkflowExecution executionF = WorkflowClient.start(stubF::func);\n+\n+      GetWorkflowExecutionHistoryResponse historyResp =\n+          WorkflowExecutionUtils.getHistoryPage(\n+              testWorkflowRule.getTestEnvironment().getWorkflowService(),\n+              SDKTestWorkflowRule.NAMESPACE,\n+              executionF,\n+              ByteString.EMPTY,\n+              new NoopScope());\n+      HistoryEvent startEvent = historyResp.getHistory().getEvents(0);\n+      SearchAttributes searchAttrFromEvent =\n+          startEvent.getWorkflowExecutionStartedEventAttributes().getSearchAttributes();\n+\n+      Map<String, Payload> fieldsMap = searchAttrFromEvent.getIndexedFieldsMap();\n+      Payload searchAttrStringBytes = fieldsMap.get(testKeyString);\n+      DataConverter converter = DataConverter.getDefaultInstance();\n+      String retrievedString =\n+          converter.fromPayload(searchAttrStringBytes, String.class, String.class);\n+      Assert.assertEquals(testValueString, retrievedString);\n+      Payload searchAttrIntegerBytes = fieldsMap.get(testKeyInteger);\n+      Integer retrievedInteger =\n+          converter.fromPayload(searchAttrIntegerBytes, Integer.class, Integer.class);\n+      Assert.assertEquals(testValueInteger, retrievedInteger);\n+      Payload searchAttrDateTimeBytes = fieldsMap.get(testKeyDateTime);\n+      LocalDateTime retrievedDateTime =\n+          converter.fromPayload(searchAttrDateTimeBytes, LocalDateTime.class, LocalDateTime.class);\n+      Assert.assertEquals(testValueDateTime, retrievedDateTime);\n+      Payload searchAttrBoolBytes = fieldsMap.get(testKeyBool);\n+      Boolean retrievedBool =\n+          converter.fromPayload(searchAttrBoolBytes, Boolean.class, Boolean.class);\n+      Assert.assertEquals(testValueBool, retrievedBool);\n+      Payload searchAttrDoubleBytes = fieldsMap.get(testKeyDouble);\n+      Double retrievedDouble =\n+          converter.fromPayload(searchAttrDoubleBytes, Double.class, Double.class);\n+      Assert.assertEquals(testValueDouble, retrievedDouble);\n+    }\n+  }\n+}"
  },
  {
    "sha": "b6bf1a6f9864f81ac23302b4a85680b8905b8c2d",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/SideEffectTest.java",
    "status": "added",
    "additions": 89,
    "deletions": 0,
    "changes": 89,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/SideEffectTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/SideEffectTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/SideEffectTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,89 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import io.temporal.testing.TracingWorkerInterceptor;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestOptions;\n+import io.temporal.workflow.shared.TestWorkflows;\n+import java.time.Duration;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class SideEffectTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestSideEffectWorkflowImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .setWorkerInterceptors(\n+              new TracingWorkerInterceptor(new TracingWorkerInterceptor.FilteredTrace()))\n+          .build();\n+\n+  @Test\n+  public void testSideEffect() {\n+    TestWorkflows.TestWorkflow1 workflowStub =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(TestWorkflows.TestWorkflow1.class);\n+    String result = workflowStub.execute(testWorkflowRule.getTaskQueue());\n+    Assert.assertEquals(\"activity1\", result);\n+    testWorkflowRule\n+        .getInterceptor(TracingWorkerInterceptor.class)\n+        .setExpected(\n+            \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+            \"newThread workflow-method\",\n+            \"currentTimeMillis\",\n+            \"sideEffect\",\n+            \"sideEffect\",\n+            \"sleep PT1S\",\n+            \"executeActivity customActivity1\",\n+            \"activity customActivity1\");\n+  }\n+\n+  public static class TestSideEffectWorkflowImpl implements TestWorkflows.TestWorkflow1 {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      TestActivities testActivities =\n+          Workflow.newActivityStub(\n+              TestActivities.class, TestOptions.newActivityOptionsForTaskQueue(taskQueue));\n+\n+      long workflowTime = Workflow.currentTimeMillis();\n+      long time1 = Workflow.sideEffect(long.class, () -> workflowTime);\n+      long time2 = Workflow.sideEffect(long.class, () -> workflowTime);\n+      assertEquals(time1, time2);\n+      Workflow.sleep(Duration.ofSeconds(1));\n+      String result;\n+      if (workflowTime == time1) {\n+        result = \"activity\" + testActivities.activity1(1);\n+      } else {\n+        result = testActivities.activity2(\"activity2\", 2);\n+      }\n+      return result;\n+    }\n+  }\n+}"
  },
  {
    "sha": "96f64752fd9eb4add3ada8b881d5ab273bfa4d5a",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/StartTest.java",
    "status": "added",
    "additions": 199,
    "deletions": 0,
    "changes": 199,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/StartTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/StartTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/StartTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,199 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.WorkflowIdReusePolicy;\n+import io.temporal.client.WorkflowClient;\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestMultiargdsWorkflowFunctions;\n+import io.temporal.workflow.shared.TestOptions;\n+import java.util.Optional;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class StartTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testStart() {\n+    WorkflowOptions workflowOptions =\n+        TestOptions.newWorkflowOptionsWithTimeouts(testWorkflowRule.getTaskQueue())\n+            .toBuilder()\n+            .setWorkflowIdReusePolicy(\n+                WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE)\n+            .build();\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc stubF =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc.class, workflowOptions);\n+    assertResult(\"func\", WorkflowClient.start(stubF::func));\n+    Assert.assertEquals(\n+        \"func\", stubF.func()); // Check that duplicated start just returns the result.\n+    WorkflowOptions options =\n+        WorkflowOptions.newBuilder().setTaskQueue(testWorkflowRule.getTaskQueue()).build();\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc1 stubF1 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc1.class, options);\n+\n+    if (!SDKTestWorkflowRule.useExternalService) {\n+      // Use worker that polls on a task queue configured through @WorkflowMethod annotation of\n+      // func1\n+      assertResult(1, WorkflowClient.start(stubF1::func1, 1));\n+      Assert.assertEquals(\n+          1, stubF1.func1(1)); // Check that duplicated start just returns the result.\n+    }\n+    // Check that duplicated start is not allowed for AllowDuplicate IdReusePolicy\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc2 stubF2 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc2.class,\n+                TestOptions.newWorkflowOptionsWithTimeouts(testWorkflowRule.getTaskQueue())\n+                    .toBuilder()\n+                    .setWorkflowIdReusePolicy(\n+                        WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE)\n+                    .build());\n+    assertResult(\"12\", WorkflowClient.start(stubF2::func2, \"1\", 2));\n+    try {\n+      stubF2.func2(\"1\", 2);\n+      Assert.fail(\"unreachable\");\n+    } catch (IllegalStateException e) {\n+      // expected\n+    }\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc3 stubF3 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc3.class, workflowOptions);\n+    assertResult(\"123\", WorkflowClient.start(stubF3::func3, \"1\", 2, 3));\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc4 stubF4 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc4.class, workflowOptions);\n+    assertResult(\"1234\", WorkflowClient.start(stubF4::func4, \"1\", 2, 3, 4));\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc5 stubF5 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc5.class, workflowOptions);\n+    assertResult(\"12345\", WorkflowClient.start(stubF5::func5, \"1\", 2, 3, 4, 5));\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc6 stubF6 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc6.class, workflowOptions);\n+    assertResult(\"123456\", WorkflowClient.start(stubF6::func6, \"1\", 2, 3, 4, 5, 6));\n+\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc stubP =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc.class, workflowOptions);\n+    waitForProc(WorkflowClient.start(stubP::proc));\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc1 stubP1 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc1.class, workflowOptions);\n+    waitForProc(WorkflowClient.start(stubP1::proc1, \"1\"));\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc2 stubP2 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc2.class, workflowOptions);\n+    waitForProc(WorkflowClient.start(stubP2::proc2, \"1\", 2));\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc3 stubP3 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc3.class, workflowOptions);\n+    waitForProc(WorkflowClient.start(stubP3::proc3, \"1\", 2, 3));\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc4 stubP4 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc4.class, workflowOptions);\n+    waitForProc(WorkflowClient.start(stubP4::proc4, \"1\", 2, 3, 4));\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc5 stubP5 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc5.class, workflowOptions);\n+    waitForProc(WorkflowClient.start(stubP5::proc5, \"1\", 2, 3, 4, 5));\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc6 stubP6 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsProc6.class, workflowOptions);\n+    waitForProc(WorkflowClient.start(stubP6::proc6, \"1\", 2, 3, 4, 5, 6));\n+\n+    Assert.assertEquals(\"proc\", stubP.query());\n+    Assert.assertEquals(\"1\", stubP1.query());\n+    Assert.assertEquals(\"12\", stubP2.query());\n+    Assert.assertEquals(\"123\", stubP3.query());\n+    Assert.assertEquals(\"1234\", stubP4.query());\n+    Assert.assertEquals(\"12345\", stubP5.query());\n+    Assert.assertEquals(\"123456\", stubP6.query());\n+  }\n+\n+  private void assertResult(String expected, WorkflowExecution execution) {\n+    String result =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newUntypedWorkflowStub(execution, Optional.empty())\n+            .getResult(String.class);\n+    assertEquals(expected, result);\n+  }\n+\n+  private void assertResult(int expected, WorkflowExecution execution) {\n+    int result =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newUntypedWorkflowStub(execution, Optional.empty())\n+            .getResult(int.class);\n+    assertEquals(expected, result);\n+  }\n+\n+  private void waitForProc(WorkflowExecution execution) {\n+    testWorkflowRule\n+        .getWorkflowClient()\n+        .newUntypedWorkflowStub(execution, Optional.empty())\n+        .getResult(Void.class);\n+  }\n+}"
  },
  {
    "sha": "213dafa9ff53877cb0408da9bc1818e0107baf4d",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/SyncTest.java",
    "status": "added",
    "additions": 137,
    "deletions": 0,
    "changes": 137,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/SyncTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/SyncTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/SyncTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,137 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import static io.temporal.client.WorkflowClient.QUERY_TYPE_STACK_TRACE;\n+import static org.junit.Assert.*;\n+\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.client.WorkflowFailedException;\n+import io.temporal.client.WorkflowStub;\n+import io.temporal.failure.CanceledFailure;\n+import io.temporal.failure.TerminatedFailure;\n+import io.temporal.testing.TracingWorkerInterceptor;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestOptions;\n+import io.temporal.workflow.shared.TestWorkflows;\n+import java.time.Duration;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class SyncTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestSyncWorkflowImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .setWorkerInterceptors(\n+              new TracingWorkerInterceptor(new TracingWorkerInterceptor.FilteredTrace()))\n+          .build();\n+\n+  @Test\n+  public void testSync() {\n+    TestWorkflows.TestWorkflow1 workflowStub =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(TestWorkflows.TestWorkflow1.class);\n+    String result = workflowStub.execute(testWorkflowRule.getTaskQueue());\n+    Assert.assertEquals(\"activity10\", result);\n+    testWorkflowRule\n+        .getInterceptor(TracingWorkerInterceptor.class)\n+        .setExpected(\n+            \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+            \"newThread workflow-method\",\n+            \"newThread null\",\n+            \"sleep PT2S\",\n+            \"executeActivity ActivityWithDelay\",\n+            \"activity ActivityWithDelay\",\n+            \"executeActivity Activity2\",\n+            \"activity Activity2\");\n+  }\n+\n+  @Test\n+  public void testSyncUntypedAndStackTrace() {\n+    WorkflowStub workflowStub =\n+        testWorkflowRule.newUntypedWorkflowStubTimeoutOptions(\"TestWorkflow1\");\n+    WorkflowExecution execution = workflowStub.start(testWorkflowRule.getTaskQueue());\n+    testWorkflowRule.sleep(Duration.ofMillis(500));\n+    String stackTrace = workflowStub.query(QUERY_TYPE_STACK_TRACE, String.class);\n+    assertTrue(stackTrace, stackTrace.contains(\"WorkflowTest$TestSyncWorkflowImpl.execute\"));\n+    assertTrue(stackTrace, stackTrace.contains(\"activityWithDelay\"));\n+    // Test stub created from workflow execution.\n+    workflowStub =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newUntypedWorkflowStub(execution, workflowStub.getWorkflowType());\n+    stackTrace = workflowStub.query(QUERY_TYPE_STACK_TRACE, String.class);\n+    assertTrue(stackTrace, stackTrace.contains(\"WorkflowTest$TestSyncWorkflowImpl.execute\"));\n+    assertTrue(stackTrace, stackTrace.contains(\"activityWithDelay\"));\n+    String result = workflowStub.getResult(String.class);\n+    assertEquals(\"activity10\", result);\n+  }\n+\n+  @Test\n+  public void testWorkflowCancellation() {\n+    WorkflowStub client = testWorkflowRule.newUntypedWorkflowStubTimeoutOptions(\"TestWorkflow1\");\n+    client.start(testWorkflowRule.getTaskQueue());\n+    client.cancel();\n+    try {\n+      client.getResult(String.class);\n+      fail(\"unreachable\");\n+    } catch (WorkflowFailedException e) {\n+      assertTrue(e.getCause() instanceof CanceledFailure);\n+    }\n+  }\n+\n+  @Test\n+  public void testWorkflowTermination() throws InterruptedException {\n+    WorkflowStub client = testWorkflowRule.newUntypedWorkflowStubTimeoutOptions(\"TestWorkflow1\");\n+    client.start(testWorkflowRule.getTaskQueue());\n+    Thread.sleep(1000);\n+    client.terminate(\"boo\", \"detail1\", \"detail2\");\n+    try {\n+      client.getResult(String.class);\n+      fail(\"unreachable\");\n+    } catch (WorkflowFailedException ignored) {\n+      assertTrue(ignored.getCause() instanceof TerminatedFailure);\n+      assertEquals(\"boo\", ((TerminatedFailure) ignored.getCause()).getOriginalMessage());\n+    }\n+  }\n+\n+  public static class TestSyncWorkflowImpl implements TestWorkflows.TestWorkflow1 {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      TestActivities activities =\n+          Workflow.newActivityStub(\n+              TestActivities.class, TestOptions.newActivityOptionsForTaskQueue(taskQueue));\n+      // Invoke synchronously in a separate thread for testing purposes only.\n+      // In real workflows use\n+      // Async.procedure(activities::activityWithDelay, 1000, true)\n+      Promise<String> a1 = Async.function(() -> activities.activityWithDelay(1000, true));\n+      Workflow.sleep(2000);\n+      return activities.activity2(a1.get(), 10);\n+    }\n+  }\n+}"
  },
  {
    "sha": "9363edbfa8034acab126e0f8f841f95412a9950f",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/TimerCallbackBlockedTest.java",
    "status": "added",
    "additions": 76,
    "deletions": 0,
    "changes": 76,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/TimerCallbackBlockedTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/TimerCallbackBlockedTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/TimerCallbackBlockedTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,76 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestWorkflows;\n+import java.time.Duration;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class TimerCallbackBlockedTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestTimerCallbackBlockedWorkflowImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  /** Test that it is not allowed to block in the timer callback thread. */\n+  @Test\n+  public void testTimerCallbackBlocked() {\n+    WorkflowOptions options =\n+        WorkflowOptions.newBuilder()\n+            .setWorkflowRunTimeout(Duration.ofSeconds(10))\n+            .setWorkflowTaskTimeout(Duration.ofSeconds(1))\n+            .setTaskQueue(testWorkflowRule.getTaskQueue())\n+            .build();\n+    TestWorkflows.TestWorkflow1 client =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(TestWorkflows.TestWorkflow1.class, options);\n+    String result = client.execute(testWorkflowRule.getTaskQueue());\n+    Assert.assertEquals(\"timer2Fired\", result);\n+  }\n+\n+  public static class TestTimerCallbackBlockedWorkflowImpl implements TestWorkflows.TestWorkflow1 {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      Promise<Void> timer1 = Workflow.newTimer(Duration.ZERO);\n+      Promise<Void> timer2 = Workflow.newTimer(Duration.ofSeconds(1));\n+\n+      return timer1\n+          .thenApply(\n+              e -> {\n+                timer2.get();\n+                return \"timer2Fired\";\n+              })\n+          .get();\n+    }\n+  }\n+}"
  },
  {
    "sha": "838ecc4d254c649483927f21190764dc7ef958d3",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/TimerTest.java",
    "status": "added",
    "additions": 138,
    "deletions": 0,
    "changes": 138,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/TimerTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/TimerTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/TimerTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,138 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.testing.TracingWorkerInterceptor;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestOptions;\n+import io.temporal.workflow.shared.TestWorkflows;\n+import java.time.Duration;\n+import java.util.List;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class TimerTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestTimerWorkflowImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .setWorkerInterceptors(\n+              new TracingWorkerInterceptor(new TracingWorkerInterceptor.FilteredTrace()))\n+          .build();\n+\n+  @Test\n+  public void testTimer() {\n+    WorkflowOptions options;\n+    if (SDKTestWorkflowRule.useExternalService) {\n+      options = TestOptions.newWorkflowOptionsWithTimeouts(testWorkflowRule.getTaskQueue());\n+    } else {\n+      options =\n+          TestOptions.newWorkflowOptionsWithTimeouts(testWorkflowRule.getTaskQueue())\n+              .toBuilder()\n+              .setWorkflowRunTimeout(Duration.ofDays(1))\n+              .build();\n+    }\n+    TestWorkflows.TestWorkflow2 client =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(TestWorkflows.TestWorkflow2.class, options);\n+    String result = client.execute(SDKTestWorkflowRule.useExternalService);\n+    Assert.assertEquals(\"testTimer\", result);\n+    if (SDKTestWorkflowRule.useExternalService) {\n+      testWorkflowRule\n+          .getInterceptor(TracingWorkerInterceptor.class)\n+          .setExpected(\n+              \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+              \"registerQuery getTrace\",\n+              \"newThread workflow-method\",\n+              \"newTimer PT0.7S\",\n+              \"newTimer PT1.3S\",\n+              \"currentTimeMillis\",\n+              \"newTimer PT10S\",\n+              \"currentTimeMillis\",\n+              \"currentTimeMillis\",\n+              \"currentTimeMillis\");\n+    } else {\n+      testWorkflowRule\n+          .getInterceptor(TracingWorkerInterceptor.class)\n+          .setExpected(\n+              \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+              \"registerQuery getTrace\",\n+              \"newThread workflow-method\",\n+              \"newTimer PT11M40S\",\n+              \"newTimer PT21M40S\",\n+              \"currentTimeMillis\",\n+              \"newTimer PT10H\",\n+              \"currentTimeMillis\",\n+              \"currentTimeMillis\",\n+              \"currentTimeMillis\");\n+    }\n+  }\n+\n+  public static class TestTimerWorkflowImpl implements TestWorkflows.TestWorkflow2 {\n+\n+    @Override\n+    public String execute(boolean useExternalService) {\n+      Promise<Void> timer1;\n+      Promise<Void> timer2;\n+      Duration timeout1 = useExternalService ? Duration.ofMillis(700) : Duration.ofSeconds(700);\n+      Duration timeout2 = useExternalService ? Duration.ofMillis(1300) : Duration.ofSeconds(1300);\n+      timer1 = Workflow.newTimer(timeout1);\n+      timer2 = Workflow.newTimer(timeout2);\n+      long time = Workflow.currentTimeMillis();\n+      timer1\n+          .thenApply(\n+              r -> {\n+                // Testing that timer can be created from a callback thread.\n+                if (useExternalService) {\n+                  Workflow.newTimer(Duration.ofSeconds(10));\n+                } else {\n+                  Workflow.newTimer(Duration.ofHours(10));\n+                }\n+                Workflow.currentTimeMillis(); // Testing that time is available here.\n+                return r;\n+              })\n+          .get();\n+      timer1.get();\n+      long slept = Workflow.currentTimeMillis() - time;\n+      // Also checks that rounding up to a second works.\n+      assertTrue(slept + \"<\" + timeout1.toMillis(), slept >= timeout1.toMillis());\n+      timer2.get();\n+      slept = Workflow.currentTimeMillis() - time;\n+      assertTrue(String.valueOf(slept), slept >= timeout2.toMillis());\n+      return \"testTimer\";\n+    }\n+\n+    @Override\n+    public List<String> getTrace() {\n+      throw new UnsupportedOperationException(\"not implemented\");\n+    }\n+  }\n+}"
  },
  {
    "sha": "880e0591bb3d3a6bb0f338ca108a7b728e464ef0",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/UUIDAndRandomTest.java",
    "status": "added",
    "additions": 86,
    "deletions": 0,
    "changes": 86,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/UUIDAndRandomTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/UUIDAndRandomTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/UUIDAndRandomTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,86 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import io.temporal.testing.TracingWorkerInterceptor;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestOptions;\n+import io.temporal.workflow.shared.TestWorkflows;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class UUIDAndRandomTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestUUIDAndRandom.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .setWorkerInterceptors(\n+              new TracingWorkerInterceptor(new TracingWorkerInterceptor.FilteredTrace()))\n+          .build();\n+\n+  @Test\n+  public void testUUIDAndRandom() {\n+    TestWorkflows.TestWorkflow1 workflowStub =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(TestWorkflows.TestWorkflow1.class);\n+    String result = workflowStub.execute(testWorkflowRule.getTaskQueue());\n+    Assert.assertEquals(\"foo10\", result);\n+    testWorkflowRule\n+        .getInterceptor(TracingWorkerInterceptor.class)\n+        .setExpected(\n+            \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+            \"newThread workflow-method\",\n+            \"sideEffect\",\n+            \"sideEffect\",\n+            \"executeActivity Activity2\",\n+            \"activity Activity2\");\n+  }\n+\n+  public static class TestUUIDAndRandom implements TestWorkflows.TestWorkflow1 {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      TestActivities activities =\n+          Workflow.newActivityStub(\n+              TestActivities.class, TestOptions.newActivityOptionsForTaskQueue(taskQueue));\n+      Random rand1 = Workflow.newRandom();\n+      int r11 = rand1.nextInt();\n+      int r12 = r11 + rand1.nextInt();\n+      int savedInt = Workflow.sideEffect(int.class, () -> r12);\n+      String id = Workflow.randomUUID().toString() + \"-\" + Workflow.randomUUID().toString();\n+      String savedId = Workflow.sideEffect(String.class, () -> id);\n+      // Invoke activity in a blocking mode to ensure that asserts run after replay.\n+      String result = activities.activity2(\"foo\", 10);\n+      // Assert that during replay values didn't change.\n+      assertEquals(savedId, id);\n+      assertEquals(savedInt, r12);\n+      return result;\n+    }\n+  }\n+}"
  },
  {
    "sha": "ae8decfaba09bb374e9265ea561667593fc5a720",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/UpsertSearchAttributesTest.java",
    "status": "added",
    "additions": 130,
    "deletions": 0,
    "changes": 130,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/UpsertSearchAttributesTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/UpsertSearchAttributesTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/UpsertSearchAttributesTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,130 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+\n+import io.temporal.api.common.v1.SearchAttributes;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryRequest;\n+import io.temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryResponse;\n+import io.temporal.client.WorkflowClient;\n+import io.temporal.internal.common.SearchAttributesUtil;\n+import io.temporal.testing.TracingWorkerInterceptor;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestOptions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class UpsertSearchAttributesTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestUpsertSearchAttributesImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .setWorkerInterceptors(\n+              new TracingWorkerInterceptor(new TracingWorkerInterceptor.FilteredTrace()))\n+          .build();\n+\n+  @Test\n+  public void testUpsertSearchAttributes() {\n+    TestUpsertSearchAttributes testWorkflow =\n+        testWorkflowRule.newWorkflowStubTimeoutOptions(TestUpsertSearchAttributes.class);\n+    WorkflowExecution execution =\n+        WorkflowClient.start(testWorkflow::execute, testWorkflowRule.getTaskQueue(), \"testKey\");\n+    String result = testWorkflow.execute(testWorkflowRule.getTaskQueue(), \"testKey\");\n+    Assert.assertEquals(\"done\", result);\n+    testWorkflowRule\n+        .getInterceptor(TracingWorkerInterceptor.class)\n+        .setExpected(\n+            \"interceptExecuteWorkflow \" + SDKTestWorkflowRule.UUID_REGEXP,\n+            \"newThread workflow-method\",\n+            \"upsertSearchAttributes\",\n+            \"executeActivity Activity\",\n+            \"activity Activity\");\n+    GetWorkflowExecutionHistoryRequest request =\n+        GetWorkflowExecutionHistoryRequest.newBuilder()\n+            .setNamespace(SDKTestWorkflowRule.NAMESPACE)\n+            .setExecution(execution)\n+            .build();\n+    GetWorkflowExecutionHistoryResponse response =\n+        testWorkflowRule\n+            .getTestEnvironment()\n+            .getWorkflowService()\n+            .blockingStub()\n+            .getWorkflowExecutionHistory(request);\n+\n+    boolean found = false;\n+    for (HistoryEvent event : response.getHistory().getEventsList()) {\n+      if (EventType.EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES == event.getEventType()) {\n+        found = true;\n+        break;\n+      }\n+    }\n+    Assert.assertTrue(\"EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES found in the history\", found);\n+  }\n+\n+  @WorkflowInterface\n+  public interface TestUpsertSearchAttributes {\n+    @WorkflowMethod\n+    String execute(String taskQueue, String keyword);\n+  }\n+\n+  public static class TestUpsertSearchAttributesImpl implements TestUpsertSearchAttributes {\n+\n+    @Override\n+    public String execute(String taskQueue, String keyword) {\n+      SearchAttributes searchAttributes = Workflow.getInfo().getSearchAttributes();\n+      assertNull(searchAttributes);\n+\n+      Map<String, Object> searchAttrMap = new HashMap<>();\n+      searchAttrMap.put(\"CustomKeywordField\", keyword);\n+      Workflow.upsertSearchAttributes(searchAttrMap);\n+\n+      searchAttributes = Workflow.getInfo().getSearchAttributes();\n+      assertEquals(\n+          \"testKey\",\n+          SearchAttributesUtil.getValueFromSearchAttributes(\n+              searchAttributes, \"CustomKeywordField\", String.class));\n+\n+      // Running the activity below ensures that we have one more workflow task to be executed after\n+      // adding the search attributes. This helps with replaying the history one more time to check\n+      // against a possible NonDeterminisicWorkflowError which could be caused by missing\n+      // UpsertWorkflowSearchAttributes event in history.\n+      TestActivities activities =\n+          Workflow.newActivityStub(\n+              TestActivities.class, TestOptions.newActivityOptionsForTaskQueue(taskQueue));\n+      activities.activity();\n+\n+      return \"done\";\n+    }\n+  }\n+}"
  },
  {
    "sha": "26167a7334296877a7031e483bb6494a8b6b2277",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/WorkflowCancellationScopePromiseTest.java",
    "status": "renamed",
    "additions": 25,
    "deletions": 9,
    "changes": 34,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/WorkflowCancellationScopePromiseTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/WorkflowCancellationScopePromiseTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/WorkflowCancellationScopePromiseTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -19,32 +19,48 @@\n \n package io.temporal.workflow;\n \n+import io.temporal.client.WorkflowFailedException;\n+import io.temporal.client.WorkflowStub;\n+import io.temporal.failure.CanceledFailure;\n import io.temporal.workflow.shared.SDKTestWorkflowRule;\n import io.temporal.workflow.shared.TestActivities;\n-import io.temporal.workflow.shared.TestMultiargdsWorkflowFunctions;\n import io.temporal.workflow.shared.TestWorkflows;\n import org.junit.Assert;\n import org.junit.Rule;\n import org.junit.Test;\n \n-public class UntypedChildStubWorkflowTest {\n+public class WorkflowCancellationScopePromiseTest {\n \n   private final TestActivities.TestActivitiesImpl activitiesImpl =\n       new TestActivities.TestActivitiesImpl(null);\n \n   @Rule\n   public SDKTestWorkflowRule testWorkflowRule =\n       SDKTestWorkflowRule.newBuilder()\n-          .setWorkflowTypes(\n-              WorkflowTest.TestUntypedChildStubWorkflow.class,\n-              TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsImpl.class)\n+          .setWorkflowTypes(TestCancellationScopePromise.class)\n           .setActivityImplementations(activitiesImpl)\n           .build();\n \n   @Test\n-  public void testUntypedChildStubWorkflow() {\n-    TestWorkflows.TestWorkflow1 client =\n-        testWorkflowRule.newWorkflowStub200sTimeoutOptions(TestWorkflows.TestWorkflow1.class);\n-    Assert.assertEquals(null, client.execute(testWorkflowRule.getTaskQueue()));\n+  public void testWorkflowCancellationScopePromise() {\n+    WorkflowStub client = testWorkflowRule.newUntypedWorkflowStubTimeoutOptions(\"TestWorkflow1\");\n+    client.start(testWorkflowRule.getTaskQueue());\n+    client.cancel();\n+    try {\n+      client.getResult(String.class);\n+      Assert.fail(\"unreachable\");\n+    } catch (WorkflowFailedException e) {\n+      Assert.assertTrue(e.getCause() instanceof CanceledFailure);\n+    }\n+  }\n+\n+  public static class TestCancellationScopePromise implements TestWorkflows.TestWorkflow1 {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      Promise<String> cancellationRequest = CancellationScope.current().getCancellationRequest();\n+      cancellationRequest.get();\n+      return \"done\";\n+    }\n   }\n }",
    "previous_filename": "temporal-sdk/src/test/java/io/temporal/workflow/UntypedChildStubWorkflowTest.java"
  },
  {
    "sha": "99f95fe46aca74316337d13dd86684893623de0f",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/WorkflowFailureNonRetryableFlagTest.java",
    "status": "added",
    "additions": 103,
    "deletions": 0,
    "changes": 103,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/WorkflowFailureNonRetryableFlagTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/WorkflowFailureNonRetryableFlagTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/WorkflowFailureNonRetryableFlagTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,103 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.client.WorkflowException;\n+import io.temporal.common.RetryOptions;\n+import io.temporal.failure.ApplicationFailure;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestOptions;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+public class WorkflowFailureNonRetryableFlagTest {\n+\n+  private static final Map<String, AtomicInteger> retryCount = new ConcurrentHashMap<>();\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule public TestName testName = new TestName();\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestWorkflowNonRetryableFlag.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testWorkflowFailureNonRetryableFlag() {\n+    RetryOptions workflowRetryOptions =\n+        RetryOptions.newBuilder()\n+            .setInitialInterval(Duration.ofSeconds(1))\n+            .setMaximumAttempts(100)\n+            .setBackoffCoefficient(1.0)\n+            .build();\n+    WorkflowTest.TestWorkflowRetry workflowStub =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                WorkflowTest.TestWorkflowRetry.class,\n+                TestOptions.newWorkflowOptionsWithTimeouts(testWorkflowRule.getTaskQueue())\n+                    .toBuilder()\n+                    .setRetryOptions(workflowRetryOptions)\n+                    .build());\n+    try {\n+      workflowStub.execute(testName.getMethodName());\n+      Assert.fail(\"unreachable\");\n+    } catch (WorkflowException e) {\n+      Assert.assertTrue(e.getCause() instanceof ApplicationFailure);\n+      Assert.assertEquals(\"foo\", ((ApplicationFailure) e.getCause()).getType());\n+      Assert.assertEquals(\n+          \"details1\", ((ApplicationFailure) e.getCause()).getDetails().get(0, String.class));\n+      Assert.assertEquals(\n+          Integer.valueOf(123),\n+          ((ApplicationFailure) e.getCause()).getDetails().get(1, Integer.class));\n+      Assert.assertEquals(\n+          \"message='simulated 3', type='foo', nonRetryable=true\", e.getCause().getMessage());\n+    }\n+  }\n+\n+  public static class TestWorkflowNonRetryableFlag implements WorkflowTest.TestWorkflowRetry {\n+\n+    @Override\n+    public String execute(String testName) {\n+      AtomicInteger count = retryCount.get(testName);\n+      if (count == null) {\n+        count = new AtomicInteger();\n+        retryCount.put(testName, count);\n+      }\n+      int c = count.incrementAndGet();\n+      ApplicationFailure f =\n+          ApplicationFailure.newFailure(\"simulated \" + c, \"foo\", \"details1\", 123);\n+      if (c == 3) {\n+        f.setNonRetryable(true);\n+      }\n+      throw f;\n+    }\n+  }\n+}"
  },
  {
    "sha": "060e3abc833be7477fa2846cd1bdc072b98d39b0",
    "filename": "temporal-sdk/src/test/java/io/temporal/workflow/WorkflowIdResuePolicyTest.java",
    "status": "added",
    "additions": 88,
    "deletions": 0,
    "changes": 88,
    "blob_url": "https://github.com/temporalio/sdk-java/blob/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/WorkflowIdResuePolicyTest.java",
    "raw_url": "https://github.com/temporalio/sdk-java/raw/91f8ea082c8b0e3da657052380ba056be0ab5e64/temporal-sdk/src/test/java/io/temporal/workflow/WorkflowIdResuePolicyTest.java",
    "contents_url": "https://api.github.com/repos/temporalio/sdk-java/contents/temporal-sdk/src/test/java/io/temporal/workflow/WorkflowIdResuePolicyTest.java?ref=91f8ea082c8b0e3da657052380ba056be0ab5e64",
    "patch": "@@ -0,0 +1,88 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.api.enums.v1.WorkflowIdReusePolicy;\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.workflow.shared.SDKTestWorkflowRule;\n+import io.temporal.workflow.shared.TestActivities;\n+import io.temporal.workflow.shared.TestMultiargdsWorkflowFunctions;\n+import io.temporal.workflow.shared.TestOptions;\n+import java.util.UUID;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class WorkflowIdResuePolicyTest {\n+\n+  private final TestActivities.TestActivitiesImpl activitiesImpl =\n+      new TestActivities.TestActivitiesImpl(null);\n+\n+  @Rule\n+  public SDKTestWorkflowRule testWorkflowRule =\n+      SDKTestWorkflowRule.newBuilder()\n+          .setWorkflowTypes(TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsImpl.class)\n+          .setActivityImplementations(activitiesImpl)\n+          .build();\n+\n+  @Test\n+  public void testWorkflowIdResuePolicy() {\n+    // When WorkflowIdReusePolicy is not AllowDuplicate the semantics is to get result for the\n+    // previous run.\n+    String workflowId = UUID.randomUUID().toString();\n+    WorkflowOptions workflowOptions =\n+        TestOptions.newWorkflowOptionsWithTimeouts(testWorkflowRule.getTaskQueue())\n+            .toBuilder()\n+            .setWorkflowIdReusePolicy(\n+                WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY)\n+            .setWorkflowId(workflowId)\n+            .build();\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc1 stubF1_1 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc1.class, workflowOptions);\n+    Assert.assertEquals(1, stubF1_1.func1(1));\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc1 stubF1_2 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc1.class, workflowOptions);\n+    Assert.assertEquals(1, stubF1_2.func1(2));\n+\n+    // Setting WorkflowIdReusePolicy to AllowDuplicate will trigger new run.\n+    workflowOptions =\n+        TestOptions.newWorkflowOptionsWithTimeouts(testWorkflowRule.getTaskQueue())\n+            .toBuilder()\n+            .setWorkflowIdReusePolicy(\n+                WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE)\n+            .setWorkflowId(workflowId)\n+            .build();\n+    TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc1 stubF1_3 =\n+        testWorkflowRule\n+            .getWorkflowClient()\n+            .newWorkflowStub(\n+                TestMultiargdsWorkflowFunctions.TestMultiargsWorkflowsFunc1.class, workflowOptions);\n+    Assert.assertEquals(2, stubF1_3.func1(2));\n+\n+    // Setting WorkflowIdReusePolicy to RejectDuplicate or AllowDuplicateFailedOnly does not work as\n+    // expected. See https://github.com/uber/cadence-java-client/issues/295.\n+  }\n+}"
  }
]
