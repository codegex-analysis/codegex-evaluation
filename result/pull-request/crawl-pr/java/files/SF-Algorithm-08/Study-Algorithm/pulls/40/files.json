[
  {
    "sha": "6a8f9a107907c5ccfac04aba7bab26634e7776eb",
    "filename": "배수연/3월 3주차/3월 3주차 풀이.md",
    "status": "added",
    "additions": 121,
    "deletions": 0,
    "changes": 121,
    "blob_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/blob/ef041e146f6c7d61d8509c695fc9bee141fd5ada/%EB%B0%B0%EC%88%98%EC%97%B0/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8%20%ED%92%80%EC%9D%B4.md",
    "raw_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/raw/ef041e146f6c7d61d8509c695fc9bee141fd5ada/%EB%B0%B0%EC%88%98%EC%97%B0/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8%20%ED%92%80%EC%9D%B4.md",
    "contents_url": "https://api.github.com/repos/SF-Algorithm-08/Study-Algorithm/contents/%EB%B0%B0%EC%88%98%EC%97%B0/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8%20%ED%92%80%EC%9D%B4.md?ref=ef041e146f6c7d61d8509c695fc9bee141fd5ada",
    "patch": "@@ -0,0 +1,121 @@\n+# 3월 3주차 풀이\n+\n+# BOJ_G4_5052 - 전화번호 목록\n+\n+### Idea\n+\n+- 문자열 정렬 -> 사전식으로 정렬됨\n+- 예를 들어 [911, 9112, 9113, 912] 순으로 정렬되면 911은 바로 옆의 9112만 비교하면 된다. 9112만 확인해도 일관성 없음이 판별되기 때문에 9113은 판별할 필요가 없다.\n+- 911 문자열 길이가 3이므로 다음 문자의 앞에서부터 3글자만 비교하면 된다. => substring 이용\n+\n+### Code\n+\n+``` java\n+\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n+\t\t...\n+\t\t\tArrays.sort(numbers);\n+\t\t\tfor(int n = 0 ; n<N-1 ; n++) {\n+\t\t\t\tint temp_len = numbers[n].length();\n+\t\t\t\tint next_len = numbers[n+1].length();\n+\t\t\t\tif(temp_len<next_len) { // 현재 문자가 다음 비교할 문자의 길이보다 길면 아예 다른 문자이므로 비교 안함\n+\t\t\t\t\tif(numbers[n+1].substring(0, temp_len).equals(numbers[n])) {\n+\t\t\t\t\t\tans = \"NO\";\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t...\n+\t}\n+```\n+\n+### 정리\n+\n+처음에는 맨 앞부분부터 겹쳐야한다고 생각해서 for문으로 한글자 한글자 비교해서 풀려고 했다. 그런데 for문 중첩이 많아지는 것 같아서 포기했다. 그 다음에는 맨 처음이 아니더라도 어디에든 포함만 되면 되지 않나 생각해서 numbers[n].contains(numbers[n+1])로 풀었다. 그런데 제출해보니 끝까지 다 가서 틀렸다고 떠서 조건 조금씩 바꿔봤는데 오히려 25%에서 틀려서 이 방법도 포기했다. 그래서 마지막에 생각해낸게 substring을 이용한 방법이었다. 전에 문자열 비교할때 ==으로 비교해서 많이 틀렸었는데 이번에는 바로 .equals 생각해서 바로 통과했다.\n+\n+------\n+\n+# BOJ_G4_2573 - 빙산\n+\n+### Idea\n+\n+- DFS, 완탐\n+- 빙산 덩어리 개수 구하면서 인접 바다 수 구해주기\n+- 빙산 높이에서 바다 수 빼가면서 높이 변화시키고 빙산 덩어리 개수 구하기\n+- 빙산 덩어리 개수가 0이라면 분리 안된다는 의미니까 0 출력, 2 이상이면 그때까지 걸린 반복 횟수 출력\n+\n+### Code\n+\n+``` java\n+public class BOJ_G4_2573 {\n+\tpublic static void main(String[] args) throws IOException {\n+\t\t...input...\t\n+\t\tans = 0;\n+\t\twhile(true) {\n+\t\t\t// 빙산 개수, 인접 바다 수 구하기\n+\t\t\tland = 0;\n+         \t for(int i = 0 ; i<N ; i++) {\n+\t\t\t\tArrays.fill(visited[i], 0);\n+\t\t\t\tArrays.fill(melt[i], 0);\n+\t\t\t}\n+\t\t\tfor(int i = 0 ; i<N ; i++) {\n+\t\t\t\tfor(int j = 0 ; j<M ; j++) {\n+\t\t\t\t\tif(visited[i][j] == 0 && map[i][j] != 0) {\n+\t\t\t\t\t\tcountLand(i, j);\n+\t\t\t\t\t\tland++;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\t// 빙산 개수 판별\n+\t\t\tif(land == 0) {\n+\t\t\t\tSystem.out.println(0);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\telse if(land >= 2) {\n+\t\t\t\tSystem.out.println(ans);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\t\n+\t\t\t// 빙산이 분리되지 않은 경우 빙산 녹이기\n+\t\t\tfor(int i = 0 ; i<N ; i++) {\n+\t\t\t\tfor(int j = 0 ; j<M ; j++) {\n+\t\t\t\t\tmap[i][j] -= melt[i][j];\n+\t\t\t\t\tif(map[i][j] < 0) map[i][j] = 0;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tans++;\n+\t\t}\n+\t}\n+\tpublic static void countLand(int r, int c) {\n+\t\tvisited[r][c] = 1;\n+\t\tint nr = 0, nc = 0;\n+\t\tfor(int d = 0 ; d<4 ; d++) {\n+\t\t\tnr = r+dr[d];\n+\t\t\tnc = c+dc[d];\n+\t\t\tif(nr>-1 && nr<N && nc>-1 && nc<M && map[nr][nc] == 0) {\n+\t\t\t\tmelt[r][c]++;\n+\t\t\t}\n+\t\t\tif(visited[nr][nc] == 0 && map[nr][nc] != 0) {\n+\t\t\t\tcountLand(nr, nc);\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+```\n+\n+### 정리\n+\n+지난번에 스터디 연습에서 풀었던 2146번 다리만들기와 비슷하다고 생각했다. 그때는 덩어리 별로 나눠서 색을 구분했고 이번엔 덩어리 개수를 세야 해서 유사하다고 생각했다. 이번에도 그때랑 비슷하게 단순 4방 완탐으로 풀었는데 풀고 나서 보니까 DFS인 것 같다. 처음에는 어떻게 해야할지 조금 헷갈렸는데 문제를 읽어보고 어떤 순서로 할지 주석 먼저 달고 하니까 문제가 풀렸다.\n+\n+------\n+\n+# BOJ_S1_6118 - 숨바꼭질\n+\n+### Idea\n+\n+- 문제 이해도 잘 안가고 문제에 같이 제시된 힌트 보고 그래프라는건 알았는데 해결 방법을 모르겠어서 구글링해보고 풀었다.\n+- 다익스트라 문제\n+\n+### 정리\n+\n+풀이 방법을 생각할 때에는 단순 BFS로만 생각했는데 어떻게 방문을 해줘야 하는지 전혀 감이 오지 않았다. 그래서 한참 고민하다가 이건 절대 안되겠다 싶어서 구글링했다. 코드를 보고 한줄한줄 따라서 쳐보니 단순 BFS보다 조금 더 심화된 느낌이라고 생각했다. 다익스트라는 처음이라 완전 새롭게 다가와서 그래프 이론 배우고 문제 좀 풀어봐야겠다고 생각했다.\n\\ No newline at end of file"
  },
  {
    "sha": "3cbdb8b3a5e799e0e89028efbfc9212eb311682a",
    "filename": "배수연/3월 3주차/BOJ_G4_2573.java",
    "status": "added",
    "additions": 93,
    "deletions": 0,
    "changes": 93,
    "blob_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/blob/ef041e146f6c7d61d8509c695fc9bee141fd5ada/%EB%B0%B0%EC%88%98%EC%97%B0/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_G4_2573.java",
    "raw_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/raw/ef041e146f6c7d61d8509c695fc9bee141fd5ada/%EB%B0%B0%EC%88%98%EC%97%B0/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_G4_2573.java",
    "contents_url": "https://api.github.com/repos/SF-Algorithm-08/Study-Algorithm/contents/%EB%B0%B0%EC%88%98%EC%97%B0/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_G4_2573.java?ref=ef041e146f6c7d61d8509c695fc9bee141fd5ada",
    "patch": "@@ -0,0 +1,93 @@\n+package boj;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.Arrays;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * 빙산\n+ * 빙산 덩어리 개수 구하면서 인접 바다 수 구하기\n+ * 빙산 높이에서 바다 수 빼면서 높이 변화시키기\n+ */\n+\n+public class BOJ_G4_2573 {\n+\tstatic int N, M, land, ans;\n+\tstatic int[][] map;\n+\tstatic int[][] melt;\n+\tstatic int[][] visited;\n+\tstatic int[] dr = {-1, 1, 0, 0};\n+\tstatic int[] dc = {0, 0, -1, 1};\n+\n+\tpublic static void main(String[] args) throws IOException {\n+\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+\t\tStringTokenizer st;\n+\t\tst = new StringTokenizer(br.readLine());\n+\t\tN = Integer.parseInt(st.nextToken());\n+\t\tM = Integer.parseInt(st.nextToken());\n+\t\tmap = new int[N][M];\n+\t\tmelt = new int[N][M];\n+\t\tvisited = new int[N][M];\n+\t\tfor(int n = 0 ; n<N ; n++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tfor(int m = 0 ; m<M ; m++) {\n+\t\t\t\tmap[n][m] = Integer.parseInt(st.nextToken());\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tans = 0;\n+\t\twhile(true) {\n+\t\t\t// 빙산 개수, 인접 바다 수 구하기\n+\t\t\tland = 0;\n+\t\t\tfor(int i = 0 ; i<N ; i++) {\n+\t\t\t\tArrays.fill(visited[i], 0);\n+\t\t\t\tArrays.fill(melt[i], 0);\n+\t\t\t}\n+\t\t\tfor(int i = 0 ; i<N ; i++) {\n+\t\t\t\tfor(int j = 0 ; j<M ; j++) {\n+\t\t\t\t\tif(visited[i][j] == 0 && map[i][j] != 0) {\n+\t\t\t\t\t\tcountLand(i, j);\n+\t\t\t\t\t\tland++;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\t// 빙산 개수 판별\n+\t\t\tif(land == 0) {\n+\t\t\t\tSystem.out.println(0);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\telse if(land >= 2) {\n+\t\t\t\tSystem.out.println(ans);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\t\n+\t\t\t// 빙산 녹이기\n+\t\t\tfor(int i = 0 ; i<N ; i++) {\n+\t\t\t\tfor(int j = 0 ; j<M ; j++) {\n+\t\t\t\t\tmap[i][j] -= melt[i][j];\n+\t\t\t\t\tif(map[i][j] < 0) map[i][j] = 0;\n+//\t\t\t\t\tvisited[i][j] = 0;\n+//\t\t\t\t\tmelt[i][j] = 0;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tans++;\n+\t\t}\n+\t}\n+\tpublic static void countLand(int r, int c) {\n+\t\tvisited[r][c] = 1;\n+\t\tint nr = 0, nc = 0;\n+\t\tfor(int d = 0 ; d<4 ; d++) {\n+\t\t\tnr = r+dr[d];\n+\t\t\tnc = c+dc[d];\n+\t\t\tif(nr>-1 && nr<N && nc>-1 && nc<M && map[nr][nc] == 0) {\n+\t\t\t\tmelt[r][c]++;\n+\t\t\t}\n+\t\t\tif(visited[nr][nc] == 0 && map[nr][nc] != 0) {\n+\t\t\t\tcountLand(nr, nc);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+}"
  },
  {
    "sha": "528a3c79efcfa2f2bf817c02588654a30500a552",
    "filename": "배수연/3월 3주차/BOJ_G4_5052.java",
    "status": "added",
    "additions": 54,
    "deletions": 0,
    "changes": 54,
    "blob_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/blob/ef041e146f6c7d61d8509c695fc9bee141fd5ada/%EB%B0%B0%EC%88%98%EC%97%B0/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_G4_5052.java",
    "raw_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/raw/ef041e146f6c7d61d8509c695fc9bee141fd5ada/%EB%B0%B0%EC%88%98%EC%97%B0/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_G4_5052.java",
    "contents_url": "https://api.github.com/repos/SF-Algorithm-08/Study-Algorithm/contents/%EB%B0%B0%EC%88%98%EC%97%B0/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_G4_5052.java?ref=ef041e146f6c7d61d8509c695fc9bee141fd5ada",
    "patch": "@@ -0,0 +1,54 @@\n+package boj;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.Arrays;\n+\n+/**\n+ * 전화번호 목록\n+ * 사전식 정렬 -> 일관성이 없는건 바로 옆에 위치할 수밖에 없음\n+ */\n+public class BOJ_G4_5052 {\n+\tstatic int T, N;\n+\tstatic String[] numbers;\n+\n+\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n+\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+\t\tT = Integer.parseInt(br.readLine());\n+\t\tfor(int test = 1 ; test<=T ; test++) {\n+\t\t\tN = Integer.parseInt(br.readLine());\n+\t\t\tnumbers = new String[N];\n+\t\t\tString ans = \"YES\";\n+\t\t\tfor(int n = 0 ; n<N ; n++) {\n+\t\t\t\tnumbers[n] = br.readLine();\n+\t\t\t}\n+\t\t\tArrays.sort(numbers);\n+\t\t\tfor(int n = 0 ; n<N-1 ; n++) {\n+\t\t\t\tint temp_len = numbers[n].length();\n+\t\t\t\tint next_len = numbers[n+1].length();\n+\t\t\t\tif(temp_len<next_len) {\n+\t\t\t\t\tif(numbers[n+1].substring(0, temp_len).equals(numbers[n])) {\n+\t\t\t\t\t\tans = \"NO\";\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+//\t\t\t\tint idx = 0;\n+//\t\t\t\tint min = Math.min(temp_len, next_len);\n+//\t\t\t\twhile(idx<min) {\n+//\t\t\t\t\tif(numbers[n].charAt(idx) == numbers[n+1].charAt(idx)) {\n+//\t\t\t\t\t\tans = \"NO\";\n+//\t\t\t\t\t\tbreak;\n+//\t\t\t\t\t}\n+//\t\t\t\t\tidx++;\n+//\t\t\t\t}\n+//\t\t\t\tif(numbers[n].contains(numbers[n+1]) || numbers[n+1].contains(numbers[n])) {\n+//\t\t\t\t\tans = \"NO\";\n+//\t\t\t\t\tbreak;\n+//\t\t\t\t}\n+\t\t\t\t\n+\t\t\t}\n+\t\t\tSystem.out.println(ans);\n+\t\t}\n+\t}\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "e0f3150c59adabb664c17f55a8b6ebec5e6da28c",
    "filename": "배수연/3월 3주차/BOJ_S1_6118.java",
    "status": "added",
    "additions": 73,
    "deletions": 0,
    "changes": 73,
    "blob_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/blob/ef041e146f6c7d61d8509c695fc9bee141fd5ada/%EB%B0%B0%EC%88%98%EC%97%B0/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_S1_6118.java",
    "raw_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/raw/ef041e146f6c7d61d8509c695fc9bee141fd5ada/%EB%B0%B0%EC%88%98%EC%97%B0/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_S1_6118.java",
    "contents_url": "https://api.github.com/repos/SF-Algorithm-08/Study-Algorithm/contents/%EB%B0%B0%EC%88%98%EC%97%B0/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_S1_6118.java?ref=ef041e146f6c7d61d8509c695fc9bee141fd5ada",
    "patch": "@@ -0,0 +1,73 @@\n+package boj;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.StringTokenizer;\n+\n+public class BOJ_S1_6118 {\n+\tstatic int N, M, from, to;\n+\tstatic ArrayList<Integer>[] road;\n+\n+\tpublic static void main(String[] args) throws IOException {\n+\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n+\t\tN = Integer.parseInt(st.nextToken());\n+\t\tM = Integer.parseInt(st.nextToken());\n+\t\troad = new ArrayList[N+1];\n+\t\tfor(int i = 0 ; i<=N ; i++) {\n+\t\t\troad[i] = new ArrayList<>();\n+\t\t}\n+\t\t\n+\t\t// 노드 간 연결 정보를 저장해야 하므로 from에는 to, to에는 from 정보를 저장해준다.\n+\t\tfor(int m = 0 ; m<M ; m++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tfrom = Integer.parseInt(st.nextToken());\n+\t\t\tto = Integer.parseInt(st.nextToken());\n+\t\t\troad[from].add(to);\n+\t\t\troad[to].add(from);\n+\t\t}\n+\t\t\n+\t\t// 1번 헛간부터 판별\n+\t\tdijkstra(1);\n+\t}\n+\tprivate static void dijkstra(int v) {\n+\t\tint[] dist = new int[N+1]; // 각 노드를 몇 번째로 방문할 수 있는지 저장\n+\t\tboolean[] visited = new boolean[N+1];\n+\t\tArrays.fill(dist, Integer.MAX_VALUE);\n+\t\t\n+\t\t// BFS\n+\t\tQueue<Integer> queue = new LinkedList<>();\n+\t\tdist[v] = 0;\n+\t\tvisited[v] = true;\n+\t\tqueue.offer(v); // 첫 번째 노드부터 탐색 시작\n+\t\t\n+\t\twhile(!queue.isEmpty()) {\n+\t\t\tint temp = queue.poll();\n+\t\t\tfor(int i = 0 ; i<road[temp].size() ; i++) {\n+\t\t\t\tint next = road[temp].get(i); // 연결된 노드를 판별\n+\t\t\t\tif(!visited[next] && dist[next]>dist[temp]+1) { // 다음 노드에 방문하는 데 걸린 횟수가 최소가 되도록 반복\n+\t\t\t\t\tdist[next] = dist[temp]+1;\n+\t\t\t\t\tqueue.offer(next);\n+\t\t\t\t\tvisited[next] = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\t// 최댓값 찾기\n+\t\tint max = 0, maxPos = 0, maxNum = 0;\n+\t\tfor(int i = 1 ; i<=N ; i++) {\n+\t\t\tif(max<dist[i]) { // 방문할 수 있는 최대 거리의 노드라면\n+\t\t\t\tmax = dist[i];\n+\t\t\t\tmaxPos = i;\n+\t\t\t\tmaxNum = 1; // 거리가 가장 먼 노드의 개수를 1로 초기화\n+\t\t\t}\n+\t\t\telse if(max == dist[i]) maxNum++; // 거리가 같으면 개수를 늘려줌\n+\t\t}\n+\t\tSystem.out.println(maxPos + \" \" + max + \" \" + maxNum);\n+\t}\n+}\n\\ No newline at end of file"
  }
]
