[
  {
    "sha": "8b382dc030f02daf460be9f1f236d9e5369f84fa",
    "filename": "김나은/3월 3주차/3월 3주차 문제 정리.md",
    "status": "added",
    "additions": 154,
    "deletions": 0,
    "changes": 154,
    "blob_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/blob/22aafc404c8c1bd4d3cdbf7c94bc81ad6961db3f/%EA%B9%80%EB%82%98%EC%9D%80/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8%20%EB%AC%B8%EC%A0%9C%20%EC%A0%95%EB%A6%AC.md",
    "raw_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/raw/22aafc404c8c1bd4d3cdbf7c94bc81ad6961db3f/%EA%B9%80%EB%82%98%EC%9D%80/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8%20%EB%AC%B8%EC%A0%9C%20%EC%A0%95%EB%A6%AC.md",
    "contents_url": "https://api.github.com/repos/SF-Algorithm-08/Study-Algorithm/contents/%EA%B9%80%EB%82%98%EC%9D%80/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8%20%EB%AC%B8%EC%A0%9C%20%EC%A0%95%EB%A6%AC.md?ref=22aafc404c8c1bd4d3cdbf7c94bc81ad6961db3f",
    "patch": "@@ -0,0 +1,154 @@\n+#  3월 3주차 풀이\n+## BOJ S1 6118 숨바꼭질\n+### **Idea**\n+* 모든 헛간은 양방향 길로 이어져 있으므로 그래프 사용\n+* 헛간의 개수 N(2≤N≤20000) 이므로 2차원 배열로 풀 수 없다! => ArrayList 사용\n+* bfs 이용하여 헛간 탐색\n+\n+### 코드\n+```java\n+private static void bfs(int cur) {\n+\tQueue<Integer> queue = new LinkedList<Integer>();\n+\tboolean[] visited = new boolean[N + 1];\n+\tint[] distance = new int[N + 1];\n+\t\n+\tqueue.offer(cur);\n+\tvisited[cur] = true;\n+\t\n+\twhile (!queue.isEmpty()) {\n+\t\tcur = queue.poll();\n+\t\tfor (int temp : adjList[cur]) {\n+\t\t\tif (!visited[temp]) {\n+\t\t\t\tqueue.offer(temp);\n+\t\t\t\tvisited[temp] = true;\n+\t\t\t\tdistance[temp] = distance[cur] + 1;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tint idx = 0, dist = Integer.MIN_VALUE, cnt = 0;\n+\tfor (int i = 0; i <= N; i++) {\n+\t\tif (distance[i] > dist) {\n+\t\t\tdist = distance[i];\n+\t\t\tidx = i;\n+\t\t\tcnt = 1;\n+\t\t} else if (distance[i] == dist)\n+\t\t\tcnt++;\n+\t}\n+\t\n+\tSystem.out.println(idx + \" \" + distance[idx] + \" \" + cnt);\t\n+```\n+\n+### 후기\n+\n+화요일에 공부한 그래프를 이용해보았다!\n+distance[temp] = distance[cur] + 1; 이 한줄만 추가하면 되서 크게 어렵지는 않았던 것 같다.\n+\n+---\n+\n+## BOJ G4 2573 빙산\n+### **Idea**\n+* 빙산이 한 덩어리인지 아닌지 판별하기 위해서 동서남북 네 방향을 탐색해야하기 때문에 bfs 이용\n+* 빙산이 녹은 후 전체 배열을 탐색하며 0이 아닌 칸의 개수(cnt)와 bfs로 탐색하여 0이 아닌 칸의 개수(count)가 동일하면 빙산은 한 덩어리, 동일하지 않으면 분리되었음\n+\n+### 코드\n+\n+```java\n+while (true) {\n+\tans++;\n+\n+\t// 빙산이 녹는 양\n+\tint[][] melt = new int[N][M];\n+\tfor (int r = 0; r < N; r++) {\n+\t\tfor (int c = 0; c < M; c++) {\n+\t\t\tif (iceberg[r][c] > 0) {\n+\t\t\t\tint m = 0;\n+\t\t\t\tfor (int d = 0; d < 4; d++) {\n+\t\t\t\t\tint nr = r + dr[d];\n+\t\t\t\t\tint nc = c + dc[d];\n+\t\t\t\t\tif (0 <= nr && nr < N && 0 <= nc && nc < M && iceberg[nr][nc] == 0)\n+\t\t\t\t\t\tm++;\n+\t\t\t\t}\n+\t\t\t\tmelt[r][c] = m;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tQueue<int[]> queue = new LinkedList<int[]>();\n+\tboolean[][] visit = new boolean[N][M];\n+\tint cnt = 0;\n+\tfor (int i = 0; i < N; i++) {\n+\t\tfor (int j = 0; j < M; j++) {\n+\t\t\ticeberg[i][j] -= melt[i][j]; // 빙산 녹음\n+\t\t\tif (iceberg[i][j] < 0)\n+\t\t\t\ticeberg[i][j] = 0; // 높이는 0보다 더 줄어들지 않는다\n+\t\t\telse if (iceberg[i][j] > 0) {\n+\t\t\t\tcnt++;\n+\t\t\t\tif (queue.isEmpty()) {\n+\t\t\t\t\tqueue.offer(new int[] { i, j });\n+\t\t\t\t\tvisit[i][j] = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif (cnt == 0) {\n+\t\tSystem.out.println(0);\n+\t\treturn;\n+\t}\n+\n+\tint size = 1;\n+\twhile (!queue.isEmpty()) {\n+\t\tint[] cur = queue.poll();\n+\t\tfor (int d = 0; d < 4; d++) {\n+\t\t\tint nr = cur[0] + dr[d];\n+\t\t\tint nc = cur[1] + dc[d];\n+\t\t\tif (0 <= nr && nr < N && 0 <= nc && nc < M && iceberg[nr][nc] > 0 && !visit[nr][nc]) {\n+\t\t\t\tvisit[nr][nc] = true;\n+\t\t\t\tqueue.offer(new int[] { nr, nc });\n+\t\t\t\tsize++;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif (size != cnt) {\n+\t\tSystem.out.println(ans);\n+\t\treturn;\n+\t}\n+}\n+```\n+\n+### 후기\n+\n+저번에 풀었던 다리만들기의 낮은? 버전인 것 같다.\n+나는 빙산이 녹은 후에 한 덩어리인지 아닌지 판별해주었는데, 빙산 개수를 판별한 후에 빙산을 녹이는 코드가 더욱 간결한 것 같다.\n+코드 깔끔하게 짜고 싶다... bfs 최적화는 어려웡\n+\n+----\n+\n+## BOJ G4 5052 전화번호 목록\n+### **Idea**\n+* sort를 통해 사전식으로 정렬(오름차순)\n+* startsWith 메소드를 이용하여 일관성 판별 => 사전식으로 정렬되어있기 때문에 만약 문자열이 접두어 관계를 가진다면 붙어있다!\n+\n+### 코드\n+\n+```java\n+Arrays.sort(tel);\n+\n+boolean flag = false;\n+for (int i = 1; i < N; i++) {\n+\tif (tel[i].startsWith(tel[i - 1])) {\n+\t\tflag = true;\n+\t\tbreak;\n+\t}\n+}\n+\n+if (flag) System.out.println(\"NO\");\n+else System.out.println(\"YES\");\n+```\n+\n+### 후기\n+\n+문제를 푸는 데는 10분도 안 걸렸지만 오타를 찾는데는 20분이 넘게 걸린 어처구니가 없었던...\n+\"NO\"를 출력해야하는데 \"No\"를  출력해서 로직 고치고 디버깅하고 헛수고 투성이었던 재밌는 문제였다^^ 하하\n\\ No newline at end of file"
  },
  {
    "sha": "8637817cd15e751145921b5ebfd43aebf13c1cf6",
    "filename": "김나은/3월 3주차/BOJ_G4_2573.java",
    "status": "added",
    "additions": 98,
    "deletions": 0,
    "changes": 98,
    "blob_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/blob/22aafc404c8c1bd4d3cdbf7c94bc81ad6961db3f/%EA%B9%80%EB%82%98%EC%9D%80/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_G4_2573.java",
    "raw_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/raw/22aafc404c8c1bd4d3cdbf7c94bc81ad6961db3f/%EA%B9%80%EB%82%98%EC%9D%80/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_G4_2573.java",
    "contents_url": "https://api.github.com/repos/SF-Algorithm-08/Study-Algorithm/contents/%EA%B9%80%EB%82%98%EC%9D%80/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_G4_2573.java?ref=22aafc404c8c1bd4d3cdbf7c94bc81ad6961db3f",
    "patch": "@@ -0,0 +1,98 @@\n+// 빙산\n+\n+package algo;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.StringTokenizer;\n+\n+public class BOJ_G4_2573 {\n+\n+\tstatic int[] dr = { -1, 1, 0, 0 };\n+\tstatic int[] dc = { 0, 0, -1, 1 };\n+\n+\tpublic static void main(String[] args) throws IOException {\n+\n+\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n+\t\t\n+\t\tint N = Integer.parseInt(st.nextToken());\n+\t\tint M = Integer.parseInt(st.nextToken());\n+\t\tint[][] iceberg = new int[N][M];\n+\t\tint ans = 0;\n+\n+\t\tfor (int i = 0; i < N; i++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tfor (int j = 0; j < M; j++) {\n+\t\t\t\ticeberg[i][j] = Integer.parseInt(st.nextToken());\n+\t\t\t}\n+\t\t}\n+\n+\t\twhile (true) {\n+\t\t\tans++;\n+\n+\t\t\t// 빙산이 녹는 양\n+\t\t\tint[][] melt = new int[N][M];\n+\t\t\tfor (int r = 0; r < N; r++) {\n+\t\t\t\tfor (int c = 0; c < M; c++) {\n+\t\t\t\t\tif (iceberg[r][c] > 0) {\n+\t\t\t\t\t\tint m = 0;\n+\t\t\t\t\t\tfor (int d = 0; d < 4; d++) {\n+\t\t\t\t\t\t\tint nr = r + dr[d];\n+\t\t\t\t\t\t\tint nc = c + dc[d];\n+\t\t\t\t\t\t\tif (0 <= nr && nr < N && 0 <= nc && nc < M && iceberg[nr][nc] == 0)\n+\t\t\t\t\t\t\t\tm++;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tmelt[r][c] = m;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tQueue<int[]> queue = new LinkedList<int[]>();\n+\t\t\tboolean[][] visit = new boolean[N][M];\n+\t\t\tint cnt = 0;\n+\t\t\tfor (int i = 0; i < N; i++) {\n+\t\t\t\tfor (int j = 0; j < M; j++) {\n+\t\t\t\t\ticeberg[i][j] -= melt[i][j]; // 빙산 녹음\n+\t\t\t\t\tif (iceberg[i][j] < 0)\n+\t\t\t\t\t\ticeberg[i][j] = 0; // 높이는 0보다 더 줄어들지 않는다\n+\t\t\t\t\telse if (iceberg[i][j] > 0) {\n+\t\t\t\t\t\tcnt++;\n+\t\t\t\t\t\tif (queue.isEmpty()) {\n+\t\t\t\t\t\t\tqueue.offer(new int[] { i, j });\n+\t\t\t\t\t\t\tvisit[i][j] = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (cnt == 0) {\n+\t\t\t\tSystem.out.println(0);\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tint count = 1;\n+\t\t\twhile (!queue.isEmpty()) {\n+\t\t\t\tint[] cur = queue.poll();\n+\t\t\t\tfor (int d = 0; d < 4; d++) {\n+\t\t\t\t\tint nr = cur[0] + dr[d];\n+\t\t\t\t\tint nc = cur[1] + dc[d];\n+\t\t\t\t\tif (0 <= nr && nr < N && 0 <= nc && nc < M && iceberg[nr][nc] > 0 && !visit[nr][nc]) {\n+\t\t\t\t\t\tvisit[nr][nc] = true;\n+\t\t\t\t\t\tqueue.offer(new int[] { nr, nc });\n+\t\t\t\t\t\tcount++;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (count != cnt) {\n+\t\t\t\tSystem.out.println(ans);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+}"
  },
  {
    "sha": "16173af519586409e39c896b7940305a944e6e4d",
    "filename": "김나은/3월 3주차/BOJ_G4_5052.java",
    "status": "added",
    "additions": 42,
    "deletions": 0,
    "changes": 42,
    "blob_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/blob/22aafc404c8c1bd4d3cdbf7c94bc81ad6961db3f/%EA%B9%80%EB%82%98%EC%9D%80/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_G4_5052.java",
    "raw_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/raw/22aafc404c8c1bd4d3cdbf7c94bc81ad6961db3f/%EA%B9%80%EB%82%98%EC%9D%80/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_G4_5052.java",
    "contents_url": "https://api.github.com/repos/SF-Algorithm-08/Study-Algorithm/contents/%EA%B9%80%EB%82%98%EC%9D%80/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_G4_5052.java?ref=22aafc404c8c1bd4d3cdbf7c94bc81ad6961db3f",
    "patch": "@@ -0,0 +1,42 @@\n+// 전화번호 목록\n+\n+package algo;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.Arrays;\n+\n+public class BOJ_G4_5052 {\n+\n+\tpublic static void main(String[] args) throws IOException {\n+\n+\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+\t\tint T = Integer.parseInt(br.readLine());\n+\n+\t\tfor (int tc = 1; tc <= T; tc++) {\n+\t\t\tint N = Integer.parseInt(br.readLine());\n+\t\t\tString[] tel = new String[N];\n+\n+\t\t\tfor (int i = 0; i < N; i++) {\n+\t\t\t\ttel[i] = br.readLine();\n+\t\t\t}\n+\n+\t\t\tArrays.sort(tel);\n+\n+\t\t\tboolean flag = false;\n+\t\t\tfor (int i = 1; i < N; i++) {\n+\t\t\t\tif (tel[i].startsWith(tel[i - 1])) {\n+\t\t\t\t\tflag = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (flag) System.out.println(\"NO\");\n+\t\t\telse System.out.println(\"YES\");\n+\t\t\t\n+\t\t}\n+\t}\n+}"
  },
  {
    "sha": "029f387a941c09720b373cd222530427a2d95fbb",
    "filename": "김나은/3월 3주차/BOJ_S1_6118.java",
    "status": "added",
    "additions": 73,
    "deletions": 0,
    "changes": 73,
    "blob_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/blob/22aafc404c8c1bd4d3cdbf7c94bc81ad6961db3f/%EA%B9%80%EB%82%98%EC%9D%80/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_S1_6118.java",
    "raw_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/raw/22aafc404c8c1bd4d3cdbf7c94bc81ad6961db3f/%EA%B9%80%EB%82%98%EC%9D%80/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_S1_6118.java",
    "contents_url": "https://api.github.com/repos/SF-Algorithm-08/Study-Algorithm/contents/%EA%B9%80%EB%82%98%EC%9D%80/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/BOJ_S1_6118.java?ref=22aafc404c8c1bd4d3cdbf7c94bc81ad6961db3f",
    "patch": "@@ -0,0 +1,73 @@\n+// 숨바꼭질\n+\n+package algo;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.StringTokenizer;\n+\n+public class BOJ_S1_6118 {\n+\n+\tstatic int N, M;\n+\tstatic ArrayList<Integer>[] adjList;\n+\n+\tpublic static void main(String[] args) throws IOException {\n+\n+\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n+\n+\t\tN = Integer.parseInt(st.nextToken()); // 정점의 개수\n+\t\tM = Integer.parseInt(st.nextToken()); // 간선의 개수\n+\t\tadjList = new ArrayList[N + 1]; // 정점 1부터 시작\n+\n+\t\tfor (int i = 0; i <= N; i++) {\n+\t\t\tadjList[i] = new ArrayList<Integer>();\n+\t\t}\n+\n+\t\tfor (int i = 0; i < M; i++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tint from = Integer.parseInt(st.nextToken());\n+\t\t\tint to = Integer.parseInt(st.nextToken());\n+\t\t\tadjList[from].add(to);\n+\t\t\tadjList[to].add(from);\n+\t\t}\n+\n+\t\tbfs(1); // 정점 1부터 시작\n+\t}\n+\n+\tprivate static void bfs(int cur) {\n+\t\tQueue<Integer> queue = new LinkedList<Integer>();\n+\t\tboolean[] visited = new boolean[N + 1];\n+\t\tint[] distance = new int[N + 1];\n+\n+\t\tqueue.offer(cur);\n+\t\tvisited[cur] = true;\n+\n+\t\twhile (!queue.isEmpty()) {\n+\t\t\tcur = queue.poll();\n+\t\t\tfor (int temp : adjList[cur]) {\n+\t\t\t\tif (!visited[temp]) {\n+\t\t\t\t\tqueue.offer(temp);\n+\t\t\t\t\tvisited[temp] = true;\n+\t\t\t\t\tdistance[temp] = distance[cur] + 1;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tint idx = 0, dist = 0, cnt = 0;\n+\t\tfor (int i = 0; i <= N; i++) {\n+\t\t\tif (distance[i] > dist) {\n+\t\t\t\tdist = distance[i];\n+\t\t\t\tidx = i;\n+\t\t\t\tcnt = 1;\n+\t\t\t} else if (distance[i] == dist)\n+\t\t\t\tcnt++;\n+\t\t}\n+\n+\t\tSystem.out.println(idx + \" \" + dist + \" \" + cnt);\n+\t}\n+}"
  }
]
