[
  {
    "sha": "190cd49ea3d4ad7fb6cb9b5db6fd41515646dc18",
    "filename": "박규동/3월 3주차/3월_3주차_문제정리.txt",
    "status": "added",
    "additions": 40,
    "deletions": 0,
    "changes": 40,
    "blob_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/blob/6546c0365451a8852eb079b3b8adaf0a4df8fe09/%EB%B0%95%EA%B7%9C%EB%8F%99/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/3%EC%9B%94_3%EC%A3%BC%EC%B0%A8_%EB%AC%B8%EC%A0%9C%EC%A0%95%EB%A6%AC.txt",
    "raw_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/raw/6546c0365451a8852eb079b3b8adaf0a4df8fe09/%EB%B0%95%EA%B7%9C%EB%8F%99/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/3%EC%9B%94_3%EC%A3%BC%EC%B0%A8_%EB%AC%B8%EC%A0%9C%EC%A0%95%EB%A6%AC.txt",
    "contents_url": "https://api.github.com/repos/SF-Algorithm-08/Study-Algorithm/contents/%EB%B0%95%EA%B7%9C%EB%8F%99/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/3%EC%9B%94_3%EC%A3%BC%EC%B0%A8_%EB%AC%B8%EC%A0%9C%EC%A0%95%EB%A6%AC.txt?ref=6546c0365451a8852eb079b3b8adaf0a4df8fe09",
    "patch": "@@ -0,0 +1,40 @@\n+3월 3주차 문제 정리\n+\n+----------------------------------------------------------------------------------------------------------------------------------------------------------\n+#백준 G4 5052 전화번호 목록\n+○Idea\n+ - String들이 입력으로 들어오고 String들의 substring이 다른 String의 시작으로 사용되는지 판별하는 문제\n+ - Set에 번호들을 저장하고 번호들의 substring이 Set에 이미 속해있는지 검사\n+ - Set에 속해 있으면 \"NO\"를 출력하고 없으면 \"YES\"를 출력 \n+\n+●평가\n+ - 단순 문자열 비교로 구현했을 때는 당연하게도 시간초과가 발생했다. \n+ - 문자열 자르는 메소드를 몰라서 처음에는 직접 char 단위로 잘라서 부문자열을 구했다. \n+ - 찾아보고 substring 메소드를 적용하여 코드를 개선했는데 자주 사용할 것 같으니 외워두자. \n+\n+----------------------------------------------------------------------------------------------------------------------------------------------------------\n+#백준 S1 6118 숨박꼭질\n+○Idea\n+ - 1번으로 부터 가장 멀리 떨어진 헛간의 갯수와 거리, 최소 헛간 번호를 출력하는 문제\n+ - 인접리스트로 각 헛간에서 갈 수 있는 곳을 양방향으로 구현\n+ - 1번 헛간부터 시작하는 bfs를 돌고 visit에 true대신 거리를 저장\n+ - visit배열에서 값이 최대인 것과 그 갯수 그리고 처음 나온 인덱스를 출력\n+\n+●평가\n+ - 단순히 인접리스트와 bfs로 바로 풀 수있는 쉬운 문제였다.\n+ - 다만 답을 찾는 과정에서 헛간 번호, 거리, 갯수를 구하는 과정에서 살짝 헷갈려 Queue에서 정보를 같이 넘겨줄까도 생각했지만, visit배열\n+에서 바로 찾아 줄 수 있었다.  \n+\n+----------------------------------------------------------------------------------------------------------------------------------------------------------\n+#백준 G4 2573 빙산\n+○Idea\n+ - 입력으로 하나로 이어진 빙산의 높이들이 주어지고 주변 4방에 바닷물이 있는 영역만큼씩 높이가 줄어들때 두 지역 이상으로 갈라지는 시점을 구하는 문제\n+ - while문을 돌면서 isTwo()(빙산이 두 개 이상인지) 체크, melt()(빙산 녹이기) 진행 후 시간을 1씩 증가 시킨다.\n+ - isTwo()는 bfs로 구현, 현재 빙산의 한 점을 bfs로 돌아 방문하지 않은 빙산이 있으면 true를 리턴\n+ - melt()는 각 빙산좌표들을 하나씩 검사해 이번 depth에 얼마나 녹는지를 copymap에 저장 후 원래 빙산에서 빼준다.\n+ - while문이 종료되는 시점(1. 빙산이 다 녹았다 2. 두 개 이상으로 갈라졌다)에 상태에 따라 answer를 출력 \n+\n+●평가\n+ - 빙산을 녹일때 녹인 후에 다음 좌표로 넘어가면 결과가 달라질 수 있어서 동시에 녹이는게 중요했다.\n+ - 시뮬레이션 문제인데 마음가는대로 바로 풀어서 최적화가 엉망이다.\n+ - 제한 시간은 1초로 나와있는데 채점해보니 1000ms가 넘는데 통과였다. 스터디때  좀 더 최적화 된 사람들 코드를 참고하고 다시 풀어봐야 할 문제다.\n\\ No newline at end of file"
  },
  {
    "sha": "e6b6e15c3e5cb60b46616d9fda786b7eee0ad199",
    "filename": "박규동/3월 3주차/Main_2573.java",
    "status": "added",
    "additions": 151,
    "deletions": 0,
    "changes": 151,
    "blob_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/blob/6546c0365451a8852eb079b3b8adaf0a4df8fe09/%EB%B0%95%EA%B7%9C%EB%8F%99/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/Main_2573.java",
    "raw_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/raw/6546c0365451a8852eb079b3b8adaf0a4df8fe09/%EB%B0%95%EA%B7%9C%EB%8F%99/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/Main_2573.java",
    "contents_url": "https://api.github.com/repos/SF-Algorithm-08/Study-Algorithm/contents/%EB%B0%95%EA%B7%9C%EB%8F%99/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/Main_2573.java?ref=6546c0365451a8852eb079b3b8adaf0a4df8fe09",
    "patch": "@@ -0,0 +1,151 @@\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.StringTokenizer;\n+\n+public class Main_2573 {\n+\n+\tstatic int N, M;\n+\tstatic StringTokenizer st;\n+\tstatic int[][] board, copymap;\n+\tstatic boolean[][] visit;\n+\tstatic int[] dy = { 0, 0, 1, -1 };\n+\tstatic int[] dx = { 1, -1, 0, 0 };\n+\tstatic int answer;\n+\n+\tstatic class Pair {\n+\t\tint y;\n+\t\tint x;\n+\n+\t\tpublic Pair(int y, int x) {\n+\t\t\tthis.y = y;\n+\t\t\tthis.x = x;\n+\t\t}\n+\t}\n+\n+\tpublic static void main(String[] args) throws Exception {\n+\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+\t\tst = new StringTokenizer(br.readLine());\n+\t\tN = Integer.parseInt(st.nextToken());\n+\t\tM = Integer.parseInt(st.nextToken());\n+\t\tboard = new int[N][M];\n+\t\tvisit = new boolean[N][M];\n+\t\tfor (int i = 0; i < N; i++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tfor (int j = 0; j < M; j++) {\n+\t\t\t\tboard[i][j] = Integer.parseInt(st.nextToken());\n+\t\t\t}\n+\t\t}\n+\n+\t\tsolution();\n+\t\tSystem.out.println(answer);\n+\n+\t}\n+\n+\tprivate static void solution() {\n+\t\t\n+\t\twhile (true) {\n+\t\t\tif (isTwo()) break;\n+\t\t\tmelt();\n+\t\t\tanswer++;\n+\t\t}\n+\t\t\n+\t\tfor (int i = 0; i < N; i++) {\n+\t\t\tfor (int j = 0; j < M; j++) {\n+\t\t\t\tif(board[i][j]!=0) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tanswer=0;\n+\t\t\n+\t}\n+\n+\tprivate static void melt() {\n+\n+\t\tcopymap = new int[N][M];\n+\t\tQueue<Pair> q = new LinkedList<Pair>();\n+\t\t\n+\t\tfor (int i = 0; i < N; i++) {\n+\t\t\tfor (int j = 0; j < M; j++) {\n+\t\t\t\tq.add(new Pair(i,j));\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\twhile(!q.isEmpty()) {\n+\t\t\tint cy = q.peek().y;\n+\t\t\tint cx = q.peek().x;\n+\t\t\tq.poll();\n+\t\t\tfor (int i = 0; i < 4; i++) {\n+\t\t\t\tint ny = cy + dy[i];\n+\t\t\t\tint nx = cx + dx[i];\n+\t\t\t\tif (ny >= N || nx >= M || ny < 0 || nx < 0)\n+\t\t\t\t\tcontinue;\n+\t\t\t\tif (board[ny][nx] == 0) {\n+\t\t\t\t\tcopymap[cy][cx]++;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tfor (int i = 0; i < N; i++) {\n+\t\t\tfor (int j = 0; j < M; j++) {\n+\t\t\t\tboard[i][j]-=copymap[i][j];\n+\t\t\t\tif(board[i][j]<0) board[i][j]=0;\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t}\n+\n+\tprivate static boolean isTwo() {\n+\n+\t\tfor (int i = 0; i < N; i++) {\n+\t\t\tArrays.fill(visit[i], false);\n+\t\t}\n+\t\tQueue<Pair> q = new LinkedList<Pair>();\n+\n+\t\tint y = 0;\n+\t\tint x = 0;\n+\t\ttop: for (int i = 0; i < N; i++) {\n+\t\t\tfor (int j = 0; j < M; j++) {\n+\t\t\t\tif (board[i][j] > 0) {\n+\t\t\t\t\ty = i;\n+\t\t\t\t\tx = j;\n+\t\t\t\t\tbreak top;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tq.add(new Pair(y, x));\n+\t\tvisit[y][x] = true;\n+\n+\t\twhile (!q.isEmpty()) {\n+\t\t\tint cy = q.peek().y;\n+\t\t\tint cx = q.peek().x;\n+\t\t\tq.poll();\n+\t\t\tfor (int i = 0; i < 4; i++) {\n+\t\t\t\tint ny = cy + dy[i];\n+\t\t\t\tint nx = cx + dx[i];\n+\t\t\t\tif (ny >= N || nx >= M || ny < 0 || nx < 0)\n+\t\t\t\t\tcontinue;\n+\t\t\t\tif (visit[ny][nx] || board[ny][nx] == 0)\n+\t\t\t\t\tcontinue;\n+\t\t\t\tvisit[ny][nx] = true;\n+\t\t\t\tq.add(new Pair(ny, nx));\n+\t\t\t}\n+\t\t}\n+\t\tfor (int i = 0; i < N; i++) {\n+\t\t\tfor (int j = 0; j < M; j++) {\n+\t\t\t\tif (board[i][j] > 0 && visit[i][j])\n+\t\t\t\t\tcontinue;\n+\t\t\t\tif (board[i][j] == 0 && !visit[i][j])\n+\t\t\t\t\tcontinue;\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+}"
  },
  {
    "sha": "b2b2206a788535ba250cb7e760eb0b2f9cb741d3",
    "filename": "박규동/3월 3주차/Main_5052.java",
    "status": "added",
    "additions": 44,
    "deletions": 0,
    "changes": 44,
    "blob_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/blob/6546c0365451a8852eb079b3b8adaf0a4df8fe09/%EB%B0%95%EA%B7%9C%EB%8F%99/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/Main_5052.java",
    "raw_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/raw/6546c0365451a8852eb079b3b8adaf0a4df8fe09/%EB%B0%95%EA%B7%9C%EB%8F%99/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/Main_5052.java",
    "contents_url": "https://api.github.com/repos/SF-Algorithm-08/Study-Algorithm/contents/%EB%B0%95%EA%B7%9C%EB%8F%99/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/Main_5052.java?ref=6546c0365451a8852eb079b3b8adaf0a4df8fe09",
    "patch": "@@ -0,0 +1,44 @@\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+\n+public class Main_5052 {\n+\n+\tstatic int T, N;\n+\tstatic HashSet<String> set;\n+\tstatic String[] phonenums;\n+\tstatic String str;\n+\n+\tpublic static void main(String[] args) throws Exception {\n+\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+\t\tT = Integer.parseInt(br.readLine());\n+\t\tfor (int tc = 1; tc <= T; tc++) {\n+\n+\t\t\tN = Integer.parseInt(br.readLine());\n+\t\t\tphonenums = new String[N];\n+\t\t\tset = new HashSet<>();\n+\t\t\tfor (int i = 0; i < N; i++) {\n+\t\t\t\tphonenums[i] = br.readLine();\n+\t\t\t\tset.add(phonenums[i]);\n+\t\t\t}\n+\t\t\tif (solution())\n+\t\t\t\tSystem.out.println(\"NO\");\n+\t\t\telse\n+\t\t\t\tSystem.out.println(\"YES\");\n+\t\t}\n+\t}\n+\n+\tprivate static boolean solution() {\n+\n+\t\tfor (int i = 0; i < N; i++) {\n+\t\t\tfor (int j = 1; j < phonenums[i].length(); j++) {\n+\t\t\t\tif (set.contains(phonenums[i].substring(0, j))) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+}"
  },
  {
    "sha": "20687ee86de57db20ff9ac41a96412c7bdf94ab6",
    "filename": "박규동/3월 3주차/Main_6118.java",
    "status": "added",
    "additions": 70,
    "deletions": 0,
    "changes": 70,
    "blob_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/blob/6546c0365451a8852eb079b3b8adaf0a4df8fe09/%EB%B0%95%EA%B7%9C%EB%8F%99/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/Main_6118.java",
    "raw_url": "https://github.com/SF-Algorithm-08/Study-Algorithm/raw/6546c0365451a8852eb079b3b8adaf0a4df8fe09/%EB%B0%95%EA%B7%9C%EB%8F%99/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/Main_6118.java",
    "contents_url": "https://api.github.com/repos/SF-Algorithm-08/Study-Algorithm/contents/%EB%B0%95%EA%B7%9C%EB%8F%99/3%EC%9B%94%203%EC%A3%BC%EC%B0%A8/Main_6118.java?ref=6546c0365451a8852eb079b3b8adaf0a4df8fe09",
    "patch": "@@ -0,0 +1,70 @@\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.StringTokenizer;\n+\n+public class Main_6118 {\n+\n+\tstatic int N,M;\n+\tstatic StringTokenizer st;\n+\tstatic int[] visit;\n+\tstatic int[] hut;\n+\tstatic ArrayList<Integer>[] info;\n+\tstatic int anshut,dist,count;\n+\t\n+\tpublic static void main(String[] args) throws Exception {\n+\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+\t\tst = new StringTokenizer(br.readLine());\n+\t\tN = Integer.parseInt(st.nextToken());\n+\t\tM = Integer.parseInt(st.nextToken());\n+\t\t\n+\t\tvisit = new int[N+1];\n+\t\thut = new int[N+1];\n+\t\tinfo = new ArrayList[N+1];\n+\t\tfor(int i=1;i<N+1;i++) {\n+\t\t\tinfo[i]=new ArrayList<>();\n+\t\t}\n+\t\t\n+\t\tfor(int i=0;i<M;i++) {\n+\t\t\tst=new StringTokenizer(br.readLine());\n+\t\t\tint start = Integer.parseInt(st.nextToken());\n+\t\t\tint dest = Integer.parseInt(st.nextToken());\n+\t\t\tinfo[start].add(dest);\n+\t\t\tinfo[dest].add(start);\n+\t\t}\n+\t\t\n+\t\tbfs();\n+\t\tSystem.out.printf(\"%d %d %d\",anshut,dist,count);\n+\n+\t}\n+\tprivate static void bfs() {\n+\t\tArrays.fill(visit, -1);\n+\t\tvisit[1]=0;\n+\t\tQueue<Integer> q = new LinkedList<Integer>();\n+\t\tq.add(1);\n+\t\twhile(!q.isEmpty()) {\n+\t\t\tint cur = q.poll();\n+\t\t\tfor(int i=0;i<info[cur].size();i++) {\n+\t\t\t\tint next = info[cur].get(i);\n+\t\t\t\tif(visit[next]>-1) continue;\n+\t\t\t\tvisit[next] = visit[cur]+1;\n+\t\t\t\tq.add(next);\n+\t\t\t}\n+\t\t}\n+\t\tdist=visit[1];\n+\t\tfor(int i=2;i<=N;i++) {\n+\t\t\tif(visit[i]>dist) {\n+\t\t\t\tdist=visit[i];\n+\t\t\t\tanshut=i;\n+\t\t\t\tcount=1;\n+\t\t\t}\n+\t\t\telse if(visit[i]==dist) {\n+\t\t\t\tcount++;\n+\t\t\t}\n+\t\t}\n+\t}\n+}"
  }
]
