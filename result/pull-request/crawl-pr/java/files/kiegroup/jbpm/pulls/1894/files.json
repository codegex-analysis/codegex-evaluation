[
  {
    "sha": "2d963eaa7928a7e8eb5700534e2eeaeeb1ba2d74",
    "filename": "jbpm-services/jbpm-executor/src/main/java/org/jbpm/executor/impl/AbstractAvailableJobsExecutor.java",
    "status": "modified",
    "additions": 5,
    "deletions": 5,
    "changes": 10,
    "blob_url": "https://github.com/kiegroup/jbpm/blob/9b5e5e8d9a8861bd8564e0af03c5f09e1873c0f7/jbpm-services/jbpm-executor/src/main/java/org/jbpm/executor/impl/AbstractAvailableJobsExecutor.java",
    "raw_url": "https://github.com/kiegroup/jbpm/raw/9b5e5e8d9a8861bd8564e0af03c5f09e1873c0f7/jbpm-services/jbpm-executor/src/main/java/org/jbpm/executor/impl/AbstractAvailableJobsExecutor.java",
    "contents_url": "https://api.github.com/repos/kiegroup/jbpm/contents/jbpm-services/jbpm-executor/src/main/java/org/jbpm/executor/impl/AbstractAvailableJobsExecutor.java?ref=9b5e5e8d9a8861bd8564e0af03c5f09e1873c0f7",
    "patch": "@@ -183,19 +183,17 @@ public void executeGivenJob(RequestInfo request) {\n                         \n                         handler.onCommandDone(ctx, results);\n                     }\n-                    \n+                    ((ExecutorImpl) executor).clearExecution(request.getId());\n                 } catch (InterruptedException e) {\n                     Thread.currentThread().interrupt();\n                 } catch (Throwable e) {\n                     exception = e;\n                     if (callbacks == null) {\n                         callbacks = classCacheManager.buildCommandCallback(ctx, cl);\n                     }\n-                    \n-                \tprocessReoccurring = handleException(request, e, ctx, callbacks);\n-                \t\n+\n+                    processReoccurring = handleException(request, e, ctx, callbacks);\n                 } finally {\n-                    ((ExecutorImpl) executor).clearExecution(request.getId());\n                     AsyncExecutionMarker.reset();\n                 \thandleCompletion(processReoccurring, cmd, ctx);\n                 \teventSupport.fireAfterJobExecuted(request, exception);\n@@ -273,6 +271,8 @@ protected boolean handleException(RequestInfo request, Throwable e, CommandConte\n                     handler.onCommandError(ctx, wrappedException);                        \n                 }\n             }\n+            // only when there are no retries left we clean up\n+            ((ExecutorImpl) executor).clearExecution(request.getId());\n             return true;\n         }\n     }"
  },
  {
    "sha": "a9cbfeb73682e0f38e4889ce51c7747c516abeaa",
    "filename": "jbpm-services/jbpm-executor/src/main/java/org/jbpm/executor/impl/concurrent/LoadAndScheduleRequestsTask.java",
    "status": "modified",
    "additions": 4,
    "deletions": 4,
    "changes": 8,
    "blob_url": "https://github.com/kiegroup/jbpm/blob/9b5e5e8d9a8861bd8564e0af03c5f09e1873c0f7/jbpm-services/jbpm-executor/src/main/java/org/jbpm/executor/impl/concurrent/LoadAndScheduleRequestsTask.java",
    "raw_url": "https://github.com/kiegroup/jbpm/raw/9b5e5e8d9a8861bd8564e0af03c5f09e1873c0f7/jbpm-services/jbpm-executor/src/main/java/org/jbpm/executor/impl/concurrent/LoadAndScheduleRequestsTask.java",
    "contents_url": "https://api.github.com/repos/kiegroup/jbpm/contents/jbpm-services/jbpm-executor/src/main/java/org/jbpm/executor/impl/concurrent/LoadAndScheduleRequestsTask.java?ref=9b5e5e8d9a8861bd8564e0af03c5f09e1873c0f7",
    "patch": "@@ -45,20 +45,20 @@ public LoadAndScheduleRequestsTask(ExecutorStoreService executorStoreService, Sc\n     @Override\n     public void run() {\n         try {\n-            logger.info(\"Load of jobs from storage started at {}\", new Date());\n+\n             List<RequestInfo> loaded = executorStoreService.loadRequests();\n-            \n+            logger.info(\"Load of jobs from storage started at {} with size {}\", new Date(), loaded.size());\n             if (!loaded.isEmpty()) {\n                 logger.info(\"Found {} jobs that are waiting for execution, scheduling them...\", loaded.size());\n                 int scheduledCounter = 0;\n                 for (RequestInfo request : loaded) {\n                     \n                     PrioritisedRunnable job = new PrioritisedRunnable(request.getId(), request.getPriority(), request.getTime(), jobProcessor);\n                     long delay = request.getTime().getTime() - System.currentTimeMillis();\n-                    logger.debug(\"Scheduling with delay {} for request {}\", delay, request.getId());\n+                    logger.debug(\"Scheduling with delay {} for request {} at time {}\", delay, request.getId(), request.getTime());\n                     boolean scheduled = ((PrioritisedScheduledThreadPoolExecutor)scheduler).scheduleNoDuplicates(job, delay, TimeUnit.MILLISECONDS);\n                     if (scheduled) {\n-                        logger.debug(\"Request {} has been successfully scheduled\", request.getId());\n+                        logger.debug(\"Request {} has been successfully scheduled at {}\", request.getId(), request.getTime());\n                         scheduledCounter++;\n                     } else {\n                         logger.debug(\"Request {} has not been scheduled as it's already there\", request.getId());"
  },
  {
    "sha": "acf51e2e1895921a96de3522b5b99a47f0e63be6",
    "filename": "jbpm-services/jbpm-executor/src/main/java/org/jbpm/executor/impl/concurrent/PrioritisedScheduledThreadPoolExecutor.java",
    "status": "modified",
    "additions": 9,
    "deletions": 8,
    "changes": 17,
    "blob_url": "https://github.com/kiegroup/jbpm/blob/9b5e5e8d9a8861bd8564e0af03c5f09e1873c0f7/jbpm-services/jbpm-executor/src/main/java/org/jbpm/executor/impl/concurrent/PrioritisedScheduledThreadPoolExecutor.java",
    "raw_url": "https://github.com/kiegroup/jbpm/raw/9b5e5e8d9a8861bd8564e0af03c5f09e1873c0f7/jbpm-services/jbpm-executor/src/main/java/org/jbpm/executor/impl/concurrent/PrioritisedScheduledThreadPoolExecutor.java",
    "contents_url": "https://api.github.com/repos/kiegroup/jbpm/contents/jbpm-services/jbpm-executor/src/main/java/org/jbpm/executor/impl/concurrent/PrioritisedScheduledThreadPoolExecutor.java?ref=9b5e5e8d9a8861bd8564e0af03c5f09e1873c0f7",
    "patch": "@@ -16,6 +16,7 @@\n \n package org.jbpm.executor.impl.concurrent;\n \n+import java.util.Date;\n import java.util.List;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.RejectedExecutionHandler;\n@@ -46,20 +47,20 @@ public PrioritisedScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory th\n \n     \n     public boolean scheduleNoDuplicates(Runnable command, long delay, TimeUnit unit) {\n+        Long requestId = null;\n+        Date fireDate = null;\n         if (command instanceof PrioritisedRunnable) {\n-            Long requestId = ((PrioritisedRunnable) command).getId();\n+            requestId = ((PrioritisedRunnable) command).getId();\n+            fireDate = ((PrioritisedRunnable) command).getFireDate();\n             ScheduledFuture<?> alreadyScheduled = scheduled.get(requestId);\n             logger.debug(\"Checking if request with id {} is already scheduled {}\", requestId, alreadyScheduled);\n             if (alreadyScheduled != null) {\n-                if (alreadyScheduled.isDone()) {\n-                    logger.debug(\"Request {} is already completed so remove it and reschedule\", requestId);\n-                    scheduled.remove(requestId);                    \n-                } else {\n-                    logger.debug(\"Request {} is already scheduled\", requestId);\n-                    return false;\n-                }\n+                // we need to wait till done is being called by the job executor\n+                logger.debug(\"Request {} is already scheduled\", requestId);\n+                return false;\n             }\n         }\n+        logger.debug(\"Schedule request {} with fireDate {} is already scheduled at {}\", requestId, fireDate, delay);\n         super.schedule(command, delay, unit);\n         return true;\n     }"
  },
  {
    "sha": "2aa066dffedda44975f3ae93e1296726f2fae2c5",
    "filename": "jbpm-services/jbpm-executor/src/test/java/org/jbpm/executor/impl/jms/JmsAvaiableJobExecutorTest.java",
    "status": "modified",
    "additions": 33,
    "deletions": 25,
    "changes": 58,
    "blob_url": "https://github.com/kiegroup/jbpm/blob/9b5e5e8d9a8861bd8564e0af03c5f09e1873c0f7/jbpm-services/jbpm-executor/src/test/java/org/jbpm/executor/impl/jms/JmsAvaiableJobExecutorTest.java",
    "raw_url": "https://github.com/kiegroup/jbpm/raw/9b5e5e8d9a8861bd8564e0af03c5f09e1873c0f7/jbpm-services/jbpm-executor/src/test/java/org/jbpm/executor/impl/jms/JmsAvaiableJobExecutorTest.java",
    "contents_url": "https://api.github.com/repos/kiegroup/jbpm/contents/jbpm-services/jbpm-executor/src/test/java/org/jbpm/executor/impl/jms/JmsAvaiableJobExecutorTest.java?ref=9b5e5e8d9a8861bd8564e0af03c5f09e1873c0f7",
    "patch": "@@ -17,10 +17,12 @@\n package org.jbpm.executor.impl.jms;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n \n import java.util.ArrayList;\n import java.util.List;\n import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n \n import javax.jms.Connection;\n import javax.jms.ConnectionFactory;\n@@ -82,7 +84,8 @@ public void setUp() throws Exception {\n         ((ExecutorImpl)((ExecutorServiceImpl)executorService).getExecutor()).setQueue(queue);\n         \n         executorService.setThreadPoolSize(0);\n-        executorService.setInterval(10000);\n+        executorService.setInterval(100);\n+        executorService.setTimeunit(TimeUnit.MILLISECONDS);\n         executorService.init();\n     }\n \n@@ -131,6 +134,28 @@ public void testAsyncAuditProducer() throws Exception {\n         assertEquals(1, executedRequests.size());\n  \n     }\n+\n+    @Test\n+    public void testAsyncAuditErrorProducer() throws Exception {\n+        \n+        CountDownAsyncJobListener countDownListener = configureListener(4);\n+        CommandContext ctxCMD = new CommandContext();\n+        ctxCMD.setData(\"businessKey\", UUID.randomUUID().toString());\n+        ctxCMD.setData(\"retries\", 3);\n+        ctxCMD.setData(\"retryDelay\",\"2000\");\n+\n+        UserTransaction ut = InitialContext.doLookup(\"java:comp/UserTransaction\");\n+        ut.begin();\n+        long end = System.currentTimeMillis() + 2000*3; // retry delay + number of retries;\n+        long requestId = executorService.scheduleRequest(\"org.jbpm.executor.ThrowExceptionCommand\", ctxCMD);\n+        ut.commit();\n+        MessageReceiver receiver = new MessageReceiver();\n+        receiver.receiveAndProcess(queue, countDownListener);\n+        assertTrue(end <= System.currentTimeMillis()); // the time spent cannot be inferior it means interval was not honored\n+        RequestInfo info = executorService.getRequestById(requestId);\n+        assertEquals(0, info.getRetries());\n+        assertEquals(4, info.getExecutions());\n+    }\n     \n     @Test\n     public void testAsyncAuditProducerPrioritizedJobs() throws Exception {\n@@ -240,13 +265,13 @@ private void stopHornetQServer() throws Exception {\n     }\n     \n     private class MessageReceiver {\n-        \n+\n         void receiveAndProcess(Queue queue, CountDownAsyncJobListener countDownListener) throws Exception {\n-            \n-            receiveAndProcess(queue, countDownListener, 100000);\n+\n+            receiveAndProcess(queue, countDownListener, 100000L);\n \n         }\n-        \n+\n         void receiveAndProcess(Queue queue, CountDownAsyncJobListener countDownListener, long waitTill) throws Exception {\n             \n             Connection qconnetion = factory.createConnection();\n@@ -260,6 +285,7 @@ void receiveAndProcess(Queue queue, CountDownAsyncJobListener countDownListener,\n             jmsExecutor.setEventSupport(((ExecutorServiceImpl)executorService).getEventSupport());\n             jmsExecutor.setExecutor(((ExecutorServiceImpl)executorService).getExecutor());\n             consumer.setMessageListener(jmsExecutor);\n+\n             // since we use message listener allow it to complete the async processing\n             countDownListener.waitTillCompleted(waitTill);\n             \n@@ -268,25 +294,7 @@ void receiveAndProcess(Queue queue, CountDownAsyncJobListener countDownListener,\n             qconnetion.close();\n \n         }\n-        \n-        public List<Message> receive(Queue queue) throws Exception {\n-            List<Message> messages = new ArrayList<Message>();\n-            \n-            Connection qconnetion = factory.createConnection();\n-            Session qsession = qconnetion.createSession(true, QueueSession.AUTO_ACKNOWLEDGE);\n-            MessageConsumer consumer = qsession.createConsumer(queue);\n-            qconnetion.start();\n-            \n-            Message m = null;\n-            \n-            while ((m = consumer.receiveNoWait()) != null) {\n-                messages.add(m);\n-            }\n-            consumer.close();            \n-            qsession.close();            \n-            qconnetion.close();\n-            \n-            return messages;\n-        }\n+\n+\n     }\n }"
  }
]
