[
  {
    "sha": "28b0b5f38ca845a8f0532daeb9b59a8b23b9ae7a",
    "filename": "task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/ImmutableTask.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/ImmutableTask.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/ImmutableTask.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/ImmutableTask.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.kie.kogito.taskassigning.core.model;\n \n import java.time.ZonedDateTime;"
  },
  {
    "sha": "654e9c57961f29aa5e48d48a322dc79bcfafbfaa",
    "filename": "task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/ImmutableTaskAssignment.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/ImmutableTaskAssignment.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/ImmutableTaskAssignment.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/ImmutableTaskAssignment.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.kie.kogito.taskassigning.core.model;\n \n public class ImmutableTaskAssignment extends TaskAssignment {"
  },
  {
    "sha": "6b155f388e42f19ff0156ce1f0ba2e65966a2465",
    "filename": "task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/ModelConstants.java",
    "status": "modified",
    "additions": 32,
    "deletions": 9,
    "changes": 41,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/ModelConstants.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/ModelConstants.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/ModelConstants.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -22,26 +22,20 @@\n \n public class ModelConstants {\n \n-    private ModelConstants() {\n-    }\n-\n-    private static final ZonedDateTime DUMMY_DATE = ZonedDateTime.parse(\"2021-01-01T01:01:01.001Z\",\n-            DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n     /**\n      * System property for configuring the PLANNING_USER entityId.\n      */\n     public static final String PLANNING_USER_ID_PROPERTY = \"org.kie.kogito.taskassigning.core.model.planningUserId\";\n-\n     public static final String PLANNING_USER_ID = System.getProperty(PLANNING_USER_ID_PROPERTY, \"planninguser\");\n-\n     /**\n      * Planning user is defined user for avoid breaking hard constraints. When no user is found that met the task required\n      * potential owners set, or the required skills set, etc, the PLANNING_USER is assigned.\n      */\n     public static final User PLANNING_USER = new ImmutableUser(PLANNING_USER_ID, true, Collections.emptySet(), Collections.emptyMap());\n-\n     public static final Predicate<String> IS_PLANNING_USER = entityId -> PLANNING_USER.getId().equals(entityId);\n \n+    private static final ZonedDateTime DUMMY_DATE = ZonedDateTime.parse(\"2021-01-01T01:01:01.001Z\",\n+            DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n     /**\n      * This task was introduced for dealing with situations where the solution ends up with no tasks. e.g. there is a\n      * solution with tasks A and B, and a user completes both tasks in the kogito runtime. When the completion events\n@@ -57,11 +51,40 @@ private ModelConstants() {\n             \"1\",\n             \"dummy-process-instance-id\",\n             \"dummy-process-id\",\n-            \"dummy-root-process-id\",\n+            \"dummy-root-process-instance-id\",\n             \"dummy-root-process-id\",\n             DUMMY_DATE,\n             DUMMY_DATE,\n             DUMMY_DATE,\n             \"dummy-endpoint\"),\n             false);\n+\n+    /**\n+     * This task was introduced for avoid falling into scenarios where we have all assignments pinned and only one\n+     * entity for selection, which will make the solver enter in the bailing out loop. At least this second task plus\n+     * the DUMMY_TASK_ASSIGNMENT ensures two available elements. (see https://issues.jboss.org/browse/PLANNER-1738)\n+     * Will be removed when issue is fixed.\n+     */\n+    public static final TaskAssignment DUMMY_TASK_ASSIGNMENT_PLANNER_1738 = new ImmutableTaskAssignment(new ImmutableTask(\"-1738\",\n+            \"dummy-task-1738\",\n+            \"dummy-state-1738\",\n+            \"dummy-description-1738\",\n+            \"dummy-reference-name-1738\",\n+            \"1\",\n+            \"dummy-process-instance-id-241\",\n+            \"dummy-process-id-241\",\n+            \"dummy-root-process-instance-id-241\",\n+            \"dummy-root-process-id-241\",\n+            DUMMY_DATE,\n+            DUMMY_DATE,\n+            DUMMY_DATE,\n+            \"dummy-endpoint-241\"),\n+            false);\n+\n+    public static final Predicate<TaskAssignment> IS_NOT_DUMMY_TASK_ASSIGNMENT =\n+            taskAssignment -> !DUMMY_TASK_ASSIGNMENT.getId().equals(taskAssignment.getId()) &&\n+                    !DUMMY_TASK_ASSIGNMENT_PLANNER_1738.getId().equals(taskAssignment.getId());\n+\n+    private ModelConstants() {\n+    }\n }"
  },
  {
    "sha": "f15eb2cf76ea7104603c368d0e36433a1e222d48",
    "filename": "task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/solver/TaskHelper.java",
    "status": "modified",
    "additions": 9,
    "deletions": 0,
    "changes": 9,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/solver/TaskHelper.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/solver/TaskHelper.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/solver/TaskHelper.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -20,12 +20,15 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n \n import org.kie.kogito.taskassigning.core.model.ChainElement;\n import org.kie.kogito.taskassigning.core.model.Task;\n import org.kie.kogito.taskassigning.core.model.TaskAssignment;\n import org.kie.kogito.taskassigning.core.model.User;\n \n+import static org.kie.kogito.taskassigning.core.model.ModelConstants.IS_NOT_DUMMY_TASK_ASSIGNMENT;\n+\n public class TaskHelper {\n \n     private TaskHelper() {\n@@ -118,6 +121,12 @@ public static boolean hasPinnedTasks(ChainElement user) {\n         return !extractTaskAssignments(user, TaskAssignment::isPinned).isEmpty();\n     }\n \n+    public static List<TaskAssignment> filterNonDummyAssignments(List<TaskAssignment> taskAssignments) {\n+        return taskAssignments.stream()\n+                .filter(IS_NOT_DUMMY_TASK_ASSIGNMENT)\n+                .collect(Collectors.toList());\n+    }\n+\n     private static Collection<?> attributeAsCollection(Object attribute) {\n         if (attribute == null) {\n             return Collections.emptySet();"
  },
  {
    "sha": "5e79a3af5c271e0b6aacb4b4dcc1dbf1648a4cfa",
    "filename": "task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/solver/realtime/TaskStateChangeProblemFactChange.java",
    "status": "added",
    "additions": 35,
    "deletions": 0,
    "changes": 35,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/solver/realtime/TaskStateChangeProblemFactChange.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/solver/realtime/TaskStateChangeProblemFactChange.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-core/src/main/java/org/kie/kogito/taskassigning/core/model/solver/realtime/TaskStateChangeProblemFactChange.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.taskassigning.core.model.solver.realtime;\n+\n+import org.kie.kogito.taskassigning.core.model.Task;\n+import org.kie.kogito.taskassigning.core.model.TaskAssignment;\n+\n+public class TaskStateChangeProblemFactChange extends AbstractTaskPropertyChangeProblemFactChange {\n+\n+    private String newState;\n+\n+    public TaskStateChangeProblemFactChange(TaskAssignment taskAssignment, String newState) {\n+        super(taskAssignment);\n+        this.newState = newState;\n+    }\n+\n+    @Override\n+    protected void applyChange(Task task) {\n+        task.setState(newState);\n+    }\n+}"
  },
  {
    "sha": "28f2f2b0da01806406ee95de166f2252363bf729",
    "filename": "task-assigning/task-assigning-core/src/test/java/org/kie/kogito/taskassigning/core/model/solver/TaskHelperTest.java",
    "status": "modified",
    "additions": 16,
    "deletions": 1,
    "changes": 17,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/test/java/org/kie/kogito/taskassigning/core/model/solver/TaskHelperTest.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/test/java/org/kie/kogito/taskassigning/core/model/solver/TaskHelperTest.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-core/src/test/java/org/kie/kogito/taskassigning/core/model/solver/TaskHelperTest.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -36,6 +36,8 @@\n import org.kie.kogito.taskassigning.core.model.User;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.kie.kogito.taskassigning.core.model.ModelConstants.DUMMY_TASK_ASSIGNMENT;\n+import static org.kie.kogito.taskassigning.core.model.ModelConstants.DUMMY_TASK_ASSIGNMENT_PLANNER_1738;\n import static org.kie.kogito.taskassigning.core.model.solver.TaskHelper.isPotentialOwner;\n \n class TaskHelperTest {\n@@ -203,6 +205,19 @@ void hasPinnedTasks() {\n         assertThat(TaskHelper.hasPinnedTasks(chainElement)).isTrue();\n     }\n \n+    @Test\n+    void filterNonDummyAssignments() {\n+        List<TaskAssignment> taskAssignments = Arrays.asList(\n+                new TaskAssignment(Task.newBuilder().id(TASK_ID_1).build()),\n+                new TaskAssignment(Task.newBuilder().id(DUMMY_TASK_ASSIGNMENT.getId()).build()),\n+                new TaskAssignment(Task.newBuilder().id(TASK_ID_2).build()),\n+                new TaskAssignment(Task.newBuilder().id(DUMMY_TASK_ASSIGNMENT_PLANNER_1738.getId()).build()));\n+        List<TaskAssignment> result = TaskHelper.filterNonDummyAssignments(taskAssignments);\n+        assertThat(result).hasSize(2);\n+        assertThat(result.get(0)).isSameAs(taskAssignments.get(0));\n+        assertThat(result.get(1)).isSameAs(taskAssignments.get(2));\n+    }\n+\n     private ChainElement buildChainElement() {\n         ChainElement chainElement = new TaskAssignment(Task.newBuilder().build());\n         TaskAssignment taskAssignment1 = new TaskAssignment(Task.newBuilder().id(TASK_ID_1).build());\n@@ -257,4 +272,4 @@ private static Task mockTask(String labelName, Set<Object> labelValues) {\n         task.getAttributes().put(labelName, labelValues);\n         return task;\n     }\n-}\n\\ No newline at end of file\n+}"
  },
  {
    "sha": "77f381cc66ec577a8aa43c9aada5748ee1f9a2cc",
    "filename": "task-assigning/task-assigning-core/src/test/java/org/kie/kogito/taskassigning/core/model/solver/realtime/TaskPriorityChangeProblemFactChangeTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/test/java/org/kie/kogito/taskassigning/core/model/solver/realtime/TaskPriorityChangeProblemFactChangeTest.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/test/java/org/kie/kogito/taskassigning/core/model/solver/realtime/TaskPriorityChangeProblemFactChangeTest.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-core/src/test/java/org/kie/kogito/taskassigning/core/model/solver/realtime/TaskPriorityChangeProblemFactChangeTest.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -40,5 +40,6 @@ protected Task createTask() {\n     @Override\n     protected void verifyValuesWhereApplied() {\n         assertThat(workingTaskAssignment.getTask().getPriority()).isEqualTo(NEW_PRIORITY);\n+        assertThat(task.getPriority()).isEqualTo(CURRENT_PRIORITY);\n     }\n }"
  },
  {
    "sha": "282e049c435c7b5d8c4a289c119840d96eccdd3b",
    "filename": "task-assigning/task-assigning-core/src/test/java/org/kie/kogito/taskassigning/core/model/solver/realtime/TaskStateChangeProblemFactChangeTest.java",
    "status": "added",
    "additions": 46,
    "deletions": 0,
    "changes": 46,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/test/java/org/kie/kogito/taskassigning/core/model/solver/realtime/TaskStateChangeProblemFactChangeTest.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-core/src/test/java/org/kie/kogito/taskassigning/core/model/solver/realtime/TaskStateChangeProblemFactChangeTest.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-core/src/test/java/org/kie/kogito/taskassigning/core/model/solver/realtime/TaskStateChangeProblemFactChangeTest.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.taskassigning.core.model.solver.realtime;\n+\n+import org.kie.kogito.taskassigning.core.model.Task;\n+import org.kie.kogito.taskassigning.core.model.TaskAssignment;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class TaskStateChangeProblemFactChangeTest extends AbstractTaskPropertyChangeProblemFactChangeTest<TaskStateChangeProblemFactChange> {\n+\n+    private static final String CURRENT_STATE = \"CURRENT_STATE\";\n+    private static final String NEW_STATE = \"NEW_STATE\";\n+\n+    @Override\n+    protected TaskStateChangeProblemFactChange createChange(TaskAssignment taskAssignment) {\n+        return new TaskStateChangeProblemFactChange(taskAssignment, NEW_STATE);\n+    }\n+\n+    @Override\n+    protected Task createTask() {\n+        Task task = super.createTask();\n+        task.setState(CURRENT_STATE);\n+        return task;\n+    }\n+\n+    @Override\n+    protected void verifyValuesWhereApplied() {\n+        assertThat(workingTaskAssignment.getTask().getState()).isEqualTo(NEW_STATE);\n+        assertThat(task.getState()).isEqualTo(CURRENT_STATE);\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "afee001d7f8d28769bf90078da71e2c7994982cb",
    "filename": "task-assigning/task-assigning-process-service-client/pom.xml",
    "status": "modified",
    "additions": 0,
    "deletions": 8,
    "changes": 8,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-process-service-client/pom.xml",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-process-service-client/pom.xml",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-process-service-client/pom.xml?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -35,14 +35,6 @@\n       <groupId>org.slf4j</groupId>\n       <artifactId>slf4j-api</artifactId>\n     </dependency>\n-    <dependency>\n-      <groupId>io.quarkus</groupId>\n-      <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.kafka</groupId>\n-      <artifactId>kafka-clients</artifactId>\n-    </dependency>\n     <dependency>\n       <groupId>com.google.guava</groupId>\n       <artifactId>guava</artifactId>"
  },
  {
    "sha": "6f191ab0da2b4cb1709ec5ad1656d414ce1687d3",
    "filename": "task-assigning/task-assigning-process-service-client/src/main/resources/META-INF/microprofile-config.properties",
    "status": "modified",
    "additions": 0,
    "deletions": 10,
    "changes": 10,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-process-service-client/src/main/resources/META-INF/microprofile-config.properties",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-process-service-client/src/main/resources/META-INF/microprofile-config.properties",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-process-service-client/src/main/resources/META-INF/microprofile-config.properties?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -5,13 +5,3 @@ quarkus.oidc.tenant-enabled=false\n %keycloak.quarkus.oidc.client-id=kogito-task-assigning-service\n %keycloak.quarkus.oidc.application-type=service\n %keycloak.quarkus.oidc.credentials.secret=secret\n-\n-\n-mp.messaging.incoming.kogito-usertaskinstances-events.connector=smallrye-kafka\n-mp.messaging.incoming.kogito-usertaskinstances-events.topic=kogito-usertaskinstances-events\n-mp.messaging.incoming.kogito-usertaskinstances-events.value.deserializer=org.kie.kogito.taskassigning.messaging.UserTaskEventDeserializer\n-mp.messaging.incoming.kogito-usertaskinstances-events.client.id=kogito-task-assigning-service\n-mp.messaging.incoming.kogito-usertaskinstances-events.group.id=kogito-task-assigning-service\n-mp.messaging.incoming.kogito-usertaskinstances-events.enable.auto.commit=false\n-mp.messaging.incoming.kogito-usertaskinstances-events.auto.offset.reset=earliest\n-mp.messaging.incoming.kogito-usertaskinstances-events.isolation.level=read_committed\n\\ No newline at end of file"
  },
  {
    "sha": "f20d8fd5b86d924e31538316b11dd04e862f63d1",
    "filename": "task-assigning/task-assigning-service/pom.xml",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/pom.xml",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/pom.xml",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/pom.xml?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -43,6 +43,14 @@\n       <groupId>io.quarkus</groupId>\n       <artifactId>quarkus-smallrye-context-propagation</artifactId>\n     </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-smallrye-reactive-messaging</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n+    </dependency>\n \n     <dependency>\n       <groupId>org.optaplanner</groupId>"
  },
  {
    "sha": "75da74de00b2db15caa8237bf2754009cb2b1514",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/resource/TaskAssigningResource.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/resource/TaskAssigningResource.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/resource/TaskAssigningResource.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/resource/TaskAssigningResource.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -13,7 +13,6 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-\n package org.kie.kogito.taskassigning.resource;\n \n import javax.enterprise.context.ApplicationScoped;\n@@ -38,6 +37,7 @@\n     @Path(\"/service/status\")\n     @Produces({ \"application/json\" })\n     public String getServiceStatus() {\n-        return \"{\\\"result\\\": \\\"\" + service.getStatus() + \"\\\"}\";\n+        //TODO, future iteration, define the set of useful operations.\n+        return \"{\\\"result\\\": \\\"Not yet implemented!\\\"}\";\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "087c9fd608a09322291931afe87f82961fb22ae1",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningBuilder.java",
    "status": "added",
    "additions": 84,
    "deletions": 0,
    "changes": 84,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningBuilder.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningBuilder.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningBuilder.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.taskassigning.service;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.kie.kogito.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.kogito.taskassigning.core.model.TaskAssignment;\n+import org.kie.kogito.taskassigning.core.model.User;\n+\n+import static org.kie.kogito.taskassigning.core.model.ModelConstants.IS_NOT_DUMMY_TASK_ASSIGNMENT;\n+import static org.kie.kogito.taskassigning.core.model.ModelConstants.IS_PLANNING_USER;\n+import static org.kie.kogito.taskassigning.core.model.solver.TaskHelper.extractTaskAssignments;\n+\n+public class PlanningBuilder {\n+\n+    private TaskAssigningSolution solution;\n+    private int publishWindowSize;\n+    private TaskAssigningServiceContext context;\n+\n+    private PlanningBuilder() {\n+    }\n+\n+    public static PlanningBuilder create() {\n+        return new PlanningBuilder();\n+    }\n+\n+    public PlanningBuilder forSolution(TaskAssigningSolution solution) {\n+        this.solution = solution;\n+        return this;\n+    }\n+\n+    public PlanningBuilder withContext(TaskAssigningServiceContext context) {\n+        this.context = context;\n+        return this;\n+    }\n+\n+    public PlanningBuilder withPublishWindowSize(int publishWindowSize) {\n+        this.publishWindowSize = publishWindowSize;\n+        return this;\n+    }\n+\n+    public List<PlanningItem> build() {\n+        return solution.getUserList().stream()\n+                .map(this::buildPlanningItems)\n+                .flatMap(Collection::stream)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<PlanningItem> buildPlanningItems(User user) {\n+        List<TaskAssignment> taskAssignments = extractTaskAssignments(user, IS_NOT_DUMMY_TASK_ASSIGNMENT);\n+        Iterator<TaskAssignment> taskAssignmentsIt = taskAssignments.iterator();\n+        TaskAssignment taskAssignment;\n+        List<PlanningItem> result = new ArrayList<>();\n+\n+        int count = 0;\n+        while (taskAssignmentsIt.hasNext() && (count < publishWindowSize || IS_PLANNING_USER.test(user.getId()))) {\n+            taskAssignment = taskAssignmentsIt.next();\n+            if (!context.isTaskPublished(taskAssignment.getId())) {\n+                result.add(new PlanningItem(taskAssignment.getTask(), user.getId()));\n+            }\n+            count++;\n+        }\n+        return result;\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "74071ea504099dbf49db43cf5c05908f4ed9506c",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningExecutionResult.java",
    "status": "added",
    "additions": 32,
    "deletions": 0,
    "changes": 32,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningExecutionResult.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningExecutionResult.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningExecutionResult.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.taskassigning.service;\n+\n+import java.util.List;\n+\n+public class PlanningExecutionResult {\n+\n+    private List<PlanningExecutionResultItem> items;\n+\n+    public PlanningExecutionResult(List<PlanningExecutionResultItem> items) {\n+        this.items = items;\n+    }\n+\n+    public List<PlanningExecutionResultItem> getItems() {\n+        return items;\n+    }\n+}"
  },
  {
    "sha": "eb30fbf4f11bdb2cb4db28014a075195d00c5386",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningExecutionResultItem.java",
    "status": "added",
    "additions": 45,
    "deletions": 0,
    "changes": 45,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningExecutionResultItem.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningExecutionResultItem.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningExecutionResultItem.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.taskassigning.service;\n+\n+public class PlanningExecutionResultItem {\n+\n+    private PlanningItem item;\n+\n+    private Exception error;\n+\n+    public PlanningExecutionResultItem(PlanningItem item) {\n+        this.item = item;\n+    }\n+\n+    public PlanningExecutionResultItem(PlanningItem item, Exception error) {\n+        this.item = item;\n+        this.error = error;\n+    }\n+\n+    public boolean hasError() {\n+        return error != null;\n+    }\n+\n+    public PlanningItem getItem() {\n+        return item;\n+    }\n+\n+    public Exception getError() {\n+        return error;\n+    }\n+}"
  },
  {
    "sha": "e273fcd1e0b8ef9e695ab414e213ce7d356af600",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningExecutor.java",
    "status": "added",
    "additions": 138,
    "deletions": 0,
    "changes": 138,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningExecutor.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningExecutor.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningExecutor.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.taskassigning.service;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+import org.kie.kogito.taskassigning.ClientServices;\n+import org.kie.kogito.taskassigning.core.model.Task;\n+import org.kie.kogito.taskassigning.process.service.client.ProcessServiceClient;\n+import org.kie.kogito.taskassigning.service.config.TaskAssigningConfig;\n+import org.kie.kogito.taskassigning.service.config.TaskAssigningConfigUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.taskassigning.service.RunnableBase.Status.STARTED;\n+import static org.kie.kogito.taskassigning.service.RunnableBase.Status.STARTING;\n+import static org.kie.kogito.taskassigning.service.RunnableBase.Status.STOPPED;\n+\n+public class PlanningExecutor extends RunnableBase {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PlanningExecutor.class);\n+\n+    private static final String CLAIM_PHASE = \"claim\";\n+\n+    private TaskAssigningConfig config;\n+    private ClientServices clientServices;\n+\n+    private List<PlanningItem> planningItems;\n+    private Consumer<PlanningExecutionResult> resultConsumer;\n+    private Map<String, ProcessServiceClient> serviceClientMap = new HashMap<>();\n+\n+    public PlanningExecutor(ClientServices clientServices, TaskAssigningConfig config) {\n+        this.clientServices = clientServices;\n+        this.config = config;\n+    }\n+\n+    public void start(List<PlanningItem> planningItems, Consumer<PlanningExecutionResult> resultConsumer) {\n+        startCheck();\n+        this.planningItems = planningItems;\n+        this.resultConsumer = resultConsumer;\n+        startPermit.release();\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (isAlive()) {\n+            try {\n+                startPermit.acquire();\n+                if (isAlive() && status.compareAndSet(STARTING, STARTED)) {\n+                    LOGGER.debug(\"Starting planning execution with {} items\", planningItems.size());\n+                    PlanningExecutionResult result = executePlanning(planningItems);\n+                    LOGGER.debug(\"Planning execution finalized\");\n+                    if (isAlive() && status.compareAndSet(STARTED, STOPPED)) {\n+                        LOGGER.debug(\"Notify planning execution result consumer\");\n+                        applyResult(result);\n+                    }\n+                }\n+            } catch (InterruptedException e) {\n+                super.destroy();\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+        closeServiceClients();\n+    }\n+\n+    private PlanningExecutionResult executePlanning(List<PlanningItem> planningItems) {\n+        ArrayList<PlanningExecutionResultItem> resultItems = new ArrayList<>();\n+        Iterator<PlanningItem> planningItemsIt = planningItems.iterator();\n+        PlanningItem planningItem;\n+        while (planningItemsIt.hasNext() && isAlive()) {\n+            planningItem = planningItemsIt.next();\n+            try {\n+                URL serviceURL = buildServiceURL(planningItem.getTask());\n+                ProcessServiceClient serviceClient =\n+                        serviceClientMap.computeIfAbsent(serviceURL.toString(), url -> createProcessServiceClient(clientServices, config, serviceURL));\n+                serviceClient.transitionTask(planningItem.getTask().getProcessId(),\n+                        planningItem.getTask().getProcessInstanceId(),\n+                        planningItem.getTask().getName(),\n+                        planningItem.getTask().getId(),\n+                        CLAIM_PHASE,\n+                        planningItem.getTargetUser(),\n+                        new ArrayList<>(planningItem.getTask().getPotentialGroups()));\n+                resultItems.add(new PlanningExecutionResultItem(planningItem));\n+\n+            } catch (Exception e) {\n+                LOGGER.debug(\"Error during the assignment of taskId: {}, processInstanceId: {}, processId: {}, to user: {}\", planningItem.getTask().getId(),\n+                        planningItem.getTask().getProcessInstanceId(), planningItem.getTask().getProcessId(), planningItem.getTargetUser());\n+                resultItems.add(new PlanningExecutionResultItem(planningItem, e));\n+            }\n+        }\n+        return new PlanningExecutionResult(resultItems);\n+    }\n+\n+    ProcessServiceClient createProcessServiceClient(ClientServices clientServices, TaskAssigningConfig config, URL serviceUrl) {\n+        return TaskAssigningConfigUtil.createProcessServiceClient(clientServices, config, serviceUrl);\n+    }\n+\n+    void applyResult(PlanningExecutionResult result) {\n+        resultConsumer.accept(result);\n+    }\n+\n+    private void closeServiceClients() {\n+        serviceClientMap.values().forEach(serviceClient -> {\n+            try {\n+                serviceClient.close();\n+            } catch (IOException e) {\n+                LOGGER.warn(\"Error while closing process service client: {}\", e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private static URL buildServiceURL(Task task) throws MalformedURLException {\n+        int serviceUrlIndex = task.getEndpoint().indexOf(task.getProcessId() + \"/\" + task.getProcessInstanceId());\n+        return new URL(task.getEndpoint().substring(0, serviceUrlIndex - 1));\n+    }\n+}"
  },
  {
    "sha": "f38a5b4891a76d1e20ed7d9adfcc2e8f0233b90e",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningItem.java",
    "status": "added",
    "additions": 39,
    "deletions": 0,
    "changes": 39,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningItem.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningItem.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/PlanningItem.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.taskassigning.service;\n+\n+import org.kie.kogito.taskassigning.core.model.Task;\n+\n+public class PlanningItem {\n+\n+    private Task task;\n+\n+    private String targetUser;\n+\n+    public PlanningItem(Task task, String targetUser) {\n+        this.task = task;\n+        this.targetUser = targetUser;\n+    }\n+\n+    public Task getTask() {\n+        return task;\n+    }\n+\n+    public String getTargetUser() {\n+        return targetUser;\n+    }\n+}"
  },
  {
    "sha": "e772ca4aa3622c0c5d418d097e5320781199899d",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/RunnableBase.java",
    "status": "modified",
    "additions": 11,
    "deletions": 0,
    "changes": 11,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/RunnableBase.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/RunnableBase.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/RunnableBase.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -16,9 +16,11 @@\n \n package org.kie.kogito.taskassigning.service;\n \n+import java.util.concurrent.Semaphore;\n import java.util.concurrent.atomic.AtomicReference;\n \n import static org.kie.kogito.taskassigning.service.RunnableBase.Status.DESTROYED;\n+import static org.kie.kogito.taskassigning.service.RunnableBase.Status.STARTING;\n import static org.kie.kogito.taskassigning.service.RunnableBase.Status.STOPPED;\n \n public abstract class RunnableBase implements Runnable {\n@@ -33,8 +35,17 @@\n \n     protected final AtomicReference<Status> status = new AtomicReference<>(STOPPED);\n \n+    protected final Semaphore startPermit = new Semaphore(0);\n+\n+    protected void startCheck() {\n+        if (!status.compareAndSet(STOPPED, STARTING)) {\n+            throw new IllegalStateException(\"start method can only be invoked when the status is STOPPED\");\n+        }\n+    }\n+\n     public void destroy() {\n         status.set(DESTROYED);\n+        startPermit.release();\n     }\n \n     /**"
  },
  {
    "sha": "862cdaf45e28d0f9f2d23b851ee12de3f3be052f",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolutionBuilder.java",
    "status": "modified",
    "additions": 12,
    "deletions": 13,
    "changes": 25,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolutionBuilder.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolutionBuilder.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolutionBuilder.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -28,24 +28,21 @@\n import org.kie.kogito.taskassigning.core.model.TaskAssigningSolution;\n import org.kie.kogito.taskassigning.core.model.TaskAssignment;\n import org.kie.kogito.taskassigning.core.model.User;\n-import org.kie.kogito.taskassigning.index.service.client.graphql.UserTaskInstance;\n import org.kie.kogito.taskassigning.service.util.IndexedElement;\n import org.kie.kogito.taskassigning.service.util.UserUtil;\n \n import static org.kie.kogito.taskassigning.core.model.ModelConstants.DUMMY_TASK_ASSIGNMENT;\n+import static org.kie.kogito.taskassigning.core.model.ModelConstants.DUMMY_TASK_ASSIGNMENT_PLANNER_1738;\n import static org.kie.kogito.taskassigning.core.model.ModelConstants.IS_PLANNING_USER;\n import static org.kie.kogito.taskassigning.core.model.ModelConstants.PLANNING_USER;\n-import static org.kie.kogito.taskassigning.service.TaskStatus.RESERVED;\n+import static org.kie.kogito.taskassigning.service.TaskState.RESERVED;\n import static org.kie.kogito.taskassigning.service.util.IndexedElement.addInOrder;\n-import static org.kie.kogito.taskassigning.service.util.TaskUtil.fromUserTaskInstance;\n+import static org.kie.kogito.taskassigning.service.util.TaskUtil.fromTaskData;\n import static org.kie.kogito.taskassigning.service.util.UserUtil.filterDuplicates;\n \n-/**\n- * This class is intended for the restoring of a TaskAssigningSolution given a set of UserTaskInstance and a set of User.\n- */\n public class SolutionBuilder {\n \n-    private List<UserTaskInstance> userTaskInstances;\n+    private List<TaskData> taskDataList;\n     private List<org.kie.kogito.taskassigning.user.service.api.User> externalUsers;\n \n     private SolutionBuilder() {\n@@ -55,8 +52,8 @@ public static SolutionBuilder newBuilder() {\n         return new SolutionBuilder();\n     }\n \n-    public SolutionBuilder withTasks(List<UserTaskInstance> userTaskInstances) {\n-        this.userTaskInstances = userTaskInstances;\n+    public SolutionBuilder withTasks(List<TaskData> taskDataList) {\n+        this.taskDataList = taskDataList;\n         return this;\n     }\n \n@@ -74,13 +71,13 @@ public TaskAssigningSolution build() {\n                 .collect(Collectors.toMap(User::getId, Function.identity()));\n         usersById.put(PLANNING_USER.getId(), PLANNING_USER);\n \n-        userTaskInstances.forEach(userTaskInstance -> {\n-            Task task = fromUserTaskInstance(userTaskInstance);\n+        taskDataList.forEach(taskData -> {\n+            Task task = fromTaskData(taskData);\n             TaskAssignment taskAssignment = new TaskAssignment(task);\n             String state = task.getState();\n             taskAssignments.add(taskAssignment);\n             if (RESERVED.value().equals(state)) {\n-                addTaskAssignmentToUser(assignmentsByUserId, taskAssignment, userTaskInstance.getActualOwner(), -1, true);\n+                addTaskAssignmentToUser(assignmentsByUserId, taskAssignment, taskData.getActualOwner(), -1, true);\n             }\n         });\n \n@@ -95,8 +92,10 @@ public TaskAssigningSolution build() {\n             addAssignmentsToUser(user, userTasks);\n         });\n \n-        // Add the DUMMY_TASK to avoid running into scenarios where the solution remains with no tasks.\n+        // Add the DUMMY_TASKs to avoid running into scenarios where the solution remains with no tasks or only one task\n+        // for selection. (https://issues.redhat.com/browse/PLANNER-1738)\n         taskAssignments.add(DUMMY_TASK_ASSIGNMENT);\n+        taskAssignments.add(DUMMY_TASK_ASSIGNMENT_PLANNER_1738);\n \n         final List<User> users = new ArrayList<>(usersById.values());\n         return new TaskAssigningSolution(\"-1\", users, taskAssignments);"
  },
  {
    "sha": "d96d0fe16df1fcfb7545708f21de8bb2ed625c05",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolutionChangesBuilder.java",
    "status": "added",
    "additions": 213,
    "deletions": 0,
    "changes": 213,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolutionChangesBuilder.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolutionChangesBuilder.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolutionChangesBuilder.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.taskassigning.service;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.kie.kogito.taskassigning.core.model.Task;\n+import org.kie.kogito.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.kogito.taskassigning.core.model.TaskAssignment;\n+import org.kie.kogito.taskassigning.core.model.User;\n+import org.kie.kogito.taskassigning.core.model.solver.realtime.AddTaskProblemFactChange;\n+import org.kie.kogito.taskassigning.core.model.solver.realtime.AssignTaskProblemFactChange;\n+import org.kie.kogito.taskassigning.core.model.solver.realtime.ReleaseTaskProblemFactChange;\n+import org.kie.kogito.taskassigning.core.model.solver.realtime.RemoveTaskProblemFactChange;\n+import org.kie.kogito.taskassigning.core.model.solver.realtime.TaskPriorityChangeProblemFactChange;\n+import org.kie.kogito.taskassigning.core.model.solver.realtime.TaskStateChangeProblemFactChange;\n+import org.kie.kogito.taskassigning.service.util.IndexedElement;\n+import org.kie.kogito.taskassigning.user.service.api.UserServiceConnector;\n+import org.optaplanner.core.api.solver.ProblemFactChange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.taskassigning.core.model.solver.TaskHelper.filterNonDummyAssignments;\n+import static org.kie.kogito.taskassigning.service.TaskState.READY;\n+import static org.kie.kogito.taskassigning.service.TaskState.RESERVED;\n+import static org.kie.kogito.taskassigning.service.util.IndexedElement.addInOrder;\n+import static org.kie.kogito.taskassigning.service.util.TaskUtil.fromTaskData;\n+import static org.kie.kogito.taskassigning.service.util.UserUtil.fromExternalUser;\n+\n+public class SolutionChangesBuilder {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SolutionChangesBuilder.class);\n+\n+    private Map<String, User> usersById;\n+    private List<AddTaskProblemFactChange> newTasksChanges = new ArrayList<>();\n+    private List<RemoveTaskProblemFactChange> removedTaskChanges = new ArrayList<>();\n+    private Set<TaskAssignment> removedTasksSet = new HashSet<>();\n+    private List<ReleaseTaskProblemFactChange> releasedTasksChanges = new ArrayList<>();\n+    private Map<String, List<IndexedElement<AssignTaskProblemFactChange>>> assignToUserChangesByUserId = new HashMap<>();\n+    private List<ProblemFactChange<TaskAssigningSolution>> propertyChanges = new ArrayList<>();\n+\n+    private TaskAssigningServiceContext context;\n+    private UserServiceConnector userServiceConnector;\n+    private TaskAssigningSolution solution;\n+    private List<TaskData> taskDataList;\n+\n+    private SolutionChangesBuilder() {\n+    }\n+\n+    public static SolutionChangesBuilder create() {\n+        return new SolutionChangesBuilder();\n+    }\n+\n+    public SolutionChangesBuilder withContext(TaskAssigningServiceContext context) {\n+        this.context = context;\n+        return this;\n+    }\n+\n+    public SolutionChangesBuilder withUserServiceConnector(UserServiceConnector userServiceConnector) {\n+        this.userServiceConnector = userServiceConnector;\n+        return this;\n+    }\n+\n+    public SolutionChangesBuilder forSolution(TaskAssigningSolution solution) {\n+        this.solution = solution;\n+        return this;\n+    }\n+\n+    public SolutionChangesBuilder fromTasksData(List<TaskData> taskDataList) {\n+        this.taskDataList = taskDataList;\n+        return this;\n+    }\n+\n+    public List<ProblemFactChange<TaskAssigningSolution>> build() {\n+        usersById = solution.getUserList()\n+                .stream()\n+                .collect(Collectors.toMap(User::getId, Function.identity()));\n+\n+        Map<String, TaskAssignment> taskAssignmentById = filterNonDummyAssignments(solution.getTaskAssignmentList())\n+                .stream()\n+                .collect(Collectors.toMap(TaskAssignment::getId, Function.identity()));\n+\n+        TaskAssignment taskAssignment;\n+        for (TaskData taskData : taskDataList) {\n+            taskAssignment = taskAssignmentById.remove(taskData.getId());\n+            if (taskAssignment == null) {\n+                addNewTaskChanges(taskData);\n+            } else {\n+                addTaskChanges(taskAssignment, taskData);\n+            }\n+        }\n+\n+        for (TaskAssignment removedTask : removedTasksSet) {\n+            removedTaskChanges.add(new RemoveTaskProblemFactChange(removedTask));\n+        }\n+\n+        List<ProblemFactChange<TaskAssigningSolution>> totalChanges = new ArrayList<>();\n+        totalChanges.addAll(removedTaskChanges);\n+        totalChanges.addAll(releasedTasksChanges);\n+\n+        for (List<IndexedElement<AssignTaskProblemFactChange>> assignTaskToUserChanges : assignToUserChangesByUserId.values()) {\n+            totalChanges.addAll(assignTaskToUserChanges.stream().map(IndexedElement::getElement).collect(Collectors.toList()));\n+        }\n+\n+        totalChanges.addAll(propertyChanges);\n+        totalChanges.addAll(newTasksChanges);\n+\n+        if (!totalChanges.isEmpty()) {\n+            totalChanges.add(0, scoreDirector -> context.setCurrentChangeSetId(context.nextChangeSetId()));\n+        }\n+        return totalChanges;\n+    }\n+\n+    private void addNewTaskChanges(TaskData taskData) {\n+        Task newTask;\n+        if (READY.value().equals(taskData.getState())) {\n+            newTask = fromTaskData(taskData);\n+            newTasksChanges.add(new AddTaskProblemFactChange(new TaskAssignment(newTask)));\n+            context.setTaskPublished(taskData.getId(), false);\n+        } else if (RESERVED.value().equals(taskData.getState())) {\n+            newTask = fromTaskData(taskData);\n+            User user = getUser(usersById.get(taskData.getActualOwner()), taskData.getActualOwner());\n+            AssignTaskProblemFactChange change = new AssignTaskProblemFactChange(new TaskAssignment(newTask), user, true);\n+            context.setTaskPublished(taskData.getId(), true);\n+            addChangeToUser(assignToUserChangesByUserId, change, user, -1, true);\n+        }\n+    }\n+\n+    private static void addChangeToUser(Map<String, List<IndexedElement<AssignTaskProblemFactChange>>> changesByUserId,\n+            AssignTaskProblemFactChange change,\n+            User user,\n+            int index,\n+            boolean pinned) {\n+        final List<IndexedElement<AssignTaskProblemFactChange>> userChanges = changesByUserId.computeIfAbsent(user.getId(), key -> new ArrayList<>());\n+        addInOrder(userChanges, new IndexedElement<>(change, index, pinned));\n+    }\n+\n+    private void addTaskChanges(TaskAssignment taskAssignment,\n+            TaskData taskData) {\n+        String taskState = taskData.getState();\n+        if (READY.value().equals(taskState)) {\n+            context.setTaskPublished(taskData.getId(), false);\n+            releasedTasksChanges.add(new ReleaseTaskProblemFactChange(taskAssignment));\n+        } else if (RESERVED.value().equals(taskState)) {\n+            context.setTaskPublished(taskData.getId(), true);\n+            if (!taskData.getActualOwner().equals(taskAssignment.getUser().getId()) || !taskAssignment.isPinned()) {\n+                final User user = getUser(usersById.get(taskData.getActualOwner()), taskData.getActualOwner());\n+                AssignTaskProblemFactChange change = new AssignTaskProblemFactChange(taskAssignment, user, true);\n+                addChangeToUser(assignToUserChangesByUserId, change, user, -1, true);\n+            }\n+        } else if (TaskState.isTerminal(taskState)) {\n+            removedTasksSet.add(taskAssignment);\n+        }\n+\n+        //TODO, discuss other traceable change types.\n+        if (!removedTasksSet.contains(taskAssignment)) {\n+            if (!Objects.equals(taskAssignment.getTask().getPriority(), taskData.getPriority())) {\n+                propertyChanges.add(new TaskPriorityChangeProblemFactChange(taskAssignment, taskData.getPriority()));\n+            }\n+            if (!Objects.equals(taskAssignment.getTask().getState(), taskData.getState())) {\n+                propertyChanges.add(new TaskStateChangeProblemFactChange(taskAssignment, taskData.getState()));\n+            }\n+        }\n+    }\n+\n+    private User getUser(User existingUser, String userId) {\n+        if (existingUser != null) {\n+            return existingUser;\n+        } else {\n+            LOGGER.debug(\"User {} was not found in current solution, it'll we looked up in the external user system .\", userId);\n+            User user;\n+            org.kie.kogito.taskassigning.user.service.api.User externalUser = null;\n+            try {\n+                externalUser = userServiceConnector.findUser(userId);\n+            } catch (Exception e) {\n+                LOGGER.warn(\"An error was produced while querying user {} from the external user system.\", userId);\n+            }\n+            if (externalUser != null) {\n+                user = fromExternalUser(externalUser);\n+            } else {\n+                // We add it by convention, since the kogito runtime supports the assignment of tasks to whatever user id.\n+                LOGGER.warn(\"User {} was not found in the external user system, it looks like it's a manual\" +\n+                        \" assignment from the kogito tasks administration to a non existing user or an error was produced when\" +\n+                        \" querying the external user system (in this last case the user will be updated on next synchronization).\" +\n+                        \" It'll be added to the solution to respect the assignment.\", userId);\n+                user = new User(userId);\n+            }\n+            return user;\n+        }\n+    }\n+}"
  },
  {
    "sha": "dcdb37eb9633520095d05cf2922ab643920ce1fc",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolutionDataLoader.java",
    "status": "modified",
    "additions": 34,
    "deletions": 36,
    "changes": 70,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolutionDataLoader.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolutionDataLoader.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolutionDataLoader.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -17,22 +17,23 @@\n package org.kie.kogito.taskassigning.service;\n \n import java.time.Duration;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n-import java.util.concurrent.Semaphore;\n import java.util.function.Consumer;\n \n-import org.kie.kogito.taskassigning.index.service.client.graphql.UserTaskInstance;\n import org.kie.kogito.taskassigning.user.service.api.User;\n import org.kie.kogito.taskassigning.user.service.api.UserServiceConnector;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import static org.kie.kogito.taskassigning.service.RunnableBase.Status.STARTED;\n+import static org.kie.kogito.taskassigning.service.RunnableBase.Status.STARTING;\n import static org.kie.kogito.taskassigning.service.RunnableBase.Status.STOPPED;\n-import static org.kie.kogito.taskassigning.service.TaskStatus.READY;\n-import static org.kie.kogito.taskassigning.service.TaskStatus.RESERVED;\n+import static org.kie.kogito.taskassigning.service.TaskState.READY;\n+import static org.kie.kogito.taskassigning.service.TaskState.RESERVED;\n+import static org.kie.kogito.taskassigning.service.util.TaskUtil.fromUserTaskInstances;\n \n public class SolutionDataLoader extends RunnableBase {\n \n@@ -41,33 +42,31 @@\n             \" It was not possible to access the %s.\" +\n             \" Next attempt will be in a period of %s, error: %s\";\n \n-    //TODO upcoming iteration, parametrize this value\n-    private static final int PAGE_SIZE = 2;\n-\n     private TaskServiceConnector taskServiceConnector;\n     private UserServiceConnector userServiceConnector;\n-    private final Duration retryInterval;\n-\n-    private Semaphore startPermit = new Semaphore(0);\n     private Consumer<Result> resultConsumer;\n+    private boolean includeTasks;\n+    private boolean includeUsers;\n+    private Duration retryInterval;\n     private int remainingRetries;\n+    private int pageSize;\n \n     public static class Result {\n \n-        private List<UserTaskInstance> tasks;\n-        private List<User> users;\n-        private List<Throwable> errors;\n+        private List<TaskData> tasks = new ArrayList<>();\n+        private List<User> users = new ArrayList<>();\n+        private List<Exception> errors;\n \n-        public Result(List<UserTaskInstance> tasks, List<User> users) {\n+        public Result(List<TaskData> tasks, List<User> users) {\n             this.tasks = tasks;\n             this.users = users;\n         }\n \n-        public Result(List<Throwable> errors) {\n+        public Result(List<Exception> errors) {\n             this.errors = errors;\n         }\n \n-        public List<UserTaskInstance> getTasks() {\n+        public List<TaskData> getTasks() {\n             return tasks;\n         }\n \n@@ -79,31 +78,27 @@ public boolean hasErrors() {\n             return errors != null && !errors.isEmpty();\n         }\n \n-        public List<Throwable> getErrors() {\n+        public List<Exception> getErrors() {\n             return errors;\n         }\n     }\n \n     public SolutionDataLoader(TaskServiceConnector taskServiceConnector,\n-            UserServiceConnector userServiceConnector,\n-            Duration retryInterval) {\n+            UserServiceConnector userServiceConnector) {\n+\n         this.taskServiceConnector = taskServiceConnector;\n         this.userServiceConnector = userServiceConnector;\n-        this.retryInterval = retryInterval;\n     }\n \n-    public void start(Consumer<Result> resultConsumer, int retries) {\n-        if (!status.compareAndSet(STOPPED, STARTED)) {\n-            throw new IllegalStateException(\"start method can only be invoked when the status is STOPPED\");\n-        }\n+    public void start(Consumer<Result> resultConsumer, boolean includeTasks, boolean includeUsers,\n+            Duration retryInterval, int retries, int pageSize) {\n+        startCheck();\n         this.resultConsumer = resultConsumer;\n+        this.includeTasks = includeTasks;\n+        this.includeUsers = includeUsers;\n+        this.retryInterval = retryInterval;\n         this.remainingRetries = retries;\n-        startPermit.release();\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        super.destroy();\n+        this.pageSize = pageSize;\n         startPermit.release();\n     }\n \n@@ -112,7 +107,7 @@ public void run() {\n         while (isAlive()) {\n             try {\n                 startPermit.acquire();\n-                if (isAlive()) {\n+                if (isAlive() && (status.compareAndSet(STARTING, STARTED) || status.get() == STARTED)) {\n                     Result result = loadData();\n                     if (result.hasErrors() && hasRemainingRetries()) {\n                         decreaseRemainingRetries();\n@@ -138,17 +133,20 @@ private void decreaseRemainingRetries() {\n     }\n \n     protected Result loadData() {\n-        List<UserTaskInstance> tasks = null;\n+        List<TaskData> tasks = null;\n         List<User> users = null;\n         try {\n-            tasks = taskServiceConnector.findAllTasks(Arrays.asList(READY.value(), RESERVED.value()), PAGE_SIZE);\n-            if (isAlive()) {\n+            if (includeTasks && isAlive()) {\n+                tasks = fromUserTaskInstances(taskServiceConnector.findAllTasks(Arrays.asList(READY.value(), RESERVED.value()), pageSize));\n+            }\n+            if (includeUsers && isAlive()) {\n                 users = userServiceConnector.findAllUsers();\n             }\n-            return new Result(tasks, users);\n+            return new Result(tasks != null ? tasks : new ArrayList<>(),\n+                    users != null ? users : new ArrayList<>());\n         } catch (Exception e) {\n             String msg;\n-            if (tasks == null) {\n+            if (includeTasks && tasks == null) {\n                 msg = String.format(SERVICE_ACCESS_ERROR, \" Task Service\", retryInterval, e.getMessage());\n             } else {\n                 msg = String.format(SERVICE_ACCESS_ERROR, \" User Service\", retryInterval, e.getMessage());"
  },
  {
    "sha": "940299498fdb1aabe1047a2f4e71f1d866d594cf",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolverExecutor.java",
    "status": "modified",
    "additions": 1,
    "deletions": 6,
    "changes": 7,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolverExecutor.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolverExecutor.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/SolverExecutor.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -17,7 +17,6 @@\n package org.kie.kogito.taskassigning.service;\n \n import java.util.List;\n-import java.util.concurrent.Semaphore;\n \n import org.kie.kogito.taskassigning.core.model.TaskAssigningSolution;\n import org.optaplanner.core.api.solver.ProblemFactChange;\n@@ -45,8 +44,6 @@\n     private SolverFactory<TaskAssigningSolution> solverFactory;\n     private SolverEventListener<TaskAssigningSolution> eventListener;\n \n-    private final Semaphore startPermit = new Semaphore(0);\n-\n     public SolverExecutor(SolverFactory<TaskAssigningSolution> solverFactory,\n             SolverEventListener<TaskAssigningSolution> eventListener) {\n         this.solverFactory = solverFactory;\n@@ -63,9 +60,7 @@ public SolverExecutor(SolverFactory<TaskAssigningSolution> solverFactory,\n      * @param solution a valid solution for starting the solver with.\n      */\n     public void start(final TaskAssigningSolution solution) {\n-        if (!status.compareAndSet(STOPPED, STARTING)) {\n-            throw new SolverExecutorException(\"SolverExecutor start method can only be invoked when the status is STOPPED\");\n-        }\n+        startCheck();\n         this.solution = solution;\n         try {\n             this.solver = solverFactory.buildSolver();"
  },
  {
    "sha": "9e27dcd3ab620c115a4221b43a955ba780fda492",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskAssigningService.java",
    "status": "modified",
    "additions": 348,
    "deletions": 50,
    "changes": 398,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskAssigningService.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskAssigningService.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskAssigningService.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -16,36 +16,57 @@\n \n package org.kie.kogito.taskassigning.service;\n \n-import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n \n import javax.annotation.PostConstruct;\n import javax.enterprise.context.ApplicationScoped;\n import javax.enterprise.event.Observes;\n import javax.inject.Inject;\n \n import org.eclipse.microprofile.context.ManagedExecutor;\n+import org.kie.kogito.taskassigning.ClientServices;\n+import org.kie.kogito.taskassigning.core.model.Task;\n import org.kie.kogito.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.kogito.taskassigning.core.model.TaskAssignment;\n+import org.kie.kogito.taskassigning.core.model.User;\n+import org.kie.kogito.taskassigning.core.model.solver.realtime.AssignTaskProblemFactChange;\n import org.kie.kogito.taskassigning.service.config.TaskAssigningConfig;\n import org.kie.kogito.taskassigning.service.config.TaskAssigningConfigValidator;\n+import org.kie.kogito.taskassigning.service.messaging.BufferedUserTaskEventConsumer;\n+import org.kie.kogito.taskassigning.service.messaging.UserTaskEvent;\n import org.kie.kogito.taskassigning.user.service.api.UserServiceConnector;\n+import org.optaplanner.core.api.solver.ProblemFactChange;\n import org.optaplanner.core.api.solver.SolverFactory;\n+import org.optaplanner.core.api.solver.event.BestSolutionChangedEvent;\n+import org.optaplanner.core.api.solver.event.SolverEventListener;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import io.quarkus.runtime.ShutdownEvent;\n import io.quarkus.runtime.Startup;\n \n-/**\n- * Class in experimental status! don't waste time here!\n- * The only objective by now is to be sure the tasks can be consumed and the solver started.\n- */\n+import static org.kie.kogito.taskassigning.core.model.solver.TaskHelper.filterNonDummyAssignments;\n+import static org.kie.kogito.taskassigning.service.util.EventUtil.filterNewestTaskEvents;\n+import static org.kie.kogito.taskassigning.service.util.EventUtil.filterNewestTaskEventsInContext;\n+import static org.kie.kogito.taskassigning.service.util.TaskUtil.fromUserTaskEvents;\n+\n @ApplicationScoped\n @Startup\n public class TaskAssigningService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(TaskAssigningService.class);\n \n+    private static final Predicate<UserTaskEvent> IS_ACTIVE_TASK_EVENT = userTaskEvent -> !TaskState.isTerminal(userTaskEvent.getState());\n+\n     @Inject\n     SolverFactory<TaskAssigningSolution> solverFactory;\n \n@@ -61,76 +82,321 @@\n     @Inject\n     UserServiceConnector userServiceConnector;\n \n-    SolverExecutor solverExecutor;\n+    @Inject\n+    BufferedUserTaskEventConsumer userTaskEventConsumer;\n+\n+    @Inject\n+    ClientServices clientServices;\n+\n+    private SolverExecutor solverExecutor;\n+\n+    private SolutionDataLoader solutionDataLoader;\n+\n+    private PlanningExecutor planningExecutor;\n+\n+    private TaskAssigningServiceContext context;\n \n-    SolutionDataLoader solutionDataLoader;\n+    private AtomicReference<TaskAssigningSolution> currentSolution = new AtomicReference<>(null);\n \n-    AtomicReference<String> serviceStatus = new AtomicReference<>(\"Stopped\");\n+    private AtomicBoolean applyingPlanningExecutionResult = new AtomicBoolean();\n \n-    int totalChances = 3;\n+    private AtomicBoolean startingFromEvents = new AtomicBoolean();\n \n+    private List<UserTaskEvent> startingEvents;\n+\n+    /**\n+     * Synchronizes potential concurrent accesses between the different components that invoke callbacks on the service.\n+     */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /**\n+     * Handles the TaskAssigningService initialization procedure and instructs the SolutionDataLoader for getting the\n+     * information for the initial solution.\n+     */\n     @PostConstruct\n     void start() {\n-        serviceStatus.set(\"Starting\");\n         startUpValidation();\n-        solverExecutor = new SolverExecutor(solverFactory, solution -> {\n-            serviceStatus.set(\"Solution produced!\");\n-            LOGGER.debug(\"A new solution has been produced {}\", solution);\n-        });\n-\n+        context = createContext();\n+        userTaskEventConsumer.setConsumer(this::onTaskEvents);\n+        solverExecutor = createSolverExecutor(solverFactory, this::onBestSolutionChange);\n         managedExecutor.execute(solverExecutor);\n-        solutionDataLoader = new SolutionDataLoader(taskServiceConnector,\n-                userServiceConnector,\n-                Duration.ofMillis(5000));\n+        planningExecutor = createPlanningExecutor(clientServices, config);\n+        managedExecutor.execute(planningExecutor);\n+        solutionDataLoader = createSolutionDataLoader(taskServiceConnector, userServiceConnector);\n         managedExecutor.execute(solutionDataLoader);\n-        solutionDataLoader.start(this::processTaskLoadResult, 1);\n+        solutionDataLoader.start(this::onSolutionDataLoad,\n+                true, true,\n+                config.getDataLoaderRetryInterval(), config.getDataLoaderRetries(), config.getDataLoaderPageSize());\n     }\n \n-    // use the observer instead of the @PreDestroy alternative.\n-    // https://github.com/quarkusio/quarkus/issues/15026\n-    void onShutDownEvent(@Observes ShutdownEvent ev) {\n-        destroy();\n+    /**\n+     * Invoked by the SolutionDataLoader when the data for initializing the solution has been loaded or the number of\n+     * unsuccessful retries has been reached.\n+     * Three main scenarios might happen:\n+     * a) The service is starting and thus the initial solution load is attempted. If there are available tasks, the\n+     * solver will be started, first solution will arrive, etc.\n+     *\n+     * b) The number of unsuccessful retries has been reached, please continue retrying.\n+     *\n+     * c) No tasks where available at the time of service initialization and thus no solution to start the solver.\n+     * At a later point in time events arrived and the solution can be started with the information coming for them plus\n+     * the user information loaded by the solution data loader.\n+     *\n+     * @param result contains the requested data for creating the initial solution.\n+     */\n+    void onSolutionDataLoad(SolutionDataLoader.Result result) {\n+        lock.lock();\n+        try {\n+            LOGGER.debug(\"Solution data loading has finished, startingFromEvents: {}, hasErrors: {}, includeTasks: {}\"\n+                    + \", includeUsers: {}, tasks: {}, users: {}\", startingFromEvents, result.hasErrors(),\n+                    !startingFromEvents.get(), true, result.getTasks().size(), result.getUsers().size());\n+            if (result.hasErrors()) {\n+                solutionDataLoader.start(this::onSolutionDataLoad,\n+                        !startingFromEvents.get(), true,\n+                        config.getDataLoaderRetryInterval(), config.getDataLoaderRetries(), config.getDataLoaderPageSize());\n+            } else {\n+                TaskAssigningSolution solution;\n+                List<TaskAssignment> taskAssignments;\n+                if (Boolean.TRUE.equals(startingFromEvents.get())) {\n+                    if (hasQueuedEvents()) {\n+                        List<UserTaskEvent> newEvents = filterNewestTaskEventsInContext(context, pollEvents());\n+                        startingEvents.addAll(newEvents);\n+                        startingEvents = filterNewestTaskEvents(startingEvents)\n+                                .stream()\n+                                .filter(IS_ACTIVE_TASK_EVENT)\n+                                .collect(Collectors.toList());\n+                    }\n+                    solution = SolutionBuilder.newBuilder()\n+                            .withTasks(fromUserTaskEvents(startingEvents))\n+                            .withUsers(result.getUsers())\n+                            .build();\n+                    startingFromEvents.set(false);\n+                    startingEvents = null;\n+                } else {\n+                    solution = SolutionBuilder.newBuilder()\n+                            .withTasks(result.getTasks())\n+                            .withUsers(result.getUsers())\n+                            .build();\n+                }\n+                taskAssignments = filterNonDummyAssignments(solution.getTaskAssignmentList());\n+                if (!taskAssignments.isEmpty()) {\n+                    taskAssignments.forEach(taskAssignment -> {\n+                        context.setTaskPublished(taskAssignment.getId(), taskAssignment.isPinned());\n+                        context.setTaskLastEventTime(taskAssignment.getId(), taskAssignment.getTask().getLastUpdate());\n+                    });\n+                    solverExecutor.start(solution);\n+                } else {\n+                    resumeEvents();\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n     }\n \n-    void destroy() {\n+    private void onTaskEvents(List<UserTaskEvent> events) {\n+        lock.lock();\n         try {\n-            serviceStatus.set(\"Destroying\");\n-            LOGGER.info(\"Service is going down and will be destroyed.\");\n-            solverExecutor.destroy();\n-            solutionDataLoader.destroy();\n-            LOGGER.info(\"Service destroy sequence was executed successfully.\");\n-        } catch (Throwable e) {\n-            LOGGER.error(\"An error was produced during service destroy, but it'll go down anyway.\", e);\n+            pauseEvents();\n+            CompletableFuture.runAsync(() -> processTaskEvents(events));\n+        } finally {\n+            lock.unlock();\n         }\n     }\n \n-    public String getStatus() {\n-        return serviceStatus.get();\n+    /**\n+     * Invoked when a set of events are received for processing.\n+     * Two main scenarios might happen:\n+     * a) A solution already exists and thus the proper problem fact changes are calculated and passed to the solver for\n+     * execution. If there are no changes to apply, wait for more events.\n+     *\n+     * b) No solution exist. Instruct the solution data loader to read the users information and the solver will be\n+     * stared when this information is returned plus the information collected from the events.\n+     * \n+     * @param events a list of events to process.\n+     */\n+    void processTaskEvents(List<UserTaskEvent> events) {\n+        lock.lock();\n+        try {\n+            List<UserTaskEvent> newEvents = filterNewestTaskEventsInContext(context, events);\n+            if (currentSolution.get() == null) {\n+                // b) no solution exists, start if from the events information.\n+                List<UserTaskEvent> activeTaskEvents = newEvents.stream()\n+                        .filter(IS_ACTIVE_TASK_EVENT)\n+                        .collect(Collectors.toList());\n+                if (!activeTaskEvents.isEmpty()) {\n+                    startingEvents = activeTaskEvents;\n+                    startingFromEvents.set(true);\n+                    solutionDataLoader.start(this::onSolutionDataLoad,\n+                            false, true,\n+                            config.getDataLoaderRetryInterval(), config.getDataLoaderRetries(), config.getDataLoaderPageSize());\n+                } else {\n+                    resumeEvents();\n+                }\n+            } else {\n+                // a) a solution exists, calculate and apply the potential changes to apply.\n+                List<ProblemFactChange<TaskAssigningSolution>> changes = SolutionChangesBuilder.create()\n+                        .forSolution(currentSolution.get())\n+                        .withContext(context)\n+                        .withUserServiceConnector(userServiceConnector)\n+                        .fromTasksData(fromUserTaskEvents(newEvents))\n+                        .build();\n+                if (!changes.isEmpty()) {\n+                    solverExecutor.addProblemFactChanges(changes);\n+                } else {\n+                    resumeEvents();\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n     }\n \n-    private void processTaskLoadResult(SolutionDataLoader.Result result) {\n-        if (result.hasErrors()) {\n-            LOGGER.error(\"The following error was produced during initial solution loading\", result.getErrors().get(0));\n+    /**\n+     * Invoked when a new solution has been produced.\n+     * Three main scenarios might happen:\n+     * a) The produced solution is the result of set problem fact changes derived from new incoming events.\n+     * A new solution was created, the corresponding plan is created and delivered to the PlanningExecutor for execution.\n+     *\n+     * b) Same as a) but the corresponding plan has no items, nothing to execute. Wait for more events.\n+     *\n+     * c) The produced solution is the result of executing a set of \"pinning changes\" derived from the result of a\n+     * planning execution. Prioritize the execution of events that might have been arrived in the middle if any.\n+     *\n+     * @param event a BestSolutionChangeEvent with the new solution.\n+     */\n+    void onBestSolutionChange(BestSolutionChangedEvent<TaskAssigningSolution> event) {\n+        if (LOGGER.isDebugEnabled()) {\n+            LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {},\" +\n+                    \" isCurrentChangeSetProcessed: {}, newBestSolution: {}\",\n+                    event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(),\n+                    context.isCurrentChangeSetProcessed(), event.getNewBestSolution());\n+        }\n+        TaskAssigningSolution newBestSolution = event.getNewBestSolution();\n+        if (event.isEveryProblemFactChangeProcessed() && newBestSolution.getScore().isSolutionInitialized()) {\n+            onBestSolutionChange(newBestSolution);\n+        }\n+    }\n \n-            if (totalChances-- > 0) {\n-                LOGGER.debug(\"Initial solution load failed but we have totalChances {} to retry\", totalChances);\n-                solutionDataLoader.start(this::processTaskLoadResult, 1);\n+    private void onBestSolutionChange(TaskAssigningSolution newBestSolution) {\n+        if (!context.isCurrentChangeSetProcessed()) {\n+            executeSolutionChange(newBestSolution);\n+        }\n+    }\n+\n+    private void executeSolutionChange(TaskAssigningSolution solution) {\n+        lock.lock();\n+        try {\n+            LOGGER.debug(\"process the next generated solution, applyingPlanningExecutionResult: {}\", applyingPlanningExecutionResult.get());\n+            currentSolution.set(solution);\n+            context.setProcessedChangeSet(context.getCurrentChangeSetId());\n+            List<ProblemFactChange<TaskAssigningSolution>> pendingEventsChanges = null;\n+            if (Boolean.TRUE.equals(applyingPlanningExecutionResult.get())) {\n+                applyingPlanningExecutionResult.set(false);\n+                List<UserTaskEvent> pendingEvents = filterNewestTaskEventsInContext(context, pollEvents());\n+                if (!pendingEvents.isEmpty()) {\n+                    pendingEventsChanges = SolutionChangesBuilder.create()\n+                            .forSolution(solution)\n+                            .withContext(context)\n+                            .withUserServiceConnector(userServiceConnector)\n+                            .fromTasksData(fromUserTaskEvents(pendingEvents))\n+                            .build();\n+                }\n+            }\n+\n+            if (pendingEventsChanges != null && !pendingEventsChanges.isEmpty()) {\n+                solverExecutor.addProblemFactChanges(pendingEventsChanges);\n             } else {\n-                LOGGER.debug(\"There are no more chances left for starting the solution, service won't be able to start\");\n-                solutionDataLoader.destroy();\n-                solverExecutor.destroy();\n+                List<PlanningItem> planningItems = PlanningBuilder.create()\n+                        .forSolution(solution)\n+                        .withContext(context)\n+                        .withPublishWindowSize(config.getPublishWindowSize())\n+                        .build();\n+                if (!planningItems.isEmpty()) {\n+                    planningExecutor.start(planningItems, this::onPlanningExecuted);\n+                } else {\n+                    resumeEvents();\n+                }\n             }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n \n-        } else {\n-            LOGGER.debug(\"Data loading successful: tasks: {}, users: {}\", result.getTasks().size(), result.getUsers().size());\n-            TaskAssigningSolution solution = SolutionBuilder.newBuilder()\n-                    .withTasks(result.getTasks())\n-                    .withUsers(result.getUsers())\n-                    .build();\n-            serviceStatus.set(\"Starting Solver\");\n-            solverExecutor.start(solution);\n+    /**\n+     * Invoked when the PlanningExecutor finalized the execution of a plan.\n+     * Three main scenarios might happen:\n+     * a) There are successful invocations and thus tasks were assigned, the corresponding \"pinning changes\" must be produced.\n+     * Create and add them to the Solver.\n+     * \n+     * b) No \"pinning changes\" to execute there and no available events, retry with the planning items that failed.\n+     * \n+     * c) No \"pinning changes\" but there are available events, execute them.\n+     *\n+     * @param result a PlanningExecutionResult with results of the planning execution.\n+     */\n+    void onPlanningExecuted(PlanningExecutionResult result) {\n+        lock.lock();\n+        try {\n+            LOGGER.debug(\"Planning was executed\");\n+            applyingPlanningExecutionResult.set(false);\n+            TaskAssigningSolution solution = currentSolution.get();\n+            Map<String, User> usersById = solution.getUserList()\n+                    .stream()\n+                    .collect(Collectors.toMap(User::getId, Function.identity()));\n+            List<ProblemFactChange<TaskAssigningSolution>> pinningChanges = new ArrayList<>();\n+            Task task;\n+            User user;\n+            boolean published;\n+            for (PlanningExecutionResultItem resultItem : result.getItems()) {\n+                task = resultItem.getItem().getTask();\n+                published = !resultItem.hasError();\n+                if (published) {\n+                    user = usersById.get(resultItem.getItem().getTargetUser());\n+                    pinningChanges.add(new AssignTaskProblemFactChange(new TaskAssignment(task), user));\n+                }\n+                context.setTaskPublished(task.getId(), published);\n+            }\n+            if (!pinningChanges.isEmpty()) {\n+                LOGGER.debug(\"Pinning changes must be executed for the successful invocations: {}\", pinningChanges.size());\n+                pinningChanges.add(0, scoreDirector -> context.setCurrentChangeSetId(context.nextChangeSetId()));\n+                applyingPlanningExecutionResult.set(true);\n+                solverExecutor.addProblemFactChanges(pinningChanges);\n+            } else if (!hasQueuedEvents()) {\n+                List<PlanningItem> failingItems = result.getItems().stream()\n+                        .filter(PlanningExecutionResultItem::hasError)\n+                        .map(PlanningExecutionResultItem::getItem)\n+                        .collect(Collectors.toList());\n+                LOGGER.debug(\"No new events to process, but some items failed: {}, we must retry\", failingItems.size());\n+                planningExecutor.start(failingItems, this::onPlanningExecuted);\n+            } else {\n+                LOGGER.debug(\"Some items failed but there are events to process, try to adjust the solution accordingly.\");\n+                resumeEvents();\n+            }\n+        } finally {\n+            lock.unlock();\n         }\n+    }\n \n+    // use the observer instead of the @PreDestroy alternative.\n+    // https://github.com/quarkusio/quarkus/issues/15026\n+    void onShutDownEvent(@Observes ShutdownEvent ev) {\n+        destroy();\n+    }\n+\n+    /**\n+     * Handles the TaskAssigningService finalization prodecure.\n+     */\n+    void destroy() {\n+        try {\n+            LOGGER.info(\"Service is going down and will be destroyed.\");\n+            solverExecutor.destroy();\n+            solutionDataLoader.destroy();\n+            planningExecutor.destroy();\n+            LOGGER.info(\"Service destroy sequence was executed successfully.\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"An error was produced during service destroy, but it'll go down anyway.\", e);\n+        }\n     }\n \n     private void startUpValidation() {\n@@ -145,4 +411,36 @@ private void validateConfig() {\n     private void validateSolver() {\n         solverFactory.buildSolver();\n     }\n+\n+    private void pauseEvents() {\n+        userTaskEventConsumer.pause();\n+    }\n+\n+    private void resumeEvents() {\n+        userTaskEventConsumer.resume();\n+    }\n+\n+    private List<UserTaskEvent> pollEvents() {\n+        return userTaskEventConsumer.pollEvents();\n+    }\n+\n+    private boolean hasQueuedEvents() {\n+        return userTaskEventConsumer.queuedEvents() > 0;\n+    }\n+\n+    TaskAssigningServiceContext createContext() {\n+        return new TaskAssigningServiceContext();\n+    }\n+\n+    SolverExecutor createSolverExecutor(SolverFactory<TaskAssigningSolution> solverFactory, SolverEventListener<TaskAssigningSolution> eventListener) {\n+        return new SolverExecutor(solverFactory, eventListener);\n+    }\n+\n+    PlanningExecutor createPlanningExecutor(ClientServices clientServices, TaskAssigningConfig config) {\n+        return new PlanningExecutor(clientServices, config);\n+    }\n+\n+    SolutionDataLoader createSolutionDataLoader(TaskServiceConnector taskServiceConnector, UserServiceConnector userServiceConnector) {\n+        return new SolutionDataLoader(taskServiceConnector, userServiceConnector);\n+    }\n }"
  },
  {
    "sha": "ff32a00ac4ca64c8be70fbdf1864ac7c3606f9cc",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskAssigningServiceContext.java",
    "status": "added",
    "additions": 100,
    "deletions": 0,
    "changes": 100,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskAssigningServiceContext.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskAssigningServiceContext.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskAssigningServiceContext.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.taskassigning.service;\n+\n+import java.time.ZonedDateTime;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class TaskAssigningServiceContext {\n+\n+    private static class TaskContext {\n+        private boolean published;\n+        private ZonedDateTime lastEventTime;\n+\n+        public synchronized void setPublished(boolean published) {\n+            this.published = published;\n+        }\n+\n+        public synchronized boolean isPublished() {\n+            return published;\n+        }\n+\n+        public synchronized ZonedDateTime getLastEventTime() {\n+            return lastEventTime;\n+        }\n+\n+        public synchronized void setLastEventTime(ZonedDateTime lastEventTime) {\n+            this.lastEventTime = lastEventTime;\n+        }\n+    }\n+\n+    private AtomicLong changeSetIds = new AtomicLong();\n+    private AtomicLong currentChangeSetId = new AtomicLong();\n+    private AtomicLong lastProcessedChangeSetId = new AtomicLong(-1);\n+    private Map<String, TaskContext> taskContextMap = new ConcurrentHashMap<>();\n+\n+    public long getCurrentChangeSetId() {\n+        return currentChangeSetId.get();\n+    }\n+\n+    public void setCurrentChangeSetId(long currentChangeSetId) {\n+        this.currentChangeSetId.set(currentChangeSetId);\n+    }\n+\n+    public long nextChangeSetId() {\n+        return changeSetIds.incrementAndGet();\n+    }\n+\n+    public boolean isProcessedChangeSet(long changeSetId) {\n+        return changeSetId <= lastProcessedChangeSetId.get();\n+    }\n+\n+    public boolean isCurrentChangeSetProcessed() {\n+        return isProcessedChangeSet(currentChangeSetId.get());\n+    }\n+\n+    public void setProcessedChangeSet(long changeSetId) {\n+        lastProcessedChangeSetId.set(changeSetId);\n+    }\n+\n+    public void setTaskPublished(String taskId, boolean published) {\n+        TaskContext taskContext = taskContextMap.computeIfAbsent(taskId, id -> new TaskContext());\n+        taskContext.setPublished(published);\n+    }\n+\n+    public boolean isTaskPublished(String taskId) {\n+        TaskContext taskContext = taskContextMap.get(taskId);\n+        return taskContext != null && taskContext.isPublished();\n+    }\n+\n+    public void setTaskLastEventTime(String taskId, ZonedDateTime lastEventTime) {\n+        TaskContext taskContext = taskContextMap.computeIfAbsent(taskId, id -> new TaskContext());\n+        taskContext.setLastEventTime(lastEventTime);\n+    }\n+\n+    public ZonedDateTime getTaskLastEventTime(String taskId) {\n+        TaskContext taskContext = taskContextMap.get(taskId);\n+        return taskContext != null ? taskContext.getLastEventTime() : null;\n+    }\n+\n+    public boolean isNewTaskEventTime(String taskId, ZonedDateTime taskEventTime) {\n+        ZonedDateTime lastTaskEventTime = getTaskLastEventTime(taskId);\n+        return lastTaskEventTime == null || taskEventTime.isAfter(lastTaskEventTime);\n+    }\n+}"
  },
  {
    "sha": "9fce9d622079ce250af408554b7203fa77e5c8c9",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskData.java",
    "status": "added",
    "additions": 66,
    "deletions": 0,
    "changes": 66,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskData.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskData.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskData.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.taskassigning.service;\n+\n+import java.time.ZonedDateTime;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+\n+public interface TaskData {\n+    String getId();\n+\n+    String getName();\n+\n+    String getState();\n+\n+    String getDescription();\n+\n+    String getReferenceName();\n+\n+    String getPriority();\n+\n+    String getProcessInstanceId();\n+\n+    String getProcessId();\n+\n+    String getRootProcessInstanceId();\n+\n+    String getRootProcessId();\n+\n+    String getActualOwner();\n+\n+    Set<String> getPotentialUsers();\n+\n+    Set<String> getPotentialGroups();\n+\n+    Set<String> getAdminUsers();\n+\n+    Set<String> getAdminGroups();\n+\n+    Set<String> getExcludedUsers();\n+\n+    ZonedDateTime getStarted();\n+\n+    ZonedDateTime getCompleted();\n+\n+    ZonedDateTime getLastUpdate();\n+\n+    JsonNode getInputs();\n+\n+    String getEndpoint();\n+}"
  },
  {
    "sha": "2cf49b5420e5b6e4caf23d0a1a8d76790d35321a",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskState.java",
    "status": "renamed",
    "additions": 11,
    "deletions": 3,
    "changes": 14,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskState.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskState.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskState.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -16,13 +16,16 @@\n \n package org.kie.kogito.taskassigning.service;\n \n-public enum TaskStatus {\n+public enum TaskState {\n     READY(\"Ready\"),\n-    RESERVED(\"Reserved\");\n+    RESERVED(\"Reserved\"),\n+    ABORTED(\"Aborted\"),\n+    SKIPPED(\"Skipped\"),\n+    COMPLETED(\"Completed\");\n \n     private String value;\n \n-    TaskStatus(String value) {\n+    TaskState(String value) {\n         this.value = value;\n     }\n \n@@ -34,4 +37,9 @@ public String value() {\n     public String toString() {\n         return value();\n     }\n+\n+    public static boolean isTerminal(String status) {\n+        return ABORTED.value().equals(status) || SKIPPED.value().equals(status) || COMPLETED.value().equals(status);\n+    }\n+\n }",
    "previous_filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/TaskStatus.java"
  },
  {
    "sha": "9caea22dd8d2c3ee9eb4a2dbba500a5c908a84da",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/config/TaskAssigningConfig.java",
    "status": "modified",
    "additions": 41,
    "deletions": 0,
    "changes": 41,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/config/TaskAssigningConfig.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/config/TaskAssigningConfig.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/config/TaskAssigningConfig.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -18,6 +18,7 @@\n \n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.time.Duration;\n import java.util.Optional;\n \n import javax.enterprise.context.ApplicationScoped;\n@@ -28,6 +29,10 @@\n import static org.kie.kogito.taskassigning.service.config.TaskAssigningConfigProperties.CLIENT_AUTH_PASSWORD;\n import static org.kie.kogito.taskassigning.service.config.TaskAssigningConfigProperties.CLIENT_AUTH_USER;\n import static org.kie.kogito.taskassigning.service.config.TaskAssigningConfigProperties.DATA_INDEX_SERVER_URL;\n+import static org.kie.kogito.taskassigning.service.config.TaskAssigningConfigProperties.DATA_LOADER_PAGE_SIZE;\n+import static org.kie.kogito.taskassigning.service.config.TaskAssigningConfigProperties.DATA_LOADER_RETRIES;\n+import static org.kie.kogito.taskassigning.service.config.TaskAssigningConfigProperties.DATA_LOADER_RETRY_INTERVAL_DURATION;\n+import static org.kie.kogito.taskassigning.service.config.TaskAssigningConfigProperties.PUBLISH_WINDOW_SIZE;\n import static org.kie.kogito.taskassigning.service.config.TaskAssigningConfigProperties.QUARKUS_OIDC_AUTH_SERVER_URL;\n import static org.kie.kogito.taskassigning.service.config.TaskAssigningConfigProperties.QUARKUS_OIDC_CLIENT_ID;\n import static org.kie.kogito.taskassigning.service.config.TaskAssigningConfigProperties.QUARKUS_OIDC_CREDENTIALS_SECRET;\n@@ -70,6 +75,22 @@\n     @ConfigProperty(name = DATA_INDEX_SERVER_URL)\n     URL dataIndexServerUrl;\n \n+    @Inject\n+    @ConfigProperty(name = DATA_LOADER_RETRY_INTERVAL_DURATION, defaultValue = \"PT1S\")\n+    Duration dataLoaderRetryInterval;\n+\n+    @Inject\n+    @ConfigProperty(name = DATA_LOADER_RETRIES, defaultValue = \"5\")\n+    int dataLoaderRetries;\n+\n+    @Inject\n+    @ConfigProperty(name = DATA_LOADER_PAGE_SIZE, defaultValue = \"3000\")\n+    int dataLoaderPageSize;\n+\n+    @Inject\n+    @ConfigProperty(name = PUBLISH_WINDOW_SIZE, defaultValue = \"2\")\n+    int publishWindowSize;\n+\n     public boolean isOidcTenantEnabled() {\n         return oidcTenantEnabled;\n     }\n@@ -136,6 +157,22 @@ public boolean isBasicAuthSet() {\n         return !isKeycloakSet() && clientAuthUser.isPresent();\n     }\n \n+    public Duration getDataLoaderRetryInterval() {\n+        return dataLoaderRetryInterval;\n+    }\n+\n+    public int getDataLoaderRetries() {\n+        return dataLoaderRetries;\n+    }\n+\n+    public int getDataLoaderPageSize() {\n+        return dataLoaderPageSize;\n+    }\n+\n+    public int getPublishWindowSize() {\n+        return publishWindowSize;\n+    }\n+\n     @Override\n     public String toString() {\n         return \"TaskAssigningConfig{\" +\n@@ -146,6 +183,10 @@ public String toString() {\n                 \", clientAuthUser=\" + clientAuthUser +\n                 \", clientAuthPassword=\" + (clientAuthPassword.isEmpty() ? null : \"*****\") +\n                 \", dataIndexServerUrl=\" + dataIndexServerUrl +\n+                \", dataLoaderRetryInterval=\" + dataLoaderRetryInterval +\n+                \", dataLoaderRetries=\" + dataLoaderRetries +\n+                \", dataLoaderPageSize=\" + dataLoaderPageSize +\n+                \", publishWindowSize=\" + publishWindowSize +\n                 '}';\n     }\n }"
  },
  {
    "sha": "42f65caf2ef568ee6f980c796eb78c8d35d79df1",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/config/TaskAssigningConfigProperties.java",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/config/TaskAssigningConfigProperties.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/config/TaskAssigningConfigProperties.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/config/TaskAssigningConfigProperties.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -36,4 +36,12 @@ private TaskAssigningConfigProperties() {\n     public static final String CLIENT_AUTH_PASSWORD = TASK_ASSIGNING_PROPERTY_PREFIX + \".password\";\n \n     public static final String DATA_INDEX_SERVER_URL = TASK_ASSIGNING_PROPERTY_PREFIX + \".data-index.server-url\";\n+\n+    public static final String DATA_LOADER_RETRY_INTERVAL_DURATION = TASK_ASSIGNING_PROPERTY_PREFIX + \".data-loader.retry-interval-duration\";\n+\n+    public static final String DATA_LOADER_RETRIES = TASK_ASSIGNING_PROPERTY_PREFIX + \".data-loader.retries\";\n+\n+    public static final String DATA_LOADER_PAGE_SIZE = TASK_ASSIGNING_PROPERTY_PREFIX + \".data-loader.page-size\";\n+\n+    public static final String PUBLISH_WINDOW_SIZE = TASK_ASSIGNING_PROPERTY_PREFIX + \".publish-window-size\";\n }"
  },
  {
    "sha": "8b1cc88a94958ff4448e978fdd3e8dc92e63c770",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/config/TaskAssigningConfigUtil.java",
    "status": "modified",
    "additions": 18,
    "deletions": 1,
    "changes": 19,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/config/TaskAssigningConfigUtil.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/config/TaskAssigningConfigUtil.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/config/TaskAssigningConfigUtil.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -16,13 +16,17 @@\n \n package org.kie.kogito.taskassigning.service.config;\n \n+import java.net.URL;\n+\n import org.kie.kogito.taskassigning.ClientServices;\n import org.kie.kogito.taskassigning.auth.AuthenticationCredentials;\n import org.kie.kogito.taskassigning.auth.BasicAuthenticationCredentials;\n import org.kie.kogito.taskassigning.auth.KeycloakAuthenticationCredentials;\n import org.kie.kogito.taskassigning.auth.NoAuthenticationCredentials;\n import org.kie.kogito.taskassigning.index.service.client.DataIndexServiceClient;\n import org.kie.kogito.taskassigning.index.service.client.DataIndexServiceClientConfig;\n+import org.kie.kogito.taskassigning.process.service.client.ProcessServiceClient;\n+import org.kie.kogito.taskassigning.process.service.client.ProcessServiceClientConfig;\n \n public class TaskAssigningConfigUtil {\n \n@@ -34,7 +38,20 @@ public static DataIndexServiceClient createDataIndexServiceClient(ClientServices\n         DataIndexServiceClientConfig clientServiceConfig = DataIndexServiceClientConfig.newBuilder()\n                 .serviceUrl(config.getDataIndexServerUrl().toString())\n                 .build();\n+        AuthenticationCredentials credentials = buildAuthenticationCredentials(config);\n+        return clientServices.dataIndexClientFactory().newClient(clientServiceConfig, credentials);\n+    }\n+\n+    public static ProcessServiceClient createProcessServiceClient(ClientServices clientServices, TaskAssigningConfig config, URL serviceUrl) {\n+        TaskAssigningConfigValidator.of(config).validate();\n+        ProcessServiceClientConfig clientServiceConfig = ProcessServiceClientConfig.newBuilder()\n+                .serviceUrl(serviceUrl.toString())\n+                .build();\n+        AuthenticationCredentials credentials = buildAuthenticationCredentials(config);\n+        return clientServices.processServiceClientFactory().newClient(clientServiceConfig, credentials);\n+    }\n \n+    private static AuthenticationCredentials buildAuthenticationCredentials(TaskAssigningConfig config) {\n         AuthenticationCredentials credentials;\n         if (config.isKeycloakSet()) {\n             KeycloakAuthenticationCredentials.Builder builder = KeycloakAuthenticationCredentials.newBuilder()\n@@ -53,6 +70,6 @@ public static DataIndexServiceClient createDataIndexServiceClient(ClientServices\n         } else {\n             credentials = NoAuthenticationCredentials.INSTANCE;\n         }\n-        return clientServices.dataIndexClientFactory().newClient(clientServiceConfig, credentials);\n+        return credentials;\n     }\n }"
  },
  {
    "sha": "d341e75f19b95f82f5fd89c872759bad75418684",
    "filename": "task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/messaging/BufferedUserTaskEventConsumer.java",
    "status": "added",
    "additions": 115,
    "deletions": 0,
    "changes": 115,
    "blob_url": "https://github.com/kiegroup/kogito-apps/blob/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/messaging/BufferedUserTaskEventConsumer.java",
    "raw_url": "https://github.com/kiegroup/kogito-apps/raw/f27c2fb5392c815e4a0648c66f59253b0dfdd612/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/messaging/BufferedUserTaskEventConsumer.java",
    "contents_url": "https://api.github.com/repos/kiegroup/kogito-apps/contents/task-assigning/task-assigning-service/src/main/java/org/kie/kogito/taskassigning/service/messaging/BufferedUserTaskEventConsumer.java?ref=f27c2fb5392c815e4a0648c66f59253b0dfdd612",
    "patch": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.taskassigning.service.messaging;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Consumer;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@ApplicationScoped\n+public class BufferedUserTaskEventConsumer implements UserTaskEventConsumer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(BufferedUserTaskEventConsumer.class);\n+\n+    private List<UserTaskEvent> buffer = new ArrayList<>();\n+\n+    private AtomicBoolean paused = new AtomicBoolean(true);\n+\n+    private ReentrantLock lock = new ReentrantLock();\n+\n+    private Consumer<List<UserTaskEvent>> consumer;\n+\n+    public void setConsumer(Consumer<List<UserTaskEvent>> consumer) {\n+        this.consumer = consumer;\n+    }\n+\n+    @Override\n+    public void pause() {\n+        lock.lock();\n+        LOGGER.debug(\"pause was invoked with current buffer.size: {}\", buffer.size());\n+        try {\n+            paused.set(true);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void resume() {\n+        lock.lock();\n+        LOGGER.debug(\"resume was invoked with current buffer.size: {}\", buffer.size());\n+        try {\n+            paused.set(false);\n+            if (!buffer.isEmpty()) {\n+                deliverToConsumer();\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public List<UserTaskEvent> pollEvents() {\n+        lock.lock();\n+        try {\n+            LOGGER.debug(\"pollEvents was invoked with current buffer.size: {}\", buffer.size());\n+            List<UserTaskEvent> result = new ArrayList<>(buffer);\n+            buffer.clear();\n+            return result;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public int queuedEvents() {\n+        lock.lock();\n+        try {\n+            return buffer.size();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void accept(UserTaskEvent userTaskEvent) {\n+        lock.lock();\n+        try {\n+            LOGGER.debug(\"Event being accepted, current buffer.size: {},  paused: {}\", buffer.size(), paused.get());\n+            buffer.add(userTaskEvent);\n+            if (!paused.get()) {\n+                LOGGER.debug(\"Delivering to consumer, current buffer.size: {}, paused: {}\", buffer.size(), paused.get());\n+                deliverToConsumer();\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private void deliverToConsumer() {\n+        List<UserTaskEvent> result = new ArrayList<>(buffer);\n+        buffer.clear();\n+        consumer.accept(result);\n+    }\n+}\n\\ No newline at end of file"
  }
]
