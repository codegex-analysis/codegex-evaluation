[
  {
    "sha": "ca349f165dd17d52b18cfea19cb2696b126c86f3",
    "filename": "crowdnotifier-sdk/src/androidTest/java/org/crowdnotifier/android/sdk/MatchingTest.java",
    "status": "modified",
    "additions": 87,
    "deletions": 1,
    "changes": 88,
    "blob_url": "https://github.com/CrowdNotifier/crowdnotifier-sdk-android/blob/f2a90ab340eb21207996e2c9cf36f804295a8021/crowdnotifier-sdk/src/androidTest/java/org/crowdnotifier/android/sdk/MatchingTest.java",
    "raw_url": "https://github.com/CrowdNotifier/crowdnotifier-sdk-android/raw/f2a90ab340eb21207996e2c9cf36f804295a8021/crowdnotifier-sdk/src/androidTest/java/org/crowdnotifier/android/sdk/MatchingTest.java",
    "contents_url": "https://api.github.com/repos/CrowdNotifier/crowdnotifier-sdk-android/contents/crowdnotifier-sdk/src/androidTest/java/org/crowdnotifier/android/sdk/MatchingTest.java?ref=f2a90ab340eb21207996e2c9cf36f804295a8021",
    "patch": "@@ -62,6 +62,84 @@ public void init() {\n \t\thaKeyPair = createHAKeyPair();\n \t}\n \n+\t/**\n+\t * This test runs a benchmark with 1000 Encryptions, 1000 successful Decryptions and 1000 unsuccessful Decryptions and prints\n+\t * the results to the console.\n+\t */\n+\t@Test\n+\tpublic void benchmark() throws QrUtils.QRException, InvalidProtocolBufferException {\n+\t\tlong currentTime = System.currentTimeMillis();\n+\t\tlong arrivalTime = 20;\n+\t\tlong departureTime = 30;\n+\t\tlong exposureStart = 25;\n+\t\tlong exposureEnd = 45;\n+\n+\t\t//Setup Location Owner 1 and 2\n+\t\tbyte[] notificationKey = new byte[Box.SECRETKEYBYTES];\n+\t\tsodium.crypto_secretbox_keygen(notificationKey);\n+\n+\t\tbyte[] notificationKey2 = new byte[Box.SECRETKEYBYTES];\n+\t\tsodium.crypto_secretbox_keygen(notificationKey2);\n+\n+\t\tlong qrCodeValidFrom = currentTime - ONE_DAY_IN_MILLIS;\n+\t\tlong qrCodeValidTo = currentTime + ONE_DAY_IN_MILLIS;\n+\t\tLocation location1 = new Location(haKeyPair.publicKey, Qr.QRCodeContent.VenueType.OTHER, \"Name\", \"Location\",\n+\t\t\t\t\"Room\", notificationKey, qrCodeValidFrom, qrCodeValidTo);\n+\t\tLocation location2 = new Location(haKeyPair.publicKey, Qr.QRCodeContent.VenueType.OTHER, \"Name2\", \"Location2\",\n+\t\t\t\t\"Room2\", notificationKey2, qrCodeValidFrom, qrCodeValidTo);\n+\n+\t\tBackend.QRCodeTrace qrTrace1 = location1.getQrCodeTrace();\n+\t\tBackend.QRCodeTrace qrTrace2 = location2.getQrCodeTrace();\n+\n+\t\t//Venue Owners Create PreTraces\n+\t\tBackend.PreTraceWithProof preTraceWithProof1 =\n+\t\t\t\tcreatePreTrace(qrTrace1, exposureStart, exposureEnd, notificationKey, \"message\").get(0);\n+\n+\t\tBackend.PreTraceWithProof preTraceWithProof2 =\n+\t\t\t\tcreatePreTrace(qrTrace2, exposureStart, exposureEnd, notificationKey, \"message\").get(0);\n+\n+\t\t//Health Authority generates Traces\n+\t\tBackend.Trace trace1 = createTrace(preTraceWithProof1, haKeyPair);\n+\n+\t\tBackend.Trace trace2 = createTrace(preTraceWithProof2, haKeyPair);\n+\n+\t\t// Create ciphertext for Venue 1\n+\t\tint NONCE_LENGTH = 32;\n+\t\tbyte[] msg_orig = getRandomValue(NONCE_LENGTH);\n+\t\tG2 masterPublicKey = new G2();\n+\t\tmasterPublicKey.deserialize(preTraceWithProof1.getProof().getMasterPublicKey().toByteArray());\n+\t\tIBECiphertext ibeCiphertext = cryptoUtils\n+\t\t\t\t.encryptInternal(masterPublicKey, preTraceWithProof1.getPreTrace().getIdentity().toByteArray(), msg_orig);\n+\n+\t\t// Benchmark Encryption\n+\t\tArrayList<Long> timestamps = new ArrayList(1001);\n+\t\tfor (int i = 0; i < 1001; i++) {\n+\t\t\ttimestamps.add(System.currentTimeMillis());\n+\t\t\tcryptoUtils.encryptInternal(masterPublicKey, preTraceWithProof1.getPreTrace().getIdentity().toByteArray(), msg_orig);\n+\t\t}\n+\t\tprintValuesAsCSV(timestamps, \"ENCRYPTION (in ms)\");\n+\n+\t\t// Benchmark Successful Decryption with Trace1\n+\t\tG1 secretKeyForIdentity = new G1();\n+\t\tsecretKeyForIdentity.deserialize(trace1.getSecretKeyForIdentity().toByteArray());\n+\t\ttimestamps = new ArrayList(1001);\n+\t\tfor (int i = 0; i < 1001; i++) {\n+\t\t\ttimestamps.add(System.currentTimeMillis());\n+\t\t\tbyte[] msg_dec = cryptoUtils.decryptInternal(ibeCiphertext, secretKeyForIdentity, trace1.getIdentity().toByteArray());\n+\t\t\tassert (msg_dec != null);\n+\t\t}\n+\t\tprintValuesAsCSV(timestamps, \"SUCCESSFUL DECRYPTION (in ms)\");\n+\n+\t\t// Benchmark Unsuccessful Decryption with Trace2\n+\t\tsecretKeyForIdentity.deserialize(trace2.getSecretKeyForIdentity().toByteArray());\n+\t\ttimestamps = new ArrayList(1001);\n+\t\tfor (int i = 0; i < 1001; i++) {\n+\t\t\ttimestamps.add(System.currentTimeMillis());\n+\t\t\tbyte[] msg_dec = cryptoUtils.decryptInternal(ibeCiphertext, secretKeyForIdentity, trace2.getIdentity().toByteArray());\n+\t\t\tassert (msg_dec == null);\n+\t\t}\n+\t\tprintValuesAsCSV(timestamps, \"UNSUCCESSFUL DECRYPTION (in ms)\");\n+\t}\n \n \t@Test\n \tpublic void testMatching() throws QrUtils.QRException, InvalidProtocolBufferException {\n@@ -108,6 +186,15 @@ public void testNoMatching() throws QrUtils.QRException, InvalidProtocolBufferEx\n \t\tassertEquals(0, exposureEvents.size());\n \t}\n \n+\tprivate void printValuesAsCSV(ArrayList<Long> timestamps, String rowTitle) {\n+\t\tStringBuilder csvString = new StringBuilder();\n+\t\tfor (int i = 0; i < timestamps.size() - 1; i++) {\n+\t\t\tcsvString.append(timestamps.get(i + 1) - timestamps.get(i));\n+\t\t\tcsvString.append(\",\");\n+\t\t}\n+\t\tSystem.out.println(rowTitle + \", \" + csvString);\n+\t}\n+\n \n \tprivate List<ProblematicEventInfo> generateVisitAndExposure(long arrivalTime, long departureTime, long exposureStart,\n \t\t\tlong exposureEnd, String message) throws QrUtils.QRException, InvalidProtocolBufferException {\n@@ -371,7 +458,6 @@ public Location(byte[] healthAuthorityPublicKey, Qr.QRCodeContent.VenueType venu\n \t\t\t\t\t.build();\n \t\t}\n \n-\n \t\tpublic Backend.QRCodeTrace getQrCodeTrace() {\n \n \t\t\treturn Backend.QRCodeTrace.newBuilder()"
  }
]
