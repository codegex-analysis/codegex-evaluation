[
  {
    "sha": "96cc36aa308f1e166490b1f6fec4864caa2c92c5",
    "filename": "backend/src/main/java/com/bakdata/conquery/models/dictionary/DictionaryMapping.java",
    "status": "modified",
    "additions": 12,
    "deletions": 5,
    "changes": 17,
    "blob_url": "https://github.com/bakdata/conquery/blob/d71b9d7cfc9bcb286049d12fb9d6c9791f01659d/backend/src/main/java/com/bakdata/conquery/models/dictionary/DictionaryMapping.java",
    "raw_url": "https://github.com/bakdata/conquery/raw/d71b9d7cfc9bcb286049d12fb9d6c9791f01659d/backend/src/main/java/com/bakdata/conquery/models/dictionary/DictionaryMapping.java",
    "contents_url": "https://api.github.com/repos/bakdata/conquery/contents/backend/src/main/java/com/bakdata/conquery/models/dictionary/DictionaryMapping.java?ref=d71b9d7cfc9bcb286049d12fb9d6c9791f01659d",
    "patch": "@@ -60,14 +60,21 @@ public int source2Target(int sourceId) {\n \t/**\n \t * Mutably applies mapping to store.\n \t */\n-\tpublic void applyToStore(StringStore from, IntegerStore to, long rows) {\n-\t\tfor (int row = 0; row < rows; row++) {\n-\t\t\tif (!from.has(row)) {\n-\t\t\t\tto.setNull(row);\n+\tpublic void applyToStore(StringStore from, IntegerStore to) {\n+\t\tfor (int event = 0; event < from.getLines(); event++) {\n+\t\t\tif (!from.has(event)) {\n+\t\t\t\tto.setNull(event);\n \t\t\t\tcontinue;\n \t\t\t}\n \n-\t\t\tto.setInteger(row, source2Target(from.getString(row)));\n+\t\t\tfinal int string = from.getString(event);\n+\n+\t\t\tif (string >= source2TargetMap.length) {\n+\t\t\t\tlog.error(\"Event[{}]=`{}` is not in source.\", event, string);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tto.setInteger(event, source2Target(string));\n+\t\t\t}\n \t\t}\n \t}\n "
  },
  {
    "sha": "c74dd35204d2bb7ec440194eddc14044fb506789",
    "filename": "backend/src/main/java/com/bakdata/conquery/models/jobs/ImportJob.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/bakdata/conquery/blob/d71b9d7cfc9bcb286049d12fb9d6c9791f01659d/backend/src/main/java/com/bakdata/conquery/models/jobs/ImportJob.java",
    "raw_url": "https://github.com/bakdata/conquery/raw/d71b9d7cfc9bcb286049d12fb9d6c9791f01659d/backend/src/main/java/com/bakdata/conquery/models/jobs/ImportJob.java",
    "contents_url": "https://api.github.com/repos/bakdata/conquery/contents/backend/src/main/java/com/bakdata/conquery/models/jobs/ImportJob.java?ref=d71b9d7cfc9bcb286049d12fb9d6c9791f01659d",
    "patch": "@@ -429,7 +429,7 @@ public void applyDictionaryMappings(Map<String, DictionaryMapping> mappings, Map\n \n \t\t\t\tlog.debug(\"Decided for {}\", newType);\n \n-\t\t\t\tmapping.applyToStore(stringStore, newType, stringStore.getLines());\n+\t\t\t\tmapping.applyToStore(stringStore, newType);\n \n \t\t\t\tstringStore.setIndexStore(newType);\n \t\t\t}finally {"
  },
  {
    "sha": "e94bdcdc35c43dda4b11710cf41f3109866ecb86",
    "filename": "backend/src/main/java/com/bakdata/conquery/models/preproc/Preprocessed.java",
    "status": "modified",
    "additions": 24,
    "deletions": 56,
    "changes": 80,
    "blob_url": "https://github.com/bakdata/conquery/blob/d71b9d7cfc9bcb286049d12fb9d6c9791f01659d/backend/src/main/java/com/bakdata/conquery/models/preproc/Preprocessed.java",
    "raw_url": "https://github.com/bakdata/conquery/raw/d71b9d7cfc9bcb286049d12fb9d6c9791f01659d/backend/src/main/java/com/bakdata/conquery/models/preproc/Preprocessed.java",
    "contents_url": "https://api.github.com/repos/bakdata/conquery/contents/backend/src/main/java/com/bakdata/conquery/models/preproc/Preprocessed.java?ref=d71b9d7cfc9bcb286049d12fb9d6c9791f01659d",
    "patch": "@@ -30,14 +30,9 @@\n import it.unimi.dsi.fastutil.ints.Int2ObjectMap;\n import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;\n import it.unimi.dsi.fastutil.ints.IntArrayList;\n-import it.unimi.dsi.fastutil.ints.IntIterable;\n-import it.unimi.dsi.fastutil.ints.IntIterator;\n import it.unimi.dsi.fastutil.ints.IntList;\n import it.unimi.dsi.fastutil.ints.IntLists;\n-import it.unimi.dsi.fastutil.ints.IntOpenHashSet;\n-import it.unimi.dsi.fastutil.ints.IntSet;\n import lombok.Data;\n-import lombok.RequiredArgsConstructor;\n import lombok.extern.slf4j.Slf4j;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n \n@@ -64,10 +59,6 @@\n \t */\n \tprivate final IntList rowEntities = new IntArrayList();\n \n-\t/**\n-\t * Global Set of all processed entities (not necessarily all output entities, as they may have null values)\n-\t */\n-\tprivate final IntSet entities = new IntOpenHashSet();\n \n \tprivate long rows = 0;\n \n@@ -133,6 +124,7 @@ public void write(HCFile outFile) throws IOException {\n \t * Calculate beginning and length of entities in output data.\n \t */\n \tprivate void calculateEntitySpans(Int2IntMap entityStart, Int2IntMap entityLength) {\n+\n \t\t// Count the number of events for the entity\n \t\tfor (int entity : rowEntities) {\n \t\t\tfinal int curr = entityLength.getOrDefault(entity, 0);\n@@ -142,10 +134,9 @@ private void calculateEntitySpans(Int2IntMap entityStart, Int2IntMap entityLengt\n \t\t// Lay out the entities in order, adding their length.\n \t\tint outIndex = 0;\n \n-\t\tfor (int entity : entities) {\n-\t\t\tentityStart.put(entity, outIndex);\n-\n-\t\t\toutIndex += entityLength.get(entity);\n+\t\tfor (Int2IntMap.Entry entry : entityLength.int2IntEntrySet()) {\n+\t\t\tentityStart.put(entry.getIntKey(), outIndex);\n+\t\t\toutIndex += entry.getIntValue();\n \t\t}\n \t}\n \n@@ -159,7 +150,7 @@ private void calculateEntitySpans(Int2IntMap entityStart, Int2IntMap entityLengt\n \t\t\t\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toMap(PPColumn::getName, PPColumn::findBestType));\n \n \t\t// This object can be huge!\n-\t\tInt2ObjectMap<IntList>  entityEvents = new Int2ObjectOpenHashMap<>(entities.size());\n+\t\tInt2ObjectMap<IntList> entityEvents = new Int2ObjectOpenHashMap<>(entityStart.size());\n \n \t\tfor (int pos = 0, size = rowEntities.size(); pos < size; pos++) {\n \t\t\tint entity = rowEntities.getInt(pos);\n@@ -173,23 +164,24 @@ private void calculateEntitySpans(Int2IntMap entityStart, Int2IntMap entityLengt\n \n \t\t\tfinal ColumnStore store = columnStores.get(ppColumn.getName());\n \n-\t\t\tentities.intStream()\n-\t\t\t\t\t.forEach((int entity) -> {\n-\t\t\t\t\t\tint outIndex = entityStart.get(entity);\n-\n-\t\t\t\t\t\tfinal IntList events = entityEvents.getOrDefault(entity, IntLists.emptyList());\n-\n-\t\t\t\t\t\tfor (int inIndex : events) {\n-\t\t\t\t\t\t\tif (columnValues.isNull(inIndex)) {\n-\t\t\t\t\t\t\t\tstore.setNull(outIndex);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\tfinal Object raw = columnValues.get(inIndex);\n-\t\t\t\t\t\t\t\tppColumn.getParser().setValue(store, outIndex, raw);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\toutIndex++;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t});\n+\t\t\tentityStart.int2IntEntrySet()\n+\t\t\t\t\t   .forEach(entry -> {\n+\t\t\t\t\t\t   final int entity = entry.getIntKey();\n+\t\t\t\t\t\t   int outIndex = entry.getIntValue();\n+\n+\t\t\t\t\t\t   final IntList events = entityEvents.getOrDefault(entity, IntLists.emptyList());\n+\n+\t\t\t\t\t\t   for (int inIndex : events) {\n+\t\t\t\t\t\t\t   if (columnValues.isNull(inIndex)) {\n+\t\t\t\t\t\t\t\t   store.setNull(outIndex);\n+\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   else {\n+\t\t\t\t\t\t\t\t   final Object raw = columnValues.get(inIndex);\n+\t\t\t\t\t\t\t\t   ppColumn.getParser().setValue(store, outIndex, raw);\n+\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   outIndex++;\n+\t\t\t\t\t\t   }\n+\t\t\t\t\t   });\n \t\t}\n \t\treturn columnStores;\n \t}\n@@ -255,7 +247,6 @@ public static void writeData(OutputStream out1, Int2IntMap entityStart, Int2IntM\n \n \tpublic synchronized int addPrimary(int primary) {\n \t\tprimaryColumn.addLine(primary);\n-\t\tentities.add(primary);\n \t\treturn primary;\n \t}\n \n@@ -266,7 +257,7 @@ public synchronized void addRow(int primaryId, PPColumn[] columns, Object[] outR\n \t\tfor (int col = 0; col < outRow.length; col++) {\n \t\t\tfinal int idx = values[col].add(outRow[col]);\n \n-\t\t\tif(event != idx){\n+\t\t\tif (event != idx) {\n \t\t\t\tthrow new IllegalStateException(\"Columns are not aligned\");\n \t\t\t}\n \n@@ -277,27 +268,4 @@ public synchronized void addRow(int primaryId, PPColumn[] columns, Object[] outR\n \t\t//update stats\n \t\trows++;\n \t}\n-\n-\t/**\n-\t * Offset encoded positions, in the assumption that entity values are stored close to each other.\n-\t */\n-\t@RequiredArgsConstructor\n-\tprivate static class EntityPositions implements IntIterable {\n-\t\tprivate final IntList offsets = new IntArrayList();\n-\n-\t\tpublic void add(int event) {\n-\t\t\toffsets.add(event);\n-\t\t}\n-\n-\t\tpublic int length() {\n-\t\t\treturn offsets.size();\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic IntIterator iterator() {\n-\t\t\treturn offsets.iterator();\n-\t\t}\n-\t}\n-\n-\n }"
  },
  {
    "sha": "adc5c87acbc3647040aa92df17eef7b8ae99b9c1",
    "filename": "backend/src/main/java/com/bakdata/conquery/models/preproc/parser/specific/StringParser.java",
    "status": "modified",
    "additions": 8,
    "deletions": 3,
    "changes": 11,
    "blob_url": "https://github.com/bakdata/conquery/blob/d71b9d7cfc9bcb286049d12fb9d6c9791f01659d/backend/src/main/java/com/bakdata/conquery/models/preproc/parser/specific/StringParser.java",
    "raw_url": "https://github.com/bakdata/conquery/raw/d71b9d7cfc9bcb286049d12fb9d6c9791f01659d/backend/src/main/java/com/bakdata/conquery/models/preproc/parser/specific/StringParser.java",
    "contents_url": "https://api.github.com/repos/bakdata/conquery/contents/backend/src/main/java/com/bakdata/conquery/models/preproc/parser/specific/StringParser.java?ref=d71b9d7cfc9bcb286049d12fb9d6c9791f01659d",
    "patch": "@@ -13,6 +13,7 @@\n import com.bakdata.conquery.models.events.stores.primitive.BitSetStore;\n import com.bakdata.conquery.models.events.stores.root.IntegerStore;\n import com.bakdata.conquery.models.events.stores.root.StringStore;\n+import com.bakdata.conquery.models.events.stores.specific.string.StringTypeEncoded;\n import com.bakdata.conquery.models.events.stores.specific.string.StringTypeEncoded.Encoding;\n import com.bakdata.conquery.models.events.stores.specific.string.StringTypePrefixSuffix;\n import com.bakdata.conquery.models.events.stores.specific.string.StringTypeSingleton;\n@@ -81,8 +82,6 @@ public int processSingleValue(String value) {\n \t@Override\n \tprotected StringStore decideType() {\n \n-\t\tstrings.values().removeIf(id -> !registered.contains(id));\n-\n \t\t//check if a singleton type is enough\n \t\tif (strings.isEmpty()) {\n \t\t\treturn EmptyStore.INSTANCE;\n@@ -132,12 +131,18 @@ protected StringStore decideType() {\n \t\t);\n \n \t\tStringStore result = guess.getType();\n+\n+\t\tif(result instanceof StringTypeEncoded){\n+\n+\t\t}\n+\n \t\t//wrap in prefix suffix\n \t\tif (!Strings.isNullOrEmpty(prefix) || !Strings.isNullOrEmpty(suffix)) {\n \t\t\tresult = new StringTypePrefixSuffix(result, prefix, suffix);\n-\n \t\t}\n \n+\n+\n \t\treturn result;\n \t}\n "
  }
]
