[
  {
    "sha": "40befe1fb7d3a6c5823ea83ec64bed8e94dfa4f3",
    "filename": "src/main/java/com/github/shyiko/mysql/binlog/BinaryLogClient.java",
    "status": "modified",
    "additions": 19,
    "deletions": 1243,
    "changes": 1262,
    "blob_url": "https://github.com/fivetran/mysql-binlog-connector-java/blob/341f8dac8630a52d8989bbeba9a93b370f322d60/src/main/java/com/github/shyiko/mysql/binlog/BinaryLogClient.java",
    "raw_url": "https://github.com/fivetran/mysql-binlog-connector-java/raw/341f8dac8630a52d8989bbeba9a93b370f322d60/src/main/java/com/github/shyiko/mysql/binlog/BinaryLogClient.java",
    "contents_url": "https://api.github.com/repos/fivetran/mysql-binlog-connector-java/contents/src/main/java/com/github/shyiko/mysql/binlog/BinaryLogClient.java?ref=341f8dac8630a52d8989bbeba9a93b370f322d60",
    "patch": "@@ -1,1249 +1,25 @@\n-/*\n- * Copyright 2013 Stanley Shyiko\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n package com.github.shyiko.mysql.binlog;\n \n-import com.github.shyiko.mysql.binlog.event.*;\n-import com.github.shyiko.mysql.binlog.event.deserialization.*;\n-import com.github.shyiko.mysql.binlog.event.deserialization.EventDeserializer.EventDataWrapper;\n-import com.github.shyiko.mysql.binlog.io.ByteArrayInputStream;\n+import com.github.shyiko.mysql.binlog.event.Event;\n+import com.github.shyiko.mysql.binlog.event.deserialization.EventDeserializer;\n import com.github.shyiko.mysql.binlog.jmx.BinaryLogClientMXBean;\n-import com.github.shyiko.mysql.binlog.network.*;\n-import com.github.shyiko.mysql.binlog.network.protocol.*;\n-import com.github.shyiko.mysql.binlog.network.protocol.command.*;\n+import com.github.shyiko.mysql.binlog.network.SSLMode;\n+import com.github.shyiko.mysql.binlog.network.SSLSocketFactory;\n \n-import javax.net.ssl.SSLContext;\n-import javax.net.ssl.TrustManager;\n-import javax.net.ssl.X509TrustManager;\n-import java.io.EOFException;\n import java.io.IOException;\n-import java.net.InetSocketAddress;\n-import java.net.Socket;\n-import java.net.SocketException;\n-import java.security.GeneralSecurityException;\n-import java.security.cert.X509Certificate;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.concurrent.*;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantLock;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n \n+abstract public class BinaryLogClient implements BinaryLogClientMXBean {\n+    abstract public void setServerId(long serverId);\n+    abstract public void connect() throws IOException;\n+    abstract public void setSSLMode(SSLMode sslMode);\n+    abstract public void abort() throws IOException;\n+    abstract public void registerEventListener(EventListener eventListener);\n+    abstract public void registerLifecycleListener(LifecycleListener lifecycleListener);\n+    abstract public void setEventDeserializer(EventDeserializer eventDeserializer);\n+    abstract public void setKeepAliveConnectTimeout(long connectTimeout);\n+    abstract public long getConnectionId();\n+    abstract public void setSslSocketFactory(SSLSocketFactory sslSocketFactory);\n \n-/**\n- * MySQL replication stream client.\n- *\n- * @author <a href=\"mailto:stanley.shyiko@gmail.com\">Stanley Shyiko</a>\n- */\n-public class BinaryLogClient implements BinaryLogClientMXBean {\n-\n-    private static final SSLSocketFactory DEFAULT_REQUIRED_SSL_MODE_SOCKET_FACTORY = new DefaultSSLSocketFactory() {\n-\n-        @Override\n-        protected void initSSLContext(SSLContext sc) throws GeneralSecurityException {\n-            sc.init(null, new TrustManager[]{\n-                new X509TrustManager() {\n-\n-                    @Override\n-                    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) { }\n-\n-                    @Override\n-                    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) { }\n-\n-                    @Override\n-                    public X509Certificate[] getAcceptedIssuers() {\n-                        return new X509Certificate[0];\n-                    }\n-                }\n-            }, null);\n-        }\n-    };\n-    private static final SSLSocketFactory DEFAULT_VERIFY_CA_SSL_MODE_SOCKET_FACTORY = new DefaultSSLSocketFactory();\n-\n-    // https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html\n-    private static final int MAX_PACKET_LENGTH = 16777215;\n-\n-    private final Logger logger = Logger.getLogger(\"donkey\");\n-\n-    private final String hostname;\n-    private final int port;\n-    private final String schema;\n-    private final String username;\n-    private final String password;\n-\n-    private boolean blocking = true;\n-    private long serverId = 65535;\n-    private volatile String binlogFilename;\n-    private volatile long binlogPosition = 4;\n-    private volatile long connectionId;\n-    private SSLMode sslMode = SSLMode.DISABLED;\n-\n-    private GtidSet gtidSet;\n-    private final Object gtidSetAccessLock = new Object();\n-    private boolean gtidSetFallbackToPurged;\n-    private boolean useBinlogFilenamePositionInGtidMode;\n-    private String gtid;\n-    private boolean tx;\n-\n-    private EventDeserializer eventDeserializer = new EventDeserializer();\n-\n-    private final List<EventListener> eventListeners = new CopyOnWriteArrayList<EventListener>();\n-    private final List<LifecycleListener> lifecycleListeners = new CopyOnWriteArrayList<LifecycleListener>();\n-    private boolean abortRequest = false;\n-\n-    private SocketFactory socketFactory;\n-    private SSLSocketFactory sslSocketFactory;\n-\n-    private volatile PacketChannel channel;\n-    private volatile boolean connected;\n-\n-    private ThreadFactory threadFactory;\n-\n-    private boolean keepAlive = true;\n-    private long keepAliveInterval = TimeUnit.MINUTES.toMillis(1);\n-\n-    private long heartbeatInterval;\n-    private volatile long eventLastSeen;\n-\n-    private long connectTimeout = TimeUnit.SECONDS.toMillis(3);\n-\n-    private volatile ExecutorService keepAliveThreadExecutor;\n-\n-    private final Lock connectLock = new ReentrantLock();\n-    private volatile CountDownLatch connectLatch;\n-\n-    /**\n-     * Alias for BinaryLogClient(\"localhost\", 3306, &lt;no schema&gt; = null, username, password).\n-     * @see BinaryLogClient#BinaryLogClient(String, int, String, String, String)\n-     */\n-    public BinaryLogClient(String username, String password) {\n-        this(\"localhost\", 3306, null, username, password);\n-    }\n-\n-    /**\n-     * Alias for BinaryLogClient(\"localhost\", 3306, schema, username, password).\n-     * @see BinaryLogClient#BinaryLogClient(String, int, String, String, String)\n-     */\n-    public BinaryLogClient(String schema, String username, String password) {\n-        this(\"localhost\", 3306, schema, username, password);\n-    }\n-\n-    /**\n-     * Alias for BinaryLogClient(hostname, port, &lt;no schema&gt; = null, username, password).\n-     * @see BinaryLogClient#BinaryLogClient(String, int, String, String, String)\n-     */\n-    public BinaryLogClient(String hostname, int port, String username, String password) {\n-        this(hostname, port, null, username, password);\n-    }\n-\n-    /**\n-     * @param hostname mysql server hostname\n-     * @param port mysql server port\n-     * @param schema database name, nullable. Note that this parameter has nothing to do with event filtering. It's\n-     * used only during the authentication.\n-     * @param username login name\n-     * @param password password\n-     */\n-    public BinaryLogClient(String hostname, int port, String schema, String username, String password) {\n-        this.hostname = hostname;\n-        this.port = port;\n-        this.schema = schema;\n-        this.username = username;\n-        this.password = password;\n-    }\n-\n-    public boolean isBlocking() {\n-        return blocking;\n-    }\n-\n-    /**\n-     * @param blocking blocking mode. If set to false - BinaryLogClient will disconnect after the last event.\n-     */\n-    public void setBlocking(boolean blocking) {\n-        this.blocking = blocking;\n-    }\n-\n-    public SSLMode getSSLMode() {\n-        return sslMode;\n-    }\n-\n-    public void setSSLMode(SSLMode sslMode) {\n-        if (sslMode == null) {\n-            throw new IllegalArgumentException(\"SSL mode cannot be NULL\");\n-        }\n-        this.sslMode = sslMode;\n-    }\n-\n-    /**\n-     * @return server id (65535 by default)\n-     * @see #setServerId(long)\n-     */\n-    public long getServerId() {\n-        return serverId;\n-    }\n-\n-    /**\n-     * @param serverId server id (in the range from 1 to 2^32 - 1). This value MUST be unique across whole replication\n-     * group (that is, different from any other server id being used by any master or slave). Keep in mind that each\n-     * binary log client (mysql-binlog-connector-java/BinaryLogClient, mysqlbinlog, etc) should be treated as a\n-     * simplified slave and thus MUST also use a different server id.\n-     * @see #getServerId()\n-     */\n-    public void setServerId(long serverId) {\n-        this.serverId = serverId;\n-    }\n-\n-    /**\n-     * @return binary log filename, nullable (and null be default). Note that this value is automatically tracked by\n-     * the client and thus is subject to change (in response to {@link EventType#ROTATE}, for example).\n-     * @see #setBinlogFilename(String)\n-     */\n-    public String getBinlogFilename() {\n-        return binlogFilename;\n-    }\n-\n-    /**\n-     * @param binlogFilename binary log filename.\n-     * Special values are:\n-     * <ul>\n-     *   <li>null, which turns on automatic resolution (resulting in the last known binlog and position). This is what\n-     * happens by default when you don't specify binary log filename explicitly.</li>\n-     *   <li>\"\" (empty string), which instructs server to stream events starting from the oldest known binlog.</li>\n-     * </ul>\n-     * @see #getBinlogFilename()\n-     */\n-    public void setBinlogFilename(String binlogFilename) {\n-        this.binlogFilename = binlogFilename;\n-    }\n-\n-    /**\n-     * @return binary log position of the next event, 4 by default (which is a position of first event). Note that this\n-     * value changes with each incoming event.\n-     * @see #setBinlogPosition(long)\n-     */\n-    public long getBinlogPosition() {\n-        return binlogPosition;\n-    }\n-\n-    /**\n-     * @param binlogPosition binary log position. Any value less than 4 gets automatically adjusted to 4 on connect.\n-     * @see #getBinlogPosition()\n-     */\n-    public void setBinlogPosition(long binlogPosition) {\n-        this.binlogPosition = binlogPosition;\n-    }\n-\n-    /**\n-     * @return thread id\n-     */\n-    public long getConnectionId() {\n-        return connectionId;\n-    }\n-\n-    /**\n-     * @return GTID set. Note that this value changes with each received GTID event (provided client is in GTID mode).\n-     * @see #setGtidSet(String)\n-     */\n-    public String getGtidSet() {\n-        synchronized (gtidSetAccessLock) {\n-            return gtidSet != null ? gtidSet.toString() : null;\n-        }\n-    }\n-\n-    /**\n-     * @param gtidSet GTID set (can be an empty string).\n-     * <p>NOTE #1: Any value but null will switch BinaryLogClient into a GTID mode (this will also set binlogFilename\n-     * to \"\" (provided it's null) forcing MySQL to send events starting from the oldest known binlog (keep in mind\n-     * that connection will fail if gtid_purged is anything but empty (unless\n-     * {@link #setGtidSetFallbackToPurged(boolean)} is set to true))).\n-     * <p>NOTE #2: GTID set is automatically updated with each incoming GTID event (provided GTID mode is on).\n-     * @see #getGtidSet()\n-     * @see #setGtidSetFallbackToPurged(boolean)\n-     */\n-    public void setGtidSet(String gtidSet) {\n-        if (gtidSet != null && this.binlogFilename == null) {\n-            this.binlogFilename = \"\";\n-        }\n-        synchronized (gtidSetAccessLock) {\n-            this.gtidSet = gtidSet != null ? new GtidSet(gtidSet) : null;\n-        }\n-    }\n-\n-    /**\n-     * @see #setGtidSetFallbackToPurged(boolean)\n-     */\n-    public boolean isGtidSetFallbackToPurged() {\n-        return gtidSetFallbackToPurged;\n-    }\n-\n-    /**\n-     * @param gtidSetFallbackToPurged true if gtid_purged should be used as a fallback when gtidSet is set to \"\" and\n-     * MySQL server has purged some of the binary logs, false otherwise (default).\n-     */\n-    public void setGtidSetFallbackToPurged(boolean gtidSetFallbackToPurged) {\n-        this.gtidSetFallbackToPurged = gtidSetFallbackToPurged;\n-    }\n-\n-    /**\n-     * @see #setUseBinlogFilenamePositionInGtidMode(boolean)\n-     */\n-    public boolean isUseBinlogFilenamePositionInGtidMode() {\n-        return useBinlogFilenamePositionInGtidMode;\n-    }\n-\n-    /**\n-     * @param useBinlogFilenamePositionInGtidMode true if MySQL server should start streaming events from a given\n-     * {@link #getBinlogFilename()} and {@link #getBinlogPosition()} instead of \"the oldest known binlog\" when\n-     * {@link #getGtidSet()} is set, false otherwise (default).\n-     */\n-    public void setUseBinlogFilenamePositionInGtidMode(boolean useBinlogFilenamePositionInGtidMode) {\n-        this.useBinlogFilenamePositionInGtidMode = useBinlogFilenamePositionInGtidMode;\n-    }\n-\n-    /**\n-     * @return true if \"keep alive\" thread should be automatically started (default), false otherwise.\n-     * @see #setKeepAlive(boolean)\n-     */\n-    public boolean isKeepAlive() {\n-        return keepAlive;\n-    }\n-\n-    /**\n-     * @param keepAlive true if \"keep alive\" thread should be automatically started (recommended and true by default),\n-     * false otherwise.\n-     * @see #isKeepAlive()\n-     * @see #setKeepAliveInterval(long)\n-     */\n-    public void setKeepAlive(boolean keepAlive) {\n-        this.keepAlive = keepAlive;\n-    }\n-\n-    /**\n-     * @return \"keep alive\" interval in milliseconds, 1 minute by default.\n-     * @see #setKeepAliveInterval(long)\n-     */\n-    public long getKeepAliveInterval() {\n-        return keepAliveInterval;\n-    }\n-\n-    /**\n-     * @param keepAliveInterval \"keep alive\" interval in milliseconds.\n-     * @see #getKeepAliveInterval()\n-     * @see #setHeartbeatInterval(long)\n-     */\n-    public void setKeepAliveInterval(long keepAliveInterval) {\n-        this.keepAliveInterval = keepAliveInterval;\n-    }\n-\n-    /**\n-     * @return \"keep alive\" connect timeout in milliseconds.\n-     * @see #setKeepAliveConnectTimeout(long)\n-     *\n-     * @deprecated in favour of {@link #getConnectTimeout()}\n-     */\n-    public long getKeepAliveConnectTimeout() {\n-        return connectTimeout;\n-    }\n-\n-    /**\n-     * @param connectTimeout \"keep alive\" connect timeout in milliseconds.\n-     * @see #getKeepAliveConnectTimeout()\n-    *\n-     * @deprecated in favour of {@link #setConnectTimeout(long)}\n-     */\n-    public void setKeepAliveConnectTimeout(long connectTimeout) {\n-        this.connectTimeout = connectTimeout;\n-    }\n-\n-    /**\n-     * @return heartbeat period in milliseconds (0 if not set (default)).\n-     * @see #setHeartbeatInterval(long)\n-     */\n-    public long getHeartbeatInterval() {\n-        return heartbeatInterval;\n-    }\n-\n-    /**\n-     * @param heartbeatInterval heartbeat period in milliseconds.\n-     * <p>\n-     * If set (recommended)\n-     * <ul>\n-     * <li> HEARTBEAT event will be emitted every \"heartbeatInterval\".\n-     * <li> if {@link #setKeepAlive(boolean)} is on then keepAlive thread will attempt to reconnect if no\n-     *   HEARTBEAT events were received within {@link #setKeepAliveInterval(long)} (instead of trying to send\n-     *   PING every {@link #setKeepAliveInterval(long)}, which is fundamentally flawed -\n-     *   https://github.com/shyiko/mysql-binlog-connector-java/issues/118).\n-     * </ul>\n-     * Note that when used together with keepAlive heartbeatInterval MUST be set less than keepAliveInterval.\n-     *\n-     * @see #getHeartbeatInterval()\n-     */\n-    public void setHeartbeatInterval(long heartbeatInterval) {\n-        this.heartbeatInterval = heartbeatInterval;\n-    }\n-\n-    /**\n-     * @return connect timeout in milliseconds, 3 seconds by default.\n-     * @see #setConnectTimeout(long)\n-     */\n-    public long getConnectTimeout() {\n-        return connectTimeout;\n-    }\n-\n-    /**\n-     * @param connectTimeout connect timeout in milliseconds.\n-     * @see #getConnectTimeout()\n-     */\n-    public void setConnectTimeout(long connectTimeout) {\n-        this.connectTimeout = connectTimeout;\n-    }\n-\n-    /**\n-     * @param eventDeserializer custom event deserializer\n-     */\n-    public void setEventDeserializer(EventDeserializer eventDeserializer) {\n-        if (eventDeserializer == null) {\n-            throw new IllegalArgumentException(\"Event deserializer cannot be NULL\");\n-        }\n-        this.eventDeserializer = eventDeserializer;\n-    }\n-\n-    /**\n-     * @param socketFactory custom socket factory. If not provided, socket will be created with \"new Socket()\".\n-     */\n-    public void setSocketFactory(SocketFactory socketFactory) {\n-        this.socketFactory = socketFactory;\n-    }\n-\n-    /**\n-     * @param sslSocketFactory custom ssl socket factory\n-     */\n-    public void setSslSocketFactory(SSLSocketFactory sslSocketFactory) {\n-        this.sslSocketFactory = sslSocketFactory;\n-    }\n-\n-    /**\n-     * @param threadFactory custom thread factory. If not provided, threads will be created using simple \"new Thread()\".\n-     */\n-    public void setThreadFactory(ThreadFactory threadFactory) {\n-        this.threadFactory = threadFactory;\n-    }\n-\n-    /**\n-     * Connect to the replication stream. Note that this method blocks until disconnected.\n-     * @throws AuthenticationException if authentication fails\n-     * @throws ServerException if MySQL server responds with an error\n-     * @throws IOException if anything goes wrong while trying to connect\n-     */\n-    public void connect() throws IOException {\n-        connectWithTimeout(connectTimeout);\n-    }\n-\n-    private void connectWithTimeout(final long connectTimeout) throws IOException {\n-        CountDownLatch latch = new CountDownLatch(1);\n-        boolean connected = false;\n-        try {\n-            PacketChannel localChannel;\n-            connectLock.lock();\n-            try {\n-                if (connectLatch != null) {\n-                    throw new IllegalStateException(\"BinaryLogClient is already connected\");\n-                }\n-                connectLatch = latch;\n-                localChannel = openChannelToBinaryLogStream(connectTimeout);\n-                channel = localChannel;\n-                if (keepAlive && !isKeepAliveThreadRunning()) {\n-                    keepAliveThreadExecutor = spawnKeepAliveThread(connectTimeout);\n-                }\n-            } finally {\n-                connectLock.unlock();\n-            }\n-            connected = true;\n-            for (LifecycleListener lifecycleListener : lifecycleListeners) {\n-                lifecycleListener.onConnect(this);\n-            }\n-            ensureEventDeserializerHasRequiredEDDs();\n-            listenForEventPackets(localChannel);\n-        } finally {\n-            connectLock.lock();\n-            try {\n-                latch.countDown();\n-                if (latch == connectLatch) {\n-                    connectLatch = null;\n-                }\n-            } finally {\n-                connectLock.unlock();\n-            }\n-            if (connected) {\n-                for (LifecycleListener lifecycleListener : lifecycleListeners) {\n-                    lifecycleListener.onDisconnect(this);\n-                }\n-            }\n-        }\n-    }\n-\n-    private PacketChannel openChannelToBinaryLogStream(final long connectTimeout) throws IOException {\n-        PacketChannel channel = null;\n-        Callable<Void> cancelCloseChannel = null;\n-        try {\n-            try {\n-                long start = System.currentTimeMillis();\n-                channel = openChannel(connectTimeout);\n-                if (connectTimeout > 0 && !isKeepAliveThreadRunning()) {\n-                    cancelCloseChannel = scheduleCloseChannel(channel, connectTimeout -\n-                        (System.currentTimeMillis() - start));\n-                }\n-                if (channel.getInputStream().peek() == -1) {\n-                    throw new EOFException();\n-                }\n-            } catch (IOException e) {\n-                throw new IOException(\"Failed to connect to MySQL on \" + hostname + \":\" + port +\n-                    \". Please make sure it's running.\", e);\n-            }\n-            GreetingPacket greetingPacket = receiveGreeting(channel);\n-            authenticate(channel, greetingPacket);\n-            connectionId = greetingPacket.getThreadId();\n-            if (\"\".equals(binlogFilename)) {\n-                synchronized (gtidSetAccessLock) {\n-                    if (gtidSet != null && \"\".equals(gtidSet.toString()) && gtidSetFallbackToPurged) {\n-                        gtidSet = new GtidSet(fetchGtidPurged(channel));\n-                    }\n-                }\n-            }\n-            if (binlogFilename == null) {\n-                fetchBinlogFilenameAndPosition(channel);\n-            }\n-            if (binlogPosition < 4) {\n-                if (logger.isLoggable(Level.WARNING)) {\n-                    logger.warning(\"Binary log position adjusted from \" + binlogPosition + \" to \" + 4);\n-                }\n-                binlogPosition = 4;\n-            }\n-            ChecksumType checksumType = fetchBinlogChecksum(channel);\n-            if (checksumType != ChecksumType.NONE) {\n-                confirmSupportOfChecksum(channel, checksumType);\n-            }\n-            if (heartbeatInterval > 0) {\n-                enableHeartbeat(channel);\n-            }\n-            gtid = null;\n-            tx = false;\n-            requestBinaryLogStream(channel);\n-        } catch (IOException e) {\n-            closeChannel(channel);\n-            throw e;\n-        } finally {\n-            if (cancelCloseChannel != null) {\n-                try {\n-                    cancelCloseChannel.call();\n-                } catch (Exception e) {\n-                    if (logger.isLoggable(Level.WARNING)) {\n-                        logger.warning(\"\\\"\" + e.getMessage() +\n-                            \"\\\" was thrown while canceling scheduled disconnect call\");\n-                    }\n-                }\n-            }\n-        }\n-        connected = true;\n-        if (logger.isLoggable(Level.INFO)) {\n-            String position;\n-            synchronized (gtidSetAccessLock) {\n-                position = gtidSet != null ? gtidSet.toString() : binlogFilename + \"/\" + binlogPosition;\n-            }\n-            logger.info(\"Connected to \" + hostname + \":\" + port + \" at \" + position +\n-                \" (\" + (blocking ? \"sid:\" + serverId + \", \" : \"\") + \"cid:\" + connectionId + \")\");\n-        }\n-        return channel;\n-    }\n-\n-    private void ensureEventDeserializerHasRequiredEDDs() {\n-        ensureEventDataDeserializerIfPresent(EventType.ROTATE, RotateEventDataDeserializer.class);\n-        synchronized (gtidSetAccessLock) {\n-            if (gtidSet != null) {\n-                ensureEventDataDeserializerIfPresent(EventType.GTID, GtidEventDataDeserializer.class);\n-                ensureEventDataDeserializerIfPresent(EventType.QUERY, QueryEventDataDeserializer.class);\n-            }\n-        }\n-    }\n-\n-    private PacketChannel openChannel(final long connectTimeout) throws IOException {\n-        Socket socket = socketFactory != null ? socketFactory.createSocket() : new Socket();\n-        socket.connect(new InetSocketAddress(hostname, port), (int) connectTimeout);\n-        return new PacketChannel(socket);\n-    }\n-\n-    private Callable<Void> scheduleCloseChannel(final PacketChannel channel, final long timeout) {\n-        final CountDownLatch connectLatch = new CountDownLatch(1);\n-        final Thread thread = newNamedThread(new Runnable() {\n-            @Override\n-            public void run() {\n-                try {\n-                    connectLatch.await(timeout, TimeUnit.MILLISECONDS);\n-                } catch (InterruptedException e) {\n-                    if (logger.isLoggable(Level.WARNING)) {\n-                        logger.log(Level.WARNING, e.getMessage());\n-                    }\n-                }\n-                if (connectLatch.getCount() != 0) {\n-                    if (logger.isLoggable(Level.WARNING)) {\n-                        logger.warning(\"Failed to establish connection in \" + timeout + \"ms. \" +\n-                            \"Forcing disconnect.\");\n-                    }\n-                    try {\n-                        closeChannel(channel);\n-                    } catch (IOException e) {\n-                        if (logger.isLoggable(Level.WARNING)) {\n-                            logger.log(Level.WARNING, e.getMessage());\n-                        }\n-                    }\n-                }\n-            }\n-        }, \"blc-disconnect-\" + hostname + \":\" + port);\n-        thread.start();\n-        return new Callable<Void>() {\n-\n-            public Void call() throws Exception {\n-                connectLatch.countDown();\n-                thread.join();\n-                return null;\n-            }\n-        };\n-    }\n-\n-    private GreetingPacket receiveGreeting(final PacketChannel channel) throws IOException {\n-        byte[] initialHandshakePacket = channel.read();\n-        if (initialHandshakePacket[0] == (byte) 0xFF /* error */) {\n-            byte[] bytes = Arrays.copyOfRange(initialHandshakePacket, 1, initialHandshakePacket.length);\n-            ErrorPacket errorPacket = new ErrorPacket(bytes);\n-            throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n-                    errorPacket.getSqlState());\n-        }\n-        return new GreetingPacket(initialHandshakePacket);\n-    }\n-\n-    private void enableHeartbeat(final PacketChannel channel) throws IOException {\n-        channel.write(new QueryCommand(\"set @master_heartbeat_period=\" + heartbeatInterval * 1000000));\n-        byte[] statementResult = channel.read();\n-        if (statementResult[0] == (byte) 0xFF /* error */) {\n-            byte[] bytes = Arrays.copyOfRange(statementResult, 1, statementResult.length);\n-            ErrorPacket errorPacket = new ErrorPacket(bytes);\n-            throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n-                errorPacket.getSqlState());\n-        }\n-    }\n-\n-    private void requestBinaryLogStream(final PacketChannel channel) throws IOException {\n-        long serverId = blocking ? this.serverId : 0; // http://bugs.mysql.com/bug.php?id=71178\n-        Command dumpBinaryLogCommand;\n-        synchronized (gtidSetAccessLock) {\n-            if (gtidSet != null) {\n-                dumpBinaryLogCommand = new DumpBinaryLogGtidCommand(serverId,\n-                    useBinlogFilenamePositionInGtidMode ? binlogFilename : \"\",\n-                    useBinlogFilenamePositionInGtidMode ? binlogPosition : 4,\n-                    gtidSet);\n-            } else {\n-                dumpBinaryLogCommand = new DumpBinaryLogCommand(serverId, binlogFilename, binlogPosition);\n-            }\n-        }\n-        channel.write(dumpBinaryLogCommand);\n-    }\n-\n-    private void ensureEventDataDeserializerIfPresent(EventType eventType,\n-            Class<? extends EventDataDeserializer<?>> eventDataDeserializerClass) {\n-        EventDataDeserializer<?> eventDataDeserializer = eventDeserializer.getEventDataDeserializer(eventType);\n-        if (eventDataDeserializer.getClass() != eventDataDeserializerClass &&\n-            eventDataDeserializer.getClass() != EventDataWrapper.Deserializer.class) {\n-            EventDataDeserializer<?> internalEventDataDeserializer;\n-            try {\n-                internalEventDataDeserializer = eventDataDeserializerClass.newInstance();\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n-            }\n-            eventDeserializer.setEventDataDeserializer(eventType,\n-                new EventDataWrapper.Deserializer(internalEventDataDeserializer,\n-                    eventDataDeserializer));\n-        }\n-    }\n-\n-    private void authenticate(final PacketChannel channel, GreetingPacket greetingPacket) throws IOException {\n-        int collation = greetingPacket.getServerCollation();\n-        int packetNumber = 1;\n-\n-        boolean usingSSLSocket = false;\n-        if (sslMode != SSLMode.DISABLED) {\n-            boolean serverSupportsSSL = (greetingPacket.getServerCapabilities() & ClientCapabilities.SSL) != 0;\n-            if (!serverSupportsSSL && (sslMode == SSLMode.REQUIRED || sslMode == SSLMode.VERIFY_CA ||\n-                sslMode == SSLMode.VERIFY_IDENTITY)) {\n-                throw new IOException(\"MySQL server does not support SSL\");\n-            }\n-            if (serverSupportsSSL) {\n-                SSLRequestCommand sslRequestCommand = new SSLRequestCommand();\n-                sslRequestCommand.setCollation(collation);\n-                channel.write(sslRequestCommand, packetNumber++);\n-                SSLSocketFactory sslSocketFactory =\n-                    this.sslSocketFactory != null ?\n-                        this.sslSocketFactory :\n-                        sslMode == SSLMode.REQUIRED || sslMode == SSLMode.PREFERRED ?\n-                            DEFAULT_REQUIRED_SSL_MODE_SOCKET_FACTORY :\n-                            DEFAULT_VERIFY_CA_SSL_MODE_SOCKET_FACTORY;\n-                channel.upgradeToSSL(sslSocketFactory, null);\n-                usingSSLSocket = true;\n-            }\n-        }\n-        AuthenticateCommand authenticateCommand = new AuthenticateCommand(schema, username, password,\n-            greetingPacket.getScramble());\n-        authenticateCommand.setCollation(collation);\n-        channel.write(authenticateCommand, packetNumber);\n-        byte[] authenticationResult = channel.read();\n-        if (authenticationResult[0] != (byte) 0x00 /* ok */) {\n-            if (authenticationResult[0] == (byte) 0xFF /* error */) {\n-                byte[] bytes = Arrays.copyOfRange(authenticationResult, 1, authenticationResult.length);\n-                ErrorPacket errorPacket = new ErrorPacket(bytes);\n-                throw new AuthenticationException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n-                    errorPacket.getSqlState());\n-            } else if (authenticationResult[0] == (byte) 0xFE) {\n-                switchAuthentication(channel, authenticationResult, usingSSLSocket);\n-            } else {\n-                throw new AuthenticationException(\"Unexpected authentication result (\" + authenticationResult[0] + \")\");\n-            }\n-        }\n-    }\n-\n-    private void switchAuthentication(final PacketChannel channel, byte[] authenticationResult, boolean usingSSLSocket)\n-            throws IOException {\n-        /*\n-            Azure-MySQL likes to tell us to switch authentication methods, even though\n-            we haven't advertised that we support any.  It uses this for some-odd\n-            reason to send the real password scramble.\n-        */\n-        ByteArrayInputStream buffer = new ByteArrayInputStream(authenticationResult);\n-        //noinspection ResultOfMethodCallIgnored\n-        buffer.read(1);\n-\n-        String authName = buffer.readZeroTerminatedString();\n-        if (\"mysql_native_password\".equals(authName)) {\n-            String scramble = buffer.readZeroTerminatedString();\n-\n-            Command switchCommand = new AuthenticateNativePasswordCommand(scramble, password);\n-            channel.write(switchCommand, (usingSSLSocket ? 4 : 3));\n-            byte[] authResult = channel.read();\n-\n-            if (authResult[0] != (byte) 0x00) {\n-                byte[] bytes = Arrays.copyOfRange(authResult, 1, authResult.length);\n-                ErrorPacket errorPacket = new ErrorPacket(bytes);\n-                throw new AuthenticationException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n-                    errorPacket.getSqlState());\n-            }\n-        } else {\n-            throw new AuthenticationException(\"Unsupported authentication type: \" + authName);\n-        }\n-    }\n-\n-    private ExecutorService spawnKeepAliveThread(final long connectTimeout) {\n-        final ExecutorService threadExecutor =\n-            Executors.newSingleThreadExecutor(new ThreadFactory() {\n-\n-                @Override\n-                public Thread newThread(Runnable runnable) {\n-                    return newNamedThread(runnable, \"blc-keepalive-\" + hostname + \":\" + port);\n-                }\n-            });\n-        threadExecutor.submit(new Runnable() {\n-            @Override\n-            public void run() {\n-                connectLock.lock(); // wait for connect() to finish initialization sequence\n-                connectLock.unlock();\n-                while (!threadExecutor.isShutdown()) {\n-                    try {\n-                        //noinspection BusyWait\n-                        Thread.sleep(keepAliveInterval);\n-                    } catch (InterruptedException e) {\n-                        // expected in case of disconnect\n-                    }\n-                    if (threadExecutor.isShutdown()) {\n-                        return;\n-                    }\n-                    boolean connectionLost = false;\n-                    if (heartbeatInterval > 0) {\n-                        connectionLost = System.currentTimeMillis() - eventLastSeen > keepAliveInterval;\n-                    } else {\n-                        try {\n-                            channel.write(new PingCommand());\n-                        } catch (IOException e) {\n-                            connectionLost = true;\n-                        }\n-                    }\n-                    if (connectionLost) {\n-                        if (logger.isLoggable(Level.INFO)) {\n-                            logger.info(\"Trying to restore lost connection to \" + hostname + \":\" + port);\n-                        }\n-                        try {\n-                            terminateConnect();\n-                            connect(connectTimeout);\n-                        } catch (Exception ce) {\n-                            if (logger.isLoggable(Level.WARNING)) {\n-                                logger.warning(\"Failed to restore connection to \" + hostname + \":\" + port +\n-                                    \". Next attempt in \" + keepAliveInterval + \"ms\");\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        });\n-        return threadExecutor;\n-    }\n-\n-    private Thread newNamedThread(Runnable runnable, String threadName) {\n-        Thread thread = threadFactory == null ? new Thread(runnable) : threadFactory.newThread(runnable);\n-        thread.setName(threadName);\n-        return thread;\n-    }\n-\n-    boolean isKeepAliveThreadRunning() {\n-        return keepAliveThreadExecutor != null && !keepAliveThreadExecutor.isShutdown();\n-    }\n-\n-    /**\n-     * Connect to the replication stream in a separate thread.\n-     * @param timeout timeout in milliseconds\n-     * @throws AuthenticationException if authentication fails\n-     * @throws ServerException if MySQL server responds with an error\n-     * @throws IOException if anything goes wrong while trying to connect\n-     * @throws TimeoutException if client was unable to connect within given time limit\n-     */\n-    public void connect(final long timeout) throws IOException, TimeoutException {\n-        final CountDownLatch countDownLatch = new CountDownLatch(1);\n-        AbstractLifecycleListener connectListener = new AbstractLifecycleListener() {\n-            @Override\n-            public void onConnect(BinaryLogClient client) {\n-                countDownLatch.countDown();\n-            }\n-        };\n-        registerLifecycleListener(connectListener);\n-        final AtomicReference<IOException> exceptionReference = new AtomicReference<IOException>();\n-        Runnable runnable = new Runnable() {\n-\n-            @Override\n-            public void run() {\n-                try {\n-                    connectWithTimeout(timeout);\n-                } catch (IOException e) {\n-                    exceptionReference.set(e);\n-                    countDownLatch.countDown(); // making sure we don't end up waiting whole \"timeout\"\n-                }\n-            }\n-        };\n-        newNamedThread(runnable, \"blc-\" + hostname + \":\" + port).start();\n-        boolean started = false;\n-        try {\n-            started = countDownLatch.await(timeout, TimeUnit.MILLISECONDS);\n-        } catch (InterruptedException e) {\n-            if (logger.isLoggable(Level.WARNING)) {\n-                logger.log(Level.WARNING, e.getMessage());\n-            }\n-        }\n-        unregisterLifecycleListener(connectListener);\n-        if (exceptionReference.get() != null) {\n-            throw exceptionReference.get();\n-        }\n-        if (!started) {\n-            try {\n-                // NOTE: we don't call disconnect here and so if client is able to connect right after timeout expires -\n-                // keep-alive thread may be left running.\n-                terminateConnect();\n-            } catch (IOException e) {\n-                if (logger.isLoggable(Level.WARNING)) {\n-                    logger.warning(\"\\\"\" + e.getMessage() +\n-                        \"\\\" was thrown while terminating connection due to timeout\");\n-                }\n-            }\n-            throw new TimeoutException(\"BinaryLogClient was unable to connect in \" + timeout + \"ms\");\n-        }\n-    }\n-\n-    /**\n-     * @return true if client is connected, false otherwise\n-     */\n-    public boolean isConnected() {\n-        return connectLatch != null;\n-    }\n-\n-    private String fetchGtidPurged(final PacketChannel channel) throws IOException {\n-        channel.write(new QueryCommand(\"show global variables like 'gtid_purged'\"));\n-        ResultSetRowPacket[] resultSet = readResultSet(channel);\n-        if (resultSet.length != 0) {\n-            return resultSet[0].getValue(1).toUpperCase();\n-        }\n-        return \"\";\n-    }\n-\n-    private void fetchBinlogFilenameAndPosition(final PacketChannel channel) throws IOException {\n-        channel.write(new QueryCommand(\"show master status\"));\n-        ResultSetRowPacket[] resultSet = readResultSet(channel);\n-        if (resultSet.length == 0) {\n-            throw new IOException(\"Failed to determine binlog filename/position\");\n-        }\n-        ResultSetRowPacket resultSetRow = resultSet[0];\n-        binlogFilename = resultSetRow.getValue(0);\n-        binlogPosition = Long.parseLong(resultSetRow.getValue(1));\n-    }\n-\n-    protected ChecksumType fetchBinlogChecksum(final PacketChannel channel) throws IOException {\n-        channel.write(new QueryCommand(\"show global variables like 'binlog_checksum'\"));\n-        ResultSetRowPacket[] resultSet = readResultSet(channel);\n-        if (resultSet.length == 0) {\n-            return ChecksumType.NONE;\n-        }\n-        return ChecksumType.valueOf(resultSet[0].getValue(1).toUpperCase());\n-    }\n-\n-    private void confirmSupportOfChecksum(final PacketChannel channel, ChecksumType checksumType) throws IOException {\n-        channel.write(new QueryCommand(\"set @master_binlog_checksum= @@global.binlog_checksum\"));\n-        byte[] statementResult = channel.read();\n-        if (statementResult[0] == (byte) 0xFF /* error */) {\n-            byte[] bytes = Arrays.copyOfRange(statementResult, 1, statementResult.length);\n-            ErrorPacket errorPacket = new ErrorPacket(bytes);\n-            throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n-                errorPacket.getSqlState());\n-        }\n-        eventDeserializer.setChecksumType(checksumType);\n-    }\n-\n-    private void listenForEventPackets(final PacketChannel channel) throws IOException {\n-        ByteArrayInputStream inputStream = channel.getInputStream();\n-        boolean completeShutdown = false;\n-        try {\n-            while (!abortRequest && inputStream.peek() != -1) {\n-                int packetLength = inputStream.readInteger(3);\n-                //noinspection ResultOfMethodCallIgnored\n-                inputStream.skip(1); // 1 byte for sequence\n-                int marker = inputStream.read();\n-                if (marker == 0xFF) {\n-                    ErrorPacket errorPacket = new ErrorPacket(inputStream.read(packetLength - 1));\n-                    throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n-                        errorPacket.getSqlState());\n-                }\n-                if (marker == 0xFE && !blocking) {\n-                    completeShutdown = true;\n-                    break;\n-                }\n-                Event event;\n-                try {\n-                    event = eventDeserializer.nextEvent(packetLength == MAX_PACKET_LENGTH ?\n-                        new ByteArrayInputStream(readPacketSplitInChunks(inputStream, packetLength - 1)) :\n-                        inputStream);\n-                    if (event == null) {\n-                        throw new EOFException();\n-                    }\n-                } catch (Exception e) {\n-                    Throwable cause = e instanceof EventDataDeserializationException ? e.getCause() : e;\n-                    if (cause instanceof EOFException || cause instanceof SocketException) {\n-                        throw e;\n-                    }\n-                    if (connected) {\n-                        for (LifecycleListener lifecycleListener : lifecycleListeners) {\n-                            lifecycleListener.onEventDeserializationFailure(this, e);\n-                        }\n-                    }\n-                    continue;\n-                }\n-                if (connected) {\n-                    eventLastSeen = System.currentTimeMillis();\n-                    updateGtidSet(event);\n-                    notifyEventListeners(event);\n-                    updateClientBinlogFilenameAndPosition(event);\n-                }\n-            }\n-        } catch (Exception e) {\n-            if (connected) {\n-                for (LifecycleListener lifecycleListener : lifecycleListeners) {\n-                    lifecycleListener.onCommunicationFailure(this, e);\n-                }\n-            }\n-        } finally {\n-            abortRequest = false;\n-            if (connected) {\n-                if (completeShutdown) {\n-                    disconnect(); // initiate complete shutdown sequence (which includes keep alive thread)\n-                } else {\n-                    closeChannel(channel);\n-                }\n-            }\n-        }\n-    }\n-\n-    private byte[] readPacketSplitInChunks(ByteArrayInputStream inputStream, int packetLength) throws IOException {\n-        byte[] result = inputStream.read(packetLength);\n-        int chunkLength;\n-        do {\n-            chunkLength = inputStream.readInteger(3);\n-            //noinspection ResultOfMethodCallIgnored\n-            inputStream.skip(1); // 1 byte for sequence\n-            result = Arrays.copyOf(result, result.length + chunkLength);\n-            inputStream.fill(result, result.length - chunkLength, chunkLength);\n-        } while (chunkLength == Packet.MAX_LENGTH);\n-        return result;\n-    }\n-\n-    private void updateClientBinlogFilenameAndPosition(Event event) {\n-        EventHeader eventHeader = event.getHeader();\n-        EventType eventType = eventHeader.getEventType();\n-        if (eventType == EventType.ROTATE) {\n-            RotateEventData rotateEventData = (RotateEventData) EventDataWrapper.internal(event.getData());\n-            binlogFilename = rotateEventData.getBinlogFilename();\n-            binlogPosition = rotateEventData.getBinlogPosition();\n-        } else\n-        // do not update binlogPosition on TABLE_MAP so that in case of reconnect (using a different instance of\n-        // client) table mapping cache could be reconstructed before hitting row mutation event\n-        if (eventType != EventType.TABLE_MAP && eventHeader instanceof EventHeaderV4) {\n-            EventHeaderV4 trackableEventHeader = (EventHeaderV4) eventHeader;\n-            long nextBinlogPosition = trackableEventHeader.getNextPosition();\n-            if (nextBinlogPosition > 0) {\n-                binlogPosition = nextBinlogPosition;\n-            }\n-        }\n-    }\n-\n-    private void updateGtidSet(Event event) {\n-        synchronized (gtidSetAccessLock) {\n-            if (gtidSet == null) {\n-                return;\n-            }\n-        }\n-        EventHeader eventHeader = event.getHeader();\n-        switch(eventHeader.getEventType()) {\n-            case GTID:\n-                GtidEventData gtidEventData = (GtidEventData) EventDataWrapper.internal(event.getData());\n-                gtid = gtidEventData.getGtid();\n-                break;\n-            case XID:\n-                commitGtid();\n-                tx = false;\n-                break;\n-            case QUERY:\n-                QueryEventData queryEventData = (QueryEventData) EventDataWrapper.internal(event.getData());\n-                String sql = queryEventData.getSql();\n-                if (sql == null) {\n-                    break;\n-                }\n-                if (\"BEGIN\".equals(sql)) {\n-                    tx = true;\n-                } else\n-                if (\"COMMIT\".equals(sql) || \"ROLLBACK\".equals(sql)) {\n-                    commitGtid();\n-                    tx = false;\n-                } else\n-                if (!tx) {\n-                    // auto-commit query, likely DDL\n-                    commitGtid();\n-                }\n-            default:\n-        }\n-    }\n-\n-    private void commitGtid() {\n-        if (gtid != null) {\n-            synchronized (gtidSetAccessLock) {\n-                gtidSet.add(gtid);\n-            }\n-        }\n-    }\n-\n-    protected ResultSetRowPacket[] readResultSet(final PacketChannel channel) throws IOException {\n-        List<ResultSetRowPacket> resultSet = new LinkedList<ResultSetRowPacket>();\n-        byte[] statementResult = channel.read();\n-        if (statementResult[0] == (byte) 0xFF /* error */) {\n-            byte[] bytes = Arrays.copyOfRange(statementResult, 1, statementResult.length);\n-            ErrorPacket errorPacket = new ErrorPacket(bytes);\n-            throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n-                    errorPacket.getSqlState());\n-        }\n-        while ((channel.read())[0] != (byte) 0xFE /* eof */) { /* skip */ }\n-        for (byte[] bytes; (bytes = channel.read())[0] != (byte) 0xFE /* eof */; ) {\n-            resultSet.add(new ResultSetRowPacket(bytes));\n-        }\n-        return resultSet.toArray(new ResultSetRowPacket[0]);\n-    }\n-\n-    /**\n-     * @return registered event listeners\n-     */\n-    public List<EventListener> getEventListeners() {\n-        return Collections.unmodifiableList(eventListeners);\n-    }\n-\n-    /**\n-     * Register event listener. Note that multiple event listeners will be called in order they\n-     * where registered.\n-     */\n-    public void registerEventListener(EventListener eventListener) {\n-        eventListeners.add(eventListener);\n-    }\n-\n-    /**\n-     * Unregister all event listener of specific type.\n-     */\n-    public void unregisterEventListener(Class<? extends EventListener> listenerClass) {\n-        for (EventListener eventListener: eventListeners) {\n-            if (listenerClass.isInstance(eventListener)) {\n-                eventListeners.remove(eventListener);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Unregister single event listener.\n-     */\n-    public void unregisterEventListener(EventListener eventListener) {\n-        eventListeners.remove(eventListener);\n-    }\n-\n-    private void notifyEventListeners(Event event) {\n-        if (event.getData() instanceof EventDataWrapper) {\n-            event = new Event(event.getHeader(), ((EventDataWrapper) event.getData()).getExternal());\n-        }\n-        for (EventListener eventListener : eventListeners) {\n-            try {\n-                eventListener.onEvent(event);\n-            } catch (Exception e) {\n-                    throw new RuntimeException(\"Binlog event listener \" + eventListener +\n-                                               \" choked on \" + event, e);\n-                }\n-            }\n-    }\n-\n-    /**\n-     * @return registered lifecycle listeners\n-     */\n-    public List<LifecycleListener> getLifecycleListeners() {\n-        return Collections.unmodifiableList(lifecycleListeners);\n-    }\n-\n-    /**\n-     * Register lifecycle listener. Note that multiple lifecycle listeners will be called in order they\n-     * where registered.\n-     */\n-    public void registerLifecycleListener(LifecycleListener lifecycleListener) {\n-        lifecycleListeners.add(lifecycleListener);\n-    }\n-\n-    /**\n-     * Unregister all lifecycle listener of specific type.\n-     */\n-    public void unregisterLifecycleListener(Class<? extends LifecycleListener> listenerClass) {\n-        for (LifecycleListener lifecycleListener : lifecycleListeners) {\n-            if (listenerClass.isInstance(lifecycleListener)) {\n-                lifecycleListeners.remove(lifecycleListener);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Unregister single lifecycle listener.\n-     */\n-    public void unregisterLifecycleListener(LifecycleListener eventListener) {\n-        lifecycleListeners.remove(eventListener);\n-    }\n-\n-    /**\n-     * Disconnect from the replication stream.\n-     * Note that this does not reset binlogFilename/binlogPosition. Calling {@link #connect()} or\n-     * {@link #connect(long)}} again resumes client from where it left off.\n-     */\n-    public void disconnect() throws IOException {\n-        connectLock.lock();\n-        ExecutorService keepAliveThreadExecutor = this.keepAliveThreadExecutor;\n-        PacketChannel channel = this.channel;\n-        CountDownLatch connectLatch = this.connectLatch;\n-        connectLock.unlock();\n-\n-        terminateKeepAliveThread(keepAliveThreadExecutor);\n-        closeChannel(channel);\n-        waitForConnectToTerminate(connectLatch);\n-    }\n-\n-    public void abort() {\n-        abortRequest = true;\n-    }\n-\n-    private void terminateKeepAliveThread(final ExecutorService threadExecutor) {\n-        if (threadExecutor == null) {\n-            return;\n-        }\n-        threadExecutor.shutdownNow();\n-        while (!awaitTerminationInterruptibly(threadExecutor, Long.MAX_VALUE, TimeUnit.NANOSECONDS)) { /* retry */ }\n-    }\n-\n-    @SuppressWarnings(\"SameParameterValue\")\n-    private static boolean awaitTerminationInterruptibly(final ExecutorService executorService,\n-            final long timeout, final TimeUnit unit) {\n-        try {\n-            return executorService.awaitTermination(timeout, unit);\n-        } catch (InterruptedException e) {\n-            return false;\n-        }\n-    }\n-\n-    private void terminateConnect() throws IOException {\n-        connectLock.lock();\n-        PacketChannel channel = this.channel;\n-        CountDownLatch connectLatch = this.connectLatch;\n-        connectLock.unlock();\n-\n-        closeChannel(channel);\n-        waitForConnectToTerminate(connectLatch);\n-    }\n-\n-    private void waitForConnectToTerminate(final CountDownLatch connectLatch) {\n-        if (connectLatch != null) {\n-            while (!awaitInterruptibly(connectLatch, Long.MAX_VALUE, TimeUnit.NANOSECONDS)) { /* retry */ }\n-        }\n-    }\n-\n-    @SuppressWarnings(\"SameParameterValue\")\n-    private static boolean awaitInterruptibly(final CountDownLatch countDownLatch,\n-            final long time, final TimeUnit unit) {\n-        try {\n-            return countDownLatch.await(time, unit);\n-        } catch (InterruptedException e) {\n-            return false;\n-        }\n-    }\n-\n-    private void closeChannel(final PacketChannel channel) throws IOException {\n-        connected = false;\n-        if (channel != null && channel.isOpen()) {\n-            channel.close();\n-        }\n-    }\n-\n-    /**\n-     * {@link BinaryLogClient}'s event listener.\n-     */\n-    public interface EventListener {\n-\n-        void onEvent(Event event);\n-    }\n-\n-    /**\n-     * {@link BinaryLogClient}'s lifecycle listener.\n-     */\n     public interface LifecycleListener {\n \n         /**\n@@ -1269,10 +45,7 @@ private void closeChannel(final PacketChannel channel) throws IOException {\n         void onDisconnect(BinaryLogClient client);\n     }\n \n-    /**\n-     * Default (no-op) implementation of {@link LifecycleListener}.\n-     */\n-    public static abstract class AbstractLifecycleListener implements LifecycleListener {\n+    public abstract static class AbstractLifecycleListener implements LifecycleListener {\n \n         public void onConnect(BinaryLogClient client) { }\n \n@@ -1284,4 +57,7 @@ public void onDisconnect(BinaryLogClient client) { }\n \n     }\n \n+    public interface EventListener {\n+        void onEvent(Event event);\n+    }\n }"
  },
  {
    "sha": "be762f5d99c87736e928b1c93ef3eec13a1c4781",
    "filename": "src/main/java/com/github/shyiko/mysql/binlog/NewBinaryLogClient.java",
    "status": "added",
    "additions": 1235,
    "deletions": 0,
    "changes": 1235,
    "blob_url": "https://github.com/fivetran/mysql-binlog-connector-java/blob/341f8dac8630a52d8989bbeba9a93b370f322d60/src/main/java/com/github/shyiko/mysql/binlog/NewBinaryLogClient.java",
    "raw_url": "https://github.com/fivetran/mysql-binlog-connector-java/raw/341f8dac8630a52d8989bbeba9a93b370f322d60/src/main/java/com/github/shyiko/mysql/binlog/NewBinaryLogClient.java",
    "contents_url": "https://api.github.com/repos/fivetran/mysql-binlog-connector-java/contents/src/main/java/com/github/shyiko/mysql/binlog/NewBinaryLogClient.java?ref=341f8dac8630a52d8989bbeba9a93b370f322d60",
    "patch": "@@ -0,0 +1,1235 @@\n+/*\n+ * Copyright 2013 Stanley Shyiko\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.github.shyiko.mysql.binlog;\n+\n+import com.github.shyiko.mysql.binlog.event.*;\n+import com.github.shyiko.mysql.binlog.event.deserialization.*;\n+import com.github.shyiko.mysql.binlog.event.deserialization.EventDeserializer.EventDataWrapper;\n+import com.github.shyiko.mysql.binlog.io.ByteArrayInputStream;\n+import com.github.shyiko.mysql.binlog.network.*;\n+import com.github.shyiko.mysql.binlog.network.protocol.*;\n+import com.github.shyiko.mysql.binlog.network.protocol.command.*;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.GeneralSecurityException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+\n+/**\n+ * MySQL replication stream client.\n+ *\n+ * @author <a href=\"mailto:stanley.shyiko@gmail.com\">Stanley Shyiko</a>\n+ */\n+public class NewBinaryLogClient extends BinaryLogClient {\n+\n+    private static final SSLSocketFactory DEFAULT_REQUIRED_SSL_MODE_SOCKET_FACTORY = new DefaultSSLSocketFactory() {\n+\n+        @Override\n+        protected void initSSLContext(SSLContext sc) throws GeneralSecurityException {\n+            sc.init(null, new TrustManager[]{\n+                new X509TrustManager() {\n+\n+                    @Override\n+                    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) { }\n+\n+                    @Override\n+                    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) { }\n+\n+                    @Override\n+                    public X509Certificate[] getAcceptedIssuers() {\n+                        return new X509Certificate[0];\n+                    }\n+                }\n+            }, null);\n+        }\n+    };\n+    private static final SSLSocketFactory DEFAULT_VERIFY_CA_SSL_MODE_SOCKET_FACTORY = new DefaultSSLSocketFactory();\n+\n+    // https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html\n+    private static final int MAX_PACKET_LENGTH = 16777215;\n+\n+    private final Logger logger = Logger.getLogger(\"donkey\");\n+\n+    private final String hostname;\n+    private final int port;\n+    private final String schema;\n+    private final String username;\n+    private final String password;\n+\n+    private boolean blocking = true;\n+    private long serverId = 65535;\n+    private volatile String binlogFilename;\n+    private volatile long binlogPosition = 4;\n+    private volatile long connectionId;\n+    private SSLMode sslMode = SSLMode.DISABLED;\n+\n+    private GtidSet gtidSet;\n+    private final Object gtidSetAccessLock = new Object();\n+    private boolean gtidSetFallbackToPurged;\n+    private boolean useBinlogFilenamePositionInGtidMode;\n+    private String gtid;\n+    private boolean tx;\n+\n+    private EventDeserializer eventDeserializer = new EventDeserializer();\n+\n+    private final List<EventListener> eventListeners = new CopyOnWriteArrayList<EventListener>();\n+    private final List<LifecycleListener> lifecycleListeners = new CopyOnWriteArrayList<LifecycleListener>();\n+    private boolean abortRequest = false;\n+\n+    private SocketFactory socketFactory;\n+    private SSLSocketFactory sslSocketFactory;\n+\n+    private volatile PacketChannel channel;\n+    private volatile boolean connected;\n+\n+    private ThreadFactory threadFactory;\n+\n+    private boolean keepAlive = true;\n+    private long keepAliveInterval = TimeUnit.MINUTES.toMillis(1);\n+\n+    private long heartbeatInterval;\n+    private volatile long eventLastSeen;\n+\n+    private long connectTimeout = TimeUnit.SECONDS.toMillis(3);\n+\n+    private volatile ExecutorService keepAliveThreadExecutor;\n+\n+    private final Lock connectLock = new ReentrantLock();\n+    private volatile CountDownLatch connectLatch;\n+\n+    /**\n+     * Alias for BinaryLogClient(\"localhost\", 3306, &lt;no schema&gt; = null, username, password).\n+     * @see NewBinaryLogClient#NewBinaryLogClient(String, int, String, String, String)\n+     */\n+    public NewBinaryLogClient(String username, String password) {\n+        this(\"localhost\", 3306, null, username, password);\n+    }\n+\n+    /**\n+     * Alias for BinaryLogClient(\"localhost\", 3306, schema, username, password).\n+     * @see NewBinaryLogClient#NewBinaryLogClient(String, int, String, String, String)\n+     */\n+    public NewBinaryLogClient(String schema, String username, String password) {\n+        this(\"localhost\", 3306, schema, username, password);\n+    }\n+\n+    /**\n+     * Alias for BinaryLogClient(hostname, port, &lt;no schema&gt; = null, username, password).\n+     * @see NewBinaryLogClient#NewBinaryLogClient(String, int, String, String, String)\n+     */\n+    public NewBinaryLogClient(String hostname, int port, String username, String password) {\n+        this(hostname, port, null, username, password);\n+    }\n+\n+    /**\n+     * @param hostname mysql server hostname\n+     * @param port mysql server port\n+     * @param schema database name, nullable. Note that this parameter has nothing to do with event filtering. It's\n+     * used only during the authentication.\n+     * @param username login name\n+     * @param password password\n+     */\n+    public NewBinaryLogClient(String hostname, int port, String schema, String username, String password) {\n+        this.hostname = hostname;\n+        this.port = port;\n+        this.schema = schema;\n+        this.username = username;\n+        this.password = password;\n+    }\n+\n+    public boolean isBlocking() {\n+        return blocking;\n+    }\n+\n+    /**\n+     * @param blocking blocking mode. If set to false - BinaryLogClient will disconnect after the last event.\n+     */\n+    public void setBlocking(boolean blocking) {\n+        this.blocking = blocking;\n+    }\n+\n+    public SSLMode getSSLMode() {\n+        return sslMode;\n+    }\n+\n+    public void setSSLMode(SSLMode sslMode) {\n+        if (sslMode == null) {\n+            throw new IllegalArgumentException(\"SSL mode cannot be NULL\");\n+        }\n+        this.sslMode = sslMode;\n+    }\n+\n+    /**\n+     * @return server id (65535 by default)\n+     * @see #setServerId(long)\n+     */\n+    public long getServerId() {\n+        return serverId;\n+    }\n+\n+    /**\n+     * @param serverId server id (in the range from 1 to 2^32 - 1). This value MUST be unique across whole replication\n+     * group (that is, different from any other server id being used by any master or slave). Keep in mind that each\n+     * binary log client (mysql-binlog-connector-java/BinaryLogClient, mysqlbinlog, etc) should be treated as a\n+     * simplified slave and thus MUST also use a different server id.\n+     * @see #getServerId()\n+     */\n+    public void setServerId(long serverId) {\n+        this.serverId = serverId;\n+    }\n+\n+    /**\n+     * @return binary log filename, nullable (and null be default). Note that this value is automatically tracked by\n+     * the client and thus is subject to change (in response to {@link EventType#ROTATE}, for example).\n+     * @see #setBinlogFilename(String)\n+     */\n+    public String getBinlogFilename() {\n+        return binlogFilename;\n+    }\n+\n+    /**\n+     * @param binlogFilename binary log filename.\n+     * Special values are:\n+     * <ul>\n+     *   <li>null, which turns on automatic resolution (resulting in the last known binlog and position). This is what\n+     * happens by default when you don't specify binary log filename explicitly.</li>\n+     *   <li>\"\" (empty string), which instructs server to stream events starting from the oldest known binlog.</li>\n+     * </ul>\n+     * @see #getBinlogFilename()\n+     */\n+    public void setBinlogFilename(String binlogFilename) {\n+        this.binlogFilename = binlogFilename;\n+    }\n+\n+    /**\n+     * @return binary log position of the next event, 4 by default (which is a position of first event). Note that this\n+     * value changes with each incoming event.\n+     * @see #setBinlogPosition(long)\n+     */\n+    public long getBinlogPosition() {\n+        return binlogPosition;\n+    }\n+\n+    /**\n+     * @param binlogPosition binary log position. Any value less than 4 gets automatically adjusted to 4 on connect.\n+     * @see #getBinlogPosition()\n+     */\n+    public void setBinlogPosition(long binlogPosition) {\n+        this.binlogPosition = binlogPosition;\n+    }\n+\n+    /**\n+     * @return thread id\n+     */\n+    public long getConnectionId() {\n+        return connectionId;\n+    }\n+\n+    /**\n+     * @return GTID set. Note that this value changes with each received GTID event (provided client is in GTID mode).\n+     * @see #setGtidSet(String)\n+     */\n+    public String getGtidSet() {\n+        synchronized (gtidSetAccessLock) {\n+            return gtidSet != null ? gtidSet.toString() : null;\n+        }\n+    }\n+\n+    /**\n+     * @param gtidSet GTID set (can be an empty string).\n+     * <p>NOTE #1: Any value but null will switch BinaryLogClient into a GTID mode (this will also set binlogFilename\n+     * to \"\" (provided it's null) forcing MySQL to send events starting from the oldest known binlog (keep in mind\n+     * that connection will fail if gtid_purged is anything but empty (unless\n+     * {@link #setGtidSetFallbackToPurged(boolean)} is set to true))).\n+     * <p>NOTE #2: GTID set is automatically updated with each incoming GTID event (provided GTID mode is on).\n+     * @see #getGtidSet()\n+     * @see #setGtidSetFallbackToPurged(boolean)\n+     */\n+    public void setGtidSet(String gtidSet) {\n+        if (gtidSet != null && this.binlogFilename == null) {\n+            this.binlogFilename = \"\";\n+        }\n+        synchronized (gtidSetAccessLock) {\n+            this.gtidSet = gtidSet != null ? new GtidSet(gtidSet) : null;\n+        }\n+    }\n+\n+    /**\n+     * @see #setGtidSetFallbackToPurged(boolean)\n+     */\n+    public boolean isGtidSetFallbackToPurged() {\n+        return gtidSetFallbackToPurged;\n+    }\n+\n+    /**\n+     * @param gtidSetFallbackToPurged true if gtid_purged should be used as a fallback when gtidSet is set to \"\" and\n+     * MySQL server has purged some of the binary logs, false otherwise (default).\n+     */\n+    public void setGtidSetFallbackToPurged(boolean gtidSetFallbackToPurged) {\n+        this.gtidSetFallbackToPurged = gtidSetFallbackToPurged;\n+    }\n+\n+    /**\n+     * @see #setUseBinlogFilenamePositionInGtidMode(boolean)\n+     */\n+    public boolean isUseBinlogFilenamePositionInGtidMode() {\n+        return useBinlogFilenamePositionInGtidMode;\n+    }\n+\n+    /**\n+     * @param useBinlogFilenamePositionInGtidMode true if MySQL server should start streaming events from a given\n+     * {@link #getBinlogFilename()} and {@link #getBinlogPosition()} instead of \"the oldest known binlog\" when\n+     * {@link #getGtidSet()} is set, false otherwise (default).\n+     */\n+    public void setUseBinlogFilenamePositionInGtidMode(boolean useBinlogFilenamePositionInGtidMode) {\n+        this.useBinlogFilenamePositionInGtidMode = useBinlogFilenamePositionInGtidMode;\n+    }\n+\n+    /**\n+     * @return true if \"keep alive\" thread should be automatically started (default), false otherwise.\n+     * @see #setKeepAlive(boolean)\n+     */\n+    public boolean isKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * @param keepAlive true if \"keep alive\" thread should be automatically started (recommended and true by default),\n+     * false otherwise.\n+     * @see #isKeepAlive()\n+     * @see #setKeepAliveInterval(long)\n+     */\n+    public void setKeepAlive(boolean keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    /**\n+     * @return \"keep alive\" interval in milliseconds, 1 minute by default.\n+     * @see #setKeepAliveInterval(long)\n+     */\n+    public long getKeepAliveInterval() {\n+        return keepAliveInterval;\n+    }\n+\n+    /**\n+     * @param keepAliveInterval \"keep alive\" interval in milliseconds.\n+     * @see #getKeepAliveInterval()\n+     * @see #setHeartbeatInterval(long)\n+     */\n+    public void setKeepAliveInterval(long keepAliveInterval) {\n+        this.keepAliveInterval = keepAliveInterval;\n+    }\n+\n+    /**\n+     * @return \"keep alive\" connect timeout in milliseconds.\n+     * @see #setKeepAliveConnectTimeout(long)\n+     *\n+     * @deprecated in favour of {@link #getConnectTimeout()}\n+     */\n+    public long getKeepAliveConnectTimeout() {\n+        return connectTimeout;\n+    }\n+\n+    /**\n+     * @param connectTimeout \"keep alive\" connect timeout in milliseconds.\n+     * @see #getKeepAliveConnectTimeout()\n+     *\n+     * @deprecated in favour of {@link #setConnectTimeout(long)}\n+     */\n+    public void setKeepAliveConnectTimeout(long connectTimeout) {\n+        this.connectTimeout = connectTimeout;\n+    }\n+\n+    /**\n+     * @return heartbeat period in milliseconds (0 if not set (default)).\n+     * @see #setHeartbeatInterval(long)\n+     */\n+    public long getHeartbeatInterval() {\n+        return heartbeatInterval;\n+    }\n+\n+    /**\n+     * @param heartbeatInterval heartbeat period in milliseconds.\n+     * <p>\n+     * If set (recommended)\n+     * <ul>\n+     * <li> HEARTBEAT event will be emitted every \"heartbeatInterval\".\n+     * <li> if {@link #setKeepAlive(boolean)} is on then keepAlive thread will attempt to reconnect if no\n+     *   HEARTBEAT events were received within {@link #setKeepAliveInterval(long)} (instead of trying to send\n+     *   PING every {@link #setKeepAliveInterval(long)}, which is fundamentally flawed -\n+     *   https://github.com/shyiko/mysql-binlog-connector-java/issues/118).\n+     * </ul>\n+     * Note that when used together with keepAlive heartbeatInterval MUST be set less than keepAliveInterval.\n+     *\n+     * @see #getHeartbeatInterval()\n+     */\n+    public void setHeartbeatInterval(long heartbeatInterval) {\n+        this.heartbeatInterval = heartbeatInterval;\n+    }\n+\n+    /**\n+     * @return connect timeout in milliseconds, 3 seconds by default.\n+     * @see #setConnectTimeout(long)\n+     */\n+    public long getConnectTimeout() {\n+        return connectTimeout;\n+    }\n+\n+    /**\n+     * @param connectTimeout connect timeout in milliseconds.\n+     * @see #getConnectTimeout()\n+     */\n+    public void setConnectTimeout(long connectTimeout) {\n+        this.connectTimeout = connectTimeout;\n+    }\n+\n+    /**\n+     * @param eventDeserializer custom event deserializer\n+     */\n+    public void setEventDeserializer(EventDeserializer eventDeserializer) {\n+        if (eventDeserializer == null) {\n+            throw new IllegalArgumentException(\"Event deserializer cannot be NULL\");\n+        }\n+        this.eventDeserializer = eventDeserializer;\n+    }\n+\n+    /**\n+     * @param socketFactory custom socket factory. If not provided, socket will be created with \"new Socket()\".\n+     */\n+    public void setSocketFactory(SocketFactory socketFactory) {\n+        this.socketFactory = socketFactory;\n+    }\n+\n+    /**\n+     * @param sslSocketFactory custom ssl socket factory\n+     */\n+    public void setSslSocketFactory(SSLSocketFactory sslSocketFactory) {\n+        this.sslSocketFactory = sslSocketFactory;\n+    }\n+\n+    /**\n+     * @param threadFactory custom thread factory. If not provided, threads will be created using simple \"new Thread()\".\n+     */\n+    public void setThreadFactory(ThreadFactory threadFactory) {\n+        this.threadFactory = threadFactory;\n+    }\n+\n+    /**\n+     * Connect to the replication stream. Note that this method blocks until disconnected.\n+     * @throws AuthenticationException if authentication fails\n+     * @throws ServerException if MySQL server responds with an error\n+     * @throws IOException if anything goes wrong while trying to connect\n+     */\n+    public void connect() throws IOException {\n+        connectWithTimeout(connectTimeout);\n+    }\n+\n+    private void connectWithTimeout(final long connectTimeout) throws IOException {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        boolean connected = false;\n+        try {\n+            PacketChannel localChannel;\n+            connectLock.lock();\n+            try {\n+                if (connectLatch != null) {\n+                    throw new IllegalStateException(\"BinaryLogClient is already connected\");\n+                }\n+                connectLatch = latch;\n+                localChannel = openChannelToBinaryLogStream(connectTimeout);\n+                channel = localChannel;\n+                if (keepAlive && !isKeepAliveThreadRunning()) {\n+                    keepAliveThreadExecutor = spawnKeepAliveThread(connectTimeout);\n+                }\n+            } finally {\n+                connectLock.unlock();\n+            }\n+            connected = true;\n+            for (LifecycleListener lifecycleListener : lifecycleListeners) {\n+                lifecycleListener.onConnect(this);\n+            }\n+            ensureEventDeserializerHasRequiredEDDs();\n+            listenForEventPackets(localChannel);\n+        } finally {\n+            connectLock.lock();\n+            try {\n+                latch.countDown();\n+                if (latch == connectLatch) {\n+                    connectLatch = null;\n+                }\n+            } finally {\n+                connectLock.unlock();\n+            }\n+            if (connected) {\n+                for (LifecycleListener lifecycleListener : lifecycleListeners) {\n+                    lifecycleListener.onDisconnect(this);\n+                }\n+            }\n+        }\n+    }\n+\n+    private PacketChannel openChannelToBinaryLogStream(final long connectTimeout) throws IOException {\n+        PacketChannel channel = null;\n+        Callable<Void> cancelCloseChannel = null;\n+        try {\n+            try {\n+                long start = System.currentTimeMillis();\n+                channel = openChannel(connectTimeout);\n+                if (connectTimeout > 0 && !isKeepAliveThreadRunning()) {\n+                    cancelCloseChannel = scheduleCloseChannel(channel, connectTimeout -\n+                        (System.currentTimeMillis() - start));\n+                }\n+                if (channel.getInputStream().peek() == -1) {\n+                    throw new EOFException();\n+                }\n+            } catch (IOException e) {\n+                throw new IOException(\"Failed to connect to MySQL on \" + hostname + \":\" + port +\n+                    \". Please make sure it's running.\", e);\n+            }\n+            GreetingPacket greetingPacket = receiveGreeting(channel);\n+            authenticate(channel, greetingPacket);\n+            connectionId = greetingPacket.getThreadId();\n+            if (\"\".equals(binlogFilename)) {\n+                synchronized (gtidSetAccessLock) {\n+                    if (gtidSet != null && \"\".equals(gtidSet.toString()) && gtidSetFallbackToPurged) {\n+                        gtidSet = new GtidSet(fetchGtidPurged(channel));\n+                    }\n+                }\n+            }\n+            if (binlogFilename == null) {\n+                fetchBinlogFilenameAndPosition(channel);\n+            }\n+            if (binlogPosition < 4) {\n+                if (logger.isLoggable(Level.WARNING)) {\n+                    logger.warning(\"Binary log position adjusted from \" + binlogPosition + \" to \" + 4);\n+                }\n+                binlogPosition = 4;\n+            }\n+            ChecksumType checksumType = fetchBinlogChecksum(channel);\n+            if (checksumType != ChecksumType.NONE) {\n+                confirmSupportOfChecksum(channel, checksumType);\n+            }\n+            if (heartbeatInterval > 0) {\n+                enableHeartbeat(channel);\n+            }\n+            gtid = null;\n+            tx = false;\n+            requestBinaryLogStream(channel);\n+        } catch (IOException e) {\n+            closeChannel(channel);\n+            throw e;\n+        } finally {\n+            if (cancelCloseChannel != null) {\n+                try {\n+                    cancelCloseChannel.call();\n+                } catch (Exception e) {\n+                    if (logger.isLoggable(Level.WARNING)) {\n+                        logger.warning(\"\\\"\" + e.getMessage() +\n+                            \"\\\" was thrown while canceling scheduled disconnect call\");\n+                    }\n+                }\n+            }\n+        }\n+        connected = true;\n+        if (logger.isLoggable(Level.INFO)) {\n+            String position;\n+            synchronized (gtidSetAccessLock) {\n+                position = gtidSet != null ? gtidSet.toString() : binlogFilename + \"/\" + binlogPosition;\n+            }\n+            logger.info(\"Connected to \" + hostname + \":\" + port + \" at \" + position +\n+                \" (\" + (blocking ? \"sid:\" + serverId + \", \" : \"\") + \"cid:\" + connectionId + \")\");\n+        }\n+        return channel;\n+    }\n+\n+    private void ensureEventDeserializerHasRequiredEDDs() {\n+        ensureEventDataDeserializerIfPresent(EventType.ROTATE, RotateEventDataDeserializer.class);\n+        synchronized (gtidSetAccessLock) {\n+            if (gtidSet != null) {\n+                ensureEventDataDeserializerIfPresent(EventType.GTID, GtidEventDataDeserializer.class);\n+                ensureEventDataDeserializerIfPresent(EventType.QUERY, QueryEventDataDeserializer.class);\n+            }\n+        }\n+    }\n+\n+    private PacketChannel openChannel(final long connectTimeout) throws IOException {\n+        Socket socket = socketFactory != null ? socketFactory.createSocket() : new Socket();\n+        socket.connect(new InetSocketAddress(hostname, port), (int) connectTimeout);\n+        return new PacketChannel(socket);\n+    }\n+\n+    private Callable<Void> scheduleCloseChannel(final PacketChannel channel, final long timeout) {\n+        final CountDownLatch connectLatch = new CountDownLatch(1);\n+        final Thread thread = newNamedThread(new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    connectLatch.await(timeout, TimeUnit.MILLISECONDS);\n+                } catch (InterruptedException e) {\n+                    if (logger.isLoggable(Level.WARNING)) {\n+                        logger.log(Level.WARNING, e.getMessage());\n+                    }\n+                }\n+                if (connectLatch.getCount() != 0) {\n+                    if (logger.isLoggable(Level.WARNING)) {\n+                        logger.warning(\"Failed to establish connection in \" + timeout + \"ms. \" +\n+                            \"Forcing disconnect.\");\n+                    }\n+                    try {\n+                        closeChannel(channel);\n+                    } catch (IOException e) {\n+                        if (logger.isLoggable(Level.WARNING)) {\n+                            logger.log(Level.WARNING, e.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        }, \"blc-disconnect-\" + hostname + \":\" + port);\n+        thread.start();\n+        return new Callable<Void>() {\n+\n+            public Void call() throws Exception {\n+                connectLatch.countDown();\n+                thread.join();\n+                return null;\n+            }\n+        };\n+    }\n+\n+    private GreetingPacket receiveGreeting(final PacketChannel channel) throws IOException {\n+        byte[] initialHandshakePacket = channel.read();\n+        if (initialHandshakePacket[0] == (byte) 0xFF /* error */) {\n+            byte[] bytes = Arrays.copyOfRange(initialHandshakePacket, 1, initialHandshakePacket.length);\n+            ErrorPacket errorPacket = new ErrorPacket(bytes);\n+            throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n+                errorPacket.getSqlState());\n+        }\n+        return new GreetingPacket(initialHandshakePacket);\n+    }\n+\n+    private void enableHeartbeat(final PacketChannel channel) throws IOException {\n+        channel.write(new QueryCommand(\"set @master_heartbeat_period=\" + heartbeatInterval * 1000000));\n+        byte[] statementResult = channel.read();\n+        if (statementResult[0] == (byte) 0xFF /* error */) {\n+            byte[] bytes = Arrays.copyOfRange(statementResult, 1, statementResult.length);\n+            ErrorPacket errorPacket = new ErrorPacket(bytes);\n+            throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n+                errorPacket.getSqlState());\n+        }\n+    }\n+\n+    private void requestBinaryLogStream(final PacketChannel channel) throws IOException {\n+        long serverId = blocking ? this.serverId : 0; // http://bugs.mysql.com/bug.php?id=71178\n+        Command dumpBinaryLogCommand;\n+        synchronized (gtidSetAccessLock) {\n+            if (gtidSet != null) {\n+                dumpBinaryLogCommand = new DumpBinaryLogGtidCommand(serverId,\n+                    useBinlogFilenamePositionInGtidMode ? binlogFilename : \"\",\n+                    useBinlogFilenamePositionInGtidMode ? binlogPosition : 4,\n+                    gtidSet);\n+            } else {\n+                dumpBinaryLogCommand = new DumpBinaryLogCommand(serverId, binlogFilename, binlogPosition);\n+            }\n+        }\n+        channel.write(dumpBinaryLogCommand);\n+    }\n+\n+    private void ensureEventDataDeserializerIfPresent(EventType eventType,\n+                                                      Class<? extends EventDataDeserializer<?>> eventDataDeserializerClass) {\n+        EventDataDeserializer<?> eventDataDeserializer = eventDeserializer.getEventDataDeserializer(eventType);\n+        if (eventDataDeserializer.getClass() != eventDataDeserializerClass &&\n+            eventDataDeserializer.getClass() != EventDataWrapper.Deserializer.class) {\n+            EventDataDeserializer<?> internalEventDataDeserializer;\n+            try {\n+                internalEventDataDeserializer = eventDataDeserializerClass.newInstance();\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+            eventDeserializer.setEventDataDeserializer(eventType,\n+                new EventDataWrapper.Deserializer(internalEventDataDeserializer,\n+                    eventDataDeserializer));\n+        }\n+    }\n+\n+    private void authenticate(final PacketChannel channel, GreetingPacket greetingPacket) throws IOException {\n+        int collation = greetingPacket.getServerCollation();\n+        int packetNumber = 1;\n+\n+        boolean usingSSLSocket = false;\n+        if (sslMode != SSLMode.DISABLED) {\n+            boolean serverSupportsSSL = (greetingPacket.getServerCapabilities() & ClientCapabilities.SSL) != 0;\n+            if (!serverSupportsSSL && (sslMode == SSLMode.REQUIRED || sslMode == SSLMode.VERIFY_CA ||\n+                sslMode == SSLMode.VERIFY_IDENTITY)) {\n+                throw new IOException(\"MySQL server does not support SSL\");\n+            }\n+            if (serverSupportsSSL) {\n+                SSLRequestCommand sslRequestCommand = new SSLRequestCommand();\n+                sslRequestCommand.setCollation(collation);\n+                channel.write(sslRequestCommand, packetNumber++);\n+                SSLSocketFactory sslSocketFactory =\n+                    this.sslSocketFactory != null ?\n+                        this.sslSocketFactory :\n+                        sslMode == SSLMode.REQUIRED || sslMode == SSLMode.PREFERRED ?\n+                            DEFAULT_REQUIRED_SSL_MODE_SOCKET_FACTORY :\n+                            DEFAULT_VERIFY_CA_SSL_MODE_SOCKET_FACTORY;\n+                channel.upgradeToSSL(sslSocketFactory, null);\n+                usingSSLSocket = true;\n+            }\n+        }\n+        AuthenticateCommand authenticateCommand = new AuthenticateCommand(schema, username, password,\n+            greetingPacket.getScramble());\n+        authenticateCommand.setCollation(collation);\n+        channel.write(authenticateCommand, packetNumber);\n+        byte[] authenticationResult = channel.read();\n+        if (authenticationResult[0] != (byte) 0x00 /* ok */) {\n+            if (authenticationResult[0] == (byte) 0xFF /* error */) {\n+                byte[] bytes = Arrays.copyOfRange(authenticationResult, 1, authenticationResult.length);\n+                ErrorPacket errorPacket = new ErrorPacket(bytes);\n+                throw new AuthenticationException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n+                    errorPacket.getSqlState());\n+            } else if (authenticationResult[0] == (byte) 0xFE) {\n+                switchAuthentication(channel, authenticationResult, usingSSLSocket);\n+            } else {\n+                throw new AuthenticationException(\"Unexpected authentication result (\" + authenticationResult[0] + \")\");\n+            }\n+        }\n+    }\n+\n+    private void switchAuthentication(final PacketChannel channel, byte[] authenticationResult, boolean usingSSLSocket)\n+        throws IOException {\n+        /*\n+            Azure-MySQL likes to tell us to switch authentication methods, even though\n+            we haven't advertised that we support any.  It uses this for some-odd\n+            reason to send the real password scramble.\n+        */\n+        ByteArrayInputStream buffer = new ByteArrayInputStream(authenticationResult);\n+        //noinspection ResultOfMethodCallIgnored\n+        buffer.read(1);\n+\n+        String authName = buffer.readZeroTerminatedString();\n+        if (\"mysql_native_password\".equals(authName)) {\n+            String scramble = buffer.readZeroTerminatedString();\n+\n+            Command switchCommand = new AuthenticateNativePasswordCommand(scramble, password);\n+            channel.write(switchCommand, (usingSSLSocket ? 4 : 3));\n+            byte[] authResult = channel.read();\n+\n+            if (authResult[0] != (byte) 0x00) {\n+                byte[] bytes = Arrays.copyOfRange(authResult, 1, authResult.length);\n+                ErrorPacket errorPacket = new ErrorPacket(bytes);\n+                throw new AuthenticationException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n+                    errorPacket.getSqlState());\n+            }\n+        } else {\n+            throw new AuthenticationException(\"Unsupported authentication type: \" + authName);\n+        }\n+    }\n+\n+    private ExecutorService spawnKeepAliveThread(final long connectTimeout) {\n+        final ExecutorService threadExecutor =\n+            Executors.newSingleThreadExecutor(new ThreadFactory() {\n+\n+                @Override\n+                public Thread newThread(Runnable runnable) {\n+                    return newNamedThread(runnable, \"blc-keepalive-\" + hostname + \":\" + port);\n+                }\n+            });\n+        threadExecutor.submit(new Runnable() {\n+            @Override\n+            public void run() {\n+                connectLock.lock(); // wait for connect() to finish initialization sequence\n+                connectLock.unlock();\n+                while (!threadExecutor.isShutdown()) {\n+                    try {\n+                        //noinspection BusyWait\n+                        Thread.sleep(keepAliveInterval);\n+                    } catch (InterruptedException e) {\n+                        // expected in case of disconnect\n+                    }\n+                    if (threadExecutor.isShutdown()) {\n+                        return;\n+                    }\n+                    boolean connectionLost = false;\n+                    if (heartbeatInterval > 0) {\n+                        connectionLost = System.currentTimeMillis() - eventLastSeen > keepAliveInterval;\n+                    } else {\n+                        try {\n+                            channel.write(new PingCommand());\n+                        } catch (IOException e) {\n+                            connectionLost = true;\n+                        }\n+                    }\n+                    if (connectionLost) {\n+                        if (logger.isLoggable(Level.INFO)) {\n+                            logger.info(\"Trying to restore lost connection to \" + hostname + \":\" + port);\n+                        }\n+                        try {\n+                            terminateConnect();\n+                            connect(connectTimeout);\n+                        } catch (Exception ce) {\n+                            if (logger.isLoggable(Level.WARNING)) {\n+                                logger.warning(\"Failed to restore connection to \" + hostname + \":\" + port +\n+                                    \". Next attempt in \" + keepAliveInterval + \"ms\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        });\n+        return threadExecutor;\n+    }\n+\n+    private Thread newNamedThread(Runnable runnable, String threadName) {\n+        Thread thread = threadFactory == null ? new Thread(runnable) : threadFactory.newThread(runnable);\n+        thread.setName(threadName);\n+        return thread;\n+    }\n+\n+    boolean isKeepAliveThreadRunning() {\n+        return keepAliveThreadExecutor != null && !keepAliveThreadExecutor.isShutdown();\n+    }\n+\n+    /**\n+     * Connect to the replication stream in a separate thread.\n+     * @param timeout timeout in milliseconds\n+     * @throws AuthenticationException if authentication fails\n+     * @throws ServerException if MySQL server responds with an error\n+     * @throws IOException if anything goes wrong while trying to connect\n+     * @throws TimeoutException if client was unable to connect within given time limit\n+     */\n+    public void connect(final long timeout) throws IOException, TimeoutException {\n+        final CountDownLatch countDownLatch = new CountDownLatch(1);\n+        AbstractLifecycleListener connectListener = new AbstractLifecycleListener() {\n+            @Override\n+            public void onConnect(BinaryLogClient client) {\n+                countDownLatch.countDown();\n+            }\n+        };\n+        registerLifecycleListener(connectListener);\n+        final AtomicReference<IOException> exceptionReference = new AtomicReference<IOException>();\n+        Runnable runnable = new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                try {\n+                    connectWithTimeout(timeout);\n+                } catch (IOException e) {\n+                    exceptionReference.set(e);\n+                    countDownLatch.countDown(); // making sure we don't end up waiting whole \"timeout\"\n+                }\n+            }\n+        };\n+        newNamedThread(runnable, \"blc-\" + hostname + \":\" + port).start();\n+        boolean started = false;\n+        try {\n+            started = countDownLatch.await(timeout, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException e) {\n+            if (logger.isLoggable(Level.WARNING)) {\n+                logger.log(Level.WARNING, e.getMessage());\n+            }\n+        }\n+        unregisterLifecycleListener(connectListener);\n+        if (exceptionReference.get() != null) {\n+            throw exceptionReference.get();\n+        }\n+        if (!started) {\n+            try {\n+                // NOTE: we don't call disconnect here and so if client is able to connect right after timeout expires -\n+                // keep-alive thread may be left running.\n+                terminateConnect();\n+            } catch (IOException e) {\n+                if (logger.isLoggable(Level.WARNING)) {\n+                    logger.warning(\"\\\"\" + e.getMessage() +\n+                        \"\\\" was thrown while terminating connection due to timeout\");\n+                }\n+            }\n+            throw new TimeoutException(\"BinaryLogClient was unable to connect in \" + timeout + \"ms\");\n+        }\n+    }\n+\n+    /**\n+     * @return true if client is connected, false otherwise\n+     */\n+    public boolean isConnected() {\n+        return connectLatch != null;\n+    }\n+\n+    private String fetchGtidPurged(final PacketChannel channel) throws IOException {\n+        channel.write(new QueryCommand(\"show global variables like 'gtid_purged'\"));\n+        ResultSetRowPacket[] resultSet = readResultSet(channel);\n+        if (resultSet.length != 0) {\n+            return resultSet[0].getValue(1).toUpperCase();\n+        }\n+        return \"\";\n+    }\n+\n+    private void fetchBinlogFilenameAndPosition(final PacketChannel channel) throws IOException {\n+        channel.write(new QueryCommand(\"show master status\"));\n+        ResultSetRowPacket[] resultSet = readResultSet(channel);\n+        if (resultSet.length == 0) {\n+            throw new IOException(\"Failed to determine binlog filename/position\");\n+        }\n+        ResultSetRowPacket resultSetRow = resultSet[0];\n+        binlogFilename = resultSetRow.getValue(0);\n+        binlogPosition = Long.parseLong(resultSetRow.getValue(1));\n+    }\n+\n+    protected ChecksumType fetchBinlogChecksum(final PacketChannel channel) throws IOException {\n+        channel.write(new QueryCommand(\"show global variables like 'binlog_checksum'\"));\n+        ResultSetRowPacket[] resultSet = readResultSet(channel);\n+        if (resultSet.length == 0) {\n+            return ChecksumType.NONE;\n+        }\n+        return ChecksumType.valueOf(resultSet[0].getValue(1).toUpperCase());\n+    }\n+\n+    private void confirmSupportOfChecksum(final PacketChannel channel, ChecksumType checksumType) throws IOException {\n+        channel.write(new QueryCommand(\"set @master_binlog_checksum= @@global.binlog_checksum\"));\n+        byte[] statementResult = channel.read();\n+        if (statementResult[0] == (byte) 0xFF /* error */) {\n+            byte[] bytes = Arrays.copyOfRange(statementResult, 1, statementResult.length);\n+            ErrorPacket errorPacket = new ErrorPacket(bytes);\n+            throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n+                errorPacket.getSqlState());\n+        }\n+        eventDeserializer.setChecksumType(checksumType);\n+    }\n+\n+    private void listenForEventPackets(final PacketChannel channel) throws IOException {\n+        ByteArrayInputStream inputStream = channel.getInputStream();\n+        boolean completeShutdown = false;\n+        try {\n+            while (!abortRequest && inputStream.peek() != -1) {\n+                int packetLength = inputStream.readInteger(3);\n+                //noinspection ResultOfMethodCallIgnored\n+                inputStream.skip(1); // 1 byte for sequence\n+                int marker = inputStream.read();\n+                if (marker == 0xFF) {\n+                    ErrorPacket errorPacket = new ErrorPacket(inputStream.read(packetLength - 1));\n+                    throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n+                        errorPacket.getSqlState());\n+                }\n+                if (marker == 0xFE && !blocking) {\n+                    completeShutdown = true;\n+                    break;\n+                }\n+                Event event;\n+                try {\n+                    event = eventDeserializer.nextEvent(packetLength == MAX_PACKET_LENGTH ?\n+                        new ByteArrayInputStream(readPacketSplitInChunks(inputStream, packetLength - 1)) :\n+                        inputStream);\n+                    if (event == null) {\n+                        throw new EOFException();\n+                    }\n+                } catch (Exception e) {\n+                    Throwable cause = e instanceof EventDataDeserializationException ? e.getCause() : e;\n+                    if (cause instanceof EOFException || cause instanceof SocketException) {\n+                        throw e;\n+                    }\n+                    if (connected) {\n+                        for (LifecycleListener lifecycleListener : lifecycleListeners) {\n+                            lifecycleListener.onEventDeserializationFailure(this, e);\n+                        }\n+                    }\n+                    continue;\n+                }\n+                if (connected) {\n+                    eventLastSeen = System.currentTimeMillis();\n+                    updateGtidSet(event);\n+                    notifyEventListeners(event);\n+                    updateClientBinlogFilenameAndPosition(event);\n+                }\n+            }\n+        } catch (Exception e) {\n+            if (connected) {\n+                for (LifecycleListener lifecycleListener : lifecycleListeners) {\n+                    lifecycleListener.onCommunicationFailure(this, e);\n+                }\n+            }\n+        } finally {\n+            abortRequest = false;\n+            if (connected) {\n+                if (completeShutdown) {\n+                    disconnect(); // initiate complete shutdown sequence (which includes keep alive thread)\n+                } else {\n+                    closeChannel(channel);\n+                }\n+            }\n+        }\n+    }\n+\n+    private byte[] readPacketSplitInChunks(ByteArrayInputStream inputStream, int packetLength) throws IOException {\n+        byte[] result = inputStream.read(packetLength);\n+        int chunkLength;\n+        do {\n+            chunkLength = inputStream.readInteger(3);\n+            //noinspection ResultOfMethodCallIgnored\n+            inputStream.skip(1); // 1 byte for sequence\n+            result = Arrays.copyOf(result, result.length + chunkLength);\n+            inputStream.fill(result, result.length - chunkLength, chunkLength);\n+        } while (chunkLength == Packet.MAX_LENGTH);\n+        return result;\n+    }\n+\n+    private void updateClientBinlogFilenameAndPosition(Event event) {\n+        EventHeader eventHeader = event.getHeader();\n+        EventType eventType = eventHeader.getEventType();\n+        if (eventType == EventType.ROTATE) {\n+            RotateEventData rotateEventData = (RotateEventData) EventDataWrapper.internal(event.getData());\n+            binlogFilename = rotateEventData.getBinlogFilename();\n+            binlogPosition = rotateEventData.getBinlogPosition();\n+        } else\n+            // do not update binlogPosition on TABLE_MAP so that in case of reconnect (using a different instance of\n+            // client) table mapping cache could be reconstructed before hitting row mutation event\n+            if (eventType != EventType.TABLE_MAP && eventHeader instanceof EventHeaderV4) {\n+                EventHeaderV4 trackableEventHeader = (EventHeaderV4) eventHeader;\n+                long nextBinlogPosition = trackableEventHeader.getNextPosition();\n+                if (nextBinlogPosition > 0) {\n+                    binlogPosition = nextBinlogPosition;\n+                }\n+            }\n+    }\n+\n+    private void updateGtidSet(Event event) {\n+        synchronized (gtidSetAccessLock) {\n+            if (gtidSet == null) {\n+                return;\n+            }\n+        }\n+        EventHeader eventHeader = event.getHeader();\n+        switch(eventHeader.getEventType()) {\n+            case GTID:\n+                GtidEventData gtidEventData = (GtidEventData) EventDataWrapper.internal(event.getData());\n+                gtid = gtidEventData.getGtid();\n+                break;\n+            case XID:\n+                commitGtid();\n+                tx = false;\n+                break;\n+            case QUERY:\n+                QueryEventData queryEventData = (QueryEventData) EventDataWrapper.internal(event.getData());\n+                String sql = queryEventData.getSql();\n+                if (sql == null) {\n+                    break;\n+                }\n+                if (\"BEGIN\".equals(sql)) {\n+                    tx = true;\n+                } else\n+                if (\"COMMIT\".equals(sql) || \"ROLLBACK\".equals(sql)) {\n+                    commitGtid();\n+                    tx = false;\n+                } else\n+                if (!tx) {\n+                    // auto-commit query, likely DDL\n+                    commitGtid();\n+                }\n+            default:\n+        }\n+    }\n+\n+    private void commitGtid() {\n+        if (gtid != null) {\n+            synchronized (gtidSetAccessLock) {\n+                gtidSet.add(gtid);\n+            }\n+        }\n+    }\n+\n+    protected ResultSetRowPacket[] readResultSet(final PacketChannel channel) throws IOException {\n+        List<ResultSetRowPacket> resultSet = new LinkedList<ResultSetRowPacket>();\n+        byte[] statementResult = channel.read();\n+        if (statementResult[0] == (byte) 0xFF /* error */) {\n+            byte[] bytes = Arrays.copyOfRange(statementResult, 1, statementResult.length);\n+            ErrorPacket errorPacket = new ErrorPacket(bytes);\n+            throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n+                errorPacket.getSqlState());\n+        }\n+        while ((channel.read())[0] != (byte) 0xFE /* eof */) { /* skip */ }\n+        for (byte[] bytes; (bytes = channel.read())[0] != (byte) 0xFE /* eof */; ) {\n+            resultSet.add(new ResultSetRowPacket(bytes));\n+        }\n+        return resultSet.toArray(new ResultSetRowPacket[0]);\n+    }\n+\n+    /**\n+     * @return registered event listeners\n+     */\n+    public List<EventListener> getEventListeners() {\n+        return Collections.unmodifiableList(eventListeners);\n+    }\n+\n+    /**\n+     * Register event listener. Note that multiple event listeners will be called in order they\n+     * where registered.\n+     */\n+    public void registerEventListener(EventListener eventListener) {\n+        eventListeners.add(eventListener);\n+    }\n+\n+    /**\n+     * Unregister all event listener of specific type.\n+     */\n+    public void unregisterEventListener(Class<? extends EventListener> listenerClass) {\n+        for (EventListener eventListener: eventListeners) {\n+            if (listenerClass.isInstance(eventListener)) {\n+                eventListeners.remove(eventListener);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unregister single event listener.\n+     */\n+    public void unregisterEventListener(EventListener eventListener) {\n+        eventListeners.remove(eventListener);\n+    }\n+\n+    private void notifyEventListeners(Event event) {\n+        if (event.getData() instanceof EventDataWrapper) {\n+            event = new Event(event.getHeader(), ((EventDataWrapper) event.getData()).getExternal());\n+        }\n+        for (EventListener eventListener : eventListeners) {\n+            try {\n+                eventListener.onEvent(event);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Binlog event listener \" + eventListener +\n+                    \" choked on \" + event, e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @return registered lifecycle listeners\n+     */\n+    public List<LifecycleListener> getLifecycleListeners() {\n+        return Collections.unmodifiableList(lifecycleListeners);\n+    }\n+\n+    /**\n+     * Register lifecycle listener. Note that multiple lifecycle listeners will be called in order they\n+     * where registered.\n+     */\n+    public void registerLifecycleListener(LifecycleListener lifecycleListener) {\n+        lifecycleListeners.add(lifecycleListener);\n+    }\n+\n+    /**\n+     * Unregister all lifecycle listener of specific type.\n+     */\n+    public void unregisterLifecycleListener(Class<? extends LifecycleListener> listenerClass) {\n+        for (LifecycleListener lifecycleListener : lifecycleListeners) {\n+            if (listenerClass.isInstance(lifecycleListener)) {\n+                lifecycleListeners.remove(lifecycleListener);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unregister single lifecycle listener.\n+     */\n+    public void unregisterLifecycleListener(LifecycleListener eventListener) {\n+        lifecycleListeners.remove(eventListener);\n+    }\n+\n+    /**\n+     * Disconnect from the replication stream.\n+     * Note that this does not reset binlogFilename/binlogPosition. Calling {@link #connect()} or\n+     * {@link #connect(long)}} again resumes client from where it left off.\n+     */\n+    public void disconnect() throws IOException {\n+        connectLock.lock();\n+        ExecutorService keepAliveThreadExecutor = this.keepAliveThreadExecutor;\n+        PacketChannel channel = this.channel;\n+        CountDownLatch connectLatch = this.connectLatch;\n+        connectLock.unlock();\n+\n+        terminateKeepAliveThread(keepAliveThreadExecutor);\n+        closeChannel(channel);\n+        waitForConnectToTerminate(connectLatch);\n+    }\n+\n+    @Override\n+    public void abort() {\n+        abortRequest = true;\n+    }\n+\n+    private void terminateKeepAliveThread(final ExecutorService threadExecutor) {\n+        if (threadExecutor == null) {\n+            return;\n+        }\n+        threadExecutor.shutdownNow();\n+        while (!awaitTerminationInterruptibly(threadExecutor, Long.MAX_VALUE, TimeUnit.NANOSECONDS)) { /* retry */ }\n+    }\n+\n+    @SuppressWarnings(\"SameParameterValue\")\n+    private static boolean awaitTerminationInterruptibly(final ExecutorService executorService,\n+                                                         final long timeout, final TimeUnit unit) {\n+        try {\n+            return executorService.awaitTermination(timeout, unit);\n+        } catch (InterruptedException e) {\n+            return false;\n+        }\n+    }\n+\n+    private void terminateConnect() throws IOException {\n+        connectLock.lock();\n+        PacketChannel channel = this.channel;\n+        CountDownLatch connectLatch = this.connectLatch;\n+        connectLock.unlock();\n+\n+        closeChannel(channel);\n+        waitForConnectToTerminate(connectLatch);\n+    }\n+\n+    private void waitForConnectToTerminate(final CountDownLatch connectLatch) {\n+        if (connectLatch != null) {\n+            while (!awaitInterruptibly(connectLatch, Long.MAX_VALUE, TimeUnit.NANOSECONDS)) { /* retry */ }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"SameParameterValue\")\n+    private static boolean awaitInterruptibly(final CountDownLatch countDownLatch,\n+                                              final long time, final TimeUnit unit) {\n+        try {\n+            return countDownLatch.await(time, unit);\n+        } catch (InterruptedException e) {\n+            return false;\n+        }\n+    }\n+\n+    private void closeChannel(final PacketChannel channel) throws IOException {\n+        connected = false;\n+        if (channel != null && channel.isOpen()) {\n+            channel.close();\n+        }\n+    }\n+}"
  },
  {
    "sha": "f580f3528ad7f5e108fc5a1e5929fd7e78e84d8e",
    "filename": "src/main/java/com/github/shyiko/mysql/binlog/OldBinaryLogClient.java",
    "status": "added",
    "additions": 1230,
    "deletions": 0,
    "changes": 1230,
    "blob_url": "https://github.com/fivetran/mysql-binlog-connector-java/blob/341f8dac8630a52d8989bbeba9a93b370f322d60/src/main/java/com/github/shyiko/mysql/binlog/OldBinaryLogClient.java",
    "raw_url": "https://github.com/fivetran/mysql-binlog-connector-java/raw/341f8dac8630a52d8989bbeba9a93b370f322d60/src/main/java/com/github/shyiko/mysql/binlog/OldBinaryLogClient.java",
    "contents_url": "https://api.github.com/repos/fivetran/mysql-binlog-connector-java/contents/src/main/java/com/github/shyiko/mysql/binlog/OldBinaryLogClient.java?ref=341f8dac8630a52d8989bbeba9a93b370f322d60",
    "patch": "@@ -0,0 +1,1230 @@\n+/*\n+ * Copyright 2013 Stanley Shyiko\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.github.shyiko.mysql.binlog;\n+\n+import com.github.shyiko.mysql.binlog.event.Event;\n+import com.github.shyiko.mysql.binlog.event.EventHeader;\n+import com.github.shyiko.mysql.binlog.event.EventHeaderV4;\n+import com.github.shyiko.mysql.binlog.event.EventType;\n+import com.github.shyiko.mysql.binlog.event.GtidEventData;\n+import com.github.shyiko.mysql.binlog.event.QueryEventData;\n+import com.github.shyiko.mysql.binlog.event.RotateEventData;\n+import com.github.shyiko.mysql.binlog.event.deserialization.ChecksumType;\n+import com.github.shyiko.mysql.binlog.event.deserialization.EventDataDeserializationException;\n+import com.github.shyiko.mysql.binlog.event.deserialization.EventDataDeserializer;\n+import com.github.shyiko.mysql.binlog.event.deserialization.EventDeserializer;\n+import com.github.shyiko.mysql.binlog.event.deserialization.EventDeserializer.EventDataWrapper;\n+import com.github.shyiko.mysql.binlog.event.deserialization.GtidEventDataDeserializer;\n+import com.github.shyiko.mysql.binlog.event.deserialization.QueryEventDataDeserializer;\n+import com.github.shyiko.mysql.binlog.event.deserialization.RotateEventDataDeserializer;\n+import com.github.shyiko.mysql.binlog.io.ByteArrayInputStream;\n+import com.github.shyiko.mysql.binlog.network.AuthenticationException;\n+import com.github.shyiko.mysql.binlog.network.ClientCapabilities;\n+import com.github.shyiko.mysql.binlog.network.DefaultSSLSocketFactory;\n+import com.github.shyiko.mysql.binlog.network.SSLMode;\n+import com.github.shyiko.mysql.binlog.network.SSLSocketFactory;\n+import com.github.shyiko.mysql.binlog.network.ServerException;\n+import com.github.shyiko.mysql.binlog.network.SocketFactory;\n+import com.github.shyiko.mysql.binlog.network.protocol.ErrorPacket;\n+import com.github.shyiko.mysql.binlog.network.protocol.GreetingPacket;\n+import com.github.shyiko.mysql.binlog.network.protocol.Packet;\n+import com.github.shyiko.mysql.binlog.network.protocol.PacketChannel;\n+import com.github.shyiko.mysql.binlog.network.protocol.ResultSetRowPacket;\n+import com.github.shyiko.mysql.binlog.network.protocol.command.AuthenticateCommand;\n+import com.github.shyiko.mysql.binlog.network.protocol.command.AuthenticateNativePasswordCommand;\n+import com.github.shyiko.mysql.binlog.network.protocol.command.Command;\n+import com.github.shyiko.mysql.binlog.network.protocol.command.DumpBinaryLogCommand;\n+import com.github.shyiko.mysql.binlog.network.protocol.command.DumpBinaryLogGtidCommand;\n+import com.github.shyiko.mysql.binlog.network.protocol.command.PingCommand;\n+import com.github.shyiko.mysql.binlog.network.protocol.command.QueryCommand;\n+import com.github.shyiko.mysql.binlog.network.protocol.command.SSLRequestCommand;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.GeneralSecurityException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+\n+/**\n+ * MySQL replication stream client.\n+ *\n+ * @author <a href=\"mailto:stanley.shyiko@gmail.com\">Stanley Shyiko</a>\n+ */\n+public class OldBinaryLogClient extends BinaryLogClient {\n+\n+    private static final SSLSocketFactory DEFAULT_REQUIRED_SSL_MODE_SOCKET_FACTORY = new DefaultSSLSocketFactory() {\n+\n+        @Override\n+        protected void initSSLContext(SSLContext sc) throws GeneralSecurityException {\n+            sc.init(null, new TrustManager[]{\n+                new X509TrustManager() {\n+\n+                    @Override\n+                    public void checkClientTrusted(X509Certificate[] x509Certificates, String s)\n+                        throws CertificateException { }\n+\n+                    @Override\n+                    public void checkServerTrusted(X509Certificate[] x509Certificates, String s)\n+                        throws CertificateException { }\n+\n+                    @Override\n+                    public X509Certificate[] getAcceptedIssuers() {\n+                        return new X509Certificate[0];\n+                    }\n+                }\n+            }, null);\n+        }\n+    };\n+    private static final SSLSocketFactory DEFAULT_VERIFY_CA_SSL_MODE_SOCKET_FACTORY = new DefaultSSLSocketFactory();\n+\n+    // https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html\n+    private static final int MAX_PACKET_LENGTH = 16777215;\n+\n+    private final Logger logger = Logger.getLogger(\"donkey\");\n+\n+    private final String hostname;\n+    private final int port;\n+    private final String schema;\n+    private final String username;\n+    private final String password;\n+\n+    private boolean blocking = true;\n+    private long serverId = 65535;\n+    private volatile String binlogFilename;\n+    private volatile long binlogPosition = 4;\n+    private volatile long connectionId;\n+    private SSLMode sslMode = SSLMode.DISABLED;\n+\n+    private GtidSet gtidSet;\n+    private final Object gtidSetAccessLock = new Object();\n+    private boolean gtidSetFallbackToPurged;\n+    private boolean useBinlogFilenamePositionInGtidMode;\n+    private String gtid;\n+    private boolean tx;\n+\n+    private EventDeserializer eventDeserializer = new EventDeserializer();\n+\n+    private final List<EventListener> eventListeners = new CopyOnWriteArrayList<EventListener>();\n+    private final List<LifecycleListener> lifecycleListeners = new CopyOnWriteArrayList<LifecycleListener>();\n+\n+    private SocketFactory socketFactory;\n+    private SSLSocketFactory sslSocketFactory;\n+\n+    protected volatile PacketChannel channel;\n+    private volatile boolean connected;\n+\n+    private ThreadFactory threadFactory;\n+\n+    private boolean keepAlive = true;\n+    private long keepAliveInterval = TimeUnit.MINUTES.toMillis(1);\n+\n+    private long heartbeatInterval;\n+    private volatile long eventLastSeen;\n+\n+    private long connectTimeout = TimeUnit.SECONDS.toMillis(3);\n+\n+    private volatile ExecutorService keepAliveThreadExecutor;\n+\n+    private final Lock connectLock = new ReentrantLock();\n+    private final Lock keepAliveThreadExecutorLock = new ReentrantLock();\n+\n+    /**\n+     * Alias for BinaryLogClient(\"localhost\", 3306, &lt;no schema&gt; = null, username, password).\n+     * @see OldBinaryLogClient#OldBinaryLogClient(String, int, String, String, String)\n+     */\n+    public OldBinaryLogClient(String username, String password) {\n+        this(\"localhost\", 3306, null, username, password);\n+    }\n+\n+    /**\n+     * Alias for BinaryLogClient(\"localhost\", 3306, schema, username, password).\n+     * @see OldBinaryLogClient#OldBinaryLogClient(String, int, String, String, String)\n+     */\n+    public OldBinaryLogClient(String schema, String username, String password) {\n+        this(\"localhost\", 3306, schema, username, password);\n+    }\n+\n+    /**\n+     * Alias for BinaryLogClient(hostname, port, &lt;no schema&gt; = null, username, password).\n+     * @see OldBinaryLogClient#OldBinaryLogClient(String, int, String, String, String)\n+     */\n+    public OldBinaryLogClient(String hostname, int port, String username, String password) {\n+        this(hostname, port, null, username, password);\n+    }\n+\n+    /**\n+     * @param hostname mysql server hostname\n+     * @param port mysql server port\n+     * @param schema database name, nullable. Note that this parameter has nothing to do with event filtering. It's\n+     * used only during the authentication.\n+     * @param username login name\n+     * @param password password\n+     */\n+    public OldBinaryLogClient(String hostname, int port, String schema, String username, String password) {\n+        this.hostname = hostname;\n+        this.port = port;\n+        this.schema = schema;\n+        this.username = username;\n+        this.password = password;\n+    }\n+\n+    public boolean isBlocking() {\n+        return blocking;\n+    }\n+\n+    /**\n+     * @param blocking blocking mode. If set to false - BinaryLogClient will disconnect after the last event.\n+     */\n+    public void setBlocking(boolean blocking) {\n+        this.blocking = blocking;\n+    }\n+\n+    public SSLMode getSSLMode() {\n+        return sslMode;\n+    }\n+\n+    public void setSSLMode(SSLMode sslMode) {\n+        if (sslMode == null) {\n+            throw new IllegalArgumentException(\"SSL mode cannot be NULL\");\n+        }\n+        this.sslMode = sslMode;\n+    }\n+\n+    /**\n+     * @return server id (65535 by default)\n+     * @see #setServerId(long)\n+     */\n+    public long getServerId() {\n+        return serverId;\n+    }\n+\n+    /**\n+     * @param serverId server id (in the range from 1 to 2^32 - 1). This value MUST be unique across whole replication\n+     * group (that is, different from any other server id being used by any master or slave). Keep in mind that each\n+     * binary log client (mysql-binlog-connector-java/BinaryLogClient, mysqlbinlog, etc) should be treated as a\n+     * simplified slave and thus MUST also use a different server id.\n+     * @see #getServerId()\n+     */\n+    public void setServerId(long serverId) {\n+        this.serverId = serverId;\n+    }\n+\n+    /**\n+     * @return binary log filename, nullable (and null be default). Note that this value is automatically tracked by\n+     * the client and thus is subject to change (in response to {@link EventType#ROTATE}, for example).\n+     * @see #setBinlogFilename(String)\n+     */\n+    public String getBinlogFilename() {\n+        return binlogFilename;\n+    }\n+\n+    /**\n+     * @param binlogFilename binary log filename.\n+     * Special values are:\n+     * <ul>\n+     *   <li>null, which turns on automatic resolution (resulting in the last known binlog and position). This is what\n+     * happens by default when you don't specify binary log filename explicitly.</li>\n+     *   <li>\"\" (empty string), which instructs server to stream events starting from the oldest known binlog.</li>\n+     * </ul>\n+     * @see #getBinlogFilename()\n+     */\n+    public void setBinlogFilename(String binlogFilename) {\n+        this.binlogFilename = binlogFilename;\n+    }\n+\n+    /**\n+     * @return binary log position of the next event, 4 by default (which is a position of first event). Note that this\n+     * value changes with each incoming event.\n+     * @see #setBinlogPosition(long)\n+     */\n+    public long getBinlogPosition() {\n+        return binlogPosition;\n+    }\n+\n+    /**\n+     * @param binlogPosition binary log position. Any value less than 4 gets automatically adjusted to 4 on connect.\n+     * @see #getBinlogPosition()\n+     */\n+    public void setBinlogPosition(long binlogPosition) {\n+        this.binlogPosition = binlogPosition;\n+    }\n+\n+    /**\n+     * @return thread id\n+     */\n+    public long getConnectionId() {\n+        return connectionId;\n+    }\n+\n+    /**\n+     * @return GTID set. Note that this value changes with each received GTID event (provided client is in GTID mode).\n+     * @see #setGtidSet(String)\n+     */\n+    public String getGtidSet() {\n+        synchronized (gtidSetAccessLock) {\n+            return gtidSet != null ? gtidSet.toString() : null;\n+        }\n+    }\n+\n+    /**\n+     * @param gtidSet GTID set (can be an empty string).\n+     * <p>NOTE #1: Any value but null will switch BinaryLogClient into a GTID mode (this will also set binlogFilename\n+     * to \"\" (provided it's null) forcing MySQL to send events starting from the oldest known binlog (keep in mind\n+     * that connection will fail if gtid_purged is anything but empty (unless\n+     * {@link #setGtidSetFallbackToPurged(boolean)} is set to true))).\n+     * <p>NOTE #2: GTID set is automatically updated with each incoming GTID event (provided GTID mode is on).\n+     * @see #getGtidSet()\n+     * @see #setGtidSetFallbackToPurged(boolean)\n+     */\n+    public void setGtidSet(String gtidSet) {\n+        if (gtidSet != null && this.binlogFilename == null) {\n+            this.binlogFilename = \"\";\n+        }\n+        synchronized (gtidSetAccessLock) {\n+            this.gtidSet = gtidSet != null ? new GtidSet(gtidSet) : null;\n+        }\n+    }\n+\n+    /**\n+     * @see #setGtidSetFallbackToPurged(boolean)\n+     */\n+    public boolean isGtidSetFallbackToPurged() {\n+        return gtidSetFallbackToPurged;\n+    }\n+\n+    /**\n+     * @param gtidSetFallbackToPurged true if gtid_purged should be used as a fallback when gtidSet is set to \"\" and\n+     * MySQL server has purged some of the binary logs, false otherwise (default).\n+     */\n+    public void setGtidSetFallbackToPurged(boolean gtidSetFallbackToPurged) {\n+        this.gtidSetFallbackToPurged = gtidSetFallbackToPurged;\n+    }\n+\n+    /**\n+     * @see #setUseBinlogFilenamePositionInGtidMode(boolean)\n+     */\n+    public boolean isUseBinlogFilenamePositionInGtidMode() {\n+        return useBinlogFilenamePositionInGtidMode;\n+    }\n+\n+    /**\n+     * @param useBinlogFilenamePositionInGtidMode true if MySQL server should start streaming events from a given\n+     * {@link #getBinlogFilename()} and {@link #getBinlogPosition()} instead of \"the oldest known binlog\" when\n+     * {@link #getGtidSet()} is set, false otherwise (default).\n+     */\n+    public void setUseBinlogFilenamePositionInGtidMode(boolean useBinlogFilenamePositionInGtidMode) {\n+        this.useBinlogFilenamePositionInGtidMode = useBinlogFilenamePositionInGtidMode;\n+    }\n+\n+    /**\n+     * @return true if \"keep alive\" thread should be automatically started (default), false otherwise.\n+     * @see #setKeepAlive(boolean)\n+     */\n+    public boolean isKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * @param keepAlive true if \"keep alive\" thread should be automatically started (recommended and true by default),\n+     * false otherwise.\n+     * @see #isKeepAlive()\n+     * @see #setKeepAliveInterval(long)\n+     */\n+    public void setKeepAlive(boolean keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    /**\n+     * @return \"keep alive\" interval in milliseconds, 1 minute by default.\n+     * @see #setKeepAliveInterval(long)\n+     */\n+    public long getKeepAliveInterval() {\n+        return keepAliveInterval;\n+    }\n+\n+    /**\n+     * @param keepAliveInterval \"keep alive\" interval in milliseconds.\n+     * @see #getKeepAliveInterval()\n+     * @see #setHeartbeatInterval(long)\n+     */\n+    public void setKeepAliveInterval(long keepAliveInterval) {\n+        this.keepAliveInterval = keepAliveInterval;\n+    }\n+\n+    /**\n+     * @return \"keep alive\" connect timeout in milliseconds.\n+     * @see #setKeepAliveConnectTimeout(long)\n+     *\n+     * @deprecated in favour of {@link #getConnectTimeout()}\n+     */\n+    public long getKeepAliveConnectTimeout() {\n+        return connectTimeout;\n+    }\n+\n+    /**\n+     * @param connectTimeout \"keep alive\" connect timeout in milliseconds.\n+     * @see #getKeepAliveConnectTimeout()\n+    *\n+     * @deprecated in favour of {@link #setConnectTimeout(long)}\n+     */\n+    public void setKeepAliveConnectTimeout(long connectTimeout) {\n+        this.connectTimeout = connectTimeout;\n+    }\n+\n+    /**\n+     * @return heartbeat period in milliseconds (0 if not set (default)).\n+     * @see #setHeartbeatInterval(long)\n+     */\n+    public long getHeartbeatInterval() {\n+        return heartbeatInterval;\n+    }\n+\n+    /**\n+     * @param heartbeatInterval heartbeat period in milliseconds.\n+     * <p>\n+     * If set (recommended)\n+     * <ul>\n+     * <li> HEARTBEAT event will be emitted every \"heartbeatInterval\".\n+     * <li> if {@link #setKeepAlive(boolean)} is on then keepAlive thread will attempt to reconnect if no\n+     *   HEARTBEAT events were received within {@link #setKeepAliveInterval(long)} (instead of trying to send\n+     *   PING every {@link #setKeepAliveInterval(long)}, which is fundamentally flawed -\n+     *   https://github.com/shyiko/mysql-binlog-connector-java/issues/118).\n+     * </ul>\n+     * Note that when used together with keepAlive heartbeatInterval MUST be set less than keepAliveInterval.\n+     *\n+     * @see #getHeartbeatInterval()\n+     */\n+    public void setHeartbeatInterval(long heartbeatInterval) {\n+        this.heartbeatInterval = heartbeatInterval;\n+    }\n+\n+    /**\n+     * @return connect timeout in milliseconds, 3 seconds by default.\n+     * @see #setConnectTimeout(long)\n+     */\n+    public long getConnectTimeout() {\n+        return connectTimeout;\n+    }\n+\n+    /**\n+     * @param connectTimeout connect timeout in milliseconds.\n+     * @see #getConnectTimeout()\n+     */\n+    public void setConnectTimeout(long connectTimeout) {\n+        this.connectTimeout = connectTimeout;\n+    }\n+\n+    /**\n+     * @param eventDeserializer custom event deserializer\n+     */\n+    public void setEventDeserializer(EventDeserializer eventDeserializer) {\n+        if (eventDeserializer == null) {\n+            throw new IllegalArgumentException(\"Event deserializer cannot be NULL\");\n+        }\n+        this.eventDeserializer = eventDeserializer;\n+    }\n+\n+    /**\n+     * @param socketFactory custom socket factory. If not provided, socket will be created with \"new Socket()\".\n+     */\n+    public void setSocketFactory(SocketFactory socketFactory) {\n+        this.socketFactory = socketFactory;\n+    }\n+\n+    /**\n+     * @param sslSocketFactory custom ssl socket factory\n+     */\n+    public void setSslSocketFactory(SSLSocketFactory sslSocketFactory) {\n+        this.sslSocketFactory = sslSocketFactory;\n+    }\n+\n+    /**\n+     * @param threadFactory custom thread factory. If not provided, threads will be created using simple \"new Thread()\".\n+     */\n+    public void setThreadFactory(ThreadFactory threadFactory) {\n+        this.threadFactory = threadFactory;\n+    }\n+\n+    /**\n+     * Connect to the replication stream. Note that this method blocks until disconnected.\n+     * @throws AuthenticationException if authentication fails\n+     * @throws ServerException if MySQL server responds with an error\n+     * @throws IOException if anything goes wrong while trying to connect\n+     */\n+    public void connect() throws IOException {\n+        if (!connectLock.tryLock()) {\n+            throw new IllegalStateException(\"BinaryLogClient is already connected\");\n+        }\n+        boolean notifyWhenDisconnected = false;\n+        try {\n+            Callable cancelDisconnect = null;\n+            try {\n+                try {\n+                    long start = System.currentTimeMillis();\n+                    channel = openChannel();\n+                    if (connectTimeout > 0 && !isKeepAliveThreadRunning()) {\n+                        cancelDisconnect = scheduleDisconnectIn(connectTimeout -\n+                            (System.currentTimeMillis() - start));\n+                    }\n+                    if (channel.getInputStream().peek() == -1) {\n+                        throw new EOFException();\n+                    }\n+                } catch (IOException e) {\n+                    throw new IOException(\"Failed to connect to MySQL on \" + hostname + \":\" + port +\n+                        \". Please make sure it's running.\", e);\n+                }\n+                GreetingPacket greetingPacket = receiveGreeting();\n+                authenticate(greetingPacket);\n+                connectionId = greetingPacket.getThreadId();\n+                if (\"\".equals(binlogFilename)) {\n+                    synchronized (gtidSetAccessLock) {\n+                        if (gtidSet != null && \"\".equals(gtidSet.toString()) && gtidSetFallbackToPurged) {\n+                            gtidSet = new GtidSet(fetchGtidPurged());\n+                        }\n+                    }\n+                }\n+                if (binlogFilename == null) {\n+                    fetchBinlogFilenameAndPosition();\n+                }\n+                if (binlogPosition < 4) {\n+                    if (logger.isLoggable(Level.WARNING)) {\n+                        logger.warning(\"Binary log position adjusted from \" + binlogPosition + \" to \" + 4);\n+                    }\n+                    binlogPosition = 4;\n+                }\n+                ChecksumType checksumType = fetchBinlogChecksum();\n+                if (checksumType != ChecksumType.NONE) {\n+                    confirmSupportOfChecksum(checksumType);\n+                }\n+                if (heartbeatInterval > 0) {\n+                    enableHeartbeat();\n+                }\n+                gtid = null;\n+                tx = false;\n+                requestBinaryLogStream();\n+            } catch (IOException e) {\n+                disconnectChannel();\n+                throw e;\n+            } finally {\n+                if (cancelDisconnect != null) {\n+                    try {\n+                        cancelDisconnect.call();\n+                    } catch (Exception e) {\n+                        if (logger.isLoggable(Level.WARNING)) {\n+                            logger.warning(\"\\\"\" + e.getMessage() +\n+                                \"\\\" was thrown while canceling scheduled disconnect call\");\n+                        }\n+                    }\n+                }\n+            }\n+            connected = true;\n+            notifyWhenDisconnected = true;\n+            if (logger.isLoggable(Level.INFO)) {\n+                String position;\n+                synchronized (gtidSetAccessLock) {\n+                    position = gtidSet != null ? gtidSet.toString() : binlogFilename + \"/\" + binlogPosition;\n+                }\n+                logger.info(\"Connected to \" + hostname + \":\" + port + \" at \" + position +\n+                    \" (\" + (blocking ? \"sid:\" + serverId + \", \" : \"\") + \"cid:\" + connectionId + \")\");\n+            }\n+            for (LifecycleListener lifecycleListener : lifecycleListeners) {\n+                lifecycleListener.onConnect(this);\n+            }\n+            if (keepAlive && !isKeepAliveThreadRunning()) {\n+                spawnKeepAliveThread();\n+            }\n+            ensureEventDataDeserializer(EventType.ROTATE, RotateEventDataDeserializer.class);\n+            synchronized (gtidSetAccessLock) {\n+                if (gtidSet != null) {\n+                    ensureEventDataDeserializer(EventType.GTID, GtidEventDataDeserializer.class);\n+                    ensureEventDataDeserializer(EventType.QUERY, QueryEventDataDeserializer.class);\n+                }\n+            }\n+            listenForEventPackets();\n+        } finally {\n+            connectLock.unlock();\n+            if (notifyWhenDisconnected) {\n+                for (LifecycleListener lifecycleListener : lifecycleListeners) {\n+                    lifecycleListener.onDisconnect(this);\n+                }\n+            }\n+        }\n+    }\n+\n+    private PacketChannel openChannel() throws IOException {\n+        Socket socket = socketFactory != null ? socketFactory.createSocket() : new Socket();\n+        socket.connect(new InetSocketAddress(hostname, port), (int) connectTimeout);\n+        return new PacketChannel(socket);\n+    }\n+\n+    private Callable scheduleDisconnectIn(final long timeout) {\n+        final OldBinaryLogClient self = this;\n+        final CountDownLatch connectLatch = new CountDownLatch(1);\n+        final Thread thread = newNamedThread(new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    connectLatch.await(timeout, TimeUnit.MILLISECONDS);\n+                } catch (InterruptedException e) {\n+                    if (logger.isLoggable(Level.WARNING)) {\n+                        logger.log(Level.WARNING, e.getMessage());\n+                    }\n+                }\n+                if (connectLatch.getCount() != 0) {\n+                    if (logger.isLoggable(Level.WARNING)) {\n+                        logger.warning(\"Failed to establish connection in \" + timeout + \"ms. \" +\n+                            \"Forcing disconnect.\");\n+                    }\n+                    try {\n+                        self.disconnectChannel();\n+                    } catch (IOException e) {\n+                        if (logger.isLoggable(Level.WARNING)) {\n+                            logger.log(Level.WARNING, e.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        }, \"blc-disconnect-\" + hostname + \":\" + port);\n+        thread.start();\n+        return new Callable() {\n+\n+            public Object call() throws Exception {\n+                connectLatch.countDown();\n+                thread.join();\n+                return null;\n+            }\n+        };\n+    }\n+\n+    private GreetingPacket receiveGreeting() throws IOException {\n+        byte[] initialHandshakePacket = channel.read();\n+        if (initialHandshakePacket[0] == (byte) 0xFF /* error */) {\n+            byte[] bytes = Arrays.copyOfRange(initialHandshakePacket, 1, initialHandshakePacket.length);\n+            ErrorPacket errorPacket = new ErrorPacket(bytes);\n+            throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n+                    errorPacket.getSqlState());\n+        }\n+        return new GreetingPacket(initialHandshakePacket);\n+    }\n+\n+    private void enableHeartbeat() throws IOException {\n+        channel.write(new QueryCommand(\"set @master_heartbeat_period=\" + heartbeatInterval * 1000000));\n+        byte[] statementResult = channel.read();\n+        if (statementResult[0] == (byte) 0xFF /* error */) {\n+            byte[] bytes = Arrays.copyOfRange(statementResult, 1, statementResult.length);\n+            ErrorPacket errorPacket = new ErrorPacket(bytes);\n+            throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n+                errorPacket.getSqlState());\n+        }\n+    }\n+\n+    private void requestBinaryLogStream() throws IOException {\n+        long serverId = blocking ? this.serverId : 0; // http://bugs.mysql.com/bug.php?id=71178\n+        Command dumpBinaryLogCommand;\n+        synchronized (gtidSetAccessLock) {\n+            if (gtidSet != null) {\n+                dumpBinaryLogCommand = new DumpBinaryLogGtidCommand(serverId,\n+                    useBinlogFilenamePositionInGtidMode ? binlogFilename : \"\",\n+                    useBinlogFilenamePositionInGtidMode ? binlogPosition : 4,\n+                    gtidSet);\n+            } else {\n+                dumpBinaryLogCommand = new DumpBinaryLogCommand(serverId, binlogFilename, binlogPosition);\n+            }\n+        }\n+        channel.write(dumpBinaryLogCommand);\n+    }\n+\n+    private void ensureEventDataDeserializer(EventType eventType,\n+             Class<? extends EventDataDeserializer> eventDataDeserializerClass) {\n+        EventDataDeserializer eventDataDeserializer = eventDeserializer.getEventDataDeserializer(eventType);\n+        if (eventDataDeserializer.getClass() != eventDataDeserializerClass &&\n+            eventDataDeserializer.getClass() != EventDataWrapper.Deserializer.class) {\n+            EventDataDeserializer internalEventDataDeserializer;\n+            try {\n+                internalEventDataDeserializer = eventDataDeserializerClass.newInstance();\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+            eventDeserializer.setEventDataDeserializer(eventType,\n+                new EventDataWrapper.Deserializer(internalEventDataDeserializer,\n+                    eventDataDeserializer));\n+        }\n+    }\n+\n+    private void authenticate(GreetingPacket greetingPacket) throws IOException {\n+        int collation = greetingPacket.getServerCollation();\n+        int packetNumber = 1;\n+\n+        boolean usingSSLSocket = false;\n+        if (sslMode != SSLMode.DISABLED) {\n+            boolean serverSupportsSSL = (greetingPacket.getServerCapabilities() & ClientCapabilities.SSL) != 0;\n+            if (!serverSupportsSSL && (sslMode == SSLMode.REQUIRED || sslMode == SSLMode.VERIFY_CA ||\n+                sslMode == SSLMode.VERIFY_IDENTITY)) {\n+                throw new IOException(\"MySQL server does not support SSL\");\n+            }\n+            if (serverSupportsSSL) {\n+                SSLRequestCommand sslRequestCommand = new SSLRequestCommand();\n+                sslRequestCommand.setCollation(collation);\n+                channel.write(sslRequestCommand, packetNumber++);\n+                SSLSocketFactory sslSocketFactory =\n+                    this.sslSocketFactory != null ?\n+                        this.sslSocketFactory :\n+                        sslMode == SSLMode.REQUIRED || sslMode == SSLMode.PREFERRED ?\n+                            DEFAULT_REQUIRED_SSL_MODE_SOCKET_FACTORY :\n+                            DEFAULT_VERIFY_CA_SSL_MODE_SOCKET_FACTORY;\n+                channel.upgradeToSSL(sslSocketFactory, null);\n+                usingSSLSocket = true;\n+            }\n+        }\n+        AuthenticateCommand authenticateCommand = new AuthenticateCommand(schema, username, password,\n+            greetingPacket.getScramble());\n+        authenticateCommand.setCollation(collation);\n+        channel.write(authenticateCommand, packetNumber);\n+        byte[] authenticationResult = channel.read();\n+        if (authenticationResult[0] != (byte) 0x00 /* ok */) {\n+            if (authenticationResult[0] == (byte) 0xFF /* error */) {\n+                byte[] bytes = Arrays.copyOfRange(authenticationResult, 1, authenticationResult.length);\n+                ErrorPacket errorPacket = new ErrorPacket(bytes);\n+                throw new AuthenticationException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n+                    errorPacket.getSqlState());\n+            } else if (authenticationResult[0] == (byte) 0xFE) {\n+                switchAuthentication(authenticationResult, usingSSLSocket);\n+            } else {\n+                throw new AuthenticationException(\"Unexpected authentication result (\" + authenticationResult[0] + \")\");\n+            }\n+        }\n+    }\n+\n+    private void switchAuthentication(byte[] authenticationResult, boolean usingSSLSocket) throws IOException {\n+        /*\n+            Azure-MySQL likes to tell us to switch authentication methods, even though\n+            we haven't advertised that we support any.  It uses this for some-odd\n+            reason to send the real password scramble.\n+        */\n+        ByteArrayInputStream buffer = new ByteArrayInputStream(authenticationResult);\n+        buffer.read(1);\n+\n+        String authName = buffer.readZeroTerminatedString();\n+        if (\"mysql_native_password\".equals(authName)) {\n+            String scramble = buffer.readZeroTerminatedString();\n+\n+            Command switchCommand = new AuthenticateNativePasswordCommand(scramble, password);\n+            channel.write(switchCommand, (usingSSLSocket ? 4 : 3));\n+            byte[] authResult = channel.read();\n+\n+            if (authResult[0] != (byte) 0x00) {\n+                byte[] bytes = Arrays.copyOfRange(authResult, 1, authResult.length);\n+                ErrorPacket errorPacket = new ErrorPacket(bytes);\n+                throw new AuthenticationException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n+                    errorPacket.getSqlState());\n+            }\n+        } else {\n+            throw new AuthenticationException(\"Unsupported authentication type: \" + authName);\n+        }\n+    }\n+\n+    private void spawnKeepAliveThread() {\n+        final ExecutorService threadExecutor =\n+            Executors.newSingleThreadExecutor(new ThreadFactory() {\n+\n+                @Override\n+                public Thread newThread(Runnable runnable) {\n+                    return newNamedThread(runnable, \"blc-keepalive-\" + hostname + \":\" + port);\n+                }\n+            });\n+        try {\n+            keepAliveThreadExecutorLock.lock();\n+            threadExecutor.submit(new Runnable() {\n+                @Override\n+                public void run() {\n+                    while (!threadExecutor.isShutdown()) {\n+                        try {\n+                            Thread.sleep(keepAliveInterval);\n+                        } catch (InterruptedException e) {\n+                            // expected in case of disconnect\n+                        }\n+                        if (threadExecutor.isShutdown()) {\n+                            return;\n+                        }\n+                        boolean connectionLost = false;\n+                        if (heartbeatInterval > 0) {\n+                            connectionLost = System.currentTimeMillis() - eventLastSeen > keepAliveInterval;\n+                        } else {\n+                            try {\n+                                channel.write(new PingCommand());\n+                            } catch (IOException e) {\n+                                connectionLost = true;\n+                            }\n+                        }\n+                        if (connectionLost) {\n+                            if (logger.isLoggable(Level.INFO)) {\n+                                logger.info(\"Trying to restore lost connection to \" + hostname + \":\" + port);\n+                            }\n+                            try {\n+                                terminateConnect();\n+                                connect(connectTimeout);\n+                            } catch (Exception ce) {\n+                                if (logger.isLoggable(Level.WARNING)) {\n+                                    logger.warning(\"Failed to restore connection to \" + hostname + \":\" + port +\n+                                        \". Next attempt in \" + keepAliveInterval + \"ms\");\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            });\n+            keepAliveThreadExecutor = threadExecutor;\n+        } finally {\n+            keepAliveThreadExecutorLock.unlock();\n+        }\n+    }\n+\n+    private Thread newNamedThread(Runnable runnable, String threadName) {\n+        Thread thread = threadFactory == null ? new Thread(runnable) : threadFactory.newThread(runnable);\n+        thread.setName(threadName);\n+        return thread;\n+    }\n+\n+    boolean isKeepAliveThreadRunning() {\n+        try {\n+            keepAliveThreadExecutorLock.lock();\n+            return keepAliveThreadExecutor != null && !keepAliveThreadExecutor.isShutdown();\n+        } finally {\n+            keepAliveThreadExecutorLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Connect to the replication stream in a separate thread.\n+     * @param timeout timeout in milliseconds\n+     * @throws AuthenticationException if authentication fails\n+     * @throws ServerException if MySQL server responds with an error\n+     * @throws IOException if anything goes wrong while trying to connect\n+     * @throws TimeoutException if client was unable to connect within given time limit\n+     */\n+    public void connect(final long timeout) throws IOException, TimeoutException {\n+        final CountDownLatch countDownLatch = new CountDownLatch(1);\n+        AbstractLifecycleListener connectListener = new AbstractLifecycleListener() {\n+            @Override\n+            public void onConnect(BinaryLogClient client) {\n+                countDownLatch.countDown();\n+            }\n+        };\n+        registerLifecycleListener(connectListener);\n+        final AtomicReference<IOException> exceptionReference = new AtomicReference<IOException>();\n+        Runnable runnable = new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                try {\n+                    setConnectTimeout(timeout);\n+                    connect();\n+                } catch (IOException e) {\n+                    exceptionReference.set(e);\n+                    countDownLatch.countDown(); // making sure we don't end up waiting whole \"timeout\"\n+                }\n+            }\n+        };\n+        newNamedThread(runnable, \"blc-\" + hostname + \":\" + port).start();\n+        boolean started = false;\n+        try {\n+            started = countDownLatch.await(timeout, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException e) {\n+            if (logger.isLoggable(Level.WARNING)) {\n+                logger.log(Level.WARNING, e.getMessage());\n+            }\n+        }\n+        unregisterLifecycleListener(connectListener);\n+        if (exceptionReference.get() != null) {\n+            throw exceptionReference.get();\n+        }\n+        if (!started) {\n+            try {\n+                terminateConnect();\n+            } finally {\n+                throw new TimeoutException(\"BinaryLogClient was unable to connect in \" + timeout + \"ms\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @return true if client is connected, false otherwise\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    private String fetchGtidPurged() throws IOException {\n+        channel.write(new QueryCommand(\"show global variables like 'gtid_purged'\"));\n+        ResultSetRowPacket[] resultSet = readResultSet();\n+        if (resultSet.length != 0) {\n+            return resultSet[0].getValue(1).toUpperCase();\n+        }\n+        return \"\";\n+    }\n+\n+    private void fetchBinlogFilenameAndPosition() throws IOException {\n+        ResultSetRowPacket[] resultSet;\n+        channel.write(new QueryCommand(\"show master status\"));\n+        resultSet = readResultSet();\n+        if (resultSet.length == 0) {\n+            throw new IOException(\"Failed to determine binlog filename/position\");\n+        }\n+        ResultSetRowPacket resultSetRow = resultSet[0];\n+        binlogFilename = resultSetRow.getValue(0);\n+        binlogPosition = Long.parseLong(resultSetRow.getValue(1));\n+    }\n+\n+    protected ChecksumType fetchBinlogChecksum() throws IOException {\n+        channel.write(new QueryCommand(\"show global variables like 'binlog_checksum'\"));\n+        ResultSetRowPacket[] resultSet = readResultSet();\n+        if (resultSet.length == 0) {\n+            return ChecksumType.NONE;\n+        }\n+        return ChecksumType.valueOf(resultSet[0].getValue(1).toUpperCase());\n+    }\n+\n+    private void confirmSupportOfChecksum(ChecksumType checksumType) throws IOException {\n+        channel.write(new QueryCommand(\"set @master_binlog_checksum= @@global.binlog_checksum\"));\n+        byte[] statementResult = channel.read();\n+        if (statementResult[0] == (byte) 0xFF /* error */) {\n+            byte[] bytes = Arrays.copyOfRange(statementResult, 1, statementResult.length);\n+            ErrorPacket errorPacket = new ErrorPacket(bytes);\n+            throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n+                errorPacket.getSqlState());\n+        }\n+        eventDeserializer.setChecksumType(checksumType);\n+    }\n+\n+    private void listenForEventPackets() throws IOException {\n+        ByteArrayInputStream inputStream = channel.getInputStream();\n+        boolean completeShutdown = false;\n+        try {\n+            while (inputStream.peek() != -1) {\n+                int packetLength = inputStream.readInteger(3);\n+                inputStream.skip(1); // 1 byte for sequence\n+                int marker = inputStream.read();\n+                if (marker == 0xFF) {\n+                    ErrorPacket errorPacket = new ErrorPacket(inputStream.read(packetLength - 1));\n+                    throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n+                        errorPacket.getSqlState());\n+                }\n+                if (marker == 0xFE && !blocking) {\n+                    completeShutdown = true;\n+                    break;\n+                }\n+                Event event;\n+                try {\n+                    event = eventDeserializer.nextEvent(packetLength == MAX_PACKET_LENGTH ?\n+                        new ByteArrayInputStream(readPacketSplitInChunks(inputStream, packetLength - 1)) :\n+                        inputStream);\n+                    if (event == null) {\n+                        throw new EOFException();\n+                    }\n+                } catch (Exception e) {\n+                    Throwable cause = e instanceof EventDataDeserializationException ? e.getCause() : e;\n+                    if (cause instanceof EOFException || cause instanceof SocketException) {\n+                        throw e;\n+                    }\n+                    if (isConnected()) {\n+                        for (LifecycleListener lifecycleListener : lifecycleListeners) {\n+                            lifecycleListener.onEventDeserializationFailure(this, e);\n+                        }\n+                    }\n+                    continue;\n+                }\n+                if (isConnected()) {\n+                    eventLastSeen = System.currentTimeMillis();\n+                    updateGtidSet(event);\n+                    notifyEventListeners(event);\n+                    updateClientBinlogFilenameAndPosition(event);\n+                }\n+            }\n+        } catch (Exception e) {\n+            if (isConnected()) {\n+                for (LifecycleListener lifecycleListener : lifecycleListeners) {\n+                    lifecycleListener.onCommunicationFailure(this, e);\n+                }\n+            }\n+        } finally {\n+            if (isConnected()) {\n+                if (completeShutdown) {\n+                    disconnect(); // initiate complete shutdown sequence (which includes keep alive thread)\n+                } else {\n+                    disconnectChannel();\n+                }\n+            }\n+        }\n+    }\n+\n+    private byte[] readPacketSplitInChunks(ByteArrayInputStream inputStream, int packetLength) throws IOException {\n+        byte[] result = inputStream.read(packetLength);\n+        int chunkLength;\n+        do {\n+            chunkLength = inputStream.readInteger(3);\n+            inputStream.skip(1); // 1 byte for sequence\n+            result = Arrays.copyOf(result, result.length + chunkLength);\n+            inputStream.fill(result, result.length - chunkLength, chunkLength);\n+        } while (chunkLength == Packet.MAX_LENGTH);\n+        return result;\n+    }\n+\n+    private void updateClientBinlogFilenameAndPosition(Event event) {\n+        EventHeader eventHeader = event.getHeader();\n+        EventType eventType = eventHeader.getEventType();\n+        if (eventType == EventType.ROTATE) {\n+            RotateEventData rotateEventData = (RotateEventData) EventDataWrapper.internal(event.getData());\n+            binlogFilename = rotateEventData.getBinlogFilename();\n+            binlogPosition = rotateEventData.getBinlogPosition();\n+        } else\n+        // do not update binlogPosition on TABLE_MAP so that in case of reconnect (using a different instance of\n+        // client) table mapping cache could be reconstructed before hitting row mutation event\n+        if (eventType != EventType.TABLE_MAP && eventHeader instanceof EventHeaderV4) {\n+            EventHeaderV4 trackableEventHeader = (EventHeaderV4) eventHeader;\n+            long nextBinlogPosition = trackableEventHeader.getNextPosition();\n+            if (nextBinlogPosition > 0) {\n+                binlogPosition = nextBinlogPosition;\n+            }\n+        }\n+    }\n+\n+    private void updateGtidSet(Event event) {\n+        synchronized (gtidSetAccessLock) {\n+            if (gtidSet == null) {\n+                return;\n+            }\n+        }\n+        EventHeader eventHeader = event.getHeader();\n+        switch(eventHeader.getEventType()) {\n+            case GTID:\n+                GtidEventData gtidEventData = (GtidEventData) EventDataWrapper.internal(event.getData());\n+                gtid = gtidEventData.getGtid();\n+                break;\n+            case XID:\n+                commitGtid();\n+                tx = false;\n+                break;\n+            case QUERY:\n+                QueryEventData queryEventData = (QueryEventData) EventDataWrapper.internal(event.getData());\n+                String sql = queryEventData.getSql();\n+                if (sql == null) {\n+                    break;\n+                }\n+                if (\"BEGIN\".equals(sql)) {\n+                    tx = true;\n+                } else\n+                if (\"COMMIT\".equals(sql) || \"ROLLBACK\".equals(sql)) {\n+                    commitGtid();\n+                    tx = false;\n+                } else\n+                if (!tx) {\n+                    // auto-commit query, likely DDL\n+                    commitGtid();\n+                }\n+            default:\n+        }\n+    }\n+\n+    private void commitGtid() {\n+        if (gtid != null) {\n+            synchronized (gtidSetAccessLock) {\n+                gtidSet.add(gtid);\n+            }\n+        }\n+    }\n+\n+    protected ResultSetRowPacket[] readResultSet() throws IOException {\n+        List<ResultSetRowPacket> resultSet = new LinkedList<ResultSetRowPacket>();\n+        byte[] statementResult = channel.read();\n+        if (statementResult[0] == (byte) 0xFF /* error */) {\n+            byte[] bytes = Arrays.copyOfRange(statementResult, 1, statementResult.length);\n+            ErrorPacket errorPacket = new ErrorPacket(bytes);\n+            throw new ServerException(errorPacket.getErrorMessage(), errorPacket.getErrorCode(),\n+                    errorPacket.getSqlState());\n+        }\n+        while ((channel.read())[0] != (byte) 0xFE /* eof */) { /* skip */ }\n+        for (byte[] bytes; (bytes = channel.read())[0] != (byte) 0xFE /* eof */; ) {\n+            resultSet.add(new ResultSetRowPacket(bytes));\n+        }\n+        return resultSet.toArray(new ResultSetRowPacket[resultSet.size()]);\n+    }\n+\n+    /**\n+     * @return registered event listeners\n+     */\n+    public List<EventListener> getEventListeners() {\n+        return Collections.unmodifiableList(eventListeners);\n+    }\n+\n+    /**\n+     * Register event listener. Note that multiple event listeners will be called in order they\n+     * where registered.\n+     */\n+    public void registerEventListener(EventListener eventListener) {\n+        eventListeners.add(eventListener);\n+    }\n+\n+    /**\n+     * Unregister all event listener of specific type.\n+     */\n+    public void unregisterEventListener(Class<? extends EventListener> listenerClass) {\n+        for (EventListener eventListener: eventListeners) {\n+            if (listenerClass.isInstance(eventListener)) {\n+                eventListeners.remove(eventListener);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unregister single event listener.\n+     */\n+    public void unregisterEventListener(EventListener eventListener) {\n+        eventListeners.remove(eventListener);\n+    }\n+\n+    private void notifyEventListeners(Event event) {\n+        if (event.getData() instanceof EventDataWrapper) {\n+            event = new Event(event.getHeader(), ((EventDataWrapper) event.getData()).getExternal());\n+        }\n+\n+        for (EventListener eventListener : eventListeners) {\n+            try {\n+                eventListener.onEvent(event);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Binlog event listener \" + eventListener +\n+                    \" choked on \" + event, e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @return registered lifecycle listeners\n+     */\n+    public List<LifecycleListener> getLifecycleListeners() {\n+        return Collections.unmodifiableList(lifecycleListeners);\n+    }\n+\n+    /**\n+     * Register lifecycle listener. Note that multiple lifecycle listeners will be called in order they\n+     * where registered.\n+     */\n+    public void registerLifecycleListener(LifecycleListener lifecycleListener) {\n+        lifecycleListeners.add(lifecycleListener);\n+    }\n+\n+    /**\n+     * Unregister all lifecycle listener of specific type.\n+     */\n+    public void unregisterLifecycleListener(Class<? extends LifecycleListener> listenerClass) {\n+        for (LifecycleListener lifecycleListener : lifecycleListeners) {\n+            if (listenerClass.isInstance(lifecycleListener)) {\n+                lifecycleListeners.remove(lifecycleListener);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unregister single lifecycle listener.\n+     */\n+    public void unregisterLifecycleListener(LifecycleListener eventListener) {\n+        lifecycleListeners.remove(eventListener);\n+    }\n+\n+    /**\n+     * Disconnect from the replication stream.\n+     * Note that this does not cause binlogFilename/binlogPosition to be cleared out.\n+     * As the result following {@link #connect()} resumes client from where it left off.\n+     */\n+    public void disconnect() throws IOException {\n+        terminateKeepAliveThread();\n+        terminateConnect();\n+    }\n+\n+    @Override\n+    public void abort() throws IOException {\n+        disconnect();\n+    }\n+\n+    private void terminateKeepAliveThread() {\n+        try {\n+            keepAliveThreadExecutorLock.lock();\n+            ExecutorService keepAliveThreadExecutor = this.keepAliveThreadExecutor;\n+            if (keepAliveThreadExecutor == null) {\n+                return;\n+            }\n+            keepAliveThreadExecutor.shutdownNow();\n+            while (!awaitTerminationInterruptibly(keepAliveThreadExecutor,\n+                Long.MAX_VALUE, TimeUnit.NANOSECONDS)) {\n+                // ignore\n+            }\n+        } finally {\n+            keepAliveThreadExecutorLock.unlock();\n+        }\n+    }\n+\n+    private static boolean awaitTerminationInterruptibly(ExecutorService executorService, long timeout, TimeUnit unit) {\n+        try {\n+            return executorService.awaitTermination(timeout, unit);\n+        } catch (InterruptedException e) {\n+            return false;\n+        }\n+    }\n+\n+    private void terminateConnect() throws IOException {\n+        do {\n+            disconnectChannel();\n+        } while (!tryLockInterruptibly(connectLock, 1000, TimeUnit.MILLISECONDS));\n+        connectLock.unlock();\n+    }\n+\n+    private static boolean tryLockInterruptibly(Lock lock, long time, TimeUnit unit) {\n+        try {\n+            return lock.tryLock(time, unit);\n+        } catch (InterruptedException e) {\n+            return false;\n+        }\n+    }\n+\n+    private void disconnectChannel() throws IOException {\n+        connected = false;\n+        if (channel != null && channel.isOpen()) {\n+            channel.close();\n+        }\n+    }\n+}"
  },
  {
    "sha": "de6f1b08948487a5e1431e7de13997439db4bd62",
    "filename": "src/main/java/com/github/shyiko/mysql/binlog/jmx/BinaryLogClientStatistics.java",
    "status": "modified",
    "additions": 5,
    "deletions": 2,
    "changes": 7,
    "blob_url": "https://github.com/fivetran/mysql-binlog-connector-java/blob/341f8dac8630a52d8989bbeba9a93b370f322d60/src/main/java/com/github/shyiko/mysql/binlog/jmx/BinaryLogClientStatistics.java",
    "raw_url": "https://github.com/fivetran/mysql-binlog-connector-java/raw/341f8dac8630a52d8989bbeba9a93b370f322d60/src/main/java/com/github/shyiko/mysql/binlog/jmx/BinaryLogClientStatistics.java",
    "contents_url": "https://api.github.com/repos/fivetran/mysql-binlog-connector-java/contents/src/main/java/com/github/shyiko/mysql/binlog/jmx/BinaryLogClientStatistics.java?ref=341f8dac8630a52d8989bbeba9a93b370f322d60",
    "patch": "@@ -16,6 +16,9 @@\n package com.github.shyiko.mysql.binlog.jmx;\n \n import com.github.shyiko.mysql.binlog.BinaryLogClient;\n+import com.github.shyiko.mysql.binlog.BinaryLogClient.EventListener;\n+import com.github.shyiko.mysql.binlog.BinaryLogClient.LifecycleListener;\n+import com.github.shyiko.mysql.binlog.NewBinaryLogClient;\n import com.github.shyiko.mysql.binlog.event.Event;\n import com.github.shyiko.mysql.binlog.event.EventHeader;\n \n@@ -26,7 +29,7 @@\n  * @author <a href=\"mailto:stanley.shyiko@gmail.com\">Stanley Shyiko</a>\n  */\n public class BinaryLogClientStatistics implements BinaryLogClientStatisticsMXBean,\n-        BinaryLogClient.EventListener, BinaryLogClient.LifecycleListener {\n+    EventListener, LifecycleListener {\n \n     private AtomicReference<EventHeader> lastEventHeader = new AtomicReference<EventHeader>();\n     private AtomicLong timestampOfLastEvent = new AtomicLong();\n@@ -38,7 +41,7 @@\n     public BinaryLogClientStatistics() {\n     }\n \n-    public BinaryLogClientStatistics(BinaryLogClient binaryLogClient) {\n+    public BinaryLogClientStatistics(NewBinaryLogClient binaryLogClient) {\n         binaryLogClient.registerEventListener(this);\n         binaryLogClient.registerLifecycleListener(this);\n     }"
  },
  {
    "sha": "baa35410524cc60bc4ba2b361c0de0db40728079",
    "filename": "src/test/java/com/github/shyiko/mysql/binlog/BinaryLogClientGTIDIntegrationTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/fivetran/mysql-binlog-connector-java/blob/341f8dac8630a52d8989bbeba9a93b370f322d60/src/test/java/com/github/shyiko/mysql/binlog/BinaryLogClientGTIDIntegrationTest.java",
    "raw_url": "https://github.com/fivetran/mysql-binlog-connector-java/raw/341f8dac8630a52d8989bbeba9a93b370f322d60/src/test/java/com/github/shyiko/mysql/binlog/BinaryLogClientGTIDIntegrationTest.java",
    "contents_url": "https://api.github.com/repos/fivetran/mysql-binlog-connector-java/contents/src/test/java/com/github/shyiko/mysql/binlog/BinaryLogClientGTIDIntegrationTest.java?ref=341f8dac8630a52d8989bbeba9a93b370f322d60",
    "patch": "@@ -105,7 +105,7 @@ public void execute(ResultSet rs) throws SQLException {\n         EventDeserializer eventDeserializer = new EventDeserializer();\n         try {\n             client.disconnect();\n-            final BinaryLogClient clientWithKeepAlive = new BinaryLogClient(slave.hostname(), slave.port(),\n+            final com.github.shyiko.mysql.binlog.NewBinaryLogClient clientWithKeepAlive = new com.github.shyiko.mysql.binlog.NewBinaryLogClient(slave.hostname(), slave.port(),\n                 slave.username(), slave.password());\n \n             clientWithKeepAlive.setGtidSet(initialGTIDSet[0]);"
  },
  {
    "sha": "a5f91b173d19845a78af7c85433cf847ee468d07",
    "filename": "src/test/java/com/github/shyiko/mysql/binlog/BinaryLogClientIntegrationTest.java",
    "status": "modified",
    "additions": 18,
    "deletions": 18,
    "changes": 36,
    "blob_url": "https://github.com/fivetran/mysql-binlog-connector-java/blob/341f8dac8630a52d8989bbeba9a93b370f322d60/src/test/java/com/github/shyiko/mysql/binlog/BinaryLogClientIntegrationTest.java",
    "raw_url": "https://github.com/fivetran/mysql-binlog-connector-java/raw/341f8dac8630a52d8989bbeba9a93b370f322d60/src/test/java/com/github/shyiko/mysql/binlog/BinaryLogClientIntegrationTest.java",
    "contents_url": "https://api.github.com/repos/fivetran/mysql-binlog-connector-java/contents/src/test/java/com/github/shyiko/mysql/binlog/BinaryLogClientIntegrationTest.java?ref=341f8dac8630a52d8989bbeba9a93b370f322d60",
    "patch": "@@ -100,7 +100,7 @@\n     private final TimeZone timeZoneBeforeTheTest = TimeZone.getDefault();\n \n     protected MySQLConnection master, slave;\n-    protected BinaryLogClient client;\n+    protected NewBinaryLogClient client;\n     protected CountDownEventListener eventListener;\n \n     @BeforeClass\n@@ -114,7 +114,7 @@ public void setUp() throws Exception {\n         slave = new MySQLConnection(bundle.getString(prefix + \"slave.hostname\"),\n                 Integer.parseInt(bundle.getString(prefix + \"slave.port\")),\n                 bundle.getString(prefix + \"slave.superUsername\"), bundle.getString(prefix + \"slave.superPassword\"));\n-        client = new BinaryLogClient(slave.hostname, slave.port, slave.username, slave.password);\n+        client = new NewBinaryLogClient(slave.hostname, slave.port, slave.username, slave.password);\n         EventDeserializer eventDeserializer = new EventDeserializer();\n         eventDeserializer.setCompatibilityMode(CompatibilityMode.CHAR_AND_BINARY_AS_BYTE_ARRAY,\n             CompatibilityMode.DATE_AND_TIME_AS_LONG);\n@@ -384,7 +384,7 @@ public void execute(Statement statement) throws SQLException {\n \n     @Test\n     public void testDeserializationOfDateAndTimeAsLong() throws Exception {\n-        final BinaryLogClient client = new BinaryLogClient(slave.hostname, slave.port,\n+        final NewBinaryLogClient client = new NewBinaryLogClient(slave.hostname, slave.port,\n             slave.username, slave.password);\n         EventDeserializer eventDeserializer = new EventDeserializer();\n         eventDeserializer.setCompatibilityMode(CompatibilityMode.DATE_AND_TIME_AS_LONG);\n@@ -400,7 +400,7 @@ public void testDeserializationOfDateAndTimeAsLong() throws Exception {\n \n     @Test\n     public void testDeserializationOfDateAndTimeAsLongMicrosecondsPrecision() throws Exception {\n-        final BinaryLogClient client = new BinaryLogClient(slave.hostname, slave.port,\n+        final NewBinaryLogClient client = new NewBinaryLogClient(slave.hostname, slave.port,\n             slave.username, slave.password);\n         EventDeserializer eventDeserializer = new EventDeserializer();\n         eventDeserializer.setCompatibilityMode(CompatibilityMode.DATE_AND_TIME_AS_LONG_MICRO);\n@@ -439,8 +439,8 @@ private long generateTime(int year, int month, int day, int hour, int minute, in\n         return writeAndCaptureRow(client, columnDefinition, values);\n     }\n \n-    private Serializable[] writeAndCaptureRow(BinaryLogClient client, final String columnDefinition,\n-            final String... values) throws Exception {\n+    private Serializable[] writeAndCaptureRow(NewBinaryLogClient client, final String columnDefinition,\n+                                              final String... values) throws Exception {\n         CapturingEventListener capturingEventListener = new CapturingEventListener();\n         client.registerEventListener(capturingEventListener);\n         CountDownEventListener eventListener = new CountDownEventListener();\n@@ -503,7 +503,7 @@ public void execute(Statement statement) throws SQLException {\n                 }\n             });\n             eventListener.waitFor(WriteRowsEventData.class, 3, DEFAULT_TIMEOUT);\n-            final BinaryLogClient anotherClient = new BinaryLogClient(slave.hostname, slave.port,\n+            final NewBinaryLogClient anotherClient = new NewBinaryLogClient(slave.hostname, slave.port,\n                 slave.username, slave.password);\n             anotherClient.registerLifecycleListener(new TraceLifecycleListener());\n             CountDownEventListener anotherClientEventListener = new CountDownEventListener();\n@@ -648,7 +648,7 @@ public void testAutomaticFailover() throws Exception {\n             bindInSeparateThread(tcpReverseProxy);\n             try {\n                 client.disconnect();\n-                final BinaryLogClient clientOverProxy = new BinaryLogClient(slave.hostname, tcpReverseProxy.getPort(),\n+                final NewBinaryLogClient clientOverProxy = new NewBinaryLogClient(slave.hostname, tcpReverseProxy.getPort(),\n                         slave.username, slave.password);\n                 clientOverProxy.setKeepAliveInterval(TimeUnit.MILLISECONDS.toMillis(100));\n                 clientOverProxy.setKeepAliveConnectTimeout(TimeUnit.SECONDS.toMillis(2));\n@@ -728,7 +728,7 @@ private void testCommunicationFailureInTheMiddleOfEventDataDeserialization(final\n     protected void testCommunicationFailure(EventDeserializer eventDeserializer) throws Exception {\n         try {\n             client.disconnect();\n-            final BinaryLogClient clientWithKeepAlive = new BinaryLogClient(slave.hostname, slave.port,\n+            final NewBinaryLogClient clientWithKeepAlive = new NewBinaryLogClient(slave.hostname, slave.port,\n                     slave.username, slave.password);\n             clientWithKeepAlive.setKeepAliveInterval(TimeUnit.MILLISECONDS.toMillis(100));\n             clientWithKeepAlive.setKeepAliveConnectTimeout(TimeUnit.SECONDS.toMillis(2));\n@@ -766,7 +766,7 @@ public void execute(Statement statement) throws SQLException {\n     public void testCustomEventDataDeserializers() throws Exception {\n         try {\n             client.disconnect();\n-            final BinaryLogClient binaryLogClient = new BinaryLogClient(slave.hostname, slave.port,\n+            final NewBinaryLogClient binaryLogClient = new NewBinaryLogClient(slave.hostname, slave.port,\n                     slave.username, slave.password);\n             binaryLogClient.registerEventListener(new TraceEventListener());\n             binaryLogClient.registerEventListener(eventListener);\n@@ -812,8 +812,8 @@ public void testExceptionIsThrownWhenTryingToConnectAlreadyConnectedClient() thr\n \n     @Test\n     public void testExceptionIsThrownWhenProvidedWithWrongCredentials() throws Exception {\n-        BinaryLogClient binaryLogClient =\n-            new BinaryLogClient(slave.hostname, slave.port, slave.username, slave.password + \"^_^\");\n+        NewBinaryLogClient binaryLogClient =\n+            new NewBinaryLogClient(slave.hostname, slave.port, slave.username, slave.password + \"^_^\");\n         try {\n             binaryLogClient.connect();\n             fail(\"Wrong password should have resulted in AuthenticationException being thrown\");\n@@ -828,7 +828,7 @@ public void testExceptionIsThrownWhenInsufficientPermissionsToDetectPosition() t\n         String prefix = \"jdbc.mysql.replication.\";\n         String slaveUsername = bundle.getString(prefix + \"slave.slaveUsername\");\n         String slavePassword = bundle.getString(prefix + \"slave.slavePassword\");\n-        new BinaryLogClient(slave.hostname, slave.port, slaveUsername, slavePassword).connect();\n+        new NewBinaryLogClient(slave.hostname, slave.port, slaveUsername, slavePassword).connect();\n     }\n \n     private void bindInSeparateThread(final TCPReverseProxy tcpReverseProxy) throws InterruptedException {\n@@ -848,7 +848,7 @@ public void run() {\n \n     @Test(expectedExceptions = AuthenticationException.class)\n     public void testAuthenticationFailsWhenNonExistingSchemaProvided() throws Exception {\n-        new BinaryLogClient(slave.hostname, slave.port, \"mbcj_test_non_existing\", slave.username, slave.password).\n+        new NewBinaryLogClient(slave.hostname, slave.port, \"mbcj_test_non_existing\", slave.username, slave.password).\n             connect(DEFAULT_TIMEOUT);\n     }\n \n@@ -864,8 +864,8 @@ public void execute(Statement statement) throws SQLException {\n             }\n         });\n         eventListener.waitFor(QueryEventData.class, 4, DEFAULT_TIMEOUT);\n-        BinaryLogClient isolatedClient =\n-            new BinaryLogClient(slave.hostname, slave.port, \"mbcj_test_isolated\", slave.username, slave.password);\n+        NewBinaryLogClient isolatedClient =\n+            new NewBinaryLogClient(slave.hostname, slave.port, \"mbcj_test_isolated\", slave.username, slave.password);\n         try {\n             CountDownEventListener isolatedEventListener = new CountDownEventListener();\n             isolatedClient.registerEventListener(isolatedEventListener);\n@@ -890,8 +890,8 @@ public void testReconnectRaceCondition() throws Exception {\n         // a more reliable way would be to use buffered 2-level concurrent filter input stream\n         try {\n             client.disconnect();\n-            final BinaryLogClient binaryLogClient =\n-                new BinaryLogClient(slave.hostname, slave.port, slave.username, slave.password);\n+            final NewBinaryLogClient binaryLogClient =\n+                new NewBinaryLogClient(slave.hostname, slave.port, slave.username, slave.password);\n             final Lock inputStreamLock = new ReentrantLock();\n             final AtomicBoolean breakOutputStream = new AtomicBoolean();\n             binaryLogClient.setSocketFactory(new SocketFactory() {"
  },
  {
    "sha": "c2497f48985a5ac2b0847ccf9eb45a7259aa803a",
    "filename": "src/test/java/com/github/shyiko/mysql/binlog/BinaryLogClientTest.java",
    "status": "modified",
    "additions": 6,
    "deletions": 6,
    "changes": 12,
    "blob_url": "https://github.com/fivetran/mysql-binlog-connector-java/blob/341f8dac8630a52d8989bbeba9a93b370f322d60/src/test/java/com/github/shyiko/mysql/binlog/BinaryLogClientTest.java",
    "raw_url": "https://github.com/fivetran/mysql-binlog-connector-java/raw/341f8dac8630a52d8989bbeba9a93b370f322d60/src/test/java/com/github/shyiko/mysql/binlog/BinaryLogClientTest.java",
    "contents_url": "https://api.github.com/repos/fivetran/mysql-binlog-connector-java/contents/src/test/java/com/github/shyiko/mysql/binlog/BinaryLogClientTest.java?ref=341f8dac8630a52d8989bbeba9a93b370f322d60",
    "patch": "@@ -40,7 +40,7 @@\n \n     @Test\n     public void testEventListenersManagement() {\n-        BinaryLogClient binaryLogClient = new BinaryLogClient(\"localhost\", 3306, \"root\", \"mysql\");\n+        NewBinaryLogClient binaryLogClient = new NewBinaryLogClient(\"localhost\", 3306, \"root\", \"mysql\");\n         assertTrue(binaryLogClient.getEventListeners().isEmpty());\n         TraceEventListener traceEventListener = new TraceEventListener();\n         binaryLogClient.registerEventListener(traceEventListener);\n@@ -55,7 +55,7 @@ public void testEventListenersManagement() {\n \n     @Test\n     public void testLifecycleListenersManagement() {\n-        BinaryLogClient binaryLogClient = new BinaryLogClient(\"localhost\", 3306, \"root\", \"mysql\");\n+        NewBinaryLogClient binaryLogClient = new NewBinaryLogClient(\"localhost\", 3306, \"root\", \"mysql\");\n         assertTrue(binaryLogClient.getLifecycleListeners().isEmpty());\n         TraceLifecycleListener traceLifecycleListener = new TraceLifecycleListener();\n         binaryLogClient.registerLifecycleListener(traceLifecycleListener);\n@@ -71,12 +71,12 @@ public void testLifecycleListenersManagement() {\n \n     @Test(expectedExceptions = TimeoutException.class)\n     public void testNoConnectionTimeout() throws Exception {\n-        new BinaryLogClient(\"_localhost_\", 3306, \"root\", \"mysql\").connect(0);\n+        new NewBinaryLogClient(\"_localhost_\", 3306, \"root\", \"mysql\").connect(0);\n     }\n \n     @Test(timeOut = 15000)\n     public void testConnectionTimeout() throws Exception {\n-        final BinaryLogClient binaryLogClient = new BinaryLogClient(\"localhost\", 33059, \"root\", \"mysql\");\n+        final NewBinaryLogClient binaryLogClient = new NewBinaryLogClient(\"localhost\", 33059, \"root\", \"mysql\");\n         final CountDownLatch socketBound = new CountDownLatch(1);\n         final CountDownLatch binaryLogClientDisconnected = new CountDownLatch(1);\n         new Thread(new Runnable() {\n@@ -110,12 +110,12 @@ public void run() {\n \n     @Test(expectedExceptions = IllegalArgumentException.class)\n     public void testNullEventDeserializerIsNotAllowed() throws Exception {\n-        new BinaryLogClient(\"localhost\", 3306, \"root\", \"mysql\").setEventDeserializer(null);\n+        new NewBinaryLogClient(\"localhost\", 3306, \"root\", \"mysql\").setEventDeserializer(null);\n     }\n \n     @Test(timeOut = 15000)\n     public void testDisconnectWhileBlockedByFBRead() throws Exception {\n-        final BinaryLogClient binaryLogClient = new BinaryLogClient(\"localhost\", 33060, \"root\", \"mysql\");\n+        final NewBinaryLogClient binaryLogClient = new NewBinaryLogClient(\"localhost\", 33060, \"root\", \"mysql\");\n         final CountDownLatch readAttempted = new CountDownLatch(1);\n         binaryLogClient.setSocketFactory(new SocketFactory() {\n             @Override"
  },
  {
    "sha": "f035f91cd03138120e72336c005ccce776fa8307",
    "filename": "src/test/java/com/github/shyiko/mysql/binlog/TraceLifecycleListener.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/fivetran/mysql-binlog-connector-java/blob/341f8dac8630a52d8989bbeba9a93b370f322d60/src/test/java/com/github/shyiko/mysql/binlog/TraceLifecycleListener.java",
    "raw_url": "https://github.com/fivetran/mysql-binlog-connector-java/raw/341f8dac8630a52d8989bbeba9a93b370f322d60/src/test/java/com/github/shyiko/mysql/binlog/TraceLifecycleListener.java",
    "contents_url": "https://api.github.com/repos/fivetran/mysql-binlog-connector-java/contents/src/test/java/com/github/shyiko/mysql/binlog/TraceLifecycleListener.java?ref=341f8dac8630a52d8989bbeba9a93b370f322d60",
    "patch": "@@ -52,4 +52,4 @@ public void onDisconnect(BinaryLogClient client) {\n             logger.log(Level.INFO, \"Disconnected\");\n         }\n     }\n-}\n\\ No newline at end of file\n+}"
  },
  {
    "sha": "e44530d7a67faa1799d43e93d42886beaa5fad9b",
    "filename": "src/test/java/com/github/shyiko/mysql/binlog/event/deserialization/json/JsonBinaryValueIntegrationTest.java",
    "status": "modified",
    "additions": 3,
    "deletions": 8,
    "changes": 11,
    "blob_url": "https://github.com/fivetran/mysql-binlog-connector-java/blob/341f8dac8630a52d8989bbeba9a93b370f322d60/src/test/java/com/github/shyiko/mysql/binlog/event/deserialization/json/JsonBinaryValueIntegrationTest.java",
    "raw_url": "https://github.com/fivetran/mysql-binlog-connector-java/raw/341f8dac8630a52d8989bbeba9a93b370f322d60/src/test/java/com/github/shyiko/mysql/binlog/event/deserialization/json/JsonBinaryValueIntegrationTest.java",
    "contents_url": "https://api.github.com/repos/fivetran/mysql-binlog-connector-java/contents/src/test/java/com/github/shyiko/mysql/binlog/event/deserialization/json/JsonBinaryValueIntegrationTest.java?ref=341f8dac8630a52d8989bbeba9a93b370f322d60",
    "patch": "@@ -15,12 +15,7 @@\n  */\n package com.github.shyiko.mysql.binlog.event.deserialization.json;\n \n-import com.github.shyiko.mysql.binlog.BinaryLogClient;\n-import com.github.shyiko.mysql.binlog.BinaryLogClientIntegrationTest;\n-import com.github.shyiko.mysql.binlog.CapturingEventListener;\n-import com.github.shyiko.mysql.binlog.CountDownEventListener;\n-import com.github.shyiko.mysql.binlog.TraceEventListener;\n-import com.github.shyiko.mysql.binlog.TraceLifecycleListener;\n+import com.github.shyiko.mysql.binlog.*;\n import com.github.shyiko.mysql.binlog.event.Event;\n import com.github.shyiko.mysql.binlog.event.EventData;\n import com.github.shyiko.mysql.binlog.event.EventType;\n@@ -64,7 +59,7 @@\n     private final TimeZone timeZoneBeforeTheTest = TimeZone.getDefault();\n \n     private BinaryLogClientIntegrationTest.MySQLConnection master;\n-    private BinaryLogClient client;\n+    private NewBinaryLogClient client;\n     private CountDownEventListener eventListener;\n \n     @BeforeClass\n@@ -75,7 +70,7 @@ public void setUp() throws Exception {\n         master = new BinaryLogClientIntegrationTest.MySQLConnection(bundle.getString(prefix + \"master.hostname\"),\n                 Integer.parseInt(bundle.getString(prefix + \"master.port\")),\n                 bundle.getString(prefix + \"master.username\"), bundle.getString(prefix + \"master.password\"));\n-        client = new BinaryLogClient(master.hostname(), master.port(), master.username(), master.password());\n+        client = new NewBinaryLogClient(master.hostname(), master.port(), master.username(), master.password());\n         client.setServerId(client.getServerId() - 1); // avoid clashes between BinaryLogClient instances\n         client.setKeepAlive(false);\n         client.registerEventListener(new TraceEventListener());"
  },
  {
    "sha": "14c92a5506e2571c4521da66407f3cb32994687f",
    "filename": "src/test/java/com/github/shyiko/mysql/binlog/jmx/BinaryLogClientMXBeanTest.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/fivetran/mysql-binlog-connector-java/blob/341f8dac8630a52d8989bbeba9a93b370f322d60/src/test/java/com/github/shyiko/mysql/binlog/jmx/BinaryLogClientMXBeanTest.java",
    "raw_url": "https://github.com/fivetran/mysql-binlog-connector-java/raw/341f8dac8630a52d8989bbeba9a93b370f322d60/src/test/java/com/github/shyiko/mysql/binlog/jmx/BinaryLogClientMXBeanTest.java",
    "contents_url": "https://api.github.com/repos/fivetran/mysql-binlog-connector-java/contents/src/test/java/com/github/shyiko/mysql/binlog/jmx/BinaryLogClientMXBeanTest.java?ref=341f8dac8630a52d8989bbeba9a93b370f322d60",
    "patch": "@@ -15,7 +15,7 @@\n  */\n package com.github.shyiko.mysql.binlog.jmx;\n \n-import com.github.shyiko.mysql.binlog.BinaryLogClient;\n+import com.github.shyiko.mysql.binlog.NewBinaryLogClient;\n import org.testng.annotations.Test;\n \n import javax.management.MBeanServer;\n@@ -32,7 +32,7 @@\n     @Test\n     public void testRegistration() throws Exception {\n         MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();\n-        BinaryLogClient binaryLogClient = new BinaryLogClient(\"localhost\", 3306, \"root\", \"mysql\");\n+        NewBinaryLogClient binaryLogClient = new NewBinaryLogClient(\"localhost\", 3306, \"root\", \"mysql\");\n         ObjectName objectName = new ObjectName(\"mysql.binlog:type=BinaryLogClient\");\n         mBeanServer.registerMBean(binaryLogClient, objectName);\n         try {"
  },
  {
    "sha": "a9c5aae204b07fac9467747684e05295ec1c3a54",
    "filename": "src/test/java/com/github/shyiko/mysql/binlog/jmx/BinaryLogClientStatisticsMXBeanTest.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/fivetran/mysql-binlog-connector-java/blob/341f8dac8630a52d8989bbeba9a93b370f322d60/src/test/java/com/github/shyiko/mysql/binlog/jmx/BinaryLogClientStatisticsMXBeanTest.java",
    "raw_url": "https://github.com/fivetran/mysql-binlog-connector-java/raw/341f8dac8630a52d8989bbeba9a93b370f322d60/src/test/java/com/github/shyiko/mysql/binlog/jmx/BinaryLogClientStatisticsMXBeanTest.java",
    "contents_url": "https://api.github.com/repos/fivetran/mysql-binlog-connector-java/contents/src/test/java/com/github/shyiko/mysql/binlog/jmx/BinaryLogClientStatisticsMXBeanTest.java?ref=341f8dac8630a52d8989bbeba9a93b370f322d60",
    "patch": "@@ -15,7 +15,7 @@\n  */\n package com.github.shyiko.mysql.binlog.jmx;\n \n-import com.github.shyiko.mysql.binlog.BinaryLogClient;\n+import com.github.shyiko.mysql.binlog.NewBinaryLogClient;\n import org.junit.Test;\n \n import javax.management.MBeanServer;\n@@ -32,7 +32,7 @@\n     @Test\n     public void testRegistration() throws Exception {\n         MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();\n-        BinaryLogClient binaryLogClient = new BinaryLogClient(\"localhost\", 3306, \"root\", \"mysql\");\n+        NewBinaryLogClient binaryLogClient = new NewBinaryLogClient(\"localhost\", 3306, \"root\", \"mysql\");\n         BinaryLogClientStatistics binaryLogClientStats = new BinaryLogClientStatistics(binaryLogClient);\n         ObjectName objectName = new ObjectName(\"mysql.binlog:type=BinaryLogClientStatistics\");\n         mBeanServer.registerMBean(binaryLogClientStats, objectName);"
  }
]
