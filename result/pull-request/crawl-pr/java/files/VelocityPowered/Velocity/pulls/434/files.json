[
  {
    "sha": "6b86490c5aef52c76efea58bee82beba1094e2ae",
    "filename": "api/src/main/java/com/velocitypowered/api/event/connection/ConnectionHandshakeEvent.java",
    "status": "modified",
    "additions": 179,
    "deletions": 1,
    "changes": 180,
    "blob_url": "https://github.com/VelocityPowered/Velocity/blob/1f7f2b810a54e21fef368829912555441a39222f/api/src/main/java/com/velocitypowered/api/event/connection/ConnectionHandshakeEvent.java",
    "raw_url": "https://github.com/VelocityPowered/Velocity/raw/1f7f2b810a54e21fef368829912555441a39222f/api/src/main/java/com/velocitypowered/api/event/connection/ConnectionHandshakeEvent.java",
    "contents_url": "https://api.github.com/repos/VelocityPowered/Velocity/contents/api/src/main/java/com/velocitypowered/api/event/connection/ConnectionHandshakeEvent.java?ref=1f7f2b810a54e21fef368829912555441a39222f",
    "patch": "@@ -1,27 +1,205 @@\n package com.velocitypowered.api.event.connection;\n \n import com.google.common.base.Preconditions;\n+import com.velocitypowered.api.event.ResultedEvent;\n import com.velocitypowered.api.proxy.InboundConnection;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+import net.kyori.adventure.text.Component;\n+import net.kyori.adventure.text.serializer.plain.PlainComponentSerializer;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n \n /**\n  * This event is fired when a handshake is established between a client and the proxy.\n  */\n-public final class ConnectionHandshakeEvent {\n+public final class ConnectionHandshakeEvent\n+        implements ResultedEvent<ConnectionHandshakeEvent.ConnectionHandshakeComponentResult> {\n \n   private final InboundConnection connection;\n+  private ConnectionHandshakeComponentResult result;\n+  private String newSocketAddressHostname;\n+  private String hostname;\n \n+  /**\n+   * Constructs a {@code ConnectionHandshakeEvent}.\n+   *\n+   * @param connection the connection\n+   * @deprecated in favor of {@link #ConnectionHandshakeEvent(InboundConnection, String)}\n+   */\n+  @Deprecated\n   public ConnectionHandshakeEvent(InboundConnection connection) {\n+    this(connection, \"127.0.0.1\");\n+  }\n+\n+  /**\n+   * Constructs a {@code ConnectionHandshakeEvent}.\n+   *\n+   * @param connection the connection\n+   * @param hostname the handshake hostname\n+   */\n+  public ConnectionHandshakeEvent(InboundConnection connection, @NonNull String hostname) {\n     this.connection = Preconditions.checkNotNull(connection, \"connection\");\n+    this.hostname = Preconditions.checkNotNull(hostname, \"serverHostname\");\n+    this.result = ConnectionHandshakeComponentResult.allowed();\n   }\n \n   public InboundConnection getConnection() {\n     return connection;\n   }\n \n+  /**\n+   * Sets the new handshake hostname. Keep in mind we will run a cleanup of the specified hostname\n+   * after it (removing SRV record points, removing everything after {@code \\0}, ...)\n+   *\n+   * @param hostname the new handshake hostname\n+   * @see #getHostname()\n+   */\n+  public void setHostname(@NonNull String hostname) {\n+    this.hostname = hostname;\n+  }\n+\n+  /**\n+   * Returns the handshake hostname.\n+   *\n+   * @return the handshake hostname\n+   * @see #setHostname(String)\n+   */\n+  @NonNull\n+  public String getHostname() {\n+    return hostname;\n+  }\n+\n+  /**\n+   * Sets the socket address hostname (without the port) of the player.\n+   *\n+   * <p>This essentially changes the IP to the one specified.\n+   *\n+   * <p>We expect you to provide a *resolved* IP address!\n+   *\n+   * @param newSocketAddressHostname the new hostname of the socket address\n+   * @see #getNewSocketAddressHostname()\n+   */\n+  public void setNewSocketAddressHostname(String newSocketAddressHostname) {\n+    this.newSocketAddressHostname = newSocketAddressHostname;\n+  }\n+\n+  /**\n+   * Returns the set hostname of the player's socket address.\n+   *\n+   * <p>This returns {@code null} if the socket address wasn't previously set by {@link\n+   * #setNewSocketAddressHostname(String)}.\n+   *\n+   * @return the hostname of the set socket address\n+   * @see #setNewSocketAddressHostname(String)\n+   */\n+  @Nullable\n+  public String getNewSocketAddressHostname() {\n+    return newSocketAddressHostname;\n+  }\n+\n+  /**\n+   * Returns the result of the event.\n+   *\n+   * @return the result\n+   * @see #setResult(ConnectionHandshakeComponentResult)\n+   */\n+  @Override\n+  public ConnectionHandshakeComponentResult getResult() {\n+    return result;\n+  }\n+\n+  /**\n+   * Sets the result of the event. If the {@code result} is denied, the player will disconnect with\n+   * the specified reason.\n+   *\n+   * <p>If the specified reason is {@code null}, the socket will be closed without a disconnect\n+   * message.\n+   *\n+   * @param result the new result\n+   * @see #getResult()\n+   */\n+  @Override\n+  public void setResult(ConnectionHandshakeComponentResult result) {\n+    this.result = result;\n+  }\n+\n   @Override\n   public String toString() {\n     return \"ConnectionHandshakeEvent{\"\n         + \"connection=\" + connection\n+        + \", result=\" + result\n+        + \", newSocketAddressHostname='\" + newSocketAddressHostname + '\\''\n+        + \", hostname='\" + hostname + '\\''\n         + '}';\n   }\n+\n+  /**\n+   * Represents an \"allowed/denied\" result with a (nullable) reason for denial.\n+   *\n+   * @implNote We don't use {@link com.velocitypowered.api.event.ResultedEvent.ComponentResult} as\n+   *     it doesn't allow for a {@code null} component result on deny.\n+   */\n+  public static final class ConnectionHandshakeComponentResult implements ResultedEvent.Result {\n+\n+    private static final ConnectionHandshakeComponentResult ALLOWED\n+            = new ConnectionHandshakeComponentResult(true, null);\n+\n+    private final boolean status;\n+    private final @Nullable Component reason;\n+\n+    private ConnectionHandshakeComponentResult(boolean status, @Nullable Component reason) {\n+      this.status = status;\n+      this.reason = reason;\n+    }\n+\n+    @Override\n+    public boolean isAllowed() {\n+      return status;\n+    }\n+\n+    public Optional<Component> getReason() {\n+      return Optional.ofNullable(reason);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      if (status) {\n+        return \"allowed\";\n+      }\n+      if (reason != null) {\n+        return \"denied: \" + PlainComponentSerializer.plain().serialize(reason);\n+      }\n+      return \"denied\";\n+    }\n+\n+    /**\n+     * Returns a result indicating the connection will be allowed.\n+     *\n+     * @return the allowed result\n+     */\n+    public static ConnectionHandshakeComponentResult allowed() {\n+      return ALLOWED;\n+    }\n+\n+    /**\n+     * Returns a result indicating the connection will be denied with no kick reason provided.\n+     *\n+     * @return the denied result\n+     * @see #denied(Component)\n+     */\n+    public static ConnectionHandshakeComponentResult denied() {\n+      return denied(null);\n+    }\n+\n+    /**\n+     * Returns a result indicating the connection will be denied with the specified kick reason.\n+     *\n+     * @param reason the reason for disallowing the connection, can be {@code null}\n+     * @return the denied result\n+     * @see #denied()\n+     */\n+    public static ConnectionHandshakeComponentResult denied(@Nullable Component reason) {\n+      return new ConnectionHandshakeComponentResult(false, reason);\n+    }\n+  }\n }"
  },
  {
    "sha": "ed6a55726453bdb6db535220a5bab7efae81db6e",
    "filename": "proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftConnection.java",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/VelocityPowered/Velocity/blob/1f7f2b810a54e21fef368829912555441a39222f/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftConnection.java",
    "raw_url": "https://github.com/VelocityPowered/Velocity/raw/1f7f2b810a54e21fef368829912555441a39222f/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftConnection.java",
    "contents_url": "https://api.github.com/repos/VelocityPowered/Velocity/contents/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftConnection.java?ref=1f7f2b810a54e21fef368829912555441a39222f",
    "patch": "@@ -280,6 +280,10 @@ public boolean isClosed() {\n     return !channel.isActive();\n   }\n \n+  public void setRemoteAddress(SocketAddress remoteAddress) {\n+    this.remoteAddress = remoteAddress;\n+  }\n+\n   public SocketAddress getRemoteAddress() {\n     return remoteAddress;\n   }"
  },
  {
    "sha": "1b91c86c51f38c4979e715c98e28a92c6779185e",
    "filename": "proxy/src/main/java/com/velocitypowered/proxy/connection/client/HandshakeSessionHandler.java",
    "status": "modified",
    "additions": 43,
    "deletions": 2,
    "changes": 45,
    "blob_url": "https://github.com/VelocityPowered/Velocity/blob/1f7f2b810a54e21fef368829912555441a39222f/proxy/src/main/java/com/velocitypowered/proxy/connection/client/HandshakeSessionHandler.java",
    "raw_url": "https://github.com/VelocityPowered/Velocity/raw/1f7f2b810a54e21fef368829912555441a39222f/proxy/src/main/java/com/velocitypowered/proxy/connection/client/HandshakeSessionHandler.java",
    "contents_url": "https://api.github.com/repos/VelocityPowered/Velocity/contents/proxy/src/main/java/com/velocitypowered/proxy/connection/client/HandshakeSessionHandler.java?ref=1f7f2b810a54e21fef368829912555441a39222f",
    "patch": "@@ -121,8 +121,49 @@ private void handleLogin(Handshake handshake, InitialInboundConnection ic) {\n       return;\n     }\n \n-    server.getEventManager().fireAndForget(new ConnectionHandshakeEvent(ic));\n-    connection.setSessionHandler(new LoginSessionHandler(server, connection, ic));\n+    String originalHostname = handshake.getServerAddress();\n+    server.getEventManager()\n+        .fire(new ConnectionHandshakeEvent(ic, originalHostname))\n+        .thenAcceptAsync(\n+            handshakeEvent -> {\n+              ConnectionHandshakeEvent.ConnectionHandshakeComponentResult result =\n+                  handshakeEvent.getResult();\n+              // maybe something already closed the connection\n+              if (ic.getConnection().isClosed()) {\n+                return;\n+              }\n+\n+              // if result is denied, disconnect. If a reason is provided, disconnect with that\n+              // reason, if not, disconnect without any message.\n+              if (!result.isAllowed()) {\n+                Optional<Component> reason = result.getReason();\n+                if (!reason.isPresent()) {\n+                  connection.close();\n+                } else {\n+                  ic.disconnect(reason.get());\n+                }\n+\n+                return;\n+              }\n+\n+              // if the handshake is changed, propagate the change\n+              if (!handshakeEvent.getHostname().equals(originalHostname)) {\n+                String cleanedHandshake = cleanVhost(handshakeEvent.getHostname());\n+                handshake.setServerAddress(cleanedHandshake);\n+                ic.setCleanedAddress(cleanedHandshake);\n+              }\n+\n+              // if the socket address is changed, propagate the change\n+              String newSocketAddress = handshakeEvent.getNewSocketAddressHostname();\n+              if (newSocketAddress != null) {\n+                // Using #createUnresolved is important as a reverse lookup is expensive\n+                InetSocketAddress newAddress\n+                        = InetSocketAddress.createUnresolved(newSocketAddress, handshake.getPort());\n+                ic.getConnection().setRemoteAddress(newAddress);\n+              }\n+\n+              connection.setSessionHandler(new LoginSessionHandler(server, connection, ic));\n+            });\n   }\n \n   private ConnectionType getHandshakeConnectionType(Handshake handshake) {"
  },
  {
    "sha": "8c0f03a0c388a548aaac4385446cb221e70db070",
    "filename": "proxy/src/main/java/com/velocitypowered/proxy/connection/client/InitialInboundConnection.java",
    "status": "modified",
    "additions": 9,
    "deletions": 1,
    "changes": 10,
    "blob_url": "https://github.com/VelocityPowered/Velocity/blob/1f7f2b810a54e21fef368829912555441a39222f/proxy/src/main/java/com/velocitypowered/proxy/connection/client/InitialInboundConnection.java",
    "raw_url": "https://github.com/VelocityPowered/Velocity/raw/1f7f2b810a54e21fef368829912555441a39222f/proxy/src/main/java/com/velocitypowered/proxy/connection/client/InitialInboundConnection.java",
    "contents_url": "https://api.github.com/repos/VelocityPowered/Velocity/contents/proxy/src/main/java/com/velocitypowered/proxy/connection/client/InitialInboundConnection.java?ref=1f7f2b810a54e21fef368829912555441a39222f",
    "patch": "@@ -19,8 +19,8 @@\n   private static final Logger logger = LogManager.getLogger(InitialInboundConnection.class);\n \n   private final MinecraftConnection connection;\n-  private final String cleanedAddress;\n   private final Handshake handshake;\n+  private String cleanedAddress;\n \n   InitialInboundConnection(MinecraftConnection connection, String cleanedAddress,\n       Handshake handshake) {\n@@ -54,6 +54,14 @@ public String toString() {\n     return \"[initial connection] \" + connection.getRemoteAddress().toString();\n   }\n \n+  public MinecraftConnection getConnection() {\n+    return connection;\n+  }\n+\n+  public void setCleanedAddress(String cleanedAddress) {\n+    this.cleanedAddress = cleanedAddress;\n+  }\n+\n   /**\n    * Disconnects the connection from the server.\n    * @param reason the reason for disconnecting"
  }
]
