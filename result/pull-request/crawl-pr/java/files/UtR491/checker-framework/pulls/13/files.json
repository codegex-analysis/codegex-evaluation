[
  {
    "sha": "279b2087abc183888b7adf0f400d856214140c92",
    "filename": "checker-util/src/main/java/org/checkerframework/checker/regex/util/RegexUtil.java",
    "status": "modified",
    "additions": 125,
    "deletions": 98,
    "changes": 223,
    "blob_url": "https://github.com/UtR491/checker-framework/blob/8bd609331717b8d9166503abf2543a9a957d91d0/checker-util/src/main/java/org/checkerframework/checker/regex/util/RegexUtil.java",
    "raw_url": "https://github.com/UtR491/checker-framework/raw/8bd609331717b8d9166503abf2543a9a957d91d0/checker-util/src/main/java/org/checkerframework/checker/regex/util/RegexUtil.java",
    "contents_url": "https://api.github.com/repos/UtR491/checker-framework/contents/checker-util/src/main/java/org/checkerframework/checker/regex/util/RegexUtil.java?ref=8bd609331717b8d9166503abf2543a9a957d91d0",
    "patch": "@@ -363,9 +363,7 @@ public static boolean isRegex(final char c) {\n     // RegexAnnotatedTypeFactory.\n     public static @RegexNNGroups String asRegex(String s, int groups, int... nonNullGroups) {\n         try {\n-            Pattern p = Pattern.compile(s);\n-            int actualGroups = getGroupCount(p);\n-            List<Integer> actualNonNullGroups = getNonNullGroups(p.pattern(), actualGroups);\n+            List<Integer> actualNonNullGroups = getNonNullGroups(s, groups);\n             boolean containsAll = true;\n             int failingGroup = -1;\n             for (int e : nonNullGroups) {\n@@ -375,11 +373,7 @@ public static boolean isRegex(final char c) {\n                     break;\n                 }\n             }\n-            if (actualGroups < groups) {\n-                throw new Error(regexErrorMessage(s, groups, actualGroups));\n-            } else if (!containsAll) {\n-                throw new Error(regexNNGroupsErrorMessage(s, failingGroup));\n-            }\n+            if (!containsAll) throw new Error(regexNNGroupsErrorMessage(s, failingGroup));\n             return s;\n         } catch (PatternSyntaxException e) {\n             throw new Error(e);\n@@ -406,6 +400,15 @@ private static String regexErrorMessage(String s, int expectedGroups, int actual\n                 + \" groups are needed.\";\n     }\n \n+    /**\n+     * Generates an error message for s when nullableGroup is expected to be definitely non-null but\n+     * turns out to be nullable.\n+     *\n+     * @param s string to check for being a regular expression\n+     * @param nullableGroup group expected to be non-null\n+     * @return an error message for s when nullableGroup is expected to be definitely non-null but\n+     *     turns out to be nullable.\n+     */\n     private static String regexNNGroupsErrorMessage(String s, int nullableGroup) {\n         return \"for regex \\\"\"\n                 + s\n@@ -436,124 +439,148 @@ private static int getGroupCount(Pattern p) {\n      * @param n number of capturing groups in the pattern\n      * @return a {@code List} of groups that are guaranteed to match some part of a string that\n      *     matches {@code regexp}\n-     * @throws Error if the argument is not a regex\n+     * @throws Error if the argument is not a regex or has less than the specified number of groups\n      */\n     public static List<Integer> getNonNullGroups(String regexp, int n) {\n         try {\n-            Pattern.compile(regexp);\n+            Pattern p = Pattern.compile(regexp);\n+            int actualGroups = getGroupCount(p);\n+            if (actualGroups < n) {\n+                throw new Error(regexErrorMessage(regexp, n, actualGroups));\n+            }\n         } catch (PatternSyntaxException e) {\n             throw new Error(e);\n         }\n+        // The list that will hold the groups that are guaranteed to match some part of text that\n+        // matches the regex. Initially holds all the groups. The optional groups will be removed.\n         List<Integer> nonNullGroups = new ArrayList<>();\n         for (int i = 1; i <= n; i++) {\n             nonNullGroups.add(i);\n         }\n \n-        // Holds all indices of opening parentheses that were openings of a capturing group.\n-        ArrayDeque<Integer> openingIndices = new ArrayDeque<>();\n-        // Holds whether the last occurrence of a non-literal '(' was a capturing group (true)\n-        // or was some other special construct (false). This helps in determining whether a\n-        // non-literal\n-        // ')' closes a capturing group or some other special construct. If it closes a capturing\n-        // group, the top element from openingIndices has to be removed.\n-        ArrayDeque<Boolean> openingWasGroup = new ArrayDeque<>();\n-        // If true, the character just before the current one was '\\', i.e. the current character\n-        // has to be considered either in a literal sense or as some special character or flag.\n-        boolean escaped = false;\n+        // ArrayDeque here is used as a stack.\n+        // We need stack functionality because brackets that were last opened during the traversal\n+        // need to be closed first.\n+\n+        // Indices of the groups that are currently not closed. It is a ArrayDeque which is used as\n+        // a stack.\n+        // An element is pushed to it when we encounter a '(' which opens a capturing group.\n+        // An element popped from it when a ')' is encountered which is closing a capturing group.\n+        // We know ')' closes a capturing group from our boolean stack.\n+        ArrayDeque<Integer> unclosedCapturingGroups = new ArrayDeque<>();\n+\n+        // Stores whether the last occurrence of '(' in the regex marked a capturing group (true) or\n+        // a non-capturing group (false).\n+        // Element is pushed to it when a '(' is encountered. If it is a capturing group (named or\n+        // unnamed), push true otherwise push false.\n+        // Element is popped from it when a ')' is encountered. If the popped element is true, it\n+        // means that the ')' closes a capturing group (we need to pop from the Integer deque)\n+        // otherwise it closes a non-capturing group.\n+        ArrayDeque<Boolean> lastUnclosedWasCapturingGroup = new ArrayDeque<>();\n+\n+        // Number of capturing groups encountered. Used for numbering of the capturing groups.\n+        // Increments every time a '(' that opens a capturing group is encountered during the\n+        // traversal. This is the value that is pushed onto the Integer deque.\n         int group = 0;\n \n-        /**\n-         * If you encounter '(' and it is not preceded by a '\\', then it is a special group. If it\n-         * is followed by a '?', it will either be a named capturing group or some other special\n-         * construct. A named capturing group has a '<' followed by the '?'. The boolean stack is to\n-         * figure out whether a ')' closes a capturing group or a special construct.\n-         *\n-         * <p>If you encounter a '\\' it defines some sort of flag or special character. If the '\\'\n-         * is preceded by another '\\', it represents the literal '\\'.\n-         *\n-         * <p>If you encounter a '[' and it was not preceded by a '\\', it marks the beginning of a\n-         * literal list. Traverse inside the list till you encounter the closing ']', then resume\n-         * normal traversal.\n-         *\n-         * <p>If you encounter a 'Q' which is preceded by a '\\', it marks the beginning of a quote.\n-         * Traverse until you find the corresponding '\\E', then resume normal traversal.\n-         */\n+        // Optional group here onwards means the ith capturing group, which may not match any part\n+        // of a text that matched the regular expression and thus may return null on calls to\n+        // matcher.group(i).\n+\n+        // If you encounter '(', check the next character. If it is a '?', it is a special\n+        // construct,\n+        // (either pure, non-capturing groups that do not capture text and do not count towards the\n+        // group total, or named-capturing group) and we need to check the next character. If the\n+        // character following the '?' is a '<' the '(' represents the opening of a named-capturing\n+        // group and it will be handled like a normal capturing group. If the '(' was not followed\n+        // by a '?', it is a normal capturing group.\n+        // In case of capturing groups, increment the group variable and push it to the\n+        // unclosedCapturingGroups deque. Push true to the lastUnclosedWasCapturingGroup deque.\n+        // In case of non-capturing groups, push false to the lastUnclosedWasCapturingGroup deque.\n+        // We need the boolean deque so that when we encounter a ')', we can know whether it closes\n+        // a capturing group (the top element is true) or a non-capturing group (the top element is\n+        // false). One additional check is required. If '(' represented a capturing a group and was\n+        // preceded by '|', it is an optional group.\n+\n+        // If you encounter ')', check the top of the lastUnclosedWasCapturingGroup deque. If it was\n+        // false, do nothing otherwise remove the top element from the deque since it is now closed\n+        // and check if it is followed by a '?', '*', '|' or '{0'. If it is, then it is an optional\n+        // group otherwise not. If it is an optional group, remove it from the nonNullGroups list.\n+\n+        // If you encounter '[', traverse the regex till you find the closing '[', you may encounter\n+        // more of '[' in the process, keep a track of the number of character classes that are\n+        // still open. Keep on traversing till the number becomes 0. After this resume normal\n+        // traversal.\n+\n+        // If you encounter '\\', check the next character. If it is not 'Q', skip the next\n+        // character. If it is 'Q', it marks the beginning of a literal quote, find the next\n+        // occurrence of '\\E', which marks the end of quote. Set the loop variable to the index of\n+        // 'E' and resume normal traversal.\n+\n         final int length = regexp.length();\n         for (int i = 0; i < length; i++) {\n             if (regexp.charAt(i) == '(') {\n-                if (!escaped) {\n-                    if (i != length - 1) {\n-                        if (regexp.charAt(i + 1) == '?') {\n-                            if (i < length - 2\n-                                    && regexp.charAt(i + 2) == '<') { // named capturing group.\n-                                group += 1;\n-                                if (i != 0 && regexp.charAt(i - 1) == '|') {\n-                                    nonNullGroups.remove(Integer.valueOf(group));\n-                                }\n-                                openingIndices.push(group);\n-                                openingWasGroup.push(true);\n-                            } else { // non capturing group.\n-                                openingWasGroup.push(false);\n-                            }\n-                        } else { // unnamed capturing group.\n-                            group += 1;\n-                            if (i != 0 && regexp.charAt(i - 1) == '|') {\n-                                nonNullGroups.remove(Integer.valueOf(group));\n-                            }\n-                            openingIndices.push(group);\n-                            openingWasGroup.push(true);\n-                        }\n+                boolean isCapturingGroup = false;\n+                if ((i < length - 1)\n+                        && (regexp.startsWith(\"?<\", i + 1) || regexp.charAt(i + 1) != '?')) {\n+                    group += 1;\n+                    unclosedCapturingGroups.push(group);\n+                    isCapturingGroup = true;\n+                }\n+                lastUnclosedWasCapturingGroup.push(isCapturingGroup);\n+                if (isCapturingGroup) {\n+                    if (i > 0 && regexp.charAt(i - 1) == '|') {\n+                        nonNullGroups.remove(Integer.valueOf(group));\n                     }\n-                } else {\n-                    escaped = false;\n                 }\n             } else if (regexp.charAt(i) == ')') {\n-                if (!escaped) { // ending of a construct.\n-                    boolean closesGroup = openingWasGroup.pop();\n-                    if (closesGroup) {\n-                        int value = openingIndices.pop();\n-                        if (i != regexp.length() - 1\n-                                && \"?|*\".contains(Character.toString(regexp.charAt(i + 1)))) {\n-                            nonNullGroups.remove(Integer.valueOf(value));\n-                        } else if (i < length - 2\n-                                && regexp.charAt(i + 1) == '{'\n-                                && regexp.charAt(i + 2) == '0') {\n-                            nonNullGroups.remove(Integer.valueOf(value));\n-                        }\n+                boolean closesCapturingGroup = lastUnclosedWasCapturingGroup.pop();\n+                if (closesCapturingGroup) {\n+                    Integer closedGroupIndex = unclosedCapturingGroups.pop();\n+                    if ((i < length - 1 && \"?*|\".contains(String.valueOf(regexp.charAt(i + 1))))\n+                            || (i < length - 2 && regexp.startsWith(\"{0\", i + 1))) {\n+                        nonNullGroups.remove(closedGroupIndex);\n                     }\n-                } else {\n-                    escaped = false;\n                 }\n-            } else if (regexp.charAt(i) == '\\\\') {\n-                escaped = !escaped;\n             } else if (regexp.charAt(i) == '[') {\n-                if (!escaped) {\n-                    int balance = 1;\n-                    int j;\n-                    for (j = i + 1; balance > 0; j++) {\n-                        if (regexp.charAt(j) == '\\\\') {\n-                            escaped = !escaped;\n-                        } else if (regexp.charAt(j) == ']' && !escaped) {\n+                int balance = 1, j;\n+                // the loop starts from i+2 because the character class cannot be empty. \"[]]\" is a\n+                // valid regex.\n+                for (j = i + 1; j < length && balance > 0; j++) {\n+                    if (regexp.charAt(j) == '[') {\n+                        balance += 1;\n+                    } else if (regexp.charAt(j) == ']') {\n+                        // in \"[]]\", the first ']' is considered literally.\n+                        // Similarly in \"[[]]], the first ']' is considered literally.\n+                        // in \"[][]]]\", the first and second ']' are considered literally.\n+                        // Thus ']' that immediately follows a '[' does not close a character class.\n+                        if (regexp.charAt(j - 1) != '[') {\n                             balance -= 1;\n-                        } else if (escaped) {\n-                            escaped = false;\n                         }\n+                    } else if (regexp.charAt(j) == '\\\\') {\n+                        j = resumeFromHere(regexp, j);\n                     }\n-                    i = j - 1;\n-                } else {\n-                    escaped = false;\n-                }\n-            } else if (regexp.charAt(i) == 'Q') {\n-                if (escaped) {\n-                    escaped = false;\n-                }\n-                i = regexp.indexOf(\"\\\\E\", i) + 1;\n-            } else { // any other character.\n-                if (escaped) {\n-                    escaped = false;\n                 }\n+                i = j - 1;\n+            } else if (regexp.charAt(i) == '\\\\') {\n+                i = resumeFromHere(regexp, i);\n             }\n         }\n         return nonNullGroups;\n     }\n+\n+    /**\n+     * Returns the index till which the regex can be skipped, when '\\' is encountered.\n+     *\n+     * @param regexp the regular expression to analyse\n+     * @param st the index of the '\\' which causes the skip\n+     * @return the index till which the traversal can be skipped\n+     */\n+    private static int resumeFromHere(String regexp, int st) {\n+        int length = regexp.length();\n+        if (st < length - 1 && regexp.charAt(st + 1) != 'Q') {\n+            return st + 1;\n+        }\n+        return regexp.indexOf(\"\\\\E\", st) + 1;\n+    }\n }"
  },
  {
    "sha": "e0ed55b01f2051b274c46f984314a486196c720a",
    "filename": "checker/tests/regex/RegexNNGroupsTest.java",
    "status": "modified",
    "additions": 16,
    "deletions": 0,
    "changes": 16,
    "blob_url": "https://github.com/UtR491/checker-framework/blob/8bd609331717b8d9166503abf2543a9a957d91d0/checker/tests/regex/RegexNNGroupsTest.java",
    "raw_url": "https://github.com/UtR491/checker-framework/raw/8bd609331717b8d9166503abf2543a9a957d91d0/checker/tests/regex/RegexNNGroupsTest.java",
    "contents_url": "https://api.github.com/repos/UtR491/checker-framework/contents/checker/tests/regex/RegexNNGroupsTest.java?ref=8bd609331717b8d9166503abf2543a9a957d91d0",
    "patch": "@@ -68,6 +68,22 @@ void getNonNullImplementationTest() {\n                 groups = 1,\n                 nonNullGroups = {1})\n         String s = \"\\\\\\\\include\\\\{(.*)\\\\}\";\n+        @RegexNNGroups(groups = 3)\n+        // :: error: (assignment.type.incompatible)\n+        String s14 = \"[(a-d&&[^x-z]&&[()\\\\\\\\(\\\\)])]|(abc)\";\n+\n+        @RegexNNGroups(\n+                groups = 1,\n+                nonNullGroups = {1})\n+        // :: error: (assignment.type.incompatible)\n+        String s15 = \"[(a-d&&[^x-z]&&[()\\\\\\\\(\\\\)])]|(abc)\";\n+\n+        @RegexNNGroups(groups = 1) String s16 = \"[(a-d&&[^x-z]&&[()\\\\\\\\(\\\\)])]|(abc)\";\n+        @RegexNNGroups(groups = 0) String s17 = \"[])]\";\n+        @RegexNNGroups(\n+                groups = 1,\n+                nonNullGroups = {1})\n+        String s18 = \"([(\\\\Q()\\\\E)])\\\\d[^\\\\d]\";\n     }\n \n     String s = \"(abc)(def)?(?<alpha>alpha)?.\";"
  }
]
