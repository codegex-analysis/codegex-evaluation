[
  {
    "sha": "f05c30180d583299e4c78d1fb072b053927056fc",
    "filename": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.kt",
    "status": "modified",
    "additions": 3,
    "deletions": 10,
    "changes": 13,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.kt",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.kt",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.kt?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -2162,14 +2162,11 @@ class RealmProxyClassGenerator(private val processingEnvironment: ProcessingEnvi\n                                     emitStatement(\"$genericType ${fieldName}UnmanagedEntryValue = entry.getValue()\")\n                                     emitStatement(\"$genericType cache${fieldName} = (${genericType}) cache.get(${fieldName}UnmanagedEntryValue)\")\n \n-                                    // TODO: is this is needed at all? According to the table.cpp\n-                                    //  ColKey Table::add_column_dictionary method throws if the\n-                                    //  field is an embedded object\n                                     if (isEmbedded) {\n                                         beginControlFlow(\"if (cache${fieldName} != null)\")\n                                             emitStatement(\"\"\"throw new IllegalArgumentException(\"Embedded objects can only have one parent pointing to them. This object was already copied, so another object is pointing to it: cache${fieldName}.toString()\")\"\"\")\n                                         nextControlFlow(\"else\")\n-                                            emitStatement(\"long objKey = ${fieldName}ManagedDictionary.getOsMap().createAndPutEmbeddedObject(realm.sharedRealm, entryKey)\")\n+                                            emitStatement(\"long objKey = ${fieldName}ManagedDictionary.getOsMap().createAndPutEmbeddedObject(entryKey)\")\n                                             emitStatement(\"Row linkedObjectRow = realm.getTable(${genericType}.class).getUncheckedRow(objKey)\")\n                                             emitStatement(\"$genericType linkedObject = ${linkedProxyClass}.newProxyInstance(realm, linkedObjectRow)\")\n                                             emitStatement(\"cache.put(${fieldName}UnmanagedEntryValue, (RealmObjectProxy) linkedObject)\")\n@@ -2294,10 +2291,6 @@ class RealmProxyClassGenerator(private val processingEnvironment: ProcessingEnvi\n                             val valueDictionaryFieldType = Utils.getDictionaryValueTypeQualifiedName(field)\n                             val genericType = requireNotNull(Utils.getGenericTypeQualifiedName(field))\n \n-                            emitSingleLineComment(\"proxyClassSimpleName: $proxyClassSimpleName\")\n-                            emitSingleLineComment(\"valueDictionaryFieldType: $valueDictionaryFieldType\")\n-                            emitSingleLineComment(\"genericType: $genericType\")\n-\n                             emitEmptyLine()\n                             emitSingleLineComment(\"Deep copy of $fieldName\")\n                             beginControlFlow(\"if (currentDepth == maxDepth)\")\n@@ -2567,8 +2560,8 @@ class RealmProxyClassGenerator(private val processingEnvironment: ProcessingEnvi\n                             emitStatement(\"stringBuilder.append((%1\\$s().isNull()) ? \\\"null\\\" : \\\"%s()\\\")\", metadata.getInternalGetter(fieldName), metadata.getInternalGetter(fieldName))\n                         }\n                         Utils.isRealmDictionary(field) -> {\n-                            // TODO: maps\n-                            emitSingleLineComment(\"TODO: Dictionary\")\n+                            val genericTypeSimpleName: SimpleClassName? = Utils.getDictionaryValueTypeQualifiedName(field)?.getSimpleName()\n+                            emitStatement(\"stringBuilder.append(\\\"RealmDictionary<%s>[\\\").append(%s().size()).append(\\\"]\\\")\", genericTypeSimpleName, metadata.getInternalGetter(fieldName))\n                         }\n                         else -> {\n                             if (metadata.isNullable(field)) {"
  },
  {
    "sha": "b7a6fe6327f08e80c69f1e4d24730fb383876e3d",
    "filename": "realm/realm-annotations-processor/src/test/resources/io/realm/some_test_AllTypesRealmProxy.java",
    "status": "modified",
    "additions": 918,
    "deletions": 2,
    "changes": 920,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_AllTypesRealmProxy.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_AllTypesRealmProxy.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_AllTypesRealmProxy.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -75,9 +75,24 @@\n         long columnObjectIdListColKey;\n         long columnUUIDListColKey;\n         long columnMixedListColKey;\n+        long columnRealmDictionaryColKey;\n+        long columnBooleanDictionaryColKey;\n+        long columnStringDictionaryColKey;\n+        long columnIntegerDictionaryColKey;\n+        long columnFloatDictionaryColKey;\n+        long columnLongDictionaryColKey;\n+        long columnShortDictionaryColKey;\n+        long columnDoubleDictionaryColKey;\n+        long columnByteDictionaryColKey;\n+        long columnBinaryDictionaryColKey;\n+        long columnDateDictionaryColKey;\n+        long columnObjectIdDictionaryColKey;\n+        long columnUUIDDictionaryColKey;\n+        long columnDecimal128DictionaryColKey;\n+        long columnMixedDictionaryColKey;\n \n         AllTypesColumnInfo(OsSchemaInfo schemaInfo) {\n-            super(32);\n+            super(47);\n             OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo(\"AllTypes\");\n             this.columnStringColKey = addColumnDetails(\"columnString\", \"columnString\", objectSchemaInfo);\n             this.columnLongColKey = addColumnDetails(\"columnLong\", \"columnLong\", objectSchemaInfo);\n@@ -111,6 +126,21 @@\n             this.columnObjectIdListColKey = addColumnDetails(\"columnObjectIdList\", \"columnObjectIdList\", objectSchemaInfo);\n             this.columnUUIDListColKey = addColumnDetails(\"columnUUIDList\", \"columnUUIDList\", objectSchemaInfo);\n             this.columnMixedListColKey = addColumnDetails(\"columnMixedList\", \"columnMixedList\", objectSchemaInfo);\n+            this.columnRealmDictionaryColKey = addColumnDetails(\"columnRealmDictionary\", \"columnRealmDictionary\", objectSchemaInfo);\n+            this.columnBooleanDictionaryColKey = addColumnDetails(\"columnBooleanDictionary\", \"columnBooleanDictionary\", objectSchemaInfo);\n+            this.columnStringDictionaryColKey = addColumnDetails(\"columnStringDictionary\", \"columnStringDictionary\", objectSchemaInfo);\n+            this.columnIntegerDictionaryColKey = addColumnDetails(\"columnIntegerDictionary\", \"columnIntegerDictionary\", objectSchemaInfo);\n+            this.columnFloatDictionaryColKey = addColumnDetails(\"columnFloatDictionary\", \"columnFloatDictionary\", objectSchemaInfo);\n+            this.columnLongDictionaryColKey = addColumnDetails(\"columnLongDictionary\", \"columnLongDictionary\", objectSchemaInfo);\n+            this.columnShortDictionaryColKey = addColumnDetails(\"columnShortDictionary\", \"columnShortDictionary\", objectSchemaInfo);\n+            this.columnDoubleDictionaryColKey = addColumnDetails(\"columnDoubleDictionary\", \"columnDoubleDictionary\", objectSchemaInfo);\n+            this.columnByteDictionaryColKey = addColumnDetails(\"columnByteDictionary\", \"columnByteDictionary\", objectSchemaInfo);\n+            this.columnBinaryDictionaryColKey = addColumnDetails(\"columnBinaryDictionary\", \"columnBinaryDictionary\", objectSchemaInfo);\n+            this.columnDateDictionaryColKey = addColumnDetails(\"columnDateDictionary\", \"columnDateDictionary\", objectSchemaInfo);\n+            this.columnObjectIdDictionaryColKey = addColumnDetails(\"columnObjectIdDictionary\", \"columnObjectIdDictionary\", objectSchemaInfo);\n+            this.columnUUIDDictionaryColKey = addColumnDetails(\"columnUUIDDictionary\", \"columnUUIDDictionary\", objectSchemaInfo);\n+            this.columnDecimal128DictionaryColKey = addColumnDetails(\"columnDecimal128Dictionary\", \"columnDecimal128Dictionary\", objectSchemaInfo);\n+            this.columnMixedDictionaryColKey = addColumnDetails(\"columnMixedDictionary\", \"columnMixedDictionary\", objectSchemaInfo);\n             addBacklinkDetails(schemaInfo, \"parentObjects\", \"AllTypes\", \"columnObject\");\n         }\n \n@@ -160,6 +190,21 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {\n             dst.columnObjectIdListColKey = src.columnObjectIdListColKey;\n             dst.columnUUIDListColKey = src.columnUUIDListColKey;\n             dst.columnMixedListColKey = src.columnMixedListColKey;\n+            dst.columnRealmDictionaryColKey = src.columnRealmDictionaryColKey;\n+            dst.columnBooleanDictionaryColKey = src.columnBooleanDictionaryColKey;\n+            dst.columnStringDictionaryColKey = src.columnStringDictionaryColKey;\n+            dst.columnIntegerDictionaryColKey = src.columnIntegerDictionaryColKey;\n+            dst.columnFloatDictionaryColKey = src.columnFloatDictionaryColKey;\n+            dst.columnLongDictionaryColKey = src.columnLongDictionaryColKey;\n+            dst.columnShortDictionaryColKey = src.columnShortDictionaryColKey;\n+            dst.columnDoubleDictionaryColKey = src.columnDoubleDictionaryColKey;\n+            dst.columnByteDictionaryColKey = src.columnByteDictionaryColKey;\n+            dst.columnBinaryDictionaryColKey = src.columnBinaryDictionaryColKey;\n+            dst.columnDateDictionaryColKey = src.columnDateDictionaryColKey;\n+            dst.columnObjectIdDictionaryColKey = src.columnObjectIdDictionaryColKey;\n+            dst.columnUUIDDictionaryColKey = src.columnUUIDDictionaryColKey;\n+            dst.columnDecimal128DictionaryColKey = src.columnDecimal128DictionaryColKey;\n+            dst.columnMixedDictionaryColKey = src.columnMixedDictionaryColKey;\n         }\n     }\n \n@@ -190,6 +235,21 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {\n     private RealmList<org.bson.types.ObjectId> columnObjectIdListRealmList;\n     private RealmList<java.util.UUID> columnUUIDListRealmList;\n     private RealmList<Mixed> columnMixedListRealmList;\n+    private RealmDictionary<some.test.AllTypes> columnRealmDictionaryRealmDictionary;\n+    private RealmDictionary<Boolean> columnBooleanDictionaryRealmDictionary;\n+    private RealmDictionary<String> columnStringDictionaryRealmDictionary;\n+    private RealmDictionary<Integer> columnIntegerDictionaryRealmDictionary;\n+    private RealmDictionary<Float> columnFloatDictionaryRealmDictionary;\n+    private RealmDictionary<Long> columnLongDictionaryRealmDictionary;\n+    private RealmDictionary<Short> columnShortDictionaryRealmDictionary;\n+    private RealmDictionary<Double> columnDoubleDictionaryRealmDictionary;\n+    private RealmDictionary<Byte> columnByteDictionaryRealmDictionary;\n+    private RealmDictionary<byte[]> columnBinaryDictionaryRealmDictionary;\n+    private RealmDictionary<Date> columnDateDictionaryRealmDictionary;\n+    private RealmDictionary<org.bson.types.ObjectId> columnObjectIdDictionaryRealmDictionary;\n+    private RealmDictionary<java.util.UUID> columnUUIDDictionaryRealmDictionary;\n+    private RealmDictionary<org.bson.types.Decimal128> columnDecimal128DictionaryRealmDictionary;\n+    private RealmDictionary<Mixed> columnMixedDictionaryRealmDictionary;\n     private RealmResults<some.test.AllTypes> parentObjectsBacklinks;\n \n     some_test_AllTypesRealmProxy() {\n@@ -1383,6 +1443,604 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {\n         }\n     }\n \n+    @Override\n+    public RealmDictionary<some.test.AllTypes> realmGet$columnRealmDictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnRealmDictionaryRealmDictionary != null) {\n+            return columnRealmDictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getModelMap(columnInfo.columnRealmDictionaryColKey);\n+            columnRealmDictionaryRealmDictionary = new RealmDictionary<some.test.AllTypes>(proxyState.getRealm$realm(), osMap, some.test.AllTypes.class);\n+            return columnRealmDictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnRealmDictionary(RealmDictionary<some.test.AllTypes> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnRealmDictionary\")) {\n+                return;\n+            }\n+            // if the dictionary contains unmanaged RealmModel instances, convert them to managed.\n+            if (value != null && !value.isManaged()) {\n+                final Realm realm = (Realm) proxyState.getRealm$realm();\n+                final RealmDictionary<some.test.AllTypes> original = value;\n+                value = new RealmDictionary<some.test.AllTypes>();\n+                for (java.util.Map.Entry<String, some.test.AllTypes> entry : original.entrySet()) {\n+                    String entryKey = entry.getKey();\n+                    some.test.AllTypes entryValue = entry.getValue();\n+                    if (entryValue == null || RealmObject.isManaged(entryValue)) {\n+                        value.put(entryKey, entryValue);\n+                    } else {\n+                        value.put(entryKey, realm.copyToRealmOrUpdate(entryValue));\n+                    }\n+                }\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getModelMap(columnInfo.columnRealmDictionaryColKey);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, some.test.AllTypes> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            some.test.AllTypes entryValue = item.getValue();\n+            if (entryValue == null) {\n+                osMap.put(entryKey, null);\n+            } else {\n+                osMap.putRow(entryKey, ((RealmObjectProxy) entryValue).realmGet$proxyState().getRow$realm().getObjectKey());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public RealmDictionary<Boolean> realmGet$columnBooleanDictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnBooleanDictionaryRealmDictionary != null) {\n+            return columnBooleanDictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnBooleanDictionaryColKey, RealmFieldType.STRING_TO_BOOLEAN_MAP);\n+            columnBooleanDictionaryRealmDictionary = new RealmDictionary<java.lang.Boolean>(proxyState.getRealm$realm(), osMap, java.lang.Boolean.class);\n+            return columnBooleanDictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnBooleanDictionary(RealmDictionary<Boolean> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnBooleanDictionary\")) {\n+                return;\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnBooleanDictionaryColKey, RealmFieldType.STRING_TO_BOOLEAN_MAP);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, java.lang.Boolean> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            java.lang.Boolean entryValue = item.getValue();\n+            osMap.put(entryKey, entryValue);\n+        }\n+    }\n+\n+    @Override\n+    public RealmDictionary<String> realmGet$columnStringDictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnStringDictionaryRealmDictionary != null) {\n+            return columnStringDictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnStringDictionaryColKey, RealmFieldType.STRING_TO_STRING_MAP);\n+            columnStringDictionaryRealmDictionary = new RealmDictionary<java.lang.String>(proxyState.getRealm$realm(), osMap, java.lang.String.class);\n+            return columnStringDictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnStringDictionary(RealmDictionary<String> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnStringDictionary\")) {\n+                return;\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnStringDictionaryColKey, RealmFieldType.STRING_TO_STRING_MAP);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, java.lang.String> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            java.lang.String entryValue = item.getValue();\n+            osMap.put(entryKey, entryValue);\n+        }\n+    }\n+\n+    @Override\n+    public RealmDictionary<Integer> realmGet$columnIntegerDictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnIntegerDictionaryRealmDictionary != null) {\n+            return columnIntegerDictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnIntegerDictionaryColKey, RealmFieldType.STRING_TO_INTEGER_MAP);\n+            columnIntegerDictionaryRealmDictionary = new RealmDictionary<java.lang.Integer>(proxyState.getRealm$realm(), osMap, java.lang.Integer.class);\n+            return columnIntegerDictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnIntegerDictionary(RealmDictionary<Integer> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnIntegerDictionary\")) {\n+                return;\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnIntegerDictionaryColKey, RealmFieldType.STRING_TO_INTEGER_MAP);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, java.lang.Integer> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            java.lang.Integer entryValue = item.getValue();\n+            osMap.put(entryKey, entryValue);\n+        }\n+    }\n+\n+    @Override\n+    public RealmDictionary<Float> realmGet$columnFloatDictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnFloatDictionaryRealmDictionary != null) {\n+            return columnFloatDictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnFloatDictionaryColKey, RealmFieldType.STRING_TO_FLOAT_MAP);\n+            columnFloatDictionaryRealmDictionary = new RealmDictionary<java.lang.Float>(proxyState.getRealm$realm(), osMap, java.lang.Float.class);\n+            return columnFloatDictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnFloatDictionary(RealmDictionary<Float> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnFloatDictionary\")) {\n+                return;\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnFloatDictionaryColKey, RealmFieldType.STRING_TO_FLOAT_MAP);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, java.lang.Float> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            java.lang.Float entryValue = item.getValue();\n+            osMap.put(entryKey, entryValue);\n+        }\n+    }\n+\n+    @Override\n+    public RealmDictionary<Long> realmGet$columnLongDictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnLongDictionaryRealmDictionary != null) {\n+            return columnLongDictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnLongDictionaryColKey, RealmFieldType.STRING_TO_INTEGER_MAP);\n+            columnLongDictionaryRealmDictionary = new RealmDictionary<java.lang.Long>(proxyState.getRealm$realm(), osMap, java.lang.Long.class);\n+            return columnLongDictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnLongDictionary(RealmDictionary<Long> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnLongDictionary\")) {\n+                return;\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnLongDictionaryColKey, RealmFieldType.STRING_TO_INTEGER_MAP);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, java.lang.Long> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            java.lang.Long entryValue = item.getValue();\n+            osMap.put(entryKey, entryValue);\n+        }\n+    }\n+\n+    @Override\n+    public RealmDictionary<Short> realmGet$columnShortDictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnShortDictionaryRealmDictionary != null) {\n+            return columnShortDictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnShortDictionaryColKey, RealmFieldType.STRING_TO_INTEGER_MAP);\n+            columnShortDictionaryRealmDictionary = new RealmDictionary<java.lang.Short>(proxyState.getRealm$realm(), osMap, java.lang.Short.class);\n+            return columnShortDictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnShortDictionary(RealmDictionary<Short> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnShortDictionary\")) {\n+                return;\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnShortDictionaryColKey, RealmFieldType.STRING_TO_INTEGER_MAP);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, java.lang.Short> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            java.lang.Short entryValue = item.getValue();\n+            osMap.put(entryKey, entryValue);\n+        }\n+    }\n+\n+    @Override\n+    public RealmDictionary<Double> realmGet$columnDoubleDictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnDoubleDictionaryRealmDictionary != null) {\n+            return columnDoubleDictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnDoubleDictionaryColKey, RealmFieldType.STRING_TO_DOUBLE_MAP);\n+            columnDoubleDictionaryRealmDictionary = new RealmDictionary<java.lang.Double>(proxyState.getRealm$realm(), osMap, java.lang.Double.class);\n+            return columnDoubleDictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnDoubleDictionary(RealmDictionary<Double> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnDoubleDictionary\")) {\n+                return;\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnDoubleDictionaryColKey, RealmFieldType.STRING_TO_DOUBLE_MAP);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, java.lang.Double> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            java.lang.Double entryValue = item.getValue();\n+            osMap.put(entryKey, entryValue);\n+        }\n+    }\n+\n+    @Override\n+    public RealmDictionary<Byte> realmGet$columnByteDictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnByteDictionaryRealmDictionary != null) {\n+            return columnByteDictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnByteDictionaryColKey, RealmFieldType.STRING_TO_INTEGER_MAP);\n+            columnByteDictionaryRealmDictionary = new RealmDictionary<java.lang.Byte>(proxyState.getRealm$realm(), osMap, java.lang.Byte.class);\n+            return columnByteDictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnByteDictionary(RealmDictionary<Byte> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnByteDictionary\")) {\n+                return;\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnByteDictionaryColKey, RealmFieldType.STRING_TO_INTEGER_MAP);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, java.lang.Byte> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            java.lang.Byte entryValue = item.getValue();\n+            osMap.put(entryKey, entryValue);\n+        }\n+    }\n+\n+    @Override\n+    public RealmDictionary<byte[]> realmGet$columnBinaryDictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnBinaryDictionaryRealmDictionary != null) {\n+            return columnBinaryDictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnBinaryDictionaryColKey, RealmFieldType.STRING_TO_BINARY_MAP);\n+            columnBinaryDictionaryRealmDictionary = new RealmDictionary<byte[]>(proxyState.getRealm$realm(), osMap, byte[].class);\n+            return columnBinaryDictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnBinaryDictionary(RealmDictionary<byte[]> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnBinaryDictionary\")) {\n+                return;\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnBinaryDictionaryColKey, RealmFieldType.STRING_TO_BINARY_MAP);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, byte[]> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            byte[] entryValue = item.getValue();\n+            osMap.put(entryKey, entryValue);\n+        }\n+    }\n+\n+    @Override\n+    public RealmDictionary<Date> realmGet$columnDateDictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnDateDictionaryRealmDictionary != null) {\n+            return columnDateDictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnDateDictionaryColKey, RealmFieldType.STRING_TO_DATE_MAP);\n+            columnDateDictionaryRealmDictionary = new RealmDictionary<java.util.Date>(proxyState.getRealm$realm(), osMap, java.util.Date.class);\n+            return columnDateDictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnDateDictionary(RealmDictionary<Date> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnDateDictionary\")) {\n+                return;\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnDateDictionaryColKey, RealmFieldType.STRING_TO_DATE_MAP);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, java.util.Date> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            java.util.Date entryValue = item.getValue();\n+            osMap.put(entryKey, entryValue);\n+        }\n+    }\n+\n+    @Override\n+    public RealmDictionary<org.bson.types.ObjectId> realmGet$columnObjectIdDictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnObjectIdDictionaryRealmDictionary != null) {\n+            return columnObjectIdDictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnObjectIdDictionaryColKey, RealmFieldType.STRING_TO_OBJECT_ID_MAP);\n+            columnObjectIdDictionaryRealmDictionary = new RealmDictionary<org.bson.types.ObjectId>(proxyState.getRealm$realm(), osMap, org.bson.types.ObjectId.class);\n+            return columnObjectIdDictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnObjectIdDictionary(RealmDictionary<org.bson.types.ObjectId> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnObjectIdDictionary\")) {\n+                return;\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnObjectIdDictionaryColKey, RealmFieldType.STRING_TO_OBJECT_ID_MAP);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, org.bson.types.ObjectId> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            org.bson.types.ObjectId entryValue = item.getValue();\n+            osMap.put(entryKey, entryValue);\n+        }\n+    }\n+\n+    @Override\n+    public RealmDictionary<java.util.UUID> realmGet$columnUUIDDictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnUUIDDictionaryRealmDictionary != null) {\n+            return columnUUIDDictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnUUIDDictionaryColKey, RealmFieldType.STRING_TO_UUID_MAP);\n+            columnUUIDDictionaryRealmDictionary = new RealmDictionary<java.util.UUID>(proxyState.getRealm$realm(), osMap, java.util.UUID.class);\n+            return columnUUIDDictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnUUIDDictionary(RealmDictionary<java.util.UUID> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnUUIDDictionary\")) {\n+                return;\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnUUIDDictionaryColKey, RealmFieldType.STRING_TO_UUID_MAP);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, java.util.UUID> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            java.util.UUID entryValue = item.getValue();\n+            osMap.put(entryKey, entryValue);\n+        }\n+    }\n+\n+    @Override\n+    public RealmDictionary<org.bson.types.Decimal128> realmGet$columnDecimal128Dictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnDecimal128DictionaryRealmDictionary != null) {\n+            return columnDecimal128DictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnDecimal128DictionaryColKey, RealmFieldType.STRING_TO_DECIMAL128_MAP);\n+            columnDecimal128DictionaryRealmDictionary = new RealmDictionary<org.bson.types.Decimal128>(proxyState.getRealm$realm(), osMap, org.bson.types.Decimal128.class);\n+            return columnDecimal128DictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnDecimal128Dictionary(RealmDictionary<org.bson.types.Decimal128> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnDecimal128Dictionary\")) {\n+                return;\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getValueMap(columnInfo.columnDecimal128DictionaryColKey, RealmFieldType.STRING_TO_DECIMAL128_MAP);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, org.bson.types.Decimal128> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            org.bson.types.Decimal128 entryValue = item.getValue();\n+            osMap.put(entryKey, entryValue);\n+        }\n+    }\n+\n+    @Override\n+    public RealmDictionary<Mixed> realmGet$columnMixedDictionary() {\n+        proxyState.getRealm$realm().checkIfValid();\n+        // use the cached value if available\n+        if (columnMixedDictionaryRealmDictionary != null) {\n+            return columnMixedDictionaryRealmDictionary;\n+        } else {\n+            OsMap osMap = proxyState.getRow$realm().getMixedMap(columnInfo.columnMixedDictionaryColKey);\n+            columnMixedDictionaryRealmDictionary = new RealmDictionary<io.realm.Mixed>(proxyState.getRealm$realm(), osMap, io.realm.Mixed.class);\n+            return columnMixedDictionaryRealmDictionary;\n+        }\n+    }\n+\n+    @Override\n+    public void realmSet$columnMixedDictionary(RealmDictionary<Mixed> value) {\n+        if (proxyState.isUnderConstruction()) {\n+            if (!proxyState.getAcceptDefaultValue$realm()) {\n+                return;\n+            }\n+            if (proxyState.getExcludeFields$realm().contains(\"columnMixedDictionary\")) {\n+                return;\n+            }\n+            // if the dictionary contains unmanaged RealmModel instances boxed in Mixed objects, convert them to managed.\n+            if (value != null && !value.isManaged()) {\n+                final Realm realm = (Realm) proxyState.getRealm$realm();\n+                final RealmDictionary<io.realm.Mixed> original = value;\n+                value = new RealmDictionary<io.realm.Mixed>();\n+                for (java.util.Map.Entry<String, io.realm.Mixed> item : original.entrySet()) {\n+                    String entryKey = item.getKey();\n+                    io.realm.Mixed entryValue = item.getValue();\n+                    // ensure (potential) RealmModel instances are copied to Realm if generic type is Mixed\n+                    if (entryValue == null) {\n+                        value.put(entryKey, null);\n+                    } else if (entryValue.getType() == MixedType.OBJECT) {\n+                        RealmModel realmModel = entryValue.asRealmModel(RealmModel.class);\n+                        RealmModel modelFromRealm = realm.copyToRealmOrUpdate(realmModel);\n+                        value.put(entryKey, Mixed.valueOf(modelFromRealm));\n+                    } else {\n+                        value.put(entryKey, entryValue);\n+                    }\n+                }\n+            }\n+        }\n+\n+        proxyState.getRealm$realm().checkIfValid();\n+        OsMap osMap = proxyState.getRow$realm().getMixedMap(columnInfo.columnMixedDictionaryColKey);\n+        if (value == null) {\n+            return;\n+        }\n+        osMap.clear();\n+        for (java.util.Map.Entry<String, io.realm.Mixed> item : value.entrySet()) {\n+            String entryKey = item.getKey();\n+            io.realm.Mixed entryValue = item.getValue();\n+            if (entryValue == null) {\n+                osMap.put(entryKey, null);\n+            } else {\n+                osMap.putMixed(entryKey, entryValue.getNativePtr());\n+            }\n+        }\n+    }\n+\n     @Override\n     public RealmResults<some.test.AllTypes> realmGet$parentObjects() {\n         BaseRealm realm = proxyState.getRealm$realm();\n@@ -1395,7 +2053,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {\n     }\n \n     private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {\n-        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder(NO_ALIAS, \"AllTypes\", false, 32, 1);\n+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder(NO_ALIAS, \"AllTypes\", false, 47, 1);\n         builder.addPersistedProperty(NO_ALIAS, \"columnString\", RealmFieldType.STRING, Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);\n         builder.addPersistedProperty(NO_ALIAS, \"columnLong\", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);\n         builder.addPersistedProperty(NO_ALIAS, \"columnFloat\", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);\n@@ -1428,6 +2086,22 @@ private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {\n         builder.addPersistedValueListProperty(NO_ALIAS, \"columnObjectIdList\", RealmFieldType.OBJECT_ID_LIST, !Property.REQUIRED);\n         builder.addPersistedValueListProperty(NO_ALIAS, \"columnUUIDList\", RealmFieldType.UUID_LIST, !Property.REQUIRED);\n         builder.addPersistedValueListProperty(NO_ALIAS, \"columnMixedList\", RealmFieldType.MIXED_LIST, !Property.REQUIRED);\n+        builder.addPersistedLinkProperty(NO_ALIAS, \"columnRealmDictionary\", RealmFieldType.STRING_TO_LINK_MAP, \"AllTypes\");\n+        builder.addPersistedMapProperty(NO_ALIAS, \"columnBooleanDictionary\", RealmFieldType.STRING_TO_BOOLEAN_MAP, !Property.REQUIRED);\n+        builder.addPersistedMapProperty(NO_ALIAS, \"columnStringDictionary\", RealmFieldType.STRING_TO_STRING_MAP, !Property.REQUIRED);\n+        builder.addPersistedMapProperty(NO_ALIAS, \"columnIntegerDictionary\", RealmFieldType.STRING_TO_INTEGER_MAP, !Property.REQUIRED);\n+        builder.addPersistedMapProperty(NO_ALIAS, \"columnFloatDictionary\", RealmFieldType.STRING_TO_FLOAT_MAP, !Property.REQUIRED);\n+        builder.addPersistedMapProperty(NO_ALIAS, \"columnLongDictionary\", RealmFieldType.STRING_TO_INTEGER_MAP, !Property.REQUIRED);\n+        builder.addPersistedMapProperty(NO_ALIAS, \"columnShortDictionary\", RealmFieldType.STRING_TO_INTEGER_MAP, !Property.REQUIRED);\n+        builder.addPersistedMapProperty(NO_ALIAS, \"columnDoubleDictionary\", RealmFieldType.STRING_TO_DOUBLE_MAP, !Property.REQUIRED);\n+        builder.addPersistedMapProperty(NO_ALIAS, \"columnByteDictionary\", RealmFieldType.STRING_TO_INTEGER_MAP, !Property.REQUIRED);\n+        builder.addPersistedMapProperty(NO_ALIAS, \"columnBinaryDictionary\", RealmFieldType.STRING_TO_BINARY_MAP, !Property.REQUIRED);\n+        builder.addPersistedMapProperty(NO_ALIAS, \"columnDateDictionary\", RealmFieldType.STRING_TO_DATE_MAP, !Property.REQUIRED);\n+        builder.addPersistedMapProperty(NO_ALIAS, \"columnObjectIdDictionary\", RealmFieldType.STRING_TO_OBJECT_ID_MAP, !Property.REQUIRED);\n+        builder.addPersistedMapProperty(NO_ALIAS, \"columnUUIDDictionary\", RealmFieldType.STRING_TO_UUID_MAP, !Property.REQUIRED);\n+        builder.addPersistedMapProperty(NO_ALIAS, \"columnDecimal128Dictionary\", RealmFieldType.STRING_TO_DECIMAL128_MAP, !Property.REQUIRED);\n+        builder.addPersistedMapProperty(NO_ALIAS, \"columnMixedDictionary\", RealmFieldType.STRING_TO_MIXED_MAP, !Property.REQUIRED);\n+\n         builder.addComputedLinkProperty(\"parentObjects\", \"AllTypes\", \"columnObject\");\n         return builder.build();\n     }\n@@ -1953,6 +2627,36 @@ public static String getSimpleClassName() {\n                 objProxy.realmSet$columnUUIDList(ProxyUtils.createRealmListWithJsonStream(java.util.UUID.class, reader));\n             } else if (name.equals(\"columnMixedList\")) {\n                 objProxy.realmSet$columnMixedList(ProxyUtils.createRealmListWithJsonStream(io.realm.Mixed.class, reader));\n+            } else if (name.equals(\"columnRealmDictionary\")) {\n+                // TODO: Dictionary\n+            } else if (name.equals(\"columnBooleanDictionary\")) {\n+                // TODO: Dictionary\n+            } else if (name.equals(\"columnStringDictionary\")) {\n+                // TODO: Dictionary\n+            } else if (name.equals(\"columnIntegerDictionary\")) {\n+                // TODO: Dictionary\n+            } else if (name.equals(\"columnFloatDictionary\")) {\n+                // TODO: Dictionary\n+            } else if (name.equals(\"columnLongDictionary\")) {\n+                // TODO: Dictionary\n+            } else if (name.equals(\"columnShortDictionary\")) {\n+                // TODO: Dictionary\n+            } else if (name.equals(\"columnDoubleDictionary\")) {\n+                // TODO: Dictionary\n+            } else if (name.equals(\"columnByteDictionary\")) {\n+                // TODO: Dictionary\n+            } else if (name.equals(\"columnBinaryDictionary\")) {\n+                // TODO: Dictionary\n+            } else if (name.equals(\"columnDateDictionary\")) {\n+                // TODO: Dictionary\n+            } else if (name.equals(\"columnObjectIdDictionary\")) {\n+                // TODO: Dictionary\n+            } else if (name.equals(\"columnUUIDDictionary\")) {\n+                // TODO: Dictionary\n+            } else if (name.equals(\"columnDecimal128Dictionary\")) {\n+                // TODO: Dictionary\n+            } else if (name.equals(\"columnMixedDictionary\")) {\n+                // TODO: Dictionary\n             } else {\n                 reader.skipValue();\n             }\n@@ -2053,6 +2757,19 @@ static some_test_AllTypesRealmProxy newProxyInstance(BaseRealm realm, Row row) {\n         builder.addDecimal128List(columnInfo.columnDecimal128ListColKey, unmanagedSource.realmGet$columnDecimal128List());\n         builder.addObjectIdList(columnInfo.columnObjectIdListColKey, unmanagedSource.realmGet$columnObjectIdList());\n         builder.addUUIDList(columnInfo.columnUUIDListColKey, unmanagedSource.realmGet$columnUUIDList());\n+        builder.addBooleanValueDictionary(columnInfo.columnBooleanDictionaryColKey, unmanagedSource.realmGet$columnBooleanDictionary());\n+        builder.addStringValueDictionary(columnInfo.columnStringDictionaryColKey, unmanagedSource.realmGet$columnStringDictionary());\n+        builder.addIntegerValueDictionary(columnInfo.columnIntegerDictionaryColKey, unmanagedSource.realmGet$columnIntegerDictionary());\n+        builder.addFloatValueDictionary(columnInfo.columnFloatDictionaryColKey, unmanagedSource.realmGet$columnFloatDictionary());\n+        builder.addLongValueDictionary(columnInfo.columnLongDictionaryColKey, unmanagedSource.realmGet$columnLongDictionary());\n+        builder.addShortValueDictionary(columnInfo.columnShortDictionaryColKey, unmanagedSource.realmGet$columnShortDictionary());\n+        builder.addDoubleValueDictionary(columnInfo.columnDoubleDictionaryColKey, unmanagedSource.realmGet$columnDoubleDictionary());\n+        builder.addByteValueDictionary(columnInfo.columnByteDictionaryColKey, unmanagedSource.realmGet$columnByteDictionary());\n+        builder.addBinaryValueDictionary(columnInfo.columnBinaryDictionaryColKey, unmanagedSource.realmGet$columnBinaryDictionary());\n+        builder.addDateValueDictionary(columnInfo.columnDateDictionaryColKey, unmanagedSource.realmGet$columnDateDictionary());\n+        builder.addObjectIdValueDictionary(columnInfo.columnObjectIdDictionaryColKey, unmanagedSource.realmGet$columnObjectIdDictionary());\n+        builder.addUUIDValueDictionary(columnInfo.columnUUIDDictionaryColKey, unmanagedSource.realmGet$columnUUIDDictionary());\n+        builder.addDecimal128ValueDictionary(columnInfo.columnDecimal128DictionaryColKey, unmanagedSource.realmGet$columnDecimal128Dictionary());\n \n         // Create the underlying object and cache it before setting any object/objectlist references\n         // This will allow us to break any circular dependencies by using the object cache.\n@@ -2160,6 +2877,39 @@ static some_test_AllTypesRealmProxy newProxyInstance(BaseRealm realm, Row row) {\n             }\n         }\n \n+        RealmDictionary<some.test.AllTypes> columnRealmDictionaryUnmanagedDictionary = unmanagedSource.realmGet$columnRealmDictionary();\n+        if (columnRealmDictionaryUnmanagedDictionary != null) {\n+            RealmDictionary<some.test.AllTypes> columnRealmDictionaryManagedDictionary = managedCopy.realmGet$columnRealmDictionary();\n+            columnRealmDictionaryManagedDictionary.clear();\n+            java.util.Set<java.util.Map.Entry<String, some.test.AllTypes>> entries = columnRealmDictionaryUnmanagedDictionary.entrySet();\n+            for (java.util.Map.Entry<String, some.test.AllTypes> entry : entries) {\n+                String entryKey = entry.getKey();\n+                some.test.AllTypes columnRealmDictionaryUnmanagedEntryValue = entry.getValue();\n+                some.test.AllTypes cachecolumnRealmDictionary = (some.test.AllTypes) cache.get(columnRealmDictionaryUnmanagedEntryValue);\n+                if (cachecolumnRealmDictionary != null) {\n+                    columnRealmDictionaryManagedDictionary.put(entryKey, cachecolumnRealmDictionary);\n+                } else {\n+                    if (columnRealmDictionaryUnmanagedEntryValue == null) {\n+                        columnRealmDictionaryManagedDictionary.put(entryKey, null);\n+                    } else {\n+                        columnRealmDictionaryManagedDictionary.put(entryKey, some_test_AllTypesRealmProxy.copyOrUpdate(realm, (some_test_AllTypesRealmProxy.AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class), columnRealmDictionaryUnmanagedEntryValue, update, cache, flags));\n+                    }\n+                }\n+            }\n+        }\n+        RealmDictionary<Mixed> columnMixedDictionaryUnmanagedDictionary = unmanagedSource.realmGet$columnMixedDictionary();\n+        if (columnMixedDictionaryUnmanagedDictionary != null) {\n+            RealmDictionary<Mixed> columnMixedDictionaryManagedDictionary = managedCopy.realmGet$columnMixedDictionary();\n+            java.util.Set<java.util.Map.Entry<String, io.realm.Mixed>> entries = columnMixedDictionaryUnmanagedDictionary.entrySet();\n+            java.util.List<String> keys = new java.util.ArrayList<>();\n+            java.util.List<Long> mixedPointers = new java.util.ArrayList<>();\n+            for (java.util.Map.Entry<String, io.realm.Mixed> entry : entries) {\n+                Mixed mixedItem = entry.getValue();\n+                mixedItem = ProxyUtils.copyOrUpdate(mixedItem, realm, update, cache, flags);\n+                columnMixedDictionaryManagedDictionary.put(entry.getKey(), mixedItem);\n+            }\n+        }\n+\n         return managedCopy;\n     }\n \n@@ -3714,6 +4464,112 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob\n             }\n         }\n \n+        // Deep copy of columnRealmDictionary\n+        if (currentDepth == maxDepth) {\n+            unmanagedCopy.realmSet$columnRealmDictionary(null);\n+        } else {\n+            RealmDictionary<some.test.AllTypes> managedcolumnRealmDictionaryDictionary = realmSource.realmGet$columnRealmDictionary();\n+            RealmDictionary<some.test.AllTypes> unmanagedcolumnRealmDictionaryDictionary = new RealmDictionary<some.test.AllTypes>();\n+            unmanagedCopy.realmSet$columnRealmDictionary(unmanagedcolumnRealmDictionaryDictionary);\n+            int nextDepth = currentDepth + 1;\n+            for (Map.Entry<String, some.test.AllTypes> entry : managedcolumnRealmDictionaryDictionary.entrySet()) {\n+                some.test.AllTypes detachedValue = some_test_AllTypesRealmProxy.createDetachedCopy(entry.getValue(), nextDepth, maxDepth, cache);\n+                unmanagedcolumnRealmDictionaryDictionary.put(entry.getKey(), detachedValue);\n+            }\n+        }\n+\n+        unmanagedCopy.realmSet$columnBooleanDictionary(new RealmDictionary<java.lang.Boolean>());\n+        RealmDictionary<java.lang.Boolean> managedcolumnBooleanDictionaryDictionary = realmSource.realmGet$columnBooleanDictionary();\n+        for (Map.Entry<String, java.lang.Boolean> entry : managedcolumnBooleanDictionaryDictionary.entrySet()) {\n+            unmanagedCopy.realmGet$columnBooleanDictionary().put(entry.getKey(), entry.getValue());\n+        }\n+\n+        unmanagedCopy.realmSet$columnStringDictionary(new RealmDictionary<java.lang.String>());\n+        RealmDictionary<java.lang.String> managedcolumnStringDictionaryDictionary = realmSource.realmGet$columnStringDictionary();\n+        for (Map.Entry<String, java.lang.String> entry : managedcolumnStringDictionaryDictionary.entrySet()) {\n+            unmanagedCopy.realmGet$columnStringDictionary().put(entry.getKey(), entry.getValue());\n+        }\n+\n+        unmanagedCopy.realmSet$columnIntegerDictionary(new RealmDictionary<java.lang.Integer>());\n+        RealmDictionary<java.lang.Integer> managedcolumnIntegerDictionaryDictionary = realmSource.realmGet$columnIntegerDictionary();\n+        for (Map.Entry<String, java.lang.Integer> entry : managedcolumnIntegerDictionaryDictionary.entrySet()) {\n+            unmanagedCopy.realmGet$columnIntegerDictionary().put(entry.getKey(), entry.getValue());\n+        }\n+\n+        unmanagedCopy.realmSet$columnFloatDictionary(new RealmDictionary<java.lang.Float>());\n+        RealmDictionary<java.lang.Float> managedcolumnFloatDictionaryDictionary = realmSource.realmGet$columnFloatDictionary();\n+        for (Map.Entry<String, java.lang.Float> entry : managedcolumnFloatDictionaryDictionary.entrySet()) {\n+            unmanagedCopy.realmGet$columnFloatDictionary().put(entry.getKey(), entry.getValue());\n+        }\n+\n+        unmanagedCopy.realmSet$columnLongDictionary(new RealmDictionary<java.lang.Long>());\n+        RealmDictionary<java.lang.Long> managedcolumnLongDictionaryDictionary = realmSource.realmGet$columnLongDictionary();\n+        for (Map.Entry<String, java.lang.Long> entry : managedcolumnLongDictionaryDictionary.entrySet()) {\n+            unmanagedCopy.realmGet$columnLongDictionary().put(entry.getKey(), entry.getValue());\n+        }\n+\n+        unmanagedCopy.realmSet$columnShortDictionary(new RealmDictionary<java.lang.Short>());\n+        RealmDictionary<java.lang.Short> managedcolumnShortDictionaryDictionary = realmSource.realmGet$columnShortDictionary();\n+        for (Map.Entry<String, java.lang.Short> entry : managedcolumnShortDictionaryDictionary.entrySet()) {\n+            unmanagedCopy.realmGet$columnShortDictionary().put(entry.getKey(), entry.getValue());\n+        }\n+\n+        unmanagedCopy.realmSet$columnDoubleDictionary(new RealmDictionary<java.lang.Double>());\n+        RealmDictionary<java.lang.Double> managedcolumnDoubleDictionaryDictionary = realmSource.realmGet$columnDoubleDictionary();\n+        for (Map.Entry<String, java.lang.Double> entry : managedcolumnDoubleDictionaryDictionary.entrySet()) {\n+            unmanagedCopy.realmGet$columnDoubleDictionary().put(entry.getKey(), entry.getValue());\n+        }\n+\n+        unmanagedCopy.realmSet$columnByteDictionary(new RealmDictionary<java.lang.Byte>());\n+        RealmDictionary<java.lang.Byte> managedcolumnByteDictionaryDictionary = realmSource.realmGet$columnByteDictionary();\n+        for (Map.Entry<String, java.lang.Byte> entry : managedcolumnByteDictionaryDictionary.entrySet()) {\n+            unmanagedCopy.realmGet$columnByteDictionary().put(entry.getKey(), entry.getValue());\n+        }\n+\n+        unmanagedCopy.realmSet$columnBinaryDictionary(new RealmDictionary<byte[]>());\n+        RealmDictionary<byte[]> managedcolumnBinaryDictionaryDictionary = realmSource.realmGet$columnBinaryDictionary();\n+        for (Map.Entry<String, byte[]> entry : managedcolumnBinaryDictionaryDictionary.entrySet()) {\n+            unmanagedCopy.realmGet$columnBinaryDictionary().put(entry.getKey(), entry.getValue());\n+        }\n+\n+        unmanagedCopy.realmSet$columnDateDictionary(new RealmDictionary<java.util.Date>());\n+        RealmDictionary<java.util.Date> managedcolumnDateDictionaryDictionary = realmSource.realmGet$columnDateDictionary();\n+        for (Map.Entry<String, java.util.Date> entry : managedcolumnDateDictionaryDictionary.entrySet()) {\n+            unmanagedCopy.realmGet$columnDateDictionary().put(entry.getKey(), entry.getValue());\n+        }\n+\n+        unmanagedCopy.realmSet$columnObjectIdDictionary(new RealmDictionary<org.bson.types.ObjectId>());\n+        RealmDictionary<org.bson.types.ObjectId> managedcolumnObjectIdDictionaryDictionary = realmSource.realmGet$columnObjectIdDictionary();\n+        for (Map.Entry<String, org.bson.types.ObjectId> entry : managedcolumnObjectIdDictionaryDictionary.entrySet()) {\n+            unmanagedCopy.realmGet$columnObjectIdDictionary().put(entry.getKey(), entry.getValue());\n+        }\n+\n+        unmanagedCopy.realmSet$columnUUIDDictionary(new RealmDictionary<java.util.UUID>());\n+        RealmDictionary<java.util.UUID> managedcolumnUUIDDictionaryDictionary = realmSource.realmGet$columnUUIDDictionary();\n+        for (Map.Entry<String, java.util.UUID> entry : managedcolumnUUIDDictionaryDictionary.entrySet()) {\n+            unmanagedCopy.realmGet$columnUUIDDictionary().put(entry.getKey(), entry.getValue());\n+        }\n+\n+        unmanagedCopy.realmSet$columnDecimal128Dictionary(new RealmDictionary<org.bson.types.Decimal128>());\n+        RealmDictionary<org.bson.types.Decimal128> managedcolumnDecimal128DictionaryDictionary = realmSource.realmGet$columnDecimal128Dictionary();\n+        for (Map.Entry<String, org.bson.types.Decimal128> entry : managedcolumnDecimal128DictionaryDictionary.entrySet()) {\n+            unmanagedCopy.realmGet$columnDecimal128Dictionary().put(entry.getKey(), entry.getValue());\n+        }\n+\n+        // Deep copy of columnMixedDictionary\n+        if (currentDepth == maxDepth) {\n+            unmanagedCopy.realmSet$columnMixedDictionary(null);\n+        } else {\n+            RealmDictionary<Mixed> managedcolumnMixedDictionaryDictionary = realmSource.realmGet$columnMixedDictionary();\n+            RealmDictionary<Mixed> unmanagedcolumnMixedDictionaryDictionary = new RealmDictionary<Mixed>();\n+            unmanagedCopy.realmSet$columnMixedDictionary(unmanagedcolumnMixedDictionaryDictionary);\n+            int nextDepth = currentDepth + 1;\n+            for (Map.Entry<String, Mixed> entry : managedcolumnMixedDictionaryDictionary.entrySet()) {\n+                Mixed detachedValue = ProxyUtils.createDetachedCopy(entry.getValue(), objectRealm, nextDepth, maxDepth, cache);\n+                unmanagedcolumnMixedDictionaryDictionary.put(entry.getKey(), detachedValue);\n+            }\n+        }\n+\n         return unmanagedObject;\n     }\n \n@@ -3994,6 +4850,66 @@ public String toString() {\n         stringBuilder.append(\"{columnMixedList:\");\n         stringBuilder.append(\"RealmList<Mixed>[\").append(realmGet$columnMixedList().size()).append(\"]\");\n         stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnRealmDictionary:\");\n+        stringBuilder.append(\"RealmDictionary<AllTypes>[\").append(realmGet$columnRealmDictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnBooleanDictionary:\");\n+        stringBuilder.append(\"RealmDictionary<Boolean>[\").append(realmGet$columnBooleanDictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnStringDictionary:\");\n+        stringBuilder.append(\"RealmDictionary<String>[\").append(realmGet$columnStringDictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnIntegerDictionary:\");\n+        stringBuilder.append(\"RealmDictionary<Integer>[\").append(realmGet$columnIntegerDictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnFloatDictionary:\");\n+        stringBuilder.append(\"RealmDictionary<Float>[\").append(realmGet$columnFloatDictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnLongDictionary:\");\n+        stringBuilder.append(\"RealmDictionary<Long>[\").append(realmGet$columnLongDictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnShortDictionary:\");\n+        stringBuilder.append(\"RealmDictionary<Short>[\").append(realmGet$columnShortDictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnDoubleDictionary:\");\n+        stringBuilder.append(\"RealmDictionary<Double>[\").append(realmGet$columnDoubleDictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnByteDictionary:\");\n+        stringBuilder.append(\"RealmDictionary<Byte>[\").append(realmGet$columnByteDictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnBinaryDictionary:\");\n+        stringBuilder.append(\"RealmDictionary<byte[]>[\").append(realmGet$columnBinaryDictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnDateDictionary:\");\n+        stringBuilder.append(\"RealmDictionary<Date>[\").append(realmGet$columnDateDictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnObjectIdDictionary:\");\n+        stringBuilder.append(\"RealmDictionary<ObjectId>[\").append(realmGet$columnObjectIdDictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnUUIDDictionary:\");\n+        stringBuilder.append(\"RealmDictionary<UUID>[\").append(realmGet$columnUUIDDictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnDecimal128Dictionary:\");\n+        stringBuilder.append(\"RealmDictionary<Decimal128>[\").append(realmGet$columnDecimal128Dictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n+        stringBuilder.append(\",\");\n+        stringBuilder.append(\"{columnMixedDictionary:\");\n+        stringBuilder.append(\"RealmDictionary<Mixed>[\").append(realmGet$columnMixedDictionary().size()).append(\"]\");\n+        stringBuilder.append(\"}\");\n         stringBuilder.append(\"]\");\n         return stringBuilder.toString();\n     }"
  },
  {
    "sha": "152de3e660f65bd9a162ffd376987dc0b2146acc",
    "filename": "realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java",
    "status": "modified",
    "additions": 138,
    "deletions": 0,
    "changes": 138,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -24,6 +24,7 @@\n \n import io.realm.Mixed;\n import io.realm.MutableRealmInteger;\n+import io.realm.RealmDictionary;\n import io.realm.RealmList;\n import io.realm.RealmObject;\n import io.realm.RealmResults;\n@@ -84,6 +85,23 @@\n     private RealmList<UUID> columnUUIDList;\n     private RealmList<Mixed> columnMixedList;\n \n+    private RealmDictionary<AllTypes> columnRealmDictionary;\n+\n+    private RealmDictionary<Boolean> columnBooleanDictionary;\n+    private RealmDictionary<String> columnStringDictionary;\n+    private RealmDictionary<Integer> columnIntegerDictionary;\n+    private RealmDictionary<Float> columnFloatDictionary;\n+    private RealmDictionary<Long> columnLongDictionary;\n+    private RealmDictionary<Short> columnShortDictionary;\n+    private RealmDictionary<Double> columnDoubleDictionary;\n+    private RealmDictionary<Byte> columnByteDictionary;\n+    private RealmDictionary<byte[]> columnBinaryDictionary;\n+    private RealmDictionary<Date> columnDateDictionary;\n+    private RealmDictionary<ObjectId> columnObjectIdDictionary;\n+    private RealmDictionary<UUID> columnUUIDDictionary;\n+    private RealmDictionary<Decimal128> columnDecimal128Dictionary;\n+    private RealmDictionary<Mixed> columnMixedDictionary;\n+\n     @LinkingObjects(FIELD_PARENTS)\n     private final RealmResults<AllTypes> parentObjects = null;\n \n@@ -246,4 +264,124 @@ public Mixed getColumnMixed() {\n     public Mixed realmGet$columnMixed() {\n         return columnMixed;\n     }\n+\n+    public RealmDictionary<AllTypes> getColumnRealmDictionary() {\n+        return columnRealmDictionary;\n+    }\n+\n+    public void setColumnRealmDictionary(RealmDictionary<AllTypes> columnRealmDictionary) {\n+        this.columnRealmDictionary = columnRealmDictionary;\n+    }\n+\n+    public RealmDictionary<Boolean> getColumnBooleanDictionary() {\n+        return columnBooleanDictionary;\n+    }\n+\n+    public void setColumnBooleanDictionary(RealmDictionary<Boolean> columnBooleanDictionary) {\n+        this.columnBooleanDictionary = columnBooleanDictionary;\n+    }\n+\n+    public RealmDictionary<String> getColumnStringDictionary() {\n+        return columnStringDictionary;\n+    }\n+\n+    public void setColumnStringDictionary(RealmDictionary<String> columnStringDictionary) {\n+        this.columnStringDictionary = columnStringDictionary;\n+    }\n+\n+    public RealmDictionary<Integer> getColumnIntegerDictionary() {\n+        return columnIntegerDictionary;\n+    }\n+\n+    public void setColumnIntegerDictionary(RealmDictionary<Integer> columnIntegerDictionary) {\n+        this.columnIntegerDictionary = columnIntegerDictionary;\n+    }\n+\n+    public RealmDictionary<Float> getColumnFloatDictionary() {\n+        return columnFloatDictionary;\n+    }\n+\n+    public void setColumnFloatDictionary(RealmDictionary<Float> columnFloatDictionary) {\n+        this.columnFloatDictionary = columnFloatDictionary;\n+    }\n+\n+    public RealmDictionary<Long> getColumnLongDictionary() {\n+        return columnLongDictionary;\n+    }\n+\n+    public void setColumnLongDictionary(RealmDictionary<Long> columnLongDictionary) {\n+        this.columnLongDictionary = columnLongDictionary;\n+    }\n+\n+    public RealmDictionary<Short> getColumnShortDictionary() {\n+        return columnShortDictionary;\n+    }\n+\n+    public void setColumnShortDictionary(RealmDictionary<Short> columnShortDictionary) {\n+        this.columnShortDictionary = columnShortDictionary;\n+    }\n+\n+    public RealmDictionary<Double> getColumnDoubleDictionary() {\n+        return columnDoubleDictionary;\n+    }\n+\n+    public void setColumnDoubleDictionary(RealmDictionary<Double> columnDoubleDictionary) {\n+        this.columnDoubleDictionary = columnDoubleDictionary;\n+    }\n+\n+    public RealmDictionary<Byte> getColumnByteDictionary() {\n+        return columnByteDictionary;\n+    }\n+\n+    public void setColumnByteDictionary(RealmDictionary<Byte> columnByteDictionary) {\n+        this.columnByteDictionary = columnByteDictionary;\n+    }\n+\n+    public RealmDictionary<byte[]> getColumnBinaryDictionary() {\n+        return columnBinaryDictionary;\n+    }\n+\n+    public void setColumnBinaryDictionary(RealmDictionary<byte[]> columnBinaryDictionary) {\n+        this.columnBinaryDictionary = columnBinaryDictionary;\n+    }\n+\n+    public RealmDictionary<Date> getColumnDateDictionary() {\n+        return columnDateDictionary;\n+    }\n+\n+    public void setColumnDateDictionary(RealmDictionary<Date> columnDateDictionary) {\n+        this.columnDateDictionary = columnDateDictionary;\n+    }\n+\n+    public RealmDictionary<ObjectId> getColumnObjectIdDictionary() {\n+        return columnObjectIdDictionary;\n+    }\n+\n+    public void setColumnObjectIdDictionary(RealmDictionary<ObjectId> columnObjectIdDictionary) {\n+        this.columnObjectIdDictionary = columnObjectIdDictionary;\n+    }\n+\n+    public RealmDictionary<UUID> getColumnUUIDDictionary() {\n+        return columnUUIDDictionary;\n+    }\n+\n+    public void setColumnUUIDDictionary(RealmDictionary<UUID> columnUUIDDictionary) {\n+        this.columnUUIDDictionary = columnUUIDDictionary;\n+    }\n+\n+    public RealmDictionary<Decimal128> getColumnDecimal128Dictionary() {\n+        return columnDecimal128Dictionary;\n+    }\n+\n+    public void setColumnDecimal128Dictionary(RealmDictionary<Decimal128> columnDecimal128Dictionary) {\n+        this.columnDecimal128Dictionary = columnDecimal128Dictionary;\n+    }\n+\n+    public RealmDictionary<Mixed> getColumnMixedDictionary() {\n+        return columnMixedDictionary;\n+    }\n+\n+    public void setColumnMixedDictionary(RealmDictionary<Mixed> columnMixedDictionary) {\n+        this.columnMixedDictionary = columnMixedDictionary;\n+    }\n }"
  },
  {
    "sha": "673da799277637ceda62f688c530a69cdbe0c310",
    "filename": "realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java",
    "status": "modified",
    "additions": 98,
    "deletions": 2,
    "changes": 100,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -27,6 +27,7 @@\n import java.io.IOException;\n import java.lang.reflect.Field;\n import java.math.BigDecimal;\n+import java.util.AbstractMap;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Date;\n@@ -247,6 +248,10 @@ private void populateNoPrimaryKeyNullTypesRows() {\n \n         FIND_FIRST,\n         FIND_FIRST_ASYNC,\n+\n+        CONTAINS_KEY,\n+        CONTAINS_VALUE,\n+        CONTAINS_ENTRY,\n     }\n \n     private static void callThreadConfinedMethod(RealmQuery<?> query, ThreadConfinedMethods method) {\n@@ -358,6 +363,10 @@ private static void callThreadConfinedMethod(RealmQuery<?> query, ThreadConfined\n             case FIND_FIRST: query.findFirst(); break;\n             case FIND_FIRST_ASYNC: query.findFirstAsync(); break;\n \n+            case CONTAINS_KEY: query.containsKey(AllJavaTypes.FIELD_STRING, null); break;\n+            case CONTAINS_VALUE: query.containsValue(AllJavaTypes.FIELD_STRING, (String) null); break;\n+            case CONTAINS_ENTRY: query.containsEntry(AllJavaTypes.FIELD_STRING, new AbstractMap.SimpleImmutableEntry<>(null, null)); break;\n+\n             default:\n                 throw new AssertionError(\"missing case for \" + method);\n         }\n@@ -3790,14 +3799,14 @@ public void rawPredicate_invalidRealmObjectThrows() {\n             realm.where(AllTypes.class).rawPredicate(\"columnRealmObject = $0\", allTypes);\n             fail();\n         } catch (IllegalArgumentException e) {\n-            assertTrue(e.getMessage().contains(\"Argument[0] is not a valid managed object.\"));\n+            assertTrue(e.getMessage().contains(\"RealmObject is not a valid managed object.\"));\n         }\n \n         try {\n             realm.where(AllTypes.class).rawPredicate(\"columnRealmObject = $0\", new AllTypes());\n             fail();\n         } catch (IllegalArgumentException e) {\n-            assertTrue(e.getMessage().contains(\"Argument[0] is not a valid managed object.\"));\n+            assertTrue(e.getMessage().contains(\"RealmObject is not a valid managed object.\"));\n         }\n     }\n \n@@ -4118,6 +4127,93 @@ public void minimumDate_runOnMainThreadThrows() {\n         }\n     }\n \n+    private void fillDictionaryTests(){\n+        realm.executeTransaction(transactionRealm -> {\n+            AllTypes allTypes1 = realm.createObject(AllTypes.class);\n+            allTypes1.getColumnStringDictionary().put(\"hello world1\", \"Test1\");\n+\n+            AllTypes allTypes2 = realm.createObject(AllTypes.class);\n+            allTypes2.getColumnStringDictionary().put(\"hello world1\", \"Test2\");\n+\n+            AllTypes allTypes3 = realm.createObject(AllTypes.class);\n+            allTypes3.getColumnStringDictionary().put(\"hello world2\", \"Test2\");\n+        });\n+    }\n+\n+    @Test\n+    public void dictionary_containsKey(){\n+        fillDictionaryTests();\n+        RealmResults<AllTypes> results = realm.where(AllTypes.class).containsKey(AllTypes.FIELD_STRING_DICTIONARY, \"hello world1\").findAll();\n+        assertEquals(2, results.size());\n+        assertEquals(\"Test1\", results.get(0).getColumnStringDictionary().get(\"hello world1\"));\n+        assertEquals(\"Test2\", results.get(1).getColumnStringDictionary().get(\"hello world1\"));\n+    }\n+\n+    @Test\n+    public void dictionary_doesntContainKey(){\n+        fillDictionaryTests();\n+        RealmResults<AllTypes> results = realm.where(AllTypes.class).containsKey(AllTypes.FIELD_STRING_DICTIONARY, \"Do I exist?\").findAll();\n+        assertEquals(0, results.size());\n+    }\n+\n+    @Test\n+    public void dictionary_containsKeyNonLatin(){\n+        fillDictionaryTests();\n+        RealmResults<AllTypes> results = realm.where(AllTypes.class).containsKey(AllTypes.FIELD_STRING_DICTIONARY, \"델타\").findAll();\n+        assertEquals(0, results.size());\n+    }\n+\n+    @Test\n+    public void dictionary_containsValue(){\n+        fillDictionaryTests();\n+        RealmResults<AllTypes> results = realm.where(AllTypes.class).containsValue(AllTypes.FIELD_STRING_DICTIONARY, \"Test2\").findAll();\n+        assertEquals(2, results.size());\n+        assertEquals(\"Test2\", results.get(0).getColumnStringDictionary().get(\"hello world1\"));\n+        assertEquals(\"Test2\", results.get(1).getColumnStringDictionary().get(\"hello world2\"));\n+    }\n+\n+    @Test\n+    public void dictionary_doesntContainsValue(){\n+        fillDictionaryTests();\n+        RealmResults<AllTypes> results = realm.where(AllTypes.class).containsValue(AllTypes.FIELD_STRING_DICTIONARY, \"who am I\").findAll();\n+        assertEquals(0, results.size());\n+    }\n+\n+    @Test\n+    public void dictionary_containsEntry(){\n+        fillDictionaryTests();\n+        RealmResults<AllTypes> results = realm.where(AllTypes.class).containsEntry(AllTypes.FIELD_STRING_DICTIONARY, new AbstractMap.SimpleImmutableEntry<>(\"hello world1\", \"Test2\")).findAll();\n+        assertEquals(1, results.size());\n+        assertEquals(\"Test2\", results.first().getColumnStringDictionary().get(\"hello world1\"));\n+    }\n+\n+    @Test\n+    public void dictionary_doesntContainsEntry(){\n+        fillDictionaryTests();\n+        RealmResults<AllTypes> results = realm.where(AllTypes.class).containsEntry(AllTypes.FIELD_STRING_DICTIONARY, new AbstractMap.SimpleImmutableEntry<>(\"is this\", \"real\")).findAll();\n+        assertEquals(0, results.size());\n+    }\n+\n+    @Test\n+    public void dictionary_containsKeyNull(){\n+        fillDictionaryTests();\n+        RealmResults<AllTypes> results = realm.where(AllTypes.class).containsKey(AllTypes.FIELD_STRING_DICTIONARY, null).findAll();\n+        assertEquals(0, results.size());\n+    }\n+\n+    @Test\n+    public void dictionary_containsValueNull(){\n+        fillDictionaryTests();\n+        RealmResults<AllTypes> results = realm.where(AllTypes.class).containsValue(AllTypes.FIELD_STRING_DICTIONARY, (Date) null).findAll();\n+        assertEquals(0, results.size());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void dictionary_dictionary_containsEntryNull(){\n+        fillDictionaryTests();\n+        realm.where(AllTypes.class).containsEntry(AllTypes.FIELD_STRING_DICTIONARY, null);\n+    }\n+\n     // FIXME Maybe move to QueryDescriptor or maybe even to RealmFieldType?\n     private boolean supportDistinct(RealmFieldType type) {\n         switch (type) {"
  },
  {
    "sha": "9b54c5abde9ad974212df6e7f97cf53c7eac4752",
    "filename": "realm/realm-library/src/androidTest/kotlin/io/realm/DictionaryMiscTests.kt",
    "status": "renamed",
    "additions": 70,
    "deletions": 4,
    "changes": 74,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/androidTest/kotlin/io/realm/DictionaryMiscTests.kt",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/androidTest/kotlin/io/realm/DictionaryMiscTests.kt",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/androidTest/kotlin/io/realm/DictionaryMiscTests.kt?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -19,21 +19,24 @@ package io.realm\n import androidx.test.ext.junit.runners.AndroidJUnit4\n import androidx.test.platform.app.InstrumentationRegistry\n import io.realm.entities.DictionaryContainerClass\n+import io.realm.entities.EmbeddedObjectDictionaryContainerClass\n import io.realm.entities.StringOnly\n+import io.realm.entities.embedded.EmbeddedSimpleChild\n+import io.realm.entities.embedded.EmbeddedSimpleParent\n import io.realm.kotlin.createObject\n+import io.realm.kotlin.where\n import org.bson.types.Decimal128\n import org.bson.types.ObjectId\n+import org.junit.After\n import org.junit.Before\n import org.junit.Rule\n import org.junit.Test\n import org.junit.runner.RunWith\n import java.util.*\n-import kotlin.test.assertEquals\n-import kotlin.test.assertNotNull\n-import kotlin.test.assertTrue\n+import kotlin.test.*\n \n @RunWith(AndroidJUnit4::class)\n-class DictionaryMigrationTests {\n+class DictionaryMiscTests {\n \n     @Rule\n     @JvmField\n@@ -65,6 +68,11 @@ class DictionaryMigrationTests {\n         Realm.init(InstrumentationRegistry.getInstrumentation().context)\n     }\n \n+    @After\n+    fun tearDown() {\n+        realm.close()\n+    }\n+\n     @Test\n     fun migrate_realmDictionary() {\n         // Creates v0 of the Realm.\n@@ -112,4 +120,62 @@ class DictionaryMigrationTests {\n \n         realm.close()\n     }\n+\n+    @Test\n+    fun put_embeddedObject() {\n+        realm = Realm.getInstance(configFactory.createConfiguration())\n+        realm.executeTransaction {\n+            val parent = EmbeddedSimpleParent(\"parent\")\n+            parent.child = EmbeddedSimpleChild(\"child\")\n+\n+            val managedParent: EmbeddedSimpleParent = it.copyToRealm(parent)\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+            val managedChild: EmbeddedSimpleChild = managedParent.child!!\n+\n+            // Dictionary\n+            val container = it.createObject<EmbeddedObjectDictionaryContainerClass>()\n+            val dictionary = container.myEmbeddedObjectDictionary\n+            dictionary[\"HELLO\"] = managedChild\n+\n+            assertEquals(1, dictionary.size)\n+            val valueFromDictionary = dictionary[\"HELLO\"]\n+            assertNotNull(valueFromDictionary)\n+            assertNotEquals(managedChild, valueFromDictionary)     // should be NOT equals, they contain different objKeys\n+\n+            managedParent.deleteFromRealm()\n+            assertFalse(managedParent.isValid)\n+            assertEquals(1, dictionary.size)\n+            assertFalse(managedChild.isValid)\n+            assertTrue(valueFromDictionary.isValid)\n+        }\n+    }\n+\n+    @Test\n+    fun copyToRealm_unmanagedEmbeddedObject() {\n+        realm = Realm.getInstance(configFactory.createConfiguration())\n+        realm.executeTransaction {\n+            val unmanagedChild = EmbeddedSimpleChild(\"child\")\n+\n+            val unmanagedContainer = EmbeddedObjectDictionaryContainerClass().apply {\n+                myEmbeddedObjectDictionary[\"KEY_EMBEDDED\"] = unmanagedChild\n+            }\n+\n+            val managedContainer = it.copyToRealm(unmanagedContainer)\n+            assertNotNull(managedContainer)\n+            val managedDictionary = managedContainer.myEmbeddedObjectDictionary\n+            assertNotNull(managedDictionary)\n+            assertEquals(1, managedDictionary.size)\n+\n+            val managedChild = managedDictionary[\"KEY_EMBEDDED\"]\n+            assertNotNull(managedChild)\n+            assertTrue(managedChild.isValid)\n+            assertEquals(unmanagedChild.childId, managedChild.childId)\n+\n+            assertEquals(1, it.where<EmbeddedSimpleChild>().count())\n+            managedDictionary.clear()\n+            assertTrue(managedDictionary.isEmpty())\n+            assertEquals(0, it.where<EmbeddedSimpleChild>().count())\n+            assertFalse(managedChild.isValid)\n+        }\n+    }\n }",
    "previous_filename": "realm/realm-library/src/androidTest/kotlin/io/realm/DictionaryMigrationTests.kt"
  },
  {
    "sha": "ac64a99ec1499f08044b4614ffa71b4428f48147",
    "filename": "realm/realm-library/src/androidTest/kotlin/io/realm/ManagedDictionaryTesters.kt",
    "status": "modified",
    "additions": 8,
    "deletions": 12,
    "changes": 20,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/androidTest/kotlin/io/realm/ManagedDictionaryTesters.kt",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/androidTest/kotlin/io/realm/ManagedDictionaryTesters.kt",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/androidTest/kotlin/io/realm/ManagedDictionaryTesters.kt?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -526,16 +526,6 @@ class ManagedDictionaryTester<T : Any>(\n         return allTypesObject\n     }\n \n-    /**\n-     * Helper function to get the managed version of a particular unmanaged RealmModel.\n-     */\n-    private fun DogPrimaryKey.getFromRealm(realm: Realm): DogPrimaryKey? {\n-        return realm.where<DogPrimaryKey>()\n-                .equalTo(\"id\", this.id)\n-                .equalTo(\"name\", this.name)\n-                .findFirst()\n-    }\n-\n     private fun putInternal(\n             initialized: RealmDictionary<T>,\n             alternative: RealmDictionary<T>\n@@ -746,7 +736,8 @@ open class TypeAsserter<T> {\n     open fun assertRemoveRealmModelFromRealm(\n             dictionary: RealmDictionary<T>,\n             index: Int,\n-            key: String, value: T?\n+            key: String,\n+            value: T?\n     ) = Unit    // Do nothing if we aren't testing a RealmModel or a Mixed wrapping a RealmModel\n \n     // RealmModel requires different testing here\n@@ -962,7 +953,12 @@ class MixedAsserter : TypeAsserter<Mixed>() {\n         }\n     }\n \n-    override fun assertRemoveRealmModelFromRealm(dictionary: RealmDictionary<Mixed>, index: Int, key: String, value: Mixed?) {\n+    override fun assertRemoveRealmModelFromRealm(\n+            dictionary: RealmDictionary<Mixed>,\n+            index: Int,\n+            key: String,\n+            value: Mixed?\n+    ) {\n         // No need to check anything for other types than RealmModel\n         if (value is Mixed && value.valueClass == DogPrimaryKey::class.java) {\n             // Removal of actual RealmModel to check whether it vanished from the dictionary"
  },
  {
    "sha": "888d376976d3c998323e2cbce8c0af93668a91a8",
    "filename": "realm/realm-library/src/androidTest/kotlin/io/realm/entities/DictionaryContainerClass.kt",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/androidTest/kotlin/io/realm/entities/DictionaryContainerClass.kt",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/androidTest/kotlin/io/realm/entities/DictionaryContainerClass.kt",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/androidTest/kotlin/io/realm/entities/DictionaryContainerClass.kt?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -19,6 +19,7 @@ package io.realm.entities\n import io.realm.Mixed\n import io.realm.RealmDictionary\n import io.realm.RealmObject\n+import io.realm.entities.embedded.EmbeddedSimpleChild\n import org.bson.types.Decimal128\n import org.bson.types.ObjectId\n import java.util.*\n@@ -45,3 +46,7 @@ open class DictionaryContainerClass : RealmObject() {\n         const val CLASS_NAME = \"DictionaryContainerClass\"\n     }\n }\n+\n+open class EmbeddedObjectDictionaryContainerClass : RealmObject() {\n+    val myEmbeddedObjectDictionary = RealmDictionary<EmbeddedSimpleChild>()\n+}"
  },
  {
    "sha": "2396a1b61056617df4c9c50f98071f9d166f806a",
    "filename": "realm/realm-library/src/main/cpp/io_realm_internal_OsMap.cpp",
    "status": "modified",
    "additions": 2,
    "deletions": 3,
    "changes": 5,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/cpp/io_realm_internal_OsMap.cpp",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/cpp/io_realm_internal_OsMap.cpp",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/main/cpp/io_realm_internal_OsMap.cpp?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -439,21 +439,20 @@ Java_io_realm_internal_OsMap_nativeFreeze(JNIEnv* env, jclass, jlong wrapper_ptr\n \n JNIEXPORT jlong JNICALL\n Java_io_realm_internal_OsMap_nativeCreateAndPutEmbeddedObject(JNIEnv* env, jclass,\n-                                                              jlong shared_realm_ptr,\n                                                               jlong wrapper_ptr,\n                                                               jstring j_key) {\n     try {\n-        auto& realm = *reinterpret_cast<SharedRealm*>(shared_realm_ptr);\n         auto& wrapper = *reinterpret_cast<ObservableDictionaryWrapper*>(wrapper_ptr);\n         auto& dictionary = wrapper.collection();\n+        auto& realm = dictionary.get_realm();\n         auto& object_schema = dictionary.get_object_schema();\n \n         JStringAccessor key(env, j_key);\n         JavaContext context(env, realm, object_schema);\n \n         dictionary.insert(context, StringData(key), JavaValue(std::map<ColKey, JavaValue>()), CreatePolicy::Skip);\n         const Mixed& mixed = dictionary.get_any(StringData(key));\n-        return reinterpret_cast<jlong>(mixed.get_link().get_obj_key().value);\n+        return reinterpret_cast<jlong>(mixed.get<ObjKey>().value);\n     }\n     CATCH_STD()\n     return reinterpret_cast<jlong>(nullptr);"
  },
  {
    "sha": "c4fa0b4c7896743fc7cc3f3c3c32219b4d6c0c17",
    "filename": "realm/realm-library/src/main/java/io/realm/CollectionUtils.java",
    "status": "modified",
    "additions": 20,
    "deletions": 0,
    "changes": 20,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/CollectionUtils.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/CollectionUtils.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/main/java/io/realm/CollectionUtils.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -16,10 +16,15 @@\n \n package io.realm;\n \n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.Locale;\n \n import io.realm.internal.OsObjectStore;\n import io.realm.internal.RealmObjectProxy;\n+import io.realm.internal.RealmProxyMediator;\n+import io.realm.internal.Table;\n+import io.realm.internal.Util;\n \n public class CollectionUtils {\n \n@@ -138,4 +143,19 @@ static Mixed copyToRealmIfNeeded(BaseRealm realm, Mixed mixed) {\n             return realm.copyToRealm(object);\n         }\n     }\n+\n+    /**\n+     * Used to update an embedded object internally after its row has been created.\n+     *\n+     * @param realm      The Realm instance used to create the object.\n+     * @param realmModel the model that will be used to update the object.\n+     * @param objKey     the object key.\n+     */\n+    static void updateEmbeddedObject(Realm realm, RealmModel realmModel, long objKey) {\n+        RealmProxyMediator schemaMediator = realm.getConfiguration().getSchemaMediator();\n+        Class<? extends RealmModel> modelClass = Util.getOriginalModelClass(realmModel.getClass());\n+        Table table = realm.getTable(modelClass);\n+        RealmModel managedObject = schemaMediator.newInstance(modelClass, realm, table.getUncheckedRow(objKey), realm.getSchema().getColumnInfo(modelClass), true, Collections.EMPTY_LIST);\n+        schemaMediator.updateEmbeddedObject(realm, realmModel, managedObject, new HashMap<>(), Collections.EMPTY_SET);\n+    }\n }"
  },
  {
    "sha": "f536d44b7e4f09e3bd97d8b5fcbffd3a0273ff2c",
    "filename": "realm/realm-library/src/main/java/io/realm/ManagedListOperator.java",
    "status": "modified",
    "additions": 3,
    "deletions": 12,
    "changes": 15,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/ManagedListOperator.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/ManagedListOperator.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/main/java/io/realm/ManagedListOperator.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -216,7 +216,7 @@ public void appendValue(Object value) {\n                 throw new IllegalArgumentException(\"Embedded objects are not supported by RealmLists of DynamicRealmObjects yet.\");\n             }\n             long objKey = osList.createAndAddEmbeddedObject();\n-            updateEmbeddedObject(realmObject, objKey);\n+            CollectionUtils.updateEmbeddedObject((Realm) realm, realmObject, objKey);\n         } else {\n             RealmObjectProxy proxy = (RealmObjectProxy) ((copyObject) ? CollectionUtils.copyToRealm(realm, (RealmModel) value) : realmObject);\n             osList.addRow(proxy.realmGet$proxyState().getRow$realm().getObjectKey());\n@@ -239,7 +239,7 @@ public void insertValue(int index, Object value) {\n                 throw new IllegalArgumentException(\"Embedded objects are not supported by RealmLists of DynamicRealmObjects yet.\");\n             }\n             long objKey = osList.createAndAddEmbeddedObject(index);\n-            updateEmbeddedObject(realmObject, objKey);\n+            CollectionUtils.updateEmbeddedObject((Realm) realm, realmObject, objKey);\n         } else {\n             RealmObjectProxy proxy = (RealmObjectProxy) ((copyObject) ? CollectionUtils.copyToRealm(realm, (RealmModel) value) : realmObject);\n             osList.insertRow(index, proxy.realmGet$proxyState().getRow$realm().getObjectKey());\n@@ -269,21 +269,12 @@ protected void setValue(int index, Object value) {\n                 throw new IllegalArgumentException(\"Embedded objects are not supported by RealmLists of DynamicRealmObjects yet.\");\n             }\n             long objKey = osList.createAndSetEmbeddedObject(index);\n-            updateEmbeddedObject(realmObject, objKey);\n+            CollectionUtils.updateEmbeddedObject((Realm) realm, realmObject, objKey);\n         } else {\n             RealmObjectProxy proxy = (RealmObjectProxy) ((copyObject) ? CollectionUtils.copyToRealm(realm, (RealmModel) value) : realmObject);\n             osList.setRow(index, proxy.realmGet$proxyState().getRow$realm().getObjectKey());\n         }\n     }\n-\n-    private void updateEmbeddedObject(RealmModel unmanagedObject, long objKey) {\n-        RealmProxyMediator schemaMediator = realm.getConfiguration().getSchemaMediator();\n-        Class<? extends RealmModel> modelClass = Util.getOriginalModelClass(unmanagedObject.getClass());\n-        Table table = ((Realm) realm).getTable(modelClass);\n-        RealmModel managedObject = schemaMediator.newInstance(modelClass, realm, table.getUncheckedRow(objKey), realm.getSchema().getColumnInfo(modelClass), true, Collections.EMPTY_LIST);\n-        schemaMediator.updateEmbeddedObject((Realm) realm, unmanagedObject, managedObject, new HashMap<>(), Collections.EMPTY_SET);\n-    }\n-\n }\n \n /**"
  },
  {
    "sha": "9d1bef1e2de88b115d3cc6de43b5daa0725a5bbf",
    "filename": "realm/realm-library/src/main/java/io/realm/ManagedMapManager.java",
    "status": "modified",
    "additions": 43,
    "deletions": 102,
    "changes": 145,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/ManagedMapManager.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/ManagedMapManager.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/main/java/io/realm/ManagedMapManager.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -16,24 +16,19 @@\n \n package io.realm;\n \n-import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n \n import javax.annotation.Nullable;\n \n-import io.realm.internal.ClassContainer;\n import io.realm.internal.Freezable;\n import io.realm.internal.ManageableObject;\n import io.realm.internal.ObservableMap;\n import io.realm.internal.ObserverPairList;\n import io.realm.internal.OsMap;\n-import io.realm.internal.OsResults;\n import io.realm.internal.RealmObjectProxy;\n import io.realm.internal.Row;\n-import io.realm.internal.Table;\n import io.realm.internal.core.NativeMixed;\n import io.realm.internal.util.Pair;\n \n@@ -48,15 +43,15 @@\n \n     protected final BaseRealm baseRealm;\n     protected final MapValueOperator<K, V> mapValueOperator;\n-    protected final ClassContainer classContainer;\n+    protected final RealmTypeSelectorForMap<K, V> realmTypeSelector;\n     protected final ObserverPairList<MapObserverPair<K, V>> mapObserverPairs = new ObserverPairList<>();\n \n     ManagedMapManager(BaseRealm baseRealm,\n                       MapValueOperator<K, V> mapValueOperator,\n-                      ClassContainer classContainer) {\n+                      RealmTypeSelectorForMap<K, V> realmTypeSelector) {\n         this.baseRealm = baseRealm;\n         this.mapValueOperator = mapValueOperator;\n-        this.classContainer = classContainer;\n+        this.realmTypeSelector = realmTypeSelector;\n     }\n \n     protected abstract RealmMap<K, V> freezeInternal(Pair<BaseRealm, OsMap> frozenBaseRealmMap);\n@@ -182,17 +177,17 @@ public boolean hasListeners() {\n         return !mapObserverPairs.isEmpty();\n     }\n \n+    OsMap getOsMap() {\n+        return mapValueOperator.osMap;\n+    }\n+\n     private void checkForAddRemoveListener(@Nullable Object listener, boolean checkListener) {\n         if (checkListener && listener == null) {\n             throw new IllegalArgumentException(\"Listener should not be null\");\n         }\n         baseRealm.checkIfValid();\n         baseRealm.sharedRealm.capabilities.checkCanDeliverNotification(BaseRealm.LISTENER_NOT_ALLOWED_MESSAGE);\n     }\n-\n-    OsMap getOsMap() {\n-        return mapValueOperator.osMap;\n-    }\n }\n \n /**\n@@ -211,25 +206,15 @@ OsMap getOsMap() {\n \n     DictionaryManager(BaseRealm baseRealm,\n                       MapValueOperator<String, V> mapValueOperator,\n-                      ClassContainer classContainer) {\n-        super(baseRealm, mapValueOperator, classContainer);\n+                      RealmTypeSelectorForMap<String, V> realmTypeSelector) {\n+        super(baseRealm, mapValueOperator, realmTypeSelector);\n     }\n \n     @Override\n     protected RealmDictionary<V> freezeInternal(Pair<BaseRealm, OsMap> frozenBaseRealmMap) {\n         BaseRealm frozenBaseRealm = frozenBaseRealmMap.first;\n         OsMap osMap = frozenBaseRealmMap.second;\n-        Class<?> clazz = classContainer.getClazz();\n-        String className = classContainer.getClassName();\n-\n-        if (clazz != null) {\n-            //noinspection unchecked\n-            return new RealmDictionary<>(frozenBaseRealm, osMap, (Class<V>) clazz);\n-        } else if (className != null) {\n-            return new RealmDictionary<>(frozenBaseRealm, osMap, className);\n-        } else {\n-            throw new IllegalArgumentException(\"Either a class or a class string is required.\");\n-        }\n+        return realmTypeSelector.freeze(frozenBaseRealm);\n     }\n \n     @Override\n@@ -264,16 +249,16 @@ public V put(String key, V value) {\n \n     protected final BaseRealm baseRealm;\n     protected final OsMap osMap;\n-    protected final ClassContainer classContainer;\n+    protected final RealmTypeSelectorForMap<K, V> realmTypeSelector;\n     protected final RealmMapEntrySet.IteratorType iteratorType;\n \n     MapValueOperator(BaseRealm baseRealm,\n                      OsMap osMap,\n-                     ClassContainer classContainer,\n+                     RealmTypeSelectorForMap<K, V> realmTypeSelector,\n                      RealmMapEntrySet.IteratorType iteratorType) {\n         this.baseRealm = baseRealm;\n         this.osMap = osMap;\n-        this.classContainer = classContainer;\n+        this.realmTypeSelector = realmTypeSelector;\n         this.iteratorType = iteratorType;\n     }\n \n@@ -327,18 +312,11 @@ public void putAll(Map<K, V> map) {\n     }\n \n     public Set<K> keySet() {\n-        //noinspection unchecked\n-        return new HashSet<>((Collection<K>) produceResults(osMap.tableAndKeyPtrs(), true, String.class));\n+        return realmTypeSelector.keySet();\n     }\n \n     public Collection<V> values() {\n-        Class<?> clazz = classContainer.getClazz();\n-        if (clazz != null) {\n-            boolean forPrimitives = !RealmModel.class.isAssignableFrom(clazz);\n-            //noinspection unchecked\n-            return (Collection<V>) produceResults(osMap.tableAndValuePtrs(), forPrimitives, classContainer.getClazz());\n-        }\n-        throw new IllegalStateException(\"MapValueOperator missing class in 'classContainer'.\");\n+        return realmTypeSelector.getValues();\n     }\n \n     public Pair<BaseRealm, OsMap> freeze() {\n@@ -353,31 +331,17 @@ public void startListening(ObservableMap observableMap) {\n     public void stopListening() {\n         osMap.stopListening();\n     }\n-\n-    private <T> RealmResults<T> produceResults(Pair<Table, Long> tableAndValuesPtr,\n-                                               boolean forPrimitives,\n-                                               @Nullable Class<T> clazz) {\n-        if (baseRealm instanceof Realm) {\n-            Realm realm = (Realm) baseRealm;\n-            Long valuesPtr = tableAndValuesPtr.second;\n-            OsResults osResults = OsResults.createFromMap(baseRealm.sharedRealm, valuesPtr);\n-            if (clazz != null) {\n-                return new RealmResults<>(realm, osResults, clazz, forPrimitives);\n-            }\n-            throw new IllegalStateException(\"MapValueOperator missing class.\");\n-        }\n-\n-        throw new UnsupportedOperationException(\"Add support for 'values' for DynamicRealms.\");\n-    }\n }\n \n /**\n  * {@link MapValueOperator} targeting {@link Mixed} values in {@link RealmMap}s.\n  */\n class MixedValueOperator<K> extends MapValueOperator<K, Mixed> {\n \n-    MixedValueOperator(BaseRealm baseRealm, OsMap osMap, ClassContainer classContainer) {\n-        super(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.MIXED);\n+    MixedValueOperator(BaseRealm baseRealm,\n+                       OsMap osMap,\n+                       RealmTypeSelectorForMap<K, Mixed> realmTypeSelector) {\n+        super(baseRealm, osMap, realmTypeSelector, RealmMapEntrySet.IteratorType.MIXED);\n     }\n \n     @Nullable\n@@ -431,17 +395,17 @@ public boolean containsValue(@Nullable Object value) {\n \n     GenericPrimitiveValueOperator(BaseRealm baseRealm,\n                                   OsMap osMap,\n-                                  ClassContainer classContainer,\n+                                  RealmTypeSelectorForMap<K, V> realmTypeSelector,\n                                   RealmMapEntrySet.IteratorType iteratorType) {\n-        this(baseRealm, osMap, classContainer, iteratorType, new GenericEquals<>());\n+        this(baseRealm, osMap, realmTypeSelector, iteratorType, new GenericEquals<>());\n     }\n \n     GenericPrimitiveValueOperator(BaseRealm baseRealm,\n                                   OsMap osMap,\n-                                  ClassContainer classContainer,\n+                                  RealmTypeSelectorForMap<K, V> realmTypeSelector,\n                                   RealmMapEntrySet.IteratorType iteratorType,\n                                   EqualsHelper<K, V> equalsHelper) {\n-        super(baseRealm, osMap, classContainer, iteratorType);\n+        super(baseRealm, osMap, realmTypeSelector, iteratorType);\n         this.equalsHelper = equalsHelper;\n     }\n \n@@ -495,8 +459,10 @@ protected V processValue(Object value) {\n  */\n class IntegerValueOperator<K> extends GenericPrimitiveValueOperator<K, Integer> {\n \n-    IntegerValueOperator(BaseRealm baseRealm, OsMap osMap, ClassContainer classContainer) {\n-        super(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.INTEGER);\n+    IntegerValueOperator(BaseRealm baseRealm,\n+                         OsMap osMap,\n+                         RealmTypeSelectorForMap<K, Integer> realmTypeSelector) {\n+        super(baseRealm, osMap, realmTypeSelector, RealmMapEntrySet.IteratorType.INTEGER);\n     }\n \n     @Override\n@@ -512,8 +478,10 @@ protected Integer processValue(Object value) {\n  */\n class ShortValueOperator<K> extends GenericPrimitiveValueOperator<K, Short> {\n \n-    ShortValueOperator(BaseRealm baseRealm, OsMap osMap, ClassContainer classContainer) {\n-        super(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.SHORT);\n+    ShortValueOperator(BaseRealm baseRealm,\n+                       OsMap osMap,\n+                       RealmTypeSelectorForMap<K, Short> realmTypeSelector) {\n+        super(baseRealm, osMap, realmTypeSelector, RealmMapEntrySet.IteratorType.SHORT);\n     }\n \n     @Override\n@@ -529,8 +497,10 @@ protected Short processValue(Object value) {\n  */\n class ByteValueOperator<K> extends GenericPrimitiveValueOperator<K, Byte> {\n \n-    ByteValueOperator(BaseRealm baseRealm, OsMap osMap, ClassContainer classContainer) {\n-        super(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.BYTE);\n+    ByteValueOperator(BaseRealm baseRealm,\n+                      OsMap osMap,\n+                      RealmTypeSelectorForMap<K, Byte> realmTypeSelector) {\n+        super(baseRealm, osMap, realmTypeSelector, RealmMapEntrySet.IteratorType.BYTE);\n     }\n \n     @Override\n@@ -544,8 +514,10 @@ protected Byte processValue(Object value) {\n  */\n class RealmModelValueOperator<K, V> extends MapValueOperator<K, V> {\n \n-    RealmModelValueOperator(BaseRealm baseRealm, OsMap osMap, ClassContainer classContainer) {\n-        super(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.OBJECT);\n+    RealmModelValueOperator(BaseRealm baseRealm,\n+                            OsMap osMap,\n+                            RealmTypeSelectorForMap<K, V> realmTypeSelector) {\n+        super(baseRealm, osMap, realmTypeSelector, RealmMapEntrySet.IteratorType.OBJECT);\n     }\n \n     @Nullable\n@@ -556,50 +528,18 @@ public V get(Object key) {\n             return null;\n         }\n \n-        //noinspection unchecked\n-        Class<? extends RealmModel> clazz = (Class<? extends RealmModel>) classContainer.getClazz();\n-        String className = classContainer.getClassName();\n-\n-        //noinspection unchecked\n-        return (V) baseRealm.get(clazz, className, realmModelKey);\n+        return realmTypeSelector.getRealmModel(baseRealm, realmModelKey);\n     }\n \n     @Nullable\n     @Override\n     public V put(K key, @Nullable V value) {\n-        //noinspection unchecked\n-        Class<V> clazz = (Class<V>) classContainer.getClazz();\n-        String className = classContainer.getClassName();\n-        long rowModelKey = osMap.getModelRowKey(key);\n-\n-        if (value == null) {\n-            osMap.put(key, null);\n-        } else {\n-            if (className == null) {\n-                if (clazz == null) {\n-                    throw new IllegalStateException(\"Missing clazz.\");\n-                }\n-                className = clazz.getCanonicalName();\n-            }\n-            boolean copyObject = CollectionUtils.checkCanObjectBeCopied(baseRealm, (RealmModel) value, className);\n-            RealmObjectProxy proxy = (RealmObjectProxy) ((copyObject) ? CollectionUtils.copyToRealm(baseRealm, (RealmModel) value) : (RealmModel) value);\n-            osMap.putRow(key, proxy.realmGet$proxyState().getRow$realm().getObjectKey());\n-        }\n-\n-        if (rowModelKey == OsMap.NOT_FOUND) {\n-            return null;\n-        } else {\n-            if (clazz == null) {\n-                throw new IllegalStateException(\"Missing clazz.\");\n-            }\n-            //noinspection unchecked\n-            return (V) baseRealm.get((Class<? extends RealmModel>) clazz, rowModelKey, false, new ArrayList<>());\n-        }\n+        return realmTypeSelector.putRealmModel(baseRealm, osMap, key, value);\n     }\n \n     @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n-        return new RealmMapEntrySet<>(baseRealm, osMap, RealmMapEntrySet.IteratorType.OBJECT, classContainer);\n+        return new RealmMapEntrySet<>(baseRealm, osMap, RealmMapEntrySet.IteratorType.OBJECT, realmTypeSelector);\n     }\n \n     @Override\n@@ -614,3 +554,4 @@ public boolean containsValue(@Nullable Object value) {\n         throw new IllegalArgumentException(\"Only managed models can be contained in this dictionary.\");\n     }\n }\n+"
  },
  {
    "sha": "87b9d9eb1d4831f1148ba58aac6f5abd860ece05",
    "filename": "realm/realm-library/src/main/java/io/realm/Mixed.java",
    "status": "modified",
    "additions": 49,
    "deletions": 0,
    "changes": 49,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/Mixed.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/Mixed.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/main/java/io/realm/Mixed.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -455,6 +455,55 @@ public Decimal128 asDecimal128() {\n         return operator.getValue(clazz);\n     }\n \n+    /**\n+     * Creates a new Mixed out of an Object.\n+     *\n+     * @param value initial value.\n+     * @return a new Mixed wrapping the object.\n+     */\n+    static Mixed valueOf(@Nullable Object value) {\n+        if (value == null) {\n+            return Mixed.nullValue();\n+        } else if (value instanceof Boolean) {\n+            return Mixed.valueOf((Boolean) value);\n+        } else if (value instanceof Byte) {\n+            return Mixed.valueOf((Byte) value);\n+        } else if (value instanceof Short) {\n+            return Mixed.valueOf((Short) value);\n+        } else if (value instanceof Integer) {\n+            return Mixed.valueOf((Integer) value);\n+        } else if (value instanceof Long) {\n+            return Mixed.valueOf((Long) value);\n+        } else if (value instanceof Float) {\n+            return Mixed.valueOf((Float) value);\n+        } else if (value instanceof Double) {\n+            return Mixed.valueOf((Double) value);\n+        } else if (value instanceof Decimal128) {\n+            return Mixed.valueOf((Decimal128) value);\n+        } else if (value instanceof String) {\n+            return Mixed.valueOf((String) value);\n+        } else if (value instanceof byte[]) {\n+            return Mixed.valueOf((byte[]) value);\n+        } else if (value instanceof Date) {\n+            return Mixed.valueOf((Date) value);\n+        } else if (value instanceof ObjectId) {\n+            return Mixed.valueOf((ObjectId) value);\n+        } else if (value instanceof UUID) {\n+            return Mixed.valueOf((UUID) value);\n+        } else if (value instanceof Mixed) {\n+            return (Mixed) value;\n+        } else if (RealmModel.class.isAssignableFrom(value.getClass())) {\n+            RealmModel model = (RealmModel) value;\n+\n+            if (!RealmObject.isValid(model) || !RealmObject.isManaged(model)) {\n+                throw new IllegalArgumentException(\"RealmObject is not a valid managed object.\");\n+            }\n+\n+            return Mixed.valueOf((RealmModel) model);\n+        } else {\n+            throw new IllegalArgumentException(\"Type not supported on Mixed: \" + value.getClass().getSimpleName());\n+        }\n+    }\n \n     /**\n      * A {@code Mixed}'s hash code is, exactly, the hash code of its value."
  },
  {
    "sha": "c39a3d27dfb02ca463b33b80c23f9b3005b9cdef",
    "filename": "realm/realm-library/src/main/java/io/realm/Realm.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/Realm.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/Realm.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/main/java/io/realm/Realm.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -1030,9 +1030,9 @@ private Scanner getFullStringScanner(InputStream in) {\n      * This method should only be used to create objects of types marked as embedded.\n      *\n      * @param clazz the Class of the object to create. It must be marked with {@code \\@RealmClass(embedded = true)}.\n-     * @param parentObject The parent object which should hold a reference to the embedded object. If the parent property is a list\n+     * @param parentObject The parent object which should hold a reference to the embedded object.\n+     * @param parentProperty the property in the parent class which holds the reference. If the parent property is a list\n      * the embedded object will be added to the end of that list.\n-     * @param parentProperty the property in the parent class which holds the reference.\n      * @return the newly created embedded object.\n      * @throws IllegalArgumentException if {@code clazz} is not an embedded class or if the property\n      * in the parent class cannot hold objects of the appropriate type."
  },
  {
    "sha": "911805f26b1f901d9d0adb7ec50e41b0ba7265fb",
    "filename": "realm/realm-library/src/main/java/io/realm/RealmDictionary.java",
    "status": "modified",
    "additions": 59,
    "deletions": 46,
    "changes": 105,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/RealmDictionary.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/RealmDictionary.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/main/java/io/realm/RealmDictionary.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -24,7 +24,6 @@\n import java.util.Map;\n import java.util.UUID;\n \n-import io.realm.internal.ClassContainer;\n import io.realm.internal.OsMap;\n \n /**\n@@ -105,109 +104,123 @@ public RealmDictionary(RealmDictionary<V> dictionary) {\n         return map;\n     }\n \n-    private static <V> ManagedMapStrategy<String, V> getStrategy(Class<V> valueClass, BaseRealm baseRealm, OsMap osMap) {\n-        if (isClassForRealmModel(valueClass)) {\n-            ClassContainer classContainer = new ClassContainer(valueClass, null);\n-            RealmModelValueOperator<String, RealmModel> realmModelValueOperator = new RealmModelValueOperator<>(baseRealm, osMap, classContainer);\n-            ManagedMapManager<String, RealmModel> dictionaryManager = new DictionaryManager<>(baseRealm, realmModelValueOperator, classContainer);\n+    private static <V extends RealmModel> LinkRealmSelectorForMap<String, V> getRealmModelMapManager(Class<V> valueClass,\n+                                                                                                     BaseRealm baseRealm,\n+                                                                                                     OsMap osMap) {\n+        return new LinkRealmSelectorForMap<>(baseRealm, osMap, String.class, valueClass);\n+    }\n \n-            //noinspection unchecked\n+    @SuppressWarnings(\"unchecked\")\n+    private static <V> ManagedMapStrategy<String, V> getStrategy(Class<V> valueClass,\n+                                                                 BaseRealm baseRealm,\n+                                                                 OsMap osMap) {\n+        if (isClassForRealmModel(valueClass)) {\n+            LinkRealmSelectorForMap<String, ? extends RealmModel> realmModelStrategy = getRealmModelMapManager((Class<? extends RealmModel>) valueClass, baseRealm, osMap);\n+            RealmTypeSelectorForMap<String, V> realmTypeSelectorForMap = (RealmTypeSelectorForMap<String, V>) realmModelStrategy;;\n+            RealmModelValueOperator<String, RealmModel> realmModelValueOperator = new RealmModelValueOperator<>(baseRealm, osMap, (RealmTypeSelectorForMap<String, RealmModel>) realmTypeSelectorForMap);\n+            ManagedMapManager<String, RealmModel> dictionaryManager = new DictionaryManager<>(baseRealm, realmModelValueOperator, (RealmTypeSelectorForMap<String, RealmModel>) realmTypeSelectorForMap);\n             return (ManagedMapStrategy<String, V>) new ManagedMapStrategy<>(dictionaryManager);\n         }\n \n         DictionaryManager<V> manager = getManager(valueClass, baseRealm, osMap);\n         return new ManagedMapStrategy<>(manager);\n     }\n \n-    private static <V> ManagedMapStrategy<String, V> getStrategy(String valueClass, BaseRealm baseRealm, OsMap osMap) {\n+    private static <V> ManagedMapStrategy<String, V> getStrategy(String valueClass,\n+                                                                 BaseRealm baseRealm,\n+                                                                 OsMap osMap) {\n         DictionaryManager<V> manager = getManager(valueClass, baseRealm, osMap);\n         return new ManagedMapStrategy<>(manager);\n     }\n \n-    private static <K, V> DictionaryManager<V> getManager(Class<V> valueClass, BaseRealm baseRealm, OsMap osMap) {\n-        ClassContainer classContainer = new ClassContainer(valueClass, null);\n+    @SuppressWarnings(\"unchecked\")\n+    private static <V> DictionaryManager<V> getManager(Class<V> valueClass,\n+                                                       BaseRealm baseRealm,\n+                                                       OsMap osMap) {\n+        RealmTypeSelectorForMap<String, V> realmTypeSelectorForMap = new RealmSelectorForMap<>(baseRealm, osMap, String.class, valueClass);\n \n-        MapValueOperator<K, ?> mapValueOperator;\n+        MapValueOperator<String, ?> mapValueOperator;\n \n         if (valueClass == Mixed.class) {\n-            mapValueOperator = new MixedValueOperator<>(baseRealm, osMap, classContainer);\n+            mapValueOperator = new MixedValueOperator<>(baseRealm, osMap, (RealmTypeSelectorForMap<String, Mixed>) realmTypeSelectorForMap);\n         } else if (valueClass == Long.class) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.LONG);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.LONG);\n         } else if (valueClass == Float.class) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.FLOAT);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.FLOAT);\n         } else if (valueClass == Double.class) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.DOUBLE);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.DOUBLE);\n         } else if (valueClass == String.class) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.STRING);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.STRING);\n         } else if (valueClass == Boolean.class) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.BOOLEAN);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.BOOLEAN);\n         } else if (valueClass == Date.class) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.DATE);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.DATE);\n         } else if (valueClass == Decimal128.class) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.DECIMAL128);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.DECIMAL128);\n         } else if (valueClass == Integer.class) {\n-            mapValueOperator = new IntegerValueOperator<>(baseRealm, osMap, classContainer);\n+            mapValueOperator = new IntegerValueOperator<>(baseRealm, osMap, (RealmTypeSelectorForMap<String, Integer>) realmTypeSelectorForMap);\n         } else if (valueClass == Short.class) {\n-            mapValueOperator = new ShortValueOperator<>(baseRealm, osMap, classContainer);\n+            mapValueOperator = new ShortValueOperator<>(baseRealm, osMap, (RealmTypeSelectorForMap<String, Short>) realmTypeSelectorForMap);\n         } else if (valueClass == Byte.class) {\n-            mapValueOperator = new ByteValueOperator<>(baseRealm, osMap, classContainer);\n+            mapValueOperator = new ByteValueOperator<>(baseRealm, osMap, (RealmTypeSelectorForMap<String, Byte>) realmTypeSelectorForMap);\n         } else if (valueClass == byte[].class) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.BINARY, new BinaryEquals<>());\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.BINARY, (EqualsHelper<String, V>) new BinaryEquals<String>());\n         } else if (valueClass == ObjectId.class) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.OBJECT_ID);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.OBJECT_ID);\n         } else if (valueClass == UUID.class) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.UUID);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.UUID);\n         } else {\n             throw new IllegalArgumentException(\"Only Maps of Mixed or one of the types that can be boxed inside Mixed can be used.\");\n         }\n \n-        //noinspection unchecked\n         return new DictionaryManager<>(baseRealm,\n                 (MapValueOperator<String, V>) mapValueOperator,\n-                classContainer);\n+                realmTypeSelectorForMap);\n     }\n \n-    private static <K, V> DictionaryManager<V> getManager(String valueClass, BaseRealm baseRealm, OsMap osMap) {\n-        ClassContainer classContainer = new ClassContainer(null, valueClass);\n+    @SuppressWarnings(\"unchecked\")\n+    private static <V> DictionaryManager<V> getManager(String valueClass,\n+                                                       BaseRealm baseRealm,\n+                                                       OsMap osMap) {\n+        RealmTypeSelectorForMap<String, V> realmTypeSelectorForMap = new DynamicRealmSelectorForMap<>(baseRealm, osMap, valueClass);\n \n-        MapValueOperator<K, ?> mapValueOperator;\n+        MapValueOperator<String, ?> mapValueOperator;\n \n         if (valueClass.equals(Mixed.class.getCanonicalName())) {\n-            mapValueOperator = new MixedValueOperator<>(baseRealm, osMap, classContainer);\n+            mapValueOperator = new MixedValueOperator<>(baseRealm, osMap, (RealmTypeSelectorForMap<String, Mixed>) realmTypeSelectorForMap);\n         } else if (valueClass.equals(Long.class.getCanonicalName())) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.LONG);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.LONG);\n         } else if (valueClass.equals(Float.class.getCanonicalName())) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.FLOAT);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.FLOAT);\n         } else if (valueClass.equals(Double.class.getCanonicalName())) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.DOUBLE);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.DOUBLE);\n         } else if (valueClass.equals(String.class.getCanonicalName())) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.STRING);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.STRING);\n         } else if (valueClass.equals(Boolean.class.getCanonicalName())) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.BOOLEAN);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.BOOLEAN);\n         } else if (valueClass.equals(Date.class.getCanonicalName())) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.DATE);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.DATE);\n         } else if (valueClass.equals(Decimal128.class.getCanonicalName())) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.DECIMAL128);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.DECIMAL128);\n         } else if (valueClass.equals(Integer.class.getCanonicalName())) {\n-            mapValueOperator = new IntegerValueOperator<>(baseRealm, osMap, classContainer);\n+            mapValueOperator = new IntegerValueOperator<>(baseRealm, osMap, (RealmTypeSelectorForMap<String, Integer>) realmTypeSelectorForMap);\n         } else if (valueClass.equals(Short.class.getCanonicalName())) {\n-            mapValueOperator = new ShortValueOperator<>(baseRealm, osMap, classContainer);\n+            mapValueOperator = new ShortValueOperator<>(baseRealm, osMap, (RealmTypeSelectorForMap<String, Short>) realmTypeSelectorForMap);\n         } else if (valueClass.equals(Byte.class.getCanonicalName())) {\n-            mapValueOperator = new ByteValueOperator<>(baseRealm, osMap, classContainer);\n+            mapValueOperator = new ByteValueOperator<>(baseRealm, osMap, (RealmTypeSelectorForMap<String, Byte>) realmTypeSelectorForMap);\n         } else if (valueClass.equals(byte[].class.getCanonicalName())) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.BINARY, new BinaryEquals<>());\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.BINARY, (EqualsHelper<String, V>) new BinaryEquals<String>());\n         } else if (valueClass.equals(ObjectId.class.getCanonicalName())) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.OBJECT_ID);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.OBJECT_ID);\n         } else if (valueClass.equals(UUID.class.getCanonicalName())) {\n-            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, classContainer, RealmMapEntrySet.IteratorType.UUID);\n+            mapValueOperator = new GenericPrimitiveValueOperator<>(baseRealm, osMap, realmTypeSelectorForMap, RealmMapEntrySet.IteratorType.UUID);\n         } else {\n             throw new IllegalArgumentException(\"Only Maps of Mixed or one of the types that can be boxed inside Mixed can be used.\");\n         }\n \n-        //noinspection unchecked\n         return new DictionaryManager<>(baseRealm,\n                 (MapValueOperator<String, V>) mapValueOperator,\n-                classContainer);\n+                realmTypeSelectorForMap);\n     }\n \n     private static boolean isClassForRealmModel(Class<?> clazz) {"
  },
  {
    "sha": "237222b6db6e0c36095f99689a3c39b5e1103a46",
    "filename": "realm/realm-library/src/main/java/io/realm/RealmMap.java",
    "status": "modified",
    "additions": 0,
    "deletions": 1,
    "changes": 1,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/RealmMap.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/RealmMap.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/main/java/io/realm/RealmMap.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -306,7 +306,6 @@ public boolean hasListeners() {\n         return mapStrategy.hasListeners();\n     }\n \n-    // Needed for embedded objects\n     OsMap getOsMap() {\n         return mapStrategy.getOsMap();\n     }"
  },
  {
    "sha": "0846f63f00c8d62ec9307f95cbf3993f193eec3a",
    "filename": "realm/realm-library/src/main/java/io/realm/RealmMapEntrySet.java",
    "status": "modified",
    "additions": 16,
    "deletions": 22,
    "changes": 38,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/RealmMapEntrySet.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/RealmMapEntrySet.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/main/java/io/realm/RealmMapEntrySet.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -32,9 +32,7 @@\n import java.util.Set;\n import java.util.UUID;\n \n-import io.realm.internal.ClassContainer;\n import io.realm.internal.OsMap;\n-import io.realm.internal.android.TypeUtils;\n import io.realm.internal.core.NativeMixed;\n import io.realm.internal.util.Pair;\n \n@@ -55,29 +53,29 @@\n     private final OsMap osMap;\n     private final IteratorType iteratorType;\n     private final EqualsHelper<K, V> equalsHelper;\n-    private final ClassContainer classContainer;\n+    private final RealmTypeSelectorForMap realmTypeSelectorForMap;\n \n     public RealmMapEntrySet(BaseRealm baseRealm,\n                             OsMap osMap,\n                             IteratorType iteratorType,\n-                            @Nullable ClassContainer classContainer) {\n+                            @Nullable RealmTypeSelectorForMap realmTypeSelectorForMap) {\n         this.baseRealm = baseRealm;\n         this.osMap = osMap;\n         this.iteratorType = iteratorType;\n         this.equalsHelper = new GenericEquals<>();\n-        this.classContainer = classContainer;\n+        this.realmTypeSelectorForMap = realmTypeSelectorForMap;\n     }\n \n     public RealmMapEntrySet(BaseRealm baseRealm,\n                             OsMap osMap,\n                             IteratorType iteratorType,\n                             EqualsHelper<K, V> equalsHelper,\n-                            @Nullable ClassContainer classContainer) {\n+                            @Nullable RealmTypeSelectorForMap realmTypeSelectorForMap) {\n         this.baseRealm = baseRealm;\n         this.osMap = osMap;\n         this.iteratorType = iteratorType;\n         this.equalsHelper = equalsHelper;\n-        this.classContainer = classContainer;\n+        this.realmTypeSelectorForMap = realmTypeSelectorForMap;\n     }\n \n     @Override\n@@ -111,7 +109,7 @@ public boolean contains(@Nullable Object o) {\n     @NotNull\n     @Override\n     public Iterator<Map.Entry<K, V>> iterator() {\n-        return iteratorFactory(iteratorType, osMap, baseRealm, classContainer);\n+        return iteratorFactory(iteratorType, osMap, baseRealm, realmTypeSelectorForMap);\n     }\n \n     @NotNull\n@@ -216,7 +214,7 @@ public void clear() {\n     private static <K, V> EntrySetIterator<K, V> iteratorFactory(IteratorType iteratorType,\n                                                                  OsMap osMap,\n                                                                  BaseRealm baseRealm,\n-                                                                 @Nullable ClassContainer classContainer) {\n+                                                                 @Nullable RealmTypeSelectorForMap realmTypeSelectorForMap) {\n         switch (iteratorType) {\n             case LONG:\n                 //noinspection unchecked\n@@ -261,10 +259,10 @@ public void clear() {\n                 //noinspection unchecked\n                 return (EntrySetIterator<K, V>) new MixedValueIterator<K>(osMap, baseRealm);\n             case OBJECT:\n-                if (classContainer == null) {\n+                if (realmTypeSelectorForMap == null) {\n                     throw new IllegalArgumentException(\"Missing class container when creating RealmModelValueIterator.\");\n                 }\n-                return new RealmModelValueIterator<>(osMap, baseRealm, classContainer);\n+                return new RealmModelValueIterator<>(osMap, baseRealm, realmTypeSelectorForMap);\n             default:\n                 throw new IllegalArgumentException(\"Invalid iterator type.\");\n         }\n@@ -533,11 +531,13 @@ public UUIDValueIterator(OsMap osMap, BaseRealm baseRealm) {\n \n     private static class RealmModelValueIterator<K, V> extends EntrySetIterator<K, V> {\n \n-        private final ClassContainer classContainer;\n+        private final RealmTypeSelectorForMap<K, V> realmTypeSelectorForMap;\n \n-        public RealmModelValueIterator(OsMap osMap, BaseRealm baseRealm, ClassContainer classContainer) {\n+        public RealmModelValueIterator(OsMap osMap,\n+                                       BaseRealm baseRealm,\n+                                       RealmTypeSelectorForMap<K, V> realmTypeSelectorForMap) {\n             super(osMap, baseRealm);\n-            this.classContainer = classContainer;\n+            this.realmTypeSelectorForMap = realmTypeSelectorForMap;\n         }\n \n         @Override\n@@ -551,13 +551,7 @@ public RealmModelValueIterator(OsMap osMap, BaseRealm baseRealm, ClassContainer\n             }\n \n             //noinspection unchecked\n-            Class<? extends RealmModel> clazz = (Class<? extends RealmModel>) classContainer.getClazz();\n-            String className = classContainer.getClassName();\n-\n-            //noinspection unchecked\n-            V realmModel = (V) baseRealm.get(clazz, className, objRow);\n-\n-            return new AbstractMap.SimpleImmutableEntry<>(key, realmModel);\n+            return (Map.Entry<K, V>) realmTypeSelectorForMap.getModelEntry(baseRealm, objRow, key);\n         }\n     }\n \n@@ -578,7 +572,7 @@ public MixedValueIterator(OsMap osMap, BaseRealm baseRealm) {\n     }\n }\n \n-abstract class EqualsHelper<K, V>  {\n+abstract class EqualsHelper<K, V> {\n \n     boolean equalsHelper(Map.Entry<K, V> entry, Map.Entry<K, V> other) {\n         K otherKey = other.getKey();"
  },
  {
    "sha": "6b30cf60fe98e420ad5815c1fa54bfbc6abc1c53",
    "filename": "realm/realm-library/src/main/java/io/realm/RealmQuery.java",
    "status": "modified",
    "additions": 246,
    "deletions": 1,
    "changes": 247,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/RealmQuery.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/RealmQuery.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/main/java/io/realm/RealmQuery.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -23,6 +23,7 @@\n import java.util.Collections;\n import java.util.Date;\n import java.util.Locale;\n+import java.util.Map;\n import java.util.UUID;\n \n import javax.annotation.Nullable;\n@@ -1934,6 +1935,245 @@ public boolean isValid() {\n         return this;\n     }\n \n+    /**\n+     * Condition that value if a dictionary field contains the specified key.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param key       the key to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsKey(String fieldName, @Nullable String key) {\n+        realm.checkIfValid();\n+        this.query.containsKey(fieldName, Mixed.valueOf(key));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, @Nullable Boolean value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, Mixed.valueOf(value));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, @Nullable Byte value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, Mixed.valueOf(value));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, @Nullable Short value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, Mixed.valueOf(value));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, @Nullable Integer value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, Mixed.valueOf(value));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, @Nullable Long value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, Mixed.valueOf(value));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, @Nullable Double value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, Mixed.valueOf(value));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, @Nullable Float value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, Mixed.valueOf(value));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, @Nullable String value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, Mixed.valueOf(value));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, @Nullable byte[] value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, Mixed.valueOf(value));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, @Nullable Date value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, Mixed.valueOf(value));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, @Nullable Decimal128 value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, Mixed.valueOf(value));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, @Nullable ObjectId value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, Mixed.valueOf(value));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, @Nullable UUID value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, Mixed.valueOf(value));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, Mixed value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified value.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param value     the value to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsValue(String fieldName, RealmModel value) {\n+        realm.checkIfValid();\n+        this.query.containsValue(fieldName, Mixed.valueOf(value));\n+        return this;\n+    }\n+\n+    /**\n+     * Condition that value if dictionary field contains the specified entry.\n+     *\n+     * @param fieldName the field to compare.\n+     * @param entry     the entry to search for.\n+     * @return the query object.\n+     * @throws java.lang.IllegalArgumentException if the field name isn't valid.\n+     */\n+    public RealmQuery<E> containsEntry(String fieldName, Map.Entry<String, ?> entry) {\n+        Util.checkNull(entry, \"entry\");\n+        realm.checkIfValid();\n+        this.query.containsEntry(fieldName, Mixed.valueOf(entry.getKey()), Mixed.valueOf(entry.getValue()));\n+        return this;\n+    }\n+\n     /**\n      * Calculates the sum of a given field.\n      *\n@@ -2363,7 +2603,12 @@ private OsResults lazyFindAll() {\n             throw new IllegalArgumentException(\"Non-null 'predicate' required.\");\n         }\n \n-        query.rawPredicate(predicate, arguments);\n+        Mixed[] mixedArgs = new Mixed[arguments.length];\n+        for (int i = 0; i < arguments.length; i++) {\n+            mixedArgs[i] = Mixed.valueOf(arguments[i]);\n+        }\n+\n+        query.rawPredicate(predicate, mixedArgs);\n         return this;\n     }\n "
  },
  {
    "sha": "e01d2a1ebc1178d190cd72b8e8355fb4474d858b",
    "filename": "realm/realm-library/src/main/java/io/realm/RealmTypeSelectorForMap.java",
    "status": "added",
    "additions": 220,
    "deletions": 0,
    "changes": 220,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/RealmTypeSelectorForMap.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/RealmTypeSelectorForMap.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/main/java/io/realm/RealmTypeSelectorForMap.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.OsMap;\n+import io.realm.internal.OsResults;\n+import io.realm.internal.RealmObjectProxy;\n+import io.realm.internal.Table;\n+import io.realm.internal.util.Pair;\n+\n+/**\n+ * Abstracts certain operations from value operators depending on the type of Realm we are working\n+ * with.\n+ *\n+ * @param <K> the key type\n+ * @param <V> the value type\n+ */\n+abstract class RealmTypeSelectorForMap<K, V> {\n+\n+    protected final BaseRealm baseRealm;\n+    protected final OsMap osMap;\n+\n+    RealmTypeSelectorForMap(BaseRealm baseRealm, OsMap osMap) {\n+        this.baseRealm = baseRealm;\n+        this.osMap = osMap;\n+    }\n+\n+    protected V getRealmModel(BaseRealm baseRealm, long realmModelKey) {\n+        // do nothing here, override only for RealModels\n+        return null;\n+    }\n+\n+    protected V putRealmModel(BaseRealm baseRealm, OsMap osMap, K key, @Nullable V value) {\n+        // do nothing here, override only for RealModels\n+        return null;\n+    }\n+\n+    protected Map.Entry<K, V> getModelEntry(BaseRealm baseRealm, long objRow, K key) {\n+        // do nothing here, override only for RealModels\n+        return null;\n+    }\n+\n+    abstract Set<K> keySet();\n+\n+    abstract Collection<V> getValues();\n+\n+    abstract RealmDictionary<V> freeze(BaseRealm frozenBaseRealm);\n+}\n+\n+/**\n+ * Implementation for ordinary Realms.\n+ */\n+class RealmSelectorForMap<K, V> extends RealmTypeSelectorForMap<K, V> {\n+\n+    protected final Class<K> keyClass;\n+    protected final Class<V> valueClass;\n+\n+    public RealmSelectorForMap(BaseRealm baseRealm,\n+                               OsMap osMap,\n+                               Class<K> keyClass,\n+                               Class<V> valueClass) {\n+        super(baseRealm, osMap);\n+        this.keyClass = keyClass;\n+        this.valueClass = valueClass;\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        return new HashSet<>(produceResults(baseRealm, osMap.tableAndKeyPtrs(), true, keyClass));\n+    }\n+\n+    @Override\n+    public Collection<V> getValues() {\n+        boolean forPrimitives = !RealmModel.class.isAssignableFrom(valueClass);\n+        return produceResults(baseRealm, osMap.tableAndValuePtrs(), forPrimitives, valueClass);\n+    }\n+\n+    @Override\n+    public RealmDictionary<V> freeze(BaseRealm frozenBaseRealm) {\n+        return new RealmDictionary<>(frozenBaseRealm, osMap, valueClass);\n+    }\n+\n+    // Do not use <K> or <V> as this method can be used for either keys or values\n+    private <T> RealmResults<T> produceResults(BaseRealm baseRealm,\n+                                               Pair<Table, Long> tableAndValuesPtr,\n+                                               boolean forPrimitives,\n+                                               @Nullable Class<T> clazz) {\n+        if (baseRealm instanceof Realm) {\n+            Realm realm = (Realm) baseRealm;\n+            Long valuesPtr = tableAndValuesPtr.second;\n+            OsResults osResults = OsResults.createFromMap(baseRealm.sharedRealm, valuesPtr);\n+            if (clazz != null) {\n+                return new RealmResults<>(realm, osResults, clazz, forPrimitives);\n+            }\n+            throw new IllegalStateException(\"MapValueOperator missing class.\");\n+        }\n+\n+        throw new UnsupportedOperationException(\"Add support for 'values' for DynamicRealms.\");\n+    }\n+}\n+\n+/**\n+ * Implementation for ordinary Realms in case we are working with RealmModels.\n+ */\n+class LinkRealmSelectorForMap<K, V extends RealmModel> extends RealmSelectorForMap<K, V> {\n+\n+    public LinkRealmSelectorForMap(BaseRealm baseRealm, OsMap osMap, Class<K> keyClass, Class<V> valueClass) {\n+        super(baseRealm, osMap, keyClass, valueClass);\n+    }\n+\n+    @Override\n+    public V getRealmModel(BaseRealm baseRealm, long realmModelKey) {\n+        return baseRealm.get(valueClass, null, realmModelKey);\n+    }\n+\n+    @Override\n+    public V putRealmModel(BaseRealm baseRealm, OsMap osMap, K key, @Nullable V value) {\n+        long rowModelKey = osMap.getModelRowKey(key);\n+\n+        if (value == null) {\n+            osMap.put(key, null);\n+        } else {\n+            boolean isEmbedded = baseRealm.getSchema().getSchemaForClass(valueClass).isEmbedded();\n+            if (isEmbedded) {\n+                long objKey = osMap.createAndPutEmbeddedObject(key);\n+                CollectionUtils.updateEmbeddedObject((Realm) baseRealm, value, objKey);\n+            } else {\n+                boolean copyObject = CollectionUtils.checkCanObjectBeCopied(baseRealm, value, valueClass.getSimpleName());\n+                RealmObjectProxy proxy = (RealmObjectProxy) ((copyObject) ? CollectionUtils.copyToRealm(baseRealm, value) : value);\n+                osMap.putRow(key, proxy.realmGet$proxyState().getRow$realm().getObjectKey());\n+            }\n+        }\n+\n+        if (rowModelKey == OsMap.NOT_FOUND) {\n+            return null;\n+        } else {\n+            return (V) baseRealm.get(valueClass, rowModelKey, false, new ArrayList<>());\n+        }\n+    }\n+\n+    @Override\n+    public Map.Entry<K, V> getModelEntry(BaseRealm baseRealm, long objRow, K key) {\n+        V realmModel = baseRealm.get(valueClass, null, objRow);\n+        return new AbstractMap.SimpleImmutableEntry<>(key, realmModel);\n+    }\n+}\n+\n+/**\n+ * Implementation for DynamicRealms.\n+ */\n+class DynamicRealmSelectorForMap<K, V> extends RealmTypeSelectorForMap<K, V> {\n+\n+    private final String className;\n+\n+    public DynamicRealmSelectorForMap(BaseRealm baseRealm,\n+                                      OsMap osMap,\n+                                      String className) {\n+        super(baseRealm, osMap);\n+        this.className = className;\n+    }\n+\n+    @Override\n+    public V getRealmModel(BaseRealm baseRealm, long realmModelKey) {\n+        // TODO\n+        throw new UnsupportedOperationException(\"Support for getRealmModel for DynamicRealms not ready yet \");\n+    }\n+\n+    @Override\n+    public V putRealmModel(BaseRealm baseRealm, OsMap osMap, K key, @Nullable V value) {\n+        // TODO\n+        throw new UnsupportedOperationException(\"Support for putRealmModel for DynamicRealms not ready yet \");\n+    }\n+\n+    @Override\n+    public Map.Entry<K, V> getModelEntry(BaseRealm baseRealm, long objRow, K key) {\n+        // TODO\n+        throw new UnsupportedOperationException(\"Support for getModelEntry for DynamicRealms not ready yet \");\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        // TODO\n+        throw new UnsupportedOperationException(\"Support for keySet for DynamicRealms not ready yet \");\n+    }\n+\n+    @Override\n+    public Collection<V> getValues() {\n+        // TODO\n+        throw new UnsupportedOperationException(\"Support for getValues for DynamicRealms not ready yet \");\n+    }\n+\n+    @Override\n+    public RealmDictionary<V> freeze(BaseRealm frozenBaseRealm) {\n+        // TODO\n+        throw new UnsupportedOperationException(\"Support for freeze for DynamicRealms not ready yet \");\n+    }\n+}"
  },
  {
    "sha": "c9977bc84010ebfb1e9165a6944b760f88f34425",
    "filename": "realm/realm-library/src/main/java/io/realm/internal/ClassContainer.java",
    "status": "removed",
    "additions": 0,
    "deletions": 45,
    "changes": 45,
    "blob_url": "https://github.com/realm/realm-java/blob/d3bed728ac8a457fd7996d4d2b1cb7ef3d2c5cfa/realm/realm-library/src/main/java/io/realm/internal/ClassContainer.java",
    "raw_url": "https://github.com/realm/realm-java/raw/d3bed728ac8a457fd7996d4d2b1cb7ef3d2c5cfa/realm/realm-library/src/main/java/io/realm/internal/ClassContainer.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/main/java/io/realm/internal/ClassContainer.java?ref=d3bed728ac8a457fd7996d4d2b1cb7ef3d2c5cfa",
    "patch": "@@ -1,45 +0,0 @@\n-/*\n- * Copyright 2020 Realm Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.realm.internal;\n-\n-import javax.annotation.Nullable;\n-\n-/**\n- * Used to avoid passing a {@link Class} and a {@link String} via parameters to the value operators.\n- */\n-public class ClassContainer {\n-\n-    @Nullable\n-    private final Class<?> clazz;\n-    @Nullable\n-    private final String className;\n-\n-    public ClassContainer(@Nullable Class<?> clazz, @Nullable String className) {\n-        this.clazz = clazz;\n-        this.className = className;\n-    }\n-\n-    @Nullable\n-    public Class<?> getClazz() {\n-        return clazz;\n-    }\n-\n-    @Nullable\n-    public String getClassName() {\n-        return className;\n-    }\n-}"
  },
  {
    "sha": "0b0ed43815615199fe6a415070dbb0ebd020553f",
    "filename": "realm/realm-library/src/main/java/io/realm/internal/OsMap.java",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/internal/OsMap.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/internal/OsMap.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/main/java/io/realm/internal/OsMap.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -217,8 +217,8 @@ public long getMixedPtr(Object key) {\n         return nativeGetMixedPtr(nativePtr, (String) key);\n     }\n \n-    public long createAndPutEmbeddedObject(OsSharedRealm sharedRealm, Object key) {\n-        return nativeCreateAndPutEmbeddedObject(sharedRealm.getNativePtr(), nativePtr, (String) key);\n+    public long createAndPutEmbeddedObject(Object key) {\n+        return nativeCreateAndPutEmbeddedObject(nativePtr, (String) key);\n     }\n \n     public <K> Pair<K, Object> getEntryForPrimitive(int position) {\n@@ -315,7 +315,7 @@ public void stopListening() {\n \n     private static native long nativeFreeze(long nativePtr, long realmPtr);\n \n-    private static native long nativeCreateAndPutEmbeddedObject(long sharedRealmPtr, long nativePtr, String key);\n+    private static native long nativeCreateAndPutEmbeddedObject(long nativePtr, String key);\n \n     private static native Object[] nativeGetEntryForModel(long nativePtr, int position);\n "
  },
  {
    "sha": "3ac74c01e773534f1df68a37c24a05fb4b69e3b0",
    "filename": "realm/realm-library/src/main/java/io/realm/internal/TableQuery.java",
    "status": "modified",
    "additions": 23,
    "deletions": 50,
    "changes": 73,
    "blob_url": "https://github.com/realm/realm-java/blob/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java",
    "raw_url": "https://github.com/realm/realm-java/raw/6b9a334b50fb4245d3c6ca352b4be7685bfa073d/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java",
    "contents_url": "https://api.github.com/repos/realm/realm-java/contents/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java?ref=6b9a334b50fb4245d3c6ca352b4be7685bfa073d",
    "patch": "@@ -20,6 +20,7 @@\n import org.bson.types.ObjectId;\n \n import java.util.Date;\n+import java.util.Map;\n import java.util.UUID;\n \n import io.realm.Mixed;\n@@ -172,56 +173,8 @@ public TableQuery isNotEmpty(String fieldName) {\n         return this;\n     }\n \n-    public TableQuery rawPredicate(String predicate, Object... args) {\n-        Mixed[] mixedArgs = new Mixed[args.length];\n-\n-        for (int i = 0; i < args.length; i++) {\n-            Object argument = args[i];\n-            if (argument == null) {\n-                mixedArgs[i] = Mixed.nullValue();\n-            } else if (argument instanceof Boolean) {\n-                mixedArgs[i] = Mixed.valueOf((Boolean) argument);\n-            } else if (argument instanceof Byte) {\n-                mixedArgs[i] = Mixed.valueOf((Byte) argument);\n-            } else if (argument instanceof Short) {\n-                mixedArgs[i] = Mixed.valueOf((Short) argument);\n-            } else if (argument instanceof Integer) {\n-                mixedArgs[i] = Mixed.valueOf((Integer) argument);\n-            } else if (argument instanceof Long) {\n-                mixedArgs[i] = Mixed.valueOf((Long) argument);\n-            } else if (argument instanceof Float) {\n-                mixedArgs[i] = Mixed.valueOf((Float) argument);\n-            } else if (argument instanceof Double) {\n-                mixedArgs[i] = Mixed.valueOf((Double) argument);\n-            } else if (argument instanceof Decimal128) {\n-                mixedArgs[i] = Mixed.valueOf((Decimal128) argument);\n-            } else if (argument instanceof String) {\n-                mixedArgs[i] = Mixed.valueOf((String) argument);\n-            } else if (argument instanceof byte[]) {\n-                mixedArgs[i] = Mixed.valueOf((byte[]) argument);\n-            } else if (argument instanceof Date) {\n-                mixedArgs[i] = Mixed.valueOf((Date) argument);\n-            } else if (argument instanceof ObjectId) {\n-                mixedArgs[i] = Mixed.valueOf((ObjectId) argument);\n-            } else if (argument instanceof UUID) {\n-                mixedArgs[i] = Mixed.valueOf((UUID) argument);\n-            } else if (argument instanceof Mixed) {\n-                mixedArgs[i] = (Mixed) argument;\n-            } else if (RealmModel.class.isAssignableFrom(argument.getClass())) {\n-                RealmModel value = (RealmModel) argument;\n-\n-                if (!RealmObject.isValid(value) || !RealmObject.isManaged(value)) {\n-                    throw new IllegalArgumentException(\"Argument[\" + i + \"] is not a valid managed object.\");\n-                }\n-\n-                mixedArgs[i] = Mixed.valueOf((RealmModel) argument);\n-            } else {\n-                throw new IllegalArgumentException(\"Unsupported query argument type: \" + argument.getClass().getSimpleName());\n-            }\n-        }\n-\n-        mixedNativeFunctions.callRawPredicate(this, predicate, mixedArgs);\n-\n+    public TableQuery rawPredicate(String predicate, Mixed... args) {\n+        mixedNativeFunctions.callRawPredicate(this, predicate, args);\n         return this;\n     }\n \n@@ -344,6 +297,26 @@ public TableQuery containsInsensitive(String fieldName, Mixed value) {\n         return this;\n     }\n \n+    // Dictionary queries\n+\n+    public TableQuery containsKey(String fieldName, Mixed key) {\n+        mixedNativeFunctions.callRawPredicate(this, \"ANY \" + fieldName + \".@keys == $0\", key);\n+        queryValidated = false;\n+        return this;\n+    }\n+\n+    public TableQuery containsValue(String fieldName, Mixed value) {\n+        mixedNativeFunctions.callRawPredicate(this, \"ANY \" + fieldName + \".@values == $0\", value);\n+        queryValidated = false;\n+        return this;\n+    }\n+\n+    public TableQuery containsEntry(String fieldName, Mixed key, Mixed value) {\n+        mixedNativeFunctions.callRawPredicate(this, fieldName + \"[$0] == $1\", key, value);\n+        queryValidated = false;\n+        return this;\n+    }\n+\n     // isNull and isNotNull\n     public TableQuery isNull(String fieldName) {\n         rawPredicateWithPointers(fieldName + \" = NULL\");"
  }
]
