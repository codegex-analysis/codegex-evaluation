[
  {
    "sha": "db09c12e8bd8721d372ece76cb8e319c532a97b5",
    "filename": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/ColumnDescriptor.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/splicemachine/spliceengine/blob/ea2a4ac8da66acce4b12f7eb26b4bb8c851aceb4/db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/ColumnDescriptor.java",
    "raw_url": "https://github.com/splicemachine/spliceengine/raw/ea2a4ac8da66acce4b12f7eb26b4bb8c851aceb4/db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/ColumnDescriptor.java",
    "contents_url": "https://api.github.com/repos/splicemachine/spliceengine/contents/db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/ColumnDescriptor.java?ref=ea2a4ac8da66acce4b12f7eb26b4bb8c851aceb4",
    "patch": "@@ -640,7 +640,7 @@ public static boolean allowsStatistics(int typeFormatId){\n \n     public static boolean allowsStatistics(DataTypeDescriptor columnType) {\n         try {\n-            return allowsStatistics(columnType.getNull().getTypeFormatId());\n+            return columnType != null && allowsStatistics(columnType.getNull().getTypeFormatId());\n         } catch (StandardException se) {\n             throw new RuntimeException(se);\n         }"
  },
  {
    "sha": "8810a17111d09a6b5fffb68350053524036dfd29",
    "filename": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateViewNode.java",
    "status": "modified",
    "additions": 556,
    "deletions": 547,
    "changes": 1103,
    "blob_url": "https://github.com/splicemachine/spliceengine/blob/ea2a4ac8da66acce4b12f7eb26b4bb8c851aceb4/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateViewNode.java",
    "raw_url": "https://github.com/splicemachine/spliceengine/raw/ea2a4ac8da66acce4b12f7eb26b4bb8c851aceb4/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateViewNode.java",
    "contents_url": "https://api.github.com/repos/splicemachine/spliceengine/contents/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateViewNode.java?ref=ea2a4ac8da66acce4b12f7eb26b4bb8c851aceb4",
    "patch": "@@ -62,512 +62,521 @@\n \n public class CreateViewNode extends DDLStatementNode\n {\n-\tResultColumnList\tresultColumns;\n-\tResultSetNode\t\tqueryExpression;\n-\tString\t\t\t\tqeText;\n-\tint\t\t\t\t\tcheckOption;\n-\tProviderInfo[]\t\tproviderInfos;\n-\tColumnInfo[]\t\tcolInfos;\n-\tprivate OrderByList orderByList;\n+    ResultColumnList    resultColumns;\n+    ResultSetNode        queryExpression;\n+    String                qeText;\n+    int                    checkOption;\n+    ProviderInfo[]        providerInfos;\n+    ColumnInfo[]        colInfos;\n+    private OrderByList orderByList;\n     private ValueNode   offset;\n     private ValueNode   fetchFirst;\n     private boolean hasJDBClimitClause; // true if using JDBC limit/offset escape syntax\n-\tprivate boolean isRecursive;\n-\tprivate boolean isDynamic;  // true if this node is created for a CTE\n-\n-\t/**\n-\t * Initializer for a CreateViewNode\n-\t *\n-\t * @param newObjectName\t\tThe name of the table to be created\n-\t * @param resultColumns\t\tThe column list from the view definition, \n-\t *\t\t\t\t\t\t\tif specified\n-\t * @param queryExpression\tThe query expression for the view\n-\t * @param checkOption\t\tThe type of WITH CHECK OPTION that was specified\n-\t *\t\t\t\t\t\t\t(NONE for now)\n-\t * @param qeText\t\t\tThe text for the queryExpression\n-\t * @param orderCols         ORDER BY list\n+    private boolean isRecursive;\n+    private boolean isDynamic;  // true if this node is created for a CTE\n+\n+    /**\n+     * Initializer for a CreateViewNode\n+     *\n+     * @param newObjectName        The name of the table to be created\n+     * @param resultColumns        The column list from the view definition,\n+     *                            if specified\n+     * @param queryExpression    The query expression for the view\n+     * @param checkOption        The type of WITH CHECK OPTION that was specified\n+     *                            (NONE for now)\n+     * @param qeText            The text for the queryExpression\n+     * @param orderCols         ORDER BY list\n      * @param offset            OFFSET if any, or null\n      * @param fetchFirst        FETCH FIRST if any, or null\n-\t * @param hasJDBClimitClause True if the offset/fetchFirst clauses come from JDBC limit/offset escape syntax\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n-\n-\tpublic void init(Object newObjectName,\n-\t\t\t\t   Object resultColumns,\n-\t\t\t\t   Object\t queryExpression,\n-\t\t\t\t   Object checkOption,\n-\t\t\t\t   Object qeText,\n+     * @param hasJDBClimitClause True if the offset/fetchFirst clauses come from JDBC limit/offset escape syntax\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+\n+    public void init(Object newObjectName,\n+                   Object resultColumns,\n+                   Object     queryExpression,\n+                   Object checkOption,\n+                   Object qeText,\n                    Object orderCols,\n                    Object offset,\n                    Object fetchFirst,\n                    Object hasJDBClimitClause,\n                    Object isRecursive,\n                    Object isDynamic)\n-\t\tthrows StandardException\n-\t{\n-\t\tinitAndCheck(newObjectName);\n-\t\tthis.resultColumns = (ResultColumnList) resultColumns;\n-\t\tthis.queryExpression = (ResultSetNode) queryExpression;\n-\t\tthis.checkOption = (Integer) checkOption;\n-\t\tthis.qeText = ((String) qeText).trim();\n-\t\tthis.orderByList = (OrderByList)orderCols;\n+        throws StandardException\n+    {\n+        initAndCheck(newObjectName);\n+        this.resultColumns = (ResultColumnList) resultColumns;\n+        this.queryExpression = (ResultSetNode) queryExpression;\n+        this.checkOption = (Integer) checkOption;\n+        this.qeText = ((String) qeText).trim();\n+        this.orderByList = (OrderByList)orderCols;\n         this.offset = (ValueNode)offset;\n         this.fetchFirst = (ValueNode)fetchFirst;\n         this.hasJDBClimitClause = hasJDBClimitClause != null && (Boolean) hasJDBClimitClause;\n         this.isRecursive = isRecursive != null && (Boolean) isRecursive;\n         this.isDynamic = isDynamic != null && (Boolean) isDynamic;\n \n-\t\timplicitCreateSchema = true;\n-\t}\n-\n-\t/**\n-\t * Convert this object to a String.  See comments in QueryTreeNode.java\n-\t * for how this should be done for tree printing.\n-\t *\n-\t * @return\tThis object as a String\n-\t */\n-\n-\tpublic String toString()\n-\t{\n-\t\tif (SanityManager.DEBUG)\n-\t\t{\n-\t\t\treturn super.toString() +\n-\t\t\t\t\"checkOption: \" + checkOption + \"\\n\" +\n-\t\t\t\t\"qeText: \" + qeText + \"\\n\";\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn \"\";\n-\t\t}\n-\t}\n-\n-\tpublic String statementToString()\n-\t{\n-\t\treturn \"CREATE VIEW\";\n-\t}\n-\n-\t/**\n-\t * Prints the sub-nodes of this object.  See QueryTreeNode.java for\n-\t * how tree printing is supposed to work.\n-\t *\n-\t * @param depth\t\tThe depth of this node in the tree\n-\t */\n-\n-\tpublic void printSubNodes(int depth)\n-\t{\n-\t\tif (SanityManager.DEBUG)\n-\t\t{\n-\t\t\tsuper.printSubNodes(depth);\n-\n-\t\t\tif (resultColumns != null)\n-\t\t\t{\n-\t\t\t\tprintLabel(depth, \"resultColumns: \");\n-\t\t\t\tresultColumns.treePrint(depth + 1);\n-\t\t\t}\n-\n-\t\t\tprintLabel(depth, \"queryExpression: \");\n-\t\t\tqueryExpression.treePrint(depth + 1);\n-\t\t}\n-\t}\n-\n-\t// accessors\n-\n-\tpublic\tint\t\t\t\tgetCheckOption() { return checkOption; }\n-\n-\tpublic\tProviderInfo[]\tgetProviderInfo() { return providerInfos; }\n-\n-\tpublic\tColumnInfo[]\tgetColumnInfo() { return colInfos; }\n-\n-\t// We inherit the generate() method from DDLStatementNode.\n-\n-\t/**\n-\t * Bind this CreateViewNode.  This means doing any static error\n-\t * checking that can be done before actually creating the table.\n-\t * For example, verifying that the ResultColumnList does not\n-\t * contain any duplicate column names.\n-\t *\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n-\tpublic void bindStatement() throws StandardException\n-\t{\n-\t\tCompilerContext\t\t\t\tcc = getCompilerContext();\n-\t\tDataDictionary\t\t\t\tdataDictionary = getDataDictionary();\n-\t\tResultColumnList\t\t\tqeRCL;\n-\t\tString\t\t\t\t\t\tduplicateColName;\n-\n-\t\t// bind the query expression\n-\t\tif (isRecursive) {\n-\t\t\tproviderInfos = bindRecursiveViewDefinition\n-\t\t\t\t\t( dataDictionary, cc,\n-\t\t\t\t\t\t\tgetNodeFactory(),\n-\t\t\t\t\t\t\tgetContextManager()\n-\t\t\t\t\t);\n-\t\t} else {\n-\t\t\tproviderInfos = bindViewDefinition\n-\t\t\t\t\t(dataDictionary, cc,\n-\t\t\t\t\t\t\tgetNodeFactory(),\n-\t\t\t\t\t\t\tqueryExpression,\n-\t\t\t\t\t\t\tgetContextManager()\n-\t\t\t\t\t);\n-\t\t}\n-\n-\t\tqeRCL = queryExpression.getResultColumns();\n-\n-\t\t/* If there is an RCL for the view definition then\n-\t\t * copy the names to the queryExpression's RCL after verifying\n-\t\t * that they both have the same size.\n-\t\t */\n-\t\tif (resultColumns != null)\n-\t\t{\n-\t\t\tif (resultColumns.size() != qeRCL.visibleSize())\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_VIEW_DEFINITION_R_C_L_MISMATCH,\n-\t\t\t\t\t\t\t\tgetFullName());\n-\t\t\t}\n-\t\t\tqeRCL.copyResultColumnNames(resultColumns);\n-\t\t}\n-\n-\t\t/* Check to make sure the queryExpression's RCL has unique names. If target column\n-\t\t * names not specified, raise error if there are any un-named columns to match DB2\n-\t\t */\n-\t\tduplicateColName = qeRCL.verifyUniqueNames(resultColumns == null);\n-\t\tif (duplicateColName != null)\n-\t\t{\n-\t\t\tthrow StandardException.newException(SQLState.LANG_DUPLICATE_COLUMN_NAME_CREATE_VIEW, duplicateColName);\n-\t\t}\n-\n-\t\t/* Only 5000 columns allowed per view */\n-\t\tif (queryExpression.getResultColumns().size() > Limits.DB2_MAX_COLUMNS_IN_VIEW)\n-\t\t{\n-\t\t\tthrow StandardException.newException(SQLState.LANG_TOO_MANY_COLUMNS_IN_TABLE_OR_VIEW,\n-\t\t\t\tString.valueOf(queryExpression.getResultColumns().size()),\n-\t\t\t\tgetRelativeName(),\n-\t\t\t\tString.valueOf(Limits.DB2_MAX_COLUMNS_IN_VIEW));\n-\t\t}\n-\n-\t\t// for each column, stuff system.column\n-\t\t// System columns should only include visible columns DERBY-4230\n-\t\tcolInfos = new ColumnInfo[queryExpression.getResultColumns().visibleSize()];\n-\t\tgenColumnInfos(colInfos);\n-\t}\n-\n-\t/**\n-\t * Bind the query expression for a view definition. \n-\t *\n-\t * @param dataDictionary\tThe DataDictionary to use to look up\n-\t *\t\t\t\tcolumns, tables, etc.\n-\t *\n-\t * @return\tArray of providers that this view depends on.\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n-\n-\tprivate ProviderInfo[] bindViewDefinition( DataDictionary \tdataDictionary,\n-\t\t\t\t\t\t\t\t\t\t\t CompilerContext\tcompilerContext,\n-\t\t\t\t\t\t\t\t\t\t\t NodeFactory\t\tnodeFactory,\n-\t\t\t\t\t\t\t\t\t\t\t ResultSetNode\t\tqueryExpr,\n-\t\t\t\t\t\t\t\t\t\t\t ContextManager\t\tcm)\n-\t\tthrows StandardException\n-\t{\n-\t\tFromList\tfromList = (FromList) nodeFactory.getNode(\n-\t\t\t\t\t\t\t\t\t\tC_NodeTypes.FROM_LIST,\n-\t\t\t\t\t\t\t\t\t\tnodeFactory.doJoinOrderOptimization(),\n-\t\t\t\t\t\t\t\t\t\tcm);\n-\n-\t\tProviderList \tprevAPL = compilerContext.getCurrentAuxiliaryProviderList();\n-\t\tProviderList \tapl = new ProviderList();\n-\n-\t\ttry {\n-\t\t\tcompilerContext.setCurrentAuxiliaryProviderList(apl);\n-\t\t\tcompilerContext.pushCurrentPrivType(Authorizer.SELECT_PRIV);\n-\n-\t\t\t/* Bind the tables in the queryExpression */\n-\t\t\tqueryExpr = queryExpr.bindNonVTITables(dataDictionary, fromList);\n-\t\t\tqueryExpr = queryExpr.bindVTITables(fromList);\n-\n-\n-\t\t\t/* Bind the expressions under the resultSet */\n-\t\t\tqueryExpr.bindExpressions(fromList);\n-\n-\t\t\t//cannot define views on temporary tables\n-\t\t\tif (queryExpr instanceof SelectNode)\n-\t\t\t{\n-\t\t\t\t//If attempting to reference a SESSION schema table (temporary or permanent) in the view, throw an exception\n-\t\t\t\tif (!isDynamic && (queryExpr.referencesSessionSchema() ||\n-\t\t\t\t\t\t(getObjectName().hasSchema() && getObjectName().schemaName.equals(SchemaDescriptor.STD_DECLARED_GLOBAL_TEMPORARY_TABLES_SCHEMA_NAME))))\n-\t\t\t\t\tthrow StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);\n+        implicitCreateSchema = true;\n+    }\n+\n+    /**\n+     * Convert this object to a String.  See comments in QueryTreeNode.java\n+     * for how this should be done for tree printing.\n+     *\n+     * @return    This object as a String\n+     */\n+\n+    public String toString()\n+    {\n+        if (SanityManager.DEBUG)\n+        {\n+            return super.toString() +\n+                \"checkOption: \" + checkOption + \"\\n\" +\n+                \"qeText: \" + qeText + \"\\n\";\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+\n+    public String statementToString()\n+    {\n+        return \"CREATE VIEW\";\n+    }\n+\n+    /**\n+     * Prints the sub-nodes of this object.  See QueryTreeNode.java for\n+     * how tree printing is supposed to work.\n+     *\n+     * @param depth        The depth of this node in the tree\n+     */\n+\n+    public void printSubNodes(int depth)\n+    {\n+        if (SanityManager.DEBUG)\n+        {\n+            super.printSubNodes(depth);\n+\n+            if (resultColumns != null)\n+            {\n+                printLabel(depth, \"resultColumns: \");\n+                resultColumns.treePrint(depth + 1);\n+            }\n+\n+            printLabel(depth, \"queryExpression: \");\n+            queryExpression.treePrint(depth + 1);\n+        }\n+    }\n+\n+    // accessors\n+\n+    public    int                getCheckOption() { return checkOption; }\n+\n+    public    ProviderInfo[]    getProviderInfo() { return providerInfos; }\n+\n+    public    ColumnInfo[]    getColumnInfo() { return colInfos; }\n+\n+    // We inherit the generate() method from DDLStatementNode.\n+\n+    /**\n+     * Bind this CreateViewNode.  This means doing any static error\n+     * checking that can be done before actually creating the table.\n+     * For example, verifying that the ResultColumnList does not\n+     * contain any duplicate column names.\n+     *\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+    public void bindStatement() throws StandardException\n+    {\n+        CompilerContext                cc = getCompilerContext();\n+        DataDictionary                dataDictionary = getDataDictionary();\n+        ResultColumnList            qeRCL;\n+        String                        duplicateColName;\n+\n+        /* Parameters not allowed in create view */\n+        if (!isDynamic) {\n+            HasNodeVisitor visitor = new HasNodeVisitor(ParameterNode.class);\n+            queryExpression.accept(visitor);\n+            if (visitor.hasNode()) {\n+                throw StandardException.newException(SQLState.LANG_NO_PARAMS_IN_VIEWS);\n+            }\n+        }\n+\n+        // bind the query expression\n+        if (isRecursive) {\n+            providerInfos = bindRecursiveViewDefinition\n+                    ( dataDictionary, cc,\n+                            getNodeFactory(),\n+                            getContextManager()\n+                    );\n+        } else {\n+            providerInfos = bindViewDefinition\n+                    (dataDictionary, cc,\n+                            getNodeFactory(),\n+                            queryExpression,\n+                            getContextManager()\n+                    );\n+        }\n+\n+        qeRCL = queryExpression.getResultColumns();\n+\n+        /* If there is an RCL for the view definition then\n+         * copy the names to the queryExpression's RCL after verifying\n+         * that they both have the same size.\n+         */\n+        if (resultColumns != null)\n+        {\n+            if (resultColumns.size() != qeRCL.visibleSize())\n+            {\n+                throw StandardException.newException(SQLState.LANG_VIEW_DEFINITION_R_C_L_MISMATCH,\n+                                getFullName());\n+            }\n+            qeRCL.copyResultColumnNames(resultColumns);\n+        }\n+\n+        /* Check to make sure the queryExpression's RCL has unique names. If target column\n+         * names not specified, raise error if there are any un-named columns to match DB2\n+         */\n+        duplicateColName = qeRCL.verifyUniqueNames(resultColumns == null);\n+        if (duplicateColName != null)\n+        {\n+            throw StandardException.newException(SQLState.LANG_DUPLICATE_COLUMN_NAME_CREATE_VIEW, duplicateColName);\n+        }\n+\n+        /* Only 5000 columns allowed per view */\n+        if (queryExpression.getResultColumns().size() > Limits.DB2_MAX_COLUMNS_IN_VIEW)\n+        {\n+            throw StandardException.newException(SQLState.LANG_TOO_MANY_COLUMNS_IN_TABLE_OR_VIEW,\n+                String.valueOf(queryExpression.getResultColumns().size()),\n+                getRelativeName(),\n+                String.valueOf(Limits.DB2_MAX_COLUMNS_IN_VIEW));\n+        }\n+\n+        // for each column, stuff system.column\n+        // System columns should only include visible columns DERBY-4230\n+        colInfos = new ColumnInfo[queryExpression.getResultColumns().visibleSize()];\n+        genColumnInfos(colInfos);\n+    }\n+\n+    /**\n+     * Bind the query expression for a view definition.\n+     *\n+     * @param dataDictionary    The DataDictionary to use to look up\n+     *                columns, tables, etc.\n+     *\n+     * @return    Array of providers that this view depends on.\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+\n+    private ProviderInfo[] bindViewDefinition( DataDictionary     dataDictionary,\n+                                             CompilerContext    compilerContext,\n+                                             NodeFactory        nodeFactory,\n+                                             ResultSetNode        queryExpr,\n+                                             ContextManager        cm)\n+        throws StandardException\n+    {\n+        FromList    fromList = (FromList) nodeFactory.getNode(\n+                                        C_NodeTypes.FROM_LIST,\n+                                        nodeFactory.doJoinOrderOptimization(),\n+                                        cm);\n+\n+        ProviderList     prevAPL = compilerContext.getCurrentAuxiliaryProviderList();\n+        ProviderList     apl = new ProviderList();\n+\n+        try {\n+            compilerContext.setCurrentAuxiliaryProviderList(apl);\n+            compilerContext.pushCurrentPrivType(Authorizer.SELECT_PRIV);\n+\n+            /* Bind the tables in the queryExpression */\n+            queryExpr = queryExpr.bindNonVTITables(dataDictionary, fromList);\n+            queryExpr = queryExpr.bindVTITables(fromList);\n+\n+\n+            /* Bind the expressions under the resultSet */\n+            queryExpr.bindExpressions(fromList);\n+\n+            //cannot define views on temporary tables\n+            if (queryExpr instanceof SelectNode)\n+            {\n+                //If attempting to reference a SESSION schema table (temporary or permanent) in the view, throw an exception\n+                if (!isDynamic && (queryExpr.referencesSessionSchema() ||\n+                        (getObjectName().hasSchema() && getObjectName().schemaName.equals(SchemaDescriptor.STD_DECLARED_GLOBAL_TEMPORARY_TABLES_SCHEMA_NAME))))\n+                    throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);\n                 // check that no provider is a temp table (whether or not it's in SESSION schema)\n                 for (Provider provider : apl.values()) {\n                     if (provider instanceof TableDescriptor && ! provider.isPersistent()) {\n                         throw StandardException.newException(SQLState.LANG_TEMP_TABLES_CANNOT_BE_IN_VIEWS,\n                                                              provider.getObjectName());\n                     }\n                 }\n-\t\t\t}\n-\n-\t\t\t// bind the query expression\n-\t\t\tqueryExpr.bindResultColumns(fromList);\n-\t\t\t\n-\t\t\t// rejects any untyped nulls in the RCL\n-\t\t\t// e.g.:  CREATE VIEW v1 AS VALUES NULL\n-\t\t\tqueryExpr.bindUntypedNullsToResultColumns(null);\n-\t\t}\n-\t\tfinally\n-\t\t{\n-\t\t\tcompilerContext.popCurrentPrivType();\n-\t\t\tcompilerContext.setCurrentAuxiliaryProviderList(prevAPL);\n-\t\t}\n-\n-\t\tDependencyManager \t\tdm = dataDictionary.getDependencyManager();\n-\t\tProviderInfo[]\t\t\tproviderInfos = dm.getPersistentProviderInfos(apl);\n-\t\t// need to clear the column info in case the same table descriptor\n-\t\t// is reused, eg., in multiple target only view definition\n-\t\tdm.clearColumnInfoInProviders(apl);\n-\n-\t\t/* Verify that all underlying ResultSets reclaimed their FromList */\n-\t\tif (SanityManager.DEBUG)\n-\t\t{\n-\t\t\tSanityManager.ASSERT(fromList.size() == 0,\n-\t\t\t\t\"fromList.size() is expected to be 0, not \" + fromList.size() +\n-\t\t\t\t\" on return from RS.bindExpressions()\");\n-\t\t}\n-\n-\t\treturn providerInfos;\n-\t}\n-\n-\tpublic void replaceSelfReferenceForRecursiveView(TableDescriptor td) throws StandardException {\n-\t\t// set recursive view descriptor which contains the column type info.\n-\t\t((UnionNode)queryExpression).setViewDescreiptor(td);\n-\t\tResultSetNode leftResultSetNode = ((UnionNode) queryExpression).getLeftResultSet();\n-\t\tResultSetNode rightResultSetNode = ((UnionNode) queryExpression).getRightResultSet();\n-\t\tRecursiveViewReferenceVisitor recursiveViewReferenceVisitor =\n-\t\t\t\tnew RecursiveViewReferenceVisitor(getObjectName(), leftResultSetNode, queryExpression, td);\n-\n-\t\tleftResultSetNode.accept(recursiveViewReferenceVisitor);\n-\t\tint numReferences = recursiveViewReferenceVisitor.getNumReferences();\n-\t\tif (numReferences > 0) {\n-\t\t\tthrow StandardException.newException(SQLState.LANG_SYNTAX_ERROR,\n-\t\t\t\t\t\"No recursive reference is allowed in the seed statement of a WITH RECURSIVE\");\n-\t\t}\n-\n-\t\trightResultSetNode.accept(recursiveViewReferenceVisitor);\n-\t\tnumReferences = recursiveViewReferenceVisitor.getNumReferences();\n-\n-\t\t/* check for valid syntax: currently only one recursive reference is allowed */\n-\t\tif (numReferences <= 0) {\n-\t\t\tthrow StandardException.newException(SQLState.LANG_SYNTAX_ERROR,\n-\t\t\t\t\t\"No recursive reference found in WITH RECURSIVE\");\n-\t\t} else if (numReferences > 1) {\n-\t\t\tthrow StandardException.newException(SQLState.LANG_SYNTAX_ERROR,\n-\t\t\t\t\t\"More than one recursive reference in WITH RECURSIVE is not supported!\");\n-\t\t}\n-\n-\t\treturn;\n-\t}\n-\n-\tprivate ProviderInfo[] bindRecursiveViewDefinition(DataDictionary \tdataDictionary,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t   CompilerContext\tcompilerContext,\n-\t\t\t\t\t\t\t\t\t\t\t           NodeFactory\t\tnodeFactory,\n-\t\t\t\t\t\t\t\t\t\t\t           ContextManager\tcm)\n-\t\t\tthrows StandardException\n-\t{\n-\t\tFromList\tfromList = (FromList) nodeFactory.getNode(\n-\t\t\t\tC_NodeTypes.FROM_LIST,\n-\t\t\t\tnodeFactory.doJoinOrderOptimization(),\n-\t\t\t\tcm);\n-\n-\t\tProviderList \tprevAPL = compilerContext.getCurrentAuxiliaryProviderList();\n-\t\tProviderList \tapl = new ProviderList();\n-\n-\t\ttry {\n-\t\t\tcompilerContext.setCurrentAuxiliaryProviderList(apl);\n-\t\t\tcompilerContext.pushCurrentPrivType(Authorizer.SELECT_PRIV);\n-\n-\t\t\t/* step 1: recursive with must be a UNION-AlL where the left branch is the\n-\t\t\t   seed, and the right branch is the recursion part with a self-reference\n-\t\t\t */\n-\t\t\tif (!(queryExpression instanceof UnionNode) ||  !((UnionNode)queryExpression).all)\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_SYNTAX_ERROR,\n-\t\t\t\t\t\t\"WITH RECURSIVE requires UNION-ALL operation at the top level of the definition\");\n-\n-\t\t\t/* step 2: replace the self-reference in the right branch with a SelfReferenceNode */\n-\t\t\treplaceSelfReferenceForRecursiveView(null);\n-\n-\t\t\t/* step 3: bind the left of the union-all */\n-\t\t\t((UnionNode) queryExpression).getLeftResultSet().bindNonVTITables(dataDictionary, fromList);\n-\t\t\t((UnionNode) queryExpression).getLeftResultSet().bindVTITables(fromList);\n-\n-\t\t\t/* Bind the expressions under the resultSet */\n-\t\t\t((UnionNode) queryExpression).getLeftResultSet().bindExpressions(fromList);\n-\n-\t\t\t// bind the query expression\n-\t\t\t((UnionNode) queryExpression).getLeftResultSet().bindResultColumns(fromList);\n-\n-\t\t\t/* step 4: bind the right only, and the union node */\n-\t\t\t((SetOperatorNode)queryExpression).bindNonVTITables(dataDictionary, fromList, true);\n-\t\t\t((SetOperatorNode)queryExpression).bindVTITables(fromList, true);\n-\t\t\t((SetOperatorNode)queryExpression).bindExpressions(fromList, true);\n-\t\t\t((SetOperatorNode)queryExpression).bindResultColumns(fromList, true);\n-\n-\t\t\t/* step 5: more syntax check, no nested recursive view allowed */\n-\t\t\tRecursiveViewSyntaxCheckVisitor syntaxCheckVisitor = new RecursiveViewSyntaxCheckVisitor();\n-\t\t\tqueryExpression.accept(syntaxCheckVisitor);\n-\n-\t\t\t// cannot define views on temporary tables\n-\t\t\t//If attempting to reference a SESSION schema table (temporary or permanent) in the view, throw an exception\n-\t\t\tif (!isDynamic && (queryExpression.referencesSessionSchema() ||\n-\t\t\t\t\t(getObjectName().hasSchema() && getObjectName().schemaName.equals(SchemaDescriptor.STD_DECLARED_GLOBAL_TEMPORARY_TABLES_SCHEMA_NAME))))\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);\n-\t\t\t// check that no provider is a temp table (whether or not it's in SESSION schema)\n-\t\t\tfor (Provider provider : apl.values()) {\n-\t\t\t\tif (provider instanceof TableDescriptor && ! provider.isPersistent()) {\n-\t\t\t\t\tthrow StandardException.newException(SQLState.LANG_TEMP_TABLES_CANNOT_BE_IN_VIEWS,\n-\t\t\t\t\t\t\tprovider.getObjectName());\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// rejects any untyped nulls in the RCL\n-\t\t\t// e.g.:  CREATE VIEW v1 AS VALUES NULL\n-\t\t\tqueryExpression.bindUntypedNullsToResultColumns(null);\n-\t\t}\n-\t\tfinally\n-\t\t{\n-\t\t\tcompilerContext.popCurrentPrivType();\n-\t\t\tcompilerContext.setCurrentAuxiliaryProviderList(prevAPL);\n-\t\t}\n-\n-\t\tDependencyManager \t\tdm = dataDictionary.getDependencyManager();\n-\t\tProviderInfo[]\t\t\tproviderInfos = dm.getPersistentProviderInfos(apl);\n-\t\t// need to clear the column info in case the same table descriptor\n-\t\t// is reused, eg., in multiple target only view definition\n-\t\tdm.clearColumnInfoInProviders(apl);\n-\n-\t\t/* Verify that all underlying ResultSets reclaimed their FromList */\n-\t\tif (SanityManager.DEBUG)\n-\t\t{\n-\t\t\tSanityManager.ASSERT(fromList.size() == 0,\n-\t\t\t\t\t\"fromList.size() is expected to be 0, not \" + fromList.size() +\n-\t\t\t\t\t\t\t\" on return from RS.bindExpressions()\");\n-\t\t}\n-\n-\t\treturn providerInfos;\n-\t}\n-\n-\t/**\n-\t * Return true if the node references SESSION schema tables (temporary or permanent)\n-\t *\n-\t * @return\ttrue if references SESSION schema tables, else false\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n-\tpublic boolean referencesSessionSchema()\n-\t\tthrows StandardException\n-\t{\n-\t\t//If create view is part of create statement and the view references SESSION schema tables, then it will\n-\t\t//get caught in the bind phase of the view and exception will be thrown by the view bind. \n-\t\treturn (queryExpression.referencesSessionSchema());\n-\t}\n-\n-\t/**\n-\t * Return true if the node references temporary tables no matter under which schema\n-\t *\n-\t * @return true if references temporary tables, else false\n-\t */\n-\t@Override\n-\tpublic boolean referencesTemporaryTable() {\n-\t\treturn queryExpression.referencesTemporaryTable();\n-\t}\n-\n-\t/**\n-\t * Create the Constant information that will drive the guts of Execution.\n-\t *\n-\t * @exception StandardException\t\tThrown on failure\n-\t */\n-\tpublic ConstantAction\tmakeConstantAction() throws StandardException\n-\t{\n-\t\t/* RESOLVE - need to build up dependendencies and store them away through\n-\t\t * the constant action.\n-\t\t */\n-\t\treturn\tgetGenericConstantActionFactory().getCreateViewConstantAction(getSchemaDescriptor().getSchemaName(),\n-\t\t\t\t\t\t\t\t\t\t\t  getRelativeName(),\n-\t\t\t\t\t\t\t\t\t\t\t  TableDescriptor.VIEW_TYPE,\n-\t\t\t\t\t\t\t\t\t\t\t  qeText,\n-\t\t\t\t\t\t\t\t\t\t\t  checkOption,\n-\t\t\t\t\t\t\t\t\t\t\t  colInfos,\n-\t\t\t\t\t\t\t\t\t\t\t  providerInfos,\n-\t\t\t\t\t\t\t\t\t\t\t  (UUID)null); \t// compilation schema, filled\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// in when we create the view\n-\t}\n-\n-\t/**\n-\t * Fill in the ColumnInfo[] for this create view.\n-\t * \n-\t * @param colInfos\tThe ColumnInfo[] to be filled in.\n-\t */\n-\tprivate void genColumnInfos(ColumnInfo[] colInfos)\n-\t{\n-\t\tResultColumnList rcl = \tqueryExpression.getResultColumns();\n-\n-\t\tfor (int index = 0; index < colInfos.length; index++)\n-\t\t{\n-\t\t\tResultColumn rc = (ResultColumn) rcl.elementAt(index);\n-\t\t\t// The colInfo array has been initialized to be of length \n-\t\t\t// visibleSize() (DERBY-4230).  This code assumes that all the visible\n-\t\t\t// columns are at the beginning of the rcl. Throw an assertion \n-\t\t\t// if we hit a generated column in what we think is the visible\n-\t\t\t// range.\n-\t\t\tif (SanityManager.DEBUG) {\n-\t\t\t\tif (rc.isGenerated)\n-\t\t\t\t\tSanityManager.THROWASSERT(\"Encountered generated column in expected visible range at rcl[\" + index +\"]\");\n-\t\t\t}\n-\t\t\t//RESOLVEAUTOINCREMENT\n-\t\t\tcolInfos[index] = new ColumnInfo(rc.getName(),\n-\t\t\t\t\t\t\t\t\t\t\t rc.getType(),\n-\t\t\t\t\t\t\t\t\t\t\t null,\n-\t\t\t\t\t\t\t\t\t\t\t null,\n-\t\t\t\t\t\t\t\t\t\t\t null,\n-\t\t\t\t\t\t\t\t\t\t\t null,\n-\t\t\t\t\t\t\t\t\t\t\t null,\n-\t\t\t\t\t\t\t\t\t\t\t ColumnInfo.CREATE,\n-\t\t\t\t\t\t\t\t\t\t\t 0, 0, 0,-1);\n-\t\t}\n-\t}\n-\n-\t/*\n-\t * class interface\n-\t */\n-\n-\t/**\n-\t  *\tGet the parsed query expression (the SELECT statement).\n-\t  *\n-\t  *\t@return\tthe parsed query expression.\n-\t  */\n-\tResultSetNode\tgetParsedQueryExpression() { return queryExpression; }\n-\n-\n-\t/*\n-\t * These methods are used by execution\n-\t * to get information for storing into\n-\t * the system catalogs.\n-\t */\n-\n-\n-\t/**\n-\t * Accept the visitor for all visitable children of this node.\n-\t * \n-\t * @param v the visitor\n-\t */\n+            }\n+\n+            // bind the query expression\n+            queryExpr.bindResultColumns(fromList);\n+\n+            // rejects any untyped nulls in the RCL\n+            // e.g.:  CREATE VIEW v1 AS VALUES NULL\n+            queryExpr.bindUntypedNullsToResultColumns(null);\n+        }\n+        finally\n+        {\n+            compilerContext.popCurrentPrivType();\n+            compilerContext.setCurrentAuxiliaryProviderList(prevAPL);\n+        }\n+\n+        DependencyManager         dm = dataDictionary.getDependencyManager();\n+        ProviderInfo[]            providerInfos = dm.getPersistentProviderInfos(apl);\n+        // need to clear the column info in case the same table descriptor\n+        // is reused, eg., in multiple target only view definition\n+        dm.clearColumnInfoInProviders(apl);\n+\n+        /* Verify that all underlying ResultSets reclaimed their FromList */\n+        if (SanityManager.DEBUG)\n+        {\n+            SanityManager.ASSERT(fromList.size() == 0,\n+                \"fromList.size() is expected to be 0, not \" + fromList.size() +\n+                \" on return from RS.bindExpressions()\");\n+        }\n+\n+        return providerInfos;\n+    }\n+\n+    public void replaceSelfReferenceForRecursiveView(TableDescriptor td) throws StandardException {\n+        // set recursive view descriptor which contains the column type info.\n+        ((UnionNode)queryExpression).setViewDescreiptor(td);\n+        ResultSetNode leftResultSetNode = ((UnionNode) queryExpression).getLeftResultSet();\n+        ResultSetNode rightResultSetNode = ((UnionNode) queryExpression).getRightResultSet();\n+        RecursiveViewReferenceVisitor recursiveViewReferenceVisitor =\n+                new RecursiveViewReferenceVisitor(getObjectName(), leftResultSetNode, queryExpression, td);\n+\n+        leftResultSetNode.accept(recursiveViewReferenceVisitor);\n+        int numReferences = recursiveViewReferenceVisitor.getNumReferences();\n+        if (numReferences > 0) {\n+            throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,\n+                    \"No recursive reference is allowed in the seed statement of a WITH RECURSIVE\");\n+        }\n+\n+        rightResultSetNode.accept(recursiveViewReferenceVisitor);\n+        numReferences = recursiveViewReferenceVisitor.getNumReferences();\n+\n+        /* check for valid syntax: currently only one recursive reference is allowed */\n+        if (numReferences <= 0) {\n+            throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,\n+                    \"No recursive reference found in WITH RECURSIVE\");\n+        } else if (numReferences > 1) {\n+            throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,\n+                    \"More than one recursive reference in WITH RECURSIVE is not supported!\");\n+        }\n+\n+        return;\n+    }\n+\n+    private ProviderInfo[] bindRecursiveViewDefinition(DataDictionary     dataDictionary,\n+                                                       CompilerContext    compilerContext,\n+                                                       NodeFactory        nodeFactory,\n+                                                       ContextManager    cm)\n+            throws StandardException\n+    {\n+        FromList    fromList = (FromList) nodeFactory.getNode(\n+                C_NodeTypes.FROM_LIST,\n+                nodeFactory.doJoinOrderOptimization(),\n+                cm);\n+\n+        ProviderList     prevAPL = compilerContext.getCurrentAuxiliaryProviderList();\n+        ProviderList     apl = new ProviderList();\n+\n+        try {\n+            compilerContext.setCurrentAuxiliaryProviderList(apl);\n+            compilerContext.pushCurrentPrivType(Authorizer.SELECT_PRIV);\n+\n+            /* step 1: recursive with must be a UNION-AlL where the left branch is the\n+               seed, and the right branch is the recursion part with a self-reference\n+             */\n+            if (!(queryExpression instanceof UnionNode) ||  !((UnionNode)queryExpression).all)\n+                throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,\n+                        \"WITH RECURSIVE requires UNION-ALL operation at the top level of the definition\");\n+\n+            /* step 2: replace the self-reference in the right branch with a SelfReferenceNode */\n+            replaceSelfReferenceForRecursiveView(null);\n+\n+            /* step 3: bind the left of the union-all */\n+            ((UnionNode) queryExpression).getLeftResultSet().bindNonVTITables(dataDictionary, fromList);\n+            ((UnionNode) queryExpression).getLeftResultSet().bindVTITables(fromList);\n+\n+            /* Bind the expressions under the resultSet */\n+            ((UnionNode) queryExpression).getLeftResultSet().bindExpressions(fromList);\n+\n+            // bind the query expression\n+            ((UnionNode) queryExpression).getLeftResultSet().bindResultColumns(fromList);\n+\n+            /* step 4: bind the right only, and the union node */\n+            ((SetOperatorNode)queryExpression).bindNonVTITables(dataDictionary, fromList, true);\n+            ((SetOperatorNode)queryExpression).bindVTITables(fromList, true);\n+            ((SetOperatorNode)queryExpression).bindExpressions(fromList, true);\n+            ((SetOperatorNode)queryExpression).bindResultColumns(fromList, true);\n+\n+            /* step 5: more syntax check, no nested recursive view allowed */\n+            RecursiveViewSyntaxCheckVisitor syntaxCheckVisitor = new RecursiveViewSyntaxCheckVisitor();\n+            queryExpression.accept(syntaxCheckVisitor);\n+\n+            // cannot define views on temporary tables\n+            //If attempting to reference a SESSION schema table (temporary or permanent) in the view, throw an exception\n+            if (!isDynamic && (queryExpression.referencesSessionSchema() ||\n+                    (getObjectName().hasSchema() && getObjectName().schemaName.equals(SchemaDescriptor.STD_DECLARED_GLOBAL_TEMPORARY_TABLES_SCHEMA_NAME))))\n+                throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);\n+            // check that no provider is a temp table (whether or not it's in SESSION schema)\n+            for (Provider provider : apl.values()) {\n+                if (provider instanceof TableDescriptor && ! provider.isPersistent()) {\n+                    throw StandardException.newException(SQLState.LANG_TEMP_TABLES_CANNOT_BE_IN_VIEWS,\n+                            provider.getObjectName());\n+                }\n+            }\n+\n+            // rejects any untyped nulls in the RCL\n+            // e.g.:  CREATE VIEW v1 AS VALUES NULL\n+            queryExpression.bindUntypedNullsToResultColumns(null);\n+        }\n+        finally\n+        {\n+            compilerContext.popCurrentPrivType();\n+            compilerContext.setCurrentAuxiliaryProviderList(prevAPL);\n+        }\n+\n+        DependencyManager         dm = dataDictionary.getDependencyManager();\n+        ProviderInfo[]            providerInfos = dm.getPersistentProviderInfos(apl);\n+        // need to clear the column info in case the same table descriptor\n+        // is reused, eg., in multiple target only view definition\n+        dm.clearColumnInfoInProviders(apl);\n+\n+        /* Verify that all underlying ResultSets reclaimed their FromList */\n+        if (SanityManager.DEBUG)\n+        {\n+            SanityManager.ASSERT(fromList.size() == 0,\n+                    \"fromList.size() is expected to be 0, not \" + fromList.size() +\n+                            \" on return from RS.bindExpressions()\");\n+        }\n+\n+        return providerInfos;\n+    }\n+\n+    /**\n+     * Return true if the node references SESSION schema tables (temporary or permanent)\n+     *\n+     * @return    true if references SESSION schema tables, else false\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+    public boolean referencesSessionSchema()\n+        throws StandardException\n+    {\n+        //If create view is part of create statement and the view references SESSION schema tables, then it will\n+        //get caught in the bind phase of the view and exception will be thrown by the view bind.\n+        return (queryExpression.referencesSessionSchema());\n+    }\n+\n+    /**\n+     * Return true if the node references temporary tables no matter under which schema\n+     *\n+     * @return true if references temporary tables, else false\n+     */\n     @Override\n-\tpublic void acceptChildren(Visitor v) throws StandardException {\n-\t\tsuper.acceptChildren(v);\n+    public boolean referencesTemporaryTable() {\n+        return queryExpression.referencesTemporaryTable();\n+    }\n+\n+    /**\n+     * Create the Constant information that will drive the guts of Execution.\n+     *\n+     * @exception StandardException        Thrown on failure\n+     */\n+    public ConstantAction    makeConstantAction() throws StandardException\n+    {\n+        /* RESOLVE - need to build up dependendencies and store them away through\n+         * the constant action.\n+         */\n+        return    getGenericConstantActionFactory().getCreateViewConstantAction(getSchemaDescriptor().getSchemaName(),\n+                                              getRelativeName(),\n+                                              TableDescriptor.VIEW_TYPE,\n+                                              qeText,\n+                                              checkOption,\n+                                              colInfos,\n+                                              providerInfos,\n+                                              (UUID)null);     // compilation schema, filled\n+                                                            // in when we create the view\n+    }\n+\n+    /**\n+     * Fill in the ColumnInfo[] for this create view.\n+     *\n+     * @param colInfos    The ColumnInfo[] to be filled in.\n+     */\n+    private void genColumnInfos(ColumnInfo[] colInfos)\n+    {\n+        ResultColumnList rcl =     queryExpression.getResultColumns();\n+\n+        for (int index = 0; index < colInfos.length; index++)\n+        {\n+            ResultColumn rc = (ResultColumn) rcl.elementAt(index);\n+            // The colInfo array has been initialized to be of length\n+            // visibleSize() (DERBY-4230).  This code assumes that all the visible\n+            // columns are at the beginning of the rcl. Throw an assertion\n+            // if we hit a generated column in what we think is the visible\n+            // range.\n+            if (SanityManager.DEBUG) {\n+                if (rc.isGenerated)\n+                    SanityManager.THROWASSERT(\"Encountered generated column in expected visible range at rcl[\" + index +\"]\");\n+            }\n+            //RESOLVEAUTOINCREMENT\n+            colInfos[index] = new ColumnInfo(rc.getName(),\n+                                             rc.getType(),\n+                                             null,\n+                                             null,\n+                                             null,\n+                                             null,\n+                                             null,\n+                                             ColumnInfo.CREATE,\n+                                             0, 0, 0,-1);\n+        }\n+    }\n+\n+    /*\n+     * class interface\n+     */\n+\n+    /**\n+      *    Get the parsed query expression (the SELECT statement).\n+      *\n+      *    @return    the parsed query expression.\n+      */\n+    ResultSetNode    getParsedQueryExpression() { return queryExpression; }\n+\n \n-\t\tif (queryExpression != null)\n-\t\t{\n-\t\t\tqueryExpression = (ResultSetNode)queryExpression.accept(v, this);\n-\t\t}\n-\t}\n+    /*\n+     * These methods are used by execution\n+     * to get information for storing into\n+     * the system catalogs.\n+     */\n+\n+\n+    /**\n+     * Accept the visitor for all visitable children of this node.\n+     *\n+     * @param v the visitor\n+     */\n+    @Override\n+    public void acceptChildren(Visitor v) throws StandardException {\n+        super.acceptChildren(v);\n+\n+        if (queryExpression != null)\n+        {\n+            queryExpression = (ResultSetNode)queryExpression.accept(v, this);\n+        }\n+    }\n \n     public OrderByList getOrderByList() {\n         return orderByList;\n@@ -583,71 +592,71 @@ public ValueNode getFetchFirst() {\n     \n     public boolean hasJDBClimitClause() { return hasJDBClimitClause; }\n \n-\tpublic TableDescriptor createDynamicView() throws StandardException {\n-\t\tDataDictionary dd = this.getDataDictionary();\n-\t\tSchemaDescriptor sd  = getObjectName().hasSchema() ?\n-\t\t\t\tthis.getSchemaDescriptor() : dd.getDeclaredGlobalTemporaryTablesSchemaDescriptor();  // SESSION schema\n-\t\tLanguageConnectionContext lcc = this.getLanguageConnectionContext();\n-\t\tTransactionController tc = lcc.getTransactionExecute();\n-\t\tTableDescriptor existingDescriptor = dd.getTableDescriptor(getRelativeName(), sd, tc);\n-\t\tif (existingDescriptor != null) {\n-\t\t\tthrow StandardException.newException(com.splicemachine.db.shared.common.reference.SQLState.LANG_OBJECT_ALREADY_EXISTS_IN_OBJECT,\n-\t\t\t\t\texistingDescriptor.getDescriptorType(),\n-\t\t\t\t\texistingDescriptor.getDescriptorName(),\n-\t\t\t\t\tsd.getDescriptorType(),\n-\t\t\t\t\tsd.getDescriptorName());\n-\t\t}\n-\n-\t\t/* Create a new table descriptor.\n-\t\t * (Pass in row locking, even though meaningless for views.)\n-\t\t */\n-\t\tDataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();\n-\t\tTableDescriptor td = ddg.newTableDescriptor(getRelativeName(),sd,TableDescriptor.WITH_TYPE,TableDescriptor.ROW_LOCK_GRANULARITY,-1,null,null,null,null,null, null,false,false,null);\n-\t\tUUID toid = td.getUUID();\n-\n-\t\t// No Need to add since this will be dynamic!!!\n-//\t\tdd.addDescriptor(td, sd, DataDictionary.SYSTABLES_CATALOG_NUM, false, tc);\n-//\t\ttoid = td.getUUID();\n-\n-\t\t// for each column, stuff system.column\n-\t\tColumnDescriptor[] cdlArray = new ColumnDescriptor[colInfos.length];\n-\t\tint index = 1;\n-\t\tfor (int ix = 0; ix < colInfos.length; ix++) {\n-\t\t\tindex++;\n-\t\t\tColumnDescriptor columnDescriptor = new ColumnDescriptor(\n-\t\t\t\t\tcolInfos[ix].name,\n-\t\t\t\t\tindex,\n-\t\t\t\t\tindex,\n-\t\t\t\t\tcolInfos[ix].dataType,\n-\t\t\t\t\tcolInfos[ix].defaultValue,\n-\t\t\t\t\tcolInfos[ix].defaultInfo,\n-\t\t\t\t\ttd,\n-\t\t\t\t\t(UUID) null,\n-\t\t\t\t\tcolInfos[ix].autoincStart,\n-\t\t\t\t\tcolInfos[ix].autoincInc,\n-\t\t\t\t\tindex\n-\t\t\t);\n-\t\t\tcdlArray[ix] = columnDescriptor;\n-\t\t}\n-\t\t// Do not add to dictionary since it is dynamic!!\n-//\t\tdd.addDescriptorArray(cdlArray, td,DataDictionary.SYSCOLUMNS_CATALOG_NUM, false, tc);\n-\n-\t\t// add columns to the column descriptor list.\n-\t\tColumnDescriptorList cdl = td.getColumnDescriptorList();\n-\t\tCollections.addAll(cdl, cdlArray);\n-\n-\t\tString createViewString;\n-\t\tif (isRecursive)\n-\t\t\tcreateViewString = \"create recursive view \";\n-\t\telse\n-\t\t\tcreateViewString = \"create view \";\n-\n-\t\tViewDescriptor vd = ddg.newViewDescriptor(toid, getRelativeName(), createViewString + getRelativeName() + \" \" + qeText, checkOption, sd.getUUID());\n-\t\ttd.setViewDescriptor(vd);\n-\t\treturn td;\n-\t}\n-\n-\tpublic boolean isRecursive() {\n-    \treturn isRecursive;\n-\t}\n+    public TableDescriptor createDynamicView() throws StandardException {\n+        DataDictionary dd = this.getDataDictionary();\n+        SchemaDescriptor sd  = getObjectName().hasSchema() ?\n+                this.getSchemaDescriptor() : dd.getDeclaredGlobalTemporaryTablesSchemaDescriptor();  // SESSION schema\n+        LanguageConnectionContext lcc = this.getLanguageConnectionContext();\n+        TransactionController tc = lcc.getTransactionExecute();\n+        TableDescriptor existingDescriptor = dd.getTableDescriptor(getRelativeName(), sd, tc);\n+        if (existingDescriptor != null) {\n+            throw StandardException.newException(com.splicemachine.db.shared.common.reference.SQLState.LANG_OBJECT_ALREADY_EXISTS_IN_OBJECT,\n+                    existingDescriptor.getDescriptorType(),\n+                    existingDescriptor.getDescriptorName(),\n+                    sd.getDescriptorType(),\n+                    sd.getDescriptorName());\n+        }\n+\n+        /* Create a new table descriptor.\n+         * (Pass in row locking, even though meaningless for views.)\n+         */\n+        DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();\n+        TableDescriptor td = ddg.newTableDescriptor(getRelativeName(),sd,TableDescriptor.WITH_TYPE,TableDescriptor.ROW_LOCK_GRANULARITY,-1,null,null,null,null,null, null,false,false,null);\n+        UUID toid = td.getUUID();\n+\n+        // No Need to add since this will be dynamic!!!\n+//        dd.addDescriptor(td, sd, DataDictionary.SYSTABLES_CATALOG_NUM, false, tc);\n+//        toid = td.getUUID();\n+\n+        // for each column, stuff system.column\n+        ColumnDescriptor[] cdlArray = new ColumnDescriptor[colInfos.length];\n+        int index = 1;\n+        for (int ix = 0; ix < colInfos.length; ix++) {\n+            index++;\n+            ColumnDescriptor columnDescriptor = new ColumnDescriptor(\n+                    colInfos[ix].name,\n+                    index,\n+                    index,\n+                    colInfos[ix].dataType,\n+                    colInfos[ix].defaultValue,\n+                    colInfos[ix].defaultInfo,\n+                    td,\n+                    (UUID) null,\n+                    colInfos[ix].autoincStart,\n+                    colInfos[ix].autoincInc,\n+                    index\n+            );\n+            cdlArray[ix] = columnDescriptor;\n+        }\n+        // Do not add to dictionary since it is dynamic!!\n+//        dd.addDescriptorArray(cdlArray, td,DataDictionary.SYSCOLUMNS_CATALOG_NUM, false, tc);\n+\n+        // add columns to the column descriptor list.\n+        ColumnDescriptorList cdl = td.getColumnDescriptorList();\n+        Collections.addAll(cdl, cdlArray);\n+\n+        String createViewString;\n+        if (isRecursive)\n+            createViewString = \"create recursive view \";\n+        else\n+            createViewString = \"create view \";\n+\n+        ViewDescriptor vd = ddg.newViewDescriptor(toid, getRelativeName(), createViewString + getRelativeName() + \" \" + qeText, checkOption, sd.getUUID());\n+        td.setViewDescriptor(vd);\n+        return td;\n+    }\n+\n+    public boolean isRecursive() {\n+        return isRecursive;\n+    }\n }"
  },
  {
    "sha": "6f02589c878b9054166c2d1b8c0117003e8ee0d1",
    "filename": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj",
    "status": "modified",
    "additions": 0,
    "deletions": 13,
    "changes": 13,
    "blob_url": "https://github.com/splicemachine/spliceengine/blob/ea2a4ac8da66acce4b12f7eb26b4bb8c851aceb4/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj",
    "raw_url": "https://github.com/splicemachine/spliceengine/raw/ea2a4ac8da66acce4b12f7eb26b4bb8c851aceb4/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj",
    "contents_url": "https://api.github.com/repos/splicemachine/spliceengine/contents/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj?ref=ea2a4ac8da66acce4b12f7eb26b4bb8c851aceb4",
    "patch": "@@ -13119,12 +13119,6 @@ void withClause(Vector parameterList) throws StandardException :\n         {\n             checkOptionType = ViewDescriptor.NO_CHECK_OPTION;\n             endToken = getToken(0);\n-            /* Parameters not allowed in create view */\n-            HasNodeVisitor visitor = new HasNodeVisitor(ParameterNode.class);\n-            queryExpression.accept(visitor);\n-            if (visitor.hasNode()) {\n-                throw StandardException.newException(SQLState.LANG_NO_PARAMS_IN_VIEWS);\n-            }\n             if (topNOut[0] != null) {\n                 hasJDBClimitClause = true;\n                 offsetClauses[ FETCH_FIRST_CLAUSE ] = topNOut[0];\n@@ -13187,13 +13181,6 @@ viewDefinition(Token beginToken) throws StandardException :\n     {\n         checkOptionType = ViewDescriptor.NO_CHECK_OPTION;\n         endToken = getToken(0);\n-        /* Parameters not allowed in create view */\n-        HasNodeVisitor visitor = new HasNodeVisitor(ParameterNode.class);\n-        queryExpression.accept(visitor);\n-        if (visitor.hasNode())\n-        {\n-            throw StandardException.newException(SQLState.LANG_NO_PARAMS_IN_VIEWS);\n-        }\n \n         if (topNOut[0] != null) {\n             hasJDBClimitClause = true;"
  },
  {
    "sha": "38c9510cbf8aeea51014fa73cfa1c1a5f3e141be",
    "filename": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/PreparedStatementIT.java",
    "status": "modified",
    "additions": 16,
    "deletions": 0,
    "changes": 16,
    "blob_url": "https://github.com/splicemachine/spliceengine/blob/ea2a4ac8da66acce4b12f7eb26b4bb8c851aceb4/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/PreparedStatementIT.java",
    "raw_url": "https://github.com/splicemachine/spliceengine/raw/ea2a4ac8da66acce4b12f7eb26b4bb8c851aceb4/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/PreparedStatementIT.java",
    "contents_url": "https://api.github.com/repos/splicemachine/spliceengine/contents/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/PreparedStatementIT.java?ref=ea2a4ac8da66acce4b12f7eb26b4bb8c851aceb4",
    "patch": "@@ -652,4 +652,20 @@ public void testConcatUnknownParameters() throws Exception {\n                         \"------\\n\" +\n                         \"true |\");\n     }\n+\n+    @Test\n+    public void testParameterInWithClause() throws Exception {\n+        testOneParamHelper(\n+                \"with cte as (select n from sys.sysnaturalnumbers where n = ?) select * from sys.sysnaturalnumbers where N = (select n from cte)\",\n+                42,\n+                \"N |\\n\" +\n+                        \"----\\n\" +\n+                        \"42 |\");\n+        testOneParamHelper(\n+                \"with cte as (select ? + 4 as L) select * from cte\",\n+                42,\n+                \"L |\\n\" +\n+                        \"----\\n\" +\n+                        \"46 |\");\n+    }\n }"
  }
]
