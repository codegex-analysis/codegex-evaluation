[
  {
    "sha": "2f8dac82a55abcc000538edce8581e7885870697",
    "filename": "debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/MySqlConnectorConfig.java",
    "status": "modified",
    "additions": 11,
    "deletions": 0,
    "changes": 11,
    "blob_url": "https://github.com/debezium/debezium/blob/d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/MySqlConnectorConfig.java",
    "raw_url": "https://github.com/debezium/debezium/raw/d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/MySqlConnectorConfig.java",
    "contents_url": "https://api.github.com/repos/debezium/debezium/contents/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/MySqlConnectorConfig.java?ref=d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413",
    "patch": "@@ -809,6 +809,17 @@ public static GtidNewChannelPosition parse(String value, String defaultValue) {\n                     + DatabaseHistory.CONFIGURATION_FIELD_PREFIX_STRING + \"' string.\")\n             .withDefault(KafkaDatabaseHistory.class.getName());\n \n+    public static final Field USE_CURSOR_FETCH = Field.create(\"useCursorFetch\")\n+            .withDisplayName(\"Use Cursor Fetch\")\n+            .withType(Type.BOOLEAN)\n+            .withWidth(Width.SHORT)\n+            .withImportance(Importance.LOW)\n+            .withDefault(false)\n+            .withValidation(Field::isBoolean)\n+            .withDescription(\"Another alternative is to use cursor-based streaming to retrieve a set number of rows each time. \" +\n+                    \"This can be done by setting the connection property useCursorFetch to true, \" +\n+                    \"and then calling setFetchSize(int) with int being the desired number of rows to be fetched each time\");\n+\n     public static final Field INCLUDE_SQL_QUERY = Field.create(\"include.query\")\n             .withDisplayName(\"Include original SQL query with in change events\")\n             .withType(Type.BOOLEAN)"
  },
  {
    "sha": "a656f7cbc82e9cab06c9c5f479b489c2790685c3",
    "filename": "debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/AbstractMysqlFieldReader.java",
    "status": "added",
    "additions": 61,
    "deletions": 0,
    "changes": 61,
    "blob_url": "https://github.com/debezium/debezium/blob/d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/AbstractMysqlFieldReader.java",
    "raw_url": "https://github.com/debezium/debezium/raw/d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/AbstractMysqlFieldReader.java",
    "contents_url": "https://api.github.com/repos/debezium/debezium/contents/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/AbstractMysqlFieldReader.java?ref=d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413",
    "patch": "@@ -0,0 +1,61 @@\n+package io.debezium.connector.mysql.legacy;\n+\n+import io.debezium.relational.Column;\n+import io.debezium.relational.Table;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+/**\n+ * Abstract class for decode MySQL return value according to different protocols.\n+ *\n+ * @author yangjie\n+ */\n+public abstract class AbstractMysqlFieldReader implements MysqlFieldReader {\n+\n+    protected final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    @Override\n+    public Object readField(ResultSet rs, int fieldNo, Column actualColumn, Table actualTable) throws SQLException {\n+        if (actualColumn.jdbcType() == Types.TIME) {\n+            return readTimeField(rs, fieldNo);\n+        }\n+        else if (actualColumn.jdbcType() == Types.DATE) {\n+            return readDateField(rs, fieldNo, actualColumn, actualTable);\n+        }\n+        // This is for DATETIME columns (a logical date + time without time zone)\n+        // by reading them with a calendar based on the default time zone, we make sure that the value\n+        // is constructed correctly using the database's (or connection's) time zone\n+        else if (actualColumn.jdbcType() == Types.TIMESTAMP) {\n+            return readTimestampField(rs, fieldNo, actualColumn, actualTable);\n+        }\n+        // JDBC's rs.GetObject() will return a Boolean for all TINYINT(1) columns.\n+        // TINYINT columns are reprtoed as SMALLINT by JDBC driver\n+        else if (actualColumn.jdbcType() == Types.TINYINT || actualColumn.jdbcType() == Types.SMALLINT) {\n+            // It seems that rs.wasNull() returns false when default value is set and NULL is inserted\n+            // We thus need to use getObject() to identify if the value was provided and if yes then\n+            // read it again to get correct scale\n+            return rs.getObject(fieldNo) == null ? null : rs.getInt(fieldNo);\n+        }\n+        // DBZ-2673\n+        // It is necessary to check the type names as types like ENUM and SET are\n+        // also reported as JDBC type char\n+        else if (\"CHAR\".equals(actualColumn.typeName()) ||\n+                \"VARCHAR\".equals(actualColumn.typeName()) ||\n+                \"TEXT\".equals(actualColumn.typeName())) {\n+            return rs.getBytes(fieldNo);\n+        }\n+        else {\n+            return rs.getObject(fieldNo);\n+        }\n+    }\n+\n+    protected abstract Object readTimeField(ResultSet rs, int fieldNo) throws SQLException;\n+\n+    protected abstract Object readDateField(ResultSet rs, int fieldNo, Column column, Table table) throws SQLException;\n+\n+    protected abstract Object readTimestampField(ResultSet rs, int fieldNo, Column column, Table table) throws SQLException;\n+}"
  },
  {
    "sha": "3334b062e3372ee71e853638060704cbdfea6e36",
    "filename": "debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MySqlJdbcContext.java",
    "status": "modified",
    "additions": 16,
    "deletions": 1,
    "changes": 17,
    "blob_url": "https://github.com/debezium/debezium/blob/d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MySqlJdbcContext.java",
    "raw_url": "https://github.com/debezium/debezium/raw/d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MySqlJdbcContext.java",
    "contents_url": "https://api.github.com/repos/debezium/debezium/contents/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MySqlJdbcContext.java?ref=d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413",
    "patch": "@@ -11,6 +11,7 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n \n@@ -33,14 +34,17 @@\n import io.debezium.relational.history.DatabaseHistory;\n import io.debezium.util.Strings;\n \n+import static io.debezium.config.CommonConnectorConfig.SNAPSHOT_FETCH_SIZE;\n+import static io.debezium.connector.mysql.MySqlConnectorConfig.USE_CURSOR_FETCH;\n+\n /**\n  * A context for a JDBC connection to MySQL.\n  *\n  * @author Randall Hauch\n  */\n public class MySqlJdbcContext implements AutoCloseable {\n \n-    protected static final String MYSQL_CONNECTION_URL = \"jdbc:mysql://${hostname}:${port}/?useInformationSchema=true&nullCatalogMeansCurrent=false&useSSL=${useSSL}&useUnicode=true&characterEncoding=UTF-8&characterSetResults=UTF-8&zeroDateTimeBehavior=CONVERT_TO_NULL&connectTimeout=${connectTimeout}\";\n+    protected static final String MYSQL_CONNECTION_URL = \"jdbc:mysql://${hostname}:${port}/?useInformationSchema=true&nullCatalogMeansCurrent=false&useSSL=${useSSL}&useUnicode=true&characterEncoding=UTF-8&characterSetResults=UTF-8&zeroDateTimeBehavior=CONVERT_TO_NULL&connectTimeout=${connectTimeout}&useCursorFetch=${useCursorFetch}\";\n     protected static final String JDBC_PROPERTY_LEGACY_DATETIME = \"useLegacyDatetimeCode\";\n \n     private static final String SQL_SHOW_SYSTEM_VARIABLES = \"SHOW VARIABLES\";\n@@ -54,9 +58,14 @@\n     protected final Configuration config;\n     protected final JdbcConnection jdbc;\n     private final Map<String, String> originalSystemProperties = new HashMap<>();\n+    private final boolean useCursorFetch;\n \n     public MySqlJdbcContext(MySqlConnectorConfig config) {\n         this.config = config.getConfig(); // must be set before most methods are used\n+        final String fetchSizeStr = this.config.getString(SNAPSHOT_FETCH_SIZE);\n+        // DBZ-3238: automatically set \"useCursorFetch\" to true when a snapshot fetch size other than the default of -1 is given\n+        // there is no need to catch the exception of Integer.parseInt() here, because it has been done in BaseSourceTask\n+        this.useCursorFetch = Objects.nonNull(fetchSizeStr) && Integer.parseInt(fetchSizeStr) > 0;\n \n         // Set up the JDBC connection without actually connecting, with extra MySQL-specific properties\n         // to give us better JDBC database metadata behavior, including using UTF-8 for the client-side character encoding\n@@ -82,12 +91,18 @@ else if (\"true\".equals(legacyDateTime)) {\n             logger.warn(\"'{}' is set to 'true'. This setting is not recommended and can result in timezone issues.\", JDBC_PROPERTY_LEGACY_DATETIME);\n         }\n \n+        jdbcConfigBuilder.with(USE_CURSOR_FETCH, this.useCursorFetch ? Boolean.TRUE.toString() : Boolean.FALSE.toString());\n+\n         jdbcConfig = jdbcConfigBuilder.build();\n         String driverClassName = jdbcConfig.getString(MySqlConnectorConfig.JDBC_DRIVER);\n         this.jdbc = new JdbcConnection(jdbcConfig,\n                 JdbcConnection.patternBasedFactory(MYSQL_CONNECTION_URL, driverClassName, getClass().getClassLoader()));\n     }\n \n+    public boolean useCursorFetch() {\n+        return this.useCursorFetch;\n+    }\n+\n     public Configuration config() {\n         return config;\n     }"
  },
  {
    "sha": "85f517a02ff777c8243535ca29abbe7fd1bcbd5a",
    "filename": "debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MysqlBinaryProtocolFieldReader.java",
    "status": "added",
    "additions": 105,
    "deletions": 0,
    "changes": 105,
    "blob_url": "https://github.com/debezium/debezium/blob/d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MysqlBinaryProtocolFieldReader.java",
    "raw_url": "https://github.com/debezium/debezium/raw/d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MysqlBinaryProtocolFieldReader.java",
    "contents_url": "https://api.github.com/repos/debezium/debezium/contents/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MysqlBinaryProtocolFieldReader.java?ref=d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413",
    "patch": "@@ -0,0 +1,105 @@\n+package io.debezium.connector.mysql.legacy;\n+\n+import com.mysql.cj.protocol.a.NativeConstants;\n+import io.debezium.connector.mysql.MySqlValueConverters;\n+import io.debezium.relational.Column;\n+import io.debezium.relational.Table;\n+\n+import java.sql.Blob;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Calendar;\n+\n+/**\n+ * Decode binary protocol value for MySQL.\n+ *\n+ * Consult <a href=\"https://dev.mysql.com/doc/internals/en/binary-protocol-value.html\">Binary Protocol Value</a> if you want to learn more about this.\n+ *\n+ * @author yangjie\n+ */\n+public class MysqlBinaryProtocolFieldReader extends AbstractMysqlFieldReader {\n+\n+    /**\n+     * @see <a href=\"https://dev.mysql.com/doc/internals/en/binary-protocol-value.html#packet-ProtocolBinary::MYSQL_TYPE_TIME\">ProtocolBinary::MYSQL_TYPE_TIME</a>\n+     */\n+    @Override\n+    protected Object readTimeField(ResultSet rs, int fieldNo) throws SQLException {\n+        Blob b = rs.getBlob(fieldNo);\n+        if (b == null) {\n+            return null; // Don't continue parsing time field if it is null\n+        }\n+        // if micro_seconds is 0, length is 8; otherwise length is 12\n+        if (b.length() != NativeConstants.BIN_LEN_TIME_NO_FRAC && b.length() != NativeConstants.BIN_LEN_TIME_WITH_MICROS) {\n+            throw new RuntimeException(String.format(\"Invalid length when read MySQL TIME value. BIN_LEN_TIME is %d\", b.length()));\n+        }\n+\n+        final byte[] bytes = b.getBytes(1, (int) (b.length()));\n+        final int days = (bytes[1] & 0xFF) | ((bytes[2] & 0xFF) << 8) | ((bytes[3] & 0xFF) << 16) | ((bytes[4] & 0xFF) << 24);\n+        final int hours = bytes[5];\n+        final int minutes = bytes[6];\n+        final int seconds = bytes[7];\n+        final int nanos = 1000 * days;\n+        final int finalHours = (bytes[0] == 1 ? days * -1 : days) * 24 + hours;\n+\n+        return MySqlValueConverters.stringToDuration(String.format(\"%d:%d:%d.%d\", finalHours, minutes, seconds, nanos));\n+    }\n+\n+    /**\n+     * @see <a href=\"https://dev.mysql.com/doc/internals/en/binary-protocol-value.html#packet-ProtocolBinary::MYSQL_TYPE_DATE\">ProtocolBinary::MYSQL_TYPE_DATE</a>\n+     */\n+    @Override\n+    protected Object readDateField(ResultSet rs, int fieldNo, Column column, Table table) throws SQLException {\n+        Blob b = rs.getBlob(fieldNo);\n+        if (b == null) {\n+            return null; // Don't continue parsing date field if it is null\n+        }\n+        // length is 4\n+        if (b.length() != NativeConstants.BIN_LEN_DATE) {\n+            throw new RuntimeException(String.format(\"Invalid length when read MySQL DATE value. BIN_LEN_DATE is %d\", b.length()));\n+        }\n+\n+        final byte[] bytes = b.getBytes(1L, (int) b.length());\n+        final int year = (bytes[0] & 0xFF) | ((bytes[1] & 0xFF) << 8);\n+        final int month = bytes[2];\n+        final int day = bytes[3];\n+\n+        return MySqlValueConverters.stringToLocalDate(String.format(\"%d-%d-%d\", year, month, day), column, table);\n+    }\n+\n+    /**\n+     * @see <a href=\"https://dev.mysql.com/doc/internals/en/binary-protocol-value.html#packet-ProtocolBinary::MYSQL_TYPE_DATETIME\">ProtocolBinary::MYSQL_TYPE_DATETIME</a>\n+     */\n+    @Override\n+    protected Object readTimestampField(ResultSet rs, int fieldNo, Column column, Table table) throws SQLException {\n+        Blob b = rs.getBlob(fieldNo);\n+        if (b == null) {\n+            return null; // Don't continue parsing timestamp field if it is null\n+        }\n+        // if hour, minutes, seconds and micro_seconds are all 0, length is 4; if micro_seconds is 0, length is 7; otherwise length is 11\n+        if (b.length() != NativeConstants.BIN_LEN_DATE && b.length() != NativeConstants.BIN_LEN_TIMESTAMP_NO_FRAC\n+                && b.length() != NativeConstants.BIN_LEN_TIMESTAMP_WITH_MICROS) {\n+            throw new RuntimeException(String.format(\"Invalid length when read MySQL DATETIME value. BIN_LEN_DATETIME is %d\", b.length()));\n+        }\n+\n+        final byte[] bytes = b.getBytes(1, (int) (b.length()));\n+        final int year = (bytes[0] & 0xFF) | ((bytes[1] & 0xFF) << 8);\n+        final int month = bytes[2];\n+        final int day = bytes[3];\n+        int hours = 0;\n+        int minutes = 0;\n+        int seconds = 0;\n+        int nanos = 0;\n+        if (bytes.length > NativeConstants.BIN_LEN_DATE) {\n+            hours = bytes[4];\n+            minutes = bytes[5];\n+            seconds = bytes[6];\n+        }\n+        if (bytes.length > NativeConstants.BIN_LEN_TIMESTAMP_NO_FRAC) {\n+            nanos = 1000 * ((bytes[7] & 0xFF) | ((bytes[8] & 0xFF) << 8) | ((bytes[9] & 0xFF) << 16) | ((bytes[10] & 0xFF) << 24));\n+        }\n+\n+        return MySqlValueConverters.containsZeroValuesInDatePart(String.format(\"%d-%d-%d %d:%d:%d.%d\", year, month, day, hours, minutes, seconds, nanos), column, table) ?\n+                null :\n+                rs.getTimestamp(fieldNo, Calendar.getInstance());\n+    }\n+}"
  },
  {
    "sha": "3670e80b882d1d003ea89aaccc9d62058d97864d",
    "filename": "debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MysqlFieldReader.java",
    "status": "added",
    "additions": 27,
    "deletions": 0,
    "changes": 27,
    "blob_url": "https://github.com/debezium/debezium/blob/d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MysqlFieldReader.java",
    "raw_url": "https://github.com/debezium/debezium/raw/d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MysqlFieldReader.java",
    "contents_url": "https://api.github.com/repos/debezium/debezium/contents/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MysqlFieldReader.java?ref=d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413",
    "patch": "@@ -0,0 +1,27 @@\n+package io.debezium.connector.mysql.legacy;\n+\n+import io.debezium.relational.Column;\n+import io.debezium.relational.Table;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+/**\n+ * Decode MySQL return value according to different protocols.\n+ *\n+ * Normally, MySQL uses \"Text protocol\" to return a value. When set `useCursorFetch=true`,\n+ * `useServerPrepStmts` is consequently also set to `true`, setting `useServerPrepStmts=true`\n+ * internally causes the MySQL protocol to change from \"Text protocol\" to \"Binary Protocol\".\n+ *\n+ * @see MysqlBinaryProtocolFieldReader\n+ * @see MysqlTextProtocolFieldReader\n+ * @see <a href=\"https://issues.redhat.com/browse/DBZ-3238\">DBZ-3238</a>\n+ * @author yangjie\n+ */\n+public interface MysqlFieldReader {\n+\n+    /**\n+     * read field from ResultSet according to different protocols\n+     */\n+    Object readField(ResultSet rs, int fieldNo, Column actualColumn, Table actualTable) throws SQLException;\n+}"
  },
  {
    "sha": "0f919381f51ce9bace1e8f8322eb394dc30600c6",
    "filename": "debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MysqlTextProtocolFieldReader.java",
    "status": "added",
    "additions": 81,
    "deletions": 0,
    "changes": 81,
    "blob_url": "https://github.com/debezium/debezium/blob/d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MysqlTextProtocolFieldReader.java",
    "raw_url": "https://github.com/debezium/debezium/raw/d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MysqlTextProtocolFieldReader.java",
    "contents_url": "https://api.github.com/repos/debezium/debezium/contents/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/MysqlTextProtocolFieldReader.java?ref=d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413",
    "patch": "@@ -0,0 +1,81 @@\n+package io.debezium.connector.mysql.legacy;\n+\n+import io.debezium.connector.mysql.MySqlValueConverters;\n+import io.debezium.relational.Column;\n+import io.debezium.relational.Table;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.sql.Blob;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Calendar;\n+\n+/**\n+ * Decode text protocol value for MySQL.\n+ *\n+ * @author yangjie\n+ */\n+public class MysqlTextProtocolFieldReader extends AbstractMysqlFieldReader {\n+\n+    /**\n+     * As MySQL connector/J implementation is broken for MySQL type \"TIME\" we have to use a binary-ish workaround\n+     *\n+     * @see https://issues.jboss.org/browse/DBZ-342\n+     */\n+    @Override\n+    protected Object readTimeField(ResultSet rs, int fieldNo) throws SQLException {\n+        Blob b = rs.getBlob(fieldNo);\n+        if (b == null) {\n+            return null; // Don't continue parsing time field if it is null\n+        }\n+\n+        try {\n+            return MySqlValueConverters.stringToDuration(new String(b.getBytes(1, (int) (b.length())), \"UTF-8\"));\n+        }\n+        catch (UnsupportedEncodingException e) {\n+            logger.error(\"Could not read MySQL TIME value as UTF-8\");\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * In non-string mode the date field can contain zero in any of the date part which we need to handle as all-zero\n+     *\n+     */\n+    @Override\n+    protected Object readDateField(ResultSet rs, int fieldNo, Column column, Table table) throws SQLException {\n+        Blob b = rs.getBlob(fieldNo);\n+        if (b == null) {\n+            return null; // Don't continue parsing date field if it is null\n+        }\n+\n+        try {\n+            return MySqlValueConverters.stringToLocalDate(new String(b.getBytes(1, (int) (b.length())), \"UTF-8\"), column, table);\n+        }\n+        catch (UnsupportedEncodingException e) {\n+            logger.error(\"Could not read MySQL DATE value as UTF-8\");\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * In non-string mode the time field can contain zero in any of the date part which we need to handle as all-zero\n+     *\n+     */\n+    @Override\n+    protected Object readTimestampField(ResultSet rs, int fieldNo, Column column, Table table) throws SQLException {\n+        Blob b = rs.getBlob(fieldNo);\n+        if (b == null) {\n+            return null; // Don't continue parsing timestamp field if it is null\n+        }\n+\n+        try {\n+            return MySqlValueConverters.containsZeroValuesInDatePart((new String(b.getBytes(1, (int) (b.length())), \"UTF-8\")), column, table) ? null\n+                    : rs.getTimestamp(fieldNo, Calendar.getInstance());\n+        }\n+        catch (UnsupportedEncodingException e) {\n+            logger.error(\"Could not read MySQL DATETIME value as UTF-8\");\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}"
  },
  {
    "sha": "27977d1806ed5cddc6fc506ede875db3a4264f61",
    "filename": "debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/SnapshotReader.java",
    "status": "modified",
    "additions": 5,
    "deletions": 101,
    "changes": 106,
    "blob_url": "https://github.com/debezium/debezium/blob/d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/SnapshotReader.java",
    "raw_url": "https://github.com/debezium/debezium/raw/d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/SnapshotReader.java",
    "contents_url": "https://api.github.com/repos/debezium/debezium/contents/debezium-connector-mysql/src/main/java/io/debezium/connector/mysql/legacy/SnapshotReader.java?ref=d334ee1b4ab423e41c6eb2fff9dbb9da7b06b413",
    "patch": "@@ -5,17 +5,13 @@\n  */\n package io.debezium.connector.mysql.legacy;\n \n-import java.io.UnsupportedEncodingException;\n-import java.sql.Blob;\n import java.sql.Connection;\n import java.sql.ResultSet;\n import java.sql.SQLException;\n import java.sql.Statement;\n-import java.sql.Types;\n import java.time.Instant;\n import java.time.temporal.ChronoUnit;\n import java.util.ArrayList;\n-import java.util.Calendar;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.HashMap;\n@@ -40,7 +36,6 @@\n import io.debezium.connector.SnapshotRecord;\n import io.debezium.connector.mysql.MySqlConnector;\n import io.debezium.connector.mysql.MySqlConnectorConfig;\n-import io.debezium.connector.mysql.MySqlValueConverters;\n import io.debezium.connector.mysql.legacy.MySqlJdbcContext.DatabaseLocales;\n import io.debezium.connector.mysql.legacy.RecordMakers.RecordsForTable;\n import io.debezium.data.Envelope;\n@@ -68,6 +63,7 @@\n     private final SnapshotReaderMetrics metrics;\n     private ExecutorService executorService;\n     private final boolean useGlobalLock;\n+    private final MysqlFieldReader mysqlFieldReader;\n \n     private final MySqlConnectorConfig.SnapshotLockingMode snapshotLockingMode;\n \n@@ -97,6 +93,7 @@ public SnapshotReader(String name, MySqlTaskContext context) {\n         recorder = this::recordRowAsRead;\n         metrics = new SnapshotReaderMetrics(context, context.dbSchema(), changeEventQueueMetrics);\n         this.useGlobalLock = useGlobalLock;\n+        this.mysqlFieldReader = context.getConnectionContext().useCursorFetch() ? new MysqlBinaryProtocolFieldReader() : new MysqlTextProtocolFieldReader();\n     }\n \n     /**\n@@ -143,99 +140,6 @@ protected void doCleanup() {\n         logger.debug(\"Completed writing all snapshot records\");\n     }\n \n-    protected Object readField(ResultSet rs, int fieldNo, Column actualColumn, Table actualTable) throws SQLException {\n-        if (actualColumn.jdbcType() == Types.TIME) {\n-            return readTimeField(rs, fieldNo);\n-        }\n-        else if (actualColumn.jdbcType() == Types.DATE) {\n-            return readDateField(rs, fieldNo, actualColumn, actualTable);\n-        }\n-        // This is for DATETIME columns (a logical date + time without time zone)\n-        // by reading them with a calendar based on the default time zone, we make sure that the value\n-        // is constructed correctly using the database's (or connection's) time zone\n-        else if (actualColumn.jdbcType() == Types.TIMESTAMP) {\n-            return readTimestampField(rs, fieldNo, actualColumn, actualTable);\n-        }\n-        // JDBC's rs.GetObject() will return a Boolean for all TINYINT(1) columns.\n-        // TINYINT columns are reprtoed as SMALLINT by JDBC driver\n-        else if (actualColumn.jdbcType() == Types.TINYINT || actualColumn.jdbcType() == Types.SMALLINT) {\n-            // It seems that rs.wasNull() returns false when default value is set and NULL is inserted\n-            // We thus need to use getObject() to identify if the value was provided and if yes then\n-            // read it again to get correct scale\n-            return rs.getObject(fieldNo) == null ? null : rs.getInt(fieldNo);\n-        }\n-        // DBZ-2673\n-        // It is necessary to check the type names as types like ENUM and SET are\n-        // also reported as JDBC type char\n-        else if (\"CHAR\".equals(actualColumn.typeName()) ||\n-                \"VARCHAR\".equals(actualColumn.typeName()) ||\n-                \"TEXT\".equals(actualColumn.typeName())) {\n-            return rs.getBytes(fieldNo);\n-        }\n-        else {\n-            return rs.getObject(fieldNo);\n-        }\n-    }\n-\n-    /**\n-     * As MySQL connector/J implementation is broken for MySQL type \"TIME\" we have to use a binary-ish workaround\n-     *\n-     * @see https://issues.jboss.org/browse/DBZ-342\n-     */\n-    private Object readTimeField(ResultSet rs, int fieldNo) throws SQLException {\n-        Blob b = rs.getBlob(fieldNo);\n-        if (b == null) {\n-            return null; // Don't continue parsing time field if it is null\n-        }\n-\n-        try {\n-            return MySqlValueConverters.stringToDuration(new String(b.getBytes(1, (int) (b.length())), \"UTF-8\"));\n-        }\n-        catch (UnsupportedEncodingException e) {\n-            logger.error(\"Could not read MySQL TIME value as UTF-8\");\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    /**\n-     * In non-string mode the date field can contain zero in any of the date part which we need to handle as all-zero\n-     *\n-     */\n-    private Object readDateField(ResultSet rs, int fieldNo, Column column, Table table) throws SQLException {\n-        Blob b = rs.getBlob(fieldNo);\n-        if (b == null) {\n-            return null; // Don't continue parsing date field if it is null\n-        }\n-\n-        try {\n-            return MySqlValueConverters.stringToLocalDate(new String(b.getBytes(1, (int) (b.length())), \"UTF-8\"), column, table);\n-        }\n-        catch (UnsupportedEncodingException e) {\n-            logger.error(\"Could not read MySQL TIME value as UTF-8\");\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    /**\n-     * In non-string mode the time field can contain zero in any of the date part which we need to handle as all-zero\n-     *\n-     */\n-    private Object readTimestampField(ResultSet rs, int fieldNo, Column column, Table table) throws SQLException {\n-        Blob b = rs.getBlob(fieldNo);\n-        if (b == null) {\n-            return null; // Don't continue parsing timestamp field if it is null\n-        }\n-\n-        try {\n-            return MySqlValueConverters.containsZeroValuesInDatePart((new String(b.getBytes(1, (int) (b.length())), \"UTF-8\")), column, table) ? null\n-                    : rs.getTimestamp(fieldNo, Calendar.getInstance());\n-        }\n-        catch (UnsupportedEncodingException e) {\n-            logger.error(\"Could not read MySQL TIME value as UTF-8\");\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n     /**\n      * Perform the snapshot using the same logic as the \"mysqldump\" utility.\n      */\n@@ -666,7 +570,7 @@ protected void execute() {\n                                         while (rs.next()) {\n                                             for (int i = 0, j = 1; i != numColumns; ++i, ++j) {\n                                                 Column actualColumn = table.columns().get(i);\n-                                                row[i] = readField(rs, j, actualColumn, table);\n+                                                row[i] = mysqlFieldReader.readField(rs, j, actualColumn, table);\n                                             }\n                                             recorder.recordRow(recordMaker, row, clock.currentTimeAsInstant()); // has no row number!\n                                             rowNum.incrementAndGet();\n@@ -1016,8 +920,8 @@ private void logRolesForCurrentUser(JdbcConnection mysql) {\n             });\n             if (grants.isEmpty()) {\n                 logger.warn(\"Snapshot is using user '{}' but it likely doesn't have proper privileges. \" +\n-                        \"If tables are missing or are empty, ensure connector is configured with the correct MySQL user \" +\n-                        \"and/or ensure that the MySQL user has the required privileges.\",\n+                                \"If tables are missing or are empty, ensure connector is configured with the correct MySQL user \" +\n+                                \"and/or ensure that the MySQL user has the required privileges.\",\n                         mysql.username());\n             }\n             else {"
  }
]
