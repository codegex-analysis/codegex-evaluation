[
  {
    "sha": "290107bd842196529dceabacb0f1d871127f274c",
    "filename": "compiler/rt/libcore/crypto/src/main/java/org/conscrypt/NativeCrypto.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/MobiVM/robovm/blob/3c6e25346890489ee9240481e554bd46a7f8e2af/compiler/rt/libcore/crypto/src/main/java/org/conscrypt/NativeCrypto.java",
    "raw_url": "https://github.com/MobiVM/robovm/raw/3c6e25346890489ee9240481e554bd46a7f8e2af/compiler/rt/libcore/crypto/src/main/java/org/conscrypt/NativeCrypto.java",
    "contents_url": "https://api.github.com/repos/MobiVM/robovm/contents/compiler/rt/libcore/crypto/src/main/java/org/conscrypt/NativeCrypto.java?ref=3c6e25346890489ee9240481e554bd46a7f8e2af",
    "patch": "@@ -1015,9 +1015,9 @@ public static native void SSL_set_tlsext_host_name(long sslNativePointer, String\n \n     /**\n      * For clients, sets the list of supported ALPN protocols in wire-format\n-     * (length-prefixed 8-bit strings) on an SSL context.\n+     * (length-prefixed 8-bit strings).\n      */\n-    public static native int SSL_CTX_set_alpn_protos(long sslCtxPointer, byte[] protos);\n+    public static native int SSL_set_alpn_protos(long sslPointer, byte[] protos);\n \n     /**\n      * Returns the selected ALPN protocol. If the server did not select a"
  },
  {
    "sha": "23f7120d719d114f1b6f5e5913ba0a87abf45075",
    "filename": "compiler/rt/libcore/crypto/src/main/java/org/conscrypt/OpenSSLSocketImpl.java",
    "status": "modified",
    "additions": 471,
    "deletions": 182,
    "changes": 653,
    "blob_url": "https://github.com/MobiVM/robovm/blob/3c6e25346890489ee9240481e554bd46a7f8e2af/compiler/rt/libcore/crypto/src/main/java/org/conscrypt/OpenSSLSocketImpl.java",
    "raw_url": "https://github.com/MobiVM/robovm/raw/3c6e25346890489ee9240481e554bd46a7f8e2af/compiler/rt/libcore/crypto/src/main/java/org/conscrypt/OpenSSLSocketImpl.java",
    "contents_url": "https://api.github.com/repos/MobiVM/robovm/contents/compiler/rt/libcore/crypto/src/main/java/org/conscrypt/OpenSSLSocketImpl.java?ref=3c6e25346890489ee9240481e554bd46a7f8e2af",
    "patch": "@@ -39,17 +39,18 @@\n import javax.net.ssl.HandshakeCompletedListener;\n import javax.net.ssl.SSLException;\n import javax.net.ssl.SSLHandshakeException;\n-import javax.net.ssl.SSLPeerUnverifiedException;\n import javax.net.ssl.SSLProtocolException;\n import javax.net.ssl.SSLSession;\n import javax.net.ssl.X509TrustManager;\n import javax.security.auth.x500.X500Principal;\n-import static libcore.io.OsConstants.*;\n import libcore.io.ErrnoException;\n import libcore.io.Libcore;\n import libcore.io.Streams;\n import libcore.io.StructTimeval;\n \n+import static libcore.io.OsConstants.SOL_SOCKET;\n+import static libcore.io.OsConstants.SO_SNDTIMEO;\n+\n /**\n  * Implementation of the class OpenSSLSocketImpl based on OpenSSL.\n  * <p>\n@@ -64,36 +65,100 @@\n         extends javax.net.ssl.SSLSocket\n         implements NativeCrypto.SSLHandshakeCallbacks {\n \n+    private static final boolean DBG_STATE = false;\n+\n+    /**\n+     * Protects handshakeStarted and handshakeCompleted.\n+     */\n+    private final Object stateLock = new Object();\n+\n+    /**\n+     * The {@link OpenSSLSocketImpl} object is constructed, but {@link #startHandshake()}\n+     * has not yet been called.\n+     */\n+    private static final int STATE_NEW = 0;\n+\n+    /**\n+     * {@link #startHandshake()} has been called at least once.\n+     */\n+    private static final int STATE_HANDSHAKE_STARTED = 1;\n+\n+    /**\n+     * {@link #handshakeCompleted()} has been called, but {@link #startHandshake()} hasn't\n+     * returned yet.\n+     */\n+    private static final int STATE_HANDSHAKE_COMPLETED = 2;\n+\n+    /**\n+     * {@link #startHandshake()} has completed but {@link #handshakeCompleted()} hasn't\n+     * been called. This is expected behaviour in cut-through mode, where SSL_do_handshake\n+     * returns before the handshake is complete. We can now start writing data to the socket.\n+     */\n+    private static final int STATE_READY_HANDSHAKE_CUT_THROUGH = 3;\n+\n+    /**\n+     * {@link #startHandshake()} has completed and {@link #handshakeCompleted()} has been\n+     * called.\n+     */\n+    private static final int STATE_READY = 4;\n+\n+    /**\n+     * {@link #close()} has been called at least once.\n+     */\n+    private static final int STATE_CLOSED = 5;\n+\n+    // @GuardedBy(\"stateLock\");\n+    private int state = STATE_NEW;\n+\n+    /**\n+     * Protected by synchronizing on stateLock. Starts as 0, set by\n+     * startHandshake, reset to 0 on close.\n+     */\n+    // @GuardedBy(\"stateLock\");\n     private long sslNativePointer;\n-    private InputStream is;\n-    private OutputStream os;\n-    private final Object handshakeLock = new Object();\n-    private final Object readLock = new Object();\n-    private final Object writeLock = new Object();\n-    private SSLParametersImpl sslParameters;\n-    private byte[] npnProtocols;\n-    private byte[] alpnProtocols;\n+\n+    /**\n+     * Protected by synchronizing on stateLock. Starts as null, set by\n+     * getInputStream.\n+     */\n+    // @GuardedBy(\"stateLock\");\n+    private SSLInputStream is;\n+\n+    /**\n+     * Protected by synchronizing on stateLock. Starts as null, set by\n+     * getInputStream.\n+     */\n+    // @GuardedBy(\"stateLock\");\n+    private SSLOutputStream os;\n+\n+    private final Socket socket;\n+    private final boolean autoClose;\n+    private final String wrappedHost;\n+    private final int wrappedPort;\n+    private final SSLParametersImpl sslParameters;\n+    private final CloseGuard guard = CloseGuard.get();\n+\n     private String[] enabledProtocols;\n     private String[] enabledCipherSuites;\n+    private byte[] npnProtocols;\n+    private byte[] alpnProtocols;\n     private boolean useSessionTickets;\n     private String hostname;\n-    /** Whether the TLS Channel ID extension is enabled. This field is server-side only. */\n+\n+    /**\n+     * Whether the TLS Channel ID extension is enabled. This field is\n+     * server-side only.\n+     */\n     private boolean channelIdEnabled;\n-    /** Private key for the TLS Channel ID extension. This field is client-side only. */\n-    private OpenSSLKey channelIdPrivateKey;\n-    private OpenSSLSessionImpl sslSession;\n-    private final Socket socket;\n-    private boolean autoClose;\n-    private boolean handshakeStarted = false;\n-    private final CloseGuard guard = CloseGuard.get();\n \n     /**\n-     * Not set to true until the update from native that tells us the\n-     * full handshake is complete, since SSL_do_handshake can return\n-     * before the handshake is completely done due to\n-     * handshake_cutthrough support.\n+     * Private key for the TLS Channel ID extension. This field is\n+     * client-side only. Set during startHandshake.\n      */\n-    private boolean handshakeCompleted = false;\n+    private OpenSSLKey channelIdPrivateKey;\n+\n+    /** Set during startHandshake. */\n+    private OpenSSLSessionImpl sslSession;\n \n     private ArrayList<HandshakeCompletedListener> listeners;\n \n@@ -107,33 +172,51 @@\n     private int writeTimeoutMilliseconds = 0;\n \n     private int handshakeTimeoutMilliseconds = -1;  // -1 = same as timeout; 0 = infinite\n-    private String wrappedHost;\n-    private int wrappedPort;\n \n     protected OpenSSLSocketImpl(SSLParametersImpl sslParameters) throws IOException {\n         this.socket = this;\n-        init(sslParameters);\n+        this.wrappedHost = null;\n+        this.wrappedPort = -1;\n+        this.autoClose = false;\n+        this.sslParameters = sslParameters;\n+        this.enabledProtocols = NativeCrypto.getDefaultProtocols();\n+        this.enabledCipherSuites = NativeCrypto.getDefaultCipherSuites();\n     }\n \n     protected OpenSSLSocketImpl(SSLParametersImpl sslParameters,\n                                 String[] enabledProtocols,\n                                 String[] enabledCipherSuites) throws IOException {\n         this.socket = this;\n-        init(sslParameters, enabledProtocols, enabledCipherSuites);\n+        this.wrappedHost = null;\n+        this.wrappedPort = -1;\n+        this.autoClose = false;\n+        this.sslParameters = sslParameters;\n+        this.enabledProtocols = enabledProtocols;\n+        this.enabledCipherSuites = enabledCipherSuites;\n     }\n \n     protected OpenSSLSocketImpl(String host, int port, SSLParametersImpl sslParameters)\n             throws IOException {\n         super(host, port);\n         this.socket = this;\n-        init(sslParameters);\n+        this.wrappedHost = null;\n+        this.wrappedPort = -1;\n+        this.autoClose = false;\n+        this.sslParameters = sslParameters;\n+        this.enabledProtocols = NativeCrypto.getDefaultProtocols();\n+        this.enabledCipherSuites = NativeCrypto.getDefaultCipherSuites();\n     }\n \n     protected OpenSSLSocketImpl(InetAddress address, int port, SSLParametersImpl sslParameters)\n             throws IOException {\n         super(address, port);\n         this.socket = this;\n-        init(sslParameters);\n+        this.wrappedHost = null;\n+        this.wrappedPort = -1;\n+        this.autoClose = false;\n+        this.sslParameters = sslParameters;\n+        this.enabledProtocols = NativeCrypto.getDefaultProtocols();\n+        this.enabledCipherSuites = NativeCrypto.getDefaultCipherSuites();\n     }\n \n \n@@ -142,56 +225,46 @@ protected OpenSSLSocketImpl(String host, int port,\n                                 SSLParametersImpl sslParameters) throws IOException {\n         super(host, port, clientAddress, clientPort);\n         this.socket = this;\n-        init(sslParameters);\n+        this.wrappedHost = null;\n+        this.wrappedPort = -1;\n+        this.autoClose = false;\n+        this.sslParameters = sslParameters;\n+        this.enabledProtocols = NativeCrypto.getDefaultProtocols();\n+        this.enabledCipherSuites = NativeCrypto.getDefaultCipherSuites();\n     }\n \n     protected OpenSSLSocketImpl(InetAddress address, int port,\n                                 InetAddress clientAddress, int clientPort,\n                                 SSLParametersImpl sslParameters) throws IOException {\n         super(address, port, clientAddress, clientPort);\n         this.socket = this;\n-        init(sslParameters);\n+        this.wrappedHost = null;\n+        this.wrappedPort = -1;\n+        this.autoClose = false;\n+        this.sslParameters = sslParameters;\n+        this.enabledProtocols = NativeCrypto.getDefaultProtocols();\n+        this.enabledCipherSuites = NativeCrypto.getDefaultCipherSuites();\n     }\n \n     /**\n      * Create an SSL socket that wraps another socket. Invoked by\n      * OpenSSLSocketImplWrapper constructor.\n      */\n     protected OpenSSLSocketImpl(Socket socket, String host, int port,\n-            boolean autoClose, SSLParametersImpl sslParameters) throws IOException {\n+                                boolean autoClose, SSLParametersImpl sslParameters) throws IOException {\n         this.socket = socket;\n         this.wrappedHost = host;\n         this.wrappedPort = port;\n         this.autoClose = autoClose;\n-        init(sslParameters);\n+        this.sslParameters = sslParameters;\n+        this.enabledProtocols = NativeCrypto.getDefaultProtocols();\n+        this.enabledCipherSuites = NativeCrypto.getDefaultCipherSuites();\n \n         // this.timeout is not set intentionally.\n         // OpenSSLSocketImplWrapper.getSoTimeout will delegate timeout\n         // to wrapped socket\n     }\n \n-    /**\n-     * Initialize the SSL socket and set the certificates for the\n-     * future handshaking.\n-     */\n-    private void init(SSLParametersImpl sslParameters) throws IOException {\n-        init(sslParameters,\n-             NativeCrypto.getDefaultProtocols(),\n-             NativeCrypto.getDefaultCipherSuites());\n-    }\n-\n-    /**\n-     * Initialize the SSL socket and set the certificates for the\n-     * future handshaking.\n-     */\n-    private void init(SSLParametersImpl sslParameters,\n-                      String[] enabledProtocols,\n-                      String[] enabledCipherSuites) throws IOException {\n-        this.sslParameters = sslParameters;\n-        this.enabledProtocols = enabledProtocols;\n-        this.enabledCipherSuites = enabledCipherSuites;\n-    }\n-\n     /**\n      * Gets the suitable session reference from the session cache container.\n      */\n@@ -246,12 +319,14 @@ private void checkOpen() throws SocketException {\n      * verified if the correspondent property in java.Security is set. All\n      * listeners are notified at the end of the TLS/SSL handshake.\n      */\n-    @Override public synchronized void startHandshake() throws IOException {\n-        synchronized (handshakeLock) {\n-            checkOpen();\n-            if (!handshakeStarted) {\n-                handshakeStarted = true;\n+    @Override public void startHandshake() throws IOException {\n+        checkOpen();\n+        synchronized (stateLock) {\n+            if (state == STATE_NEW) {\n+                state = STATE_HANDSHAKE_STARTED;\n             } else {\n+                // We've either started the handshake already or have been closed.\n+                // Do nothing in both cases.\n                 return;\n             }\n         }\n@@ -268,11 +343,11 @@ private void checkOpen() throws SocketException {\n         final boolean client = sslParameters.getUseClientMode();\n \n         final long sslCtxNativePointer = (client) ?\n-            sslParameters.getClientSessionContext().sslCtxNativePointer :\n-            sslParameters.getServerSessionContext().sslCtxNativePointer;\n+                sslParameters.getClientSessionContext().sslCtxNativePointer :\n+                sslParameters.getServerSessionContext().sslCtxNativePointer;\n \n-        this.sslNativePointer = 0;\n-        boolean exception = true;\n+        sslNativePointer = 0;\n+        boolean releaseResources = true;\n         try {\n             sslNativePointer = NativeCrypto.SSL_new(sslCtxNativePointer);\n             guard.open(\"close\");\n@@ -282,7 +357,7 @@ private void checkOpen() throws SocketException {\n             }\n \n             if (client && alpnProtocols != null) {\n-                NativeCrypto.SSL_CTX_set_alpn_protos(sslCtxNativePointer, alpnProtocols);\n+                NativeCrypto.SSL_set_alpn_protos(sslNativePointer, alpnProtocols);\n             }\n \n             // setup server certificates and private keys.\n@@ -301,8 +376,8 @@ private void checkOpen() throws SocketException {\n                 for (String keyType : keyTypes) {\n                     try {\n                         setCertificate(sslParameters.getKeyManager().chooseServerAlias(keyType,\n-                                                                                       null,\n-                                                                                       this));\n+                                null,\n+                                this));\n                     } catch (CertificateEncodingException e) {\n                         throw new IOException(e);\n                     }\n@@ -321,7 +396,7 @@ private void checkOpen() throws SocketException {\n             boolean enableSessionCreation = sslParameters.getEnableSessionCreation();\n             if (!enableSessionCreation) {\n                 NativeCrypto.SSL_set_session_creation_enabled(sslNativePointer,\n-                                                              enableSessionCreation);\n+                        enableSessionCreation);\n             }\n \n             AbstractSessionContext sessionContext;\n@@ -333,7 +408,7 @@ private void checkOpen() throws SocketException {\n                 sessionToReuse = getCachedClientSession(clientSessionContext);\n                 if (sessionToReuse != null) {\n                     NativeCrypto.SSL_set_session(sslNativePointer,\n-                                                 sessionToReuse.sslSessionNativePointer);\n+                            sessionToReuse.sslSessionNativePointer);\n                 }\n             } else {\n                 sessionContext = sslParameters.getServerSessionContext();\n@@ -349,15 +424,15 @@ private void checkOpen() throws SocketException {\n                 boolean certRequested;\n                 if (sslParameters.getNeedClientAuth()) {\n                     NativeCrypto.SSL_set_verify(sslNativePointer,\n-                                                NativeCrypto.SSL_VERIFY_PEER\n-                                                | NativeCrypto.SSL_VERIFY_FAIL_IF_NO_PEER_CERT);\n+                            NativeCrypto.SSL_VERIFY_PEER\n+                                    | NativeCrypto.SSL_VERIFY_FAIL_IF_NO_PEER_CERT);\n                     certRequested = true;\n-                // ... over just wanting it...\n+                    // ... over just wanting it...\n                 } else if (sslParameters.getWantClientAuth()) {\n                     NativeCrypto.SSL_set_verify(sslNativePointer,\n-                                                NativeCrypto.SSL_VERIFY_PEER);\n+                            NativeCrypto.SSL_VERIFY_PEER);\n                     certRequested = true;\n-                // ... and it defaults properly so don't call SSL_set_verify in the common case.\n+                    // ... and it defaults properly so don't call SSL_set_verify in the common case.\n                 } else {\n                     certRequested = false;\n                 }\n@@ -400,6 +475,12 @@ private void checkOpen() throws SocketException {\n                 }\n             }\n \n+            synchronized (stateLock) {\n+                if (state == STATE_CLOSED) {\n+                    return;\n+                }\n+            }\n+\n             long sslSessionNativePointer;\n             try {\n                 sslSessionNativePointer = NativeCrypto.SSL_do_handshake(sslNativePointer,\n@@ -409,7 +490,32 @@ private void checkOpen() throws SocketException {\n                 SSLHandshakeException wrapper = new SSLHandshakeException(e.getMessage());\n                 wrapper.initCause(e);\n                 throw wrapper;\n+            } catch (SSLException e) {\n+                // Swallow this exception if it's thrown as the result of an interruption.\n+                //\n+                // TODO: SSL_read and SSL_write return -1 when interrupted, but SSL_do_handshake\n+                // will throw the last sslError that it saw before sslSelect, usually SSL_WANT_READ\n+                // (or WANT_WRITE). Catching that exception here doesn't seem much worse than\n+                // changing the native code to return a \"special\" native pointer value when that\n+                // happens.\n+                synchronized (stateLock) {\n+                    if (state == STATE_CLOSED) {\n+                        return;\n+                    }\n+                }\n+\n+                throw e;\n             }\n+\n+            boolean handshakeCompleted = false;\n+            synchronized (stateLock) {\n+                if (state == STATE_HANDSHAKE_COMPLETED) {\n+                    handshakeCompleted = true;\n+                } else if (state == STATE_CLOSED) {\n+                    return;\n+                }\n+            }\n+\n             byte[] sessionId = NativeCrypto.SSL_SESSION_session_id(sslSessionNativePointer);\n             if (sessionToReuse != null && Arrays.equals(sessionToReuse.getId(), sessionId)) {\n                 this.sslSession = sessionToReuse;\n@@ -443,13 +549,41 @@ private void checkOpen() throws SocketException {\n                 notifyHandshakeCompletedListeners();\n             }\n \n-            exception = false;\n+            synchronized (stateLock) {\n+                releaseResources = (state == STATE_CLOSED);\n+\n+                if (state == STATE_HANDSHAKE_STARTED) {\n+                    state = STATE_READY_HANDSHAKE_CUT_THROUGH;\n+                } else if (state == STATE_HANDSHAKE_COMPLETED) {\n+                    state = STATE_READY;\n+                }\n+\n+                if (!releaseResources) {\n+                    // Unblock threads that are waiting for our state to transition\n+                    // into STATE_READY or STATE_READY_HANDSHAKE_CUT_THROUGH.\n+                    stateLock.notifyAll();\n+                }\n+            }\n         } catch (SSLProtocolException e) {\n             throw new SSLHandshakeException(e);\n         } finally {\n             // on exceptional exit, treat the socket as closed\n-            if (exception) {\n-                close();\n+            if (releaseResources) {\n+                synchronized (stateLock) {\n+                    // Mark the socket as closed since we might have reached this as\n+                    // a result on an exception thrown by the handshake process.\n+                    //\n+                    // The state will already be set to closed if we reach this as a result of\n+                    // an early return or an interruption due to a concurrent call to close().\n+                    state = STATE_CLOSED;\n+                    stateLock.notifyAll();\n+                }\n+\n+                try {\n+                    shutdownAndFreeSslNative();\n+                } catch (IOException ignored) {\n+\n+                }\n             }\n         }\n     }\n@@ -546,36 +680,52 @@ public void clientCertificateRequested(byte[] keyTypeBytes, byte[][] asn1DerEnco\n \n     @SuppressWarnings(\"unused\") // used by NativeCrypto.SSLHandshakeCallbacks / info_callback\n     public void handshakeCompleted() {\n-        handshakeCompleted = true;\n-\n-        // If sslSession is null, the handshake was completed during\n-        // the call to NativeCrypto.SSL_do_handshake and not during a\n-        // later read operation. That means we do not need to fix up\n-        // the SSLSession and session cache or notify\n-        // HandshakeCompletedListeners, it will be done in\n-        // startHandshake.\n-        if (sslSession == null) {\n-            return;\n+        synchronized (stateLock) {\n+            if (state == STATE_HANDSHAKE_STARTED) {\n+                // If sslSession is null, the handshake was completed during\n+                // the call to NativeCrypto.SSL_do_handshake and not during a\n+                // later read operation. That means we do not need to fix up\n+                // the SSLSession and session cache or notify\n+                // HandshakeCompletedListeners, it will be done in\n+                // startHandshake.\n+\n+                state = STATE_HANDSHAKE_COMPLETED;\n+                return;\n+            } else if (state == STATE_READY_HANDSHAKE_CUT_THROUGH) {\n+                // We've returned from startHandshake, which means we've set a sslSession etc.\n+                // we need to fix them up, which we'll do outside this lock.\n+            } else if (state == STATE_CLOSED) {\n+                // Someone called \"close\" but the handshake hasn't been interrupted yet.\n+                return;\n+            }\n         }\n \n         // reset session id from the native pointer and update the\n         // appropriate cache.\n         sslSession.resetId();\n         AbstractSessionContext sessionContext =\n-            (sslParameters.getUseClientMode())\n-            ? sslParameters.getClientSessionContext()\n-                : sslParameters.getServerSessionContext();\n+                (sslParameters.getUseClientMode())\n+                        ? sslParameters.getClientSessionContext()\n+                        : sslParameters.getServerSessionContext();\n         sessionContext.putSession(sslSession);\n \n         // let listeners know we are finally done\n         notifyHandshakeCompletedListeners();\n+\n+        synchronized (stateLock) {\n+            // Now that we've fixed up our state, we can tell waiting threads that\n+            // we're ready.\n+            state = STATE_READY;\n+            // Notify all threads waiting for the handshake to complete.\n+            stateLock.notifyAll();\n+        }\n     }\n \n     private void notifyHandshakeCompletedListeners() {\n         if (listeners != null && !listeners.isEmpty()) {\n             // notify the listeners\n             HandshakeCompletedEvent event =\n-                new HandshakeCompletedEvent(this, sslSession);\n+                    new HandshakeCompletedEvent(this, sslSession);\n             for (HandshakeCompletedListener listener : listeners) {\n                 try {\n                     listener.handshakeCompleted(event);\n@@ -615,7 +765,7 @@ private void notifyHandshakeCompletedListeners() {\n             } else {\n                 String authType = peerCertificateChain[0].getPublicKey().getAlgorithm();\n                 sslParameters.getTrustManager().checkClientTrusted(peerCertificateChain,\n-                                                                   authType);\n+                        authType);\n             }\n \n         } catch (CertificateException e) {\n@@ -627,23 +777,80 @@ private void notifyHandshakeCompletedListeners() {\n \n     @Override public InputStream getInputStream() throws IOException {\n         checkOpen();\n-        synchronized (this) {\n+\n+        InputStream returnVal;\n+        synchronized (stateLock) {\n+            if (state == STATE_CLOSED) {\n+                throw new SocketException(\"Socket is closed.\");\n+            }\n+\n             if (is == null) {\n                 is = new SSLInputStream();\n             }\n \n-            return is;\n+            returnVal = is;\n         }\n+\n+        // Block waiting for a handshake without a lock held. It's possible that the socket\n+        // is closed at this point. If that happens, we'll still return the input stream but\n+        // all reads on it will throw.\n+        waitForHandshake();\n+        return returnVal;\n     }\n \n     @Override public OutputStream getOutputStream() throws IOException {\n         checkOpen();\n-        synchronized (this) {\n+\n+        OutputStream returnVal;\n+        synchronized (stateLock) {\n+            if (state == STATE_CLOSED) {\n+                throw new SocketException(\"Socket is closed.\");\n+            }\n+\n             if (os == null) {\n                 os = new SSLOutputStream();\n             }\n \n-            return os;\n+            returnVal = os;\n+        }\n+\n+        // Block waiting for a handshake without a lock held. It's possible that the socket\n+        // is closed at this point. If that happens, we'll still return the output stream but\n+        // all writes on it will throw.\n+        waitForHandshake();\n+        return returnVal;\n+    }\n+\n+    private void assertReadableOrWriteableState() {\n+        if (state == STATE_READY || state == STATE_READY_HANDSHAKE_CUT_THROUGH) {\n+            return;\n+        }\n+\n+        throw new AssertionError(\"Invalid state: \" + state);\n+    }\n+\n+\n+    private void waitForHandshake() throws IOException {\n+        startHandshake();\n+\n+        synchronized (stateLock) {\n+            while (state != STATE_READY &&\n+                    state != STATE_READY_HANDSHAKE_CUT_THROUGH &&\n+                    state != STATE_CLOSED) {\n+                try {\n+                    stateLock.wait();\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    IOException ioe = new IOException(\"Interrupted waiting for handshake\");\n+                    ioe.initCause(e);\n+\n+                    throw ioe;\n+                }\n+            }\n+\n+            if (state == STATE_CLOSED) {\n+                throw new SocketException(\"Socket is closed\");\n+            }\n         }\n     }\n \n@@ -653,20 +860,22 @@ private void notifyHandshakeCompletedListeners() {\n      * read data received via SSL protocol.\n      */\n     private class SSLInputStream extends InputStream {\n-        SSLInputStream() throws IOException {\n-            /*\n-             * Note: When startHandshake() throws an exception, no\n-             * SSLInputStream object will be created.\n-             */\n-            OpenSSLSocketImpl.this.startHandshake();\n+        /**\n+         * OpenSSL only lets one thread read at a time, so this is used to\n+         * make sure we serialize callers of SSL_read. Thread is already\n+         * expected to have completed handshaking.\n+         */\n+        private final Object readLock = new Object();\n+\n+        SSLInputStream() {\n         }\n \n         /**\n          * Reads one byte. If there is no data in the underlying buffer,\n          * this operation can block until the data will be\n          * available.\n          * @return read value.\n-         * @throws <code>IOException</code>\n+         * @throws IOException\n          */\n         @Override\n         public int read() throws IOException {\n@@ -680,16 +889,36 @@ public int read() throws IOException {\n         @Override\n         public int read(byte[] buf, int offset, int byteCount) throws IOException {\n             BlockGuard.getThreadPolicy().onNetwork();\n+\n+            checkOpen();\n+            Arrays.checkOffsetAndCount(buf.length, offset, byteCount);\n+            if (byteCount == 0) {\n+                return 0;\n+            }\n+\n             synchronized (readLock) {\n-                checkOpen();\n-                Arrays.checkOffsetAndCount(buf.length, offset, byteCount);\n-                if (byteCount == 0) {\n-                    return 0;\n+                synchronized (stateLock) {\n+                    if (state == STATE_CLOSED) {\n+                        throw new SocketException(\"socket is closed\");\n+                    }\n+\n+                    if (DBG_STATE) assertReadableOrWriteableState();\n                 }\n+\n                 return NativeCrypto.SSL_read(sslNativePointer, socket.getFileDescriptor$(),\n                         OpenSSLSocketImpl.this, buf, offset, byteCount, getSoTimeout());\n             }\n         }\n+\n+        public void awaitPendingOps() {\n+            if (DBG_STATE) {\n+                synchronized (stateLock) {\n+                    if (state != STATE_CLOSED) throw new AssertionError(\"State is: \" + state);\n+                }\n+            }\n+\n+            synchronized (readLock) { }\n+        }\n     }\n \n     /**\n@@ -698,12 +927,15 @@ public int read(byte[] buf, int offset, int byteCount) throws IOException {\n      * write data according to the encryption parameters given in SSL context.\n      */\n     private class SSLOutputStream extends OutputStream {\n-        SSLOutputStream() throws IOException {\n-            /*\n-             * Note: When startHandshake() throws an exception, no\n-             * SSLOutputStream object will be created.\n-             */\n-            OpenSSLSocketImpl.this.startHandshake();\n+\n+        /**\n+         * OpenSSL only lets one thread write at a time, so this is used\n+         * to make sure we serialize callers of SSL_write. Thread is\n+         * already expected to have completed handshaking.\n+         */\n+        private final Object writeLock = new Object();\n+\n+        SSLOutputStream() {\n         }\n \n         /**\n@@ -722,23 +954,43 @@ public void write(int oneByte) throws IOException {\n         @Override\n         public void write(byte[] buf, int offset, int byteCount) throws IOException {\n             BlockGuard.getThreadPolicy().onNetwork();\n+            checkOpen();\n+            Arrays.checkOffsetAndCount(buf.length, offset, byteCount);\n+            if (byteCount == 0) {\n+                return;\n+            }\n+\n             synchronized (writeLock) {\n-                checkOpen();\n-                Arrays.checkOffsetAndCount(buf.length, offset, byteCount);\n-                if (byteCount == 0) {\n-                    return;\n+                synchronized (stateLock) {\n+                    if (state == STATE_CLOSED) {\n+                        throw new SocketException(\"socket is closed\");\n+                    }\n+\n+                    if (DBG_STATE) assertReadableOrWriteableState();\n                 }\n+\n                 NativeCrypto.SSL_write(sslNativePointer, socket.getFileDescriptor$(),\n                         OpenSSLSocketImpl.this, buf, offset, byteCount, writeTimeoutMilliseconds);\n             }\n         }\n+\n+\n+        public void awaitPendingOps() {\n+            if (DBG_STATE) {\n+                synchronized (stateLock) {\n+                    if (state != STATE_CLOSED) throw new AssertionError(\"State is: \" + state);\n+                }\n+            }\n+\n+            synchronized (writeLock) { }\n+        }\n     }\n \n \n     @Override public SSLSession getSession() {\n         if (sslSession == null) {\n             try {\n-                startHandshake();\n+                waitForHandshake();\n             } catch (IOException e) {\n                 // return an invalid session with\n                 // invalid cipher suite of \"SSL_NULL_WITH_NULL_NULL\"\n@@ -837,10 +1089,13 @@ public void setChannelIdEnabled(boolean enabled) {\n         if (getUseClientMode()) {\n             throw new IllegalStateException(\"Client mode\");\n         }\n-        if (handshakeStarted) {\n-            throw new IllegalStateException(\n-                    \"Could not enable/disable Channel ID after the initial handshake has\"\n-                    + \" begun.\");\n+\n+        synchronized (stateLock) {\n+            if (state != STATE_NEW) {\n+                throw new IllegalStateException(\n+                        \"Could not enable/disable Channel ID after the initial handshake has\"\n+                                + \" begun.\");\n+            }\n         }\n         this.channelIdEnabled = enabled;\n     }\n@@ -859,9 +1114,12 @@ public void setChannelIdEnabled(boolean enabled) {\n         if (getUseClientMode()) {\n             throw new IllegalStateException(\"Client mode\");\n         }\n-        if (!handshakeCompleted) {\n-            throw new IllegalStateException(\n-                    \"Channel ID is only available after handshake completes\");\n+\n+        synchronized (stateLock) {\n+            if (state != STATE_READY) {\n+                throw new IllegalStateException(\n+                        \"Channel ID is only available after handshake completes\");\n+            }\n         }\n         return NativeCrypto.SSL_get_tls_channel_id(sslNativePointer);\n     }\n@@ -882,11 +1140,15 @@ public void setChannelIdPrivateKey(PrivateKey privateKey) {\n         if (!getUseClientMode()) {\n             throw new IllegalStateException(\"Server mode\");\n         }\n-        if (handshakeStarted) {\n-            throw new IllegalStateException(\n-                    \"Could not change Channel ID private key after the initial handshake has\"\n-                    + \" begun.\");\n+\n+        synchronized (stateLock) {\n+            if (state != STATE_NEW) {\n+                throw new IllegalStateException(\n+                        \"Could not change Channel ID private key after the initial handshake has\"\n+                                + \" begun.\");\n+            }\n         }\n+\n         if (privateKey == null) {\n             this.channelIdEnabled = false;\n             this.channelIdPrivateKey = null;\n@@ -905,9 +1167,11 @@ public void setChannelIdPrivateKey(PrivateKey privateKey) {\n     }\n \n     @Override public void setUseClientMode(boolean mode) {\n-        if (handshakeStarted) {\n-            throw new IllegalArgumentException(\n-                    \"Could not change the mode after the initial handshake has begun.\");\n+        synchronized (stateLock) {\n+            if (state != STATE_NEW) {\n+                throw new IllegalArgumentException(\n+                        \"Could not change the mode after the initial handshake has begun.\");\n+            }\n         }\n         sslParameters.setUseClientMode(mode);\n     }\n@@ -977,65 +1241,90 @@ public void setHandshakeTimeout(int handshakeTimeoutMilliseconds) throws SocketE\n     @Override public void close() throws IOException {\n         // TODO: Close SSL sockets using a background thread so they close gracefully.\n \n-        synchronized (handshakeLock) {\n-            if (!handshakeStarted) {\n-                // prevent further attempts to start handshake\n-                handshakeStarted = true;\n+        SSLInputStream sslInputStream = null;\n+        SSLOutputStream sslOutputStream = null;\n \n-                synchronized (this) {\n-                    free();\n+        synchronized (stateLock) {\n+            if (state == STATE_CLOSED) {\n+                // close() has already been called, so do nothing and return.\n+                return;\n+            }\n \n-                    if (socket != this) {\n-                        if (autoClose && !socket.isClosed()) socket.close();\n-                    } else {\n-                        if (!super.isClosed()) super.close();\n-                    }\n-                }\n+            int oldState = state;\n+            state = STATE_CLOSED;\n+\n+            if (oldState == STATE_NEW) {\n+                // The handshake hasn't been started yet, so there's no OpenSSL related\n+                // state to clean up. We still need to close the underlying socket if\n+                // we're wrapping it and were asked to autoClose.\n+                closeUnderlyingSocket();\n \n+                stateLock.notifyAll();\n                 return;\n             }\n-        }\n \n-        synchronized (this) {\n+            if (oldState != STATE_READY && oldState != STATE_READY_HANDSHAKE_CUT_THROUGH) {\n+                // If we're in these states, we still haven't returned from startHandshake.\n+                // We call SSL_interrupt so that we can interrupt SSL_do_handshake and then\n+                // set the state to STATE_CLOSED. startHandshake will handle all cleanup\n+                // after SSL_do_handshake returns, so we don't have anything to do here.\n+                NativeCrypto.SSL_interrupt(sslNativePointer);\n+\n+                stateLock.notifyAll();\n+                return;\n+            }\n \n-            // Interrupt any outstanding reads or writes before taking the writeLock and readLock\n+            stateLock.notifyAll();\n+            // We've already returned from startHandshake, so we potentially have\n+            // input and output streams to clean up.\n+            sslInputStream = is;\n+            sslOutputStream = os;\n+        }\n+\n+        // Don't bother interrupting unless we have something to interrupt.\n+        if (sslInputStream != null || sslOutputStream != null) {\n             NativeCrypto.SSL_interrupt(sslNativePointer);\n+        }\n \n-            synchronized (writeLock) {\n-                synchronized (readLock) {\n-                    // Shut down the SSL connection, per se.\n-                    try {\n-                        if (handshakeStarted) {\n-                            BlockGuard.getThreadPolicy().onNetwork();\n-                            NativeCrypto.SSL_shutdown(sslNativePointer, socket.getFileDescriptor$(),\n-                                    this);\n-                        }\n-                    } catch (IOException ignored) {\n-                        /*\n-                         * Note that although close() can throw\n-                         * IOException, the RI does not throw if there\n-                         * is problem sending a \"close notify\" which\n-                         * can happen if the underlying socket is closed.\n-                         */\n-                    } finally {\n-                        /*\n-                         * Even if the above call failed, it is still safe to free\n-                         * the native structs, and we need to do so lest we leak\n-                         * memory.\n-                         */\n-                        free();\n-\n-                        if (socket != this) {\n-                            if (autoClose && !socket.isClosed()) {\n-                                socket.close();\n-                            }\n-                        } else {\n-                            if (!super.isClosed()) {\n-                                super.close();\n-                            }\n-                        }\n-                    }\n-                }\n+        // Wait for the input and output streams to finish any reads they have in\n+        // progress. If there are no reads in progress at this point, future reads will\n+        // throw because state == STATE_CLOSED\n+        if (sslInputStream != null) {\n+            sslInputStream.awaitPendingOps();\n+        }\n+        if (sslOutputStream != null) {\n+            sslOutputStream.awaitPendingOps();\n+        }\n+\n+        shutdownAndFreeSslNative();\n+    }\n+\n+    private void shutdownAndFreeSslNative() throws IOException {\n+        try {\n+            BlockGuard.getThreadPolicy().onNetwork();\n+            NativeCrypto.SSL_shutdown(sslNativePointer, socket.getFileDescriptor$(),\n+                    this);\n+        } catch (IOException ignored) {\n+            /*\n+             * Note that although close() can throw\n+             * IOException, the RI does not throw if there\n+             * is problem sending a \"close notify\" which\n+             * can happen if the underlying socket is closed.\n+             */\n+        } finally {\n+            free();\n+            closeUnderlyingSocket();\n+        }\n+    }\n+\n+    private void closeUnderlyingSocket() throws IOException {\n+        if (socket != this) {\n+            if (autoClose && !socket.isClosed()) {\n+                socket.close();\n+            }\n+        } else {\n+            if (!super.isClosed()) {\n+                super.close();\n             }\n         }\n     }"
  },
  {
    "sha": "c9bbaf265e02449359594dafbcb062be1f691447",
    "filename": "compiler/vm/rt/android/external/openssl/ssl/t1_lib.c",
    "status": "modified",
    "additions": 16,
    "deletions": 9,
    "changes": 25,
    "blob_url": "https://github.com/MobiVM/robovm/blob/3c6e25346890489ee9240481e554bd46a7f8e2af/compiler/vm/rt/android/external/openssl/ssl/t1_lib.c",
    "raw_url": "https://github.com/MobiVM/robovm/raw/3c6e25346890489ee9240481e554bd46a7f8e2af/compiler/vm/rt/android/external/openssl/ssl/t1_lib.c",
    "contents_url": "https://api.github.com/repos/MobiVM/robovm/contents/compiler/vm/rt/android/external/openssl/ssl/t1_lib.c?ref=3c6e25346890489ee9240481e554bd46a7f8e2af",
    "patch": "@@ -1592,15 +1592,22 @@ int ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, in\n \t\t\t\t*al = TLS1_AD_DECODE_ERROR;\n \t\t\t\treturn 0;\n \t\t\t\t}\n-\t\t\ts->session->tlsext_ecpointformatlist_length = 0;\n-\t\t\tif (s->session->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->session->tlsext_ecpointformatlist);\n-\t\t\tif ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)\n-\t\t\t\t{\n-\t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;\n-\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\ts->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;\n-\t\t\tmemcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);\n+\t\t\tif (!s->hit)\n+ \t\t\t\t{\n+\t\t\t\tif(s->session->tlsext_ecpointformatlist)\n+\t\t\t\t\t{\n+\t\t\t\t\tOPENSSL_free(s->session->tlsext_ecpointformatlist);\n+\t\t\t\t\ts->session->tlsext_ecpointformatlist = NULL;\n+\t\t\t\t\t}\n+\t\t\t\ts->session->tlsext_ecpointformatlist_length = 0;\n+\t\t\t\tif ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)\n+\t\t\t\t\t{\n+\t\t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;\n+\t\t\t\t\treturn 0;\n+\t\t\t\t\t}\n+\t\t\t\ts->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;\n+\t\t\t\tmemcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);\n+ \t\t\t\t}\n #if 0\n \t\t\tfprintf(stderr,\"ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist \");\n \t\t\tsdata = s->session->tlsext_ecpointformatlist;"
  },
  {
    "sha": "fee8d3b18bd02a9e3b314efd3f9e9aff488a2cf5",
    "filename": "compiler/vm/rt/android/libcore/crypto/src/main/native/org_conscrypt_NativeCrypto.cpp",
    "status": "modified",
    "additions": 12,
    "deletions": 12,
    "changes": 24,
    "blob_url": "https://github.com/MobiVM/robovm/blob/3c6e25346890489ee9240481e554bd46a7f8e2af/compiler/vm/rt/android/libcore/crypto/src/main/native/org_conscrypt_NativeCrypto.cpp",
    "raw_url": "https://github.com/MobiVM/robovm/raw/3c6e25346890489ee9240481e554bd46a7f8e2af/compiler/vm/rt/android/libcore/crypto/src/main/native/org_conscrypt_NativeCrypto.cpp",
    "contents_url": "https://api.github.com/repos/MobiVM/robovm/contents/compiler/vm/rt/android/libcore/crypto/src/main/native/org_conscrypt_NativeCrypto.cpp?ref=3c6e25346890489ee9240481e554bd46a7f8e2af",
    "patch": "@@ -5596,6 +5596,10 @@ class AppData {\n   public:\n     static AppData* create() {\n         UniquePtr<AppData> appData(new AppData());\n+        if (MUTEX_SETUP(appData.get()->mutex) == -1) {\n+            ALOGE(\"pthread_mutex_init(3) failed: %s\", strerror(errno));\n+            return NULL;\n+        }\n         if (pipe(appData.get()->fdsEmergency) == -1) {\n             ALOGE(\"AppData::create pipe(2) failed: %s\", strerror(errno));\n             return NULL;\n@@ -5604,10 +5608,6 @@ class AppData {\n             ALOGE(\"AppData::create fcntl(2) failed: %s\", strerror(errno));\n             return NULL;\n         }\n-        if (MUTEX_SETUP(appData.get()->mutex) == -1) {\n-            ALOGE(\"pthread_mutex_init(3) failed: %s\", strerror(errno));\n-            return NULL;\n-        }\n         return appData.release();\n     }\n \n@@ -6912,30 +6912,30 @@ extern \"C\" jbyteArray Java_com_android_org_conscrypt_NativeCrypto_SSL_1get_1npn_\n     return result;\n }\n \n-extern \"C\" int Java_com_android_org_conscrypt_NativeCrypto_SSL_1CTX_1set_1alpn_1protos(JNIEnv* env, jclass, jlong ssl_ctx_address,\n+extern \"C\" int Java_com_android_org_conscrypt_NativeCrypto_SSL_1set_1alpn_1protos(JNIEnv* env, jclass, jlong ssl_address,\n         jbyteArray protos) {\n-    SSL_CTX* ssl_ctx = to_SSL_CTX(env, ssl_ctx_address, true);\n-    if (ssl_ctx == NULL) {\n+    SSL* ssl = to_SSL(env, ssl_address, true);\n+    if (ssl == NULL) {\n         return 0;\n     }\n \n-    JNI_TRACE(\"ssl_ctx=%p SSL_CTX_set_alpn_protos protos=%p\", ssl_ctx, protos);\n+    JNI_TRACE(\"ssl=%p SSL_set_alpn_protos protos=%p\", ssl, protos);\n \n     if (protos == NULL) {\n-        JNI_TRACE(\"ssl_ctx=%p SSL_CTX_set_alpn_protos protos=NULL\", ssl_ctx);\n+        JNI_TRACE(\"ssl=%p SSL_set_alpn_protos protos=NULL\", ssl);\n         return 1;\n     }\n \n     ScopedByteArrayRO protosBytes(env, protos);\n     if (protosBytes.get() == NULL) {\n-        JNI_TRACE(\"ssl_ctx=%p SSL_CTX_set_alpn_protos protos=%p => protosBytes == NULL\", ssl_ctx,\n+        JNI_TRACE(\"ssl=%p SSL_set_alpn_protos protos=%p => protosBytes == NULL\", ssl,\n                 protos);\n         return 0;\n     }\n \n     const unsigned char *tmp = reinterpret_cast<const unsigned char*>(protosBytes.get());\n-    int ret = SSL_CTX_set_alpn_protos(ssl_ctx, tmp, protosBytes.size());\n-    JNI_TRACE(\"ssl_ctx=%p SSL_CTX_set_alpn_protos protos=%p => ret=%d\", ssl_ctx, protos, ret);\n+    int ret = SSL_set_alpn_protos(ssl, tmp, protosBytes.size());\n+    JNI_TRACE(\"ssl=%p SSL_set_alpn_protos protos=%p => ret=%d\", ssl, protos, ret);\n     return ret;\n }\n "
  }
]
