[
  {
    "sha": "a20ba84954575be40126307195925faa6f353fdb",
    "filename": "src/main/java/edu/iis/mto/bsearch/BinarySearch.java",
    "status": "modified",
    "additions": 29,
    "deletions": 1,
    "changes": 30,
    "blob_url": "https://github.com/mto-2021-pn/lab2_1/blob/90fd7a390b7a20fe6d82bf1a395abe02b4a36064/src/main/java/edu/iis/mto/bsearch/BinarySearch.java",
    "raw_url": "https://github.com/mto-2021-pn/lab2_1/raw/90fd7a390b7a20fe6d82bf1a395abe02b4a36064/src/main/java/edu/iis/mto/bsearch/BinarySearch.java",
    "contents_url": "https://api.github.com/repos/mto-2021-pn/lab2_1/contents/src/main/java/edu/iis/mto/bsearch/BinarySearch.java?ref=90fd7a390b7a20fe6d82bf1a395abe02b4a36064",
    "patch": "@@ -3,6 +3,9 @@\n  */\n package edu.iis.mto.bsearch;\n \n+import java.util.HashSet;\n+import java.util.Set;\n+\n /**\n  * Klasa implementujÄ…ca wyszukiwanie binarne\n  *\n@@ -22,6 +25,12 @@ private BinarySearch() {}\n      *         sekwencji, jezeli nie znaleziony -1)\n      */\n     public static SearchResult search(int key, int[] seq) {\n+        if (seq.length == 0)\n+            throw new IllegalArgumentException(\"Sequence cannot be empty\");\n+        if (checkIfSequenceContainsDuplicates(seq))\n+            throw new IllegalArgumentException(\"Sequence cannot contain duplicates\");\n+        if (!checkIfSequenceIsSortedAscending(seq))\n+            throw new IllegalArgumentException(\"Sequence cannot be unsorted\");\n         int start = 0;\n         int end = seq.length - 1;\n         int center;\n@@ -30,7 +39,7 @@ public static SearchResult search(int key, int[] seq) {\n         while (start <= end) {\n             center = (start + end) / 2;\n             if (seq[center] == key) {\n-                result.setPosition(center + 1);\n+                result.setPosition(center);\n                 break;\n             } else {\n                 if (seq[center] < key) {\n@@ -43,4 +52,23 @@ public static SearchResult search(int key, int[] seq) {\n         return result;\n     }\n \n+    private static Boolean checkIfSequenceIsSortedAscending(int[] seq) {\n+        int previous = seq[0];\n+\n+        for (int i = 1; i < seq.length; ++i) {\n+            if (previous > seq[i])\n+                return false;\n+            previous = seq[i];\n+        }\n+        return true;\n+    }\n+\n+    private static Boolean checkIfSequenceContainsDuplicates(int[] seq) {\n+        Set<Integer> set = new HashSet<>();\n+        for (Integer element : seq) {\n+            if (!set.add(element))\n+                return true;\n+        }\n+        return false;\n+    }\n }"
  },
  {
    "sha": "282134494434a9593a8098ff3bb12f50b01438e6",
    "filename": "src/test/java/edu/iis/mto/bsearch/BinarySearchTest.java",
    "status": "modified",
    "additions": 129,
    "deletions": 1,
    "changes": 130,
    "blob_url": "https://github.com/mto-2021-pn/lab2_1/blob/90fd7a390b7a20fe6d82bf1a395abe02b4a36064/src/test/java/edu/iis/mto/bsearch/BinarySearchTest.java",
    "raw_url": "https://github.com/mto-2021-pn/lab2_1/raw/90fd7a390b7a20fe6d82bf1a395abe02b4a36064/src/test/java/edu/iis/mto/bsearch/BinarySearchTest.java",
    "contents_url": "https://api.github.com/repos/mto-2021-pn/lab2_1/contents/src/test/java/edu/iis/mto/bsearch/BinarySearchTest.java?ref=90fd7a390b7a20fe6d82bf1a395abe02b4a36064",
    "patch": "@@ -5,7 +5,6 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n \n-\n class BinarySearchTest {\n \n     @BeforeEach\n@@ -16,4 +15,133 @@ void test() {\n         fail(\"Not yet implemented\");\n     }\n \n+    @Test\n+    void shouldFindElementWhenSequenceContainsOnlyThisElement() {\n+        // given\n+        int element = 100;\n+        int[] sequence = {element};\n+\n+        // when\n+        SearchResult result = BinarySearch.search(element, sequence);\n+\n+        // then\n+        assertTrue(result.isFound(), \"Expected element should be found\");\n+        assertEquals(0, result.getPosition(), \"Position of found element should be 0\");\n+    }\n+\n+    @Test\n+    void shouldNotFindElementInSingleElementSequence() {\n+        // given\n+        int element = 100;\n+        int[] sequence = {200};\n+\n+        // when\n+        SearchResult result = BinarySearch.search(element, sequence);\n+\n+        // then\n+        assertFalse(result.isFound(), \"Expected element should not be found\");\n+        assertEquals(-1, result.getPosition(), \"Position should be set to -1 for an item that's not found\");\n+    }\n+\n+    @Test\n+    void shouldFindElementWhenTheElementIsFirstInMultiSequence() {\n+        // given\n+        int element = 50;\n+        int[] sequence = {50, 100};\n+\n+        // when\n+        SearchResult result = BinarySearch.search(element, sequence);\n+\n+        // then\n+        assertTrue(result.isFound(), \"Expected element should be found\");\n+        assertEquals(0, result.getPosition(), \"Position of found element should be 0\");\n+    }\n+\n+    @Test\n+    void shouldFindElementWhenTheElementIsLastInMultiSequence() {\n+        // given\n+        int element = 50;\n+        int[] sequence = {25, 50};\n+\n+        // when\n+        SearchResult result = BinarySearch.search(element, sequence);\n+\n+        // then\n+        assertTrue(result.isFound(), \"Expected element should be found\");\n+        assertEquals(1, result.getPosition(), \"Position of found element should be 1\");\n+    }\n+\n+    @Test\n+    void shouldFindElementWhenTheElementIsInTheMiddleOfMultiSequence() {\n+        // given\n+        int element = 50;\n+        int[] sequence = {25, 50, 75};\n+\n+        // when\n+        SearchResult result = BinarySearch.search(element, sequence);\n+\n+        // then\n+        assertTrue(result.isFound(), \"Expected element should be found\");\n+        assertEquals(1, result.getPosition(), \"Position of found element should be 1\");\n+    }\n+\n+    @Test\n+    void shouldNotFindElementInMultiElementSequence() {\n+        // given\n+        int element = 100;\n+        int[] sequence = {150, 200, 350};\n+\n+        // when\n+        SearchResult result = BinarySearch.search(element, sequence);\n+\n+        // then\n+        assertFalse(result.isFound(), \"Expected element should not be found\");\n+        assertEquals(-1, result.getPosition(), \"Position should be set to -1 for an item that's not found\");\n+    }\n+\n+    @Test\n+    void shouldThrowIllegalArgumentExceptionWhenSequenceIsEmpty() {\n+        // given\n+        int element = 100;\n+        int[] sequence = {};\n+        String expectedMessage = \"Sequence cannot be empty\";\n+\n+        // when\n+        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> BinarySearch.search(element, sequence),\n+                \"IllegalArgumentException should be thrown when sequence is empty\");\n+\n+        // then\n+        assertEquals(expectedMessage, exception.getMessage(), \"Message of exception should be: \" + expectedMessage);\n+\n+    }\n+\n+    @Test\n+    void shouldThrowIllegalArgumentExceptionWhenSequenceUnsorted() {\n+        // given\n+        int element = 5;\n+        int[] sequence = {1, 2, 8, 4, 3, 5, 17};\n+        String expectedMessage = \"Sequence cannot be unsorted\";\n+\n+        // when\n+        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> BinarySearch.search(element, sequence),\n+                \"IllegalArgumentException should be thrown when sequence is unsorted\");\n+\n+        // then\n+        assertEquals(expectedMessage, exception.getMessage(), \"Message of exception should be: \" + expectedMessage);\n+    }\n+\n+    @Test\n+    void shouldThrowIllegalArgumentExceptionWhenSequenceContainsDuplicates() {\n+        // given\n+        int[] sequence = {1, 2, 3, 3, 5};\n+        String expectedMessage = \"Sequence cannot contain duplicates\";\n+\n+        // when\n+        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> BinarySearch.search(5, sequence),\n+                \"IllegalArgumentException should be thrown when sequence is unsorted\");\n+\n+        // then\n+        assertEquals(expectedMessage, exception.getMessage(), \"Message of exception should be: \" + expectedMessage);\n+    }\n+\n }"
  }
]
