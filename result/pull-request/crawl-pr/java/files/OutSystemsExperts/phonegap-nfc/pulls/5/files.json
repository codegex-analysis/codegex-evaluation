[
  {
    "sha": "c2cf950d78b03eff52e9e04f12c018144d5e24a9",
    "filename": "src/android/src/com/chariotsolutions/nfc/plugin/NfcPlugin.java",
    "status": "modified",
    "additions": 541,
    "deletions": 305,
    "changes": 846,
    "blob_url": "https://github.com/OutSystemsExperts/phonegap-nfc/blob/4a9bedb36dec08f63a86af45a139d1ab1f89a595/src/android/src/com/chariotsolutions/nfc/plugin/NfcPlugin.java",
    "raw_url": "https://github.com/OutSystemsExperts/phonegap-nfc/raw/4a9bedb36dec08f63a86af45a139d1ab1f89a595/src/android/src/com/chariotsolutions/nfc/plugin/NfcPlugin.java",
    "contents_url": "https://api.github.com/repos/OutSystemsExperts/phonegap-nfc/contents/src/android/src/com/chariotsolutions/nfc/plugin/NfcPlugin.java?ref=4a9bedb36dec08f63a86af45a139d1ab1f89a595",
    "patch": "@@ -1,5 +1,20 @@\n package com.chariotsolutions.nfc.plugin;\n \n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+// using wildcard imports so we can support Cordova 3.x\n+import org.apache.cordova.*; // Cordova 3.x\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n import android.app.Activity;\n import android.app.PendingIntent;\n import android.content.Intent;\n@@ -15,24 +30,11 @@\n import android.nfc.TagLostException;\n import android.nfc.tech.Ndef;\n import android.nfc.tech.NdefFormatable;\n+import android.nfc.tech.TagTechnology;\n+import android.os.Bundle;\n import android.os.Parcelable;\n import android.util.Log;\n \n-import org.apache.cordova.CallbackContext;\n-import org.apache.cordova.CordovaPlugin;\n-import org.apache.cordova.PluginResult;\n-import org.json.JSONArray;\n-import org.json.JSONException;\n-import org.json.JSONObject;\n-\n-import java.io.IOException;\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-// using wildcard imports so we can support Cordova 3.x\n-\n public class NfcPlugin extends CordovaPlugin implements NfcAdapter.OnNdefPushCompleteCallback {\n     private static final String REGISTER_MIME_TYPE = \"registerMimeType\";\n     private static final String REMOVE_MIME_TYPE = \"removeMimeType\";\n@@ -57,20 +59,34 @@\n     private static final String NDEF_FORMATABLE = \"ndef-formatable\";\n     private static final String TAG_DEFAULT = \"tag\";\n \n+    private static final String READER_MODE = \"readerMode\";\n+    private static final String DISABLE_READER_MODE = \"disableReaderMode\";\n+\n+    // TagTechnology IsoDep, NfcA, NfcB, NfcV, NfcF, MifareClassic, MifareUltralight\n+    private static final String CONNECT = \"connect\";\n+    private static final String CLOSE = \"close\";\n+    private static final String TRANSCEIVE = \"transceive\";\n+    private TagTechnology tagTechnology = null;\n+    private Class<?> tagTechnologyClass;\n+\n+    private static final String CHANNEL = \"channel\";\n+\n     private static final String STATUS_NFC_OK = \"NFC_OK\";\n     private static final String STATUS_NO_NFC = \"NO_NFC\";\n     private static final String STATUS_NFC_DISABLED = \"NFC_DISABLED\";\n     private static final String STATUS_NDEF_PUSH_DISABLED = \"NDEF_PUSH_DISABLED\";\n \n     private static final String TAG = \"NfcPlugin\";\n-    private final List<IntentFilter> intentFilters = new ArrayList<IntentFilter>();\n-    private final ArrayList<String[]> techLists = new ArrayList<String[]>();\n+    private final List<IntentFilter> intentFilters = new ArrayList<>();\n+    private final ArrayList<String[]> techLists = new ArrayList<>();\n \n     private NdefMessage p2pMessage = null;\n     private PendingIntent pendingIntent = null;\n \n     private Intent savedIntent = null;\n \n+    private CallbackContext readerModeCallback;\n+    private CallbackContext channelCallback;\n     private CallbackContext shareTagCallback;\n     private CallbackContext handoverCallback;\n \n@@ -86,33 +102,49 @@ public boolean execute(String action, JSONArray data, CallbackContext callbackCo\n             return true;\n         }\n \n+        // the channel is set up when the plugin starts\n+        if (action.equalsIgnoreCase(CHANNEL)) {\n+            channelCallback = callbackContext;\n+            return true; // short circuit\n+        }\n+\n+        // allow reader mode to be disabled even if nfc is disabled\n+        if (action.equalsIgnoreCase(DISABLE_READER_MODE)) {\n+            disableReaderMode(callbackContext);\n+            return true; // short circuit\n+        }\n+\n         if (!getNfcStatus().equals(STATUS_NFC_OK)) {\n             callbackContext.error(getNfcStatus());\n             return true; // short circuit\n         }\n \n         createPendingIntent();\n \n-        if (action.equalsIgnoreCase(REGISTER_MIME_TYPE)) {\n+        if (action.equalsIgnoreCase(READER_MODE)) {\n+            int flags = data.getInt(0);\n+            readerMode(flags, callbackContext);\n+\n+        } else if (action.equalsIgnoreCase(REGISTER_MIME_TYPE)) {\n             registerMimeType(data, callbackContext);\n \n         } else if (action.equalsIgnoreCase(REMOVE_MIME_TYPE)) {\n-          removeMimeType(data, callbackContext);\n+            removeMimeType(data, callbackContext);\n \n         } else if (action.equalsIgnoreCase(REGISTER_NDEF)) {\n-          registerNdef(callbackContext);\n+            registerNdef(callbackContext);\n \n         } else if (action.equalsIgnoreCase(REMOVE_NDEF)) {\n-          removeNdef(callbackContext);\n+            removeNdef(callbackContext);\n \n         } else if (action.equalsIgnoreCase(REGISTER_NDEF_FORMATABLE)) {\n             registerNdefFormatable(callbackContext);\n \n-        }  else if (action.equals(REGISTER_DEFAULT_TAG)) {\n-          registerDefaultTag(callbackContext);\n+        } else if (action.equals(REGISTER_DEFAULT_TAG)) {\n+            registerDefaultTag(callbackContext);\n \n-        }  else if (action.equals(REMOVE_DEFAULT_TAG)) {\n-          removeDefaultTag(callbackContext);\n+        } else if (action.equals(REMOVE_DEFAULT_TAG)) {\n+            removeDefaultTag(callbackContext);\n \n         } else if (action.equalsIgnoreCase(WRITE_TAG)) {\n             writeTag(data, callbackContext);\n@@ -143,6 +175,20 @@ public boolean execute(String action, JSONArray data, CallbackContext callbackCo\n             // if code made it here, NFC is enabled\n             callbackContext.success(STATUS_NFC_OK);\n \n+        } else if (action.equalsIgnoreCase(CONNECT)) {\n+            String tech = data.getString(0);\n+            int timeout = data.optInt(1, -1);\n+            connect(tech, timeout, callbackContext);\n+\n+        } else if (action.equalsIgnoreCase(TRANSCEIVE)) {\n+            CordovaArgs args = new CordovaArgs(data); // execute is using the old signature with JSON data\n+\n+            byte[] command = args.getArrayBuffer(0);\n+            transceive(command, callbackContext);\n+\n+        } else if (action.equalsIgnoreCase(CLOSE)) {\n+            close(callbackContext);\n+\n         } else {\n             // invalid action\n             return false;\n@@ -162,30 +208,86 @@ private String getNfcStatus() {\n         }\n     }\n \n+    private void readerMode(int flags, CallbackContext callbackContext) {\n+        Bundle extras = new Bundle(); // not used\n+        readerModeCallback = callbackContext;\n+        getActivity().runOnUiThread(() -> {\n+            NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());\n+            nfcAdapter.enableReaderMode(getActivity(), callback, flags, extras);\n+        });\n+\n+    }\n+\n+    private void disableReaderMode(CallbackContext callbackContext) {\n+        getActivity().runOnUiThread(() -> {\n+            readerModeCallback = null;\n+            NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());\n+            if (nfcAdapter != null) {\n+                nfcAdapter.disableReaderMode(getActivity());\n+            }\n+            callbackContext.success();\n+        });\n+    }\n+\n+    private NfcAdapter.ReaderCallback callback = new NfcAdapter.ReaderCallback() {\n+        @Override\n+        public void onTagDiscovered(Tag tag) {\n+\n+            JSONObject json;\n+\n+            // If the tag supports Ndef, try and return an Ndef message\n+            List<String> techList = Arrays.asList(tag.getTechList());\n+            if (techList.contains(Ndef.class.getName())) {\n+                Ndef ndef = Ndef.get(tag);\n+                json = Util.ndefToJSON(ndef);\n+            } else {\n+                json = Util.tagToJSON(tag);\n+            }\n+\n+            Intent tagIntent = new Intent();\n+            tagIntent.putExtra(NfcAdapter.EXTRA_TAG, tag);\n+            setIntent(tagIntent);\n+\n+            PluginResult result = new PluginResult(PluginResult.Status.OK, json);\n+            result.setKeepCallback(true);\n+            if (readerModeCallback != null) {\n+                readerModeCallback.sendPluginResult(result);\n+            } else {\n+                Log.i(TAG, \"readerModeCallback is null - reader mode probably disabled in the meantime\");\n+            }\n+\n+        }\n+    };\n+\n     private void registerDefaultTag(CallbackContext callbackContext) {\n-      addTagFilter();\n-      callbackContext.success();\n-  }\n+        addTagFilter();\n+        restartNfc();\n+        callbackContext.success();\n+    }\n \n     private void removeDefaultTag(CallbackContext callbackContext) {\n-      removeTagFilter();\n-      callbackContext.success();\n-  }\n+        removeTagFilter();\n+        restartNfc();\n+        callbackContext.success();\n+    }\n \n     private void registerNdefFormatable(CallbackContext callbackContext) {\n         addTechList(new String[]{NdefFormatable.class.getName()});\n+        restartNfc();\n         callbackContext.success();\n     }\n \n     private void registerNdef(CallbackContext callbackContext) {\n-      addTechList(new String[]{Ndef.class.getName()});\n-      callbackContext.success();\n-  }\n+        addTechList(new String[]{Ndef.class.getName()});\n+        restartNfc();\n+        callbackContext.success();\n+    }\n \n     private void removeNdef(CallbackContext callbackContext) {\n-      removeTechList(new String[]{Ndef.class.getName()});\n-      callbackContext.success();\n-  }\n+        removeTechList(new String[]{Ndef.class.getName()});\n+        restartNfc();\n+        callbackContext.success();\n+    }\n \n     private void unshareTag(CallbackContext callbackContext) {\n         p2pMessage = null;\n@@ -205,40 +307,36 @@ private void init(CallbackContext callbackContext) {\n     }\n \n     private void removeMimeType(JSONArray data, CallbackContext callbackContext) throws JSONException {\n-        String mimeType = \"\";\n-        try {\n-            mimeType = data.getString(0);\n-            /*boolean removed =*/ removeIntentFilter(mimeType);\n-            callbackContext.success();\n-        } catch (MalformedMimeTypeException e) {\n-            callbackContext.error(\"Invalid MIME Type \" + mimeType);\n-        }\n+        String mimeType = data.getString(0);\n+        removeIntentFilter(mimeType);\n+        restartNfc();\n+        callbackContext.success();\n     }\n \n     private void registerMimeType(JSONArray data, CallbackContext callbackContext) throws JSONException {\n         String mimeType = \"\";\n         try {\n             mimeType = data.getString(0);\n             intentFilters.add(createIntentFilter(mimeType));\n+            restartNfc();\n             callbackContext.success();\n         } catch (MalformedMimeTypeException e) {\n             callbackContext.error(\"Invalid MIME Type \" + mimeType);\n         }\n     }\n \n     // Cheating and writing an empty record. We may actually be able to erase some tag types.\n-    private void eraseTag(CallbackContext callbackContext) throws JSONException {\n+    private void eraseTag(CallbackContext callbackContext) {\n         Tag tag = savedIntent.getParcelableExtra(NfcAdapter.EXTRA_TAG);\n         NdefRecord[] records = {\n-            new NdefRecord(NdefRecord.TNF_EMPTY, new byte[0], new byte[0], new byte[0])\n+                new NdefRecord(NdefRecord.TNF_EMPTY, new byte[0], new byte[0], new byte[0])\n         };\n         writeNdefMessage(new NdefMessage(records), tag, callbackContext);\n     }\n \n     private void writeTag(JSONArray data, CallbackContext callbackContext) throws JSONException {\n         if (getIntent() == null) {  // TODO remove this and handle LostTag\n             callbackContext.error(\"Failed to write tag, received null intent\");\n-            return;\n         }\n \n         Tag tag = savedIntent.getParcelableExtra(NfcAdapter.EXTRA_TAG);\n@@ -247,53 +345,47 @@ private void writeTag(JSONArray data, CallbackContext callbackContext) throws JS\n     }\n \n     private void writeNdefMessage(final NdefMessage message, final Tag tag, final CallbackContext callbackContext) {\n-        cordova.getThreadPool().execute(new Runnable() {\n-            @Override\n-            public void run() {\n-                try {\n-                    Ndef ndef = Ndef.get(tag);\n-                    if (ndef != null && !ndef.isConnected()) {\n-                        ndef.connect();\n-\n-                        if (ndef.isWritable()) {\n-                            int size = message.toByteArray().length;\n-                            if (ndef.getMaxSize() < size) {\n-                                callbackContext.error(\"Tag capacity is \" + ndef.getMaxSize() +\n-                                        \" bytes, message is \" + size + \" bytes.\");\n-                            } else {\n-                                ndef.writeNdefMessage(message);\n-                                callbackContext.success();\n-                            }\n+        cordova.getThreadPool().execute(() -> {\n+            try {\n+                Ndef ndef = Ndef.get(tag);\n+                if (ndef != null) {\n+                    ndef.connect();\n+\n+                    if (ndef.isWritable()) {\n+                        int size = message.toByteArray().length;\n+                        if (ndef.getMaxSize() < size) {\n+                            callbackContext.error(\"Tag capacity is \" + ndef.getMaxSize() +\n+                                    \" bytes, message is \" + size + \" bytes.\");\n                         } else {\n-                            callbackContext.error(\"Tag is read only\");\n-                        }\n-                        ndef.close();\n-                    } else {\n-                        NdefFormatable formatable = NdefFormatable.get(tag);\n-                        if (formatable != null) {\n-                            formatable.connect();\n-                            formatable.format(message);\n+                            ndef.writeNdefMessage(message);\n                             callbackContext.success();\n-                            formatable.close();\n-                        } else {\n-                            callbackContext.error(\"Tag doesn't support NDEF\");\n                         }\n+                    } else {\n+                        callbackContext.error(\"Tag is read only\");\n+                    }\n+                    ndef.close();\n+                } else {\n+                    NdefFormatable formatable = NdefFormatable.get(tag);\n+                    if (formatable != null) {\n+                        formatable.connect();\n+                        formatable.format(message);\n+                        callbackContext.success();\n+                        formatable.close();\n+                    } else {\n+                        callbackContext.error(\"Tag doesn't support NDEF\");\n                     }\n-                } catch (FormatException e) {\n-                    callbackContext.error(e.getMessage());\n-                } catch (TagLostException e) {\n-                    callbackContext.error(e.getMessage());\n-                } catch (IOException e) {\n-                    callbackContext.error(e.getMessage());\n-                } catch (IllegalStateException e) {\n-                \tcallbackContext.error(\"Still writing!\");\n-                    Log.e(TAG, \"Illegal State, still writing !\");\n                 }\n+            } catch (FormatException e) {\n+                callbackContext.error(e.getMessage());\n+            } catch (TagLostException e) {\n+                callbackContext.error(e.getMessage());\n+            } catch (IOException e) {\n+                callbackContext.error(e.getMessage());\n             }\n         });\n     }\n \n-    private void makeReadOnly(final CallbackContext callbackContext) throws JSONException {\n+    private void makeReadOnly(final CallbackContext callbackContext) {\n \n         if (getIntent() == null) { // Lost Tag\n             callbackContext.error(\"Failed to make tag read only, received null intent\");\n@@ -306,46 +398,43 @@ private void makeReadOnly(final CallbackContext callbackContext) throws JSONExce\n             return;\n         }\n \n-        cordova.getThreadPool().execute(new Runnable() {\n-            @Override\n-            public void run() {\n-                boolean success = false;\n-                String message = \"Could not make tag read only\";\n+        cordova.getThreadPool().execute(() -> {\n+            boolean success = false;\n+            String message = \"Could not make tag read only\";\n \n-                Ndef ndef = Ndef.get(tag);\n-\n-                try {\n-                    if (ndef != null) {\n+            Ndef ndef = Ndef.get(tag);\n \n-                        ndef.connect();\n+            try {\n+                if (ndef != null) {\n \n-                        if (!ndef.isWritable()) {\n-                            message = \"Tag is not writable\";\n-                        } else if (ndef.canMakeReadOnly()) {\n-                            success = ndef.makeReadOnly();\n-                        } else {\n-                            message = \"Tag can not be made read only\";\n-                        }\n+                    ndef.connect();\n \n+                    if (!ndef.isWritable()) {\n+                        message = \"Tag is not writable\";\n+                    } else if (ndef.canMakeReadOnly()) {\n+                        success = ndef.makeReadOnly();\n                     } else {\n-                        message = \"Tag is not NDEF\";\n+                        message = \"Tag can not be made read only\";\n                     }\n \n-                } catch (IOException e) {\n-                    Log.e(TAG, \"Failed to make tag read only\", e);\n-                    if (e.getMessage() != null) {\n-                        message = e.getMessage();\n-                    } else {\n-                        message = e.toString();\n-                    }\n+                } else {\n+                    message = \"Tag is not NDEF\";\n                 }\n \n-                if (success) {\n-                    callbackContext.success();\n+            } catch (IOException e) {\n+                Log.e(TAG, \"Failed to make tag read only\", e);\n+                if (e.getMessage() != null) {\n+                    message = e.getMessage();\n                 } else {\n-                    callbackContext.error(message);\n+                    message = e.toString();\n                 }\n             }\n+\n+            if (success) {\n+                callbackContext.success();\n+            } else {\n+                callbackContext.error(message);\n+            }\n         });\n     }\n \n@@ -372,7 +461,7 @@ private void handover(JSONArray data, CallbackContext callbackContext) throws JS\n         startNdefBeam(callbackContext, uri);\n     }\n \n-    private void stopHandover(CallbackContext callbackContext) throws JSONException {\n+    private void stopHandover(CallbackContext callbackContext) {\n         stopNdefBeam();\n         handoverCallback = null;\n         callbackContext.success();\n@@ -399,193 +488,187 @@ private void createPendingIntent() {\n     }\n \n     private void addTechList(String[] list) {\n-      this.addTechFilter();\n-      this.addToTechList(list);\n+        this.addTechFilter();\n+        this.addToTechList(list);\n     }\n \n     private void removeTechList(String[] list) {\n-      this.removeTechFilter();\n-      this.removeFromTechList(list);\n+        this.removeTechFilter();\n+        this.removeFromTechList(list);\n     }\n \n     private void addTechFilter() {\n-      intentFilters.add(new IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED));\n+        intentFilters.add(new IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED));\n     }\n \n-    private boolean removeTechFilter() {\n-      boolean removed = false;\n-      Iterator<IntentFilter> iter = intentFilters.iterator();\n-      while (iter.hasNext()) {\n-        IntentFilter intentFilter = iter.next();\n-        if (NfcAdapter.ACTION_TECH_DISCOVERED.equals(intentFilter.getAction(0))) {\n-          iter.remove();\n-          removed = true;\n+    private void removeTechFilter() {\n+        Iterator<IntentFilter> iterator = intentFilters.iterator();\n+        while (iterator.hasNext()) {\n+            IntentFilter intentFilter = iterator.next();\n+            if (NfcAdapter.ACTION_TECH_DISCOVERED.equals(intentFilter.getAction(0))) {\n+                iterator.remove();\n+            }\n         }\n-      }\n-      return removed;\n     }\n \n     private void addTagFilter() {\n-      intentFilters.add(new IntentFilter(NfcAdapter.ACTION_TAG_DISCOVERED));\n-  }\n-\n-    private boolean removeTagFilter() {\n-      boolean removed = false;\n-      Iterator<IntentFilter> iter = intentFilters.iterator();\n-      while (iter.hasNext()) {\n-        IntentFilter intentFilter = iter.next();\n-        if (NfcAdapter.ACTION_TAG_DISCOVERED.equals(intentFilter.getAction(0))) {\n-          iter.remove();\n-          removed = true;\n+        intentFilters.add(new IntentFilter(NfcAdapter.ACTION_TAG_DISCOVERED));\n+    }\n+\n+    private void removeTagFilter() {\n+        Iterator<IntentFilter> iterator = intentFilters.iterator();\n+        while (iterator.hasNext()) {\n+            IntentFilter intentFilter = iterator.next();\n+            if (NfcAdapter.ACTION_TAG_DISCOVERED.equals(intentFilter.getAction(0))) {\n+                iterator.remove();\n+            }\n         }\n-      }\n-      return removed;\n-  }\n+    }\n+\n+    private void restartNfc() {\n+        stopNfc();\n+        startNfc();\n+    }\n \n     private void startNfc() {\n         createPendingIntent(); // onResume can call startNfc before execute\n \n-        getActivity().runOnUiThread(new Runnable() {\n-            public void run() {\n-                NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());\n+        getActivity().runOnUiThread(() -> {\n+            NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());\n \n-                if (nfcAdapter != null && !getActivity().isFinishing()) {\n-                    try {\n-                        nfcAdapter.enableForegroundDispatch(getActivity(), getPendingIntent(), getIntentFilters(), getTechLists());\n-\n-                        if (p2pMessage != null) {\n-                            nfcAdapter.setNdefPushMessage(p2pMessage, getActivity());\n-                        }\n-                    } catch (IllegalStateException e) {\n-                        // issue 110 - user exits app with home button while nfc is initializing\n-                        Log.w(TAG, \"Illegal State Exception starting NFC. Assuming application is terminating.\");\n+            if (nfcAdapter != null && !getActivity().isFinishing()) {\n+                try {\n+                    IntentFilter[] intentFilters = getIntentFilters();\n+                    String[][] techLists = getTechLists();\n+                    // don't start NFC unless some intent filters or tech lists have been added,\n+                    // because empty lists act as wildcards and receives ALL scan events\n+                    if (intentFilters.length > 0 || techLists.length > 0) {\n+                        nfcAdapter.enableForegroundDispatch(getActivity(), getPendingIntent(), intentFilters, techLists);\n                     }\n \n+                    if (p2pMessage != null) {\n+                        nfcAdapter.setNdefPushMessage(p2pMessage, getActivity());\n+                    }\n+                } catch (IllegalStateException e) {\n+                    // issue 110 - user exits app with home button while nfc is initializing\n+                    Log.w(TAG, \"Illegal State Exception starting NFC. Assuming application is terminating.\");\n                 }\n+\n             }\n         });\n     }\n \n     private void stopNfc() {\n         Log.d(TAG, \"stopNfc\");\n-        getActivity().runOnUiThread(new Runnable() {\n-            public void run() {\n+        getActivity().runOnUiThread(() -> {\n \n-                NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());\n+            NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());\n \n-                if (nfcAdapter != null) {\n-                    try {\n-                        nfcAdapter.disableForegroundDispatch(getActivity());\n-                    } catch (IllegalStateException e) {\n-                        // issue 125 - user exits app with back button while nfc\n-                        Log.w(TAG, \"Illegal State Exception stopping NFC. Assuming application is terminating.\");\n-                    }\n+            if (nfcAdapter != null) {\n+                try {\n+                    nfcAdapter.disableForegroundDispatch(getActivity());\n+                } catch (IllegalStateException e) {\n+                    // issue 125 - user exits app with back button while nfc\n+                    Log.w(TAG, \"Illegal State Exception stopping NFC. Assuming application is terminating.\");\n                 }\n             }\n         });\n     }\n \n     private void startNdefBeam(final CallbackContext callbackContext, final Uri[] uris) {\n-        getActivity().runOnUiThread(new Runnable() {\n-            public void run() {\n+        getActivity().runOnUiThread(() -> {\n \n-                NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());\n+            NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());\n \n-                if (nfcAdapter == null) {\n-                    callbackContext.error(STATUS_NO_NFC);\n-                } else if (!nfcAdapter.isNdefPushEnabled()) {\n-                    callbackContext.error(STATUS_NDEF_PUSH_DISABLED);\n-                } else {\n-                    nfcAdapter.setOnNdefPushCompleteCallback(NfcPlugin.this, getActivity());\n-                    try {\n-                        nfcAdapter.setBeamPushUris(uris, getActivity());\n+            if (nfcAdapter == null) {\n+                callbackContext.error(STATUS_NO_NFC);\n+            } else if (!nfcAdapter.isNdefPushEnabled()) {\n+                callbackContext.error(STATUS_NDEF_PUSH_DISABLED);\n+            } else {\n+                nfcAdapter.setOnNdefPushCompleteCallback(NfcPlugin.this, getActivity());\n+                try {\n+                    nfcAdapter.setBeamPushUris(uris, getActivity());\n \n-                        PluginResult result = new PluginResult(PluginResult.Status.NO_RESULT);\n-                        result.setKeepCallback(true);\n-                        handoverCallback = callbackContext;\n-                        callbackContext.sendPluginResult(result);\n+                    PluginResult result = new PluginResult(PluginResult.Status.NO_RESULT);\n+                    result.setKeepCallback(true);\n+                    handoverCallback = callbackContext;\n+                    callbackContext.sendPluginResult(result);\n \n-                    } catch (IllegalArgumentException e) {\n-                        callbackContext.error(e.getMessage());\n-                    }\n+                } catch (IllegalArgumentException e) {\n+                    callbackContext.error(e.getMessage());\n                 }\n             }\n         });\n     }\n \n     private void startNdefPush(final CallbackContext callbackContext) {\n-        getActivity().runOnUiThread(new Runnable() {\n-            public void run() {\n-\n-                NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());\n-\n-                if (nfcAdapter == null) {\n-                    callbackContext.error(STATUS_NO_NFC);\n-                } else if (!nfcAdapter.isNdefPushEnabled()) {\n-                    callbackContext.error(STATUS_NDEF_PUSH_DISABLED);\n-                } else {\n-                    nfcAdapter.setNdefPushMessage(p2pMessage, getActivity());\n-                    nfcAdapter.setOnNdefPushCompleteCallback(NfcPlugin.this, getActivity());\n-\n-                    PluginResult result = new PluginResult(PluginResult.Status.NO_RESULT);\n-                    result.setKeepCallback(true);\n-                    shareTagCallback = callbackContext;\n-                    callbackContext.sendPluginResult(result);\n-                }\n+        getActivity().runOnUiThread(() -> {\n+\n+            NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());\n+\n+            if (nfcAdapter == null) {\n+                callbackContext.error(STATUS_NO_NFC);\n+            } else if (!nfcAdapter.isNdefPushEnabled()) {\n+                callbackContext.error(STATUS_NDEF_PUSH_DISABLED);\n+            } else {\n+                nfcAdapter.setNdefPushMessage(p2pMessage, getActivity());\n+                nfcAdapter.setOnNdefPushCompleteCallback(NfcPlugin.this, getActivity());\n+\n+                PluginResult result = new PluginResult(PluginResult.Status.NO_RESULT);\n+                result.setKeepCallback(true);\n+                shareTagCallback = callbackContext;\n+                callbackContext.sendPluginResult(result);\n             }\n         });\n     }\n \n     private void stopNdefPush() {\n-        getActivity().runOnUiThread(new Runnable() {\n-            public void run() {\n+        getActivity().runOnUiThread(() -> {\n \n-                NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());\n-\n-                if (nfcAdapter != null) {\n-                    nfcAdapter.setNdefPushMessage(null, getActivity());\n-                }\n+            NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());\n \n+            if (nfcAdapter != null) {\n+                nfcAdapter.setNdefPushMessage(null, getActivity());\n             }\n+\n         });\n     }\n \n     private void stopNdefBeam() {\n-        getActivity().runOnUiThread(new Runnable() {\n-            public void run() {\n+        getActivity().runOnUiThread(() -> {\n \n-                NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());\n-\n-                if (nfcAdapter != null) {\n-                    nfcAdapter.setBeamPushUris(null, getActivity());\n-                }\n+            NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(getActivity());\n \n+            if (nfcAdapter != null) {\n+                nfcAdapter.setBeamPushUris(null, getActivity());\n             }\n+\n         });\n     }\n \n     private void addToTechList(String[] techs) {\n-      techLists.add(techs);\n-  }\n+        techLists.add(techs);\n+    }\n \n     private void removeFromTechList(String[] techs) {\n-      techLists.remove(techs);\n-  }\n-\n-    private boolean removeIntentFilter(String mimeType) throws MalformedMimeTypeException {\n-      boolean removed = false;\n-      Iterator<IntentFilter> iter = intentFilters.iterator();\n-      while (iter.hasNext()) {\n-        IntentFilter intentFilter = iter.next();\n-        if(intentFilter.countDataTypes() > 0 ) {\n+        Iterator<String[]> iterator = techLists.iterator();\n+        while (iterator.hasNext()) {\n+            String[] list = iterator.next();\n+            if (Arrays.equals(list, techs)) {\n+                iterator.remove();\n+            }\n+        }\n+    }\n+\n+    private void removeIntentFilter(String mimeType) {\n+        Iterator<IntentFilter> iterator = intentFilters.iterator();\n+        while (iterator.hasNext()) {\n+            IntentFilter intentFilter = iterator.next();\n             String mt = intentFilter.getDataType(0);\n             if (mimeType.equals(mt)) {\n-                iter.remove();\n-                removed = true;\n+                iterator.remove();\n             }\n         }\n-      }\n-      return removed;\n     }\n \n     private IntentFilter createIntentFilter(String mimeType) throws MalformedMimeTypeException {\n@@ -607,84 +690,74 @@ private PendingIntent getPendingIntent() {\n         return techLists.toArray(new String[0][0]);\n     }\n \n-    void parseMessage() {\n-        cordova.getThreadPool().execute(new Runnable() {\n-            @Override\n-            public void run() {\n-                Log.d(TAG, \"parseMessage \" + getIntent());\n-                Intent intent = getIntent();\n-                String action = intent.getAction();\n-                Log.d(TAG, \"action \" + action);\n-                if (action == null) {\n-                    return;\n-                }\n+    private void parseMessage() {\n+        cordova.getThreadPool().execute(() -> {\n+            Log.d(TAG, \"parseMessage \" + getIntent());\n+            Intent intent = getIntent();\n+            String action = intent.getAction();\n+            Log.d(TAG, \"action \" + action);\n+            if (action == null) {\n+                return;\n+            }\n \n-                Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);\n-                Parcelable[] messages = intent.getParcelableArrayExtra((NfcAdapter.EXTRA_NDEF_MESSAGES));\n-\n-                if (action.equals(NfcAdapter.ACTION_NDEF_DISCOVERED)) {\n-                    Ndef ndef = Ndef.get(tag);\n-                    boolean sendNdefMimeEvent = false;\n-                    if(messages.length == 1){\n-                        NdefMessage message = (NdefMessage) messages[0];\n-                        for(NdefRecord record : message.getRecords()) {\n-                            sendNdefMimeEvent = record.getTnf() == NdefRecord.TNF_MIME_MEDIA;\n-                            break;\n-                        }\n-                    }\n-                    if(sendNdefMimeEvent) {\n-                        fireNdefEvent(NDEF_MIME, ndef, messages);\n-                    }\n-                    \n-                    fireNdefEvent(NDEF, ndef, messages);\n-\n-                } else if (action.equals(NfcAdapter.ACTION_TECH_DISCOVERED)) {\n-                    for (String tagTech : tag.getTechList()) {\n-                        Log.d(TAG, tagTech);\n-                        if (tagTech.equals(NdefFormatable.class.getName())) {\n-                            fireNdefFormatableEvent(tag);\n-                        } else if (tagTech.equals(Ndef.class.getName())) { //\n-                            Ndef ndef = Ndef.get(tag);\n-                            fireNdefEvent(NDEF, ndef, messages);\n-                        }\n-                    }\n-                }\n+            Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);\n+            Parcelable[] messages = intent.getParcelableArrayExtra((NfcAdapter.EXTRA_NDEF_MESSAGES));\n \n-                if (action.equals(NfcAdapter.ACTION_TAG_DISCOVERED)) {\n-                    fireTagEvent(tag);\n+            if (action.equals(NfcAdapter.ACTION_NDEF_DISCOVERED)) {\n+                Ndef ndef = Ndef.get(tag);\n+                fireNdefEvent(NDEF_MIME, ndef, messages);\n+\n+            } else if (action.equals(NfcAdapter.ACTION_TECH_DISCOVERED)) {\n+                for (String tagTech : tag.getTechList()) {\n+                    Log.d(TAG, tagTech);\n+                    if (tagTech.equals(NdefFormatable.class.getName())) {\n+                        fireNdefFormatableEvent(tag);\n+                    } else if (tagTech.equals(Ndef.class.getName())) { //\n+                        Ndef ndef = Ndef.get(tag);\n+                        fireNdefEvent(NDEF, ndef, messages);\n+                    }\n                 }\n+            }\n \n-                setIntent(new Intent());\n+            if (action.equals(NfcAdapter.ACTION_TAG_DISCOVERED)) {\n+                fireTagEvent(tag);\n             }\n+\n+            setIntent(new Intent());\n         });\n     }\n \n-    private void fireNdefEvent(String type, Ndef ndef, Parcelable[] messages) {\n+    // Send the event data through a channel so the JavaScript side can fire the event\n+    private void sendEvent(String type, JSONObject tag) {\n \n-        JSONObject jsonObject = buildNdefJSON(ndef, messages);\n-        String tag = jsonObject.toString();\n+        try {\n+            JSONObject event = new JSONObject();\n+            event.put(\"type\", type);       // TAG_DEFAULT, NDEF, NDEF_MIME, NDEF_FORMATABLE\n+            event.put(\"tag\", tag);         // JSON representing the NFC tag and NDEF messages\n \n-        String command = MessageFormat.format(javaScriptEventTemplate, type, tag);\n-        Log.v(TAG, command);\n-        this.webView.sendJavascript(command);\n+            PluginResult result = new PluginResult(PluginResult.Status.OK, event);\n+            result.setKeepCallback(true);\n+            channelCallback.sendPluginResult(result);\n+        } catch (JSONException e) {\n+            Log.e(TAG, \"Error sending NFC event through the channel\", e);\n+        }\n \n     }\n \n-    private void fireNdefFormatableEvent (Tag tag) {\n-\n-        String command = MessageFormat.format(javaScriptEventTemplate, NDEF_FORMATABLE, Util.tagToJSON(tag));\n-        Log.v(TAG, command);\n-        this.webView.sendJavascript(command);\n+    private void fireNdefEvent(String type, Ndef ndef, Parcelable[] messages) {\n+        JSONObject json = buildNdefJSON(ndef, messages);\n+        sendEvent(type, json);\n     }\n \n-    private void fireTagEvent (Tag tag) {\n+    private void fireNdefFormatableEvent(Tag tag) {\n+        sendEvent(NDEF_FORMATABLE, Util.tagToJSON(tag));\n+    }\n \n-        String command = MessageFormat.format(javaScriptEventTemplate, TAG_DEFAULT, Util.tagToJSON(tag));\n-        Log.v(TAG, command);\n-        this.webView.sendJavascript(command);\n+    private void fireTagEvent(Tag tag) {\n+        sendEvent(TAG_DEFAULT, Util.tagToJSON(tag));\n     }\n \n-    JSONObject buildNdefJSON(Ndef ndef, Parcelable[] messages) {\n+    private JSONObject buildNdefJSON(Ndef ndef, Parcelable[] messages) {\n \n         JSONObject json = Util.ndefToJSON(ndef);\n \n@@ -741,13 +814,6 @@ public void onResume(boolean multitasking) {\n         startNfc();\n     }\n \n-    @Override\n-    public void onReset() {\n-        super.onReset();\n-        intentFilters.clear();\n-        techLists.clear();\n-    }\n-\n     @Override\n     public void onNewIntent(Intent intent) {\n         Log.d(TAG, \"onNewIntent \" + intent);\n@@ -769,12 +835,6 @@ private void setIntent(Intent intent) {\n         getActivity().setIntent(intent);\n     }\n \n-    String javaScriptEventTemplate =\n-        \"var e = document.createEvent(''Events'');\\n\" +\n-        \"e.initEvent(''{0}'');\\n\" +\n-        \"e.tag = {1};\\n\" +\n-        \"document.dispatchEvent(e);\";\n-\n     @Override\n     public void onNdefPushComplete(NfcEvent event) {\n \n@@ -790,4 +850,180 @@ public void onNdefPushComplete(NfcEvent event) {\n         }\n \n     }\n+\n+    /**\n+     * Enable I/O operations to the tag from this TagTechnology object.\n+     * *\n+     *\n+     * @param tech            TagTechnology class name e.g. 'android.nfc.tech.IsoDep' or 'android.nfc.tech.NfcV'\n+     * @param timeout         tag timeout\n+     * @param callbackContext Cordova callback context\n+     */\n+    private void connect(final String tech, final int timeout, final CallbackContext callbackContext) {\n+        this.cordova.getThreadPool().execute(() -> {\n+            try {\n+\n+                Tag tag = getIntent().getParcelableExtra(NfcAdapter.EXTRA_TAG);\n+                if (tag == null && savedIntent != null) {\n+                    tag = savedIntent.getParcelableExtra(NfcAdapter.EXTRA_TAG);\n+                }\n+\n+                if (tag == null) {\n+                    Log.e(TAG, \"No Tag\");\n+                    callbackContext.error(\"No Tag\");\n+                    return;\n+                }\n+\n+                JSONObject resultObject = new JSONObject();\n+\n+                // get technologies supported by this tag\n+                List<String> techList = Arrays.asList(tag.getTechList());\n+                if (techList.contains(tech)) {\n+                    // use reflection to call the static function Tech.get(tag)\n+                    tagTechnologyClass = Class.forName(tech);\n+                    Method method = tagTechnologyClass.getMethod(\"get\", Tag.class);\n+                    tagTechnology = (TagTechnology) method.invoke(null, tag);\n+\n+                    // If the tech supports it, return maxTransceiveLength and return it to the user\n+                    try {\n+                        Method maxTransceiveLengthMethod = tagTechnologyClass.getMethod(\"getMaxTransceiveLength\");\n+                        resultObject.put(\"maxTransceiveLength\", maxTransceiveLengthMethod.invoke(tagTechnology));\n+                    } catch(NoSuchMethodException e) {\n+                        // Some technologies do not support this, so just ignore.\n+                    } catch(JSONException e) {\n+                        Log.e(TAG, \"Error serializing JSON\", e);\n+                    }\n+                }\n+\n+                if (tagTechnology == null) {\n+                    callbackContext.error(\"Tag does not support \" + tech);\n+                    return;\n+                }\n+\n+                tagTechnology.connect();\n+                setTimeout(timeout);\n+                callbackContext.success(resultObject);\n+\n+            } catch (IOException ex) {\n+                Log.e(TAG, \"Tag connection failed\", ex);\n+                callbackContext.error(\"Tag connection failed\");\n+\n+                // Users should never get these reflection errors\n+            } catch (ClassNotFoundException e) {\n+                Log.e(TAG, e.getMessage(), e);\n+                callbackContext.error(e.getMessage());\n+            } catch (NoSuchMethodException e) {\n+                Log.e(TAG, e.getMessage(), e);\n+                callbackContext.error(e.getMessage());\n+            } catch (IllegalAccessException e) {\n+                Log.e(TAG, e.getMessage(), e);\n+                callbackContext.error(e.getMessage());\n+            } catch (InvocationTargetException e) {\n+                Log.e(TAG, e.getMessage(), e);\n+                callbackContext.error(e.getMessage());\n+            }\n+        });\n+    }\n+\n+    // Call tagTech setTimeout with reflection or fail silently\n+    private void setTimeout(int timeout) {\n+        if (timeout < 0) {\n+            return;\n+        }\n+        try {\n+            Method setTimeout = tagTechnologyClass.getMethod(\"setTimeout\", int.class);\n+            setTimeout.invoke(tagTechnology, timeout);\n+        } catch (NoSuchMethodException e) {\n+            // ignore\n+        } catch (IllegalAccessException e) {\n+            // ignore\n+        } catch (InvocationTargetException e) {\n+            // ignore\n+        }\n+    }\n+\n+    /**\n+     * Disable I/O operations to the tag from this TagTechnology object, and release resources.\n+     *\n+     * @param callbackContext Cordova callback context\n+     */\n+    private void close(CallbackContext callbackContext) {\n+        cordova.getThreadPool().execute(() -> {\n+            try {\n+\n+                if (tagTechnology != null && tagTechnology.isConnected()) {\n+                    tagTechnology.close();\n+                    tagTechnology = null;\n+                    callbackContext.success();\n+                } else {\n+                    // connection already gone\n+                    callbackContext.success();\n+                }\n+\n+            } catch (IOException ex) {\n+                Log.e(TAG, \"Error closing nfc connection\", ex);\n+                callbackContext.error(\"Error closing nfc connection \" + ex.getLocalizedMessage());\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Send raw commands to the tag and receive the response.\n+     *\n+     * @param data            byte[] command to be passed to the tag\n+     * @param callbackContext Cordova callback context\n+     */\n+    private void transceive(final byte[] data, final CallbackContext callbackContext) {\n+        cordova.getThreadPool().execute(() -> {\n+            try {\n+                if (tagTechnology == null) {\n+                    Log.e(TAG, \"No Tech\");\n+                    callbackContext.error(\"No Tech\");\n+                    return;\n+                }\n+                if (!tagTechnology.isConnected()) {\n+                    Log.e(TAG, \"Not connected\");\n+                    callbackContext.error(\"Not connected\");\n+                    return;\n+                }\n+\n+                // Use reflection so we can support many tag types\n+                Method transceiveMethod = tagTechnologyClass.getMethod(\"transceive\", byte[].class);\n+                @SuppressWarnings(\"PrimitiveArrayArgumentToVarargsMethod\")\n+                byte[] response = (byte[]) transceiveMethod.invoke(tagTechnology, data);\n+\n+                callbackContext.success(response);\n+\n+            } catch (NoSuchMethodException e) {\n+                String error = \"TagTechnology \" + tagTechnologyClass.getName() + \" does not have a transceive function\";\n+                Log.e(TAG, error, e);\n+                callbackContext.error(error);\n+            } catch (NullPointerException e) {\n+                // This can happen if the tag has been closed while we're still working with it from the thread pool.\n+                Log.e(TAG, e.getMessage(), e);\n+                callbackContext.error(e.getMessage());\n+            } catch (IllegalAccessException e) {\n+                Log.e(TAG, e.getMessage(), e);\n+                callbackContext.error(e.getMessage());\n+            } catch (InvocationTargetException e) {\n+                Log.e(TAG, e.getMessage(), e);\n+                Throwable cause = e.getCause();\n+                callbackContext.error(cause.getMessage());\n+            }\n+        });\n+    }\n+\n }\n+© 2021 GitHub, Inc.\n+Terms\n+Privacy\n+Security\n+Status\n+Docs\n+Contact GitHub\n+Pricing\n+API\n+Training\n+Blog\n+About\n+"
  }
]
