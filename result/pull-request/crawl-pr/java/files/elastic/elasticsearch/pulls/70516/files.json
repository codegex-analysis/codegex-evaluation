[
  {
    "sha": "d890e2cfdf6b2e8983662a33e65e53172ec518c4",
    "filename": "docs/reference/glossary.asciidoc",
    "status": "modified",
    "additions": 307,
    "deletions": 444,
    "changes": 751,
    "blob_url": "https://github.com/elastic/elasticsearch/blob/6df32797604c7f3a62b4b997e2501cb4c1d4f199/docs/reference/glossary.asciidoc",
    "raw_url": "https://github.com/elastic/elasticsearch/raw/6df32797604c7f3a62b4b997e2501cb4c1d4f199/docs/reference/glossary.asciidoc",
    "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/docs/reference/glossary.asciidoc?ref=6df32797604c7f3a62b4b997e2501cb4c1d4f199",
    "patch": "@@ -1,670 +1,533 @@\n+////\n+============\n+IMPORTANT\n+Add new terms to the Stack Docs glossary:\n+https://github.com/elastic/stack-docs/tree/master/docs/en/glossary\n+============\n+////\n+\n [glossary]\n [[glossary]]\n = Glossary of terms\n \n [glossary]\n-[[glossary-analysis]] analysis ::\n-+\n---\n+[[glossary-analysis]] analysis::\n // tag::analysis-def[]\n-Analysis is the process of converting <<glossary-text,full text>> to\n-<<glossary-term,terms>>. Depending on which analyzer is used, these phrases:\n-`FOO BAR`, `Foo-Bar`, `foo,bar` will probably all result in the\n-terms `foo` and `bar`. These terms are what is actually stored in\n-the index.\n-\n-A full text query (not a <<glossary-term,term>> query) for `FoO:bAR` will\n-also be analyzed to the terms `foo`,`bar` and will thus match the\n-terms stored in the index.\n-\n-It is this process of analysis (both at index time and at search time)\n-that allows Elasticsearch to perform full text queries.\n-\n-Also see <<glossary-text,text>> and <<glossary-term,term>>.\n+Process of converting unstructured <<glossary-text,text>> into a format\n+optimized for search. See {ref}/analysis.html[Text analysis].\n // end::analysis-def[]\n---\n \n-[[glossary-api-key]] API key ::\n+[[glossary-api-key]] API key::\n // tag::api-key-def[]\n-A unique identifier that you can use for authentication when submitting {es} requests.\n-When TLS is enabled, all requests must be authenticated using either basic authentication\n-(user name and password) or an API key.\n+Unique identifier for authentication in {es}. When\n+{ref}/encrypting-communications.html[transport layer security (TLS)] is enabled,\n+all requests must be authenticated using an API key or a username and password.\n+See the {ref}/security-api-create-api-key.html[Create API key API].\n // end::api-key-def[]\n \n-\n-[[glossary-auto-follow-pattern]] auto-follow pattern ::\n+[[glossary-auto-follow-pattern]] auto-follow pattern::\n // tag::auto-follow-pattern-def[]\n-An <<glossary-index-pattern,index pattern>> that automatically configures new indices as\n-<<glossary-follower-index,follower indices>> for <<glossary-ccr,{ccr}>>.\n-For more information, see {ref}/ccr-auto-follow.html[Managing auto follow patterns].\n+<<glossary-index-pattern,Index pattern>> that automatically configures new\n+<<glossary-index,indices>> as <<glossary-follower-index,follower indices>> for\n+<<glossary-ccr,{ccr}>>. See {ref}/ccr-auto-follow.html[Manage auto-follow\n+patterns].\n // end::auto-follow-pattern-def[]\n \n-[[glossary-cluster]] cluster ::\n+[[glossary-cluster]] cluster::\n // tag::cluster-def[]\n-One or more <<glossary-node,nodes>> that share the\n-same cluster name. Each cluster has a single master node, which is\n-chosen automatically by the cluster and can be replaced if it fails.\n+A group of one or more connected {es} <<glossary-node,nodes>>. See\n+{ref}/scalability.html[Clusters, nodes, and shards].\n // end::cluster-def[]\n \n-[[glossary-cold-phase]] cold phase ::\n+[[glossary-cold-phase]] cold phase::\n // tag::cold-phase-def[]\n-The third possible phase in the <<glossary-index-lifecycle,index lifecycle>>.\n-In the cold phase, an index is no longer updated and seldom queried.\n-The information still needs to be searchable, but it’s okay if those queries are slower.\n+Third possible phase in the <<glossary-index-lifecycle,index lifecycle>>. In the\n+cold phase, data is no longer updated and seldom <<glossary-query,queried>>. The\n+data still needs to be searchable, but it’s okay if those queries are slower.\n+See {ref}/ilm-index-lifecycle.html[Index lifecycle].\n // end::cold-phase-def[]\n \n [[glossary-cold-tier]] cold tier::\n // tag::cold-tier-def[]\n-A <<glossary-data-tier, data tier>> that contains nodes that hold time series data\n-that is accessed occasionally and not normally updated.\n+<<glossary-data-tier,Data tier>> that contains <<glossary-node,nodes>> that hold\n+time series data that is accessed occasionally and not normally updated. See\n+{ref}/data-tiers.html[Data tiers].\n // end::cold-tier-def[]\n \n-[[glossary-component-template]] component template ::\n+[[glossary-component-template]] component template::\n // tag::component-template-def[]\n-A building block for constructing <<index-templates,index templates>> that specifies index\n-<<mapping,mappings>>, <<index-modules-settings,settings>>, and <<indices-aliases,aliases>>.\n+Building block for creating <<glossary-index-template,index templates>>. A\n+component template can specify <<glossary-mapping,mappings>>,\n+{ref}/index-modules.html[index settings], and <<glossary-index-alias,index\n+aliases>>. See {ref}/index-templates.html[index templates].\n // end::component-template-def[]\n \n [[glossary-content-tier]] content tier::\n // tag::content-tier-def[]\n-A <<glossary-data-tier, data tier>> that contains nodes that handle the indexing and query load for\n-content such as a product catalog.\n+<<glossary-data-tier,Data tier>> that contains <<glossary-node,nodes>> that\n+handle the <<glossary-index,indexing>> and <<glossary-query,query>> load for\n+content, such as a product catalog. See {ref}/data-tiers.html[Data tiers].\n // end::content-tier-def[]\n \n-[[glossary-ccr]] {ccr} (CCR)::\n+[[glossary-ccr]] {ccr} ({ccr-init})::\n // tag::ccr-def[]\n-A feature that enables you to replicate indices in remote clusters to your\n-local cluster. For more information, see\n-{ref}/xpack-ccr.html[{ccr-cap}].\n+Replicates <<glossary-data-stream,data streams>> and <<glossary-index,indices>>\n+from <<glossary-remote-cluster,remote clusters>> in a\n+<<glossary-local-cluster,local cluster>>. See {ref}/xpack-ccr.html[{ccr-cap}].\n // end::ccr-def[]\n \n [[glossary-ccs]] {ccs} (CCS)::\n // tag::ccs-def[]\n-A feature that enables any node to act as a federated client across\n-multiple clusters.\n-See {ref}/modules-cross-cluster-search.html[Search across clusters].\n+Searches <<glossary-data-stream,data streams>> and <<glossary-index,indices>> on\n+<<glossary-remote-cluster,remote clusters>> from a\n+<<glossary-local-cluster,local cluster>>. See\n+{ref}/modules-cross-cluster-search.html[Search across clusters].\n // end::ccs-def[]\n \n-[[glossary-data-stream]] data stream ::\n-+\n---\n+[[glossary-data-stream]] data stream::\n // tag::data-stream-def[]\n-A named resource used to ingest, search, and manage time series data in {es}. A\n-data stream's data is stored across multiple hidden, auto-generated\n-<<glossary-index,indices>>. You can automate management of these indices to more\n-efficiently store large data volumes.\n-\n-See {ref}/data-streams.html[Data streams].\n+Named resource used to manage time series data. A data stream stores data across\n+multiple backing <<glossary-index,indices>>. See {ref}/data-streams.html[Data\n+streams].\n // end::data-stream-def[]\n---\n \n [[glossary-data-tier]] data tier::\n // tag::data-tier-def[]\n-A collection of nodes with the same data role that typically share the same hardware profile.\n-See <<glossary-content-tier, content tier>>, <<glossary-hot-tier, hot tier>>, <<glossary-warm-tier, warm tier>>,\n-<<glossary-cold-tier, cold tier>>.\n+Collection of <<glossary-node,nodes>> with the same {ref}/modules-node.html[data\n+role] that typically share the same hardware profile. Data tiers include the\n+<<glossary-content-tier, content tier>>, <<glossary-hot-tier, hot tier>>,\n+<<glossary-warm-tier, warm tier>>, <<glossary-cold-tier, cold tier>>, and\n+{ref}/glossary.html#glossary-frozen-tier[frozen tier]. See\n+{ref}/data-tiers.html[Data tiers].\n // end::data-tier-def[]\n \n-[[glossary-delete-phase]] delete phase ::\n+[[glossary-delete-phase]] delete phase::\n // tag::delete-phase-def[]\n-The last possible phase in the <<glossary-index-lifecycle,index lifecycle>>.\n-In the delete phase, an index is no longer needed and can safely be deleted.\n+Last possible phase in the <<glossary-index-lifecycle,index lifecycle>>. In the\n+delete phase, an <<glossary-index,index>> is no longer needed and can safely be\n+deleted. See {ref}/ilm-index-lifecycle.html[Index lifecycle].\n // end::delete-phase-def[]\n \n-[[glossary-document]] document ::\n-+\n---\n+[[glossary-document]] document::\n // tag::document-def[]\n-A document is a JSON document which is stored in Elasticsearch. It is\n-like a row in a table in a relational database. Each document is\n-stored in an <<glossary-index,index>> and has a type\n-and an <<glossary-id,id>>.\n-\n-A document is a JSON object (also known in other languages as a hash /\n-hashmap / associative array) which contains zero or more\n-<<glossary-field,fields>>, or key-value pairs.\n-\n-The original JSON document that is indexed will be stored in the\n-<<glossary-source_field,`_source` field>>, which is returned by default when\n-getting or searching for a document.\n+JSON object containing data stored in {es}. See\n+{ref}/documents-indices.html[Documents and indices].\n // end::document-def[]\n---\n \n [[glossary-eql]]\n-Event Query Language (EQL) ::\n+Event Query Language (EQL)::\n // tag::eql-def[]\n-A query language for event-based time series data, such as logs, metrics, and\n-traces. EQL supports matching for event sequences. In the {security-app}, you\n-use EQL to write event correlation rules. See {ref}/eql.html[EQL].\n+<<glossary-query,Query>> language for event-based time series data, such as\n+logs, metrics, and traces. EQL supports matching for event sequences. See\n+{ref}/eql.html[EQL].\n // end::eql-def[]\n \n-[[glossary-field]] field ::\n-+\n---\n+[[glossary-field]] field::\n // tag::field-def[]\n-A <<glossary-document,document>> contains a list of fields, or key-value\n-pairs. The value can be a simple (scalar) value (eg a string, integer,\n-date), or a nested structure like an array or an object. A field is\n-similar to a column in a table in a relational database.\n-\n-The <<glossary-mapping,mapping>> for each field has a field _type_ (not to\n-be confused with document type) which indicates the type\n-of data that can be stored in that field, eg `integer`, `string`,\n-`object`. The mapping also allows you to define (amongst other things)\n-how the value for a field should be analyzed.\n+Key-value pair in a <<glossary-document,document>>. See\n+{ref}/mapping.html[Mapping].\n // end::field-def[]\n---\n \n-[[glossary-filter]] filter ::\n+[[glossary-filter]] filter::\n // tag::filter-def[]\n-A filter is a non-scoring <<glossary-query,query>>,\n-meaning that it does not score documents.\n-It is only concerned about answering the question - \"Does this document match?\".\n-The answer is always a simple, binary yes or no. This kind of query is said to be made\n-in a {ref}/query-filter-context.html[filter context],\n-hence it is called a filter. Filters are simple checks for set inclusion or exclusion.\n-In most cases, the goal of filtering is to reduce the number of documents that have to be examined.\n+<<glossary-query,Query>> that does not score matching documents. See\n+{ref}/query-filter-context.html[filter context].\n // end::filter-def[]\n \n-[[glossary-flush]] flush ::\n+[[glossary-flush]] flush::\n // tag::flush-def[]\n-Peform a Lucene commit to write index updates in the transaction log (translog) to disk.\n-Because a Lucene commit is a relatively expensive operation,\n-{es} records index and delete operations in the translog and\n-automatically flushes changes to disk in batches.\n-To recover from a crash, operations that have been acknowledged but not yet committed\n-can be replayed from the translog.\n-Before upgrading, you can explicitly call the {ref}/indices-flush.html[Flush] API\n-to ensure that all changes are committed to disk.\n+Writes data from the {ref}/index-modules-translog.html[transaction log] to disk\n+for permanent storage. See the {ref}/indices-flush.html[flush API].\n // end::flush-def[]\n \n-[[glossary-follower-index]] follower index ::\n+[[glossary-follower-index]] follower index::\n // tag::follower-index-def[]\n-The target index for <<glossary-ccr,{ccr}>>. A follower index exists\n-in a local cluster and replicates a <<glossary-leader-index,leader index>>.\n+Target <<glossary-index,index>> for <<glossary-ccr,{ccr}>>. A follower index\n+exists in a <<glossary-local-cluster,local cluster>> and replicates a\n+<<glossary-leader-index,leader index>>. See {ref}/xpack-ccr.html[{ccr-cap}].\n // end::follower-index-def[]\n \n-[[glossary-force-merge]] force merge ::\n+[[glossary-force-merge]] force merge::\n // tag::force-merge-def[]\n // tag::force-merge-def-short[]\n-Manually trigger a merge to reduce the number of segments in each shard of an index\n-and free up the space used by deleted documents.\n+Manually triggers a <<glossary-merge,merge>> to reduce the number of\n+<<glossary-segment,segments>> in an index's <<glossary-shard,shards>>.\n // end::force-merge-def-short[]\n-You should not force merge indices that are actively being written to.\n-Merging is normally performed automatically, but you can use force merge after\n-<<glossary-rollover,rollover>> to reduce the shards in the old index to a single segment.\n See the {ref}/indices-forcemerge.html[force merge API].\n // end::force-merge-def[]\n \n-[[glossary-freeze]] freeze ::\n+[[glossary-freeze]] freeze::\n // tag::freeze-def[]\n // tag::freeze-def-short[]\n-Make an index read-only and minimize its memory footprint.\n+Makes an index read-only and minimizes its memory footprint.\n // end::freeze-def-short[]\n-Frozen indices can be searched without incurring the overhead of re-opening a closed index,\n-but searches are throttled and might be slower.\n-You can freeze indices to reduce the overhead of keeping older indices searchable\n-before you are ready to archive or delete them.\n See the {ref}/freeze-index-api.html[freeze API].\n // end::freeze-def[]\n \n-[[glossary-frozen-index]] frozen index ::\n+[[glossary-frozen-index]] frozen index::\n // tag::frozen-index-def[]\n-An index reduced to a low overhead state that still enables occasional searches.\n-Frozen indices use a memory-efficient shard implementation and throttle searches to conserve resources.\n-Searching a frozen index is lower overhead than re-opening a closed index to enable searching.\n+An <<glossary-index,index>> reduced to a low overhead state that still enables\n+occasional searches.\n+See the {ref}/freeze-index-api.html[freeze API].\n // end::frozen-index-def[]\n \n-[[glossary-frozen-phase]] frozen phase ::\n+[[glossary-frozen-phase]] frozen phase::\n // tag::frozen-phase-def[]\n-The fourth possible phase in the <<glossary-index-lifecycle,index lifecycle>>.\n-In the frozen phase, an index is no longer updated and queried rarely.\n-The information still needs to be searchable, but it’s okay if those queries are extremely slow.\n+Fourth possible phase in the <<glossary-index-lifecycle,index lifecycle>>. In\n+the frozen phase, an <<glossary-index,index>> is no longer updated and\n+<<glossary-query,queried>> rarely. The information still needs to be searchable,\n+but it’s okay if those queries are extremely slow. See\n+{ref}/ilm-index-lifecycle.html[Index lifecycle].\n // end::frozen-phase-def[]\n \n [[glossary-frozen-tier]] frozen tier::\n // tag::frozen-tier-def[]\n-A <<glossary-data-tier, data tier>> that contains nodes that hold time series data\n-that is accessed rarely and not normally updated.\n+<<glossary-data-tier,Data tier>> that contains <<glossary-node,nodes>> that\n+hold time series data that is accessed rarely and not normally updated. See\n+{ref}/data-tiers.html[Data tiers].\n // end::frozen-tier-def[]\n \n-[[glossary-hidden-index]] hidden index ::\n+[[glossary-hidden-index]] hidden data stream or index::\n // tag::hidden-index-def[]\n-An index that is excluded by default when you access indices using a wildcard expression.\n-You can specify the `expand_wildcards` parameter to include hidden indices.\n-Note that hidden indices _are_ included if the wildcard expression starts with a dot, for example `.watcher-history*`.\n+<<glossary-data-stream,Data stream>> or <<glossary-index,index>> excluded from\n+most <<glossary-index-pattern,index patterns>> by default. See\n+{ref}/multi-index.html#hidden-indices[Hidden data streams and indices].\n // end::hidden-index-def[]\n \n-[[glossary-hot-phase]] hot phase ::\n+[[glossary-hot-phase]] hot phase::\n // tag::hot-phase-def[]\n-The first possible phase in the <<glossary-index-lifecycle,index lifecycle>>.\n-In the hot phase, an index is actively updated and queried.\n+First possible phase in the <<glossary-index-lifecycle,index lifecycle>>. In\n+the hot phase, an <<glossary-index,index>> is actively updated and queried. See\n+{ref}/ilm-index-lifecycle.html[Index lifecycle].\n // end::hot-phase-def[]\n \n [[glossary-hot-tier]] hot tier::\n // tag::hot-tier-def[]\n-A <<glossary-data-tier, data tier>> that contains nodes that handle the indexing load\n-for time series data such as logs or metrics and hold your most recent,\n-most-frequently-accessed data.\n+<<glossary-data-tier,Data tier>> that contains <<glossary-node,nodes>> that\n+handle the <<glossary-index,indexing>> load for time series data, such as logs or\n+metrics. This tier holds your most recent, most frequently accessed data. See\n+{ref}/data-tiers.html[Data tiers].\n // end::hot-tier-def[]\n \n-[[glossary-id]] id ::\n+[[glossary-id]] ID::\n // tag::id-def[]\n-The ID of a <<glossary-document,document>> identifies a document. The\n-`index/id` of a document must be unique. If no ID is provided,\n-then it will be auto-generated. (also see <<glossary-routing,routing>>)\n+Identifier for a <<glossary-document,document>>. Document IDs must be unique\n+within an <<glossary-index,index>>. See the {ref}/mapping-id-field.html[`_id`\n+field].\n // end::id-def[]\n \n-[[glossary-index]] index ::\n-+\n---\n+[[glossary-index]] index::\n // tag::index-def[]\n-// tag::index-def-short[]\n-An optimized collection of JSON documents. Each document is a collection of fields,\n-the key-value pairs that contain your data.\n-// end::index-def-short[]\n-\n-An index is a logical namespace that maps to one or more\n-<<glossary-primary-shard,primary shards>> and can have zero or more\n-<<glossary-replica-shard,replica shards>>.\n+. Collection of JSON <<glossary-document,documents>>. See\n+{ref}/documents-indices.html[Documents and indices].\n+\n+. To add one or more JSON documents to {es}. This process is called indexing.\n // end::index-def[]\n---\n \n-[[glossary-index-alias]] index alias ::\n-+\n---\n+[[glossary-index-alias]] index alias::\n // tag::index-alias-def[]\n-// tag::index-alias-desc[]\n-An index alias is a logical name used to reference one or more indices.\n-\n-Most {es} APIs accept an index alias in place of an index name.\n-// end::index-alias-desc[]\n-\n-See {ref}/indices-add-alias.html[Create or update index alias API].\n+Secondary name for one or more <<glossary-index,indices>>. Most {es} APIs accept\n+an index alias in place of an index name. See the\n+{ref}/indices-add-alias.html[Create or update index alias API].\n // end::index-alias-def[]\n---\n \n-[[glossary-index-lifecycle]] index lifecycle ::\n+[[glossary-index-lifecycle]] index lifecycle::\n // tag::index-lifecycle-def[]\n-The four phases an index can transition through:\n+Five phases an <<glossary-index,index>> can transition through:\n <<glossary-hot-phase,hot>>, <<glossary-warm-phase,warm>>,\n-<<glossary-cold-phase,cold>>, and <<glossary-delete-phase,delete>>.\n-For more information, see {ref}/ilm-policy-definition.html[Index lifecycle].\n+<<glossary-cold-phase,cold>>, {ref}/glossary.html#glossary-frozen-phase[frozen],\n+and <<glossary-delete-phase,delete>>. See {ref}/ilm-policy-definition.html[Index\n+lifecycle].\n // end::index-lifecycle-def[]\n \n-[[glossary-index-lifecycle-policy]] index lifecycle policy ::\n+[[glossary-index-lifecycle-policy]] index lifecycle policy::\n // tag::index-lifecycle-policy-def[]\n-Specifies how an index moves between phases in the index lifecycle and\n-what actions to perform during each phase.\n+Specifies how an <<glossary-index,index>> moves between phases in the\n+<<glossary-index-lifecycle,index lifecycle>> and what actions to perform during\n+each phase. See {ref}/ilm-policy-definition.html[Index lifecycle].\n // end::index-lifecycle-policy-def[]\n \n-[[glossary-index-pattern]] index pattern ::\n+[[glossary-index-pattern]] index pattern::\n // tag::index-pattern-def[]\n-A string that can contain the `*` wildcard to match multiple index names.\n-In most cases, the index parameter in an {es} request can be the name of a specific index,\n-a list of index names, or an index pattern.\n-For example, if you have the indices `datastream-000001`, `datastream-000002`, and `datastream-000003`,\n-to search across all three you could use the `datastream-*` index pattern.\n+String containing a wildcard (`*`) pattern that can match multiple\n+<<glossary-data-stream,data streams>>, <<glossary-index,indices>>, or\n+<<glossary-index-alias,index aliases>>. See {ref}/multi-index.html[Multi-target\n+syntax].\n // end::index-pattern-def[]\n \n-[[glossary-index-template]] index template ::\n-+\n---\n+[[glossary-index-template]] index template::\n // tag::index-template-def[]\n-// tag::index-template-def-short[]\n-Defines settings and mappings to apply to new indexes that match a simple naming pattern, such as _logs-*_.\n-// end::index-template-def-short[]\n-\n-An index template can also attach a lifecycle policy to the new index.\n-Index templates are used to automatically configure indices created during <<glossary-rollover,rollover>>.\n+Automatically configures the <<glossary-mapping,mappings>>,\n+{ref}/index-modules.html[index settings], and <<glossary-index-alias,aliases>>\n+of new <<glossary-index,indices>> that match its <<glossary-index-pattern,index\n+pattern>>. You can also use index templates to create\n+<<glossary-data-stream,data streams>>. See {ref}/index-templates.html[Index\n+templates].\n // end::index-template-def[]\n---\n \n-[[glossary-leader-index]] leader index ::\n+[[glossary-leader-index]] leader index::\n // tag::leader-index-def[]\n-The source index for <<glossary-ccr,{ccr}>>. A leader index exists\n-on a remote cluster and is replicated to\n-<<glossary-follower-index,follower indices>>.\n+Source <<glossary-index,index>> for <<glossary-ccr,{ccr}>>. A leader index\n+exists on a <<glossary-remote-cluster,remote cluster>> and is replicated to\n+<<glossary-follower-index,follower indices>>. See\n+{ref}/xpack-ccr.html[{ccr-cap}].\n // end::leader-index-def[]\n \n-[[glossary-local-cluster]] local cluster ::\n+[[glossary-local-cluster]] local cluster::\n // tag::local-cluster-def[]\n-The cluster that pulls data from a <<glossary-remote-cluster,remote cluster>> in {ccs} or {ccr}.\n+<<glossary-cluster,Cluster>> that pulls data from a\n+<<glossary-remote-cluster,remote cluster>> in <<glossary-ccs,{ccs}>> or\n+<<glossary-ccr,{ccr}>>. See {ref}/modules-remote-clusters.html[Remote clusters].\n // end::local-cluster-def[]\n \n-[[glossary-mapping]] mapping ::\n-+\n---\n+[[glossary-mapping]] mapping::\n // tag::mapping-def[]\n-A mapping is like a _schema definition_ in a relational database. Each\n-<<glossary-index,index>> has a mapping,\n-which defines a type,\n-plus a number of index-wide settings.\n-\n-A mapping can either be defined explicitly, or it will be generated\n-automatically when a document is indexed.\n+Defines how a <<glossary-document,document>>, its <<glossary-field,fields>>, and\n+its metadata are stored in {es}. Similar to a schema definition. See\n+{ref}/mapping.html[Mapping].\n // end::mapping-def[]\n---\n \n-[[glossary-node]] node ::\n+[[glossary-merge]] merge::\n+// tag::merge-def[]\n+Process of combining a <<glossary-shard,shard>>'s smaller Lucene\n+<<glossary-segment,segments>> into a larger one. {es} manages merges\n+automatically.\n+// end::merge-def[]\n+\n+[[glossary-node]] node::\n // tag::node-def[]\n-A running instance of {es} that belongs to a\n-<<glossary-cluster,cluster>>. Multiple nodes can be started on a single\n-server for testing purposes, but usually you should have one node per\n-server.\n+A single {es} server. One or more nodes can form a <<glossary-cluster,cluster>>.\n+See {ref}/scalability.html[Clusters, nodes, and shards].\n // end::node-def[]\n \n-[[glossary-primary-shard]] primary shard ::\n-+\n---\n+[[glossary-primary-shard]] primary shard::\n // tag::primary-shard-def[]\n-Each document is stored in a single primary <<glossary-shard,shard>>. When\n-you index a document, it is indexed first on the primary shard, then\n-on all <<glossary-replica-shard,replicas>> of the primary shard.\n-\n-By default, an <<glossary-index,index>> has one primary shard. You can specify\n-more primary shards to scale the number of <<glossary-document,documents>>\n-that your index can handle.\n-\n-You cannot change the number of primary shards in an index, once the index is\n-created. However, an index can be split into a new index using the\n-{ref}/indices-split-index.html[split index API].\n-\n-See also <<glossary-routing,routing>>.\n+Lucene instance containing some or all data for an <<glossary-index,index>>.\n+When you index a <<glossary-document,document>>, {es} adds the document to\n+primary shards before <<glossary-replica-shard,replica shards>>. See\n+{ref}/scalability.html[Clusters, nodes, and shards].\n // end::primary-shard-def[]\n---\n \n-[[glossary-query]] query ::\n-+\n---\n+[[glossary-query]] query::\n // tag::query-def[]\n-A request for information from {es}. You can think of a query as a question,\n-written in a way {es} understands. A search consists of one or more queries\n-combined.\n-\n-There are two types of queries: _scoring queries_ and _filters_. For more\n-information about query types,\n-see {ref}/query-filter-context.html[Query and filter context].\n+Request for information about your data. You can think of a query as a\n+question, written in a way {es} understands. See\n+{ref}/search-your-data.html[Search your data].\n // end::query-def[]\n---\n \n-[[glossary-recovery]] recovery ::\n-+\n---\n+[[glossary-recovery]] recovery::\n // tag::recovery-def[]\n-Shard recovery is the process\n-of syncing a <<glossary-replica-shard,replica shard>>\n-from a <<glossary-primary-shard,primary shard>>.\n-Upon completion,\n-the replica shard is available for search.\n-\n-// tag::recovery-triggers[]\n-Recovery automatically occurs\n-during the following processes:\n-\n-* Node startup or failure.\n-  This type of recovery is called a *local store recovery*.\n-* <<glossary-replica-shard,Primary shard replication>>.\n-* Relocation of a shard to a different node in the same cluster.\n-* {ref}/snapshots-restore-snapshot.html[Snapshot restoration].\n-// end::recovery-triggers[]\n+Process of syncing a <<glossary-replica-shard,replica shard>> from a\n+<<glossary-primary-shard,primary shard>>. Upon completion, the replica shard is\n+available for searches. See the {ref}/indices-recovery.html[index recovery API].\n // end::recovery-def[]\n---\n \n-[[glossary-reindex]] reindex ::\n-+\n---\n+[[glossary-reindex]] reindex::\n // tag::reindex-def[]\n-Copies documents from a _source_ to a _destination_. The source and\n-destination can be any pre-existing index, index alias, or\n-{ref}/data-streams.html[data stream].\n-\n-You can reindex all documents from a source or select a subset of documents to\n-copy. You can also reindex to a destination in a remote cluster.\n-\n-A reindex is often performed to update mappings, change static index settings,\n-or upgrade {es} between incompatible versions.\n+Copies documents from a source to a destination. The source and destination can\n+be a <<glossary-data-stream,data stream>>, <<glossary-index,index>>, or\n+<<glossary-index-alias,index alias>>. See the {ref}/docs-reindex.html[Reindex\n+API].\n // end::reindex-def[]\n---\n-\n-[[glossary-remote-cluster]] remote cluster ::\n \n+[[glossary-remote-cluster]] remote cluster::\n // tag::remote-cluster-def[]\n-A separate cluster, often in a different data center or locale, that contains indices that\n-can be replicated or searched by the <<glossary-local-cluster,local cluster>>.\n-The connection to a remote cluster is unidirectional.\n+A separate <<glossary-cluster,cluster>>, often in a different data center or\n+locale, that contains <<glossary-index,indices>> that can be replicated or\n+searched by the <<glossary-local-cluster,local cluster>>. The connection to a\n+remote cluster is unidirectional. See {ref}/modules-remote-clusters.html[Remote\n+clusters].\n // end::remote-cluster-def[]\n \n-[[glossary-replica-shard]] replica shard ::\n-+\n---\n+[[glossary-replica-shard]] replica shard::\n // tag::replica-shard-def[]\n-Each <<glossary-primary-shard,primary shard>> can have zero or more\n-replicas. A replica is a copy of the primary shard, and has two\n-purposes:\n-\n-1.  Increase failover: a replica shard can be promoted to a primary\n-shard if the primary fails\n-2.  Increase performance: get and search requests can be handled by\n-primary or replica shards.\n-\n-By default, each primary shard has one replica, but the number of\n-replicas can be changed dynamically on an existing index. A replica\n-shard will never be started on the same node as its primary shard.\n+Copy of a <<glossary-primary-shard,primary shard>>. Replica shards can improve\n+search performance and resiliency by distributing data across multiple\n+<<glossary-node,nodes>>. See {ref}/scalability.html[Clusters, nodes, and\n+shards].\n // end::replica-shard-def[]\n---\n \n-[[glossary-rollover]] rollover ::\n-+\n---\n+[[glossary-rollover]] rollover::\n // tag::rollover-def[]\n // tag::rollover-def-short[]\n-Creates a new index for a rollover target when the existing index reaches a certain size, number of docs, or age.\n-A rollover target can be either an <<indices-aliases, index alias>> or a <<data-streams, data stream>>.\n+Creates a new write index when the current one reaches a certain size, number of\n+docs, or age.\n // end::rollover-def-short[]\n-\n-For example, if you're indexing log data, you might use rollover to create daily or weekly indices.\n-See the {ref}/indices-rollover-index.html[rollover index API].\n+A rollover can target a <<data-streams, data stream>> or an\n+<<indices-aliases,index alias>> with a write index.\n // end::rollover-def[]\n---\n \n ifdef::permanently-unreleased-branch[]\n \n-[[glossary-rollup]] rollup ::\n+[[glossary-rollup]] rollup::\n // tag::rollup-def[]\n-Aggregates an index's time series data and stores the results in a new read-only\n-index. For example, you can roll up hourly data into daily or weekly summaries.\n-See {ref}/xpack-rollup.html[Roll up your data].\n+Aggregates an <<glossary-index,index>>'s time series data and stores the results\n+in a new read-only index. For example, you can roll up hourly data into daily or\n+weekly summaries. See {ref}/xpack-rollup.html[Rollups].\n // end::rollup-def[]\n \n endif::[]\n ifndef::permanently-unreleased-branch[]\n \n-[[glossary-rollup]] rollup ::\n+[[glossary-rollup]] rollup::\n // tag::rollup-def[]\n-Summarize high-granularity data into a more compressed format to\n-maintain access to historical data in a cost-effective way.\n+Summarizes high-granularity data into a more compressed format to maintain access\n+to historical data in a cost-effective way. See\n+{ref}/xpack-rollup.html[Roll up your data].\n // end::rollup-def[]\n \n-[[glossary-rollup-index]] rollup index ::\n+[[glossary-rollup-index]] rollup index::\n // tag::rollup-index-def[]\n-A special type of index for storing historical data at reduced granularity.\n-Documents are summarized and indexed into a rollup index by a <<glossary-rollup-job,rollup job>>.\n+Special type of <<glossary-index,index>> for storing historical data at reduced\n+granularity. Documents are summarized and indexed into a rollup index by a\n+<<glossary-rollup-job,rollup job>>. See {ref}/xpack-rollup.html[Rolling up\n+historical data].\n // end::rollup-index-def[]\n \n-[[glossary-rollup-job]] rollup job ::\n+[[glossary-rollup-job]] rollup job::\n // tag::rollup-job-def[]\n-A background task that runs continuously to summarize documents in an index and\n-index the summaries into a separate rollup index.\n-The job configuration controls what information is rolled up and how often.\n+Background task that runs continuously to summarize documents in an\n+<<glossary-index,index>> and index the summaries into a separate rollup index.\n+The job configuration controls what data is rolled up and how often. See\n+{ref}/xpack-rollup.html[Rolling up historical data].\n // end::rollup-job-def[]\n \n endif::[]\n \n-[[glossary-routing]] routing ::\n-+\n---\n+[[glossary-routing]] routing::\n // tag::routing-def[]\n-When you index a document, it is stored on a single\n-<<glossary-primary-shard,primary shard>>. That shard is chosen by hashing\n-the `routing` value. By default, the `routing` value is derived from\n-the ID of the document or, if the document has a specified parent\n-document, from the ID of the parent document (to ensure that child and\n-parent documents are stored on the same shard).\n-\n-This value can be overridden by specifying a `routing` value at index\n-time, or a {ref}/mapping-routing-field.html[routing field]\n-in the <<glossary-mapping,mapping>>.\n+Process of sending and retrieving data from a specific\n+<<glossary-primary-shard,primary shard>>. {es} uses a hashed routing value to\n+choose this shard. You can provide a routing value in\n+<<glossary-index,indexing>> and search requests to take advantage of caching.\n+See the {ref}/mapping-routing-field.html[`_routing` field].\n // end::routing-def[]\n---\n \n-[[glossary-runtime-fields]] runtime field ::\n+[[glossary-runtime-fields]] runtime field::\n // tag::runtime-fields-def[]\n-A runtime field is a field that is evaluated at query time. You access runtime\n-fields from the search API like any other field, and {es} sees runtime fields\n-no differently. You can define runtime fields in the\n-{ref}/runtime-mapping-fields.html[index mapping] or in the\n-{ref}/runtime-search-request.html[search request].\n+<<glossary-field,Field>> that is evaluated at query time. You access runtime\n+fields from the search API like any other field, and {es} sees runtime fields no\n+differently. See {ref}/runtime.html[Runtime fields].\n // end::runtime-fields-def[]\n \n-[[glossary-searchable-snapshot]] searchable snapshot ::\n+[[glossary-searchable-snapshot]] searchable snapshot::\n // tag::searchable-snapshot-def[]\n-A <<glossary-snapshot, snapshot>> of an index that has been mounted as a\n-<<glossary-searchable-snapshot-index, searchable snapshot index>> and can be\n-searched as if it were a regular index.\n+<<glossary-snapshot,Snapshot>> of an <<glossary-index,index>> mounted as a\n+<<glossary-searchable-snapshot-index,searchable snapshot index>>. You can search\n+this index like a regular index. See {ref}/searchable-snapshots.html[searchable\n+snapshots].\n // end::searchable-snapshot-def[]\n \n-[[glossary-searchable-snapshot-index]] searchable snapshot index ::\n+[[glossary-searchable-snapshot-index]] searchable snapshot index::\n // tag::searchable-snapshot-index-def[]\n-An <<glossary-index, index>> whose data is stored in a <<glossary-snapshot,\n-snapshot>> that resides in a separate <<glossary-snapshot-repository,snapshot\n-repository>> such as AWS S3. Searchable snapshot indices do not need\n-<<glossary-replica-shard,replica>> shards for resilience, since their data is\n-reliably stored outside the cluster.\n+<<glossary-index,Index>> whose data is stored in a\n+<<glossary-snapshot,snapshot>>. Searchable snapshot indices do not need\n+<<glossary-replica-shard,replica shards>> for resilience, since their data is\n+reliably stored outside the cluster. See\n+{ref}/searchable-snapshots.html[searchable snapshots].\n // end::searchable-snapshot-index-def[]\n \n-[[glossary-shard]] shard ::\n-+\n---\n+[[glossary-segment]] segment::\n+// tag::segment-def[]\n+Data file in a <<glossary-shard,shard>>'s Lucene instance. {es} manages Lucene\n+segments automatically.\n+// end::segment-def[]\n+\n+[[glossary-shard]] shard::\n // tag::shard-def[]\n-A shard is a single Lucene instance. It is a low-level “worker” unit\n-which is managed automatically by Elasticsearch. An index is a logical\n-namespace which points to <<glossary-primary-shard,primary>> and\n-<<glossary-replica-shard,replica>> shards.\n-\n-Other than defining the number of primary and replica shards that an\n-index should have, you never need to refer to shards directly.\n-Instead, your code should deal only with an index.\n-\n-Elasticsearch distributes shards amongst all <<glossary-node,nodes>> in the\n-<<glossary-cluster,cluster>>, and can move shards automatically from one\n-node to another in the case of node failure, or the addition of new\n-nodes.\n+Lucene instance containing some or all data for an <<glossary-index,index>>.\n+{es} automatically creates and manages these Lucene instances. There are two\n+types of shards: <<glossary-primary-shard,primary>> and\n+<<glossary-replica-shard,replica>>. See {ref}/scalability.html[Clusters, nodes,\n+and shards].\n // end::shard-def[]\n---\n \n-[[glossary-shrink]] shrink ::\n-+\n---\n+[[glossary-shrink]] shrink::\n // tag::shrink-def[]\n // tag::shrink-def-short[]\n-Reduce the number of primary shards in an index.\n+Reduces the number of <<glossary-primary-shard,primary shards>> in an index.\n // end::shrink-def-short[]\n-\n-You can shrink an index to reduce its overhead when the request volume drops.\n-For example, you might opt to shrink an index once it is no longer the write index.\n See the {ref}/indices-shrink-index.html[shrink index API].\n // end::shrink-def[]\n---\n \n-[[glossary-snapshot]] snapshot ::\n+[[glossary-snapshot]] snapshot::\n // tag::snapshot-def[]\n-Captures the state of the whole cluster or of particular indices or data\n-streams at a particular point in time. Snapshots provide a back up of a running\n-cluster, ensuring you can restore your data in the event of a failure. You can\n-also mount indices or datastreams from snapshots as read-only\n-{ref}/glossary.html#glossary-searchable-snapshot-index[searchable snapshots].\n+Backup taken of a running <<glossary-cluster,cluster>>. You can take snapshots\n+of the entire cluster or only specific <<glossary-data-stream,data streams>> and\n+<<glossary-index,indices>>. See {ref}/snapshot-restore.html[Snapshot and\n+restore].\n // end::snapshot-def[]\n \n-[[glossary-snapshot-lifecycle-policy]] snapshot lifecycle policy ::\n+[[glossary-snapshot-lifecycle-policy]] snapshot lifecycle policy::\n // tag::snapshot-lifecycle-policy-def[]\n-Specifies how frequently to perform automatic backups of a cluster and\n-how long to retain the resulting snapshots.\n+Specifies how frequently to perform automatic backups of a cluster and how long\n+to retain the resulting <<glossary-snapshot,snapshots>>. See\n+{ref}/snapshot-lifecycle-management.html[Manage the snapshot lifecycle]\n // end::snapshot-lifecycle-policy-def[]\n \n-[[glossary-snapshot-repository]] snapshot repository ::\n+[[glossary-snapshot-repository]] snapshot repository::\n // tag::snapshot-repository-def[]\n-Specifies where snapshots are to be stored.\n-Snapshots can be written to a shared filesystem or to a remote repository.\n+Location where <<glossary-snapshot,snapshots>> are stored. A snapshot repository\n+can be a shared filesystem or a remote repository, such as Azure or Google Cloud\n+Storage. See {ref}/snapshot-restore.html[Snapshot and restore].\n // end::snapshot-repository-def[]\n \n-[[glossary-source_field]] source field ::\n+[[glossary-source_field]] source field::\n // tag::source-field-def[]\n-By default, the JSON document that you index will be stored in the\n-`_source` field and will be returned by all get and search requests.\n-This allows you access to the original object directly from search\n-results, rather than requiring a second step to retrieve the object\n-from an ID.\n+Original JSON object provided during <<glossary-index,indexing>>. See the\n+{ref}/mapping-source-field.html[`_source` field].\n // end::source-field-def[]\n \n-[[glossary-split]] split ::\n+[[glossary-split]] split::\n // tag::split-def[]\n-To grow the amount of shards in an index.\n-See the {ref}/indices-split-index.html[split index API].\n+Adds more <<glossary-primary-shard,primary shards>> to an\n+<<glossary-index,index>>. See the {ref}/indices-split-index.html[split index\n+API].\n // end::split-def[]\n \n-[[glossary-system-index]] system index ::\n+[[glossary-system-index]] system index::\n // tag::system-index-def[]\n-An index that contains configuration information or other data used internally by the system,\n-such as the `.security` index.\n-The name of a system index is always prefixed with a dot.\n-You should not directly access or modify system indices.\n+<<glossary-index,Index>> containing configurations and other data used\n+internally by the {stack}. System index names start with a dot (`.`), such as\n+`.security`. Do not directly access or change system indices.\n // end::system-index-def[]\n \n-[[glossary-term]] term ::\n-+\n---\n+[[glossary-term]] term::\n // tag::term-def[]\n-A term is an exact value that is indexed in Elasticsearch. The terms\n-`foo`, `Foo`, `FOO` are NOT equivalent. Terms (i.e. exact values) can\n-be searched for using _term_ queries.\n-\n-See also <<glossary-text,text>> and <<glossary-analysis,analysis>>.\n+See {ref}/glossary.html#glossary-token[token].\n // end::term-def[]\n---\n \n-[[glossary-text]] text ::\n-+\n---\n+[[glossary-text]] text::\n // tag::text-def[]\n-Text (or full text) is ordinary unstructured text, such as this\n-paragraph. By default, text will be <<glossary-analysis,analyzed>> into\n-<<glossary-term,terms>>, which is what is actually stored in the index.\n-\n-Text <<glossary-field,fields>> need to be analyzed at index time in order to\n-be searchable as full text, and keywords in full text queries must be\n-analyzed at search time to produce (and search for) the same terms\n-that were generated at index time.\n-\n-See also <<glossary-term,term>> and <<glossary-analysis,analysis>>.\n+Unstructured content, such as a product description or log message. You\n+typically <<glossary-analysis,analyze>> text for better search. See\n+{ref}/analysis.html[Text analysis].\n // end::text-def[]\n---\n-\n-[[glossary-type]] type ::\n-// tag::type-def[]\n-A type used to represent the _type_ of document, e.g. an `email`, a `user`, or a `tweet`.\n-Types are deprecated and are in the process of being removed.\n-See {ref}/removal-of-types.html[Removal of mapping types].\n-// end::type-def[]\n \n-[[glossary-warm-phase]] warm phase ::\n+[[glossary-token]] token::\n+// tag::token-def[]\n+A chunk of unstructured <<glossary-text,text>> that's been optimized for search.\n+In most cases, tokens are individual words. Tokens are also called terms. See\n+{ref}/analysis.html[Test analysis].\n+// end::token-def[]\n+\n+[[glossary-tokenization]] tokenization::\n+// tag::tokenization-def[]\n+Process of breaking unstructured text down into smaller, searchable chunks\n+called <<glossary-token,tokens>>. See\n+{ref}/analysis-overview.html#tokenization[Tokenization].\n+// end::tokenization-def[]\n+\n+[[glossary-warm-phase]] warm phase::\n // tag::warm-phase-def[]\n-The second possible phase in the <<glossary-index-lifecycle,index lifecycle>>.\n-In the warm phase, an index is generally optimized for search and no longer updated.\n+Second possible phase in the <<glossary-index-lifecycle,index lifecycle>>. In\n+the warm phase, an <<glossary-index,index>> is generally optimized for search\n+and no longer updated. See {ref}/ilm-policy-definition.html[Index lifecycle].\n // end::warm-phase-def[]\n \n [[glossary-warm-tier]] warm tier::\n // tag::warm-tier-def[]\n-A <<glossary-data-tier, data tier>> that contains nodes that hold time series data\n-that is accessed less frequently and rarely needs to be updated.\n+<<glossary-data-tier,Data tier>> that contains <<glossary-node,nodes>> that hold\n+time series data that is accessed less frequently and rarely needs to be\n+updated. See {ref}/data-tiers.html[Data tiers].\n // end::warm-tier-def[]"
  },
  {
    "sha": "9de8077f6df390ff3f36e547b04360bd830fdafe",
    "filename": "docs/reference/indices/add-alias.asciidoc",
    "status": "modified",
    "additions": 4,
    "deletions": 1,
    "changes": 5,
    "blob_url": "https://github.com/elastic/elasticsearch/blob/6df32797604c7f3a62b4b997e2501cb4c1d4f199/docs/reference/indices/add-alias.asciidoc",
    "raw_url": "https://github.com/elastic/elasticsearch/raw/6df32797604c7f3a62b4b997e2501cb4c1d4f199/docs/reference/indices/add-alias.asciidoc",
    "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/docs/reference/indices/add-alias.asciidoc?ref=6df32797604c7f3a62b4b997e2501cb4c1d4f199",
    "patch": "@@ -6,7 +6,10 @@\n \n Creates or updates an index alias.\n \n-include::{es-repo-dir}/glossary.asciidoc[tag=index-alias-desc]\n+//tag::index-alias-desc[]\n+An index alias is a secondary name for one or more indices. Most {es} APIs\n+accept an index alias in place of an index name.\n+//end::index-alias-desc[]\n \n [source,console]\n ----"
  },
  {
    "sha": "8e81915262a1283a4c34b376cd8647e72e7a4406",
    "filename": "docs/reference/indices/alias-exists.asciidoc",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/elastic/elasticsearch/blob/6df32797604c7f3a62b4b997e2501cb4c1d4f199/docs/reference/indices/alias-exists.asciidoc",
    "raw_url": "https://github.com/elastic/elasticsearch/raw/6df32797604c7f3a62b4b997e2501cb4c1d4f199/docs/reference/indices/alias-exists.asciidoc",
    "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/docs/reference/indices/alias-exists.asciidoc?ref=6df32797604c7f3a62b4b997e2501cb4c1d4f199",
    "patch": "@@ -6,7 +6,7 @@\n \n Checks if an index alias exists.\n \n-include::{es-repo-dir}/glossary.asciidoc[tag=index-alias-desc]\n+include::{es-repo-dir}/indices/add-alias.asciidoc[tag=index-alias-desc]\n \n [source,console]\n ----"
  },
  {
    "sha": "29fb8a442531d6640a4715a0fc938da7a14fbe2f",
    "filename": "docs/reference/indices/delete-alias.asciidoc",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/elastic/elasticsearch/blob/6df32797604c7f3a62b4b997e2501cb4c1d4f199/docs/reference/indices/delete-alias.asciidoc",
    "raw_url": "https://github.com/elastic/elasticsearch/raw/6df32797604c7f3a62b4b997e2501cb4c1d4f199/docs/reference/indices/delete-alias.asciidoc",
    "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/docs/reference/indices/delete-alias.asciidoc?ref=6df32797604c7f3a62b4b997e2501cb4c1d4f199",
    "patch": "@@ -6,7 +6,7 @@\n \n Deletes an existing index alias.\n \n-include::{es-repo-dir}/glossary.asciidoc[tag=index-alias-desc]\n+include::{es-repo-dir}/indices/add-alias.asciidoc[tag=index-alias-desc]\n \n [source,console]\n ----"
  },
  {
    "sha": "ac841fd282251cfc1da8ac84494c0553cc0151b7",
    "filename": "docs/reference/indices/get-alias.asciidoc",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/elastic/elasticsearch/blob/6df32797604c7f3a62b4b997e2501cb4c1d4f199/docs/reference/indices/get-alias.asciidoc",
    "raw_url": "https://github.com/elastic/elasticsearch/raw/6df32797604c7f3a62b4b997e2501cb4c1d4f199/docs/reference/indices/get-alias.asciidoc",
    "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/docs/reference/indices/get-alias.asciidoc?ref=6df32797604c7f3a62b4b997e2501cb4c1d4f199",
    "patch": "@@ -6,7 +6,7 @@\n \n Returns information about one or more index aliases.\n \n-include::{es-repo-dir}/glossary.asciidoc[tag=index-alias-desc]\n+include::{es-repo-dir}/indices/add-alias.asciidoc[tag=index-alias-desc]\n \n [source,console]\n ----"
  },
  {
    "sha": "5c231e345eee200bfb3ea06d62f51580cbf2d664",
    "filename": "docs/reference/indices/recovery.asciidoc",
    "status": "modified",
    "additions": 7,
    "deletions": 1,
    "changes": 8,
    "blob_url": "https://github.com/elastic/elasticsearch/blob/6df32797604c7f3a62b4b997e2501cb4c1d4f199/docs/reference/indices/recovery.asciidoc",
    "raw_url": "https://github.com/elastic/elasticsearch/raw/6df32797604c7f3a62b4b997e2501cb4c1d4f199/docs/reference/indices/recovery.asciidoc",
    "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/docs/reference/indices/recovery.asciidoc?ref=6df32797604c7f3a62b4b997e2501cb4c1d4f199",
    "patch": "@@ -42,7 +42,13 @@ of syncing a replica shard from a primary shard.\n Upon completion,\n the replica shard is available for search.\n \n-include::{es-repo-dir}/glossary.asciidoc[tag=recovery-triggers]\n+Recovery automatically occurs during the following processes:\n+\n+* Node startup or failure. This type of recovery is called a local store\n+  recovery.\n+* <<glossary-replica-shard,Primary shard replication>>.\n+* Relocation of a shard to a different node in the same cluster.\n+* <<snapshots-restore-snapshot,Snapshot restoration>>.\n \n // end::shard-recovery-desc[]\n "
  }
]
