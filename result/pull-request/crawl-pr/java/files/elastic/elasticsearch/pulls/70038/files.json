[
  {
    "sha": "ed5ba1358a1c6938f49dcb59b1dc51141ed56a9f",
    "filename": "server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java",
    "status": "modified",
    "additions": 6,
    "deletions": 7,
    "changes": 13,
    "blob_url": "https://github.com/elastic/elasticsearch/blob/6eb07b9117dbc6724499fb5f4535e352ee69ca9e/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java",
    "raw_url": "https://github.com/elastic/elasticsearch/raw/6eb07b9117dbc6724499fb5f4535e352ee69ca9e/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java",
    "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java?ref=6eb07b9117dbc6724499fb5f4535e352ee69ca9e",
    "patch": "@@ -19,7 +19,6 @@\n import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.common.SuppressForbidden;\n-import org.elasticsearch.common.collect.Tuple;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.common.io.stream.Writeable;\n@@ -221,7 +220,7 @@\n      * @return the retention leases\n      */\n     public RetentionLeases getRetentionLeases() {\n-        return getRetentionLeases(false).v2();\n+        return getRetentionLeases(false);\n     }\n \n     /**\n@@ -230,11 +229,11 @@ public RetentionLeases getRetentionLeases() {\n      * primary shard calculates which leases are expired, and if any have expired, syncs the retention leases to any replicas. If the\n      * expire leases parameter is true, this replication tracker must be in primary mode.\n      *\n-     * @return a tuple indicating whether or not any retention leases were expired, and the non-expired retention leases\n+     * @return the non-expired retention leases\n      */\n-    public synchronized Tuple<Boolean, RetentionLeases> getRetentionLeases(final boolean expireLeases) {\n+    public synchronized RetentionLeases getRetentionLeases(final boolean expireLeases) {\n         if (expireLeases == false) {\n-            return Tuple.tuple(false, retentionLeases);\n+            return retentionLeases;\n         }\n         assert primaryMode;\n         // the primary calculates the non-expired retention leases and syncs them to replicas\n@@ -267,13 +266,13 @@ public RetentionLeases getRetentionLeases() {\n         if (expiredLeases == null) {\n             // early out as no retention leases have expired\n             logger.debug(\"no retention leases are expired from current retention leases [{}]\", retentionLeases);\n-            return Tuple.tuple(false, retentionLeases);\n+            return retentionLeases;\n         }\n         final Collection<RetentionLease> nonExpiredLeases =\n                 partitionByExpiration.get(false) != null ? partitionByExpiration.get(false) : Collections.emptyList();\n         logger.debug(\"expiring retention leases [{}] from current retention leases [{}]\", expiredLeases, retentionLeases);\n         retentionLeases = new RetentionLeases(operationPrimaryTerm, retentionLeases.version() + 1, nonExpiredLeases);\n-        return Tuple.tuple(true, retentionLeases);\n+        return retentionLeases;\n     }\n \n     private long getMinimumReasonableRetainedSeqNo() {"
  },
  {
    "sha": "9d141eb6879deabaaf82e8f5284b537c72ec53b2",
    "filename": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java",
    "status": "modified",
    "additions": 6,
    "deletions": 6,
    "changes": 12,
    "blob_url": "https://github.com/elastic/elasticsearch/blob/6eb07b9117dbc6724499fb5f4535e352ee69ca9e/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java",
    "raw_url": "https://github.com/elastic/elasticsearch/raw/6eb07b9117dbc6724499fb5f4535e352ee69ca9e/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java",
    "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java?ref=6eb07b9117dbc6724499fb5f4535e352ee69ca9e",
    "patch": "@@ -2147,7 +2147,7 @@ private void ensureSoftDeletesEnabled(String feature) {\n      * @return the retention leases\n      */\n     public RetentionLeases getRetentionLeases() {\n-        return getRetentionLeases(false).v2();\n+        return getRetentionLeases(false);\n     }\n \n     /**\n@@ -2156,9 +2156,9 @@ public RetentionLeases getRetentionLeases() {\n      * primary shard calculates which leases are expired, and if any have expired, syncs the retention leases to any replicas. If the\n      * expire leases parameter is true, this replication tracker must be in primary mode.\n      *\n-     * @return a tuple indicating whether or not any retention leases were expired, and the non-expired retention leases\n+     * @return the non-expired retention leases\n      */\n-    public Tuple<Boolean, RetentionLeases> getRetentionLeases(final boolean expireLeases) {\n+    public RetentionLeases getRetentionLeases(final boolean expireLeases) {\n         assert expireLeases == false || assertPrimaryMode();\n         verifyNotClosed();\n         return replicationTracker.getRetentionLeases(expireLeases);\n@@ -2276,10 +2276,10 @@ public void syncRetentionLeases() {\n         assert assertPrimaryMode();\n         verifyNotClosed();\n         replicationTracker.renewPeerRecoveryRetentionLeases();\n-        final Tuple<Boolean, RetentionLeases> retentionLeases = getRetentionLeases(true);\n-        logger.trace(\"background syncing retention leases [{}] after expiration check\", retentionLeases.v2());\n+        final RetentionLeases retentionLeases = getRetentionLeases(true);\n+        logger.trace(\"background syncing retention leases [{}] after expiration check\", retentionLeases);\n         retentionLeaseSyncer.backgroundSync(\n-            shardId, shardRouting.allocationId().getId(), getPendingPrimaryTerm(), retentionLeases.v2());\n+            shardId, shardRouting.allocationId().getId(), getPendingPrimaryTerm(), retentionLeases);\n     }\n \n     /**"
  },
  {
    "sha": "d412b87d69c52667a3a376c014d1aed7198341fc",
    "filename": "server/src/test/java/org/elasticsearch/index/seqno/PeerRecoveryRetentionLeaseExpiryTests.java",
    "status": "modified",
    "additions": 10,
    "deletions": 16,
    "changes": 26,
    "blob_url": "https://github.com/elastic/elasticsearch/blob/6eb07b9117dbc6724499fb5f4535e352ee69ca9e/server/src/test/java/org/elasticsearch/index/seqno/PeerRecoveryRetentionLeaseExpiryTests.java",
    "raw_url": "https://github.com/elastic/elasticsearch/raw/6eb07b9117dbc6724499fb5f4535e352ee69ca9e/server/src/test/java/org/elasticsearch/index/seqno/PeerRecoveryRetentionLeaseExpiryTests.java",
    "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/server/src/test/java/org/elasticsearch/index/seqno/PeerRecoveryRetentionLeaseExpiryTests.java?ref=6eb07b9117dbc6724499fb5f4535e352ee69ca9e",
    "patch": "@@ -12,7 +12,6 @@\n import org.elasticsearch.cluster.routing.AllocationId;\n import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n import org.elasticsearch.cluster.routing.ShardRouting;\n-import org.elasticsearch.common.collect.Tuple;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.index.IndexSettings;\n@@ -106,10 +105,9 @@ public void testPeerRecoveryRetentionLeasesForAssignedCopiesDoNotEverExpire() {\n         currentTimeMillis.set(currentTimeMillis.get() + randomLongBetween(0, Long.MAX_VALUE - currentTimeMillis.get()));\n         safeCommitInfo = randomSafeCommitInfo();\n \n-        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n-        assertFalse(retentionLeases.v1());\n+        final RetentionLeases retentionLeases = replicationTracker.getRetentionLeases(true);\n \n-        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n+        final Set<String> leaseIds = retentionLeases.leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n         assertThat(leaseIds, hasSize(2));\n         assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n             .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n@@ -125,10 +123,9 @@ public void testPeerRecoveryRetentionLeasesForUnassignedCopiesDoNotExpireImmedia\n \n         safeCommitInfo = randomSafeCommitInfoSuitableForOpsBasedRecovery(globalCheckpoint);\n \n-        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n-        assertFalse(\"should not have expired anything\", retentionLeases.v1());\n+        final RetentionLeases retentionLeases = replicationTracker.getRetentionLeases(true);\n \n-        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n+        final Set<String> leaseIds = retentionLeases.leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n         assertThat(leaseIds, hasSize(3));\n         assertThat(leaseIds, equalTo(Stream.concat(Stream.of(ReplicationTracker.getPeerRecoveryRetentionLeaseId(unknownNodeId)),\n             replicationTracker.routingTable.shards().stream()\n@@ -150,10 +147,9 @@ public void testPeerRecoveryRetentionLeasesForUnassignedCopiesExpireEventually()\n \n         safeCommitInfo = randomSafeCommitInfoSuitableForOpsBasedRecovery(globalCheckpoint);\n \n-        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n-        assertTrue(\"should have expired something\", retentionLeases.v1());\n+        final RetentionLeases retentionLeases = replicationTracker.getRetentionLeases(true);\n \n-        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n+        final Set<String> leaseIds = retentionLeases.leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n         assertThat(leaseIds, hasSize(2));\n         assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n             .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n@@ -171,10 +167,9 @@ public void testPeerRecoveryRetentionLeasesForUnassignedCopiesExpireImmediatelyI\n                 : randomLongBetween(0, Long.MAX_VALUE - currentTimeMillis.get())));\n         safeCommitInfo = randomSafeCommitInfo();\n \n-        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n-        assertTrue(retentionLeases.v1());\n+        final RetentionLeases retentionLeases = replicationTracker.getRetentionLeases(true);\n \n-        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n+        final Set<String> leaseIds = retentionLeases.leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n         assertThat(leaseIds, hasSize(2));\n         assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n             .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));\n@@ -191,10 +186,9 @@ public void testPeerRecoveryRetentionLeasesForUnassignedCopiesExpireIfRetainingT\n \n         safeCommitInfo = randomSafeCommitInfoSuitableForFileBasedRecovery(globalCheckpoint);\n \n-        final Tuple<Boolean, RetentionLeases> retentionLeases = replicationTracker.getRetentionLeases(true);\n-        assertTrue(\"should have expired something\", retentionLeases.v1());\n+        final RetentionLeases retentionLeases = replicationTracker.getRetentionLeases(true);\n \n-        final Set<String> leaseIds = retentionLeases.v2().leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n+        final Set<String> leaseIds = retentionLeases.leases().stream().map(RetentionLease::id).collect(Collectors.toSet());\n         assertThat(leaseIds, hasSize(2));\n         assertThat(leaseIds, equalTo(replicationTracker.routingTable.shards().stream()\n             .map(ReplicationTracker::getPeerRecoveryRetentionLeaseId).collect(Collectors.toSet())));"
  },
  {
    "sha": "7ed4953779e058b0b349d9f91a3615a20d40ce5d",
    "filename": "server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerRetentionLeaseTests.java",
    "status": "modified",
    "additions": 2,
    "deletions": 6,
    "changes": 8,
    "blob_url": "https://github.com/elastic/elasticsearch/blob/6eb07b9117dbc6724499fb5f4535e352ee69ca9e/server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerRetentionLeaseTests.java",
    "raw_url": "https://github.com/elastic/elasticsearch/raw/6eb07b9117dbc6724499fb5f4535e352ee69ca9e/server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerRetentionLeaseTests.java",
    "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerRetentionLeaseTests.java?ref=6eb07b9117dbc6724499fb5f4535e352ee69ca9e",
    "patch": "@@ -752,14 +752,10 @@ private void assertRetentionLeases(\n             if (randomBoolean()) {\n                 retentionLeases = replicationTracker.getRetentionLeases();\n             } else {\n-                final Tuple<Boolean, RetentionLeases> tuple = replicationTracker.getRetentionLeases(false);\n-                assertFalse(tuple.v1());\n-                retentionLeases = tuple.v2();\n+                retentionLeases = replicationTracker.getRetentionLeases(false);\n             }\n         } else {\n-            final Tuple<Boolean, RetentionLeases> tuple = replicationTracker.getRetentionLeases(true);\n-            assertTrue(tuple.v1());\n-            retentionLeases = tuple.v2();\n+            retentionLeases = replicationTracker.getRetentionLeases(true);\n         }\n         assertThat(retentionLeases.primaryTerm(), equalTo(primaryTerm));\n         assertThat(retentionLeases.version(), equalTo(version));"
  },
  {
    "sha": "a55f73563cf1891a6e2462eaa9b4b47c2ab88584",
    "filename": "server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java",
    "status": "modified",
    "additions": 5,
    "deletions": 1,
    "changes": 6,
    "blob_url": "https://github.com/elastic/elasticsearch/blob/6eb07b9117dbc6724499fb5f4535e352ee69ca9e/server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java",
    "raw_url": "https://github.com/elastic/elasticsearch/raw/6eb07b9117dbc6724499fb5f4535e352ee69ca9e/server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java",
    "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java?ref=6eb07b9117dbc6724499fb5f4535e352ee69ca9e",
    "patch": "@@ -1081,7 +1081,11 @@ public void testPeerRecoveryRetentionLeaseCreationAndRenewal() {\n         });\n \n         tracker.renewPeerRecoveryRetentionLeases();\n-        assertTrue(\"expired extra lease\", tracker.getRetentionLeases(true).v1());\n+        assertThat(tracker.getRetentionLeases().leases().stream().map(RetentionLease::id).collect(Collectors.toSet()),\n+            not(equalTo(expectedLeaseIds)));\n+        assertThat(\"expired extra lease\",\n+            tracker.getRetentionLeases(true).leases().stream().map(RetentionLease::id).collect(Collectors.toSet()),\n+            equalTo(expectedLeaseIds));\n \n         final AllocationId advancingAllocationId\n             = initializingAllocationIds.isEmpty() || rarely() ? primaryId : randomFrom(initializingAllocationIds);"
  },
  {
    "sha": "9124bc9fcd9dabd2bfdd4aea9ba2691240e33f10",
    "filename": "server/src/test/java/org/elasticsearch/index/shard/IndexShardRetentionLeaseTests.java",
    "status": "modified",
    "additions": 2,
    "deletions": 7,
    "changes": 9,
    "blob_url": "https://github.com/elastic/elasticsearch/blob/6eb07b9117dbc6724499fb5f4535e352ee69ca9e/server/src/test/java/org/elasticsearch/index/shard/IndexShardRetentionLeaseTests.java",
    "raw_url": "https://github.com/elastic/elasticsearch/raw/6eb07b9117dbc6724499fb5f4535e352ee69ca9e/server/src/test/java/org/elasticsearch/index/shard/IndexShardRetentionLeaseTests.java",
    "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/server/src/test/java/org/elasticsearch/index/shard/IndexShardRetentionLeaseTests.java?ref=6eb07b9117dbc6724499fb5f4535e352ee69ca9e",
    "patch": "@@ -11,7 +11,6 @@\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.routing.RecoverySource;\n import org.elasticsearch.cluster.routing.ShardRoutingHelper;\n-import org.elasticsearch.common.collect.Tuple;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.index.IndexSettings;\n@@ -306,14 +305,10 @@ private void assertRetentionLeases(\n             if (randomBoolean()) {\n                 retentionLeases = indexShard.getRetentionLeases();\n             } else {\n-                final Tuple<Boolean, RetentionLeases> tuple = indexShard.getRetentionLeases(false);\n-                assertFalse(tuple.v1());\n-                retentionLeases = tuple.v2();\n+                retentionLeases = indexShard.getRetentionLeases(false);\n             }\n         } else {\n-            final Tuple<Boolean, RetentionLeases> tuple = indexShard.getRetentionLeases(true);\n-            assertTrue(tuple.v1());\n-            retentionLeases = tuple.v2();\n+            retentionLeases = indexShard.getRetentionLeases(true);\n         }\n         assertRetentionLeases(\n                 retentionLeases,"
  }
]
