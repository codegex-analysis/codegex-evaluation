[
  {
    "sha": "1d73770ac354945b795ffb6a879fe6bb8f277e72",
    "filename": "appinventor/misc/checkstyle/checkstyle-git.py",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/checkstyle/checkstyle-git.py",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/checkstyle/checkstyle-git.py",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/checkstyle/checkstyle-git.py?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -37,7 +37,7 @@ def check_chunks(checkstyle_output, chunks):\n             linenum = int(match.group('line'))\n             while i < len(chunks):\n                 if chunks[i][0] <= linenum < chunks[i][1]:\n-                    print(line.strip())\n+                    print((line.strip()))\n                     success = False\n                     break\n                 elif chunks[i][0] <= linenum:\n@@ -62,8 +62,8 @@ def process_chunk_info(line):\n     parts = line.split(' ')\n     del_info = parts[1][1:]\n     add_info = parts[2][1:]\n-    del_start, del_length = map(int, del_info.split(',')) if ',' in del_info else (int(del_info), 1)\n-    add_start, add_length = map(int, add_info.split(',')) if ',' in add_info else (int(add_info), 1)\n+    del_start, del_length = list(map(int, del_info.split(','))) if ',' in del_info else (int(del_info), 1)\n+    add_start, add_length = list(map(int, add_info.split(','))) if ',' in add_info else (int(add_info), 1)\n     return del_start, del_length, add_start, add_length\n \n "
  },
  {
    "sha": "2cf3fe68cdc752f5105de6098af5103ed2d04ce2",
    "filename": "appinventor/misc/checkstyle/checkstyle-git.py.bak",
    "status": "added",
    "additions": 118,
    "deletions": 0,
    "changes": 118,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/checkstyle/checkstyle-git.py.bak",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/checkstyle/checkstyle-git.py.bak",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/checkstyle/checkstyle-git.py.bak?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -0,0 +1,118 @@\n+#!/usr/bin/env python3\n+import subprocess\n+from io import StringIO\n+from re import compile\n+import os\n+import sys\n+\n+\n+parent_commit = 'HEAD' if len(sys.argv) < 2 else sys.argv[1]\n+checkstyle_pattern = compile(r'^\\[(?P<severity>[^\\]]*)\\] (?P<filename>[^:]*):(?P<line>[0-9]*):(?P<message>.*)'\n+                             r' \\[(?P<rule>[^\\]]*)\\]$')\n+compile(r'^\\[(?P<severity>[^\\]]*)\\]')\n+basedir = os.getcwd() if os.path.exists('build.xml') else os.path.join(os.getcwd(), 'appinventor')\n+\n+\n+def checkstyle(current_file):\n+    return StringIO(subprocess.check_output(['java', '-cp',\n+                                             'lib/checkstyle/checkstyle.jar:lib/checkstyle/appinventor-checks.jar',\n+                                             'com.puppycrawl.tools.checkstyle.Main', '-c',\n+                                             'lib/checkstyle/appinventor-checks.xml', current_file],\n+                                            encoding='utf-8', cwd=basedir))\n+\n+\n+def check_chunks(checkstyle_output, chunks):\n+    \"\"\"\n+\n+    :param checkstyle_output:\n+    :param chunks:\n+    :type chunks: list[(int, int)]\n+    :return:\n+    \"\"\"\n+    success = True\n+    i = 0\n+    for line in checkstyle_output:\n+        match = checkstyle_pattern.match(line.strip())\n+        if match:\n+            linenum = int(match.group('line'))\n+            while i < len(chunks):\n+                if chunks[i][0] <= linenum < chunks[i][1]:\n+                    print(line.strip())\n+                    success = False\n+                    break\n+                elif chunks[i][0] <= linenum:\n+                    i += 1\n+                    if i >= len(chunks):\n+                        return success\n+                else:\n+                    break\n+    return success\n+\n+\n+def process_chunk_info(line):\n+    \"\"\"\n+    Processes a unified diff chunk header and returns a tuple indication the start and length of the deletion and\n+    addition hunks.\n+\n+    :param line: Unified diff chunk marker, beginning with '@@'\n+    :type line: str\n+    :return: a 4-tuple of deletion start, deletion length, addition start, addition length\n+    :rtype: tuple[int]\n+    \"\"\"\n+    parts = line.split(' ')\n+    del_info = parts[1][1:]\n+    add_info = parts[2][1:]\n+    del_start, del_length = map(int, del_info.split(',')) if ',' in del_info else (int(del_info), 1)\n+    add_start, add_length = map(int, add_info.split(',')) if ',' in add_info else (int(add_info), 1)\n+    return del_start, del_length, add_start, add_length\n+\n+\n+def main(parent):\n+    current_file, chunk_start, chunk_length = '', 0, 0\n+    checkstyle_output = None\n+    chunks = []\n+    passed = True\n+    for line in StringIO(subprocess.check_output(['git', 'diff', '-U0', parent], encoding='utf-8')):\n+        if line.startswith('diff --git'):\n+            pass\n+        elif line.startswith('index '):\n+            pass\n+        elif line.startswith('---'):\n+            if '/dev/null' in line:\n+                new_file = True\n+            else:\n+                new_file = False\n+            pass\n+        elif line.startswith('+++'):\n+            if line.startswith('+++ /dev/null'):\n+                continue  # Deleted file\n+            if len(chunks) > 0 and current_file != '':\n+                passed = check_chunks(checkstyle_output, chunks) and passed\n+            # Handle new file\n+            current_file = line[6:].strip()\n+            current_file = os.path.join('..', current_file)\n+            checkstyle_output = checkstyle(current_file)\n+            chunks = []\n+        elif line.startswith('@@'):\n+            # Handle chunk\n+            del_start, del_length, add_start, add_length = process_chunk_info(line)\n+            if add_length > 0:\n+                # Addition or replacement\n+                chunks.append((add_start, add_start + add_length))\n+            else:\n+                # Code removal. Check next line to ensure it didn't introduce an error\n+                chunks.append((del_start, del_start + 1))\n+\n+    if len(chunks) > 0:\n+        passed = check_chunks(checkstyle_output, chunks) and passed\n+\n+    return passed\n+\n+\n+if __name__ == '__main__':\n+    if 'BYPASS_CHECKSTYLE' in os.environ:\n+        sys.exit(0)\n+    if main(parent_commit):\n+        sys.exit(0)\n+    else:\n+        sys.exit(1)"
  },
  {
    "sha": "39b489118a9e88ae50b0c2657e7b071a3a4e8ee2",
    "filename": "appinventor/misc/emulator-support/aiStarter.py",
    "status": "modified",
    "additions": 9,
    "deletions": 9,
    "changes": 18,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/emulator-support/aiStarter.py",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/emulator-support/aiStarter.py",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/emulator-support/aiStarter.py?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -118,7 +118,7 @@ def reset():\n \n @route('/replstart/:device')\n def replstart(device=None):\n-    print('Device =', device)\n+    print(('Device =', device))\n     try:\n         subprocess.check_output('\"%s\" -s %s forward tcp:8001 tcp:8001' % (ADB, device), shell=True)\n         if re.match('emulator.*', device):  # Only fake the menu key for the emulator\n@@ -130,7 +130,7 @@ def replstart(device=None):\n         response.headers['Access-Control-Allow-Headers'] = 'origin, content-type'\n         return ''\n     except subprocess.CalledProcessError as e:\n-        print('Problem starting companion app : status', e.returncode)\n+        print(('Problem starting companion app : status', e.returncode))\n         return ''\n \n \n@@ -154,7 +154,7 @@ def checkrunning(emulator):\n             return match.group(1)\n         return False\n     except subprocess.CalledProcessError as e:\n-        print('Problem checking for devices : status', e.returncode)\n+        print(('Problem checking for devices : status', e.returncode))\n         return False\n \n \n@@ -163,15 +163,15 @@ def killadb():\n         subprocess.check_output('\"%s\" kill-server' % ADB, shell=True)\n         print('Killed adb')\n     except subprocess.CalledProcessError as e:\n-        print('Problem stopping adb : status', e.returncode)\n+        print(('Problem stopping adb : status', e.returncode))\n \n \n def killemulator():\n     try:\n         subprocess.check_output('\"%s\"' % KILL_EMULATOR, shell=True)\n         print('Killed emulator')\n     except subprocess.CalledProcessError as e:\n-        print('Problem stopping emulator : status', e.returncode)\n+        print(('Problem stopping emulator : status', e.returncode))\n \n \n def shutdown():\n@@ -183,10 +183,10 @@ def shutdown():\n \n \n if __name__ == '__main__':\n-    print('App Inventor version:', VERSION, '\\n')\n-    print('Architecture:', platform.machine(), '\\n')\n-    print('AppInventor tools located here:', PLATDIR, '\\n')\n-    print('ADB path:', ADB)\n+    print(('App Inventor version:', VERSION, '\\n'))\n+    print(('Architecture:', platform.machine(), '\\n'))\n+    print(('AppInventor tools located here:', PLATDIR, '\\n'))\n+    print(('ADB path:', ADB))\n \n     import atexit\n     atexit.register(shutdown)"
  },
  {
    "sha": "6f4548f9faefc371e1e64c76305706a936146f82",
    "filename": "appinventor/misc/emulator-support/aiStarter.py.bak",
    "status": "added",
    "additions": 194,
    "deletions": 0,
    "changes": 194,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/emulator-support/aiStarter.py.bak",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/emulator-support/aiStarter.py.bak",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/emulator-support/aiStarter.py.bak?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -0,0 +1,194 @@\n+#!/usr/bin/python\n+# -*- coding: utf-8; fill-column: 120 -*-\n+import os\n+import platform\n+import re\n+import subprocess\n+import sys\n+import config\n+\n+from bottle import run, route, response\n+\n+VERSION = '%d.%d.%d%s' % (config.ANDROID_PLATFORM, config.COMPANION_VERSION, config.MINOR_VERSION, config.BUILD_EXTRAS)\n+\n+PLATDIR = os.path.abspath(os.path.dirname(sys.argv[0]))\n+\n+# Path to executables\n+ADB = os.path.join(PLATDIR, 'from-Android-SDK', 'platform-tools', 'adb')\n+RUN_EMULATOR = os.path.join(PLATDIR, 'run-emulator')\n+RESET_EMULATOR = os.path.join(PLATDIR, 'reset-emulator')\n+KILL_EMULATOR = os.path.join(PLATDIR, 'kill-emulator')\n+\n+\n+@route('/ping/')\n+def ping():\n+    response.headers['Access-Control-Allow-Origin'] = '*'\n+    response.headers['Access-Control-Allow-Headers'] = 'origin, content-type'\n+    response.headers['Content-Type'] = 'application/json'\n+    return {\n+        \"status\": \"OK\",\n+        \"version\": VERSION\n+    }\n+\n+\n+@route('/utest/')\n+def utest():\n+    response.headers['Access-Control-Allow-Origin'] = '*'\n+    response.headers['Access-Control-Allow-Headers'] = 'origin, content-type'\n+    response.headers['Content-Type'] = 'application/json'\n+    device = checkrunning(False)\n+    if device:\n+        return {\n+            \"status\": \"OK\",\n+            \"device\": device,\n+            \"version\": VERSION\n+        }\n+    else:\n+        return {\n+            \"status\": \"NO\",\n+            \"version\": VERSION\n+        }\n+\n+\n+@route('/start/')\n+def start():\n+    subprocess.call(RUN_EMULATOR, shell=True)\n+    response.headers['Access-Control-Allow-Origin'] = '*'\n+    response.headers['Access-Control-Allow-Headers'] = 'origin, content-type'\n+    return ''\n+\n+\n+@route('/emulatorreset/')\n+def emulatorreset():\n+    subprocess.call(RESET_EMULATOR, shell=True)\n+    response.headers['Access-Control-Allow-Origin'] = '*'\n+    response.headers['Access-Control-Allow-Headers'] = 'origin, content-type'\n+    return ''\n+\n+\n+@route('/echeck/')\n+def echeck():\n+    response.headers['Access-Control-Allow-Origin'] = '*'\n+    response.headers['Access-Control-Allow-Headers'] = 'origin, content-type'\n+    response.headers['Content-Type'] = 'application/json'\n+    device = checkrunning(True)\n+    if device:\n+        return {\n+            \"status\": \"OK\",\n+            \"device\": device,\n+            \"version\": VERSION\n+        }\n+    else:\n+        return {\n+            \"status\": \"NO\",\n+            \"version\": VERSION\n+        }\n+\n+\n+@route('/ucheck/')\n+def ucheck():\n+    response.headers['Access-Control-Allow-Origin'] = '*'\n+    response.headers['Access-Control-Allow-Headers'] = 'origin, content-type'\n+    response.headers['Content-Type'] = 'application/json'\n+    device = checkrunning(False)\n+    if device:\n+        return {\n+            \"status\": \"OK\",\n+            \"device\": device,\n+            \"version\": VERSION\n+        }\n+    else:\n+        return {\n+            \"status\": \"NO\",\n+            \"version\": VERSION\n+        }\n+\n+\n+@route('/reset/')\n+def reset():\n+    response.headers['Access-Control-Allow-Origin'] = '*'\n+    response.headers['Access-Control-Allow-Headers'] = 'origin, content-type'\n+    response.headers['Content-Type'] = 'application/json'\n+    shutdown()\n+    return {\n+        \"status\": \"OK\",\n+        \"version\": VERSION\n+    }\n+\n+\n+@route('/replstart/:device')\n+def replstart(device=None):\n+    print('Device =', device)\n+    try:\n+        subprocess.check_output('\"%s\" -s %s forward tcp:8001 tcp:8001' % (ADB, device), shell=True)\n+        if re.match('emulator.*', device):  # Only fake the menu key for the emulator\n+            subprocess.check_output('\"%s\" -s %s shell input keyevent 82' % (ADB, device), shell=True)\n+        subprocess.check_output(\n+            '\"%s\" -s %s shell am start -a android.intent.action.VIEW -n edu.mit.appinventor.aicompanion3/.Screen1 --ez rundirect true' % (ADB, device),\n+            shell=True)\n+        response.headers['Access-Control-Allow-Origin'] = '*'\n+        response.headers['Access-Control-Allow-Headers'] = 'origin, content-type'\n+        return ''\n+    except subprocess.CalledProcessError as e:\n+        print('Problem starting companion app : status', e.returncode)\n+        return ''\n+\n+\n+def checkrunning(emulator):\n+    try:\n+        match = None\n+        result = subprocess.check_output('\"%s\" devices' % ADB, shell=True)\n+        lines = result.splitlines()\n+        for line in lines[1:]:\n+            line = str(line, 'utf-8')\n+            if line:\n+                if emulator:\n+                    match = re.search(r'^(emulator-\\d+)\\s+device$', line)\n+                else:\n+                    if re.search(r'^(emulator-\\d+)\\s+device$', line): # We are emulator\n+                        continue                                      # Skip it\n+                    match = re.search(r'^([\\w\\d]+)\\s+device$', line)\n+                if match:\n+                    break\n+        if match:\n+            return match.group(1)\n+        return False\n+    except subprocess.CalledProcessError as e:\n+        print('Problem checking for devices : status', e.returncode)\n+        return False\n+\n+\n+def killadb():\n+    try:\n+        subprocess.check_output('\"%s\" kill-server' % ADB, shell=True)\n+        print('Killed adb')\n+    except subprocess.CalledProcessError as e:\n+        print('Problem stopping adb : status', e.returncode)\n+\n+\n+def killemulator():\n+    try:\n+        subprocess.check_output('\"%s\"' % KILL_EMULATOR, shell=True)\n+        print('Killed emulator')\n+    except subprocess.CalledProcessError as e:\n+        print('Problem stopping emulator : status', e.returncode)\n+\n+\n+def shutdown():\n+    try:\n+        killemulator()\n+        killadb()\n+    except:\n+        pass\n+\n+\n+if __name__ == '__main__':\n+    print('App Inventor version:', VERSION, '\\n')\n+    print('Architecture:', platform.machine(), '\\n')\n+    print('AppInventor tools located here:', PLATDIR, '\\n')\n+    print('ADB path:', ADB)\n+\n+    import atexit\n+    atexit.register(shutdown)\n+\n+    run(host='127.0.0.1', port=8004)"
  },
  {
    "sha": "c2eb27762ec8f36e4644527bdd55f013e1070f8c",
    "filename": "appinventor/misc/emulator-support/bottle.py",
    "status": "modified",
    "additions": 64,
    "deletions": 64,
    "changes": 128,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/emulator-support/bottle.py",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/emulator-support/bottle.py",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/emulator-support/bottle.py?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -13,7 +13,7 @@\n License: MIT (see LICENSE for details)\n \"\"\"\n \n-from __future__ import with_statement\n+\n \n __author__ = 'Marcel Hellkamp'\n __version__ = '0.12.13'\n@@ -88,39 +88,39 @@ def _e(): return sys.exc_info()[1]\n     import pickle\n     from io import BytesIO\n     from configparser import ConfigParser\n-    basestring = str\n-    unicode = str\n+    str = str\n+    str = str\n     json_loads = lambda s: json_lds(touni(s))\n     callable = lambda x: hasattr(x, '__call__')\n     imap = map\n     def _raise(*a): raise a[0](a[1]).with_traceback(a[2])\n else: # 2.x\n-    import httplib\n-    import thread\n-    from urlparse import urljoin, SplitResult as UrlSplitResult\n-    from urllib import urlencode, quote as urlquote, unquote as urlunquote\n-    from Cookie import SimpleCookie\n-    from itertools import imap\n-    import cPickle as pickle\n-    from StringIO import StringIO as BytesIO\n-    from ConfigParser import SafeConfigParser as ConfigParser\n+    import http.client\n+    import _thread\n+    from urllib.parse import urljoin, SplitResult as UrlSplitResult\n+    from urllib.parse import urlencode, quote as urlquote, unquote as urlunquote\n+    from http.cookies import SimpleCookie\n+    \n+    import pickle as pickle\n+    from io import StringIO as BytesIO\n+    from configparser import SafeConfigParser as ConfigParser\n     if py25:\n         msg  = \"Python 2.5 support may be dropped in future versions of Bottle.\"\n         warnings.warn(msg, DeprecationWarning)\n         from UserDict import DictMixin\n-        def next(it): return it.next()\n+        def next(it): return next(it)\n         bytes = str\n     else: # 2.6, 2.7\n         from collections import MutableMapping as DictMixin\n-    unicode = unicode\n+    str = str\n     json_loads = json_lds\n     eval(compile('def _raise(*a): raise a[0], a[1], a[2]', '<py3fix>', 'exec'))\n \n # Some helpers for string/byte handling\n def tob(s, enc='utf8'):\n-    return s.encode(enc) if isinstance(s, unicode) else bytes(s)\n+    return s.encode(enc) if isinstance(s, str) else bytes(s)\n def touni(s, enc='utf8', err='strict'):\n-    return s.decode(enc, err) if isinstance(s, bytes) else unicode(s)\n+    return s.decode(enc, err) if isinstance(s, bytes) else str(s)\n tonat = touni if py3k else tob\n \n # 3.2 fixes cgi.FieldStorage to accept bytes (which makes a lot of sense).\n@@ -659,7 +659,7 @@ def mount(self, prefix, app, **options):\n \n             All other parameters are passed to the underlying :meth:`route` call.\n         '''\n-        if isinstance(app, basestring):\n+        if isinstance(app, str):\n             depr('Parameter order of Bottle.mount() changed.', True) # 0.10\n \n         segments = [p for p in prefix.split('/') if p]\n@@ -805,7 +805,7 @@ def hello(name):\n         skiplist = makelist(skip)\n         def decorator(callback):\n             # TODO: Documentation and tests\n-            if isinstance(callback, basestring): callback = load(callback)\n+            if isinstance(callback, str): callback = load(callback)\n             for rule in makelist(path) or yieldroutes(callback):\n                 for verb in makelist(method):\n                     verb = verb.upper()\n@@ -890,10 +890,10 @@ def _cast(self, out, peek=None):\n             return []\n         # Join lists of byte or unicode strings. Mixed lists are NOT supported\n         if isinstance(out, (tuple, list))\\\n-        and isinstance(out[0], (bytes, unicode)):\n+        and isinstance(out[0], (bytes, str)):\n             out = out[0][0:0].join(out) # b'abc'[0:0] -> b''\n         # Encode unicode strings\n-        if isinstance(out, unicode):\n+        if isinstance(out, str):\n             out = out.encode(response.charset)\n         # Byte Strings are just returned\n         if isinstance(out, bytes):\n@@ -938,9 +938,9 @@ def _cast(self, out, peek=None):\n             return self._cast(first)\n         elif isinstance(first, bytes):\n             new_iter = itertools.chain([first], iout)\n-        elif isinstance(first, unicode):\n+        elif isinstance(first, str):\n             encoder = lambda x: x.encode(response.charset)\n-            new_iter = imap(encoder, itertools.chain([first], iout))\n+            new_iter = map(encoder, itertools.chain([first], iout))\n         else:\n             msg = 'Unsupported response type: %s' % type(first)\n             return self._cast(HTTPError(500, msg))\n@@ -1048,7 +1048,7 @@ def get_header(self, name, default=None):\n     def cookies(self):\n         \"\"\" Cookies parsed into a :class:`FormsDict`. Signed cookies are NOT\n             decoded. Use :meth:`get_cookie` if you expect signed cookies. \"\"\"\n-        cookies = SimpleCookie(self.environ.get('HTTP_COOKIE','')).values()\n+        cookies = list(SimpleCookie(self.environ.get('HTTP_COOKIE','')).values())\n         return FormsDict((c.key, c.value) for c in cookies)\n \n     def get_cookie(self, key, default=None, secret=None):\n@@ -1362,7 +1362,7 @@ def __getitem__(self, key): return self.environ[key]\n     def __delitem__(self, key): self[key] = \"\"; del(self.environ[key])\n     def __iter__(self): return iter(self.environ)\n     def __len__(self): return len(self.environ)\n-    def keys(self): return self.environ.keys()\n+    def keys(self): return list(self.environ.keys())\n     def __setitem__(self, key, value):\n         \"\"\" Change an environ value and clear all caches that depend on it. \"\"\"\n \n@@ -1464,11 +1464,11 @@ def __init__(self, body='', status=None, headers=None, **more_headers):\n         self.status = status or self.default_status\n         if headers:\n             if isinstance(headers, dict):\n-                headers = headers.items()\n+                headers = list(headers.items())\n             for name, value in headers:\n                 self.add_header(name, value)\n         if more_headers:\n-            for name, value in more_headers.items():\n+            for name, value in list(more_headers.items()):\n                 self.add_header(name, value)\n \n     def copy(self, cls=None):\n@@ -1477,7 +1477,7 @@ def copy(self, cls=None):\n         assert issubclass(cls, BaseResponse)\n         copy = cls()\n         copy.status = self.status\n-        copy._headers = dict((k, v[:]) for (k, v) in self._headers.items())\n+        copy._headers = dict((k, v[:]) for (k, v) in list(self._headers.items()))\n         if self._cookies:\n             copy._cookies = SimpleCookie()\n             copy._cookies.load(self._cookies.output(header=''))\n@@ -1567,7 +1567,7 @@ def headerlist(self):\n             headers = [h for h in headers if h[0] not in bad_headers]\n         out += [(name, val) for name, vals in headers for val in vals]\n         if self._cookies:\n-            for c in self._cookies.values():\n+            for c in list(self._cookies.values()):\n                 out.append(('Set-Cookie', c.OutputString()))\n         return out\n \n@@ -1622,13 +1622,13 @@ def set_cookie(self, name, value, secret=None, **options):\n \n         if secret:\n             value = touni(cookie_encode((name, value), secret))\n-        elif not isinstance(value, basestring):\n+        elif not isinstance(value, str):\n             raise TypeError('Secret key missing for non-string Cookie.')\n \n         if len(value) > 4096: raise ValueError('Cookie value to long.')\n         self._cookies[name] = value\n \n-        for key, value in options.items():\n+        for key, value in list(options.items()):\n             if key == 'max_age':\n                 if isinstance(value, timedelta):\n                     value = value.seconds + value.days * 24 * 3600\n@@ -1817,37 +1817,37 @@ class MultiDict(DictMixin):\n     \"\"\"\n \n     def __init__(self, *a, **k):\n-        self.dict = dict((k, [v]) for (k, v) in dict(*a, **k).items())\n+        self.dict = dict((k, [v]) for (k, v) in list(dict(*a, **k).items()))\n \n     def __len__(self): return len(self.dict)\n     def __iter__(self): return iter(self.dict)\n     def __contains__(self, key): return key in self.dict\n     def __delitem__(self, key): del self.dict[key]\n     def __getitem__(self, key): return self.dict[key][-1]\n     def __setitem__(self, key, value): self.append(key, value)\n-    def keys(self): return self.dict.keys()\n+    def keys(self): return list(self.dict.keys())\n \n     if py3k:\n-        def values(self): return (v[-1] for v in self.dict.values())\n-        def items(self): return ((k, v[-1]) for k, v in self.dict.items())\n+        def values(self): return (v[-1] for v in list(self.dict.values()))\n+        def items(self): return ((k, v[-1]) for k, v in list(self.dict.items()))\n         def allitems(self):\n-            return ((k, v) for k, vl in self.dict.items() for v in vl)\n+            return ((k, v) for k, vl in list(self.dict.items()) for v in vl)\n         iterkeys = keys\n         itervalues = values\n         iteritems = items\n         iterallitems = allitems\n \n     else:\n-        def values(self): return [v[-1] for v in self.dict.values()]\n-        def items(self): return [(k, v[-1]) for k, v in self.dict.items()]\n-        def iterkeys(self): return self.dict.iterkeys()\n-        def itervalues(self): return (v[-1] for v in self.dict.itervalues())\n+        def values(self): return [v[-1] for v in list(self.dict.values())]\n+        def items(self): return [(k, v[-1]) for k, v in list(self.dict.items())]\n+        def iterkeys(self): return iter(self.dict.keys())\n+        def itervalues(self): return (v[-1] for v in self.dict.values())\n         def iteritems(self):\n-            return ((k, v[-1]) for k, v in self.dict.iteritems())\n+            return ((k, v[-1]) for k, v in self.dict.items())\n         def iterallitems(self):\n-            return ((k, v) for k, vl in self.dict.iteritems() for v in vl)\n+            return ((k, v) for k, vl in self.dict.items() for v in vl)\n         def allitems(self):\n-            return [(k, v) for k, vl in self.dict.iteritems() for v in vl]\n+            return [(k, v) for k, vl in self.dict.items() for v in vl]\n \n     def get(self, key, default=None, index=-1, type=None):\n         ''' Return the most recent value for a key.\n@@ -1898,7 +1898,7 @@ class FormsDict(MultiDict):\n     recode_unicode = True\n \n     def _fix(self, s, encoding=None):\n-        if isinstance(s, unicode) and self.recode_unicode: # Python 3 WSGI\n+        if isinstance(s, str) and self.recode_unicode: # Python 3 WSGI\n             return s.encode('latin1').decode(encoding or self.input_encoding)\n         elif isinstance(s, bytes): # Python 2 WSGI\n             return s.decode(encoding or self.input_encoding)\n@@ -1923,7 +1923,7 @@ def getunicode(self, name, default=None, encoding=None):\n         except (UnicodeError, KeyError):\n             return default\n \n-    def __getattr__(self, name, default=unicode()):\n+    def __getattr__(self, name, default=str()):\n         # Without this guard, pickle generates a cryptic TypeError:\n         if name.startswith('__') and name.endswith('__'):\n             return super(FormsDict, self).__getattr__(name)\n@@ -1997,7 +1997,7 @@ def __iter__(self):\n                 yield key.replace('_', '-').title()\n \n     def keys(self): return [x for x in self]\n-    def __len__(self): return len(self.keys())\n+    def __len__(self): return len(list(self.keys()))\n     def __contains__(self, key): return self._ekey(key) in self.environ\n \n \n@@ -2038,7 +2038,7 @@ def __iter__(self):\n                     yield name\n \n         def keys(self): return [x for x in self]\n-        def __len__(self): return len(self.keys())\n+        def __len__(self): return len(list(self.keys()))\n         def __contains__(self, key): return self._prefix + '.' + key in self._config\n         def __repr__(self): return '<Config.Namespace %s.*>' % self._prefix\n         def __str__(self): return '<Config.Namespace %s.*>' % self._prefix\n@@ -2112,8 +2112,8 @@ def load_dict(self, source, namespace='', make_namespaces=False):\n             prefix, source = stack.pop()\n             if not isinstance(source, dict):\n                 raise TypeError('Source is not a dict (r)' % type(key))\n-            for key, value in source.items():\n-                if not isinstance(key, basestring):\n+            for key, value in list(source.items()):\n+                if not isinstance(key, str):\n                     raise TypeError('Key is not a string (%r)' % type(key))\n                 full_key = prefix + '.' + key if prefix else key\n                 if isinstance(value, dict):\n@@ -2129,10 +2129,10 @@ def update(self, *a, **ka):\n             namespace. Apart from that it works just as the usual dict.update().\n             Example: ``update('some.namespace', key='value')`` '''\n         prefix = ''\n-        if a and isinstance(a[0], basestring):\n+        if a and isinstance(a[0], str):\n             prefix = a[0].strip('.') + '.'\n             a = a[1:]\n-        for key, value in dict(*a, **ka).items():\n+        for key, value in list(dict(*a, **ka).items()):\n             self[prefix+key] = value\n \n     def setdefault(self, key, value):\n@@ -2141,7 +2141,7 @@ def setdefault(self, key, value):\n         return self[key]\n \n     def __setitem__(self, key, value):\n-        if not isinstance(key, basestring):\n+        if not isinstance(key, str):\n             raise TypeError('Key has type %r (not a string)' % type(key))\n \n         value = self.meta_get(key, 'filter', lambda x: x)(value)\n@@ -2170,7 +2170,7 @@ def meta_set(self, key, metafield, value):\n \n     def meta_list(self, key):\n         ''' Return an iterable of meta field names defined for a key. '''\n-        return self._meta.get(key, {}).keys()\n+        return list(self._meta.get(key, {}).keys())\n \n     # Deprecated ConfigDict features\n     def __getattr__(self, key):\n@@ -2370,7 +2370,7 @@ def filename(self):\n             or dashes are removed. The filename is limited to 255 characters.\n         '''\n         fname = self.raw_filename\n-        if not isinstance(fname, unicode):\n+        if not isinstance(fname, str):\n             fname = fname.decode('utf8', 'ignore')\n         fname = normalize('NFKD', fname).encode('ASCII', 'ignore').decode('ASCII')\n         fname = os.path.basename(fname.replace('\\\\', os.path.sep))\n@@ -2395,7 +2395,7 @@ def save(self, destination, overwrite=False, chunk_size=2**16):\n             :param overwrite: If True, replace existing files. (default: False)\n             :param chunk_size: Bytes to read at a time. (default: 64kb)\n         '''\n-        if isinstance(destination, basestring): # Except file-likes here\n+        if isinstance(destination, str): # Except file-likes here\n             if os.path.isdir(destination):\n                 destination = os.path.join(destination, self.filename)\n             if not overwrite and os.path.exists(destination):\n@@ -2535,7 +2535,7 @@ def http_date(value):\n         value = value.utctimetuple()\n     elif isinstance(value, (int, float)):\n         value = time.gmtime(value)\n-    if not isinstance(value, basestring):\n+    if not isinstance(value, str):\n         value = time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", value)\n     return value\n \n@@ -2736,7 +2736,7 @@ def run(self, handler): # pragma: no cover\n         pass\n \n     def __repr__(self):\n-        args = ', '.join(['%s=%s'%(k,repr(v)) for k, v in self.options.items()])\n+        args = ', '.join(['%s=%s'%(k,repr(v)) for k, v in list(self.options.items())])\n         return \"%s(%s)\" % (self.__class__.__name__, args)\n \n \n@@ -3093,7 +3093,7 @@ def run(app=None, server='wsgiref', host='127.0.0.1', port=8080,\n     try:\n         if debug is not None: _debug(debug)\n         app = app or default_app()\n-        if isinstance(app, basestring):\n+        if isinstance(app, str):\n             app = load_app(app)\n         if not callable(app):\n             raise ValueError(\"Application is not callable: %r\" % app)\n@@ -3103,7 +3103,7 @@ def run(app=None, server='wsgiref', host='127.0.0.1', port=8080,\n \n         if server in server_names:\n             server = server_names.get(server)\n-        if isinstance(server, basestring):\n+        if isinstance(server, str):\n             server = load(server)\n         if isinstance(server, type):\n             server = server(host=host, port=port, **kargs)\n@@ -3162,11 +3162,11 @@ def run(self):\n             if not exists(self.lockfile)\\\n             or mtime(self.lockfile) < time.time() - self.interval - 5:\n                 self.status = 'error'\n-                thread.interrupt_main()\n+                _thread.interrupt_main()\n             for path, lmtime in list(files.items()):\n                 if not exists(path) or mtime(path) > lmtime:\n                     self.status = 'reload'\n-                    thread.interrupt_main()\n+                    _thread.interrupt_main()\n                     break\n             time.sleep(self.interval)\n \n@@ -3462,8 +3462,8 @@ def set_syntax(self, syntax):\n         self._tokens = syntax.split()\n         if not syntax in self._re_cache:\n             names = 'block_start block_close line_start inline_start inline_end'\n-            etokens = map(re.escape, self._tokens)\n-            pattern_vars = dict(zip(names.split(), etokens))\n+            etokens = list(map(re.escape, self._tokens))\n+            pattern_vars = dict(list(zip(names.split(), etokens)))\n             patterns = (self._re_split, self._re_tok, self._re_inl)\n             patterns = [re.compile(p%pattern_vars) for p in patterns]\n             self._re_cache[syntax] = patterns\n@@ -3667,14 +3667,14 @@ def wrapper(*args, **kwargs):\n NORUN = False # If set, run() does nothing. Used by load_app()\n \n #: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')\n-HTTP_CODES = httplib.responses\n+HTTP_CODES = http.client.responses\n HTTP_CODES[418] = \"I'm a teapot\" # RFC 2324\n HTTP_CODES[422] = \"Unprocessable Entity\" # RFC 4918\n HTTP_CODES[428] = \"Precondition Required\"\n HTTP_CODES[429] = \"Too Many Requests\"\n HTTP_CODES[431] = \"Request Header Fields Too Large\"\n HTTP_CODES[511] = \"Network Authentication Required\"\n-_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in HTTP_CODES.items())\n+_HTTP_STATUS_LINES = dict((k, '%d %s'%(k,v)) for (k,v) in list(HTTP_CODES.items()))\n \n #: The default template used for error pages. Override with @error()\n ERROR_PAGE_TEMPLATE = \"\"\""
  },
  {
    "sha": "26bd87380b63097fec578601eebe1d75cd41a6ac",
    "filename": "appinventor/misc/emulator-support/bottle.py.bak",
    "status": "added",
    "additions": 3760,
    "deletions": 0,
    "changes": 3760,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/emulator-support/bottle.py.bak",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/emulator-support/bottle.py.bak",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/emulator-support/bottle.py.bak?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879"
  },
  {
    "sha": "1dbf439d084a08900ef5d5c9daa52e036761d801",
    "filename": "appinventor/misc/i18n/i18n.py",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/i18n/i18n.py",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/i18n/i18n.py",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/i18n/i18n.py?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -16,7 +16,7 @@\n \n \"\"\"\n \n-from __future__ import print_function\n+\n import argparse\n import os\n import os.path"
  },
  {
    "sha": "b5f603534dfac44aa49e4498fa81e5843a090af6",
    "filename": "appinventor/misc/i18n/i18n.py.bak",
    "status": "added",
    "additions": 265,
    "deletions": 0,
    "changes": 265,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/i18n/i18n.py.bak",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/i18n/i18n.py.bak",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/i18n/i18n.py.bak?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -0,0 +1,265 @@\n+#!/usr/bin/env python\n+# -*- mode: python; coding: utf-8; -*-\n+# Copyright © 2019 MIT, All rights reserved.\n+# Released under the Apache License, Version 2.0\n+# http://www.apache.org/licenses/LICENSE-2.0\n+\n+\n+\"\"\"\n+Internationalization helper tool for MIT App Inventor. This utility provides two commands, combine and split, to work\n+with the Java properties and JavaScript files needed to internationalize the App Inventor web editor.\n+\n+The combine command takes the OdeMessages_default.properties file generated by GWT and the English messages file for\n+blocklyeditor and combines them into a single .properties file that can be imported into translation services, such as\n+Google Translate Toolkit.\n+\n+\n+\"\"\"\n+\n+from __future__ import print_function\n+import argparse\n+import os\n+import os.path\n+import re\n+\n+\n+__author__ = 'Evan W. Patton (ewpatton@mit.edu)'\n+\n+\n+file_path = os.path.realpath(__file__)\n+js_to_prop = os.path.join(os.path.dirname(file_path), 'js_to_prop.js')\n+appinventor_dir = os.path.normpath(os.path.join(os.path.dirname(file_path), '../../'))\n+\n+\n+class CombineAction(argparse.Action):\n+    def __init__(self, option_strings, dest, nargs=None, **kwargs):\n+        if nargs is not None:\n+            raise ValueError('nargs not allowed')\n+        super(CombineAction, self).__init__(option_strings, dest, **kwargs)\n+\n+    def __call__(self, parser, namespace, values, option_strings=None):\n+        pass\n+\n+\n+blockly_header = \"\"\"// -*- mode: javascript; js-indent-level: 2; -*-\n+// Copyright 2018-2019 Massachusetts Institute of Technology. All rights reserved.\n+// Released under the Apache License, Version 2.0\n+// http://www.apache.org/licenses/LICENSE-2.0\n+\n+'use strict';\n+\n+goog.provide('AI.Blockly.Msg.%(lang)s');\n+goog.require('Blockly.Msg.%(lang)s');\n+\n+Blockly.Msg.%(lang)s.switch_language_to_%(lang_name)s = {\n+  // Switch language to %(lang_name)s.\n+  category: '',\n+  helpUrl: '',\n+  init: function() {\n+    Blockly.Msg.%(lang)s.switch_blockly_language_to_%(lang)s.init();\n+\"\"\"\n+\n+blockly_footer = \"\"\"  }\n+};\n+\"\"\"\n+\n+\n+paletteItems = {\n+    'userInterfaceComponentPallette',\n+    'layoutComponentPallette',\n+    'mediaComponentPallette',\n+    'drawingAndAnimationComponentPallette',\n+    'mapsComponentPallette',\n+    'sensorComponentPallette',\n+    'socialComponentPallette',\n+    'storageComponentPallette',\n+    'connectivityComponentPallette',\n+    'legoMindstormsComponentPallette',\n+    'experimentalComponentPallette',\n+    'extensionComponentPallette'\n+}\n+\n+\n+def js_stringify(text):\n+    return \"'\" + text.replace(\"''\", \"'\").replace(\"'\", \"\\\\'\").replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\").replace(\"\\\\:\", \":\").replace(\"\\\\=\", \"=\") + \"'\"\n+\n+\n+def split(args):\n+    if args.lang is None:\n+        raise ValueError('No --lang specified for splitting file')\n+    if args.lang_name is None:\n+        raise ValueError('No --lang_name specified for splitting file')\n+    appengine_file = os.path.join(appinventor_dir, 'appengine', 'src', 'com',\n+                                  'google', 'appinventor', 'client',\n+                                  'OdeMessages_%s.properties' % args.lang[0])\n+    blockly_dir = os.path.join(appinventor_dir, 'blocklyeditor', 'src', 'msg', args.lang[0].lower())\n+    if not os.path.isdir(blockly_dir):\n+        os.mkdir(blockly_dir)\n+    blockly_file = os.path.join(blockly_dir, '_messages.js')\n+    with open(args.source) as source:\n+        with open(appengine_file, 'w+') as ode_output:\n+            with open(blockly_file, 'w+') as blockly_output:\n+                blockly_output.write(blockly_header % {'lang': args.lang[0], 'lang_name': args.lang_name[0]})\n+                description = None\n+                for line in source:\n+                    if len(line) <= 2:\n+                        pass\n+                    elif line[0] == '#':\n+                        if description is not None:\n+                            description += line\n+                        else:\n+                            description = line\n+                    elif line.startswith('appengine.switchTo') or line.startswith('appengine.SwitchTo'):\n+                        pass\n+                    elif line.startswith('appengine.'):\n+                        if description is not None:\n+                            ode_output.write(description)\n+                            description = None\n+                        line = line[len('appengine.'):]\n+                        parts = [part.strip() for part in line.split(' = ', 1)]\n+                        ode_output.write(parts[0])\n+                        ode_output.write(' = ')\n+                        if parts[0].endswith('Params') or parts[0].endswith('Properties') or \\\n+                                parts[0].endswith('Methods') or parts[0].endswith('Events') or \\\n+                                (parts[0].endswith('ComponentPallette') and\n+                                 not parts[0].endswith('HelpStringComponentPallette') and\n+                                 not parts[0] in paletteItems):\n+                            parts[1] = ''.join(parts[1].split())\n+                        ode_output.write(parts[1].replace(\"'\", \"''\"))\n+                        ode_output.write('\\n\\n')\n+                    else:\n+                        parts = [part.strip() for part in line[len('blockseditor.'):].split('=', 1)]\n+                        blockly_output.write('    Blockly.Msg.')\n+                        blockly_output.write(parts[0])\n+                        blockly_output.write(' = ')\n+                        blockly_output.write(js_stringify(parts[1]))\n+                        blockly_output.write(';\\n')\n+                blockly_output.write(blockly_footer)\n+\n+\n+def propescape(s):\n+    return s.replace('\\\\\\\\', '\\\\').replace('\\\\\\'', '\\'').replace('\\\\\\\"', '\\\"').replace('\\'', '\\'\\'').replace(':', '\\\\:').replace('=', '\\\\=')\n+\n+\n+def read_block_translations(lang_code):\n+    linere = re.compile(r\"(Blockly\\.Msg\\.[A-Z_]+)\\s*=\\s*?[\\\"\\'\\[](.*)[\\\"\\'\\]];\")\n+    continuation = re.compile(r'\\s*\\+?\\s*(?:\\\"|\\')?(.*)?(?:\\\"|\\')\\s*\\+?')\n+    with open(os.path.join(appinventor_dir, 'blocklyeditor', 'src', 'msg', lang_code, '_messages.js')) as js:\n+        comment = None\n+        items = []\n+        full_line = ''\n+        is_block_comment = False\n+        is_line_continuation = False\n+        for line in js:\n+            line = line.strip()\n+            if line == '':\n+                continue\n+            if line.startswith(r'//'):\n+                comment = line[3:]\n+                continue\n+            if is_block_comment:\n+                full_line += line\n+                if line.endswith(r'*/'):\n+                    comment = full_line\n+                    is_block_comment = False\n+                    full_line = ''\n+                continue\n+            if line.startswith(r'/*'):\n+                full_line = line\n+                is_block_comment = True\n+                continue\n+            if line.endswith('{'):\n+                full_line = ''\n+                continue\n+            if line.startswith('+') or line.endswith('+'):\n+                line = continuation.match(line).group(1)\n+                is_line_continuation = True\n+            elif is_line_continuation:\n+                line = line[1:]\n+                is_line_continuation = False\n+            full_line += line\n+            if full_line.endswith(';'):\n+                match = linere.match(full_line)\n+                if match is not None:\n+                    items.append('blockseditor.%s = %s' % (match.group(1), propescape(match.group(2))))\n+                    if comment:\n+                        items.append('# Description: %s' % comment)\n+                        comment = None\n+                full_line = ''\n+        return '\\n'.join(items) + '\\n'\n+\n+\n+def combine(args):\n+    if args.lang is None:\n+        javaprops = os.path.join(appinventor_dir, 'appengine', 'build', 'extra', 'ode',\n+                              'com.google.appinventor.client.OdeMessages_default.properties')\n+        lang_code = 'en'\n+    else:\n+        lang_code = args.lang[0]\n+        javaprops = os.path.join(appinventor_dir, 'appengine', 'build', 'extra', 'ode',\n+                              'com.google.appinventor.client.OdeMessages_%s.properties' % lang_code)\n+    blockprops = read_block_translations(lang_code.lower())  # subprocess.check_output(['node', js_to_prop], text=True, encoding='utf8')\n+    with open(os.path.join(appinventor_dir, 'misc', 'i18n', 'translation_template_%s.properties' % lang_code), 'w+', encoding='utf8') as out:\n+        out.write('# Frontend definitions\\n')\n+        with open(javaprops, 'rt', encoding='utf8') as props:\n+            lastline = ''\n+            for line in props:\n+                if lastline.endswith(r'\\n') or line.startswith('#') or line.strip() == '':\n+                    out.write(line)\n+                else:\n+                    out.write('appengine.')\n+                    out.write(line)\n+        out.write('\\n# Blocks editor definitions\\n')\n+        out.write(blockprops)\n+        out.close()\n+\n+from xml.etree import ElementTree as et\n+def tmx_merge(args):\n+    if args.dest is None:\n+        raise ValueError('No --dest specified for splitting file')\n+    tmx_tree = None\n+    for sfile in args.source_files:\n+        data = et.parse(sfile).getroot()\n+        if tmx_tree is None:\n+            tmx_tree = data\n+        else:\n+            for tu in data.iter('tu'):\n+                insertion_point = tmx_tree.find(\"./body/tu/[@tuid='%s']\" % tu.attrib[\"tuid\"])\n+                if insertion_point is not None:\n+                    for child in tu:\n+                        insertion_point.append(child)\n+    if tmx_tree is not None:\n+        with open(args.dest[0], 'w+') as ofile:\n+            ofile.write(et.tostring(tmx_tree, encoding='utf8').decode('utf8'))\n+    else:\n+        raise ValueError('No output')\n+\n+def parse_args():\n+    parser = argparse.ArgumentParser(description='App Inventor internationalization toolkit')\n+    subparsers = parser.add_subparsers()\n+    parser_combine = subparsers.add_parser('combine')\n+    parser_combine.add_argument('--lang', nargs=1, type=str, action='store')\n+    parser_combine.set_defaults(func=combine)\n+    parser_split = subparsers.add_parser('split')\n+    parser_split.add_argument('--lang', nargs=1, type=str, action='store')\n+    parser_split.add_argument('--lang_name', nargs=1, type=str, action='store')\n+    parser_split.add_argument('source')\n+    parser_split.set_defaults(func=split)\n+    parser_tmxmerge = subparsers.add_parser('tmx_merge')\n+    parser_tmxmerge.add_argument('--dest', nargs=1, type=str, action='store')\n+    parser_tmxmerge.add_argument('source_files', nargs=argparse.REMAINDER)\n+    parser_tmxmerge.set_defaults(func=tmx_merge)\n+    args = parser.parse_args()\n+    if not hasattr(args, 'func'):\n+        parser.error('One of either combine or split must be specified')\n+    return args\n+\n+\n+def main():\n+    args = parse_args()\n+    args.func(args)\n+\n+\n+if __name__ == '__main__':\n+    main()\n+"
  },
  {
    "sha": "6f402acf1639ff2038fe2069f657932318f9402b",
    "filename": "appinventor/misc/passwordmail/getmail.fcgi",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/passwordmail/getmail.fcgi",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/passwordmail/getmail.fcgi",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/passwordmail/getmail.fcgi?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -22,7 +22,7 @@ init()\n @route('/', method='POST')\n def store():\n     d = {}\n-    for k,v in request.POST.items():\n+    for k,v in list(request.POST.items()):\n         d[k] = v.decode('utf-8')\n     message = Message()\n     message.email = d['email']"
  },
  {
    "sha": "3df277b57d15316e377ecb998afa39cb45f052da",
    "filename": "appinventor/misc/passwordmail/getmail.fcgi.bak",
    "status": "added",
    "additions": 52,
    "deletions": 0,
    "changes": 52,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/passwordmail/getmail.fcgi.bak",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/passwordmail/getmail.fcgi.bak",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/passwordmail/getmail.fcgi.bak?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -0,0 +1,52 @@\n+#!/usr/bin/python\n+from bottle import run,route,app,request,response,template,default_app,Bottle,debug,abort\n+from flup.server.fcgi import WSGIServer\n+from email.utils import formatdate\n+from email.parser import Parser\n+import smtplib\n+from email.charset import add_charset\n+import pika\n+\n+from message_pb2 import Message\n+\n+app = Bottle()\n+default_app.push(app)\n+\n+def init():\n+    global channel\n+    conn = pika.BlockingConnection()\n+    channel = conn.channel()\n+\n+init()\n+\n+@route('/', method='POST')\n+def store():\n+    d = {}\n+    for k,v in request.POST.items():\n+        d[k] = v.decode('utf-8')\n+    message = Message()\n+    message.email = d['email']\n+    message.url = d['url']\n+    message.locale = d.get('locale', 'en')\n+    if d.get('pass') != 'changeme':\n+        return ''\n+    channel.basic_publish('', 'passmail', message.SerializeToString(),\n+                          pika.BasicProperties(content_type='text/plain',\n+                                               delivery_mode=1))\n+    response.headers['Access-Control-Allow-Origin'] = '*'\n+    response.headers['Access-Control-Allow-Headers'] = 'origin, content-type'\n+    return ''\n+\n+@route('/', method='OPTIONS')\n+def options():\n+    response.headers['Access-Control-Allow-Origin'] = '*'\n+    response.headers['Access-Control-Allow-Headers'] = 'origin, content-type'\n+    return ''\n+\n+debug(True)\n+\n+\n+\n+##run(host='127.0.0.1', port=8080)\n+WSGIServer(app).run()\n+"
  },
  {
    "sha": "08db56b92666b278b11f43e95b8c466db8391549",
    "filename": "appinventor/misc/passwordmail/mailsender.py",
    "status": "modified",
    "additions": 4,
    "deletions": 4,
    "changes": 8,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/passwordmail/mailsender.py",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/passwordmail/mailsender.py",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/passwordmail/mailsender.py?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -14,7 +14,7 @@\n def on_message(channel, method_frame, header_frame, body):\n     sys.stderr.write(\"%s...\" % method_frame.delivery_tag)\n     m = Message.FromString(body)\n-    print 'New Message: email = %s, url = %s, locale = %s' % (m.email, m.url, m.locale)\n+    print('New Message: email = %s, url = %s, locale = %s' % (m.email, m.url, m.locale))\n     sendmail(m.email, m.url, m.locale)\n     channel.basic_ack(delivery_tag=method_frame.delivery_tag)\n \n@@ -25,7 +25,7 @@ def __init__(self, queue, handler):\n         self.handler = handler\n \n     def start(self, arg):\n-        print 'Queue %s Declared and Ready' % self.queue\n+        print('Queue %s Declared and Ready' % self.queue)\n         channel.basic_consume(self.handler, self.queue)\n \n def sendmail(email, url, locale):\n@@ -61,8 +61,8 @@ def sendmail(email, url, locale):\n \n The MIT App Inventor Team\n ''',\n-              'zh_TW' :  u'To: %s\\nContent-Type: text/plain; charset=utf-8; format=flowed\\nContent-Transfer-Encoding: 8bit\\nSubject: =?UTF-8?B?6K+35qOA5p+l5oKo55qE55S15a2Q6YKu5Lu277yM5oiR5Lus5bey57uP5Y+R6YCB6ZO+5o6l57uZ5L2g6K6+572u5L2g55qE5Yid6K6+5a+G56CBL+aUueWPmOS9oOeahOaXp+WvhueggeOAgg==?=\\n\\n\\u4f60\\u5411\\u7cfb\\u7edf\\u8981\\u6c42\\u8bbe\\u7f6e\\u4f60 MIT App Inventor \\u8d26\\u6237\\u7684\\u521d\\u8bbe\\u5bc6\\u7801/\\u66f4\\u6539\\u65e7\\u7684\\u5bc6\\u7801\\u3002\\n\\u4f7f\\u7528\\u4e0b\\u9762\\u7684\\u94fe\\u63a5\\u8bbe\\u7f6e\\u521d\\u8bbe\\u6216\\u91cd\\u7f6e\\u60a8\\u7684\\u5bc6\\u7801\\u3002\\u4f60\\u70b9\\u51fb\\n\\u8fd9\\u4e2a\\u94fe\\u63a5\\u540e\\uff0c\\u4f60\\u5c06\\u88ab\\u8981\\u6c42\\u63d0\\u4f9b\\u4e00\\u4e2a\\u65b0\\u5bc6\\u7801\\u3002\\u4e00\\u65e6\\u4f60\\u8f93\\u5165\\u4e86\\u5bc6\\u7801\\n\\uff0c\\u4f60\\u4f1a\\u6210\\u529f\\u767b\\u5f55\\u5230 Apple Inventor \\u3002\\n\\u3000\\u3000\\n\\u3000\\u3000\\u4f60\\u7684\\u94fe\\u63a5\\u662f: %s\\n\\u3000\\u3000\\n\\u3000\\u3000\\u5feb\\u4e50\\u521b\\u9020!\\nMIT App Inventor \\u56e2\\u961f',\n-              'zh_CN' : u'To: %s\\nContent-Type: text/plain; charset=utf-8; format=flowed\\nContent-Transfer-Encoding: 8bit\\nSubject: =?UTF-8?B?6K+35qOA5p+l5oKo55qE55S15a2Q6YKu5Lu277yM5oiR5Lus5bey57uP5Y+R6YCB6ZO+5o6l57uZ5L2g6K6+572u5L2g55qE5Yid6K6+5a+G56CBL+aUueWPmOS9oOeahOaXp+WvhueggeOAgg==?=\\n\\n\\u4f60\\u5411\\u7cfb\\u7edf\\u8981\\u6c42\\u8bbe\\u7f6e\\u4f60 MIT App Inventor \\u8d26\\u6237\\u7684\\u521d\\u8bbe\\u5bc6\\u7801/\\u66f4\\u6539\\u65e7\\u7684\\u5bc6\\u7801\\u3002\\n\\u4f7f\\u7528\\u4e0b\\u9762\\u7684\\u94fe\\u63a5\\u8bbe\\u7f6e\\u521d\\u8bbe\\u6216\\u91cd\\u7f6e\\u60a8\\u7684\\u5bc6\\u7801\\u3002\\u4f60\\u70b9\\u51fb\\n\\u8fd9\\u4e2a\\u94fe\\u63a5\\u540e\\uff0c\\u4f60\\u5c06\\u88ab\\u8981\\u6c42\\u63d0\\u4f9b\\u4e00\\u4e2a\\u65b0\\u5bc6\\u7801\\u3002\\u4e00\\u65e6\\u4f60\\u8f93\\u5165\\u4e86\\u5bc6\\u7801\\n\\uff0c\\u4f60\\u4f1a\\u6210\\u529f\\u767b\\u5f55\\u5230 Apple Inventor \\u3002\\n\\u3000\\u3000\\n\\u3000\\u3000\\u4f60\\u7684\\u94fe\\u63a5\\u662f: %s\\n\\u3000\\u3000\\n\\u3000\\u3000\\u5feb\\u4e50\\u521b\\u9020!\\nMIT App Inventor \\u56e2\\u961f',\n+              'zh_TW' :  'To: %s\\nContent-Type: text/plain; charset=utf-8; format=flowed\\nContent-Transfer-Encoding: 8bit\\nSubject: =?UTF-8?B?6K+35qOA5p+l5oKo55qE55S15a2Q6YKu5Lu277yM5oiR5Lus5bey57uP5Y+R6YCB6ZO+5o6l57uZ5L2g6K6+572u5L2g55qE5Yid6K6+5a+G56CBL+aUueWPmOS9oOeahOaXp+WvhueggeOAgg==?=\\n\\n\\u4f60\\u5411\\u7cfb\\u7edf\\u8981\\u6c42\\u8bbe\\u7f6e\\u4f60 MIT App Inventor \\u8d26\\u6237\\u7684\\u521d\\u8bbe\\u5bc6\\u7801/\\u66f4\\u6539\\u65e7\\u7684\\u5bc6\\u7801\\u3002\\n\\u4f7f\\u7528\\u4e0b\\u9762\\u7684\\u94fe\\u63a5\\u8bbe\\u7f6e\\u521d\\u8bbe\\u6216\\u91cd\\u7f6e\\u60a8\\u7684\\u5bc6\\u7801\\u3002\\u4f60\\u70b9\\u51fb\\n\\u8fd9\\u4e2a\\u94fe\\u63a5\\u540e\\uff0c\\u4f60\\u5c06\\u88ab\\u8981\\u6c42\\u63d0\\u4f9b\\u4e00\\u4e2a\\u65b0\\u5bc6\\u7801\\u3002\\u4e00\\u65e6\\u4f60\\u8f93\\u5165\\u4e86\\u5bc6\\u7801\\n\\uff0c\\u4f60\\u4f1a\\u6210\\u529f\\u767b\\u5f55\\u5230 Apple Inventor \\u3002\\n\\u3000\\u3000\\n\\u3000\\u3000\\u4f60\\u7684\\u94fe\\u63a5\\u662f: %s\\n\\u3000\\u3000\\n\\u3000\\u3000\\u5feb\\u4e50\\u521b\\u9020!\\nMIT App Inventor \\u56e2\\u961f',\n+              'zh_CN' : 'To: %s\\nContent-Type: text/plain; charset=utf-8; format=flowed\\nContent-Transfer-Encoding: 8bit\\nSubject: =?UTF-8?B?6K+35qOA5p+l5oKo55qE55S15a2Q6YKu5Lu277yM5oiR5Lus5bey57uP5Y+R6YCB6ZO+5o6l57uZ5L2g6K6+572u5L2g55qE5Yid6K6+5a+G56CBL+aUueWPmOS9oOeahOaXp+WvhueggeOAgg==?=\\n\\n\\u4f60\\u5411\\u7cfb\\u7edf\\u8981\\u6c42\\u8bbe\\u7f6e\\u4f60 MIT App Inventor \\u8d26\\u6237\\u7684\\u521d\\u8bbe\\u5bc6\\u7801/\\u66f4\\u6539\\u65e7\\u7684\\u5bc6\\u7801\\u3002\\n\\u4f7f\\u7528\\u4e0b\\u9762\\u7684\\u94fe\\u63a5\\u8bbe\\u7f6e\\u521d\\u8bbe\\u6216\\u91cd\\u7f6e\\u60a8\\u7684\\u5bc6\\u7801\\u3002\\u4f60\\u70b9\\u51fb\\n\\u8fd9\\u4e2a\\u94fe\\u63a5\\u540e\\uff0c\\u4f60\\u5c06\\u88ab\\u8981\\u6c42\\u63d0\\u4f9b\\u4e00\\u4e2a\\u65b0\\u5bc6\\u7801\\u3002\\u4e00\\u65e6\\u4f60\\u8f93\\u5165\\u4e86\\u5bc6\\u7801\\n\\uff0c\\u4f60\\u4f1a\\u6210\\u529f\\u767b\\u5f55\\u5230 Apple Inventor \\u3002\\n\\u3000\\u3000\\n\\u3000\\u3000\\u4f60\\u7684\\u94fe\\u63a5\\u662f: %s\\n\\u3000\\u3000\\n\\u3000\\u3000\\u5feb\\u4e50\\u521b\\u9020!\\nMIT App Inventor \\u56e2\\u961f',\n               }\n \n connection = pika.BlockingConnection()"
  },
  {
    "sha": "1ca7ab631bb2632c38555c86c8405343ae95687f",
    "filename": "appinventor/misc/passwordmail/mailsender.py.bak",
    "status": "added",
    "additions": 78,
    "deletions": 0,
    "changes": 78,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/passwordmail/mailsender.py.bak",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/passwordmail/mailsender.py.bak",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/passwordmail/mailsender.py.bak?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -0,0 +1,78 @@\n+import pika\n+import sys\n+from email.utils import formatdate\n+from email.parser import Parser\n+import smtplib\n+from getpass import getpass\n+from email.charset import add_charset\n+\n+from message_pb2 import Message\n+\n+parser = Parser()\n+password = getpass()\n+\n+def on_message(channel, method_frame, header_frame, body):\n+    sys.stderr.write(\"%s...\" % method_frame.delivery_tag)\n+    m = Message.FromString(body)\n+    print 'New Message: email = %s, url = %s, locale = %s' % (m.email, m.url, m.locale)\n+    sendmail(m.email, m.url, m.locale)\n+    channel.basic_ack(delivery_tag=method_frame.delivery_tag)\n+\n+class _setupconsume(object):\n+\n+    def __init__(self, queue, handler):\n+        self.queue = queue\n+        self.handler = handler\n+\n+    def start(self, arg):\n+        print 'Queue %s Declared and Ready' % self.queue\n+        channel.basic_consume(self.handler, self.queue)\n+\n+def sendmail(email, url, locale):\n+    t = templates.get(locale, None)\n+    if t == None:\n+        t = templates.get('en')\n+    if locale != 'en':\n+        url += '?locale=' + locale\n+    m = parser.parsestr((t % (email, url)).encode('utf8'))\n+    m['Date'] = formatdate(localtime=True)\n+    s = smtplib.SMTP('osiris.mit.edu', 587)\n+    s.starttls()\n+    s.login('jis', password)\n+    try:\n+        retval = s.sendmail('appinventor@osiris.mit.edu', [email,], str(m))\n+    except:\n+        import traceback\n+        traceback.print_exc()\n+    s.quit()\n+\n+templates = { 'en' : '''From: MIT App Inventor System <appinventor@mit.edu>\n+To: %s\n+Subject: Password Reset for you MIT App Inventor Account\n+\n+You have requested a new password for your MIT App Inventor Account.\n+Use the link below to set (or reset) your password. After you click on\n+this link you will be asked to provide a new password. Once you do that\n+you will be logged in to App Inventor.\n+\n+    Your Link is: %s\n+\n+Happy Inventing!\n+\n+The MIT App Inventor Team\n+''',\n+              'zh_TW' :  u'To: %s\\nContent-Type: text/plain; charset=utf-8; format=flowed\\nContent-Transfer-Encoding: 8bit\\nSubject: =?UTF-8?B?6K+35qOA5p+l5oKo55qE55S15a2Q6YKu5Lu277yM5oiR5Lus5bey57uP5Y+R6YCB6ZO+5o6l57uZ5L2g6K6+572u5L2g55qE5Yid6K6+5a+G56CBL+aUueWPmOS9oOeahOaXp+WvhueggeOAgg==?=\\n\\n\\u4f60\\u5411\\u7cfb\\u7edf\\u8981\\u6c42\\u8bbe\\u7f6e\\u4f60 MIT App Inventor \\u8d26\\u6237\\u7684\\u521d\\u8bbe\\u5bc6\\u7801/\\u66f4\\u6539\\u65e7\\u7684\\u5bc6\\u7801\\u3002\\n\\u4f7f\\u7528\\u4e0b\\u9762\\u7684\\u94fe\\u63a5\\u8bbe\\u7f6e\\u521d\\u8bbe\\u6216\\u91cd\\u7f6e\\u60a8\\u7684\\u5bc6\\u7801\\u3002\\u4f60\\u70b9\\u51fb\\n\\u8fd9\\u4e2a\\u94fe\\u63a5\\u540e\\uff0c\\u4f60\\u5c06\\u88ab\\u8981\\u6c42\\u63d0\\u4f9b\\u4e00\\u4e2a\\u65b0\\u5bc6\\u7801\\u3002\\u4e00\\u65e6\\u4f60\\u8f93\\u5165\\u4e86\\u5bc6\\u7801\\n\\uff0c\\u4f60\\u4f1a\\u6210\\u529f\\u767b\\u5f55\\u5230 Apple Inventor \\u3002\\n\\u3000\\u3000\\n\\u3000\\u3000\\u4f60\\u7684\\u94fe\\u63a5\\u662f: %s\\n\\u3000\\u3000\\n\\u3000\\u3000\\u5feb\\u4e50\\u521b\\u9020!\\nMIT App Inventor \\u56e2\\u961f',\n+              'zh_CN' : u'To: %s\\nContent-Type: text/plain; charset=utf-8; format=flowed\\nContent-Transfer-Encoding: 8bit\\nSubject: =?UTF-8?B?6K+35qOA5p+l5oKo55qE55S15a2Q6YKu5Lu277yM5oiR5Lus5bey57uP5Y+R6YCB6ZO+5o6l57uZ5L2g6K6+572u5L2g55qE5Yid6K6+5a+G56CBL+aUueWPmOS9oOeahOaXp+WvhueggeOAgg==?=\\n\\n\\u4f60\\u5411\\u7cfb\\u7edf\\u8981\\u6c42\\u8bbe\\u7f6e\\u4f60 MIT App Inventor \\u8d26\\u6237\\u7684\\u521d\\u8bbe\\u5bc6\\u7801/\\u66f4\\u6539\\u65e7\\u7684\\u5bc6\\u7801\\u3002\\n\\u4f7f\\u7528\\u4e0b\\u9762\\u7684\\u94fe\\u63a5\\u8bbe\\u7f6e\\u521d\\u8bbe\\u6216\\u91cd\\u7f6e\\u60a8\\u7684\\u5bc6\\u7801\\u3002\\u4f60\\u70b9\\u51fb\\n\\u8fd9\\u4e2a\\u94fe\\u63a5\\u540e\\uff0c\\u4f60\\u5c06\\u88ab\\u8981\\u6c42\\u63d0\\u4f9b\\u4e00\\u4e2a\\u65b0\\u5bc6\\u7801\\u3002\\u4e00\\u65e6\\u4f60\\u8f93\\u5165\\u4e86\\u5bc6\\u7801\\n\\uff0c\\u4f60\\u4f1a\\u6210\\u529f\\u767b\\u5f55\\u5230 Apple Inventor \\u3002\\n\\u3000\\u3000\\n\\u3000\\u3000\\u4f60\\u7684\\u94fe\\u63a5\\u662f: %s\\n\\u3000\\u3000\\n\\u3000\\u3000\\u5feb\\u4e50\\u521b\\u9020!\\nMIT App Inventor \\u56e2\\u961f',\n+              }\n+\n+connection = pika.BlockingConnection()\n+channel = connection.channel()\n+channel.queue_declare(queue='passmail', durable=True, callback=_setupconsume('passmail', on_message).start)\n+channel.basic_consume(on_message, 'passmail')\n+\n+try:\n+    channel.start_consuming()\n+except KeyboardInterrupt:\n+    channel.stop_consuming()\n+\n+connection.close()"
  },
  {
    "sha": "12665d1fa6ee5f9a7e31b048babf2568b03a33b7",
    "filename": "appinventor/misc/passwordmail/message_pb2.py",
    "status": "modified",
    "additions": 4,
    "deletions": 5,
    "changes": 9,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/passwordmail/message_pb2.py",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/passwordmail/message_pb2.py",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/passwordmail/message_pb2.py?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -28,21 +28,21 @@\n     _descriptor.FieldDescriptor(\n       name='email', full_name='Message.email', index=0,\n       number=1, type=9, cpp_type=9, label=2,\n-      has_default_value=False, default_value=unicode(\"\", \"utf-8\"),\n+      has_default_value=False, default_value=str(\"\", \"utf-8\"),\n       message_type=None, enum_type=None, containing_type=None,\n       is_extension=False, extension_scope=None,\n       options=None),\n     _descriptor.FieldDescriptor(\n       name='url', full_name='Message.url', index=1,\n       number=2, type=9, cpp_type=9, label=1,\n-      has_default_value=False, default_value=unicode(\"\", \"utf-8\"),\n+      has_default_value=False, default_value=str(\"\", \"utf-8\"),\n       message_type=None, enum_type=None, containing_type=None,\n       is_extension=False, extension_scope=None,\n       options=None),\n     _descriptor.FieldDescriptor(\n       name='locale', full_name='Message.locale', index=2,\n       number=3, type=9, cpp_type=9, label=1,\n-      has_default_value=False, default_value=unicode(\"\", \"utf-8\"),\n+      has_default_value=False, default_value=str(\"\", \"utf-8\"),\n       message_type=None, enum_type=None, containing_type=None,\n       is_extension=False, extension_scope=None,\n       options=None),\n@@ -61,8 +61,7 @@\n \n DESCRIPTOR.message_types_by_name['Message'] = _MESSAGE\n \n-class Message(_message.Message):\n-  __metaclass__ = _reflection.GeneratedProtocolMessageType\n+class Message(_message.Message, metaclass=_reflection.GeneratedProtocolMessageType):\n   DESCRIPTOR = _MESSAGE\n \n   # @@protoc_insertion_point(class_scope:Message)"
  },
  {
    "sha": "86ce8eafb57507b77614a630e8b8b7b88cdf89bb",
    "filename": "appinventor/misc/passwordmail/message_pb2.py.bak",
    "status": "added",
    "additions": 71,
    "deletions": 0,
    "changes": 71,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/passwordmail/message_pb2.py.bak",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/passwordmail/message_pb2.py.bak",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/passwordmail/message_pb2.py.bak?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -0,0 +1,71 @@\n+# Generated by the protocol buffer compiler.  DO NOT EDIT!\n+# source: message.proto\n+\n+from google.protobuf import descriptor as _descriptor\n+from google.protobuf import message as _message\n+from google.protobuf import reflection as _reflection\n+from google.protobuf import descriptor_pb2\n+# @@protoc_insertion_point(imports)\n+\n+\n+\n+\n+DESCRIPTOR = _descriptor.FileDescriptor(\n+  name='message.proto',\n+  package='',\n+  serialized_pb='\\n\\rmessage.proto\\\"5\\n\\x07Message\\x12\\r\\n\\x05\\x65mail\\x18\\x01 \\x02(\\t\\x12\\x0b\\n\\x03url\\x18\\x02 \\x01(\\t\\x12\\x0e\\n\\x06locale\\x18\\x03 \\x01(\\t')\n+\n+\n+\n+\n+_MESSAGE = _descriptor.Descriptor(\n+  name='Message',\n+  full_name='Message',\n+  filename=None,\n+  file=DESCRIPTOR,\n+  containing_type=None,\n+  fields=[\n+    _descriptor.FieldDescriptor(\n+      name='email', full_name='Message.email', index=0,\n+      number=1, type=9, cpp_type=9, label=2,\n+      has_default_value=False, default_value=unicode(\"\", \"utf-8\"),\n+      message_type=None, enum_type=None, containing_type=None,\n+      is_extension=False, extension_scope=None,\n+      options=None),\n+    _descriptor.FieldDescriptor(\n+      name='url', full_name='Message.url', index=1,\n+      number=2, type=9, cpp_type=9, label=1,\n+      has_default_value=False, default_value=unicode(\"\", \"utf-8\"),\n+      message_type=None, enum_type=None, containing_type=None,\n+      is_extension=False, extension_scope=None,\n+      options=None),\n+    _descriptor.FieldDescriptor(\n+      name='locale', full_name='Message.locale', index=2,\n+      number=3, type=9, cpp_type=9, label=1,\n+      has_default_value=False, default_value=unicode(\"\", \"utf-8\"),\n+      message_type=None, enum_type=None, containing_type=None,\n+      is_extension=False, extension_scope=None,\n+      options=None),\n+  ],\n+  extensions=[\n+  ],\n+  nested_types=[],\n+  enum_types=[\n+  ],\n+  options=None,\n+  is_extendable=False,\n+  extension_ranges=[],\n+  serialized_start=17,\n+  serialized_end=70,\n+)\n+\n+DESCRIPTOR.message_types_by_name['Message'] = _MESSAGE\n+\n+class Message(_message.Message):\n+  __metaclass__ = _reflection.GeneratedProtocolMessageType\n+  DESCRIPTOR = _MESSAGE\n+\n+  # @@protoc_insertion_point(class_scope:Message)\n+\n+\n+# @@protoc_insertion_point(module_scope)"
  },
  {
    "sha": "5f2d335a2b8b4da31ab53330afeae77d6bc1bf68",
    "filename": "appinventor/misc/splashscreen/splashmanager.py",
    "status": "modified",
    "additions": 9,
    "deletions": 9,
    "changes": 18,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/splashscreen/splashmanager.py",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/splashscreen/splashmanager.py",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/splashscreen/splashmanager.py?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -14,7 +14,7 @@\n \n \n def auth_func():\n-  return (raw_input('Email: '), getpass.getpass('Password: '))\n+  return (input('Email: '), getpass.getpass('Password: '))\n \n def main():\n     getlibdir()\n@@ -67,7 +67,7 @@ class SplashData(db.Model):\n         sys.stderr.write('Usage: splashmanager.py [-f splashfile -w width -h height] [-H host] \\n')\n         sys.exit(1)\n \n-    print 'Connecting to %s' % host\n+    print('Connecting to %s' % host)\n     if host == 'localhost':\n         host = host + ':8888'\n         secure = False\n@@ -83,7 +83,7 @@ class SplashData(db.Model):\n     update = False\n     sd = SplashData.all().fetch(1)[0]\n     if getversion:\n-        print 'Splash Version: %d' % sd.version\n+        print('Splash Version: %d' % sd.version)\n     if setversion:\n         sd.version = setversion\n         update = True\n@@ -105,16 +105,16 @@ class SplashData(db.Model):\n def getlibdir():\n     '''Find the googl_appengine library directory'''\n     from os.path import expanduser\n-    import ConfigParser\n+    import configparser\n     doupdate = False\n-    config = ConfigParser.RawConfigParser()\n+    config = configparser.RawConfigParser()\n     configfile = expanduser('~/.appinv_splashmanager')\n     config.read(configfile)\n     libdir = '/usr/local/google_appengine' # Default\n     if config.has_section('splashmanager'):\n         try:\n             libdir = config.get('splashmanager', 'googlelibdir')\n-        except ConfigParser.NoOptionError:\n+        except configparser.NoOptionError:\n             config.set('splashmanager', 'googlelibdir', libdir)\n             doupdate = True\n     else:\n@@ -129,15 +129,15 @@ def getlibdir():\n     try:\n         from google.appengine.ext import db\n     except ImportError:\n-        newpath = raw_input('Google Python App Engine SDK Path [%s]: ' % libdir)\n+        newpath = input('Google Python App Engine SDK Path [%s]: ' % libdir)\n         if newpath == '':\n             newpath = libdir\n         libdir = newpath\n         config.set('splashmanager', 'googlelibdir', libdir)\n         f = open(configfile, 'w')\n         config.write(f)\n         f.close()\n-        print 'Location of Google Library Directory Saved, exiting, try again...'\n+        print('Location of Google Library Directory Saved, exiting, try again...')\n         sys.exit(0)\n \n # The stuff below is to permit the prompt for the library dir to\n@@ -190,7 +190,7 @@ def complete(self, text, state):\n try:\n     import readline\n except ImportError:\n-    print \"Module readline not available.\"\n+    print(\"Module readline not available.\")\n else:\n     import rlcompleter\n     readline.set_completer_delims(' \\t\\n;')"
  },
  {
    "sha": "550c06928dc367e2b279271d9fe2d15e710c66e2",
    "filename": "appinventor/misc/splashscreen/splashmanager.py.bak",
    "status": "added",
    "additions": 202,
    "deletions": 0,
    "changes": 202,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/splashscreen/splashmanager.py.bak",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/splashscreen/splashmanager.py.bak",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/splashscreen/splashmanager.py.bak?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -0,0 +1,202 @@\n+#!/usr/bin/env python\n+#\n+# Simple tool for managing the Splash Screen in MIT App Inventor using\n+# the Remote API Service\n+#\n+# @author Jeffrey I. Schiller <jis@mit.edu>\n+\n+import os\n+import sys\n+import getpass\n+from getopt import getopt, GetoptError\n+\n+os.environ['SERVER_SOFTWARE'] = 'MIT SplashScreen Manager 1.0' # Googlism\n+\n+\n+def auth_func():\n+  return (raw_input('Email: '), getpass.getpass('Password: '))\n+\n+def main():\n+    getlibdir()\n+    from google.appengine.ext import db\n+    from google.appengine.ext.remote_api import remote_api_stub\n+    from google.appengine.tools import appengine_rpc\n+\n+    class SplashData(db.Model):\n+        version = db.IntegerProperty()\n+        content = db.TextProperty()\n+        width = db.IntegerProperty()\n+        height = db.IntegerProperty()\n+\n+    filename = None\n+    host = 'localhost'\n+    getversion = False\n+    bumpversion = False\n+    setversion = None\n+    width = None\n+    height = None\n+    try:\n+        opts = getopt(sys.argv[1:], 'sbgf:w:h:H:', ['set','bump','getversion','file=','width=','height=','host='])\n+    except GetoptError:\n+        sys.stderr.write('Usage: splashmanager.py [-f splashfile -w width -h height] [-H host] \\n')\n+        sys.exit(1)\n+    for opt in opts[0]:\n+        if opt == []:\n+            continue\n+        if len(opt) < 2:\n+            sys.stderr.write('Usage: splashmanager.py [-f splashfile -w width -h height] [-H host] \\n')\n+            sys.exit(1)\n+        if opt[0] in ('--file', '-f'):\n+            filename = opt[1]\n+            whitelistname = opt[1]\n+        elif opt[0] in ('-H','--host'):\n+            host = opt[1]\n+        elif opt[0] in ('-g','--getversion'):\n+            getversion = True\n+        elif opt[0] in ('--bump','-b'):\n+            bumpversion = True\n+        elif opt[0] in ('-w','--width'):\n+            width = opt[1]\n+        elif opt[0] in ('-h','--host'):\n+            height = opt[1]\n+        elif opt[0] in ('-s','--set'):\n+            setversion = opt[1]\n+\n+    if setversion and bumpversion:\n+        sys.stderr.write('Error: -s and -b are incompatible, use one or the other.\\n')\n+        sys.stderr.write('Usage: splashmanager.py [-f splashfile -w width -h height] [-H host] \\n')\n+        sys.exit(1)\n+\n+    print 'Connecting to %s' % host\n+    if host == 'localhost':\n+        host = host + ':8888'\n+        secure = False\n+    else:\n+        secure = True\n+\n+    remote_api_stub.ConfigureRemoteApi(None, '/remote_api', auth_func,\n+                                       servername=host,\n+                                       save_cookies=True, secure=secure,\n+                                       rpc_server_factory=appengine_rpc.HttpRpcServer)\n+    remote_api_stub.MaybeInvokeAuthentication()\n+\n+    update = False\n+    sd = SplashData.all().fetch(1)[0]\n+    if getversion:\n+        print 'Splash Version: %d' % sd.version\n+    if setversion:\n+        sd.version = setversion\n+        update = True\n+    if filename:\n+        if width == None or height == None:\n+            sys.stderr.write('Must specify width and height while you provide a file.\\n')\n+            sys.exit(1)\n+        data = open(filename).read()\n+        sd.content = data\n+        sd.width = int(width)\n+        sd.height = int(height)\n+        update = True\n+    if bumpversion:\n+        sd.version = sd.version + 1\n+        update = True\n+    if update:\n+        sd.put()\n+\n+def getlibdir():\n+    '''Find the googl_appengine library directory'''\n+    from os.path import expanduser\n+    import ConfigParser\n+    doupdate = False\n+    config = ConfigParser.RawConfigParser()\n+    configfile = expanduser('~/.appinv_splashmanager')\n+    config.read(configfile)\n+    libdir = '/usr/local/google_appengine' # Default\n+    if config.has_section('splashmanager'):\n+        try:\n+            libdir = config.get('splashmanager', 'googlelibdir')\n+        except ConfigParser.NoOptionError:\n+            config.set('splashmanager', 'googlelibdir', libdir)\n+            doupdate = True\n+    else:\n+        config.add_section('splashmanager')\n+        doupdate = True\n+    if doupdate:\n+        f = open(configfile, 'w')\n+        config.write(f)\n+        f.close()\n+    sys.path.insert(0, libdir)\n+    sys.path.insert(1, libdir + '/lib/fancy_urllib')\n+    try:\n+        from google.appengine.ext import db\n+    except ImportError:\n+        newpath = raw_input('Google Python App Engine SDK Path [%s]: ' % libdir)\n+        if newpath == '':\n+            newpath = libdir\n+        libdir = newpath\n+        config.set('splashmanager', 'googlelibdir', libdir)\n+        f = open(configfile, 'w')\n+        config.write(f)\n+        f.close()\n+        print 'Location of Google Library Directory Saved, exiting, try again...'\n+        sys.exit(0)\n+\n+# The stuff below is to permit the prompt for the library dir to\n+# use filename completion....\n+\n+class Completer(object):\n+\n+    def _listdir(self, root):\n+        \"List directory 'root' appending the path separator to subdirs.\"\n+        res = []\n+        for name in os.listdir(root):\n+            path = os.path.join(root, name)\n+            if os.path.isdir(path):\n+                name += os.sep\n+            res.append(name)\n+        return res\n+\n+    def _complete_path(self, path=None):\n+        \"Perform completion of filesystem path.\"\n+        if not path:\n+            return self._listdir('.')\n+        dirname, rest = os.path.split(path)\n+        tmp = dirname if dirname else '.'\n+        res = [os.path.join(dirname, p)\n+                for p in self._listdir(tmp) if p.startswith(rest)]\n+        # more than one match, or single match which does not exist (typo)\n+        if len(res) > 1 or not os.path.exists(path):\n+            return res\n+        # resolved to a single directory, so return list of files below it\n+        if os.path.isdir(path):\n+            return [os.path.join(path, p) for p in self._listdir(path)]\n+        # exact file match terminates this completion\n+        return [path + ' ']\n+\n+    def complete_filename(self, args):\n+        \"Completions for the 'extra' command.\"\n+        if not args:\n+            return self._complete_path('.')\n+        # treat the last arg as a path and complete it\n+        return self._complete_path(args[-1])\n+\n+    def complete(self, text, state):\n+        \"Generic readline completion entry point.\"\n+        buffer = readline.get_line_buffer()\n+        line = buffer.split()\n+        return (self.complete_filename(line) + [None])[state]\n+\n+comp = Completer()\n+\n+try:\n+    import readline\n+except ImportError:\n+    print \"Module readline not available.\"\n+else:\n+    import rlcompleter\n+    readline.set_completer_delims(' \\t\\n;')\n+    readline.parse_and_bind(\"tab: complete\")\n+    readline.set_completer(comp.complete)\n+\n+if __name__ == '__main__':\n+    main()\n+"
  },
  {
    "sha": "6fd9196a570b5c1033a10fc0b4b6e67d1969b383",
    "filename": "appinventor/misc/whitelist/whitelist.py",
    "status": "modified",
    "additions": 17,
    "deletions": 17,
    "changes": 34,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/whitelist/whitelist.py",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/whitelist/whitelist.py",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/whitelist/whitelist.py?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -15,10 +15,10 @@\n os.environ['SERVER_SOFTWARE'] = 'MIT Whitelist Generator 1.0' # Googlism\n \n def auth_func():\n-  return (raw_input('Email: '), getpass.getpass('Password: '))\n+  return (input('Email: '), getpass.getpass('Password: '))\n \n def main():\n-    if sys.modules.has_key('google'):\n+    if 'google' in sys.modules:\n       del sys.modules['google'] # This interferes with imports later\n     getlibdir()\n     from google.appengine.ext import db\n@@ -51,8 +51,8 @@ class WhiteListData(db.Model):\n         elif opt[0] == '--getonly':\n             getonly = True\n \n-    print 'Using %s for input' % whitelistname\n-    print 'Connecting to %s' % host\n+    print('Using %s for input' % whitelistname)\n+    print('Connecting to %s' % host)\n     if host == 'localhost':\n         host = host + ':8888'\n         secure = False\n@@ -84,49 +84,49 @@ class WhiteListData(db.Model):\n             break\n \n     if getonly:\n-        print 'Getonly set, returning existing whitelist with no changes'\n+        print('Getonly set, returning existing whitelist with no changes')\n         for person in installed_people:\n-            print person.emailLower\n+            print(person.emailLower)\n         return\n \n     WHITE = {}\n     for email in input_people:\n-        WHITE[unicode(email)] = [0, None]\n+        WHITE[str(email)] = [0, None]\n     for person in installed_people:\n         email = person.emailLower\n-        if WHITE.has_key(email):\n+        if email in WHITE:\n             WHITE[email] = [2, person]\n         else:\n             WHITE[email] = [1, person]\n \n     # Now we go through the dictionary. Remove people in state 1\n     # and add people in state 0\n \n-    for (email, z) in WHITE.items():\n+    for (email, z) in list(WHITE.items()):\n         state, person = z\n         if state == 0:\n             v = WhiteListData()\n             v.emailLower = email\n             v.put()\n-            print 'Added %s' % email\n+            print('Added %s' % email)\n         elif state == 1:\n             person.delete()\n-            print 'Removed %s' % email\n+            print('Removed %s' % email)\n \n \n def getlibdir():\n     '''Find the googl_appengine library directory'''\n     from os.path import expanduser\n-    import ConfigParser\n+    import configparser\n     doupdate = False\n-    config = ConfigParser.RawConfigParser()\n+    config = configparser.RawConfigParser()\n     configfile = expanduser('~/.appinv_whitelist')\n     config.read(configfile)\n     libdir = '/usr/local/google_appengine' # Default\n     if config.has_section('whitelist'):\n         try:\n             libdir = config.get('whitelist', 'googlelibdir')\n-        except ConfigParser.NoOptionError:\n+        except configparser.NoOptionError:\n             config.set('whitelist', 'googlelibdir', libdir)\n             doupdate = True\n     else:\n@@ -141,15 +141,15 @@ def getlibdir():\n     try:\n         from google.appengine.ext import db\n     except ImportError:\n-        newpath = raw_input('Google Python App Engine SDK Path [%s]: ' % libdir)\n+        newpath = input('Google Python App Engine SDK Path [%s]: ' % libdir)\n         if newpath == '':\n             newpath = libdir\n         libdir = newpath\n         config.set('whitelist', 'googlelibdir', libdir)\n         f = open(configfile, 'w')\n         config.write(f)\n         f.close()\n-        print 'Location of Google Library Directory Saved, exiting, try again...'\n+        print('Location of Google Library Directory Saved, exiting, try again...')\n         sys.exit(0)\n \n # The stuff below is to permit the prompt for the library dir to\n@@ -202,7 +202,7 @@ def complete(self, text, state):\n try:\n     import readline\n except ImportError:\n-    print \"Module readline not available.\"\n+    print(\"Module readline not available.\")\n else:\n     import rlcompleter\n     readline.set_completer_delims(' \\t\\n;')"
  },
  {
    "sha": "05e1650c2e9f8f12b652224dcafbe684782ee039",
    "filename": "appinventor/misc/whitelist/whitelist.py.bak",
    "status": "added",
    "additions": 214,
    "deletions": 0,
    "changes": 214,
    "blob_url": "https://github.com/mit-cml/appinventor-sources/blob/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/whitelist/whitelist.py.bak",
    "raw_url": "https://github.com/mit-cml/appinventor-sources/raw/28a0bdacc7a7a8c1252f1b3b059ead88fbe63879/appinventor/misc/whitelist/whitelist.py.bak",
    "contents_url": "https://api.github.com/repos/mit-cml/appinventor-sources/contents/appinventor/misc/whitelist/whitelist.py.bak?ref=28a0bdacc7a7a8c1252f1b3b059ead88fbe63879",
    "patch": "@@ -0,0 +1,214 @@\n+#!/usr/bin/env python\n+#\n+# Tool for managing the App Inventor whitelist. The whitelist\n+# is stored in the App Engine Data Store. However it is only\n+# consulted if \"user.whitelist\" is set to true in appengine-web.xml\n+#\n+\n+# WhiteListData, an element of the whitelist. This class definition\n+# *MUST* be congruent to the Java class WhiteListData in StoredData.java\n+import os\n+import sys\n+import getpass\n+from getopt import getopt, GetoptError\n+\n+os.environ['SERVER_SOFTWARE'] = 'MIT Whitelist Generator 1.0' # Googlism\n+\n+def auth_func():\n+  return (raw_input('Email: '), getpass.getpass('Password: '))\n+\n+def main():\n+    if sys.modules.has_key('google'):\n+      del sys.modules['google'] # This interferes with imports later\n+    getlibdir()\n+    from google.appengine.ext import db\n+    from google.appengine.ext.remote_api import remote_api_stub\n+    from google.appengine.tools import appengine_rpc\n+\n+    class WhiteListData(db.Model):\n+        emailLower = db.StringProperty();\n+\n+    whitelistname = 'whitelist'\n+    host = 'localhost'\n+    getonly = False\n+    try:\n+        opts = getopt(sys.argv[1:], 'n:h:d', ['name=','getonly'])\n+    except GetoptError:\n+        sys.stderr.write('Usage: whitelist.py [-n whitelistfile] [-h host] [-d] [--getonly]\\n')\n+        sys.exit(1)\n+    for opt in opts[0]:\n+        if opt == []:\n+            continue\n+        if len(opt) < 2:\n+            sys.stderr.write('Usage: whitelist.py [-n whitelistfile] [-h host] [-d] [--getonly]\\n')\n+            sys.exit(1)\n+        if opt[0] in ('-n', '--name'):\n+            whitelistname = opt[1]\n+        elif opt[0] == '-h':\n+            host = opt[1]\n+        elif opt[0] == '-d':\n+            host = 'localhost'\n+        elif opt[0] == '--getonly':\n+            getonly = True\n+\n+    print 'Using %s for input' % whitelistname\n+    print 'Connecting to %s' % host\n+    if host == 'localhost':\n+        host = host + ':8888'\n+        secure = False\n+    else:\n+        secure = True\n+\n+    if secure:\n+      remote_api_stub.ConfigureRemoteApiForOAuth(host, '/remote_api',\n+                                                 secure=secure)\n+    else:\n+      remote_api_stub.ConfigureRemoteApi(None, '/remote_api', auth_func,\n+                                         servername=host,\n+                                         save_cookies=True, secure=secure)\n+    remote_api_stub.MaybeInvokeAuthentication()\n+\n+    input_people = open(whitelistname).readlines()\n+    input_people = [x.strip() for x in input_people]\n+\n+    installed_people = []\n+    c = None\n+    while True:\n+        q = WhiteListData.gql(\"\")\n+        if c:\n+            q = q.with_cursor(c)\n+        z = q.fetch(500)\n+        c = q.cursor()\n+        installed_people += z\n+        if len(z) < 500:\n+            break\n+\n+    if getonly:\n+        print 'Getonly set, returning existing whitelist with no changes'\n+        for person in installed_people:\n+            print person.emailLower\n+        return\n+\n+    WHITE = {}\n+    for email in input_people:\n+        WHITE[unicode(email)] = [0, None]\n+    for person in installed_people:\n+        email = person.emailLower\n+        if WHITE.has_key(email):\n+            WHITE[email] = [2, person]\n+        else:\n+            WHITE[email] = [1, person]\n+\n+    # Now we go through the dictionary. Remove people in state 1\n+    # and add people in state 0\n+\n+    for (email, z) in WHITE.items():\n+        state, person = z\n+        if state == 0:\n+            v = WhiteListData()\n+            v.emailLower = email\n+            v.put()\n+            print 'Added %s' % email\n+        elif state == 1:\n+            person.delete()\n+            print 'Removed %s' % email\n+\n+\n+def getlibdir():\n+    '''Find the googl_appengine library directory'''\n+    from os.path import expanduser\n+    import ConfigParser\n+    doupdate = False\n+    config = ConfigParser.RawConfigParser()\n+    configfile = expanduser('~/.appinv_whitelist')\n+    config.read(configfile)\n+    libdir = '/usr/local/google_appengine' # Default\n+    if config.has_section('whitelist'):\n+        try:\n+            libdir = config.get('whitelist', 'googlelibdir')\n+        except ConfigParser.NoOptionError:\n+            config.set('whitelist', 'googlelibdir', libdir)\n+            doupdate = True\n+    else:\n+        config.add_section('whitelist')\n+        doupdate = True\n+    if doupdate:\n+        f = open(configfile, 'w')\n+        config.write(f)\n+        f.close()\n+    sys.path.insert(0, libdir)\n+    sys.path.insert(1, libdir + '/lib/fancy_urllib')\n+    try:\n+        from google.appengine.ext import db\n+    except ImportError:\n+        newpath = raw_input('Google Python App Engine SDK Path [%s]: ' % libdir)\n+        if newpath == '':\n+            newpath = libdir\n+        libdir = newpath\n+        config.set('whitelist', 'googlelibdir', libdir)\n+        f = open(configfile, 'w')\n+        config.write(f)\n+        f.close()\n+        print 'Location of Google Library Directory Saved, exiting, try again...'\n+        sys.exit(0)\n+\n+# The stuff below is to permit the prompt for the library dir to\n+# use filename completion....\n+\n+class Completer(object):\n+\n+    def _listdir(self, root):\n+        \"List directory 'root' appending the path separator to subdirs.\"\n+        res = []\n+        for name in os.listdir(root):\n+            path = os.path.join(root, name)\n+            if os.path.isdir(path):\n+                name += os.sep\n+            res.append(name)\n+        return res\n+\n+    def _complete_path(self, path=None):\n+        \"Perform completion of filesystem path.\"\n+        if not path:\n+            return self._listdir('.')\n+        dirname, rest = os.path.split(path)\n+        tmp = dirname if dirname else '.'\n+        res = [os.path.join(dirname, p)\n+                for p in self._listdir(tmp) if p.startswith(rest)]\n+        # more than one match, or single match which does not exist (typo)\n+        if len(res) > 1 or not os.path.exists(path):\n+            return res\n+        # resolved to a single directory, so return list of files below it\n+        if os.path.isdir(path):\n+            return [os.path.join(path, p) for p in self._listdir(path)]\n+        # exact file match terminates this completion\n+        return [path + ' ']\n+\n+    def complete_filename(self, args):\n+        \"Completions for the 'extra' command.\"\n+        if not args:\n+            return self._complete_path('.')\n+        # treat the last arg as a path and complete it\n+        return self._complete_path(args[-1])\n+\n+    def complete(self, text, state):\n+        \"Generic readline completion entry point.\"\n+        buffer = readline.get_line_buffer()\n+        line = buffer.split()\n+        return (self.complete_filename(line) + [None])[state]\n+\n+comp = Completer()\n+\n+try:\n+    import readline\n+except ImportError:\n+    print \"Module readline not available.\"\n+else:\n+    import rlcompleter\n+    readline.set_completer_delims(' \\t\\n;')\n+    readline.parse_and_bind(\"tab: complete\")\n+    readline.set_completer(comp.complete)\n+\n+if __name__ == '__main__':\n+    main()\n+"
  }
]
