[
  {
    "sha": "31f8df97c5231d4eccb7f0007c9587fb7da09417",
    "filename": "sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/client/DefaultSentinelApiClient.java",
    "status": "added",
    "additions": 845,
    "deletions": 0,
    "changes": 845,
    "blob_url": "https://github.com/alibaba/Sentinel/blob/d94bfe370c4f4be771edb88ac896377d73bcda89/sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/client/DefaultSentinelApiClient.java",
    "raw_url": "https://github.com/alibaba/Sentinel/raw/d94bfe370c4f4be771edb88ac896377d73bcda89/sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/client/DefaultSentinelApiClient.java",
    "contents_url": "https://api.github.com/repos/alibaba/Sentinel/contents/sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/client/DefaultSentinelApiClient.java?ref=d94bfe370c4f4be771edb88ac896377d73bcda89",
    "patch": "@@ -0,0 +1,845 @@\n+package com.alibaba.csp.sentinel.dashboard.client;\n+\n+import com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayFlowRule;\n+import com.alibaba.csp.sentinel.command.CommandConstants;\n+import com.alibaba.csp.sentinel.command.vo.NodeVo;\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.dashboard.datasource.entity.SentinelVersion;\n+import com.alibaba.csp.sentinel.dashboard.datasource.entity.gateway.ApiDefinitionEntity;\n+import com.alibaba.csp.sentinel.dashboard.datasource.entity.gateway.GatewayFlowRuleEntity;\n+import com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.*;\n+import com.alibaba.csp.sentinel.dashboard.discovery.AppManagement;\n+import com.alibaba.csp.sentinel.dashboard.domain.cluster.ClusterClientInfoVO;\n+import com.alibaba.csp.sentinel.dashboard.domain.cluster.config.ClusterClientConfig;\n+import com.alibaba.csp.sentinel.dashboard.domain.cluster.config.ServerFlowConfig;\n+import com.alibaba.csp.sentinel.dashboard.domain.cluster.config.ServerTransportConfig;\n+import com.alibaba.csp.sentinel.dashboard.domain.cluster.state.ClusterServerStateVO;\n+import com.alibaba.csp.sentinel.dashboard.domain.cluster.state.ClusterStateSimpleEntity;\n+import com.alibaba.csp.sentinel.dashboard.util.AsyncUtils;\n+import com.alibaba.csp.sentinel.dashboard.util.VersionUtils;\n+import com.alibaba.csp.sentinel.slots.block.Rule;\n+import com.alibaba.csp.sentinel.slots.block.authority.AuthorityRule;\n+import com.alibaba.csp.sentinel.slots.block.degrade.DegradeRule;\n+import com.alibaba.csp.sentinel.slots.block.flow.FlowRule;\n+import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;\n+import com.alibaba.csp.sentinel.slots.system.SystemRule;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+import com.alibaba.fastjson.JSON;\n+import org.apache.http.Consts;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.entity.UrlEncodedFormEntity;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+import org.apache.http.concurrent.FutureCallback;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.impl.client.DefaultRedirectStrategy;\n+import org.apache.http.impl.nio.client.CloseableHttpAsyncClient;\n+import org.apache.http.impl.nio.client.HttpAsyncClients;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.apache.http.message.BasicNameValuePair;\n+import org.apache.http.util.EntityUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.lang.Nullable;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n+import java.util.*;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+\n+public class DefaultSentinelApiClient implements SentinelApiClient {\n+\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    private static final Charset DEFAULT_CHARSET = Charset.forName(SentinelConfig.charset());\n+    private static final String HTTP_HEADER_CONTENT_TYPE = \"Content-Type\";\n+    private static final String HTTP_HEADER_CONTENT_TYPE_URLENCODED = ContentType.create(URLEncodedUtils.CONTENT_TYPE).toString();\n+\n+    private static final String RESOURCE_URL_PATH = \"jsonTree\";\n+    private static final String CLUSTER_NODE_PATH = \"clusterNode\";\n+    private static final String GET_RULES_PATH = \"getRules\";\n+    private static final String SET_RULES_PATH = \"setRules\";\n+    private static final String GET_PARAM_RULE_PATH = \"getParamFlowRules\";\n+    private static final String SET_PARAM_RULE_PATH = \"setParamFlowRules\";\n+\n+    private static final String FETCH_CLUSTER_MODE_PATH = \"getClusterMode\";\n+    private static final String MODIFY_CLUSTER_MODE_PATH = \"setClusterMode\";\n+    private static final String FETCH_CLUSTER_CLIENT_CONFIG_PATH = \"cluster/client/fetchConfig\";\n+    private static final String MODIFY_CLUSTER_CLIENT_CONFIG_PATH = \"cluster/client/modifyConfig\";\n+\n+    private static final String FETCH_CLUSTER_SERVER_BASIC_INFO_PATH = \"cluster/server/info\";\n+\n+    private static final String MODIFY_CLUSTER_SERVER_TRANSPORT_CONFIG_PATH = \"cluster/server/modifyTransportConfig\";\n+    private static final String MODIFY_CLUSTER_SERVER_FLOW_CONFIG_PATH = \"cluster/server/modifyFlowConfig\";\n+    private static final String MODIFY_CLUSTER_SERVER_NAMESPACE_SET_PATH = \"cluster/server/modifyNamespaceSet\";\n+\n+    private static final String FETCH_GATEWAY_API_PATH = \"gateway/getApiDefinitions\";\n+    private static final String MODIFY_GATEWAY_API_PATH = \"gateway/updateApiDefinitions\";\n+\n+    private static final String FETCH_GATEWAY_FLOW_RULE_PATH = \"gateway/getRules\";\n+    private static final String MODIFY_GATEWAY_FLOW_RULE_PATH = \"gateway/updateRules\";\n+\n+    private static final String FLOW_RULE_TYPE = \"flow\";\n+    private static final String DEGRADE_RULE_TYPE = \"degrade\";\n+    private static final String SYSTEM_RULE_TYPE = \"system\";\n+    private static final String AUTHORITY_TYPE = \"authority\";\n+\n+    private final CloseableHttpAsyncClient httpClient;\n+\n+    private static final SentinelVersion version160 = new SentinelVersion(1, 6, 0);\n+    private static final SentinelVersion version171 = new SentinelVersion(1, 7, 1);\n+\n+    private final AppManagement appManagement;\n+\n+    public DefaultSentinelApiClient(AppManagement appManagement) {\n+        this.appManagement = appManagement;\n+        IOReactorConfig ioConfig = IOReactorConfig.custom().setConnectTimeout(3000).setSoTimeout(10000)\n+                .setIoThreadCount(Runtime.getRuntime().availableProcessors() * 2).build();\n+        httpClient = HttpAsyncClients.custom().setRedirectStrategy(new DefaultRedirectStrategy() {\n+            @Override\n+            protected boolean isRedirectable(final String method) {\n+                return false;\n+            }\n+        }).setMaxConnTotal(4000).setMaxConnPerRoute(1000).setDefaultIOReactorConfig(ioConfig).build();\n+        httpClient.start();\n+    }\n+\n+    private boolean isSuccess(int statusCode) {\n+        return statusCode >= 200 && statusCode < 300;\n+    }\n+\n+    private boolean isCommandNotFound(int statusCode, String body) {\n+        return statusCode == 400 && StringUtil.isNotEmpty(body) && body.contains(CommandConstants.MSG_UNKNOWN_COMMAND_PREFIX);\n+    }\n+\n+    protected boolean isSupportPost(String app, String ip, int port) {\n+        return StringUtil.isNotEmpty(app) && Optional.ofNullable(appManagement.getDetailApp(app))\n+                .flatMap(e -> e.getMachine(ip, port))\n+                .flatMap(m -> VersionUtils.parseVersion(m.getVersion())\n+                        .map(v -> v.greaterOrEqual(version160)))\n+                .orElse(false);\n+    }\n+\n+    /**\n+     * Check wheter target instance (identified by tuple of app-ip:port)\n+     * supports the form of \"xxxxx; xx=xx\" in \"Content-Type\" header.\n+     *\n+     * @param app target app name\n+     * @param ip target node's address\n+     * @param port target node's port\n+     */\n+    protected boolean isSupportEnhancedContentType(String app, String ip, int port) {\n+        return StringUtil.isNotEmpty(app) && Optional.ofNullable(appManagement.getDetailApp(app))\n+                .flatMap(e -> e.getMachine(ip, port))\n+                .flatMap(m -> VersionUtils.parseVersion(m.getVersion())\n+                        .map(v -> v.greaterOrEqual(version171)))\n+                .orElse(false);\n+    }\n+\n+    private StringBuilder queryString(Map<String, String> params) {\n+        StringBuilder queryStringBuilder = new StringBuilder();\n+        for (Map.Entry<String, String> entry : params.entrySet()) {\n+            if (StringUtil.isEmpty(entry.getValue())) {\n+                continue;\n+            }\n+            String name = urlEncode(entry.getKey());\n+            String value = urlEncode(entry.getValue());\n+            if (name != null && value != null) {\n+                if (queryStringBuilder.length() > 0) {\n+                    queryStringBuilder.append('&');\n+                }\n+                queryStringBuilder.append(name).append('=').append(value);\n+            }\n+        }\n+        return queryStringBuilder;\n+    }\n+\n+    /**\n+     * Build an `HttpUriRequest` in POST way.\n+     *\n+     * @param url\n+     * @param params\n+     * @param supportEnhancedContentType see {@link #isSupportEnhancedContentType(String, String, int)}\n+     * @return\n+     */\n+    protected static HttpUriRequest postRequest(String url, Map<String, String> params, boolean supportEnhancedContentType) {\n+        HttpPost httpPost = new HttpPost(url);\n+        if (params != null && params.size() > 0) {\n+            List<NameValuePair> list = new ArrayList<>(params.size());\n+            for (Map.Entry<String, String> entry : params.entrySet()) {\n+                list.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));\n+            }\n+            httpPost.setEntity(new UrlEncodedFormEntity(list, Consts.UTF_8));\n+            if (!supportEnhancedContentType) {\n+                httpPost.setHeader(HTTP_HEADER_CONTENT_TYPE, HTTP_HEADER_CONTENT_TYPE_URLENCODED);\n+            }\n+        }\n+        return httpPost;\n+    }\n+\n+    private String urlEncode(String str) {\n+        try {\n+            return URLEncoder.encode(str, DEFAULT_CHARSET.name());\n+        } catch (UnsupportedEncodingException e) {\n+            logger.info(\"encode string error: {}\", str, e);\n+            return null;\n+        }\n+    }\n+\n+    private String getBody(HttpResponse response) throws Exception {\n+        Charset charset = null;\n+        try {\n+            String contentTypeStr = response.getFirstHeader(HTTP_HEADER_CONTENT_TYPE).getValue();\n+            if (StringUtil.isNotEmpty(contentTypeStr)) {\n+                ContentType contentType = ContentType.parse(contentTypeStr);\n+                charset = contentType.getCharset();\n+            }\n+        } catch (Exception ignore) {\n+        }\n+        return EntityUtils.toString(response.getEntity(), charset != null ? charset : DEFAULT_CHARSET);\n+    }\n+\n+    /**\n+     * With no param\n+     *\n+     * @param ip\n+     * @param port\n+     * @param api\n+     * @return\n+     */\n+    private CompletableFuture<String> executeCommand(String ip, int port, String api, boolean useHttpPost) {\n+        return executeCommand(ip, port, api, null, useHttpPost);\n+    }\n+\n+    /**\n+     * No app specified, force to GET\n+     *\n+     * @param ip\n+     * @param port\n+     * @param api\n+     * @param params\n+     * @return\n+     */\n+    private CompletableFuture<String> executeCommand(String ip, int port, String api, Map<String, String> params, boolean useHttpPost) {\n+        return executeCommand(null, ip, port, api, params, useHttpPost);\n+    }\n+\n+    /**\n+     * Prefer to execute request using POST\n+     *\n+     * @param app\n+     * @param ip\n+     * @param port\n+     * @param api\n+     * @param params\n+     * @return\n+     */\n+    private CompletableFuture<String> executeCommand(String app, String ip, int port, String api, Map<String, String> params, boolean useHttpPost) {\n+        CompletableFuture<String> future = new CompletableFuture<>();\n+        if (StringUtil.isBlank(ip) || StringUtil.isBlank(api)) {\n+            future.completeExceptionally(new IllegalArgumentException(\"Bad URL or command name\"));\n+            return future;\n+        }\n+        StringBuilder urlBuilder = new StringBuilder();\n+        urlBuilder.append(\"http://\");\n+        urlBuilder.append(ip).append(':').append(port).append('/').append(api);\n+        if (params == null) {\n+            params = Collections.emptyMap();\n+        }\n+        if (!useHttpPost || !isSupportPost(app, ip, port)) {\n+            // Using GET in older versions, append parameters after url\n+            if (!params.isEmpty()) {\n+                if (urlBuilder.indexOf(\"?\") == -1) {\n+                    urlBuilder.append('?');\n+                } else {\n+                    urlBuilder.append('&');\n+                }\n+                urlBuilder.append(queryString(params));\n+            }\n+            return executeCommand(new HttpGet(urlBuilder.toString()));\n+        } else {\n+            // Using POST\n+            return executeCommand(\n+                    postRequest(urlBuilder.toString(), params, isSupportEnhancedContentType(app, ip, port)));\n+        }\n+    }\n+\n+    private CompletableFuture<String> executeCommand(HttpUriRequest request) {\n+        CompletableFuture<String> future = new CompletableFuture<>();\n+        httpClient.execute(request, new FutureCallback<HttpResponse>() {\n+            @Override\n+            public void completed(final HttpResponse response) {\n+                int statusCode = response.getStatusLine().getStatusCode();\n+                try {\n+                    String value = getBody(response);\n+                    if (isSuccess(statusCode)) {\n+                        future.complete(value);\n+                    } else {\n+                        if (isCommandNotFound(statusCode, value)) {\n+                            future.completeExceptionally(new CommandNotFoundException(request.getURI().getPath()));\n+                        } else {\n+                            future.completeExceptionally(new CommandFailedException(value));\n+                        }\n+                    }\n+\n+                } catch (Exception ex) {\n+                    future.completeExceptionally(ex);\n+                    logger.error(\"HTTP request failed: {}\", request.getURI().toString(), ex);\n+                }\n+            }\n+\n+            @Override\n+            public void failed(final Exception ex) {\n+                future.completeExceptionally(ex);\n+                logger.error(\"HTTP request failed: {}\", request.getURI().toString(), ex);\n+            }\n+\n+            @Override\n+            public void cancelled() {\n+                future.complete(null);\n+            }\n+        });\n+        return future;\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+        httpClient.close();\n+    }\n+\n+    @Nullable\n+    private <T> CompletableFuture<List<T>> fetchItemsAsync(String ip, int port, String api, String type, Class<T> ruleType) {\n+        AssertUtil.notEmpty(ip, \"Bad machine IP\");\n+        AssertUtil.isTrue(port > 0, \"Bad machine port\");\n+        Map<String, String> params = null;\n+        if (StringUtil.isNotEmpty(type)) {\n+            params = new HashMap<>(1);\n+            params.put(\"type\", type);\n+        }\n+        return executeCommand(ip, port, api, params, false)\n+                .thenApply(json -> JSON.parseArray(json, ruleType));\n+    }\n+\n+    @Nullable\n+    private <T> List<T> fetchItems(String ip, int port, String api, String type, Class<T> ruleType) {\n+        try {\n+            AssertUtil.notEmpty(ip, \"Bad machine IP\");\n+            AssertUtil.isTrue(port > 0, \"Bad machine port\");\n+            Map<String, String> params = null;\n+            if (StringUtil.isNotEmpty(type)) {\n+                params = new HashMap<>(1);\n+                params.put(\"type\", type);\n+            }\n+            return fetchItemsAsync(ip, port, api, type, ruleType).get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            logger.error(\"Error when fetching items from api: {} -> {}\", api, type, e);\n+            return null;\n+        } catch (Exception e) {\n+            logger.error(\"Error when fetching items: {} -> {}\", api, type, e);\n+            return null;\n+        }\n+    }\n+\n+    private <T extends Rule> List<T> fetchRules(String ip, int port, String type, Class<T> ruleType) {\n+        return fetchItems(ip, port, GET_RULES_PATH, type, ruleType);\n+    }\n+\n+    private boolean setRules(String app, String ip, int port, String type, List<? extends RuleEntity> entities) {\n+        if (entities == null) {\n+            return true;\n+        }\n+        try {\n+            AssertUtil.notEmpty(app, \"Bad app name\");\n+            AssertUtil.notEmpty(ip, \"Bad machine IP\");\n+            AssertUtil.isTrue(port > 0, \"Bad machine port\");\n+            String data = JSON.toJSONString(\n+                    entities.stream().map(r -> r.toRule()).collect(Collectors.toList()));\n+            Map<String, String> params = new HashMap<>(2);\n+            params.put(\"type\", type);\n+            params.put(\"data\", data);\n+            String result = executeCommand(app, ip, port, SET_RULES_PATH, params, true).get();\n+            logger.info(\"setRules result: {}, type={}\", result, type);\n+            return true;\n+        } catch (InterruptedException e) {\n+            logger.warn(\"setRules API failed: {}\", type, e);\n+            return false;\n+        } catch (ExecutionException e) {\n+            logger.warn(\"setRules API failed: {}\", type, e.getCause());\n+            return false;\n+        } catch (Exception e) {\n+            logger.error(\"setRules API failed, type={}\", type, e);\n+            return false;\n+        }\n+    }\n+\n+    private CompletableFuture<Void> setRulesAsync(String app, String ip, int port, String type, List<? extends RuleEntity> entities) {\n+        try {\n+            AssertUtil.notNull(entities, \"rules cannot be null\");\n+            AssertUtil.notEmpty(app, \"Bad app name\");\n+            AssertUtil.notEmpty(ip, \"Bad machine IP\");\n+            AssertUtil.isTrue(port > 0, \"Bad machine port\");\n+            String data = JSON.toJSONString(\n+                    entities.stream().map(r -> r.toRule()).collect(Collectors.toList()));\n+            Map<String, String> params = new HashMap<>(2);\n+            params.put(\"type\", type);\n+            params.put(\"data\", data);\n+            return executeCommand(app, ip, port, SET_RULES_PATH, params, true)\n+                    .thenCompose(r -> {\n+                        if (\"success\".equalsIgnoreCase(r.trim())) {\n+                            return CompletableFuture.completedFuture(null);\n+                        }\n+                        return AsyncUtils.newFailedFuture(new CommandFailedException(r));\n+                    });\n+        } catch (Exception e) {\n+            logger.error(\"setRulesAsync API failed, type={}\", type, e);\n+            return AsyncUtils.newFailedFuture(e);\n+        }\n+    }\n+\n+    @Override\n+    public List<NodeVo> fetchResourceOfMachine(String ip, int port, String type) {\n+        return fetchItems(ip, port, RESOURCE_URL_PATH, type, NodeVo.class);\n+    }\n+\n+    /**\n+     * Fetch cluster node.\n+     *\n+     * @param ip          ip to fetch\n+     * @param port        port of the ip\n+     * @param includeZero whether zero value should in the result list.\n+     * @return\n+     */\n+    @Override\n+    public List<NodeVo> fetchClusterNodeOfMachine(String ip, int port, boolean includeZero) {\n+        String type = \"notZero\";\n+        if (includeZero) {\n+            type = \"zero\";\n+        }\n+        return fetchItems(ip, port, CLUSTER_NODE_PATH, type, NodeVo.class);\n+    }\n+\n+    @Override\n+    public List<FlowRuleEntity> fetchFlowRuleOfMachine(String app, String ip, int port) {\n+        List<FlowRule> rules = fetchRules(ip, port, FLOW_RULE_TYPE, FlowRule.class);\n+        if (rules != null) {\n+            return rules.stream().map(rule -> FlowRuleEntity.fromFlowRule(app, ip, port, rule))\n+                    .collect(Collectors.toList());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public List<DegradeRuleEntity> fetchDegradeRuleOfMachine(String app, String ip, int port) {\n+        List<DegradeRule> rules = fetchRules(ip, port, DEGRADE_RULE_TYPE, DegradeRule.class);\n+        if (rules != null) {\n+            return rules.stream().map(rule -> DegradeRuleEntity.fromDegradeRule(app, ip, port, rule))\n+                    .collect(Collectors.toList());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public List<SystemRuleEntity> fetchSystemRuleOfMachine(String app, String ip, int port) {\n+        List<SystemRule> rules = fetchRules(ip, port, SYSTEM_RULE_TYPE, SystemRule.class);\n+        if (rules != null) {\n+            return rules.stream().map(rule -> SystemRuleEntity.fromSystemRule(app, ip, port, rule))\n+                    .collect(Collectors.toList());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Fetch all parameter flow rules from provided machine.\n+     *\n+     * @param app  application name\n+     * @param ip   machine client IP\n+     * @param port machine client port\n+     * @return all retrieved parameter flow rules\n+     * @since 0.2.1\n+     */\n+    @Override\n+    public CompletableFuture<List<ParamFlowRuleEntity>> fetchParamFlowRulesOfMachine(String app, String ip, int port) {\n+        try {\n+            AssertUtil.notEmpty(app, \"Bad app name\");\n+            AssertUtil.notEmpty(ip, \"Bad machine IP\");\n+            AssertUtil.isTrue(port > 0, \"Bad machine port\");\n+            return fetchItemsAsync(ip, port, GET_PARAM_RULE_PATH, null, ParamFlowRule.class)\n+                    .thenApply(rules -> rules.stream()\n+                            .map(e -> ParamFlowRuleEntity.fromAuthorityRule(app, ip, port, e))\n+                            .collect(Collectors.toList())\n+                    );\n+        } catch (Exception e) {\n+            logger.error(\"Error when fetching parameter flow rules\", e);\n+            return AsyncUtils.newFailedFuture(e);\n+        }\n+    }\n+\n+    /**\n+     * Fetch all authority rules from provided machine.\n+     *\n+     * @param app  application name\n+     * @param ip   machine client IP\n+     * @param port machine client port\n+     * @return all retrieved authority rules\n+     * @since 0.2.1\n+     */\n+    @Override\n+    public List<AuthorityRuleEntity> fetchAuthorityRulesOfMachine(String app, String ip, int port) {\n+        AssertUtil.notEmpty(app, \"Bad app name\");\n+        AssertUtil.notEmpty(ip, \"Bad machine IP\");\n+        AssertUtil.isTrue(port > 0, \"Bad machine port\");\n+        Map<String, String> params = new HashMap<>(1);\n+        params.put(\"type\", AUTHORITY_TYPE);\n+        List<AuthorityRule> rules = fetchRules(ip, port, AUTHORITY_TYPE, AuthorityRule.class);\n+        return Optional.ofNullable(rules).map(r -> r.stream()\n+                .map(e -> AuthorityRuleEntity.fromAuthorityRule(app, ip, port, e))\n+                .collect(Collectors.toList())\n+        ).orElse(null);\n+    }\n+\n+    /**\n+     * set rules of the machine. rules == null will return immediately;\n+     * rules.isEmpty() means setting the rules to empty.\n+     *\n+     * @param app\n+     * @param ip\n+     * @param port\n+     * @param rules\n+     * @return whether successfully set the rules.\n+     */\n+    @Override\n+    public boolean setFlowRuleOfMachine(String app, String ip, int port, List<FlowRuleEntity> rules) {\n+        return setRules(app, ip, port, FLOW_RULE_TYPE, rules);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> setFlowRuleOfMachineAsync(String app, String ip, int port, List<FlowRuleEntity> rules) {\n+        return setRulesAsync(app, ip, port, FLOW_RULE_TYPE, rules);\n+    }\n+\n+    /**\n+     * set rules of the machine. rules == null will return immediately;\n+     * rules.isEmpty() means setting the rules to empty.\n+     *\n+     * @param app\n+     * @param ip\n+     * @param port\n+     * @param rules\n+     * @return whether successfully set the rules.\n+     */\n+    @Override\n+    public boolean setDegradeRuleOfMachine(String app, String ip, int port, List<DegradeRuleEntity> rules) {\n+        return setRules(app, ip, port, DEGRADE_RULE_TYPE, rules);\n+    }\n+\n+    /**\n+     * set rules of the machine. rules == null will return immediately;\n+     * rules.isEmpty() means setting the rules to empty.\n+     *\n+     * @param app\n+     * @param ip\n+     * @param port\n+     * @param rules\n+     * @return whether successfully set the rules.\n+     */\n+    @Override\n+    public boolean setSystemRuleOfMachine(String app, String ip, int port, List<SystemRuleEntity> rules) {\n+        return setRules(app, ip, port, SYSTEM_RULE_TYPE, rules);\n+    }\n+\n+    @Override\n+    public boolean setAuthorityRuleOfMachine(String app, String ip, int port, List<AuthorityRuleEntity> rules) {\n+        return setRules(app, ip, port, AUTHORITY_TYPE, rules);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> setParamFlowRuleOfMachine(String app, String ip, int port, List<ParamFlowRuleEntity> rules) {\n+        if (rules == null) {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+        if (StringUtil.isBlank(ip) || port <= 0) {\n+            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n+        }\n+        try {\n+            String data = JSON.toJSONString(\n+                    rules.stream().map(ParamFlowRuleEntity::getRule).collect(Collectors.toList())\n+            );\n+            Map<String, String> params = new HashMap<>(1);\n+            params.put(\"data\", data);\n+            return executeCommand(app, ip, port, SET_PARAM_RULE_PATH, params, true)\n+                    .thenCompose(e -> {\n+                        if (CommandConstants.MSG_SUCCESS.equals(e)) {\n+                            return CompletableFuture.completedFuture(null);\n+                        } else {\n+                            logger.warn(\"Push parameter flow rules to client failed: \" + e);\n+                            return AsyncUtils.newFailedFuture(new RuntimeException(e));\n+                        }\n+                    });\n+        } catch (Exception ex) {\n+            logger.warn(\"Error when setting parameter flow rule\", ex);\n+            return AsyncUtils.newFailedFuture(ex);\n+        }\n+    }\n+\n+    // Cluster related\n+\n+    @Override\n+    public CompletableFuture<ClusterStateSimpleEntity> fetchClusterMode(String ip, int port) {\n+        if (StringUtil.isBlank(ip) || port <= 0) {\n+            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n+        }\n+        try {\n+            return executeCommand(ip, port, FETCH_CLUSTER_MODE_PATH, false)\n+                    .thenApply(r -> JSON.parseObject(r, ClusterStateSimpleEntity.class));\n+        } catch (Exception ex) {\n+            logger.warn(\"Error when fetching cluster mode\", ex);\n+            return AsyncUtils.newFailedFuture(ex);\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> modifyClusterMode(String ip, int port, int mode) {\n+        if (StringUtil.isBlank(ip) || port <= 0) {\n+            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n+        }\n+        try {\n+            Map<String, String> params = new HashMap<>(1);\n+            params.put(\"mode\", String.valueOf(mode));\n+            return executeCommand(ip, port, MODIFY_CLUSTER_MODE_PATH, params, false)\n+                    .thenCompose(e -> {\n+                        if (CommandConstants.MSG_SUCCESS.equals(e)) {\n+                            return CompletableFuture.completedFuture(null);\n+                        } else {\n+                            logger.warn(\"Error when modifying cluster mode: \" + e);\n+                            return AsyncUtils.newFailedFuture(new RuntimeException(e));\n+                        }\n+                    });\n+        } catch (Exception ex) {\n+            logger.warn(\"Error when modifying cluster mode\", ex);\n+            return AsyncUtils.newFailedFuture(ex);\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<ClusterClientInfoVO> fetchClusterClientInfoAndConfig(String ip, int port) {\n+        if (StringUtil.isBlank(ip) || port <= 0) {\n+            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n+        }\n+        try {\n+            return executeCommand(ip, port, FETCH_CLUSTER_CLIENT_CONFIG_PATH, false)\n+                    .thenApply(r -> JSON.parseObject(r, ClusterClientInfoVO.class));\n+        } catch (Exception ex) {\n+            logger.warn(\"Error when fetching cluster client config\", ex);\n+            return AsyncUtils.newFailedFuture(ex);\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> modifyClusterClientConfig(String app, String ip, int port, ClusterClientConfig config) {\n+        if (StringUtil.isBlank(ip) || port <= 0) {\n+            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n+        }\n+        try {\n+            Map<String, String> params = new HashMap<>(1);\n+            params.put(\"data\", JSON.toJSONString(config));\n+            return executeCommand(app, ip, port, MODIFY_CLUSTER_CLIENT_CONFIG_PATH, params, true)\n+                    .thenCompose(e -> {\n+                        if (CommandConstants.MSG_SUCCESS.equals(e)) {\n+                            return CompletableFuture.completedFuture(null);\n+                        } else {\n+                            logger.warn(\"Error when modifying cluster client config: \" + e);\n+                            return AsyncUtils.newFailedFuture(new RuntimeException(e));\n+                        }\n+                    });\n+        } catch (Exception ex) {\n+            logger.warn(\"Error when modifying cluster client config\", ex);\n+            return AsyncUtils.newFailedFuture(ex);\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> modifyClusterServerFlowConfig(String app, String ip, int port, ServerFlowConfig config) {\n+        if (StringUtil.isBlank(ip) || port <= 0) {\n+            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n+        }\n+        try {\n+            Map<String, String> params = new HashMap<>(1);\n+            params.put(\"data\", JSON.toJSONString(config));\n+            return executeCommand(app, ip, port, MODIFY_CLUSTER_SERVER_FLOW_CONFIG_PATH, params, true)\n+                    .thenCompose(e -> {\n+                        if (CommandConstants.MSG_SUCCESS.equals(e)) {\n+                            return CompletableFuture.completedFuture(null);\n+                        } else {\n+                            logger.warn(\"Error when modifying cluster server flow config: \" + e);\n+                            return AsyncUtils.newFailedFuture(new RuntimeException(e));\n+                        }\n+                    });\n+        } catch (Exception ex) {\n+            logger.warn(\"Error when modifying cluster server flow config\", ex);\n+            return AsyncUtils.newFailedFuture(ex);\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> modifyClusterServerTransportConfig(String app, String ip, int port, ServerTransportConfig config) {\n+        if (StringUtil.isBlank(ip) || port <= 0) {\n+            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n+        }\n+        try {\n+            Map<String, String> params = new HashMap<>(2);\n+            params.put(\"port\", config.getPort().toString());\n+            params.put(\"idleSeconds\", config.getIdleSeconds().toString());\n+            return executeCommand(app, ip, port, MODIFY_CLUSTER_SERVER_TRANSPORT_CONFIG_PATH, params, false)\n+                    .thenCompose(e -> {\n+                        if (CommandConstants.MSG_SUCCESS.equals(e)) {\n+                            return CompletableFuture.completedFuture(null);\n+                        } else {\n+                            logger.warn(\"Error when modifying cluster server transport config: \" + e);\n+                            return AsyncUtils.newFailedFuture(new RuntimeException(e));\n+                        }\n+                    });\n+        } catch (Exception ex) {\n+            logger.warn(\"Error when modifying cluster server transport config\", ex);\n+            return AsyncUtils.newFailedFuture(ex);\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> modifyClusterServerNamespaceSet(String app, String ip, int port, Set<String> set) {\n+        if (StringUtil.isBlank(ip) || port <= 0) {\n+            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n+        }\n+        try {\n+            Map<String, String> params = new HashMap<>(1);\n+            params.put(\"data\", JSON.toJSONString(set));\n+            return executeCommand(app, ip, port, MODIFY_CLUSTER_SERVER_NAMESPACE_SET_PATH, params, true)\n+                    .thenCompose(e -> {\n+                        if (CommandConstants.MSG_SUCCESS.equals(e)) {\n+                            return CompletableFuture.completedFuture(null);\n+                        } else {\n+                            logger.warn(\"Error when modifying cluster server NamespaceSet\", e);\n+                            return AsyncUtils.newFailedFuture(new RuntimeException(e));\n+                        }\n+                    });\n+        } catch (Exception ex) {\n+            logger.warn(\"Error when modifying cluster server NamespaceSet\", ex);\n+            return AsyncUtils.newFailedFuture(ex);\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<ClusterServerStateVO> fetchClusterServerBasicInfo(String ip, int port) {\n+        if (StringUtil.isBlank(ip) || port <= 0) {\n+            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n+        }\n+        try {\n+            return executeCommand(ip, port, FETCH_CLUSTER_SERVER_BASIC_INFO_PATH, false)\n+                    .thenApply(r -> JSON.parseObject(r, ClusterServerStateVO.class));\n+        } catch (Exception ex) {\n+            logger.warn(\"Error when fetching cluster sever all config and basic info\", ex);\n+            return AsyncUtils.newFailedFuture(ex);\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<List<ApiDefinitionEntity>> fetchApis(String app, String ip, int port) {\n+        if (StringUtil.isBlank(ip) || port <= 0) {\n+            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n+        }\n+\n+        try {\n+            return executeCommand(ip, port, FETCH_GATEWAY_API_PATH, false)\n+                    .thenApply(r -> {\n+                        List<ApiDefinitionEntity> entities = JSON.parseArray(r, ApiDefinitionEntity.class);\n+                        if (entities != null) {\n+                            for (ApiDefinitionEntity entity : entities) {\n+                                entity.setApp(app);\n+                                entity.setIp(ip);\n+                                entity.setPort(port);\n+                            }\n+                        }\n+                        return entities;\n+                    });\n+        } catch (Exception ex) {\n+            logger.warn(\"Error when fetching gateway apis\", ex);\n+            return AsyncUtils.newFailedFuture(ex);\n+        }\n+    }\n+\n+    @Override\n+    public boolean modifyApis(String app, String ip, int port, List<ApiDefinitionEntity> apis) {\n+        if (apis == null) {\n+            return true;\n+        }\n+\n+        try {\n+            AssertUtil.notEmpty(app, \"Bad app name\");\n+            AssertUtil.notEmpty(ip, \"Bad machine IP\");\n+            AssertUtil.isTrue(port > 0, \"Bad machine port\");\n+            String data = JSON.toJSONString(\n+                    apis.stream().map(r -> r.toApiDefinition()).collect(Collectors.toList()));\n+            Map<String, String> params = new HashMap<>(2);\n+            params.put(\"data\", data);\n+            String result = executeCommand(app, ip, port, MODIFY_GATEWAY_API_PATH, params, true).get();\n+            logger.info(\"Modify gateway apis: {}\", result);\n+            return true;\n+        } catch (Exception e) {\n+            logger.warn(\"Error when modifying gateway apis\", e);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<List<GatewayFlowRuleEntity>> fetchGatewayFlowRules(String app, String ip, int port) {\n+        if (StringUtil.isBlank(ip) || port <= 0) {\n+            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n+        }\n+\n+        try {\n+            return executeCommand(ip, port, FETCH_GATEWAY_FLOW_RULE_PATH, false)\n+                    .thenApply(r -> {\n+                        List<GatewayFlowRule> gatewayFlowRules = JSON.parseArray(r, GatewayFlowRule.class);\n+                        List<GatewayFlowRuleEntity> entities = gatewayFlowRules.stream().map(rule -> GatewayFlowRuleEntity.fromGatewayFlowRule(app, ip, port, rule)).collect(Collectors.toList());\n+                        return entities;\n+                    });\n+        } catch (Exception ex) {\n+            logger.warn(\"Error when fetching gateway flow rules\", ex);\n+            return AsyncUtils.newFailedFuture(ex);\n+        }\n+    }\n+\n+    @Override\n+    public boolean modifyGatewayFlowRules(String app, String ip, int port, List<GatewayFlowRuleEntity> rules) {\n+        if (rules == null) {\n+            return true;\n+        }\n+\n+        try {\n+            AssertUtil.notEmpty(app, \"Bad app name\");\n+            AssertUtil.notEmpty(ip, \"Bad machine IP\");\n+            AssertUtil.isTrue(port > 0, \"Bad machine port\");\n+            String data = JSON.toJSONString(\n+                    rules.stream().map(r -> r.toGatewayFlowRule()).collect(Collectors.toList()));\n+            Map<String, String> params = new HashMap<>(2);\n+            params.put(\"data\", data);\n+            String result = executeCommand(app, ip, port, MODIFY_GATEWAY_FLOW_RULE_PATH, params, true).get();\n+            logger.info(\"Modify gateway flow rules: {}\", result);\n+            return true;\n+        } catch (Exception e) {\n+            logger.warn(\"Error when modifying gateway apis\", e);\n+            return false;\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "4099feb67bd241b72fc044857c14efd100895231",
    "filename": "sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/client/SentinelApiClient.java",
    "status": "modified",
    "additions": 34,
    "deletions": 749,
    "changes": 783,
    "blob_url": "https://github.com/alibaba/Sentinel/blob/d94bfe370c4f4be771edb88ac896377d73bcda89/sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/client/SentinelApiClient.java",
    "raw_url": "https://github.com/alibaba/Sentinel/raw/d94bfe370c4f4be771edb88ac896377d73bcda89/sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/client/SentinelApiClient.java",
    "contents_url": "https://api.github.com/repos/alibaba/Sentinel/contents/sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/client/SentinelApiClient.java?ref=d94bfe370c4f4be771edb88ac896377d73bcda89",
    "patch": "@@ -15,477 +15,47 @@\n  */\n package com.alibaba.csp.sentinel.dashboard.client;\n \n-import java.io.UnsupportedEncodingException;\n-import java.net.URLEncoder;\n-import java.nio.charset.Charset;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.stream.Collectors;\n-\n-import com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayFlowRule;\n-import com.alibaba.csp.sentinel.command.CommandConstants;\n-import com.alibaba.csp.sentinel.config.SentinelConfig;\n import com.alibaba.csp.sentinel.command.vo.NodeVo;\n import com.alibaba.csp.sentinel.dashboard.datasource.entity.gateway.ApiDefinitionEntity;\n import com.alibaba.csp.sentinel.dashboard.datasource.entity.gateway.GatewayFlowRuleEntity;\n-import com.alibaba.csp.sentinel.dashboard.util.AsyncUtils;\n-import com.alibaba.csp.sentinel.slots.block.Rule;\n-import com.alibaba.csp.sentinel.slots.block.authority.AuthorityRule;\n-import com.alibaba.csp.sentinel.slots.block.degrade.DegradeRule;\n-import com.alibaba.csp.sentinel.slots.block.flow.FlowRule;\n-import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;\n-import com.alibaba.csp.sentinel.slots.system.SystemRule;\n-import com.alibaba.csp.sentinel.util.AssertUtil;\n-import com.alibaba.csp.sentinel.util.StringUtil;\n-import com.alibaba.fastjson.JSON;\n-import com.alibaba.csp.sentinel.dashboard.datasource.entity.SentinelVersion;\n-import com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.AuthorityRuleEntity;\n-import com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.DegradeRuleEntity;\n-import com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.FlowRuleEntity;\n-import com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.ParamFlowRuleEntity;\n-import com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.RuleEntity;\n-import com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.SystemRuleEntity;\n-import com.alibaba.csp.sentinel.dashboard.discovery.AppManagement;\n+import com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.*;\n import com.alibaba.csp.sentinel.dashboard.domain.cluster.ClusterClientInfoVO;\n-import com.alibaba.csp.sentinel.dashboard.domain.cluster.state.ClusterServerStateVO;\n-import com.alibaba.csp.sentinel.dashboard.domain.cluster.state.ClusterStateSimpleEntity;\n import com.alibaba.csp.sentinel.dashboard.domain.cluster.config.ClusterClientConfig;\n import com.alibaba.csp.sentinel.dashboard.domain.cluster.config.ServerFlowConfig;\n import com.alibaba.csp.sentinel.dashboard.domain.cluster.config.ServerTransportConfig;\n-import com.alibaba.csp.sentinel.dashboard.util.VersionUtils;\n+import com.alibaba.csp.sentinel.dashboard.domain.cluster.state.ClusterServerStateVO;\n+import com.alibaba.csp.sentinel.dashboard.domain.cluster.state.ClusterStateSimpleEntity;\n \n-import org.apache.http.Consts;\n-import org.apache.http.HttpResponse;\n-import org.apache.http.NameValuePair;\n-import org.apache.http.client.entity.UrlEncodedFormEntity;\n-import org.apache.http.client.methods.HttpGet;\n-import org.apache.http.client.methods.HttpPost;\n-import org.apache.http.client.methods.HttpUriRequest;\n-import org.apache.http.client.utils.URLEncodedUtils;\n-import org.apache.http.concurrent.FutureCallback;\n-import org.apache.http.entity.ContentType;\n-import org.apache.http.impl.client.DefaultRedirectStrategy;\n-import org.apache.http.impl.nio.client.CloseableHttpAsyncClient;\n-import org.apache.http.impl.nio.client.HttpAsyncClients;\n-import org.apache.http.impl.nio.reactor.IOReactorConfig;\n-import org.apache.http.message.BasicNameValuePair;\n-import org.apache.http.util.EntityUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.lang.Nullable;\n-import org.springframework.stereotype.Component;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n /**\n  * Communicate with Sentinel client.\n  *\n  * @author leyou\n+ * @author wxq\n  */\n-@Component\n-public class SentinelApiClient {\n-    private static Logger logger = LoggerFactory.getLogger(SentinelApiClient.class);\n+public interface SentinelApiClient {\n \n-    private static final Charset DEFAULT_CHARSET = Charset.forName(SentinelConfig.charset());\n-    private static final String HTTP_HEADER_CONTENT_TYPE = \"Content-Type\";\n-    private static final String HTTP_HEADER_CONTENT_TYPE_URLENCODED = ContentType.create(URLEncodedUtils.CONTENT_TYPE).toString();\n+    void close() throws Exception;\n \n-    private static final String RESOURCE_URL_PATH = \"jsonTree\";\n-    private static final String CLUSTER_NODE_PATH = \"clusterNode\";\n-    private static final String GET_RULES_PATH = \"getRules\";\n-    private static final String SET_RULES_PATH = \"setRules\";\n-    private static final String GET_PARAM_RULE_PATH = \"getParamFlowRules\";\n-    private static final String SET_PARAM_RULE_PATH = \"setParamFlowRules\";\n-\n-    private static final String FETCH_CLUSTER_MODE_PATH = \"getClusterMode\";\n-    private static final String MODIFY_CLUSTER_MODE_PATH = \"setClusterMode\";\n-    private static final String FETCH_CLUSTER_CLIENT_CONFIG_PATH = \"cluster/client/fetchConfig\";\n-    private static final String MODIFY_CLUSTER_CLIENT_CONFIG_PATH = \"cluster/client/modifyConfig\";\n-\n-    private static final String FETCH_CLUSTER_SERVER_BASIC_INFO_PATH = \"cluster/server/info\";\n-\n-    private static final String MODIFY_CLUSTER_SERVER_TRANSPORT_CONFIG_PATH = \"cluster/server/modifyTransportConfig\";\n-    private static final String MODIFY_CLUSTER_SERVER_FLOW_CONFIG_PATH = \"cluster/server/modifyFlowConfig\";\n-    private static final String MODIFY_CLUSTER_SERVER_NAMESPACE_SET_PATH = \"cluster/server/modifyNamespaceSet\";\n-\n-    private static final String FETCH_GATEWAY_API_PATH = \"gateway/getApiDefinitions\";\n-    private static final String MODIFY_GATEWAY_API_PATH = \"gateway/updateApiDefinitions\";\n-\n-    private static final String FETCH_GATEWAY_FLOW_RULE_PATH = \"gateway/getRules\";\n-    private static final String MODIFY_GATEWAY_FLOW_RULE_PATH = \"gateway/updateRules\";\n-\n-    private static final String FLOW_RULE_TYPE = \"flow\";\n-    private static final String DEGRADE_RULE_TYPE = \"degrade\";\n-    private static final String SYSTEM_RULE_TYPE = \"system\";\n-    private static final String AUTHORITY_TYPE = \"authority\";\n-\n-    private CloseableHttpAsyncClient httpClient;\n-\n-    private static final SentinelVersion version160 = new SentinelVersion(1, 6, 0);\n-    private static final SentinelVersion version171 = new SentinelVersion(1, 7, 1);\n-    \n-    @Autowired\n-    private AppManagement appManagement;\n-\n-    public SentinelApiClient() {\n-        IOReactorConfig ioConfig = IOReactorConfig.custom().setConnectTimeout(3000).setSoTimeout(10000)\n-            .setIoThreadCount(Runtime.getRuntime().availableProcessors() * 2).build();\n-        httpClient = HttpAsyncClients.custom().setRedirectStrategy(new DefaultRedirectStrategy() {\n-            @Override\n-            protected boolean isRedirectable(final String method) {\n-                return false;\n-            }\n-        }).setMaxConnTotal(4000).setMaxConnPerRoute(1000).setDefaultIOReactorConfig(ioConfig).build();\n-        httpClient.start();\n-    }\n-\n-    private boolean isSuccess(int statusCode) {\n-        return statusCode >= 200 && statusCode < 300;\n-    }\n-    \n-    private boolean isCommandNotFound(int statusCode, String body) {\n-        return statusCode == 400 && StringUtil.isNotEmpty(body) && body.contains(CommandConstants.MSG_UNKNOWN_COMMAND_PREFIX);\n-    }\n-    \n-    protected boolean isSupportPost(String app, String ip, int port) {\n-        return StringUtil.isNotEmpty(app) && Optional.ofNullable(appManagement.getDetailApp(app))\n-                .flatMap(e -> e.getMachine(ip, port))\n-                .flatMap(m -> VersionUtils.parseVersion(m.getVersion())\n-                    .map(v -> v.greaterOrEqual(version160)))\n-                .orElse(false);\n-    }\n-    \n-    /**\n-     * Check wheter target instance (identified by tuple of app-ip:port)\n-     * supports the form of \"xxxxx; xx=xx\" in \"Content-Type\" header.\n-     * \n-     * @param app target app name\n-     * @param ip target node's address\n-     * @param port target node's port\n-     */\n-    protected boolean isSupportEnhancedContentType(String app, String ip, int port) {\n-        return StringUtil.isNotEmpty(app) && Optional.ofNullable(appManagement.getDetailApp(app))\n-                .flatMap(e -> e.getMachine(ip, port))\n-                .flatMap(m -> VersionUtils.parseVersion(m.getVersion())\n-                    .map(v -> v.greaterOrEqual(version171)))\n-                .orElse(false);\n-    }\n-    \n-    private StringBuilder queryString(Map<String, String> params) {\n-        StringBuilder queryStringBuilder = new StringBuilder();\n-        for (Entry<String, String> entry : params.entrySet()) {\n-            if (StringUtil.isEmpty(entry.getValue())) {\n-                continue;\n-            }\n-            String name = urlEncode(entry.getKey());\n-            String value = urlEncode(entry.getValue());\n-            if (name != null && value != null) {\n-                if (queryStringBuilder.length() > 0) {\n-                    queryStringBuilder.append('&');\n-                }\n-                queryStringBuilder.append(name).append('=').append(value);\n-            }\n-        }\n-        return queryStringBuilder;\n-    }\n-    \n-    /**\n-     * Build an `HttpUriRequest` in POST way.\n-     * \n-     * @param url\n-     * @param params\n-     * @param supportEnhancedContentType see {@link #isSupportEnhancedContentType(String, String, int)}\n-     * @return\n-     */\n-    protected static HttpUriRequest postRequest(String url, Map<String, String> params, boolean supportEnhancedContentType) {\n-        HttpPost httpPost = new HttpPost(url);\n-        if (params != null && params.size() > 0) {\n-            List<NameValuePair> list = new ArrayList<>(params.size());\n-            for (Entry<String, String> entry : params.entrySet()) {\n-                list.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));\n-            }\n-            httpPost.setEntity(new UrlEncodedFormEntity(list, Consts.UTF_8));\n-            if (!supportEnhancedContentType) {\n-                httpPost.setHeader(HTTP_HEADER_CONTENT_TYPE, HTTP_HEADER_CONTENT_TYPE_URLENCODED);\n-            }\n-        }\n-        return httpPost;\n-    }\n-    \n-    private String urlEncode(String str) {\n-        try {\n-            return URLEncoder.encode(str, DEFAULT_CHARSET.name());\n-        } catch (UnsupportedEncodingException e) {\n-            logger.info(\"encode string error: {}\", str, e);\n-            return null;\n-        }\n-    }\n-    \n-    private String getBody(HttpResponse response) throws Exception {\n-        Charset charset = null;\n-        try {\n-            String contentTypeStr = response.getFirstHeader(HTTP_HEADER_CONTENT_TYPE).getValue();\n-            if (StringUtil.isNotEmpty(contentTypeStr)) {\n-                ContentType contentType = ContentType.parse(contentTypeStr);\n-                charset = contentType.getCharset();\n-            }\n-        } catch (Exception ignore) {\n-        }\n-        return EntityUtils.toString(response.getEntity(), charset != null ? charset : DEFAULT_CHARSET);\n-    }\n-    \n-    /**\n-     * With no param\n-     * \n-     * @param ip\n-     * @param port\n-     * @param api\n-     * @return\n-     */\n-    private CompletableFuture<String> executeCommand(String ip, int port, String api, boolean useHttpPost) {\n-        return executeCommand(ip, port, api, null, useHttpPost);\n-    }\n-    \n-    /**\n-     * No app specified, force to GET\n-     * \n-     * @param ip\n-     * @param port\n-     * @param api\n-     * @param params\n-     * @return\n-     */\n-    private CompletableFuture<String> executeCommand(String ip, int port, String api, Map<String, String> params, boolean useHttpPost) {\n-        return executeCommand(null, ip, port, api, params, useHttpPost);\n-    }\n-\n-    /**\n-     * Prefer to execute request using POST\n-     * \n-     * @param app\n-     * @param ip\n-     * @param port\n-     * @param api\n-     * @param params\n-     * @return\n-     */\n-    private CompletableFuture<String> executeCommand(String app, String ip, int port, String api, Map<String, String> params, boolean useHttpPost) {\n-        CompletableFuture<String> future = new CompletableFuture<>();\n-        if (StringUtil.isBlank(ip) || StringUtil.isBlank(api)) {\n-            future.completeExceptionally(new IllegalArgumentException(\"Bad URL or command name\"));\n-            return future;\n-        }\n-        StringBuilder urlBuilder = new StringBuilder();\n-        urlBuilder.append(\"http://\");\n-        urlBuilder.append(ip).append(':').append(port).append('/').append(api);\n-        if (params == null) {\n-            params = Collections.emptyMap();\n-        }\n-        if (!useHttpPost || !isSupportPost(app, ip, port)) {\n-            // Using GET in older versions, append parameters after url\n-            if (!params.isEmpty()) {\n-                if (urlBuilder.indexOf(\"?\") == -1) {\n-                    urlBuilder.append('?');\n-                } else {\n-                    urlBuilder.append('&');\n-                }\n-                urlBuilder.append(queryString(params));\n-            }\n-            return executeCommand(new HttpGet(urlBuilder.toString()));\n-        } else {\n-            // Using POST\n-            return executeCommand(\n-                    postRequest(urlBuilder.toString(), params, isSupportEnhancedContentType(app, ip, port)));\n-        }\n-    }\n-    \n-    private CompletableFuture<String> executeCommand(HttpUriRequest request) {\n-        CompletableFuture<String> future = new CompletableFuture<>();\n-        httpClient.execute(request, new FutureCallback<HttpResponse>() {\n-            @Override\n-            public void completed(final HttpResponse response) {\n-                int statusCode = response.getStatusLine().getStatusCode();\n-                try {\n-                    String value = getBody(response);\n-                    if (isSuccess(statusCode)) {\n-                        future.complete(value);\n-                    } else {\n-                        if (isCommandNotFound(statusCode, value)) {\n-                            future.completeExceptionally(new CommandNotFoundException(request.getURI().getPath()));\n-                        } else {\n-                            future.completeExceptionally(new CommandFailedException(value));\n-                        }\n-                    }\n-\n-                } catch (Exception ex) {\n-                    future.completeExceptionally(ex);\n-                    logger.error(\"HTTP request failed: {}\", request.getURI().toString(), ex);\n-                }\n-            }\n-\n-            @Override\n-            public void failed(final Exception ex) {\n-                future.completeExceptionally(ex);\n-                logger.error(\"HTTP request failed: {}\", request.getURI().toString(), ex);\n-            }\n-\n-            @Override\n-            public void cancelled() {\n-                future.complete(null);\n-            }\n-        });\n-        return future;\n-    }\n-    \n-    public void close() throws Exception {\n-        httpClient.close();\n-    }\n-    \n-    @Nullable\n-    private <T> CompletableFuture<List<T>> fetchItemsAsync(String ip, int port, String api, String type, Class<T> ruleType) {\n-        AssertUtil.notEmpty(ip, \"Bad machine IP\");\n-        AssertUtil.isTrue(port > 0, \"Bad machine port\");\n-        Map<String, String> params = null;\n-        if (StringUtil.isNotEmpty(type)) {\n-            params = new HashMap<>(1);\n-            params.put(\"type\", type);\n-        }\n-        return executeCommand(ip, port, api, params, false)\n-                .thenApply(json -> JSON.parseArray(json, ruleType));\n-    }\n-    \n-    @Nullable\n-    private <T> List<T> fetchItems(String ip, int port, String api, String type, Class<T> ruleType) {\n-        try {\n-            AssertUtil.notEmpty(ip, \"Bad machine IP\");\n-            AssertUtil.isTrue(port > 0, \"Bad machine port\");\n-            Map<String, String> params = null;\n-            if (StringUtil.isNotEmpty(type)) {\n-                params = new HashMap<>(1);\n-                params.put(\"type\", type);\n-            }\n-            return fetchItemsAsync(ip, port, api, type, ruleType).get();\n-        } catch (InterruptedException | ExecutionException e) {\n-            logger.error(\"Error when fetching items from api: {} -> {}\", api, type, e);\n-            return null;\n-        } catch (Exception e) {\n-            logger.error(\"Error when fetching items: {} -> {}\", api, type, e);\n-            return null;\n-        }\n-    }\n-    \n-    private <T extends Rule> List<T> fetchRules(String ip, int port, String type, Class<T> ruleType) {\n-        return fetchItems(ip, port, GET_RULES_PATH, type, ruleType);\n-    }\n-    \n-    private boolean setRules(String app, String ip, int port, String type, List<? extends RuleEntity> entities) {\n-        if (entities == null) {\n-            return true;\n-        }\n-        try {\n-            AssertUtil.notEmpty(app, \"Bad app name\");\n-            AssertUtil.notEmpty(ip, \"Bad machine IP\");\n-            AssertUtil.isTrue(port > 0, \"Bad machine port\");\n-            String data = JSON.toJSONString(\n-                    entities.stream().map(r -> r.toRule()).collect(Collectors.toList()));\n-            Map<String, String> params = new HashMap<>(2);\n-            params.put(\"type\", type);\n-            params.put(\"data\", data);\n-            String result = executeCommand(app, ip, port, SET_RULES_PATH, params, true).get();\n-            logger.info(\"setRules result: {}, type={}\", result, type);\n-            return true;\n-        } catch (InterruptedException e) {\n-            logger.warn(\"setRules API failed: {}\", type, e);\n-            return false;\n-        } catch (ExecutionException e) {\n-            logger.warn(\"setRules API failed: {}\", type, e.getCause());\n-            return false;\n-        } catch (Exception e) {\n-            logger.error(\"setRules API failed, type={}\", type, e);\n-            return false;\n-        }\n-    }\n-\n-    private CompletableFuture<Void> setRulesAsync(String app, String ip, int port, String type, List<? extends RuleEntity> entities) {\n-        try {\n-            AssertUtil.notNull(entities, \"rules cannot be null\");\n-            AssertUtil.notEmpty(app, \"Bad app name\");\n-            AssertUtil.notEmpty(ip, \"Bad machine IP\");\n-            AssertUtil.isTrue(port > 0, \"Bad machine port\");\n-            String data = JSON.toJSONString(\n-                entities.stream().map(r -> r.toRule()).collect(Collectors.toList()));\n-            Map<String, String> params = new HashMap<>(2);\n-            params.put(\"type\", type);\n-            params.put(\"data\", data);\n-            return executeCommand(app, ip, port, SET_RULES_PATH, params, true)\n-                .thenCompose(r -> {\n-                    if (\"success\".equalsIgnoreCase(r.trim())) {\n-                        return CompletableFuture.completedFuture(null);\n-                    }\n-                    return AsyncUtils.newFailedFuture(new CommandFailedException(r));\n-                });\n-        } catch (Exception e) {\n-            logger.error(\"setRulesAsync API failed, type={}\", type, e);\n-            return AsyncUtils.newFailedFuture(e);\n-        }\n-    }\n-\n-    public List<NodeVo> fetchResourceOfMachine(String ip, int port, String type) {\n-        return fetchItems(ip, port, RESOURCE_URL_PATH, type, NodeVo.class);\n-    }\n+    List<NodeVo> fetchResourceOfMachine(String ip, int port, String type);\n \n     /**\n      * Fetch cluster node.\n      *\n      * @param ip          ip to fetch\n      * @param port        port of the ip\n      * @param includeZero whether zero value should in the result list.\n-     * @return\n      */\n-    public List<NodeVo> fetchClusterNodeOfMachine(String ip, int port, boolean includeZero) {\n-        String type = \"notZero\";\n-        if (includeZero) {\n-            type = \"zero\";\n-        }\n-        return fetchItems(ip, port, CLUSTER_NODE_PATH, type, NodeVo.class);\n-    }\n+    List<NodeVo> fetchClusterNodeOfMachine(String ip, int port, boolean includeZero);\n \n-    public List<FlowRuleEntity> fetchFlowRuleOfMachine(String app, String ip, int port) {\n-        List<FlowRule> rules = fetchRules(ip, port, FLOW_RULE_TYPE, FlowRule.class);\n-        if (rules != null) {\n-            return rules.stream().map(rule -> FlowRuleEntity.fromFlowRule(app, ip, port, rule))\n-                .collect(Collectors.toList());\n-        } else {\n-            return null;\n-        }\n-    }\n+    List<FlowRuleEntity> fetchFlowRuleOfMachine(String app, String ip, int port);\n \n-    public List<DegradeRuleEntity> fetchDegradeRuleOfMachine(String app, String ip, int port) {\n-        List<DegradeRule> rules = fetchRules(ip, port, DEGRADE_RULE_TYPE, DegradeRule.class);\n-        if (rules != null) {\n-            return rules.stream().map(rule -> DegradeRuleEntity.fromDegradeRule(app, ip, port, rule))\n-                .collect(Collectors.toList());\n-        } else {\n-            return null;\n-        }\n-    }\n+    List<DegradeRuleEntity> fetchDegradeRuleOfMachine(String app, String ip, int port);\n \n-    public List<SystemRuleEntity> fetchSystemRuleOfMachine(String app, String ip, int port) {\n-        List<SystemRule> rules = fetchRules(ip, port, SYSTEM_RULE_TYPE, SystemRule.class);\n-        if (rules != null) {\n-            return rules.stream().map(rule -> SystemRuleEntity.fromSystemRule(app, ip, port, rule))\n-                .collect(Collectors.toList());\n-        } else {\n-            return null;\n-        }\n-    }\n+    List<SystemRuleEntity> fetchSystemRuleOfMachine(String app, String ip, int port);\n \n     /**\n      * Fetch all parameter flow rules from provided machine.\n@@ -496,21 +66,7 @@ private boolean setRules(String app, String ip, int port, String type, List<? ex\n      * @return all retrieved parameter flow rules\n      * @since 0.2.1\n      */\n-    public CompletableFuture<List<ParamFlowRuleEntity>> fetchParamFlowRulesOfMachine(String app, String ip, int port) {\n-        try {\n-            AssertUtil.notEmpty(app, \"Bad app name\");\n-            AssertUtil.notEmpty(ip, \"Bad machine IP\");\n-            AssertUtil.isTrue(port > 0, \"Bad machine port\");\n-            return fetchItemsAsync(ip, port, GET_PARAM_RULE_PATH, null, ParamFlowRule.class)\n-                .thenApply(rules -> rules.stream()\n-                    .map(e -> ParamFlowRuleEntity.fromAuthorityRule(app, ip, port, e))\n-                    .collect(Collectors.toList())\n-                );\n-        } catch (Exception e) {\n-            logger.error(\"Error when fetching parameter flow rules\", e);\n-            return AsyncUtils.newFailedFuture(e);\n-        }\n-    }\n+    CompletableFuture<List<ParamFlowRuleEntity>> fetchParamFlowRulesOfMachine(String app, String ip, int port);\n \n     /**\n      * Fetch all authority rules from provided machine.\n@@ -521,332 +77,61 @@ private boolean setRules(String app, String ip, int port, String type, List<? ex\n      * @return all retrieved authority rules\n      * @since 0.2.1\n      */\n-    public List<AuthorityRuleEntity> fetchAuthorityRulesOfMachine(String app, String ip, int port) {\n-        AssertUtil.notEmpty(app, \"Bad app name\");\n-        AssertUtil.notEmpty(ip, \"Bad machine IP\");\n-        AssertUtil.isTrue(port > 0, \"Bad machine port\");\n-        Map<String, String> params = new HashMap<>(1);\n-        params.put(\"type\", AUTHORITY_TYPE);\n-        List<AuthorityRule> rules = fetchRules(ip, port, AUTHORITY_TYPE, AuthorityRule.class);\n-        return Optional.ofNullable(rules).map(r -> r.stream()\n-                    .map(e -> AuthorityRuleEntity.fromAuthorityRule(app, ip, port, e))\n-                    .collect(Collectors.toList())\n-                ).orElse(null);\n-    }\n+    List<AuthorityRuleEntity> fetchAuthorityRulesOfMachine(String app, String ip, int port);\n \n     /**\n      * set rules of the machine. rules == null will return immediately;\n      * rules.isEmpty() means setting the rules to empty.\n      *\n-     * @param app\n-     * @param ip\n-     * @param port\n-     * @param rules\n      * @return whether successfully set the rules.\n      */\n-    public boolean setFlowRuleOfMachine(String app, String ip, int port, List<FlowRuleEntity> rules) {\n-        return setRules(app, ip, port, FLOW_RULE_TYPE, rules);\n-    }\n+    boolean setFlowRuleOfMachine(String app, String ip, int port, List<FlowRuleEntity> rules);\n \n-    public CompletableFuture<Void> setFlowRuleOfMachineAsync(String app, String ip, int port, List<FlowRuleEntity> rules) {\n-        return setRulesAsync(app, ip, port, FLOW_RULE_TYPE, rules);\n-    }\n+    CompletableFuture<Void> setFlowRuleOfMachineAsync(String app, String ip, int port, List<FlowRuleEntity> rules);\n \n     /**\n      * set rules of the machine. rules == null will return immediately;\n      * rules.isEmpty() means setting the rules to empty.\n      *\n-     * @param app\n-     * @param ip\n-     * @param port\n-     * @param rules\n      * @return whether successfully set the rules.\n      */\n-    public boolean setDegradeRuleOfMachine(String app, String ip, int port, List<DegradeRuleEntity> rules) {\n-        return setRules(app, ip, port, DEGRADE_RULE_TYPE, rules);\n-    }\n+    boolean setDegradeRuleOfMachine(String app, String ip, int port, List<DegradeRuleEntity> rules);\n \n     /**\n      * set rules of the machine. rules == null will return immediately;\n      * rules.isEmpty() means setting the rules to empty.\n      *\n-     * @param app\n-     * @param ip\n-     * @param port\n-     * @param rules\n      * @return whether successfully set the rules.\n      */\n-    public boolean setSystemRuleOfMachine(String app, String ip, int port, List<SystemRuleEntity> rules) {\n-        return setRules(app, ip, port, SYSTEM_RULE_TYPE, rules);\n-    }\n+    boolean setSystemRuleOfMachine(String app, String ip, int port, List<SystemRuleEntity> rules);\n \n-    public boolean setAuthorityRuleOfMachine(String app, String ip, int port, List<AuthorityRuleEntity> rules) {\n-        return setRules(app, ip, port, AUTHORITY_TYPE, rules);\n-    }\n+    boolean setAuthorityRuleOfMachine(String app, String ip, int port, List<AuthorityRuleEntity> rules);\n \n-    public CompletableFuture<Void> setParamFlowRuleOfMachine(String app, String ip, int port, List<ParamFlowRuleEntity> rules) {\n-        if (rules == null) {\n-            return CompletableFuture.completedFuture(null);\n-        }\n-        if (StringUtil.isBlank(ip) || port <= 0) {\n-            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n-        }\n-        try {\n-            String data = JSON.toJSONString(\n-                rules.stream().map(ParamFlowRuleEntity::getRule).collect(Collectors.toList())\n-            );\n-            Map<String, String> params = new HashMap<>(1);\n-            params.put(\"data\", data);\n-            return executeCommand(app, ip, port, SET_PARAM_RULE_PATH, params, true)\n-                .thenCompose(e -> {\n-                    if (CommandConstants.MSG_SUCCESS.equals(e)) {\n-                        return CompletableFuture.completedFuture(null);\n-                    } else {\n-                        logger.warn(\"Push parameter flow rules to client failed: \" + e);\n-                        return AsyncUtils.newFailedFuture(new RuntimeException(e));\n-                    }\n-                });\n-        } catch (Exception ex) {\n-            logger.warn(\"Error when setting parameter flow rule\", ex);\n-            return AsyncUtils.newFailedFuture(ex);\n-        }\n-    }\n+    CompletableFuture<Void> setParamFlowRuleOfMachine(String app, String ip, int port, List<ParamFlowRuleEntity> rules);\n \n     // Cluster related\n \n-    public CompletableFuture<ClusterStateSimpleEntity> fetchClusterMode(String ip, int port) {\n-        if (StringUtil.isBlank(ip) || port <= 0) {\n-            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n-        }\n-        try {\n-            return executeCommand(ip, port, FETCH_CLUSTER_MODE_PATH, false)\n-                .thenApply(r -> JSON.parseObject(r, ClusterStateSimpleEntity.class));\n-        } catch (Exception ex) {\n-            logger.warn(\"Error when fetching cluster mode\", ex);\n-            return AsyncUtils.newFailedFuture(ex);\n-        }\n-    }\n-\n-    public CompletableFuture<Void> modifyClusterMode(String ip, int port, int mode) {\n-        if (StringUtil.isBlank(ip) || port <= 0) {\n-            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n-        }\n-        try {\n-            Map<String, String> params = new HashMap<>(1);\n-            params.put(\"mode\", String.valueOf(mode));\n-            return executeCommand(ip, port, MODIFY_CLUSTER_MODE_PATH, params, false)\n-                .thenCompose(e -> {\n-                    if (CommandConstants.MSG_SUCCESS.equals(e)) {\n-                        return CompletableFuture.completedFuture(null);\n-                    } else {\n-                        logger.warn(\"Error when modifying cluster mode: \" + e);\n-                        return AsyncUtils.newFailedFuture(new RuntimeException(e));\n-                    }\n-                });\n-        } catch (Exception ex) {\n-            logger.warn(\"Error when modifying cluster mode\", ex);\n-            return AsyncUtils.newFailedFuture(ex);\n-        }\n-    }\n-\n-    public CompletableFuture<ClusterClientInfoVO> fetchClusterClientInfoAndConfig(String ip, int port) {\n-        if (StringUtil.isBlank(ip) || port <= 0) {\n-            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n-        }\n-        try {\n-            return executeCommand(ip, port, FETCH_CLUSTER_CLIENT_CONFIG_PATH, false)\n-                .thenApply(r -> JSON.parseObject(r, ClusterClientInfoVO.class));\n-        } catch (Exception ex) {\n-            logger.warn(\"Error when fetching cluster client config\", ex);\n-            return AsyncUtils.newFailedFuture(ex);\n-        }\n-    }\n-\n-    public CompletableFuture<Void> modifyClusterClientConfig(String app, String ip, int port, ClusterClientConfig config) {\n-        if (StringUtil.isBlank(ip) || port <= 0) {\n-            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n-        }\n-        try {\n-            Map<String, String> params = new HashMap<>(1);\n-            params.put(\"data\", JSON.toJSONString(config));\n-            return executeCommand(app, ip, port, MODIFY_CLUSTER_CLIENT_CONFIG_PATH, params, true)\n-                .thenCompose(e -> {\n-                    if (CommandConstants.MSG_SUCCESS.equals(e)) {\n-                        return CompletableFuture.completedFuture(null);\n-                    } else {\n-                        logger.warn(\"Error when modifying cluster client config: \" + e);\n-                        return AsyncUtils.newFailedFuture(new RuntimeException(e));\n-                    }\n-                });\n-        } catch (Exception ex) {\n-            logger.warn(\"Error when modifying cluster client config\", ex);\n-            return AsyncUtils.newFailedFuture(ex);\n-        }\n-    }\n-\n-    public CompletableFuture<Void> modifyClusterServerFlowConfig(String app, String ip, int port, ServerFlowConfig config) {\n-        if (StringUtil.isBlank(ip) || port <= 0) {\n-            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n-        }\n-        try {\n-            Map<String, String> params = new HashMap<>(1);\n-            params.put(\"data\", JSON.toJSONString(config));\n-            return executeCommand(app, ip, port, MODIFY_CLUSTER_SERVER_FLOW_CONFIG_PATH, params, true)\n-                .thenCompose(e -> {\n-                    if (CommandConstants.MSG_SUCCESS.equals(e)) {\n-                        return CompletableFuture.completedFuture(null);\n-                    } else {\n-                        logger.warn(\"Error when modifying cluster server flow config: \" + e);\n-                        return AsyncUtils.newFailedFuture(new RuntimeException(e));\n-                    }\n-                });\n-        } catch (Exception ex) {\n-            logger.warn(\"Error when modifying cluster server flow config\", ex);\n-            return AsyncUtils.newFailedFuture(ex);\n-        }\n-    }\n+    CompletableFuture<ClusterStateSimpleEntity> fetchClusterMode(String ip, int port);\n \n-    public CompletableFuture<Void> modifyClusterServerTransportConfig(String app, String ip, int port, ServerTransportConfig config) {\n-        if (StringUtil.isBlank(ip) || port <= 0) {\n-            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n-        }\n-        try {\n-            Map<String, String> params = new HashMap<>(2);\n-            params.put(\"port\", config.getPort().toString());\n-            params.put(\"idleSeconds\", config.getIdleSeconds().toString());\n-            return executeCommand(app, ip, port, MODIFY_CLUSTER_SERVER_TRANSPORT_CONFIG_PATH, params, false)\n-                .thenCompose(e -> {\n-                    if (CommandConstants.MSG_SUCCESS.equals(e)) {\n-                        return CompletableFuture.completedFuture(null);\n-                    } else {\n-                        logger.warn(\"Error when modifying cluster server transport config: \" + e);\n-                        return AsyncUtils.newFailedFuture(new RuntimeException(e));\n-                    }\n-                });\n-        } catch (Exception ex) {\n-            logger.warn(\"Error when modifying cluster server transport config\", ex);\n-            return AsyncUtils.newFailedFuture(ex);\n-        }\n-    }\n+    CompletableFuture<Void> modifyClusterMode(String ip, int port, int mode);\n \n-    public CompletableFuture<Void> modifyClusterServerNamespaceSet(String app, String ip, int port, Set<String> set) {\n-        if (StringUtil.isBlank(ip) || port <= 0) {\n-            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n-        }\n-        try {\n-            Map<String, String> params = new HashMap<>(1);\n-            params.put(\"data\", JSON.toJSONString(set));\n-            return executeCommand(app, ip, port, MODIFY_CLUSTER_SERVER_NAMESPACE_SET_PATH, params, true)\n-                .thenCompose(e -> {\n-                    if (CommandConstants.MSG_SUCCESS.equals(e)) {\n-                        return CompletableFuture.completedFuture(null);\n-                    } else {\n-                        logger.warn(\"Error when modifying cluster server NamespaceSet\", e);\n-                        return AsyncUtils.newFailedFuture(new RuntimeException(e));\n-                    }\n-                });\n-        } catch (Exception ex) {\n-            logger.warn(\"Error when modifying cluster server NamespaceSet\", ex);\n-            return AsyncUtils.newFailedFuture(ex);\n-        }\n-    }\n+    CompletableFuture<ClusterClientInfoVO> fetchClusterClientInfoAndConfig(String ip, int port);\n \n-    public CompletableFuture<ClusterServerStateVO> fetchClusterServerBasicInfo(String ip, int port) {\n-        if (StringUtil.isBlank(ip) || port <= 0) {\n-            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n-        }\n-        try {\n-            return executeCommand(ip, port, FETCH_CLUSTER_SERVER_BASIC_INFO_PATH, false)\n-                .thenApply(r -> JSON.parseObject(r, ClusterServerStateVO.class));\n-        } catch (Exception ex) {\n-            logger.warn(\"Error when fetching cluster sever all config and basic info\", ex);\n-            return AsyncUtils.newFailedFuture(ex);\n-        }\n-    }\n+    CompletableFuture<Void> modifyClusterClientConfig(String app, String ip, int port, ClusterClientConfig config);\n \n-    public CompletableFuture<List<ApiDefinitionEntity>> fetchApis(String app, String ip, int port) {\n-        if (StringUtil.isBlank(ip) || port <= 0) {\n-            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n-        }\n+    CompletableFuture<Void> modifyClusterServerFlowConfig(String app, String ip, int port, ServerFlowConfig config);\n \n-        try {\n-            return executeCommand(ip, port, FETCH_GATEWAY_API_PATH, false)\n-                    .thenApply(r -> {\n-                        List<ApiDefinitionEntity> entities = JSON.parseArray(r, ApiDefinitionEntity.class);\n-                        if (entities != null) {\n-                            for (ApiDefinitionEntity entity : entities) {\n-                                entity.setApp(app);\n-                                entity.setIp(ip);\n-                                entity.setPort(port);\n-                            }\n-                        }\n-                        return entities;\n-                    });\n-        } catch (Exception ex) {\n-            logger.warn(\"Error when fetching gateway apis\", ex);\n-            return AsyncUtils.newFailedFuture(ex);\n-        }\n-    }\n+    CompletableFuture<Void> modifyClusterServerTransportConfig(String app, String ip, int port, ServerTransportConfig config);\n \n-    public boolean modifyApis(String app, String ip, int port, List<ApiDefinitionEntity> apis) {\n-        if (apis == null) {\n-            return true;\n-        }\n+    CompletableFuture<Void> modifyClusterServerNamespaceSet(String app, String ip, int port, Set<String> set);\n \n-        try {\n-            AssertUtil.notEmpty(app, \"Bad app name\");\n-            AssertUtil.notEmpty(ip, \"Bad machine IP\");\n-            AssertUtil.isTrue(port > 0, \"Bad machine port\");\n-            String data = JSON.toJSONString(\n-                    apis.stream().map(r -> r.toApiDefinition()).collect(Collectors.toList()));\n-            Map<String, String> params = new HashMap<>(2);\n-            params.put(\"data\", data);\n-            String result = executeCommand(app, ip, port, MODIFY_GATEWAY_API_PATH, params, true).get();\n-            logger.info(\"Modify gateway apis: {}\", result);\n-            return true;\n-        } catch (Exception e) {\n-            logger.warn(\"Error when modifying gateway apis\", e);\n-            return false;\n-        }\n-    }\n+    CompletableFuture<ClusterServerStateVO> fetchClusterServerBasicInfo(String ip, int port);\n \n-    public CompletableFuture<List<GatewayFlowRuleEntity>> fetchGatewayFlowRules(String app, String ip, int port) {\n-        if (StringUtil.isBlank(ip) || port <= 0) {\n-            return AsyncUtils.newFailedFuture(new IllegalArgumentException(\"Invalid parameter\"));\n-        }\n+    CompletableFuture<List<ApiDefinitionEntity>> fetchApis(String app, String ip, int port);\n \n-        try {\n-            return executeCommand(ip, port, FETCH_GATEWAY_FLOW_RULE_PATH, false)\n-                    .thenApply(r -> {\n-                        List<GatewayFlowRule> gatewayFlowRules = JSON.parseArray(r, GatewayFlowRule.class);\n-                        List<GatewayFlowRuleEntity> entities = gatewayFlowRules.stream().map(rule -> GatewayFlowRuleEntity.fromGatewayFlowRule(app, ip, port, rule)).collect(Collectors.toList());\n-                        return entities;\n-                    });\n-        } catch (Exception ex) {\n-            logger.warn(\"Error when fetching gateway flow rules\", ex);\n-            return AsyncUtils.newFailedFuture(ex);\n-        }\n-    }\n+    boolean modifyApis(String app, String ip, int port, List<ApiDefinitionEntity> apis);\n \n-    public boolean modifyGatewayFlowRules(String app, String ip, int port, List<GatewayFlowRuleEntity> rules) {\n-        if (rules == null) {\n-            return true;\n-        }\n+    CompletableFuture<List<GatewayFlowRuleEntity>> fetchGatewayFlowRules(String app, String ip, int port);\n \n-        try {\n-            AssertUtil.notEmpty(app, \"Bad app name\");\n-            AssertUtil.notEmpty(ip, \"Bad machine IP\");\n-            AssertUtil.isTrue(port > 0, \"Bad machine port\");\n-            String data = JSON.toJSONString(\n-                    rules.stream().map(r -> r.toGatewayFlowRule()).collect(Collectors.toList()));\n-            Map<String, String> params = new HashMap<>(2);\n-            params.put(\"data\", data);\n-            String result = executeCommand(app, ip, port, MODIFY_GATEWAY_FLOW_RULE_PATH, params, true).get();\n-            logger.info(\"Modify gateway flow rules: {}\", result);\n-            return true;\n-        } catch (Exception e) {\n-            logger.warn(\"Error when modifying gateway apis\", e);\n-            return false;\n-        }\n-    }\n+    boolean modifyGatewayFlowRules(String app, String ip, int port, List<GatewayFlowRuleEntity> rules);\n }"
  },
  {
    "sha": "3c8de5391c277103b9dcb0ef7a3cda73b30a8c8f",
    "filename": "sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/config/SentinelApiClientConfiguration.java",
    "status": "added",
    "additions": 19,
    "deletions": 0,
    "changes": 19,
    "blob_url": "https://github.com/alibaba/Sentinel/blob/d94bfe370c4f4be771edb88ac896377d73bcda89/sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/config/SentinelApiClientConfiguration.java",
    "raw_url": "https://github.com/alibaba/Sentinel/raw/d94bfe370c4f4be771edb88ac896377d73bcda89/sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/config/SentinelApiClientConfiguration.java",
    "contents_url": "https://api.github.com/repos/alibaba/Sentinel/contents/sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/config/SentinelApiClientConfiguration.java?ref=d94bfe370c4f4be771edb88ac896377d73bcda89",
    "patch": "@@ -0,0 +1,19 @@\n+package com.alibaba.csp.sentinel.dashboard.config;\n+\n+import com.alibaba.csp.sentinel.dashboard.client.DefaultSentinelApiClient;\n+import com.alibaba.csp.sentinel.dashboard.client.SentinelApiClient;\n+import com.alibaba.csp.sentinel.dashboard.discovery.AppManagement;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+@Configuration\n+public class SentinelApiClientConfiguration {\n+\n+    @Bean\n+    @ConditionalOnMissingBean\n+    public SentinelApiClient sentinelApiClient(AppManagement appManagement) {\n+        return new DefaultSentinelApiClient(appManagement);\n+    }\n+\n+}"
  },
  {
    "sha": "7b0562364e4fd4840e88b9a976d0db591d00fbf9",
    "filename": "sentinel-dashboard/src/test/java/com/alibaba/csp/sentinel/dashboard/client/DefaultSentinelApiClientTest.java",
    "status": "renamed",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/alibaba/Sentinel/blob/d94bfe370c4f4be771edb88ac896377d73bcda89/sentinel-dashboard/src/test/java/com/alibaba/csp/sentinel/dashboard/client/DefaultSentinelApiClientTest.java",
    "raw_url": "https://github.com/alibaba/Sentinel/raw/d94bfe370c4f4be771edb88ac896377d73bcda89/sentinel-dashboard/src/test/java/com/alibaba/csp/sentinel/dashboard/client/DefaultSentinelApiClientTest.java",
    "contents_url": "https://api.github.com/repos/alibaba/Sentinel/contents/sentinel-dashboard/src/test/java/com/alibaba/csp/sentinel/dashboard/client/DefaultSentinelApiClientTest.java?ref=d94bfe370c4f4be771edb88ac896377d73bcda89",
    "patch": "@@ -27,7 +27,7 @@\n import org.apache.http.protocol.RequestContent;\n import org.junit.Test;\n \n-public class SentinelApiClientTest {\n+public class DefaultSentinelApiClientTest {\n     @Test\n     public void postRequest() throws HttpException, IOException {\n         // Processor is required because it will determine the final request body including\n@@ -40,13 +40,13 @@ public void postRequest() throws HttpException, IOException {\n         \n         HttpUriRequest request;\n         \n-        request = SentinelApiClient.postRequest(\"/test\", params, false);\n+        request = DefaultSentinelApiClient.postRequest(\"/test\", params, false);\n         assertNotNull(request);\n         processor.process(request, null);\n         assertNotNull(request.getFirstHeader(\"Content-Type\"));\n         assertEquals(\"application/x-www-form-urlencoded\", request.getFirstHeader(\"Content-Type\").getValue());\n         \n-        request = SentinelApiClient.postRequest(\"/test\", params, true);\n+        request = DefaultSentinelApiClient.postRequest(\"/test\", params, true);\n         assertNotNull(request);\n         processor.process(request, null);\n         assertNotNull(request.getFirstHeader(\"Content-Type\"));",
    "previous_filename": "sentinel-dashboard/src/test/java/com/alibaba/csp/sentinel/dashboard/client/SentinelApiClientTest.java"
  }
]
