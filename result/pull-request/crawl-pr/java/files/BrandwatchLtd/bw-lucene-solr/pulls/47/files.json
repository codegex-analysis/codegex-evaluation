[
  {
    "sha": "27ae91e6109410dbccc1e0830f2c794d8cdbba3a",
    "filename": "solr/core/src/java/org/apache/solr/update/processor/ConditionalUpsertProcessorFactory.java",
    "status": "added",
    "additions": 123,
    "deletions": 0,
    "changes": 123,
    "blob_url": "https://github.com/BrandwatchLtd/bw-lucene-solr/blob/625de8e9c86324a40f9840252ce6533007be0a4e/solr/core/src/java/org/apache/solr/update/processor/ConditionalUpsertProcessorFactory.java",
    "raw_url": "https://github.com/BrandwatchLtd/bw-lucene-solr/raw/625de8e9c86324a40f9840252ce6533007be0a4e/solr/core/src/java/org/apache/solr/update/processor/ConditionalUpsertProcessorFactory.java",
    "contents_url": "https://api.github.com/repos/BrandwatchLtd/bw-lucene-solr/contents/solr/core/src/java/org/apache/solr/update/processor/ConditionalUpsertProcessorFactory.java?ref=625de8e9c86324a40f9840252ce6533007be0a4e",
    "patch": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.update.processor;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.NamedList;\n+import org.apache.solr.core.SolrCore;\n+import org.apache.solr.handler.component.RealTimeGetComponent;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.update.AddUpdateCommand;\n+import org.apache.solr.update.UpdateCommand;\n+import org.apache.solr.util.plugin.SolrCoreAware;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.SolrException.ErrorCode.SERVER_ERROR;\n+import static org.apache.solr.update.processor.DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM;\n+\n+public class ConditionalUpsertProcessorFactory extends UpdateRequestProcessorFactory implements SolrCoreAware, UpdateRequestProcessorFactory.RunAlways {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  private final List<UpsertCondition> conditions = new ArrayList<>();\n+\n+  @Override\n+  public void init(NamedList args)  {\n+    conditions.clear();\n+    conditions.addAll(UpsertCondition.readConditions(args));\n+    super.init(args);\n+  }\n+\n+  @Override\n+  public ConditionalUpsertUpdateProcessor getInstance(SolrQueryRequest req,\n+                                                          SolrQueryResponse rsp,\n+                                                          UpdateRequestProcessor next) {\n+    return new ConditionalUpsertUpdateProcessor(req, next, conditions);\n+  }\n+\n+  @Override\n+  public void inform(SolrCore core) {\n+    if (core.getUpdateHandler().getUpdateLog() == null) {\n+      throw new SolrException(SERVER_ERROR, \"updateLog must be enabled.\");\n+    }\n+\n+    if (core.getLatestSchema().getUniqueKeyField() == null) {\n+      throw new SolrException(SERVER_ERROR, \"schema must have uniqueKey defined.\");\n+    }\n+  }\n+\n+  static class ConditionalUpsertUpdateProcessor extends UpdateRequestProcessor {\n+    private final SolrCore core;\n+\n+    private DistributedUpdateProcessor distribProc;  // the distributed update processor following us\n+    private DistributedUpdateProcessor.DistribPhase phase;\n+    private final List<UpsertCondition> conditions;\n+\n+    ConditionalUpsertUpdateProcessor(SolrQueryRequest req,\n+                                     UpdateRequestProcessor next,\n+                                     List<UpsertCondition> conditions) {\n+      super(next);\n+      this.core = req.getCore();\n+      this.conditions = conditions;\n+\n+      for (UpdateRequestProcessor proc = next ;proc != null; proc = proc.next) {\n+        if (proc instanceof DistributedUpdateProcessor) {\n+          distribProc = (DistributedUpdateProcessor)proc;\n+          break;\n+        }\n+      }\n+\n+      if (distribProc == null) {\n+        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"DistributedUpdateProcessor must follow DocComplianceUpdateProcessor\");\n+      }\n+\n+      phase = DistributedUpdateProcessor.DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n+    }\n+\n+    boolean isLeader(UpdateCommand cmd) {\n+      if ((cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n+        return false;\n+      }\n+      if (phase == DistributedUpdateProcessor.DistribPhase.FROMLEADER) {\n+        return false;\n+      }\n+      return distribProc.isLeader(cmd);\n+    }\n+\n+    @Override\n+    public void processAdd(AddUpdateCommand cmd) throws IOException {\n+      if (!conditions.isEmpty() && isLeader(cmd)) {\n+        BytesRef indexedDocId = cmd.getIndexedId();\n+        SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(core, indexedDocId);\n+        SolrInputDocument newDoc = cmd.getSolrInputDocument();\n+        if (!UpsertCondition.shouldInsertOrUpsert(conditions, oldDoc, newDoc)) {\n+          return;\n+        }\n+      }\n+      super.processAdd(cmd);\n+    }\n+  }\n+}"
  },
  {
    "sha": "c08e29338073499ca6e5c767580252b0c0dc594d",
    "filename": "solr/core/src/java/org/apache/solr/update/processor/UpsertCondition.java",
    "status": "added",
    "additions": 276,
    "deletions": 0,
    "changes": 276,
    "blob_url": "https://github.com/BrandwatchLtd/bw-lucene-solr/blob/625de8e9c86324a40f9840252ce6533007be0a4e/solr/core/src/java/org/apache/solr/update/processor/UpsertCondition.java",
    "raw_url": "https://github.com/BrandwatchLtd/bw-lucene-solr/raw/625de8e9c86324a40f9840252ce6533007be0a4e/solr/core/src/java/org/apache/solr/update/processor/UpsertCondition.java",
    "contents_url": "https://api.github.com/repos/BrandwatchLtd/bw-lucene-solr/contents/solr/core/src/java/org/apache/solr/update/processor/UpsertCondition.java?ref=625de8e9c86324a40f9840252ce6533007be0a4e",
    "patch": "@@ -0,0 +1,276 @@\n+package org.apache.solr.update.processor;\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.SolrInputField;\n+import org.apache.solr.common.util.NamedList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.SolrException.ErrorCode.SERVER_ERROR;\n+\n+class UpsertCondition {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  private static final Pattern ACTION_PATTERN = Pattern.compile(\"^(skip|insert)|upsert:(\\\\*|[\\\\w,]+)$\");\n+  private static final List<String> ALL_FIELDS = Collections.singletonList(\"*\");\n+\n+  private final String name;\n+  private final List<FieldRule> rules;\n+  private final Action action;\n+  private final List<String> upsertFields;\n+\n+  UpsertCondition(String name, Action action, List<String> upsertFields, List<FieldRule> rules) {\n+    this.name = name;\n+    this.action = action;\n+    this.upsertFields = upsertFields;\n+    this.rules = rules;\n+  }\n+\n+  static List<UpsertCondition> readConditions(NamedList args) {\n+    List<UpsertCondition> conditions = new ArrayList<>(args.size());\n+    for (Map.Entry<String, ?> entry: (NamedList<?>)args) {\n+      String name = entry.getKey();\n+      Object tmp = entry.getValue();\n+      if (tmp instanceof NamedList) {\n+        NamedList<String> condition = (NamedList<String>)tmp;\n+        conditions.add(UpsertCondition.parse(name, condition));\n+      } else {\n+        throw new SolrException(SERVER_ERROR, tmp + \" not a valid upsert condition\");\n+      }\n+    }\n+    return conditions;\n+  }\n+\n+  static boolean shouldInsertOrUpsert(List<UpsertCondition> conditions, SolrInputDocument oldDoc, SolrInputDocument newDoc) {\n+    for (UpsertCondition condition: conditions) {\n+      if (condition.matches(oldDoc, newDoc)) {\n+        log.info(\"Condition {} matched, taking action\", condition.getName());\n+        if (condition.isSkip()) {\n+          log.info(\"Condition {} matched - skipping insert\", condition.getName());\n+          return false;\n+        }\n+        if (condition.isInsert()) {\n+          log.info(\"Condition {} matched - will insert\", condition.getName());\n+          break;\n+        }\n+\n+        condition.copyOldDocFields(oldDoc, newDoc);\n+        break;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  static UpsertCondition parse(String name, NamedList<String> args) {\n+    List<FieldRule> rules = new ArrayList<>();\n+    Action action = null;\n+    List<String> upsertFields = null;\n+    for (Map.Entry<String, String> entry: args) {\n+      String key = entry.getKey();\n+      if (\"action\".equals(key)) {\n+        String actionValue = entry.getValue();\n+        Matcher m = ACTION_PATTERN.matcher(actionValue);\n+        if (!m.matches()) {\n+          throw new SolrException(SERVER_ERROR, \"'\" + actionValue + \"' not a valid action\");\n+        }\n+        if (m.group(1) != null) {\n+          if (\"skip\".equals(m.group(1))) {\n+            action = Action.SKIP;\n+          } else {\n+            action = Action.INSERT;\n+          }\n+          upsertFields = null;\n+        } else {\n+          action = Action.UPSERT;\n+          String fields = m.group(2);\n+          upsertFields = Arrays.asList(fields.split(\",\"));\n+        }\n+      } else {\n+        BooleanClause.Occur occur;\n+        try {\n+          occur = BooleanClause.Occur.valueOf(key.toUpperCase(Locale.ROOT));\n+        } catch(IllegalArgumentException e) {\n+          throw new SolrException(SERVER_ERROR, \"'\" + key + \"' not a valid occurence value\");\n+        }\n+        String value = entry.getValue();\n+        rules.add(FieldRule.parse(occur, value));\n+      }\n+    }\n+    if (action == null) {\n+      throw new SolrException(SERVER_ERROR, \"no action defined for condition: \" + name);\n+    }\n+    if (rules.isEmpty()) {\n+      throw new SolrException(SERVER_ERROR, \"no rules specified for condition: \" + name);\n+    }\n+    return new UpsertCondition(name, action, upsertFields, rules);\n+  }\n+\n+  String getName() {\n+    return name;\n+  }\n+\n+  boolean isSkip() {\n+    return action == Action.SKIP;\n+  }\n+\n+  boolean isInsert() {\n+    return action == Action.INSERT;\n+  }\n+\n+  void copyOldDocFields(SolrInputDocument oldDoc, SolrInputDocument newDoc) {\n+    if (action != Action.UPSERT) {\n+      throw new IllegalStateException(\"Can only copy old doc fields when upserting\");\n+    }\n+    Collection<String> fieldsToCopy;\n+    if (ALL_FIELDS.equals(upsertFields)) {\n+      fieldsToCopy = oldDoc.keySet();\n+    } else {\n+      fieldsToCopy = upsertFields;\n+    }\n+    fieldsToCopy.forEach(field -> {\n+      if (!newDoc.containsKey(field)) {\n+        SolrInputField inputField = oldDoc.getField(field);\n+        newDoc.put(field, inputField);\n+      }\n+    });\n+  }\n+\n+  boolean matches(SolrInputDocument oldDoc, SolrInputDocument newDoc) {\n+    Docs docs = new Docs(oldDoc, newDoc);\n+    boolean atLeastOneMatched = false;\n+    for (FieldRule rule: rules) {\n+      boolean ruleMatched = rule.matches(docs);\n+      switch(rule.getOccur()) {\n+        case MUST:\n+          if (!ruleMatched) {\n+            return false;\n+          }\n+          atLeastOneMatched = true;\n+          break;\n+        case MUST_NOT:\n+          if (ruleMatched) {\n+            return false;\n+          }\n+          atLeastOneMatched = true;\n+          break;\n+        default:\n+          atLeastOneMatched = ruleMatched || atLeastOneMatched;\n+          break;\n+      }\n+    }\n+    return atLeastOneMatched;\n+  }\n+\n+  enum Action {\n+    UPSERT,\n+    INSERT,\n+    SKIP;\n+  }\n+\n+  private static class Docs {\n+    private final SolrInputDocument oldDoc;\n+    private final SolrInputDocument newDoc;\n+\n+    Docs(SolrInputDocument oldDoc, SolrInputDocument newDoc) {\n+      this.oldDoc = oldDoc;\n+      this.newDoc = newDoc;\n+    }\n+\n+    SolrInputDocument getOldDoc() {\n+      return oldDoc;\n+    }\n+\n+    SolrInputDocument getNewDoc() {\n+      return newDoc;\n+    }\n+  }\n+\n+  private static class FieldRule {\n+    private static final Pattern RULE_CONDITION_PATTERN = Pattern.compile(\"^(OLD|NEW)\\\\.(\\\\*|\\\\w+:(?:\\\\w+|\\\\*))$\");\n+\n+    private final BooleanClause.Occur occur;\n+    private final Function<Docs, SolrInputDocument> docGetter;\n+    private final Predicate<SolrInputDocument> docPredicate;\n+\n+    private FieldRule(BooleanClause.Occur occur, Function<Docs, SolrInputDocument> docGetter, Predicate<SolrInputDocument> docPredicate) {\n+      this.occur = occur;\n+      this.docGetter = docGetter;\n+      this.docPredicate = docPredicate;\n+    }\n+\n+    static FieldRule parse(BooleanClause.Occur occur, String condition) {\n+      Matcher m = RULE_CONDITION_PATTERN.matcher(condition);\n+      if (m.matches()) {\n+        String doc = m.group(1);\n+        String predicate = m.group(2);\n+        Function<Docs, SolrInputDocument> docGetter;\n+        if (doc.equalsIgnoreCase(\"OLD\")) {\n+          docGetter = Docs::getOldDoc;\n+        } else {\n+          docGetter = Docs::getNewDoc;\n+        }\n+\n+        Predicate<SolrInputDocument> docPredicate;\n+        if (\"*\".equals(predicate)) {\n+          docPredicate = Objects::nonNull;\n+        } else {\n+          String[] parts = predicate.split(\":\");\n+          String field = parts[0];\n+          String value = parts[1];\n+          if (\"*\".equals(value)) {\n+            docPredicate = forField(field, Objects::nonNull);\n+          } else {\n+            docPredicate = forField(field, value::equals);\n+          }\n+        }\n+        return new FieldRule(occur, docGetter, docPredicate);\n+      }\n+      throw new SolrException(SERVER_ERROR, \"'\" + condition + \"' not a valid condition for rule\");\n+    }\n+\n+    BooleanClause.Occur getOccur() {\n+      return occur;\n+    }\n+\n+    boolean matches(Docs docs) {\n+      SolrInputDocument doc = docGetter.apply(docs);\n+      return docPredicate.test(doc);\n+    }\n+\n+    private static Predicate<SolrInputDocument> forField(String field, Predicate<Object> fieldPredicate) {\n+      return doc -> doc != null && fieldPredicate.test(doc.getFieldValue(field));\n+    }\n+  }\n+}"
  },
  {
    "sha": "652e279e85157922f2daa8645b2c2e283d3a2f0a",
    "filename": "solr/core/src/test/org/apache/solr/update/processor/UpsertConditionTest.java",
    "status": "added",
    "additions": 617,
    "deletions": 0,
    "changes": 617,
    "blob_url": "https://github.com/BrandwatchLtd/bw-lucene-solr/blob/625de8e9c86324a40f9840252ce6533007be0a4e/solr/core/src/test/org/apache/solr/update/processor/UpsertConditionTest.java",
    "raw_url": "https://github.com/BrandwatchLtd/bw-lucene-solr/raw/625de8e9c86324a40f9840252ce6533007be0a4e/solr/core/src/test/org/apache/solr/update/processor/UpsertConditionTest.java",
    "contents_url": "https://api.github.com/repos/BrandwatchLtd/bw-lucene-solr/contents/solr/core/src/test/org/apache/solr/update/processor/UpsertConditionTest.java?ref=625de8e9c86324a40f9840252ce6533007be0a4e",
    "patch": "@@ -0,0 +1,617 @@\n+package org.apache.solr.update.processor;\n+\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableListMultimap;\n+import com.google.common.collect.ListMultimap;\n+import java.util.List;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.NamedList;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+public class UpsertConditionTest {\n+\n+  @Test(expected = SolrException.class)\n+  public void givenNoAction_whenParsingCondition() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\"must\", \"OLD.field:value\"));\n+    UpsertCondition.parse(\"no-action\", args);\n+  }\n+\n+  @Test(expected = SolrException.class)\n+  public void givenInvalidMatchOccurrence_whenParsingCondition() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"maybe_might\", \"OLD.field:value\",\n+        \"action\", \"skip\"\n+    ));\n+    UpsertCondition.parse(\"bad-occurrence\", args);\n+  }\n+\n+  @Test(expected = SolrException.class)\n+  public void givenNoRules_whenParsingCondition() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\"action\", \"skip\"));\n+    UpsertCondition.parse(\"no-rules\", args);\n+  }\n+\n+  @Test(expected = SolrException.class)\n+  public void givenBadRuleDocPart_whenParsingCondition() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"must\", \"YOUNG.field:value\",\n+        \"action\", \"skip\"\n+    ));\n+    UpsertCondition.parse(\"bad-rule\", args);\n+  }\n+\n+  @Test(expected = SolrException.class)\n+  public void givenNoDocPart_whenParsingCondition() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"must\", \"field:value\",\n+        \"action\", \"skip\"\n+    ));\n+    UpsertCondition.parse(\"bad-rule\", args);\n+  }\n+\n+  @Test(expected = SolrException.class)\n+  public void givenNoValuePart_whenParsingCondition() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"must\", \"OLD.field\",\n+        \"action\", \"skip\"\n+    ));\n+    UpsertCondition.parse(\"bad-rule\", args);\n+  }\n+\n+  @Test(expected = SolrException.class)\n+  public void givenBadAction_whenParsingCondition() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"must\", \"OLD.field:value\",\n+        \"action\", \"skippy\"\n+    ));\n+    UpsertCondition.parse(\"bad-action\", args);\n+  }\n+\n+  @Test\n+  public void givenNoOldDoc_whenMatching() {\n+    NamedList<String> args = new NamedList<>(ImmutableMap.of(\n+        \"must\", \"OLD.field:value\",\n+        \"action\", \"skip\"\n+    ));\n+\n+    UpsertCondition condition = UpsertCondition.parse(\"skip-it\", args);\n+\n+    assertThat(condition.isSkip(), is(true));\n+    assertThat(condition.isInsert(), is(false));\n+    assertThat(condition.getName(), is(\"skip-it\"));\n+\n+    SolrInputDocument oldDoc = null;\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+  }\n+\n+  @Test\n+  public void givenSingleMustClause_whenMatching() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"must\", \"OLD.field:value\",\n+        \"action\", \"skip\"\n+    ));\n+\n+    UpsertCondition condition = UpsertCondition.parse(\"skip-it\", args);\n+\n+    assertThat(condition.isSkip(), is(true));\n+    assertThat(condition.isInsert(), is(false));\n+    assertThat(condition.getName(), is(\"skip-it\"));\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field\", \"value\");\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field\", \"not-value\");\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+  }\n+\n+  @Test\n+  public void givenSingleShouldClause_whenMatching() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"should\", \"OLD.field:value\",\n+        \"action\", \"skip\"\n+    ));\n+\n+    UpsertCondition condition = UpsertCondition.parse(\"skip-it\", args);\n+\n+    assertThat(condition.isSkip(), is(true));\n+    assertThat(condition.isInsert(), is(false));\n+    assertThat(condition.getName(), is(\"skip-it\"));\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field\", \"value\");\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field\", \"not-value\");\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+  }\n+\n+  @Test\n+  public void givenSingleMustNotClause_whenMatching() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"must_not\", \"OLD.field:value\",\n+        \"action\", \"skip\"\n+    ));\n+\n+    UpsertCondition condition = UpsertCondition.parse(\"skip-it\", args);\n+\n+    assertThat(condition.isSkip(), is(true));\n+    assertThat(condition.isInsert(), is(false));\n+    assertThat(condition.getName(), is(\"skip-it\"));\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field\", \"value\");\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field\", \"not-value\");\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+  }\n+\n+  @Test\n+  public void givenSingleShouldAnyValueClause_whenMatching() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"should\", \"OLD.field:*\",\n+        \"action\", \"skip\"\n+    ));\n+\n+    UpsertCondition condition = UpsertCondition.parse(\"skip-it\", args);\n+\n+    assertThat(condition.isSkip(), is(true));\n+    assertThat(condition.isInsert(), is(false));\n+    assertThat(condition.getName(), is(\"skip-it\"));\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field\", \"value\");\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field\", \"not-value\");\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+  }\n+\n+  @Test\n+  public void givenSingleShouldDocExistsClause_whenMatching() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"should\", \"OLD.*\",\n+        \"action\", \"skip\"\n+    ));\n+\n+    UpsertCondition condition = UpsertCondition.parse(\"skip-it\", args);\n+\n+    assertThat(condition.isSkip(), is(true));\n+    assertThat(condition.isInsert(), is(false));\n+    assertThat(condition.getName(), is(\"skip-it\"));\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    assertFalse(condition.matches(null, newDoc));\n+\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field\", \"value\");\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+  }\n+\n+  @Test\n+  public void givenMultipleMustClauses_whenMatching() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"must\", \"OLD.field1:value1\",\n+        \"must\", \"NEW.field2:value2\",\n+        \"action\", \"skip\"\n+    ));\n+\n+    UpsertCondition condition = UpsertCondition.parse(\"skip-it\", args);\n+\n+    assertThat(condition.isSkip(), is(true));\n+    assertThat(condition.isInsert(), is(false));\n+    assertThat(condition.getName(), is(\"skip-it\"));\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field1\", \"value1\");\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field1\", \"value1\");\n+    newDoc.setField(\"field2\", \"value2\");\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field1\", \"not-value1\");\n+    newDoc.setField(\"field2\", \"value2\");\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.removeField(\"field1\");\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+  }\n+\n+  @Test\n+  public void givenMultipleShouldClauses_whenMatching() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"should\", \"OLD.field1:value1\",\n+        \"should\", \"NEW.field2:value2\",\n+        \"action\", \"skip\"\n+    ));\n+\n+    UpsertCondition condition = UpsertCondition.parse(\"skip-it\", args);\n+\n+    assertThat(condition.isSkip(), is(true));\n+    assertThat(condition.isInsert(), is(false));\n+    assertThat(condition.getName(), is(\"skip-it\"));\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field1\", \"value1\");\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field1\", \"value1\");\n+    newDoc.setField(\"field2\", \"value2\");\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field1\", \"not-value1\");\n+    newDoc.setField(\"field2\", \"value2\");\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.removeField(\"field1\");\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+\n+    newDoc.setField(\"field2\", \"not-value2\");\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+  }\n+\n+  @Test\n+  public void givenMustAndMustNotClauses_whenMatching() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"must\", \"OLD.field1:value1\",\n+        \"must_not\", \"NEW.field2:value2\",\n+        \"action\", \"skip\"\n+    ));\n+\n+    UpsertCondition condition = UpsertCondition.parse(\"skip-it\", args);\n+\n+    assertThat(condition.isSkip(), is(true));\n+    assertThat(condition.isInsert(), is(false));\n+    assertThat(condition.getName(), is(\"skip-it\"));\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field1\", \"value1\");\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field1\", \"value1\");\n+    newDoc.setField(\"field2\", \"value2\");\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field1\", \"not-value1\");\n+    newDoc.setField(\"field2\", \"value2\");\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field1\", \"value1\");\n+    newDoc.setField(\"field2\", \"not-value2\");\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+  }\n+\n+  @Test(expected = IllegalStateException.class)\n+  public void givenSkipAction_whenCopyingOldFields() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"should\", \"OLD.field:value\",\n+        \"action\", \"skip\"\n+    ));\n+\n+    UpsertCondition condition = UpsertCondition.parse(\"skip-it\", args);\n+\n+    assertThat(condition.isSkip(), is(true));\n+    assertThat(condition.isInsert(), is(false));\n+    assertThat(condition.getName(), is(\"skip-it\"));\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    condition.copyOldDocFields(oldDoc, newDoc);\n+  }\n+\n+  @Test(expected = IllegalStateException.class)\n+  public void givenInsertAction_whenCopyingOldFields() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"should\", \"OLD.field:value\",\n+        \"action\", \"insert\"\n+    ));\n+\n+    UpsertCondition condition = UpsertCondition.parse(\"insert-it\", args);\n+\n+    assertThat(condition.isSkip(), is(false));\n+    assertThat(condition.isInsert(), is(true));\n+    assertThat(condition.getName(), is(\"insert-it\"));\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    condition.copyOldDocFields(oldDoc, newDoc);\n+  }\n+\n+  @Test\n+  public void givenInsert_whenMatching() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"must\", \"OLD.field:value\",\n+        \"action\", \"insert\"\n+    ));\n+\n+    UpsertCondition condition = UpsertCondition.parse(\"insert-it\", args);\n+\n+    assertThat(condition.isSkip(), is(false));\n+    assertThat(condition.isInsert(), is(true));\n+    assertThat(condition.getName(), is(\"insert-it\"));\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field\", \"value\");\n+    assertTrue(condition.matches(oldDoc, newDoc));\n+\n+    oldDoc.setField(\"field\", \"not-value\");\n+    assertFalse(condition.matches(oldDoc, newDoc));\n+  }\n+\n+  @Test\n+  public void givenUpsertForSpecificFields_whenCopyingOldFields() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"must\", \"OLD.field:value\",\n+        \"action\", \"upsert:field,other_field\"\n+    ));\n+\n+    UpsertCondition condition = UpsertCondition.parse(\"upsert\", args);\n+\n+    assertThat(condition.isSkip(), is(false));\n+    assertThat(condition.isInsert(), is(false));\n+    assertThat(condition.getName(), is(\"upsert\"));\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+    oldDoc.setField(\"field\", \"value\");\n+    oldDoc.setField(\"other_field\", \"old-value\");\n+    oldDoc.setField(\"not-copied\", \"not-copied\");\n+\n+    condition.copyOldDocFields(oldDoc, newDoc);\n+\n+    assertThat(newDoc.getFieldValue(\"field\"), is(\"value\"));\n+    assertThat(newDoc.getFieldValue(\"other_field\"), is(\"old-value\"));\n+    assertFalse(newDoc.containsKey(\"not-copied\"));\n+\n+    newDoc = new SolrInputDocument();\n+    newDoc.setField(\"field\", \"left-alone\");\n+\n+    condition.copyOldDocFields(oldDoc, newDoc);\n+\n+    assertThat(newDoc.getFieldValue(\"field\"), is(\"left-alone\"));\n+    assertThat(newDoc.getFieldValue(\"other_field\"), is(\"old-value\"));\n+    assertFalse(newDoc.containsKey(\"not-copied\"));\n+  }\n+\n+  @Test\n+  public void givenUpsertForAllFields_whenCopyingOldFields() {\n+    NamedList<String> args = namedList(ImmutableListMultimap.of(\n+        \"must\", \"OLD.field:value\",\n+        \"action\", \"upsert:*\"\n+    ));\n+\n+    UpsertCondition condition = UpsertCondition.parse(\"upsert\", args);\n+\n+    assertThat(condition.isSkip(), is(false));\n+    assertThat(condition.isInsert(), is(false));\n+    assertThat(condition.getName(), is(\"upsert\"));\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+    oldDoc.setField(\"field\", \"value\");\n+    oldDoc.setField(\"other_field\", \"old-value\");\n+    oldDoc.setField(\"also-copied\", \"also-copied\");\n+\n+    condition.copyOldDocFields(oldDoc, newDoc);\n+\n+    assertThat(newDoc.getFieldValue(\"field\"), is(\"value\"));\n+    assertThat(newDoc.getFieldValue(\"other_field\"), is(\"old-value\"));\n+    assertThat(newDoc.getFieldValue(\"also-copied\"), is(\"also-copied\"));\n+\n+    newDoc = new SolrInputDocument();\n+    newDoc.setField(\"field\", \"left-alone\");\n+\n+    condition.copyOldDocFields(oldDoc, newDoc);\n+\n+    assertThat(newDoc.getFieldValue(\"field\"), is(\"left-alone\"));\n+    assertThat(newDoc.getFieldValue(\"other_field\"), is(\"old-value\"));\n+    assertThat(newDoc.getFieldValue(\"also-copied\"), is(\"also-copied\"));\n+  }\n+\n+  @Test\n+  public void givenExistingPermanentDelete_whenCheckingShouldInsertOrUpsert() {\n+    List<UpsertCondition> conditions = givenMultipleConditions();\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    oldDoc.setField(\"compliance_reason\", \"delete\");\n+\n+    assertThat(UpsertCondition.shouldInsertOrUpsert(conditions, oldDoc, newDoc), is(false));\n+  }\n+\n+  @Test\n+  public void givenExistingSoftDelete_whenCheckingShouldInsertOrUpsert() {\n+    List<UpsertCondition> conditions = givenMultipleConditions();\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    oldDoc.setField(\"compliance_reason\", \"soft_delete\");\n+    oldDoc.setField(\"old_field\", \"not-kept-from-old\");\n+    newDoc.setField(\"new_field\", \"kept-from-new\");\n+\n+    assertThat(UpsertCondition.shouldInsertOrUpsert(conditions, oldDoc, newDoc), is(true));\n+    assertThat(newDoc.getFieldValue(\"new_field\"), is(\"kept-from-new\"));\n+    assertThat(newDoc.getFieldValue(\"compliance_reason\"), is(\"soft_delete\"));\n+    assertThat(newDoc.getFieldValue(\"old_field\"), nullValue());\n+  }\n+\n+  @Test\n+  public void givenNewSoftDelete_whenCheckingShouldInsertOrUpsert() {\n+    List<UpsertCondition> conditions = givenMultipleConditions();\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    oldDoc.setField(\"old_field1\", \"kept-from-old1\");\n+    oldDoc.setField(\"old_field2\", \"kept-from-old2\");\n+    newDoc.setField(\"compliance_reason\", \"soft_delete\");\n+\n+    assertThat(UpsertCondition.shouldInsertOrUpsert(conditions, oldDoc, newDoc), is(true));\n+    assertThat(newDoc.getFieldValue(\"old_field1\"), is(\"kept-from-old1\"));\n+    assertThat(newDoc.getFieldValue(\"old_field2\"), is(\"kept-from-old2\"));\n+    assertThat(newDoc.getFieldValue(\"compliance_reason\"), is(\"soft_delete\"));\n+  }\n+\n+  @Test\n+  public void givenExistingMetrics_whenCheckingShouldInsertOrUpsert() {\n+    List<UpsertCondition> conditions = givenMultipleConditions();\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    oldDoc.setField(\"metric1\", \"kept-from-old1\");\n+    oldDoc.setField(\"metric2\", \"kept-from-old2\");\n+    oldDoc.setField(\"metric3\", \"not-kept-from-old\");\n+\n+    assertThat(UpsertCondition.shouldInsertOrUpsert(conditions, oldDoc, newDoc), is(true));\n+    assertThat(newDoc.getFieldValue(\"metric1\"), is(\"kept-from-old1\"));\n+    assertThat(newDoc.getFieldValue(\"metric2\"), is(\"kept-from-old2\"));\n+    assertThat(newDoc.getFieldValue(\"metric3\"), nullValue());\n+  }\n+\n+  @Test\n+  public void givenForceInsert_whenCheckingShouldInsertOrUpsert() {\n+    List<UpsertCondition> conditions = givenMultipleConditions();\n+\n+    SolrInputDocument oldDoc = new SolrInputDocument();\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    oldDoc.setField(\"compliance_reason\", \"delete\");\n+    newDoc.setField(\"force_insert\", \"true\");\n+\n+    assertThat(UpsertCondition.shouldInsertOrUpsert(conditions, oldDoc, newDoc), is(true));\n+    assertThat(newDoc.getFieldValue(\"force_insert\"), is(\"true\"));\n+    assertThat(newDoc.getFieldValue(\"compliance_reason\"), nullValue());\n+  }\n+\n+  @Test\n+  public void givenSkipIfNotExists_whenCheckingShouldInsertOrUpsert() {\n+    List<UpsertCondition> conditions = givenMultipleConditions();\n+\n+    SolrInputDocument newDoc = new SolrInputDocument();\n+\n+    assertThat(UpsertCondition.shouldInsertOrUpsert(conditions, null, newDoc), is(false));\n+    assertThat(newDoc.isEmpty(), is(true));\n+\n+    newDoc.setField(\"date\", \"today\");\n+\n+    assertThat(UpsertCondition.shouldInsertOrUpsert(conditions, null, newDoc), is(true));\n+    assertThat(newDoc.getFieldValue(\"date\"), is(\"today\"));\n+  }\n+\n+  @Test(expected = SolrException.class)\n+  public void givenInvalidConfig_whenReadingConditions() {\n+    NamedList<Object> args = new NamedList<>();\n+    args.add(\"something\", \"else\");\n+\n+    UpsertCondition.readConditions(args);\n+  }\n+\n+  private List<UpsertCondition> givenMultipleConditions() {\n+    NamedList<?> args = namedList(ImmutableListMultimap.<String, NamedList<String>>builder()\n+        .put(\"forceInsert\", namedList(ImmutableListMultimap.of(\n+            \"must\", \"NEW.force_insert:true\",\n+            \"action\", \"insert\"\n+        )))\n+        .put(\"existingPermanentDeletes\", namedList(ImmutableListMultimap.of(\n+            \"must\", \"OLD.compliance_reason:delete\",\n+            \"action\", \"skip\"\n+        )))\n+        .put(\"existingSoftDeletes\", namedList(ImmutableListMultimap.of(\n+            \"must\", \"OLD.compliance_reason:soft_delete\",\n+            \"action\", \"upsert:compliance_reason\"\n+        )))\n+        .put(\"newSoftDeletes\", namedList(ImmutableListMultimap.of(\n+            \"must\", \"NEW.compliance_reason:soft_delete\",\n+            \"action\", \"upsert:*\"\n+        )))\n+        .put(\"existingMetrics\", namedList(ImmutableListMultimap.of(\n+            \"should\", \"OLD.metric1:*\",\n+            \"should\", \"OLD.metric2:*\",\n+            \"action\", \"upsert:metric1,metric2\"\n+        )))\n+        .put(\"skipIfNotExists\", namedList(ImmutableListMultimap.of(\n+            \"must_not\", \"OLD.*\",\n+            \"must_not\", \"NEW.date:*\",\n+            \"action\", \"skip\"\n+        )))\n+        .build()\n+    );\n+\n+    return UpsertCondition.readConditions(args);\n+  }\n+\n+  private<T> NamedList<T> namedList(ListMultimap<String, T> values) {\n+    return new NamedList<>(values.entries().toArray(new Map.Entry[0]));\n+  }\n+}"
  }
]
