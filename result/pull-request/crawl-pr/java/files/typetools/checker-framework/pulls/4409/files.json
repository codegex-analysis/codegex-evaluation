[
  {
    "sha": "fe576104fb1dbcaceb8d4d1940ad7cc6f1c31d82",
    "filename": "checker-util/src/main/java/org/checkerframework/checker/regex/util/RegexUtil.java",
    "status": "modified",
    "additions": 225,
    "deletions": 1,
    "changes": 226,
    "blob_url": "https://github.com/typetools/checker-framework/blob/177d4091d25b103f8370983a0187ac9abbb59814/checker-util/src/main/java/org/checkerframework/checker/regex/util/RegexUtil.java",
    "raw_url": "https://github.com/typetools/checker-framework/raw/177d4091d25b103f8370983a0187ac9abbb59814/checker-util/src/main/java/org/checkerframework/checker/regex/util/RegexUtil.java",
    "contents_url": "https://api.github.com/repos/typetools/checker-framework/contents/checker-util/src/main/java/org/checkerframework/checker/regex/util/RegexUtil.java?ref=177d4091d25b103f8370983a0187ac9abbb59814",
    "patch": "@@ -3,6 +3,9 @@\n \n package org.checkerframework.checker.regex.util;\n \n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.regex.Pattern;\n import java.util.regex.PatternSyntaxException;\n import org.checkerframework.checker.index.qual.GTENegativeOne;\n@@ -170,6 +173,30 @@ public static boolean isRegex(String s, int groups) {\n         return getGroupCount(p) >= groups;\n     }\n \n+    /**\n+     * Returns true if the argument is a syntactically valid regular expression with at least {@code\n+     * groups} groups, and the specified groups are non-null if the regex matches.\n+     *\n+     * @param s string to check for being a regular expression\n+     * @param groups minimum number of groups\n+     * @param nonNullGroups groups that are non-null if the regex matches\n+     * @return true iff s is a regular expression with at least {@code groups} groups, and at least\n+     *     the groups in {@code nonNullGroups} are non-null when the regex matches\n+     */\n+    @Pure\n+    @EnsuresQualifierIf(result = true, expression = \"#1\", qualifier = Regex.class)\n+    public static boolean isRegex(String s, int groups, int... nonNullGroups) {\n+        Pattern p;\n+        try {\n+            p = Pattern.compile(s);\n+        } catch (PatternSyntaxException e) {\n+            return false;\n+        }\n+        List<Integer> computedNonNullGroups = getNonNullGroups(p.pattern(), getGroupCount(p));\n+        return groups <= getGroupCount(p)\n+                && computedNonNullGroups.containsAll(Arrays.asList(nonNullGroups));\n+    }\n+\n     /**\n      * Returns true if the argument is a syntactically valid regular expression.\n      *\n@@ -269,6 +296,8 @@ public static boolean isRegex(final char c) {\n      * @throws Error if argument is not a regex\n      */\n     @SideEffectFree\n+    // The return type annotation is irrelevant; it is special-cased by\n+    // RegexAnnotatedTypeFactory.\n     // The return type annotation is a conservative bound.\n     public static @Regex String asRegex(String s) {\n         return asRegex(s, 0);\n@@ -284,7 +313,7 @@ public static boolean isRegex(final char c) {\n      * @param s string to check for being a regular expression\n      * @param groups number of groups expected\n      * @return its argument\n-     * @throws Error if argument is not a regex\n+     * @throws Error if argument is not a regex with at least the given number of groups\n      */\n     @SuppressWarnings(\"regex\") // RegexUtil\n     @SideEffectFree\n@@ -303,6 +332,44 @@ public static boolean isRegex(final char c) {\n         }\n     }\n \n+    /**\n+     * Returns the argument as a {@code @Regex(groups) String} if it is a regex with at least the\n+     * given number of groups and the groups in {@code nonNullGroups} are guaranteed to match\n+     * provided that the regex matches a string. Otherwise, throws an error.\n+     *\n+     * <p>The purpose of this method is to suppress Regex Checker warnings. It should be rarely\n+     * needed.\n+     *\n+     * @param s string to check for being a regular expression\n+     * @param groups number of groups expected\n+     * @param nonNullGroups groups expected to be match some (possibly empty) part of a target\n+     *     string when the regex matches\n+     * @return its argument\n+     * @throws Error if argument is not a regex with the specified characteristics\n+     */\n+    @SuppressWarnings(\"regex\")\n+    @SideEffectFree\n+    // The return type annotation is irrelevant; this method is special-cased by\n+    // RegexAnnotatedTypeFactory.\n+    public static @Regex String asRegex(String s, int groups, int... nonNullGroups) {\n+        try {\n+            List<Integer> actualNonNullGroups = getNonNullGroups(s, groups);\n+            int failingGroup = -1;\n+            for (int e : nonNullGroups) {\n+                if (!actualNonNullGroups.contains(e)) {\n+                    failingGroup = e;\n+                    break;\n+                }\n+            }\n+            if (failingGroup != -1) {\n+                throw new Error(regexNNGroupsErrorMessage(s, failingGroup));\n+            }\n+            return s;\n+        } catch (PatternSyntaxException e) {\n+            throw new Error(e);\n+        }\n+    }\n+\n     /**\n      * Generates an error message for s when expectedGroups are needed, but s only has actualGroups.\n      *\n@@ -323,6 +390,24 @@ private static String regexErrorMessage(String s, int expectedGroups, int actual\n                 + \" groups are needed.\";\n     }\n \n+    /**\n+     * Generates an error message for s when nullableGroup is expected to be definitely non-null but\n+     * turns out to be nullable.\n+     *\n+     * @param s string to check for being a regular expression\n+     * @param nullableGroup group expected to be non-null\n+     * @return an error message for s when nullableGroup is expected to be definitely non-null but\n+     *     turns out to be nullable.\n+     */\n+    private static String regexNNGroupsErrorMessage(String s, int nullableGroup) {\n+        return \"for regex \\\"\"\n+                + s\n+                + \"\\\", call to group(\"\n+                + nullableGroup\n+                + \") can return a possibly-null string \"\n+                + \" but is expected to return a non-null string.\";\n+    }\n+\n     /**\n      * Return the count of groups in the argument.\n      *\n@@ -334,4 +419,143 @@ private static String regexErrorMessage(String s, int expectedGroups, int actual\n     private static int getGroupCount(Pattern p) {\n         return p.matcher(\"\").groupCount();\n     }\n+\n+    /**\n+     * Returns a list of groups other than 0, that are guaranteed to be non-null given that the\n+     * regular expression matches the String. The String argument passed has to be a valid regular\n+     * expression.\n+     *\n+     * @param regexp regular expression to be analysed; must be a legal regex\n+     * @param n number of capturing groups in the pattern\n+     * @return a {@code List} of groups that are guaranteed to match some part of a string that\n+     *     matches {@code regexp}\n+     * @throws Error if the argument is not a regex or has less than the specified number of\n+     *     capturing groups\n+     */\n+    public static List<Integer> getNonNullGroups(String regexp, int n) {\n+        try {\n+            Pattern p = Pattern.compile(regexp);\n+            int actualGroups = getGroupCount(p);\n+            if (actualGroups < n) {\n+                throw new Error(regexErrorMessage(regexp, n, actualGroups));\n+            }\n+        } catch (PatternSyntaxException e) {\n+            throw new Error(e);\n+        }\n+        // The list that will hold the groups that are guaranteed to match some part of text that\n+        // matches the regex. Initially holds all the groups. The optional groups will be removed.\n+        List<Integer> nonNullGroups = new ArrayList<>();\n+        for (int i = 1; i <= n; i++) {\n+            nonNullGroups.add(i);\n+        }\n+\n+        // A stack containing indices of the capturing groups that are currently not closed.\n+        ArrayDeque<Integer> unclosedCapturingGroups = new ArrayDeque<>();\n+\n+        // A stack that tracks all open groups (both capturing and non-capturing groups),\n+        // indicating whether the group is capturing or not.\n+        ArrayDeque<Boolean> isCapturingGroup = new ArrayDeque<>();\n+\n+        // Index of the most recently opened capturing group.\n+        int group = 0;\n+\n+        // Optional group here onwards means the ith capturing group, which may not match any part\n+        // of a text that matched the regular expression and thus may return null on calls to\n+        // matcher.group(i).\n+\n+        // If you encounter '(', check the next character. If it is a '?', it is a special\n+        // construct,\n+        // (either pure, non-capturing groups that do not capture text and do not count towards the\n+        // group total, or named-capturing group) and we need to check the next character. If the\n+        // character following the '?' is a '<' the '(' represents the opening of a named-capturing\n+        // group and it will be handled like a normal capturing group. If the '(' was not followed\n+        // by a '?', it is a normal capturing group.\n+        // In case of capturing groups, increment the group variable and push it to the\n+        // unclosedCapturingGroups deque. Push true to the isCapturingGroup deque.\n+        // In case of non-capturing groups, push false to the isCapturingGroup deque.\n+        // We need the boolean deque so that when we encounter a ')', we can know whether it closes\n+        // a capturing group (the top element is true) or a non-capturing group (the top element is\n+        // false). One additional check is required. If '(' represented a capturing a group and was\n+        // preceded by '|', it is an optional group.\n+\n+        // If you encounter ')', check the top of the isCapturingGroup deque. If it was\n+        // false, do nothing otherwise remove the top element from the deque since it is now closed\n+        // and check if it is followed by a '?', '*', '|' or '{0'. If it is, then it is an optional\n+        // group otherwise not. If it is an optional group, remove it from the nonNullGroups list.\n+\n+        // If you encounter '[', traverse the regex till you find the closing '[', you may encounter\n+        // more of '[' in the process, keep a track of the number of character classes that are\n+        // still open. Keep on traversing till the number becomes 0. After this resume normal\n+        // traversal.\n+\n+        // If you encounter '\\', check the next character. If it is not 'Q', skip the next\n+        // character. If it is 'Q', it marks the beginning of a literal quote, find the next\n+        // occurrence of '\\E', which marks the end of quote. Set the loop variable to the index of\n+        // 'E' and resume normal traversal.\n+\n+        final int length = regexp.length();\n+        for (int i = 0; i < length; i++) {\n+            if (regexp.charAt(i) == '(') {\n+                boolean isCapturingGroup = false;\n+                if ((i < length - 1)\n+                        && (regexp.charAt(i + 1) != '?' || regexp.startsWith(\"?<\", i + 1))) {\n+                    group += 1;\n+                    unclosedCapturingGroups.push(group);\n+                    isCapturingGroup = true;\n+                }\n+                isCapturingGroup.push(isCapturingGroup);\n+                if (isCapturingGroup) {\n+                    if (i > 0 && regexp.charAt(i - 1) == '|') {\n+                        nonNullGroups.remove(Integer.valueOf(group));\n+                    }\n+                }\n+            } else if (regexp.charAt(i) == ')') {\n+                boolean closesCapturingGroup = isCapturingGroup.pop();\n+                if (closesCapturingGroup) {\n+                    Integer closedGroupIndex = unclosedCapturingGroups.pop();\n+                    if ((i < length - 1 && \"?*|\".contains(String.valueOf(regexp.charAt(i + 1))))\n+                            || (i < length - 2 && regexp.startsWith(\"{0\", i + 1))) {\n+                        nonNullGroups.remove(closedGroupIndex);\n+                    }\n+                }\n+            } else if (regexp.charAt(i) == '[') {\n+                int balance = 1, j;\n+                // the loop starts from i+2 because the character class cannot be empty. \"[]]\" is a\n+                // valid regex.\n+                for (j = i + 1; j < length && balance > 0; j++) {\n+                    if (regexp.charAt(j) == '[') {\n+                        // Character classes can be nested.\n+                        balance += 1;\n+                    } else if (regexp.charAt(j) == ']') {\n+                        // If the first character in a character class is \"]\", it is treated\n+                        // literally and does not close the character class.\n+                        if (regexp.charAt(j - 1) != '[') {\n+                            balance -= 1;\n+                        }\n+                    } else if (regexp.charAt(j) == '\\\\') {\n+                        j = resumeTraversalFromHere(regexp, j);\n+                    }\n+                }\n+                i = j - 1;\n+            } else if (regexp.charAt(i) == '\\\\') {\n+                i = resumeTraversalFromHere(regexp, i);\n+            }\n+        }\n+        return nonNullGroups;\n+    }\n+\n+    /**\n+     * Returns the index till which the regex can be skipped, when '\\' is encountered.\n+     *\n+     * @param regexp the regular expression to analyse\n+     * @param st the index of the '\\' which causes the skip\n+     * @return the index till which the traversal can be skipped\n+     */\n+    private static int resumeTraversalFromHere(String regexp, int st) {\n+        int length = regexp.length();\n+        if (st < length - 1 && regexp.charAt(st + 1) != 'Q') {\n+            return st + 1;\n+        }\n+        return regexp.indexOf(\"\\\\E\", st) + 1;\n+    }\n }"
  },
  {
    "sha": "1dba86de3f783004fe5b67956a6a16244a6b1af5",
    "filename": "checker-util/src/test/java/org/checkerframework/checker/regex/util/RegexUtilTest.java",
    "status": "modified",
    "additions": 41,
    "deletions": 0,
    "changes": 41,
    "blob_url": "https://github.com/typetools/checker-framework/blob/177d4091d25b103f8370983a0187ac9abbb59814/checker-util/src/test/java/org/checkerframework/checker/regex/util/RegexUtilTest.java",
    "raw_url": "https://github.com/typetools/checker-framework/raw/177d4091d25b103f8370983a0187ac9abbb59814/checker-util/src/test/java/org/checkerframework/checker/regex/util/RegexUtilTest.java",
    "contents_url": "https://api.github.com/repos/typetools/checker-framework/contents/checker-util/src/test/java/org/checkerframework/checker/regex/util/RegexUtilTest.java?ref=177d4091d25b103f8370983a0187ac9abbb59814",
    "patch": "@@ -2,6 +2,8 @@\n \n package org.checkerframework.checker.regex.util;\n \n+import java.util.Arrays;\n+import java.util.Collections;\n import org.junit.Assert;\n import org.junit.Test;\n \n@@ -14,6 +16,7 @@ public void test_isRegex_and_asRegex() {\n         String s2 = \"(brown|beige)\";\n         String s3 = \"colou?r\";\n         String s4 = \"1) first point\";\n+        String s5 = \"(abc)(cde[)])(\\\\Qxyz\\\\E)\";\n \n         Assert.assertTrue(RegexUtil.isRegex(s1));\n         RegexUtil.asRegex(s1);\n@@ -23,6 +26,10 @@ public void test_isRegex_and_asRegex() {\n         RegexUtil.asRegex(s1, 1);\n         Assert.assertFalse(RegexUtil.isRegex(s1, 2));\n         Assert.assertThrows(Error.class, () -> RegexUtil.asRegex(s1, 2));\n+        Assert.assertTrue(RegexUtil.isRegex(s1, 1, 1));\n+        Assert.assertFalse(RegexUtil.isRegex(s1, 1, 1, 2));\n+        Assert.assertFalse(RegexUtil.isRegex(s1, 2, 1));\n+        Assert.assertThrows(Error.class, () -> RegexUtil.asRegex(s1, 2, 1));\n \n         Assert.assertTrue(RegexUtil.isRegex(s2));\n         RegexUtil.asRegex(s2);\n@@ -32,6 +39,10 @@ public void test_isRegex_and_asRegex() {\n         RegexUtil.asRegex(s2, 1);\n         Assert.assertFalse(RegexUtil.isRegex(s2, 2));\n         Assert.assertThrows(Error.class, () -> RegexUtil.asRegex(s2, 2));\n+        Assert.assertTrue(RegexUtil.isRegex(s2, 1, 1));\n+        Assert.assertFalse(RegexUtil.isRegex(s2, 1, 1, 2));\n+        Assert.assertFalse(RegexUtil.isRegex(s2, 2, 1));\n+        Assert.assertThrows(Error.class, () -> RegexUtil.asRegex(s2, 2, 1));\n \n         Assert.assertTrue(RegexUtil.isRegex(s3));\n         RegexUtil.asRegex(s3);\n@@ -41,6 +52,8 @@ public void test_isRegex_and_asRegex() {\n         Assert.assertThrows(Error.class, () -> RegexUtil.asRegex(s3, 1));\n         Assert.assertFalse(RegexUtil.isRegex(s3, 2));\n         Assert.assertThrows(Error.class, () -> RegexUtil.asRegex(s3, 2));\n+        Assert.assertFalse(RegexUtil.isRegex(s3, 0, 1));\n+        Assert.assertThrows(Error.class, () -> RegexUtil.asRegex(s3, 0, 1));\n \n         Assert.assertFalse(RegexUtil.isRegex(s4));\n         Assert.assertThrows(Error.class, () -> RegexUtil.asRegex(s4));\n@@ -50,5 +63,33 @@ public void test_isRegex_and_asRegex() {\n         Assert.assertThrows(Error.class, () -> RegexUtil.asRegex(s4, 1));\n         Assert.assertFalse(RegexUtil.isRegex(s4, 2));\n         Assert.assertThrows(Error.class, () -> RegexUtil.asRegex(s4, 2));\n+        Assert.assertFalse(RegexUtil.isRegex(s4, 1, 1));\n+        Assert.assertThrows(Error.class, () -> RegexUtil.asRegex(s4, 1, 1));\n+\n+        Assert.assertTrue(RegexUtil.isRegex(s5, 3, 1, 2, 3));\n+        Assert.assertTrue(RegexUtil.isRegex(s5, 3, 1, 2));\n+        Assert.assertTrue(RegexUtil.isRegex(s5, 3, 1));\n+        Assert.assertFalse(RegexUtil.isRegex(s5, 4, 1, 2, 3));\n+        Assert.assertThrows(Error.class, () -> RegexUtil.asRegex(s5, 3, 1, 2, 4));\n+        Assert.assertThrows(Error.class, () -> RegexUtil.asRegex(s5, 4, 1, 2, 3));\n+    }\n+\n+    @Test\n+    public void test_getNonNullGroups() {\n+        String s1 = \"\\\\(abc\\\\)?(123)\";\n+        String s2 = \"([(abc)])*(xyz)\\\\?(abc)\";\n+        String s3 = \"(\\\\Q()()\\\\E)\";\n+        String s4 = \"([abc\\\\Qwww\\\\E])(abc)?\";\n+        String s5 = \"[(abc]\";\n+\n+        Assert.assertThrows(Error.class, () -> RegexUtil.getNonNullGroups(s1, 2));\n+        Assert.assertEquals(Collections.singletonList(1), RegexUtil.getNonNullGroups(s1, 1));\n+        Assert.assertThrows(Error.class, () -> RegexUtil.getNonNullGroups(s2, 4));\n+        Assert.assertEquals(Arrays.asList(2, 3), RegexUtil.getNonNullGroups(s2, 3));\n+        Assert.assertThrows(Error.class, () -> RegexUtil.getNonNullGroups(s3, 3));\n+        Assert.assertEquals(Collections.singletonList(1), RegexUtil.getNonNullGroups(s3, 1));\n+        Assert.assertThrows(Error.class, () -> RegexUtil.getNonNullGroups(s4, 3));\n+        Assert.assertEquals(Collections.singletonList(1), RegexUtil.getNonNullGroups(s4, 2));\n+        Assert.assertThrows(Error.class, () -> RegexUtil.getNonNullGroups(s5, 1));\n     }\n }"
  },
  {
    "sha": "ffa6a7e0767b2603747819f2c07e8ad5d2360d1b",
    "filename": "docs/manual/contributors.tex",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/typetools/checker-framework/blob/177d4091d25b103f8370983a0187ac9abbb59814/docs/manual/contributors.tex",
    "raw_url": "https://github.com/typetools/checker-framework/raw/177d4091d25b103f8370983a0187ac9abbb59814/docs/manual/contributors.tex",
    "contents_url": "https://api.github.com/repos/typetools/checker-framework/contents/docs/manual/contributors.tex?ref=177d4091d25b103f8370983a0187ac9abbb59814",
    "patch": "@@ -109,6 +109,7 @@\n Tony Wang,\n Trask Stalnaker,\n Travis Haagen,\n+Utkarsh Rai,\n Utsav Oza,\n Vatsal Sura,\n Vladimir Sitnikov,"
  }
]
