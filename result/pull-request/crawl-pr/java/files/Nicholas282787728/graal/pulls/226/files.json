[
  {
    "sha": "2407857df0307fc29f69f6528c05b6a3341f1780",
    "filename": "ci.hocon",
    "status": "modified",
    "additions": 0,
    "deletions": 3,
    "changes": 3,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/e1eb501fe3106ddddbe6a5dbc08db866663b1976/ci.hocon",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/e1eb501fe3106ddddbe6a5dbc08db866663b1976/ci.hocon",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/ci.hocon?ref=e1eb501fe3106ddddbe6a5dbc08db866663b1976",
    "patch": "@@ -50,9 +50,6 @@ include \"compiler/ci_includes/x52-c2.hocon\"\n include \"compiler/ci_includes/x52-c2-jfr.hocon\"\n include \"compiler/ci_includes/bench-aarch64-c2.hocon\"\n \n-# ------------------- JAOTC -------------------\n-include \"compiler/ci_includes/gate_tasks.hocon\"\n-\n # ------------------ SVM ----------------------\n include \"substratevm/ci_includes/gate.hocon\"\n "
  },
  {
    "sha": "1549bf249ae2904fd5e003bf1e0eb34754c59d7f",
    "filename": "common.hocon",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/e1eb501fe3106ddddbe6a5dbc08db866663b1976/common.hocon",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/e1eb501fe3106ddddbe6a5dbc08db866663b1976/common.hocon",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/common.hocon?ref=e1eb501fe3106ddddbe6a5dbc08db866663b1976",
    "patch": "@@ -173,6 +173,10 @@ svm-common-windows-jdk11: ${svm-common} ${windows-amd64} ${devkits.windows-jdk11\n   timelimit: \"45:00\"\n }\n \n+svm-common-windows-jdk16: ${svm-common} ${windows-amd64} ${devkits.windows-jdk16} {\n+  timelimit: \"45:00\"\n+}\n+\n svm-common-sulong: {\n   packages: {\n     llvm: \"==6.0.1\""
  },
  {
    "sha": "7da82e5f57db31e1191a7e1e86a147ae530f7a2d",
    "filename": "common.json",
    "status": "modified",
    "additions": 10,
    "deletions": 10,
    "changes": 20,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/e1eb501fe3106ddddbe6a5dbc08db866663b1976/common.json",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/e1eb501fe3106ddddbe6a5dbc08db866663b1976/common.json",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/common.json?ref=e1eb501fe3106ddddbe6a5dbc08db866663b1976",
    "patch": "@@ -2,26 +2,26 @@\n   \"README\": \"This file contains definitions that are useful for the hocon and jsonnet CI files of multiple repositories.\",\n \n   \"jdks\": {\n-    \"openjdk8\":           {\"name\": \"openjdk\",   \"version\": \"8u282+08-jvmci-21.1-b01\", \"platformspecific\": true },\n-    \"oraclejdk8\":         {\"name\": \"oraclejdk\", \"version\": \"8u281+09-jvmci-21.1-b01\", \"platformspecific\": true },\n-    \"oraclejdk8Debug\":    {\"name\": \"oraclejdk\", \"version\": \"8u281+09-jvmci-21.1-b01-fastdebug\", \"platformspecific\": true },\n+    \"openjdk8\":           {\"name\": \"openjdk\",   \"version\": \"8u292+05-jvmci-21.1-b02\", \"platformspecific\": true },\n+    \"oraclejdk8\":         {\"name\": \"oraclejdk\", \"version\": \"8u291+07-jvmci-21.1-b02\", \"platformspecific\": true },\n+    \"oraclejdk8Debug\":    {\"name\": \"oraclejdk\", \"version\": \"8u291+07-jvmci-21.1-b02-fastdebug\", \"platformspecific\": true },\n \n     \"openjdk11\":          {\"name\": \"openjdk\",   \"version\": \"11.0.3+7\", \"platformspecific\": true },\n     \"oraclejdk11\":        {\"name\": \"oraclejdk\", \"version\": \"11.0.6+8\", \"platformspecific\": true },\n-    \"labsjdk-ce-11\":      {\"name\": \"labsjdk\",   \"version\": \"ce-11.0.10+9-jvmci-21.1-b01\", \"platformspecific\": true },\n-    \"labsjdk-ee-11\":      {\"name\": \"labsjdk\",   \"version\": \"ee-11.0.10+8-jvmci-21.1-b01\", \"platformspecific\": true },\n+    \"labsjdk-ce-11\":      {\"name\": \"labsjdk\",   \"version\": \"ce-11.0.11+5-jvmci-21.1-b02\", \"platformspecific\": true },\n+    \"labsjdk-ee-11\":      {\"name\": \"labsjdk\",   \"version\": \"ee-11.0.11+5-jvmci-21.1-b02\", \"platformspecific\": true },\n \n     \"oraclejdk16\":        {\"name\": \"oraclejdk\", \"version\": \"16.0.1+4\", \"platformspecific\": true },\n-    \"labsjdk-ce-16\":      {\"name\": \"labsjdk\",   \"version\": \"ce-16+29-jvmci-21.1-b01\", \"platformspecific\": true },\n-    \"labsjdk-ce-16Debug\": {\"name\": \"labsjdk\",   \"version\": \"ce-16+29-jvmci-21.1-b01-debug\", \"platformspecific\": true },\n-    \"labsjdk-ee-16\":      {\"name\": \"labsjdk\",   \"version\": \"ee-16.0.1+2-jvmci-21.1-b01\", \"platformspecific\": true },\n-    \"labsjdk-ee-16Debug\": {\"name\": \"labsjdk\",   \"version\": \"ee-16.0.1+2-jvmci-21.1-b01-debug\", \"platformspecific\": true }\n+    \"labsjdk-ce-16\":      {\"name\": \"labsjdk\",   \"version\": \"ce-16+36-jvmci-21.1-b02\", \"platformspecific\": true },\n+    \"labsjdk-ce-16Debug\": {\"name\": \"labsjdk\",   \"version\": \"ce-16+36-jvmci-21.1-b02-debug\", \"platformspecific\": true },\n+    \"labsjdk-ee-16\":      {\"name\": \"labsjdk\",   \"version\": \"ee-16+36-jvmci-21.1-b02\", \"platformspecific\": true },\n+    \"labsjdk-ee-16Debug\": {\"name\": \"labsjdk\",   \"version\": \"ee-16+36-jvmci-21.1-b02-debug\", \"platformspecific\": true }\n   },\n \n   \"COMMENT\" : \"The devkits versions reflect those used to build the JVMCI JDKs (e.g., see devkit_platform_revisions in <jdk>/make/conf/jib-profiles.js)\",\n   \"devkits\": {\n       \"windows-oraclejdk8\": { \"packages\" : { \"devkit:VS2017-15.9.16+1\" : \"==0\" }},\n-      \"windows-openjdk8\":   { \"packages\" : { \"devkit:VS2017-15.5.5+1\"  : \"==0\" }},\n+      \"windows-openjdk8\":   { \"packages\" : { \"devkit:VS2017-15.9.16+1\" : \"==0\" }},\n       \"windows-jdk11\":      { \"packages\" : { \"devkit:VS2017-15.9.24+1\" : \"==0\" }},\n       \"windows-jdk16\":      { \"packages\" : { \"devkit:VS2019-16.7.2+1\"  : \"==1\" }}\n   },"
  },
  {
    "sha": "1c4f6e5ae948ec16c458191b1c37e09fff1f1443",
    "filename": "compiler/CHANGELOG.md",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/e1eb501fe3106ddddbe6a5dbc08db866663b1976/compiler/CHANGELOG.md",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/e1eb501fe3106ddddbe6a5dbc08db866663b1976/compiler/CHANGELOG.md",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/CHANGELOG.md?ref=e1eb501fe3106ddddbe6a5dbc08db866663b1976",
    "patch": "@@ -3,6 +3,7 @@\n This changelog summarizes newly introduced optimizations that may be relevant to other teams.\n \n ## Version 21.1.0\n+* (GR-29126) Unify box optimizations in the compiler. Remove `-Dgraal.ReuseOutOfCacheBoxedValues=false`.\n * (GR-28523) Optimize Box nodes: Optimizes box operations by re-using boxed representations \n if the value of the boxed primitive is outside of the cache range of the Int/Long/Short/Char caches.\n Box node optimization is enabled per default. Disable it with `-Dgraal.ReuseOutOfCacheBoxedValues=false`."
  },
  {
    "sha": "91619664757bec8ecf87bec1ab01461f9abfa9ec",
    "filename": "compiler/ci_common/gate.hocon",
    "status": "modified",
    "additions": 0,
    "deletions": 9,
    "changes": 9,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/e1eb501fe3106ddddbe6a5dbc08db866663b1976/compiler/ci_common/gate.hocon",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/e1eb501fe3106ddddbe6a5dbc08db866663b1976/compiler/ci_common/gate.hocon",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/ci_common/gate.hocon?ref=e1eb501fe3106ddddbe6a5dbc08db866663b1976",
    "patch": "@@ -152,15 +152,6 @@ gateWindowsAMD64 : ${windows-amd64} ${gateCommon}\n \n gateLinuxAArch64 : ${linux-aarch64} ${gateCommon}\n \n-gateJAOTC : {\n-  environment : {\n-    EXTRA_VM_ARGS : \"\"\n-  }\n-  run : [\n-    ${gateCmd} [\"build,jaotc\"]\n-  ]\n-}\n-\n # This task listens to the hotspot math stubs changes. In case of failure, please check if the hotspot changes affect the\n # emitted stub code in C2, and update corresponding recasts in the org.graalvm.compiler.lir.amd64 package accordingly.\n gateMathStubsListener: ${linux-amd64} {"
  },
  {
    "sha": "cc507b486c953e3bc76c20bd00f4b95057244b2d",
    "filename": "compiler/ci_includes/gate_tasks.hocon",
    "status": "removed",
    "additions": 0,
    "deletions": 12,
    "changes": 12,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/ci_includes/gate_tasks.hocon",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/ci_includes/gate_tasks.hocon",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/ci_includes/gate_tasks.hocon?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,12 +0,0 @@\n-# Build targets\n-\n-builds += [\n-  ${gateJAOTC} ${oraclejdk16} ${gateLinuxAMD64} {name: \"gate-compiler-jaotc-16-linux-amd64\", timelimit:   \"30:00\"}\n-  ${gateJAOTC} ${oraclejdk16} ${gateLinuxAMD64} {name: \"daily-jaotc-16-linux-amd64\",         timelimit: \"1:20:00\"} {\n-    environment: {\n-      JAOTC_TEST_GROUP: \"daily\"\n-    }\n-    targets: [daily]\n-    notify_emails: [ \"dean.long@oracle.com\", \"igor.veresov@oracle.com\" ]\n-  }\n-]"
  },
  {
    "sha": "9e2503597f47ade78fe8622a4fd4834d6fad8009",
    "filename": "compiler/mx.compiler/mx_compiler.py",
    "status": "modified",
    "additions": 3,
    "deletions": 11,
    "changes": 14,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/e1eb501fe3106ddddbe6a5dbc08db866663b1976/compiler/mx.compiler/mx_compiler.py",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/e1eb501fe3106ddddbe6a5dbc08db866663b1976/compiler/mx.compiler/mx_compiler.py",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/mx.compiler/mx_compiler.py?ref=e1eb501fe3106ddddbe6a5dbc08db866663b1976",
    "patch": "@@ -58,8 +58,6 @@\n from mx_sdk_vm import jlink_new_jdk\n import mx_sdk_vm_impl\n \n-import mx_jaotc\n-\n import mx_graal_benchmark # pylint: disable=unused-import\n import mx_graal_tools #pylint: disable=unused-import\n \n@@ -453,7 +451,7 @@ def compiler_gate_runner(suites, unit_test_runs, bootstrap_tests, tasks, extraVM\n     with Task('CTW:hosted', tasks, tags=GraalTags.ctw) as t:\n         if t:\n             ctw([\n-                    '-DCompileTheWorld.Config=Inline=false CompilationFailureAction=ExitVM', '-esa', '-XX:-UseJVMCICompiler', '-XX:+EnableJVMCI',\n+                    '-DCompileTheWorld.Config=Inline=false CompilationFailureAction=ExitVM CompilationBailoutAsFailure=false', '-esa', '-XX:-UseJVMCICompiler', '-XX:+EnableJVMCI',\n                     '-DCompileTheWorld.MultiThreaded=true', '-Dgraal.InlineDuringParsing=false', '-Dgraal.TrackNodeSourcePosition=true',\n                     '-DCompileTheWorld.Verbose=false', '-XX:ReservedCodeCacheSize=300m',\n                 ], _remove_empty_entries(extraVMarguments))\n@@ -604,14 +602,9 @@ def compiler_gate_benchmark_runner(tasks, extraVMarguments=None, prefix=''):\n     BootstrapTest('BootstrapWithSystemAssertionsImmutableCode', _defaultFlags + _assertionFlags + _immutableCodeFlags + ['-Dgraal.VerifyPhases=true'] + _graalErrorFlags, tags=GraalTags.bootstrap)\n ]\n \n-def _is_jaotc_supported():\n-    return exists(jdk.exe_path('jaotc'))\n-\n def _graal_gate_runner(args, tasks):\n     compiler_gate_runner(['compiler', 'truffle'], graal_unit_test_runs, graal_bootstrap_tests, tasks, args.extra_vm_argument, args.extra_unittest_argument)\n     compiler_gate_benchmark_runner(tasks, args.extra_vm_argument)\n-    if _is_jaotc_supported():\n-        mx_jaotc.jaotc_gate_runner(tasks)\n \n class ShellEscapedStringAction(argparse.Action):\n     \"\"\"Turns a shell-escaped string into a list of arguments.\n@@ -1404,7 +1397,7 @@ def _jvmci_jars():\n         'compiler:GRAAL',\n         'compiler:GRAAL_MANAGEMENT',\n         'compiler:GRAAL_TRUFFLE_JFR_IMPL',\n-    ] + (['compiler:JAOTC'] if not isJDK8 and _is_jaotc_supported() else [])\n+    ]\n \n # The community compiler component\n cmp_ce_components = [\n@@ -1421,6 +1414,7 @@ def _jvmci_jars():\n         ],\n         jvmci_jars=_jvmci_jars(),\n         graal_compiler='graal',\n+        stability=\"supported\",\n     ),\n     mx_sdk_vm.GraalVmComponent(\n         suite=_suite,\n@@ -1451,8 +1445,6 @@ def print_graaljdk_home(args):\n mx.update_commands(_suite, {\n     'sl' : [sl, '[SL args|@VM options]'],\n     'vm': [run_vm_with_jvmci_compiler, '[-options] class [args...]'],\n-    'jaotc': [mx_jaotc.run_jaotc, '[-options] class [args...]'],\n-    'jaotc-test': [mx_jaotc.jaotc_test, ''],\n     'collate-metrics': [collate_metrics, 'filename'],\n     'ctw': [ctw, '[-vmoptions|noinline|nocomplex|full]'],\n     'nodecostdump' : [_nodeCostDump, ''],"
  },
  {
    "sha": "f29da817bd8d07b5155453edef7f78f17cbf816d",
    "filename": "compiler/mx.compiler/mx_jaotc.py",
    "status": "removed",
    "additions": 0,
    "deletions": 321,
    "changes": 321,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/mx.compiler/mx_jaotc.py",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/mx.compiler/mx_jaotc.py",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/mx.compiler/mx_jaotc.py?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,321 +0,0 @@\n-#\n-# ----------------------------------------------------------------------------------------------------\n-#\n-# Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# ----------------------------------------------------------------------------------------------------\n-from __future__ import print_function\n-\n-import os\n-import shutil\n-import tempfile\n-from argparse import ArgumentParser, ZERO_OR_MORE\n-\n-import mx\n-import mx_compiler\n-from mx_gate import Task\n-\n-jdk = mx.get_jdk(tag='default')\n-\n-def _check_jaotc_support():\n-    if jdk.javaCompliance < '11':\n-        mx.abort('jaotc command is only available if JAVA_HOME is JDK 11 or later')\n-    if not mx_compiler._is_jaotc_supported():\n-        mx.abort('jaotc executable is not present in ' + str(mx_compiler.jdk))\n-\n-def run_jaotc(args, classpath=None, cwd=None):\n-    \"\"\"run AOT compiler with classes in this repo instead of those in the JDK\"\"\"\n-    _check_jaotc_support()\n-    vm_args = [a for a in args if a.startswith('-J')]\n-    args = [a for a in args if not a.startswith('-J')]\n-\n-    verbose = ['--verbose'] if mx._opts.very_verbose else []\n-    cp = ['-J--class-path=' + classpath] if classpath else []\n-\n-    graaljdk_dir, _ = mx_compiler._update_graaljdk(mx_compiler.jdk)\n-    graaljdk = mx.JDKConfig(graaljdk_dir)\n-    jaotc_exe = graaljdk.exe_path('jaotc', 'bin')\n-    mx.run([jaotc_exe] + vm_args + cp + verbose + args, cwd=cwd)\n-\n-def jaotc_gate_runner(tasks):\n-    with Task('jaotc', tasks, tags=['jaotc', 'fulltest']) as t:\n-        group = mx.get_env('JAOTC_TEST_GROUP', 'gate')\n-        if t: jaotc_test(['--group', group])\n-\n-\n-def jaotc_run(tests, group):\n-    for test in tests:\n-        mx.log('Testing `{}`'.format(test))\n-\n-        group_config = jaotc_group_config[group]\n-        test_info = jaotc_test_info[test]\n-\n-        test_type = jaotc_test_info[test]['type']\n-        if test_type == 'app':\n-            test_class(\n-                opts_set=group_config['class'],\n-                classpath=mx.classpath('JAOTC_TEST'),\n-                main_class=test_info['main']\n-            )\n-        elif test_type == 'javac':\n-            test_javac('jdk.tools.jaotc', group_config['javac'])\n-        elif test_type == 'modules':\n-            cp = jaotc_test_info[test].get('cp')\n-            cp = cp() if cp else None\n-            test_modules(\n-                opts_set=group_config['modules'],\n-                classpath=cp,\n-                main_class=test_info['main'],\n-                modules=test_info['modules'],\n-                vm_args=test_info.get('vm_args'),\n-                program_args=test_info.get('program_args'),\n-                commands=test_info.get('commands'),\n-            )\n-        else:\n-            mx.abort('Unknown jaotc test: {}'.format(test))\n-\n-\n-def jaotc_test(args):\n-    \"\"\"run (acceptance) tests for the AOT compiler (jaotc)\"\"\"\n-    _check_jaotc_support()\n-    parser = ArgumentParser(prog='mx jaotc-test')\n-    parser.add_argument(\"--list\", default=None, action=\"store_true\", help=\"Print the list of available jaotc tests.\")\n-    parser.add_argument(\"--group\", default='default', action=\"store\", help=\"Test group {}.\".format(jaotc_group_config.keys()))\n-    parser.add_argument('tests', help='tests to run (omit to run all tests)', nargs=ZERO_OR_MORE)\n-    args = parser.parse_args(args)\n-\n-    group = args.group\n-    if args.list:\n-        print(\"The following jaotc tests are available:\\n\")\n-        for name in jaotc_group_config[group]['tests']:\n-            print(\"  \" + name)\n-        return\n-\n-    group_tests = jaotc_group_config[group]['tests']\n-    tests = args.tests or group_tests\n-\n-    if tests == args.tests:\n-        for test in tests:\n-            if not test in group_tests:\n-                mx.abort('Test {} not on list: {}'.format(test, list(group_tests)))\n-\n-    jaotc_run(tests, group)\n-\n-def mktemp_libfile():\n-    return tempfile.NamedTemporaryFile(prefix=mx.add_lib_prefix(''), suffix=mx.add_lib_suffix(''))\n-\n-def jaotc_classpath():\n-    return mx.project('jdk.tools.jaotc.test').output_dir()\n-\n-jaotc_test_info = {\n-    'HelloWorld' : {\n-        'type' : 'app',\n-        'main' : 'jdk.tools.jaotc.test.HelloWorld'\n-    },\n-    'java.base' : {\n-        'type'    : 'modules',\n-        'modules' : ['java.base'],\n-        'cp'      : jaotc_classpath,\n-        'main'    : 'jdk.tools.jaotc.test.HelloWorld'\n-    },\n-    'graal-jlink' : {\n-        'type'         : 'modules',\n-        'main'         : 'jdk.tools.jlink.internal.Main',\n-        'modules'      : ['jdk.internal.vm.ci', 'jdk.internal.vm.compiler', 'jdk.internal.vm.compiler.management'],\n-        'commands'     : '\\n'.join([\n-            '# exclude troublesome methods',\n-            r'exclude org\\.graalvm\\.compiler\\.replacements\\..*',\n-            r'exclude org\\.graalvm\\.compiler\\.hotspot\\.replacements\\..*',\n-            r'exclude org\\.graalvm\\.compiler\\.nodes\\.java\\.DynamicNewArrayNode\\.new.*',\n-            r'exclude org\\.graalvm\\.compiler\\.nodes\\.PiNode\\..*',\n-            r'exclude org\\.graalvm\\.compiler\\.hotspot\\.stubs\\.Plugin.*',\n-            r'exclude org\\.graalvm\\.compiler\\.hotspot\\.stubs\\.StubUtil\\..*',\n-            r'exclude org\\.graalvm\\.compiler\\.hotspot\\.nodes\\.GraalHotSpotVMConfigNode\\..*',\n-            r'exclude org\\.graalvm\\.compiler\\..*\\.substitutions\\..*',\n-            'exclude org.graalvm.compiler.nodes.java.NewArrayNode.newUninitializedArray(Ljava/lang/Class;I)Ljava/lang/Object;',\n-            'exclude org.graalvm.compiler.nodes.PiNode.piCastNonNull(Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;',\n-            ''\n-        ]),\n-        'vm_args'      : ['-XX:+UnlockExperimentalVMOptions', '-XX:+UseJVMCICompiler', '-Xcomp'],\n-        'program_args' : ['--list-plugins'],\n-    },\n-    'javac'     : {'type' : 'javac'},\n-}\n-\n-jaotc_common_opts = ['-ea:org.graalvm...']\n-\n-jaotc_common_gc_compressed = [\n-    jaotc_common_opts + [gc, ops]\n-    for gc in ['-XX:+UseParallelGC', '-XX:+UseG1GC']\n-    for ops in ['-XX:-UseCompressedOops', '-XX:+UseCompressedOops']\n-]\n-\n-jaotc_group_config = {\n-    'default': {\n-        'tests': ['HelloWorld', 'javac', 'graal-jlink', 'java.base'],\n-        'class':   jaotc_common_gc_compressed,\n-        'javac':   [jaotc_common_opts],\n-        'modules': [jaotc_common_opts],\n-    },\n-    'gate': {\n-        'tests': ['HelloWorld', 'javac', 'java.base'],\n-        'class':   jaotc_common_gc_compressed,\n-        'javac':   [jaotc_common_opts],\n-        'modules': [jaotc_common_opts],\n-    },\n-    'daily': {\n-        'tests': ['graal-jlink', 'java.base'],\n-        'modules': jaotc_common_gc_compressed,\n-    },\n-    'stress': {\n-        'tests': ['HelloWorld', 'javac', 'graal-jlink', 'java.base'],\n-        'class':   jaotc_common_gc_compressed,\n-        'javac':   jaotc_common_gc_compressed,\n-        'modules': jaotc_common_gc_compressed,\n-    },\n-}\n-\n-def test_class(opts_set, classpath, main_class, program_args=None):\n-    \"\"\"(jaotc-)Compiles simple HelloWorld program.\n-    Compares the output vs. standard JVM.\n-    \"\"\"\n-    # Run on vanilla JVM.\n-    program_args = program_args or []\n-    expected_out = mx.OutputCapture()\n-    mx_compiler.run_vm((['-cp', classpath] if classpath else []) +\n-                       [main_class] + program_args, out=expected_out)\n-\n-    for common_opts in opts_set:\n-        mx.log('Running {} with {}'.format(main_class, ' '.join(common_opts)))\n-\n-        with mktemp_libfile() as lib_module:\n-            lib_module.file.close()\n-            run_jaotc(['-J' + opt for opt in common_opts] +\n-                      ['--exit-on-error', '--info', '--output', lib_module.name, main_class],\n-                      classpath=classpath)\n-            check_aot(classpath, main_class, common_opts, expected_out.data, lib_module, program_args)\n-\n-def test_modules(opts_set, classpath, main_class, modules, vm_args, program_args, commands):\n-    \"\"\"(jaotc-)Compiles `modules` and runs `main_class` + AOT library.\n-    Compares the output vs. standard JVM.\n-    \"\"\"\n-    # Run on vanilla JVM.\n-    program_args = program_args or []\n-    vm_args = vm_args or []\n-    commands = commands or ''\n-    expected_out = mx.OutputCapture()\n-\n-    mx_compiler.run_vm((['-cp', classpath] if classpath else []) +\n-                       vm_args +\n-                       [main_class] + program_args, out=expected_out)\n-\n-    # jaotc uses ':' as separator.\n-    module_list = ':'.join(modules)\n-\n-    for common_opts in opts_set:\n-        mx.log('(jaotc) Compiling module(s) {} with {}'.format(module_list, ' '.join(common_opts)))\n-        with mktemp_libfile() as lib_module:\n-            lib_module.file.close()\n-            with tempfile.NamedTemporaryFile(mode='w', prefix='cmds_', suffix='.txt') as cmd_file:\n-                cmd_file.write(commands)\n-                cmd_file.file.close()\n-                run_jaotc(['-J' + opt for opt in common_opts] +\n-                          ['--module', module_list] +\n-                          ['--compile-commands', cmd_file.name] +\n-                          ['--exit-on-error', '--info', '--output', lib_module.name])\n-\n-            check_aot(classpath, main_class, common_opts, expected_out.data, lib_module, program_args)\n-\n-\n-def collect_java_sources(source_dirs):\n-    javafilelist = []\n-    for sourceDir in source_dirs:\n-        for root, _, files in os.walk(sourceDir, followlinks=True):\n-            javafiles = [os.path.join(root, name) for name in files if name.endswith('.java')]\n-            javafilelist += javafiles\n-    return javafilelist\n-\n-\n-def test_javac(project_name, opts_set):\n-    \"\"\"(jaotc-)Compiles the `jdk.compiler` module and compiles (mx) project_name using `javac` (+ AOT module).\"\"\"\n-    # jaotc uses ':' as separator.\n-    modules = ':'.join(['jdk.compiler'])\n-    for common_opts in opts_set:\n-        out_dir = tempfile.mkdtemp()\n-        try:\n-            mx.log('(jaotc) Compiling module(s) {} with {}'.format(modules, ' '.join(common_opts)))\n-            with mktemp_libfile() as lib_module:\n-                lib_module.file.close()\n-                run_jaotc(['-J' + opt for opt in common_opts] +\n-                          ['--exit-on-error', '--info', '--module', modules, '--output', lib_module.name])\n-\n-                aot_opts = [\n-                    '-XX:+UnlockDiagnosticVMOptions',\n-                    '-XX:+UseAOTStrictLoading',\n-                    '-XX:AOTLibrary=' + lib_module.name\n-                ]\n-\n-                project = mx.project(project_name)\n-                java_files = collect_java_sources(project.source_dirs())\n-                javac_args = mx.JavacCompiler(jdk).prepare(\n-                    sourceFiles=java_files,\n-                    project=project,\n-                    outputDir=out_dir,\n-                    classPath=mx.classpath(project, includeSelf=False, jdk=jdk, ignoreStripped=True),\n-                    sourceGenDir=project.source_gen_dir(),\n-                    jnigenDir=project.jni_gen_dir(),\n-                    processorPath=project.annotation_processors_path(jdk),\n-                    disableApiRestrictions=True,\n-                    warningsAsErrors=False,\n-                    showTasks=False,\n-                    postCompileActions=[],\n-                    forceDeprecationAsWarning=False)\n-\n-                mx_compiler.run_vm(common_opts + aot_opts + ['com.sun.tools.javac.Main'] + javac_args)\n-\n-        finally:\n-            shutil.rmtree(out_dir)\n-\n-\n-def check_aot(classpath, main_class, common_opts, expected_output, lib_module, program_args=None):\n-    aot_opts = [\n-        '-XX:+UnlockDiagnosticVMOptions',\n-        '-XX:+UseAOTStrictLoading',\n-        '-XX:AOTLibrary=' + lib_module.name\n-    ]\n-\n-    program_args = program_args or []\n-\n-    # Check AOT library is loaded.\n-    out = mx.OutputCapture()\n-    mx_compiler.run_vm(common_opts + aot_opts + ['-XX:+PrintAOT', '-version'], out=out, err=out, nonZeroIsFatal=False)\n-    if 'aot library' not in out.data:\n-        mx.abort(\"Missing expected 'aot library' in -XX:+PrintAOT -version output. VM Output:\\n\" + str(out.data))\n-\n-    # Run main_class+AOT modules and check output.\n-    aot_out = mx.OutputCapture()\n-    mx_compiler.run_vm(common_opts + aot_opts + (['-cp', classpath] if classpath else []) + [main_class] + program_args, out=aot_out)\n-\n-    if expected_output != aot_out.data:\n-        mx.abort('Outputs differ, expected `{}` != `{}`'.format(expected_output, aot_out.data))"
  },
  {
    "sha": "45f7c79652cdd7df9b717ce71c71edc63e71e356",
    "filename": "compiler/mx.compiler/mx_updategraalinopenjdk.py",
    "status": "modified",
    "additions": 0,
    "deletions": 23,
    "changes": 23,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/e1eb501fe3106ddddbe6a5dbc08db866663b1976/compiler/mx.compiler/mx_updategraalinopenjdk.py",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/e1eb501fe3106ddddbe6a5dbc08db866663b1976/compiler/mx.compiler/mx_updategraalinopenjdk.py",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/mx.compiler/mx_updategraalinopenjdk.py?ref=e1eb501fe3106ddddbe6a5dbc08db866663b1976",
    "patch": "@@ -121,10 +121,6 @@ def updategraalinopenjdk(args):\n             GraalJDKModule('jdk.internal.vm.compiler.management',\n                 # 1. Classes in the compiler suite under the org.graalvm.compiler.hotspot.management namespace\n                 [SuiteJDKInfo('compiler', ['org.graalvm.compiler.hotspot.management'], ['libgraal'])]),\n-            # JDK module jdk.aot is composed of sources from:\n-            GraalJDKModule('jdk.aot',\n-                # 1. Classes in the compiler suite under the jdk.tools.jaotc namespace\n-                [SuiteJDKInfo('compiler', ['jdk.tools.jaotc'], [])]),\n         ]\n     else:\n         if args.version < 15:\n@@ -143,10 +139,6 @@ def updategraalinopenjdk(args):\n             GraalJDKModule('jdk.internal.vm.compiler.management',\n                 # 1. Classes in the compiler suite under the org.graalvm.compiler.hotspot.management namespace\n                 [SuiteJDKInfo('compiler', ['org.graalvm.compiler.hotspot.management'], ['libgraal'])]),\n-            # JDK module jdk.aot is composed of sources from:\n-            GraalJDKModule('jdk.aot',\n-                # 1. Classes in the compiler suite under the jdk.tools.jaotc namespace\n-                [SuiteJDKInfo('compiler', ['jdk.tools.jaotc'], [])]),\n         ]\n \n \n@@ -399,25 +391,10 @@ def do_nothing(line):\n     new_line = '    uses org.graalvm.compiler.nodes.graphbuilderconf.GeneratedPluginFactory;\\n'\n     replace_line(compiler_module_info, old_line, new_line)\n \n-    if args.version == 11:\n-        # add aot exclude\n-        out = run_output(['grep', 'jdk.aot_EXCLUDES', CompileJavaModules_gmk], cwd=jdkrepo)\n-        if out:\n-            # replace existing exclude setting\n-            begin_lines = ['jdk.aot_EXCLUDES += \\\\']\n-            end_line = '#'\n-            new_lines = ['jdk.tools.jaotc.test \\\\\\n']\n-            replace_lines(CompileJavaModules_gmk, begin_lines, end_line, new_lines, old_line_check, preserve_indent=True)\n-        else:\n-            # append exclude setting after jdk.internal.vm.compiler_EXCLUDES\n-            new_lines = ['\\n', 'jdk.aot_EXCLUDES += \\\\\\n', '    jdk.tools.jaotc.test \\\\\\n', '    #\\n', '\\n']  # indent is inlined\n-            replace_lines(CompileJavaModules_gmk, begin_lines, end_line, new_lines, old_line_check, preserve_indent=True, append_mode=True)\n-\n     # Update 'SRC' in the 'Compile graalunit tests' section of make/test/JtregGraalUnit.gmk\n     # to include all test packages.\n     JtregGraalUnit_gmk = join(jdkrepo, 'make', 'test', 'JtregGraalUnit.gmk') # pylint: disable=invalid-name\n     new_lines = []\n-    jdk_internal_vm_compiler_test_SRC.discard('jdk.tools.jaotc.test')\n     jdk_internal_vm_compiler_test_SRC.discard('org.graalvm.compiler.microbenchmarks')\n     jdk_internal_vm_compiler_test_SRC.discard('org.graalvm.compiler.virtual.bench')\n     jdk_internal_vm_compiler_test_SRC.discard('org.graalvm.micro.benchmarks')"
  },
  {
    "sha": "8822a19094a75840c3858af248496b68f0192a9e",
    "filename": "compiler/mx.compiler/suite.py",
    "status": "modified",
    "additions": 29,
    "deletions": 120,
    "changes": 149,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/e1eb501fe3106ddddbe6a5dbc08db866663b1976/compiler/mx.compiler/suite.py",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/e1eb501fe3106ddddbe6a5dbc08db866663b1976/compiler/mx.compiler/suite.py",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/mx.compiler/suite.py?ref=e1eb501fe3106ddddbe6a5dbc08db866663b1976",
    "patch": "@@ -1,5 +1,5 @@\n suite = {\n-  \"mxversion\" : \"5.287.0\",\n+  \"mxversion\" : \"5.288.5\",\n   \"name\" : \"compiler\",\n   \"sourceinprojectwhitelist\" : [],\n \n@@ -227,13 +227,34 @@\n         ],\n       },\n       \"checkstyle\" : \"org.graalvm.compiler.graph\",\n-      \"javaCompliance\" : \"13+\",\n+      \"javaCompliance\" : \"13..15\",\n       \"checkPackagePrefix\" : \"false\",\n       \"overlayTarget\" : \"org.graalvm.compiler.serviceprovider\",\n       \"multiReleaseJarVersion\" : \"13\",\n       \"workingSets\" : \"API,Graal\",\n     },\n \n+    \"org.graalvm.compiler.serviceprovider.jdk16\" : {\n+      \"subDir\" : \"src\",\n+      \"sourceDirs\" : [\"src\"],\n+      \"dependencies\" : [\"org.graalvm.compiler.serviceprovider\"],\n+      \"requiresConcealed\" : {\n+        \"jdk.internal.vm.ci\" : [\n+          \"jdk.vm.ci.meta\",\n+          \"jdk.vm.ci.code\",\n+          \"jdk.vm.ci.code.site\",\n+          \"jdk.vm.ci.services\",\n+          \"jdk.vm.ci.runtime\",\n+        ],\n+      },\n+      \"checkstyle\" : \"org.graalvm.compiler.graph\",\n+      \"javaCompliance\" : \"16+\",\n+      \"checkPackagePrefix\" : \"false\",\n+      \"overlayTarget\" : \"org.graalvm.compiler.serviceprovider\",\n+      \"multiReleaseJarVersion\" : \"16\",\n+      \"workingSets\" : \"API,Graal\",\n+    },\n+\n     \"org.graalvm.compiler.processor\" : {\n       \"subDir\" : \"src\",\n       \"sourceDirs\" : [\"src\"],\n@@ -570,7 +591,7 @@\n       \"overlayTarget\" : \"org.graalvm.compiler.hotspot\",\n       \"multiReleaseJarVersion\" : \"13\",\n       \"checkstyle\" : \"org.graalvm.compiler.graph\",\n-      \"javaCompliance\" : \"13+\",\n+      \"javaCompliance\" : \"13..14\",\n       \"workingSets\" : \"Graal,HotSpot\",\n     },\n \n@@ -1532,58 +1553,6 @@\n       \"testProject\" : True,\n     },\n \n-    # ------------- JDK AOT -------------\n-\n-    \"jdk.tools.jaotc\" : {\n-      \"subDir\" : \"src\",\n-      \"sourceDirs\" : [\"src\"],\n-      \"dependencies\" : [\n-        \"JVMCI_HOTSPOT\",\n-        \"jdk.tools.jaotc.binformat\",\n-        \"org.graalvm.compiler.asm.amd64\",\n-        \"org.graalvm.compiler.asm.aarch64\",\n-      ],\n-      \"requiresConcealed\" : {\n-        \"jdk.internal.vm.ci\" : '*',\n-      },\n-      \"requires\" : [\n-        \"java.management\"\n-      ],\n-      \"checkstyle\" : \"org.graalvm.compiler.graph\",\n-      \"javaCompliance\" : \"11+\",\n-      \"workingSets\" : \"Graal,HotSpot\",\n-    },\n-\n-    \"jdk.tools.jaotc.binformat\" : {\n-      \"subDir\" : \"src\",\n-      \"sourceDirs\" : [\"src\"],\n-      \"dependencies\" : [\n-        \"JVMCI_HOTSPOT\",\n-        \"org.graalvm.compiler.hotspot\",\n-      ],\n-      \"requiresConcealed\" : {\n-        \"jdk.internal.vm.ci\" : [\n-          \"jdk.vm.ci.hotspot\",\n-          \"jdk.vm.ci.services\"\n-        ]\n-      },\n-      \"checkstyle\" : \"org.graalvm.compiler.graph\",\n-      \"javaCompliance\" : \"11+\",\n-      \"workingSets\" : \"Graal,HotSpot\",\n-    },\n-\n-    \"jdk.tools.jaotc.test\" : {\n-      \"subDir\" : \"src\",\n-      \"sourceDirs\" : [\"src\"],\n-      \"dependencies\" : [\n-        \"jdk.tools.jaotc\",\n-        \"mx:JUNIT\",\n-      ],\n-      \"checkstyle\" : \"org.graalvm.compiler.graph\",\n-      \"javaCompliance\" : \"11+\",\n-      \"workingSets\" : \"Graal,Test\",\n-    },\n-\n     # ------------- GraalTruffle -------------\n \n     \"org.graalvm.compiler.truffle.common\" : {\n@@ -2156,36 +2125,12 @@\n         ],\n         \"exports\" : [\n           \"* to com.oracle.graal.graal_enterprise\",\n-          \"org.graalvm.compiler.api.directives         to jdk.aot\",\n-          \"org.graalvm.compiler.api.runtime            to jdk.aot\",\n-          \"org.graalvm.compiler.api.replacements       to jdk.aot\",\n-          \"org.graalvm.compiler.asm.amd64              to jdk.aot\",\n-          \"org.graalvm.compiler.asm.aarch64            to jdk.aot\",\n-          \"org.graalvm.compiler.bytecode               to jdk.aot\",\n-          \"org.graalvm.compiler.code                   to jdk.aot\",\n-          \"org.graalvm.compiler.core                   to jdk.aot\",\n-          \"org.graalvm.compiler.core.common            to jdk.aot,jdk.internal.vm.compiler.management\",\n-          \"org.graalvm.compiler.core.target            to jdk.aot\",\n-          \"org.graalvm.compiler.debug                  to jdk.aot,jdk.internal.vm.compiler.management\",\n-          \"org.graalvm.compiler.graph                  to jdk.aot\",\n-          \"org.graalvm.compiler.hotspot                to jdk.aot,jdk.internal.vm.compiler.management\",\n-          \"org.graalvm.compiler.hotspot.meta           to jdk.aot\",\n-          \"org.graalvm.compiler.hotspot.replacements   to jdk.aot\",\n-          \"org.graalvm.compiler.hotspot.stubs          to jdk.aot\",\n-          \"org.graalvm.compiler.hotspot.word           to jdk.aot\",\n-          \"org.graalvm.compiler.java                   to jdk.aot\",\n-          \"org.graalvm.compiler.lir.asm                to jdk.aot\",\n-          \"org.graalvm.compiler.lir.phases             to jdk.aot\",\n-          \"org.graalvm.compiler.nodes                  to jdk.aot\",\n-          \"org.graalvm.compiler.nodes.graphbuilderconf to jdk.aot\",\n-          \"org.graalvm.compiler.options                to jdk.aot,jdk.internal.vm.compiler.management\",\n-          \"org.graalvm.compiler.phases                 to jdk.aot\",\n+          \"org.graalvm.compiler.core.common            to jdk.internal.vm.compiler.management\",\n+          \"org.graalvm.compiler.debug                  to jdk.internal.vm.compiler.management\",\n+          \"org.graalvm.compiler.hotspot                to jdk.internal.vm.compiler.management\",\n+          \"org.graalvm.compiler.options                to jdk.internal.vm.compiler.management\",\n           \"org.graalvm.compiler.phases.common.jmx      to jdk.internal.vm.compiler.management\",\n-          \"org.graalvm.compiler.phases.tiers           to jdk.aot\",\n-          \"org.graalvm.compiler.printer                to jdk.aot\",\n-          \"org.graalvm.compiler.runtime                to jdk.aot\",\n-          \"org.graalvm.compiler.replacements           to jdk.aot\",\n-          \"org.graalvm.compiler.serviceprovider        to jdk.aot,jdk.internal.vm.compiler.management\",\n+          \"org.graalvm.compiler.serviceprovider        to jdk.internal.vm.compiler.management\",\n           \"org.graalvm.compiler.truffle.jfr            to jdk.internal.vm.compiler.truffle.jfr\",\n           \"org.graalvm.libgraal                        to jdk.internal.vm.compiler.management\",\n           \"org.graalvm.util                            to jdk.internal.vm.compiler.management\",\n@@ -2307,42 +2252,6 @@\n       \"javaCompliance\" : \"8+\",\n     },\n \n-    \"JAOTC\" : {\n-      # This distribution defines a module.\n-      \"moduleInfo\" : {\n-        \"name\":\"jdk.aot\",\n-      },\n-      \"subDir\" : \"src\",\n-      \"dependencies\" : [\n-        \"jdk.tools.jaotc\",\n-      ],\n-      \"distDependencies\" : [\n-        \"GRAAL\",\n-        \"GRAAL_MANAGEMENT\",\n-      ],\n-      \"exclude\" : [\n-        \"JVMCI_SERVICES\",\n-        \"JVMCI_API\",\n-        \"JVMCI_HOTSPOT\",\n-      ],\n-      \"maven\": False,\n-    },\n-\n-    \"JAOTC_TEST\" : {\n-      \"subDir\" : \"src\",\n-      \"dependencies\" : [\n-        \"jdk.tools.jaotc.test\",\n-      ],\n-      \"distDependencies\" : [\n-        \"JAOTC\",\n-      ],\n-      \"exclude\" : [\n-        \"mx:JUNIT\",\n-      ],\n-      \"testDistribution\" : True,\n-      \"maven\": False,\n-    },\n-\n     \"GRAAL_COMPILER_WHITEBOX_MICRO_BENCHMARKS\" : {\n       \"subDir\" : \"src\",\n       \"dependencies\" : ["
  },
  {
    "sha": "29b18fbbaa0da0d7b8741b1bba98f38c9e404348",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/BinaryContainer.java",
    "status": "removed",
    "additions": 0,
    "deletions": 959,
    "changes": 959,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/BinaryContainer.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/BinaryContainer.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/BinaryContainer.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,959 +0,0 @@\n-/*\n- * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat;\n-\n-import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;\n-import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;\n-import org.graalvm.compiler.options.OptionValues;\n-import org.graalvm.compiler.serviceprovider.JavaVersionUtil;\n-\n-import jdk.tools.jaotc.binformat.Symbol.Binding;\n-import jdk.tools.jaotc.binformat.Symbol.Kind;\n-import jdk.tools.jaotc.binformat.elf.JELFRelocObject;\n-import jdk.tools.jaotc.binformat.macho.JMachORelocObject;\n-import jdk.tools.jaotc.binformat.pecoff.JPECoffRelocObject;\n-\n-/**\n- * A format-agnostic container class that holds various components of a binary.\n- *\n- * <p>\n- * This class holds information necessary to create platform-specific binary containers such as\n- * ELFContainer for Linux or MachOContainer for Mac OS or PEContainer for MS Windows operating\n- * systems.\n- *\n- * <p>\n- * Method APIs provided by this class are used to construct and populate platform-independent\n- * contents of a binary as the first step to create a binary representation of code generated by a\n- * compiler backend such as Graal.\n- *\n- * <p>\n- * Methods to record and access code section contents, symbols and relocations are provided.\n- */\n-public final class BinaryContainer implements SymbolTable {\n-    private final OptionValues graalOptions;\n-\n-    private final int codeSegmentSize;\n-\n-    private final int codeEntryAlignment;\n-\n-    private final boolean threadLocalHandshakes;\n-\n-    /**\n-     * Container holding code bits and any other related information.\n-     */\n-    private final CodeContainer codeContainer;\n-\n-    /**\n-     * Container holding global offset data for hotspot linkage.\n-     */\n-    private final ByteContainer extLinkageGOTContainer;\n-\n-    /**\n-     * Patched by HotSpot, contains Klass pointers.\n-     */\n-    private final ByteContainer klassesGotContainer;\n-\n-    /**\n-     * Patched by HotSpot, contains MethodCounters pointers.\n-     */\n-    private final ByteContainer countersGotContainer;\n-\n-    /**\n-     * Patched lazily by hotspot, contains klass/method pointers.\n-     */\n-    private final ByteContainer metadataGotContainer;\n-\n-    /**\n-     * BSS container, contains method state array.\n-     */\n-    private final ByteContainer methodStateContainer;\n-\n-    /**\n-     * Patched by hotspot, contains java object pointers.\n-     */\n-    private final ByteContainer oopGotContainer;\n-\n-    // Containers holding read-only data\n-    private final ReadOnlyDataContainer configContainer;\n-    private final ReadOnlyDataContainer metaspaceNamesContainer;\n-    private final ReadOnlyDataContainer methodsOffsetsContainer;\n-    private final ReadOnlyDataContainer klassesOffsetsContainer;\n-    private final ReadOnlyDataContainer klassesDependenciesContainer;\n-    private final HeaderContainer headerContainer;\n-    private final ReadOnlyDataContainer stubsOffsetsContainer;\n-    private final ReadOnlyDataContainer codeSegmentsContainer;\n-\n-    // This cannot be read only since we need to patch the metadata at runtime..\n-    private final ReadOnlyDataContainer methodMetadataContainer;\n-\n-    /**\n-     * Container containing constant data used by code.\n-     */\n-    private final ReadOnlyDataContainer constantDataContainer;\n-\n-    /**\n-     * Map holding the Strings table.\n-     */\n-    private final Map<String, Integer> offsetStringTable = new HashMap<>();\n-\n-    private final Map<String, Integer> metaspaceNames = new HashMap<>();\n-\n-    // List of relocation table entries - (symbolName, relocationInfo)\n-    private final Map<String, Symbol> symbolTable = new HashMap<>();\n-    private final Map<Symbol, List<Relocation>> relocationTable = new HashMap<>();\n-    private final Map<Symbol, Relocation> uniqueRelocationTable = new HashMap<>();\n-\n-    /**\n-     * Mapping of local VM function names to known global symbols generated in the output binary.\n-     */\n-    private static final HashMap<String, String> functionNamesToAOTSymbols = new HashMap<>();\n-\n-    //@formatter:off\n-    private static final String[][] map = {\n-        {\"CompilerToVM::Data::SharedRuntime_deopt_blob_unpack\",         \"_aot_deopt_blob_unpack\"},\n-        {\"CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap\",  \"_aot_deopt_blob_uncommon_trap\"},\n-        {\"CompilerToVM::Data::SharedRuntime_deopt_blob_unpack_with_exception_in_tls\",  \"_aot_deopt_blob_unpack_with_exception_in_tls\"},\n-        {\"CompilerToVM::Data::SharedRuntime_ic_miss_stub\",              \"_aot_ic_miss_stub\"},\n-        {\"CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub\",  \"_aot_handle_wrong_method_stub\"},\n-        {\"SharedRuntime::exception_handler_for_return_address\",         \"_aot_exception_handler_for_return_address\"},\n-        {\"SharedRuntime::register_finalizer\",                           \"_aot_register_finalizer\"},\n-        {\"SharedRuntime::OSR_migration_end\",                            \"_aot_OSR_migration_end\"},\n-        {\"SharedRuntime::enable_stack_reserved_zone\",                   \"_aot_enable_stack_reserved_zone\"},\n-        {\"CompilerRuntime::resolve_dynamic_invoke\",                     \"_aot_resolve_dynamic_invoke\"},\n-        {\"CompilerRuntime::resolve_string_by_symbol\",                   \"_aot_resolve_string_by_symbol\"},\n-        {\"CompilerRuntime::resolve_klass_by_symbol\",                    \"_aot_resolve_klass_by_symbol\"},\n-        {\"CompilerRuntime::resolve_method_by_symbol_and_load_counters\", \"_aot_resolve_method_by_symbol_and_load_counters\"},\n-        {\"CompilerRuntime::initialize_klass_by_symbol\",                 \"_aot_initialize_klass_by_symbol\"},\n-        {\"CompilerRuntime::invocation_event\",                           \"_aot_invocation_event\"},\n-        {\"CompilerRuntime::backedge_event\",                             \"_aot_backedge_event\"},\n-\n-        {\"CompilerToVM::Data::dpow\", \"_aot_shared_runtime_dpow\"},\n-        {\"CompilerToVM::Data::dexp\", \"_aot_shared_runtime_dexp\"},\n-        {\"CompilerToVM::Data::dcos\", \"_aot_shared_runtime_dcos\"},\n-        {\"CompilerToVM::Data::dsin\", \"_aot_shared_runtime_dsin\"},\n-        {\"CompilerToVM::Data::dtan\", \"_aot_shared_runtime_dtan\"},\n-        {\"CompilerToVM::Data::dlog\", \"_aot_shared_runtime_dlog\"},\n-        {\"CompilerToVM::Data::dlog10\", \"_aot_shared_runtime_dlog10\"},\n-\n-        {\"StubRoutines::_jbyte_arraycopy\", \"_aot_stub_routines_jbyte_arraycopy\"},\n-        {\"StubRoutines::_jshort_arraycopy\", \"_aot_stub_routines_jshort_arraycopy\"},\n-        {\"StubRoutines::_jint_arraycopy\", \"_aot_stub_routines_jint_arraycopy\"},\n-        {\"StubRoutines::_jlong_arraycopy\", \"_aot_stub_routines_jlong_arraycopy\"},\n-        {\"StubRoutines::_oop_arraycopy\", \"_aot_stub_routines_oop_arraycopy\"},\n-        {\"StubRoutines::_oop_arraycopy_uninit\", \"_aot_stub_routines_oop_arraycopy_uninit\"},\n-\n-        {\"StubRoutines::_jbyte_disjoint_arraycopy\", \"_aot_stub_routines_jbyte_disjoint_arraycopy\"},\n-        {\"StubRoutines::_jshort_disjoint_arraycopy\", \"_aot_stub_routines_jshort_disjoint_arraycopy\"},\n-        {\"StubRoutines::_jint_disjoint_arraycopy\", \"_aot_stub_routines_jint_disjoint_arraycopy\"},\n-        {\"StubRoutines::_jlong_disjoint_arraycopy\", \"_aot_stub_routines_jlong_disjoint_arraycopy\"},\n-        {\"StubRoutines::_oop_disjoint_arraycopy\", \"_aot_stub_routines_oop_disjoint_arraycopy\"},\n-        {\"StubRoutines::_oop_disjoint_arraycopy_uninit\", \"_aot_stub_routines_oop_disjoint_arraycopy_uninit\"},\n-\n-        {\"StubRoutines::_arrayof_jbyte_arraycopy\", \"_aot_stub_routines_arrayof_jbyte_arraycopy\"},\n-        {\"StubRoutines::_arrayof_jshort_arraycopy\", \"_aot_stub_routines_arrayof_jshort_arraycopy\"},\n-        {\"StubRoutines::_arrayof_jint_arraycopy\", \"_aot_stub_routines_arrayof_jint_arraycopy\"},\n-        {\"StubRoutines::_arrayof_jlong_arraycopy\", \"_aot_stub_routines_arrayof_jlong_arraycopy\"},\n-        {\"StubRoutines::_arrayof_oop_arraycopy\", \"_aot_stub_routines_arrayof_oop_arraycopy\"},\n-        {\"StubRoutines::_arrayof_oop_arraycopy_uninit\", \"_aot_stub_routines_arrayof_oop_arraycopy_uninit\"},\n-\n-        {\"StubRoutines::_arrayof_jbyte_disjoint_arraycopy\", \"_aot_stub_routines_arrayof_jbyte_disjoint_arraycopy\"},\n-        {\"StubRoutines::_arrayof_jshort_disjoint_arraycopy\", \"_aot_stub_routines_arrayof_jshort_disjoint_arraycopy\"},\n-        {\"StubRoutines::_arrayof_jint_disjoint_arraycopy\", \"_aot_stub_routines_arrayof_jint_disjoint_arraycopy\"},\n-        {\"StubRoutines::_arrayof_jlong_disjoint_arraycopy\", \"_aot_stub_routines_arrayof_jlong_disjoint_arraycopy\"},\n-        {\"StubRoutines::_arrayof_oop_disjoint_arraycopy\", \"_aot_stub_routines_arrayof_oop_disjoint_arraycopy\"},\n-        {\"StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit\", \"_aot_stub_routines_arrayof_oop_disjoint_arraycopy_uninit\"},\n-\n-        {\"StubRoutines::_unsafe_arraycopy\", \"_aot_stub_routines_unsafe_arraycopy\"},\n-\n-        {\"StubRoutines::_checkcast_arraycopy\", \"_aot_stub_routines_checkcast_arraycopy\"},\n-\n-        {\"StubRoutines::_generic_arraycopy\", \"_aot_stub_routines_generic_arraycopy\"},\n-\n-        {\"StubRoutines::_aescrypt_encryptBlock\", \"_aot_stub_routines_aescrypt_encryptBlock\"},\n-        {\"StubRoutines::_aescrypt_decryptBlock\", \"_aot_stub_routines_aescrypt_decryptBlock\"},\n-        {\"StubRoutines::_cipherBlockChaining_encryptAESCrypt\", \"_aot_stub_routines_cipherBlockChaining_encryptAESCrypt\"},\n-        {\"StubRoutines::_cipherBlockChaining_decryptAESCrypt\", \"_aot_stub_routines_cipherBlockChaining_decryptAESCrypt\"},\n-        {\"StubRoutines::_electronicCodeBook_encryptAESCrypt\", \"_aot_stub_routines_electronicCodeBook_encryptAESCrypt\"},\n-        {\"StubRoutines::_electronicCodeBook_decryptAESCrypt\", \"_aot_stub_routines_electronicCodeBook_decryptAESCrypt\"},\n-        {\"StubRoutines::_updateBytesCRC32\", \"_aot_stub_routines_update_bytes_crc32\"},\n-        {\"StubRoutines::_crc_table_adr\", \"_aot_stub_routines_crc_table_adr\"},\n-\n-        {\"StubRoutines::_sha1_implCompress\", \"_aot_stub_routines_sha1_implCompress\" },\n-        {\"StubRoutines::_sha1_implCompressMB\", \"_aot_stub_routines_sha1_implCompressMB\" },\n-        {\"StubRoutines::_sha256_implCompress\", \"_aot_stub_routines_sha256_implCompress\" },\n-        {\"StubRoutines::_sha256_implCompressMB\", \"_aot_stub_routines_sha256_implCompressMB\" },\n-        {\"StubRoutines::_sha512_implCompress\", \"_aot_stub_routines_sha512_implCompress\" },\n-        {\"StubRoutines::_sha512_implCompressMB\", \"_aot_stub_routines_sha512_implCompressMB\" },\n-        {\"StubRoutines::_multiplyToLen\", \"_aot_stub_routines_multiplyToLen\" },\n-\n-        {\"StubRoutines::_counterMode_AESCrypt\", \"_aot_stub_routines_counterMode_AESCrypt\" },\n-        {\"StubRoutines::_ghash_processBlocks\", \"_aot_stub_routines_ghash_processBlocks\" },\n-        {\"StubRoutines::_base64_encodeBlock\", \"_aot_stub_routines_base64_encodeBlock\" },\n-        {\"StubRoutines::_crc32c_table_addr\", \"_aot_stub_routines_crc32c_table_addr\" },\n-        {\"StubRoutines::_updateBytesCRC32C\", \"_aot_stub_routines_updateBytesCRC32C\" },\n-        {\"StubRoutines::_updateBytesAdler32\", \"_aot_stub_routines_updateBytesAdler32\" },\n-        {\"StubRoutines::_squareToLen\", \"_aot_stub_routines_squareToLen\" },\n-        {\"StubRoutines::_mulAdd\", \"_aot_stub_routines_mulAdd\" },\n-        {\"StubRoutines::_montgomeryMultiply\", \"_aot_stub_routines_montgomeryMultiply\" },\n-        {\"StubRoutines::_montgomerySquare\", \"_aot_stub_routines_montgomerySquare\" },\n-        {\"StubRoutines::_vectorizedMismatch\", \"_aot_stub_routines_vectorizedMismatch\" },\n-        {\"StubRoutines::_bigIntegerRightShiftWorker\", \"_aot_stub_routines_bigIntegerRightShiftWorker\" },\n-        {\"StubRoutines::_bigIntegerLeftShiftWorker\", \"_aot_stub_routines_bigIntegerLeftShiftWorker\" },\n-\n-        {\"StubRoutines::_throw_delayed_StackOverflowError_entry\", \"_aot_stub_routines_throw_delayed_StackOverflowError_entry\" },\n-\n-\n-        {\"os::javaTimeMillis\", \"_aot_os_javaTimeMillis\"},\n-        {\"os::javaTimeNanos\", \"_aot_os_javaTimeNanos\"},\n-\n-        {\"JVMCIRuntime::monitorenter\", \"_aot_jvmci_runtime_monitorenter\"},\n-        {\"JVMCIRuntime::monitorexit\", \"_aot_jvmci_runtime_monitorexit\"},\n-        {\"JVMCIRuntime::object_notify\", \"_aot_object_notify\"},\n-        {\"JVMCIRuntime::object_notifyAll\", \"_aot_object_notifyAll\"},\n-        {\"JVMCIRuntime::log_object\", \"_aot_jvmci_runtime_log_object\"},\n-        {\"JVMCIRuntime::log_printf\", \"_aot_jvmci_runtime_log_printf\"},\n-        {\"JVMCIRuntime::vm_message\", \"_aot_jvmci_runtime_vm_message\"},\n-        {\"JVMCIRuntime::new_instance\", \"_aot_jvmci_runtime_new_instance\"},\n-        {\"JVMCIRuntime::new_array\", \"_aot_jvmci_runtime_new_array\"},\n-        {\"JVMCIRuntime::new_multi_array\", \"_aot_jvmci_runtime_new_multi_array\"},\n-        {\"JVMCIRuntime::dynamic_new_instance\", \"_aot_jvmci_runtime_dynamic_new_instance\"},\n-        {\"JVMCIRuntime::dynamic_new_array\", \"_aot_jvmci_runtime_dynamic_new_array\"},\n-        {\"JVMCIRuntime::new_instance_or_null\", \"_aot_jvmci_runtime_new_instance_or_null\"},\n-        {\"JVMCIRuntime::new_array_or_null\", \"_aot_jvmci_runtime_new_array_or_null\"},\n-        {\"JVMCIRuntime::new_multi_array_or_null\", \"_aot_jvmci_runtime_new_multi_array_or_null\"},\n-        {\"JVMCIRuntime::dynamic_new_instance_or_null\", \"_aot_jvmci_runtime_dynamic_new_instance_or_null\"},\n-        {\"JVMCIRuntime::dynamic_new_array_or_null\", \"_aot_jvmci_runtime_dynamic_new_array_or_null\"},\n-        {\"JVMCIRuntime::log_primitive\", \"_aot_jvmci_runtime_log_primitive\"},\n-        {\"JVMCIRuntime::validate_object\", \"_aot_jvmci_runtime_validate_object\"},\n-        {\"JVMCIRuntime::write_barrier_pre\", \"_aot_jvmci_runtime_write_barrier_pre\"},\n-        {\"JVMCIRuntime::identity_hash_code\", \"_aot_jvmci_runtime_identity_hash_code\"},\n-        {\"JVMCIRuntime::write_barrier_post\", \"_aot_jvmci_runtime_write_barrier_post\"},\n-        {\"JVMCIRuntime::thread_is_interrupted\", \"_aot_jvmci_runtime_thread_is_interrupted\"},\n-        {\"JVMCIRuntime::exception_handler_for_pc\", \"_aot_jvmci_runtime_exception_handler_for_pc\"},\n-        {\"JVMCIRuntime::test_deoptimize_call_int\", \"_aot_jvmci_runtime_test_deoptimize_call_int\"},\n-\n-        {\"JVMCIRuntime::throw_and_post_jvmti_exception\",      \"_aot_jvmci_runtime_throw_and_post_jvmti_exception\"},\n-        {\"JVMCIRuntime::throw_klass_external_name_exception\", \"_aot_jvmci_runtime_throw_klass_external_name_exception\"},\n-        {\"JVMCIRuntime::throw_class_cast_exception\",          \"_aot_jvmci_runtime_throw_class_cast_exception\"},\n-\n-        {\"JVMCIRuntime::vm_error\", \"_aot_jvmci_runtime_vm_error\"}\n-    };\n-    //@formatter:on\n-\n-    static {\n-        for (String[] entry : map) {\n-            functionNamesToAOTSymbols.put(entry[0], entry[1]);\n-        }\n-    }\n-\n-    /**\n-     * Allocates a {@code BinaryContainer} object whose content will be generated in a file with the\n-     * prefix {@code prefix}. It also initializes internal code container, symbol table and\n-     * relocation tables.\n-     *\n-     * @param graalOptions\n-     */\n-    public BinaryContainer(OptionValues graalOptions, GraalHotSpotVMConfig graalHotSpotVMConfig, GraphBuilderConfiguration graphBuilderConfig, int gc, String jvmVersion) {\n-        this.graalOptions = graalOptions;\n-\n-        this.codeSegmentSize = graalHotSpotVMConfig.codeSegmentSize;\n-        if (codeSegmentSize < 1 || codeSegmentSize > 1024) {\n-            throw new InternalError(\"codeSegmentSize is not in range [1, 1024] bytes: (\" + codeSegmentSize + \"), update JPECoffRelocObject\");\n-        }\n-        if ((codeSegmentSize & (codeSegmentSize - 1)) != 0) {\n-            throw new InternalError(\"codeSegmentSize is not power of 2: (\" + codeSegmentSize + \"), update JPECoffRelocObject\");\n-        }\n-\n-        this.codeEntryAlignment = graalHotSpotVMConfig.codeEntryAlignment;\n-\n-        this.threadLocalHandshakes = graalHotSpotVMConfig.useThreadLocalPolling;\n-\n-        // Section unique name is limited to 8 characters due to limitation on Windows.\n-        // Name could be longer but only first 8 characters are stored on Windows.\n-\n-        // read only, code\n-        codeContainer = new CodeContainer(\".text\", this);\n-\n-        // read only, info\n-        headerContainer = new HeaderContainer(jvmVersion, new ReadOnlyDataContainer(\".header\", this));\n-        configContainer = new ReadOnlyDataContainer(\".config\", this);\n-        metaspaceNamesContainer = new ReadOnlyDataContainer(\".meta.names\", this);\n-        methodsOffsetsContainer = new ReadOnlyDataContainer(\".meth.offsets\", this);\n-        klassesOffsetsContainer = new ReadOnlyDataContainer(\".kls.offsets\", this);\n-        klassesDependenciesContainer = new ReadOnlyDataContainer(\".kls.dependencies\", this);\n-\n-        stubsOffsetsContainer = new ReadOnlyDataContainer(\".stubs.offsets\", this);\n-        codeSegmentsContainer = new ReadOnlyDataContainer(\".code.segments\", this);\n-        constantDataContainer = new ReadOnlyDataContainer(\".meth.constdata\", this);\n-        methodMetadataContainer = new ReadOnlyDataContainer(\".meth.metadata\", this);\n-\n-        // writable sections\n-        oopGotContainer = new ByteContainer(\".oop.got\", this);\n-        klassesGotContainer = new ByteContainer(\".kls.got\", this);\n-        countersGotContainer = new ByteContainer(\".cnt.got\", this);\n-        metadataGotContainer = new ByteContainer(\".meta.got\", this);\n-        methodStateContainer = new ByteContainer(\".meth.state\", this);\n-        extLinkageGOTContainer = new ByteContainer(\".got.linkage\", this);\n-\n-        addGlobalSymbols();\n-\n-        recordConfiguration(graalHotSpotVMConfig, graphBuilderConfig, gc);\n-    }\n-\n-    private void recordConfiguration(GraalHotSpotVMConfig graalHotSpotVMConfig, GraphBuilderConfiguration graphBuilderConfig, int gc) {\n-        // @Checkstyle: stop\n-        // @formatter:off\n-        ArrayList<Boolean> booleanFlagsList = new ArrayList<>();\n-\n-        booleanFlagsList.addAll(Arrays.asList(graalHotSpotVMConfig.cAssertions, // Debug VM\n-                                              graalHotSpotVMConfig.useCompressedOops,\n-                                              graalHotSpotVMConfig.useCompressedClassPointers));\n-        if (JavaVersionUtil.JAVA_SPEC < 15) {\n-            // See JDK-8236224. FieldsAllocationStyle and CompactFields flags were removed in JDK15.\n-            booleanFlagsList.add(graalHotSpotVMConfig.compactFields);\n-        }\n-        booleanFlagsList.addAll(Arrays.asList(graalHotSpotVMConfig.useTLAB,\n-                                              graalHotSpotVMConfig.useBiasedLocking,\n-                                              TieredAOT.getValue(graalOptions),\n-                                              graalHotSpotVMConfig.enableContended,\n-                                              graalHotSpotVMConfig.restrictContended,\n-                                              graphBuilderConfig.omitAssertions()));\n-        if (JavaVersionUtil.JAVA_SPEC < 14) {\n-            // See JDK-8220049. Thread local handshakes are on by default since JDK14, the command line option has been removed.\n-            booleanFlagsList.add(graalHotSpotVMConfig.useThreadLocalPolling);\n-        }\n-\n-        ArrayList<Integer> intFlagsList = new ArrayList<>();\n-        intFlagsList.addAll(Arrays.asList(graalHotSpotVMConfig.getOopEncoding().getShift(),\n-                                          graalHotSpotVMConfig.getKlassEncoding().getShift(),\n-                                          graalHotSpotVMConfig.contendedPaddingWidth));\n-        if (JavaVersionUtil.JAVA_SPEC < 15) {\n-            // See JDK-8236224. FieldsAllocationStyle and CompactFields flags were removed in JDK15.\n-            intFlagsList.add(graalHotSpotVMConfig.fieldsAllocationStyle);\n-        }\n-        intFlagsList.addAll(Arrays.asList(1 << graalHotSpotVMConfig.logMinObjAlignment(),\n-                                          graalHotSpotVMConfig.codeSegmentSize,\n-                                          gc));\n-\n-        // @formatter:on\n-        // @Checkstyle: resume\n-\n-        byte[] booleanFlagsAsBytes = booleanListToByteArray(booleanFlagsList);\n-        int[] intFlags = intFlagsList.stream().mapToInt(i -> i).toArray();\n-        int size0 = configContainer.getByteStreamSize();\n-\n-        // @formatter:off\n-        int computedSize = booleanFlagsAsBytes.length * Byte.BYTES    + // size of boolean flags\n-                           intFlags.length            * Integer.BYTES + // size of int flags\n-                           Integer.BYTES;                               // size of the \"computedSize\"\n-\n-        configContainer.appendInt(computedSize).\n-                        appendInts(intFlags).\n-                        appendBytes(booleanFlagsAsBytes);\n-        // @formatter:on\n-\n-        int size = configContainer.getByteStreamSize() - size0;\n-        assert size == computedSize;\n-    }\n-\n-    private static byte[] booleanListToByteArray(ArrayList<Boolean> list) {\n-        byte[] byteArray = new byte[list.size()];\n-        for (int i = 0; i < list.size(); ++i) {\n-            byteArray[i] = boolToByte(list.get(i));\n-        }\n-        return byteArray;\n-    }\n-\n-    private static byte boolToByte(boolean flag) {\n-        return (byte) (flag ? 1 : 0);\n-    }\n-\n-    /**\n-     * Free some memory.\n-     */\n-    public void freeMemory() {\n-        offsetStringTable.clear();\n-        metaspaceNames.clear();\n-    }\n-\n-    /*\n-     * Global symbol names in generated DSO corresponding to VM's symbols. VM needs to look up this\n-     * symbol in DSO and link it with VM's corresponding symbol: store VM's symbol address or value\n-     * in the named GOT cell.\n-     */\n-\n-    public static String getCardTableAddressSymbolName() {\n-        return \"_aot_card_table_address\";\n-    }\n-\n-    public static String getHeapTopAddressSymbolName() {\n-        return \"_aot_heap_top_address\";\n-    }\n-\n-    public static String getHeapEndAddressSymbolName() {\n-        return \"_aot_heap_end_address\";\n-    }\n-\n-    public static String getCrcTableAddressSymbolName() {\n-        return \"_aot_stub_routines_crc_table_adr\";\n-    }\n-\n-    public static String getPollingPageSymbolName() {\n-        return \"_aot_polling_page\";\n-    }\n-\n-    public static String getResolveStaticEntrySymbolName() {\n-        return \"_resolve_static_entry\";\n-    }\n-\n-    public static String getResolveVirtualEntrySymbolName() {\n-        return \"_resolve_virtual_entry\";\n-    }\n-\n-    public static String getResolveOptVirtualEntrySymbolName() {\n-        return \"_resolve_opt_virtual_entry\";\n-    }\n-\n-    public static String getNarrowKlassBaseAddressSymbolName() {\n-        return \"_aot_narrow_klass_base_address\";\n-    }\n-\n-    public static String getNarrowOopBaseAddressSymbolName() {\n-        return \"_aot_narrow_oop_base_address\";\n-    }\n-\n-    public static String getLogOfHeapRegionGrainBytesSymbolName() {\n-        return \"_aot_log_of_heap_region_grain_bytes\";\n-    }\n-\n-    public static String getInlineContiguousAllocationSupportedSymbolName() {\n-        return \"_aot_inline_contiguous_allocation_supported\";\n-    }\n-\n-    public static String getVerifyOopsSymbolName() {\n-        return \"_aot_verify_oops\";\n-    }\n-\n-    public static String getVerifyOopCountAddressSymbolName() {\n-        return \"_aot_verify_oop_count_address\";\n-    }\n-\n-    public static String getVerifyOopBitsSymbolName() {\n-        return \"_aot_verify_oop_bits\";\n-    }\n-\n-    public static String getVerifyOopMaskSymbolName() {\n-        return \"_aot_verify_oop_mask\";\n-    }\n-\n-    public int getCodeSegmentSize() {\n-        return codeSegmentSize;\n-    }\n-\n-    public int getCodeEntryAlignment() {\n-        return codeEntryAlignment;\n-    }\n-\n-    public boolean getThreadLocalHandshakes() {\n-        return threadLocalHandshakes;\n-    }\n-\n-    /**\n-     * Gets the global AOT symbol associated with the function name.\n-     *\n-     * @param functionName function name\n-     * @return AOT symbol for the given function name, or null if there is no mapping.\n-     */\n-    public static String getAOTSymbolForVMFunctionName(String functionName) {\n-        return functionNamesToAOTSymbols.get(functionName);\n-    }\n-\n-    private void addGlobalSymbols() {\n-        // Create global symbols for all containers.\n-        createContainerSymbol(codeContainer);\n-        createContainerSymbol(configContainer);\n-        createContainerSymbol(methodsOffsetsContainer);\n-        createContainerSymbol(klassesOffsetsContainer);\n-        createContainerSymbol(klassesDependenciesContainer);\n-        createContainerSymbol(klassesGotContainer);\n-        createContainerSymbol(countersGotContainer);\n-        createContainerSymbol(metadataGotContainer);\n-        createContainerSymbol(methodStateContainer);\n-        createContainerSymbol(oopGotContainer);\n-        createContainerSymbol(metaspaceNamesContainer);\n-        createContainerSymbol(methodMetadataContainer);\n-        createContainerSymbol(stubsOffsetsContainer);\n-        createContainerSymbol(headerContainer.getContainer());\n-        createContainerSymbol(codeSegmentsContainer);\n-\n-        createGotSymbol(getResolveStaticEntrySymbolName());\n-        createGotSymbol(getResolveVirtualEntrySymbolName());\n-        createGotSymbol(getResolveOptVirtualEntrySymbolName());\n-        createGotSymbol(getCardTableAddressSymbolName());\n-        createGotSymbol(getHeapTopAddressSymbolName());\n-        createGotSymbol(getHeapEndAddressSymbolName());\n-        createGotSymbol(getNarrowKlassBaseAddressSymbolName());\n-        createGotSymbol(getNarrowOopBaseAddressSymbolName());\n-        createGotSymbol(getPollingPageSymbolName());\n-        createGotSymbol(getLogOfHeapRegionGrainBytesSymbolName());\n-        createGotSymbol(getInlineContiguousAllocationSupportedSymbolName());\n-        createGotSymbol(getVerifyOopsSymbolName());\n-        createGotSymbol(getVerifyOopCountAddressSymbolName());\n-        createGotSymbol(getVerifyOopBitsSymbolName());\n-        createGotSymbol(getVerifyOopMaskSymbolName());\n-\n-        for (HashMap.Entry<String, String> entry : functionNamesToAOTSymbols.entrySet()) {\n-            createGotSymbol(entry.getValue());\n-        }\n-    }\n-\n-    /**\n-     * Creates a global symbol of the form {@code \"A\" + container name}. Note, linker on Windows\n-     * does not allow names which start with '.'\n-     *\n-     * @param container container to create a symbol for\n-     */\n-    private static void createContainerSymbol(ByteContainer container) {\n-        container.createSymbol(0, Kind.OBJECT, Binding.GLOBAL, 0, \"A\" + container.getContainerName());\n-    }\n-\n-    /**\n-     * Creates a global GOT symbol of the form {@code \"got.\" + name}.\n-     *\n-     * @param name name for the GOT symbol\n-     */\n-    private void createGotSymbol(String name) {\n-        String s = \"got.\" + name;\n-        Symbol gotSymbol = extLinkageGOTContainer.createGotSymbol(s);\n-        extLinkageGOTContainer.createSymbol(gotSymbol.getOffset(), Kind.OBJECT, Binding.GLOBAL, 8, name);\n-    }\n-\n-    /**\n-     * Create a platform-specific binary file representing the content of the\n-     * {@code BinaryContainer} object.\n-     *\n-     * This method is called after creating and performing any necessary changes to the contents of\n-     * code stream, symbol tables and relocation tables is completely finalized\n-     *\n-     * @param outputFileName name of output file\n-     *\n-     * @throws IOException in case of file creation failure\n-     */\n-    public void createBinary(String outputFileName) throws IOException {\n-        String osName = System.getProperty(\"os.name\");\n-        switch (osName) {\n-            case \"Linux\":\n-                JELFRelocObject elfobj = JELFRelocObject.newInstance(this, outputFileName);\n-                elfobj.createELFRelocObject(relocationTable, symbolTable.values());\n-                break;\n-            case \"Mac OS X\":\n-                JMachORelocObject machobj = new JMachORelocObject(this, outputFileName);\n-                machobj.createMachORelocObject(relocationTable, symbolTable.values());\n-                break;\n-            default:\n-                if (osName.startsWith(\"Windows\")) {\n-                    JPECoffRelocObject pecoffobj = new JPECoffRelocObject(this, outputFileName);\n-                    pecoffobj.createPECoffRelocObject(relocationTable, symbolTable.values());\n-                    break;\n-                } else {\n-                    throw new InternalError(\"Unsupported platform: \" + osName);\n-                }\n-        }\n-    }\n-\n-    /**\n-     * Add symbol to the symbol table. If the existing symbol is undefined and the specified symbol\n-     * is not undefined, replace the existing symbol information with that specified.\n-     *\n-     * @param symInfo symbol information to be added\n-     */\n-    @Override\n-    public void addSymbol(Symbol symInfo) {\n-        if (symInfo.getName().startsWith(\"got.\") && !(symInfo instanceof GotSymbol)) {\n-            throw new InternalError(\"adding got. without being GotSymbol\");\n-        }\n-        if (symbolTable.containsKey(symInfo.getName())) {\n-            throw new InternalError(\"Symbol: \" + symInfo.getName() + \" already exists in SymbolTable\");\n-        } else {\n-            // System.out.println(\"# Symbol [\" + name + \"] [\" + symInfo.getValue() + \"] [\" +\n-            // symInfo.getSection().getContainerName() + \"] [\" + symInfo.getSize() + \"]\");\n-            symbolTable.put(symInfo.getName(), symInfo);\n-        }\n-    }\n-\n-    public boolean addStringOffset(String name, Integer offset) {\n-        offsetStringTable.put(name, offset);\n-        return true;\n-    }\n-\n-    /**\n-     * Add relocation entry for {@code symName}. Multiple relocation entries for a given symbol may\n-     * exist.\n-     *\n-     * @param info relocation information to be added\n-     */\n-    public void addRelocation(Relocation info) {\n-        // System.out.println(\"# Relocation [\" + info.getSymbol() + \"] [\" + info.getOffset() + \"] [\"\n-        // +\n-        // info.getSection().getContainerName() + \"] [\" + info.getSymbol().getName() + \"] [\" +\n-        // info.getSymbol().getOffset() + \" @ \" + info.getSymbol().getSection().getContainerName() +\n-        // \"]\");\n-        if (relocationTable.containsKey(info.getSymbol())) {\n-            relocationTable.get(info.getSymbol()).add(info);\n-        } else if (uniqueRelocationTable.containsKey(info.getSymbol())) {\n-            // promote\n-            ArrayList<Relocation> list = new ArrayList<>(2);\n-            list.add(uniqueRelocationTable.get(info.getSymbol()));\n-            list.add(info);\n-            relocationTable.put(info.getSymbol(), list);\n-            uniqueRelocationTable.remove(info.getSymbol());\n-        } else {\n-            uniqueRelocationTable.put(info.getSymbol(), info);\n-        }\n-    }\n-\n-    /**\n-     * Get symbol with name {@code symName}.\n-     *\n-     * @param symName name of symbol for which symbol table information is being queried\n-     * @return success or failure of insertion operation\n-     */\n-    @Override\n-    public Symbol getSymbol(String symName) {\n-        return symbolTable.get(symName);\n-    }\n-\n-    @Override\n-    public Symbol createSymbol(int offset, Kind kind, Binding binding, int size, String name) {\n-        if (kind != Kind.NATIVE_FUNCTION) {\n-            throw new UnsupportedOperationException(\"Must be external functions: \" + name);\n-        }\n-        Symbol symbol = new Symbol(offset, kind, binding, null, size, name);\n-        addSymbol(symbol);\n-        return symbol;\n-    }\n-\n-    /**\n-     * Get offset in got section with name {@code symName}.\n-     *\n-     * @param name for which String table information is being queried\n-     * @return success or failure of insertion operation\n-     */\n-    public Integer getStringOffset(String name) {\n-        return offsetStringTable.get(name);\n-    }\n-\n-    /**\n-     * Insert {@code targetCode} to code stream with {@code size} at {@code offset}.\n-     *\n-     * @param targetCode byte array of native code\n-     * @param offset offset at which {@code targetCode} is to be inserted\n-     * @param size size of {@code targetCode}\n-     */\n-    private static void appendBytes(ByteContainer byteContainer, byte[] targetCode, int offset, int size) {\n-        byteContainer.appendBytes(targetCode, offset, size);\n-    }\n-\n-    public void appendCodeBytes(byte[] targetCode, int offset, int size) {\n-        appendBytes(codeContainer, targetCode, offset, size);\n-    }\n-\n-    public void appendIntToCode(int value) {\n-        codeContainer.appendInt(value);\n-    }\n-\n-    public int appendExtLinkageGotBytes(byte[] bytes, int offset, int size) {\n-        int startOffset = extLinkageGOTContainer.getByteStreamSize();\n-        appendBytes(extLinkageGOTContainer, bytes, offset, size);\n-        return startOffset;\n-    }\n-\n-    public void addMetadataGotEntry(int offset) {\n-        metadataGotContainer.appendLong(offset);\n-    }\n-\n-    public int addMetaspaceName(String name) {\n-        Integer value = metaspaceNames.get(name);\n-        if (value != null) {\n-            return value.intValue();\n-        }\n-        // Get the current length of the stubsNameContainer\n-        // align on 8-byte boundary\n-        int nameOffset = alignUp(metaspaceNamesContainer, 8);\n-\n-        try {\n-            // Add the name of the symbol to the .stubs.names section\n-            // Modify them to sequence of utf8 strings with length:\n-            // \"<u2_size>Ljava/lang/ThreadGroup;<u2_size>addUnstarted<u2_size>()V\"\n-            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-            DataOutputStream out = new DataOutputStream(bout);\n-            int len = name.length();\n-            if (name.startsWith(\"Stub\")) { // Stub\n-                out.writeUTF(name);\n-            } else { // Method or Klass\n-                int parenthesesIndex = name.lastIndexOf('(', len - 1);\n-                if (parenthesesIndex > 0) {  // Method name\n-                    int dotIndex = name.lastIndexOf('.', parenthesesIndex - 1);\n-                    assert dotIndex > 0 : \"method's full name should have '.' : \" + name;\n-                    String klassName = name.substring(0, dotIndex);\n-                    out.writeUTF(klassName);\n-                    String methodName = name.substring(dotIndex + 1, parenthesesIndex);\n-                    out.writeUTF(methodName);\n-                    String signature = name.substring(parenthesesIndex, len);\n-                    out.writeUTF(signature);\n-                } else {\n-                    out.writeUTF(name); // Klass\n-                }\n-            }\n-            out.writeShort(0); // Terminate by 0.\n-            byte[] b = bout.toByteArray();\n-            metaspaceNamesContainer.appendBytes(b, 0, b.length);\n-\n-            metaspaceNames.put(name, nameOffset);\n-            return nameOffset;\n-        } catch (IOException e) {\n-            throw new InternalError(\"Failed to append bytes to stubs sections\", e);\n-        }\n-    }\n-\n-    /**\n-     * Add oop symbol by as follows. Extend the oop.got section with another slot for the VM to\n-     * patch.\n-     *\n-     * @param oopName name of the oop symbol\n-     */\n-    public Integer addOopSymbol(String oopName) {\n-        Integer oopGotOffset = getStringOffset(oopName);\n-        if (oopGotOffset != null) {\n-            return oopGotOffset;\n-        }\n-        return newOopSymbol(oopName);\n-    }\n-\n-    private Integer newOopSymbol(String oopName) {\n-        // Reference to String resolution (ldc).\n-        int offset = oopGotContainer.getByteStreamSize();\n-        String gotName = \"got.ldc.\" + offset;\n-        Symbol relocationSymbol = oopGotContainer.createGotSymbol(gotName);\n-\n-        if (offset != relocationSymbol.getOffset()) {\n-            throw new InternalError(\"offset must equal! (\" + offset + \" vs \" + relocationSymbol.getOffset());\n-        }\n-\n-        addStringOffset(oopName, relocationSymbol.getOffset());\n-        return relocationSymbol.getOffset();\n-    }\n-\n-    public int addCountersSymbol(String metaspaceName) {\n-        String gotName = \"got.\" + metaspaceName;\n-        Symbol relocationSymbol = getGotSymbol(gotName);\n-        int metaspaceOffset = -1;\n-        if (relocationSymbol == null) {\n-            // Add slots when asked in the .metaspace.got section:\n-            countersGotContainer.createGotSymbol(gotName);\n-        }\n-        return metaspaceOffset;\n-    }\n-\n-    public Symbol getGotSymbol(String name) {\n-        assert name.startsWith(\"got.\");\n-        return symbolTable.get(name);\n-    }\n-\n-    /**\n-     * Add klass symbol by as follows. - Adding the symbol name to the metaspace.names section - Add\n-     * the offset of the name in metaspace.names to metaspace.offsets - Extend the klasses.got\n-     * section with another slot for the VM to patch\n-     *\n-     * @param klassName name of the metaspace symbol\n-     * @return the got offset in the klasses.got of the metaspace symbol\n-     */\n-    public int addTwoSlotKlassSymbol(String klassName) {\n-        String gotName = \"got.\" + klassName;\n-        Symbol previous = getGotSymbol(gotName);\n-        assert previous == null : \"should be called only once for: \" + klassName;\n-        // Add slots when asked in the .metaspace.got section:\n-        // First slot\n-        String gotInitName = \"got.init.\" + klassName;\n-        GotSymbol slot1Symbol = klassesGotContainer.createGotSymbol(gotInitName);\n-        GotSymbol slot2Symbol = klassesGotContainer.createGotSymbol(gotName);\n-\n-        slot1Symbol.getIndex(); // check alignment and ignore result\n-        // Get the index (offset/8) to the got in the .metaspace.got section\n-        return slot2Symbol.getIndex();\n-    }\n-\n-    public static int addMethodsCount(int count, ReadOnlyDataContainer container) {\n-        return appendInt(count, container);\n-    }\n-\n-    private static int appendInt(int count, ReadOnlyDataContainer container) {\n-        int offset = container.getByteStreamSize();\n-        container.appendInt(count);\n-        return offset;\n-    }\n-\n-    /**\n-     * Add constant data as follows. - Adding the data to the meth.constdata section\n-     *\n-     * @param data\n-     * @param alignment\n-     * @return the offset in the meth.constdata of the data\n-     */\n-    public int addConstantData(byte[] data, int alignment) {\n-        // Get the current length of the metaspaceNameContainer\n-        int constantDataOffset = alignUp(constantDataContainer, alignment);\n-        constantDataContainer.appendBytes(data, 0, data.length);\n-        alignUp(constantDataContainer, alignment); // Post alignment\n-        return constantDataOffset;\n-    }\n-\n-    public static int alignUp(ByteContainer container, int alignment) {\n-        if (Integer.bitCount(alignment) != 1) {\n-            throw new IllegalArgumentException(\"Must be a power of 2\");\n-        }\n-        int offset = container.getByteStreamSize();\n-        int aligned = (offset + (alignment - 1)) & -alignment;\n-        if (aligned < offset || (aligned & (alignment - 1)) != 0) {\n-            throw new RuntimeException(\"Error aligning: \" + offset + \" -> \" + aligned);\n-        }\n-        if (aligned != offset) {\n-            int nullArraySz = aligned - offset;\n-            byte[] nullArray = new byte[nullArraySz];\n-            container.appendBytes(nullArray, 0, nullArraySz);\n-            offset = aligned;\n-        }\n-        return offset;\n-    }\n-\n-    public void addCodeSegments(int start, int end) {\n-        assert (start % codeSegmentSize) == 0 : \"not aligned code\";\n-        int currentOffset = codeSegmentsContainer.getByteStreamSize();\n-        int offset = start / codeSegmentSize;\n-        int emptySize = offset - currentOffset;\n-        // add empty segments if needed\n-        if (emptySize > 0) {\n-            byte[] emptyArray = new byte[emptySize];\n-            for (int i = 0; i < emptySize; i++) {\n-                emptyArray[i] = (byte) 0xff;\n-            }\n-            appendBytes(codeSegmentsContainer, emptyArray, 0, emptySize);\n-        }\n-        int alignedEnd = (end + (codeSegmentSize - 1)) & -codeSegmentSize;\n-        int segmentsCount = (alignedEnd / codeSegmentSize) - offset;\n-        byte[] segments = new byte[segmentsCount];\n-        int idx = 0;\n-        for (int i = 0; i < segmentsCount; i++) {\n-            segments[i] = (byte) idx;\n-            idx = (idx == 0xfe) ? 1 : (idx + 1);\n-        }\n-        appendBytes(codeSegmentsContainer, segments, 0, segmentsCount);\n-    }\n-\n-    public ByteContainer getExtLinkageGOTContainer() {\n-        return extLinkageGOTContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getMethodMetadataContainer() {\n-        return methodMetadataContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getMetaspaceNamesContainer() {\n-        return metaspaceNamesContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getMethodsOffsetsContainer() {\n-        return methodsOffsetsContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getKlassesOffsetsContainer() {\n-        return klassesOffsetsContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getKlassesDependenciesContainer() {\n-        return klassesDependenciesContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getStubsOffsetsContainer() {\n-        return stubsOffsetsContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getCodeSegmentsContainer() {\n-        return codeSegmentsContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getConstantDataContainer() {\n-        return constantDataContainer;\n-    }\n-\n-    public ByteContainer getKlassesGotContainer() {\n-        return klassesGotContainer;\n-    }\n-\n-    public ByteContainer getCountersGotContainer() {\n-        return countersGotContainer;\n-    }\n-\n-    public ByteContainer getMetadataGotContainer() {\n-        return metadataGotContainer;\n-    }\n-\n-    public ByteContainer getMethodStateContainer() {\n-        return methodStateContainer;\n-    }\n-\n-    public ByteContainer getOopGotContainer() {\n-        return oopGotContainer;\n-    }\n-\n-    public CodeContainer getCodeContainer() {\n-        return codeContainer;\n-    }\n-\n-    public ReadOnlyDataContainer getConfigContainer() {\n-        return configContainer;\n-    }\n-\n-    public Map<Symbol, Relocation> getUniqueRelocationTable() {\n-        return uniqueRelocationTable;\n-    }\n-\n-    public HeaderContainer getHeaderContainer() {\n-        return headerContainer;\n-    }\n-\n-}"
  },
  {
    "sha": "a45329ca49580a5a0be2f5516a8449bd646a520c",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/ByteContainer.java",
    "status": "removed",
    "additions": 0,
    "deletions": 261,
    "changes": 261,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/ByteContainer.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/ByteContainer.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/ByteContainer.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,261 +0,0 @@\n-/*\n- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat;\n-\n-import jdk.tools.jaotc.binformat.Symbol.Binding;\n-import jdk.tools.jaotc.binformat.Symbol.Kind;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.util.Arrays;\n-\n-/**\n- * Base class that represents content of all sections with byte-level granularity. The ByteContainer\n- * class is backed by a ByteArrayOutputStream. This class supports writing all desired byte content\n- * to the container using the method {@code appendBytes} and accessing the byte array using the\n- * method {@code getByteArray}.\n- *\n- * The method {@code putIntAt} updates the content of {@code contentBytes}. Changes are not\n- * reflected in {@code contentStream}.\n- */\n-public class ByteContainer implements Container {\n-    /**\n-     * {@code ByteBuffer} representation of {@code BinaryContainer}.\n-     */\n-    private ByteBuffer contentBytes;\n-\n-    /**\n-     * {@code ByteArrayoutputStream} to which all appends are done.\n-     */\n-    private ByteArrayOutputStream contentStream;\n-\n-    /**\n-     * Boolean to indicate if contentBytes was modified.\n-     */\n-    private boolean bufferModified;\n-\n-    /**\n-     * Boolean to indicate if this section contains any relocations.\n-     */\n-    private boolean hasRelocations;\n-\n-    /**\n-     * Name of this container, used as section name.\n-     */\n-    private String containerName;\n-    private final SymbolTable symbolTable;\n-\n-    /**\n-     * Contains a unique id.\n-     */\n-    private int sectionId = -1;\n-\n-    /**\n-     * Construct a {@code ByteContainer} object.\n-     */\n-    public ByteContainer(String containerName, SymbolTable symbolTable) {\n-        this.containerName = containerName;\n-        this.symbolTable = symbolTable;\n-        this.contentBytes = null;\n-        this.bufferModified = false;\n-        this.hasRelocations = false;\n-        this.contentStream = new ByteArrayOutputStream();\n-    }\n-\n-    /**\n-     * Update byte buffer to reflect the current contents of byte stream.\n-     *\n-     * @throws InternalError throws {@code InternalError} if buffer byte array was modified\n-     */\n-    private void updateByteBuffer() {\n-        if (!bufferModified) {\n-            contentBytes = ByteBuffer.wrap(contentStream.toByteArray());\n-            // Default byte order of ByteBuffer is BIG_ENDIAN.\n-            // Set it appropriately\n-            this.contentBytes.order(ByteOrder.nativeOrder());\n-        } else {\n-            throw new InternalError(\"Backing byte buffer no longer in sync with byte stream\");\n-        }\n-    }\n-\n-    /**\n-     * Get the byte array of {@code ByteContainer}.\n-     *\n-     * @return byte array\n-     * @throws InternalError throws {@code InternalError} if buffer byte array was modified\n-     */\n-    public byte[] getByteArray() {\n-        if (!bufferModified) {\n-            updateByteBuffer();\n-        }\n-        return contentBytes.array();\n-    }\n-\n-    /**\n-     * Append to byte stream. It is an error to append to stream if the byte buffer version is\n-     * changed.\n-     *\n-     * @param newBytes new content\n-     * @param off offset start offset in {@code newBytes}\n-     * @param len length of data to write\n-     * @throws InternalError throws {@code InternalError} if buffer byte array was modified\n-     */\n-    public ByteContainer appendBytes(byte[] newBytes, int off, int len) {\n-        if (bufferModified) {\n-            throw new InternalError(\"Backing byte buffer no longer in sync with byte stream\");\n-        }\n-        contentStream.write(newBytes, off, len);\n-        return this;\n-    }\n-\n-    public ByteContainer appendBytes(byte[] newBytes) {\n-        appendBytes(newBytes, 0, newBytes.length);\n-        return this;\n-    }\n-\n-    public ByteContainer appendInt(int i) {\n-        if (bufferModified) {\n-            throw new InternalError(\"Backing byte buffer no longer in sync with byte stream\");\n-        }\n-        ByteBuffer b = ByteBuffer.allocate(Integer.BYTES);\n-        b.order(ByteOrder.nativeOrder());\n-        b.putInt(i);\n-        byte[] result = b.array();\n-        contentStream.write(result, 0, result.length);\n-        return this;\n-    }\n-\n-    public ByteContainer appendInts(int[] newInts) {\n-        if (bufferModified) {\n-            throw new InternalError(\"Backing byte buffer no longer in sync with byte stream\");\n-        }\n-        ByteBuffer b = ByteBuffer.allocate(Integer.BYTES * newInts.length).order(ByteOrder.nativeOrder());\n-        Arrays.stream(newInts).forEach(i -> b.putInt(i));\n-        byte[] result = b.array();\n-        contentStream.write(result, 0, result.length);\n-        return this;\n-    }\n-\n-    public void appendLong(long l) {\n-        if (bufferModified) {\n-            throw new InternalError(\"Backing byte buffer no longer in sync with byte stream\");\n-        }\n-        ByteBuffer b = ByteBuffer.allocate(8);\n-        b.order(ByteOrder.nativeOrder());\n-        b.putLong(l);\n-        byte[] result = b.array();\n-        contentStream.write(result, 0, result.length);\n-    }\n-\n-    /**\n-     * Return the current size of byte stream backing the BinaryContainer.\n-     *\n-     * @return size of buffer stream\n-     */\n-    public int getByteStreamSize() {\n-        return contentStream.size();\n-    }\n-\n-    /**\n-     * Return the name of this container.\n-     *\n-     * @return string containing name\n-     */\n-    @Override\n-    public String getContainerName() {\n-        return containerName;\n-    }\n-\n-    /**\n-     * Modify the byte buffer version of the byte output stream. Note that after calling this method\n-     * all further updates to BinaryContainer will be out of sync with byte buffer content.\n-     *\n-     * @param index index of byte to be changed\n-     * @param value new value\n-     */\n-    public void putIntAt(int index, int value) {\n-        if (!bufferModified) {\n-            updateByteBuffer();\n-        }\n-        contentBytes.putInt(index, value);\n-        bufferModified = true;\n-    }\n-\n-    public void putLongAt(int index, long value) {\n-        if (!bufferModified) {\n-            updateByteBuffer();\n-        }\n-        contentBytes.putLong(index, value);\n-        bufferModified = true;\n-    }\n-\n-    public void setSectionId(int id) {\n-        if (sectionId != -1) {\n-            throw new InternalError(\"Assigning new sectionId (old: \" + sectionId + \", new: \" + id + \")\");\n-        }\n-        sectionId = id;\n-    }\n-\n-    @Override\n-    public int getSectionId() {\n-        if (sectionId == -1) {\n-            throw new InternalError(\"Using sectionId before assigned\");\n-        }\n-        return sectionId;\n-    }\n-\n-    public Symbol createSymbol(int offset, Kind kind, Binding binding, int size, String name) {\n-        Symbol symbol = new Symbol(offset, kind, binding, this, size, name);\n-        symbolTable.addSymbol(symbol);\n-        return symbol;\n-    }\n-\n-    public GotSymbol createGotSymbol(String name) {\n-        GotSymbol symbol = new GotSymbol(Kind.OBJECT, Binding.LOCAL, this, name);\n-        symbolTable.addSymbol(symbol);\n-        return symbol;\n-    }\n-\n-    public GotSymbol createGotSymbol(int offset, String name) {\n-        GotSymbol symbol = new GotSymbol(offset, Kind.OBJECT, Binding.LOCAL, this, name);\n-        symbolTable.addSymbol(symbol);\n-        return symbol;\n-    }\n-\n-    public void clear() {\n-        this.contentBytes = null;\n-        this.contentStream = null;\n-    }\n-\n-    public void setHasRelocations() {\n-        this.hasRelocations = true;\n-    }\n-\n-    public boolean hasRelocations() {\n-        return this.hasRelocations;\n-    }\n-}"
  },
  {
    "sha": "033a4f7f8a77beed045ddbeaab2e010f4c80f06d",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/GotSymbol.java",
    "status": "removed",
    "additions": 0,
    "deletions": 64,
    "changes": 64,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/GotSymbol.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/GotSymbol.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/GotSymbol.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,64 +0,0 @@\n-/*\n- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat;\n-\n-public final class GotSymbol extends Symbol {\n-\n-    private static final int GOT_SIZE = 8;\n-\n-    public int getIndex() {\n-        int offset = getOffset();\n-        assert (offset % GOT_SIZE) == 0 : \"got cells should be aligned: \" + offset;\n-        return offset / GOT_SIZE;\n-    }\n-\n-    /**\n-     * Create GOT symbol info.\n-     *\n-     * @param type type of the symbol (UNDEFINED, FUNC, etc)\n-     * @param binding binding of the symbol (LOCAL, GLOBAL, ...)\n-     * @param container section in which this symbol is \"defined\"\n-     * @param name name of the symbol\n-     */\n-    public GotSymbol(Kind type, Binding binding, ByteContainer container, String name) {\n-        this(container.getByteStreamSize(), type, binding, container, name);\n-        container.appendBytes(new byte[GOT_SIZE], 0, GOT_SIZE);\n-    }\n-\n-    /**\n-     * Create GOT symbol info.\n-     *\n-     * @param offset section offset for the defined symbol\n-     * @param type type of the symbol (UNDEFINED, FUNC, etc)\n-     * @param binding binding of the symbol (LOCAL, GLOBAL, ...)\n-     * @param sec section in which this symbol is \"defined\"\n-     * @param name name of the symbol\n-     */\n-    public GotSymbol(int offset, Kind type, Binding binding, ByteContainer sec, String name) {\n-        super(offset, type, binding, sec, GOT_SIZE, name);\n-    }\n-\n-}"
  },
  {
    "sha": "a04be4c739749f91bea5d66205dcfb00ad9fe35b",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/HeaderContainer.java",
    "status": "removed",
    "additions": 0,
    "deletions": 94,
    "changes": 94,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/HeaderContainer.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/HeaderContainer.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/HeaderContainer.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,94 +0,0 @@\n-/*\n- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-\n-public final class HeaderContainer {\n-\n-    private static final int CURRENT_VERSION = 1;\n-    private final ReadOnlyDataContainer container;\n-\n-    // int _version;\n-    // int _class_count;\n-    // int _method_count;\n-    // int _klasses_got_size;\n-    // int _metadata_got_size;\n-    // int _oop_got_size;\n-    // int _jvm_version_offset;\n-\n-    public HeaderContainer(String jvmVersion, ReadOnlyDataContainer container) {\n-        try {\n-            byte[] filler = new byte[4 * 7];\n-            container.appendBytes(filler);\n-\n-            // Store JVM version string at the end of header section.\n-            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-            DataOutputStream out = new DataOutputStream(bout);\n-            out.writeUTF(jvmVersion);\n-            out.writeShort(0); // Terminate by 0.\n-            byte[] b = bout.toByteArray();\n-            container.appendBytes(b, 0, b.length);\n-        } catch (IOException e) {\n-            throw new InternalError(\"Failed to append bytes to header section\", e);\n-        }\n-\n-        this.container = container;\n-        this.container.putIntAt(0 * 4, CURRENT_VERSION);\n-        this.container.putIntAt(6 * 4, 7 * 4); // JVM version string offset\n-    }\n-\n-    public String getContainerName() {\n-        return container.getContainerName();\n-    }\n-\n-    public ReadOnlyDataContainer getContainer() {\n-        return container;\n-    }\n-\n-    public void setClassesCount(int count) {\n-        this.container.putIntAt(1 * 4, count);\n-    }\n-\n-    public void setMethodsCount(int count) {\n-        this.container.putIntAt(2 * 4, count);\n-    }\n-\n-    public void setKlassesGotSize(int size) {\n-        this.container.putIntAt(3 * 4, size);\n-    }\n-\n-    public void setMetadataGotSize(int size) {\n-        this.container.putIntAt(4 * 4, size);\n-    }\n-\n-    public void setOopGotSize(int size) {\n-        this.container.putIntAt(5 * 4, size);\n-    }\n-\n-}"
  },
  {
    "sha": "a0c6c854ad6692148946187bd31a6cb0de0408b8",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/Relocation.java",
    "status": "removed",
    "additions": 0,
    "deletions": 97,
    "changes": 97,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/Relocation.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/Relocation.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/Relocation.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,97 +0,0 @@\n-/*\n- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat;\n-\n-public final class Relocation {\n-\n-    // @formatter:off (workaround for Eclipse formatting bug)\n-    public enum RelocType {\n-        UNDEFINED,\n-        JAVA_CALL_INDIRECT,\n-        JAVA_CALL_DIRECT,\n-        FOREIGN_CALL_INDIRECT_GOT, // Call to address in GOT cell\n-        STUB_CALL_DIRECT,\n-        METASPACE_GOT_REFERENCE,\n-        EXTERNAL_GOT_TO_PLT,\n-        EXTERNAL_PLT_TO_GOT\n-    }\n-    // @formatter:on\n-\n-    private final RelocType type;\n-\n-    /**\n-     * Byte offset from the beginning of the file affected by relocation.\n-     */\n-    private final int offset;\n-\n-    /**\n-     * Size of relocation.\n-     */\n-    private final int size;\n-\n-    /**\n-     * Symbol associated with this relocation.\n-     */\n-    private final Symbol symbol;\n-\n-    /**\n-     * Section this relocation entry modifies.\n-     */\n-    private final ByteContainer section;\n-\n-    public Relocation(int offset, RelocType type, int size, ByteContainer section, Symbol sym) {\n-        if (sym == null) {\n-            throw new InternalError(\"must have symbol\");\n-        }\n-        this.offset = offset;\n-        this.type = type;\n-        this.size = size;\n-        this.symbol = sym;\n-        this.section = section;\n-        section.setHasRelocations();\n-    }\n-\n-    public RelocType getType() {\n-        return type;\n-    }\n-\n-    public int getOffset() {\n-        return offset;\n-    }\n-\n-    public int getSize() {\n-        return size;\n-    }\n-\n-    public Symbol getSymbol() {\n-        return symbol;\n-    }\n-\n-    public ByteContainer getSection() {\n-        return section;\n-    }\n-\n-}"
  },
  {
    "sha": "fbc06235b06cd7dbb2711cd9507553ab0e07ddfe",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/Symbol.java",
    "status": "removed",
    "additions": 0,
    "deletions": 154,
    "changes": 154,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/Symbol.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/Symbol.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/Symbol.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,154 +0,0 @@\n-/*\n- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat;\n-\n-import java.util.Objects;\n-\n-public class Symbol {\n-\n-    // @formatter:off (workaround for Eclipse formatting bug)\n-    public enum Binding {\n-        UNDEFINED,\n-        LOCAL,\n-        GLOBAL\n-    }\n-\n-    public enum Kind {\n-        UNDEFINED,\n-        NATIVE_FUNCTION,\n-        JAVA_FUNCTION,\n-        OBJECT,\n-        NOTYPE\n-    }\n-    // @formatter:on\n-\n-    private final String name;\n-    private final int size;\n-    private final int offset;\n-    private final Binding binding;\n-    private final Kind kind;\n-\n-    private ByteContainer section;\n-    private NativeSymbol nativeSymbol;\n-\n-    /**\n-     * Create symbol info.\n-     *\n-     * @param offset section offset for the defined symbol\n-     * @param kind kind of the symbol (UNDEFINED, FUNC, etc)\n-     * @param binding binding of the symbol (LOCAL, GLOBAL, ...)\n-     * @param section section in which this symbol is \"defined\"\n-     * @param size size of the symbol\n-     * @param name name of the symbol\n-     */\n-\n-    public Symbol(int offset, Kind kind, Binding binding, ByteContainer section, int size, String name) {\n-        this.binding = binding;\n-        this.kind = kind;\n-        this.section = section;\n-        this.size = size;\n-        this.offset = offset;\n-        this.name = name;\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    public NativeSymbol getNativeSymbol() {\n-        return nativeSymbol;\n-    }\n-\n-    public void setNativeSymbol(NativeSymbol nativeSym) {\n-        this.nativeSymbol = nativeSym;\n-    }\n-\n-    public Binding getBinding() {\n-        return binding;\n-    }\n-\n-    public Kind getKind() {\n-        return kind;\n-    }\n-\n-    public int getSize() {\n-        return size;\n-    }\n-\n-    public ByteContainer getSection() {\n-        return section;\n-    }\n-\n-    public int getOffset() {\n-        return offset;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (this == obj) {\n-            return true;\n-        }\n-        if (!(obj instanceof Symbol)) {\n-            return false;\n-        }\n-        if (getClass() != obj.getClass()) {\n-            return false;\n-        }\n-\n-        Symbol symbol = (Symbol) obj;\n-\n-        if (size != symbol.size) {\n-            return false;\n-        }\n-        if (offset != symbol.offset) {\n-            return false;\n-        }\n-        if (!name.equals(symbol.name)) {\n-            return false;\n-        }\n-        if (binding != symbol.binding) {\n-            return false;\n-        }\n-        if (kind != symbol.kind) {\n-            return false;\n-        }\n-        return !(section != null ? !section.equals(symbol.section) : symbol.section != null);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = Objects.hash(name, binding, kind, section);\n-        result = 31 * result + size;\n-        result = 31 * result + offset;\n-        return result;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"[\" + name + \", \" + size + \", \" + offset + \", \" + binding + \", \" + kind + \", \" + section + \"]\";\n-    }\n-\n-}"
  },
  {
    "sha": "bd9c120ed3da128dc7afeef9773d3e8f3b0b7c9b",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/AArch64JELFRelocObject.java",
    "status": "removed",
    "additions": 0,
    "deletions": 118,
    "changes": 118,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/AArch64JELFRelocObject.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/AArch64JELFRelocObject.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/AArch64JELFRelocObject.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,118 +0,0 @@\n-/*\n- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.Relocation;\n-import jdk.tools.jaotc.binformat.Relocation.RelocType;\n-import jdk.tools.jaotc.binformat.Symbol;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Ehdr;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Rela;\n-\n-public class AArch64JELFRelocObject extends JELFRelocObject {\n-\n-    AArch64JELFRelocObject(BinaryContainer binContainer, String outputFileName) {\n-        super(binContainer, outputFileName);\n-    }\n-\n-    @Override\n-    void createRelocation(Symbol symbol, Relocation reloc, ElfRelocTable elfRelocTable) {\n-        RelocType relocType = reloc.getType();\n-\n-        int elfRelocType = getELFRelocationType(relocType);\n-        ElfSymbol sym = (ElfSymbol) symbol.getNativeSymbol();\n-        int symno = sym.getIndex();\n-        int sectindex = reloc.getSection().getSectionId();\n-        int offset = reloc.getOffset();\n-        int addend = 0;\n-\n-        switch (relocType) {\n-            case STUB_CALL_DIRECT:\n-            case JAVA_CALL_DIRECT: {\n-                break;\n-            }\n-            case EXTERNAL_PLT_TO_GOT:\n-                offset -= 16;\n-                elfRelocTable.createRelocationEntry(sectindex, offset, symno, Elf64_Rela.R_AARCH64_ADR_PREL_PG_HI21, addend);\n-                elfRelocTable.createRelocationEntry(sectindex, offset + 4, symno, Elf64_Rela.R_AARCH64_ADD_ABS_LO12_NC, addend);\n-                return;\n-\n-            case FOREIGN_CALL_INDIRECT_GOT: {\n-                break;\n-            }\n-            case METASPACE_GOT_REFERENCE: {\n-                offset -= 4;\n-\n-                elfRelocTable.createRelocationEntry(sectindex, offset, symno, Elf64_Rela.R_AARCH64_ADR_PREL_PG_HI21, addend);\n-                elfRelocTable.createRelocationEntry(sectindex, offset + 4, symno, Elf64_Rela.R_AARCH64_ADD_ABS_LO12_NC, addend);\n-                return;\n-            }\n-            // break;\n-            case JAVA_CALL_INDIRECT: {\n-                addend = -4;\n-                offset = offset + addend;\n-                break;\n-            }\n-            case EXTERNAL_GOT_TO_PLT: {\n-                // this is load time relocations\n-                break;\n-            }\n-            default:\n-                throw new InternalError(\"Unhandled relocation type: \" + relocType);\n-        }\n-\n-        elfRelocTable.createRelocationEntry(sectindex, offset, symno, elfRelocType, addend);\n-    }\n-\n-    int getELFRelocationType(RelocType relocType) {\n-        int elfRelocType = 0; // R_<ARCH>_NONE if #define'd to 0 for all values of ARCH\n-        switch (ElfTargetInfo.getElfArch()) {\n-            case Elf64_Ehdr.EM_AARCH64:\n-                // Return R_X86_64_* entries based on relocType\n-                if (relocType == RelocType.JAVA_CALL_DIRECT ||\n-                                relocType == RelocType.FOREIGN_CALL_INDIRECT_GOT) {\n-                    elfRelocType = Elf64_Rela.R_AARCH64_CALL26;\n-                } else if (relocType == RelocType.STUB_CALL_DIRECT) {\n-                    elfRelocType = Elf64_Rela.R_AARCH64_CALL26;\n-                } else if (relocType == RelocType.JAVA_CALL_INDIRECT) {\n-                    elfRelocType = Elf64_Rela.R_AARCH64_CALL26;\n-                } else if (relocType == RelocType.METASPACE_GOT_REFERENCE ||\n-                                relocType == RelocType.EXTERNAL_PLT_TO_GOT) {\n-                    elfRelocType = Elf64_Rela.R_AARCH64_NONE;\n-                } else if (relocType == RelocType.EXTERNAL_GOT_TO_PLT) {\n-                    elfRelocType = Elf64_Rela.R_AARCH64_ABS64;\n-                } else {\n-                    assert false : \"Unhandled relocation type: \" + relocType;\n-                }\n-                break;\n-\n-            default:\n-                System.out.println(\"Relocation Type mapping: Unhandled architecture: \" + ElfTargetInfo.getElfArch());\n-        }\n-        return elfRelocType;\n-    }\n-}"
  },
  {
    "sha": "876be2158fed56fc2c5d9ac2e9eed1ee197b651a",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/AMD64JELFRelocObject.java",
    "status": "removed",
    "additions": 0,
    "deletions": 111,
    "changes": 111,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/AMD64JELFRelocObject.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/AMD64JELFRelocObject.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/AMD64JELFRelocObject.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,111 +0,0 @@\n-/*\n- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.Relocation;\n-import jdk.tools.jaotc.binformat.Relocation.RelocType;\n-import jdk.tools.jaotc.binformat.Symbol;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Ehdr;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Rela;\n-\n-public class AMD64JELFRelocObject extends JELFRelocObject {\n-\n-    AMD64JELFRelocObject(BinaryContainer binContainer, String outputFileName) {\n-        super(binContainer, outputFileName);\n-    }\n-\n-    @Override\n-    protected void createRelocation(Symbol symbol, Relocation reloc, ElfRelocTable elfRelocTable) {\n-        RelocType relocType = reloc.getType();\n-\n-        int elfRelocType = getELFRelocationType(relocType);\n-        ElfSymbol sym = (ElfSymbol) symbol.getNativeSymbol();\n-        int symno = sym.getIndex();\n-        int sectindex = reloc.getSection().getSectionId();\n-        int offset = reloc.getOffset();\n-        int addend = 0;\n-\n-        switch (relocType) {\n-            case JAVA_CALL_DIRECT:\n-            case STUB_CALL_DIRECT:\n-            case FOREIGN_CALL_INDIRECT_GOT: {\n-                // Create relocation entry\n-                addend = -4; // Size in bytes of the patch location\n-                // Relocation should be applied at the location after call operand\n-                offset = offset + reloc.getSize() + addend;\n-                break;\n-            }\n-            case JAVA_CALL_INDIRECT:\n-            case METASPACE_GOT_REFERENCE:\n-            case EXTERNAL_PLT_TO_GOT: {\n-                addend = -4; // Size of 32-bit address of the GOT\n-                /*\n-                 * Relocation should be applied before the test instruction to the move instruction.\n-                 * reloc.getOffset() points to the test instruction after the instruction that loads\n-                 * the address of polling page. So set the offset appropriately.\n-                 */\n-                offset = offset + addend;\n-                break;\n-            }\n-            case EXTERNAL_GOT_TO_PLT: {\n-                // this is load time relocations\n-                break;\n-            }\n-            default:\n-                throw new InternalError(\"Unhandled relocation type: \" + relocType);\n-        }\n-        elfRelocTable.createRelocationEntry(sectindex, offset, symno, elfRelocType, addend);\n-    }\n-\n-    private static int getELFRelocationType(RelocType relocType) {\n-        int elfRelocType = 0; // R_<ARCH>_NONE if #define'd to 0 for all values of ARCH\n-        switch (ElfTargetInfo.getElfArch()) {\n-            case Elf64_Ehdr.EM_X86_64:\n-                // Return R_X86_64_* entries based on relocType\n-                if (relocType == RelocType.JAVA_CALL_DIRECT ||\n-                                relocType == RelocType.FOREIGN_CALL_INDIRECT_GOT) {\n-                    elfRelocType = Elf64_Rela.R_X86_64_PLT32;\n-                } else if (relocType == RelocType.STUB_CALL_DIRECT) {\n-                    elfRelocType = Elf64_Rela.R_X86_64_PC32;\n-                } else if (relocType == RelocType.JAVA_CALL_INDIRECT) {\n-                    elfRelocType = Elf64_Rela.R_X86_64_NONE;\n-                } else if (relocType == RelocType.METASPACE_GOT_REFERENCE ||\n-                                relocType == RelocType.EXTERNAL_PLT_TO_GOT) {\n-                    elfRelocType = Elf64_Rela.R_X86_64_PC32;\n-                } else if (relocType == RelocType.EXTERNAL_GOT_TO_PLT) {\n-                    elfRelocType = Elf64_Rela.R_X86_64_64;\n-                } else {\n-                    assert false : \"Unhandled relocation type: \" + relocType;\n-                }\n-                break;\n-\n-            default:\n-                System.out.println(\"Relocation Type mapping: Unhandled architecture: \" + ElfTargetInfo.getElfArch());\n-        }\n-        return elfRelocType;\n-    }\n-}"
  },
  {
    "sha": "60d131ecb5cc606c85b4e760852c36917c5c112a",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/Elf.java",
    "status": "removed",
    "additions": 0,
    "deletions": 277,
    "changes": 277,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/Elf.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/Elf.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/Elf.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,277 +0,0 @@\n-/*\n- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-//@Checkstyle: stop\n-//@formatter:off\n-\n-/**\n- * Support for the creation of Elf Object files. Current support is limited to 64 bit x86_64.\n- */\n-final class Elf {\n-    /**\n-     * Elf64_Ehdr structure defines.\n-     */\n-    enum Elf64_Ehdr {\n-               e_ident( 0,16),\n-                e_type(16, 2),\n-             e_machine(18, 2),\n-             e_version(20, 4),\n-               e_entry(24, 8),\n-               e_phoff(32, 8),\n-               e_shoff(40, 8),\n-               e_flags(48, 4),\n-              e_ehsize(52, 2),\n-           e_phentsize(54, 2),\n-               e_phnum(56, 2),\n-           e_shentsize(58, 2),\n-               e_shnum(60, 2),\n-            e_shstrndx(62, 2);\n-\n-        final int off;\n-        final int sz;\n-\n-        Elf64_Ehdr(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 64;\n-\n-        /**\n-         * Elf64_Ehdr defines\n-         */\n-\n-        /**\n-         * e_ident\n-         */\n-        static final int  EI_MAG0        = 0;\n-        static final byte ELFMAG0        = 0x7f;\n-        static final int  EI_MAG1        = 1;\n-        static final byte ELFMAG1        = 0x45;\n-        static final int  EI_MAG2        = 2;\n-        static final byte ELFMAG2        = 0x4c;\n-        static final int  EI_MAG3        = 3;\n-        static final byte ELFMAG3        = 0x46;\n-        static final int  EI_CLASS       = 4;\n-        static final byte ELFCLASS64     = 0x2;\n-\n-        static final int  EI_DATA        = 5;\n-        static final byte ELFDATA2LSB    = 0x1;\n-\n-        static final int  EI_VERSION     = 6;\n-        static final byte EV_CURRENT     = 0x1;\n-\n-        static final int  EI_OSABI       = 7;\n-        static final byte ELFOSABI_NONE  = 0x0;\n-\n-        /**\n-         * e_type\n-         */\n-        static final char ET_REL         = 0x1;\n-\n-        /**\n-         * e_machine\n-         */\n-        static final char EM_NONE        = 0;\n-        static final char EM_X86_64      = 62;\n-        static final char EM_AARCH64     = 183;\n-\n-    }\n-\n-    /**\n-     * Elf64_Shdr structure defines.\n-     */\n-    enum Elf64_Shdr {\n-               sh_name( 0, 4),\n-               sh_type( 4, 4),\n-              sh_flags( 8, 8),\n-               sh_addr(16, 8),\n-             sh_offset(24, 8),\n-               sh_size(32, 8),\n-               sh_link(40, 4),\n-               sh_info(44, 4),\n-          sh_addralign(48, 8),\n-            sh_entsize(56, 8);\n-\n-        final int off;\n-        final int sz;\n-\n-        Elf64_Shdr(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 64;\n-\n-        /**\n-         * Elf64_Shdr defines\n-         */\n-\n-        /**\n-         * sh_type\n-         */\n-        static final int SHT_PROGBITS   = 0x1;\n-        static final int SHT_SYMTAB     = 0x2;\n-        static final int SHT_STRTAB     = 0x3;\n-        static final int SHT_RELA       = 0x4;\n-        static final int SHT_NOBITS     = 0x8;\n-        static final int SHT_REL        = 0x9;\n-\n-        static final byte SHN_UNDEF     = 0x0;\n-\n-        /**\n-         * sh_flag\n-         */\n-        static final int SHF_WRITE      = 0x1;\n-        static final int SHF_ALLOC      = 0x2;\n-        static final int SHF_EXECINSTR  = 0x4;\n-\n-    }\n-\n-    /**\n-     * Symbol table entry definitions\n-     *\n-     * Elf64_Sym structure defines\n-     */\n-    enum Elf64_Sym {\n-               st_name( 0, 4),\n-               st_info( 4, 1),\n-              st_other( 5, 1),\n-              st_shndx( 6, 2),\n-              st_value( 8, 8),\n-               st_size(16, 8);\n-\n-        final int off;\n-        final int sz;\n-\n-        Elf64_Sym(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 24;\n-\n-        /* ST_BIND is in bits 4-7 of st_info.  ST_TYPE is in low 4 bits */\n-        static final byte STB_LOCAL   = 0x0;\n-        static final byte STB_GLOBAL  = 0x1;\n-\n-        static final byte STT_NOTYPE  = 0x0;\n-        static final byte STT_OBJECT  = 0x1;\n-        static final byte STT_FUNC    = 0x2;\n-\n-        static byte ELF64_ST_INFO(byte bind, byte type) {\n-            return (byte)(((bind) << 4) + ((type) & 0xf));\n-        }\n-\n-    }\n-\n-    /**\n-     * Elf64_Rel structure defines.\n-     */\n-    enum Elf64_Rel {\n-              r_offset( 0, 8),\n-                r_info( 8, 8);\n-\n-        final int off;\n-        final int sz;\n-\n-        Elf64_Rel(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 16;\n-\n-        /**\n-         * Relocation types.\n-         */\n-\n-        static final int R_X86_64_NONE     = 0x0;\n-        static final int R_X86_64_64       = 0x1;\n-        static final int R_X86_64_PC32     = 0x2;\n-        static final int R_X86_64_PLT32    = 0x4;\n-        static final int R_X86_64_GOTPCREL = 0x9;\n-\n-        static final int R_AARCH64_NONE     = 256;\n-        static final int R_AARCH64_ABS64    = 257;\n-        static final int R_AARCH64_CALL26   = 283;\n-        static final int R_AARCH64_ADR_GOT_PAGE = 311;\n-        static final int R_AARCH64_LD64_GOT_LO12_NC = 312;\n-\n-        static final int R_AARCH64_MOVW_UABS_G0_NC = 264;\n-        static final int R_AARCH64_MOVW_UABS_G1_NC = 266;\n-        static final int R_AARCH64_MOVW_UABS_G2_NC = 268;\n-\n-        static final int R_AARCH64_ADR_PREL_PG_HI21 = 275;\n-        static final int R_AARCH64_ADD_ABS_LO12_NC = 277;\n-        static final int R_AARCH64_LDST64_ABS_LO12_NC = 286;\n-    }\n-\n-    /**\n-     * Elf64_Rela structure defines\n-     */\n-    enum Elf64_Rela {\n-              r_offset( 0, 8),\n-                r_info( 8, 8),\n-              r_addend(16, 8);\n-\n-        final int off;\n-        final int sz;\n-\n-        Elf64_Rela(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 24;\n-\n-        static final int R_X86_64_NONE     = 0x0;\n-        static final int R_X86_64_64       = 0x1;\n-        static final int R_X86_64_PC32     = 0x2;\n-        static final int R_X86_64_PLT32    = 0x4;\n-        static final int R_X86_64_GOTPCREL = 0x9;\n-\n-        static final int R_AARCH64_NONE     = 256;\n-        static final int R_AARCH64_ABS64    = 257;\n-        static final int R_AARCH64_CALL26   = 283;\n-        static final int R_AARCH64_ADR_GOT_PAGE = 311;\n-        static final int R_AARCH64_LD64_GOT_LO12_NC = 312;\n-\n-        static final int R_AARCH64_MOVW_UABS_G0_NC = 264;\n-        static final int R_AARCH64_MOVW_UABS_G1_NC = 266;\n-        static final int R_AARCH64_MOVW_UABS_G2_NC = 268;\n-\n-        static final int R_AARCH64_ADR_PREL_PG_HI21 = 275;\n-        static final int R_AARCH64_ADD_ABS_LO12_NC = 277;\n-        static final int R_AARCH64_LDST64_ABS_LO12_NC = 286;\n-\n-        static long ELF64_R_INFO(int symidx, int type) {\n-            return (((long) symidx << 32) + type);\n-        }\n-    }\n-}"
  },
  {
    "sha": "c16a9c23b4690ee06a68c5cc17dd13fa0658cf16",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfContainer.java",
    "status": "removed",
    "additions": 0,
    "deletions": 89,
    "changes": 89,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfContainer.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfContainer.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfContainer.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,89 +0,0 @@\n-/*\n- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-\n-final class ElfContainer {\n-\n-    private final File outputFile;\n-    private FileOutputStream outputStream;\n-    private long fileOffset;\n-\n-    ElfContainer(String fileName) {\n-\n-        outputFile = new File(fileName);\n-        if (outputFile.exists()) {\n-            outputFile.delete();\n-        }\n-\n-        try {\n-            outputStream = new FileOutputStream(outputFile);\n-        } catch (Exception e) {\n-            System.out.println(\"ElfContainer: Can't create file \" + fileName);\n-        }\n-        fileOffset = 0;\n-    }\n-\n-    void close() {\n-        try {\n-            outputStream.close();\n-        } catch (Exception e) {\n-            System.out.println(\"ElfContainer: close failed\");\n-        }\n-    }\n-\n-    void writeBytes(byte[] bytes) {\n-        if (bytes == null) {\n-            return;\n-        }\n-        try {\n-            outputStream.write(bytes);\n-        } catch (Exception e) {\n-            System.out.println(\"ElfContainer: writeBytes failed\");\n-        }\n-        fileOffset += bytes.length;\n-    }\n-\n-    // Write bytes to output file with up front alignment padding\n-    void writeBytes(byte[] bytes, int alignment) {\n-        if (bytes == null) {\n-            return;\n-        }\n-        try {\n-            // Pad to alignment\n-            while ((fileOffset & (alignment - 1)) != 0) {\n-                outputStream.write(0);\n-                fileOffset++;\n-            }\n-            outputStream.write(bytes);\n-        } catch (Exception e) {\n-            System.out.println(\"ElfContainer: writeBytes failed\");\n-        }\n-        fileOffset += bytes.length;\n-    }\n-}"
  },
  {
    "sha": "39e88d49f5147de55c45ba40186182d8c9126402",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfHeader.java",
    "status": "removed",
    "additions": 0,
    "deletions": 75,
    "changes": 75,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfHeader.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfHeader.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfHeader.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,75 +0,0 @@\n-/*\n- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Ehdr;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Shdr;\n-\n-final class ElfHeader {\n-    private final ByteBuffer header;\n-\n-    ElfHeader() {\n-        header = ElfByteBuffer.allocate(Elf64_Ehdr.totalsize);\n-\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_MAG0, Elf64_Ehdr.ELFMAG0);\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_MAG1, Elf64_Ehdr.ELFMAG1);\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_MAG2, Elf64_Ehdr.ELFMAG2);\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_MAG3, Elf64_Ehdr.ELFMAG3);\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_CLASS, Elf64_Ehdr.ELFCLASS64);\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_DATA, Elf64_Ehdr.ELFDATA2LSB);\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_VERSION, Elf64_Ehdr.EV_CURRENT);\n-        header.put(Elf64_Ehdr.e_ident.off + Elf64_Ehdr.EI_OSABI, Elf64_Ehdr.ELFOSABI_NONE);\n-\n-        header.putChar(Elf64_Ehdr.e_type.off, Elf64_Ehdr.ET_REL);\n-        header.putChar(Elf64_Ehdr.e_machine.off, ElfTargetInfo.getElfArch());\n-        header.putInt(Elf64_Ehdr.e_version.off, Elf64_Ehdr.EV_CURRENT);\n-        header.putChar(Elf64_Ehdr.e_ehsize.off, (char) Elf64_Ehdr.totalsize);\n-        header.putChar(Elf64_Ehdr.e_shentsize.off, (char) Elf64_Shdr.totalsize);\n-\n-    }\n-\n-    // Update header with file offset of first section\n-    void setSectionOff(int offset) {\n-        header.putLong(Elf64_Ehdr.e_shoff.off, offset);\n-    }\n-\n-    // Update header with the number of total sections\n-    void setSectionNum(int count) {\n-        header.putChar(Elf64_Ehdr.e_shnum.off, (char) count);\n-    }\n-\n-    // Update header with the section index containing the\n-    // string table for section names\n-    void setSectionStrNdx(int index) {\n-        header.putChar(Elf64_Ehdr.e_shstrndx.off, (char) index);\n-    }\n-\n-    byte[] getArray() {\n-        return header.array();\n-    }\n-}"
  },
  {
    "sha": "43407b342c297a176fe29ebf7a8a46516d08da4f",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfRelocEntry.java",
    "status": "removed",
    "additions": 0,
    "deletions": 47,
    "changes": 47,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfRelocEntry.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfRelocEntry.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfRelocEntry.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,47 +0,0 @@\n-/*\n- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Rela;\n-\n-final class ElfRelocEntry {\n-    private final ByteBuffer entry;\n-\n-    ElfRelocEntry(int offset, int symno, int type, int addend) {\n-\n-        entry = ElfByteBuffer.allocate(Elf64_Rela.totalsize);\n-\n-        entry.putLong(Elf64_Rela.r_offset.off, offset);\n-        entry.putLong(Elf64_Rela.r_info.off, Elf64_Rela.ELF64_R_INFO(symno, type));\n-        entry.putLong(Elf64_Rela.r_addend.off, addend);\n-    }\n-\n-    byte[] getArray() {\n-        return entry.array();\n-    }\n-}"
  },
  {
    "sha": "5cf13d5804f72720abfc9635ee4389a38007ec20",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfRelocTable.java",
    "status": "removed",
    "additions": 0,
    "deletions": 70,
    "changes": 70,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfRelocTable.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfRelocTable.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfRelocTable.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,70 +0,0 @@\n-/*\n- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Rela;\n-\n-final class ElfRelocTable {\n-    private final ArrayList<ArrayList<ElfRelocEntry>> relocEntries;\n-\n-    ElfRelocTable(int numsects) {\n-        relocEntries = new ArrayList<>(numsects);\n-        for (int i = 0; i < numsects; i++) {\n-            relocEntries.add(new ArrayList<ElfRelocEntry>());\n-        }\n-    }\n-\n-    void createRelocationEntry(int sectindex, int offset, int symno, int type, int addend) {\n-        ElfRelocEntry entry = new ElfRelocEntry(offset, symno, type, addend);\n-        relocEntries.get(sectindex).add(entry);\n-    }\n-\n-    int getNumRelocs(int sectionIndex) {\n-        return relocEntries.get(sectionIndex).size();\n-    }\n-\n-    // Return the relocation entries for a single section\n-    // or null if no entries added to section\n-    byte[] getRelocData(int sectionIndex) {\n-        ArrayList<ElfRelocEntry> entryList = relocEntries.get(sectionIndex);\n-\n-        if (entryList.size() == 0) {\n-            return null;\n-        }\n-        ByteBuffer relocData = ElfByteBuffer.allocate(entryList.size() * Elf64_Rela.totalsize);\n-\n-        // Copy each entry to a single ByteBuffer\n-        for (int i = 0; i < entryList.size(); i++) {\n-            ElfRelocEntry entry = entryList.get(i);\n-            relocData.put(entry.getArray());\n-        }\n-\n-        return (relocData.array());\n-    }\n-}"
  },
  {
    "sha": "67834e5278b9939e244b24ca40259dc90b76be3b",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfSection.java",
    "status": "removed",
    "additions": 0,
    "deletions": 157,
    "changes": 157,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfSection.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfSection.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfSection.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,157 +0,0 @@\n-/*\n- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Rel;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Rela;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Shdr;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Sym;\n-\n-final class ElfSection {\n-    private final String name;\n-    private final ByteBuffer section;\n-    private final byte[] data;\n-    private final boolean hasrelocations;\n-    private final int sectionIndex;\n-\n-    /**\n-     * String holding section name strings.\n-     */\n-    private static final StringBuilder sectNameTab = new StringBuilder();\n-\n-    /**\n-     * Keeps track of bytes in section string table since strTabContent.length() is number of chars,\n-     * not bytes.\n-     */\n-    private static int shStrTabNrOfBytes = 0;\n-\n-    ElfSection(String sectName, byte[] sectData, int sectFlags, int sectType,\n-                    boolean hasRelocations, int align, int sectIndex) {\n-\n-        section = ElfByteBuffer.allocate(Elf64_Shdr.totalsize);\n-        name = sectName;\n-        // Return all 0's for NULL section\n-        if (sectIndex == 0) {\n-            sectNameTab.append('\\0');\n-            shStrTabNrOfBytes += 1;\n-            data = null;\n-            hasrelocations = false;\n-            sectionIndex = 0;\n-            return;\n-        }\n-\n-        section.putInt(Elf64_Shdr.sh_name.off, shStrTabNrOfBytes);\n-        sectNameTab.append(sectName).append('\\0');\n-        shStrTabNrOfBytes += (sectName.getBytes().length + 1);\n-\n-        section.putInt(Elf64_Shdr.sh_type.off, sectType);\n-        section.putLong(Elf64_Shdr.sh_flags.off, sectFlags);\n-        section.putLong(Elf64_Shdr.sh_addr.off, 0);\n-        section.putLong(Elf64_Shdr.sh_offset.off, 0);\n-\n-        if (sectName.equals(\".shstrtab\")) {\n-            section.putLong(Elf64_Shdr.sh_size.off, shStrTabNrOfBytes);\n-            data = sectNameTab.toString().getBytes();\n-        } else {\n-            data = sectData;\n-            section.putLong(Elf64_Shdr.sh_size.off, sectData.length);\n-        }\n-\n-        section.putLong(Elf64_Shdr.sh_entsize.off, 0);\n-\n-        // Determine the entrysize\n-        // based on type of section\n-        switch (sectType) {\n-            case Elf64_Shdr.SHT_SYMTAB:\n-                section.putLong(Elf64_Shdr.sh_entsize.off, Elf64_Sym.totalsize);\n-                break;\n-            case Elf64_Shdr.SHT_RELA:\n-                section.putLong(Elf64_Shdr.sh_entsize.off, Elf64_Rela.totalsize);\n-                break;\n-            case Elf64_Shdr.SHT_REL:\n-                section.putLong(Elf64_Shdr.sh_entsize.off, Elf64_Rel.totalsize);\n-                break;\n-            default:\n-                break;\n-        }\n-        section.putLong(Elf64_Shdr.sh_addralign.off, align);\n-\n-        hasrelocations = hasRelocations;\n-        sectionIndex = sectIndex;\n-    }\n-\n-    String getName() {\n-        return name;\n-    }\n-\n-    long getSize() {\n-        return section.getLong(Elf64_Shdr.sh_size.off);\n-    }\n-\n-    int getDataAlign() {\n-        return ((int) section.getLong(Elf64_Shdr.sh_addralign.off));\n-    }\n-\n-    // Alignment requirements for the Elf64_Shdr structures\n-    static int getShdrAlign() {\n-        return (4);\n-    }\n-\n-    byte[] getArray() {\n-        return section.array();\n-    }\n-\n-    byte[] getDataArray() {\n-        return data;\n-    }\n-\n-    void setOffset(long offset) {\n-        section.putLong(Elf64_Shdr.sh_offset.off, offset);\n-    }\n-\n-    void setLink(int link) {\n-        section.putInt(Elf64_Shdr.sh_link.off, link);\n-    }\n-\n-    void setInfo(int info) {\n-        section.putInt(Elf64_Shdr.sh_info.off, info);\n-    }\n-\n-    long getOffset() {\n-        return (section.getLong(Elf64_Shdr.sh_offset.off));\n-    }\n-\n-    boolean hasRelocations() {\n-        return hasrelocations;\n-    }\n-\n-    int getSectionId() {\n-        return sectionIndex;\n-    }\n-\n-}"
  },
  {
    "sha": "7bf8e770425dae5e93f5110ba61e221aab2fdaea",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfSymbol.java",
    "status": "removed",
    "additions": 0,
    "deletions": 53,
    "changes": 53,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfSymbol.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfSymbol.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfSymbol.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,53 +0,0 @@\n-/*\n- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteBuffer;\n-\n-import jdk.tools.jaotc.binformat.NativeSymbol;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Sym;\n-\n-final class ElfSymbol extends NativeSymbol {\n-    private final ByteBuffer sym;\n-\n-    ElfSymbol(int symbolindex, int strindex, byte type, byte bind, byte sectindex, long offset, long size) {\n-        super(symbolindex);\n-        sym = ElfByteBuffer.allocate(Elf64_Sym.totalsize);\n-\n-        sym.putInt(Elf64_Sym.st_name.off, strindex);\n-        sym.put(Elf64_Sym.st_info.off, Elf64_Sym.ELF64_ST_INFO(bind, type));\n-        sym.put(Elf64_Sym.st_other.off, (byte) 0);\n-        // Section indexes start at 1 but we manage the index internally\n-        // as 0 relative\n-        sym.putChar(Elf64_Sym.st_shndx.off, (char) (sectindex));\n-        sym.putLong(Elf64_Sym.st_value.off, offset);\n-        sym.putLong(Elf64_Sym.st_size.off, size);\n-    }\n-\n-    byte[] getArray() {\n-        return sym.array();\n-    }\n-}"
  },
  {
    "sha": "0c175c2e1d3a5eae343997fd2231a8c7afce1e1e",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfSymtab.java",
    "status": "removed",
    "additions": 0,
    "deletions": 146,
    "changes": 146,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfSymtab.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfSymtab.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfSymtab.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,146 +0,0 @@\n-/*\n- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Sym;\n-\n-final class ElfSymtab {\n-\n-    private final ArrayList<ElfSymbol> localSymbols = new ArrayList<>();\n-    private final ArrayList<ElfSymbol> globalSymbols = new ArrayList<>();\n-\n-    /**\n-     * Number of symbols added.\n-     */\n-    private int symbolCount;\n-\n-    /**\n-     * String holding symbol table strings.\n-     */\n-    private final StringBuilder strTabContent = new StringBuilder();\n-\n-    /**\n-     * Keeps track of bytes in string table since strTabContent.length() is number of chars, not\n-     * bytes.\n-     */\n-    private int strTabNrOfBytes = 0;\n-\n-    ElfSymtab() {\n-        symbolCount = 0;\n-    }\n-\n-    ElfSymbol addSymbolEntry(String name, byte type, byte bind, byte secHdrIndex, long offset, long size) {\n-        // Get the current symbol index and append symbol name to string table.\n-        int index;\n-        ElfSymbol sym;\n-\n-        if (name.isEmpty()) {\n-            index = 0;\n-            strTabContent.append('\\0');\n-            strTabNrOfBytes += 1;\n-            sym = new ElfSymbol(symbolCount, index, type, bind, secHdrIndex, offset, size);\n-            localSymbols.add(sym);\n-        } else {\n-            // We can't trust strTabContent.length() since that is\n-            // chars (UTF16), keep track of bytes on our own.\n-            index = strTabNrOfBytes;\n-            // strTabContent.append(\"_\").append(name).append('\\0');\n-            strTabContent.append(name).append('\\0');\n-            // + 1 for null, + 1 for \"_\"\n-            // strTabNrOfBytes += (name.getBytes().length + 1 + 1);\n-            strTabNrOfBytes += (name.getBytes().length + 1);\n-\n-            sym = new ElfSymbol(symbolCount, index, type, bind, secHdrIndex, offset, size);\n-            if ((bind & Elf64_Sym.STB_GLOBAL) != 0) {\n-                globalSymbols.add(sym);\n-            } else {\n-                localSymbols.add(sym);\n-            }\n-        }\n-        symbolCount++;\n-        return (sym);\n-    }\n-\n-    // Update the symbol indexes once all symbols have been added.\n-    // This is required since we'll be reordering the symbols in the\n-    // file to be in the order of Local then global.\n-    void updateIndexes() {\n-        int index = 0;\n-\n-        // Update the local symbol indexes\n-        for (int i = 0; i < localSymbols.size(); i++) {\n-            ElfSymbol sym = localSymbols.get(i);\n-            sym.setIndex(index++);\n-        }\n-\n-        // Update the global symbol indexes\n-        for (int i = 0; i < globalSymbols.size(); i++) {\n-            ElfSymbol sym = globalSymbols.get(i);\n-            sym.setIndex(index++);\n-        }\n-    }\n-\n-    int getNumLocalSyms() {\n-        return localSymbols.size();\n-    }\n-\n-    int getNumGlobalSyms() {\n-        return globalSymbols.size();\n-    }\n-\n-    // Create a single byte array that contains the symbol table entries\n-    byte[] getSymtabArray() {\n-        ByteBuffer symtabData = ElfByteBuffer.allocate(symbolCount * Elf64_Sym.totalsize);\n-        byte[] retarray;\n-\n-        updateIndexes();\n-\n-        // Add the local symbols\n-        for (int i = 0; i < localSymbols.size(); i++) {\n-            ElfSymbol sym = localSymbols.get(i);\n-            byte[] arr = sym.getArray();\n-            symtabData.put(arr);\n-        }\n-        // Add the global symbols\n-        for (int i = 0; i < globalSymbols.size(); i++) {\n-            ElfSymbol sym = globalSymbols.get(i);\n-            byte[] arr = sym.getArray();\n-            symtabData.put(arr);\n-        }\n-        retarray = symtabData.array();\n-\n-        return (retarray);\n-    }\n-\n-    // Return the string table array\n-    byte[] getStrtabArray() {\n-        byte[] strs = strTabContent.toString().getBytes();\n-        return (strs);\n-    }\n-}"
  },
  {
    "sha": "478d0cfc923b23955c6921298b43cb720b8a67a9",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfTargetInfo.java",
    "status": "removed",
    "additions": 0,
    "deletions": 85,
    "changes": 85,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfTargetInfo.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfTargetInfo.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/ElfTargetInfo.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,85 +0,0 @@\n-/*\n- * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.nio.ByteOrder;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Ehdr;\n-\n-/**\n- * Class that abstracts MACH-O target details.\n- *\n- */\n-final class ElfTargetInfo {\n-    /**\n-     * Target architecture.\n-     */\n-    private static final char arch;\n-\n-    /**\n-     * Architecture endian-ness.\n-     */\n-    private static final int endian = Elf64_Ehdr.ELFDATA2LSB;\n-\n-    /**\n-     * Target OS string.\n-     */\n-    private static String osName;\n-\n-    static {\n-        // Find the target arch details\n-        String archStr = System.getProperty(\"os.arch\").toLowerCase();\n-        if (ByteOrder.nativeOrder() != ByteOrder.LITTLE_ENDIAN) {\n-            System.out.println(\"Only Little Endian byte order supported!\");\n-        }\n-\n-        if (archStr.equals(\"amd64\") || archStr.equals(\"x86_64\")) {\n-            arch = Elf64_Ehdr.EM_X86_64;\n-        } else if (archStr.equals(\"aarch64\")) {\n-            arch = Elf64_Ehdr.EM_AARCH64;\n-        } else {\n-            System.out.println(\"Unsupported architecture \" + archStr);\n-            arch = Elf64_Ehdr.EM_NONE;\n-        }\n-\n-        osName = System.getProperty(\"os.name\").toLowerCase();\n-        if (!osName.equals(\"linux\")) {\n-            System.out.println(\"Unsupported Operating System \" + osName);\n-            osName = \"Unknown\";\n-        }\n-    }\n-\n-    static char getElfArch() {\n-        return arch;\n-    }\n-\n-    static int getElfEndian() {\n-        return endian;\n-    }\n-\n-    static String getOsName() {\n-        return osName;\n-    }\n-}"
  },
  {
    "sha": "1dd6bc7dba847dd049bdf4538e5b69a53bf7ba37",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/JELFRelocObject.java",
    "status": "removed",
    "additions": 0,
    "deletions": 328,
    "changes": 328,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/JELFRelocObject.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/JELFRelocObject.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/elf/JELFRelocObject.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,328 +0,0 @@\n-/*\n- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat.elf;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.ByteContainer;\n-import jdk.tools.jaotc.binformat.CodeContainer;\n-import jdk.tools.jaotc.binformat.ReadOnlyDataContainer;\n-import jdk.tools.jaotc.binformat.Relocation;\n-import jdk.tools.jaotc.binformat.Symbol;\n-import jdk.tools.jaotc.binformat.Symbol.Binding;\n-import jdk.tools.jaotc.binformat.Symbol.Kind;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Ehdr;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Shdr;\n-import jdk.tools.jaotc.binformat.elf.Elf.Elf64_Sym;\n-\n-public abstract class JELFRelocObject {\n-\n-    private final BinaryContainer binContainer;\n-\n-    private final ElfContainer elfContainer;\n-\n-    private final int segmentSize;\n-\n-    protected JELFRelocObject(BinaryContainer binContainer, String outputFileName) {\n-        this.binContainer = binContainer;\n-        this.elfContainer = new ElfContainer(outputFileName);\n-        this.segmentSize = binContainer.getCodeSegmentSize();\n-    }\n-\n-    public static JELFRelocObject newInstance(BinaryContainer binContainer, String outputFileName) {\n-        String archStr = System.getProperty(\"os.arch\").toLowerCase();\n-        if (archStr.equals(\"amd64\") || archStr.equals(\"x86_64\")) {\n-            return new AMD64JELFRelocObject(binContainer, outputFileName);\n-        } else if (archStr.equals(\"aarch64\")) {\n-            return new AArch64JELFRelocObject(binContainer, outputFileName);\n-        }\n-        throw new InternalError(\"Unsupported platform: \" + archStr);\n-    }\n-\n-    private static ElfSection createByteSection(ArrayList<ElfSection> sections,\n-                    String sectName,\n-                    byte[] scnData,\n-                    boolean hasRelocs,\n-                    int align,\n-                    int scnFlags,\n-                    int scnType) {\n-\n-        ElfSection sect = new ElfSection(sectName, scnData, scnFlags, scnType,\n-                        hasRelocs, align, sections.size());\n-        // Add this section to our list\n-        sections.add(sect);\n-\n-        return (sect);\n-    }\n-\n-    private void createByteSection(ArrayList<ElfSection> sections,\n-                    ByteContainer c, int scnFlags) {\n-        ElfSection sect;\n-        boolean hasRelocs = c.hasRelocations();\n-        byte[] scnData = c.getByteArray();\n-\n-        int scnType = Elf64_Shdr.SHT_PROGBITS;\n-        boolean zeros = !hasRelocs;\n-        if (zeros) {\n-            for (byte b : scnData) {\n-                if (b != 0) {\n-                    zeros = false;\n-                    break;\n-                }\n-            }\n-            if (zeros) {\n-                scnType = Elf64_Shdr.SHT_NOBITS;\n-            }\n-        }\n-\n-        sect = createByteSection(sections, c.getContainerName(),\n-                        scnData, hasRelocs, segmentSize,\n-                        scnFlags, scnType);\n-        c.setSectionId(sect.getSectionId());\n-    }\n-\n-    private void createCodeSection(ArrayList<ElfSection> sections, CodeContainer c) {\n-        createByteSection(sections, c, Elf64_Shdr.SHF_ALLOC | Elf64_Shdr.SHF_EXECINSTR);\n-    }\n-\n-    private void createReadOnlySection(ArrayList<ElfSection> sections, ReadOnlyDataContainer c) {\n-        createByteSection(sections, c, Elf64_Shdr.SHF_ALLOC);\n-    }\n-\n-    private void createReadWriteSection(ArrayList<ElfSection> sections, ByteContainer c) {\n-        createByteSection(sections, c, Elf64_Shdr.SHF_ALLOC | Elf64_Shdr.SHF_WRITE);\n-    }\n-\n-    /**\n-     * Creates an ELF relocatable object.\n-     *\n-     * @param relocationTable\n-     * @param symbols\n-     * @throws IOException throws {@code IOException} as a result of file system access failures.\n-     */\n-    public void createELFRelocObject(Map<Symbol, List<Relocation>> relocationTable, Collection<Symbol> symbols) throws IOException {\n-        // Allocate ELF Header\n-        ElfHeader eh = new ElfHeader();\n-\n-        ArrayList<ElfSection> sections = new ArrayList<>();\n-\n-        // Create the null section\n-        createByteSection(sections, null, null, false, 1, 0, 0);\n-\n-        // Create text section\n-        createCodeSection(sections, binContainer.getCodeContainer());\n-        createReadOnlySection(sections, binContainer.getMetaspaceNamesContainer());\n-        createReadOnlySection(sections, binContainer.getKlassesOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getMethodsOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getKlassesDependenciesContainer());\n-        createReadOnlySection(sections, binContainer.getMethodMetadataContainer());\n-        createReadOnlySection(sections, binContainer.getStubsOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getHeaderContainer().getContainer());\n-        createReadOnlySection(sections, binContainer.getCodeSegmentsContainer());\n-        createReadOnlySection(sections, binContainer.getConstantDataContainer());\n-        createReadOnlySection(sections, binContainer.getConfigContainer());\n-        createReadWriteSection(sections, binContainer.getKlassesGotContainer());\n-        createReadWriteSection(sections, binContainer.getCountersGotContainer());\n-        createReadWriteSection(sections, binContainer.getMetadataGotContainer());\n-        createReadWriteSection(sections, binContainer.getOopGotContainer());\n-        createReadWriteSection(sections, binContainer.getMethodStateContainer());\n-        createReadWriteSection(sections, binContainer.getExtLinkageGOTContainer());\n-\n-        // Get ELF symbol data from BinaryContainer object's symbol tables\n-        ElfSymtab symtab = createELFSymbolTables(symbols);\n-\n-        // Create string table section and symbol table sections in\n-        // that order since symtab section needs to set the index of\n-        // strtab in sh_link field\n-        ElfSection strTabSection = createByteSection(sections, \".strtab\",\n-                        symtab.getStrtabArray(),\n-                        false, 1, 0,\n-                        Elf64_Shdr.SHT_STRTAB);\n-\n-        // Now create .symtab section with the symtab data constructed.\n-        // On Linux, sh_link of symtab contains the index of string table\n-        // its symbols reference and sh_info contains the index of first\n-        // non-local symbol\n-        ElfSection symTabSection = createByteSection(sections, \".symtab\",\n-                        symtab.getSymtabArray(),\n-                        false, 8, 0,\n-                        Elf64_Shdr.SHT_SYMTAB);\n-        symTabSection.setLink(strTabSection.getSectionId());\n-        symTabSection.setInfo(symtab.getNumLocalSyms());\n-\n-        ElfRelocTable elfRelocTable = createElfRelocTable(sections, relocationTable);\n-\n-        createElfRelocSections(sections, elfRelocTable, symTabSection.getSectionId());\n-\n-        // Now, finally, after creating all sections, create shstrtab section\n-        ElfSection shStrTabSection = createByteSection(sections, \".shstrtab\",\n-                        null, false, 1, 0,\n-                        Elf64_Shdr.SHT_STRTAB);\n-        eh.setSectionStrNdx(shStrTabSection.getSectionId());\n-\n-        // Update all section offsets and the Elf header section offset\n-        // Write the Header followed by the contents of each section\n-        // and then the section structures (section table).\n-        int fileOffset = Elf64_Ehdr.totalsize;\n-\n-        // and round it up\n-        fileOffset = (fileOffset + (sections.get(1).getDataAlign() - 1)) &\n-                        ~((sections.get(1).getDataAlign() - 1));\n-\n-        // Calc file offsets for section data skipping null section\n-        for (int i = 1; i < sections.size(); i++) {\n-            ElfSection sect = sections.get(i);\n-            fileOffset = (fileOffset + (sect.getDataAlign() - 1)) &\n-                            ~((sect.getDataAlign() - 1));\n-            sect.setOffset(fileOffset);\n-            fileOffset += sect.getSize();\n-        }\n-\n-        // Align the section table\n-        fileOffset = (fileOffset + (ElfSection.getShdrAlign() - 1)) &\n-                        ~((ElfSection.getShdrAlign() - 1));\n-\n-        // Update the Elf Header with the offset of the first Elf64_Shdr\n-        // and the number of sections.\n-        eh.setSectionOff(fileOffset);\n-        eh.setSectionNum(sections.size());\n-\n-        // Write out the Header\n-        elfContainer.writeBytes(eh.getArray());\n-\n-        // Write out each section contents skipping null section\n-        for (int i = 1; i < sections.size(); i++) {\n-            ElfSection sect = sections.get(i);\n-            elfContainer.writeBytes(sect.getDataArray(), sect.getDataAlign());\n-        }\n-\n-        // Write out the section table\n-        for (int i = 0; i < sections.size(); i++) {\n-            ElfSection sect = sections.get(i);\n-            elfContainer.writeBytes(sect.getArray(), ElfSection.getShdrAlign());\n-        }\n-\n-        elfContainer.close();\n-    }\n-\n-    /**\n-     * Construct ELF symbol data from BinaryContainer object's symbol tables. Both dynamic ELF\n-     * symbol table and ELF symbol table are created from BinaryContainer's symbol info.\n-     *\n-     * @param symbols\n-     */\n-    private static ElfSymtab createELFSymbolTables(Collection<Symbol> symbols) {\n-        ElfSymtab symtab = new ElfSymtab();\n-\n-        // First, create the initial null symbol. This is a local symbol.\n-        symtab.addSymbolEntry(\"\", (byte) 0, (byte) 0, Elf64_Shdr.SHN_UNDEF, 0, 0);\n-\n-        // Now create ELF symbol entries for all symbols.\n-        for (Symbol symbol : symbols) {\n-            // Get the index of section this symbol is defined in.\n-            int secHdrIndex = symbol.getSection().getSectionId();\n-            ElfSymbol elfSymbol = symtab.addSymbolEntry(symbol.getName(), getELFTypeOf(symbol), getELFBindOf(symbol), (byte) secHdrIndex, symbol.getOffset(), symbol.getSize());\n-            symbol.setNativeSymbol(elfSymbol);\n-        }\n-        return (symtab);\n-    }\n-\n-    private static byte getELFTypeOf(Symbol sym) {\n-        Kind kind = sym.getKind();\n-        if (kind == Symbol.Kind.NATIVE_FUNCTION || kind == Symbol.Kind.JAVA_FUNCTION) {\n-            return Elf64_Sym.STT_FUNC;\n-        } else if (kind == Symbol.Kind.OBJECT) {\n-            return Elf64_Sym.STT_OBJECT;\n-        }\n-        return Elf64_Sym.STT_NOTYPE;\n-    }\n-\n-    private static byte getELFBindOf(Symbol sym) {\n-        Binding binding = sym.getBinding();\n-        if (binding == Symbol.Binding.GLOBAL) {\n-            return Elf64_Sym.STB_GLOBAL;\n-        }\n-        return Elf64_Sym.STB_LOCAL;\n-    }\n-\n-    /**\n-     * Construct a Elf relocation table from BinaryContainer object's relocation tables.\n-     *\n-     * @param sections\n-     * @param relocationTable\n-     */\n-    private ElfRelocTable createElfRelocTable(ArrayList<ElfSection> sections,\n-                    Map<Symbol, List<Relocation>> relocationTable) {\n-\n-        ElfRelocTable elfRelocTable = new ElfRelocTable(sections.size());\n-        /*\n-         * For each of the symbols with associated relocation records, create a Elf relocation\n-         * entry.\n-         */\n-        for (Map.Entry<Symbol, List<Relocation>> entry : relocationTable.entrySet()) {\n-            List<Relocation> relocs = entry.getValue();\n-            Symbol symbol = entry.getKey();\n-\n-            for (Relocation reloc : relocs) {\n-                createRelocation(symbol, reloc, elfRelocTable);\n-            }\n-        }\n-\n-        for (Map.Entry<Symbol, Relocation> entry : binContainer.getUniqueRelocationTable().entrySet()) {\n-            createRelocation(entry.getKey(), entry.getValue(), elfRelocTable);\n-        }\n-\n-        return (elfRelocTable);\n-    }\n-\n-    private static void createElfRelocSections(ArrayList<ElfSection> sections,\n-                    ElfRelocTable elfRelocTable,\n-                    int symtabsectidx) {\n-\n-        // Grab count before we create new sections\n-        int count = sections.size();\n-\n-        for (int i = 0; i < count; i++) {\n-            if (elfRelocTable.getNumRelocs(i) > 0) {\n-                ElfSection sect = sections.get(i);\n-                String relname = \".rela\" + sect.getName();\n-                ElfSection relocSection = createByteSection(sections, relname,\n-                                elfRelocTable.getRelocData(i),\n-                                false, 8, 0, Elf64_Shdr.SHT_RELA);\n-                relocSection.setLink(symtabsectidx);\n-                relocSection.setInfo(sect.getSectionId());\n-            }\n-        }\n-    }\n-\n-    abstract void createRelocation(Symbol symbol, Relocation reloc, ElfRelocTable elfRelocTable);\n-\n-}"
  },
  {
    "sha": "e5f407cbce3dda7686a428e3471943e533de60e5",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/macho/JMachORelocObject.java",
    "status": "removed",
    "additions": 0,
    "deletions": 429,
    "changes": 429,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/macho/JMachORelocObject.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/macho/JMachORelocObject.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/macho/JMachORelocObject.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,429 +0,0 @@\n-/*\n- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-/*\n- *\n- * File Layout generated by JMachORelocObject\n- *\n- * MachO Header\n- * Load Commands\n- *   LC_SEGMENT_64\n- *    - Sections\n- *   LC_VERSION_MIN_MAX\n- *   LC_SYMTAB\n- *   LC_DYSYMTAB\n- * Section Data\n- * Relocation entries\n- * Symbol table\n- *\n- */\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-\n-import jdk.tools.jaotc.binformat.BinaryContainer;\n-import jdk.tools.jaotc.binformat.ByteContainer;\n-import jdk.tools.jaotc.binformat.CodeContainer;\n-import jdk.tools.jaotc.binformat.ReadOnlyDataContainer;\n-import jdk.tools.jaotc.binformat.Relocation;\n-import jdk.tools.jaotc.binformat.Relocation.RelocType;\n-import jdk.tools.jaotc.binformat.Symbol;\n-import jdk.tools.jaotc.binformat.Symbol.Kind;\n-import jdk.tools.jaotc.binformat.macho.MachO.dysymtab_command;\n-import jdk.tools.jaotc.binformat.macho.MachO.mach_header_64;\n-import jdk.tools.jaotc.binformat.macho.MachO.nlist_64;\n-import jdk.tools.jaotc.binformat.macho.MachO.reloc_info;\n-import jdk.tools.jaotc.binformat.macho.MachO.section_64;\n-import jdk.tools.jaotc.binformat.macho.MachO.segment_command_64;\n-import jdk.tools.jaotc.binformat.macho.MachO.symtab_command;\n-import jdk.tools.jaotc.binformat.macho.MachO.version_min_command;\n-\n-public class JMachORelocObject {\n-\n-    private final BinaryContainer binContainer;\n-\n-    private final MachOContainer machoContainer;\n-\n-    private final int segmentSize;\n-\n-    public JMachORelocObject(BinaryContainer binContainer, String outputFileName) {\n-        this.binContainer = binContainer;\n-        this.machoContainer = new MachOContainer(outputFileName);\n-        this.segmentSize = binContainer.getCodeSegmentSize();\n-    }\n-\n-    private void createByteSection(ArrayList<MachOSection> sections,\n-                    ByteContainer c, String sectName, String segName, int scnFlags) {\n-\n-        if (c.getByteArray().length == 0) {\n-            // System.out.println(\"Skipping creation of \" + sectName + \" section, no data\\n\");\n-        }\n-\n-        MachOSection sect = new MachOSection(sectName,\n-                        segName,\n-                        c.getByteArray(),\n-                        scnFlags,\n-                        c.hasRelocations(),\n-                        segmentSize);\n-        // Add this section to our list\n-        sections.add(sect);\n-\n-        // Record the section Id (0 relative)\n-        c.setSectionId(sections.size() - 1);\n-\n-        // TODO: Clear out code section data to allow for GC\n-        // c.clear();\n-    }\n-\n-    private void createCodeSection(ArrayList<MachOSection> sections, CodeContainer c) {\n-        createByteSection(sections, c, /* c.getContainerName() */ \"__text\", \"__TEXT\",\n-                        section_64.S_ATTR_PURE_INSTRUCTIONS |\n-                                        section_64.S_ATTR_SOME_INSTRUCTIONS);\n-    }\n-\n-    private void createReadOnlySection(ArrayList<MachOSection> sections, ReadOnlyDataContainer c) {\n-        createByteSection(sections, c, c.getContainerName(), \"__TEXT\",\n-                        section_64.S_ATTR_SOME_INSTRUCTIONS);\n-    }\n-\n-    private void createReadWriteSection(ArrayList<MachOSection> sections, ByteContainer c) {\n-        createByteSection(sections, c, c.getContainerName(), \"__DATA\", section_64.S_REGULAR);\n-    }\n-\n-    /**\n-     * Creates an MachO relocatable object.\n-     *\n-     * @param relocationTable\n-     * @param symbols\n-     * @throws IOException throws {@code IOException} as a result of file system access failures.\n-     */\n-    public void createMachORelocObject(Map<Symbol, List<Relocation>> relocationTable, Collection<Symbol> symbols) throws IOException {\n-        // Allocate MachO Header\n-        // with 4 load commands\n-        // LC_SEGMENT_64\n-        // LC_VERSION_MIN_MACOSX\n-        // LC_SYMTAB\n-        // LC_DYSYMTAB\n-\n-        MachOHeader mh = new MachOHeader();\n-\n-        ArrayList<MachOSection> sections = new ArrayList<>();\n-\n-        // Create Sections contained in the main Segment LC_SEGMENT_64\n-\n-        createCodeSection(sections, binContainer.getCodeContainer());\n-        createReadOnlySection(sections, binContainer.getMetaspaceNamesContainer());\n-        createReadOnlySection(sections, binContainer.getKlassesOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getMethodsOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getKlassesDependenciesContainer());\n-        createReadOnlySection(sections, binContainer.getMethodMetadataContainer());\n-        createReadOnlySection(sections, binContainer.getStubsOffsetsContainer());\n-        createReadOnlySection(sections, binContainer.getHeaderContainer().getContainer());\n-        createReadOnlySection(sections, binContainer.getCodeSegmentsContainer());\n-        createReadOnlySection(sections, binContainer.getConstantDataContainer());\n-        createReadOnlySection(sections, binContainer.getConfigContainer());\n-        createReadWriteSection(sections, binContainer.getKlassesGotContainer());\n-        createReadWriteSection(sections, binContainer.getCountersGotContainer());\n-        createReadWriteSection(sections, binContainer.getMetadataGotContainer());\n-        createReadWriteSection(sections, binContainer.getMethodStateContainer());\n-        createReadWriteSection(sections, binContainer.getOopGotContainer());\n-        createReadWriteSection(sections, binContainer.getExtLinkageGOTContainer());\n-\n-        // Update the Header sizeofcmds size.\n-        // This doesn't include the Header struct size\n-        mh.setCmdSizes(4, segment_command_64.totalsize +\n-                        (section_64.totalsize * sections.size()) +\n-                        version_min_command.totalsize +\n-                        symtab_command.totalsize +\n-                        dysymtab_command.totalsize);\n-\n-        // Initialize file offset for data past commands\n-        int fileOffset = mach_header_64.totalsize + mh.getCmdSize();\n-        // and round it up\n-        fileOffset = (fileOffset + (sections.get(0).getAlign() - 1)) & ~((sections.get(0).getAlign() - 1));\n-        long address = 0;\n-        int segmentOffset = fileOffset;\n-\n-        for (int i = 0; i < sections.size(); i++) {\n-            MachOSection sect = sections.get(i);\n-            fileOffset = (fileOffset + (sect.getAlign() - 1)) & ~((sect.getAlign() - 1));\n-            address = (address + (sect.getAlign() - 1)) & ~((sect.getAlign() - 1));\n-            sect.setOffset(fileOffset);\n-            sect.setAddr(address);\n-            fileOffset += sect.getSize();\n-            address += sect.getSize();\n-        }\n-\n-        // File size for Segment data\n-        int segSize = fileOffset - segmentOffset;\n-\n-        // Create the LC_SEGMENT_64 Segment which contains the MachOSections\n-        MachOSegment seg = new MachOSegment(segment_command_64.totalsize +\n-                        (section_64.totalsize * sections.size()),\n-                        segmentOffset,\n-                        segSize,\n-                        sections.size());\n-\n-        MachOVersion vers = new MachOVersion();\n-\n-        // Get symbol data from BinaryContainer object's symbol tables\n-        MachOSymtab symtab = createMachOSymbolTables(sections, symbols);\n-\n-        // Create LC_DYSYMTAB command\n-        MachODySymtab dysymtab = new MachODySymtab(symtab.getNumLocalSyms(),\n-                        symtab.getNumGlobalSyms(),\n-                        symtab.getNumUndefSyms());\n-\n-        // Create the Relocation Tables\n-        MachORelocTable machORelocs = createMachORelocTable(sections, relocationTable, symtab);\n-        // Calculate file offset for relocation data\n-        fileOffset = (fileOffset + (MachORelocTable.getAlign() - 1)) & ~((MachORelocTable.getAlign() - 1));\n-\n-        // Update relocation sizing information in each section\n-        for (int i = 0; i < sections.size(); i++) {\n-            MachOSection sect = sections.get(i);\n-            if (sect.hasRelocations()) {\n-                int nreloc = machORelocs.getNumRelocs(i);\n-                sect.setReloff(fileOffset);\n-                sect.setRelcount(nreloc);\n-                fileOffset += (nreloc * reloc_info.totalsize);\n-            }\n-        }\n-\n-        // Calculate and set file offset for symbol table data\n-        fileOffset = (fileOffset + (MachOSymtab.getAlign() - 1)) & ~((MachOSymtab.getAlign() - 1));\n-        symtab.setOffset(fileOffset);\n-\n-        // Write Out Header\n-        machoContainer.writeBytes(mh.getArray());\n-        // Write out first Segment\n-        machoContainer.writeBytes(seg.getArray());\n-        // Write out sections within first Segment\n-        for (int i = 0; i < sections.size(); i++) {\n-            MachOSection sect = sections.get(i);\n-            machoContainer.writeBytes(sect.getArray());\n-        }\n-\n-        // Write out LC_VERSION_MIN_MACOSX command\n-        machoContainer.writeBytes(vers.getArray());\n-\n-        // Write out LC_SYMTAB command\n-        symtab.calcSizes();\n-        machoContainer.writeBytes(symtab.getCmdArray());\n-\n-        // Write out LC_DYSYMTAB command\n-        machoContainer.writeBytes(dysymtab.getArray());\n-\n-        // Write out data associated with each Section\n-        for (int i = 0; i < sections.size(); i++) {\n-            MachOSection sect = sections.get(i);\n-            machoContainer.writeBytes(sect.getDataArray(), sect.getAlign());\n-        }\n-\n-        // Write out the relocation tables for all sections\n-        for (int i = 0; i < sections.size(); i++) {\n-            if (machORelocs.getNumRelocs(i) > 0) {\n-                machoContainer.writeBytes(machORelocs.getRelocData(i), MachORelocTable.getAlign());\n-            }\n-        }\n-\n-        // Write out data associated with LC_SYMTAB\n-        machoContainer.writeBytes(symtab.getDataArray(), MachOSymtab.getAlign());\n-\n-        machoContainer.close();\n-    }\n-\n-    /**\n-     * Construct MachO symbol data from BinaryContainer object's symbol tables. Both dynamic MachO\n-     * symbol table and MachO symbol table are created from BinaryContainer's symbol info.\n-     *\n-     * @param sections\n-     * @param symbols\n-     */\n-    private static MachOSymtab createMachOSymbolTables(ArrayList<MachOSection> sections,\n-                    Collection<Symbol> symbols) {\n-        MachOSymtab symtab = new MachOSymtab();\n-        // First, create the initial null symbol. This is a local symbol.\n-        symtab.addSymbolEntry(\"\", (byte) nlist_64.N_UNDF, (byte) 0, 0);\n-\n-        // Now create MachO symbol entries for all symbols.\n-        for (Symbol symbol : symbols) {\n-            int sectionId = symbol.getSection().getSectionId();\n-\n-            // Symbol offsets are relative to the section memory addr\n-            long sectionAddr = sections.get(sectionId).getAddr();\n-\n-            MachOSymbol machoSymbol = symtab.addSymbolEntry(symbol.getName(),\n-                            getMachOTypeOf(symbol),\n-                            (byte) sectionId,\n-                            symbol.getOffset() + sectionAddr);\n-            symbol.setNativeSymbol(machoSymbol);\n-        }\n-\n-        // Now that all symbols are enterred, update the\n-        // symbol indexes. This is necessary since they will\n-        // be reordered based on local, global and undefined.\n-        symtab.updateIndexes();\n-\n-        return (symtab);\n-    }\n-\n-    private static byte getMachOTypeOf(Symbol sym) {\n-        Kind kind = sym.getKind();\n-        byte type = nlist_64.N_UNDF;\n-\n-        // Global or Local\n-        if (sym.getBinding() == Symbol.Binding.GLOBAL) {\n-            type = nlist_64.N_EXT;\n-        }\n-        // If Function or Data, add section type\n-        if (kind == Symbol.Kind.NATIVE_FUNCTION ||\n-                        kind == Symbol.Kind.JAVA_FUNCTION ||\n-                        kind == Symbol.Kind.OBJECT) {\n-            type |= (nlist_64.N_SECT);\n-        }\n-\n-        return (type);\n-    }\n-\n-    /**\n-     * Construct a MachO relocation table from BinaryContainer object's relocation tables.\n-     *\n-     * @param sections\n-     * @param relocationTable\n-     * @param symtab\n-     */\n-    private MachORelocTable createMachORelocTable(ArrayList<MachOSection> sections,\n-                    Map<Symbol, List<Relocation>> relocationTable,\n-                    MachOSymtab symtab) {\n-\n-        MachORelocTable machORelocTable = new MachORelocTable(sections.size());\n-        /*\n-         * For each of the symbols with associated relocation records, create a MachO relocation\n-         * entry.\n-         */\n-        for (Map.Entry<Symbol, List<Relocation>> entry : relocationTable.entrySet()) {\n-            List<Relocation> relocs = entry.getValue();\n-            Symbol symbol = entry.getKey();\n-\n-            for (Relocation reloc : relocs) {\n-                createRelocation(symbol, reloc, machORelocTable);\n-            }\n-        }\n-\n-        for (Map.Entry<Symbol, Relocation> entry : binContainer.getUniqueRelocationTable().entrySet()) {\n-            createRelocation(entry.getKey(), entry.getValue(), machORelocTable);\n-        }\n-\n-        return (machORelocTable);\n-    }\n-\n-    private static void createRelocation(Symbol symbol, Relocation reloc, MachORelocTable machORelocTable) {\n-        RelocType relocType = reloc.getType();\n-\n-        int machORelocType = getMachORelocationType(relocType);\n-        MachOSymbol sym = (MachOSymbol) symbol.getNativeSymbol();\n-        int symno = sym.getIndex();\n-        int sectindex = reloc.getSection().getSectionId();\n-        int offset = reloc.getOffset();\n-        int pcrel = 0;\n-        int length = 0;\n-        int isextern = 1;\n-\n-        switch (relocType) {\n-            case JAVA_CALL_DIRECT:\n-            case STUB_CALL_DIRECT:\n-            case FOREIGN_CALL_INDIRECT_GOT: {\n-                // Create relocation entry\n-                int addend = -4; // Size in bytes of the patch location\n-                // Relocation should be applied at the location after call operand\n-                offset = offset + reloc.getSize() + addend;\n-                pcrel = 1;\n-                length = 2;\n-                break;\n-            }\n-            case JAVA_CALL_INDIRECT: {\n-                // Do nothing.\n-                return;\n-            }\n-            case METASPACE_GOT_REFERENCE:\n-            case EXTERNAL_PLT_TO_GOT: {\n-                int addend = -4; // Size of 32-bit address of the GOT\n-                /*\n-                 * Relocation should be applied before the test instruction to the move instruction.\n-                 * reloc.getOffset() points to the test instruction after the instruction that loads\n-                 * the address of polling page. So set the offset appropriately.\n-                 */\n-                offset = offset + addend;\n-                pcrel = 1;\n-                length = 2;\n-                break;\n-            }\n-            case EXTERNAL_GOT_TO_PLT: {\n-                // this is load time relocations\n-                pcrel = 0;\n-                length = 3;\n-                break;\n-            }\n-            default:\n-                throw new InternalError(\"Unhandled relocation type: \" + relocType);\n-        }\n-        machORelocTable.createRelocationEntry(sectindex, offset, symno,\n-                        pcrel, length, isextern,\n-                        machORelocType);\n-    }\n-\n-    private static int getMachORelocationType(RelocType relocType) {\n-        int machORelocType = 0;\n-        switch (MachOTargetInfo.getMachOArch()) {\n-            case mach_header_64.CPU_TYPE_X86_64:\n-                // Return X86_64_RELOC_* entries based on relocType\n-                if (relocType == RelocType.JAVA_CALL_DIRECT ||\n-                                relocType == RelocType.FOREIGN_CALL_INDIRECT_GOT) {\n-                    machORelocType = reloc_info.X86_64_RELOC_BRANCH;\n-                } else if (relocType == RelocType.STUB_CALL_DIRECT) {\n-                    machORelocType = reloc_info.X86_64_RELOC_BRANCH;\n-                } else if (relocType == RelocType.JAVA_CALL_INDIRECT) {\n-                    machORelocType = reloc_info.X86_64_RELOC_NONE;\n-                } else if (relocType == RelocType.METASPACE_GOT_REFERENCE ||\n-                                relocType == RelocType.EXTERNAL_PLT_TO_GOT) {\n-                    machORelocType = reloc_info.X86_64_RELOC_BRANCH;\n-                } else if (relocType == RelocType.EXTERNAL_GOT_TO_PLT) {\n-                    machORelocType = reloc_info.X86_64_RELOC_UNSIGNED;\n-                } else {\n-                    assert false : \"Unhandled relocation type: \" + relocType;\n-                }\n-                break;\n-            default:\n-                System.out.println(\"Relocation Type mapping: Unhandled architecture\");\n-        }\n-        return machORelocType;\n-    }\n-}"
  },
  {
    "sha": "e6da357c65f72e1df4a305891cfa79b4ed2310fe",
    "filename": "compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/macho/MachO.java",
    "status": "removed",
    "additions": 0,
    "deletions": 311,
    "changes": 311,
    "blob_url": "https://github.com/Nicholas282787728/graal/blob/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/macho/MachO.java",
    "raw_url": "https://github.com/Nicholas282787728/graal/raw/5682abb32a00f15b2960fef96309b4ce0984676d/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/macho/MachO.java",
    "contents_url": "https://api.github.com/repos/Nicholas282787728/graal/contents/compiler/src/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/macho/MachO.java?ref=5682abb32a00f15b2960fef96309b4ce0984676d",
    "patch": "@@ -1,311 +0,0 @@\n-/*\n- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package jdk.tools.jaotc.binformat.macho;\n-\n-//@formatter:off\n-//@Checkstyle: stop\n-\n-/**\n- *\n- * Support for the creation of Mach-o Object files. Current support is limited to 64 bit x86_64.\n- *\n- * File Format Overview:\n- *\n- *   mach_header\n- *   load_commands\n- *      Typical Mac OSX 64-bit object files have these 4 load_commands\n- *      (LC_SEGMENT_64, LC_SYMTAB, LC_VERSIN_MIN_MACOSX, LC_DYSYMTAB)\n- *   Segments corresponding to load_commands\n- *      (which each include multiple Sections)\n- */\n-\n-final class MachO {\n-\n-    /**\n-     * mach_header_64 structure defines\n-     */\n-    enum mach_header_64 {\n-                 magic( 0, 4),\n-               cputype( 4, 4),\n-            cpusubtype( 8, 4),\n-              filetype(12, 4),\n-                 ncmds(16, 4),\n-            sizeofcmds(20, 4),\n-                 flags(24, 4),\n-              reserved(28, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        mach_header_64(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 32;\n-\n-        /**\n-         * mach_header_64 defines\n-         */\n-        static final int MH_MAGIC                   = 0xfeedface;\n-        static final int MH_MAGIC_64                = 0xfeedfacf;\n-        static final int MH_SUBSECTIONS_VIA_SYMBOLS = 0x2000;\n-\n-        /**\n-         * filetype\n-         */\n-        static final int MH_OBJECT = 0x1;\n-\n-        /**\n-         * cputype\n-         */\n-        static final int CPU_TYPE_ANY              = -1;\n-        static final int CPU_ARCH_ABI64            = 0x1000000;\n-        static final int CPU_TYPE_X86_64           = 0x1000007;\n-        static final int CPU_TYPE_ARM64            = 0x100000c;\n-        /**\n-         * cpusubtype\n-         */\n-        static final int CPU_SUBTYPE_I386_ALL      = 3;\n-        static final int CPU_SUBTYPE_ARM64_ALL     = 0;\n-        static final int CPU_SUBTYPE_LITTLE_ENDIAN = 0;\n-        static final int CPU_SUBTYPE_BIG_ENDIAN    = 1;\n-\n-    }\n-\n-    /**\n-     * segment_command_64 structure defines\n-     */\n-    enum segment_command_64 {\n-                   cmd( 0, 4),\n-               cmdsize( 4, 4),\n-               segname( 8,16),\n-                vmaddr(24, 8),\n-                vmsize(32, 8),\n-               fileoff(40, 8),\n-              filesize(48, 8),\n-               maxprot(56, 4),\n-              initprot(60, 4),\n-                nsects(64, 4),\n-                 flags(68, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        segment_command_64(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 72;\n-\n-        static final int LC_SEGMENT_64           = 0x19;\n-    }\n-\n-    /**\n-     * section_64 structure defines\n-     */\n-    enum section_64 {\n-              sectname( 0,16),\n-               segname(16,16),\n-                  addr(32, 8),\n-                  size(40, 8),\n-                offset(48, 4),\n-                 align(52, 4),\n-                reloff(56, 4),\n-                nreloc(60, 4),\n-                 flags(64, 4),\n-             reserved1(68, 4),\n-             reserved2(72, 4),\n-             reserved3(76, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        section_64(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 80;\n-\n-        static int S_REGULAR                = 0x0;\n-        static int S_CSTRING_LITERALS       = 0x2;\n-        static int S_ATTR_PURE_INSTRUCTIONS = 0x80000000;\n-        static int S_ATTR_SOME_INSTRUCTIONS = 0x400;\n-    }\n-\n-    /**\n-     * version_min_command structure defines\n-     */\n-    enum version_min_command {\n-                   cmd( 0, 4),\n-               cmdsize( 4, 4),\n-               version( 8, 4),\n-                   sdk(12, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        version_min_command(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 16;\n-\n-        static final int LC_VERSION_MIN_MACOSX   = 0x24;\n-        static final int LC_VERSION_MIN_IPHONEOS = 0x25;\n-    }\n-\n-    /**\n-     * symtab_command structure defines\n-     */\n-    enum symtab_command {\n-                   cmd( 0, 4),\n-               cmdsize( 4, 4),\n-                symoff( 8, 4),\n-                 nsyms(12, 4),\n-                stroff(16, 4),\n-               strsize(20, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        symtab_command(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 24;\n-\n-        static final int LC_SYMTAB               = 0x2;\n-    }\n-\n-    /**\n-     * Symbol table entry definitions\n-     *\n-     * nlist_64 structure defines\n-     */\n-    enum nlist_64 {\n-                n_strx( 0, 4),\n-                n_type( 4, 1),\n-                n_sect( 5, 1),\n-                n_desc( 6, 2),\n-               n_value( 8, 8);\n-\n-        final int off;\n-        final int sz;\n-\n-        nlist_64(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 16;\n-\n-        static final int N_EXT                = 0x1;\n-        static final int N_TYPE               = 0xe;\n-        static final int N_UNDF               = 0x0;\n-        static final int N_SECT               = 0xe;\n-    }\n-\n-    /**\n-     * dysymtab_command structure defines\n-     */\n-    enum dysymtab_command {\n-                   cmd( 0, 4),\n-               cmdsize( 4, 4),\n-             ilocalsym( 8, 4),\n-             nlocalsym(12, 4),\n-            iextdefsym(16, 4),\n-            nextdefsym(20, 4),\n-             iundefsym(24, 4),\n-             nundefsym(28, 4),\n-                tocoff(32, 4),\n-                  ntoc(36, 4),\n-             modtaboff(40, 4),\n-               nmodtab(44, 4),\n-          extrefsymoff(48, 4),\n-           nextrefsyms(52, 4),\n-        indirectsymoff(56, 4),\n-         nindirectsyms(60, 4),\n-             extreloff(64, 4),\n-               nextrel(68, 4),\n-             locreloff(72, 4),\n-               nlocrel(76, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        dysymtab_command(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 80;\n-\n-        static final int LC_DYSYMTAB             = 0xb;\n-    }\n-\n-    /**\n-     * relocation_info structure defines\n-     */\n-    enum reloc_info {\n-             r_address( 0, 4),\n-           r_relocinfo( 4, 4);\n-\n-        final int off;\n-        final int sz;\n-\n-        reloc_info(int offset, int size) {\n-            this.off = offset;\n-            this.sz = size;\n-        }\n-\n-        static int totalsize = 8;\n-\n-        static final int REL_SYMNUM_MASK         = 0xffffff;\n-        static final int REL_SYMNUM_SHIFT        = 0x0;\n-        static final int REL_PCREL_MASK          = 0x1;\n-        static final int REL_PCREL_SHIFT         = 0x18;\n-        static final int REL_LENGTH_MASK         = 0x3;\n-        static final int REL_LENGTH_SHIFT        = 0x19;\n-        static final int REL_EXTERN_MASK         = 0x1;\n-        static final int REL_EXTERN_SHIFT        = 0x1b;\n-        static final int REL_TYPE_MASK           = 0xf;\n-        static final int REL_TYPE_SHIFT          = 0x1c;\n-\n-        /* reloc_type_x86_64 defines */\n-\n-        static final int X86_64_RELOC_NONE      = 0x0;\n-        static final int X86_64_RELOC_BRANCH    = 0x2;\n-        static final int X86_64_RELOC_GOT       = 0x4;\n-        static final int X86_64_RELOC_GOT_LOAD  = 0x3;\n-        static final int X86_64_RELOC_SIGNED    = 0x1;\n-        static final int X86_64_RELOC_UNSIGNED  = 0x0;\n-    }\n-}"
  }
]
