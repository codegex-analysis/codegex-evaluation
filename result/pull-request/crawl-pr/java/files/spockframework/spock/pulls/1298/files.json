[
  {
    "sha": "75edb7fc23db90d32cc20b575808d06f75e9f90f",
    "filename": "docs/data_driven_testing.adoc",
    "status": "modified",
    "additions": 15,
    "deletions": 1,
    "changes": 16,
    "blob_url": "https://github.com/spockframework/spock/blob/579964d18a7da6faee0812591a8363177222177a/docs/data_driven_testing.adoc",
    "raw_url": "https://github.com/spockframework/spock/raw/579964d18a7da6faee0812591a8363177222177a/docs/data_driven_testing.adoc",
    "contents_url": "https://api.github.com/repos/spockframework/spock/contents/docs/data_driven_testing.adoc?ref=579964d18a7da6faee0812591a8363177222177a",
    "patch": "@@ -72,7 +72,7 @@ This is semantically exactly the same, just as one wider combined data table:\n \n [source,groovy,indent=0]\n ----\n-include::{sourcedir}/datadriven/DataSpec.groovy[tag=multiple-tables-combined]\n+include::{sourcedir}/datadriven/DataSpec.groovy[tag=multiple-tables-joined]\n ----\n \n The sequence of two or more underscores can be used anywhere in the `where` block.\n@@ -87,6 +87,20 @@ additionally to its effect of separating them:\n include::{sourcedir}/datadriven/DataSpec.groovy[tag=multiple-tables-with-top-border]\n ----\n \n+Two or more consecutive data tables can also be combined using a cartesian product\n+using the `combine:` label between them. The following will result in these four\n+executed tests\n+\n+- `a feature (1 3 5)`\n+- `a feature (2 3 5)`\n+- `a feature (1 4 6)`\n+- `a feature (2 4 6)`\n+\n+[source,groovy,indent=0]\n+----\n+include::{sourcedir}/datadriven/DataSpec.groovy[tag=multiple-tables-combined]\n+----\n+\n == Isolated Execution of Iterations\n \n Iterations are isolated from each other in the same way as separate feature methods. Each iteration gets its own instance"
  },
  {
    "sha": "361a269d0797495d6cea8a63e1d9eb961c591baf",
    "filename": "docs/release_notes.adoc",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/spockframework/spock/blob/579964d18a7da6faee0812591a8363177222177a/docs/release_notes.adoc",
    "raw_url": "https://github.com/spockframework/spock/raw/579964d18a7da6faee0812591a8363177222177a/docs/release_notes.adoc",
    "contents_url": "https://api.github.com/repos/spockframework/spock/contents/docs/release_notes.adoc?ref=579964d18a7da6faee0812591a8363177222177a",
    "patch": "@@ -12,6 +12,8 @@ include::include.adoc[]\n \n === Misc\n \n+- Add support for combining two or more data tables using cartesian product (https://github.com/spockframework/spock/issues/1062[#1062])\n+\n - Add support for injection into `@Shared` fields in `spock-spring` module which users can opt-in for by adding\n   `@EnableSharedInjection` to the specification. https://github.com/spockframework/spock/issues/76[#76]\n "
  },
  {
    "sha": "7d44bc79fb27967eaebd8a1bb5277b9d8a774154",
    "filename": "spock-core/src/main/groovy/spock/util/SourceToAstNodeAndSourceTranspiler.groovy",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/spockframework/spock/blob/579964d18a7da6faee0812591a8363177222177a/spock-core/src/main/groovy/spock/util/SourceToAstNodeAndSourceTranspiler.groovy",
    "raw_url": "https://github.com/spockframework/spock/raw/579964d18a7da6faee0812591a8363177222177a/spock-core/src/main/groovy/spock/util/SourceToAstNodeAndSourceTranspiler.groovy",
    "contents_url": "https://api.github.com/repos/spockframework/spock/contents/spock-core/src/main/groovy/spock/util/SourceToAstNodeAndSourceTranspiler.groovy?ref=579964d18a7da6faee0812591a8363177222177a",
    "patch": "@@ -1,5 +1,6 @@\n package spock.util\n \n+import org.intellij.lang.annotations.Language\n import org.spockframework.compat.groovy2.GroovyCodeVisitorCompat\n \n import java.lang.reflect.Modifier\n@@ -131,6 +132,7 @@ enum Show {\n @TupleConstructor\n @CompileStatic\n class TranspileResult {\n+  @Language('Groovy')\n   final String source\n   final List<NodeCapture> nodeCaptures\n }"
  },
  {
    "sha": "708fd2c611964e988e3ff03421a8f787aebcc5fa",
    "filename": "spock-core/src/main/java/org/spockframework/compiler/WhereBlockRewriter.java",
    "status": "modified",
    "additions": 130,
    "deletions": 21,
    "changes": 151,
    "blob_url": "https://github.com/spockframework/spock/blob/579964d18a7da6faee0812591a8363177222177a/spock-core/src/main/java/org/spockframework/compiler/WhereBlockRewriter.java",
    "raw_url": "https://github.com/spockframework/spock/raw/579964d18a7da6faee0812591a8363177222177a/spock-core/src/main/java/org/spockframework/compiler/WhereBlockRewriter.java",
    "contents_url": "https://api.github.com/repos/spockframework/spock/contents/spock-core/src/main/java/org/spockframework/compiler/WhereBlockRewriter.java?ref=579964d18a7da6faee0812591a8363177222177a",
    "patch": "@@ -22,7 +22,6 @@\n import org.spockframework.util.*;\n \n import java.util.*;\n-import java.util.function.Function;\n import java.util.stream.Collectors;\n \n import org.codehaus.groovy.ast.*;\n@@ -36,11 +35,14 @@\n import static java.lang.Boolean.TRUE;\n import static java.util.function.Function.identity;\n import static java.util.stream.Collectors.*;\n+import static org.codehaus.groovy.ast.tools.GeneralUtils.stmt;\n+import static org.codehaus.groovy.ast.tools.GeneralUtils.varX;\n import static org.spockframework.compiler.AstUtil.createDirectMethodCall;\n import static org.spockframework.compiler.AstUtil.createGetAtMethodCall;\n import static org.spockframework.compiler.AstUtil.isDataTableSeparator;\n import static org.spockframework.compiler.AstUtil.getExpression;\n import static org.spockframework.util.ExceptionUtil.sneakyThrow;\n+import static org.spockframework.util.Identifiers.COMBINE;\n \n /**\n  *\n@@ -91,6 +93,9 @@ private void rewrite() {\n \n   private void rewriteWhereStat(ListIterator<Statement> stats) throws InvalidSpecCompileException {\n     Statement stat = stats.next();\n+    if (COMBINE.equals(stat.getStatementLabel())) {\n+      throw combineLabelMustOnlyAppearBetweenTwoDataTables(stat);\n+    }\n \n     // binary expressions are potentially parameterizations\n     BinaryExpression binExpr = AstUtil.getExpression(stat, BinaryExpression.class);\n@@ -116,9 +121,6 @@ private void rewriteWhereStat(ListIterator<Statement> stats) throws InvalidSpecC\n       .forEach(expression -> stats.previous());\n \n     if (potentialHeaderRow.size() > 1) {\n-      if (!potentialHeaderRow.stream().allMatch(VariableExpression.class::isInstance)) {\n-        throw dataTableHeaderMayOnlyContainVariableNames(stat);\n-      }\n       stats.previous();\n       rewriteExpressionTableLikeParameterization(stats);\n       return;\n@@ -189,7 +191,7 @@ private void rewriteBinaryWhereStat(ListIterator<Statement> stats) throws Invali\n     }\n   }\n \n-  private List<Expression> getExpressionChain(ListIterator<Statement> stats) {\n+  private List<Expression> getExpressionChain(ListIterator<Statement> stats) throws InvalidSpecCompileException {\n     List<Expression> result = new ArrayList<>();\n \n     if (!stats.hasNext()) {\n@@ -216,6 +218,9 @@ private void rewriteBinaryWhereStat(ListIterator<Statement> stats) throws Invali\n         stats.previous();\n         break;\n       }\n+      if (nextStat.getStatementLabel() != null) {\n+        throw columnsInDataTableMustNotBeLabeled(nextStat);\n+      }\n       stat = nextStat;\n     }\n \n@@ -385,49 +390,135 @@ private void createDataProcessorStatement(VariableExpression variable, Expressio\n     dataProcessorStats.add(exprStat);\n   }\n \n-  private void rewriteBinaryTableLikeParameterization(ListIterator<Statement> stats) throws InvalidSpecCompileException {\n-    rewriteTableLikeParameterization(stats, result -> {\n+  private void rewriteBinaryTableLikeParameterization(ListIterator<Statement> stats) {\n+    int[] i = { 0 };\n+    while (stats.hasNext()) {\n       Statement stat = stats.next();\n       BinaryExpression orExpr = getOrExpression(stat);\n       if (orExpr == null) {\n         stats.previous();\n-        return true;\n+        break;\n       }\n-      splitRow(orExpr, result);\n-      return false;\n-    });\n+      List<Expression> row = new ArrayList<>();\n+      splitRow(orExpr, row);\n+\n+      // replace `a | b || c` by `a ; b ; c` so that they can be handled uniformly later\n+      stats.remove();\n+      for (int j = 0, rowSize = row.size(); j < rowSize; j++) {\n+        Expression expr = row.get(j);\n+        Statement exStat = stmt(expr);\n+        exStat.setLineNumber(expr.getLineNumber());\n+        exStat.setLastLineNumber(expr.getLastLineNumber());\n+        exStat.setColumnNumber(expr.getColumnNumber());\n+        exStat.setLastColumnNumber(expr.getLastColumnNumber());\n+        if ((j == 0) && (stat.getStatementLabels() != null)) {\n+          stat.getStatementLabels().forEach(exStat::addStatementLabel);\n+        }\n+        stats.add(exStat);\n+        i[0]++;\n+      }\n+    }\n+\n+    if (stats.hasNext()) {\n+      boolean nextStatementIsCombineLabeled = COMBINE.equals(stats.next().getStatementLabel());\n+      stats.previous();\n+      if (!nextStatementIsCombineLabeled) {\n+        stats.add(stmt(varX(new DynamicVariable(\"__\", false))));\n+        i[0]++;\n+      }\n+    }\n+\n+    // rewind to before the added statements\n+    for (int j = i[0]; j > 0; j--) {\n+      stats.previous();\n+    }\n   }\n \n   private void rewriteExpressionTableLikeParameterization(ListIterator<Statement> stats) throws InvalidSpecCompileException {\n-    rewriteTableLikeParameterization(stats, result -> {\n+    rewriteTableLikeParameterization(stats, () -> {\n+      boolean headerRow;\n+      if (stats.hasNext()) {\n+        headerRow = COMBINE.equals(stats.next().getStatementLabel());\n+        stats.previous();\n+      } else {\n+        headerRow = false;\n+      }\n+\n+      if (headerRow) {\n+        rewriteBinaryTableLikeParameterization(stats);\n+      }\n+\n       List<Expression> row = getExpressionChain(stats);\n       if (row.size() <= 1) {\n         // rewind\n         row.forEach(expression -> stats.previous());\n-        return true;\n+        return null;\n       }\n-      result.addAll(row);\n-      return false;\n+      return new DataTableRow(row, headerRow);\n     });\n   }\n \n-  private void rewriteTableLikeParameterization(ListIterator<Statement> stats, Function<List<Expression>, Boolean> rowExtractor) throws InvalidSpecCompileException {\n+  private void rewriteTableLikeParameterization(\n+    ListIterator<Statement> stats,\n+    ThrowingSupplier<DataTableRow, InvalidSpecCompileException> rowExtractor) throws InvalidSpecCompileException {\n+\n+    List<List<Expression>> baseRows = null;\n     LinkedList<List<Expression>> rows = new LinkedList<>();\n+    int baseRowSize = 0;\n+    ASTNode lastHeaderLocation = null;\n \n     while (stats.hasNext()) {\n-      List<Expression> row = new ArrayList<>();\n-      if (rowExtractor.apply(row)) {\n+      DataTableRow row = rowExtractor.get();\n+      if (row == null) {\n         break;\n       }\n-      if (rows.size() > 0 && rows.getLast().size() != row.size())\n-        throw new InvalidSpecCompileException(row.get(0), String.format(\"Row in data table has wrong number of elements (%s instead of %s)\", row.size(), rows.getLast().size()));\n-      rows.add(row);\n+\n+      if (lastHeaderLocation == null) {\n+        lastHeaderLocation = row.expressions.get(0);\n+      }\n+\n+      if (row.isHeader) {\n+        if (rows.size() == 1) {\n+          throw new InvalidSpecCompileException(lastHeaderLocation, \"Data table must have more than just the header row\");\n+        }\n+\n+        lastHeaderLocation = row.expressions.get(0);\n+\n+        List<Expression> combinedHeaderRow = new ArrayList<>(rows.get(0));\n+        combinedHeaderRow.addAll(row.expressions);\n+        baseRows = rows.subList(1, rows.size());\n+        baseRowSize = baseRows.get(0).size();\n+        rows = new LinkedList<>();\n+        rows.add(combinedHeaderRow);\n+      } else {\n+        addRow(baseRows, baseRowSize, rows, row);\n+      }\n+    }\n+\n+    if (rows.size() == 1) {\n+      throw new InvalidSpecCompileException(lastHeaderLocation, \"Data table must have more than just the header row\");\n     }\n \n     for (List<Expression> column : transposeTable(rows))\n       turnIntoSimpleParameterization(column);\n   }\n \n+  private void addRow(List<List<Expression>> baseRows, int baseRowSize,\n+                      LinkedList<List<Expression>> rows, DataTableRow row) throws InvalidSpecCompileException {\n+    if (rows.size() > 0 && (rows.getLast().size() - baseRowSize) != row.expressions.size())\n+      throw new InvalidSpecCompileException(row.expressions.get(0), \"Row in data table has wrong number of elements (%s instead of %s)\", row.expressions.size(), rows.getLast().size() - baseRowSize);\n+\n+    if (baseRows == null) {\n+      rows.add(row.expressions);\n+    } else {\n+      for (List<Expression> baseRow : baseRows) {\n+        List<Expression> combinedRow = new ArrayList<>(baseRow);\n+        combinedRow.addAll(row.expressions);\n+        rows.add(combinedRow);\n+      }\n+    }\n+  }\n+\n   List<List<Expression>> transposeTable(List<List<Expression>> rows) {\n     List<List<Expression>> columns = new ArrayList<>();\n     if (rows.isEmpty()) return columns;\n@@ -694,6 +785,14 @@ private static InvalidSpecCompileException notAParameterization(ASTNode stat) {\n \"where-blocks may only contain parameterizations (e.g. 'salary << [1000, 5000, 9000]; salaryk = salary / 1000')\");\n   }\n \n+  private static InvalidSpecCompileException columnsInDataTableMustNotBeLabeled(ASTNode stat) {\n+    return new InvalidSpecCompileException(stat, \"Columns in data tables must not be labeled\");\n+  }\n+\n+  private static InvalidSpecCompileException combineLabelMustOnlyAppearBetweenTwoDataTables(ASTNode stat) {\n+    return new InvalidSpecCompileException(stat, \"Combine label must only appear between two data tables\");\n+  }\n+\n   private static InvalidSpecCompileException dataTableHeaderMayOnlyContainVariableNames(ASTNode stat) {\n     return new InvalidSpecCompileException(stat, \"Header of data table may only contain variable names\");\n   }\n@@ -744,4 +843,14 @@ public void visitVariableExpression(VariableExpression expression) {\n       }\n     }\n   }\n+\n+  private static class DataTableRow {\n+    private final List<Expression> expressions;\n+    private final boolean isHeader;\n+\n+    public DataTableRow(List<Expression> expressions, boolean isHeader) {\n+      this.expressions = expressions;\n+      this.isHeader = isHeader;\n+    }\n+  }\n }"
  },
  {
    "sha": "7955a2108cfb5032f7d6a7c8df2fdf5e55bb71af",
    "filename": "spock-core/src/main/java/org/spockframework/compiler/model/BlockParseInfo.java",
    "status": "modified",
    "additions": 12,
    "deletions": 1,
    "changes": 13,
    "blob_url": "https://github.com/spockframework/spock/blob/579964d18a7da6faee0812591a8363177222177a/spock-core/src/main/java/org/spockframework/compiler/model/BlockParseInfo.java",
    "raw_url": "https://github.com/spockframework/spock/raw/579964d18a7da6faee0812591a8363177222177a/spock-core/src/main/java/org/spockframework/compiler/model/BlockParseInfo.java",
    "contents_url": "https://api.github.com/repos/spockframework/spock/contents/spock-core/src/main/java/org/spockframework/compiler/model/BlockParseInfo.java?ref=579964d18a7da6faee0812591a8363177222177a",
    "patch": "@@ -118,7 +118,18 @@ public Block addNewBlock(Method method) {\n     }\n     @Override\n     public EnumSet<BlockParseInfo> getSuccessors(Method method) {\n-      return EnumSet.of(AND, METHOD_END);\n+      return EnumSet.of(AND, COMBINE, METHOD_END);\n+    }\n+  },\n+\n+  COMBINE {\n+    @Override\n+    public EnumSet<BlockParseInfo> getSuccessors(Method method) {\n+      return method.getLastBlock().getParseInfo().getSuccessors(method);\n+    }\n+    @Override\n+    public Block addNewBlock(Method method) {\n+      return method.getLastBlock();\n     }\n   },\n "
  },
  {
    "sha": "f5ed0a27813bc5a6a41fa669dcd87fb4f9dbde35",
    "filename": "spock-core/src/main/java/org/spockframework/util/Identifiers.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/spockframework/spock/blob/579964d18a7da6faee0812591a8363177222177a/spock-core/src/main/java/org/spockframework/util/Identifiers.java",
    "raw_url": "https://github.com/spockframework/spock/raw/579964d18a7da6faee0812591a8363177222177a/spock-core/src/main/java/org/spockframework/util/Identifiers.java",
    "contents_url": "https://api.github.com/repos/spockframework/spock/contents/spock-core/src/main/java/org/spockframework/util/Identifiers.java?ref=579964d18a7da6faee0812591a8363177222177a",
    "patch": "@@ -51,9 +51,11 @@\n    */\n   public static final String WHERE = \"where\";\n \n+  public static final String COMBINE = \"combine\";\n+\n   public static final String AND = \"and\";\n \n-  public static final List<String> BLOCK_LABELS = Arrays.asList(SETUP, GIVEN, EXPECT, WHEN, THEN, CLEANUP, WHERE, AND);\n+  public static final List<String> BLOCK_LABELS = Arrays.asList(SETUP, GIVEN, EXPECT, WHEN, THEN, CLEANUP, WHERE, COMBINE, AND);\n \n   public static final String SETUP_METHOD = \"setup\";\n "
  },
  {
    "sha": "0d61e9f609e465470d6fb1e0d4ba228924a78620",
    "filename": "spock-core/src/main/java/org/spockframework/util/ThrowingSupplier.java",
    "status": "added",
    "additions": 22,
    "deletions": 0,
    "changes": 22,
    "blob_url": "https://github.com/spockframework/spock/blob/579964d18a7da6faee0812591a8363177222177a/spock-core/src/main/java/org/spockframework/util/ThrowingSupplier.java",
    "raw_url": "https://github.com/spockframework/spock/raw/579964d18a7da6faee0812591a8363177222177a/spock-core/src/main/java/org/spockframework/util/ThrowingSupplier.java",
    "contents_url": "https://api.github.com/repos/spockframework/spock/contents/spock-core/src/main/java/org/spockframework/util/ThrowingSupplier.java?ref=579964d18a7da6faee0812591a8363177222177a",
    "patch": "@@ -0,0 +1,22 @@\n+/*\n+ * Copyright 2021 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.spockframework.util;\n+\n+@FunctionalInterface\n+public interface ThrowingSupplier<T, E extends Exception> {\n+  T get() throws E;\n+}"
  },
  {
    "sha": "c065d1ff67b6b7bf4a0d3f88a7e127d32cff032c",
    "filename": "spock-specs/src/test/groovy/org/spockframework/docs/datadriven/DataSpec.groovy",
    "status": "modified",
    "additions": 20,
    "deletions": 3,
    "changes": 23,
    "blob_url": "https://github.com/spockframework/spock/blob/579964d18a7da6faee0812591a8363177222177a/spock-specs/src/test/groovy/org/spockframework/docs/datadriven/DataSpec.groovy",
    "raw_url": "https://github.com/spockframework/spock/raw/579964d18a7da6faee0812591a8363177222177a/spock-specs/src/test/groovy/org/spockframework/docs/datadriven/DataSpec.groovy",
    "contents_url": "https://api.github.com/repos/spockframework/spock/contents/spock-specs/src/test/groovy/org/spockframework/docs/datadriven/DataSpec.groovy?ref=579964d18a7da6faee0812591a8363177222177a",
    "patch": "@@ -64,18 +64,18 @@ class DataSpec extends EmbeddedSpecification {\n // end::multiple-tables[]\n   }\n \n-  def \"multiple tables combined\"() {\n+  def \"multiple tables joined\"() {\n     expect:\n     a >= 0\n     b < c\n \n-// tag::multiple-tables-combined[]\n+// tag::multiple-tables-joined[]\n     where:\n     a | b | c\n     1 | 1 | 2\n     7 | 3 | 4\n     0 | 5 | 6\n-// end::multiple-tables-combined[]\n+// end::multiple-tables-joined[]\n   }\n \n   def \"multiple tables with top border\"() {\n@@ -98,6 +98,23 @@ class DataSpec extends EmbeddedSpecification {\n // end::multiple-tables-with-top-border[]\n   }\n \n+  def \"multiple tables combined\"() {\n+    expect:\n+    a >= 0\n+    b < c\n+\n+// tag::multiple-tables-combined[]\n+    where:\n+    a | _\n+    1 | _\n+    2 | _\n+    combine:\n+    b | c\n+    3 | 5\n+    4 | 6\n+// end::multiple-tables-combined[]\n+  }\n+\n // tag::sql-data-pipe[]\n   def \"maximum of two numbers\"() {\n     expect:"
  },
  {
    "sha": "4363559ee32cf82d0410ae84b390e59974a7669b",
    "filename": "spock-specs/src/test/groovy/org/spockframework/smoke/parameterization/DataTables.groovy",
    "status": "modified",
    "additions": 375,
    "deletions": 9,
    "changes": 384,
    "blob_url": "https://github.com/spockframework/spock/blob/579964d18a7da6faee0812591a8363177222177a/spock-specs/src/test/groovy/org/spockframework/smoke/parameterization/DataTables.groovy",
    "raw_url": "https://github.com/spockframework/spock/raw/579964d18a7da6faee0812591a8363177222177a/spock-specs/src/test/groovy/org/spockframework/smoke/parameterization/DataTables.groovy",
    "contents_url": "https://api.github.com/repos/spockframework/spock/contents/spock-specs/src/test/groovy/org/spockframework/smoke/parameterization/DataTables.groovy?ref=579964d18a7da6faee0812591a8363177222177a",
    "patch": "@@ -19,10 +19,10 @@ import org.spockframework.EmbeddedSpecification\n import org.spockframework.compiler.InvalidSpecCompileException\n import org.spockframework.runtime.SpockExecutionException\n \n-import spock.lang.Ignore\n import spock.lang.Issue\n import spock.lang.Rollup\n import spock.lang.Shared\n+import spock.util.Show\n \n @Rollup\n class DataTables extends EmbeddedSpecification {\n@@ -87,9 +87,9 @@ a\n     1 ; _\n   }\n \n-  def \"table with just a header are not allowed\"() {\n+  def \"table with just a header is not allowed\"() {\n     when:\n-    runner.runFeatureBody \"\"\"\n+    compiler.compileFeatureBody \"\"\"\n expect:\n true\n \n@@ -98,12 +98,31 @@ a | b\n     \"\"\"\n \n     then:\n-    thrown(SpockExecutionException)\n+    InvalidSpecCompileException e = thrown()\n+    e.message == 'Data table must have more than just the header row @ line 5, column 1.'\n   }\n \n-  def \"table with just a header are not allowed with semicolon\"() {\n+  def \"table with just a header in combination is not allowed\"() {\n     when:\n-    runner.runFeatureBody \"\"\"\n+    compiler.compileFeatureBody \"\"\"\n+expect:\n+true\n+\n+where:\n+a | b\n+1 | 2\n+combine:\n+c | _\n+    \"\"\"\n+\n+    then:\n+    InvalidSpecCompileException e = thrown()\n+    e.message == 'Data table must have more than just the header row @ line 8, column 1.'\n+  }\n+\n+  def \"table with just a header is not allowed with semicolon\"() {\n+    when:\n+    compiler.compileFeatureBody \"\"\"\n expect:\n true\n \n@@ -112,7 +131,26 @@ a ; b\n     \"\"\"\n \n     then:\n-    thrown(SpockExecutionException)\n+    InvalidSpecCompileException e = thrown()\n+    e.message == 'Data table must have more than just the header row @ line 5, column 1.'\n+  }\n+\n+  def \"table with just a header in combination is not allowed with semicolon\"() {\n+    when:\n+    compiler.compileFeatureBody \"\"\"\n+expect:\n+true\n+\n+where:\n+a ; b\n+1 ; 2\n+combine:\n+c ; _\n+    \"\"\"\n+\n+    then:\n+    InvalidSpecCompileException e = thrown()\n+    e.message == 'Data table must have more than just the header row @ line 8, column 1.'\n   }\n \n   def \"header may only contain variable names\"() {\n@@ -142,8 +180,8 @@ a ; 1 ; b\n     \"\"\"\n \n     then:\n-    MultipleFailuresError e = thrown()\n-    e.failures*.class == [InvalidSpecCompileException] * 6\n+    InvalidSpecCompileException e = thrown()\n+    e.message == 'Header of data table may only contain variable names @ line 5, column 5.'\n   }\n \n   def \"header variable names must not clash with local variables\"() {\n@@ -524,6 +562,334 @@ a ; b ; c\n     4 | 5 || 9\n   }\n \n+  def 'data tables with pipes can be combined'() {\n+    when:\n+    def results = runner.runSpecBody '''\n+      def 'a feature (#a #b #c)'() {\n+        expect:\n+        true\n+\n+        where:\n+        a | _\n+        1 | _\n+        2 | _\n+        combine:\n+        b | _\n+        3 | _\n+        combine:\n+        c | _\n+        4 | _\n+        5 | _\n+        6 | _\n+      }\n+    '''\n+\n+    then:\n+    results.testsStartedCount == 1 + 6\n+    results.testEvents().started().list().testDescriptor.displayName == [\n+      'a feature (#a #b #c)',\n+      'a feature (1 3 4)',\n+      'a feature (2 3 4)',\n+      'a feature (1 3 5)',\n+      'a feature (2 3 5)',\n+      'a feature (1 3 6)',\n+      'a feature (2 3 6)'\n+    ]\n+  }\n+\n+  def 'data tables with pipes can be combined (transpiler test)'() {\n+    when:\n+    def result = compiler.transpileFeatureBody '''\n+      expect:\n+      true\n+\n+      where:\n+      a | _\n+      1 | _\n+      2 | _\n+      combine:\n+      b | _\n+      3 | _\n+      combine:\n+      c | _\n+      4 | _\n+      5 | _\n+      6 | _\n+    ''', EnumSet.of(Show.METHODS)\n+\n+    then:\n+    result.source == '''\n+      |public void $spock_feature_0_0(java.lang.Object a, java.lang.Object b, java.lang.Object c) {\n+      |    org.spockframework.runtime.ErrorCollector $spock_errorCollector = org.spockframework.runtime.ErrorRethrower.INSTANCE\n+      |    org.spockframework.runtime.ValueRecorder $spock_valueRecorder = new org.spockframework.runtime.ValueRecorder()\n+      |    try {\n+      |        org.spockframework.runtime.SpockRuntime.verifyCondition($spock_errorCollector, $spock_valueRecorder.reset(), 'true', 2, 7, null, $spock_valueRecorder.record($spock_valueRecorder.startRecordingValue(0), true))\n+      |    }\n+      |    catch (java.lang.Throwable throwable) {\n+      |        org.spockframework.runtime.SpockRuntime.conditionFailedWithException($spock_errorCollector, $spock_valueRecorder, 'true', 2, 7, null, throwable)}\n+      |    finally {\n+      |    }\n+      |    this.getSpecificationContext().getMockController().leaveScope()\n+      |}\n+      |\n+      |public java.lang.Object $spock_feature_0_0prov0() {\n+      |    return [1, 2, 1, 2, 1, 2]\n+      |}\n+      |\n+      |public java.lang.Object $spock_feature_0_0prov1(java.util.List $spock_p_a) {\n+      |    return [3, 3, 3, 3, 3, 3]\n+      |}\n+      |\n+      |public java.lang.Object $spock_feature_0_0prov2(java.util.List $spock_p_a, java.util.List $spock_p_b) {\n+      |    return [4, 4, 5, 5, 6, 6]\n+      |}\n+      |\n+      |public java.lang.Object $spock_feature_0_0proc(java.lang.Object $spock_p0, java.lang.Object $spock_p1, java.lang.Object $spock_p2) {\n+      |    java.lang.Object a = (( $spock_p0 ) as java.lang.Object)\n+      |    java.lang.Object b = (( $spock_p1 ) as java.lang.Object)\n+      |    java.lang.Object c = (( $spock_p2 ) as java.lang.Object)\n+      |    return new java.lang.Object[]{ a , b , c }\n+      |}\n+    '''.stripMargin().trim()\n+  }\n+\n+  def 'data tables with semicolons can be combined'() {\n+    when:\n+    def results = runner.runSpecBody '''\n+      def 'a feature (#a #b #c)'() {\n+        expect:\n+        true\n+\n+        where:\n+        a ; _\n+        1 ; _\n+        2 ; _\n+        combine:\n+        b ; _\n+        3 ; _\n+        combine:\n+        c ; _\n+        4 ; _\n+        5 ; _\n+        6 ; _\n+      }\n+    '''\n+\n+    then:\n+    results.testsStartedCount == 1 + 6\n+    results.testEvents().started().list().testDescriptor.displayName == [\n+      'a feature (#a #b #c)',\n+      'a feature (1 3 4)',\n+      'a feature (2 3 4)',\n+      'a feature (1 3 5)',\n+      'a feature (2 3 5)',\n+      'a feature (1 3 6)',\n+      'a feature (2 3 6)'\n+    ]\n+  }\n+\n+  def 'data tables with semicolons can be combined (transpiler test)'() {\n+    when:\n+    def result = compiler.transpileFeatureBody '''\n+      expect:\n+      true\n+\n+      where:\n+      a ; _\n+      1 ; _\n+      2 ; _\n+      combine:\n+      b ; _\n+      3 ; _\n+      combine:\n+      c ; _\n+      4 ; _\n+      5 ; _\n+      6 ; _\n+    ''', EnumSet.of(Show.METHODS)\n+\n+    then:\n+    result.source == '''\n+      |public void $spock_feature_0_0(java.lang.Object a, java.lang.Object b, java.lang.Object c) {\n+      |    org.spockframework.runtime.ErrorCollector $spock_errorCollector = org.spockframework.runtime.ErrorRethrower.INSTANCE\n+      |    org.spockframework.runtime.ValueRecorder $spock_valueRecorder = new org.spockframework.runtime.ValueRecorder()\n+      |    try {\n+      |        org.spockframework.runtime.SpockRuntime.verifyCondition($spock_errorCollector, $spock_valueRecorder.reset(), 'true', 2, 7, null, $spock_valueRecorder.record($spock_valueRecorder.startRecordingValue(0), true))\n+      |    }\n+      |    catch (java.lang.Throwable throwable) {\n+      |        org.spockframework.runtime.SpockRuntime.conditionFailedWithException($spock_errorCollector, $spock_valueRecorder, 'true', 2, 7, null, throwable)}\n+      |    finally {\n+      |    }\n+      |    this.getSpecificationContext().getMockController().leaveScope()\n+      |}\n+      |\n+      |public java.lang.Object $spock_feature_0_0prov0() {\n+      |    return [1, 2, 1, 2, 1, 2]\n+      |}\n+      |\n+      |public java.lang.Object $spock_feature_0_0prov1(java.util.List $spock_p_a) {\n+      |    return [3, 3, 3, 3, 3, 3]\n+      |}\n+      |\n+      |public java.lang.Object $spock_feature_0_0prov2(java.util.List $spock_p_a, java.util.List $spock_p_b) {\n+      |    return [4, 4, 5, 5, 6, 6]\n+      |}\n+      |\n+      |public java.lang.Object $spock_feature_0_0proc(java.lang.Object $spock_p0, java.lang.Object $spock_p1, java.lang.Object $spock_p2) {\n+      |    java.lang.Object a = (( $spock_p0 ) as java.lang.Object)\n+      |    java.lang.Object b = (( $spock_p1 ) as java.lang.Object)\n+      |    java.lang.Object c = (( $spock_p2 ) as java.lang.Object)\n+      |    return new java.lang.Object[]{ a , b , c }\n+      |}\n+    '''.stripMargin().trim()\n+  }\n+\n+  def 'combined data table columns can use previous data table column values'() {\n+    expect:\n+    a == b\n+    c == \"x$i\"\n+\n+    where:\n+    x    | _\n+    'x1' | _\n+    'x2' | _\n+    'x3' | _\n+    'x4' | _\n+    'x5' | _\n+    'x6' | _\n+\n+    i << (1..6)\n+\n+    a | _\n+    1 | _\n+    2 | _\n+    combine:\n+    b | _\n+    a | _\n+    combine:\n+    c | _\n+    x | _\n+    x | _\n+    x | _\n+  }\n+\n+  def 'data tables with mixed separators can be combined'() {\n+    when:\n+    def results = runner.runSpecBody '''\n+      def 'a feature (#a #b #c)'() {\n+        expect:\n+        true\n+\n+        where:\n+        a | _\n+        1 | _\n+        2 | _\n+        combine:\n+        b ; _\n+        3 ; _\n+        combine:\n+        c | _\n+        4 | _\n+        5 | _\n+        6 | _\n+      }\n+    '''\n+\n+    then:\n+    results.testsStartedCount == 1 + 6\n+    results.testEvents().started().list().testDescriptor.displayName == [\n+      'a feature (#a #b #c)',\n+      'a feature (1 3 4)',\n+      'a feature (2 3 4)',\n+      'a feature (1 3 5)',\n+      'a feature (2 3 5)',\n+      'a feature (1 3 6)',\n+      'a feature (2 3 6)'\n+    ]\n+  }\n+\n+  def 'data tables with mixed separators can be combined (transpiler test)'() {\n+    when:\n+    def result = compiler.transpileFeatureBody '''\n+      expect:\n+      true\n+\n+      where:\n+      a | _\n+      1 | _\n+      2 | _\n+      combine:\n+      b ; _\n+      3 ; _\n+      combine:\n+      c | _\n+      4 | _\n+      5 | _\n+      6 | _\n+    ''', EnumSet.of(Show.METHODS)\n+\n+    then:\n+    result.source == '''\n+      |public void $spock_feature_0_0(java.lang.Object a, java.lang.Object b, java.lang.Object c) {\n+      |    org.spockframework.runtime.ErrorCollector $spock_errorCollector = org.spockframework.runtime.ErrorRethrower.INSTANCE\n+      |    org.spockframework.runtime.ValueRecorder $spock_valueRecorder = new org.spockframework.runtime.ValueRecorder()\n+      |    try {\n+      |        org.spockframework.runtime.SpockRuntime.verifyCondition($spock_errorCollector, $spock_valueRecorder.reset(), 'true', 2, 7, null, $spock_valueRecorder.record($spock_valueRecorder.startRecordingValue(0), true))\n+      |    }\n+      |    catch (java.lang.Throwable throwable) {\n+      |        org.spockframework.runtime.SpockRuntime.conditionFailedWithException($spock_errorCollector, $spock_valueRecorder, 'true', 2, 7, null, throwable)}\n+      |    finally {\n+      |    }\n+      |    this.getSpecificationContext().getMockController().leaveScope()\n+      |}\n+      |\n+      |public java.lang.Object $spock_feature_0_0prov0() {\n+      |    return [1, 2, 1, 2, 1, 2]\n+      |}\n+      |\n+      |public java.lang.Object $spock_feature_0_0prov1(java.util.List $spock_p_a) {\n+      |    return [3, 3, 3, 3, 3, 3]\n+      |}\n+      |\n+      |public java.lang.Object $spock_feature_0_0prov2(java.util.List $spock_p_a, java.util.List $spock_p_b) {\n+      |    return [4, 4, 5, 5, 6, 6]\n+      |}\n+      |\n+      |public java.lang.Object $spock_feature_0_0proc(java.lang.Object $spock_p0, java.lang.Object $spock_p1, java.lang.Object $spock_p2) {\n+      |    java.lang.Object a = (( $spock_p0 ) as java.lang.Object)\n+      |    java.lang.Object b = (( $spock_p1 ) as java.lang.Object)\n+      |    java.lang.Object c = (( $spock_p2 ) as java.lang.Object)\n+      |    return new java.lang.Object[]{ a , b , c }\n+      |}\n+    '''.stripMargin().trim()\n+  }\n+\n+  def 'data tables with different widths can be combined'() {\n+    when:\n+    def results = runner.runSpecBody '''\n+      def 'a feature (#a #b #c #d #e)'() {\n+        expect:\n+        true\n+\n+        where:\n+        a | b\n+        1 | 'b'\n+        2 | 'b'\n+        combine:\n+        c | d   | e\n+        3 | 'd' | 'e'\n+      }\n+    '''\n+\n+    then:\n+    results.testsStartedCount == 1 + 2\n+    results.testEvents().started().list().testDescriptor.displayName == [\n+      'a feature (#a #b #c #d #e)',\n+      'a feature (1 b 3 d e)',\n+      'a feature (2 b 3 d e)'\n+    ]\n+  }\n+\n   def \"cells can be separated with any amount of semicolons\"() {\n     expect:\n     a + b == c"
  },
  {
    "sha": "0e10f196bdbc504baae71e6927a46c7a49521445",
    "filename": "spock-specs/src/test/groovy/org/spockframework/smoke/parameterization/InvalidWhereBlocks.groovy",
    "status": "modified",
    "additions": 78,
    "deletions": 0,
    "changes": 78,
    "blob_url": "https://github.com/spockframework/spock/blob/579964d18a7da6faee0812591a8363177222177a/spock-specs/src/test/groovy/org/spockframework/smoke/parameterization/InvalidWhereBlocks.groovy",
    "raw_url": "https://github.com/spockframework/spock/raw/579964d18a7da6faee0812591a8363177222177a/spock-specs/src/test/groovy/org/spockframework/smoke/parameterization/InvalidWhereBlocks.groovy",
    "contents_url": "https://api.github.com/repos/spockframework/spock/contents/spock-specs/src/test/groovy/org/spockframework/smoke/parameterization/InvalidWhereBlocks.groovy?ref=579964d18a7da6faee0812591a8363177222177a",
    "patch": "@@ -268,4 +268,82 @@ c << $spock_p_a\n     then:\n     thrown(MissingPropertyException)\n   }\n+\n+  def 'using combine label outside where block is not allowed'() {\n+    when:\n+    def result = compiler.transpileFeatureBody '''\n+      combine:\n+      true\n+\n+      expect:\n+      true\n+\n+      where:\n+      a | _\n+      1 | _\n+    '''\n+\n+    then:\n+    result.source.normalize() == '''\n+      |Unable to produce AST for this phase due to earlier compilation error:\n+      |startup failed:\n+      |script.groovy: 2: 'combine' is not allowed here; instead, use one of: [setup, given, expect, when, cleanup, where, end-of-method] @ line 2, column 7.\n+      |         true\n+      |         ^\n+      |\n+      |1 error\n+    '''.stripMargin().trim()\n+  }\n+\n+  def 'using combine label between data table and something else is not allowed'() {\n+    when:\n+    def result = compiler.transpileFeatureBody '''\n+      expect:\n+      true\n+\n+      where:\n+      a | _\n+      1 | _\n+      combine:\n+      b = 1\n+    '''\n+\n+    then:\n+    result.source.normalize() == '''\n+      |Unable to produce AST for this phase due to earlier compilation error:\n+      |startup failed:\n+      |script.groovy: 8: Combine label must only appear between two data tables @ line 8, column 7.\n+      |         b = 1\n+      |         ^\n+      |\n+      |1 error\n+    '''.stripMargin().trim()\n+  }\n+\n+  def 'using combine label within semicolon data table row is not allowed'() {\n+    when:\n+    def result = compiler.transpileFeatureBody '''\n+      expect:\n+      true\n+\n+      where:\n+      a ; combine: b\n+      1 ; 2\n+    '''\n+\n+    then:\n+    result.source.normalize() == '''\n+      |Unable to produce AST for this phase due to earlier compilation error:\n+      |startup failed:\n+      |script.groovy: 5: Columns in data tables must not be labeled @ line 5, column 20.\n+      |         a ; combine: b\n+      |                      ^\n+      |\n+      |script.groovy: 6: Data table must have more than just the header row @ line 6, column 7.\n+      |         1 ; 2\n+      |         ^\n+      |\n+      |2 errors\n+    '''.stripMargin().trim()\n+  }\n }"
  }
]
