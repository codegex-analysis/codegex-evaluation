[
  {
    "sha": "5ebe2a90bff2a08ac456ed4c8442366b28c9567c",
    "filename": "src/main/java/core/CoreConstants.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/core/CoreConstants.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/core/CoreConstants.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/core/CoreConstants.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -32,7 +32,7 @@\n     public final static int backgroundImgHash = Hash.GetInstance().hash(\"backgroundImg\");\n \n     public enum GameEvents {\n-        GAME_OVER, ROUND_OVER, TURN_OVER, ACTION_CHOSEN\n+        ABOUT_TO_START, GAME_OVER, ROUND_OVER, TURN_OVER, ACTION_CHOSEN, GAME_SEQUENCE_OVER\n     }\n \n     /**"
  },
  {
    "sha": "ca98d52c42c241c0d3b73d0a41705ace50f104ec",
    "filename": "src/main/java/core/Game.java",
    "status": "modified",
    "additions": 9,
    "deletions": 7,
    "changes": 16,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/core/Game.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/core/Game.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/core/Game.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -8,21 +8,22 @@\n import players.human.ActionController;\n import players.human.HumanGUIPlayer;\n import players.mcts.MCTSParams;\n-import players.mcts.MCTSPlayer;\n-import players.rmhc.RMHCPlayer;\n import players.simple.RandomPlayer;\n-import utilities.*;\n+import utilities.Pair;\n+import utilities.TAGStatSummary;\n+import utilities.Utils;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import static core.CoreConstants.*;\n-import static games.GameType.*;\n+import static games.GameType.DotsAndBoxes;\n \n public class Game {\n \n     // Type of game\n-    private GameType gameType;\n+    private final GameType gameType;\n \n     // List of agents/players that play this game.\n     protected List<AbstractPlayer> players;\n@@ -165,6 +166,7 @@ public void resetStats() {\n         nActionsPerTurnSum = 0;\n         nActionsPerTurn = 1;\n         nActionsPerTurnCount = 0;\n+        listeners.forEach(l -> l.onGameEvent(GameEvents.ABOUT_TO_START, this));\n     }\n \n     /**\n@@ -316,7 +318,7 @@ private void terminate() {\n \n         // Perform any end of game computations as required by the game\n         forwardModel.endGame(gameState);\n-        listeners.forEach(l -> l.onEvent(GameEvents.GAME_OVER, gameState, null));\n+        listeners.forEach(l -> l.onGameEvent(GameEvents.GAME_OVER, this));\n         if (VERBOSE) {\n             System.out.println(\"Game Over\");\n         }"
  },
  {
    "sha": "ce207f3e12ef01d3c25d1f0ec474ceaf8292c42d",
    "filename": "src/main/java/core/components/Area.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/core/components/Area.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/core/components/Area.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/core/components/Area.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -87,7 +87,8 @@ public void putComponent(Component component) {\n         this.components.put(component.getComponentID(), component);\n         if (component instanceof IComponentContainer) {\n             for (Component nestedC : ((IComponentContainer<?>) component).getComponents()) {\n-                putComponent(nestedC);\n+                if (nestedC != null)\n+                    putComponent(nestedC);\n             }\n         }\n     }"
  },
  {
    "sha": "fe24703ac3fc7df7b96df367e9f9793dc0b53e66",
    "filename": "src/main/java/core/interfaces/IActionAttribute.java",
    "status": "removed",
    "additions": 0,
    "deletions": 20,
    "changes": 20,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/e738dca1d55700d7002c526938e0c449a638a1dd/src/main/java/core/interfaces/IActionAttribute.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/e738dca1d55700d7002c526938e0c449a638a1dd/src/main/java/core/interfaces/IActionAttribute.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/core/interfaces/IActionAttribute.java?ref=e738dca1d55700d7002c526938e0c449a638a1dd",
    "patch": "@@ -1,20 +0,0 @@\n-package core.interfaces;\n-\n-import core.AbstractGameState;\n-import core.actions.AbstractAction;\n-\n-public interface IActionAttribute<T> {\n-\n-    /**\n-     * A simple interface to gather data on action-specific attributes\n-     * Mostly used for logging of game trajectories\n-     *\n-     * @param state The game state\n-     * @param action The action about to be applied to the game state\n-     * @return The value of the relevant attribute\n-     */\n-    T get(AbstractGameState state, AbstractAction action);\n-\n-    String name();\n-\n-}"
  },
  {
    "sha": "bc9aa5908732fe5e01a226ab58b2d8d61d80b563",
    "filename": "src/main/java/core/interfaces/IGameAttribute.java",
    "status": "modified",
    "additions": 11,
    "deletions": 13,
    "changes": 24,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/core/interfaces/IGameAttribute.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/core/interfaces/IGameAttribute.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/core/interfaces/IGameAttribute.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -12,20 +12,18 @@\n      * @param state The game state\n      * @return The value of whatever the attribute is in this state\n      */\n-    Object get(AbstractGameState state, AbstractAction action);\n+    default Object get(AbstractGameState state, AbstractAction action) {\n+        return 0;\n+    }\n \n-    default String getAsString(AbstractGameState state, AbstractAction action) {\n-        Object value = get(state, action);\n-        if (value instanceof Double) {\n-            return String.format(\"%.4g\", value);\n-        }\n-        if (value instanceof Integer) {\n-            return String.format(\"%d\", value);\n-        }\n-        if (value instanceof Boolean) {\n-            return (Boolean) value ? \"1\" : \"0\";\n-        }\n-        return value.toString();\n+    /**\n+     *\n+     * @param state The game state\n+     * @param player The player for whom we are reporting\n+     * @return\n+     */\n+    default Object get(AbstractGameState state, int player) {\n+        return 0;\n     }\n \n     String name();"
  },
  {
    "sha": "cb44b7dd4773e6e59b1a8b026c2f2b285b82dd65",
    "filename": "src/main/java/core/interfaces/IGameListener.java",
    "status": "modified",
    "additions": 57,
    "deletions": 2,
    "changes": 59,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/core/interfaces/IGameListener.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/core/interfaces/IGameListener.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/core/interfaces/IGameListener.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -2,10 +2,65 @@\n \n import core.AbstractGameState;\n import core.CoreConstants;\n-import core.actions.AbstractAction;;\n+import core.Game;\n+import core.actions.AbstractAction;\n+import utilities.GameReportListener;\n+\n+import java.lang.reflect.Constructor;\n \n public interface IGameListener {\n \n-    public void onEvent(CoreConstants.GameEvents type, AbstractGameState state, AbstractAction action);\n+    /**\n+     * This is used to register Game Start and Game Over events\n+     *\n+     * @param type Either ABOUT_TO_START or GAME_OVER\n+     * @param game The Game\n+     */\n+    void onGameEvent(CoreConstants.GameEvents type, Game game);\n+\n+    /**\n+     * Registers all other event types.\n+     * The state will always be provided, but action will be null except for ACTION_CHOSEN events\n+     *\n+     * @param type   The GameEvent\n+     * @param state  The current Game state\n+     * @param action The Action that have just been Chosen (if relevant; else null)\n+     */\n+    // for all other event types\n+    void onEvent(CoreConstants.GameEvents type, AbstractGameState state, AbstractAction action);\n+\n+\n+    static IGameListener createListener(String listenerClass, IStatisticLogger logger) {\n+        IGameListener listener = new GameReportListener(logger);\n+        if (!listenerClass.equals(\"\")) {\n+            try {\n+                Class<?> clazz = Class.forName(listenerClass);\n+\n+                Constructor<?> constructor;\n+                try {\n+                    constructor = clazz.getConstructor(IStatisticLogger.class);\n+                    listener = (IGameListener) constructor.newInstance(logger);\n+                } catch (NoSuchMethodException e) {\n+                    return createListener(listenerClass);\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+        return listener;\n+    }\n+\n+    static IGameListener createListener(String listenerClass) {\n+        IGameListener listener = new GameReportListener();\n+        try {\n+            Class<?> clazz = Class.forName(listenerClass);\n+            Constructor<?> constructor;\n+            constructor = clazz.getConstructor();\n+            listener = (IGameListener) constructor.newInstance();\n \n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+        return listener;\n+    }\n }"
  },
  {
    "sha": "f16d2e8ddee5835f47c48bcb2abacc48919c326f",
    "filename": "src/main/java/evaluation/GameLogger.java",
    "status": "removed",
    "additions": 0,
    "deletions": 86,
    "changes": 86,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/e738dca1d55700d7002c526938e0c449a638a1dd/src/main/java/evaluation/GameLogger.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/e738dca1d55700d7002c526938e0c449a638a1dd/src/main/java/evaluation/GameLogger.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/evaluation/GameLogger.java?ref=e738dca1d55700d7002c526938e0c449a638a1dd",
    "patch": "@@ -1,86 +0,0 @@\n-package evaluation;\n-\n-import core.AbstractGameState;\n-import core.actions.AbstractAction;\n-import core.interfaces.*;\n-\n-import java.io.*;\n-import java.util.*;\n-\n-import static core.CoreConstants.*;\n-import static java.util.stream.Collectors.*;\n-\n-public class GameLogger implements IGameListener {\n-\n-    public GameLogger(List<GameEvents> eventFilter, String logFile, boolean append) {\n-        this.logFile = logFile;\n-        this.append = append;\n-        this.filter = new ArrayList<>(eventFilter);\n-    }\n-\n-    private List<IGameAttribute> gameAttributes = new ArrayList<>();\n-    private boolean append;\n-    private String logFile;\n-    private List<GameEvents> filter;\n-    private FileWriter writer;\n-\n-    public void addAttribute(IGameAttribute attribute) {\n-        gameAttributes.add(attribute);\n-    }\n-\n-    public void addAttributes(List<IGameAttribute> attributes) {\n-        gameAttributes.addAll(attributes);\n-    }\n-\n-    public void clearAttributes() {\n-        gameAttributes = new ArrayList<>();\n-    }\n-\n-    @Override\n-    public void onEvent(GameEvents event, AbstractGameState state, AbstractAction action) {\n-        if (filter.contains(event)) {\n-            String allData = gameAttributes.stream()\n-                    .map(att -> att.getAsString(state, action))\n-                    .collect(joining(\"\\t\"));\n-            ;\n-            writeData(allData + \"\\n\");\n-        }\n-    }\n-\n-    private void writeData(String data) {\n-        // first we open the file, and th\n-        try {\n-            if (writer == null) {\n-                boolean fileExists = new File(logFile).exists();\n-                writer = new FileWriter(logFile, append);\n-                if (!append || !fileExists) {\n-                    writer.write(getHeader());\n-                }\n-            }\n-            writer.write(data);\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-            throw new AssertionError(\"Problem with file \" + logFile + \" : \" + e.getMessage());\n-        }\n-    }\n-\n-    private String getHeader() {\n-        String headerData = gameAttributes.stream()\n-                .map(IGameAttribute::name)\n-                .collect(joining(\"\\t\"));\n-        return headerData + \"\\n\";\n-    }\n-\n-    public void close() {\n-        try {\n-            if (writer != null) {\n-                writer.flush();\n-                writer.close();\n-                writer = null;\n-            }\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-            throw new AssertionError(\"Problem closing file \" + logFile + \" : \" + e.getMessage());\n-        }\n-    }\n-}"
  },
  {
    "sha": "f979b8c2540cc1467073586eea36b37ec28a7006",
    "filename": "src/main/java/evaluation/GameReportII.java",
    "status": "modified",
    "additions": 33,
    "deletions": 167,
    "changes": 200,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/evaluation/GameReportII.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/evaluation/GameReportII.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/evaluation/GameReportII.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -1,18 +1,17 @@\n package evaluation;\n \n-import core.*;\n-import core.actions.AbstractAction;\n-import core.interfaces.IComponentContainer;\n+import core.AbstractPlayer;\n+import core.CoreConstants;\n+import core.Game;\n import core.interfaces.IGameListener;\n import core.interfaces.IStatisticLogger;\n import games.GameType;\n import players.PlayerFactory;\n import utilities.Pair;\n-import utilities.TAGStatSummary;\n-import utilities.TAGSummariser;\n \n-import java.util.*;\n-import java.util.stream.IntStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n \n import static java.util.stream.Collectors.toList;\n import static utilities.Utils.getArg;\n@@ -35,9 +34,15 @@ public static void main(String[] args) {\n                             \"\\t               The default is 'all' to indicate that all games should be analysed.\\n\" +\n                             \"\\tplayer=        The JSON file containing the details of the Player to monitor, OR\\n\" +\n                             \"\\t               one of mcts|rmhc|random|osla|<className>. The default is 'random'.\\n\" +\n+                            \"\\tlistener=      The full class name of an IGameListener implementation. \\n\" +\n+                            \"\\t               Defaults to utilities.GameReportListener. \\n\" +\n+                            \"\\t               A pipe-delimited string can be provided to gather many types of statistics \\n\" +\n+                            \"\\t               from the same set of games.\" +\n                             \"\\tlogger=        The full class name of an IStatisticsLogger implementation.\\n\" +\n-                            \"\\t               Defaults to SummaryLogger. \\n\" +\n+                            \"\\t               Defaults to utilities.SummaryLogger. \\n\" +\n                             \"\\tlogFile=       Will be used as the IStatisticsLogger log file (FileStatsLogger only)\\n\" +\n+                            \"\\t               A pipe-delimited list should be provided if each distinct listener should\\n\" +\n+                            \"\\t               use a different log file.\\n\" +\n                             \"\\tnPlayers=      The total number of players in each game (the default is 'all') \\n \" +\n                             \"\\t               A range can also be specified, for example 3-5. \\n \" +\n                             \"\\t               Different player counts can be specified for each game in pipe-delimited format.\\n\" +\n@@ -50,6 +55,11 @@ public static void main(String[] args) {\n         // Get Player to be used\n         String playerDescriptor = getArg(args, \"player\", \"random\");\n         String loggerClass = getArg(args, \"logger\", \"utilities.SummaryLogger\");\n+        List<String> listenerClasses = new ArrayList<>(Arrays.asList(getArg(args, \"listener\", \"utilities.GameReportListener\").split(\"\\\\|\")));\n+        List<String> logFiles = new ArrayList<>(Arrays.asList(getArg(args, \"logFile\", \"GameReport.txt\").split(\"\\\\|\")));\n+\n+        if (listenerClasses.size() > 1 && logFiles.size() > 1 && listenerClasses.size() != logFiles.size())\n+            throw new IllegalArgumentException(\"Lists of log files and listeners must be the same length\");\n \n         int nGames = getArg(args, \"nGames\", 1000);\n         List<String> games = new ArrayList<>(Arrays.asList(getArg(args, \"games\", \"all\").split(\"\\\\|\")));\n@@ -76,8 +86,6 @@ public static void main(String[] args) {\n         if (nPlayers.size() > 1 && nPlayers.size() != games.size())\n             throw new IllegalArgumentException(\"If specified, then nPlayers length must be one, or match the length of the games list\");\n \n-        String logFile = getArg(args, \"logFile\", \"GameReport.txt\");\n-\n         // Then iterate over the Game Types\n         for (int gameIndex = 0; gameIndex < games.size(); gameIndex++) {\n             GameType gameType = GameType.valueOf(games.get(gameIndex));\n@@ -95,177 +103,35 @@ public static void main(String[] args) {\n                     System.out.printf(\"Skipping game - maximum player count is %d%n\", gameType.getMaxPlayers());\n                     continue;\n                 }\n-                IStatisticLogger logger = IStatisticLogger.createLogger(loggerClass, logFile);\n-\n-                Map<String, Object> collectedData = new HashMap<>();\n-                collectedData.put(\"Game\", games.get(gameIndex));\n-                collectedData.put(\"Players\", String.valueOf(playerCount));\n-                collectedData.put(\"PlayerType\", playerDescriptor);\n \n                 Game game = gameType.createGameInstance(playerCount);\n \n+                List<IGameListener> gameTrackers = new ArrayList<>();\n+                for (int i = 0; i < listenerClasses.size(); i++) {\n+                    String logFile = logFiles.size() == 1 ? logFiles.get(0) : logFiles.get(i);\n+                    String listenerClass = listenerClasses.size() == 1 ? listenerClasses.get(0) : listenerClasses.get(i);\n+                    IStatisticLogger logger = IStatisticLogger.createLogger(loggerClass, logFile);\n+                    IGameListener gameTracker = IGameListener.createListener(listenerClass, logger);\n+                    game.addListener(gameTracker);\n+                    gameTrackers.add(gameTracker);\n+                }\n+\n                 for (int i = 0; i < nGames; i++) {\n                     List<AbstractPlayer> allPlayers = new ArrayList<>();\n                     for (int j = 0; j < playerCount; j++) {\n                         allPlayers.add(PlayerFactory.createPlayer(playerDescriptor));\n                     }\n                     // Run games, resetting the player each time\n+\n                     game.reset(allPlayers);\n-                    GameReportListener gameTracker = new GameReportListener(game.getForwardModel());\n-                    game.addListener(gameTracker);\n-                    preGameProcessing(game, collectedData);\n                     game.run();\n-                    postGameProcessing(game, collectedData);\n-                    game.clearListeners();\n-                    collectedData.putAll(gameTracker.extractData());\n-                    logger.record(collectedData);\n-                    collectedData.clear();\n                 }\n-                // Once all games are complete, call processDataAndFinish()\n-                logger.processDataAndFinish();\n-            }\n-        }\n-    }\n-\n-    private static class GameReportListener implements IGameListener {\n-\n-        List<Double> scores = new ArrayList<>();\n-        //        List<Integer> branchingByStates = new ArrayList<>();\n-        List<Double> visibilityOnTurn = new ArrayList<>();\n-        List<Integer> components = new ArrayList<>();\n-        AbstractForwardModel fm;\n-\n-        public GameReportListener(AbstractForwardModel forwardModel) {\n-            fm = forwardModel;\n-        }\n-\n-        @Override\n-        public void onEvent(CoreConstants.GameEvents type, AbstractGameState state, AbstractAction actionChosen) {\n-            if (type == CoreConstants.GameEvents.ACTION_CHOSEN) {\n-                // each action taken, we record branching factor and states (this is triggered when the decision is made,\n-                // so before it is executed\n-                int player = state.getCurrentPlayer();\n-                List<AbstractAction> allActions = fm.computeAvailableActions(state);\n-                if (allActions.size() < 2) return;\n-//                HashSet<Integer> forwardStates = new HashSet<>();\n-//                for (AbstractAction action : allActions) {\n-//                    AbstractGameState gsCopy = state.copy();\n-//                    fm.next(gsCopy, action);\n-//                    forwardStates.add(gsCopy.hashCode());\n-//                }\n-//                branchingByStates.add(forwardStates.size());\n-                scores.add(state.getGameScore(player));\n-                Pair<Integer, int[]> allComp = countComponents(state);\n-                components.add(allComp.a);\n-                visibilityOnTurn.add(allComp.b[player] / (double) allComp.a);\n-                //          System.out.printf(\"Turn: %d, Player: %d, Action: %s%n\", state.getTurnOrder().getTurnCounter(), player, actionChosen);\n+                // Once all games are complete, let the gameTracker know\n+                for (IGameListener gameTracker : gameTrackers) {\n+                    gameTracker.onGameEvent(CoreConstants.GameEvents.GAME_SEQUENCE_OVER, game);\n+                }\n             }\n         }\n-\n-        public Map<String, Object> extractData() {\n-            Map<String, Object> data = new HashMap<>();\n-//            IntSummaryStatistics bf = branchingByStates.stream().mapToInt(i -> i).summaryStatistics();\n-//            data.put(\"BranchingFactor\", bf.getAverage());\n-//            data.put(\"MaxBranchingFactor\", bf.getMax());\n-            TAGStatSummary sc = scores.stream().collect(new TAGSummariser());\n-            data.put(\"ScoreMedian\", sc.median());\n-            data.put(\"ScoreMean\", sc.mean());\n-            data.put(\"ScoreMax\", sc.max());\n-            data.put(\"ScoreMin\", sc.min());\n-            data.put(\"ScoreVarCoeff\", Math.abs(sc.sd() / sc.mean()));\n-            TAGStatSummary scoreDelta = scores.size() > 1 ?\n-                    IntStream.range(0, scores.size() - 1)\n-                            .mapToObj(i -> !scores.get(i + 1).equals(scores.get(i)) ? 1.0 : 0.0)\n-                            .collect(new TAGSummariser())\n-                    : new TAGStatSummary();\n-            data.put(\"ScoreDelta\", scoreDelta.mean()); // percentage of actions that lead to a change in score\n-            TAGStatSummary stateSize = components.stream().collect(new TAGSummariser());\n-            data.put(\"StateSizeMedian\", stateSize.median());\n-            data.put(\"StateSizeMean\", stateSize.mean());\n-            data.put(\"StateSizeMax\", stateSize.max());\n-            data.put(\"StateSizeMin\", stateSize.min());\n-            data.put(\"StateSizeVarCoeff\", Math.abs(stateSize.sd() / stateSize.mean()));\n-            TAGStatSummary visibility = visibilityOnTurn.stream().collect(new TAGSummariser());\n-            data.put(\"HiddenInfoMedian\", visibility.median());\n-            data.put(\"HiddenInfoMean\", visibility.mean());\n-            data.put(\"HiddenInfoMax\", visibility.max());\n-            data.put(\"HiddenInfoMin\", visibility.min());\n-            data.put(\"HiddenInfoVarCoeff\", Math.abs(visibility.sd() / visibility.mean()));\n-            return data;\n-        }\n-    }\n-\n-    private static void preGameProcessing(Game game, Map<String, Object> data) {\n-        AbstractGameState gs = game.getGameState();\n-\n-        AbstractForwardModel fm = game.getForwardModel();\n-        long s = System.nanoTime();\n-        fm.setup(gs);\n-        data.put(\"TimeSetup\", (System.nanoTime() - s) / 1e3);\n-\n-        Pair<Integer, int[]> components = countComponents(gs);\n-        data.put(\"StateSizeStart\", components.a);\n-\n-        IntStream.range(0, game.getPlayers().size()).forEach(p -> {\n-            int unseen = components.b[p];\n-            data.put(\"HiddenInfoStart\", unseen / (double) components.a);\n-        });\n-    }\n-\n-    /**\n-     * Returns the total number of components in the state as the first element of the returned value\n-     * and an array of the counts that are hidden to each player\n-     * <p>\n-     *\n-     * @param state\n-     * @return The total number of components\n-     */\n-    private static Pair<Integer, int[]> countComponents(AbstractGameState state) {\n-        int[] hiddenByPlayer = new int[state.getNPlayers()];\n-        // we do not include containers in the count...just the lowest-level items\n-        // open to debate on this. But we are consistent across State Size and Hidden Information stats\n-        int total = (int) state.getAllComponents().stream().filter(c -> !(c instanceof IComponentContainer)).count();\n-        for (int p = 0; p < hiddenByPlayer.length; p++)\n-            hiddenByPlayer[p] = state.getUnknownComponentsIds(p).size();\n-        return new Pair<>(total, hiddenByPlayer);\n-    }\n-\n-    private static void postGameProcessing(Game game, Map<String, Object> data) {\n-        //    Retrieves a list with one entry per game tick, each a pair (active player ID, # actions)\n-        List<Pair<Integer, Integer>> actionSpaceRecord = game.getActionSpaceSize();\n-        TAGStatSummary stats = actionSpaceRecord.stream()\n-                .map(r -> r.b)\n-                .filter(size -> size > 1)\n-                .collect(new TAGSummariser());\n-        data.put(\"ActionSpaceMean\", stats.mean());\n-        data.put(\"ActionSpaceMin\", stats.min());\n-        data.put(\"ActionSpaceMedian\", stats.median());\n-        data.put(\"ActionSpaceMax\", stats.max());\n-        data.put(\"ActionSpaceSkew\", stats.skew());\n-        data.put(\"ActionSpaceKurtosis\", stats.kurtosis());\n-        data.put(\"ActionSpaceVarCoeff\", Math.abs(stats.sd() / stats.mean()));\n-        data.put(\"Decisions\", stats.n());\n-        data.put(\"TimeNext\", game.getNextTime() / 1e3);\n-        data.put(\"TimeCopy\", game.getCopyTime() / 1e3);\n-        data.put(\"TimeActionCompute\", game.getActionComputeTime() / 1e3);\n-        data.put(\"TimeAgent\", game.getAgentTime() / 1e3);\n-\n-        data.put(\"Ticks\", game.getTick());\n-        data.put(\"Rounds\", game.getGameState().getTurnOrder().getRoundCounter());\n-        data.put(\"ActionsPerTurn\", game.getNActionsPerTurn());\n-\n-//        IntStream.range(0, game.getPlayers().size()).forEach(p -> {\n-//            StatSummary playerStats = actionSpaceRecord.stream()\n-//                    .filter(r -> r.a == p)\n-//                    .map(r -> r.b)\n-//                    .filter(size -> size > 1)\n-//                    .collect(new TAGSummariser());\n-//            data.put(\"ActionSpaceMean_P\" + p, playerStats.mean());\n-//            data.put(\"ActionSpaceMin_P\" + p, playerStats.min());\n-//            data.put(\"ActionSpaceMax_P\" + p, playerStats.max());\n-//            data.put(\"Decisions_P\" + p, playerStats.n());\n-//        });\n-\n     }\n }\n "
  },
  {
    "sha": "0aa00bac31c5a47b62799765e9530d1777155890",
    "filename": "src/main/java/evaluation/PlayerReport.java",
    "status": "modified",
    "additions": 8,
    "deletions": 9,
    "changes": 17,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/evaluation/PlayerReport.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/evaluation/PlayerReport.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/evaluation/PlayerReport.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -1,20 +1,19 @@\n package evaluation;\n \n import core.AbstractPlayer;\n-import core.*;\n+import core.Game;\n import core.interfaces.IStatisticLogger;\n-import games.*;\n+import games.GameType;\n import players.PlayerFactory;\n import players.simple.RandomPlayer;\n import utilities.FileStatsLogger;\n-import utilities.SummaryLogger;\n \n-import java.io.File;\n-import java.lang.reflect.Constructor;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n \n-import static java.util.stream.Collectors.*;\n-import static utilities.Utils.*;\n+import static java.util.stream.Collectors.toList;\n+import static utilities.Utils.getArg;\n \n public class PlayerReport {\n \n@@ -33,7 +32,7 @@ public static void main(String[] args) {\n                         \"\\tplayer=        The JSON file containing the details of the Player to monitor, OR\\n\" +\n                         \"\\t               one of mcts|rmhc|random|osla|<className>.\\n\" +\n                         \"\\tlogger=        The full class name of an IStatisticsLogger implementation.\\n\" +\n-                        \"\\t               Defaults to SummaryLogger. \\n\" +\n+                        \"\\t               Defaults to utilities.SummaryLogger. \\n\" +\n                         \"\\tlogFile=       Will be used as the IStatisticsLogger log file (FileStatsLogger only)\\n\" +\n                         \"\\tnPlayers=      The total number of players in each game (the default is game.Min#players) \\n \" +\n                         \"\\t               Different player counts can be specified for each game in pipe-delimited format.\\n\" +"
  },
  {
    "sha": "7d2e41cbed6b7aefb0a124d310372fa82b46a312",
    "filename": "src/main/java/evaluation/RoundRobinTournament.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/evaluation/RoundRobinTournament.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/evaluation/RoundRobinTournament.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/evaluation/RoundRobinTournament.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -67,7 +67,7 @@ public static void main(String[] args) {\n                 new RoundRobinTournament(agents, gameToPlay, nPlayersPerGame, nGamesPerMatchUp, selfPlay) :\n                 new RandomRRTournament(agents, gameToPlay, nPlayersPerGame, nGamesPerMatchUp, selfPlay, totalMatchups,\n                         System.currentTimeMillis());\n-        tournament.dataLogger = logFile.equals(\"\") ? null : new FileStatsLogger(logFile, \"\\t\");\n+        tournament.dataLogger = logFile.equals(\"\") ? null : new FileStatsLogger(logFile, \"\\t\", true);\n         tournament.runTournament();\n     }\n "
  },
  {
    "sha": "4ee77cf101032337fe623f86418273065b4a7767",
    "filename": "src/main/java/games/dominion/DominionGameAttributes.java",
    "status": "modified",
    "additions": 7,
    "deletions": 17,
    "changes": 24,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/games/dominion/DominionGameAttributes.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/games/dominion/DominionGameAttributes.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/games/dominion/DominionGameAttributes.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -7,12 +7,12 @@\n \n import java.util.function.*;\n \n-public enum DominionGameAttributes {\n+public enum DominionGameAttributes implements IGameAttribute {\n     GAME_ID((s, a) -> s.getGameID()),\n     GAME_ROUND((s, a) -> s.getTurnOrder().getRoundCounter()),\n     PLAYER((s, a) -> s.getCurrentPlayer()),\n-    ACTION_TYPE((s, a) -> a.getClass().getSimpleName()),\n-    ACTION_DESCRIPTION((s, a) -> a.getString(s)),\n+    ACTION_TYPE((s, a) -> a == null ? \"NONE\" : a.getClass().getSimpleName()),\n+    ACTION_DESCRIPTION((s, a) ->  a == null ? \"NONE\" : a.getString(s)),\n     PROVINCES_LEFT((s, a) -> s.cardsOfType(CardType.PROVINCE, -1, DominionConstants.DeckType.SUPPLY)),\n     DUCHIES_LEFT((s, a) -> s.cardsOfType(CardType.DUCHY, -1, DominionConstants.DeckType.SUPPLY)),\n     ESTATES_LEFT((s, a) -> s.cardsOfType(CardType.ESTATE, -1, DominionConstants.DeckType.SUPPLY)),\n@@ -21,24 +21,14 @@\n             .count());\n \n     private final BiFunction<DominionGameState, AbstractAction, Object> lambda;\n-    private final String name = this.toString();\n \n     DominionGameAttributes(BiFunction<DominionGameState, AbstractAction, Object> lambda) {\n         this.lambda = lambda;\n     }\n \n-    public IGameAttribute getAttribute() {\n-        return new IGameAttribute() {\n-            @Override\n-            public Object get(AbstractGameState state, AbstractAction action) {\n-                DominionGameState dgs = (DominionGameState) state;\n-                return lambda.apply(dgs, action);\n-            }\n-\n-            @Override\n-            public String name() {\n-                return name;\n-            }\n-        };\n+    @Override\n+    public Object get(AbstractGameState state, AbstractAction action) {\n+        return lambda.apply((DominionGameState) state, action);\n     }\n+\n }"
  },
  {
    "sha": "8b69baafdaeaf171ae2a80134c2b670a6df06d6c",
    "filename": "src/main/java/games/dominion/DominionListener.java",
    "status": "added",
    "additions": 39,
    "deletions": 0,
    "changes": 39,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/games/dominion/DominionListener.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/games/dominion/DominionListener.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/games/dominion/DominionListener.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -0,0 +1,39 @@\n+package games.dominion;\n+\n+import core.AbstractGameState;\n+import core.CoreConstants;\n+import core.Game;\n+import core.actions.AbstractAction;\n+import core.interfaces.IGameAttribute;\n+import core.interfaces.IGameListener;\n+import core.interfaces.IStatisticLogger;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+public class DominionListener implements IGameListener {\n+\n+    IStatisticLogger logger;\n+    public DominionListener(IStatisticLogger logger) {\n+        this.logger = logger;\n+    }\n+\n+    @Override\n+    public void onGameEvent(CoreConstants.GameEvents type, Game game) {\n+        if (type == CoreConstants.GameEvents.GAME_OVER) {\n+            AbstractGameState state = game.getGameState();\n+            Map<String, Object> data = Arrays.stream(DominionGameAttributes.values())\n+                    .collect(Collectors.toMap(IGameAttribute::name, attr -> attr.get(state, null)));\n+            logger.record(data);\n+        } else if (type == CoreConstants.GameEvents.GAME_SEQUENCE_OVER) {\n+            logger.processDataAndFinish();\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onEvent(CoreConstants.GameEvents type, AbstractGameState state, AbstractAction action) {\n+        // nothing\n+    }\n+}"
  },
  {
    "sha": "6ff182634ada9eaaad84ad7961b7be2e85633a85",
    "filename": "src/main/java/games/tictactoe/TicTacToeConstants.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/games/tictactoe/TicTacToeConstants.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/games/tictactoe/TicTacToeConstants.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/games/tictactoe/TicTacToeConstants.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -9,4 +9,5 @@\n         add(new Token(\"x\"));\n         add(new Token(\"o\"));\n     }};\n+    public static final String emptyCell = \".\";\n }"
  },
  {
    "sha": "f1f203fc6b89a0a1e5091e0fca2e01a93c502127",
    "filename": "src/main/java/games/tictactoe/TicTacToeForwardModel.java",
    "status": "modified",
    "additions": 19,
    "deletions": 24,
    "changes": 43,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/games/tictactoe/TicTacToeForwardModel.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/games/tictactoe/TicTacToeForwardModel.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/games/tictactoe/TicTacToeForwardModel.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -1,13 +1,16 @@\n package games.tictactoe;\n \n+import core.AbstractForwardModel;\n+import core.AbstractGameState;\n import core.actions.AbstractAction;\n import core.actions.SetGridValueAction;\n-import core.components.Component;\n import core.components.GridBoard;\n-import core.*;\n import core.components.Token;\n import utilities.Utils;\n-import java.util.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n \n import static core.CoreConstants.VERBOSE;\n \n@@ -19,7 +22,7 @@ protected void _setup(AbstractGameState firstState) {\n         TicTacToeGameParameters tttgp = (TicTacToeGameParameters) firstState.getGameParameters();\n         int gridSize = tttgp.gridSize;\n         TicTacToeGameState state = (TicTacToeGameState)firstState;\n-        state.gridBoard = new GridBoard<>(gridSize, gridSize);\n+        state.gridBoard = new GridBoard<>(gridSize, gridSize, new Token(TicTacToeConstants.emptyCell));\n     }\n \n     @Override\n@@ -30,8 +33,8 @@ protected void _setup(AbstractGameState firstState) {\n \n         for (int x = 0; x < tttgs.gridBoard.getWidth(); x++){\n             for (int y = 0; y < tttgs.gridBoard.getHeight(); y++) {\n-                if (tttgs.gridBoard.getElement(x, y) == null)\n-                    actions.add(new SetGridValueAction(tttgs.gridBoard.getComponentID(), x, y, TicTacToeConstants.playerMapping.get(player)));\n+                if (tttgs.gridBoard.getElement(x, y).getTokenType().equals(TicTacToeConstants.emptyCell))\n+                    actions.add(new SetGridValueAction<>(tttgs.gridBoard.getComponentID(), x, y, TicTacToeConstants.playerMapping.get(player)));\n             }\n         }\n         return actions;\n@@ -68,11 +71,11 @@ private boolean checkGameEnd(TicTacToeGameState gameState){\n         // Check columns\n         for (int x = 0; x < gridBoard.getWidth(); x++){\n             Token c = gridBoard.getElement(x, 0);\n-            if (c != null) {\n+            if (!c.getTokenType().equals(TicTacToeConstants.emptyCell)) {\n                 boolean win = true;\n                 for (int y = 1; y < gridBoard.getHeight(); y++) {\n                     Token o = gridBoard.getElement(x, y);\n-                    if (o == null || !o.equals(c)) {\n+                    if (o.getTokenType().equals(TicTacToeConstants.emptyCell) || !o.equals(c)) {\n                         win = false;\n                         break;\n                     }\n@@ -87,11 +90,11 @@ private boolean checkGameEnd(TicTacToeGameState gameState){\n         // Check rows\n         for (int y = 0; y < gridBoard.getHeight(); y++){\n             Token c = gridBoard.getElement(0, y);\n-            if (c != null) {\n+            if (!c.getTokenType().equals(TicTacToeConstants.emptyCell)) {\n                 boolean win = true;\n                 for (int x = 1; x < gridBoard.getWidth(); x++) {\n                     Token o = gridBoard.getElement(x, y);\n-                    if (o == null || !o.equals(c)) {\n+                    if (o.getTokenType().equals(TicTacToeConstants.emptyCell) || !o.equals(c)) {\n                         win = false;\n                         break;\n                     }\n@@ -106,11 +109,11 @@ private boolean checkGameEnd(TicTacToeGameState gameState){\n         // Check diagonals\n         // Primary\n         Token c = gridBoard.getElement(0, 0);\n-        if (c != null) {\n+        if (!c.getTokenType().equals(TicTacToeConstants.emptyCell)) {\n             boolean win = true;\n             for (int i = 1; i < gridBoard.getWidth(); i++) {\n                 Token o = gridBoard.getElement(i, i);\n-                if (o == null || !o.equals(c)) {\n+                if (o.getTokenType().equals(TicTacToeConstants.emptyCell) || !o.equals(c)) {\n                     win = false;\n                 }\n             }\n@@ -122,11 +125,11 @@ private boolean checkGameEnd(TicTacToeGameState gameState){\n \n         // Secondary\n         c = gridBoard.getElement(gridBoard.getWidth()-1, 0);\n-        if (c != null) {\n+        if (!c.getTokenType().equals(TicTacToeConstants.emptyCell)) {\n             boolean win = true;\n             for (int i = 1; i < gridBoard.getWidth(); i++) {\n                 Token o = gridBoard.getElement(gridBoard.getWidth()-1-i, i);\n-                if (o == null || !o.equals(c)) {\n+                if (o.getTokenType().equals(TicTacToeConstants.emptyCell) || !o.equals(c)) {\n                     win = false;\n                 }\n             }\n@@ -135,16 +138,8 @@ private boolean checkGameEnd(TicTacToeGameState gameState){\n                 return true;\n             }\n         }\n-        boolean tie = true;\n-        Component[][] grid = gridBoard.getGridValues();\n-        for (Component[] row: grid){\n-            for (Component field: row){\n-                if (field == null) {\n-                    tie = false;\n-                    break;\n-                }\n-            }\n-        }\n+        boolean tie = gridBoard.getComponents().stream().noneMatch(t -> t.getTokenType().equals(TicTacToeConstants.emptyCell));\n+\n         if (tie){\n             gameState.setGameStatus(Utils.GameResult.DRAW);\n             Arrays.fill(gameState.getPlayerResults(), Utils.GameResult.DRAW);"
  },
  {
    "sha": "a60199aace1a78a878b2334e8a56b5ccb71815c0",
    "filename": "src/main/java/utilities/ActionListener.java",
    "status": "added",
    "additions": 40,
    "deletions": 0,
    "changes": 40,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/utilities/ActionListener.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/utilities/ActionListener.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/utilities/ActionListener.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -0,0 +1,40 @@\n+package utilities;\n+\n+import core.AbstractGameState;\n+import core.CoreConstants;\n+import core.Game;\n+import core.actions.AbstractAction;\n+import core.interfaces.IGameListener;\n+import core.interfaces.IStatisticLogger;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ActionListener implements IGameListener {\n+\n+    private IStatisticLogger logger;\n+\n+    public ActionListener(IStatisticLogger logger) {\n+        this.logger = logger;\n+    }\n+\n+    @Override\n+    public void onGameEvent(CoreConstants.GameEvents type, Game game) {\n+        // nothing\n+    }\n+\n+    @Override\n+    public void onEvent(CoreConstants.GameEvents type, AbstractGameState state, AbstractAction action) {\n+        if (type == CoreConstants.GameEvents.ACTION_CHOSEN) {\n+            Map<String, Object> data = new HashMap<>();\n+            data.put(\"GameID\", state.getGameID());\n+            data.put(\"Player\", state.getCurrentPlayer());\n+            data.put(\"Turn\", state.getTurnOrder().getTurnCounter());\n+            data.put(\"Round\", state.getTurnOrder().getRoundCounter());\n+            data.put(\"Action\", action.getClass().getSimpleName());\n+            data.put(\"Description\", action.getString(state));\n+            logger.record(data);\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "de643889f9922b17e71354ab21bdc59c56fefc92",
    "filename": "src/main/java/utilities/FileStatsLogger.java",
    "status": "modified",
    "additions": 8,
    "deletions": 6,
    "changes": 14,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/utilities/FileStatsLogger.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/utilities/FileStatsLogger.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/utilities/FileStatsLogger.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -2,10 +2,11 @@\n \n import core.interfaces.IStatisticLogger;\n \n-import java.io.*;\n+import java.io.FileWriter;\n+import java.io.IOException;\n import java.util.*;\n \n-import static java.util.stream.Collectors.*;\n+import static java.util.stream.Collectors.toList;\n \n /**\n  * A Class to log details to file for later analysis\n@@ -17,7 +18,7 @@\n     public String doubleFormat = \"%.3g\";\n     public String intFormat = \"%d\";\n \n-    private Set<String> allKeys = new HashSet<>();\n+    private Set<String> allKeys = new LinkedHashSet<>();\n \n     /**\n      * Note that one line will be output to the file per Map<String, ?>\n@@ -26,17 +27,18 @@\n      * @param fileName  The full location of the file to write results to\n      * @param delimiter The delimiter to use in the file between data items\n      */\n-    public FileStatsLogger(String fileName, String delimiter) {\n+    public FileStatsLogger(String fileName, String delimiter, boolean append) {\n         this.delimiter = delimiter;\n         try {\n-            writer = new FileWriter(fileName);\n+            writer = new FileWriter(fileName, append);\n         } catch (Exception e) {\n             e.printStackTrace();\n             throw new AssertionError(\"Problem opening file \" + fileName + \" : \" + e.getMessage());\n         }\n     }\n+\n     public FileStatsLogger(String fileName) {\n-        this(fileName, \"\\t\");\n+        this(fileName, \"\\t\", true);\n     }\n \n     /**"
  },
  {
    "sha": "1231d6a27fbda6c067c5ca42cbcde359bd16edfc",
    "filename": "src/main/java/utilities/GameReportListener.java",
    "status": "added",
    "additions": 144,
    "deletions": 0,
    "changes": 144,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/utilities/GameReportListener.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/utilities/GameReportListener.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/utilities/GameReportListener.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -0,0 +1,144 @@\n+package utilities;\n+\n+import core.AbstractForwardModel;\n+import core.AbstractGameState;\n+import core.CoreConstants;\n+import core.Game;\n+import core.actions.AbstractAction;\n+import core.interfaces.IComponentContainer;\n+import core.interfaces.IGameListener;\n+import core.interfaces.IStatisticLogger;\n+\n+import java.util.*;\n+import java.util.stream.IntStream;\n+\n+import static core.CoreConstants.GameEvents.*;\n+\n+public class GameReportListener implements IGameListener {\n+\n+    List<Double> scores = new ArrayList<>();\n+    List<Double> visibilityOnTurn = new ArrayList<>();\n+    List<Integer> components = new ArrayList<>();\n+    Map<String, Object> collectedData = new HashMap<>();\n+    AbstractForwardModel fm;\n+    IStatisticLogger logger;\n+\n+    public GameReportListener(IStatisticLogger logger) {\n+        this.logger = logger;\n+    }\n+    public GameReportListener() {\n+        this.logger = null;\n+    }\n+\n+    @Override\n+    public void onEvent(CoreConstants.GameEvents type, AbstractGameState state, AbstractAction actionChosen) {\n+        if (type == ACTION_CHOSEN) {\n+            // each action taken, we record branching factor and states (this is triggered when the decision is made,\n+            // so before it is executed\n+            int player = state.getCurrentPlayer();\n+            if (fm == null) {\n+                throw new AssertionError(\"We have not yet received an ABOUT_TO_START event to initialise the required ForwardModel\");\n+            }\n+            List<AbstractAction> allActions = fm.computeAvailableActions(state);\n+            if (allActions.size() < 2) return;\n+\n+            scores.add(state.getGameScore(player));\n+            Pair<Integer, int[]> allComp = countComponents(state);\n+            components.add(allComp.a);\n+            visibilityOnTurn.add(allComp.b[player] / (double) allComp.a);\n+        }\n+    }\n+\n+    @Override\n+    public void onGameEvent(CoreConstants.GameEvents type, Game game) {\n+        if (type == ABOUT_TO_START) {\n+            AbstractGameState state = game.getGameState();\n+            long s = System.nanoTime();\n+            fm = game.getForwardModel();\n+\n+            collectedData.put(\"Game\", game.getGameState().getGameID());\n+            collectedData.put(\"Players\", String.valueOf(game.getGameState().getNPlayers()));\n+            collectedData.put(\"PlayerType\", game.getPlayers().get(0).toString());\n+            fm.setup(state);\n+            collectedData.put(\"TimeSetup\", (System.nanoTime() - s) / 1e3);\n+\n+            Pair<Integer, int[]> components = countComponents(state);\n+            collectedData.put(\"StateSizeStart\", components.a);\n+            collectedData.put(\"HiddenInfoStart\", Arrays.stream(components.b).sum() / (double) components.a / state.getNPlayers());\n+        } else if (type == GAME_OVER) {\n+            //    Retrieves a list with one entry per game tick, each a pair (active player ID, # actions)\n+            List<Pair<Integer, Integer>> actionSpaceRecord = game.getActionSpaceSize();\n+            TAGStatSummary stats = actionSpaceRecord.stream()\n+                    .map(r -> r.b)\n+                    .filter(size -> size > 1)\n+                    .collect(new TAGSummariser());\n+            collectedData.put(\"ActionSpaceMean\", stats.mean());\n+            collectedData.put(\"ActionSpaceMin\", stats.min());\n+            collectedData.put(\"ActionSpaceMedian\", stats.median());\n+            collectedData.put(\"ActionSpaceMax\", stats.max());\n+            collectedData.put(\"ActionSpaceSkew\", stats.skew());\n+            collectedData.put(\"ActionSpaceKurtosis\", stats.kurtosis());\n+            collectedData.put(\"ActionSpaceVarCoeff\", Math.abs(stats.sd() / stats.mean()));\n+            collectedData.put(\"Decisions\", stats.n());\n+            collectedData.put(\"TimeNext\", game.getNextTime() / 1e3);\n+            collectedData.put(\"TimeCopy\", game.getCopyTime() / 1e3);\n+            collectedData.put(\"TimeActionCompute\", game.getActionComputeTime() / 1e3);\n+            collectedData.put(\"TimeAgent\", game.getAgentTime() / 1e3);\n+\n+            collectedData.put(\"Ticks\", game.getTick());\n+            collectedData.put(\"Rounds\", game.getGameState().getTurnOrder().getRoundCounter());\n+            collectedData.put(\"ActionsPerTurn\", game.getNActionsPerTurn());\n+\n+            TAGStatSummary sc = scores.stream().collect(new TAGSummariser());\n+            collectedData.put(\"ScoreMedian\", sc.median());\n+            collectedData.put(\"ScoreMean\", sc.mean());\n+            collectedData.put(\"ScoreMax\", sc.max());\n+            collectedData.put(\"ScoreMin\", sc.min());\n+            collectedData.put(\"ScoreVarCoeff\", Math.abs(sc.sd() / sc.mean()));\n+            TAGStatSummary scoreDelta = scores.size() > 1 ?\n+                    IntStream.range(0, scores.size() - 1)\n+                            .mapToObj(i -> !scores.get(i + 1).equals(scores.get(i)) ? 1.0 : 0.0)\n+                            .collect(new TAGSummariser())\n+                    : new TAGStatSummary();\n+            collectedData.put(\"ScoreDelta\", scoreDelta.mean()); // percentage of actions that lead to a change in score\n+\n+            TAGStatSummary stateSize = components.stream().collect(new TAGSummariser());\n+            collectedData.put(\"StateSizeMedian\", stateSize.median());\n+            collectedData.put(\"StateSizeMean\", stateSize.mean());\n+            collectedData.put(\"StateSizeMax\", stateSize.max());\n+            collectedData.put(\"StateSizeMin\", stateSize.min());\n+            collectedData.put(\"StateSizeVarCoeff\", Math.abs(stateSize.sd() / stateSize.mean()));\n+\n+            TAGStatSummary visibility = visibilityOnTurn.stream().collect(new TAGSummariser());\n+            collectedData.put(\"HiddenInfoMedian\", visibility.median());\n+            collectedData.put(\"HiddenInfoMean\", visibility.mean());\n+            collectedData.put(\"HiddenInfoMax\", visibility.max());\n+            collectedData.put(\"HiddenInfoMin\", visibility.min());\n+            collectedData.put(\"HiddenInfoVarCoeff\", Math.abs(visibility.sd() / visibility.mean()));\n+\n+            logger.record(collectedData);\n+            collectedData = new HashMap<>();\n+        } else if (type == GAME_SEQUENCE_OVER) {\n+            logger.processDataAndFinish();\n+        }\n+    }\n+\n+    /**\n+     * Returns the total number of components in the state as the first element of the returned value\n+     * and an array of the counts that are hidden to each player\n+     * <p>\n+     *\n+     * @param state\n+     * @return The total number of components\n+     */\n+    private Pair<Integer, int[]> countComponents(AbstractGameState state) {\n+        int[] hiddenByPlayer = new int[state.getNPlayers()];\n+        // we do not include containers in the count...just the lowest-level items\n+        // open to debate on this. But we are consistent across State Size and Hidden Information stats\n+        int total = (int) state.getAllComponents().stream().filter(c -> !(c instanceof IComponentContainer)).count();\n+        for (int p = 0; p < hiddenByPlayer.length; p++)\n+            hiddenByPlayer[p] = state.getUnknownComponentsIds(p).size();\n+        return new Pair<>(total, hiddenByPlayer);\n+    }\n+\n+}"
  },
  {
    "sha": "704333d424f44755c371459ee9035589fe715d50",
    "filename": "src/main/java/utilities/SummaryLogger.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/GAIGResearch/TabletopGames/blob/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/utilities/SummaryLogger.java",
    "raw_url": "https://github.com/GAIGResearch/TabletopGames/raw/8d4b9f8a98bc233020c75132d3b0db3933392535/src/main/java/utilities/SummaryLogger.java",
    "contents_url": "https://api.github.com/repos/GAIGResearch/TabletopGames/contents/src/main/java/utilities/SummaryLogger.java?ref=8d4b9f8a98bc233020c75132d3b0db3933392535",
    "patch": "@@ -8,7 +8,7 @@\n import static java.util.stream.Collectors.*;\n \n /**\n- * Statistics Logger that just takes in Numeric data and maintains summery statistics for each type:\n+ * Statistics Logger that just takes in Numeric data and maintains summary statistics for each type:\n  * - mean, min, max, standard error, standard deviation, n\n  * A summary is printed out in alphabetic order once finished.\n  */"
  }
]
