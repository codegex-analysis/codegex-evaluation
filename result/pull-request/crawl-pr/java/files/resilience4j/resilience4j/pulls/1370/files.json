[
  {
    "sha": "7c627c8483404624e94868a9e2655c7f57c69f74",
    "filename": "resilience4j-ratelimiter/src/jmh/java/io/github/resilience4j/ratelimiter/RateLimiterBenchmark.java",
    "status": "modified",
    "additions": 21,
    "deletions": 0,
    "changes": 21,
    "blob_url": "https://github.com/resilience4j/resilience4j/blob/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/jmh/java/io/github/resilience4j/ratelimiter/RateLimiterBenchmark.java",
    "raw_url": "https://github.com/resilience4j/resilience4j/raw/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/jmh/java/io/github/resilience4j/ratelimiter/RateLimiterBenchmark.java",
    "contents_url": "https://api.github.com/repos/resilience4j/resilience4j/contents/resilience4j-ratelimiter/src/jmh/java/io/github/resilience4j/ratelimiter/RateLimiterBenchmark.java?ref=4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2",
    "patch": "@@ -19,6 +19,7 @@\n package io.github.resilience4j.ratelimiter;\n \n import io.github.resilience4j.ratelimiter.internal.AtomicRateLimiter;\n+import io.github.resilience4j.ratelimiter.internal.RefillRateLimiter;\n import io.github.resilience4j.ratelimiter.internal.SemaphoreBasedRateLimiter;\n import org.openjdk.jmh.annotations.*;\n import org.openjdk.jmh.infra.Blackhole;\n@@ -44,9 +45,11 @@\n \n     private RateLimiter semaphoreBasedRateLimiter;\n     private AtomicRateLimiter atomicRateLimiter;\n+    private RefillRateLimiter refillRateLimiter;\n \n     private Supplier<String> semaphoreGuardedSupplier;\n     private Supplier<String> atomicGuardedSupplier;\n+    private Supplier<String> refillGuardedSupplier;\n \n     public static void main(String[] args) throws RunnerException {\n         Options options = new OptionsBuilder()\n@@ -62,9 +65,17 @@ public void setUp() {\n             .limitRefreshPeriod(Duration.ofNanos(10))\n             .timeoutDuration(Duration.ofSeconds(5))\n             .build();\n+\n+        RefillRateLimiterConfig refillRateLimiterConfig = RefillRateLimiterConfig.custom()\n+            .limitForPeriod(1)\n+            .limitRefreshPeriod(Duration.ofNanos(1))\n+            .timeoutDuration(Duration.ofSeconds(5))\n+            .build();\n+\n         semaphoreBasedRateLimiter = new SemaphoreBasedRateLimiter(\"semaphoreBased\",\n             rateLimiterConfig);\n         atomicRateLimiter = new AtomicRateLimiter(\"atomicBased\", rateLimiterConfig);\n+        refillRateLimiter = new RefillRateLimiter(\"refillBased\", refillRateLimiterConfig);\n \n         Supplier<String> stringSupplier = () -> {\n             Blackhole.consumeCPU(1);\n@@ -73,6 +84,7 @@ public void setUp() {\n         semaphoreGuardedSupplier = RateLimiter\n             .decorateSupplier(semaphoreBasedRateLimiter, stringSupplier);\n         atomicGuardedSupplier = RateLimiter.decorateSupplier(atomicRateLimiter, stringSupplier);\n+        refillGuardedSupplier = RateLimiter.decorateSupplier(refillRateLimiter, stringSupplier);\n     }\n \n     @Benchmark\n@@ -92,4 +104,13 @@ public String semaphoreBasedPermission() {\n     public String atomicPermission() {\n         return atomicGuardedSupplier.get();\n     }\n+\n+    @Benchmark\n+    @Threads(value = THREAD_COUNT)\n+    @Warmup(iterations = WARMUP_COUNT)\n+    @Fork(value = FORK_COUNT)\n+    @Measurement(iterations = ITERATION_COUNT)\n+    public String refillPermission() {\n+        return refillGuardedSupplier.get();\n+    }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "31a27af31e7906119dcc67492ebff7a7a9c04bbd",
    "filename": "resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/resilience4j/resilience4j/blob/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java",
    "raw_url": "https://github.com/resilience4j/resilience4j/raw/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java",
    "contents_url": "https://api.github.com/repos/resilience4j/resilience4j/contents/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java?ref=4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2",
    "patch": "@@ -24,6 +24,7 @@\n import io.github.resilience4j.ratelimiter.event.RateLimiterOnFailureEvent;\n import io.github.resilience4j.ratelimiter.event.RateLimiterOnSuccessEvent;\n import io.github.resilience4j.ratelimiter.internal.AtomicRateLimiter;\n+import io.github.resilience4j.ratelimiter.internal.RefillRateLimiter;\n import io.vavr.CheckedFunction0;\n import io.vavr.CheckedFunction1;\n import io.vavr.CheckedRunnable;\n@@ -72,6 +73,11 @@ static RateLimiter of(String name, RateLimiterConfig rateLimiterConfig,\n         return new AtomicRateLimiter(name, rateLimiterConfig, tags);\n     }\n \n+    static RateLimiter of(String name, RefillRateLimiterConfig rateLimiterConfig,\n+                          Map<String, String> tags) {\n+        return new RefillRateLimiter(name, rateLimiterConfig, tags);\n+    }\n+\n     /**\n      * Creates a RateLimiter with a custom RateLimiterConfig configuration.\n      *"
  },
  {
    "sha": "37326b35353d8dc9897774d999d65484715ec451",
    "filename": "resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiterConfig.java",
    "status": "modified",
    "additions": 4,
    "deletions": 5,
    "changes": 9,
    "blob_url": "https://github.com/resilience4j/resilience4j/blob/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiterConfig.java",
    "raw_url": "https://github.com/resilience4j/resilience4j/raw/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiterConfig.java",
    "contents_url": "https://api.github.com/repos/resilience4j/resilience4j/contents/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiterConfig.java?ref=4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2",
    "patch": "@@ -41,7 +41,7 @@\n     private final Predicate<Either<? extends Throwable, ?>> drainPermissionsOnResult;\n     private final boolean writableStackTraceEnabled;\n \n-    private RateLimiterConfig(Duration timeoutDuration,\n+    protected RateLimiterConfig(Duration timeoutDuration,\n                               Duration limitRefreshPeriod,\n                               int limitForPeriod,\n                               Predicate<Either<? extends Throwable, ?>> drainPermissionsOnResult,\n@@ -52,7 +52,6 @@ private RateLimiterConfig(Duration timeoutDuration,\n         this.drainPermissionsOnResult = drainPermissionsOnResult;\n         this.writableStackTraceEnabled = writableStackTraceEnabled;\n     }\n-\n     /**\n      * Returns a builder to create a custom RateLimiterConfig.\n      *\n@@ -81,11 +80,11 @@ public static RateLimiterConfig ofDefaults() {\n         return new Builder().build();\n     }\n \n-    private static Duration checkTimeoutDuration(final Duration timeoutDuration) {\n+    protected static Duration checkTimeoutDuration(final Duration timeoutDuration) {\n         return requireNonNull(timeoutDuration, TIMEOUT_DURATION_MUST_NOT_BE_NULL);\n     }\n \n-    private static Duration checkLimitRefreshPeriod(Duration limitRefreshPeriod) {\n+    protected static Duration checkLimitRefreshPeriod(Duration limitRefreshPeriod) {\n         requireNonNull(limitRefreshPeriod, LIMIT_REFRESH_PERIOD_MUST_NOT_BE_NULL);\n         boolean refreshPeriodIsTooShort =\n             limitRefreshPeriod.compareTo(ACCEPTABLE_REFRESH_PERIOD) < 0;\n@@ -95,7 +94,7 @@ private static Duration checkLimitRefreshPeriod(Duration limitRefreshPeriod) {\n         return limitRefreshPeriod;\n     }\n \n-    private static int checkLimitForPeriod(final int limitForPeriod) {\n+    protected static int checkLimitForPeriod(final int limitForPeriod) {\n         if (limitForPeriod < 1) {\n             throw new IllegalArgumentException(\"LimitForPeriod should be greater than 0\");\n         }"
  },
  {
    "sha": "7b8a66390f0ddca066b617064ea0d98b995d296e",
    "filename": "resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RefillRateLimiterConfig.java",
    "status": "added",
    "additions": 278,
    "deletions": 0,
    "changes": 278,
    "blob_url": "https://github.com/resilience4j/resilience4j/blob/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RefillRateLimiterConfig.java",
    "raw_url": "https://github.com/resilience4j/resilience4j/raw/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RefillRateLimiterConfig.java",
    "contents_url": "https://api.github.com/repos/resilience4j/resilience4j/contents/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RefillRateLimiterConfig.java?ref=4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2",
    "patch": "@@ -0,0 +1,278 @@\n+/*\n+ *\n+ *  Copyright 2020 Emmanouil Gkatziouras\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ *\n+ */\n+package io.github.resilience4j.ratelimiter;\n+\n+import io.github.resilience4j.ratelimiter.internal.RefillRateLimiter;\n+import io.vavr.control.Either;\n+\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.util.function.Predicate;\n+\n+/**\n+ * {@link RefillRateLimiter} is a permission rate based Rate Limiter.\n+ * Instead of resetting permits based on a permission period the permission release is based on a rate.\n+ * Therefore {@link RefillRateLimiterConfig#nanosPerPermit} is used which is a product of the division\n+ * of {@link RateLimiterConfig#limitRefreshPeriod} to {@link RateLimiterConfig#limitForPeriod}.\n+ */\n+public class RefillRateLimiterConfig extends RateLimiterConfig implements Serializable{\n+\n+    private static final long serialVersionUID = 3095810082683985263L;\n+\n+    private static final boolean DEFAULT_WRITABLE_STACK_TRACE_ENABLED = true;\n+    private static final String ZERO_NANOS_PER_PERMISSION_STATE = \"Current settings lead to zero nanos per permission, adjust period and limit\";\n+    private static final String ZERO_NANOS_PER_PERMISSION_ARGUMENT = \"At least 1 nanos per permission should be provided\";\n+\n+    private final int permitCapacity;\n+    private final long nanosPerFullCapacity;\n+    private final int initialPermits;\n+    private final long nanosPerPermit;\n+\n+    private static Predicate<Either<? extends Throwable, ?>> drainPermissionsOnResult = any -> false;\n+\n+    private RefillRateLimiterConfig(Duration timeoutDuration, int permitCapacity, long nanosPerPermit,\n+                                    long nanosPerFullCapacity,\n+                                    int initialPermits, boolean writableStackTraceEnabled) {\n+        super(timeoutDuration, Duration.ofNanos(nanosPerPermit * permitCapacity), permitCapacity, drainPermissionsOnResult, writableStackTraceEnabled);\n+        noZeroNanosOnPermissionArgument(nanosPerPermit);\n+        this.permitCapacity = permitCapacity;\n+        this.nanosPerFullCapacity = nanosPerFullCapacity;\n+        this.initialPermits = initialPermits;\n+        this.nanosPerPermit = nanosPerPermit;\n+    }\n+\n+    /**\n+     * Returns a builder to create a custom RefillRateLimiterConfig.\n+     *\n+     * @return a {@link RefillRateLimiterConfig.Builder}\n+     */\n+    public static RefillRateLimiterConfig.Builder custom() {\n+        return new RefillRateLimiterConfig.Builder();\n+    }\n+\n+    /**\n+     * Returns a builder to create a custom RefillRateLimiterConfig using specified config as prototype\n+     *\n+     * @param prototype A {@link RefillRateLimiterConfig} prototype.\n+     * @return a {@link RefillRateLimiterConfig.Builder}\n+     */\n+    public static RefillRateLimiterConfig.Builder from(RefillRateLimiterConfig prototype) {\n+        return new RefillRateLimiterConfig.Builder(prototype);\n+    }\n+\n+    /**\n+     * Creates a default RefillRateLimiter configuration.\n+     *\n+     * @return a default RefillRateLimiter configuration.\n+     */\n+    public static RefillRateLimiterConfig ofDefaults() {\n+        return new RefillRateLimiterConfig.Builder().build();\n+    }\n+\n+    /**\n+     * Get the permit capacity the RefillRateLimiter should have.\n+     *\n+     * @return\n+     */\n+    public int getPermitCapacity() {\n+        return permitCapacity;\n+    }\n+\n+    /**\n+     * Get the permits the RefillRateLimiter is configured to start with.\n+     *\n+     * @return\n+     */\n+    public int getInitialPermits() {\n+        return initialPermits;\n+    }\n+\n+    /**\n+     * Get the nanos needed to replenish one permit.\n+     *\n+     * @return\n+     */\n+    public long getNanosPerPermit() {\n+        return nanosPerPermit;\n+    }\n+\n+    /**\n+     * Get the nanos needed to reach full capacity\n+     * @return\n+     */\n+    public long getNanosPerFullCapacity() {\n+        return nanosPerFullCapacity;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RefillRateLimiterConfig{\" +\n+            \"timeoutDuration=\" + getTimeoutDuration() +\n+            \", permitCapacity=\" + permitCapacity +\n+            \", nanosPerPermission=\" + nanosPerPermit +\n+            \", writableStackTraceEnabled=\" + isWritableStackTraceEnabled() +\n+            '}';\n+    }\n+\n+    public static class Builder extends RateLimiterConfig.Builder {\n+\n+        private Duration timeoutDuration = Duration.ofSeconds(5);\n+        private Duration limitRefreshPeriod = Duration.ofNanos(500);\n+        private int limitForPeriod = 50;\n+        private int permitCapacity = 0;\n+        private int initialPermits = 0;\n+        private boolean initialPermitsSet;\n+        private boolean writableStackTraceEnabled = DEFAULT_WRITABLE_STACK_TRACE_ENABLED;\n+\n+        public Builder() {\n+        }\n+\n+        public Builder(RefillRateLimiterConfig prototype) {\n+            this.timeoutDuration = prototype.getTimeoutDuration();\n+            this.limitRefreshPeriod = Duration.ofNanos(prototype.nanosPerPermit);\n+            this.limitForPeriod = 1;\n+            this.permitCapacity = prototype.permitCapacity;\n+            this.writableStackTraceEnabled = prototype.isWritableStackTraceEnabled();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public RefillRateLimiterConfig build() {\n+            if (permitCapacity < limitForPeriod) {\n+                permitCapacity = limitForPeriod;\n+            }\n+\n+            if (!initialPermitsSet) {\n+                initialPermits = limitForPeriod;\n+            }\n+\n+            final long nanosPerPermission = calculateNanosPerPermit(limitRefreshPeriod, limitForPeriod);\n+            noZeroNanosOnPermissionState(nanosPerPermission);\n+\n+            final long nanosPerFullCapacity = calculateNanosPerFullCapacity(nanosPerPermission, permitCapacity);\n+\n+            return new RefillRateLimiterConfig(timeoutDuration, permitCapacity, nanosPerPermission, nanosPerFullCapacity,\n+                initialPermits, writableStackTraceEnabled);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public RefillRateLimiterConfig.Builder writableStackTraceEnabled(boolean writableStackTraceEnabled) {\n+            this.writableStackTraceEnabled = writableStackTraceEnabled;\n+            return this;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public RefillRateLimiterConfig.Builder timeoutDuration(final Duration timeoutDuration) {\n+            this.timeoutDuration = checkTimeoutDuration(timeoutDuration);\n+            return this;\n+        }\n+\n+        /**\n+         * Configures the period needed for the permit number specified. After each period\n+         * permissions up to {@link RefillRateLimiterConfig.Builder#limitForPeriod} should be released.\n+         * Default value is 500 nanoseconds.\n+         *\n+         * @param limitRefreshPeriod the period of limit refresh\n+         * @return the RefillRateLimiterConfig.Builder\n+         */\n+        @Override\n+        public RefillRateLimiterConfig.Builder limitRefreshPeriod(final Duration limitRefreshPeriod) {\n+            this.limitRefreshPeriod = checkLimitRefreshPeriod(limitRefreshPeriod);\n+            return this;\n+        }\n+\n+        /**\n+         * Configures the permits to release through a refresh period. Count of permissions released\n+         * during one rate limiter period specified by {@link RefillRateLimiterConfig.Builder#limitRefreshPeriod}\n+         * value. Default value is 50.\n+         *\n+         * @param limitForPeriod the permissions limit for refresh period\n+         * @return the RefillRateLimiterConfig.Builder\n+         */\n+        @Override\n+        public RefillRateLimiterConfig.Builder limitForPeriod(final int limitForPeriod) {\n+            this.limitForPeriod = checkLimitForPeriod(limitForPeriod);\n+            return this;\n+        }\n+\n+        /**\n+         * Configures the permissions capacity. Count of max permissions available\n+         * If no value specified the default value is the one\n+         * specified for {@link RefillRateLimiterConfig.Builder#limitForPeriod}.\n+         *\n+         * @param permitCapacity the capacity of permissions\n+         * @return the RateLimiterConfig.Builder\n+         */\n+        public RefillRateLimiterConfig.Builder permitCapacity(final int permitCapacity) {\n+            this.permitCapacity = permitCapacity;\n+            return this;\n+        }\n+\n+        /**\n+         * Configures the initial permit available.\n+         * If no value specified the default value is the one\n+         * specified for {@link RefillRateLimiterConfig.Builder#limitForPeriod}.\n+         *\n+         * @param initialPermits the initial permits\n+         * @return the RateLimiterConfig.Builder\n+         */\n+        public RefillRateLimiterConfig.Builder initialPermits(final int initialPermits) {\n+            this.initialPermits = initialPermits;\n+            this.initialPermitsSet = true;\n+            return this;\n+        }\n+\n+        /**\n+         * Calculate the nanos needed for one permit\n+         *\n+         * @param limitRefreshPeriod\n+         * @param limitForPeriod\n+         * @return\n+         */\n+        private long calculateNanosPerPermit(Duration limitRefreshPeriod, int limitForPeriod) {\n+            long permissionsPeriodInNanos = limitRefreshPeriod.toNanos();\n+            return permissionsPeriodInNanos / limitForPeriod;\n+        }\n+\n+        private long calculateNanosPerFullCapacity(long nanosPerPermission, long permitCapacity) {\n+            return nanosPerPermission * permitCapacity;\n+        }\n+    }\n+\n+    private static void noZeroNanosOnPermissionArgument(long nanosPerPermit ) {\n+        if(nanosPerPermit<=0) {\n+            throw new IllegalArgumentException(ZERO_NANOS_PER_PERMISSION_ARGUMENT);\n+        }\n+    }\n+\n+    private static void noZeroNanosOnPermissionState(long nanosPerPermit ) {\n+        if(nanosPerPermit<=0) {\n+            throw new IllegalStateException(ZERO_NANOS_PER_PERMISSION_STATE);\n+        }\n+    }\n+\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "b62248236b0f948fa27ca522934b76afa81b4599",
    "filename": "resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/RefillRateLimiter.java",
    "status": "added",
    "additions": 510,
    "deletions": 0,
    "changes": 510,
    "blob_url": "https://github.com/resilience4j/resilience4j/blob/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/RefillRateLimiter.java",
    "raw_url": "https://github.com/resilience4j/resilience4j/raw/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/RefillRateLimiter.java",
    "contents_url": "https://api.github.com/repos/resilience4j/resilience4j/contents/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/RefillRateLimiter.java?ref=4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2",
    "patch": "@@ -0,0 +1,510 @@\n+/*\n+ *\n+ *  Copyright 2020 Emmanouil Gkatziouras\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ *\n+ */\n+package io.github.resilience4j.ratelimiter.internal;\n+\n+import io.github.resilience4j.ratelimiter.RateLimiter;\n+import io.github.resilience4j.ratelimiter.RateLimiterConfig;\n+import io.github.resilience4j.ratelimiter.RefillRateLimiterConfig;\n+import io.github.resilience4j.ratelimiter.RequestNotPermitted;\n+import io.github.resilience4j.ratelimiter.event.RateLimiterOnDrainedEvent;\n+import io.github.resilience4j.ratelimiter.event.RateLimiterOnFailureEvent;\n+import io.github.resilience4j.ratelimiter.event.RateLimiterOnSuccessEvent;\n+import io.vavr.collection.HashMap;\n+import io.vavr.collection.Map;\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static java.lang.Integer.min;\n+import static java.lang.System.nanoTime;\n+import static java.lang.Thread.currentThread;\n+import static java.util.concurrent.locks.LockSupport.parkNanos;\n+\n+/**\n+ * {@link RefillRateLimiter} has a max capacity of permits refilled periodically.\n+ * <p>Each period has duration of {@link RefillRateLimiterConfig#limitRefreshPeriod} in nanoseconds.\n+ * <p>By contract the initial {@link RefillRateLimiter.State#activePermissions} are set\n+ * to be the same with{@link RefillRateLimiterConfig#permitCapacity}\n+ * <p>A ratio of permit per nanoseconds is calculated using\n+ * {@link RefillRateLimiterConfig#limitRefreshPeriod} and {@link RefillRateLimiterConfig#limitForPeriod}.\n+ * On a permit request the permits that should have been replenished are calculated based on the nanos passed and the ratio of nanos per permit.\n+ * For the {@link RefillRateLimiter} callers it is looks like a token bucket supporting bursts and a gradual refill,\n+ * under the hood there is some optimisations that will skip this refresh if {@link RefillRateLimiter} is not used actively.\n+ * <p>All {@link RefillRateLimiter} updates are atomic and state is encapsulated in {@link\n+ * AtomicReference} to {@link RefillRateLimiter.State}\n+ */\n+public class RefillRateLimiter implements RateLimiter {\n+\n+    private final long nanoTimeStart;\n+    private final String name;\n+    private final AtomicInteger waitingThreads;\n+    private final AtomicReference<State> state;\n+    private final Map<String, String> tags;\n+    private final RateLimiterEventProcessor eventProcessor;\n+\n+    public RefillRateLimiter(String name, RefillRateLimiterConfig rateLimiterConfig) {\n+        this(name, rateLimiterConfig, HashMap.empty());\n+    }\n+\n+    public RefillRateLimiter(String name, RefillRateLimiterConfig rateLimiterConfig,\n+                             Map<String, String> tags) {\n+        this(name, rateLimiterConfig, tags, nanoTime());\n+    }\n+\n+    public RefillRateLimiter(String name, RefillRateLimiterConfig rateLimiterConfig,\n+                             Map<String, String> tags, long nanoTime) {\n+        this.name = name;\n+        this.tags = tags;\n+        this.nanoTimeStart = nanoTime();\n+\n+        waitingThreads = new AtomicInteger(0);\n+        state = new AtomicReference<>(new RefillRateLimiter.State(\n+            rateLimiterConfig, rateLimiterConfig.getInitialPermits(), 0, nanoTime\n+        ));\n+        eventProcessor = new RateLimiterEventProcessor();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void changeTimeoutDuration(final Duration timeoutDuration) {\n+        RefillRateLimiterConfig newConfig = RefillRateLimiterConfig.from(state.get().config)\n+            .timeoutDuration(timeoutDuration)\n+            .build();\n+        state.updateAndGet(currentState -> new RefillRateLimiter.State(\n+            newConfig, currentState.activePermissions, currentState.nanosToWait,\n+            currentState.timeIndex\n+        ));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void changeLimitForPeriod(final int limitForPeriod) {\n+        RefillRateLimiterConfig newConfig = RefillRateLimiterConfig.from(state.get().config)\n+            .limitForPeriod(limitForPeriod)\n+            .build();\n+        state.updateAndGet(currentState -> new RefillRateLimiter.State(\n+            newConfig, currentState.activePermissions, currentState.nanosToWait,\n+            currentState.timeIndex\n+        ));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean acquirePermission(final int permits) {\n+        long timeoutInNanos = state.get().getTimeoutInNanos();\n+        State modifiedState = updateStateWithBackOff(permits, timeoutInNanos);\n+        boolean result = waitForPermissionIfNecessary(timeoutInNanos, modifiedState.getNanosToWait());\n+        publishRateLimiterAcquisitionEvent(result, permits);\n+        return result;\n+    }\n+\n+    protected void publishRateLimiterAcquisitionEvent(boolean permissionAcquired, int permits) {\n+        if (!eventProcessor.hasConsumers()) {\n+            return;\n+        }\n+        if (permissionAcquired) {\n+            eventProcessor.consumeEvent(new RateLimiterOnSuccessEvent(name, permits));\n+            return;\n+        }\n+        eventProcessor.consumeEvent(new RateLimiterOnFailureEvent(name, permits));\n+    }\n+\n+    /**\n+     * Atomically updates the current {@link State} with the results of applying the {@link\n+     * RefillRateLimiter#calculateNextState}, returning the updated {@link State}. It differs from\n+     * {@link AtomicReference#updateAndGet(UnaryOperator)} by constant back off. It means that after\n+     * one try to {@link AtomicReference#compareAndSet(Object, Object)} this method will wait for a\n+     * while before try one more time. This technique was originally described in this\n+     * <a href=\"https://arxiv.org/abs/1305.5800\"> paper</a>\n+     * and showed great results with {@link AtomicRateLimiter} in benchmark tests.\n+     *\n+     * @param timeoutInNanos a side-effect-free function\n+     * @return the updated value\n+     */\n+    protected State updateStateWithBackOff(final int permits, final long timeoutInNanos) {\n+        State prev;\n+        State next;\n+        do {\n+            prev = state.get();\n+            next = calculateNextState(permits, timeoutInNanos, prev);\n+        } while (!compareAndSet(prev, next));\n+        return next;\n+    }\n+\n+    /**\n+     * If nanosToWait is bigger than 0 it tries to park {@link Thread} for nanosToWait but not\n+     * longer then timeoutInNanos.\n+     *\n+     * @param timeoutInNanos max time that caller can wait\n+     * @param nanosToWait    nanoseconds caller need to wait\n+     * @return true if caller was able to wait for nanosToWait without {@link Thread#interrupt} and\n+     * not exceed timeout\n+     */\n+    protected boolean waitForPermissionIfNecessary(final long timeoutInNanos,\n+                                                   final long nanosToWait) {\n+        boolean canAcquireImmediately = nanosToWait <= 0;\n+\n+        if (canAcquireImmediately) {\n+            return true;\n+        }\n+\n+        boolean canAcquireInTime = timeoutInNanos >= nanosToWait;\n+\n+        if (canAcquireInTime) {\n+            return waitForPermission(nanosToWait);\n+        }\n+        waitForPermission(timeoutInNanos);\n+        return false;\n+    }\n+\n+    /**\n+     * Parks {@link Thread} for nanosToWait.\n+     * <p>If the current thread is {@linkplain Thread#interrupted}\n+     * while waiting for a permit then it won't throw {@linkplain InterruptedException}, but its\n+     * interrupt status will be set.\n+     *\n+     * @param nanosToWait nanoseconds caller need to wait\n+     * @return true if caller was not {@link Thread#interrupted} while waiting\n+     */\n+    private boolean waitForPermission(final long nanosToWait) {\n+        waitingThreads.incrementAndGet();\n+        long deadline = currentNanoTime() + nanosToWait;\n+        boolean wasInterrupted = false;\n+        while (currentNanoTime() < deadline && !wasInterrupted) {\n+            long sleepBlockDuration = deadline - currentNanoTime();\n+            parkNanos(sleepBlockDuration);\n+            wasInterrupted = Thread.interrupted();\n+        }\n+        waitingThreads.decrementAndGet();\n+        if (wasInterrupted) {\n+            currentThread().interrupt();\n+        }\n+        return !wasInterrupted;\n+    }\n+\n+    /**\n+     * Calculates time elapsed from the class loading.\n+     */\n+    protected long currentNanoTime() {\n+        return nanoTime() - nanoTimeStart;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    protected State calculateNextState(final int permits, final long timeoutInNanos,\n+                                       final State activeState) {\n+        int permissionsNeededExtra = permissionsMissing(permits, activeState.activePermissions);\n+\n+        long currentNanoTime = refillLimiterNanoTime();\n+\n+        if(permissionsNeededExtra<=0) {\n+            return new State(activeState.config, -permissionsNeededExtra, 0, activeState.timeIndex);\n+        } else {\n+            assertLessPermitsThanCapacity(permits, activeState);\n+            return lazyPermissionCalculation(permits ,permissionsNeededExtra, activeState, currentNanoTime, timeoutInNanos);\n+        }\n+    }\n+\n+\n+\n+\n+    private void assertLessPermitsThanCapacity(int permits, State activeState) {\n+        if(permits > activeState.config.getPermitCapacity()) {\n+            throw RequestNotPermitted.createRequestNotPermitted(this);\n+        }\n+    }\n+\n+    private State lazyPermissionCalculation(int permits,int permissionsNeededExtra, final State activeState, long currentNanoTime, long timeoutInNanos) {\n+        RefillRateLimiterConfig config = activeState.config;\n+\n+        long nanosSinceLastUpdate = currentNanoTime - activeState.timeIndex;\n+\n+        if(nanosSinceLastUpdate >= config.getNanosPerFullCapacity()) {\n+            /**\n+             * We reached our max capacity. We remove the permits from the max capacity\n+             * Regardless of the permits leased previously our permits could not exceeded the max\n+             * so we clean up\n+             */\n+            int permitsLeft = config.getPermitCapacity() - permits;\n+            return new State(activeState.config, permitsLeft, 0, currentNanoTime);\n+        } else {\n+            /**\n+             * We have not reached the max capacity. Thus we need to calculate the extra permissions needed.\n+             */\n+            long nanosForPermissions = nanosNeededForExtraPermissions(permissionsNeededExtra, config);\n+            long nanosToCurrentIndex = activeState.timeIndex + nanosForPermissions;\n+\n+            long nanosToWait = nanosForPermissions - nanosSinceLastUpdate;\n+\n+            if(nanosToWait>0) {\n+                boolean canAcquireInTime = timeoutInNanos >= nanosToWait;\n+\n+                if(canAcquireInTime) {\n+                    return new State(config, 0, nanosToWait, nanosToCurrentIndex);\n+                } else {\n+                    return new State(activeState.config, activeState.activePermissions, nanosToWait, activeState.timeIndex);\n+                }\n+            } else {\n+                return new State(config, 0, 0, nanosToCurrentIndex);\n+            }\n+        }\n+    }\n+\n+    private long nanosNeededForExtraPermissions(int neededPermissions, RefillRateLimiterConfig config) {\n+        return neededPermissions * config.getNanosPerPermit();\n+    }\n+\n+    private int permissionsMissing(int permits, int currentPermits) {\n+        return permits - currentPermits;\n+    }\n+\n+    /**\n+     * Needed for testing. Inlining will take care of it.\n+     * @return\n+     */\n+    private long refillLimiterNanoTime() {\n+        return nanoTime();\n+    }\n+\n+    /**\n+     * Used only for metrics. Not good for rate limiter use.\n+     * @param state\n+     * @return\n+     */\n+    private int availablePermissions(State state) {\n+        long nanosSinceLastUpdate = refillLimiterNanoTime() - state.timeIndex;\n+        int permitCapacity = state.config.getPermitCapacity();\n+        long accumulatedPermissions = nanosSinceLastUpdate / state.config.getNanosPerPermit();\n+        int totalPermissions =  state.getActivePermissions() + (int) accumulatedPermissions;\n+        return min(permitCapacity, totalPermissions);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void drainPermissions() {\n+        RefillRateLimiter.State prev;\n+        RefillRateLimiter.State next;\n+        do {\n+            long nanoTime = refillLimiterNanoTime();\n+            prev = state.get();\n+            next = prev.withTimeIndex(nanoTime).withTimeIndex(nanoTime).withPermissions(0);\n+        } while (!compareAndSet(prev, next));\n+        if (eventProcessor.hasConsumers()) {\n+            eventProcessor.consumeEvent(new RateLimiterOnDrainedEvent(getName(), Math.min(prev.getActivePermissions(), 0)));\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"RefillRateLimiter{\" +\n+            \"name='\" + getName()+ '\\'' +\n+            \", rateLimiterConfig=\" + state.get().config+\n+            '}';\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public long reservePermission(final int permits) {\n+        long timeoutInNanos = state.get().getTimeoutInNanos();\n+        State modifiedState = updateStateWithBackOff(permits, timeoutInNanos);\n+\n+        boolean canAcquireImmediately = modifiedState.getNanosToWait() <= 0;\n+        if (canAcquireImmediately) {\n+            publishRateLimiterAcquisitionEvent(true, permits);\n+            return 0;\n+        }\n+\n+        boolean canAcquireInTime = timeoutInNanos >= modifiedState.getNanosToWait();\n+        if (canAcquireInTime) {\n+            publishRateLimiterAcquisitionEvent(true, permits);\n+            return modifiedState.getNanosToWait();\n+        }\n+\n+        publishRateLimiterAcquisitionEvent(false, permits);\n+        return -1;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public RateLimiterConfig getRateLimiterConfig() {\n+        return state.get().config;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Map<String, String> getTags() {\n+        return tags;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Metrics getMetrics() {\n+        return new RefillRateLimiterMetrics();\n+    }\n+\n+    @Override\n+    public EventPublisher getEventPublisher() {\n+        return eventProcessor;\n+    }\n+\n+    public RefillRateLimiterMetrics getDetailedMetrics() {\n+        return new RefillRateLimiterMetrics();\n+    }\n+\n+    /**\n+     * Atomically sets the value to the given updated value if the current value {@code ==} the\n+     * expected value. It differs from {@link AtomicReference#updateAndGet(UnaryOperator)} by\n+     * constant back off. It means that after one try to {@link AtomicReference#compareAndSet(Object,\n+     * Object)} this method will wait for a while before try one more time. This technique was\n+     * originally described in this\n+     * <a href=\"https://arxiv.org/abs/1305.5800\"> paper</a>\n+     * and showed great results with {@link AtomicRateLimiter} in benchmark tests.\n+     *\n+     * @param current the expected value\n+     * @param next    the new value\n+     * @return {@code true} if successful. False return indicates that the actual value was not\n+     * equal to the expected value.\n+     */\n+    protected boolean compareAndSet(final State current, final State next) {\n+        if (state.compareAndSet(current, next)) {\n+            return true;\n+        }\n+        parkNanos(1); // back-off\n+        return false;\n+    }\n+\n+    /**\n+     * <p>{@link RefillRateLimiter.State} represents immutable state of {@link RefillRateLimiter}\n+     * where:\n+     * <ul>\n+     * <li>activePermissions - count of available permissions after\n+     * the last {@link RefillRateLimiter#acquirePermission()} call.\n+     * Can be negative if some permissions where reserved.</li>\n+     * <p>\n+     * <li>nanosToWait - count of nanoseconds to wait for permission for\n+     * the last {@link RefillRateLimiter#acquirePermission()} call.</li>\n+     * <p>\n+     * <li>updatedAt - the last time the state was updated.</li>\n+     * </ul>\n+     */\n+    private static class State {\n+\n+        private final RefillRateLimiterConfig config;\n+        private final int activePermissions;\n+        private final long nanosToWait;\n+        private final long timeoutInNanos;\n+\n+        private final long timeIndex;\n+\n+        private State(RefillRateLimiterConfig config, int activePermissions, long nanosToWait, long timeIndex) {\n+            this.config = config;\n+            this.activePermissions = activePermissions;\n+            this.timeIndex = timeIndex;\n+\n+            this.timeoutInNanos = config.getTimeoutDuration().toNanos();\n+            this.nanosToWait = nanosToWait;\n+        }\n+\n+        private State withConfig(RefillRateLimiterConfig config) {\n+            return new State(config, activePermissions, getNanosToWait(), timeIndex);\n+        }\n+\n+        private State withTimeIndex(long timeIndex) {\n+            return new State(config, activePermissions, getNanosToWait(), timeIndex);\n+        }\n+\n+        private State withPermissions(int permissions) {\n+            return new State(config, permissions, getNanosToWait(), timeIndex);\n+        }\n+\n+        public int getActivePermissions() {\n+            return activePermissions;\n+        }\n+\n+        public long getNanosToWait() {\n+            return nanosToWait;\n+        }\n+\n+        public long getTimeoutInNanos() {\n+            return timeoutInNanos;\n+        }\n+    }\n+\n+    /**\n+     * Enhanced {@link Metrics} with some implementation specific details\n+     */\n+    public class RefillRateLimiterMetrics implements Metrics {\n+\n+        private RefillRateLimiterMetrics() {\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int getNumberOfWaitingThreads() {\n+            return waitingThreads.get();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int getAvailablePermissions() {\n+            State currentState = state.get();\n+            return availablePermissions(currentState);\n+        }\n+\n+        /**\n+         * @return estimated time duration in nanos to wait for the next permission\n+         */\n+        public long getNanosToWait() {\n+            State currentState = state.get();\n+            State estimatedState = calculateNextState(1, -1, currentState);\n+            return estimatedState.getNanosToWait();\n+        }\n+\n+    }\n+}"
  },
  {
    "sha": "3d1d46a6ea98db01e48f766d6c001268baf1629c",
    "filename": "resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/RefillRateLimiterConfigTest.java",
    "status": "added",
    "additions": 135,
    "deletions": 0,
    "changes": 135,
    "blob_url": "https://github.com/resilience4j/resilience4j/blob/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/RefillRateLimiterConfigTest.java",
    "raw_url": "https://github.com/resilience4j/resilience4j/raw/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/RefillRateLimiterConfigTest.java",
    "contents_url": "https://api.github.com/repos/resilience4j/resilience4j/contents/resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/RefillRateLimiterConfigTest.java?ref=4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2",
    "patch": "@@ -0,0 +1,135 @@\n+/*\n+ *\n+ *  Copyright 2020 Emmanouil Gkatziouras\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ *\n+ */\n+package io.github.resilience4j.ratelimiter;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import java.time.Duration;\n+\n+import static org.assertj.core.api.BDDAssertions.then;\n+\n+public class RefillRateLimiterConfigTest {\n+\n+    private static final int LIMIT = 50;\n+    private static final int PERMIT_CAPACITY = 60;\n+    private static final Duration TIMEOUT = Duration.ofSeconds(5);\n+    private static final Duration REFRESH_PERIOD = Duration.ofNanos(500);\n+    private static final String TIMEOUT_DURATION_MUST_NOT_BE_NULL = \"TimeoutDuration must not be null\";\n+    private static final String REFRESH_PERIOD_MUST_NOT_BE_NULL = \"RefreshPeriod must not be null\";\n+\n+    @Rule\n+    public ExpectedException exception = ExpectedException.none();\n+\n+    @Test\n+    public void builderPositive() throws Exception {\n+        RefillRateLimiterConfig config = RefillRateLimiterConfig.custom()\n+            .timeoutDuration(TIMEOUT)\n+            .limitRefreshPeriod(REFRESH_PERIOD)\n+            .limitForPeriod(LIMIT)\n+            .build();\n+\n+        then(config.getLimitForPeriod()).isEqualTo(LIMIT);\n+        then(config.getLimitRefreshPeriod()).isEqualTo(REFRESH_PERIOD);\n+        then(config.getTimeoutDuration()).isEqualTo(TIMEOUT);\n+        then(config.getPermitCapacity()).isEqualTo(LIMIT);\n+    }\n+\n+    @Test\n+    public void builderLimitCapacityAdjusted() throws Exception {\n+        RefillRateLimiterConfig config = RefillRateLimiterConfig.custom()\n+            .timeoutDuration(TIMEOUT)\n+            .limitRefreshPeriod(REFRESH_PERIOD)\n+            .limitForPeriod(LIMIT)\n+            .permitCapacity(PERMIT_CAPACITY)\n+            .build();\n+\n+        Duration adjustedPeriod = REFRESH_PERIOD.dividedBy(LIMIT).multipliedBy(PERMIT_CAPACITY);\n+\n+        then(config.getLimitForPeriod()).isEqualTo(PERMIT_CAPACITY);\n+        then(config.getLimitRefreshPeriod()).isEqualTo(adjustedPeriod);\n+        then(config.getTimeoutDuration()).isEqualTo(TIMEOUT);\n+        then(config.getPermitCapacity()).isEqualTo(PERMIT_CAPACITY);\n+    }\n+\n+    @Test\n+    public void testDefaultBurst() throws Exception {\n+        RefillRateLimiterConfig config = RefillRateLimiterConfig.custom()\n+            .timeoutDuration(TIMEOUT)\n+            .limitRefreshPeriod(REFRESH_PERIOD)\n+            .limitForPeriod(LIMIT)\n+            .build();\n+\n+        then(config.getLimitForPeriod()).isEqualTo(LIMIT);\n+        then(config.getLimitRefreshPeriod()).isEqualTo(REFRESH_PERIOD);\n+        then(config.getTimeoutDuration()).isEqualTo(TIMEOUT);\n+        then(config.getPermitCapacity()).isEqualTo(LIMIT);\n+    }\n+\n+    @Test\n+    public void testDefaultInitialPermits() throws Exception {\n+        RefillRateLimiterConfig config = RefillRateLimiterConfig.custom()\n+            .timeoutDuration(TIMEOUT)\n+            .limitRefreshPeriod(REFRESH_PERIOD)\n+            .limitForPeriod(LIMIT)\n+            .build();\n+\n+        then(config.getLimitForPeriod()).isEqualTo(LIMIT);\n+        then(config.getLimitRefreshPeriod()).isEqualTo(REFRESH_PERIOD);\n+        then(config.getTimeoutDuration()).isEqualTo(TIMEOUT);\n+        then(config.getInitialPermits()).isEqualTo(LIMIT);\n+    }\n+\n+    @Test\n+    public void builderTimeoutIsNull() throws Exception {\n+        exception.expect(NullPointerException.class);\n+        exception.expectMessage(TIMEOUT_DURATION_MUST_NOT_BE_NULL);\n+        RefillRateLimiterConfig.custom()\n+            .timeoutDuration(null);\n+    }\n+\n+    @Test\n+    public void builderRefreshPeriodIsNull() throws Exception {\n+        exception.expect(NullPointerException.class);\n+        exception.expectMessage(REFRESH_PERIOD_MUST_NOT_BE_NULL);\n+        RefillRateLimiterConfig.custom()\n+            .limitRefreshPeriod(null);\n+    }\n+\n+    @Test\n+    public void builderRefreshPeriodTooShort() throws Exception {\n+        exception.expect(IllegalArgumentException.class);\n+        exception.expectMessage(\"RefreshPeriod is too short\");\n+        RefillRateLimiterConfig.custom()\n+            .timeoutDuration(TIMEOUT)\n+            .limitRefreshPeriod(Duration.ZERO)\n+            .limitForPeriod(LIMIT)\n+            .build();\n+    }\n+\n+    @Test\n+    public void builderLimitIsLessThanOne() throws Exception {\n+        exception.expect(IllegalArgumentException.class);\n+        exception.expectMessage(\"LimitForPeriod should be greater than 0\");\n+        RefillRateLimiterConfig.custom()\n+            .limitForPeriod(0);\n+    }\n+\n+}"
  },
  {
    "sha": "fbe5a952cdf799d3b0e0b905bcba399e7a989f87",
    "filename": "resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/RefillRateLimiterTest.java",
    "status": "added",
    "additions": 824,
    "deletions": 0,
    "changes": 824,
    "blob_url": "https://github.com/resilience4j/resilience4j/blob/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/RefillRateLimiterTest.java",
    "raw_url": "https://github.com/resilience4j/resilience4j/raw/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/RefillRateLimiterTest.java",
    "contents_url": "https://api.github.com/repos/resilience4j/resilience4j/contents/resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/RefillRateLimiterTest.java?ref=4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2",
    "patch": "@@ -0,0 +1,824 @@\n+/*\n+ *\n+ *  Copyright 2020 Emmanouil Gkatziouras\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ *\n+ */\n+package io.github.resilience4j.ratelimiter.internal;\n+\n+import com.jayway.awaitility.core.ConditionFactory;\n+import io.github.resilience4j.ratelimiter.RateLimiter;\n+import io.github.resilience4j.ratelimiter.RateLimiterConfig;\n+import io.github.resilience4j.ratelimiter.RefillRateLimiterConfig;\n+import io.github.resilience4j.ratelimiter.RequestNotPermitted;\n+import io.vavr.collection.HashMap;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static com.jayway.awaitility.Awaitility.await;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.assertj.core.api.BDDAssertions.then;\n+import static org.hamcrest.CoreMatchers.equalTo;\n+\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest(RefillRateLimiter.class)\n+public class RefillRateLimiterTest {\n+\n+    private static final String LIMITER_NAME = \"test\";\n+    private static final long PERIOD_IN_NANOS = 250_000_000L;\n+    private static final long POLL_INTERVAL_IN_NANOS = 2_000_000L;\n+    private static final int PERMISSIONS_IN_PERIOD = 1;\n+    private RefillRateLimiter rateLimiter;\n+    private RefillRateLimiter.RefillRateLimiterMetrics metrics;\n+\n+    private static ConditionFactory awaitImpatiently() {\n+        return await()\n+            .pollDelay(1, TimeUnit.MICROSECONDS)\n+            .pollInterval(POLL_INTERVAL_IN_NANOS, TimeUnit.NANOSECONDS);\n+    }\n+\n+    protected RateLimiter buildRateLimiter(RefillRateLimiterConfig config) {\n+        RefillRateLimiterConfig refillConfig = RefillRateLimiterConfig.from(config)\n+            .permitCapacity(10)\n+            .initialPermits(0)\n+            .build();\n+        return new RefillRateLimiter(\"refill\", refillConfig);\n+    }\n+\n+    private void setTimeOnNanos(long nanoTime) throws Exception {\n+        PowerMockito.doReturn(nanoTime)\n+            .when(rateLimiter, \"refillLimiterNanoTime\");\n+    }\n+\n+    public void setup(Duration timeoutDuration) {\n+        setup(Duration.ofNanos(PERIOD_IN_NANOS), timeoutDuration, PERMISSIONS_IN_PERIOD);\n+    }\n+\n+    public void setup(Duration timeoutDuration, long startNanos) {\n+        setup(Duration.ofNanos(PERIOD_IN_NANOS), timeoutDuration, PERMISSIONS_IN_PERIOD, startNanos);\n+    }\n+\n+    public void setup(Duration periodDuration, Duration timeoutDuration, int permissionPerCycle) {\n+        RefillRateLimiterConfig rateLimiterConfig = RefillRateLimiterConfig.custom()\n+            .limitForPeriod(permissionPerCycle)\n+            .limitRefreshPeriod(periodDuration)\n+            .timeoutDuration(timeoutDuration)\n+            .build();\n+        RefillRateLimiter testLimiter = new RefillRateLimiter(LIMITER_NAME, rateLimiterConfig);\n+        rateLimiter = PowerMockito.spy(testLimiter);\n+        metrics = rateLimiter.getDetailedMetrics();\n+    }\n+\n+    public void setup(Duration periodDuration, Duration timeoutDuration, int permissionPerCycle, long startNanos) {\n+        RefillRateLimiterConfig rateLimiterConfig = RefillRateLimiterConfig.custom()\n+            .limitForPeriod(permissionPerCycle)\n+            .limitRefreshPeriod(periodDuration)\n+            .timeoutDuration(timeoutDuration)\n+            .build();\n+        RefillRateLimiter testLimiter = new RefillRateLimiter(LIMITER_NAME, rateLimiterConfig, HashMap.empty(),startNanos);\n+        rateLimiter = PowerMockito.spy(testLimiter);\n+        metrics = rateLimiter.getDetailedMetrics();\n+    }\n+\n+    /**\n+     * Added more nanos in order to handle the refills\n+     * Equivalent to {@link RateLimitersImplementationTest#acquireBigNumberOfPermitsAtStartOfCycleTest}\n+     */\n+    @Test\n+    public void acquireBigNumberOfPermitsAtStartTest() {\n+        RefillRateLimiterConfig config = RefillRateLimiterConfig.custom()\n+            .limitForPeriod(10)\n+            .initialPermits(0)\n+            .limitRefreshPeriod(Duration.ofNanos(600_000_000L))\n+            .timeoutDuration(Duration.ZERO)\n+            .build();\n+\n+        RateLimiter limiter = buildRateLimiter(config);\n+        RateLimiter.Metrics metrics = limiter.getMetrics();\n+\n+        waitForRefresh(metrics, config, '.');\n+\n+        boolean firstPermission = limiter.acquirePermission(5);\n+        then(firstPermission).isTrue();\n+        boolean secondPermission = limiter.acquirePermission(5);\n+        then(secondPermission).isTrue();\n+        /**\n+         * Due to the period being small it can be easily replenished\n+         */\n+        boolean firstNoPermission = limiter.acquirePermission(5);\n+        then(firstNoPermission).isFalse();\n+\n+        waitForRefresh(metrics, config, '*');\n+\n+        boolean retryInNewCyclePermission = limiter.acquirePermission(1);\n+        then(retryInNewCyclePermission).isTrue();\n+    }\n+\n+    /**\n+     * Added more nanos in order to handle the refills\n+     * Equivalent to {@link RateLimitersImplementationTest#tryToAcquireBigNumberOfPermitsAtEndOfCycleTest}\n+     */\n+    @Test\n+    public void tryToAcquireBigNumberOfPermitsOnFullCapacity() {\n+        RefillRateLimiterConfig config = RefillRateLimiterConfig.custom()\n+            .limitForPeriod(10)\n+            .initialPermits(0)\n+            .limitRefreshPeriod(Duration.ofNanos(600_000_000L))\n+            .timeoutDuration(Duration.ZERO)\n+            .build();\n+\n+        RateLimiter limiter = buildRateLimiter(config);\n+        RateLimiter.Metrics metrics = limiter.getMetrics();\n+\n+        waitForRefresh(metrics, config, '.');\n+\n+        boolean firstPermission = limiter.acquirePermission(1);\n+        then(firstPermission).isTrue();\n+        boolean secondPermission = limiter.acquirePermission(5);\n+        then(secondPermission).isTrue();\n+        boolean firstNoPermission = limiter.acquirePermission(6);\n+        then(firstNoPermission).isFalse();\n+\n+        waitForRefresh(metrics, config, '*');\n+\n+        boolean retryInSecondCyclePermission = limiter.acquirePermission(5);\n+        then(retryInSecondCyclePermission).isTrue();\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#notSpyRawTest}\n+     */\n+    @Test\n+    public void notSpyRawTest() {\n+        RefillRateLimiterConfig rateLimiterConfig = RefillRateLimiterConfig.custom()\n+            .limitForPeriod(PERMISSIONS_IN_PERIOD)\n+            .limitRefreshPeriod(Duration.ofNanos(PERIOD_IN_NANOS))\n+            .timeoutDuration(Duration.ZERO)\n+            .initialPermits(PERMISSIONS_IN_PERIOD)\n+            .build();\n+        RefillRateLimiter rateLimiter = new RefillRateLimiter(\"refillBasedLimiter\", rateLimiterConfig);\n+        RefillRateLimiter.RefillRateLimiterMetrics rateLimiterMetrics = rateLimiter\n+            .getDetailedMetrics();\n+\n+        boolean firstPermission = rateLimiter.acquirePermission();\n+        then(firstPermission).isTrue();\n+\n+        waitForPermissionRenewal(rateLimiterMetrics, '*');\n+        boolean secondPermission = rateLimiter.acquirePermission();\n+        then(secondPermission).isTrue();\n+\n+        boolean firstNoPermission = rateLimiter.acquirePermission();\n+        then(firstNoPermission).isFalse();\n+\n+        rateLimiter.changeLimitForPeriod(PERMISSIONS_IN_PERIOD * 2);\n+        waitForPermissionRenewal(rateLimiterMetrics, '^');\n+        boolean thirdPermission = rateLimiter.acquirePermission();\n+        then(thirdPermission).isTrue();\n+\n+        /**\n+         * Permission renewal happens per nanos thus the cycle splitting is not taking effect\n+         */\n+        waitNanos(PERIOD_IN_NANOS / 2l, '&');\n+        boolean fourthPermission = rateLimiter.acquirePermission();\n+        then(fourthPermission).isTrue();\n+\n+        boolean secondNoPermission = rateLimiter.acquirePermission();\n+        then(secondNoPermission).isFalse();\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#notSpyRawNonBlockingTest}\n+     */\n+    @Test\n+    public void notSpyRawNonBlockingTest() {\n+        RefillRateLimiterConfig rateLimiterConfig = RefillRateLimiterConfig.custom()\n+            .limitForPeriod(PERMISSIONS_IN_PERIOD)\n+            .limitRefreshPeriod(Duration.ofNanos(PERIOD_IN_NANOS))\n+            .timeoutDuration(Duration.ZERO)\n+            .initialPermits(PERMISSIONS_IN_PERIOD)\n+            .build();\n+\n+        RefillRateLimiter rateLimiter = new RefillRateLimiter(\"refillBasedLimiter\", rateLimiterConfig);\n+        RefillRateLimiter.RefillRateLimiterMetrics rateLimiterMetrics = rateLimiter\n+            .getDetailedMetrics();\n+\n+        long firstPermission = rateLimiter.reservePermission();\n+        waitForPermissionRenewal(rateLimiterMetrics, '*');\n+\n+        long secondPermission = rateLimiter.reservePermission();\n+        long firstNoPermission = rateLimiter.reservePermission();\n+\n+        rateLimiter.changeLimitForPeriod(PERMISSIONS_IN_PERIOD * 2);\n+\n+        /**\n+         * Permission renewal happens per nanos thus the cycle splitting is not taking effect\n+         */\n+        waitNanos(PERIOD_IN_NANOS, '^');\n+        long thirdPermission = rateLimiter.reservePermission();\n+        long fourthPermission = rateLimiter.reservePermission();\n+        long secondNoPermission = rateLimiter.reservePermission();\n+\n+\n+        then(firstPermission).isZero();\n+        then(secondPermission).isZero();\n+        then(thirdPermission).isZero();\n+        then(fourthPermission).isZero();\n+\n+        then(firstNoPermission).isNegative();\n+        then(secondNoPermission).isNegative();\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#permissionsInFirstCycle}\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void defaultPermissionsAtStartup() throws Exception {\n+        setup(Duration.ZERO, 0l);\n+\n+        setTimeOnNanos(PERIOD_IN_NANOS);\n+        RateLimiter.Metrics metrics = rateLimiter.getMetrics();\n+        int availablePermissions = metrics.getAvailablePermissions();\n+        then(availablePermissions).isEqualTo(PERMISSIONS_IN_PERIOD);\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#acquireAndRefreshWithEventPublishing}\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void acquireAndRefreshWithEventPublishing() throws Exception {\n+        setup(Duration.ZERO, PERIOD_IN_NANOS);\n+        setTimeOnNanos(PERIOD_IN_NANOS);\n+\n+        boolean permission = rateLimiter.acquirePermission();\n+        then(permission).isTrue();\n+        then(metrics.getAvailablePermissions()).isEqualTo(0);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS);\n+        boolean secondPermission = rateLimiter.acquirePermission();\n+        then(secondPermission).isFalse();\n+        then(metrics.getAvailablePermissions()).isEqualTo(0);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS);\n+\n+        setTimeOnNanos(PERIOD_IN_NANOS * 2);\n+        boolean thirdPermission = rateLimiter.acquirePermission();\n+        then(thirdPermission).isTrue();\n+        then(metrics.getAvailablePermissions()).isEqualTo(0);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS);\n+        boolean fourthPermission = rateLimiter.acquirePermission();\n+        then(fourthPermission).isFalse();\n+        then(metrics.getAvailablePermissions()).isEqualTo(0);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS);\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#reserveAndRefresh}\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void reserveAndRefresh() throws Exception {\n+        setup(Duration.ofNanos(PERIOD_IN_NANOS), PERIOD_IN_NANOS);\n+\n+        setTimeOnNanos(PERIOD_IN_NANOS);\n+        boolean permission = rateLimiter.acquirePermission();\n+        then(permission).isTrue();\n+        then(metrics.getAvailablePermissions()).isEqualTo(0);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS);\n+\n+        AtomicReference<Boolean> reservedPermission = new AtomicReference<>(null);\n+        Thread caller = new Thread(\n+            () -> reservedPermission.set(rateLimiter.acquirePermission()));\n+        caller.setDaemon(true);\n+        caller.start();\n+        awaitImpatiently()\n+            .atMost(5, SECONDS)\n+            .until(caller::getState, equalTo(Thread.State.TIMED_WAITING));\n+        then(metrics.getAvailablePermissions()).isEqualTo(-1);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS*2);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(1);\n+\n+        setTimeOnNanos(PERIOD_IN_NANOS * 2 + 10);\n+        awaitImpatiently()\n+            .atMost(5, SECONDS)\n+            .until(reservedPermission::get, equalTo(true));\n+\n+        /**\n+         * The update happens due to the reservation and is on PERIOD_IN_NANOS*2 so 10 less nanos to be needed\n+         */\n+        then(metrics.getAvailablePermissions()).isEqualTo(0);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS-10);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#reserveFewThenSkipCyclesBeforeRefreshNonBlocking}\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void reserveFewThenSkipNanosBeforeRefillNonBlocking() throws Exception {\n+        setup(Duration.ofNanos(PERIOD_IN_NANOS), PERIOD_IN_NANOS);\n+\n+        setTimeOnNanos(PERIOD_IN_NANOS);\n+        long permission = rateLimiter.reservePermission();\n+        then(permission).isZero();\n+        then(metrics.getAvailablePermissions()).isEqualTo(0);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+\n+        long reservation = rateLimiter.reservePermission();\n+        then(reservation).isPositive();\n+        then(reservation).isLessThanOrEqualTo(PERIOD_IN_NANOS);\n+        then(metrics.getAvailablePermissions()).isEqualTo(-1);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS * 2);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+\n+        long additionalReservation = rateLimiter.reservePermission();\n+        then(additionalReservation).isEqualTo(-1);\n+        then(metrics.getAvailablePermissions()).isEqualTo(-1);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS * 2);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+\n+        setTimeOnNanos(PERIOD_IN_NANOS * 6 + 10);\n+        then(metrics.getAvailablePermissions()).isEqualTo(1);\n+        then(metrics.getNanosToWait()).isEqualTo(0L);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#reserveFewThenSkipCyclesBeforeRefresh}\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void reserveFewThenWaitBeforeReachingMaxCapacity() throws Exception {\n+        setup(Duration.ofNanos(PERIOD_IN_NANOS), PERIOD_IN_NANOS);\n+\n+        setTimeOnNanos(PERIOD_IN_NANOS);\n+        boolean permission = rateLimiter.acquirePermission();\n+        then(permission).isTrue();\n+        then(metrics.getAvailablePermissions()).isEqualTo(0);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+\n+        AtomicReference<Boolean> firstReservedPermission = new AtomicReference<>(null);\n+        Thread firstCaller = new Thread(\n+            () -> firstReservedPermission.set(rateLimiter.acquirePermission()));\n+        firstCaller.setDaemon(true);\n+        firstCaller.start();\n+        awaitImpatiently()\n+            .atMost(5, SECONDS)\n+            .until(firstCaller::getState, equalTo(Thread.State.TIMED_WAITING));\n+        then(metrics.getAvailablePermissions()).isEqualTo(-1);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS * 2);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(1);\n+\n+        AtomicReference<Boolean> secondReservedPermission = new AtomicReference<>(null);\n+        Thread secondCaller = new Thread(\n+            () -> secondReservedPermission.set(rateLimiter.acquirePermission()));\n+        secondCaller.setDaemon(true);\n+        secondCaller.start();\n+        awaitImpatiently()\n+            .atMost(5, SECONDS)\n+            .until(secondCaller::getState, equalTo(Thread.State.TIMED_WAITING));\n+        then(metrics.getAvailablePermissions()).isEqualTo(-1);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS * 2);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(2);\n+\n+        setTimeOnNanos(PERIOD_IN_NANOS * 6 + 10);\n+        awaitImpatiently()\n+            .atMost(5, SECONDS)\n+            .until(firstReservedPermission::get, equalTo(true));\n+        awaitImpatiently()\n+            .atMost(5, SECONDS)\n+            .until(secondReservedPermission::get, equalTo(false));\n+        then(metrics.getAvailablePermissions()).isEqualTo(1);\n+        then(metrics.getNanosToWait()).isEqualTo(0L);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+    }\n+\n+    /**\n+     * @throws Exception\n+     */\n+    @Test(expected = RequestNotPermitted.class)\n+    public void tryToReserveMoreThatRateLimiterCapacity() throws Exception {\n+        setup(Duration.ofNanos(PERIOD_IN_NANOS * 5), 0l);\n+        setTimeOnNanos(PERIOD_IN_NANOS);\n+        rateLimiter.reservePermission(PERMISSIONS_IN_PERIOD * 3);\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#rejectedByTimeoutNonBlocking}\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void rejectedByTimeoutNonBlocking() throws Exception {\n+        setup(Duration.ZERO, 0l);\n+\n+        setTimeOnNanos(0l);\n+        long permission = rateLimiter.reservePermission();\n+        then(permission).isZero();\n+        then(metrics.getAvailablePermissions()).isEqualTo(0);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+\n+        long failedPermission = rateLimiter.reservePermission();\n+        then(failedPermission).isNegative();\n+        then(metrics.getAvailablePermissions()).isEqualTo(0);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+\n+        long updatedPeriod = PERIOD_IN_NANOS - 1;\n+        setTimeOnNanos(updatedPeriod);\n+\n+        then(metrics.getAvailablePermissions()).isEqualTo(0);\n+        then(metrics.getNanosToWait()).isEqualTo((1));\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#waitingThreadIsInterrupted}\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void waitingThreadIsInterrupted() throws Exception {\n+        setup(Duration.ofNanos(PERIOD_IN_NANOS), PERIOD_IN_NANOS);\n+\n+        setTimeOnNanos(PERIOD_IN_NANOS);\n+        boolean permission = rateLimiter.acquirePermission();\n+        then(permission).isTrue();\n+        then(metrics.getAvailablePermissions()).isEqualTo(0);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+\n+        AtomicReference<Boolean> reservedPermission = new AtomicReference<>(null);\n+        AtomicBoolean wasInterrupted = new AtomicBoolean(false);\n+        Thread caller = new Thread(\n+            () -> {\n+                reservedPermission.set(rateLimiter.acquirePermission());\n+                wasInterrupted.set(Thread.currentThread().isInterrupted());\n+            }\n+        );\n+        caller.setDaemon(true);\n+        caller.start();\n+\n+        awaitImpatiently()\n+            .atMost(5, SECONDS)\n+            .until(caller::getState, equalTo(Thread.State.TIMED_WAITING));\n+        then(metrics.getAvailablePermissions()).isEqualTo(-1);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS * 2);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(1);\n+\n+        caller.interrupt();\n+        awaitImpatiently()\n+            .atMost(5, SECONDS)\n+            .until(reservedPermission::get, equalTo(false));\n+        then(wasInterrupted.get()).isTrue();\n+        then(metrics.getAvailablePermissions()).isEqualTo(-1);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS * 2);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#changePermissionsLimitBetweenCycles}\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void changePermissionsLimitBetweenCycles() throws Exception {\n+        setup(Duration.ofNanos(PERIOD_IN_NANOS), PERIOD_IN_NANOS);\n+\n+        setTimeOnNanos(PERIOD_IN_NANOS);\n+        boolean permission = rateLimiter.acquirePermission();\n+        then(permission).isTrue();\n+        then(metrics.getAvailablePermissions()).isEqualTo(0);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS);\n+\n+        AtomicReference<Boolean> reservedPermission = new AtomicReference<>(null);\n+        Thread caller = new Thread(\n+            () -> reservedPermission.set(rateLimiter.acquirePermission()));\n+        caller.setDaemon(true);\n+        caller.start();\n+        awaitImpatiently()\n+            .atMost(5, SECONDS)\n+            .until(caller::getState, equalTo(Thread.State.TIMED_WAITING));\n+        then(metrics.getAvailablePermissions()).isEqualTo(-1);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS + PERIOD_IN_NANOS);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(1);\n+\n+        rateLimiter.changeLimitForPeriod(PERMISSIONS_IN_PERIOD * 2);\n+        then(rateLimiter.getRateLimiterConfig().getLimitForPeriod())\n+            .isEqualTo(PERMISSIONS_IN_PERIOD * 2);\n+        then(metrics.getAvailablePermissions()).isEqualTo(-2);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS+PERIOD_IN_NANOS/2);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(1);\n+\n+        setTimeOnNanos(PERIOD_IN_NANOS * 2 + 10);\n+        awaitImpatiently()\n+            .atMost(5, SECONDS)\n+            .until(reservedPermission::get, equalTo(true));\n+\n+        then(metrics.getAvailablePermissions()).isEqualTo(0);\n+        then(metrics.getNanosToWait()).isEqualTo(PERIOD_IN_NANOS/2 - 10);\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#reservePermissionsUpfront}\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void reservePermissionsUpfront() throws Exception {\n+        final int limitForPeriod = 3;\n+        final int tasksNum = 9;\n+        Duration limitRefreshPeriod = Duration.ofMillis(12);\n+        Duration timeoutDuration = Duration.ofMillis(12);\n+        long periodInNanos = limitRefreshPeriod.toNanos();\n+\n+        setup(limitRefreshPeriod, timeoutDuration, limitForPeriod, periodInNanos);\n+        setTimeOnNanos(periodInNanos);\n+\n+        ArrayList<Long> timesToWait = new ArrayList<>();\n+        for (int i = 0; i < tasksNum; i++) {\n+            setTimeOnNanos(periodInNanos);\n+            long timeToWait = rateLimiter.reservePermission(1);\n+            timesToWait.add(timeToWait);\n+        }\n+        then(timesToWait).containsExactly(\n+            0L, 0L, 0L,\n+            limitRefreshPeriod.toNanos()/3 , 2*limitRefreshPeriod.toNanos()/3, limitRefreshPeriod.toNanos(),\n+            -1L, -1L, -1L\n+        );\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#changeDefaultTimeoutDuration}\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void changeDefaultTimeoutDuration() throws Exception {\n+        setup(Duration.ZERO);\n+\n+        RateLimiterConfig rateLimiterConfig = rateLimiter.getRateLimiterConfig();\n+        then(rateLimiterConfig.getTimeoutDuration()).isEqualTo(Duration.ZERO);\n+        then(rateLimiterConfig.getLimitForPeriod()).isEqualTo(PERMISSIONS_IN_PERIOD);\n+        then(rateLimiterConfig.getLimitRefreshPeriod()).isEqualTo(Duration.ofNanos(PERIOD_IN_NANOS));\n+\n+        rateLimiter.changeTimeoutDuration(Duration.ofSeconds(1));\n+        then(rateLimiterConfig != rateLimiter.getRateLimiterConfig()).isTrue();\n+        rateLimiterConfig = rateLimiter.getRateLimiterConfig();\n+        then(rateLimiterConfig.getTimeoutDuration()).isEqualTo(Duration.ofSeconds(1));\n+        then(rateLimiterConfig.getLimitForPeriod()).isEqualTo(PERMISSIONS_IN_PERIOD);\n+        then(rateLimiterConfig.getLimitRefreshPeriod()).isEqualTo(Duration.ofNanos(PERIOD_IN_NANOS));\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#changeLimitForPeriod}\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void changeLimitForPeriod() throws Exception {\n+        setup(Duration.ZERO);\n+\n+        RateLimiterConfig rateLimiterConfig = rateLimiter.getRateLimiterConfig();\n+        then(rateLimiterConfig.getTimeoutDuration()).isEqualTo(Duration.ZERO);\n+        then(rateLimiterConfig.getLimitForPeriod()).isEqualTo(PERMISSIONS_IN_PERIOD);\n+        then(rateLimiterConfig.getLimitRefreshPeriod()).isEqualTo(Duration.ofNanos(PERIOD_IN_NANOS));\n+\n+        rateLimiter.changeLimitForPeriod(35);\n+        long nanosPerPermission = PERIOD_IN_NANOS/35;\n+        then(rateLimiterConfig != rateLimiter.getRateLimiterConfig()).isTrue();\n+        rateLimiterConfig = rateLimiter.getRateLimiterConfig();\n+        then(rateLimiterConfig.getTimeoutDuration()).isEqualTo(Duration.ZERO);\n+        then(rateLimiterConfig.getLimitForPeriod()).isEqualTo(35);\n+        then(rateLimiterConfig.getLimitRefreshPeriod()).isEqualTo(Duration.ofNanos(nanosPerPermission*35));\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#metricsTest}\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void metricsTest() {\n+        setup(Duration.ZERO);\n+\n+        RateLimiter.Metrics metrics = rateLimiter.getMetrics();\n+        then(metrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+        then(metrics.getAvailablePermissions()).isEqualTo(1);\n+\n+        RefillRateLimiter.RefillRateLimiterMetrics detailedMetrics = rateLimiter\n+            .getDetailedMetrics();\n+        then(detailedMetrics.getNumberOfWaitingThreads()).isEqualTo(0);\n+        then(detailedMetrics.getAvailablePermissions()).isEqualTo(1);\n+        then(detailedMetrics.getNanosToWait()).isEqualTo(0);\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#namePropagation}\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void namePropagation() {\n+        setup(Duration.ZERO);\n+        then(rateLimiter.getName()).isEqualTo(LIMITER_NAME);\n+    }\n+\n+    /**\n+     * Equivalent to {@link AtomicRateLimiterTest#metrics()}\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void metrics() {\n+        setup(Duration.ZERO);\n+        then(rateLimiter.getMetrics().getNumberOfWaitingThreads()).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void refillTest() throws InterruptedException {\n+        RefillRateLimiterConfig rateLimiterConfig = RefillRateLimiterConfig.custom()\n+            .limitForPeriod(10)\n+            .limitRefreshPeriod(Duration.ofMillis(1000))\n+            .timeoutDuration(Duration.ZERO)\n+            .build();\n+\n+        RateLimiter limiter = new RefillRateLimiter(\"refill\", rateLimiterConfig);\n+        Assert.assertTrue(limiter.acquirePermission(10));\n+        Thread.sleep(100);\n+        Assert.assertTrue(limiter.acquirePermission(1));\n+        Assume.assumeFalse(limiter.acquirePermission(4));\n+        Thread.sleep(410);\n+        Assume.assumeTrue(limiter.acquirePermission(4));\n+        Assume.assumeFalse(limiter.acquirePermission(1));\n+    }\n+\n+    @Test\n+    public void testMaxCapacity() throws InterruptedException {\n+        RefillRateLimiterConfig rateLimiterConfig = RefillRateLimiterConfig.custom()\n+            .limitForPeriod(10)\n+            .permitCapacity(20)\n+            .limitRefreshPeriod(Duration.ofMillis(1000))\n+            .timeoutDuration(Duration.ZERO)\n+            .build();\n+\n+        RefillRateLimiter refillRateLimiter = new RefillRateLimiter(\"refill\", rateLimiterConfig);\n+        Assert.assertTrue(refillRateLimiter.acquirePermission(10));\n+\n+        for (int i = 1; i <= 20; i++) {\n+            Thread.sleep(100 * i);\n+            Assert.assertTrue(refillRateLimiter.acquirePermission(i));\n+        }\n+    }\n+\n+    @Test\n+    public void testZeroInitialPermits() throws InterruptedException {\n+        RefillRateLimiterConfig rateLimiterConfig = RefillRateLimiterConfig.custom()\n+            .initialPermits(0)\n+            .limitForPeriod(10)\n+            .limitRefreshPeriod(Duration.ofMillis(1000))\n+            .timeoutDuration(Duration.ZERO)\n+            .build();\n+\n+        RefillRateLimiter refillRateLimiter = new RefillRateLimiter(\"refill\", rateLimiterConfig);\n+\n+        for (int i = 1; i <= 10; i++) {\n+            Thread.sleep(100 * i);\n+            Assert.assertTrue(refillRateLimiter.acquirePermission(i));\n+        }\n+\n+        Assert.assertFalse(refillRateLimiter.acquirePermission(1));\n+    }\n+\n+    @Test\n+    public void testScenarioTest() throws Exception {\n+        String scenario = \"refill_no_wait_five_bucket_scenario.csv\";\n+        List<RefillScenarioEntry> entries = getRefillScenarioEntries(scenario);\n+\n+        RefillRateLimiterConfig rateLimiterConfig = RefillRateLimiterConfig.custom()\n+            .initialPermits(5)\n+            .limitForPeriod(1)\n+            .limitRefreshPeriod(Duration.ofNanos(1))\n+            .permitCapacity(5)\n+            .timeoutDuration(Duration.ZERO)\n+            .build();\n+\n+        RefillRateLimiter refillRateLimiter = new RefillRateLimiter(\"refill_bucket_five\", rateLimiterConfig,\n+            HashMap.empty(),\n+            1);\n+\n+        rateLimiter = PowerMockito.spy(refillRateLimiter);\n+\n+        for(RefillScenarioEntry entry: entries) {\n+            setTimeOnNanos(entry.getNano());\n+            boolean result = rateLimiter.acquirePermission(entry.getRequest());\n+            Assert.assertEquals(entry.getResult(), result);\n+        }\n+    }\n+\n+    private List<RefillScenarioEntry> getRefillScenarioEntries(String scenario) throws IOException {\n+        InputStream inputStream = getClass().getClassLoader().getResourceAsStream(scenario);\n+        List<RefillScenarioEntry> entries = new ArrayList<>();\n+        try(BufferedReader br = new BufferedReader(new InputStreamReader(inputStream))) {\n+\n+            String line = br.readLine();\n+            while ((line = br.readLine()) != null) {\n+                String[] values = line.split(\",\");\n+                RefillScenarioEntry refillScenarioEntry = new RefillScenarioEntry(\n+                    Long.valueOf(values[0]),\n+                    Integer.parseInt(values[1]),\n+                    Integer.parseInt(values[2]),\n+                    Integer.parseInt(values[3]),\n+                    Boolean.parseBoolean(values[4])\n+                );\n+\n+                entries.add(refillScenarioEntry);\n+            }\n+        }\n+        return entries;\n+    }\n+\n+    private void waitForMaxPermissions(\n+        RefillRateLimiter.RefillRateLimiterMetrics rateLimiterMetrics, char printedWhileWaiting) {\n+\n+        while (PERMISSIONS_IN_PERIOD > rateLimiterMetrics.getAvailablePermissions()) {\n+            System.out.print(printedWhileWaiting);\n+        }\n+\n+        System.out.println();\n+    }\n+\n+    private void waitForPermissionRenewal(\n+        RefillRateLimiter.RefillRateLimiterMetrics rawDetailedMetrics, char printedWhileWaiting) {\n+        long nanosToWait = rawDetailedMetrics.getNanosToWait();\n+        long startTime = System.nanoTime();\n+        while (System.nanoTime() - startTime < nanosToWait) {\n+            System.out.print(printedWhileWaiting);\n+        }\n+        System.out.println();\n+    }\n+\n+    private void waitNanos(long nanosToWait, char printedWhileWaiting) {\n+        long startTime = System.nanoTime();\n+        while (System.nanoTime() - startTime < nanosToWait) {\n+            System.out.print(printedWhileWaiting);\n+        }\n+        System.out.println();\n+    }\n+\n+    protected void waitForRefresh(RateLimiter.Metrics metrics, RefillRateLimiterConfig config,\n+                                  char printedWhileWaiting) {\n+        Instant start = Instant.now();\n+        while (Instant.now().isBefore(start.plus(config.getLimitRefreshPeriod()))) {\n+            try {\n+                if (metrics.getAvailablePermissions() >= config.getPermitCapacity()) {\n+                    break;\n+                }\n+                System.out.print(printedWhileWaiting);\n+                Thread.sleep(1);\n+            } catch (InterruptedException ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        }\n+        System.out.println();\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "6e19abc0609da9dbb9243eb60e1b52081a482010",
    "filename": "resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/RefillScenarioEntry.java",
    "status": "added",
    "additions": 59,
    "deletions": 0,
    "changes": 59,
    "blob_url": "https://github.com/resilience4j/resilience4j/blob/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/RefillScenarioEntry.java",
    "raw_url": "https://github.com/resilience4j/resilience4j/raw/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/RefillScenarioEntry.java",
    "contents_url": "https://api.github.com/repos/resilience4j/resilience4j/contents/resilience4j-ratelimiter/src/test/java/io/github/resilience4j/ratelimiter/internal/RefillScenarioEntry.java?ref=4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2",
    "patch": "@@ -0,0 +1,59 @@\n+package io.github.resilience4j.ratelimiter.internal;\n+\n+public class RefillScenarioEntry {\n+\n+    private Long nano;\n+    private int bucketBefore;\n+    private int request;\n+    private int bucketAfter;\n+    private boolean result;\n+\n+    public RefillScenarioEntry(Long nano, int bucketBefore, int request, int bucketAfter, boolean result) {\n+        this.nano = nano;\n+        this.bucketBefore = bucketBefore;\n+        this.request = request;\n+        this.bucketAfter = bucketAfter;\n+        this.result = result;\n+    }\n+\n+    public Long getNano() {\n+        return nano;\n+    }\n+\n+    public void setNano(Long nano) {\n+        this.nano = nano;\n+    }\n+\n+    public int getBucketBefore() {\n+        return bucketBefore;\n+    }\n+\n+    public void setBucketBefore(int bucketBefore) {\n+        this.bucketBefore = bucketBefore;\n+    }\n+\n+    public int getRequest() {\n+        return request;\n+    }\n+\n+    public void setRequest(int request) {\n+        this.request = request;\n+    }\n+\n+    public int getBucketAfter() {\n+        return bucketAfter;\n+    }\n+\n+    public void setBucketAfter(int bucketAfter) {\n+        this.bucketAfter = bucketAfter;\n+    }\n+\n+    public boolean getResult() {\n+        return result;\n+    }\n+\n+    public void setResult(boolean result) {\n+        this.result = result;\n+    }\n+\n+}"
  },
  {
    "sha": "6a5ae531119b9bd865832953011cd475157f1c26",
    "filename": "resilience4j-ratelimiter/src/test/resources/refill_no_wait_five_bucket_scenario.csv",
    "status": "added",
    "additions": 34,
    "deletions": 0,
    "changes": 34,
    "blob_url": "https://github.com/resilience4j/resilience4j/blob/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/test/resources/refill_no_wait_five_bucket_scenario.csv",
    "raw_url": "https://github.com/resilience4j/resilience4j/raw/4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2/resilience4j-ratelimiter/src/test/resources/refill_no_wait_five_bucket_scenario.csv",
    "contents_url": "https://api.github.com/repos/resilience4j/resilience4j/contents/resilience4j-ratelimiter/src/test/resources/refill_no_wait_five_bucket_scenario.csv?ref=4a81d0c02e4c29a5b59d1a0dccc5a2ec76c96ea2",
    "patch": "@@ -0,0 +1,34 @@\n+nano_time,bucket_before,requests,bucket_after,result\n+1,5,1,5,true\n+2,5,1,5,true\n+3,5,2,4,true\n+4,4,2,3,true\n+5,3,2,2,true\n+6,2,2,1,true\n+7,1,2,2,false\n+8,2,2,1,true\n+9,1,2,2,false\n+10,2,2,1,true\n+11,1,2,2,false\n+12,2,2,1,true\n+13,1,2,2,false\n+14,2,2,1,true\n+15,1,2,2,false\n+16,2,2,1,true\n+17,1,2,2,false\n+18,2,0,3,true\n+19,3,0,4,true\n+20,4,0,5,true\n+21,5,0,5,true\n+22,5,5,1,true\n+23,1,1,1,true\n+24,1,1,1,true\n+25,1,2,2,false\n+26,2,2,1,true\n+27,1,1,1,true\n+28,1,1,1,true\n+29,1,0,2,true\n+30,2,0,3,true\n+31,3,2,2,true\n+32,2,2,1,true\n+33,1,1,1,true\n\\ No newline at end of file"
  }
]
