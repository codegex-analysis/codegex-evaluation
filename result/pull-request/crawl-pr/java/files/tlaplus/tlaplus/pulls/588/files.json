[
  {
    "sha": "2efb01da4196cadfd161dc94981429122aff3d32",
    "filename": "DEVELOPING.md",
    "status": "modified",
    "additions": 11,
    "deletions": 0,
    "changes": 11,
    "blob_url": "https://github.com/tlaplus/tlaplus/blob/50a8cc1a9aa5ea978e3e1b28da091529314631e7/DEVELOPING.md",
    "raw_url": "https://github.com/tlaplus/tlaplus/raw/50a8cc1a9aa5ea978e3e1b28da091529314631e7/DEVELOPING.md",
    "contents_url": "https://api.github.com/repos/tlaplus/tlaplus/contents/DEVELOPING.md?ref=50a8cc1a9aa5ea978e3e1b28da091529314631e7",
    "patch": "@@ -44,6 +44,12 @@ To build and test the Toolbox (well, everything really), run:\n mvn verify\n ```\n \n+To build without testing, run:\n+\n+``` sh\n+mvn install -Dmaven.test.skip=true\n+```\n+\n On completion you'll find the toolbox distributables in `org.lamport.tla.toolbox.product.product/target/products/`\n \n ```\n@@ -54,3 +60,8 @@ drwxr-xr-x 5 golly users      4096 May 19 09:20 org.lamport.tla.toolbox.product.\n -rw-r--r-- 1 golly users 160402860 May 19 09:21 TLAToolbox-1.5.8-macosx.cocoa.x86_64.zip\n -rw-r--r-- 1 golly users 161739828 May 19 09:21 TLAToolbox-1.5.8-win32.win32.x86_64.zip\n ```\n+\n+Debugging\n+======================\n+\n+See guide at https://github.com/tlaplus/tlaplus/tree/master/general/ide."
  },
  {
    "sha": "c3ba466b8f41334b4800a494f025b1fadf8e4c16",
    "filename": "tlatools/org.lamport.tlatools/README.md",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/tlaplus/tlaplus/blob/50a8cc1a9aa5ea978e3e1b28da091529314631e7/tlatools/org.lamport.tlatools/README.md",
    "raw_url": "https://github.com/tlaplus/tlaplus/raw/50a8cc1a9aa5ea978e3e1b28da091529314631e7/tlatools/org.lamport.tlatools/README.md",
    "contents_url": "https://api.github.com/repos/tlaplus/tlaplus/contents/tlatools/org.lamport.tlatools/README.md?ref=50a8cc1a9aa5ea978e3e1b28da091529314631e7",
    "patch": "@@ -27,7 +27,7 @@ To run a single test:\n \n ``` shell\n # Running the `tlc2.tool.MonolithSpecTest.java` test\n-ant -f customBuild.xml test-single -Dtest.testcase tlc2.tool.MonolithSpecTest\n+ant -f customBuild.xml test-set -Dtest.testcases=\"tlc2/tool/MonolithSpecTest*\"\n ```\n \n One tip, if you want to record the output of some tlatool (like if you"
  },
  {
    "sha": "772df1989b1796be67479ad7a9d1b858282dbf0b",
    "filename": "tlatools/org.lamport.tlatools/src/tlc2/TraceExplorationSpec.java",
    "status": "modified",
    "additions": 6,
    "deletions": 5,
    "changes": 11,
    "blob_url": "https://github.com/tlaplus/tlaplus/blob/50a8cc1a9aa5ea978e3e1b28da091529314631e7/tlatools/org.lamport.tlatools/src/tlc2/TraceExplorationSpec.java",
    "raw_url": "https://github.com/tlaplus/tlaplus/raw/50a8cc1a9aa5ea978e3e1b28da091529314631e7/tlatools/org.lamport.tlatools/src/tlc2/TraceExplorationSpec.java",
    "contents_url": "https://api.github.com/repos/tlaplus/tlaplus/contents/tlatools/org.lamport.tlatools/src/tlc2/TraceExplorationSpec.java?ref=50a8cc1a9aa5ea978e3e1b28da091529314631e7",
    "patch": "@@ -72,8 +72,7 @@ public TraceExplorationSpec(\n \t\t\tString ogModuleName = specInfo.getRootName();\n \t\t\tList<String> variables = Arrays.asList(TLCState.Empty.getVarsAsStrings());\n \t\t\tMCParserResults parserResults = MCParser.generateResultsFromProcessorAndConfig(spec, cfg);\n-\t\t\tList<String> constants = parserResults.getModelConfig().getRawConstants();\n-\t\t\treturn this.generate(ogModuleName, constants, variables, errorTrace);\n+\t\t\treturn this.generate(ogModuleName, parserResults, variables, errorTrace, specInfo);\n \t\t});\n \t}\n \n@@ -88,9 +87,10 @@ public TraceExplorationSpec(\n \t */\n \tpublic \tTraceExplorationSpecGenerationReport generate(\n \t\t\tString ogModuleName,\n-\t\t\tList<String> constants,\n+\t\t\tMCParserResults parserResults,\n \t\t\tList<String> variables,\n-\t\t\tMCError errorTrace) {\n+\t\t\tMCError errorTrace,\n+\t\t\tITool specInfo) {\n \t\tString teSpecModuleName = deriveTESpecModuleName(ogModuleName, this.timestamp);\n \t\ttry (\n \t\t\t\tOutputStream tlaStream = this.streamProvider.getTlaStream(teSpecModuleName);\n@@ -99,9 +99,10 @@ public \tTraceExplorationSpecGenerationReport generate(\n \t\t\tTraceExplorer.writeSpecTEStreams(\n \t\t\t\t\tteSpecModuleName,\n \t\t\t\t\togModuleName,\n-\t\t\t\t\tconstants,\n+\t\t\t\t\tparserResults,\n \t\t\t\t\tvariables,\n \t\t\t\t\terrorTrace,\n+\t\t\t\t\tspecInfo,\n \t\t\t\t\ttlaStream,\n \t\t\t\t\tcfgStream);\n \t\t\tTraceExplorationSpecGenerationReport report = new TraceExplorationSpecGenerationReport("
  },
  {
    "sha": "7f71772899e3e65e28026d67fbe8d10925488ca4",
    "filename": "tlatools/org.lamport.tlatools/src/tlc2/TraceExplorer.java",
    "status": "modified",
    "additions": 126,
    "deletions": 27,
    "changes": 153,
    "blob_url": "https://github.com/tlaplus/tlaplus/blob/50a8cc1a9aa5ea978e3e1b28da091529314631e7/tlatools/org.lamport.tlatools/src/tlc2/TraceExplorer.java",
    "raw_url": "https://github.com/tlaplus/tlaplus/raw/50a8cc1a9aa5ea978e3e1b28da091529314631e7/tlatools/org.lamport.tlatools/src/tlc2/TraceExplorer.java",
    "contents_url": "https://api.github.com/repos/tlaplus/tlaplus/contents/tlatools/org.lamport.tlatools/src/tlc2/TraceExplorer.java?ref=50a8cc1a9aa5ea978e3e1b28da091529314631e7",
    "patch": "@@ -9,6 +9,7 @@\n import java.io.OutputStream;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n@@ -27,7 +28,11 @@\n import tlc2.output.MP;\n import tlc2.output.Messages;\n import tlc2.output.SpecTraceExpressionWriter;\n+import tlc2.tool.Defns;\n+import tlc2.tool.ITool;\n import tlc2.tool.TLCState;\n+import tlc2.util.Vect;\n+import tlc2.value.impl.ModelValue;\n import util.TLAConstants;\n import util.ToolIO;\n import util.UsageGenerator;\n@@ -61,7 +66,6 @@\n     \n     static final String SPEC_TE_INIT_ID = \"_SpecTEInit\";\n     static final String SPEC_TE_NEXT_ID = \"_SpecTENext\";\n-    private static final String SPEC_TE_ACTION_CONSTRAINT_ID = \"_SpecTEActionConstraint\";\n     \n     // <parameter name, whether the parameter takes an argument>\n     private static final HashMap<String, Boolean> TLC_ARGUMENTS_TO_IGNORE;\n@@ -98,7 +102,6 @@\n \t\t\t\tTLAConstants.TraceExplore.TRACE_EXPRESSION_MODULE_NAME\n \t\t\t\t+ TLAConstants.Files.CONFIG_EXTENSION);\n \t\t\n-\t\tList<String> constants = results.getModelConfig().getRawConstants();\n \t\tList<String> variables = Arrays.asList(vars);\n \n \t\ttry (\n@@ -108,9 +111,10 @@\n \t\t\twriteSpecTEStreams(\n \t\t\t\t\tTLAConstants.TraceExplore.TRACE_EXPRESSION_MODULE_NAME,\n \t\t\t\t\tosn,\n-\t\t\t\t\tconstants,\n+\t\t\t\t\tresults,\n \t\t\t\t\tvariables,\n \t\t\t\t\terror,\n+\t\t\t\t\tnull,\n \t\t\t\t\tspecTETLAOutStream,\n \t\t\t\t\tspecTECFGOutStream);\n \t\t}\n@@ -120,25 +124,52 @@\n \t\n \t/**\n \t * \n+\t * @param teSpecModuleName\n \t * @param originalSpecName\n \t * @param originalSpecVariables\n-\t * @param specInfo\n+\t * @param results\n+\t * @param variables\t \n \t * @param error\n+\t * @param specInfo\n \t * @param specTETLAOutStream\n \t * @param specTECFGOutStream\n \t * @throws IOException\n \t */\n \tpublic static void writeSpecTEStreams(\n \t\t\tfinal String teSpecModuleName,\n \t\t\tfinal String originalSpecName,\n-\t\t\tfinal List<String> constants,\n+\t\t\tfinal MCParserResults results,\n \t\t\tfinal List<String> variables,\n \t\t\tfinal MCError error,\n+\t\t\tfinal ITool specInfo,\n \t\t\tfinal OutputStream specTETLAOutStream,\n \t\t\tfinal OutputStream specTECFGOutStream) throws IOException {\n \n \t\tfinal SpecTraceExpressionWriter writer = new SpecTraceExpressionWriter();\n \n+\t\t// Each element in `constants` is a `Vect` with 2 elements.\n+\t\t// The first element of this `Vect` is the key (the constant) and \n+\t\t// the second one is the value of the constant.\n+\t\tVect<Vect<Object>> constants = (Vect<Vect<Object>>) results.getModelConfig().getConstants();\t\t\t\n+\n+\t\t// Get all reified constants;\n+\t\tList<String> reifiedConstants = new ArrayList<String>();\t\t\n+\t\tfor (Vect<Object> keyValuePair : (ArrayList<Vect<Object>>) Collections.list(constants.elements())) {\n+\t\t\treifiedConstants.add(keyValuePair.elementAt(0).toString());\t\t\t\n+\t\t}\n+\n+\t\t// Add all the model values as constants, they have to be reified (to mean something) in a TLA module.\n+\t\t// First we set all the model values seen, the values will be at the static field ModelValue.mvs.\n+\t\tModelValue.setValues();\n+\t\tList<String> mvsStr = new ArrayList<String>();\n+\t\tfor (ModelValue mv : ModelValue.mvs) {\n+\t\t\t// Do not add the constant if it's already reified so we don't have \n+\t\t\t// duplicated constants error.\n+\t\t\tif (!reifiedConstants.contains(mv.toString())) {\n+\t\t\t\tmvsStr.add(mv.toString());\n+\t\t\t}\n+\t\t}\t\t\n+\n \t\t/**\n \t\t * Write content of config file (SpecTE).\n \t\t * <p>\n@@ -147,31 +178,82 @@ public static void writeSpecTEStreams(\n \t\t * and CONSTANTS verbatim from the existing config file with which TLC ran. The\n \t\t * definition that appear in the .tla file (e.g. MC.tla) don't have to be copied\n \t\t * because SpecTE extends MC.\n+\t\t * We also add the model values as constants so they can be used for the traces at\n+\t\t * the TLA modules.\n \t\t * (see TraceExplorerDelegate#writeModelInfo)\n \t\t */\n-\t\twriter.addConstants(constants);\n+\t\tList<String> mvsConfigConstants = new ArrayList<String>();\n+\t\tfor (String mv : mvsStr) {\n+\t\t\tmvsConfigConstants.add(SpecTraceExpressionWriter.indentString(String.format(\"%s = %s\", mv, mv), 1));\n+\t\t}\t\t\t\n+\n+\t\tif(!constants.isEmpty()) {\n+\t\t\tList<String> indentedConstants = new ArrayList<String>();\n+\t\t\t// Add `CONSTANTS` header.\n+\t\t\tindentedConstants.add(TLAConstants.KeyWords.CONSTANTS);\t\t\t\n+\t\t\tfor (Vect<Object> keyValuePair : (ArrayList<Vect<Object>>) Collections.list(constants.elements())) {\n+\t\t\t\tString key = keyValuePair.elementAt(0).toString();\n+\t\t\t\tString value = keyValuePair.elementAt(1).toString();\n+\t\t\t\tindentedConstants.add(SpecTraceExpressionWriter.indentString(String.format(\"%s = %s\", key, value), 1));\n+\t\t\t}\n+\n+\t\t\tindentedConstants.addAll(mvsConfigConstants);\n+\t\t\twriter.addConstants(indentedConstants);\n+\t\t}\n+\n+\t\t// If needed, create module which contain the reified constants.\n+\t\t// First we need to handle the case where a model value is defined in\n+\t\t// the config file, but, for some reason, it's not used in any of the\n+\t\t// model specs. E.g. I define `p1 = p1` in the `CONSTANTS` header of the\n+\t\t// config file, but I do not use it (through `CONSTANTS`) in the model spec.\n+\t\t// So we add these remaining constants to `mvsStr` so they are added to the \n+\t\t// `TE` spec.\n+\t\tDefns defns = specInfo.getSpecProcessor().getDefns();\n+\t\tArrayList<String> modConstants = new ArrayList<String>();\n+\t\tfor (ModelValue mv : ModelValue.mvs) {\n+\t\t\tif (defns.get(mv.toString()) == null) {\n+\t\t\t\tmodConstants.add(mv.toString());\n+\t\t\t}\n+\t\t}\n+\t\tfinal String teConstantSpecName = String.format(\"%s_%s\", originalSpecName, TLAConstants.TraceExplore.SPEC_TECONSTANTS_NAME);\n+\t\tfinal Set<String> teConstantModuleHashSet = new HashSet<>();\n+\t\tString modelValuesAsConstants;\n+\t\tif (!modConstants.isEmpty()) {\n+\t\t\tteConstantModuleHashSet.add(teConstantSpecName);\n+\t\t\tmodelValuesAsConstants = String.format(\"CONSTANTS %s\\n\", String.join(\", \", modConstants));\n+\t\t}\n+\t\telse {\n+\t\t\tmodelValuesAsConstants = \"\";\n+\t\t}\n \n \t\t/**\n \t\t * Write SpecTE.\n \t\t */\n-\t\tfinal Set<String> extendedModules = new HashSet<>();\n-\t\textendedModules.add(TLAConstants.BuiltInModules.TLC);\n-\t\textendedModules.add(TLAConstants.BuiltInModules.TRACE_EXPRESSIONS);\n+\t\tfinal Set<String> specTEExtendedModules = new HashSet<>();\n+\t\t// A TE spec has to extend Toolbox to have access to _TETrace and _TEPosition\n+\t\t// operators.\n+\t\tspecTEExtendedModules.add(TLAConstants.BuiltInModules.TRACE_EXPRESSIONS);\n+\t\t// Adds Json module so we can write a Json output.\n+\t\tspecTEExtendedModules.add(\"Json\");\n+\t\tspecTEExtendedModules.add(\"TLCExt\");\n+\t\tspecTEExtendedModules.addAll(teConstantModuleHashSet);\n+\t\t\t\t\n+\t\twriter.addPrimer(teSpecModuleName, originalSpecName, specTEExtendedModules);\t\t\n \n-\t\twriter.addPrimer(teSpecModuleName, originalSpecName, extendedModules);\n-\t\t\n \t\twriter.addTraceExpressionInstance(\n \t\t\t\tString.format(\"%s_%s\", originalSpecName, TLAConstants.TraceExplore.EXPLORATION_MODULE_NAME));\n \n \t\tfinal List<MCState> trace = error.getStates();\n+\n+\t\tfinal String teTraceName = String.format(\"%s_%s\", originalSpecName, TLAConstants.TraceExplore.SPEC_TETRACE_NAME);\n \t\t\n-\t\tfinal String traceFunctionId = writer.addTraceFunctionInstance();\n+\t\twriter.addTraceFunctionInstance(teTraceName);\n \t\t\n-\t\twriter.addProperties(trace);\n+\t\twriter.addProperties(trace, originalSpecName);\n \n \t\t// Write Init and Next with vars instead of extracting the vars from trace to\n \t\t// always write a syntactically correct behavior spec even if trace = <<>>.\n-\t\twriter.addInitNextTraceFunction(trace, variables, SPEC_TE_INIT_ID, SPEC_TE_NEXT_ID);\n+\t\twriter.addInitNextTraceFunction(trace, teSpecModuleName, variables, SPEC_TE_INIT_ID, SPEC_TE_NEXT_ID, results);\n \t\t\t\t\n \t\twriter.addFooter();\n \t\t\n@@ -181,10 +263,16 @@ public static void writeSpecTEStreams(\n \t\twriter.append(TLAConstants.CR);\n \t\t\n \t\tfinal SpecTraceExpressionWriter te = new SpecTraceExpressionWriter();\n+\t\tfinal String teModuleName = String.format(\"%s_%s\", originalSpecName, TLAConstants.TraceExplore.EXPLORATION_MODULE_NAME);\n \t\tte.append(TLAConstants.CR);\n-\t\tte.addPrimer(String.format(\"%s_%s\", originalSpecName, TLAConstants.TraceExplore.EXPLORATION_MODULE_NAME),\n-\t\t\t\toriginalSpecName, extendedModules);\n-\t\tte.addTraceExpressionStub(TLAConstants.TraceExplore.SPEC_TE_TRACE_EXPRESSION, variables);\n+\t\t\n+\t\twriter.append(String.format(\" Note that you can extract this module `%s`\", teModuleName)).append(TLAConstants.CR);\n+\t\twriter.append(\"  to a dedicated file to reuse `expression` (the module in the \").append(TLAConstants.CR);\n+\t\twriter.append(String.format(\"  dedicated `%s.tla` file takes precedence \", teModuleName)).append(TLAConstants.CR);\n+\t\twriter.append(String.format(\"  over the module `BlockingQueue_TEExpression` below).\", teModuleName));\n+\t\t\t\n+\t\tte.addPrimer(teModuleName, originalSpecName, specTEExtendedModules);\n+\t\tte.addTraceExpressionStub(originalSpecName, TLAConstants.TraceExplore.SPEC_TE_TRACE_EXPRESSION, variables);\t\t\n \t\tte.addFooter();\n \t\twriter.append(TLAConstants.CR + te.toString() + TLAConstants.CR + TLAConstants.CR);\n \t\t\n@@ -199,35 +287,46 @@ public static void writeSpecTEStreams(\n \t\t\t\t.append(TLAConstants.CR);\n \t\twriter.append(\" To create the file, replace your spec's invariant F with:\").append(TLAConstants.CR);\n \t\twriter.append(\"  Inv == IF F THEN TRUE ELSE ~IOSerialize(Trace, \\\"file.bin\\\", TRUE)\").append(TLAConstants.CR);\n-\t\twriter.append(\" (IOUtils and TLCExt modules from https://modules.tlapl.us/)\");\n+\t\twriter.append(\" (IOUtils module is from https://modules.tlapl.us/)\");\n \t\t\n-\t\tfinal Set<String> extendedModulesWithIOUtils = new HashSet<>(extendedModules);\n+\t\tfinal Set<String> extendedModulesWithIOUtils = new HashSet<>();\n \t\textendedModulesWithIOUtils.add(\"IOUtils\");\n+\t\textendedModulesWithIOUtils.addAll(teConstantModuleHashSet);\n \t\t\n \t\tfinal SpecTraceExpressionWriter w = new SpecTraceExpressionWriter();\n \t\tw.append(TLAConstants.CR);\n-\t\tw.addPrimer(TLAConstants.TraceExplore.TRACE_EXPRESSION_MODULE_NAME + \"TraceDef\", originalSpecName,\n-\t\t\t\textendedModulesWithIOUtils);\n-\t\tw.append(traceFunctionId).append(TLAConstants.DEFINES).append(\"IODeserialize(\\\"file.bin\\\", TRUE)\\n\\n\");\n+\t\tw.addPrimer(teTraceName, originalSpecName, extendedModulesWithIOUtils);\n+\t\tw.append(TLAConstants.TraceExplore.SPEC_TETRACE_TRACE_DEF).append(TLAConstants.DEFINES).append(\"IODeserialize(\\\"file.bin\\\", TRUE)\\n\\n\");\n \t\tw.addFooter();\n \t\t// Users can uncomment the module if they wish to read the serialized trace.\n \t\twriter.append(TLAConstants.CR + w.getComment() + TLAConstants.CR + TLAConstants.CR);\n \t\t\n \t\t/**\n \t\t * Write definition of trace def into new module.\n \t\t */\n-\t\twriter.addPrimer(TLAConstants.TraceExplore.TRACE_EXPRESSION_MODULE_NAME + \"TraceDef\", originalSpecName, extendedModules);\n+\t\tfinal Set<String> teTraceExtendedModules = new HashSet<>();\n+\t\tteTraceExtendedModules.addAll(teConstantModuleHashSet);\n+\t\twriter.addPrimer(teTraceName, originalSpecName, teTraceExtendedModules);\n \n-\t\twriter.addTraceFunction(trace, traceFunctionId);\n+\t\twriter.addTraceFunction(trace, TLAConstants.TraceExplore.SPEC_TETRACE_TRACE_DEF, TLAConstants.TraceExplore.SPEC_TETRACE_TRACE);\n \t\t\n-\t\twriter.addAliasToCfg(TLAConstants.TraceExplore.SPEC_TE_TTRACE_EXPRESSION);\n+\t\twriter.addAliasToCfg(TLAConstants.TraceExplore.SPEC_TE_TTRACE_EXPRESSION);\t\t\n+\n+\t\t/**\n+\t\t * Write TEConstants module, if needed.\n+\t\t */\n+\t\tif (modelValuesAsConstants != \"\") {\n+\t\t\twriter.addFooter();\n+\t\t\twriter.append(TLAConstants.CR);\n+\t\t\twriter.addPrimer(teConstantSpecName, originalSpecName);\n+\t\t\twriter.append(modelValuesAsConstants).append(TLAConstants.CR);\n+\t\t}\n \t\t\n         /**\n          * Write to streams.\n          */\n \t\twriter.writeStreams(specTETLAOutStream, specTECFGOutStream);\n-    }\n-    \n+    }\t    \n     \n     private enum RunMode {\n     \tGENERATE_SPEC_TE, PRETTY_PRINT, GENERATE_FROM_TLC_RUN, QUASI_REPL, TRACE_EXPLORATION;"
  },
  {
    "sha": "bb046b16eedc8a095d9cf6af1d8c69f30843ad8e",
    "filename": "tlatools/org.lamport.tlatools/src/tlc2/output/AbstractSpecWriter.java",
    "status": "modified",
    "additions": 8,
    "deletions": 6,
    "changes": 14,
    "blob_url": "https://github.com/tlaplus/tlaplus/blob/50a8cc1a9aa5ea978e3e1b28da091529314631e7/tlatools/org.lamport.tlatools/src/tlc2/output/AbstractSpecWriter.java",
    "raw_url": "https://github.com/tlaplus/tlaplus/raw/50a8cc1a9aa5ea978e3e1b28da091529314631e7/tlatools/org.lamport.tlatools/src/tlc2/output/AbstractSpecWriter.java",
    "contents_url": "https://api.github.com/repos/tlaplus/tlaplus/contents/tlatools/org.lamport.tlatools/src/tlc2/output/AbstractSpecWriter.java?ref=50a8cc1a9aa5ea978e3e1b28da091529314631e7",
    "patch": "@@ -29,11 +29,12 @@\n      */\n \tpublic static String addArrowAssignmentToBuffers(final StringBuilder tlaBuffer, final StringBuilder cfgBuffer,\n \t\t\tfinal Assignment constant, final String schema) {\n-\t\treturn addArrowAssignmentIdToBuffers(tlaBuffer, cfgBuffer, constant, SpecWriterUtilities.getValidIdentifier(schema));\n+\t\tfinal String identifier = SpecWriterUtilities.getValidIdentifier(schema);\n+\t\treturn addArrowAssignmentIdToBuffers(tlaBuffer, cfgBuffer, constant, identifier, identifier);\n \t}\n \n \tpublic static String addArrowAssignmentIdToBuffers(final StringBuilder tlaBuffer, final StringBuilder cfgBuffer,\n-\t\t\tfinal Assignment constant, final String id) {\n+\t\t\tfinal Assignment constant, final String id, final String configId) {\n \t\t// constant instantiation\n \t\t// to .cfg : foo <- <id>\n \t\t// to _MC.tla : <id>(a, b, c)==\n@@ -42,8 +43,8 @@ public static String addArrowAssignmentIdToBuffers(final StringBuilder tlaBuffer\n \t\ttlaBuffer.append(constant.getRight()).append(TLAConstants.CR);\n \t\t\n \t\tif (cfgBuffer != null) {\n-\t\t\tcfgBuffer.append(TLAConstants.KeyWords.CONSTANT).append(TLAConstants.CR);\n-\t\t\tcfgBuffer.append(constant.getLabel()).append(TLAConstants.ARROW).append(id).append(TLAConstants.CR);\n+\t\t\tcfgBuffer.append(TLAConstants.CR).append(TLAConstants.KeyWords.CONSTANT).append(TLAConstants.CR);\n+\t\t\tcfgBuffer.append(TLAConstants.INDENT).append(constant.getLabel()).append(TLAConstants.ARROW).append(configId).append(TLAConstants.CR);\n \t\t}\n \t\treturn id;\n \t}\n@@ -519,8 +520,9 @@ public void addAlias(final String aliasString, final String attributeName) {\n \t */\n \tpublic void addAliasToCfg(final String aliasName) {\n \t\tif (this.cfgBuffer != null) {\n-\t\t\tthis.cfgBuffer.append(TLAConstants.COMMENT).append(\"ALIAS definition\").append(TLAConstants.CR);\n-\t\t\tthis.cfgBuffer.append(\"ALIAS\").append(TLAConstants.CR).append(aliasName).append(TLAConstants.CR);\n+\t\t\tthis.cfgBuffer.append(TLAConstants.CR);\n+\t\t\tthis.cfgBuffer.append(\"ALIAS\").append(TLAConstants.CR);\n+\t\t\tthis.cfgBuffer.append(TLAConstants.INDENT).append(aliasName).append(TLAConstants.CR);\n \t\t}\n \t}\n \t"
  },
  {
    "sha": "05b7062de84bf4ebce6d0a005b7b4eb9dd2ab66a",
    "filename": "tlatools/org.lamport.tlatools/src/tlc2/output/SpecTraceExpressionWriter.java",
    "status": "modified",
    "additions": 158,
    "deletions": 103,
    "changes": 261,
    "blob_url": "https://github.com/tlaplus/tlaplus/blob/50a8cc1a9aa5ea978e3e1b28da091529314631e7/tlatools/org.lamport.tlatools/src/tlc2/output/SpecTraceExpressionWriter.java",
    "raw_url": "https://github.com/tlaplus/tlaplus/raw/50a8cc1a9aa5ea978e3e1b28da091529314631e7/tlatools/org.lamport.tlatools/src/tlc2/output/SpecTraceExpressionWriter.java",
    "contents_url": "https://api.github.com/repos/tlaplus/tlaplus/contents/tlatools/org.lamport.tlatools/src/tlc2/output/SpecTraceExpressionWriter.java?ref=50a8cc1a9aa5ea978e3e1b28da091529314631e7",
    "patch": "@@ -6,6 +6,7 @@\n import java.util.Set;\n import java.util.stream.Collectors;\n \n+import tlc2.input.MCParserResults;\n import tlc2.model.Assignment;\n import tlc2.model.Formula;\n import tlc2.model.MCState;\n@@ -219,7 +220,7 @@ public static void addInitNextToBuffers(final StringBuilder tlaBuffer, final Str\n \t         * Add the init definition.                            *\n \t         *******************************************************/\n \t\t\tif (cfgBuffer != null) {\n-\t\t\t\tcfgBuffer.append(TLAConstants.COMMENT).append(TLAConstants.KeyWords.INIT).append(\" definition\");\n+\t\t\t\tcfgBuffer.append(TLAConstants.CR);\n \t\t\t\tcfgBuffer.append(TLAConstants.CR).append(TLAConstants.KeyWords.INIT).append(TLAConstants.CR);\n \t\t\t\tcfgBuffer.append(initId).append(TLAConstants.CR);\n \t\t\t}\n@@ -504,7 +505,7 @@ public static void addInitNextToBuffers(final StringBuilder tlaBuffer, final Str\n \t}\n \n \tpublic static String addTraceFunctionToBuffers(final StringBuilder tlaBuffer, final StringBuilder cfgBuffer,\n-\t\t\tfinal List<MCState> input, final String id) {\n+\t\t\tfinal List<MCState> input, final String id, final String configId) {\n \t\t// Filter stuttering or back2state instances from trace.\n \t\tfinal List<MCState> trace = input.stream()\n \t\t\t\t.filter(state -> !state.isBackToState() && !state.isStuttering())\n@@ -513,7 +514,7 @@ public static String addTraceFunctionToBuffers(final StringBuilder tlaBuffer, fi\n \t\tif (trace.isEmpty()) {\n \t\t\treturn addArrowAssignmentIdToBuffers(tlaBuffer, cfgBuffer,\n \t\t\t\t\tnew Assignment(TLAConstants.TraceExplore.TRACE, new String[0], TLAConstants.BEGIN_TUPLE + TLAConstants.END_TUPLE),\n-\t\t\t\t\tid);\n+\t\t\t\t\tid, configId);\n \t    }\n \t\t\n \t\t// Trace\n@@ -533,7 +534,7 @@ public static String addTraceFunctionToBuffers(final StringBuilder tlaBuffer, fi\n \t\t\n \t\treturn addArrowAssignmentIdToBuffers(tlaBuffer, cfgBuffer,\n \t\t\t\tnew Assignment(TLAConstants.TraceExplore.TRACE, new String[0], traceFunctionDef.toString()),\n-\t\t\t\tid);\n+\t\t\t\tid, configId);\n \t}\n \t\n \t\n@@ -582,7 +583,7 @@ public SpecTraceExpressionWriter() {\n \tpublic void addPrimer(final String moduleFilename, final String extendedModuleName) {\n \t\taddPrimer(moduleFilename, extendedModuleName, new HashSet<>());\n \t}\n-\t\n+\n \t/**\n \t * Adds MODULE and EXTENDS statements.\n \t */\n@@ -594,13 +595,6 @@ public void addPrimer(\n \t\t\textraExtendedModules.add(extendedModuleName);\n \t\t}\n \t\t\n-\t\t// Not sure why this is required by TE.tla.\n-\t\textraExtendedModules.add(\"TLC\");\n-\t\t\n-\t\t// A TE spec has to extend Toolbox to have access to _TETrace and _TEPosition\n-\t\t// operators.\n-\t\textraExtendedModules.add(\"Toolbox\");\n-\t\t\n \t\ttlaBuffer.append(SpecWriterUtilities.getExtendingModuleContent(moduleFilename,\n \t\t\t\textraExtendedModules.toArray(new String[extraExtendedModules.size()])));\n \t}\n@@ -610,21 +604,57 @@ public void addPrimer(\n \t * This is an alias function which applies the identity transformation\n \t * to the spec's variables, with some comments explaining how to add\n \t * additional transformations for custom trace expressions.\n+\t * @param moduleName Name of original module.\n \t * @param teName Name of trace expression.\n \t * @param variables Spec variables; transformed by identity.\n \t */\n-\tpublic void addTraceExpressionStub(String teName, final List<String> variables) {\n+\tpublic void addTraceExpressionStub(String moduleName, String teName, final List<String> variables) {\n \t\tthis.tlaBuffer.append(teName + TLAConstants.DEFINES + TLAConstants.CR);\n \t\tthis.tlaBuffer\n-\t\t\t\t.append(TLAConstants.INDENT + TLAConstants.L_SQUARE_BRACKET + TLAConstants.CR + TLAConstants.INDENT);\n-\t\tthis.tlaBuffer.append(TLAConstants.INDENT\n-\t\t\t\t+ variables.stream().map(var -> var + TLAConstants.RECORD_ARROW + var).collect(Collectors\n-\t\t\t\t\t\t.joining(TLAConstants.CR + TLAConstants.INDENT + TLAConstants.INDENT + TLAConstants.COMMA)));\n-\t\tthis.tlaBuffer.append(TLAConstants.CR);\n-\t\tthis.tlaBuffer.append(TLAConstants.INDENT + TLAConstants.INDENT + TLAConstants.COMMENT + \"Put additional trace expressions here; examples:\" + TLAConstants.CR);\n-\t\tthis.tlaBuffer.append(TLAConstants.INDENT + TLAConstants.INDENT + TLAConstants.COMMENT + TLAConstants.COMMA + \"x\" + TLAConstants.RECORD_ARROW + TLAConstants.TLA_NOT + \"y\" + TLAConstants.PRIME + TLAConstants.CR);\n-\t\tthis.tlaBuffer.append(TLAConstants.INDENT + TLAConstants.INDENT + TLAConstants.COMMENT + TLAConstants.COMMA + \"e\" + TLAConstants.RECORD_ARROW + TLAConstants.KeyWords.ENABLED + TLAConstants.SPACE + \"ActionName\" + TLAConstants.CR);\n-\t\tthis.tlaBuffer.append(TLAConstants.INDENT + TLAConstants.R_SQUARE_BRACKET + TLAConstants.CR + TLAConstants.CR);\n+\t\t\t\t.append(TLAConstants.INDENT + TLAConstants.L_SQUARE_BRACKET + TLAConstants.CR);\n+\n+\t\t// Create local string build for expression and comments so we can indent everything together in the end.\n+\t\tStringBuilder localBuffer = new StringBuilder();\n+\n+\t\tlocalBuffer.append(TLAConstants.COMMENT).append(String.format(\"To hide variables of the `%s` spec from the error trace,\", moduleName)).append(TLAConstants.CR);\n+\t\tlocalBuffer.append(TLAConstants.COMMENT).append(\"remove the variables below.  The trace will be written in the order\").append(TLAConstants.CR);\n+\t\tlocalBuffer.append(TLAConstants.COMMENT).append(\"of the fields of this record.\").append(TLAConstants.CR);\n+\t\t\n+\t\tlocalBuffer.append(\n+\t\t\t\tvariables.stream().map(var -> var + TLAConstants.RECORD_ARROW + var).collect(Collectors\n+\t\t\t\t\t\t.joining(TLAConstants.CR + TLAConstants.COMMA))).append(TLAConstants.CR).append(TLAConstants.CR);\t\n+\t\t\t\t\t\t\n+\t\tlocalBuffer.append(TLAConstants.COMMENT).append(\"Put additional constant-, state-, and action-level expressions here:\").append(TLAConstants.CR);\n+\t\tlocalBuffer.append(TLAConstants.COMMENT).append(\",_stateNumber |-> _TEPosition\").append(TLAConstants.CR);\n+\t\t\n+\t\tif (variables.size() > 0) {\n+\t\t\t// Check that exists at least one variable so we can use\n+\t\t\t// in the commented trace expressions.\n+\t\t\tString someVar = variables.get(0);\n+\t\t\t\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT).append(String.format(\",_%sUnchanged |-> %s = %s'\", someVar, someVar, someVar)).append(TLAConstants.CR).append(TLAConstants.CR);\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT).append(String.format(\"Format the `%s` variable as Json value.\", someVar)).append(TLAConstants.CR);\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT).append(String.format(\",_%sJson |->\", someVar)).append(TLAConstants.CR);\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT + TLAConstants.INDENT).append(\"LET J == INSTANCE Json\").append(TLAConstants.CR);\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT + TLAConstants.INDENT).append(String.format(\"IN J!ToJson(%s)\", someVar))\n+\t\t\t\t.append(TLAConstants.CR).append(TLAConstants.CR);\n+\t\t\t\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT).append(\"Lastly, you may build expression over arbitrary sets of states by\").append(TLAConstants.CR);\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT).append(\"leveraging the _TETrace operator.  For example, this is how to\").append(TLAConstants.CR);\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT).append(\"count the number of times a spec variable changed up to the current\").append(TLAConstants.CR);\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT).append(\"state in the trace.\").append(TLAConstants.CR);\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT).append(String.format(\",_%sModCount |->\", someVar)).append(TLAConstants.CR);\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT + TLAConstants.INDENT).append(\"LET F[s \\\\in DOMAIN _TETrace] ==\").append(TLAConstants.CR);\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT + TLAConstants.INDENT + TLAConstants.INDENT).append(\"IF s = 1 THEN 0\").append(TLAConstants.CR);\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT + TLAConstants.INDENT + TLAConstants.INDENT)\n+\t\t\t\t.append(String.format(\"ELSE IF _TETrace[s].%s # _TETrace[s-1].%s\", someVar, someVar)).append(TLAConstants.CR);\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT + TLAConstants.INDENT + TLAConstants.INDENT + TLAConstants.INDENT)\n+\t\t\t\t.append(\"THEN 1 + F[s-1] ELSE F[s-1]\").append(TLAConstants.CR);\n+\t\t\tlocalBuffer.append(TLAConstants.COMMENT + TLAConstants.INDENT).append(\"IN F[_TEPosition - 1]\").append(TLAConstants.CR);\t\t\n+\t\t}\n+\t\t\n+\t\tthis.tlaBuffer.append(indentString(localBuffer.toString(), 2));\n+\t\tthis.tlaBuffer.append(TLAConstants.CR + TLAConstants.INDENT + TLAConstants.R_SQUARE_BRACKET + TLAConstants.CR + TLAConstants.CR);\t\t\n \t}\n \n \tpublic void addFooter() {\n@@ -713,18 +743,20 @@ public void addVariablesAndDefinitions(final TraceExpressionInformationHolder[]\n \t */\n \tprivate void addInvariant(final MCState finalState) {\n \t    final String id = SpecWriterUtilities.getValidIdentifierNoTimestamp(TLAConstants.Schemes.INVARIANT_SCHEME);\n-\t    cfgBuffer.append(TLAConstants.COMMENT).append(TLAConstants.KeyWords.INVARIANT).append(\" definition\");\n \t    cfgBuffer.append(TLAConstants.CR).append(TLAConstants.KeyWords.INVARIANT).append(TLAConstants.CR);\n-\t    cfgBuffer.append(id).append(TLAConstants.CR);\n+\t    cfgBuffer.append(TLAConstants.INDENT).append(id).append(TLAConstants.CR);\n \t\n-\t    tlaBuffer.append(TLAConstants.COMMENT).append(TLAConstants.KeyWords.INVARIANT).append(\" definition\");\n \t    tlaBuffer.append(TLAConstants.CR).append(id).append(TLAConstants.DEFINES_CR);\n \t    tlaBuffer.append(TLAConstants.INDENT).append(TLAConstants.TLA_NOT).append(TLAConstants.L_PAREN).append(TLAConstants.CR);\n-\t    tlaBuffer.append(TLAConstants.INDENT).append(getStateConjunction(finalState)).append(TLAConstants.CR);\n+\t    tlaBuffer.append(getStateConjunction(finalState)).append(TLAConstants.CR);\n \t    tlaBuffer.append(TLAConstants.INDENT).append(TLAConstants.R_PAREN);\n \t}\n \n \tpublic void addProperties(final List<MCState> trace) {\n+\t\taddProperties(trace, null);\n+\t}\n+\n+\tpublic void addProperties(final List<MCState> trace, String specName) {\n         MCState finalState = trace.get(trace.size() - 1);\n         boolean isBackToState = finalState.isBackToState();\n         boolean isStuttering = finalState.isStuttering();\n@@ -766,11 +798,11 @@ public void addProperties(final List<MCState> trace) {\n \t\ttlaBuffer.append(CLOSING_SEP).append(TLAConstants.CR);\n         \n \t\t// Do not require to pass -deadlock on the command-line (properties assert that\n-\t\t// TLC re-finds the error-trace).\n-\t\tcfgBuffer.append(TLAConstants.COMMENT).append(ModelConfig.CheckDeadlock).append(\" off because of PROPERTY or INVARIANT above.\")\n+\t\t// TLC re-finds the error-trace).\t\t\n+\t\tcfgBuffer.append(TLAConstants.CR).append(ModelConfig.CheckDeadlock).append(TLAConstants.CR);\n+\t\tcfgBuffer.append(TLAConstants.INDENT + TLAConstants.COMMENT).append(ModelConfig.CheckDeadlock).append(\" off because of PROPERTY or INVARIANT above.\")\n \t\t\t\t.append(TLAConstants.CR);\n-\t\tcfgBuffer.append(ModelConfig.CheckDeadlock).append(TLAConstants.SPACE).append(TLAConstants.FALSE);\n-\t\tcfgBuffer.append(TLAConstants.CR);\n+\t\tcfgBuffer.append(TLAConstants.INDENT).append(TLAConstants.FALSE);\n \t}\n \n \t/**\n@@ -787,15 +819,13 @@ public void addProperties(final List<MCState> trace) {\n \t */\n \tprivate void addStutteringProperty(final MCState finalState) {\n \t    String id = SpecWriterUtilities.getValidIdentifierNoTimestamp(TLAConstants.Schemes.PROP_SCHEME);\n-\t    cfgBuffer.append(TLAConstants.COMMENT).append(TLAConstants.KeyWords.PROPERTY).append(\" definition\");\n \t    cfgBuffer.append(TLAConstants.CR).append(TLAConstants.KeyWords.PROPERTY).append(TLAConstants.CR);\n-\t    cfgBuffer.append(id).append(TLAConstants.CR);\n+\t    cfgBuffer.append(TLAConstants.INDENT).append(id).append(TLAConstants.CR);\n \t\n-\t    tlaBuffer.append(TLAConstants.COMMENT).append(TLAConstants.KeyWords.PROPERTY).append(\" definition\");\n \t    tlaBuffer.append(TLAConstants.CR).append(id).append(TLAConstants.DEFINES_CR);\n-\t    tlaBuffer.append(TLAConstants.TLA_NOT).append(TLAConstants.TLA_EVENTUALLY_ALWAYS);\n+\t    tlaBuffer.append(TLAConstants.INDENT + TLAConstants.TLA_NOT).append(TLAConstants.TLA_EVENTUALLY_ALWAYS);\n \t    tlaBuffer.append(TLAConstants.L_PAREN).append(TLAConstants.CR).append(getStateConjunction(finalState));\n-\t    tlaBuffer.append(TLAConstants.CR).append(TLAConstants.R_PAREN);\n+\t    tlaBuffer.append(TLAConstants.CR).append(TLAConstants.INDENT + TLAConstants.R_PAREN);\n \t}\n \n \t/**\n@@ -815,12 +845,10 @@ private void addStutteringProperty(final MCState finalState) {\n \t */\n \tprivate void addBackToStateProperty(final MCState finalState, final MCState backToState) {\n \t    final String id = SpecWriterUtilities.getValidIdentifierNoTimestamp(TLAConstants.Schemes.PROP_SCHEME);\n-\t    cfgBuffer.append(TLAConstants.COMMENT).append(TLAConstants.KeyWords.PROPERTY).append(\" definition\");\n \t    cfgBuffer.append(TLAConstants.CR).append(TLAConstants.KeyWords.PROPERTY).append(TLAConstants.CR);\n-\t    cfgBuffer.append(id).append(TLAConstants.CR);\n-\t\n-\t    tlaBuffer.append(TLAConstants.COMMENT).append(TLAConstants.KeyWords.PROPERTY).append(\" definition\");\n-\t    tlaBuffer.append(TLAConstants.CR).append(id).append(TLAConstants.DEFINES_CR);\n+\t    cfgBuffer.append(TLAConstants.INDENT).append(id).append(TLAConstants.CR);\n+\t    \n+\t\ttlaBuffer.append(TLAConstants.CR).append(id).append(TLAConstants.DEFINES_CR);\n \n \t\tStringBuilder localBuffer = new StringBuilder();\n \t    localBuffer.append(TLAConstants.TLA_NOT).append(TLAConstants.L_PAREN).append(TLAConstants.L_PAREN);\n@@ -831,8 +859,8 @@ private void addBackToStateProperty(final MCState finalState, final MCState back\n \t    localBuffer.append(getStateConjunction(backToState)).append(TLAConstants.CR).append(TLAConstants.R_PAREN);\n \t    localBuffer.append(TLAConstants.R_PAREN).append(TLAConstants.R_PAREN);\n \n-\t\t// Writes local buffer back to tla buffer with some indentation.\n-\t\ttlaBuffer.append(identString(localBuffer.toString(), 1));\n+\t\t// Writes local buffer back to tla buffer with some iation.\n+\t\ttlaBuffer.append(indentString(localBuffer.toString(), 1));\n \t}\n \n \t/**\n@@ -884,42 +912,69 @@ public void addInitNext(final List<MCState> trace, final String initId, String n\n \t\taddInitNext(trace, null, initId, nextId, actionConstraintId, nextSubActionBasename);\n \t}\n \n-\tpublic void addInitNextTraceFunction(final List<MCState> trace, final List<String> vars, final String initId, String nextId) {\n-        /*******************************************************\n+\tpublic void addInitNextTraceFunction(final List<MCState> trace, final String teSpecModuleName, final List<String> vars, final String _initId, String _nextId, MCParserResults results) {\n+\t\t/*******************************************************\n          * Add the init definition.                            *\n          *******************************************************/\n \t\tif (cfgBuffer != null) {\n-\t\t\tcfgBuffer.append(TLAConstants.COMMENT).append(TLAConstants.KeyWords.INIT).append(\" definition\");\n+\t\t\tcfgBuffer.append(TLAConstants.CR);\n \t\t\tcfgBuffer.append(TLAConstants.CR).append(TLAConstants.KeyWords.INIT).append(TLAConstants.CR);\n-\t\t\tcfgBuffer.append(initId).append(TLAConstants.CR);\n+\t\t\tcfgBuffer.append(TLAConstants.INDENT).append(TLAConstants.TraceExplore.SPEC_TE_INIT).append(TLAConstants.CR);\n \t\t}\n+\n+\t\ttlaBuffer.append(TLAConstants.TraceExplore.SPEC_TE_INIT).append(TLAConstants.DEFINES_CR);\n \t\t\n-\t\ttlaBuffer.append(TLAConstants.COMMENT).append(\"TRACE INIT definition \");\n-\t\ttlaBuffer.append(TLAConstants.TraceExplore.TRACE_EXPLORE_INIT).append(TLAConstants.CR);\n-\t\ttlaBuffer.append(initId).append(TLAConstants.DEFINES_CR);\n-        \n+\t\t// Add INIT identifier from original spec to the beginning of the TE init spec.\n+\t\t// If the config spec has `SPECIFICATION`, then this will be empty.\n+\t\tfinal String configInitName = results.getModelConfig().getInit();\n+\t\tif (configInitName != null && configInitName != \"\") {\n+\t\t\ttlaBuffer.append(TLAConstants.INDENTED_CONJUNCTIVE);\n+        \ttlaBuffer.append(configInitName);\n+        \ttlaBuffer.append(TLAConstants.CR);\n+\t\t}\n+\n         // variables from spec\n \t\tfor (String var : vars) {\n             tlaBuffer.append(TLAConstants.INDENTED_CONJUNCTIVE);\n             tlaBuffer.append(var).append(TLAConstants.EQ).append(\"_TETrace[1].\").append(var);\n             tlaBuffer.append(TLAConstants.CR);\n         }\n \t\t\n-\t\ttlaBuffer.append(CLOSING_SEP).append(TLAConstants.CR);\n-\t\t\n+\t\ttlaBuffer.append(TLAConstants.SEP).append(TLAConstants.CR).append(TLAConstants.CR);\n+\n+\t\t// Get final state so we can check if this trace is for a safety\n+\t\t// or liveness property.\n+\t\tfinal MCState finalState = trace.get(trace.size() - 1);\t\t\n+\t\t\t\t\n+\t\t// If we have a safety property, use `_constraint`, otherwise\n+\t\t// use `_next`.\t\n+\t\tString nextId = \"\";\n+\t\tif (finalState.isBackToState() || finalState.isStuttering()) {\n+\t\t\tnextId = TLAConstants.TraceExplore.SPEC_TE_NEXT;\n+\t\t} else {\n+\t\t\tnextId = TLAConstants.TraceExplore.SPEC_TE_CONSTRAINT;\t\t\t\n+\t\t}\n+\n         /************************************************\n          *  Now add the next state relation             *\n          ************************************************/\n-\t\tif (cfgBuffer != null) {\n-\t\t\tcfgBuffer.append(TLAConstants.COMMENT).append(TLAConstants.KeyWords.NEXT).append(\" definition\");\n+\t\tif (cfgBuffer != null) {\t\n+\t\t\tfinal String configNextName = results.getModelConfig().getNext();\t\t\n \t\t\tcfgBuffer.append(TLAConstants.CR).append(TLAConstants.KeyWords.NEXT).append(TLAConstants.CR);\n-\t\t\tcfgBuffer.append(nextId).append(TLAConstants.CR);\n-\t\t}\n+\t\t\t// Add NEXT identifier from original spec.\n+\t\t\t// If the config spec has `SPECIFICATION` or it's an invariant, then use `nextId`.\n+\t\t\tif (finalState.isBackToState() || finalState.isStuttering() || configNextName == null || configNextName == \"\") {\n+\t\t\t\tcfgBuffer.append(TLAConstants.INDENT).append(nextId).append(TLAConstants.CR);\n+\t\t\t} else {\n+\t\t\t\tcfgBuffer.append(TLAConstants.INDENT).append(configNextName).append(TLAConstants.CR);\n+\t\t\t}\n+\t\t}\t\t\n \t\t\n-\t\ttlaBuffer.append(TLAConstants.COMMENT).append(\"TRACE NEXT definition \");\n-\t\ttlaBuffer.append(TLAConstants.TraceExplore.TRACE_EXPLORE_NEXT).append(TLAConstants.CR);\n-\t\t// _SpecTENext == \n+\t\t// _next ==\n+\t\t// OR\n+\t\t// _constraint ==\n \t\ttlaBuffer.append(nextId).append(TLAConstants.DEFINES_CR);\n+\n \t\tif (trace.size() == 1) {\n \t\t\ttlaBuffer.append(TLAConstants.INDENT).append(TLAConstants.INDENTED_CONJUNCTIVE);\n \t\t\ttlaBuffer.append(\"FALSE\").append(TLAConstants.CR);\n@@ -929,9 +984,7 @@ public void addInitNextTraceFunction(final List<MCState> trace, final List<Strin\n \t\t\ttlaBuffer.append(TLAConstants.INDENT).append(TLAConstants.INDENTED_CONJUNCTIVE).append(TLAConstants.TLA_OR).append(\" j = i + 1\")\n \t\t\t\t\t.append(TLAConstants.CR);\n \t\t\t// Back to state?\n-\t\t\tfinal MCState finalState = trace.get(trace.size() - 1);\n-\t\t\tfinal boolean isBackToState = finalState.isBackToState();\n-\t\t\tif (isBackToState) {\n+\t\t\tif (finalState.isBackToState()) {\n \t\t\t\t// Instead of this disjunct, we could append backToState to the trace function\n \t\t\t\t// (_TETrace). Len(_TETrace) would however be off by one.\n \t\t\t\tMCState backToState = trace.get(finalState.getStateNumber() - 1);\n@@ -958,16 +1011,25 @@ public void addInitNextTraceFunction(final List<MCState> trace, final List<Strin\n \t        }\n \t\t}\n \n-\t\ttlaBuffer.append(TLAConstants.CR).append(TLAConstants.CR);\n+\t\ttlaBuffer.append(TLAConstants.CR).append(TLAConstants.COMMENT)\n+\t\t\t.append(\"Uncomment the ASSUME below to write the states of the error trace\").append(TLAConstants.CR);\n+\t\ttlaBuffer.append(TLAConstants.COMMENT).append(\"to the given file in Json format. Note that you can pass any tuple\").append(TLAConstants.CR);\n+\t\ttlaBuffer.append(TLAConstants.COMMENT).append(\"to `JsonSerialize`. For example, a sub-sequence of _TETrace.\").append(TLAConstants.CR);\n+\t\ttlaBuffer.append(TLAConstants.COMMENT).append(TLAConstants.KeyWords.ASSUME).append(TLAConstants.CR);\n+\t\ttlaBuffer.append(TLAConstants.COMMENT + TLAConstants.INDENT).append(\"LET J == INSTANCE Json\").append(TLAConstants.CR);\n+\t\ttlaBuffer.append(TLAConstants.COMMENT + TLAConstants.INDENT + TLAConstants.INDENT)\n+\t\t\t.append(String.format(\"IN J!JsonSerialize(\\\"%s.json\\\", _TETrace)\", teSpecModuleName)).append(TLAConstants.CR);\t\t\n+\n+\t\ttlaBuffer.append(TLAConstants.CR);\n \t}\n \n \tpublic String addTraceFunction(final List<MCState> input) {\n-\t\treturn addTraceFunctionToBuffers(tlaBuffer, cfgBuffer, input,\n-\t\t\t\tSpecWriterUtilities.getValidIdentifier(TLAConstants.Schemes.DEFOV_SCHEME));\n+\t\tfinal String identifier = SpecWriterUtilities.getValidIdentifier(TLAConstants.Schemes.DEFOV_SCHEME);\n+\t\treturn addTraceFunctionToBuffers(tlaBuffer, cfgBuffer, input, identifier, identifier);\n \t}\n \n-\tpublic String addTraceFunction(final List<MCState> input, final String id) {\n-\t\treturn addTraceFunctionToBuffers(tlaBuffer, cfgBuffer, input, id);\n+\tpublic String addTraceFunction(final List<MCState> input, final String id, final String configId) {\n+\t\treturn addTraceFunctionToBuffers(tlaBuffer, cfgBuffer, input, id, configId);\n \t}\n \n \t/*\n@@ -980,56 +1042,49 @@ public String addTraceFunction(final List<MCState> input, final String id) {\n \t * TLA+ encoded trace function with a significantly more efficient binary\n \t * encoding to work around deficiencies in SANY and semantic processing.\n \t */\n-\tpublic String addTraceFunctionInstance() {\n-\t\t/*\n-\t\t * SpecTETraceDef == INSTANCE SpecTETraceDef\n-\t\t * _def_ov == SpecTETraceDef!def_ov\n+\tpublic void addTraceFunctionInstance(final String moduleName) {\n+\t\t/* With EWD840_TE as moduleName:\n+           _trace ==\n+               LET EWD840_TETrace == INSTANCE EWD840_TETrace\n+               IN EWD840_EWD840_TETrace!trace\n+\t\t   ----\n \t\t */\n-\t\ttlaBuffer.append(TLAConstants.COMMENT).append(TLAConstants.TraceExplore.ERROR_STATES_MODULE_NAME)\n-\t\t\t\t.append(\" definition\").append(TLAConstants.CR);\n-\t\tfinal String identifier = SpecWriterUtilities.getValidIdentifierNoTimestamp(TLAConstants.Schemes.DEFOV_SCHEME);\n-\t\ttlaBuffer.append(TLAConstants.TraceExplore.TRACE_EXPRESSION_MODULE_NAME + \"TraceDef == INSTANCE \"\n-\t\t\t\t+ TLAConstants.TraceExplore.TRACE_EXPRESSION_MODULE_NAME\n-\t\t\t\t+ TLAConstants.TraceExplore.ERROR_STATES_MODULE_NAME).append(TLAConstants.CR);\n-\t\ttlaBuffer.append(identifier).append(TLAConstants.DEFINES)\n-\t\t\t\t.append(TLAConstants.TraceExplore.TRACE_EXPRESSION_MODULE_NAME + \"TraceDef!\").append(identifier)\n-\t\t\t\t.append(TLAConstants.CR).append(TLAConstants.CR);\n-\t\treturn identifier;\n+\t\ttlaBuffer\n+\t\t\t\t.append(String.format(\"%s ==%s%sLET %s == INSTANCE %s%s%sIN %s!%s\",\n+\t\t\t\t\t\tTLAConstants.TraceExplore.SPEC_TETRACE_TRACE, TLAConstants.CR, TLAConstants.INDENT,\n+\t\t\t\t\t\tmoduleName, moduleName, TLAConstants.CR, TLAConstants.INDENT, moduleName,\n+\t\t\t\t\t\tTLAConstants.TraceExplore.SPEC_TETRACE_TRACE_DEF))\n+\t\t\t\t.append(TLAConstants.CR).append(TLAConstants.SEP).append(TLAConstants.CR);\n \t}\n \n \tpublic void addTraceExpressionInstance(final String moduleName) {\n \t\t/* With EWD840_TE as moduleName:\n-\t\t   \\* Trace Expression declaration\n-           TTraceExpression == \n-               LET EWD840_TE == INSTANCE EWD840_TE \n-               IN EWD840_TE!TraceExpression\n+           _expression ==\n+               LET EWD840_TEExpression == INSTANCE EWD840_TEExpression\n+               IN EWD840_EWD840_TEExpression!expression\n+\t\t   ----\n \t\t */\n-\t\ttlaBuffer.append(TLAConstants.COMMENT).append(TLAConstants.TraceExplore.EXPLORATION_MODULE_NAME)\n-\t\t\t\t.append(\" declaration\").append(TLAConstants.CR);\n \t\ttlaBuffer\n \t\t\t\t.append(String.format(\"%s ==%s%sLET %s == INSTANCE %s%s%sIN %s!%s\",\n \t\t\t\t\t\tTLAConstants.TraceExplore.SPEC_TE_TTRACE_EXPRESSION, TLAConstants.CR, TLAConstants.INDENT,\n \t\t\t\t\t\tmoduleName, moduleName, TLAConstants.CR, TLAConstants.INDENT, moduleName,\n \t\t\t\t\t\tTLAConstants.TraceExplore.SPEC_TE_TRACE_EXPRESSION))\n-\t\t\t\t.append(TLAConstants.CR).append(TLAConstants.CR);\n+\t\t\t\t.append(TLAConstants.CR).append(TLAConstants.SEP).append(TLAConstants.CR).append(TLAConstants.CR);\n \t}\n \n     /**\n      * Returns a string representing the formula describing the state.\n      * If the state has var1=expr1, var2 = expr2, and var3=expr3, then this returns:\n      * \n-     * var1=(\n-     * expr1\n-     * )/\\\n-     * var2=(\n-     * expr2\n-     * )/\\\n-     * var3=(\n-     * expr3\n-     * )\n-     * \n+     * var1 = (expr1)\n+     * /\\\n+     * var2 = (expr2)\n+\t * /\\\n+\t * var3 = (expr3)          \n      * \n      * The expressions expr1, expr2, and expr3 can take up multiple lines.\n+\t * \n+\t * The expressions are idented twice.\n      * \n      * This will return null if the state is stuttering or back to state.\n      * \n@@ -1046,16 +1101,16 @@ private static String getStateConjunction(final MCState state) {\n             final MCVariable[] vars = state.getVariables();\n \t\t\tfor (int i = 0; i < vars.length; i++) {\n \t\t\t\tfinal MCVariable var = vars[i];\n-\t\t\t\tformula.append(TLAConstants.INDENT).append(var.getName()).append(TLAConstants.EQ).append(TLAConstants.L_PAREN).append(TLAConstants.CR);\n-\t\t\t\tformula.append(TLAConstants.INDENT).append(var.getValueAsString()).append(TLAConstants.CR).append(TLAConstants.INDENT).append(TLAConstants.R_PAREN);\n+\t\t\t\tformula.append(var.getName()).append(TLAConstants.EQ).append(TLAConstants.L_PAREN);\n+\t\t\t\tformula.append(var.getValueAsString()).append(TLAConstants.R_PAREN);\n \n \t\t\t\t// append /\\ except for the last variable\n \t\t\t\tif (i != (vars.length - 1)) {\n-                    formula.append(TLAConstants.INDENT).append(TLAConstants.TLA_AND).append(TLAConstants.CR);\n+                    formula.append(TLAConstants.CR).append(TLAConstants.TLA_AND).append(TLAConstants.CR);\n                 }\n             }\n \n-            return formula.toString();\n+            return indentString(formula.toString(), 2);\n         }\n     }\n \n@@ -1074,7 +1129,7 @@ public String getComment() {\n \t/**\n \t * Indent n times a entire multiline string.\n \t */\n-\tprivate String identString(String s, int n) {\n+\tstatic public String indentString(String s, int n) {\n \t\tfinal String idnt = new String(new char[n]).replace(\"\\0\", TLAConstants.INDENT);\n \t\treturn idnt + String.join(TLAConstants.CR + idnt, s.split(TLAConstants.CR));\n \t}"
  },
  {
    "sha": "3053da9113c5d4cf54316eec596e1e0e48690267",
    "filename": "tlatools/org.lamport.tlatools/src/tlc2/output/SpecWriterUtilities.java",
    "status": "modified",
    "additions": 4,
    "deletions": 4,
    "changes": 8,
    "blob_url": "https://github.com/tlaplus/tlaplus/blob/50a8cc1a9aa5ea978e3e1b28da091529314631e7/tlatools/org.lamport.tlatools/src/tlc2/output/SpecWriterUtilities.java",
    "raw_url": "https://github.com/tlaplus/tlaplus/raw/50a8cc1a9aa5ea978e3e1b28da091529314631e7/tlatools/org.lamport.tlatools/src/tlc2/output/SpecWriterUtilities.java",
    "contents_url": "https://api.github.com/repos/tlaplus/tlaplus/contents/tlatools/org.lamport.tlatools/src/tlc2/output/SpecWriterUtilities.java?ref=50a8cc1a9aa5ea978e3e1b28da091529314631e7",
    "patch": "@@ -77,15 +77,15 @@ public static StringBuilder getGeneratedTimeStampCommentLine() {\n     \t\t\t\t\t\t  + TLAConstants.Schemes.PROP_SCHEME + \")_[0-9]{17,}\");\n \n     /**\n-     * Creates a new valid unqiue identifier from given scheme\n+     * Creates a new valid unqiue identifier with timestamp from given scheme.\n      * @param scheme a naming scheme, one of the {@link TLAConstants.Schemes} constants\n      * @return a valid identifier\n      */\n \tpublic static String getValidIdentifier(final String scheme) {\n \t\treturn String.format(\"%s_%s%s\", scheme, System.currentTimeMillis(), 1000 * COUNTER.incrementAndGet());\n-\t}\n-\t\n-\t/**\n+    }\n+    \n+    /**\n      * Creates a new valid unqiue identifier without timestamp from given scheme. \n      * This was created to not mess with {@link getValidIdentifier} which is used by other classes. \n      * @param scheme a naming scheme, one of the {@link TLAConstants.Schemes} constants"
  },
  {
    "sha": "c74902ccf752a0b735ddc392996b1e9a484da0ea",
    "filename": "tlatools/org.lamport.tlatools/src/util/TLAConstants.java",
    "status": "modified",
    "additions": 11,
    "deletions": 3,
    "changes": 14,
    "blob_url": "https://github.com/tlaplus/tlaplus/blob/50a8cc1a9aa5ea978e3e1b28da091529314631e7/tlatools/org.lamport.tlatools/src/util/TLAConstants.java",
    "raw_url": "https://github.com/tlaplus/tlaplus/raw/50a8cc1a9aa5ea978e3e1b28da091529314631e7/tlatools/org.lamport.tlatools/src/util/TLAConstants.java",
    "contents_url": "https://api.github.com/repos/tlaplus/tlaplus/contents/tlatools/org.lamport.tlatools/src/util/TLAConstants.java?ref=50a8cc1a9aa5ea978e3e1b28da091529314631e7",
    "patch": "@@ -34,6 +34,7 @@\n \t\n \tpublic final class KeyWords {\n \t\tpublic static final String ACTION_CONSTRAINT = \"ACTION_CONSTRAINT\";\n+\t\tpublic static final String ASSUME = \"ASSUME\";\n \t    public static final String CONSTANT = \"CONSTANT\";\n \t    public static final String CONSTANTS = CONSTANT + 'S';\n \t    public static final String EXTENDS = \"EXTENDS\";\n@@ -76,7 +77,7 @@\n \tpublic final class TraceExplore {\n \t    public static final String TRACE_EXPRESSION_MODULE_NAME = \"TTrace\";\n \t    public static final String ERROR_STATES_MODULE_NAME = \"TraceDef\";\n-\t    public static final String EXPLORATION_MODULE_NAME = \"TE\";\n+\t    public static final String EXPLORATION_MODULE_NAME = \"TEExpression\";\n \t\tpublic static final String ACTION = \"_TEAction\";\n \t\tpublic static final String POSITION = \"_TEPosition\";\n \t\tpublic static final String TRACE = \"_TETrace\";\n@@ -99,8 +100,15 @@\n \t     * The tuple of ordered sub-action names representing the trace states. \n \t     */\n \t    public static final String TRACE_EXPLORE_ACTION_CONSTRAINT = \"traceExploreActionConstraint\";\n-\t    public static final String SPEC_TE_TRACE_EXPRESSION = \"TraceExpression\";\n-\t    public static final String SPEC_TE_TTRACE_EXPRESSION = \"TTraceExpression\";\n+\t    public static final String SPEC_TE_TRACE_EXPRESSION = \"expression\";\n+\t    public static final String SPEC_TE_TTRACE_EXPRESSION = \"_expression\";\n+\t\tpublic static final String SPEC_TETRACE_TRACE_DEF = \"trace\";\n+\t\tpublic static final String SPEC_TETRACE_TRACE = \"_trace\";\n+\t\tpublic static final String SPEC_TETRACE_NAME = \"TETrace\";\n+\t\tpublic static final String SPEC_TECONSTANTS_NAME = \"TEConstants\";\n+\t\tpublic static final String SPEC_TE_INIT = \"_init\";\n+\t\tpublic static final String SPEC_TE_CONSTRAINT = \"_constraint\";\n+\t\tpublic static final String SPEC_TE_NEXT = \"_next\";\n \t}\n \n \t"
  }
]
