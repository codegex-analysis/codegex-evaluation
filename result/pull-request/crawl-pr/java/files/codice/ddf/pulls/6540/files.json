[
  {
    "sha": "166fdd95ff1da27480166a3951c210691594e581",
    "filename": "catalog/solr/catalog-solr-offline-gazetteer/pom.xml",
    "status": "added",
    "additions": 189,
    "deletions": 0,
    "changes": 189,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/pom.xml",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/pom.xml",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/catalog-solr-offline-gazetteer/pom.xml?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -0,0 +1,189 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * This is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either\n+ * version 3 of the License, or any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ *\n+ **/\n+\n+ -->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>ddf.catalog.solr</groupId>\n+        <artifactId>catalog-solr</artifactId>\n+        <version>2.19.20-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>catalog-solr-offline-gazetteer</artifactId>\n+    <version>2.19.20-SNAPSHOT</version>\n+    <packaging>bundle</packaging>\n+    <name>DDF :: Catalog :: Solr :: Offline Gazetteer</name>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>ddf.catalog.core</groupId>\n+            <artifactId>catalog-core-api</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>ddf.security.core</groupId>\n+            <artifactId>security-core-api</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>ddf.security</groupId>\n+            <artifactId>ddf-security-common</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>ddf.catalog.core</groupId>\n+            <artifactId>catalog-core-api-impl</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.codice.ddf.spatial</groupId>\n+            <artifactId>spatial-geocoding-api</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>ddf.platform.solr</groupId>\n+            <artifactId>solr-factory</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>ddf.platform.util</groupId>\n+            <artifactId>platform-util</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.solr</groupId>\n+            <artifactId>solr-solrj</artifactId>\n+            <version>${solr.version}</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.locationtech.jts</groupId>\n+            <artifactId>jts-core</artifactId>\n+            <version>${jts.spatial4j.version}</version>\n+        </dependency>\n+      <dependency>\n+        <groupId>org.locationtech.spatial4j</groupId>\n+        <artifactId>spatial4j</artifactId>\n+        <version>0.7</version>\n+      </dependency>\n+        <dependency>\n+            <groupId>org.apache.karaf.shell</groupId>\n+            <artifactId>org.apache.karaf.shell.console</artifactId>\n+            <version>${karaf.version}</version>\n+        </dependency>\n+      <dependency>\n+        <groupId>com.google.guava</groupId>\n+        <artifactId>guava</artifactId>\n+      </dependency>\n+      <dependency>\n+        <groupId>net.jodah</groupId>\n+        <artifactId>failsafe</artifactId>\n+        <version>${jodah-failsafe.version}</version>\n+      </dependency>\n+\n+      <!-- no-op slf4j impl so the tests expected exceptions don't puke to the logs -->\n+      <dependency>\n+        <groupId>org.slf4j</groupId>\n+        <artifactId>slf4j-nop</artifactId>\n+        <scope>test</scope>\n+      </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.felix</groupId>\n+                <artifactId>maven-bundle-plugin</artifactId>\n+                <extensions>true</extensions>\n+                <configuration>\n+                    <instructions>\n+                        <Bundle-SymbolicName>${project.artifactId}</Bundle-SymbolicName>\n+                        <Export-Package/>\n+                        <Embed-Dependency>\n+                            catalog-core-api-impl,\n+                            jts-core,\n+                            failsafe,\n+                            platform-util\n+                        </Embed-Dependency>\n+                        <Karaf-Commands>*</Karaf-Commands>\n+                        <Import-Package>\n+                            !javax.activation,\n+                            *\n+                        </Import-Package>\n+                    </instructions>\n+                </configuration>\n+            </plugin>\n+          <plugin>\n+            <groupId>org.apache.maven.plugins</groupId>\n+            <artifactId>maven-enforcer-plugin</artifactId>\n+            <executions>\n+              <execution>\n+                <id>check-artifact-size</id>\n+                <phase>verify</phase>\n+                <goals>\n+                  <goal>enforce</goal>\n+                </goals>\n+                <configuration>\n+                  <rules>\n+                    <ArtifactSizeEnforcerRule implementation=\"org.codice.maven.artifactsize.ArtifactSizeEnforcerRule\">\n+                      <maxArtifactSize>3_MB</maxArtifactSize>\n+                    </ArtifactSizeEnforcerRule>\n+                  </rules>\n+                </configuration>\n+              </execution>\n+            </executions>\n+          </plugin>\n+          <plugin>\n+            <groupId>org.jacoco</groupId>\n+            <artifactId>jacoco-maven-plugin</artifactId>\n+            <executions>\n+              <execution>\n+                <id>default-check</id>\n+                <goals>\n+                  <goal>check</goal>\n+                </goals>\n+                <configuration>\n+                  <haltOnFailure>true</haltOnFailure>\n+                  <rules>\n+                    <rule>\n+                      <element>BUNDLE</element>\n+\n+                      <limits>\n+                        <limit implementation=\"org.codice.jacoco.LenientLimit\">\n+                          <counter>INSTRUCTION</counter>\n+                          <value>COVEREDRATIO</value>\n+                          <minimum>0.88</minimum>\n+                        </limit>\n+                        <limit implementation=\"org.codice.jacoco.LenientLimit\">\n+                          <counter>BRANCH</counter>\n+                          <value>COVEREDRATIO</value>\n+                          <minimum>0.59</minimum>\n+                        </limit>\n+                        <limit implementation=\"org.codice.jacoco.LenientLimit\">\n+                          <counter>COMPLEXITY</counter>\n+                          <value>COVEREDRATIO</value>\n+                          <minimum>0.69</minimum>\n+                        </limit>\n+                      </limits>\n+                    </rule>\n+                  </rules>\n+                </configuration>\n+              </execution>\n+            </executions>\n+          </plugin>\n+        </plugins>\n+    </build>\n+\n+</project>\n\\ No newline at end of file"
  },
  {
    "sha": "88a4aa97323d75087731102bdb234cc056d67c43",
    "filename": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/BuildGazetteerSuggesterIndexCommand.java",
    "status": "added",
    "additions": 86,
    "deletions": 0,
    "changes": 86,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/BuildGazetteerSuggesterIndexCommand.java",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/BuildGazetteerSuggesterIndexCommand.java",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/BuildGazetteerSuggesterIndexCommand.java?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -0,0 +1,86 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.COLLECTION_NAME;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.GAZETTEER_REQUEST_HANDLER;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_BUILD_KEY;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT_KEY;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_Q_KEY;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.karaf.shell.api.action.Action;\n+import org.apache.karaf.shell.api.action.Command;\n+import org.apache.karaf.shell.api.action.lifecycle.Reference;\n+import org.apache.karaf.shell.api.action.lifecycle.Service;\n+import org.apache.karaf.shell.api.console.Session;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Service\n+@Command(\n+  scope = \"offline-solr-gazetteer\",\n+  name = \"build-suggester-index\",\n+  description = \"Sends a request to build the suggester index\"\n+)\n+public class BuildGazetteerSuggesterIndexCommand implements Action {\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(BuildGazetteerSuggesterIndexCommand.class);\n+\n+  @Reference protected Session session;\n+\n+  @Reference private SolrClientFactory clientFactory;\n+\n+  @Override\n+  public Object execute() throws Exception {\n+    SolrClient solrClient = clientFactory.newClient(COLLECTION_NAME);\n+\n+    Boolean response =\n+        Failsafe.with(\n+                new RetryPolicy()\n+                    .retryWhen(false)\n+                    .withMaxDuration(5, TimeUnit.SECONDS)\n+                    .withBackoff(25, 1_000, TimeUnit.MILLISECONDS))\n+            .get(() -> solrClient.isAvailable());\n+    if (response == null || !response) {\n+      LOGGER.error(\"Could not contact solr to build suggester index\");\n+      session.getConsole().println(\"Could not contact solr to build suggester index, exiting.\");\n+      return null;\n+    }\n+    SolrQuery query = new SolrQuery();\n+    query.setRequestHandler(GAZETTEER_REQUEST_HANDLER);\n+    query.setParam(SUGGEST_Q_KEY, \"CatalogSolrGazetteerBuildSuggester\");\n+    query.setParam(SUGGEST_BUILD_KEY, true);\n+    query.setParam(SUGGEST_DICT_KEY, SUGGEST_DICT);\n+\n+    try {\n+      solrClient.query(query);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.info(\"Error while trying to build suggester\", e);\n+      session.getConsole().println(\"Error while trying to build suggester.\");\n+      throw e;\n+    }\n+\n+    session.getConsole().println(\"Suggester built successfully.\");\n+    return null;\n+  }\n+}"
  },
  {
    "sha": "062e3f01b358c2099531df2e1010b5194edd800c",
    "filename": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/CatalogGazetteerForwardingPlugin.java",
    "status": "added",
    "additions": 237,
    "deletions": 0,
    "changes": 237,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/CatalogGazetteerForwardingPlugin.java",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/CatalogGazetteerForwardingPlugin.java",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/CatalogGazetteerForwardingPlugin.java?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -0,0 +1,237 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.Constants.SUGGESTION_BUILD_KEY;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.COLLECTION_NAME;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.COUNTRY_CODE;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.DESCRIPTION;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.FEATURE_CODE;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.GAZETTEER_METACARD_TAG;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.GAZETTEER_REQUEST_HANDLER;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.GAZETTEER_TO_CATALOG;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.ID;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.LOCATION;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.NAME;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.POPULATION;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SORT_VALUE;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_BUILD_KEY;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT_KEY;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_Q_KEY;\n+\n+import ddf.catalog.data.Attribute;\n+import ddf.catalog.data.Metacard;\n+import ddf.catalog.operation.CreateResponse;\n+import ddf.catalog.operation.DeleteResponse;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.Update;\n+import ddf.catalog.operation.UpdateResponse;\n+import ddf.catalog.plugin.PluginExecutionException;\n+import ddf.catalog.plugin.PostIngestPlugin;\n+import ddf.catalog.plugin.PreQueryPlugin;\n+import ddf.catalog.plugin.StopProcessingException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CatalogGazetteerForwardingPlugin implements PostIngestPlugin, PreQueryPlugin {\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(CatalogGazetteerForwardingPlugin.class);\n+\n+  private final SolrClient solrClient;\n+\n+  public CatalogGazetteerForwardingPlugin(SolrClientFactory clientFactory) {\n+    synchronized (clientFactory) {\n+      this.solrClient = clientFactory.newClient(COLLECTION_NAME);\n+      Boolean response =\n+          Failsafe.with(\n+                  new RetryPolicy()\n+                      .retryWhen(false)\n+                      .withMaxDuration(5, TimeUnit.SECONDS)\n+                      .withBackoff(25, 1_000, TimeUnit.MILLISECONDS))\n+              .get(() -> this.solrClient.isAvailable());\n+      if (response == null || !response) {\n+        LOGGER.error(\"Unable to get Solr client for collection: {}\", COLLECTION_NAME);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public CreateResponse process(CreateResponse input) throws PluginExecutionException {\n+    List<Metacard> gazetteerMetacards =\n+        input\n+            .getCreatedMetacards()\n+            .stream()\n+            .filter(this::isGazetteerMetacard)\n+            .collect(Collectors.toList());\n+\n+    if (gazetteerMetacards.isEmpty()) {\n+      LOGGER.trace(\"No created gazetteer metacards present.\");\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.add(\n+          gazetteerMetacards\n+              .stream()\n+              .map(CatalogGazetteerForwardingPlugin::convert)\n+              .collect(Collectors.toList()));\n+    } catch (SolrServerException | IOException e) {\n+      throw new PluginExecutionException(\"Error while processing gazetteer data\", e);\n+    }\n+\n+    return input;\n+  }\n+\n+  @Override\n+  public UpdateResponse process(UpdateResponse input) throws PluginExecutionException {\n+    List<Metacard> gazetteerMetacards =\n+        input\n+            .getUpdatedMetacards()\n+            .stream()\n+            .map(Update::getNewMetacard)\n+            .filter(this::isGazetteerMetacard)\n+            .collect(Collectors.toList());\n+\n+    if (gazetteerMetacards.isEmpty()) {\n+      LOGGER.trace(\"No updated gazetteer metacards present.\");\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.add(\n+          gazetteerMetacards\n+              .stream()\n+              .map(CatalogGazetteerForwardingPlugin::convert)\n+              .collect(Collectors.toList()));\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error while processing gazetteer data\", e);\n+      throw new PluginExecutionException(e);\n+    }\n+    return input;\n+  }\n+\n+  @Override\n+  public DeleteResponse process(DeleteResponse input) throws PluginExecutionException {\n+    List<String> ids =\n+        input\n+            .getDeletedMetacards()\n+            .stream()\n+            .filter(this::isGazetteerMetacard)\n+            .map(Metacard::getId)\n+            .collect(Collectors.toList());\n+\n+    if (ids.isEmpty()) {\n+      LOGGER.trace(\"No deleted gazetteer metacards present.\");\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.deleteById(ids);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error while processing gazetteer data\", e);\n+      throw new PluginExecutionException(e);\n+    }\n+\n+    return input;\n+  }\n+\n+  protected static SolrInputDocument convert(Metacard metacard) {\n+    SolrInputDocument solrDoc = new SolrInputDocument();\n+    Consumer<String> getAttrAndAdd =\n+        (attributeName) ->\n+            Optional.ofNullable(getStringAttribute(metacard, attributeName))\n+                .ifPresent(\n+                    attributeValue ->\n+                        solrDoc.addField(\n+                            GAZETTEER_TO_CATALOG.inverse().get(attributeName), attributeValue));\n+\n+    getAttrAndAdd.accept(GAZETTEER_TO_CATALOG.get(DESCRIPTION));\n+    getAttrAndAdd.accept(GAZETTEER_TO_CATALOG.get(FEATURE_CODE));\n+    getAttrAndAdd.accept(GAZETTEER_TO_CATALOG.get(NAME));\n+    getAttrAndAdd.accept(GAZETTEER_TO_CATALOG.get(ID));\n+    getAttrAndAdd.accept(GAZETTEER_TO_CATALOG.get(COUNTRY_CODE));\n+\n+    Optional.of(metacard)\n+        .map(m -> getStringAttribute(m, GAZETTEER_TO_CATALOG.get(LOCATION)))\n+        .ifPresent(v -> solrDoc.addField(LOCATION, v));\n+\n+    Optional.of(metacard)\n+        .map(m -> m.getAttribute(GAZETTEER_TO_CATALOG.get(POPULATION)))\n+        .map(Attribute::getValue)\n+        .filter(Long.class::isInstance)\n+        .map(Long.class::cast)\n+        .ifPresent(v -> solrDoc.addField(POPULATION, v));\n+\n+    Optional.of(metacard)\n+        .map(m -> m.getAttribute(GAZETTEER_TO_CATALOG.get(SORT_VALUE)))\n+        .map(Attribute::getValue)\n+        .filter(Integer.class::isInstance)\n+        .map(Integer.class::cast)\n+        .ifPresent(v -> solrDoc.addField(SORT_VALUE, v));\n+\n+    return solrDoc;\n+  }\n+\n+  @Nullable\n+  private static String getStringAttribute(Metacard metacard, String attributeName) {\n+    Attribute attribute = metacard.getAttribute(attributeName);\n+    if (attribute != null && attribute.getValue() instanceof String) {\n+      return (String) attribute.getValue();\n+    }\n+    return null;\n+  }\n+\n+  private boolean isGazetteerMetacard(Metacard metacard) {\n+    return Optional.of(metacard)\n+        .map(Metacard::getTags)\n+        .map(tags -> tags.contains(GAZETTEER_METACARD_TAG))\n+        .orElse(false);\n+  }\n+\n+  @Override\n+  public QueryRequest process(QueryRequest input)\n+      throws PluginExecutionException, StopProcessingException {\n+    Serializable build = input.getPropertyValue(SUGGESTION_BUILD_KEY);\n+    if (build instanceof Boolean && (Boolean) build) {\n+      SolrQuery query = new SolrQuery();\n+      query.setRequestHandler(GAZETTEER_REQUEST_HANDLER);\n+      query.setParam(SUGGEST_Q_KEY, \"SGOSBuildSuggester\");\n+      query.setParam(SUGGEST_BUILD_KEY, true);\n+      query.setParam(SUGGEST_DICT_KEY, SUGGEST_DICT);\n+      try {\n+        solrClient.query(query);\n+      } catch (SolrServerException | IOException e) {\n+        LOGGER.debug(\"Error while trying to build suggester\");\n+        throw new PluginExecutionException(e);\n+      }\n+    }\n+    return input;\n+  }\n+}"
  },
  {
    "sha": "bb31869752adc2f89d8ed1703835724879d1041a",
    "filename": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerConstants.java",
    "status": "added",
    "additions": 58,
    "deletions": 0,
    "changes": 58,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerConstants.java",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerConstants.java",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerConstants.java?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+\n+public class GazetteerConstants {\n+  /* Solr Requests */\n+  public static final String GAZETTEER_REQUEST_HANDLER = \"/gazetteer\";\n+  public static final String SUGGEST_Q_KEY = \"suggest.q\";\n+  public static final String SUGGEST_BUILD_KEY = \"suggest.build\";\n+  public static final String SUGGEST_DICT_KEY = \"suggest.dictionary\";\n+  public static final String SUGGEST_DICT = \"gazetteerSuggest\";\n+  public static final String SUGGEST_COUNT_KEY = \"suggest.count\";\n+\n+  /* Naming */\n+  public static final String GAZETTEER_METACARD_TAG = GeoCodingConstants.GAZETTEER_METACARD_TAG;\n+  public static final String COLLECTION_NAME = \"gazetteer\";\n+\n+  public static final String DESCRIPTION = \"description_txt\";\n+  public static final String FEATURE_CODE = \"feature-code_txt\";\n+  public static final String NAME = \"name_txt\";\n+  public static final String ID = \"id_txt\";\n+  public static final String COUNTRY_CODE = \"country-code_txt\";\n+  public static final String LOCATION = \"location_geo\";\n+  public static final String POPULATION = \"population_lng\";\n+  public static final String SORT_VALUE = \"sort-value_int\";\n+\n+  public static final BiMap<String, String> GAZETTEER_TO_CATALOG =\n+      new ImmutableBiMap.Builder<String, String>()\n+          .put(DESCRIPTION, Core.DESCRIPTION)\n+          .put(FEATURE_CODE, GeoEntryAttributes.FEATURE_CODE_ATTRIBUTE_NAME)\n+          .put(NAME, Core.TITLE)\n+          .put(ID, Core.ID)\n+          .put(COUNTRY_CODE, Location.COUNTRY_CODE)\n+          .put(LOCATION, Core.LOCATION)\n+          .put(POPULATION, GeoEntryAttributes.POPULATION_ATTRIBUTE_NAME)\n+          .put(SORT_VALUE, GeoEntryAttributes.GAZETTEER_SORT_VALUE)\n+          .build();\n+\n+  private GazetteerConstants() {}\n+}"
  },
  {
    "sha": "020e1d4a5a3e7b1abbca3f29f7d7b3ae0a288f54",
    "filename": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java",
    "status": "added",
    "additions": 446,
    "deletions": 0,
    "changes": 446,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -0,0 +1,446 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.COLLECTION_NAME;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.COUNTRY_CODE;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.FEATURE_CODE;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.GAZETTEER_REQUEST_HANDLER;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.ID;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.LOCATION;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.NAME;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.POPULATION;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SORT_VALUE;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_COUNT_KEY;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT_KEY;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_Q_KEY;\n+\n+import com.google.common.collect.ImmutableMap;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.locationtech.spatial4j.context.SpatialContext;\n+import org.locationtech.spatial4j.context.SpatialContextFactory;\n+import org.locationtech.spatial4j.context.jts.JtsSpatialContextFactory;\n+import org.locationtech.spatial4j.context.jts.ValidationRule;\n+import org.locationtech.spatial4j.exception.InvalidShapeException;\n+import org.locationtech.spatial4j.shape.Shape;\n+import org.locationtech.spatial4j.shape.jts.JtsGeometry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"%s:%s\", FEATURE_CODE, fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final int MAX_RESULTS = 100;\n+  private static final double KM_PER_DEGREE = 111.139;\n+\n+  private static final Map<String, String> SPATIAL_CONTEXT_ARGUMENTS =\n+      ImmutableMap.of(\n+          \"spatialContextFactory\",\n+          JtsSpatialContextFactory.class.getName(),\n+          \"validationRule\",\n+          ValidationRule.repairConvexHull.name());\n+\n+  private static final SpatialContext SPATIAL_CONTEXT =\n+      SpatialContextFactory.makeSpatialContext(SPATIAL_CONTEXT_ARGUMENTS, null);\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  private final SolrClient client;\n+\n+  public GazetteerQueryOfflineSolr(SolrClientFactory clientFactory) {\n+    synchronized (clientFactory) {\n+      this.client = clientFactory.newClient(COLLECTION_NAME);\n+      Boolean response =\n+          Failsafe.with(\n+                  new RetryPolicy()\n+                      .retryWhen(false)\n+                      .withMaxDuration(5, TimeUnit.SECONDS)\n+                      .withBackoff(25, 1_000, TimeUnit.MILLISECONDS))\n+              .get(() -> this.client.isAvailable());\n+      if (response == null || !response) {\n+        LOGGER.error(\"Unable to get Solr client for collection: {}\", COLLECTION_NAME);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"%s:\\\"%s\\\"\", NAME, ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"%s:\\\"%s\\\"\", ID, ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying by ID\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .findFirst()\n+        .orElseThrow(() -> new GeoEntryQueryException(\"Could not find id\"));\n+  }\n+\n+  @Override\n+  public List<Suggestion> getSuggestedNames(String queryString, int maxResults)\n+      throws GeoEntryQueryException {\n+    SolrQuery solrQuery = new SolrQuery();\n+    solrQuery.setRequestHandler(GAZETTEER_REQUEST_HANDLER);\n+    solrQuery.setParam(SUGGEST_Q_KEY, ClientUtils.escapeQueryChars(queryString));\n+    solrQuery.setParam(SUGGEST_DICT_KEY, SUGGEST_DICT);\n+    solrQuery.setParam(SUGGEST_COUNT_KEY, Integer.toString(Math.min(maxResults, MAX_RESULTS)));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return Optional.ofNullable(response)\n+        .map(QueryResponse::getSuggesterResponse)\n+        .map(SuggesterResponse::getSuggestions)\n+        .map(suggestionsPerDict -> suggestionsPerDict.get(SUGGEST_DICT))\n+        .orElse(Collections.emptyList())\n+        .stream()\n+        .map(suggestion -> new SuggestionImpl(suggestion.getPayload(), suggestion.getTerm()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  public static final class SuggestionImpl implements Suggestion {\n+    private final String id;\n+    private final String name;\n+\n+    public SuggestionImpl(String id, String name) {\n+      this.id = id;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public String getId() {\n+      return id;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+  }\n+\n+  @Override\n+  public List<NearbyLocation> getNearestCities(String location, int radiusInKm, int maxResults)\n+      throws ParseException, GeoEntryQueryException {\n+    Geometry geometry;\n+    try {\n+      geometry = WKT_READER_THREAD_LOCAL.get().read(location);\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      throw new GeoEntryQueryException(\"Could not parse location\");\n+    }\n+    final Geometry originalGeometry = geometry;\n+    Geometry bufferedGeo = originalGeometry.buffer(convertKilometerToDegree(radiusInKm), 14);\n+    String wkt = WKT_WRITER_THREAD_LOCAL.get().write(bufferedGeo);\n+\n+    String q =\n+        String.format(\n+            \"%s_index:\\\"Intersects( %s ) AND %s\\\"\",\n+            LOCATION, ClientUtils.escapeQueryChars(wkt), CITY_SOLR_QUERY);\n+\n+    SolrQuery solrQuery = new SolrQuery(q);\n+    solrQuery.setRows(Math.min(maxResults, MAX_RESULTS));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error executing query for nearest cities\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(result -> convert(result, originalGeometry))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private NearbyLocation convert(SolrDocument doc, Geometry originalLocation) {\n+    String location = getField(doc, LOCATION, String.class);\n+    String title =\n+        Optional.ofNullable(getField(doc, NAME, String.class))\n+            .filter(Objects::nonNull)\n+            .filter(s -> !s.isEmpty())\n+            .orElse(\"NO TITLE\");\n+\n+    String cardinalDirection = \"\";\n+    double distance = 0;\n+    try {\n+      Geometry geo = WKT_READER_THREAD_LOCAL.get().read(location);\n+      cardinalDirection =\n+          bearingToCardinalDirection(getBearing(originalLocation.getCentroid(), geo.getCentroid()));\n+      distance = convertDegreeToKilometer(originalLocation.distance(geo.getCentroid()));\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      LOGGER.debug(\"Could not parse location for item (object: {})\", doc.toString(), e);\n+    }\n+\n+    return new NearbyLocationImpl(title, cardinalDirection, distance);\n+  }\n+\n+  public static final class NearbyLocationImpl implements NearbyLocation {\n+    private final String name;\n+    private final String cardinalDirection;\n+    private final double distance;\n+\n+    public NearbyLocationImpl(String name, String cardinalDirection, double distance) {\n+      this.name = name;\n+      this.cardinalDirection = cardinalDirection;\n+      this.distance = distance;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+\n+    @Override\n+    public String getCardinalDirection() {\n+      return cardinalDirection;\n+    }\n+\n+    @Override\n+    public double getDistance() {\n+      return distance;\n+    }\n+  }\n+  /**\n+   * Calculates the bearing from the start point to the end point (i.e., the <em>initial bearing\n+   * </em>) in degrees.\n+   *\n+   * @param startPoint the point from which to start\n+   * @param endPoint the point at which to end\n+   * @return the bearing from {@code startPoint} to {@code endPoint}, in degrees\n+   */\n+  private static double getBearing(final Point startPoint, final Point endPoint) {\n+    final double lat1 = startPoint.getY();\n+    final double lon1 = startPoint.getX();\n+\n+    final double lat2 = endPoint.getY();\n+    final double lon2 = endPoint.getX();\n+\n+    final double lonDiffRads = Math.toRadians(lon2 - lon1);\n+    final double lat1Rads = Math.toRadians(lat1);\n+    final double lat2Rads = Math.toRadians(lat2);\n+    final double y = Math.sin(lonDiffRads) * Math.cos(lat2Rads);\n+    final double x =\n+        Math.cos(lat1Rads) * Math.sin(lat2Rads)\n+            - Math.sin(lat1Rads) * Math.cos(lat2Rads) * Math.cos(lonDiffRads);\n+\n+    return (Math.toDegrees(Math.atan2(y, x)) + 360) % 360;\n+  }\n+\n+  /**\n+   * Takes a bearing in degrees and returns the corresponding cardinal direction as a string.\n+   *\n+   * @param bearing the bearing, in degrees\n+   * @return the cardinal direction corresponding to {@code bearing} (N, NE, E, SE, S, SW, W, NW)\n+   */\n+  private static String bearingToCardinalDirection(final double bearing) {\n+    final String[] directions = {\"N\", \"NE\", \"E\", \"SE\", \"S\", \"SW\", \"W\", \"NW\", \"N\"};\n+    return directions[(int) Math.round(bearing / 45)];\n+  }\n+\n+  @Override\n+  public Optional<String> getCountryCode(String wktLocation, int radius)\n+      throws GeoEntryQueryException, ParseException {\n+    String wkt;\n+    try {\n+      Point center =\n+          WKT_READER_THREAD_LOCAL\n+              .get()\n+              .read(fixSelfIntersectingGeometry(wktLocation))\n+              .getCentroid();\n+      wkt = WKT_WRITER_THREAD_LOCAL.get().write(center.buffer(convertKilometerToDegree(radius)));\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      LOGGER.debug(\"Could not parse wkt: {}\", wktLocation, e);\n+      throw new GeoEntryQueryException(\"Could not parse wkt\", e);\n+    }\n+\n+    SolrQuery solrQuery =\n+        new SolrQuery(\n+            String.format(\n+                \"%s_index:\\\"Intersects( %s )\\\"\", LOCATION, ClientUtils.escapeQueryChars(wkt)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Could not query for country code ({})\", wktLocation, e);\n+      throw new GeoEntryQueryException(\"Error encountered when querying\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .findFirst()\n+        .map(doc -> getField(doc, COUNTRY_CODE, String.class));\n+  }\n+\n+  private String fixSelfIntersectingGeometry(String wkt) {\n+    try {\n+      Shape wktShape = SPATIAL_CONTEXT.getFormats().getWktReader().read(wkt);\n+      // All polygons will be an instance of JtsGeometry. If it is not a polygon we don't need\n+      // to do anything with it so just return the original wkt string.\n+      if (!(wktShape instanceof JtsGeometry)) {\n+        return wkt;\n+      }\n+      return SPATIAL_CONTEXT.getFormats().getWktWriter().toString(wktShape);\n+    } catch (IOException | java.text.ParseException | InvalidShapeException e) {\n+      LOGGER.info(\"Failed to fix or read WKT: {}\", wkt, e);\n+    }\n+    return wkt;\n+  }\n+\n+  private GeoEntry transformMetacardToGeoEntry(SolrDocument document) {\n+    GeoEntry.Builder geoEntryBuilder = new GeoEntry.Builder();\n+    String featureCode = getField(document, FEATURE_CODE, String.class);\n+\n+    if (StringUtils.isNotBlank(featureCode)) {\n+      geoEntryBuilder.featureCode(featureCode);\n+    }\n+\n+    String countryCode = getField(document, COUNTRY_CODE, String.class);\n+    if (StringUtils.isNotBlank(countryCode)) {\n+      geoEntryBuilder.countryCode(countryCode);\n+    }\n+\n+    String name = getField(document, NAME, String.class);\n+    if (StringUtils.isNotBlank(name)) {\n+      geoEntryBuilder.name(name);\n+    }\n+\n+    Long population = getField(document, POPULATION, Long.class);\n+    if (population != null) {\n+      geoEntryBuilder.population(population);\n+    }\n+\n+    Integer sortValue = getField(document, SORT_VALUE, Integer.class);\n+    if (sortValue != null) {\n+      geoEntryBuilder.gazetteerSort(sortValue);\n+    }\n+\n+    String location = getField(document, LOCATION, String.class);\n+    if (StringUtils.isNotBlank(location)) {\n+      try {\n+        Geometry geometry = WKT_READER_THREAD_LOCAL.get().read(location);\n+        Point coordinate = geometry.getCentroid();\n+        if (!coordinate.isEmpty()) {\n+          Double lat = coordinate.getY();\n+          Double lon = coordinate.getX();\n+          geoEntryBuilder.latitude(lat);\n+          geoEntryBuilder.longitude(lon);\n+        }\n+      } catch (org.locationtech.jts.io.ParseException e) {\n+        LOGGER.debug(\"GeoEntry metacard does not contain (readable) location attribute.\");\n+      }\n+    }\n+    LOGGER.trace(\"Original solr document: {}\", document);\n+    LOGGER.trace(\"GeoEntry Builder: {}\", geoEntryBuilder);\n+\n+    return geoEntryBuilder.build();\n+  }\n+\n+  private <T> T getField(SolrDocument document, String attribute, Class<T> clazz) {\n+    return Optional.of(document)\n+        .map(d -> d.get(attribute))\n+        .filter(List.class::isInstance)\n+        .map(l -> (List<Object>) l)\n+        .orElse(Collections.emptyList())\n+        .stream()\n+        .filter(clazz::isInstance)\n+        .map(clazz::cast)\n+        .findFirst()\n+        .orElse(null);\n+  }\n+\n+  private double convertKilometerToDegree(int distanceInKilometers) {\n+    return distanceInKilometers / KM_PER_DEGREE;\n+  }\n+\n+  private double convertDegreeToKilometer(double distanceInDegrees) {\n+    return distanceInDegrees * KM_PER_DEGREE;\n+  }\n+}"
  },
  {
    "sha": "f54fcc5afac9d45e6c5ddf439337f231fff1e678",
    "filename": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/RemoveAllOfflineSolrGazetteerCommand.java",
    "status": "added",
    "additions": 92,
    "deletions": 0,
    "changes": 92,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/RemoveAllOfflineSolrGazetteerCommand.java",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/RemoveAllOfflineSolrGazetteerCommand.java",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/RemoveAllOfflineSolrGazetteerCommand.java?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.COLLECTION_NAME;\n+\n+import java.util.concurrent.TimeUnit;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.karaf.shell.api.action.Action;\n+import org.apache.karaf.shell.api.action.Command;\n+import org.apache.karaf.shell.api.action.Option;\n+import org.apache.karaf.shell.api.action.lifecycle.Reference;\n+import org.apache.karaf.shell.api.action.lifecycle.Service;\n+import org.apache.karaf.shell.api.console.Session;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Service\n+@Command(\n+  scope = \"offline-solr-gazetteer\",\n+  name = \"removeall\",\n+  description = \"Deletes all items in the solr gazetteer collection\"\n+)\n+public class RemoveAllOfflineSolrGazetteerCommand implements Action {\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(RemoveAllOfflineSolrGazetteerCommand.class);\n+\n+  @Reference protected Session session;\n+\n+  @Reference private SolrClientFactory clientFactory;\n+\n+  @Option(\n+    name = \"--force\",\n+    aliases = {\"-f\"},\n+    description = \"Force the removal without a confirmation message.\"\n+  )\n+  boolean force = false;\n+\n+  @Override\n+  public Object execute() throws Exception {\n+    if (!force) {\n+      String answer =\n+          session\n+              .readLine(\n+                  \"Are you sure you want to remove all gazetteer entries inside of the solr gazetteer collection?(y/n)\",\n+                  ' ')\n+              .toLowerCase();\n+      if (!(\"y\".equals(answer) || \"yes\".equals(answer))) {\n+        session.getConsole().println(\"Aborting.\");\n+        return null;\n+      }\n+    }\n+\n+    SolrClient solrClient = clientFactory.newClient(COLLECTION_NAME);\n+\n+    Boolean response =\n+        Failsafe.with(\n+                new RetryPolicy()\n+                    .retryWhen(false)\n+                    .withMaxDuration(5, TimeUnit.SECONDS)\n+                    .withBackoff(25, 1_000, TimeUnit.MILLISECONDS))\n+            .get(() -> solrClient.isAvailable());\n+    if (response == null || !response) {\n+      LOGGER.error(\"Could not contact solr to remove all\");\n+      session.getConsole().println(\"Could not contact solr to remove all, exiting.\");\n+      return null;\n+    }\n+    try {\n+      solrClient.deleteByQuery(\"*:*\");\n+    } catch (Exception e) {\n+      LOGGER.info(\"Error while executing\", e);\n+      session.getConsole().println(\"Error while submitting remove all, exiting.\");\n+      throw e;\n+    }\n+    session.getConsole().println(\"Removeall submitted successfully.\");\n+    return null;\n+  }\n+}"
  },
  {
    "sha": "68c3041c8d3f7f3a3ad9063c915a2ee3ef2eab84",
    "filename": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/SyncCatalogCommand.java",
    "status": "added",
    "additions": 147,
    "deletions": 0,
    "changes": 147,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/SyncCatalogCommand.java",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/SyncCatalogCommand.java",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/SyncCatalogCommand.java?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.COLLECTION_NAME;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.GAZETTEER_METACARD_TAG;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import ddf.catalog.CatalogFramework;\n+import ddf.catalog.data.Result;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.filter.FilterBuilder;\n+import ddf.catalog.filter.impl.SortByImpl;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.impl.QueryImpl;\n+import ddf.catalog.operation.impl.QueryRequestImpl;\n+import ddf.catalog.util.impl.ResultIterable;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.karaf.shell.api.action.Action;\n+import org.apache.karaf.shell.api.action.Command;\n+import org.apache.karaf.shell.api.action.lifecycle.Reference;\n+import org.apache.karaf.shell.api.action.lifecycle.Service;\n+import org.apache.karaf.shell.api.console.Session;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.codice.ddf.security.common.Security;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.client.solrj.UnavailableSolrException;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.opengis.filter.sort.SortOrder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Service\n+@Command(\n+  scope = \"offline-solr-gazetteer\",\n+  name = \"synccatalog\",\n+  description = \"Syncs all catalog items to the solr gazetteer collection\"\n+)\n+public class SyncCatalogCommand implements Action {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SyncCatalogCommand.class);\n+  public static final int PARTITION_SIZE = 256;\n+\n+  @Reference private SolrClientFactory clientFactory;\n+\n+  @Reference private Session session;\n+\n+  @Reference private CatalogFramework catalogFramework;\n+  @Reference private FilterBuilder filterBuilder;\n+  @Reference private Security security;\n+\n+  private final RetryPolicy retryPolicy =\n+      new RetryPolicy()\n+          .retryOn(ImmutableList.of(UnavailableSolrException.class, SolrServerException.class))\n+          .withMaxDuration(5, TimeUnit.SECONDS)\n+          .withBackoff(50, 1_000, TimeUnit.MILLISECONDS);\n+\n+  @Override\n+  public Object execute() throws Exception {\n+    return security.runWithSubjectOrElevate(this::executeWithSubject);\n+  }\n+\n+  public Object executeWithSubject() throws Exception {\n+    SolrClient solrClient = clientFactory.newClient(COLLECTION_NAME);\n+\n+    Boolean response =\n+        Failsafe.with(\n+                new RetryPolicy()\n+                    .retryWhen(false)\n+                    .withMaxDuration(5, TimeUnit.SECONDS)\n+                    .withBackoff(50, 1_000, TimeUnit.MILLISECONDS))\n+            .get(() -> solrClient.isAvailable());\n+    if (response == null || !response) {\n+      LOGGER.error(\"Could not contact solr to remove all\");\n+      session.getConsole().println(\"Could not contact solr to remove all, exiting.\");\n+      return null;\n+    }\n+\n+    Iterable<Result> iterable =\n+        ResultIterable.resultIterable(catalogFramework, getGazetteerFilter());\n+\n+    session.getConsole().println(\"Starting sync...\");\n+    long counter = 0;\n+    Instant start = Instant.now();\n+\n+    for (List<Result> results : Iterables.partition(iterable, PARTITION_SIZE)) {\n+      if (Thread.interrupted()) {\n+        LOGGER.info(\"Catalog sync interrupted early, exiting\");\n+        session.getConsole().println(\"Catalog sync interrupted, exiting\");\n+        Thread.currentThread().interrupt();\n+        throw new InterruptedException();\n+      }\n+\n+      try {\n+        solrClient.add(\n+            results\n+                .stream()\n+                .map(Result::getMetacard)\n+                .map(CatalogGazetteerForwardingPlugin::convert)\n+                .collect(Collectors.toList()));\n+      } catch (SolrServerException | IOException e) {\n+        LOGGER.info(\"error during syncing while adding items to solr\", e);\n+        session.getConsole().printf(\"An error occured while syncing: %s\", e.getMessage());\n+        throw e;\n+      }\n+      counter += results.size();\n+    }\n+\n+    session\n+        .getConsole()\n+        .printf(\n+            \"%nComplete. Processed %d items in %s%n\",\n+            counter, Duration.between(start, Instant.now()).toString());\n+\n+    return null;\n+  }\n+\n+  public QueryRequest getGazetteerFilter() {\n+    return new QueryRequestImpl(\n+        new QueryImpl(\n+            filterBuilder.attribute(Core.METACARD_TAGS).like().text(GAZETTEER_METACARD_TAG),\n+            1,\n+            PARTITION_SIZE,\n+            new SortByImpl(Core.ID, SortOrder.ASCENDING),\n+            true,\n+            TimeUnit.MINUTES.toMillis(3)));\n+  }\n+}"
  },
  {
    "sha": "f817b135b9ecfb08de6a3a6aa29a475d0a7775dd",
    "filename": "catalog/solr/catalog-solr-offline-gazetteer/src/main/resources/OSGI-INF/blueprint/blueprint.xml",
    "status": "added",
    "additions": 36,
    "deletions": 0,
    "changes": 36,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/main/resources/OSGI-INF/blueprint/blueprint.xml",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/main/resources/OSGI-INF/blueprint/blueprint.xml",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/catalog-solr-offline-gazetteer/src/main/resources/OSGI-INF/blueprint/blueprint.xml?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -0,0 +1,36 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- /**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * This is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either\n+ * version 3 of the License, or any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ *\n+ **/ -->\n+<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\">\n+\n+  <reference id=\"solrFactory\" interface=\"org.codice.solr.factory.SolrClientFactory\"/>\n+\n+  <bean id=\"offlineGazetteerPlugin\"\n+    class=\"ddf.catalog.solr.offlinegazetteer.CatalogGazetteerForwardingPlugin\">\n+    <argument ref=\"solrFactory\"/>\n+  </bean>\n+  <service ref=\"offlineGazetteerPlugin\">\n+    <interfaces>\n+      <value>ddf.catalog.plugin.PostIngestPlugin</value>\n+      <value>ddf.catalog.plugin.PreQueryPlugin</value>\n+    </interfaces>\n+  </service>\n+\n+  <bean id=\"gazetteerQueryOfflineSolr\"\n+    class=\"ddf.catalog.solr.offlinegazetteer.GazetteerQueryOfflineSolr\">\n+    <argument ref=\"solrFactory\"/>\n+  </bean>\n+  <service ref=\"gazetteerQueryOfflineSolr\"\n+    interface=\"org.codice.ddf.spatial.geocoding.GeoEntryQueryable\" ranking=\"80\"/>\n+\n+\n+</blueprint>\n\\ No newline at end of file"
  },
  {
    "sha": "5b3e1c9baba059334a12956ac2442098031c4559",
    "filename": "catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/CatalogGazetteerForwardingPluginSpec.groovy",
    "status": "added",
    "additions": 359,
    "deletions": 0,
    "changes": 359,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/CatalogGazetteerForwardingPluginSpec.groovy",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/CatalogGazetteerForwardingPluginSpec.groovy",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/CatalogGazetteerForwardingPluginSpec.groovy?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -0,0 +1,359 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer\n+\n+\n+import ddf.catalog.Constants\n+import ddf.catalog.data.Metacard\n+import ddf.catalog.data.impl.AttributeImpl\n+import ddf.catalog.data.types.Core\n+import ddf.catalog.data.types.Location\n+import ddf.catalog.operation.CreateResponse\n+import ddf.catalog.operation.DeleteResponse\n+import ddf.catalog.operation.QueryRequest\n+import ddf.catalog.operation.Update\n+import ddf.catalog.operation.UpdateResponse\n+import ddf.catalog.plugin.PluginExecutionException\n+import org.apache.solr.client.solrj.SolrServerException\n+import org.apache.solr.common.SolrInputDocument\n+import org.apache.solr.common.params.SolrParams\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes\n+import org.codice.solr.client.solrj.SolrClient\n+import org.codice.solr.factory.SolrClientFactory\n+import spock.lang.Specification\n+\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.COLLECTION_NAME\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_BUILD_KEY\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT_KEY\n+\n+class CatalogGazetteerForwardingPluginSpec extends Specification {\n+    CatalogGazetteerForwardingPlugin testedPlugin\n+\n+    SolrClientFactory solrClientFactory\n+    SolrClient solrClient\n+\n+    static List<Metacard> resourceMetacards\n+    static List<Metacard> gazetteerMetacards\n+    static Metacard fullGazetteerMetacard\n+\n+    void setup() {\n+        solrClient = Mock(SolrClient) {\n+            isAvailable() >> true\n+        }\n+        solrClientFactory = Mock(SolrClientFactory) {\n+            newClient(COLLECTION_NAME) >> solrClient\n+        }\n+        testedPlugin = new CatalogGazetteerForwardingPlugin(solrClientFactory)\n+\n+        // testing data\n+        resourceMetacards = [\n+                Mock(Metacard) {\n+                    getTitle() >> \"resource metacard mock 1\"\n+                    getAttribute(Core.TITLE) >> new AttributeImpl(Core.TITLE,\n+                                                                  \"resource metacard mock 1\")\n+                    getTags() >> [\"resource\"]\n+                    getAttribute(Metacard.TAGS) >> new AttributeImpl(Metacard.TAGS, [\"resource\"])\n+                    getId() >> \"id1\"\n+                    getAttribute(Core.ID) >> new AttributeImpl(Core.ID, \"id1\")\n+                },\n+                Mock(Metacard) {\n+                    getTitle() >> \"resource metacard mock 2\"\n+                    getAttribute(Core.TITLE) >> new AttributeImpl(Core.TITLE,\n+                                                                  \"resource metacard mock 2\")\n+                    getTags() >> [\"resource\"]\n+                    getAttribute(Metacard.TAGS) >> new AttributeImpl(Metacard.TAGS, [\"resource\"])\n+                    getId() >> \"id2\"\n+                    getAttribute(Core.ID) >> new AttributeImpl(Core.ID, \"id2\")\n+                }]\n+\n+\n+        gazetteerMetacards = [\n+                fullGazetteerMetacard = Mock(Metacard) {\n+                    getTags() >> [\"gazetteer\"]\n+                    getAttribute(Metacard.TAGS) >> new AttributeImpl(Metacard.TAGS, [\"gazetteer\"])\n+                    getAttribute(Metacard.DESCRIPTION) >> new AttributeImpl(Metacard.DESCRIPTION,\n+                                                                            \"mock gazetteer metacard desc\")\n+                    getAttribute(GeoEntryAttributes.\n+                            FEATURE_CODE_ATTRIBUTE_NAME) >> new AttributeImpl(GeoEntryAttributes.\n+                            FEATURE_CODE_ATTRIBUTE_NAME, \"PPL\")\n+                    getTitle() >> \"gazetteer metacard mock 1\"\n+                    getAttribute(Core.TITLE) >> new AttributeImpl(Core.TITLE,\n+                                                                  \"gazetteer metacard mock 1\")\n+                    getId() >> \"id3\"\n+                    getAttribute(Core.ID) >> new AttributeImpl(Core.ID, \"id3\")\n+                    getAttribute(Location.COUNTRY_CODE) >> new AttributeImpl(Location.COUNTRY_CODE,\n+                                                                             \"FRA\")\n+                    getAttribute(Core.LOCATION) >> new AttributeImpl(Core.LOCATION,\n+                                                                     \"POINT (3.999 48.36502)\")\n+                    getAttribute(GeoEntryAttributes.POPULATION_ATTRIBUTE_NAME) >> new AttributeImpl(\n+                            GeoEntryAttributes.POPULATION_ATTRIBUTE_NAME,\n+                            2724)\n+                    getAttribute(GeoEntryAttributes.GAZETTEER_SORT_VALUE) >> new AttributeImpl(\n+                            GeoEntryAttributes.GAZETTEER_SORT_VALUE, 10)\n+                },\n+                Mock(Metacard) {\n+                    getTags() >> [\"gazetteer\"]\n+                    getAttribute(Metacard.TAGS) >> new AttributeImpl(Metacard.TAGS, [\"gazetteer\"])\n+                    getAttribute(Metacard.DESCRIPTION) >> new AttributeImpl(Metacard.DESCRIPTION,\n+                                                                            \"mock gazetteer metacard desc2\")\n+                    getAttribute(GeoEntryAttributes.\n+                            FEATURE_CODE_ATTRIBUTE_NAME) >> new AttributeImpl(Metacard.DESCRIPTION,\n+                                                                              \"PPL\")\n+                    getTitle() >> \"gazetteer metacard mock 2\"\n+                    getAttribute(Core.TITLE) >> new AttributeImpl(Metacard.DESCRIPTION,\n+                                                                  \"gazetteer metacard mock 2\")\n+                    getId() >> \"id4\"\n+                    getAttribute(Core.ID) >> new AttributeImpl(Metacard.DESCRIPTION, \"id4\")\n+                    getAttribute(Location.COUNTRY_CODE) >> new AttributeImpl(Metacard.DESCRIPTION,\n+                                                                             \"USA\")\n+                    getAttribute(Core.LOCATION) >> new AttributeImpl(Metacard.DESCRIPTION,\n+                                                                     \"POINT (-87.70058 34.27482)\")\n+                    getAttribute(GeoEntryAttributes.POPULATION_ATTRIBUTE_NAME) >> new AttributeImpl(\n+                            Metacard.DESCRIPTION,\n+                            1047)\n+                    getAttribute(GeoEntryAttributes.GAZETTEER_SORT_VALUE) >> null\n+                }]\n+    }\n+\n+    def \"Create processing no-ops when there are no gazetteer metacards\"() {\n+        setup:\n+        CreateResponse createResponse = Mock(CreateResponse) {\n+            getCreatedMetacards() >> resourceMetacards\n+        }\n+        when: \"called with no gazetteer metacards\"\n+        CreateResponse result = testedPlugin.process(createResponse)\n+\n+        then: \"solr client is not called and the input is immediately returned\"\n+        0 * solrClient.add(_)\n+    }\n+\n+    def \"Create processing sends only gazetteer metacards to solr\"() {\n+        setup:\n+        CreateResponse createResponse = Mock(CreateResponse) {\n+            getCreatedMetacards() >> resourceMetacards + gazetteerMetacards\n+        }\n+\n+        when:\n+        CreateResponse result = testedPlugin.process(createResponse)\n+\n+        then: \"solr receives 2 items with the correct number of attributes\"\n+        1 * solrClient.\n+                add({ it.size() == 2 && it.collect { it.keySet().size() }.containsAll([6, 7]) })\n+    }\n+\n+    // This is testing implementation specifics that could change -- meaning this is brittle but to\n+    // document how it handles validation (anything goes).\n+    def \"Create processing pulls needed fields from metacard\"() {\n+        setup: \"a metacard that manages to hit the plugin (has a gazetteer tag and an id) but nothing else\"\n+        CreateResponse createResponse =\n+                Mock(CreateResponse) {\n+                    getCreatedMetacards() >> [\n+                            Mock(Metacard) {\n+                                getTags() >> [\"gazetteer\"]\n+                                getAttribute(Metacard.\n+                                        TAGS) >> new AttributeImpl(Metacard.TAGS,\n+                                                                   [\"gazetteer\"])\n+                                getId() >> \"id3b\"\n+                                getAttribute(Core.ID) >> new AttributeImpl(Core.ID,\n+                                                                           \"id3b\")\n+                            }]\n+                }\n+\n+        when:\n+        CreateResponse result = testedPlugin.process(createResponse)\n+\n+        then:\n+        1 * solrClient.add(_) >>\n+                { Collection<SolrInputDocument> docs ->\n+                    assert docs.size() == 1\n+                }\n+    }\n+\n+    def \"Create processing throws plugin exception when solr client throws exception\"() {\n+        setup:\n+        CreateResponse createResponse = Mock(CreateResponse) {\n+            getCreatedMetacards() >> gazetteerMetacards\n+        }\n+\n+        when:\n+        1 * solrClient.add(_) >> { throw new SolrServerException(\"exception\") }\n+        CreateResponse result = testedPlugin.process(createResponse)\n+\n+        then:\n+        PluginExecutionException e = thrown()\n+    }\n+\n+    def \"Delete processing no-ops when no gazetteer metacards present\"() {\n+        setup:\n+        DeleteResponse deleteResponse = Mock(DeleteResponse) {\n+            getDeletedMetacards() >> resourceMetacards\n+        }\n+        when:\n+        DeleteResponse resp = testedPlugin.process(deleteResponse)\n+\n+        then:\n+        0 * solrClient./delete.*/(*_)\n+    }\n+\n+    def \"Delete processing deletes all gazetteer metacards\"() {\n+        setup:\n+        DeleteResponse deleteResponse = Mock(DeleteResponse) {\n+            getDeletedMetacards() >> resourceMetacards + gazetteerMetacards\n+        }\n+\n+        when:\n+        DeleteResponse resp = testedPlugin.process(deleteResponse)\n+\n+        then:\n+        1 * solrClient.deleteById([\"id3\", \"id4\"])\n+    }\n+\n+    def \"Delete processing throws plugin exception when solr client throws exception\"() {\n+        setup:\n+        DeleteResponse deleteResponse = Mock(DeleteResponse) {\n+            getDeletedMetacards() >> gazetteerMetacards\n+        }\n+\n+        when:\n+        1 * solrClient.deleteById(_) >> { throw new SolrServerException(\"exception\") }\n+        DeleteResponse result = testedPlugin.process(deleteResponse)\n+\n+        then:\n+        PluginExecutionException e = thrown()\n+    }\n+\n+    def \"Update no-ops when no gazetteer metacards are present\"() {\n+        setup:\n+        UpdateResponse updateResponse = Mock(UpdateResponse) {\n+            getUpdatedMetacards() >> resourceMetacards.collect { metacard ->\n+                Mock(Update) {\n+                    getNewMetacard() >> metacard\n+                }\n+            }\n+        }\n+\n+        when:\n+        UpdateResponse resp = testedPlugin.process(updateResponse)\n+\n+        then:\n+        0 * solrClient.add(_)\n+    }\n+\n+    def \"Update processes gazetteer metacards\"() {\n+        setup:\n+        UpdateResponse updateResponse = Mock(UpdateResponse) {\n+            getUpdatedMetacards() >> (resourceMetacards + gazetteerMetacards).collect { metacard ->\n+                Mock(Update) {\n+                    getNewMetacard() >> metacard\n+                }\n+            }\n+        }\n+\n+        when:\n+        UpdateResponse resp = testedPlugin.process(updateResponse)\n+\n+        then:\n+        1 * solrClient.add({ it.size() == 2 })\n+    }\n+\n+    def \"Update throws plugin exception when solr throws exception\"() {\n+        setup:\n+        UpdateResponse updateResponse = Mock(UpdateResponse) {\n+            getUpdatedMetacards() >> (resourceMetacards + gazetteerMetacards).collect { metacard ->\n+                Mock(Update) {\n+                    getNewMetacard() >> metacard\n+                }\n+            }\n+        }\n+\n+        when:\n+        1 * solrClient.add(*_) >> { throw new SolrServerException(\"exception\") }\n+        UpdateResponse resp = testedPlugin.process(updateResponse)\n+\n+        then:\n+        PluginExecutionException e = thrown()\n+    }\n+\n+    def \"Prequery plugin rebuilds dictionary when suggestion build key is present\"() {\n+        setup:\n+        QueryRequest queryRequest = Mock(QueryRequest) {\n+            getPropertyValue(Constants.SUGGESTION_BUILD_KEY) >> true\n+        }\n+\n+        when:\n+        QueryRequest response = testedPlugin.process(queryRequest)\n+\n+        then:\n+        1 * solrClient.query(*_) >> {\n+            args ->\n+                args.first().with { SolrParams it ->\n+                    assert it.get(SUGGEST_BUILD_KEY) == \"true\"\n+                    assert it.get(SUGGEST_DICT_KEY) == SUGGEST_DICT\n+                }\n+\n+        }\n+    }\n+\n+    def \"prequery plugin no-ops if no suggestion build key is present\"() {\n+        setup:\n+        QueryRequest queryRequest = Mock(QueryRequest)\n+\n+        when:\n+        QueryRequest response = testedPlugin.process(queryRequest)\n+\n+        then:\n+        0 * solrClient.query(*_)\n+    }\n+\n+    def \"Prequery plugin throws plugin exception when solr errors\"() {\n+        setup:\n+        QueryRequest queryRequest = Mock(QueryRequest) {\n+            getPropertyValue(Constants.SUGGESTION_BUILD_KEY) >> true\n+        }\n+\n+        when:\n+        1 * solrClient.query(*_) >> { throw new SolrServerException(\"exception\") }\n+        QueryRequest response = testedPlugin.process(queryRequest)\n+\n+        then:\n+        PluginExecutionException e = thrown()\n+    }\n+\n+    def \"All plugins are ephemeral and return the input (an identity transformation, with side effects)\"() {\n+        // Note this test leaves the equality semantics to the objects being tested.. we will\n+        // assume that they have sufficiently defined that already\n+        expect: \"the exact result as the input after processing\"\n+        parameter == testedPlugin.process(parameter)\n+\n+        where:\n+        parameter << [\n+                Mock(CreateResponse) {\n+                    getCreatedMetacards() >> gazetteerMetacards\n+                },\n+                Mock(UpdateResponse) {\n+                    getUpdatedMetacards() >> gazetteerMetacards.collect { metacard ->\n+                        Mock(Update) {\n+                            getNewMetacard() >> metacard\n+                        }\n+                    }\n+                },\n+                Mock(DeleteResponse) {\n+                    getDeletedMetacards() >> gazetteerMetacards\n+                },\n+                Mock(QueryRequest)\n+        ]\n+    }\n+\n+}"
  },
  {
    "sha": "68a054953d1ac1997e6310ecd7f482aee7feb306",
    "filename": "catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolrSpec.groovy",
    "status": "added",
    "additions": 385,
    "deletions": 0,
    "changes": 385,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolrSpec.groovy",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolrSpec.groovy",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolrSpec.groovy?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -0,0 +1,385 @@\n+package ddf.catalog.solr.offlinegazetteer\n+\n+\n+import org.apache.solr.client.solrj.SolrQuery\n+import org.apache.solr.client.solrj.SolrRequest\n+import org.apache.solr.client.solrj.SolrRequest.METHOD\n+import org.apache.solr.client.solrj.SolrServerException\n+import org.apache.solr.client.solrj.response.QueryResponse\n+import org.apache.solr.client.solrj.response.SuggesterResponse\n+import org.apache.solr.client.solrj.response.Suggestion\n+import org.apache.solr.common.SolrDocument\n+import org.apache.solr.common.SolrDocumentList\n+import org.codice.ddf.spatial.geocoding.GeoEntry\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation\n+import org.codice.solr.client.solrj.SolrClient\n+import org.codice.solr.factory.SolrClientFactory\n+import spock.lang.Specification\n+\n+import java.util.stream.Stream\n+\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.COUNTRY_CODE\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.FEATURE_CODE\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.GAZETTEER_REQUEST_HANDLER\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.LOCATION\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.NAME\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.POPULATION\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SORT_VALUE\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_COUNT_KEY\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT\n+\n+class GazetteerQueryOfflineSolrSpec extends Specification {\n+    GazetteerQueryOfflineSolr testedClass\n+    SolrClientFactory solrClientFactory\n+    SolrClient solrClient\n+\n+    void setup() {\n+        solrClient = Mock(SolrClient) {\n+            isAvailable() >> true\n+        }\n+        solrClientFactory = Mock(SolrClientFactory) {\n+            newClient(_) >> solrClient\n+        }\n+        testedClass = new GazetteerQueryOfflineSolr(solrClientFactory)\n+    }\n+\n+\n+    def \"Test normal query\"() {\n+        setup:\n+        int numResults = 10\n+        1 * solrClient.query({ SolrQuery it -> it.getRows() == numResults }, *_) >>\n+                Mock(QueryResponse) {\n+                    getResults() >> Mock(SolrDocumentList) {\n+                        stream() >> {\n+                            Stream.of(Mock(SolrDocument) {\n+                                get(NAME) >> [\"title\"]\n+                                get(POPULATION) >> [1337l]\n+                                get(LOCATION) >> [\"POINT (-98.86253 29.18968)\"]\n+                                get(FEATURE_CODE) >> [\"PPL\"]\n+                                get(COUNTRY_CODE) >> [\"USA\"]\n+                                get(SORT_VALUE) >> [42i]\n+                            })\n+                        }\n+                    }\n+                }\n+\n+        when:\n+        List<GeoEntry> results = testedClass.query(\"sample\", numResults)\n+\n+        then:\n+        results.size() == 1\n+        with(results.first()) {\n+            name == \"title\"\n+            population == 1337\n+            29.18 <= latitude && latitude <= 29.19\n+            -98.9 <= longitude && longitude <= -98.8\n+            featureCode == \"PPL\"\n+            countryCode == \"USA\"\n+        }\n+\n+    }\n+\n+    def \"Test query max results\"() {\n+        setup:\n+        int numResults = 101\n+        1 * solrClient.\n+                query(*_) >> {\n+            SolrQuery params, SolrRequest.METHOD method ->\n+                assert params.getRows() == GazetteerQueryOfflineSolr.MAX_RESULTS\n+                Mock(QueryResponse) {\n+                    getResults() >> Mock(SolrDocumentList) {\n+                        stream() >> { Stream.empty() }\n+                    }\n+                }\n+        }\n+\n+        when:\n+        List<GeoEntry> results = testedClass.query(\"sample\", numResults)\n+\n+        then:\n+        notThrown(Exception)\n+\n+    }\n+\n+    def \"Test invalid wkt \"() {\n+        setup:\n+        int numResults = 10\n+        1 * solrClient.query({ SolrQuery it -> it.getRows() == numResults }, *_) >>\n+                Mock(QueryResponse) {\n+                    getResults() >> Mock(SolrDocumentList) {\n+                        stream() >> {\n+                            Stream.of(Mock(SolrDocument) {\n+                                get(NAME) >> [\"title\"]\n+                                get(POPULATION) >> [1337l]\n+                                get(LOCATION) >> [\"POINT (!!!!!INVALIDWKT\"]\n+                            })\n+                        }\n+                    }\n+                }\n+\n+        when:\n+        List<GeoEntry> results = testedClass.query(\"sample\", numResults)\n+\n+        then:\n+        results.size() == 1\n+        with(results.first()) {\n+            name == \"title\"\n+            population == 1337\n+            latitude == null\n+            longitude == null\n+        }\n+\n+    }\n+\n+    def \"Test query solrclient exception\"() {\n+        setup:\n+        int numResults = 101\n+        1 * solrClient.query(*_) >> { throw new SolrServerException(\"solr exception\") }\n+\n+        when:\n+        List<GeoEntry> results = testedClass.query(\"sample\", numResults)\n+\n+        then:\n+        GeoEntryQueryException e = thrown()\n+    }\n+\n+    def \"test queryById normal\"() {\n+        setup:\n+        1 * solrClient.query(*_) >>\n+                Mock(QueryResponse) {\n+                    getResults() >> Mock(SolrDocumentList) {\n+                        stream() >> {\n+                            Stream.of(Mock(SolrDocument) {\n+                                get(NAME) >> [\"title\"]\n+                                get(POPULATION) >> [1337l]\n+                            })\n+                        }\n+                    }\n+                }\n+        when:\n+        GeoEntry result = testedClass.queryById(\"test\")\n+\n+        then:\n+        result.name == \"title\"\n+    }\n+\n+    def \"test queryById exception\"() {\n+        setup:\n+        1 * solrClient.query(*_) >> { throw new SolrServerException(\"solr exception\") }\n+        when:\n+        GeoEntry result = testedClass.queryById(\"test\")\n+\n+        then:\n+        GeoEntryQueryException e = thrown()\n+    }\n+\n+    def \"test getSuggestedNames normal\"() {\n+        setup:\n+        int maxResults = 10\n+        1 * solrClient.query(*_) >> { SolrQuery query ->\n+            assert query.get(SUGGEST_COUNT_KEY) == \"${maxResults}\"\n+            assert query.requestHandler == GAZETTEER_REQUEST_HANDLER\n+            Mock(QueryResponse) {\n+                getSuggesterResponse() >> Mock(SuggesterResponse) {\n+                    getSuggestions() >>\n+                            [(SUGGEST_DICT): [Mock(Suggestion) {\n+                                getPayload() >> \"id\"\n+                                getTerm() >> \"title\"\n+\n+                            }]]\n+                }\n+            }\n+        }\n+        when:\n+        List<Suggestion> results = testedClass.getSuggestedNames(\"place\", maxResults)\n+\n+        then:\n+        results.size() == 1\n+    }\n+\n+    def \"test getSuggestedNames maxResults\"() {\n+        setup: \"request asking for an absurdly large number of results\"\n+        int maxResults = 8675309\n+        1 * solrClient.query(*_) >> { SolrQuery query ->\n+            assert query.get(SUGGEST_COUNT_KEY) == \"${GazetteerQueryOfflineSolr.MAX_RESULTS}\"\n+            assert query.requestHandler == GAZETTEER_REQUEST_HANDLER\n+            Mock(QueryResponse) {\n+                getSuggesterResponse() >> Mock(SuggesterResponse) {\n+                    getSuggestions() >>\n+                            [(SUGGEST_DICT): [Mock(Suggestion) {\n+                                getPayload() >> \"id\"\n+                                getTerm() >> \"title\"\n+\n+                            }]]\n+                }\n+            }\n+        }\n+        when:\n+        List<Suggestion> results = testedClass.getSuggestedNames(\"place\", maxResults)\n+\n+        then:\n+        \"request goes through but the suggest.count was limited to $GazetteerQueryOfflineSolr.MAX_RESULTS\"\n+        results.size() == 1\n+    }\n+\n+    def \"test getSuggestedNames solrclient exception\"() {\n+        setup:\n+        int maxResults = 10\n+        1 * solrClient.query(*_) >> { throw new SolrServerException(\"exception\") }\n+\n+        when:\n+        List<Suggestion> results = testedClass.getSuggestedNames(\"place\", maxResults)\n+\n+        then:\n+        GeoEntryQueryException e = thrown()\n+    }\n+\n+    def \"getNearestCities\"() {\n+        setup:\n+        String locationWkt = \"POINT (-98.86253 29.18968)\"\n+        String pointAbout42kmAway = \"POINT (-98.496708 29.418376)\"\n+        int radiusInKm = 50\n+        int maxResults = 10\n+\n+        1 * solrClient.query(*_) >> { SolrQuery query, METHOD method ->\n+            assert METHOD.POST == method\n+            assert query.query == \"\"\"location_geo_index:\"Intersects( POLYGON\\\\ \\\\(\\\\(\\\\-98.41264292165667\\\\ 29.18968,\\\\ \\\\-98.41547171717704\\\\ 29.13930862896764,\\\\ \\\\-98.42392252999316\\\\ 29.089570707152163,\\\\ \\\\-98.4378890862306\\\\ 29.04109171777901,\\\\ \\\\-98.45719574834108\\\\ 28.99448131226772,\\\\ \\\\-98.4815997238466\\\\ 28.950325643511576,\\\\ \\\\-98.51079411859563\\\\ 28.909179994664907,\\\\ \\\\-98.54441179613524\\\\ 28.87156179613522,\\\\ \\\\-98.58202999466492\\\\ 28.83794411859562,\\\\ \\\\-98.62317564351159\\\\ 28.808749723846585,\\\\ \\\\-98.66733131226772\\\\ 28.784345748341078,\\\\ \\\\-98.71394171777902\\\\ 28.76503908623059,\\\\ \\\\-98.76242070715217\\\\ 28.75107252999315,\\\\ \\\\-98.81215862896765\\\\ 28.742621717177027,\\\\ \\\\-98.86253\\\\ 28.73979292165666,\\\\ \\\\-98.91290137103236\\\\ 28.742621717177027,\\\\ \\\\-98.96263929284784\\\\ 28.75107252999315,\\\\ \\\\-99.01111828222099\\\\ 28.76503908623059,\\\\ \\\\-99.0577286877323\\\\ 28.784345748341078,\\\\ \\\\-99.10188435648843\\\\ 28.808749723846585,\\\\ \\\\-99.14303000533509\\\\ 28.83794411859562,\\\\ \\\\-99.18064820386478\\\\ 28.87156179613522,\\\\ \\\\-99.21426588140439\\\\ 28.909179994664907,\\\\ \\\\-99.24346027615341\\\\ 28.950325643511576,\\\\ \\\\-99.26786425165893\\\\ 28.99448131226772,\\\\ \\\\-99.28717091376942\\\\ 29.04109171777901,\\\\ \\\\-99.30113747000685\\\\ 29.089570707152163,\\\\ \\\\-99.30958828282297\\\\ 29.13930862896764,\\\\ \\\\-99.31241707834334\\\\ 29.18968,\\\\ \\\\-99.30958828282297\\\\ 29.240051371032358,\\\\ \\\\-99.30113747000685\\\\ 29.289789292847836,\\\\ \\\\-99.28717091376942\\\\ 29.338268282220987,\\\\ \\\\-99.26786425165893\\\\ 29.38487868773228,\\\\ \\\\-99.24346027615341\\\\ 29.429034356488422,\\\\ \\\\-99.21426588140439\\\\ 29.47018000533509,\\\\ \\\\-99.18064820386478\\\\ 29.507798203864777,\\\\ \\\\-99.14303000533509\\\\ 29.54141588140438,\\\\ \\\\-99.10188435648843\\\\ 29.570610276153413,\\\\ \\\\-99.0577286877323\\\\ 29.59501425165892,\\\\ \\\\-99.01111828222099\\\\ 29.614320913769408,\\\\ \\\\-98.96263929284784\\\\ 29.62828747000685,\\\\ \\\\-98.91290137103236\\\\ 29.63673828282297,\\\\ \\\\-98.86253\\\\ 29.639567078343337,\\\\ \\\\-98.81215862896765\\\\ 29.63673828282297,\\\\ \\\\-98.76242070715217\\\\ 29.62828747000685,\\\\ \\\\-98.71394171777902\\\\ 29.614320913769408,\\\\ \\\\-98.66733131226772\\\\ 29.59501425165892,\\\\ \\\\-98.62317564351159\\\\ 29.570610276153413,\\\\ \\\\-98.58202999466492\\\\ 29.54141588140438,\\\\ \\\\-98.54441179613524\\\\ 29.507798203864777,\\\\ \\\\-98.51079411859563\\\\ 29.47018000533509,\\\\ \\\\-98.4815997238466\\\\ 29.429034356488422,\\\\ \\\\-98.45719574834108\\\\ 29.38487868773228,\\\\ \\\\-98.4378890862306\\\\ 29.338268282220987,\\\\ \\\\-98.42392252999316\\\\ 29.289789292847836,\\\\ \\\\-98.41547171717704\\\\ 29.240051371032358,\\\\ \\\\-98.41264292165667\\\\ 29.18968\\\\)\\\\) ) AND (feature-code_txt:PPL OR feature-code_txt:PPLA OR feature-code_txt:PPLA2 OR feature-code_txt:PPLA3 OR feature-code_txt:PPLA4 OR feature-code_txt:PPLC OR feature-code_txt:PPLCH OR feature-code_txt:PPLF OR feature-code_txt:PPLG OR feature-code_txt:PPLL OR feature-code_txt:PPLR OR feature-code_txt:PPLS OR feature-code_txt:PPLX)\\\"\"\"\"\n+\n+            return Mock(QueryResponse) {\n+                getResults() >> Mock(SolrDocumentList) {\n+                    stream() >> {\n+                        Stream.of(Mock(SolrDocument) {\n+                            get(NAME) >> [\"title\"]\n+                            get(LOCATION) >> [pointAbout42kmAway]\n+                        })\n+                    }\n+                }\n+            }\n+        }\n+\n+        when:\n+        List<NearbyLocation> results = testedClass.\n+                getNearestCities(locationWkt, radiusInKm, maxResults)\n+\n+        then:\n+        results.size() == 1\n+        with(results.first()) {\n+            cardinalDirection == \"NE\"\n+            40 <= it.distance && it.distance <= 50\n+            it.name == \"title\"\n+        }\n+    }\n+\n+    String extractIntersectsPolygon(String query) {\n+        String[] arr = query.split(\":\", 2)\n+        assert arr.length == 2\n+        List<String> queryNodes = Arrays.asList(\n+                arr[1].\n+                        replace(\"\\\"\", \"\").\n+                        split(\"AND|OR\"))\n+        String intersectsQuery = queryNodes.find { it.contains(\"Intersects\") }\n+        String WKTPolygon = intersectsQuery.\n+                replace(\"Intersects(\", \"\").\n+                trim()[0..-2].\n+                replace(\"\\\\\", \"\")\n+\n+        WKTPolygon\n+    }\n+\n+    def \"getNearestCities wkt parse exception\"() {\n+        when:\n+        testedClass.getNearestCities(\"POINT( !! INVALID WKT \", 50, 10)\n+\n+        then:\n+        GeoEntryQueryException e = thrown()\n+\n+    }\n+\n+    def \"getNearestCities solr query exception\"() {\n+        setup:\n+        1 * solrClient.query(*_) >> { SolrQuery query, METHOD method ->\n+            throw new SolrServerException(\"Exception\")\n+        }\n+        when:\n+        testedClass.getNearestCities(\"POINT (-98.86253 29.18968)\", 50, 10)\n+\n+        then:\n+        GeoEntryQueryException e = thrown()\n+\n+    }\n+\n+    def \"getCountryCode normal\"() {\n+        setup:\n+        1 * solrClient.query(*_) >> { SolrQuery query, METHOD method ->\n+            assert METHOD.POST == method\n+            assert query.rows == 1\n+\n+            Mock(QueryResponse) {\n+                getResults() >> Mock(SolrDocumentList) {\n+                    stream() >> {\n+                        Stream.of(Mock(SolrDocument) {\n+                            get(NAME) >> [\"title\"]\n+                            get(COUNTRY_CODE) >> [\"USA\"]\n+                        })\n+                    }\n+                }\n+            }\n+        }\n+\n+        when:\n+        Optional<String> result = testedClass.getCountryCode(\"POINT (-98.86253 29.18968)\", 50)\n+\n+        then:\n+        result.isPresent()\n+        result.get() == \"USA\"\n+\n+    }\n+\n+    def \"getCountryCode with exception\"() {\n+        setup:\n+        1 * solrClient.query(*_) >> { SolrQuery query, METHOD method ->\n+            throw new SolrServerException(\"exception\")\n+        }\n+\n+        when:\n+        Optional<String> result = testedClass.getCountryCode(\"POINT (-98.86253 29.18968)\", 50)\n+\n+        then:\n+        GeoEntryQueryException e = thrown()\n+\n+    }\n+\n+    def \"getCountryCode no results\"() {\n+        setup:\n+        1 * solrClient.query(*_) >> { SolrQuery query, METHOD method ->\n+            assert METHOD.POST == method\n+            assert query.rows == 1\n+\n+            Mock(QueryResponse) {\n+                getResults() >> Mock(SolrDocumentList) {\n+                    stream() >> {\n+                        Stream.empty()\n+                    }\n+                }\n+            }\n+        }\n+\n+        when:\n+        Optional<String> result = testedClass.getCountryCode(\"POINT (-98.86253 29.18968)\", 50)\n+\n+        then:\n+        !result.isPresent()\n+\n+    }\n+\n+    def \"getCountryCode invalid wkt\"() {\n+        when:\n+        Optional<String> result = testedClass.getCountryCode(\"POINT (!!INVALIDWKT !!\", 50)\n+\n+        then:\n+        GeoEntryQueryException e = thrown()\n+\n+    }\n+\n+}"
  },
  {
    "sha": "03fe135c7bb0c81c6e618aa95e39297cebd54da2",
    "filename": "catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/RemoveAllOfflineSolrGazetteerCommandSpec.groovy",
    "status": "added",
    "additions": 52,
    "deletions": 0,
    "changes": 52,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/RemoveAllOfflineSolrGazetteerCommandSpec.groovy",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/RemoveAllOfflineSolrGazetteerCommandSpec.groovy",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/RemoveAllOfflineSolrGazetteerCommandSpec.groovy?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -0,0 +1,52 @@\n+package ddf.catalog.solr.offlinegazetteer\n+\n+import ddf.catalog.solr.offlinegazetteer.RemoveAllOfflineSolrGazetteerCommand\n+import net.jodah.failsafe.FailsafeException\n+import org.apache.karaf.shell.api.console.Session\n+import org.apache.solr.client.solrj.SolrServerException\n+import org.codice.solr.client.solrj.SolrClient\n+import org.codice.solr.factory.SolrClientFactory\n+import spock.lang.Specification\n+\n+class RemoveAllOfflineSolrGazetteerCommandSpec extends Specification {\n+    RemoveAllOfflineSolrGazetteerCommand testedClass\n+    SolrClientFactory solrClientFactory\n+    SolrClient solrClient\n+    Session session\n+\n+    void setup() {\n+        solrClient = Mock(SolrClient) {\n+            isAvailable() >> true\n+        }\n+        solrClientFactory = Mock(SolrClientFactory) {\n+            newClient(_) >> solrClient\n+        }\n+        session = Mock(Session)\n+\n+        testedClass = new RemoveAllOfflineSolrGazetteerCommand()\n+        testedClass.clientFactory = solrClientFactory\n+        testedClass.session = session\n+        testedClass.force = true\n+        session.getConsole() >> new PrintStream(new ByteArrayOutputStream(128))\n+    }\n+\n+    def \"execute nominal\"() {\n+        when:\n+        testedClass.execute()\n+\n+        then:\n+        1 * solrClient.deleteByQuery(*_)\n+    }\n+\n+    def \"execute solr exception\"() {\n+        setup:\n+        1 * solrClient.deleteByQuery(*_) >> { throw new RuntimeException(\"exception\") }\n+\n+        when:\n+        testedClass.execute()\n+\n+        then:\n+        RuntimeException e = thrown()\n+    }\n+\n+}"
  },
  {
    "sha": "41176c7aa7c44969e80ec35bf4fd23a9936e1d28",
    "filename": "catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/SyncCatalogCommandSpec.groovy",
    "status": "added",
    "additions": 118,
    "deletions": 0,
    "changes": 118,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/SyncCatalogCommandSpec.groovy",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/SyncCatalogCommandSpec.groovy",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/catalog-solr-offline-gazetteer/src/test/groovy/ddf/catalog/solr/offlinegazetteer/SyncCatalogCommandSpec.groovy?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -0,0 +1,118 @@\n+package ddf.catalog.solr.offlinegazetteer\n+\n+import ddf.catalog.CatalogFramework\n+import ddf.catalog.data.Metacard\n+import ddf.catalog.data.Result\n+import ddf.catalog.filter.AttributeBuilder\n+import ddf.catalog.filter.ContextualExpressionBuilder\n+import ddf.catalog.filter.FilterBuilder\n+import ddf.catalog.operation.QueryRequest\n+import ddf.catalog.operation.QueryResponse\n+import ddf.catalog.solr.offlinegazetteer.SyncCatalogCommand\n+import ddf.catalog.source.SourceUnavailableException\n+import ddf.catalog.util.impl.CatalogQueryException\n+import org.apache.karaf.shell.api.console.Session\n+import org.apache.solr.client.solrj.SolrServerException\n+import org.codice.ddf.security.common.Security\n+import org.codice.solr.client.solrj.SolrClient\n+import org.codice.solr.factory.SolrClientFactory\n+import spock.lang.Specification\n+\n+class SyncCatalogCommandSpec extends Specification {\n+    SyncCatalogCommand testedClass\n+    SolrClientFactory solrClientFactory\n+    SolrClient solrClient\n+    Session session\n+    CatalogFramework catalogFramework\n+    FilterBuilder filterBuilder\n+    Security security\n+\n+    void setup() {\n+        solrClient = Mock(SolrClient) {\n+            isAvailable() >> true\n+        }\n+        solrClientFactory = Mock(SolrClientFactory) {\n+            newClient(_) >> solrClient\n+        }\n+\n+        session = Mock(Session)\n+        catalogFramework = Mock(CatalogFramework)\n+        filterBuilder = Mock(FilterBuilder)\n+        security = Mock(Security)\n+\n+        testedClass = new SyncCatalogCommand()\n+        testedClass.clientFactory = solrClientFactory\n+        testedClass.session = session\n+        testedClass.catalogFramework = catalogFramework\n+        testedClass.filterBuilder = filterBuilder\n+        testedClass.security = security\n+\n+        filterBuilder.attribute(_) >> Mock(AttributeBuilder) {\n+            like() >> Mock(ContextualExpressionBuilder) {\n+                text(_) >> Mock(org.opengis.filter.Filter)\n+            }\n+        }\n+\n+        session.getConsole() >> new PrintStream(new ByteArrayOutputStream(128))\n+    }\n+\n+    def \"executeWithSubject nominal\"() {\n+        setup:\n+        1 * catalogFramework.query(_ as QueryRequest) >> {\n+            Mock(QueryResponse) {\n+                getResults() >> [Mock(Result) {\n+                    getMetacard() >> Mock(Metacard) {\n+                        getId() >> \"id1\"\n+                    }\n+                }]\n+                getProperties() >> [\"actualResultSize\": 1]\n+                getHits() >> 1\n+            }\n+        }\n+\n+\n+        when:\n+        testedClass.executeWithSubject()\n+\n+        then:\n+        1 * solrClient.add(*_)\n+\n+    }\n+\n+    def \"executeWithSubject catalog framework exception\"() {\n+        setup:\n+        1 * catalogFramework.query(_ as QueryRequest) >>\n+                { throw new SourceUnavailableException(\"exception\") }\n+\n+        when:\n+        testedClass.executeWithSubject()\n+\n+        then:\n+        CatalogQueryException e = thrown()\n+\n+    }\n+\n+    def \"executeWithSubject solr exception \"() {\n+        setup:\n+        1 * catalogFramework.query(_ as QueryRequest) >> {\n+            Mock(QueryResponse) {\n+                getResults() >> [Mock(Result) {\n+                    getMetacard() >> Mock(Metacard) {\n+                        getId() >> \"id1\"\n+                    }\n+                }]\n+                getProperties() >> [\"actualResultSize\": 1]\n+                getHits() >> 1\n+            }\n+        }\n+        solrClient.add(*_) >> { throw new SolrServerException(\"exception\") }\n+\n+\n+        when:\n+        testedClass.executeWithSubject()\n+\n+        then:\n+        SolrServerException e = thrown()\n+\n+    }\n+}"
  },
  {
    "sha": "3e3a4f7314fd935ad8296f8fa0b849e7d4ed9f7c",
    "filename": "catalog/solr/pom.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/pom.xml",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/pom.xml",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/pom.xml?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -35,6 +35,7 @@\n     <modules>\n         <module>catalog-solr-provider</module>\n         <module>catalog-solr-solrclient</module>\n+        <module>catalog-solr-offline-gazetteer</module>\n         <module>solr-app</module>\n     </modules>\n </project>"
  },
  {
    "sha": "cfa3fc0ec04e168e03143cbb08e3880a01c34535",
    "filename": "catalog/solr/solr-app/pom.xml",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/solr-app/pom.xml",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/solr-app/pom.xml",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/solr-app/pom.xml?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -87,5 +87,10 @@\n             <artifactId>catalog-solr-solrclient</artifactId>\n             <version>${project.version}</version>\n         </dependency>\n+        <dependency>\n+            <groupId>ddf.catalog.solr</groupId>\n+            <artifactId>catalog-solr-offline-gazetteer</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n     </dependencies>\n </project>"
  },
  {
    "sha": "cbb7f4da49051c6dec2b078f707b921a923993a8",
    "filename": "catalog/solr/solr-app/src/main/resources/features.xml",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/solr-app/src/main/resources/features.xml",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/solr/solr-app/src/main/resources/features.xml",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/solr/solr-app/src/main/resources/features.xml?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -39,6 +39,13 @@\n         <bundle>mvn:ddf.catalog.solr/catalog-solr-solrclient/${project.version}</bundle>\n     </feature>\n \n+    <feature name=\"catalog-solr-offline-gazetteer\" version=\"${project.version}\" description=\"Offline gazetteer service utilizing a geonames index stored within a unique solr core (not within the catalog)\">\n+        <feature>solr-app</feature>\n+        <feature>catalog-app</feature>\n+        <feature>guava</feature>\n+        <bundle>mvn:ddf.catalog.solr/catalog-solr-offline-gazetteer/${project.version}</bundle>\n+    </feature>\n+\n     <feature name=\"solr-app\" version=\"${project.version}\"\n              description=\"The Solr Catalog Provider (SCP) is an implementation of the CatalogProvider interface using Apache Solr ${solr.version} as a data store.\\nThe SCP supports extensible metacards, fast/simple contextual searching, indexes xml attributes/CDATA sections/XML text elements, contains full XPath support, works with an embedded local Solr Server, and also works with a standalone Solr Server.\">\n         <feature>catalog-app</feature>"
  },
  {
    "sha": "7bf81ce50e2e22658769eadfc5fd2ee370086e65",
    "filename": "catalog/spatial/geocoding/spatial-geocoding-api/src/main/java/org/codice/ddf/spatial/geocoding/GeoEntry.java",
    "status": "modified",
    "additions": 64,
    "deletions": 0,
    "changes": 64,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/spatial/geocoding/spatial-geocoding-api/src/main/java/org/codice/ddf/spatial/geocoding/GeoEntry.java",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/catalog/spatial/geocoding/spatial-geocoding-api/src/main/java/org/codice/ddf/spatial/geocoding/GeoEntry.java",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/catalog/spatial/geocoding/spatial-geocoding-api/src/main/java/org/codice/ddf/spatial/geocoding/GeoEntry.java?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -122,6 +122,38 @@ public Builder importLocation(final String importLocation) {\n     public GeoEntry build() {\n       return new GeoEntry(this);\n     }\n+\n+    @Override\n+    public String toString() {\n+      return \"Builder{\"\n+          + \"name='\"\n+          + name\n+          + '\\''\n+          + \", latitude=\"\n+          + latitude\n+          + \", longitude=\"\n+          + longitude\n+          + \", featureCode='\"\n+          + featureCode\n+          + '\\''\n+          + \", population=\"\n+          + population\n+          + \", alternateNames='\"\n+          + alternateNames\n+          + '\\''\n+          + \", countryCode='\"\n+          + countryCode\n+          + '\\''\n+          + \", importLocation='\"\n+          + importLocation\n+          + '\\''\n+          + \", gazetteerSort=\"\n+          + gazetteerSort\n+          + \", featureClass='\"\n+          + featureClass\n+          + '\\''\n+          + '}';\n+    }\n   }\n \n   public String getName() {\n@@ -159,4 +191,36 @@ public String getImportLocation() {\n   public String getFeatureClass() {\n     return featureClass;\n   }\n+\n+  @Override\n+  public String toString() {\n+    return \"GeoEntry{\"\n+        + \"name='\"\n+        + name\n+        + '\\''\n+        + \", latitude=\"\n+        + latitude\n+        + \", longitude=\"\n+        + longitude\n+        + \", featureCode='\"\n+        + featureCode\n+        + '\\''\n+        + \", population=\"\n+        + population\n+        + \", alternateNames='\"\n+        + alternateNames\n+        + '\\''\n+        + \", countryCode='\"\n+        + countryCode\n+        + '\\''\n+        + \", importLocation='\"\n+        + importLocation\n+        + '\\''\n+        + \", gazetteerSort=\"\n+        + gazetteerSort\n+        + \", featureClass='\"\n+        + featureClass\n+        + '\\''\n+        + '}';\n+  }\n }"
  },
  {
    "sha": "b314e3bd29199b0d0f1418af1ac00b533195248e",
    "filename": "distribution/docs/src/main/resources/content/_reference/_appReferences/mg-spatial.adoc",
    "status": "modified",
    "additions": 41,
    "deletions": 0,
    "changes": 41,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/distribution/docs/src/main/resources/content/_reference/_appReferences/mg-spatial.adoc",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/distribution/docs/src/main/resources/content/_reference/_appReferences/mg-spatial.adoc",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/distribution/docs/src/main/resources/content/_reference/_appReferences/mg-spatial.adoc?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -47,6 +47,47 @@ index again.\n \n |===\n \n+=== Standalone Solr Offline Gazetteer Feature\n+\n+The Standalone Solr Offline Gazetteer is a reflection of the gazetteer data stored\n+in the catalog but separated from other data. This allows the suggester to be separately rebuilt\n+much quicker than for the entire catalog collection.\n+\n+\n+\n+====  Installing Standalone Solr Offline Gazetteer\n+\n+The Standalone Solr Offline Gazetteer is not installed by default but can be installed by running\n+`feature:install catalog-solr-offline-gazetteer`. This will install:\n+\n+* The plugin that intercepts gazetteer metacard creates/updates/deletes to the catalog collection\n+(and stores them in the standalone solr gazetteer collection)\n+* The gazetteer query service which registers the Query component that responds to requests from\n+the UI gazetteer search box\n+* The `offline-solr-gazetteer:removeall` command which will delete all records in the gazetteer\n+collection.\n+* The `offline-solr-gazetteer:synccatalog` command which will sync with the catalog and update all\n+records in the gazetteer collection to reflect it (or add them if they are not yet\n+created)\n+\n+==== Special Note Regarding Installation\n+\n+If the Spatial Geocoding Offline Catalog bundle and the bundle using the Gazetteer query service\n+(for example, Intrigue) are both already running, you will need to restart the bundles consuming the service\n+(for example, Intrigue) in order to pick up the correct one.\n+\n+==== Building the suggester index on Standalone Solr Offline Gazetteer\n+\n+The suggester index will be built when any of the other methods of building the catalog gazetteer\n+are run, along with on initial install. So you can run `gazetteer:build-suggester-index` or\n+`offline-solr-gazetteer:build-suggester-index` to build the suggester.\n+\n+Another option is to send a build request via a solr client. An example of this is done through\n+the Solr Dashboard after selecting the `gazetteer` collection and clicking `query`.\n+Ensure that the Request-Handler (qt) is set to `/suggest` and then in the 'Extra Parameters' field\n+add `suggest.build=true&suggest.dictionary=suggestPlace&suggest.q=bla`.\n+\n+\n ===  ${ddf-spatial} Prerequisites\n \n To use the ${ddf-spatial} Application, the following apps/features must be installed:"
  },
  {
    "sha": "da9cd4189785df132f6ee49accc48a9b9f0e4f27",
    "filename": "platform/solr/solr-schema/src/main/resources/solr/conf/solrconfig.xml",
    "status": "modified",
    "additions": 27,
    "deletions": 0,
    "changes": 27,
    "blob_url": "https://github.com/codice/ddf/blob/8590c59eb796f8c836fce361a613b7f49a00157d/platform/solr/solr-schema/src/main/resources/solr/conf/solrconfig.xml",
    "raw_url": "https://github.com/codice/ddf/raw/8590c59eb796f8c836fce361a613b7f49a00157d/platform/solr/solr-schema/src/main/resources/solr/conf/solrconfig.xml",
    "contents_url": "https://api.github.com/repos/codice/ddf/contents/platform/solr/solr-schema/src/main/resources/solr/conf/solrconfig.xml?ref=8590c59eb796f8c836fce361a613b7f49a00157d",
    "patch": "@@ -1290,6 +1290,7 @@\n       <str name=\"sortField\">ext.population_lng</str>\n       <str name=\"payloadField\">id_txt</str>\n       <str name=\"buildOnStartup\">false</str>\n+      <str name=\"highlight\">false</str>\n     </lst>\n   </searchComponent>\n \n@@ -1305,4 +1306,30 @@\n \n   <queryParser name=\"xpath\" class=\"org.codice.solr.xpath.XpathQParserPlugin\"/>\n \n+  <searchComponent name=\"gazetteer\" class=\"solr.SuggestComponent\">\n+    <lst name=\"suggester\">\n+      <str name=\"name\">gazetteerSuggest</str>\n+      <str name=\"lookupImpl\">BlendedInfixLookupFactory</str>\n+      <str name=\"indexPath\">gazetteer_index</str>\n+      <str name=\"dictionaryImpl\">DocumentDictionaryFactory</str>\n+      <str name=\"suggestAnalyzerFieldType\">lowercase</str>\n+      <str name=\"field\">name_txt</str>\n+      <str name=\"weightField\">sort-value_int</str>\n+      <str name=\"sortField\">population_lng</str>\n+      <str name=\"payloadField\">id_txt</str>\n+      <str name=\"buildOnStartup\">false</str>\n+      <str name=\"highlight\">false</str>\n+    </lst>\n+  </searchComponent>\n+\n+  <requestHandler name=\"/gazetteer\" class=\"solr.SearchHandler\" startup=\"lazy\">\n+    <lst name=\"defaults\">\n+      <str name=\"suggest\">true</str>\n+      <str name=\"suggest.count\">50</str>\n+    </lst>\n+    <arr name=\"components\">\n+      <str>gazetteer</str>\n+    </arr>\n+  </requestHandler>\n+\n </config>"
  }
]
