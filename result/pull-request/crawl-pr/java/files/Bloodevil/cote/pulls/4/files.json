[
  {
    "sha": "f67cf8d140f0500e4b6d50d18a9c645c1c68c03c",
    "filename": "heejeong/BinaryTree0310.java",
    "status": "added",
    "additions": 90,
    "deletions": 0,
    "changes": 90,
    "blob_url": "https://github.com/Bloodevil/cote/blob/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/BinaryTree0310.java",
    "raw_url": "https://github.com/Bloodevil/cote/raw/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/BinaryTree0310.java",
    "contents_url": "https://api.github.com/repos/Bloodevil/cote/contents/heejeong/BinaryTree0310.java?ref=660f6d8d6d514c03a791b9977c1beaed600cc3e8",
    "patch": "@@ -0,0 +1,90 @@\n+package heejeong;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Stack;\n+\n+//Given the root of a binary tree,\n+//return the inorder traversal of its nodes' values.\n+\n+//The number of nodes in the tree is in the range [0, 100].\n+//-100 <= Node.val <= 100\n+\n+//Recursive solution is trivial, could you do it iteratively?\n+\n+//inorder travesal(중위순회) : 왼 - 자기자신 - 오\n+\n+public class BinaryTree0310 {\n+\n+\t //Definition for a binary tree node.\n+\t public class TreeNode {\n+\t     int val;\n+\t     TreeNode left;\n+\t     TreeNode right;\n+\t     TreeNode() {}\n+\t     TreeNode(int val) { this.val = val; }\n+\t     TreeNode(int val, TreeNode left, TreeNode right) {\n+\t         this.val = val;\n+\t         this.left = left;\n+\t         this.right = right;\n+\t     }\n+\t }\n+\n+\t // 탐색\n+\tpublic void searchTree(TreeNode root, List<Integer> list ){\n+\t\tif(root != null){\n+\t\t\tif(root.left != null){\n+\t\t\t\tsearchTree(root.left, list);\n+\t\t\t}\n+\t\t\tlist.add(root.val);\n+\t\t\tif(root.right != null) searchTree(root.right, list);\n+\t\t}\n+\t}\n+\n+\tpublic List<Integer> inorderTraversal(TreeNode root) {\n+\t\t\tList<Integer> list = new ArrayList<Integer> ();\n+\t\t\tsearchTree(root, list);\n+\t\t\treturn list;\n+\t}\n+\n+\t// 스택 활용\n+\tpublic List<Integer> inorderTraversal2(TreeNode root) {\n+\t\t\tList<Integer> list = new ArrayList<Integer> ();\n+\t\t\tStack<TreeNode> stack = new Stack <TreeNode> ();\n+\t\t\tTreeNode curr = root;\n+\t\t\twhile(curr!=null || !stack.isEmpty()){\n+\t\t\t\twhile(curr!=null){\n+\t\t\t\t\tstack.push(curr);\n+\t\t\t\t\tcurr = curr.left;\n+\t\t\t\t}\n+\t\t\t\tcurr = stack.pop();\n+\t\t\t\tlist.add(curr.val);\n+\t\t\t\tcurr = curr.right;\n+\t\t\t}\n+\t\t\treturn list;\n+\t}\n+\n+\t// 또 다른 방법\n+\tpublic List<Integer> inorderTraversal3(TreeNode root) {\n+\t\tList<Integer> list = new ArrayList<Integer>();\n+\t\tTreeNode curr = root;\n+\t\tTreeNode pre;\n+\t\twhile(curr!=null){\n+\t\t\tif(curr.left == null){\n+\t\t\t\tlist.add(curr.val);\n+\t\t\t\tcurr = curr.right;\t//move to next right node\n+\t\t\t} else {\t//has a left subtree\n+\t\t\t\tpre = curr.left;\n+\t\t\t\twhile(pre.right!=null){\t//find rightmost\n+\t\t\t\t\tpre = pre.right;\n+\t\t\t\t}\n+\t\t\t\tpre.right = curr;\t//put cur after the pre node\n+\t\t\t\tTreeNode temp = curr;\t//store cur node\n+\t\t\t\tcurr = curr.left;\t//move cur to the top of the new tree\n+\t\t\t\ttemp.left = null;\t//original cur left be null to aviod infinite loops\n+\t\t\t}\n+\t\t}//while\n+\t\treturn list;\n+\t}\n+\n+}"
  },
  {
    "sha": "ca3e032aee3a3e1fff85c2f9cb7c3b630b14b893",
    "filename": "heejeong/Cookies.java",
    "status": "added",
    "additions": 28,
    "deletions": 0,
    "changes": 28,
    "blob_url": "https://github.com/Bloodevil/cote/blob/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/Cookies.java",
    "raw_url": "https://github.com/Bloodevil/cote/raw/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/Cookies.java",
    "contents_url": "https://api.github.com/repos/Bloodevil/cote/contents/heejeong/Cookies.java?ref=660f6d8d6d514c03a791b9977c1beaed600cc3e8",
    "patch": "@@ -0,0 +1,28 @@\n+package heejeong;//Greed Algorithm\n+//455. Assign Cookies\n+import java.util.Arrays;\n+\n+class Cookies {\n+  public static void main(String[] args) {\n+    int[] g = {1,2};\n+    int[] s = {1,2,3};\n+    System.out.println(findContentChildren(g,s));\n+  }\n+  public static int findContentChildren(int[] g, int[] s) {\n+    Arrays.sort(g);\n+    Arrays.sort(s);\n+\n+    int child = 0;\n+    int cookie = 0;\n+\n+    while(child<g.length && cookie<s.length){\n+      if(s[cookie] >= g[child]){\n+        child++;\n+        cookie++;\n+      }else{\n+        cookie++;\n+      }\n+    }\n+    return child;\n+  }\n+}"
  },
  {
    "sha": "3a1dfe3748dfbb58d8f13e1a92a1916f1898be00",
    "filename": "heejeong/DivisorGame1025.java",
    "status": "added",
    "additions": 34,
    "deletions": 0,
    "changes": 34,
    "blob_url": "https://github.com/Bloodevil/cote/blob/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/DivisorGame1025.java",
    "raw_url": "https://github.com/Bloodevil/cote/raw/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/DivisorGame1025.java",
    "contents_url": "https://api.github.com/repos/Bloodevil/cote/contents/heejeong/DivisorGame1025.java?ref=660f6d8d6d514c03a791b9977c1beaed600cc3e8",
    "patch": "@@ -0,0 +1,34 @@\n+package heejeong;\n+\n+public class DivisorGame1025 {\n+\tpublic static void main(String[] args) {\n+\t\tSystem.out.println(divisorGame(3));\n+\t}\n+\n+    public static boolean divisorGame(int N) {\n+    \tboolean win = false;\n+    \tint count = 0;\n+\n+    \t//매번 배열로 만들어야 하나 ?\n+    \tint [] x = new int [N-1];\n+\n+    \t//x는 1부터 N-1까지의 정수집합\n+\t\tfor(int i=0;i<N-1;i++) {\n+\t\t\tx[i] = 1+i;\n+\t\t\tSystem.out.println(\"x[i]=\"+x[i]);\n+\t\t\tif(N%x[i]==0) {\t//중 나눠서 0이되는 수 : 즉 N의 약수\n+\t\t\t\tcount++;\n+\t\t\t}\n+\t\t}\n+\n+    \t//x값은 N의 약수 중 N을 제외 한 N의 약수\n+\n+    \t// 만족하는 전체 x의 개수가 홀수일때 Alice 승리\n+    \t// 한번 더 돌때 의 경우를 생각하지 못했음\n+    \tif(count%2==1) {\n+    \t\twin=true;\n+    \t}\n+\n+    \treturn win;\n+    }\n+}"
  },
  {
    "sha": "82f3426f5863580145204d8d0aa46ea955521c78",
    "filename": "heejeong/FibonacciNum509.java",
    "status": "added",
    "additions": 86,
    "deletions": 0,
    "changes": 86,
    "blob_url": "https://github.com/Bloodevil/cote/blob/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/FibonacciNum509.java",
    "raw_url": "https://github.com/Bloodevil/cote/raw/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/FibonacciNum509.java",
    "contents_url": "https://api.github.com/repos/Bloodevil/cote/contents/heejeong/FibonacciNum509.java?ref=660f6d8d6d514c03a791b9977c1beaed600cc3e8",
    "patch": "@@ -0,0 +1,86 @@\n+package heejeong;\n+\n+class FibonacciNum509 {\n+  public static void main(String[] args) {\n+  \t\tSystem.out.println(\"피보나치 수열\");\n+  \t\tint n = 31;\n+  \t\tSystem.out.println(\"n=\"+fib_DP(n));\n+  \t\tSystem.out.println(\"n=\"+fib_rec(n));\n+  \t\tSystem.out.println(\"n=\"+fib_Bottom_Up(n));\n+  \t\tSystem.out.println(\"n=\"+fib_Top_Down(n));\n+  \t}\n+\n+  \t  //DP\n+      public static int fib_DP(int n) {\n+          int [] arr = new int [n+1];\n+\n+          arr[0] = 0;\n+          arr[1] = 1;\n+\n+          if(n<2){\n+              return arr[n];\n+          }\n+\n+          for(int i=2;i<n+1;i++){\n+              arr[i] = arr[i-2] + arr[i-1];\n+          }\n+\n+          return arr[n];\n+      }\n+\n+      //Bottom_Up\n+      public static int fib_Bottom_Up(int n) {\n+      \tif(n<=1) {\n+      \t\treturn n;\n+      \t}\n+\n+      \tint first = 0;\n+      \tint second = 1;\n+\n+      \tint next = 0;\n+      \tfor(int i=0;i<n-1;i++) {\n+      \t\tnext = first + second;\n+      \t\tfirst = second;\n+      \t\tsecond = next;\n+      \t}\n+      \treturn next;\n+      }\n+\n+      //Top_Down\n+      public static int fib_Top_Down(int n) {\n+      \tint [] arr = new int [n+1];\n+      \tif(arr[n]>0) {\n+      \t\treturn arr[n];\n+      \t}\n+\n+      \tif(n<=1) {\n+      \t\treturn n;\n+      \t}else {\n+      \t\tarr[n] = fib_Top_Down(n-1) + fib_Top_Down(n-2);\n+      \t\treturn arr[n];\n+      \t}\n+      }\n+\n+      //일반재귀함수\n+      public static int fib_rec(int n) {\n+          int result = 0;\n+\n+          //1. if문으로 했을 때\n+          if(n==0){\n+            result=0;\n+          }else if(n==1){\n+            result=1;\n+          }else{\n+            result=fib_rec(n-1)+fib_rec(n-2);\n+          }\n+\n+          //2. switch문\n+          switch(n){\n+            case 0: result=0; break;\n+            case 1: result=1; break;\n+            default: result=fib_rec(n-1)+fib_rec(n-2);\n+          }\n+\n+          return result;\n+        }\n+}"
  },
  {
    "sha": "8df0968c44837e1ebc603bcfd14c40c888bab655",
    "filename": "heejeong/GreatString.java",
    "status": "added",
    "additions": 29,
    "deletions": 0,
    "changes": 29,
    "blob_url": "https://github.com/Bloodevil/cote/blob/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/GreatString.java",
    "raw_url": "https://github.com/Bloodevil/cote/raw/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/GreatString.java",
    "contents_url": "https://api.github.com/repos/Bloodevil/cote/contents/heejeong/GreatString.java?ref=660f6d8d6d514c03a791b9977c1beaed600cc3e8",
    "patch": "@@ -0,0 +1,29 @@\n+package heejeong;\n+\n+//Make The String Great\n+class GreatString {\n+    //테스트용 메인\n+    public static void main(String[] args) {\n+      System.out.println(makeGood(\"heElLO\"));\n+    }\n+\n+    public static String makeGood(String s) {\n+      StringBuffer good = new StringBuffer(s);\n+      if(good.length()<=1){ // 비교할 문자가 없을경우 return\n+        return s;\n+      }else{\n+        int count=1;  //0이 아닌 숫자로 선언\n+        while(count!=0){  //인접문자 변경사항이 없을 때까지 진행\n+          count=0; //인접문자가 없다고 가정\n+          for(int i=0;i<good.length()-1;i++){\n+            //char에서 대/소문자 차이는 32 (순서바뀔 수 있으니 절대값 사용)\n+            if(Math.abs(good.charAt(i)-good.charAt(i+1))==32){\n+              good.replace(i, i+2, \"\"); //replce 사용위해 StringBuffer로 변환했었음 \\\n+              count++; //인접문자가 있음 추가처리 위해 count 증가\n+            }\n+          }\n+        }\n+      }\n+      return good.toString(); //StringBuffer String 변환\n+    }\n+}"
  },
  {
    "sha": "3ed5d1413d7abaa4f7af2d729ab08a8032275a63",
    "filename": "heejeong/LemonadeChange0317.java",
    "status": "added",
    "additions": 59,
    "deletions": 0,
    "changes": 59,
    "blob_url": "https://github.com/Bloodevil/cote/blob/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/LemonadeChange0317.java",
    "raw_url": "https://github.com/Bloodevil/cote/raw/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/LemonadeChange0317.java",
    "contents_url": "https://api.github.com/repos/Bloodevil/cote/contents/heejeong/LemonadeChange0317.java?ref=660f6d8d6d514c03a791b9977c1beaed600cc3e8",
    "patch": "@@ -0,0 +1,59 @@\n+package heejeong;\n+\n+import java.util.HashMap;\n+\n+public class LemonadeChange0317 {\n+    //맞게 풀었다고 생각했는데 안되는 이유를 모르겠어요\n+    public static boolean lemonadeChange(int[] bills) {\n+    \t// 처음에는 잔돈 없음 => 첫 구매 손님이 $5가 아니라면 false\n+    \tif(bills[0]!=5) {\n+    \t\treturn false;\n+    \t}\n+\n+    \t// 처음 무조건 $5\n+    \t// 1. change map 만들어서 풀기 {달러 : 갯수}\n+    \tHashMap<Integer, Integer> change = new HashMap<Integer, Integer>();\n+    \tint five=0; int ten=0;\n+    \tchange.put(5,five);\n+    \tchange.put(10,ten);\n+\n+    \tfor(int i=0;i<bills.length;i++) {\n+    \t\tif(bills[i]==5) {\n+    \t\t\t// 5 달러 추가\n+    \t\t\tchange.replace(5,five+=1);\n+    \t\t} else if(bills[i]==10) {\n+    \t\t\tchange.replace(10,ten+=1);\n+    \t\t\tif(change.get(5)>=1) {\n+    \t\t\t\tchange.replace(5,five-=1);\n+    \t\t\t}else {\n+    \t\t\t\treturn false;\n+    \t\t\t}\n+    \t\t} else {\n+    \t\t\tif(change.get(5)>=3) {\n+    \t\t\t\t//1. $5 3장 이상\n+    \t\t\t\tchange.replace(5,five-=3);\n+    \t\t\t}else if(change.get(5)>=1 && change.get(10)>=1){\n+    \t\t\t\t//2. $5 1장이상 $10 1장 이상\n+    \t\t\t\tchange.replace(5,five-=1);\n+    \t\t\t\tchange.replace(10,ten-=1);\n+    \t\t\t}else {\n+    \t\t\t\treturn false;\n+    \t\t\t}\n+    \t\t}\n+    \t} //for\n+\n+    \treturn true;\n+    }\n+\n+}\n+\n+// 860. Lemonade Change\n+// each lemonade costs $5\n+// Customers are standing in a queue to buy from you, and order one at a time\n+// => 순서대로 주문 (한 번에 하나씩)\n+// Each customer will only buy one lemonade => 한 개의 레몬에이드만 구매 가능\n+// pay with either a $5, $10, or $20 bill\n+// net transaction 순 거래\n+// Note that you don't have any change in hand at first.\n+// => 처음에는 잔돈 없음 => 첫 구매 손님이 $5가 아니라면 false\n+// Return true if and only if you can provide every customer with correct change."
  },
  {
    "sha": "ad84a921b5e89f5eb2d74aa0798755b704dc563c",
    "filename": "heejeong/MajorityElement0319.java",
    "status": "added",
    "additions": 50,
    "deletions": 0,
    "changes": 50,
    "blob_url": "https://github.com/Bloodevil/cote/blob/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/MajorityElement0319.java",
    "raw_url": "https://github.com/Bloodevil/cote/raw/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/MajorityElement0319.java",
    "contents_url": "https://api.github.com/repos/Bloodevil/cote/contents/heejeong/MajorityElement0319.java?ref=660f6d8d6d514c03a791b9977c1beaed600cc3e8",
    "patch": "@@ -0,0 +1,50 @@\n+package heejeong;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MajorityElement0319 {\n+\n+    public static void main(String[] args) {\n+        int [] nums = {2,2,2,4};\n+        System.out.println(\"majorElement = \"+majorityElement2(nums));\n+    }\n+\n+    public static int majorityElement(int[] nums) {\n+        int majorElement = 0;\n+\n+        //for문을 돌며 배열을 담는다. {숫자:개수}\n+        Map<Integer,Integer> map = new HashMap<>();\n+        for(int i=0;i<nums.length;i++){\n+            // 처음 담는 숫자가 아니라면\n+            if(map.get(nums[i])!=null){\n+                map.replace(nums[i], map.get(nums[i])+1);\n+                System.out.println(\"i=\"+i+map);\n+            }else {\n+                map.put(nums[i],1);\n+                System.out.println(\"i=\"+i+map);\n+            }\n+\n+            //majority element 찾기\n+            if(map.get(nums[i])>(nums.length/2)){\n+                majorElement = nums[i];\n+            }\n+        }//for\n+\n+        return majorElement;\n+    }\n+\n+    //Solution 보고 감탄한 답안\n+    public static int majorityElement2(int[] nums) {\n+        Arrays.sort(nums);\n+        return nums[nums.length/2];\n+    }\n+\n+}\n+\n+//169. Majority Element\n+// n개 요소를 가진 nums 배열에서\n+// majority element는 n/2번 이상 존재할 경우로 판단\n+// majority element 항상 존재하는 것으로 가정\n+// Could you solve the problem in linear time and in O(1) space?"
  },
  {
    "sha": "7bd445b9641614406843344185ccd15ad89b9579",
    "filename": "heejeong/PathSum112.java",
    "status": "added",
    "additions": 63,
    "deletions": 0,
    "changes": 63,
    "blob_url": "https://github.com/Bloodevil/cote/blob/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/PathSum112.java",
    "raw_url": "https://github.com/Bloodevil/cote/raw/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/PathSum112.java",
    "contents_url": "https://api.github.com/repos/Bloodevil/cote/contents/heejeong/PathSum112.java?ref=660f6d8d6d514c03a791b9977c1beaed600cc3e8",
    "patch": "@@ -0,0 +1,63 @@\n+package heejeong;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class PathSum112 {\n+\n+\tpublic class TreeNode {\n+\t\tint val;\n+\t\tTreeNode left;\n+\t\tTreeNode right;\n+\t\tTreeNode() {}\n+\t\tTreeNode(int val) { this.val = val; }\n+\t\tTreeNode(int val, TreeNode left, TreeNode right) {\n+\t\t\tthis.val = val;\n+\t\t\tthis.left = left;\n+\t\t\tthis.right = right;\n+\t\t}\n+\t}\n+\n+\tpublic boolean hasPathSum(TreeNode root, int targetSum) {\n+\t\tif(root == null)  return false;\n+\n+\t\tif(root.left==null && root.right==null && targetSum-root.val==0) {\n+\t\t\treturn true;\n+\t\t}else {\n+\t\t\treturn hasPathSum(root.left, targetSum-root.val) || hasPathSum(root.right, targetSum-root.val);\n+\t\t}\n+\t}\n+\n+\t/*\n+\t너무 어렵게 풀려고 한것같다. 메모리도 많이쓰이고 시간도 오래걸림.\n+\tpublic List<Integer> getSum(TreeNode root, int getSum) {\n+\t\tList<Integer> sumList = new ArrayList<Integer>();\n+\t\tif(root!=null) {\n+\t\t\tgetSum += root.val;\n+\t\t\twhile(root.left!=null || root.right!=null) {\n+\t\t\t\tif(root.left!=null) {\n+\t\t\t\t\tgetSum(root.left, getSum);\n+\t\t\t\t}\n+\t\t\t\tif(root.right!=null) {\n+\t\t\t\t\tgetSum(root.right, getSum);\n+\t\t\t\t}\n+\t\t\t\tsumList.add(getSum);\n+\t\t\t}\n+\t\t}\n+\t\treturn sumList;\n+\t}\n+\n+\t//루트부터 단말 노드부터 더한 값이 target이 되는 경로가 있으면 true\n+    public boolean hasPathSum(TreeNode root, int targetSum) {\n+    \tboolean hasPath = false;\n+    \tList<Integer> sumList = getSum(root, 0);\n+    \tfor(int target :sumList){\n+    \t\tif(target==targetSum) {\n+    \t\t\thasPath = true;\n+    \t\t}\n+    \t}\n+    \treturn hasPath;\n+    }\n+\t */\n+\n+}"
  },
  {
    "sha": "d7cad5091bacc24ff322a7e487714378dd16402b",
    "filename": "heejeong/RomantoInteger13.java",
    "status": "added",
    "additions": 54,
    "deletions": 0,
    "changes": 54,
    "blob_url": "https://github.com/Bloodevil/cote/blob/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/RomantoInteger13.java",
    "raw_url": "https://github.com/Bloodevil/cote/raw/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/RomantoInteger13.java",
    "contents_url": "https://api.github.com/repos/Bloodevil/cote/contents/heejeong/RomantoInteger13.java?ref=660f6d8d6d514c03a791b9977c1beaed600cc3e8",
    "patch": "@@ -0,0 +1,54 @@\n+package heejeong;\n+\n+public class RomantoInteger13 {\n+\n+\t//IV = V-I 4, IX = X-I 9\n+\t//XL = L-X 40, XC = C-X 90\n+\t//CD = D-C 400 CM = M-C 900\n+    public static int romanToInt(String s) {\n+    \tint val = 0;\n+    \tfor(int i=0;i<s.length();i++) {\n+    \t\tString roman = s.substring(i, i+1);\n+\n+        //인덱스 문제를 해결하려다가 30분을 넘겼지만, 어쨋든 정상작동한 것에 뿌듯합니다\n+        //더 간소화된 코드가 분명히 있을텐데 더 공부하려고요\n+    \t\tString roman2 = \"\";\n+    \t\tif(i<(s.length()-2)) {\n+    \t\t\troman2 = s.substring(i, i+2);\n+    \t\t}else {\n+    \t\t\troman2 = s.substring(i, s.length());\n+    \t\t}\n+\n+\t\t\tswitch(roman) {\n+    \t\t\tcase \"I\":\n+    \t\t\t\tif(roman2.equals(\"IV\") || roman2.equals(\"IX\")) {\n+    \t\t\t\t\tval-=1;\n+    \t\t\t\t}else {\n+    \t\t\t\t\tval+=1;\n+    \t\t\t\t}\n+    \t\t\t\tbreak;\n+    \t\t\tcase \"V\": val+=5; break;\n+    \t\t\tcase \"X\":\n+    \t\t\t\tif(roman2.equals(\"XL\") || roman2.equals(\"XC\")) {\n+    \t\t\t\t\tval-=10;\n+    \t\t\t\t}else {\n+    \t\t\t\t\tval+=10;\n+    \t\t\t\t}\n+    \t\t\t\tbreak;\n+    \t\t\tcase \"L\": val+=50; break;\n+    \t\t\tcase \"C\":\n+\t    \t\t\tif(roman2.equals(\"CD\") || roman2.equals(\"CM\")) {\n+\t    \t\t\t\tval-=100;\n+\t    \t\t\t}else {\n+\t    \t\t\t\tval+=100;\n+\t    \t\t\t}\n+\t    \t\t\tbreak;\n+    \t\t\tcase \"D\": val+=500; break;\n+    \t\t\tcase \"M\": val+=1000; break;\n+\t\t\t}\n+\n+    \t\tSystem.out.println(\"roman = \"+roman+\",roman2 = \"+roman2+\", val = \"+val);\n+    \t}\n+        return val;\n+    }\n+}"
  },
  {
    "sha": "b169edbf1c9c242e2f83a0c95ffba12c6a4d45ec",
    "filename": "heejeong/SortColors.java",
    "status": "added",
    "additions": 27,
    "deletions": 0,
    "changes": 27,
    "blob_url": "https://github.com/Bloodevil/cote/blob/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/SortColors.java",
    "raw_url": "https://github.com/Bloodevil/cote/raw/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/SortColors.java",
    "contents_url": "https://api.github.com/repos/Bloodevil/cote/contents/heejeong/SortColors.java?ref=660f6d8d6d514c03a791b9977c1beaed600cc3e8",
    "patch": "@@ -0,0 +1,27 @@\n+package heejeong;\n+\n+//798.Sort Colors\n+/*\n+Given an array nums with n objects\n+objects of the same color are adjacent,\n+with the colors in the order red, white, and blue.\n+0 : red 1: white 3: blue\n+*/\n+class SortColors  {\n+    public static void sortColors(int[] nums) {\n+      //solve this problem without using the library's sort function\n+      if(nums.length>1){\n+        for(int i=0;i<nums.length;i++){\n+          for(int j=i+1;j<nums.length;j++){\n+            int temp=0;\n+            if(nums[i]>nums[j]){\n+              temp = nums[i];\n+              nums[i] = nums[j];\n+              nums[j] = temp;\n+            }//if\n+          }\n+        }\n+      }//if\n+\n+    }\n+}"
  },
  {
    "sha": "9da731670b5c9b83b4f0c79eeaff0501da7d86a5",
    "filename": "heejeong/SortHashMap0318.java",
    "status": "added",
    "additions": 39,
    "deletions": 0,
    "changes": 39,
    "blob_url": "https://github.com/Bloodevil/cote/blob/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/SortHashMap0318.java",
    "raw_url": "https://github.com/Bloodevil/cote/raw/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/SortHashMap0318.java",
    "contents_url": "https://api.github.com/repos/Bloodevil/cote/contents/heejeong/SortHashMap0318.java?ref=660f6d8d6d514c03a791b9977c1beaed600cc3e8",
    "patch": "@@ -0,0 +1,39 @@\n+package heejeong;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+public class SortHashMap0318 {\n+    public static void main(String[] args) {\n+        HashMap<Integer, Integer> unSortedMap = new HashMap<>();\n+        unSortedMap.put(1, 1);\n+        unSortedMap.put(5, 3);\n+        //요소 추가\n+        unSortedMap.put(2, 6);\n+        SortHashMap(unSortedMap);\n+    }\n+\n+    public static HashMap<Integer, Integer> SortHashMap(HashMap<Integer, Integer> hashmap) {\n+        //let's sort\n+\n+        //1. sort by key - TreeMap (Key 기준으로 오름차순 정렬)\n+        TreeMap<Integer, Integer> sortByKeys = new TreeMap<>();\n+        sortByKeys.putAll(hashmap);\n+        System.out.println(\"sort by key = \"+sortByKeys);\n+\n+        //2. sort by value - Using the Stream API (Value 기준으로 오름차순 정렬)\n+        hashmap = hashmap.entrySet()\n+                .stream()\n+                .sorted(Map.Entry.comparingByValue())\n+                .collect(Collectors.toMap(\n+                        Map.Entry::getKey,\n+                        Map.Entry::getValue,\n+                        (oldValue,newValue) -> oldValue, LinkedHashMap::new));\n+        System.out.println(\"sort by values = \"+hashmap);\n+\n+        return hashmap;\n+    }\n+}"
  },
  {
    "sha": "051f10a39bdae2d6f97c5c4a3f6e139206580ba8",
    "filename": "heejeong/TopKElements347.java",
    "status": "added",
    "additions": 51,
    "deletions": 0,
    "changes": 51,
    "blob_url": "https://github.com/Bloodevil/cote/blob/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/TopKElements347.java",
    "raw_url": "https://github.com/Bloodevil/cote/raw/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/TopKElements347.java",
    "contents_url": "https://api.github.com/repos/Bloodevil/cote/contents/heejeong/TopKElements347.java?ref=660f6d8d6d514c03a791b9977c1beaed600cc3e8",
    "patch": "@@ -0,0 +1,51 @@\n+package heejeong;//347. Top K Frequent Elements\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+public class TopKElements347 {\n+\n+    public static int[] topKFrequent(int[] nums, int k) {\n+    \tif(nums.length==1) {\n+    \t\treturn nums;\n+    \t}\n+\n+      //해쉬 맵 형태로 {숫자:빈번도} 를 저장\n+    \t//Map은 순서유지되지 않고 Key 중복 안됨\n+    \tHashMap<Integer, Integer> kMap = new HashMap<Integer, Integer>();\n+    \tint frequent = 1;\n+    \tfor(int i=0;i<nums.length;i++) {\n+    \t\t//같은 키 값이 있다면 frequent 증가\n+    \t\tif(kMap.get(nums[i])!=null) {\n+    \t\t\tfrequent++;\n+    \t\t}else frequent = 1;\n+    \t\tkMap.put(nums[i], frequent);\n+\n+    \t\t//확인\n+    \t\tSystem.out.println(\"nums[i]=\"+nums[i]+\", frequent=\"+frequent);\n+    \t}\n+\n+    \tIterator<Integer> iter = kMap.keySet().iterator();\n+\n+    \tint [] output = new int [k];\n+    \tint j=0;\n+\n+    \twhile(iter.hasNext()) {\n+    \t\tint key = iter.next();\n+    \t\tint value = kMap.get(key);\n+    \t\tSystem.out.println(\"key=\"+key+\", value=\"+value);\n+\n+    \t\t//valueList에 value 값 정렬하기\n+    \t\toutput[j] = key;\n+    \t\tArrays.sort(output);\n+    \t}\n+\n+    \t//value 값으로 정렬하면 꺼내도 value라서\n+    \t//key값을 얻어오는 걸 고민해봐야함.\n+\n+    \t//k개 만큼만 'key'를 output에 담기\n+\n+    \treturn output;\n+    }\n+}"
  },
  {
    "sha": "14403774b083c9b3bcc4ea36a80107eee86c659e",
    "filename": "heejeong/TwoSum0316.java",
    "status": "added",
    "additions": 25,
    "deletions": 0,
    "changes": 25,
    "blob_url": "https://github.com/Bloodevil/cote/blob/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/TwoSum0316.java",
    "raw_url": "https://github.com/Bloodevil/cote/raw/660f6d8d6d514c03a791b9977c1beaed600cc3e8/heejeong/TwoSum0316.java",
    "contents_url": "https://api.github.com/repos/Bloodevil/cote/contents/heejeong/TwoSum0316.java?ref=660f6d8d6d514c03a791b9977c1beaed600cc3e8",
    "patch": "@@ -0,0 +1,25 @@\n+package heejeong;\n+// 1. Two Sum\n+// return indices of the two numbers such that they add up to target.\n+// 배열안의 값 두 개를 더해서 target이 되는 배열 인덱스를 배열형태로 return\n+// Only one valid answer exists.\n+\n+public class TwoSum0316 {\n+\tpublic int[] twoSum(int[] nums, int target) {\n+\t\tint [] twoSum = new int[2];\n+\n+\t\tfor(int i=0;i<nums.length;i++) {\n+\t\t\t//이미 더한 경우는 더하지 않아도 되므로 j=i+1\n+\t\t\tfor(int j=i+1;j<nums.length;j++) {\n+\t\t\t\tif(nums[i]+nums[j]==target) {\n+\t\t\t\t\ttwoSum[0] = i;\n+\t\t\t\t\ttwoSum[1] = j;\n+\t\t\t\t\t//값을 찾으면 바로 for문을 빠져나오기 위해 return\n+\t\t\t\t\treturn twoSum;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn twoSum;\n+\t}\n+}"
  }
]
