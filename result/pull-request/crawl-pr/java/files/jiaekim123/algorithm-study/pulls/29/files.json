[
  {
    "sha": "24b2d0450ffcea6d00f75ed04ebc935089afb61b",
    "filename": "README.md",
    "status": "added",
    "additions": 3,
    "deletions": 0,
    "changes": 3,
    "blob_url": "https://github.com/jiaekim123/algorithm-study/blob/1d5b989a77d8d7279e25296ee34f45d5b303b46c/README.md",
    "raw_url": "https://github.com/jiaekim123/algorithm-study/raw/1d5b989a77d8d7279e25296ee34f45d5b303b46c/README.md",
    "contents_url": "https://api.github.com/repos/jiaekim123/algorithm-study/contents/README.md?ref=1d5b989a77d8d7279e25296ee34f45d5b303b46c",
    "patch": "@@ -0,0 +1,3 @@\n+# algorithm-study\n+\n+언젠간 고수가 되겠지..."
  },
  {
    "sha": "f349c1ae66f66ff268c4185bf051be2a8c3588df",
    "filename": "src/main/java/week1/Solution.java",
    "status": "modified",
    "additions": 56,
    "deletions": 2,
    "changes": 58,
    "blob_url": "https://github.com/jiaekim123/algorithm-study/blob/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week1/Solution.java",
    "raw_url": "https://github.com/jiaekim123/algorithm-study/raw/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week1/Solution.java",
    "contents_url": "https://api.github.com/repos/jiaekim123/algorithm-study/contents/src/main/java/week1/Solution.java?ref=1d5b989a77d8d7279e25296ee34f45d5b303b46c",
    "patch": "@@ -4,9 +4,63 @@\n  */\n package week1;\n \n+import java.util.LinkedList;\n+\n public class Solution {\n+// TODO : 해 결 해\n+    static LinkedList<Integer> [] list;\n+    static int []dis;\n+    static int cnt=0, max=0, leaf=1;\n+\n     public int solution(int n, int[][] edges) {\n-        int answer = 0;\n-        return answer;\n+        list = new LinkedList[n+1];\n+        for(int i=0;i<=n; i++) list[i] = new LinkedList<>();\n+        dis = new int [n+1];\n+        for(int i=0; i<edges.length; i++){\n+            int s = edges[i][0];\n+            int e = edges[i][1];\n+            list[s].add(e);\n+            list[e].add(s);\n+        }\n+\n+        solve(1,n, false);  // 임의의 정점 1에서 가장 깊은 리프노드를 구한다 (정점 A)\n+        solve(leaf, n, true); // 구한 리프노드 leaf 에서 (가장 긴) 다른 리프노드를 구한다  (정점 B)\n+        if(cnt>=2) return max; // 구한 리프노드 갯수가 2개 이상일 때 중간값의 최댓값은 트리의 지름이다\n+        else{ // 구한 리프노드 갯수가 1개 일 때 정점 C를 확인해야 한다\n+            solve(leaf, n, true);  // 리프노드를 구한다 (정점 C)\n+            if(cnt>=2) return max; // 구한 리프노트 C가 2개 이상이면 중간값의 최댓값은 트리의 지름이다\n+            else return max-1; // 정점이 1개만 나오면 중간값의 최댓값은 트리의 지름-1 이 된다.\n+        }\n+    }\n+\n+    static void solve(int start, int n, boolean T){\n+        cnt = 0;\n+        max = 0;\n+        dis = new int [n+1];\n+        dfs(start, 0, T);\n+    }\n+\n+    static void dfs(int cur, int len, boolean T){\n+        if(dis[cur]==1) return; // 방문한 노드면 return\n+\n+        if(T == false){ // 리프노드가 아닐 때\n+            if(len> max){\n+                leaf = cur; // 리프노드 업데이트\n+                max = len;\n+            }\n+        }\n+        else{ // 리프노드 일 때\n+            if(len>max){ //max 가 업데이트 되면\n+                leaf = cur; // 리프노드 업데이트\n+                cnt = 1; // cnt 는 다시 1이 된다\n+                max = len;\n+            }\n+            else if(len == max) cnt ++; //len 과 처음구한 (max)값과 같을 때 갯수 증가\n+        }\n+\n+        dis[cur] = 1; // 방문 체크\n+        for(int next : list[cur]){\n+            dfs(next, len+1, T);\n+        }\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "fee021f73552af492b57761a10a2b3e531525416",
    "filename": "src/main/java/week12/Solution.java",
    "status": "modified",
    "additions": 29,
    "deletions": 1,
    "changes": 30,
    "blob_url": "https://github.com/jiaekim123/algorithm-study/blob/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week12/Solution.java",
    "raw_url": "https://github.com/jiaekim123/algorithm-study/raw/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week12/Solution.java",
    "contents_url": "https://api.github.com/repos/jiaekim123/algorithm-study/contents/src/main/java/week12/Solution.java?ref=1d5b989a77d8d7279e25296ee34f45d5b303b46c",
    "patch": "@@ -4,9 +4,37 @@\n  */\n package week12;\n \n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n class Solution {\n     public int solution(int[][] routes) {\n-        int answer = 0;\n+        // 1. routes 진입 순 정렬\n+        Arrays.sort(routes, new Comparator<int[]>() {\n+            @Override\n+            public int compare(int[] o1, int[] o2) {\n+                if (o1[0] == o2[0]) return o1[1] - o2[1];\n+                return o1[0] - o2[0];\n+            }\n+        });\n+\n+        int left = routes[0][0];\n+        int right = routes[0][1];\n+\n+        int answer = 1;\n+\n+        for (int i = 1; i < routes.length; i++) {\n+            // 겹치지 않는 부분 cctv 추가 \n+            if( right < routes[i][0]){\n+                answer ++;\n+                left = routes[i][0];\n+                right = routes[i][1];\n+            }else {\n+                left = Math.min(routes[i][0], left);\n+                right = Math.min(routes[i][1], right);\n+            }\n+        }\n+\n         return answer;\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "6854387a75ff432131fec5c96b2e2554501b24c8",
    "filename": "src/main/java/week15/Solution.java",
    "status": "modified",
    "additions": 37,
    "deletions": 1,
    "changes": 38,
    "blob_url": "https://github.com/jiaekim123/algorithm-study/blob/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week15/Solution.java",
    "raw_url": "https://github.com/jiaekim123/algorithm-study/raw/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week15/Solution.java",
    "contents_url": "https://api.github.com/repos/jiaekim123/algorithm-study/contents/src/main/java/week15/Solution.java?ref=1d5b989a77d8d7279e25296ee34f45d5b303b46c",
    "patch": "@@ -1,8 +1,44 @@\n package week15;\n \n+import java.util.Arrays;\n+\n+\n+//https://programmers.co.kr/learn/courses/30/lessons/72413\n class Solution {\n+    // 1, n 번에서 A, B 까지 최단거리를 구한다.\n+    // 2. 처음 S 에서 n 번 까지의 거리를 구한다.\n+    // 3. S -> n 거리와 n->A,B 거리 각각을 더해서 최솟값을 찾는다.\n+    int MAX_COST = 1000000;\n+\n     public int solution(int n, int s, int a, int b, int[][] fares) {\n-        int answer = 0;\n+        int[][] dis = new int[n + 1][n + 1];\n+        for (int i = 1; i <= n; i++) {\n+            Arrays.fill(dis[i], MAX_COST);\n+            dis[i][i] = 0;\n+        }\n+\n+        for (int[] f : fares) {\n+            dis[f[0]][f[1]] = f[2];\n+            dis[f[1]][f[0]] = f[2];\n+        }\n+\n+        int answer = 999999999;\n+\n+        // 각 지점에서 최소 거리 찾기 -> 플로이드 워샬로 풀기\n+        for (int i = 1; i <= n; i++) {\n+            for (int j = 1; j <= n; j++) {\n+                for (int k = 1; k <= n; k++) {\n+                    dis[j][k] = Math.min(dis[j][k], dis[j][i] + dis[i][k]); // 순서 중요\n+                }\n+            }\n+        }\n+\n+        // 어디서 분기해야(각자 타야) 최솟값이 되는 지 찾기\n+        for (int i = 1; i <= n; i++) {\n+            answer = Math.min(answer, dis[s][i] + dis[i][a] + dis[i][b]);\n+        }\n+\n         return answer;\n     }\n+\n }"
  },
  {
    "sha": "36879f506b05c03b342eaa6dd8d865ccb6f3b389",
    "filename": "src/main/java/week2/Solution.java",
    "status": "modified",
    "additions": 35,
    "deletions": 2,
    "changes": 37,
    "blob_url": "https://github.com/jiaekim123/algorithm-study/blob/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week2/Solution.java",
    "raw_url": "https://github.com/jiaekim123/algorithm-study/raw/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week2/Solution.java",
    "contents_url": "https://api.github.com/repos/jiaekim123/algorithm-study/contents/src/main/java/week2/Solution.java?ref=1d5b989a77d8d7279e25296ee34f45d5b303b46c",
    "patch": "@@ -4,9 +4,42 @@\n  */\n package week2;\n \n+import java.util.HashSet;\n+import java.util.Set;\n+\n class Solution {\n+    /*\n+    * N을 n번 사용해서 얻는 수  */\n     public int solution(int N, int number) {\n-        int answer = 0;\n-        return answer;\n+        Set<Long>[] list = new HashSet[8];\n+        for(int i=0; i<8; i++)list[i] = new HashSet<>();\n+        String n = \"\";\n+        for(int i=0; i<8; i++){\n+            n+=String.valueOf(N);\n+            list[i].add(Long.parseLong(n)); // n을 i+1번 사용해서 만들 수 있는 수\n+        }\n+        // 1번 set + n-1번 set 사칙 연산해서 만들 수 있는 수\n+        for(int i=0; i<8; i++){ // i번 사용 할 때\n+            //list[i]에 추가 되는 수들\n+            for(int j=0; j<i; j++){ // 0+2, 1+1,\n+                // 사칙 연산 op1, op2;\n+                for(Long one: list[j]){ // list[0] set ~\n+                    for(Long two : list[i-j-1]){ // list[0] set ~\n+                        list[i].add(one+two);\n+                        list[i].add(one-two);\n+                        list[i].add(one*two);\n+                        if(two != 0) list[i].add(one/two);\n+                    }\n+                }\n+            }\n+        }\n+        for(int i=0; i<8; i++){\n+//            System.out.println(i+\" :: \"+list[i]);\n+            if(list[i].contains((long)number)){\n+                return i+1;\n+            }\n+        }\n+        return -1;\n     }\n+\n }\n\\ No newline at end of file"
  },
  {
    "sha": "7c451ee53043897f6be20775930ad38c64e17b61",
    "filename": "src/main/java/week3/Solution.java",
    "status": "modified",
    "additions": 30,
    "deletions": 0,
    "changes": 30,
    "blob_url": "https://github.com/jiaekim123/algorithm-study/blob/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week3/Solution.java",
    "raw_url": "https://github.com/jiaekim123/algorithm-study/raw/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week3/Solution.java",
    "contents_url": "https://api.github.com/repos/jiaekim123/algorithm-study/contents/src/main/java/week3/Solution.java?ref=1d5b989a77d8d7279e25296ee34f45d5b303b46c",
    "patch": "@@ -7,6 +7,36 @@\n class Solution {\n     public int solution(int n, int[][] results) {\n         int answer = 0;\n+        int maxV = 1000000;\n+        int [][]map = new int [n+1][n+1];\n+        for(int i=1; i<=n; i++){\n+            for(int j=1; j<=n; j++){\n+                map[i][j] = maxV;\n+            }\n+        }\n+        for(int []e : results){\n+            map[e[0]][e[1]] = 1;\n+        }\n+        for(int k=1; k<=n; k++){\n+            for(int i=1; i<=n; i++){\n+                for(int j=1; j<=n; j++) {\n+                    if (map[i][j] > map[i][k] + map[k][j]) {\n+                        map[i][j] = map[i][k] + map[k][j];\n+                    }\n+                }\n+            }\n+        }\n+        for(int i=1; i<=n; i++){\n+            boolean f = true;\n+            for(int j=1; j<=n ; j++){\n+                if(i==j) continue;\n+                if(map[i][j] == maxV && map[j][i] == maxV){\n+                    f = false;\n+                    break;\n+                }\n+            }\n+            if(f) answer++;\n+        }\n         return answer;\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "83fa50c751f4debd8007c555cce5641fd0539a03",
    "filename": "src/main/java/week4/Solution.java",
    "status": "modified",
    "additions": 68,
    "deletions": 1,
    "changes": 69,
    "blob_url": "https://github.com/jiaekim123/algorithm-study/blob/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week4/Solution.java",
    "raw_url": "https://github.com/jiaekim123/algorithm-study/raw/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week4/Solution.java",
    "contents_url": "https://api.github.com/repos/jiaekim123/algorithm-study/contents/src/main/java/week4/Solution.java?ref=1d5b989a77d8d7279e25296ee34f45d5b303b46c",
    "patch": "@@ -4,9 +4,76 @@\n  */\n package week4;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n class Solution {\n+    static class File implements Comparable<File>{\n+        private String head;\n+        private String num;\n+        private String tail;\n+        private String s;\n+\n+        File(String head, String num, String tail, String s){\n+            this.head = head;\n+            this.num = num;\n+            this.tail = tail;\n+            this.s = s;\n+        }\n+\n+        @Override\n+        public int compareTo(File o) {\n+            int h = this.head.compareTo(o.head);\n+            if(h>0) return 1;\n+            else if(h<0) return -1;\n+            else {\n+                int num = Integer.parseInt(this.num);\n+                int n = Integer.parseInt(o.num);\n+                if(num > n) return 1;\n+                else if( num < n) return  -1;\n+            }\n+            return 0;\n+        }\n+    }\n+\n     public String[] solution(String[] files) {\n-        String[] answer = {};\n+        ArrayList<File> list = new ArrayList<>();\n+        for(String f: files){\n+            char []arr = f.toCharArray();\n+            String head = \"\";\n+            String num = \"\";\n+            String tail = \"\";\n+            int n = -1;\n+            int t = -1;\n+\n+            for(int i=0; i<arr.length; i++){\n+                char c = arr[i];\n+                if(c>=48 && c<=57 && n == -1) n = i;\n+                else if(n!=-1 && (c<48 || c>57 || c==' ') && t==-1) t=i;\n+                else if(n==-1 && (c<48 || c>57 )){\n+                    if(c>=65 && c<=90) c+=32;\n+                    head+=String.valueOf(c);\n+                }\n+            }\n+\n+            System.out.println(t);\n+            if(t!=-1) {\n+                num = f.substring(n, t);\n+                tail = f.substring(t, arr.length);\n+            }\n+            else if(n!=-1)num = f.substring(n,arr.length);\n+//            System.out.println(head+\" \"+num+\" \"+tail);\n+            list.add(new File(head, num, tail, f));\n+        }\n+        Collections.sort(list);\n+        String []answer = new String[list.size()];\n+\n+        for(int i =0; i<list.size(); i++){\n+            answer[i] = list.get(i).s;\n+//            System.out.println(answer[i]);\n+        }\n+\n         return answer;\n     }\n+\n }\n\\ No newline at end of file"
  },
  {
    "sha": "523808a05af07fc0414b5bcb11a7c4ce0201fcca",
    "filename": "src/main/java/week5/Solution.java",
    "status": "modified",
    "additions": 68,
    "deletions": 2,
    "changes": 70,
    "blob_url": "https://github.com/jiaekim123/algorithm-study/blob/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week5/Solution.java",
    "raw_url": "https://github.com/jiaekim123/algorithm-study/raw/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week5/Solution.java",
    "contents_url": "https://api.github.com/repos/jiaekim123/algorithm-study/contents/src/main/java/week5/Solution.java?ref=1d5b989a77d8d7279e25296ee34f45d5b303b46c",
    "patch": "@@ -4,9 +4,75 @@\n  */\n package week5;\n \n+import java.util.*;\n+\n class Solution {\n+\n+    class Disk implements Comparable<Disk>{\n+        int start, time;\n+        Disk(int start, int time){\n+            this.start = start;\n+            this.time = time;\n+        }\n+\n+        @Override\n+        public int compareTo(Disk o) {\n+            return this.time - o.time;\n+        }\n+    }\n+\n     public int solution(int[][] jobs) {\n-        int answer = 0;\n-        return answer;\n+        LinkedList<Disk> list = new LinkedList<>(); // 작업 리스트\n+        PriorityQueue<Disk> pq = new PriorityQueue<>(); // 대기열\n+\n+        // jobs 들어온 순서 대로 정렬\n+        Arrays.sort(jobs, (j1, j2) -> j1[0] == j2[0] ? j1[1] - j2[1] : j1[0]-j2[0]);\n+\n+        // 작업 리스트\n+        for(int []j: jobs){\n+            list.add(new Disk(j[0], j[1]));\n+        }\n+\n+        // 작업시간이 제일 작은것부터 정렬 - 우선순위 큐\n+        int sum = 0;\n+        int lastTime = 0;\n+        while(!pq.isEmpty() || !list.isEmpty()){\n+            boolean isNew = false; // 새 작업인가\n+\n+            int len = list.size();\n+            // 다음 대기 할 것들을 찾는다\n+            Iterator<Disk> iter = list.iterator();\n+            while (iter.hasNext()){\n+                Disk d = iter.next();\n+                if(d.start > lastTime) break;\n+                pq.add(d);\n+                iter.remove();\n+            }\n+\n+//            for(int i = 0; i<len; i++){\n+//                Disk d = list.get(i);\n+//                // 요청 시간이 이전에 끝난 시간 보다 더 크면 대기하고 있지 않다.\n+//                if(d.start > lastTime) break;\n+//                pq.add(d); // 대기열에 추가\n+//                list.remove(i); //봐야할 작업리스트에서 삭제\n+//            }\n+            // 대기하고 있는 것이 없으면(=start 시간에 작업할 수 있을 때) , 작업 순서대로 수행\n+            if(pq.size() == 0){\n+                pq.add(list.get(0));\n+                list.remove(0);\n+                isNew = true;\n+            }\n+\n+            // 대기열에서 꺼낸다\n+            Disk now = pq.poll();\n+            if(isNew){ // 작업순으로 수행했을 때 (대기시간이 0)\n+                sum += now.time;\n+                lastTime = now.start + now.time;\n+            }else { // 대기시간이 있을 때\n+                sum += lastTime-now.start + now.time;\n+                lastTime += now.time;\n+            }\n+        }\n+        return sum/jobs.length;\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "92e577603ef8d0288c348e3663ff9546fd5714f0",
    "filename": "src/main/java/week6/Solution.java",
    "status": "modified",
    "additions": 20,
    "deletions": 0,
    "changes": 20,
    "blob_url": "https://github.com/jiaekim123/algorithm-study/blob/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week6/Solution.java",
    "raw_url": "https://github.com/jiaekim123/algorithm-study/raw/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week6/Solution.java",
    "contents_url": "https://api.github.com/repos/jiaekim123/algorithm-study/contents/src/main/java/week6/Solution.java?ref=1d5b989a77d8d7279e25296ee34f45d5b303b46c",
    "patch": "@@ -4,9 +4,29 @@\n  */\n package week6;\n \n+import java.util.LinkedList;\n+\n class Solution {\n     public int solution(int cacheSize, String[] cities) {\n         int answer = 0;\n+        LinkedList<String> cache = new LinkedList<>();\n+        int idx = -1;\n+        if(cacheSize ==0) return 5*cities.length;\n+        for(String city : cities){\n+            city = city.toLowerCase(); // 소문자 변환\n+            idx = cache.indexOf(city);\n+            if(idx!=-1){\n+                answer+=1; // cache hit\n+                cache.remove(idx);\n+                cache.add(city);\n+            }\n+            else {\n+                answer+=5; // cache miss\n+                if(cacheSize<= cache.size())\n+                    cache.remove(0);\n+                cache.add(city);\n+            }\n+        }\n         return answer;\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "b3b68ab0924b2655a8d7090aa1bf34ac240467a7",
    "filename": "src/main/java/week8/Solution.java",
    "status": "modified",
    "additions": 20,
    "deletions": 1,
    "changes": 21,
    "blob_url": "https://github.com/jiaekim123/algorithm-study/blob/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week8/Solution.java",
    "raw_url": "https://github.com/jiaekim123/algorithm-study/raw/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week8/Solution.java",
    "contents_url": "https://api.github.com/repos/jiaekim123/algorithm-study/contents/src/main/java/week8/Solution.java?ref=1d5b989a77d8d7279e25296ee34f45d5b303b46c",
    "patch": "@@ -7,6 +7,25 @@\n class Solution {\n     public int solution(int[] a) {\n         int answer = -1;\n-        return answer;\n+\n+        int []cnt = new int [a.length+1]; // a길이 미만의 수\n+        for(int i=0; i<a.length; i++){\n+            cnt[a[i]]++;\n+        } // 숫자 등장 횟수\n+\n+        for(int i=0; i<cnt.length; i++){ // i를 공통 원소로 봤을 떄\n+            if(cnt[i] == 0) continue; // 교집합이 될 수 없는 것\n+            if(cnt[i]<= answer) continue; // 탐색 해보지 않아도 되는 경우\n+            int res = 0;\n+            for(int j=0; j<a.length-1; j++){ // 모든 원소에 대한 탐색\n+                if(a[j]!=i && a[j+1] !=i) continue; // 공통원소가 없으면 pass\n+                if(a[j]==a[j+1])continue; // 2개의 값이 달라야 함\n+                res++;\n+                j++;\n+            }\n+            answer = Math.max(answer, res); // 최대로 만들 수 있는 스타 수열 갯수 갱신\n+        }\n+\n+        return answer*2; // 수열의 길이므로 *2\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "c40c9accab30af27d829c85e6120f841af17796d",
    "filename": "src/main/java/week9/Solution.java",
    "status": "modified",
    "additions": 29,
    "deletions": 0,
    "changes": 29,
    "blob_url": "https://github.com/jiaekim123/algorithm-study/blob/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week9/Solution.java",
    "raw_url": "https://github.com/jiaekim123/algorithm-study/raw/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/main/java/week9/Solution.java",
    "contents_url": "https://api.github.com/repos/jiaekim123/algorithm-study/contents/src/main/java/week9/Solution.java?ref=1d5b989a77d8d7279e25296ee34f45d5b303b46c",
    "patch": "@@ -4,9 +4,38 @@\n  */\n package week9;\n \n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n class Solution {\n     public int solution(int n, int[][] edge) {\n         int answer = 0;\n+        LinkedList<Integer>[] list = new LinkedList[n + 1];\n+        for (int i = 0; i <= n; i++) list[i] = new LinkedList<>();\n+        for (int[] e : edge) {\n+            list[e[0]].add(e[1]);\n+            list[e[1]].add(e[0]);\n+        }\n+\n+        int[] dis = new int[n + 1];\n+        Arrays.fill(dis, -1);\n+        Queue<Integer> q = new LinkedList<>();\n+        q.add(1);\n+        dis[1] = 0;\n+        int max = 0;\n+        while (!q.isEmpty()) {\n+            int now = q.poll();\n+            for (int next : list[now]) {\n+                if (dis[next] != -1) continue;\n+                dis[next] = dis[now] + 1;\n+                max = Math.max(dis[next], max);\n+                q.add(next);\n+            }\n+        }\n+        for (int i = 1; i <= n; i++) {\n+            if (max == dis[i]) answer++;\n+        }\n         return answer;\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "cd8c78344dcd6a0aef462c412a4750b772d0751b",
    "filename": "src/test/java/week2/SolutionTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/jiaekim123/algorithm-study/blob/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/test/java/week2/SolutionTest.java",
    "raw_url": "https://github.com/jiaekim123/algorithm-study/raw/1d5b989a77d8d7279e25296ee34f45d5b303b46c/src/test/java/week2/SolutionTest.java",
    "contents_url": "https://api.github.com/repos/jiaekim123/algorithm-study/contents/src/test/java/week2/SolutionTest.java?ref=1d5b989a77d8d7279e25296ee34f45d5b303b46c",
    "patch": "@@ -8,6 +8,7 @@\n \n     @Test\n     void solution() {\n+//        assertEquals(1, new Solution().solution(5, 5)); // test case 9\n         assertEquals(4, new Solution().solution(5, 12));\n         assertEquals(3, new Solution().solution(2, 11));\n     }"
  }
]
