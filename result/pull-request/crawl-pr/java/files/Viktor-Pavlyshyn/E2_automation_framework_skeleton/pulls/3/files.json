[
  {
    "sha": "acb87a2a2c8116bb01f2fc3c62e0755d26ae684d",
    "filename": "src/main/java/com/epam/businessobject/BOProvider.java",
    "status": "modified",
    "additions": 5,
    "deletions": 6,
    "changes": 11,
    "blob_url": "https://github.com/Viktor-Pavlyshyn/E2_automation_framework_skeleton/blob/3b0bd405199a5f8c4d7a6d2b6d48222874fe5300/src/main/java/com/epam/businessobject/BOProvider.java",
    "raw_url": "https://github.com/Viktor-Pavlyshyn/E2_automation_framework_skeleton/raw/3b0bd405199a5f8c4d7a6d2b6d48222874fe5300/src/main/java/com/epam/businessobject/BOProvider.java",
    "contents_url": "https://api.github.com/repos/Viktor-Pavlyshyn/E2_automation_framework_skeleton/contents/src/main/java/com/epam/businessobject/BOProvider.java?ref=3b0bd405199a5f8c4d7a6d2b6d48222874fe5300",
    "patch": "@@ -1,20 +1,19 @@\n package com.epam.businessobject;\n \n+import java.util.Objects;\n+\n public class BOProvider {\n-//    TODO:\n-//    Try to rewrite using Optional\n-//    If you need verify if null, there is a native Objects.isNull() method\n-//\n+\n //    TODO:\n //    Rewrite usign Factory which will create by class name\n     private GoogleSearchBO googleSearchBO;\n     private ResultSearchGoogleBO resultSearchGoogleBO;\n \n     public GoogleSearchBO getGoogleSearchBO() {\n-        return (googleSearchBO == null) ? googleSearchBO = new GoogleSearchBO() : googleSearchBO;\n+        return Objects.isNull(googleSearchBO) ? googleSearchBO = new GoogleSearchBO() : googleSearchBO;\n     }\n \n     public ResultSearchGoogleBO getResultSearchGoogleBO() {\n-        return (resultSearchGoogleBO == null) ? resultSearchGoogleBO = new ResultSearchGoogleBO() : resultSearchGoogleBO;\n+        return Objects.isNull(resultSearchGoogleBO) ? resultSearchGoogleBO = new ResultSearchGoogleBO() : resultSearchGoogleBO;\n     }\n }"
  },
  {
    "sha": "a5873ea52dec619b1cd7bb80706ee809de99b458",
    "filename": "src/main/java/reflection/utils/ReflectionUtils.java",
    "status": "modified",
    "additions": 104,
    "deletions": 53,
    "changes": 157,
    "blob_url": "https://github.com/Viktor-Pavlyshyn/E2_automation_framework_skeleton/blob/3b0bd405199a5f8c4d7a6d2b6d48222874fe5300/src/main/java/reflection/utils/ReflectionUtils.java",
    "raw_url": "https://github.com/Viktor-Pavlyshyn/E2_automation_framework_skeleton/raw/3b0bd405199a5f8c4d7a6d2b6d48222874fe5300/src/main/java/reflection/utils/ReflectionUtils.java",
    "contents_url": "https://api.github.com/repos/Viktor-Pavlyshyn/E2_automation_framework_skeleton/contents/src/main/java/reflection/utils/ReflectionUtils.java?ref=3b0bd405199a5f8c4d7a6d2b6d48222874fe5300",
    "patch": "@@ -12,27 +12,50 @@\n import java.util.Objects;\n import java.util.stream.Stream;\n \n+import static org.junit.Assert.assertEquals;\n+\n public class ReflectionUtils {\n     private static Map<String, Boolean> methodMap = new LinkedHashMap<>();\n \n     private ReflectionUtils() {\n     }\n \n-    public static void setAnnotationValueByName(Object object, String name, String fieldAnnName,\n-                                                boolean valueAnn, Class<? extends Annotation> annotation) {\n-        try {\n-            Class clazz = object.getClass();\n-            Method methodWithAnn = clazz.getDeclaredMethod(name);\n-            Annotation myInvoke = methodWithAnn.getAnnotation(annotation);\n-            setValueForPrivateField(myInvoke, fieldAnnName, valueAnn);\n-        } catch (NoSuchMethodException e) {\n-            e.printStackTrace();\n-        }\n+    public static void setAnnotationValueByName(final Object object, final String nameMethod, final String fieldAnnName,\n+                                                final boolean valueAnn, final Class<? extends Annotation> annotation) {\n+\n+        Annotation invokeAnnotation = getDeclaredMethod(object, nameMethod).getAnnotation(annotation);\n+\n+        setValueForPrivateField(invokeAnnotation, fieldAnnName, valueAnn);\n+    }\n+\n+    public static int getCalculatedValue(final Object object, final String nameFieldWithAnn,\n+                                         final Class<? extends Annotation> annotation) {\n \n+        Stream.of(getDeclaredMethods(object))\n+                .filter(method -> method.isAnnotationPresent(annotation))\n+                .filter(method -> method.getAnnotation(Invoke.class).state())\n+                .forEach(method -> invokeMethod(object, method));\n+\n+        return (int) getValueFromPrivateField(object, nameFieldWithAnn);\n+    }\n+\n+    public static void saveAnnotation(Object object, Class<? extends Annotation> annotation) {\n+\n+        Stream.of(getDeclaredMethods(object))\n+                .filter(method -> method.isAnnotationPresent(annotation))\n+                .forEach(method -> methodMap.put(method.getName(), method.getAnnotation(Invoke.class).state()));\n+    }\n+\n+    public static void returnDefaultAnnotation(final Object object, final String fieldAnnName,\n+                                               final Class<? extends Annotation> annotation, boolean annotationValue) {\n+        Stream.of(getDeclaredMethods(object))\n+                .filter(method -> method.isAnnotationPresent(annotation))\n+                .filter(method -> method.getAnnotation(Invoke.class).state() != methodMap.get(method.getName()))\n+                .forEach(method -> setValueForPrivateField(method.getAnnotation(annotation), fieldAnnName, annotationValue));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    public static Object setValueForPrivateField(Annotation annotation, String key, Object newValue) {\n+    public static Object setValueForPrivateField(final Annotation annotation, final String key, final Object newValue) {\n //        TODO:\n //        - Why you go using Proxy?\n //        - The same. Combine in one line variable initialization and declaration\n@@ -61,64 +84,92 @@ public static Object setValueForPrivateField(Annotation annotation, String key,\n         return oldValue;\n     }\n \n-    public static int getCalculatedValue(Object object) {\n-        Class clazz = object.getClass();\n-\n-        Stream.of(getDeclaredMethods(object)).forEach(method -> {\n-            if (method.isAnnotationPresent(Invoke.class) && method.getAnnotation(Invoke.class).state()) {\n-                try {\n-                    method.invoke(object);\n-                } catch (IllegalAccessException | InvocationTargetException e) {\n-                    e.printStackTrace();\n-                }\n-            }\n-        });\n-//        for (Method method : methods) {\n-//            if (method.isAnnotationPresent(Invoke.class) && method.getAnnotation(Invoke.class).flag()) {\n-//                method.invoke(object);\n-//            }\n-//        }\n-\n-        Object declaredField = null;\n+    private static Method[] getDeclaredMethods(final Object object) {\n+        return object.getClass().getDeclaredMethods();\n+    }\n \n+    public static Method getDeclaredMethod(final Object object, final String name) {\n+        Method method = null;\n         try {\n-            Field field = clazz.getDeclaredField(\"sum\");\n+            method = object.getClass().getDeclaredMethod(name);\n+        } catch (NoSuchMethodException e) {\n+            e.printStackTrace();\n+        }\n+        return method;\n+    }\n+\n+    private static Object getAnnotationValue(final String name, final Class<? extends Annotation> annotation) {\n+        Object value = null;\n+        try {\n+            value = annotation.getDeclaredMethod(name).getDefaultValue();\n+        } catch (ReflectiveOperationException e) {\n+            e.printStackTrace();\n+        }\n+        return value;\n+    }\n+\n+    public static void setIntPrivateField(final Object object, final String nameField, final int fieldValue) {\n+\n+        try {\n+            Field field = object.getClass().getDeclaredField(nameField);\n+            boolean flag = field.isAccessible();\n+\n+            field.setAccessible(true);\n+            field.set(object, fieldValue);\n+            field.setAccessible(flag);\n+        } catch (ReflectiveOperationException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public static Object getValueFromPrivateField(final Object object, final String nameFieldWithAnn) {\n+\n+        Object declaredField = 0;\n+\n+        try {\n+            Field field = object.getClass().getDeclaredField(nameFieldWithAnn);\n \n             boolean flag = field.isAccessible();\n             field.setAccessible(true);\n \n             declaredField = field.get(object);\n \n             field.setAccessible(flag);\n-        } catch (NoSuchFieldException | IllegalAccessException e) {\n+        } catch (ReflectiveOperationException e) {\n             e.printStackTrace();\n         }\n-\n-        return (int) declaredField;\n+        return declaredField;\n     }\n \n-    public static void saveAnnotation(Object object) {\n-        Stream.of(getDeclaredMethods(object)).forEach(method -> {\n-            if (method.isAnnotationPresent(Invoke.class)) {\n-                boolean value = method.getAnnotation(Invoke.class).state();\n-                methodMap.put(method.getName(), value);\n-            }\n-        });\n+    public static Object invokeMethod(final Object object, final Method method) {\n+        Object value = null;\n+        try {\n+            value = method.invoke(object);\n+        } catch (ReflectiveOperationException e) {\n+            e.printStackTrace();\n+        }\n+        return value;\n     }\n \n-    public static void returnDefaultAnnotation(Object object) {\n-        Stream.of(getDeclaredMethods(object)).forEach(method -> {\n-            if (method.isAnnotationPresent(Invoke.class)) {\n-                boolean value = method.getAnnotation(Invoke.class).state();\n-                boolean storedValue = methodMap.get(method.getName());\n-                if (storedValue != value) {\n-                    setValueForPrivateField(method.getAnnotation(Invoke.class), \"state\", true);\n-                }\n-            }\n-        });\n+    public static Class getClazz(String className) {\n+        Class clazz = null;\n+        try {\n+            clazz = Class.forName(className);\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+        }\n+        return clazz;\n     }\n \n-    public static Method[] getDeclaredMethods(Object object){\n-        return object.getClass().getDeclaredMethods();\n+    public static Object getNewInstance(Class clazz) {\n+        Object object = null;\n+\n+        try {\n+            object = clazz.getConstructor().newInstance();\n+        } catch (ReflectiveOperationException e) {\n+            e.printStackTrace();\n+        }\n+\n+        return object;\n     }\n }"
  },
  {
    "sha": "a7ca54253da68716adde61342504bcc653ef4402",
    "filename": "src/test/java/com/epam/definitions/ReflectionDefinitions.java",
    "status": "modified",
    "additions": 18,
    "deletions": 64,
    "changes": 82,
    "blob_url": "https://github.com/Viktor-Pavlyshyn/E2_automation_framework_skeleton/blob/3b0bd405199a5f8c4d7a6d2b6d48222874fe5300/src/test/java/com/epam/definitions/ReflectionDefinitions.java",
    "raw_url": "https://github.com/Viktor-Pavlyshyn/E2_automation_framework_skeleton/raw/3b0bd405199a5f8c4d7a6d2b6d48222874fe5300/src/test/java/com/epam/definitions/ReflectionDefinitions.java",
    "contents_url": "https://api.github.com/repos/Viktor-Pavlyshyn/E2_automation_framework_skeleton/contents/src/test/java/com/epam/definitions/ReflectionDefinitions.java?ref=3b0bd405199a5f8c4d7a6d2b6d48222874fe5300",
    "patch": "@@ -5,11 +5,6 @@\n import io.cucumber.java.en.Then;\n import reflection.annotation.Invoke;\n \n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-\n import java.util.stream.Stream;\n \n import static org.junit.Assert.assertEquals;\n@@ -22,90 +17,49 @@\n     private Object object;\n \n     @Given(\"Class name - {string}\")\n-    public void intClass(String className) {\n-\n-        try {\n-            clazz = Class.forName(className);\n-            object = clazz.getConstructor().newInstance();\n-        } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) {\n-            e.printStackTrace();\n-        }\n+    public void intClass(final String className) {\n \n+        clazz = getClazz(className);\n+        object = getNewInstance(clazz);\n     }\n \n     @Then(\"Verify if current Object.getName equals {string}\")\n-    public void verifyClassName(String className) {\n+    public void verifyClassName(final String className) {\n \n         assertEquals(clazz.getName(), className);\n     }\n \n     @And(\"Set value - {int} in private field - {string}\")\n-    public void setValueInPrivateField(int fieldValue, String fieldName) {\n-\n-        try {\n-            Field field = clazz.getDeclaredField(fieldName);\n-            boolean flag = field.isAccessible();\n-\n-            field.setAccessible(true);\n-            field.set(object, fieldValue);\n-            field.setAccessible(flag);\n-        } catch (NoSuchFieldException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n+    public void setValueInPrivateField(final int fieldValue, final String fieldName) {\n \n+        setIntPrivateField(object, fieldName, fieldValue);\n     }\n \n     @Then(\"Verify if method - {string} return value - {int}\")\n-    public void verifyReturnValueOfMethod(String methodName, int fieldValue) {\n+    public void verifyReturnValueOfMethod(final String methodName, final int fieldValue) {\n \n-        try {\n-            assertEquals(clazz.getDeclaredMethod(methodName).invoke(object), fieldValue);\n-        } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n-            e.printStackTrace();\n-        }\n+        assertEquals(invokeMethod(object, getDeclaredMethod(object, methodName)), fieldValue);\n     }\n \n     @Then(\"Verify if field - {string} return value - {int}\")\n-    public void verifyFieldValue(String fieldName, int value){\n-\n-        int declaredField = 0;\n-\n-        try {\n-            Field field = clazz.getDeclaredField(fieldName);\n-            boolean flag = field.isAccessible();\n-            field.setAccessible(true);\n-\n-            declaredField = field.getInt(object);\n-            field.setAccessible(flag);\n-        } catch (NoSuchFieldException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-\n-\n-\n-        assertEquals(declaredField, value);\n+    public void verifyFieldValue(final String fieldName, final int value) {\n \n+        assertEquals(getValueFromPrivateField(object, fieldName), value);\n     }\n \n-    @Then(\"Verify method = {string} with annotation field name - {string} and value false  and expected sum = {int}\")\n-    public void verifyAnnotationValue(String nameMethod, String fieldAnnName, int expectedSum) {\n-\n-        saveAnnotation(object);\n+    @Then(\"Verify method = {string} with annotation field name - {string} and value false and expected sum = {int}\")\n+    public void verifyAnnotationValue(final String nameMethod, final String fieldAnnName, final int expectedSum) {\n \n-        Method[] listMethod = clazz.getDeclaredMethods();\n+        saveAnnotation(object, Invoke.class);\n \n-        Stream.of(listMethod).forEach(method -> {\n-            if (method.isAnnotationPresent(Invoke.class)){\n-                assertTrue(method.getAnnotation(Invoke.class).state());\n-            }\n-        });\n+        Stream.of(clazz.getDeclaredMethods())\n+                .filter(method -> method.isAnnotationPresent(Invoke.class))\n+                .forEach(method -> assertTrue(method.getAnnotation(Invoke.class).state()));\n \n         setAnnotationValueByName(object, nameMethod, fieldAnnName, false, Invoke.class);\n-        int sum = getCalculatedValue(object);\n \n-        assertEquals(sum, expectedSum);\n+        assertEquals(getCalculatedValue(object, \"sum\", Invoke.class), expectedSum);\n \n-        returnDefaultAnnotation(object);\n+        returnDefaultAnnotation(object, fieldAnnName, Invoke.class, true);\n     }\n-\n }"
  },
  {
    "sha": "12904abbac6fc6adb47274b15d7f063cff437fb2",
    "filename": "src/test/java/com/epam/runner/RunnerTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/Viktor-Pavlyshyn/E2_automation_framework_skeleton/blob/3b0bd405199a5f8c4d7a6d2b6d48222874fe5300/src/test/java/com/epam/runner/RunnerTest.java",
    "raw_url": "https://github.com/Viktor-Pavlyshyn/E2_automation_framework_skeleton/raw/3b0bd405199a5f8c4d7a6d2b6d48222874fe5300/src/test/java/com/epam/runner/RunnerTest.java",
    "contents_url": "https://api.github.com/repos/Viktor-Pavlyshyn/E2_automation_framework_skeleton/contents/src/test/java/com/epam/runner/RunnerTest.java?ref=3b0bd405199a5f8c4d7a6d2b6d48222874fe5300",
    "patch": "@@ -6,6 +6,6 @@\n \n @RunWith(Cucumber.class)\n @CucumberOptions(features = {\"src/test/resources/features\"},\n-        glue = {\"com/epam/definitions\"}, tags = \"@reflection\")\n+        glue = {\"com/epam/definitions\"})\n public class RunnerTest {\n }"
  },
  {
    "sha": "cebc49a9b50f3d74d9b2ff770782b854a8ff0009",
    "filename": "src/test/resources/features/reflection.feature",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/Viktor-Pavlyshyn/E2_automation_framework_skeleton/blob/3b0bd405199a5f8c4d7a6d2b6d48222874fe5300/src/test/resources/features/reflection.feature",
    "raw_url": "https://github.com/Viktor-Pavlyshyn/E2_automation_framework_skeleton/raw/3b0bd405199a5f8c4d7a6d2b6d48222874fe5300/src/test/resources/features/reflection.feature",
    "contents_url": "https://api.github.com/repos/Viktor-Pavlyshyn/E2_automation_framework_skeleton/contents/src/test/resources/features/reflection.feature?ref=3b0bd405199a5f8c4d7a6d2b6d48222874fe5300",
    "patch": "@@ -25,7 +25,7 @@ Feature: Refactor Reflection tests\n \n   Scenario Outline: Additional task\n     Given Class name - <className>\n-    Then Verify method = <nameMethod> with annotation field name - <fieldAnnName> and value false  and expected sum = <sum>\n+    Then Verify method = <nameMethod> with annotation field name - <fieldAnnName> and value false and expected sum = <sum>\n     Examples:\n       | className                  | nameMethod  | sum | fieldAnnName |\n       | \"reflection.data.SumClass\" | \"plusThree\" | 3   | \"state\"      |"
  }
]
