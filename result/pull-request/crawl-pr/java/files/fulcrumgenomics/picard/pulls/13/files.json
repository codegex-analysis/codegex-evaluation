[
  {
    "sha": "43be35da21ae743e6c2c5d8a858189458dfaaf9a",
    "filename": "src/main/java/picard/illumina/BarcodeExtractor.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/fulcrumgenomics/picard/blob/fe2ab51302641e89410c53c8587ce2f23f2e0227/src/main/java/picard/illumina/BarcodeExtractor.java",
    "raw_url": "https://github.com/fulcrumgenomics/picard/raw/fe2ab51302641e89410c53c8587ce2f23f2e0227/src/main/java/picard/illumina/BarcodeExtractor.java",
    "contents_url": "https://api.github.com/repos/fulcrumgenomics/picard/contents/src/main/java/picard/illumina/BarcodeExtractor.java?ref=fe2ab51302641e89410c53c8587ce2f23f2e0227",
    "patch": "@@ -22,7 +22,7 @@\n     private final int maxNoCalls, maxMismatches, minMismatchDelta, minimumBaseQuality;\n     private final DistanceMetric distanceMode;\n     private final static int INITIAL_LOOKUP_SIZE = 4096;\n-    private final ConcurrentHashMap<ByteString, BarcodeMatch> barcodeLookupMap = new ConcurrentHashMap<>(INITIAL_LOOKUP_SIZE);\n+    private final HashMap<ByteString, BarcodeMatch> barcodeLookupMap = new HashMap<>(INITIAL_LOOKUP_SIZE);\n \n     public BarcodeExtractor(final Map<String, BarcodeMetric> barcodeToMetrics,\n                             final BarcodeMetric noMatchMetric,"
  },
  {
    "sha": "73a6a18f9324feec4fc51047dd9d00061cfd0948",
    "filename": "src/main/java/picard/illumina/UnsortedBasecallsConverter.java",
    "status": "modified",
    "additions": 47,
    "deletions": 6,
    "changes": 53,
    "blob_url": "https://github.com/fulcrumgenomics/picard/blob/fe2ab51302641e89410c53c8587ce2f23f2e0227/src/main/java/picard/illumina/UnsortedBasecallsConverter.java",
    "raw_url": "https://github.com/fulcrumgenomics/picard/raw/fe2ab51302641e89410c53c8587ce2f23f2e0227/src/main/java/picard/illumina/UnsortedBasecallsConverter.java",
    "contents_url": "https://api.github.com/repos/fulcrumgenomics/picard/contents/src/main/java/picard/illumina/UnsortedBasecallsConverter.java?ref=fe2ab51302641e89410c53c8587ce2f23f2e0227",
    "patch": "@@ -4,6 +4,7 @@\n import htsjdk.io.Writer;\n import htsjdk.samtools.util.Log;\n import htsjdk.samtools.util.ProgressLogger;\n+import picard.PicardException;\n import picard.illumina.parser.BaseIlluminaDataProvider;\n import picard.illumina.parser.ClusterData;\n import picard.illumina.parser.IlluminaDataProviderFactory;\n@@ -16,6 +17,10 @@\n import java.util.Map;\n import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n /**\n  * UnortedBasecallsConverter utilizes an underlying IlluminaDataProvider to convert parsed and decoded sequencing data\n@@ -85,34 +90,70 @@ protected UnsortedBasecallsConverter(\n      */\n     @Override\n     public void processTilesAndWritePerSampleOutputs(final Set<String> barcodes) throws IOException {\n-        Map<String, BarcodeMetric> metrics = null;\n-        BarcodeMetric noMatch = null;\n-        if(barcodeExtractor != null) {\n+        final Map<String, BarcodeMetric> metrics;\n+        final BarcodeMetric noMatch;\n+\n+        if (barcodeExtractor != null) {\n             metrics = new LinkedHashMap<>(barcodeExtractor.getMetrics().size());\n             for (final String key : barcodeExtractor.getMetrics().keySet()) {\n                 metrics.put(key, barcodeExtractor.getMetrics().get(key).copy());\n             }\n \n             noMatch = barcodeExtractor.getNoMatchMetric().copy();\n         }\n+        else {\n+            metrics = null;\n+            noMatch = null;\n+        }\n+\n         for(IlluminaDataProviderFactory laneFactory : laneFactories) {\n+            final BlockingQueue<ClusterData> queue = new ArrayBlockingQueue<>(100000);\n+\n+            final Runnable router = new Runnable() {\n+                @Override public void run() {\n+                    while (true) {\n+                        try {\n+                            final ClusterData cluster = queue.take();\n+                            if (cluster.getNumReads() == 0) break;  // Signifies end of processing\n+                            final String barcode = maybeDemultiplex(cluster, metrics, noMatch, laneFactory);\n+                            barcodeRecordWriterMap.get(barcode).write(converter.convertClusterToOutputRecord(cluster));\n+                            progressLogger.record(null, 0);\n+\n+                        }\n+                        catch (InterruptedException ie) {\n+                            throw new PicardException(\"Ooooops\", ie);\n+                        }\n+                    }\n+                }\n+            };\n+\n+            final Thread routerThread = new Thread(router, \"DemultiplexingThread\");\n+            routerThread.start();\n+\n             for (Integer tileNum : tiles) {\n                 if (laneFactory.getAvailableTiles().contains(tileNum)) {\n                     final BaseIlluminaDataProvider dataProvider = laneFactory.makeDataProvider(tileNum);\n \n                     while (dataProvider.hasNext()) {\n                         final ClusterData cluster = dataProvider.next();\n                         if (includeNonPfReads || cluster.isPf()) {\n-                            final String barcode = maybeDemultiplex(cluster, metrics, noMatch, laneFactory);\n-                            barcodeRecordWriterMap.get(barcode).write(converter.convertClusterToOutputRecord(cluster));\n-                            progressLogger.record(null, 0);\n+                            try { queue.put(cluster); }\n+                            catch (InterruptedException ie) { throw new PicardException(\"Ooopsie\", ie); }\n                         }\n                     }\n                     dataProvider.close();\n                 }\n             }\n             updateMetrics(metrics, noMatch);\n+\n+            try {\n+                // Drop an empty item into the router queue and wait for the router thread to exit\n+                queue.put(new ClusterData());\n+                routerThread.join();\n+            }\n+            catch (InterruptedException ie) { throw new PicardException(\"Oops\", ie); }\n         }\n+\n         closeWriters();\n     }\n }"
  }
]
