[
  {
    "sha": "72f6729fc8641030ef844655b5182e9b60b968b2",
    "filename": "core/assets/bundles/bundle.properties",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/Anuken/Mindustry/blob/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/assets/bundles/bundle.properties",
    "raw_url": "https://github.com/Anuken/Mindustry/raw/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/assets/bundles/bundle.properties",
    "contents_url": "https://api.github.com/repos/Anuken/Mindustry/contents/core/assets/bundles/bundle.properties?ref=92976adc6702ef0c9ce71f33777a8ce6b87a3ec7",
    "patch": "@@ -448,6 +448,8 @@ toolmode.fillteams = Fill Teams\n toolmode.fillteams.description = Fill teams instead of blocks.\n toolmode.drawteams = Draw Teams\n toolmode.drawteams.description = Draw teams instead of blocks.\n+toolmode.controls = controls\n+toolmode.controls.description = ctrl+c ctrl+v ctrl+wheel x y\n \n filters.empty = [lightgray]No filters! Add one with the button below.\n filter.distort = Distort"
  },
  {
    "sha": "a8e92cf67293f9b69b2ace1e3ef99f41d426c276",
    "filename": "core/src/mindustry/editor/Copy.java",
    "status": "added",
    "additions": 395,
    "deletions": 0,
    "changes": 395,
    "blob_url": "https://github.com/Anuken/Mindustry/blob/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/editor/Copy.java",
    "raw_url": "https://github.com/Anuken/Mindustry/raw/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/editor/Copy.java",
    "contents_url": "https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/editor/Copy.java?ref=92976adc6702ef0c9ce71f33777a8ce6b87a3ec7",
    "patch": "@@ -0,0 +1,395 @@\n+package mindustry.editor;\n+\n+import arc.func.*;\n+import arc.math.*;\n+import arc.math.geom.*;\n+import arc.struct.*;\n+import arc.util.*;\n+import mindustry.content.*;\n+import mindustry.game.*;\n+import mindustry.world.*;\n+import mindustry.world.blocks.environment.*;\n+import mindustry.world.blocks.power.*;\n+\n+import static mindustry.Vars.world;\n+\n+/**\n+ * Class that holds data about selected tiles. It handles rotation of selection, clamping copying and pasting.\n+ */\n+public class Copy{\n+\n+    int\n+    ox, oy, // original position\n+    sx, sy, // drag handle\n+    px, py, // selection origin\n+    dx, dy, // selection offset\n+    fw, fh, // fake width height\n+    w, h;   // size of selection\n+\n+    private final Point2 tmp = new Point2();\n+\n+    private CTile[][] main, rotated; // to make rotation faster differently composed space is pre-allocated\n+    private final Seq<CTile> pool = new Seq<>(); // to reuse tiles\n+\n+    public Seq<Point2> lines = new Seq<>(), linePool = new Seq<>();\n+    final int lineLimit = 100000;\n+\n+    private final Template[] templates = {\n+    new Template(0, 1, 0, 1, 1, 1),\n+    new Template(1, 0, 1, 0, 1, 1),\n+    };\n+\n+    public Copy(){\n+        clear(); // to init the min and rotated\n+    }\n+\n+    public void setOrigin(int x, int y){\n+        // prevent off map origin\n+        px = clampW(x);\n+        py = clampH(y);\n+    }\n+\n+    public void adjust(int x, int y){\n+        // prevent off map origin\n+        x = clampW(x);\n+        y = clampH(y);\n+\n+        // + 1 because it loops nicer then\n+        fw = Math.abs(px - x) + 1;\n+        fh = Math.abs(py - y) + 1;\n+        dx = ox = Math.min(px, x);\n+        dy = oy = Math.min(py, y);\n+    }\n+\n+    public boolean empty(){\n+        return h == 0 || w == 0;\n+    }\n+\n+    public void clear(){\n+        fw = 0;\n+        fh = 0;\n+        resize();\n+    }\n+\n+    public void copy(){\n+        ox = dx;\n+        oy = dy;\n+        resize();\n+\n+        loop(w, h, (x, y) -> {\n+            CTile t = pool.pop(CTile::new);\n+\n+            t.copy(world.tile(x + dx, y + dy));\n+            main[y][x] = t;\n+        });\n+\n+\n+        outlines();\n+    }\n+\n+    public void paste(){\n+        // clamp it as moving selection out of the map can be useful\n+        int\n+        stx = Math.max(dx, 0),\n+        sty = Math.max(dy, 0),\n+        edx = Math.min(dx + w, world.width()),\n+        edy = Math.min(dy + h, world.height());\n+\n+        // we don't want garbage blocks, but also don't want to remove new blocks\n+        loop(stx, sty, edx, edy, (x, y) -> world.tile(x, y).remove());\n+        // paste everything but config\n+        loop(stx, sty, edx, edy, (x, y) -> main[y - dy][x - dx].paste(world.tile(x, y)));\n+        // final paste, because of power nodes issues\n+        loop(stx, sty, edx, edy, (x, y) -> main[y - dy][x - dx].pasteConfig(world.tile(x, y)));\n+    }\n+\n+    public void rotR(){\n+        flipX(false);\n+        flipD();\n+\n+        outlines();\n+    }\n+\n+    public void rotL(){\n+        flipY(false);\n+        flipD();\n+\n+        outlines();\n+    }\n+\n+    public void flipX(boolean alone){\n+        loop(w / 2, h, (x, y) -> swap(x, y, w - x - 1, y));\n+\n+        config(p -> p.x = -p.x, 2);\n+\n+        loop(w, h, (x, y) -> flipConnections(x, y, -1, 0));\n+        loop(w, h, (x, y) -> flipMultiBlock(x, y, -1, 0));\n+\n+        if(alone){\n+            outlines();\n+        }\n+    }\n+\n+\n+    public void flipY(boolean alone){\n+        loop(w, h / 2, (x, y) -> swap(x, y, x, h - y - 1));\n+\n+        config(p -> p.y = -p.y, 2);\n+\n+        loop(w, h, (x, y) -> flipConnections(x, y, 0, -1));\n+        loop(w, h, (x, y) -> flipMultiBlock(x, y, 0, -1));\n+\n+        if(alone){\n+            outlines();\n+        }\n+    }\n+\n+    private void outlines(){\n+        if(w * h > lineLimit) return;\n+\n+        clearLines();\n+\n+        loop(w, h, (x, y) -> {\n+            for(Template t : templates){\n+                tmp.set(x, y).add(t.offset);\n+\n+                if(!containsRaw(tmp.x, tmp.y)) continue;\n+                if(main[y][x].equal(main[tmp.y][tmp.x])) continue;\n+\n+                addLinePoint(x, y, t.a);\n+                addLinePoint(x, y, t.b);\n+            }\n+        });\n+    }\n+\n+    void clearLines(){\n+        linePool.addAll(lines);\n+        lines.clear();\n+    }\n+\n+    private void addLinePoint(int x, int y, Point2 o){\n+        Point2 p = linePool.pop(Point2::new);\n+        tmp.set(x, y).add(o);\n+        p.set(tmp);\n+        lines.add(p);\n+    }\n+\n+    public void flipMultiBlock(int x, int y, int dx, int dy){\n+        CTile a = main[y][x];\n+        if(a.doNotFlip()) return;\n+\n+\n+        // can happen\n+        if(x == 0 || y == 0){\n+            a.build.block = null;\n+            return;\n+        }\n+\n+        CTile b = main[y + dy][x + dx];\n+        CTile.Build tmp = a.build;\n+        a.build = b.build;\n+        b.build = tmp;\n+    }\n+\n+    public void flipConnections(int x, int y, int dx, int dy){\n+        CTile a = main[y][x];\n+        boolean noFlip = a.doNotFlip();\n+\n+        // this is driving me crazy, reason is that if both blocks have to be flipped or both not\n+        // do nothing, if a is flipped, go opposite of flip, if reverse go in direction of flip\n+        if(a.build.config instanceof Point2 p){\n+            if(!containsRaw(x + p.x, y + p.y)) return;\n+            CTile t = main[y + p.y][x + p.x];\n+            boolean oNoFlip = t.doNotFlip();\n+            if(oNoFlip && !noFlip){\n+                p.sub(dx, dy);\n+            }else if(!oNoFlip && noFlip){\n+                p.add(dx, dy);\n+            }\n+        }else if(a.build.config instanceof Point2[] points){\n+            for(Point2 p : points){\n+                if(!containsRaw(x + p.x, y + p.y)) continue;\n+                CTile t = main[y + p.y][x + p.x];\n+                boolean oNoFlip = t.doNotFlip();\n+                if(oNoFlip && !noFlip){\n+                    p.sub(dx, dy);\n+                }else if(!oNoFlip && noFlip){\n+                    p.add(dx, dy);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    public void flipD(){\n+        config(p -> p.set(p.y, p.x), 1);\n+\n+        loop(w, h, (x, y) -> swap(x, y, y, x, main, rotated));\n+\n+        int t = w;\n+        w = h;\n+        h = t;\n+\n+        CTile[][] u = main;\n+        main = rotated;\n+        rotated = u;\n+    }\n+\n+    private void config(Cons<Point2> con, int shift){\n+        loop(w, h, t -> {\n+            t.build.rotation += shift;\n+\n+            if(t.build.config instanceof Point2 p){\n+                con.get(p);\n+            }else if(t.build.config instanceof Point2[] ps){\n+                for(Point2 p : ps){\n+                    con.get(p);\n+                }\n+            }\n+        });\n+    }\n+\n+    private void resize(){\n+        w = fw;\n+        h = fh;\n+        // collect garbage\n+        if(main != null && main.length != 0) loop(main[0].length, main.length, t -> pool.add(t));\n+\n+        main = new CTile[h][w];\n+        rotated = new CTile[w][h];\n+    }\n+\n+    private void swap(int sx, int sy, int dx, int dy){\n+        swap(sx, sy, dx, dy, main, main);\n+    }\n+\n+    // swap swaps value from one 2D array with value of another\n+    private void swap(int sx, int sy, int dx, int dy, CTile[][] src, CTile[][] dst){\n+        CTile t = dst[dy][dx];\n+        dst[dy][dx] = src[sy][sx];\n+        src[sy][sx] = t;\n+    }\n+\n+    private void loop(int w, int h, Cons<CTile> cons){\n+        loop(0, 0, w, h, (x, y) -> cons.get(main[y][x]));\n+    }\n+\n+    private void loop(int w, int h, Looper looper){\n+        loop(0, 0, w, h, looper);\n+    }\n+\n+    private void loop(int stx, int sty, int edx, int edy, Looper looper){\n+        // i don't like repetitive nested loops that all\n+        for(int y = sty; y < edy; y++){\n+            for(int x = stx; x < edx; x++){\n+                looper.pos(x, y);\n+            }\n+        }\n+    }\n+\n+    public void center(int x, int y){\n+        select(dx + w / 2, dy + h / 2);\n+        move(x, y);\n+    }\n+\n+    public void select(int x, int y){\n+        sx = x - dx;\n+        sy = y - dy;\n+    }\n+\n+    public void move(int x, int y){\n+        dx += x - (sx + dx);\n+        dy += y - (sy + dy);\n+\n+        if(empty()){\n+            ox = dx;\n+            oy = dy;\n+        }\n+    }\n+\n+    public boolean contains(int x, int y){\n+        return dx <= x && dy <= y && dx + w >= x && dy + h >= y;\n+    }\n+\n+    private boolean containsRaw(int x, int y){\n+        return 0 <= x && 0 <= y && w > x && h > y;\n+    }\n+\n+    private int clampW(int x){\n+        return Mathf.clamp(x, 0, world.width() - 1);\n+    }\n+\n+    private int clampH(int y){\n+        return Mathf.clamp(y, 0, world.height() - 1);\n+    }\n+\n+    /** Data container used for transporting copy data. */\n+    private static class CTile{\n+        Block overlay;\n+        Floor floor;\n+        Build build = new Build();\n+\n+        boolean equal(CTile o){\n+            return top().equals(o.top());\n+        }\n+\n+        Block top(){\n+            return build.trueBlock.solid || build.trueBlock.breakable ? build.trueBlock : !overlay.useColor ? floor : overlay;\n+        }\n+\n+        void copy(Tile t){\n+            floor = t.floor();\n+            overlay = t.overlay();\n+            build.block = t.block();\n+            build.trueBlock = build.block;\n+            if(!t.isCenter()){\n+                build.block = null;\n+            }else if(t.build != null){\n+                build.team = t.build.team();\n+                build.config = t.build.config();\n+                build.rotation = t.build.rotation();\n+            }\n+        }\n+\n+        void paste(Tile t){\n+            if(build.block != null){\n+                t.setBlock(build.block, build.team, build.rotation);\n+            }\n+\n+            t.setFloor(floor);\n+            t.setOverlay(overlay);\n+        }\n+\n+        boolean doNotFlip(){\n+            return build.block == null || build.block.size % 2 == 1;\n+        }\n+\n+        void pasteConfig(Tile t){\n+            if(t.build != null){\n+                t.build.configure(build.config);\n+            }\n+        }\n+\n+        private static class Build{\n+            Block block, trueBlock;\n+            int rotation;\n+            Object config;\n+            Team team;\n+        }\n+    }\n+\n+    static class Template{\n+        Point2 offset, a, b;\n+\n+        Template(int ox, int oy, int ax, int ay, int bx, int by){\n+            offset = new Point2(ox, oy);\n+            a = new Point2(ax, ay);\n+            b = new Point2(bx, by);\n+        }\n+    }\n+\n+    interface Looper{\n+        void pos(int x, int y);\n+    }\n+\n+}"
  },
  {
    "sha": "89e21e3ca4f7474a652dcfce7ce78044b8edb1a0",
    "filename": "core/src/mindustry/editor/EditorTool.java",
    "status": "modified",
    "additions": 12,
    "deletions": 8,
    "changes": 20,
    "blob_url": "https://github.com/Anuken/Mindustry/blob/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/editor/EditorTool.java",
    "raw_url": "https://github.com/Anuken/Mindustry/raw/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/editor/EditorTool.java",
    "contents_url": "https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/editor/EditorTool.java?ref=92976adc6702ef0c9ce71f33777a8ce6b87a3ec7",
    "patch": "@@ -21,7 +21,6 @@ public void touched(MapEditor editor, int x, int y){\n         }\n     },\n     line(KeyCode.l, \"replace\", \"orthogonal\"){\n-\n         @Override\n         public void touchedLine(MapEditor editor, int x1, int y1, int x2, int y2){\n             //straight\n@@ -167,7 +166,7 @@ void fill(MapEditor editor, int x, int y, boolean replace, Boolf<Tile> tester, C\n                 stack.add(Point2.pack(x, y));\n \n                 try{\n-                    while(stack.size > 0 && stack.size < width*height){\n+                    while(stack.size > 0 && stack.size < width * height){\n                         int popped = stack.pop();\n                         x = Point2.x(popped);\n                         y = Point2.y(popped);\n@@ -230,19 +229,22 @@ public void touched(MapEditor editor, int x, int y){\n                 editor.drawBlocks(x, y, tile -> Mathf.chance(chance));\n             }\n         }\n-    };\n+    },\n+    copy(KeyCode.c, \"controls\"),\n+    flip,\n+    rotate;\n \n     public static final EditorTool[] all = values();\n \n     /** All the internal alternate placement modes of this tool. */\n     public final String[] altModes;\n     /** Key to activate this tool. */\n     public KeyCode key = KeyCode.unset;\n-    /** The current alternate placement mode. -1 is the standard mode, no changes.*/\n+    /** The current alternate placement mode. -1 is the standard mode, no changes. */\n     public int mode = -1;\n-    /** Whether this tool causes canvas changes when touched.*/\n+    /** Whether this tool causes canvas changes when touched. */\n     public boolean edit;\n-    /** Whether this tool should be dragged across the canvas when the mouse moves.*/\n+    /** Whether this tool should be dragged across the canvas when the mouse moves. */\n     public boolean draggable;\n \n     EditorTool(){\n@@ -263,7 +265,9 @@ public void touched(MapEditor editor, int x, int y){\n         this.key = code;\n     }\n \n-    public void touched(MapEditor editor, int x, int y){}\n+    public void touched(MapEditor editor, int x, int y){\n+    }\n \n-    public void touchedLine(MapEditor editor, int x1, int y1, int x2, int y2){}\n+    public void touchedLine(MapEditor editor, int x1, int y1, int x2, int y2){\n+    }\n }"
  },
  {
    "sha": "57bc98e737f3559866a7a33f7e0ce68cedd25961",
    "filename": "core/src/mindustry/editor/MapEditor.java",
    "status": "modified",
    "additions": 4,
    "deletions": 1,
    "changes": 5,
    "blob_url": "https://github.com/Anuken/Mindustry/blob/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/editor/MapEditor.java",
    "raw_url": "https://github.com/Anuken/Mindustry/raw/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/editor/MapEditor.java",
    "contents_url": "https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/editor/MapEditor.java?ref=92976adc6702ef0c9ce71f33777a8ce6b87a3ec7",
    "patch": "@@ -33,6 +33,9 @@\n     public Block drawBlock = Blocks.stone;\n     public Team drawTeam = Team.sharded;\n \n+    // if editor is not dropped, you can copy between maps\n+    public Copy copyData = new Copy();\n+\n     public boolean isLoading(){\n         return loading;\n     }\n@@ -52,7 +55,7 @@ public void beginEdit(Map map){\n         loading = true;\n         tags.putAll(map.tags);\n         if(map.file.parent().parent().name().equals(\"1127400\") && steam){\n-            tags.put(\"steamid\",  map.file.parent().name());\n+            tags.put(\"steamid\", map.file.parent().name());\n         }\n         load(() -> MapIO.loadMap(map, context));\n         renderer.resize(width(), height());"
  },
  {
    "sha": "9d3b5566479b6f7ae592fdaa34558607e2e0ffe8",
    "filename": "core/src/mindustry/editor/MapEditorDialog.java",
    "status": "modified",
    "additions": 76,
    "deletions": 31,
    "changes": 107,
    "blob_url": "https://github.com/Anuken/Mindustry/blob/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/editor/MapEditorDialog.java",
    "raw_url": "https://github.com/Anuken/Mindustry/raw/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/editor/MapEditorDialog.java",
    "contents_url": "https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/editor/MapEditorDialog.java?ref=92976adc6702ef0c9ce71f33777a8ce6b87a3ec7",
    "patch": "@@ -21,6 +21,7 @@\n import mindustry.game.*;\n import mindustry.gen.*;\n import mindustry.graphics.*;\n+import mindustry.input.*;\n import mindustry.io.*;\n import mindustry.maps.*;\n import mindustry.ui.*;\n@@ -88,30 +89,30 @@ public MapEditorDialog(){\n             t.row();\n \n             t.button(\"@editor.import\", Icon.download, () -> createDialog(\"@editor.import\",\n-                \"@editor.importmap\", \"@editor.importmap.description\", Icon.download, (Runnable)loadDialog::show,\n-                \"@editor.importfile\", \"@editor.importfile.description\", Icon.file, (Runnable)() ->\n-                platform.showFileChooser(true, mapExtension, file -> ui.loadAnd(() -> {\n-                    maps.tryCatchMapError(() -> {\n-                        if(MapIO.isImage(file)){\n-                            ui.showInfo(\"@editor.errorimage\");\n-                        }else{\n-                            editor.beginEdit(MapIO.createMap(file, true));\n-                        }\n-                    });\n-                })),\n-\n-                \"@editor.importimage\", \"@editor.importimage.description\", Icon.fileImage, (Runnable)() ->\n-                platform.showFileChooser(true, \"png\", file ->\n-                ui.loadAnd(() -> {\n-                    try{\n-                        Pixmap pixmap = new Pixmap(file);\n-                        editor.beginEdit(pixmap);\n-                        pixmap.dispose();\n-                    }catch(Exception e){\n-                        ui.showException(\"@editor.errorload\", e);\n-                        Log.err(e);\n+            \"@editor.importmap\", \"@editor.importmap.description\", Icon.download, (Runnable)loadDialog::show,\n+            \"@editor.importfile\", \"@editor.importfile.description\", Icon.file, (Runnable)() ->\n+            platform.showFileChooser(true, mapExtension, file -> ui.loadAnd(() -> {\n+                maps.tryCatchMapError(() -> {\n+                    if(MapIO.isImage(file)){\n+                        ui.showInfo(\"@editor.errorimage\");\n+                    }else{\n+                        editor.beginEdit(MapIO.createMap(file, true));\n                     }\n-                })))\n+                });\n+            })),\n+\n+            \"@editor.importimage\", \"@editor.importimage.description\", Icon.fileImage, (Runnable)() ->\n+            platform.showFileChooser(true, \"png\", file ->\n+            ui.loadAnd(() -> {\n+                try{\n+                    Pixmap pixmap = new Pixmap(file);\n+                    editor.beginEdit(pixmap);\n+                    pixmap.dispose();\n+                }catch(Exception e){\n+                    ui.showException(\"@editor.errorload\", e);\n+                    Log.err(e);\n+                }\n+            })))\n             );\n \n             t.button(\"@editor.export\", Icon.upload, () -> createDialog(\"@editor.export\",\n@@ -257,23 +258,24 @@ private void playtest(){\n                 \"height\", editor.height()\n             ));\n             world.endMapLoad();\n-            player.set(world.width() * tilesize/2f, world.height() * tilesize/2f);\n+            player.set(world.width() * tilesize / 2f, world.height() * tilesize / 2f);\n             player.clearUnit();\n             Groups.unit.clear();\n             Groups.build.clear();\n             Groups.weather.clear();\n             logic.play();\n \n             if(player.team().core() == null){\n-                player.set(world.width() * tilesize/2f, world.height() * tilesize/2f);\n+                player.set(world.width() * tilesize / 2f, world.height() * tilesize / 2f);\n                 var unit = UnitTypes.alpha.spawn(player.team(), player.x, player.y);\n                 unit.spawnedByCore = true;\n                 player.unit(unit);\n             }\n         });\n     }\n \n-    public @Nullable Map save(){\n+    public @Nullable\n+    Map save(){\n         boolean isEditor = state.rules.editor;\n         state.rules.editor = false;\n         String name = editor.tags.get(\"name\", \"\").trim();\n@@ -304,7 +306,7 @@ private void playtest(){\n         return returned;\n     }\n \n-    /** Called when a built-in map save is attempted.*/\n+    /** Called when a built-in map save is attempted. */\n     protected void handleSaveBuiltin(Map map){\n         ui.showErrorMessage(\"@editor.save.overwrite\");\n     }\n@@ -412,7 +414,6 @@ public void build(){\n                 Table[] lastTable = {null};\n \n                 Cons<EditorTool> addTool = tool -> {\n-\n                     ImageButton button = new ImageButton(ui.getIcon(tool.name()), Styles.clearTogglei);\n                     button.clicked(() -> {\n                         view.setTool(tool);\n@@ -487,6 +488,13 @@ public void build(){\n                     tools.stack(button, mode);\n                 };\n \n+                Color transparent = new Color(0, 0, 0, 0);\n+                CopyToolAdder copyTool = (icon, func, cond) -> {\n+                    ImageButton flip = tools.button(icon, Styles.cleari, func).get();\n+                    flip.setDisabled(cond);\n+                    flip.update(() -> flip.getImage().setColor(flip.isDisabled() ? transparent : Color.white));\n+                };\n+\n                 tools.defaults().size(size, size);\n \n                 tools.button(Icon.menu, Styles.cleari, menu::show);\n@@ -521,11 +529,31 @@ public void build(){\n                 addTool.get(EditorTool.spray);\n \n                 ImageButton rotate = tools.button(Icon.right, Styles.cleari, () -> editor.rotation = (editor.rotation + 1) % 4).get();\n+                rotate.updateVisibility();\n                 rotate.getImage().update(() -> {\n                     rotate.getImage().setRotation(editor.rotation * 90);\n                     rotate.getImage().setOrigin(Align.center);\n                 });\n \n+                tools.row();\n+\n+                Copy c = editor.copyData;\n+                addTool.get(EditorTool.copy);\n+                Boolp con1 = () -> view.tool != EditorTool.copy || (c.fh == 0 || c.fw == 0) ;\n+                copyTool.add(Icon.upload, c::copy, con1);\n+                copyTool.add(Icon.download, () -> {\n+                    c.paste();\n+                    editor.flushOp();\n+                }, con1);\n+\n+                tools.row();\n+\n+                Boolp con2 = () -> !view.copy();\n+                copyTool.add(Icon.flipX, () -> c.flipX(true), con2);\n+                copyTool.add(Icon.flipY, () -> c.flipY(true), con2);\n+                copyTool.add(Icon.rotate, c::rotR, con2);\n+\n+\n                 tools.row();\n \n                 tools.table(Tex.underline, t -> t.add(\"@editor.teams\"))\n@@ -595,15 +623,28 @@ public void build(){\n     }\n \n     private void doInput(){\n-\n+        Copy c = editor.copyData;\n         if(Core.input.ctrl()){\n+            if(view.tool == EditorTool.copy){\n+                if(Core.input.keyTap(Binding.editor_copy)){\n+                    c.copy();\n+                }else if(Core.input.keyTap(Binding.editor_paste)){\n+                    c.paste();\n+                    editor.flushOp();\n+                }\n+            }\n             //alt mode select\n             for(int i = 0; i < view.getTool().altModes.length; i++){\n                 if(i + 1 < KeyCode.numbers.length && Core.input.keyTap(KeyCode.numbers[i + 1])){\n                     view.getTool().mode = i;\n                 }\n             }\n         }else{\n+            if(Core.input.keyTap(Binding.editor_copy_flip_x)){\n+                c.flipX(true);\n+            }else if(Core.input.keyTap(Binding.editor_copy_flip_y)){\n+                c.flipY(true);\n+            }\n             for(EditorTool tool : EditorTool.all){\n                 if(Core.input.keyTap(tool.key)){\n                     view.setTool(tool);\n@@ -717,8 +758,8 @@ private void rebuildBlockSelection(String searchText){\n             TextureRegion region = block.icon(Cicon.medium);\n \n             if(!Core.atlas.isFound(region) || !block.inEditor\n-                    || block.buildVisibility == BuildVisibility.debugOnly\n-                    || (!searchText.isEmpty() && !block.localizedName.toLowerCase().contains(searchText.toLowerCase()))\n+                || block.buildVisibility == BuildVisibility.debugOnly\n+                || (!searchText.isEmpty() && !block.localizedName.toLowerCase().contains(searchText.toLowerCase()))\n             ) continue;\n \n             ImageButton button = new ImageButton(Tex.whiteui, Styles.clearTogglei);\n@@ -739,4 +780,8 @@ private void rebuildBlockSelection(String searchText){\n             blockSelection.add(\"@none\").color(Color.lightGray).padLeft(80f).padTop(10f);\n         }\n     }\n+\n+    interface CopyToolAdder {\n+        void add(TextureRegionDrawable t, Runnable r, Boolp c);\n+    }\n }"
  },
  {
    "sha": "1ee2f0bc51665aea5d3ca83d8438bce6bb25f9a2",
    "filename": "core/src/mindustry/editor/MapView.java",
    "status": "modified",
    "additions": 80,
    "deletions": 11,
    "changes": 91,
    "blob_url": "https://github.com/Anuken/Mindustry/blob/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/editor/MapView.java",
    "raw_url": "https://github.com/Anuken/Mindustry/raw/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/editor/MapView.java",
    "contents_url": "https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/editor/MapView.java?ref=92976adc6702ef0c9ce71f33777a8ce6b87a3ec7",
    "patch": "@@ -26,6 +26,7 @@\n     private boolean grid = false;\n     private GridImage image = new GridImage(0, 0);\n     private Vec2 vec = new Vec2();\n+    private Point2 point = new Point2();\n     private Rect rect = new Rect();\n     private Vec2[][] brushPolygons = new Vec2[MapEditor.brushSizes.length][0];\n \n@@ -54,6 +55,7 @@ public MapView(MapEditor editor){\n             public boolean mouseMoved(InputEvent event, float x, float y){\n                 mousex = x;\n                 mousey = y;\n+\n                 requestScroll();\n \n                 return false;\n@@ -73,10 +75,22 @@ public boolean touchDown(InputEvent event, float x, float y, int pointer, KeyCod\n                 if(!mobile && button != KeyCode.mouseLeft && button != KeyCode.mouseMiddle && button != KeyCode.mouseRight){\n                     return true;\n                 }\n-                \n+\n+                Point2 p = project(x, y);\n+\n                 if(button == KeyCode.mouseRight){\n-                    lastTool = tool;\n-                    tool = EditorTool.eraser;\n+                    if(tool == EditorTool.copy){\n+                        editor.copyData.setOrigin(p.x, p.y);\n+                        editor.copyData.clearLines();\n+                        editor.copyData.clear();\n+                    }else{\n+                        lastTool = tool;\n+                        tool = EditorTool.eraser;\n+                    }\n+                }\n+\n+                if(button == KeyCode.mouseLeft && tool == EditorTool.copy){\n+                    editor.copyData.select(p.x, p.y);\n                 }\n \n                 if(button == KeyCode.mouseMiddle){\n@@ -87,7 +101,6 @@ public boolean touchDown(InputEvent event, float x, float y, int pointer, KeyCod\n                 mousex = x;\n                 mousey = y;\n \n-                Point2 p = project(x, y);\n                 lastx = p.x;\n                 lasty = p.y;\n                 startx = p.x;\n@@ -139,6 +152,14 @@ public void touchDragged(InputEvent event, float x, float y, int pointer){\n                     Bresenham2.line(lastx, lasty, p.x, p.y, (cx, cy) -> tool.touched(editor, cx, cy));\n                 }\n \n+                if(tool == EditorTool.copy){\n+                    Copy c = editor.copyData;\n+                    switch(event.keyCode){\n+                        case mouseRight -> c.adjust(p.x, p.y);\n+                        case mouseLeft -> c.move(p.x, p.y);\n+                    }\n+                }\n+\n                 if(tool == EditorTool.line && tool.mode == 1){\n                     if(Math.abs(p.x - firstTouch.x) > Math.abs(p.y - firstTouch.y)){\n                         lastx = p.x;\n@@ -155,6 +176,10 @@ public void touchDragged(InputEvent event, float x, float y, int pointer){\n         });\n     }\n \n+    public boolean copy(){\n+        return (tool == EditorTool.copy || lastTool == EditorTool.copy) && !editor.copyData.empty();\n+    }\n+\n     public EditorTool getTool(){\n         return tool;\n     }\n@@ -179,7 +204,7 @@ public void center(){\n     public void act(float delta){\n         super.act(delta);\n \n-        if(Core.scene.getKeyboardFocus() == null || !(Core.scene.getKeyboardFocus() instanceof TextField) && !Core.input.keyDown(KeyCode.controlLeft)){\n+        if(Core.scene.getKeyboardFocus() == null || !(Core.scene.getKeyboardFocus() instanceof TextField)){\n             float ax = Core.input.axis(Binding.move_x);\n             float ay = Core.input.axis(Binding.move_y);\n             offsetx -= ax * 15f / zoom;\n@@ -198,10 +223,26 @@ public void act(float delta){\n \n         if(Core.scene.getScrollFocus() != this) return;\n \n-        zoom += Core.input.axis(KeyCode.scroll) / 10f * zoom;\n+        float scroll = Core.input.axis(KeyCode.scroll);\n+        if(scroll == 0){\n+            return;\n+        }\n+\n+        if(copy() && Core.input.ctrl()){\n+            if(scroll > 0){\n+                editor.copyData.rotL();\n+            } else {\n+                editor.copyData.rotR();\n+            }\n+            return;\n+        }\n+\n+        zoom += scroll / 10f * zoom;\n         clampZoom();\n     }\n \n+\n+\n     private void clampZoom(){\n         zoom = Mathf.clamp(zoom, 0.2f, 20f);\n     }\n@@ -260,8 +301,8 @@ public void draw(){\n \n             Lines.stroke(3f);\n             Draw.color(Pal.accent);\n-            Lines.line(centerx - sclwidth/2f, centery, centerx + sclwidth/2f, centery);\n-            Lines.line(centerx, centery - sclheight/2f, centerx, centery + sclheight/2f);\n+            Lines.line(centerx - sclwidth / 2f, centery, centerx + sclwidth / 2f, centery);\n+            Lines.line(centerx, centery - sclheight / 2f, centerx, centery + sclheight / 2f);\n \n             Draw.reset();\n         }\n@@ -279,12 +320,29 @@ public void draw(){\n         Draw.color(Pal.accent);\n         Lines.stroke(Scl.scl(2f));\n \n-        if((!editor.drawBlock.isMultiblock() || tool == EditorTool.eraser) && tool != EditorTool.fill){\n+        if(tool == EditorTool.copy){\n+            Copy c = editor.copyData;\n+\n+            if(!c.empty()){\n+                for(int i = 0; i < c.lines.size; i += 2){\n+                    point.set(c.dx, c.dy).add(c.lines.get(i));\n+                    Vec2 a = unproject(point.x, point.y).add(x, y);\n+                    float ax = a.x, ay = a.y;\n+                    point.set(c.dx, c.dy).add(c.lines.get(i + 1));\n+                    Vec2 b = unproject(point.x, point.y).add(x, y);\n+                    Lines.line(ax, ay, b.x, b.y);\n+                }\n+                drawRect(c.ox, c.oy, c.fw, c.fh, Color.black);\n+            } else {\n+                drawRect(c.dx, c.dy, c.fw, c.fh, Pal.accent);\n+            }\n+\n+            drawRect(c.dx, c.dy, c.w, c.h, Pal.accent);\n+        }else if((!editor.drawBlock.isMultiblock() || tool == EditorTool.eraser) && tool != EditorTool.fill){\n             if(tool == EditorTool.line && drawing){\n                 Vec2 v1 = unproject(startx, starty).add(x, y);\n                 float sx = v1.x, sy = v1.y;\n                 Vec2 v2 = unproject(lastx, lasty).add(x, y);\n-\n                 Lines.poly(brushPolygons[index], sx, sy, scaling);\n                 Lines.poly(brushPolygons[index], v2.x, v2.y, scaling);\n             }\n@@ -295,7 +353,7 @@ public void draw(){\n \n                 //pencil square outline\n                 if(tool == EditorTool.pencil && tool.mode == 1){\n-                    Lines.square(v.x + scaling/2f, v.y + scaling/2f, scaling * (editor.brushSize + 0.5f));\n+                    Lines.square(v.x + scaling / 2f, v.y + scaling / 2f, scaling * (editor.brushSize + 0.5f));\n                 }else{\n                     Lines.poly(brushPolygons[index], v.x, v.y, scaling);\n                 }\n@@ -320,6 +378,17 @@ public void draw(){\n         ScissorStack.pop();\n     }\n \n+    private void drawRect(int dx, int dy, int w, int h, Color col){\n+        Vec2 min = unproject(dx, dy).add(x, y);\n+        // because we just have to save that one allocation (i guess)\n+        // unproject returns pointer to same vec so min === max\n+        float sx = min.x, sy = min.y;\n+        unproject(dx - w, dy - h).add(x, y);\n+\n+        Draw.color(col);\n+        Lines.rect(sx, sy, sx - min.x, sy - min.y);\n+    }\n+\n     private boolean active(){\n         return Core.scene != null && Core.scene.getKeyboardFocus() != null\n         && Core.scene.getKeyboardFocus().isDescendantOf(ui.editor)"
  },
  {
    "sha": "fd2b702f4914c026b96c227be1fe2f43f7e1eb76",
    "filename": "core/src/mindustry/input/Binding.java",
    "status": "modified",
    "additions": 5,
    "deletions": 1,
    "changes": 6,
    "blob_url": "https://github.com/Anuken/Mindustry/blob/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/input/Binding.java",
    "raw_url": "https://github.com/Anuken/Mindustry/raw/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/input/Binding.java",
    "contents_url": "https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/input/Binding.java?ref=92976adc6702ef0c9ce71f33777a8ce6b87a3ec7",
    "patch": "@@ -71,7 +71,11 @@\n     chat_scroll(new Axis(KeyCode.scroll)),\n     chat_mode(KeyCode.tab),\n     console(KeyCode.f8),\n-    ;\n+\n+    editor_copy_flip_x(KeyCode.x),\n+    editor_copy_flip_y(KeyCode.z),\n+    editor_copy(KeyCode.c),\n+    editor_paste(KeyCode.v);\n \n     private final KeybindValue defaultValue;\n     private final String category;"
  },
  {
    "sha": "31f739b9d01b2750df2e285dfb1027ab11dd2131",
    "filename": "core/src/mindustry/world/Build.java",
    "status": "modified",
    "additions": 0,
    "deletions": 1,
    "changes": 1,
    "blob_url": "https://github.com/Anuken/Mindustry/blob/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/world/Build.java",
    "raw_url": "https://github.com/Anuken/Mindustry/raw/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/world/Build.java",
    "contents_url": "https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/world/Build.java?ref=92976adc6702ef0c9ce71f33777a8ce6b87a3ec7",
    "patch": "@@ -89,7 +89,6 @@ public static void beginPlace(@Nullable Unit unit, Block result, Team team, int\n         });\n \n         tile.setBlock(sub, team, rotation);\n-\n         var build = (ConstructBuild)tile.build;\n \n         build.setConstruct(previous.size == sub.size ? previous : Blocks.air, result);"
  },
  {
    "sha": "87860533c67be5ea622eff51c61a26f539c978d9",
    "filename": "core/src/mindustry/world/blocks/ConstructBlock.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/Anuken/Mindustry/blob/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/world/blocks/ConstructBlock.java",
    "raw_url": "https://github.com/Anuken/Mindustry/raw/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/world/blocks/ConstructBlock.java",
    "contents_url": "https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/world/blocks/ConstructBlock.java?ref=92976adc6702ef0c9ce71f33777a8ce6b87a3ec7",
    "patch": "@@ -120,6 +120,7 @@ public static void constructed(Tile tile, Block block, Unit builder, byte rotati\n         Call.constructFinish(tile, block, builder, rotation, team, config);\n         if(tile.build != null){\n             tile.build.placed();\n+\n         }\n \n         Events.fire(new BlockBuildEndEvent(tile, builder, team, false, config));"
  },
  {
    "sha": "83bb49222eb28d91fcdec2a0ca68c22c16f2aec6",
    "filename": "core/src/mindustry/world/blocks/power/PowerNode.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/Anuken/Mindustry/blob/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/world/blocks/power/PowerNode.java",
    "raw_url": "https://github.com/Anuken/Mindustry/raw/92976adc6702ef0c9ce71f33777a8ce6b87a3ec7/core/src/mindustry/world/blocks/power/PowerNode.java",
    "contents_url": "https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/world/blocks/power/PowerNode.java?ref=92976adc6702ef0c9ce71f33777a8ce6b87a3ec7",
    "patch": "@@ -49,7 +49,7 @@ public PowerNode(String name){\n         config(Integer.class, (entity, value) -> {\n             PowerModule power = entity.power;\n             Building other = world.build(value);\n-            boolean contains = power.links.contains(value), valid = other != null && other.power != null;\n+            boolean contains = power.links.contains(value) && !state.isEditor(), valid = other != null && other.power != null;\n \n             if(contains){\n                 //unlink"
  }
]
