[
  {
    "sha": "a150e536655a857c11b84382e76d24f216703065",
    "filename": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/FormatScrutinizer.java",
    "status": "modified",
    "additions": 7,
    "deletions": 2,
    "changes": 9,
    "blob_url": "https://github.com/OpenRefine/OpenRefine/blob/86478ffb24d990b1cb05cf9157a04ba61bdd5b0e/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/FormatScrutinizer.java",
    "raw_url": "https://github.com/OpenRefine/OpenRefine/raw/86478ffb24d990b1cb05cf9157a04ba61bdd5b0e/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/FormatScrutinizer.java",
    "contents_url": "https://api.github.com/repos/OpenRefine/OpenRefine/contents/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/FormatScrutinizer.java?ref=86478ffb24d990b1cb05cf9157a04ba61bdd5b0e",
    "patch": "@@ -38,6 +38,7 @@\n import java.util.Map;\n import java.util.Set;\n import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n \n /**\n  * A scrutinizer that detects incorrect formats in text values (mostly\n@@ -97,9 +98,13 @@ public boolean prepareDependencies() {\n                 String regex = constraint.regularExpressionFormat;\n                 Pattern pattern = null;\n                 if (regex != null) {\n-                    pattern = Pattern.compile(regex);\n+                    try {\n+                        pattern = Pattern.compile(regex);\n+                        patterns.add(pattern);\n+                    } catch(PatternSyntaxException e) {\n+                        ; // silently ignore the regex error - it is not up to the OpenRefine user to fix the regex\n+                    }\n                 }\n-                patterns.add(pattern);\n             }\n             _patterns.put(pid, patterns);\n             return patterns;"
  },
  {
    "sha": "f13885f7e16c3123a3b05d191c299f3b05df2f7a",
    "filename": "extensions/wikidata/tests/src/org/openrefine/wikidata/qa/scrutinizers/FormatScrutinizerTest.java",
    "status": "modified",
    "additions": 28,
    "deletions": 15,
    "changes": 43,
    "blob_url": "https://github.com/OpenRefine/OpenRefine/blob/86478ffb24d990b1cb05cf9157a04ba61bdd5b0e/extensions/wikidata/tests/src/org/openrefine/wikidata/qa/scrutinizers/FormatScrutinizerTest.java",
    "raw_url": "https://github.com/OpenRefine/OpenRefine/raw/86478ffb24d990b1cb05cf9157a04ba61bdd5b0e/extensions/wikidata/tests/src/org/openrefine/wikidata/qa/scrutinizers/FormatScrutinizerTest.java",
    "contents_url": "https://api.github.com/repos/OpenRefine/OpenRefine/contents/extensions/wikidata/tests/src/org/openrefine/wikidata/qa/scrutinizers/FormatScrutinizerTest.java?ref=86478ffb24d990b1cb05cf9157a04ba61bdd5b0e",
    "patch": "@@ -54,6 +54,7 @@\n     public static Value noMatchValue = Datamodel.makeStringValue(\"image\");\n     public static Value incompleteMatchValue = Datamodel.makeStringValue(\".jpg\");\n     public static String regularExpression = \"(?i).+\\\\.(jpg|jpeg|jpe|png|svg|tif|tiff|gif|xcf|pdf|djvu|webp)\";\n+    public static String invalidRegularExpression = \"(?[A-Za-z]+)\";\n \n     public static ItemIdValue entityIdValue = Datamodel.makeWikidataItemIdValue(FORMAT_CONSTRAINT_QID);\n     public static PropertyIdValue regularExpressionParameter = Datamodel.makeWikidataPropertyIdValue(FORMAT_REGEX_PID);\n@@ -72,11 +73,7 @@ public void testTrigger() {\n         Statement statement = new StatementImpl(\"P18\", value, idA);\n         ItemUpdate updateA = new ItemUpdateBuilder(idA).addStatement(statement).build();\n \n-        Snak qualifierSnak = Datamodel.makeValueSnak(regularExpressionParameter, regularExpressionFormat);\n-        List<Snak> qualifierSnakList = Collections.singletonList(qualifierSnak);\n-        SnakGroup qualifierSnakGroup = Datamodel.makeSnakGroup(qualifierSnakList);\n-        List<SnakGroup> constraintQualifiers = Collections.singletonList(qualifierSnakGroup);\n-        List<Statement> constraintDefinitions = constraintParameterStatementList(entityIdValue, constraintQualifiers);\n+        List<Statement> constraintDefinitions = generateFormatConstraint(regularExpression);\n \n         ConstraintFetcher fetcher = mock(ConstraintFetcher.class);\n         when(fetcher.getConstraintsByType(propertyIdValue, FORMAT_CONSTRAINT_QID)).thenReturn(constraintDefinitions);\n@@ -92,11 +89,7 @@ public void testNoIssue() {\n         Statement statement = new StatementImpl(\"P18\", value, idA);\n         ItemUpdate updateA = new ItemUpdateBuilder(idA).addStatement(statement).build();\n \n-        Snak qualifierSnak = Datamodel.makeValueSnak(regularExpressionParameter, regularExpressionFormat);\n-        List<Snak> qualifierSnakList = Collections.singletonList(qualifierSnak);\n-        SnakGroup qualifierSnakGroup = Datamodel.makeSnakGroup(qualifierSnakList);\n-        List<SnakGroup> constraintQualifiers = Collections.singletonList(qualifierSnakGroup);\n-        List<Statement> constraintDefinitions = constraintParameterStatementList(entityIdValue, constraintQualifiers);\n+        List<Statement> constraintDefinitions = generateFormatConstraint(regularExpression);\n \n         ConstraintFetcher fetcher = mock(ConstraintFetcher.class);\n         when(fetcher.getConstraintsByType(propertyIdValue, FORMAT_CONSTRAINT_QID)).thenReturn(constraintDefinitions);\n@@ -112,17 +105,37 @@ public void testIncompleteMatch() {\n         Statement statement = new StatementImpl(\"P18\", value, idA);\n         ItemUpdate updateA = new ItemUpdateBuilder(idA).addStatement(statement).build();\n \n-        Snak qualifierSnak = Datamodel.makeValueSnak(regularExpressionParameter, regularExpressionFormat);\n-        List<Snak> qualifierSnakList = Collections.singletonList(qualifierSnak);\n-        SnakGroup qualifierSnakGroup = Datamodel.makeSnakGroup(qualifierSnakList);\n-        List<SnakGroup> constraintQualifiers = Collections.singletonList(qualifierSnakGroup);\n-        List<Statement> constraintDefinitions = constraintParameterStatementList(entityIdValue, constraintQualifiers);\n+        List<Statement> constraintDefinitions = generateFormatConstraint(regularExpression);\n \n         ConstraintFetcher fetcher = mock(ConstraintFetcher.class);\n         when(fetcher.getConstraintsByType(propertyIdValue, FORMAT_CONSTRAINT_QID)).thenReturn(constraintDefinitions);\n         setFetcher(fetcher);\n         scrutinize(updateA);\n         assertWarningsRaised(FormatScrutinizer.type);\n     }\n+    \n+    @Test\n+    public void testInvalidRegex() {\n+        ItemIdValue idA = TestingData.existingId;\n+        ValueSnak value = Datamodel.makeValueSnak(propertyIdValue, incompleteMatchValue);\n+        Statement statement = new StatementImpl(\"P18\", value, idA);\n+        ItemUpdate updateA = new ItemUpdateBuilder(idA).addStatement(statement).build();\n+        \n+        List<Statement> constraintDefinitions = generateFormatConstraint(invalidRegularExpression);\n+\n+        ConstraintFetcher fetcher = mock(ConstraintFetcher.class);\n+        when(fetcher.getConstraintsByType(propertyIdValue, FORMAT_CONSTRAINT_QID)).thenReturn(constraintDefinitions);\n+        setFetcher(fetcher);\n+        scrutinize(updateA);\n+        assertNoWarningRaised();\n+    }\n+    \n+    protected List<Statement> generateFormatConstraint(String regex) {\n+        Snak qualifierSnak = Datamodel.makeValueSnak(regularExpressionParameter, Datamodel.makeStringValue(regex));\n+        List<Snak> qualifierSnakList = Collections.singletonList(qualifierSnak);\n+        SnakGroup qualifierSnakGroup = Datamodel.makeSnakGroup(qualifierSnakList);\n+        List<SnakGroup> constraintQualifiers = Collections.singletonList(qualifierSnakGroup);\n+        return constraintParameterStatementList(entityIdValue, constraintQualifiers);\n+    }\n \n }"
  }
]
