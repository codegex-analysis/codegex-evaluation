[
  {
    "sha": "ff8a4d434cf7efb597691e34a7288b0848706785",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/IMUSystem.java",
    "status": "removed",
    "additions": 0,
    "deletions": 110,
    "changes": 110,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/beb99b2cf1dac35ec4769647155c7f9e956c5d33/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/IMUSystem.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/beb99b2cf1dac35ec4769647155c7f9e956c5d33/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/IMUSystem.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/IMUSystem.java?ref=beb99b2cf1dac35ec4769647155c7f9e956c5d33",
    "patch": "@@ -1,110 +0,0 @@\n-package org.firstinspires.ftc.teamcode.components;\n-\n-import com.qualcomm.hardware.bosch.BNO055IMU;\n-\n-import org.firstinspires.ftc.robotcore.external.navigation.Acceleration;\n-import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\n-import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\n-import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\n-import org.firstinspires.ftc.robotcore.external.navigation.Orientation;\n-import org.firstinspires.ftc.robotcore.external.navigation.Position;\n-import org.firstinspires.ftc.robotcore.external.navigation.Velocity;\n-\n-import java.util.Locale;\n-\n-/**\n- * Creates an IMU system that handles the angle and movement of the robot through a gyroscope.\n- */\n-public class IMUSystem {\n-    public BNO055IMU imu;\n-    public BNO055IMU.Parameters parameters;\n-\n-    // State used for updating telemetry\n-    private Orientation angles;\n-    private Acceleration gravity;\n-\n-    /**\n-     * Creates a new IMU System\n-     */\n-    public IMUSystem(BNO055IMU imu)\n-    {\n-        this.parameters = new BNO055IMU.Parameters();\n-        this.parameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;\n-        this.parameters.accelUnit = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n-        this.parameters.loggingEnabled = true;\n-        this.parameters.loggingTag = \"BNO055\";\n-        // this.parameters.calibrationDataFile = \"AdafruitIMUCalibration.json\"; // see the calibration sample opmode\n-        this.imu = imu;\n-        this.imu.initialize(parameters);\n-\n-        // Enable reporting of position using the naive integrator\n-        imu.startAccelerationIntegration(new Position(), new Velocity(), 500);\n-    }\n-\n-    /**\n-     * Gets the yaw of the IMU\n-     * @return Returns the yaw in degrees\n-     */\n-    public double getHeading() {\n-        return -imu.getAngularOrientation().firstAngle;\n-//        Orientation orientation = imu.getAngularOrientation().toAxesReference(AxesReference.INTRINSIC).toAxesOrder(AxesOrder.ZYX);\n-//        return orientation.firstAngle;\n-    }\n-\n-    /**\n-     * Gets the roll of the IMU\n-     * @return Returns the roll in degrees\n-     */\n-    public double getRoll() {\n-        Orientation orientation = imu.getAngularOrientation().toAxesReference(AxesReference.INTRINSIC).toAxesOrder(AxesOrder.ZYX);\n-        return orientation.secondAngle;\n-    }\n-\n-    /**\n-     * Gets the pitch of the IMU\n-     * @return Returns the pitch in degrees\n-     */\n-    public double getPitch() {\n-        Orientation orientation = imu.getAngularOrientation().toAxesReference(AxesReference.INTRINSIC).toAxesOrder(AxesOrder.ZYX);\n-        return orientation.thirdAngle;\n-    }\n-\n-    /**\n-     * Gets the acceleration of the IMU\n-     * @return Returns the linear acceleration object\n-     * @see Acceleration\n-     */\n-    public Acceleration getAcceleration()\n-    {\n-        return imu.getLinearAcceleration();\n-    }\n-\n-    /**\n-     * Gets the velocity of the IMU\n-     * @return Returns the velocity of the IMU\n-     * @see Velocity\n-     */\n-    public Velocity getVelocity()\n-    {\n-        return imu.getVelocity();\n-    }\n-\n-    /**\n-     * Formats the angle as a string\n-     * @param angleUnit unit of the angle\n-     * @param angle value of the angle\n-     * @return Returns the formatted value of the angle\n-     */\n-    String formatAngle(AngleUnit angleUnit, double angle) {\n-        return formatDegrees(AngleUnit.DEGREES.fromUnit(angleUnit, angle));\n-    }\n-\n-    /**\n-     * Formats the degrees of the IMU\n-     * @param degrees default type of the degrees\n-     * @return Returns the formatted value of the degrees\n-     */\n-    String formatDegrees(double degrees) {\n-        return String.format(Locale.getDefault(), \"%.1f\", AngleUnit.DEGREES.normalize(degrees));\n-    }\n-}"
  },
  {
    "sha": "d9607c68fd3f8b49dd6fdb6278f0038ccf712513",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/IntakeSystem.java",
    "status": "added",
    "additions": 36,
    "deletions": 0,
    "changes": 36,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/IntakeSystem.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/IntakeSystem.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/IntakeSystem.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -0,0 +1,36 @@\n+package org.firstinspires.ftc.teamcode.components;\n+\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.DcMotorSimple;\n+\n+public class IntakeSystem {\n+\n+    private final DcMotor motor;\n+\n+    public IntakeSystem(DcMotor motor) {\n+        this.motor = motor;\n+        initMotors();\n+    }\n+\n+    /**\n+     * Initializes the motors\n+     */\n+    public void initMotors() {\n+        motor.setDirection(DcMotorSimple.Direction.REVERSE);\n+        motor.setPower(0);\n+    }\n+\n+    /**\n+     * Intakes rings\n+     */\n+    public void suck() {\n+        motor.setPower(1);\n+    }\n+\n+    /**\n+     * Shuts down the motor\n+     */\n+    public void stop() {\n+        motor.setPower(0);\n+    }\n+}"
  },
  {
    "sha": "bd75a884201de0f0aea667ee6f345dbcd1947d5b",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/RoadRunnerDriveSystem.java",
    "status": "modified",
    "additions": 46,
    "deletions": 34,
    "changes": 80,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/RoadRunnerDriveSystem.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/RoadRunnerDriveSystem.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/RoadRunnerDriveSystem.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -24,23 +24,25 @@\n import com.qualcomm.robotcore.hardware.configuration.typecontainers.MotorConfigurationType;\n import com.qualcomm.robotcore.util.Range;\n \n+import org.firstinspires.ftc.teamcode.helpers.StandardTrackingWheelLocalizer;\n+\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n \n-import static org.firstinspires.ftc.teamcode.Constants.BASE_CONSTRAINTS;\n-import static org.firstinspires.ftc.teamcode.Constants.MOTOR_VELO_PID;\n-import static org.firstinspires.ftc.teamcode.Constants.RUN_USING_ENCODER;\n-import static org.firstinspires.ftc.teamcode.Constants.TRACK_WIDTH;\n-import static org.firstinspires.ftc.teamcode.Constants.encoderTicksToInches;\n-import static org.firstinspires.ftc.teamcode.Constants.getMotorVelocityF;\n-import static org.firstinspires.ftc.teamcode.Constants.kV;\n-import static org.firstinspires.ftc.teamcode.Constants.kA;\n-import static org.firstinspires.ftc.teamcode.Constants.kStatic;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.BASE_CONSTRAINTS;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.MOTOR_VELO_PID;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.RUN_USING_ENCODER;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.TRACK_WIDTH;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.encoderTicksToInches;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.getMotorVelocityF;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.kA;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.kStatic;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.kV;\n \n public class RoadRunnerDriveSystem extends MecanumDrive {\n-    public static PIDCoefficients TRANSLATIONAL_PID = new PIDCoefficients(0, 0, 0);\n-    public static PIDCoefficients HEADING_PID = new PIDCoefficients(0, 0, 0);\n+    public static PIDCoefficients TRANSLATIONAL_PID = new PIDCoefficients(12, .3, .2);\n+    public static PIDCoefficients HEADING_PID = new PIDCoefficients(12, .3, .2);\n \n     public static double LATERAL_MULTIPLIER = 1;\n \n@@ -54,24 +56,24 @@\n \n     public Mode mode;\n \n-    private PIDFController turnController;\n+    private final PIDFController turnController;\n     private MotionProfile turnProfile;\n     private double turnStart;\n \n-    private DriveConstraints constraints;\n-    private TrajectoryFollower follower;\n+    private static DriveConstraints constraints;\n+    private final TrajectoryFollower follower;\n \n-    private List<Pose2d> poseHistory;\n+    private final List<Pose2d> poseHistory;\n \n-    private DcMotorEx leftFront, leftRear, rightRear, rightFront;\n-    private List<DcMotorEx> motors;\n+    private final DcMotorEx leftFront, leftRear, rightRear, rightFront;\n+    private final List<DcMotorEx> motors;\n \n     private Pose2d lastPoseOnTurn;\n \n     public static double VX_WEIGHT = 1;\n     public static double VY_WEIGHT = 1;\n     public static double OMEGA_WEIGHT = 1;\n-    private StandardTrackingWheelLocalizer standardTrackingWheelLocalizer;\n+    private final StandardTrackingWheelLocalizer standardTrackingWheelLocalizer;\n     private boolean mSlowDrive;\n     private boolean mPathComplete = false;\n     public static final double SLOW_DRIVE_COEFF = 0.4;\n@@ -133,22 +135,31 @@ public RoadRunnerDriveSystem(HardwareMap hardwareMap) {\n         setLocalizer(standardTrackingWheelLocalizer);\n     }\n \n+    public ArrayList<DcMotorEx> getMotors(){\n+        ArrayList<DcMotorEx> list = new ArrayList<DcMotorEx>();\n+        list.add(leftFront);\n+        list.add(rightFront);\n+        list.add(rightRear);\n+        list.add(leftRear);\n+        return list;\n+    }\n+\n     public ArrayList<Double> getEncoders() {\n         return new ArrayList<Double>(\n                 Arrays.asList(standardTrackingWheelLocalizer.leftEncoderValue(),\n                 standardTrackingWheelLocalizer.rightEncoderValue(),\n                 standardTrackingWheelLocalizer.frontEncoderValue()));\n     }\n \n-    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose) {\n+    public static TrajectoryBuilder trajectoryBuilder(Pose2d startPose) {\n         return new TrajectoryBuilder(startPose, constraints);\n     }\n \n-    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose, boolean reversed) {\n+    public static TrajectoryBuilder trajectoryBuilder(Pose2d startPose, boolean reversed) {\n         return new TrajectoryBuilder(startPose, reversed, constraints);\n     }\n \n-    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose, double startHeading) {\n+    public static TrajectoryBuilder trajectoryBuilder(Pose2d startPose, double startHeading) {\n         return new TrajectoryBuilder(startPose, startHeading, constraints);\n     }\n \n@@ -174,23 +185,16 @@ public void turn(double angle) {\n         waitForIdle();\n     }\n \n-    public boolean followTrajectoryAsync(Trajectory trajectory) {\n-        if (mPathComplete) {\n-            mPathComplete = false;\n-            return true;\n-        }\n-\n-        follower.followTrajectory(trajectory);\n-        mode = Mode.FOLLOW_TRAJECTORY;\n-\n-        return false;\n-    }\n-\n     public void followTrajectory(Trajectory trajectory) {\n         followTrajectoryAsync(trajectory);\n         waitForIdle();\n     }\n \n+    public void followTrajectoryAsync(Trajectory trajectory) {\n+        follower.followTrajectory(trajectory);\n+        mode = Mode.FOLLOW_TRAJECTORY;\n+    }\n+\n     public Pose2d getLastError() {\n         switch (mode) {\n             case FOLLOW_TRAJECTORY:\n@@ -203,7 +207,9 @@ public Pose2d getLastError() {\n         throw new AssertionError();\n     }\n \n-    public void update() {\n+    public boolean update() {\n+        boolean mPathComplete = false;\n+\n         updatePoseEstimate();\n \n         Pose2d currentPose = getPoseEstimate();\n@@ -259,6 +265,12 @@ public void update() {\n             }\n         }\n \n+        return mPathComplete;\n+    }\n+\n+    public Pose2d getPositionEstimate() {\n+        update();\n+        return getPoseEstimate();\n     }\n \n     public void waitForIdle() {"
  },
  {
    "sha": "2ca9f03e4d9eea763be3279ac8662750e77ba20a",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/ShootingSystem.java",
    "status": "added",
    "additions": 123,
    "deletions": 0,
    "changes": 123,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/ShootingSystem.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/ShootingSystem.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/ShootingSystem.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -0,0 +1,123 @@\n+package org.firstinspires.ftc.teamcode.components;\n+\n+import com.qualcomm.robotcore.hardware.DcMotorEx;\n+import com.qualcomm.robotcore.hardware.DcMotorSimple;\n+import com.qualcomm.robotcore.hardware.Servo;\n+import com.qualcomm.robotcore.util.ElapsedTime;\n+\n+import org.firstinspires.ftc.teamcode.helpers.Target;\n+\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.SERVO_WAIT_TIME;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.SHOOTING_SERVO_IDLE_POSITION;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.SHOOTING_SERVO_SHOOT_POSITION;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.TICKS_PER_REV;\n+\n+public class ShootingSystem {\n+\n+    // Systems\n+    private final DcMotorEx motor;\n+    public final Servo servo;\n+    private final ElapsedTime elapsedTime;\n+\n+    // ShootingState\n+    private enum ShootingState {\n+        IDLE,\n+        OPEN,\n+        CLOSE\n+    }\n+    private ShootingState currentShootingState;\n+\n+    // Target\n+    private Target currentTarget;\n+\n+    public ShootingSystem(DcMotorEx motor, Servo servo) {\n+        elapsedTime = new ElapsedTime();\n+        currentShootingState = ShootingState.IDLE;\n+\n+        this.motor = motor;\n+        this.servo = servo;\n+        initMotors();\n+    }\n+\n+    /**\n+     * Initializes the motor and servo\n+     */\n+    private void initMotors() {\n+        // Motors\n+        motor.setDirection(DcMotorSimple.Direction.REVERSE);\n+        setMotorRpm(0);\n+\n+        // Servos\n+        servoIdle();\n+    }\n+\n+    /**\n+     * Sets the target\n+     * @param target to shoot at\n+     */\n+    public void warmUp(Target target) {\n+        currentTarget = target;\n+        setMotorRpm(currentTarget.getRpm());\n+    }\n+\n+    /**\n+     * Shuts down the shooter\n+     */\n+    public void shutDown() {\n+        setMotorRpm(0);\n+        servoIdle();\n+    }\n+\n+    //TODO Code Review\n+    /**\n+     * Shoots a ring\n+     */\n+    public boolean shoot() {\n+        switch (currentShootingState) {\n+            case IDLE:\n+                elapsedTime.reset();\n+                currentShootingState = ShootingState.OPEN;\n+                servoShoot();\n+                break;\n+\n+            case OPEN:\n+                if (elapsedTime.milliseconds() > SERVO_WAIT_TIME) {\n+                    elapsedTime.reset();\n+                    servoIdle();\n+                    currentShootingState = ShootingState.CLOSE;\n+                }\n+                break;\n+\n+            case CLOSE:\n+                if (elapsedTime.milliseconds() > SERVO_WAIT_TIME) {\n+                    elapsedTime.reset();\n+                    currentShootingState = ShootingState.IDLE;\n+                }\n+                return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Method to set motor power manually rather than using given constants\n+     * @param rpm the motor will be set to\n+     */\n+    private void setMotorRpm(double rpm) {\n+        motor.setVelocity(rpm / 60.0 * TICKS_PER_REV);\n+    }\n+\n+    /**\n+     * Moves servo to push ring into the motor\n+     */\n+    private void servoShoot() {\n+        servo.setPosition(SHOOTING_SERVO_SHOOT_POSITION);\n+    }\n+\n+    /**\n+     * Resets servo to be ready for the next shot\n+     */\n+    private void servoIdle() {\n+        servo.setPosition(SHOOTING_SERVO_IDLE_POSITION);\n+    }\n+}"
  },
  {
    "sha": "aaa1a22d0ea641a31d92dc5550d4065cc3d0daf6",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/Tensorflow.java",
    "status": "modified",
    "additions": 5,
    "deletions": 5,
    "changes": 10,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/Tensorflow.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/Tensorflow.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/Tensorflow.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -1,11 +1,11 @@\n package org.firstinspires.ftc.teamcode.components;\n \n-import java.util.EnumMap;\n-import java.util.List;\n import org.firstinspires.ftc.robotcore.external.ClassFactory;\n-import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\n-import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\n import org.firstinspires.ftc.robotcore.external.tfod.Recognition;\n+import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\n+\n+import java.util.EnumMap;\n+import java.util.List;\n \n public class Tensorflow {\n \n@@ -72,7 +72,7 @@ public void shutdown() {\n \n     public SquareState getTargetRegion() {\n         if (tfod == null) {\n-            return null;\n+            return SquareState.BOX_A;\n         }\n         List<Recognition> recognitionList = getInference();\n         if (recognitionList.size() == 1 && recognitionList.get(0).getConfidence() >= 0.4) {"
  },
  {
    "sha": "7082562de6ff0a597a547e30f58e1653e9409901",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/VuforiaSystem.java",
    "status": "modified",
    "additions": 9,
    "deletions": 11,
    "changes": 20,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/VuforiaSystem.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/VuforiaSystem.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/VuforiaSystem.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -15,19 +15,16 @@\n import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;\n import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.YZX;\n import static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.mmPerInch;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.mmTargetHeight;\n \n /** Teddy, trust my code, you blasphemer. */\n public class VuforiaSystem {\n-    private static final float mmPerInch = 25.4f;                    // constant for converting measurements from inches to millimeters\n-    private static final float mmTargetHeight = (6) * mmPerInch;          // the height of the center of the target image above the floor\n-\n-    private static final float halfField = 72 * mmPerInch;                  // constants for perimeter targets\n-    private static final float quadField = 36 * mmPerInch;\n \n     private VuforiaLocalizer vuforiaLocalizer;\n     private OpenGLMatrix lastLocation = null; // class members\n     public static VuforiaTrackables targetsUltGoal;\n-    public static VuforiaTrackable redAllianceTarget ;\n+    public static VuforiaTrackable redAllianceTarget;\n     private static VuforiaSystem instance;\n     private static final VuforiaLocalizer.CameraDirection CAMERA_DIRECTION = VuforiaLocalizer.CameraDirection.BACK;\n \n@@ -84,8 +81,13 @@ private void initUltsGoal(WebcamName webcamName) {\n         }\n \n         redAllianceTarget.setLocation(OpenGLMatrix\n-                .translation(0, -halfField, mmTargetHeight)\n+                .translation(0, 0, mmTargetHeight)\n                 .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\n+\n+        OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener)redAllianceTarget.getListener()).getUpdatedRobotLocation();\n+        if (robotLocationTransform != null) {\n+            lastLocation = robotLocationTransform;\n+        }\n     }\n \n     public VuforiaLocalizer getVuforiaLocalizer() {\n@@ -130,10 +132,6 @@ public float getZOffset() {\n     }\n \n     public VectorF vector() {\n-        OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener)redAllianceTarget.getListener()).getUpdatedRobotLocation();\n-        if (robotLocationTransform != null) {\n-            lastLocation = robotLocationTransform;\n-        }\n         if (lastLocation == null) {\n             return null;\n         }"
  },
  {
    "sha": "746115f3fa2ae165c2a599e9a8b99b41eafa08e7",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/YeetSystem.java",
    "status": "modified",
    "additions": 110,
    "deletions": 68,
    "changes": 178,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/YeetSystem.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/YeetSystem.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/YeetSystem.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -1,102 +1,144 @@\n package org.firstinspires.ftc.teamcode.components;\n \n-import com.acmerobotics.roadrunner.drive.Drive;\n import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.DcMotorEx;\n import com.qualcomm.robotcore.hardware.Servo;\n \n-import java.util.EnumMap;\n+import org.firstinspires.ftc.robotcore.internal.system.Deadline;\n+import org.firstinspires.ftc.teamcode.helpers.Constants;\n \n-public class YeetSystem {\n+import java.util.concurrent.TimeUnit;\n \n-    //ALL CONTENTS NEED TO BE CHANGED\n-    private static final double LEFT_CLOSED_POSITION = 0.715;\n-    private static final double RIGHT_CLOSED_POSITION = 0.189;\n-    private static final double LEFT_OPEN_POSITION = 0.446;\n-    private static final double RIGHT_OPEN_POSITION = 0.456;\n+public class YeetSystem {\n \n-    public enum Servos {\n+    // Arm State\n+    private enum ArmState {\n+        IDLE,\n+        GRAB,\n+        START_ARM,\n+        MOVING_ARM\n+    }\n \n-        LEFT (LEFT_CLOSED_POSITION, LEFT_OPEN_POSITION, false), //values need to be changed\n-        RIGHT (RIGHT_CLOSED_POSITION, RIGHT_OPEN_POSITION, false); //values need to be changed\n+    // Systems\n+    private final DcMotorEx motor; //one motor that we need\n+    private final Servo leftServo;\n+    private final Servo rightServo;\n+    private final Deadline elapsedTime;\n \n-        private final double openPosition;\n-        private final double closedPosition;\n-        private boolean closed;\n+    // Tracker fields\n+    private ArmState currentState;\n+    private Integer targetPosition;\n \n-        Servos(double closedPosition, double openPosition, boolean closed) {\n-            this.closedPosition = closedPosition;\n-            this.openPosition = openPosition;\n-            this.closed = closed;\n-        }\n+    public YeetSystem(DcMotorEx motor, Servo leftServo, Servo rightServo) { //constructor\n+        this.motor = motor; //setting ArmSystem motor to whatever motor that is\n+        this.leftServo = leftServo;\n+        this.rightServo = rightServo;\n+        elapsedTime = new Deadline(Constants.SERVO_WAIT_TIME, TimeUnit.MILLISECONDS);\n+        motor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        currentState = ArmState.IDLE;\n+        release();\n+    }\n \n-        public double getOpenPosition() {\n-            return openPosition;\n+    /**\n+     * Places the wobble goal down and releases it\n+     * @return if the wobble goal is placed on the ground\n+     */\n+    public boolean placed() {\n+        if (isComplete()) {\n+            release();\n+            targetPosition = null;\n+            currentState = ArmState.IDLE;\n+            return true;\n         }\n \n-        public double getClosedPosition() {\n-            return closedPosition;\n+        if (currentState == ArmState.IDLE) {\n+            targetPosition = Constants.ARM_MOTOR_DOWN_POSITION;\n+            moveArm();\n         }\n+        return false;\n+    }\n \n-        public boolean getClosed() {\n-            return closed;\n+    /**\n+     * Picks up the wobble goal\n+     * @return If the wobble goal is picked up\n+     */\n+    public boolean pickedUp() {\n+        if (isComplete()) {\n+            shutDown();\n+            targetPosition = null;\n+            currentState = ArmState.IDLE;\n+            return true;\n         }\n \n-        private void setLatched(boolean isClosed) {\n-            closed = isClosed;\n+        switch (currentState) {\n+            case IDLE:\n+                elapsedTime.reset();\n+                currentState = ArmState.GRAB;\n+                grab();\n+                break;\n+\n+            case GRAB:\n+                if (elapsedTime.hasExpired()) {\n+                    currentState = ArmState.START_ARM;\n+                }\n+                break;\n+\n+            case START_ARM:\n+                targetPosition = Constants.ARM_MOTOR_UP_POSITION;\n+                moveArm();\n+                currentState = ArmState.MOVING_ARM;\n+                break;\n         }\n+        return false;\n     }\n \n-    public EnumMap<Servos, Servo> servoMap;\n-\n-    DcMotor motor; //one motor that we need\n-\n-    private static final double TICKS_PER_REVOLUTION = DriveConstants.TICKS_PER_REV; //number of ticks per revolution\n-    private static final double NUM_REVOLUTIONS = 0.8; // THIS NEEDS TO BE CHANGED - the number is num of revolutions\n-    private static final double UP_POSITION = TICKS_PER_REVOLUTION * NUM_REVOLUTIONS;\n-\n-    private static final int DEFAULT = 0; // this needs to be changed\n-\n-\n-    public YeetSystem(DcMotor motor, EnumMap<Servos, Servo> servoMap) { //constructor\n-        this.motor = motor; //setting ArmSystem motor to whatever motor that is\n-        init();\n-        motor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n-    }\n-\n-    private void init() {\n-        down();\n-        release();\n+    /**\n+     * Checks if the system still needs to run\n+     * @return if the system still needs to run\n+     */\n+    private boolean isComplete() {\n+        if (targetPosition == null) {\n+            return false;\n+        }\n+        return (Math.abs(targetPosition - motor.getCurrentPosition()) < 50 && motor.getVelocity() < 20);\n     }\n \n-    public void up(){\n-        grab();\n-        motor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n-        while (motor.getCurrentPosition() != UP_POSITION){\n-            motor.setPower(0.75);\n-        }\n+    /**\n+     * Shuts down the motor\n+     */\n+    public void shutDown() {\n+        motor.setPower(0.0);\n     }\n \n-    public void down(){\n+    /**\n+     * Moves arm either up or down\n+     */\n+    private void moveArm() {\n+        motor.setTargetPosition(targetPosition);\n         motor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n-        while (motor.getCurrentPosition() != DEFAULT) {\n-            motor.setTargetPosition(DEFAULT);\n+        if (targetPosition == Constants.ARM_MOTOR_DOWN_POSITION) {\n+            motor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor.setPower(-Constants.ARM_MOTOR_RAW_POWER);\n+        } else {\n+            motor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+            motor.setPower(Constants.ARM_MOTOR_RAW_POWER);\n         }\n-        motor.setPower(0.0);\n     }\n \n-    public void grab(){\n-        servoMap.forEach((name, servo) -> {\n-            servo.setPosition(name.getClosedPosition());\n-        });\n+    /**\n+     * Closes the servos to grab the wobble goal\n+     */\n+    public void grab() {\n+        leftServo.setPosition(Constants.LEFT_ARM_SERVO_CLOSED_POSITION);\n+        rightServo.setPosition(Constants.RIGHT_ARM_SERVO_CLOSED_POSITION);\n     }\n \n-    public void release(){\n-        servoMap.forEach((name, servo) -> {\n-            servo.setPosition(name.getOpenPosition());\n-        });\n+    /**\n+     * Opens the servos to release the wobble goal\n+     */\n+    public void release() {\n+        leftServo.setPosition(Constants.LEFT_ARM_SERVO_OPEN_POSITION);\n+        rightServo.setPosition(Constants.RIGHT_ARM_SERVO_OPEN_POSITION);\n     }\n }\n \n-\n-\n-"
  },
  {
    "sha": "729843f726dde35e1bcb44b6cd0e1a8e525308fb",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Constants.java",
    "status": "renamed",
    "additions": 49,
    "deletions": 4,
    "changes": 53,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Constants.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Constants.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Constants.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -1,14 +1,28 @@\n-package org.firstinspires.ftc.teamcode;\n+package org.firstinspires.ftc.teamcode.helpers;\n \n import com.acmerobotics.roadrunner.control.PIDCoefficients;\n+import com.acmerobotics.roadrunner.geometry.Vector2d;\n import com.acmerobotics.roadrunner.trajectory.constraints.DriveConstraints;\n \n public class Constants {\n \n+    // Debugging captions\n+    public static final String ROBOT_SYSTEM_ERROR = \"ROBOTSYSTEMERROR\";\n+\n+    private final static int CPS_STEP = 0x10000;\n+\n+    public static int TICKS_PER_REV = 2400;\n+    public static double WHEEL_RADIUS = 1; // in\n+    public static double GEAR_RATIO = 1; // output (wheel) speed / input (encoder) speed\n+\n+    public static double LATERAL_DISTANCE = 3.532; // in; distance between the left and right wheels\n+    public static double FORWARD_OFFSET = 3.326772; // in; offset of the lateral wheel\n+\n+    public static double X_MULTIPLIER = 1.0;\n+    public static double Y_MULTIPLIER = 1.0;\n     /*\n      * These are motor constants that should be listed online for your motors.\n      */\n-    public static final double TICKS_PER_REV = 1120;\n     public static final double MAX_RPM = 160;\n \n     /*\n@@ -26,8 +40,7 @@\n      * angular distances although most angular parameters are wrapped in Math.toRadians() for\n      * convenience. Make sure to exclude any gear ratio included in MOTOR_CONFIG from GEAR_RATIO.\n      */\n-    public static double WHEEL_RADIUS = 2; // in\n-    public static double GEAR_RATIO = 32.0 / 24.0; // output (wheel) speed / input (motor) speed\n+\n     // TODO\n     public static double TRACK_WIDTH = 12.75; // in\n \n@@ -67,4 +80,36 @@ public static double getMotorVelocityF() {\n         // see https://docs.google.com/document/d/1tyWrXDfMidwYyP_5H4mZyVgaEswhOC35gvdmP-V-5hA/edit#heading=h.61g9ixenznbx\n         return 32767 * 60.0 / (MAX_RPM * TICKS_PER_REV);\n     }\n+\n+    //Field\n+    public static final int tileWidth = 24;\n+\n+    //Vuforia\n+    public static final float mmPerInch = 25.4f;                    // constant for converting measurements from inches to millimeters\n+    public static final float mmTargetHeight = (6) * mmPerInch;          // the height of the center of the target image above the floor\n+    public static final float halfField = 72 * mmPerInch;                  // constants for perimeter targets\n+    public static final float quadField = 36 * mmPerInch;\n+\n+    //Shooter Constants\n+    public static final float powerShotY = 78;\n+    // TODO, Find position values.\n+    public static final double SHOOTING_SERVO_IDLE_POSITION = 0.5;\n+    public static final double SHOOTING_SERVO_SHOOT_POSITION = 0.7;\n+\n+    Vector2d negativeFirstPowerShotCoordinates = new Vector2d(-4 * tileWidth - (23.5f * 2 + 4.25f - ((44 * 10) / Constants.mmPerInch / 2)), powerShotY);\n+    public static final Vector2d firstPowerShotCoordinates = new Vector2d(4 * tileWidth - (23.5f * 2 + 4.25f - ((44 * 10) / mmPerInch / 2)), powerShotY);\n+    public static final Vector2d secondPowerShotCoordinates = new Vector2d(firstPowerShotCoordinates.getX() - 6.75, 78);\n+    public static final Vector2d thirdPowerShotCoordinates = new Vector2d(secondPowerShotCoordinates.getX() - 8.5, powerShotY);\n+\n+    //YeetSystem\n+    //TODO Change these numbers\n+    public static final double ARM_MOTOR_NUM_REVOLUTIONS = -0.6; // THIS NEEDS TO BE CHANGED - the number is num of revolutions\n+    public static final int ARM_MOTOR_UP_POSITION = (int)(Constants.TICKS_PER_REV * ARM_MOTOR_NUM_REVOLUTIONS);\n+    public static final int ARM_MOTOR_DOWN_POSITION = 0; // this needs to be changed\n+    public static final double ARM_MOTOR_RAW_POWER = 0.75;\n+    public static final double LEFT_ARM_SERVO_CLOSED_POSITION = 0.8;\n+    public static final double RIGHT_ARM_SERVO_CLOSED_POSITION = 0.0;\n+    public static final double LEFT_ARM_SERVO_OPEN_POSITION = 0.16;\n+    public static final double RIGHT_ARM_SERVO_OPEN_POSITION = 0.4;\n+    public static final int SERVO_WAIT_TIME = 500;\n }",
    "previous_filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Constants.java"
  },
  {
    "sha": "b632f251fe88a4671ecd50221a0aa7b3c40be4b5",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Coordinates.java",
    "status": "added",
    "additions": 51,
    "deletions": 0,
    "changes": 51,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Coordinates.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Coordinates.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Coordinates.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -0,0 +1,51 @@\n+package org.firstinspires.ftc.teamcode.helpers;\n+\n+import com.acmerobotics.roadrunner.geometry.Vector2d;\n+\n+public enum Coordinates {\n+    //TODO check and correct these coordinates\n+    // Starting position adjust for starging at back wall\n+    STARTING_POSITION(2.5 * Constants.tileWidth, 0.5 * Constants.tileWidth),\n+\n+    // Spline position to the left to avoid rings\n+    DETOUR_POSITION(0.5 * Constants.tileWidth, 2 * Constants.tileWidth),\n+\n+    // Wobblegoal dropoff boxes\n+    BOX_A(3.5 * Constants.tileWidth, 3.5 * Constants.tileWidth),\n+    BOX_B(2.5 * Constants.tileWidth, 4.5 * Constants.tileWidth),\n+    BOX_C(3.5 * Constants.tileWidth, 5.5 * Constants.tileWidth),\n+\n+    //Calibration\n+    CALIBRATION(2.5 * Constants.tileWidth, 3 * Constants.tileWidth),\n+\n+    // Powershot\n+    POWERSHOT_1(Constants.firstPowerShotCoordinates.getX(), Constants.firstPowerShotCoordinates.getY()),\n+    POWERSHOT_2(Constants.secondPowerShotCoordinates.getX(), Constants.secondPowerShotCoordinates.getY()),\n+    POWERSHOT_3(Constants.thirdPowerShotCoordinates.getX(), Constants.thirdPowerShotCoordinates.getY()),\n+\n+    // Second wobble\n+    SECOND_WOBBLE(2.5 * Constants.tileWidth, Constants.tileWidth),\n+\n+    // Parking position\n+    PARKING_POSITION(2.5 * Constants.tileWidth, 3.5 * Constants.tileWidth);\n+\n+    private final double x;\n+    private final double y;\n+\n+    Coordinates(double x, double y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    public double getX() {\n+        return x;\n+    }\n+\n+    public double getY() {\n+        return y;\n+    }\n+\n+    public Vector2d getCoordinates() {\n+        return new Vector2d(x, y);\n+    }\n+}"
  },
  {
    "sha": "6f44b1ced4c6258058dd3a845c14c84f03e8ba65",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/GameState.java",
    "status": "added",
    "additions": 31,
    "deletions": 0,
    "changes": 31,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/GameState.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/GameState.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/GameState.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -0,0 +1,31 @@\n+package org.firstinspires.ftc.teamcode.helpers;\n+\n+public enum GameState {\n+    INITIAL,//Game starts!\n+    //Robot uses vuforia with right side camera\n+    AVOID_RINGS,\n+    DELIVER_WOBBLE, //Use roadrunner to go to specified target zone and drop off wobble goal\n+    CALIBRATE_LOCATION,\n+    DRIVE_TO_SHOOTING_LOCATION, //Robot drives forward to right behind shooting line\n+    POWERSHOT,\n+    SHOOT1, //Shoot the first power shot\n+    SHOOT2, //Shoot the first power shot\n+    SHOOT3, //Shoot the first power shot\n+    DELIVER_SECOND_WOBBLE, //Drive to second wobble goal\n+    COLLECT_SECOND_WOBBLE, //Pick up second wobble goal\n+    RETURN_TO_NEST,//Backup and park on line using vuforia\n+    COMPLETE,\n+    //FOR TESTING PURPOSES (CALLIBRATION)\n+    INIT,//Game starts!\n+    //Robot uses vuforia with right side camera\n+    TEST_ROADRUNNER, //Use roadrunner to go to specified target zone and drop off wobble goal\n+    TEST_IMU, //Robot drives forward to right behind shooting line\n+    TEST_SHOOTING,\n+    TEST_INTAKE, //Drive to second wobble goal\n+    TEST_VUFORIA, //Pick up second wobble goal\n+    TEST_YEET_UP,//Backup and park on line using vuforia\n+    TEST_YEET_DOWN,//Backup and park on line using vuforia\n+    TEST_TENSORFLOW,\n+    TEST_ENCODERS,\n+    TERMINATE\n+}"
  },
  {
    "sha": "da0f5141910322b3091e930e0df2c4e898989398",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/StandardTrackingWheelLocalizer.java",
    "status": "renamed",
    "additions": 6,
    "deletions": 3,
    "changes": 9,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/StandardTrackingWheelLocalizer.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/StandardTrackingWheelLocalizer.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/StandardTrackingWheelLocalizer.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -1,9 +1,12 @@\n-package org.firstinspires.ftc.teamcode.components;\n+package org.firstinspires.ftc.teamcode.helpers;\n \n import com.acmerobotics.roadrunner.geometry.Pose2d;\n import com.acmerobotics.roadrunner.localization.ThreeTrackingWheelLocalizer;\n import com.qualcomm.robotcore.hardware.DcMotorEx;\n import com.qualcomm.robotcore.hardware.HardwareMap;\n+\n+import org.firstinspires.ftc.teamcode.components.Encoder;\n+\n import java.util.Arrays;\n import java.util.List;\n \n@@ -25,8 +28,8 @@\n     public static double WHEEL_RADIUS = 1; // in\n     public static double GEAR_RATIO = 1; // output (wheel) speed / input (encoder) speed\n \n-    public static double LATERAL_DISTANCE = 3.5; // in; distance between the left and right wheels\n-    public static double FORWARD_OFFSET = 3.4; // in; offset of the lateral wheel\n+    public static double LATERAL_DISTANCE = 3.532; // in; distance between the left and right wheels\n+    public static double FORWARD_OFFSET = 3.326772; // in; offset of the lateral wheel\n \n     public static double X_MULTIPLIER = 1.0;\n     public static double Y_MULTIPLIER = 1.0;",
    "previous_filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/components/StandardTrackingWheelLocalizer.java"
  },
  {
    "sha": "ec57a214bc86f071482c4abeeaf18be75c7cfc51",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Target.java",
    "status": "added",
    "additions": 16,
    "deletions": 0,
    "changes": 16,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Target.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Target.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Target.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -0,0 +1,16 @@\n+package org.firstinspires.ftc.teamcode.helpers;\n+\n+public enum Target {\n+    //TODO Find out powers for each goal\n+    POWER_SHOT (1000),\n+    TOWER_GOAL (1000);\n+\n+    private final double rpm;\n+    Target(double rpm) {\n+        this.rpm = rpm;\n+    }\n+\n+    public double getRpm() {\n+        return rpm;\n+    }\n+}"
  },
  {
    "sha": "e5f51d89674c155e2b5ed8ec1e4bed8fb525cab2",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Trajectories.java",
    "status": "added",
    "additions": 75,
    "deletions": 0,
    "changes": 75,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Trajectories.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Trajectories.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/helpers/Trajectories.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -0,0 +1,75 @@\n+package org.firstinspires.ftc.teamcode.helpers;\n+\n+import com.acmerobotics.roadrunner.geometry.Pose2d;\n+import com.acmerobotics.roadrunner.trajectory.Trajectory;\n+import com.acmerobotics.roadrunner.trajectory.TrajectoryBuilder;\n+\n+import org.firstinspires.ftc.teamcode.components.RoadRunnerDriveSystem;\n+import org.firstinspires.ftc.teamcode.opmodes.autonomous.AutonomousOpMode;\n+\n+public class Trajectories {\n+\n+    /**\n+     * Gets the trajectory for a given state\n+     * @param currentState to draw trajectory for\n+     * @param posEstimate current position estimate\n+     * @return Trajectory for currentState\n+     */\n+    public static Trajectory getTrajectory(GameState currentState, Pose2d posEstimate) {\n+        //TODO Add turns to the trajectories as needed\n+        //TODO figure out the initial movements of the robot from start\n+        TrajectoryBuilder trajectoryBuilder = RoadRunnerDriveSystem.trajectoryBuilder(posEstimate);\n+        switch (currentState) {\n+            case AVOID_RINGS:\n+                trajectoryBuilder.lineToConstantHeading(Coordinates.DETOUR_POSITION.getCoordinates());\n+                break;\n+\n+            case DELIVER_WOBBLE:\n+                switch (AutonomousOpMode.targetRegion) {\n+                    case BOX_A:\n+                        trajectoryBuilder.lineToConstantHeading(Coordinates.BOX_A.getCoordinates());\n+                        break;\n+\n+                    case BOX_B:\n+                        trajectoryBuilder.lineToConstantHeading(Coordinates.BOX_B.getCoordinates());\n+                        break;\n+\n+                    case BOX_C:\n+                        trajectoryBuilder.lineToConstantHeading(Coordinates.BOX_C.getCoordinates());\n+                        break;\n+\n+                    default:\n+                        throw new IllegalStateException(\"Unexpected value: \" + AutonomousOpMode.targetRegion);\n+                }\n+                break;\n+\n+            case CALIBRATE_LOCATION:\n+                trajectoryBuilder.lineToConstantHeading(Coordinates.CALIBRATION.getCoordinates());\n+                break;\n+\n+            case DRIVE_TO_SHOOTING_LOCATION:\n+                trajectoryBuilder.lineToConstantHeading(Coordinates.POWERSHOT_1.getCoordinates());\n+                break;\n+\n+            case SHOOT2:\n+                trajectoryBuilder.lineToConstantHeading(Coordinates.POWERSHOT_2.getCoordinates());\n+                break;\n+\n+            case SHOOT3:\n+                trajectoryBuilder.lineToConstantHeading(Coordinates.POWERSHOT_3.getCoordinates());\n+                break;\n+\n+            case DELIVER_SECOND_WOBBLE:\n+                trajectoryBuilder.lineToConstantHeading(Coordinates.SECOND_WOBBLE.getCoordinates());\n+                break;\n+\n+            case RETURN_TO_NEST:\n+                trajectoryBuilder.lineToConstantHeading(Coordinates.PARKING_POSITION.getCoordinates());\n+                break;\n+            default:\n+                return null;\n+        }\n+\n+        return trajectoryBuilder.build();\n+    }\n+}"
  },
  {
    "sha": "eba8e5dbe2f2e5149100e5c397fe64c62eebea7f",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/autonomous/AutonomousOpMode.java",
    "status": "added",
    "additions": 138,
    "deletions": 0,
    "changes": 138,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/autonomous/AutonomousOpMode.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/autonomous/AutonomousOpMode.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/autonomous/AutonomousOpMode.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -0,0 +1,138 @@\n+package org.firstinspires.ftc.teamcode.opmodes.autonomous;\n+\n+import com.acmerobotics.roadrunner.geometry.Pose2d;\n+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n+\n+import org.firstinspires.ftc.teamcode.components.Tensorflow;\n+import org.firstinspires.ftc.teamcode.helpers.Constants;\n+import org.firstinspires.ftc.teamcode.helpers.Coordinates;\n+import org.firstinspires.ftc.teamcode.helpers.GameState;\n+import org.firstinspires.ftc.teamcode.helpers.Target;\n+import org.firstinspires.ftc.teamcode.helpers.Trajectories;\n+import org.firstinspires.ftc.teamcode.opmodes.base.BaseOpMode;\n+\n+@Autonomous(name = \"AutonomousOpMode\", group = \"Autonomous\")\n+public class AutonomousOpMode extends BaseOpMode {\n+\n+    // Variables\n+    protected GameState currentGameState;                         // Current GameState Machine GameState.\n+    public static Tensorflow.SquareState targetRegion;\n+    protected boolean deliveredFirstWobble;\n+\n+    // Systems\n+    protected Tensorflow tensorflow;\n+\n+    @Override\n+    public void init() {\n+        super.init();\n+        deliveredFirstWobble = false;\n+        tensorflow = new Tensorflow(hardwareMap.appContext.getResources().getIdentifier(\"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName()));\n+        tensorflow.activate();\n+        newGameState(GameState.INITIAL);\n+    }\n+\n+    @Override\n+    public void init_loop() {\n+        targetRegion = tensorflow.getTargetRegion();\n+    }\n+\n+    @Override\n+    public void start() {\n+        tensorflow.shutdown();\n+        super.start();\n+    }\n+\n+    @Override\n+    public void loop() {\n+        vuforiaData();\n+        telemetry.addData(\"GameState\", currentGameState);\n+        telemetry.update();\n+\n+        trajectoryFinished = roadRunnerDriveSystem.update();\n+\n+        // Makes sure the trajectory is finished before doing anything else\n+        if (trajectoryFinished) {\n+            switch (currentGameState) {\n+                case INITIAL:\n+                   // Initialize\n+                    newGameState(GameState.AVOID_RINGS);\n+                    break;\n+\n+                case AVOID_RINGS:\n+                    roadRunnerDriveSystem.turnAsync(-Math.PI / 2);\n+                    newGameState(GameState.DELIVER_WOBBLE);\n+                    break;\n+\n+                case DELIVER_WOBBLE:\n+                    if (yeetSystem.placed()) {\n+                        yeetSystem.pickedUp();\n+                        newGameState(deliveredFirstWobble ? GameState.RETURN_TO_NEST : GameState.CALIBRATE_LOCATION);\n+                    }\n+                    break;\n+\n+                case CALIBRATE_LOCATION:\n+                    deliveredFirstWobble = true;\n+                    calibrateLocation();\n+                    newGameState(GameState.DRIVE_TO_SHOOTING_LOCATION);\n+                    break;\n+\n+                case DRIVE_TO_SHOOTING_LOCATION:\n+                    shootingSystem.warmUp(Target.POWER_SHOT);\n+                    newGameState(GameState.POWERSHOT);\n+                    break;\n+\n+                case POWERSHOT:\n+                    if (powerShotRoutine()) {\n+                        newGameState(GameState.DELIVER_SECOND_WOBBLE);\n+                    }\n+                    break;\n+\n+                case DELIVER_SECOND_WOBBLE:\n+                    if (yeetSystem.pickedUp()) {\n+                        newGameState(GameState.DELIVER_WOBBLE);\n+                    }\n+                    break;\n+\n+                case RETURN_TO_NEST:\n+                    newGameState(GameState.COMPLETE);\n+                    break;\n+\n+                case COMPLETE:\n+                    stop();\n+                    break;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (tensorflow != null) {\n+            tensorflow.shutdown();\n+        }\n+    }\n+\n+    /**\n+     * Updates the state of the system and updates RoadRunner trajectory\n+     * @param newGameState to switch to\n+     */\n+    protected void newGameState(GameState newGameState) {\n+        currentGameState = newGameState;\n+        currentPosition = roadRunnerDriveSystem.getPositionEstimate();\n+        trajectory = Trajectories.getTrajectory(currentGameState, currentPosition);\n+        if (trajectory != null) {\n+            roadRunnerDriveSystem.followTrajectoryAsync(trajectory);\n+        }\n+    }\n+\n+    /**\n+     * Calibrates RoadRunner using Vuforia data\n+     * Because camera is sideways, the x offset corresponds to y coordinates and visa versa\n+     * Vuforia is in millimeters and everything else is in inches\n+     */\n+    private void calibrateLocation() {\n+        double xUpdate = Coordinates.CALIBRATION.getX() - (vuforia.getYOffset() / Constants.mmPerInch - Constants.tileWidth);\n+        double yUpdate = Coordinates.CALIBRATION.getY() + vuforia.getXOffset() / Constants.mmPerInch;\n+        roadRunnerDriveSystem.setPoseEstimate(new Pose2d(xUpdate, yUpdate));\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "bc1be209a012a057a18ee63db2c49f0e938c50ad",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/autonomous/BaseStateMachine.java",
    "status": "removed",
    "additions": 0,
    "deletions": 186,
    "changes": 186,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/beb99b2cf1dac35ec4769647155c7f9e956c5d33/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/autonomous/BaseStateMachine.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/beb99b2cf1dac35ec4769647155c7f9e956c5d33/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/autonomous/BaseStateMachine.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/autonomous/BaseStateMachine.java?ref=beb99b2cf1dac35ec4769647155c7f9e956c5d33",
    "patch": "@@ -1,186 +0,0 @@\n-package org.firstinspires.ftc.teamcode.opmodes.autonomous;\n-\n-import com.acmerobotics.roadrunner.geometry.Pose2d;\n-import com.acmerobotics.roadrunner.trajectory.Trajectory;\n-import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n-import com.qualcomm.robotcore.hardware.ColorSensor;\n-import com.qualcomm.robotcore.hardware.DistanceSensor;\n-import com.qualcomm.robotcore.util.ElapsedTime;\n-\n-import org.firstinspires.ftc.robotcore.external.matrices.VectorF;\n-import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\n-import org.firstinspires.ftc.teamcode.components.Tensorflow;\n-import org.firstinspires.ftc.teamcode.components.VuforiaSystem;\n-import org.firstinspires.ftc.teamcode.opmodes.base.BaseOpMode;\n-\n-@Autonomous(name = \"BaseStateMachine\", group = \"\")\n-public class BaseStateMachine extends BaseOpMode {\n-    public enum State {\n-        STATE_INITIAL,//Game starts!\n-        DRIVE_FORWARD, //Robot drives forward\n-        //Robot uses vuforia with right side camera\n-        STATE_SCAN_RINGS, //Scan stack of rings\n-        DRIVE_TO_SHOOTING_LINE, //Robot drives forward to right behind shooting line\n-        STATE_SHOOT, //Shoot power shots, strafing left to get all 3\n-        STATE_DELIVER_WOBBLE, //Use roadrunner to go to specified target zone and drop off wobble goal\n-        STATE_DRIVE_TO_WOBBLE,//Turn around and drive towards second wobble goal\n-        STATE_COLLECT_WOBBLE,//Pick up second wobble goal\n-        //Turn around and drive back to target zone (STATE_ROADRUNNER)\n-        //Drop off second wobble goal (STATE_DELIVER_WOBBLE)\n-        STATE_RETURN_TO_NEST,//Backup and park on line using vuforia\n-        STATE_COMPLETE,\n-        LOGGING;\n-    }\n-\n-    private State mCurrentState;                         // Current State Machine State.\n-    private ElapsedTime mStateTime = new ElapsedTime();  // Time into current state\n-    private Tensorflow mTensorflow;\n-    private Tensorflow.SquareState mTargetRegion;\n-    Trajectory trajectory;\n-//    private Shooter mShooter;\n-//    private IntakeSystem mIntakeSystem;\n-\n-    @Override\n-    public void init() {\n-        super.init();\n-        mTensorflow = new Tensorflow(hardwareMap.appContext.getResources().getIdentifier(\"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName()));\n-        mTensorflow.activate();\n-\n-        //TODO add shooter and intakes system\n-        //mShooter = new Shooter(hardwareMap.get(DcMotor.class, \"Shooter Motor\"));\n-        newState(State.STATE_INITIAL);\n-    }\n-\n-    @Override\n-    public void init_loop() {\n-        mTargetRegion = mTensorflow.getTargetRegion();\n-        telemetry.addData(\"MESSAGE:\", \"TargetRegion is: \" + mTargetRegion);\n-    }\n-\n-    @Override\n-    public void start() {\n-        if (mTargetRegion == null) mTargetRegion = Tensorflow.SquareState.BOX_A;\n-        mTensorflow.shutdown();\n-        super.start();\n-    }\n-\n-    @Override\n-    public void loop() {\n-        vuforiaData();\n-        telemetry.addData(\"State\", mCurrentState);\n-        telemetry.update();\n-        switch (mCurrentState) { // TODO: This monstrosity.\n-            case LOGGING:\n-                break;\n-\n-            case STATE_INITIAL:\n-                // Initialize\n-                newState(State.STATE_DELIVER_WOBBLE);\n-                break;\n-\n-            case DRIVE_FORWARD:\n-                trajectory = roadRunnerDriveSystem.trajectoryBuilder(new Pose2d())\n-                        .forward(36)\n-                        .build();\n-                newState(State.STATE_SCAN_RINGS);\n-                break;\n-\n-            case STATE_SCAN_RINGS:\n-                newState(State.DRIVE_TO_SHOOTING_LINE);\n-                break;\n-\n-            case DRIVE_TO_SHOOTING_LINE:\n-                trajectory = roadRunnerDriveSystem.trajectoryBuilder(new Pose2d())\n-                        .forward(24)\n-                        .build();\n-                newState(State.STATE_SHOOT);\n-                break;\n-\n-            case STATE_SHOOT:\n-                //**Basic Version, stop at white line**\n-                //DriveSystem.stop()\n-                //mShooter.setMotorPower(**Whichever target it's going for**);\n-                //mShooter.shoot();\n-                //for (int i = 1; i < mTotalRings; i++){\n-                //  if (sticks) {\n-                //      DriveSystem.strafe(**Proper number to do it**)\n-                //  }\n-                //  mShooter.shoot();\n-                //}\n-                //mShooter.stop();\n-                //mTotalRings = 0;\n-\n-                //**Advanced Version, from anywhere**\n-                //DriveSystem.stop()\n-                //mShooter.setMotorPower(**Whichever target it's going for**);\n-                //mShooter.shoot();\n-                //for (int i = 1; i < totalRings; i++) {\n-                //  if (sticks) {\n-                //      DriveSystem.strafe(**Proper number to do it**)\n-                //  }\n-                //  mShooter.shoot();\n-                //}\n-                //mShooter.stop();\n-                //mTotalRings = 0;\n-                newState(State.STATE_DELIVER_WOBBLE);\n-                break;\n-\n-            case STATE_DELIVER_WOBBLE:\n-                //TODO Search for goal? Drop off goal? (something).dropWobbleGoal() maybe pickup wobblegoal\n-                Trajectory trajectory;\n-                switch (mTargetRegion) {\n-                    case BOX_A:\n-                        trajectory = roadRunnerDriveSystem.trajectoryBuilder(new Pose2d())\n-                                .forward(48)\n-                                .build();\n-                        break;\n-                    case BOX_B:\n-                        trajectory = roadRunnerDriveSystem.trajectoryBuilder(new Pose2d())\n-                                .strafeLeft(24)\n-                                .forward(24)\n-                                .build();\n-                        break;\n-                    case BOX_C:\n-                        trajectory = roadRunnerDriveSystem.trajectoryBuilder(new Pose2d())\n-                                .strafeLeft(48)\n-                                .forward(48)\n-                                .build();\n-                        break;\n-\n-                    default:\n-                        throw new IllegalStateException(\"Unexpected value: \" + mTargetRegion);\n-                }\n-                roadRunnerDriveSystem.turn(-90);\n-                roadRunnerDriveSystem.followTrajectory(trajectory);\n-                break;\n-\n-            case STATE_DRIVE_TO_WOBBLE:\n-                break;\n-\n-            case STATE_COLLECT_WOBBLE:\n-                newState(State.STATE_RETURN_TO_NEST);\n-                break;\n-\n-            case STATE_RETURN_TO_NEST:\n-                newState(State.STATE_COMPLETE);\n-                break;\n-\n-            case STATE_COMPLETE:\n-                break;\n-        }\n-    }\n-\n-    @Override\n-    public void stop() {\n-        super.stop();\n-        if (mTensorflow != null) {\n-            mTensorflow.shutdown();\n-        }\n-    }\n-\n-    private void newState(State newState) {\n-        // Restarts the state clock as well as the state\n-        mStateTime.reset();\n-        mCurrentState = newState;\n-    }\n-}\n\\ No newline at end of file"
  },
  {
    "sha": "9ae82c127ec145d30b339cf1593ed9cbedb588ba",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/autonomous/TensorFlowVuforiaSwitchTest2.java",
    "status": "removed",
    "additions": 0,
    "deletions": 68,
    "changes": 68,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/beb99b2cf1dac35ec4769647155c7f9e956c5d33/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/autonomous/TensorFlowVuforiaSwitchTest2.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/beb99b2cf1dac35ec4769647155c7f9e956c5d33/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/autonomous/TensorFlowVuforiaSwitchTest2.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/autonomous/TensorFlowVuforiaSwitchTest2.java?ref=beb99b2cf1dac35ec4769647155c7f9e956c5d33",
    "patch": "@@ -1,68 +0,0 @@\n-package org.firstinspires.ftc.teamcode.opmodes.autonomous;\n-\n-import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n-import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n-import com.qualcomm.robotcore.util.ElapsedTime;\n-\n-import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\n-import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;\n-import org.firstinspires.ftc.robotcore.external.matrices.VectorF;\n-import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;\n-import org.firstinspires.ftc.teamcode.components.Tensorflow;\n-import org.firstinspires.ftc.teamcode.components.VuforiaSystem;\n-\n-@Autonomous(name = \"TensorFlowVuforiaSwitchTest2\", group = \"\")\n-public class TensorFlowVuforiaSwitchTest2 extends OpMode {\n-\n-    private final static String TAG = \"MESSAGE\";\n-    private static final float mmPerInch = 25.4f;\n-    private ElapsedTime mStateTime = new ElapsedTime();  // Time into current state\n-    private Tensorflow mTensorflow;\n-    private VuforiaSystem mVuforia;\n-    private Tensorflow.SquareState mTargetRegion;\n-\n-    @Override\n-    public void init() {\n-        this.msStuckDetectInit = 15000;\n-        this.msStuckDetectInitLoop = 15000;\n-\n-        /*\n-        * hardwareMap.get(WebcamName.class, \"Webcam 1\")\n-        * For use when using the webcame in place of null for get Instance\n-        */\n-        mVuforia = VuforiaSystem.getInstance();\n-        mTensorflow = new Tensorflow(hardwareMap.appContext.getResources().getIdentifier(\"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName()));\n-        mTensorflow.activate();\n-    }\n-\n-    @Override\n-    public void init_loop() {\n-        mTargetRegion = mTensorflow.getTargetRegion();\n-        telemetry.addData(TAG, \"TargetRegion is: \" + mTargetRegion);\n-    }\n-\n-    @Override\n-    public void start() {\n-        if (mTargetRegion == null) mTargetRegion = Tensorflow.SquareState.BOX_A;\n-        mTensorflow.shutdown();\n-        mVuforia.activate();\n-    }\n-\n-    @Override\n-    public void loop() {\n-        VectorF translation = mVuforia.vector();\n-        if (translation != null) {\n-            telemetry.addData(\"Pos (in)\", \"{X, Y, Z} = %.1f, %.1f, %.1f\",\n-                    translation.get(0) / mmPerInch, translation.get(1) / mmPerInch, translation.get(2) / mmPerInch);\n-        }\n-        telemetry.addData(\"Pos (in)\", \"{X, Y, Z} = %.1f, %.1f, %.1f\",\n-                mVuforia.getXOffset() / mmPerInch, mVuforia.getYOffset() / mmPerInch, mVuforia.getZOffset() / mmPerInch);\n-    }\n-\n-    @Override\n-    public void stop() {\n-        if (mVuforia != null) {\n-            mVuforia.disable();\n-        }\n-    }\n-}"
  },
  {
    "sha": "ab5a83af9520ffafe35afc2de8d5c3227b16fdfa",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/base/BaseOpMode.java",
    "status": "modified",
    "additions": 112,
    "deletions": 7,
    "changes": 119,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/base/BaseOpMode.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/base/BaseOpMode.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/base/BaseOpMode.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -1,56 +1,161 @@\n package org.firstinspires.ftc.teamcode.opmodes.base;\n \n+import com.acmerobotics.roadrunner.geometry.Pose2d;\n+import com.acmerobotics.roadrunner.trajectory.Trajectory;\n import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.DcMotorEx;\n+import com.qualcomm.robotcore.hardware.Servo;\n+\n import org.firstinspires.ftc.robotcore.external.matrices.VectorF;\n import org.firstinspires.ftc.teamcode.components.RoadRunnerDriveSystem;\n+import org.firstinspires.ftc.teamcode.components.ShootingSystem;\n import org.firstinspires.ftc.teamcode.components.VuforiaSystem;\n+import org.firstinspires.ftc.teamcode.components.YeetSystem;\n+import org.firstinspires.ftc.teamcode.helpers.Constants;\n+import org.firstinspires.ftc.teamcode.helpers.Coordinates;\n+import org.firstinspires.ftc.teamcode.helpers.GameState;\n+import org.firstinspires.ftc.teamcode.helpers.Trajectories;\n \n public abstract class BaseOpMode extends OpMode {\n \n+    // Variables\n+    protected Trajectory trajectory;\n+    protected boolean trajectoryFinished;\n+    protected Pose2d currentPosition;\n+\n+    // Powershot\n+    private enum PowerShotState {\n+        IDLE,\n+        ONE,\n+        TWO,\n+        THREE,\n+        FINISHED\n+    }\n+    private PowerShotState powerShotState;\n+\n+    // Systems\n     protected RoadRunnerDriveSystem roadRunnerDriveSystem;\n-    private static final float mmPerInch = 25.4f;\n     protected VuforiaSystem vuforia;\n+    protected ShootingSystem shootingSystem;\n+    protected YeetSystem yeetSystem;\n \n     @Override\n     public void init() {\n         this.msStuckDetectInit = 20000;\n         this.msStuckDetectInitLoop = 20000;\n \n-        roadRunnerDriveSystem = new RoadRunnerDriveSystem(hardwareMap);\n+        currentPosition = new Pose2d(Coordinates.STARTING_POSITION.getX(), Coordinates.STARTING_POSITION.getY(), Math.PI);\n         vuforia = VuforiaSystem.getInstance();\n+        powerShotState = PowerShotState.IDLE;\n+\n+        //TODO initialize RoadRunnerDriveSystem, ShootingSystem, and IntakeSystem once hardware online\n+        try {\n+            roadRunnerDriveSystem = new RoadRunnerDriveSystem(hardwareMap);\n+            roadRunnerDriveSystem.setPoseEstimate(currentPosition);\n+        } catch (Exception e) {\n+            telemetry.addData(Constants.ROBOT_SYSTEM_ERROR, e.getStackTrace());\n+        }\n \n-        //TODO initialize RoadRunnerDriveSystem once hardware online\n+        try {\n+            shootingSystem = new ShootingSystem(hardwareMap.get(DcMotorEx.class, \"ShootingSystem\"), hardwareMap.get(Servo.class, \"ShootingSystemServo\"));\n+        } catch (Exception e) {\n+            telemetry.addData(Constants.ROBOT_SYSTEM_ERROR, e.getStackTrace());\n+        }\n+\n+        try {\n+            yeetSystem = new YeetSystem(hardwareMap.get(DcMotorEx.class, \"YeetSystem\"), hardwareMap.get(Servo.class, \"LeftArmServo\"), hardwareMap.get(Servo.class, \"RightArmServo\"));\n+        } catch (Exception e) {\n+            telemetry.addData(Constants.ROBOT_SYSTEM_ERROR, e.getStackTrace());\n+        }\n     }\n \n     @Override\n     public void start() {\n         vuforia.activate();\n     }\n \n-    public void vuforiaData() {\n+    /**\n+     * Initializes Vuforia data\n+     */\n+    protected void vuforiaData() {\n         VectorF translation = vuforia.vector();\n \n         // only one of these two will be used\n         if (translation != null) {\n             telemetry.addData(\"Pos (in)\", \"{X, Y, Z} = %.1f, %.1f, %.1f\",\n-                    translation.get(0) / mmPerInch, translation.get(1) / mmPerInch, translation.get(2) / mmPerInch);\n+                    translation.get(0) / Constants.mmPerInch, translation.get(1) / Constants.mmPerInch, translation.get(2) / Constants.mmPerInch);\n         }\n         telemetry.addData(\"Pos (in)\", \"{X, Y, Z} = %.1f, %.1f, %.1f\",\n-                vuforia.getXOffset() / mmPerInch, vuforia.getYOffset() / mmPerInch, vuforia.getZOffset() / mmPerInch);\n-\n+                vuforia.getXOffset() / Constants.mmPerInch, vuforia.getYOffset() / Constants.mmPerInch, vuforia.getZOffset() / Constants.mmPerInch);\n \n         if (translation != null) {\n             telemetry.addLine(\"null\");\n         } else {\n             telemetry.addLine(\"not null\");\n         }\n+    }\n+\n+    /**\n+     * Powershot routine\n+     * @return if all 3 powershots have been fired\n+     */\n+    protected boolean powerShotRoutine() {\n+        switch (powerShotState) {\n+            case IDLE:\n+                powerShotState = PowerShotState.ONE;\n+                break;\n+\n+            case ONE:\n+                if (atShootingPosition(GameState.SHOOT1)) {\n+                    shootingSystem.shoot();\n+                    powerShotState = PowerShotState.TWO;\n+                }\n+                break;\n+\n+            case TWO:\n+                if (atShootingPosition(GameState.SHOOT2)) {\n+                    shootingSystem.shoot();\n+                    powerShotState = PowerShotState.THREE;\n+                }\n+                break;\n+\n+            case THREE:\n+                if (atShootingPosition(GameState.SHOOT3)) {\n+                    shootingSystem.shoot();\n+                    powerShotState = PowerShotState.FINISHED;\n+                }\n+                break;\n+\n+            case FINISHED:\n+                return true;\n+        }\n+        return false;\n+    }\n \n+    /**\n+     * Assumes shooter is set to State Powershot\n+     * @param shot number to be performed\n+     */\n+    private boolean atShootingPosition(GameState shot) {\n+        trajectory = Trajectories.getTrajectory(shot, currentPosition);\n+        roadRunnerDriveSystem.followTrajectoryAsync(trajectory);\n+        trajectoryFinished = roadRunnerDriveSystem.update();\n+        return trajectoryFinished;\n     }\n \n     @Override\n     public void stop() {\n         if (vuforia != null) {\n             vuforia.disable();\n         }\n+\n+        if (shootingSystem != null) {\n+            shootingSystem.shutDown();\n+        }\n+\n+        if (yeetSystem != null) {\n+            yeetSystem.shutDown();\n+        }\n     }\n }"
  },
  {
    "sha": "076010a8de77888bae2c0518c4f5dc61aaa165ca",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/teleop/DriveTeleop.java",
    "status": "modified",
    "additions": 79,
    "deletions": 8,
    "changes": 87,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/teleop/DriveTeleop.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/teleop/DriveTeleop.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/teleop/DriveTeleop.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -1,25 +1,96 @@\n package org.firstinspires.ftc.teamcode.opmodes.teleop;\n \n import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n \n+import org.firstinspires.ftc.teamcode.components.IntakeSystem;\n+import org.firstinspires.ftc.teamcode.helpers.Constants;\n import org.firstinspires.ftc.teamcode.opmodes.base.BaseOpMode;\n \n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n @TeleOp(name = \"Real Teleop\", group=\"TeleOp\")\n public class DriveTeleop extends BaseOpMode {\n \n-    private boolean leftLatchHit = false;\n-    private boolean rightLatchHit = false;\n+    // FunctionsList\n+    private enum Functions {\n+        RAISE_ARM,\n+        LOWER_ARM,\n+        SUCK,\n+        SHOOT,\n+        DRIVE\n+    }\n+\n+    // Variables\n+    private boolean suckButtonDown;\n+    private List<Functions> calledFunctions;\n+\n+    // Systems\n+    private IntakeSystem intakeSystem;\n \n-    private final double SLIDER_SPEED = 1;\n-    private boolean gripped, down, up;\n-    // private boolean mPlacing;\n-    private boolean mCapstoning, mHoming, mQueuing;\n-    \n-    public void loop(){\n+    @Override\n+    public void init() {\n+        super.init();\n+        try {\n+            intakeSystem = new IntakeSystem(hardwareMap.get(DcMotor.class, \"IntakeSystem\"));\n+        } catch (Exception e) {\n+            telemetry.addData(Constants.ROBOT_SYSTEM_ERROR, e.getStackTrace());\n+        }\n+        calledFunctions = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public void loop() {\n+        //TODO implement gamepad mechanics\n         float rx = (float) Math.pow(gamepad1.right_stick_x, 3);\n         float lx = (float) Math.pow(gamepad1.left_stick_x, 3);\n         float ly = (float) Math.pow(gamepad1.left_stick_y, 3);\n         roadRunnerDriveSystem.slowDrive(gamepad1.left_trigger > 0.3f);\n         roadRunnerDriveSystem.drive(rx, lx, ly);\n+\n+        for (int i = 0; i < calledFunctions.size(); i++) {\n+            switch (calledFunctions.get(i)) {\n+                case RAISE_ARM:\n+                    if (yeetSystem.pickedUp()) {\n+                        calledFunctions.remove(i);\n+                        i--;\n+                    }\n+                    break;\n+\n+                case LOWER_ARM:\n+                    if (yeetSystem.placed()) {\n+                        calledFunctions.remove(i);\n+                        i--;\n+                    }\n+                    break;\n+\n+                case SHOOT:\n+                    if (powerShotRoutine()) {\n+                        calledFunctions.remove(i);\n+                        i--;\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        if (gamepad1.a) {\n+            intakeSystem.suck();\n+        } else {\n+            intakeSystem.stop();\n+        }\n+\n+        if (gamepad1.left_bumper) {\n+            calledFunctions.add(Functions.RAISE_ARM);\n+        }\n+\n+        if (gamepad1.right_bumper) {\n+            calledFunctions.add(Functions.LOWER_ARM);\n+        }\n+\n+        if (gamepad1.b) {\n+            calledFunctions.add(Functions.SHOOT);\n+        }\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "65abb03cfaaf1125d15381bd4778128290bf108b",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/AutonomousDriveTest.java",
    "status": "added",
    "additions": 144,
    "deletions": 0,
    "changes": 144,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/AutonomousDriveTest.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/AutonomousDriveTest.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/AutonomousDriveTest.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -0,0 +1,144 @@\n+package org.firstinspires.ftc.teamcode.tests;\n+\n+import com.acmerobotics.roadrunner.geometry.Pose2d;\n+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n+import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.DcMotorEx;\n+import com.qualcomm.robotcore.hardware.Servo;\n+import com.qualcomm.robotcore.util.ElapsedTime;\n+\n+import org.firstinspires.ftc.teamcode.components.ShootingSystem;\n+import org.firstinspires.ftc.teamcode.components.YeetSystem;\n+import org.firstinspires.ftc.teamcode.helpers.Constants;\n+import org.firstinspires.ftc.teamcode.helpers.Coordinates;\n+import org.firstinspires.ftc.teamcode.helpers.GameState;\n+import org.firstinspires.ftc.teamcode.helpers.Target;\n+\n+@Autonomous(name = \"AutonomousDriveTest\", group = \"Autonomous\")\n+public class AutonomousDriveTest extends OpMode {\n+\n+    // Variables\n+    protected GameState currentGameState;\n+\n+    // Variables\n+    protected Pose2d currentPosition;\n+\n+    // Systems\n+//    protected RoadRunnerDriveSystem roadRunnerDriveSystem;\n+//    protected YeetSystem yeetSystem;\n+    protected ShootingSystem shootingSystem;\n+    protected YeetSystem yeetSystem;\n+    protected ElapsedTime elapsedTime;\n+\n+    @Override\n+    public void init() {\n+        this.msStuckDetectInit = 20000;\n+        this.msStuckDetectInitLoop = 20000;\n+        elapsedTime = new ElapsedTime();\n+\n+        currentPosition = new Pose2d(Coordinates.STARTING_POSITION.getX(), Coordinates.STARTING_POSITION.getY(), Math.PI);\n+\n+        //Initialize RoadRunner\n+        try {\n+//            roadRunnerDriveSystem = new RoadRunnerDriveSystem(hardwareMap);\n+//            roadRunnerDriveSystem.setPoseEstimate(currentPosition);\n+        } catch (Exception e) {\n+            telemetry.addData(Constants.ROBOT_SYSTEM_ERROR, e.getStackTrace());\n+        }\n+\n+        shootingSystem = new ShootingSystem(hardwareMap.get(DcMotorEx.class, \"ShootingSystem\"), hardwareMap.get(Servo.class, \"ShootingSystemServo\"));\n+\n+        yeetSystem = new YeetSystem(hardwareMap.get(DcMotorEx.class, \"YeetSystem\"), hardwareMap.get(Servo.class, \"LeftArmServo\"), hardwareMap.get(Servo.class, \"RightArmServo\"));\n+        newGameState(GameState.INITIAL);\n+    }\n+\n+    @Override\n+    public void init_loop() {\n+\n+    }\n+\n+    @Override\n+    public void start() {\n+        super.start();\n+    }\n+\n+    @Override\n+    public void loop() {\n+        telemetry.addData(\"GameState\", currentGameState);\n+\n+\n+        // Makes sure the trajectory is finished before doing anything else\n+//        boolean trajectoryFinished = roadRunnerDriveSystem.update();\n+//        Pose2d poseEstimate = roadRunnerDriveSystem.getPoseEstimate();\n+//        telemetry.addData(\"x\", poseEstimate.getX());\n+//        telemetry.addData(\"y\", poseEstimate.getY());\n+//        telemetry.addData(\"heading\", poseEstimate.getHeading());\n+        telemetry.update();\n+\n+        switch (currentGameState) {\n+            case INITIAL:\n+                // Initialize\n+                newGameState(GameState.DELIVER_WOBBLE);\n+                break;\n+\n+            case DELIVER_WOBBLE:\n+                if (yeetSystem.pickedUp()) {\n+                    elapsedTime.reset();\n+                    newGameState(GameState.CALIBRATE_LOCATION);\n+                }\n+\n+                break;\n+\n+            case CALIBRATE_LOCATION:\n+                if (elapsedTime.seconds() > 2) {\n+                    newGameState(GameState.DRIVE_TO_SHOOTING_LOCATION);\n+                }\n+                break;\n+\n+            case DRIVE_TO_SHOOTING_LOCATION:\n+                if (yeetSystem.placed()) {\n+                    newGameState(GameState.COMPLETE);\n+                }\n+                break;\n+\n+            case POWERSHOT:\n+                //TODO do the powershot routine\n+                newGameState(GameState.DELIVER_SECOND_WOBBLE);\n+                break;\n+\n+            case DELIVER_SECOND_WOBBLE:\n+                //TODO drive to the second wobble goal\n+                newGameState(GameState.COLLECT_SECOND_WOBBLE);\n+                break;\n+\n+            case COLLECT_SECOND_WOBBLE:\n+                //TODO position the robot and collect the second wobble goal\n+                newGameState(GameState.DELIVER_WOBBLE);\n+                break;\n+\n+            case RETURN_TO_NEST:\n+                //TODO drive back to nest\n+                newGameState(GameState.COMPLETE);\n+                break;\n+\n+            case COMPLETE:\n+                //TODO park the robot, shut down system, and release used resources\n+                stop();\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+\n+    }\n+\n+    /**\n+     * Updates the state of the system and updates RoadRunner trajectory\n+     * @param newGameState to switch to\n+     */\n+    protected void newGameState(GameState newGameState) {\n+        currentGameState = newGameState;\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "cc726388ff0d1d0cd07552233920400f89cd5209",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/AutonomousSelfCheck.java",
    "status": "added",
    "additions": 94,
    "deletions": 0,
    "changes": 94,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/AutonomousSelfCheck.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/AutonomousSelfCheck.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/AutonomousSelfCheck.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -0,0 +1,94 @@\n+package org.firstinspires.ftc.teamcode.tests;\n+\n+import com.acmerobotics.roadrunner.geometry.Pose2d;\n+import com.acmerobotics.roadrunner.trajectory.TrajectoryBuilder;\n+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+\n+import org.firstinspires.ftc.teamcode.components.IntakeSystem;\n+import org.firstinspires.ftc.teamcode.components.RoadRunnerDriveSystem;\n+import org.firstinspires.ftc.teamcode.helpers.GameState;\n+import org.firstinspires.ftc.teamcode.helpers.Target;\n+import org.firstinspires.ftc.teamcode.opmodes.autonomous.AutonomousOpMode;\n+\n+@Autonomous(name = \"AutonomousSelfCheck\", group = \"Autonomous\")\n+public class AutonomousSelfCheck extends AutonomousOpMode {\n+\n+    private Pose2d oldPosEstimate;\n+    private IntakeSystem intake = new IntakeSystem(hardwareMap.get(DcMotor.class, \"IntakeSystem\"));\n+    private boolean first = true;\n+    TrajectoryBuilder trajectoryBuilder = RoadRunnerDriveSystem.trajectoryBuilder(currentPosition);\n+\n+    @Override\n+    public void loop() {\n+        double x = time;\n+        int i = 0;\n+        switch (currentGameState) { // TODO: This monstrosity.\n+            //TODO Do we need a trajectory as a field?\n+            case TEST_YEET_UP:\n+//                yeetSystem.pickup();\n+//                if (yeetSystem.isUp()) {\n+//                    yeetSystem.powerDown();\n+//                    newGameState(GameState.TEST_YEET_DOWN);\n+//                }\n+            case TEST_YEET_DOWN:\n+                yeetSystem.placed();\n+//                if (yeetSystem.isDown()) {\n+//                    yeetSystem.powerDown();\n+//                    newGameState(GameState.TEST_SHOOTING);\n+//                }\n+            case TEST_SHOOTING:\n+                shootingSystem.warmUp(Target.POWER_SHOT);\n+                shootingSystem.shoot();\n+                shootingSystem.shutDown();\n+                newGameState(GameState.TEST_INTAKE);\n+            case TEST_INTAKE:\n+                intake.suck();\n+                intake.stop();\n+                newGameState(GameState.TEST_VUFORIA);\n+            case TEST_VUFORIA:\n+                vuforiaData();\n+                telemetry.addData(\"GameState\", currentGameState);\n+                telemetry.update();\n+                newGameState(GameState.TEST_TENSORFLOW);\n+            case TEST_TENSORFLOW:\n+                targetRegion = tensorflow.getTargetRegion();\n+                telemetry.addData(\"TensorFlow Target\", targetRegion);\n+                telemetry.update();\n+                newGameState(GameState.TEST_ROADRUNNER);\n+            case TEST_ROADRUNNER:\n+                if (first) {\n+                    trajectoryBuilder.strafeLeft(5);\n+                    if (trajectory != null) {\n+                        roadRunnerDriveSystem.followTrajectory(trajectory);\n+                    }\n+                    if (roadRunnerDriveSystem.update()){\n+                        first = false;\n+                    }\n+                }\n+                trajectoryBuilder = RoadRunnerDriveSystem.trajectoryBuilder(currentPosition);\n+                trajectoryBuilder.strafeRight(5);\n+                if (trajectory != null) {\n+                    roadRunnerDriveSystem.followTrajectory(trajectory);\n+                    break;\n+                }\n+                if (roadRunnerDriveSystem.update()) {\n+                    newGameState(GameState.COMPLETE);\n+                }\n+            case COMPLETE:\n+                //TODO park the robot, shut down system, and release used resources\n+                stop();\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (tensorflow != null) {\n+            tensorflow.shutdown();\n+        }\n+    }\n+}\n+\n+"
  },
  {
    "sha": "e7c9394c94a88b30a5e85717292b5dda63908e9c",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/CalibrationTest.java",
    "status": "added",
    "additions": 133,
    "deletions": 0,
    "changes": 133,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/CalibrationTest.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/CalibrationTest.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/CalibrationTest.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -0,0 +1,133 @@\n+package org.firstinspires.ftc.teamcode.tests;\n+\n+import com.acmerobotics.roadrunner.geometry.Pose2d;\n+import com.acmerobotics.roadrunner.geometry.Vector2d;\n+import com.acmerobotics.roadrunner.trajectory.Trajectory;\n+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n+\n+import org.firstinspires.ftc.teamcode.helpers.GameState;\n+import org.firstinspires.ftc.teamcode.components.ShootingSystem;\n+import org.firstinspires.ftc.teamcode.components.Tensorflow;\n+import org.firstinspires.ftc.teamcode.helpers.Trajectories;\n+import org.firstinspires.ftc.teamcode.opmodes.base.BaseOpMode;\n+\n+@Autonomous(name = \"CalibrationOpMode\", group = \"Autonomous\")\n+\n+public class CalibrationTest extends BaseOpMode {\n+\n+    // Variables\n+    private GameState currentGameState;                         // Current GameState Machine GameState.\n+    public static Tensorflow.SquareState targetRegion;\n+    private boolean deliveredFirstWobble;\n+\n+    // Systems\n+    private Tensorflow tensorflow;\n+    private ShootingSystem shootingSystem;\n+\n+    @Override\n+    public void init() {\n+        super.init();\n+        deliveredFirstWobble = false;\n+        tensorflow = new Tensorflow(hardwareMap.appContext.getResources().getIdentifier(\"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName()));\n+        tensorflow.activate();\n+        newGameState(GameState.INITIAL);\n+    }\n+\n+    @Override\n+    public void init_loop() {\n+        targetRegion = tensorflow.getTargetRegion();\n+    }\n+\n+    @Override\n+    public void start() {\n+        tensorflow.shutdown();\n+        super.start();\n+    }\n+\n+    @Override\n+    public void loop() {\n+        vuforiaData();\n+        telemetry.addData(\"GameState\", currentGameState);\n+        telemetry.update();\n+        if (!trajectoryFinished && trajectory != null) {\n+            roadRunnerDriveSystem.followTrajectoryAsync(trajectory);\n+        }\n+        switch (currentGameState) { \n+            \n+            case INIT:\n+                // Initialize\n+                newGameState(GameState.DELIVER_WOBBLE);\n+                break;\n+\n+            case TEST_ROADRUNNER:\n+                Trajectory trajectory = roadRunnerDriveSystem.trajectoryBuilder(new Pose2d())\n+                        .forward(12)\n+                        .splineTo(new Vector2d(0, 0), Math.toRadians(0)) // TODO - these numbers should be changed\n+                        .strafeLeft(6)\n+                        .strafeRight(6)\n+                        .build();\n+                roadRunnerDriveSystem.followTrajectory(trajectory);\n+                roadRunnerDriveSystem.turn(-90);\n+                roadRunnerDriveSystem.turn(90);\n+                if (roadRunnerDriveSystem.getPositionEstimate() == new Pose2d(0, 0)){ // TODO - Pose2D needs coordinates to compare and calculate\n+                    telemetry.addLine(\"RoadRunner: ✔\");\n+                } else{\n+                    telemetry.addLine(\"RoadRunner: ❌\");\n+                }\n+                newGameState(GameState.TEST_IMU);\n+                break;\n+\n+            case TEST_IMU:\n+\n+                deliveredFirstWobble = true;\n+                if (trajectoryFinished) {\n+                    newGameState(GameState.POWERSHOT);\n+                }\n+                break;\n+\n+            case TEST_SHOOTING:\n+\n+                newGameState(GameState.DELIVER_SECOND_WOBBLE);\n+                break;\n+\n+            case TEST_INTAKE:\n+                // Intake system is moved to teleop only so no need to test this anymore\n+//                intakeSystem.initMotors();\n+//                intakeSystem.suck();\n+//                intakeSystem.stop();\n+                newGameState(GameState.TEST_YEET_UP);\n+                break;\n+\n+            case TEST_YEET_UP:\n+                if (yeetSystem.pickedUp()) {\n+                    newGameState(GameState.TEST_YEET_DOWN);\n+                }\n+            case TEST_YEET_DOWN:\n+                if (yeetSystem.placed()) {\n+                    newGameState(GameState.TEST_VUFORIA);\n+                }\n+            case TEST_VUFORIA:\n+                newGameState(GameState.COMPLETE);\n+                break;\n+\n+            case TERMINATE:\n+\n+                stop();\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (tensorflow != null) {\n+            tensorflow.shutdown();\n+        }\n+    }\n+\n+    private void newGameState(GameState newGameState) {\n+        currentGameState = newGameState;\n+        Pose2d posEstimate = roadRunnerDriveSystem.getPositionEstimate();\n+        trajectory = Trajectories.getTrajectory(currentGameState, posEstimate);\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "b77266c8bcb23f821822f189146eb935d08fd3fa",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/DriveTest.java",
    "status": "renamed",
    "additions": 6,
    "deletions": 12,
    "changes": 18,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/DriveTest.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/DriveTest.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/DriveTest.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -1,11 +1,10 @@\n-package org.firstinspires.ftc.teamcode.opmodes.autonomous;\n+package org.firstinspires.ftc.teamcode.tests;\n \n import com.acmerobotics.roadrunner.geometry.Pose2d;\n import com.acmerobotics.roadrunner.geometry.Vector2d;\n import com.acmerobotics.roadrunner.trajectory.Trajectory;\n import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n-import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n \n import org.firstinspires.ftc.teamcode.components.RoadRunnerDriveSystem;\n \n@@ -16,23 +15,19 @@\n     public void runOpMode() throws InterruptedException {\n         RoadRunnerDriveSystem drive = new RoadRunnerDriveSystem(hardwareMap);\n \n-        Trajectory trajectory = drive.trajectoryBuilder(new Pose2d())\n+        Trajectory trajectory = RoadRunnerDriveSystem.trajectoryBuilder(new Pose2d())\n                 .forward(30)\n                 .build();\n \n-        Trajectory trajectory1 = drive.trajectoryBuilder(trajectory.end())\n+        Trajectory trajectory1 = RoadRunnerDriveSystem.trajectoryBuilder(trajectory.end())\n                 .strafeLeft(30)\n                 .build();\n \n-        Trajectory trajectory2 = drive.trajectoryBuilder(trajectory1.end())\n-                .back(15)\n+        Trajectory trajectory2 = RoadRunnerDriveSystem.trajectoryBuilder(trajectory1.end())\n+                .strafeRight(60)\n                 .build();\n \n-        Trajectory trajectory3 = drive.trajectoryBuilder(trajectory2.end())\n-                .splineTo(new Vector2d(30, -30), Math.toRadians(90))\n-                .build();\n-\n-        Trajectory trajectory4 = drive.trajectoryBuilder(trajectory3.end())\n+        Trajectory trajectory3 = RoadRunnerDriveSystem.trajectoryBuilder(trajectory2.end())\n                 .splineTo(new Vector2d(0, 0), Math.toRadians(0))\n                 .build();\n \n@@ -44,6 +39,5 @@ public void runOpMode() throws InterruptedException {\n         drive.followTrajectory(trajectory1);\n         drive.followTrajectory(trajectory2);\n         drive.followTrajectory(trajectory3);\n-        drive.followTrajectory(trajectory4);\n     }\n }",
    "previous_filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/autonomous/DriveTest.java"
  },
  {
    "sha": "1514bf9451e78ad436cbb7cc0441fa2bb50e5c08",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/JUnitTests.java",
    "status": "added",
    "additions": 115,
    "deletions": 0,
    "changes": 115,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/JUnitTests.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/JUnitTests.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/JUnitTests.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -0,0 +1,115 @@\n+package org.firstinspires.ftc.teamcode.tests;\n+\n+import com.acmerobotics.roadrunner.geometry.Pose2d;\n+import com.acmerobotics.roadrunner.geometry.Vector2d;\n+import com.acmerobotics.roadrunner.trajectory.Trajectory;\n+import com.acmerobotics.roadrunner.trajectory.TrajectoryBuilder;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.DcMotorEx;\n+\n+import org.firstinspires.ftc.teamcode.components.Encoder;\n+import org.firstinspires.ftc.teamcode.components.IntakeSystem;\n+import org.firstinspires.ftc.teamcode.components.RoadRunnerDriveSystem;\n+import org.firstinspires.ftc.teamcode.components.Tensorflow;\n+import org.firstinspires.ftc.teamcode.helpers.GameState;\n+import org.firstinspires.ftc.teamcode.helpers.Target;\n+\n+public class JUnitTests extends AutonomousSelfCheck {\n+\n+    private Pose2d oldPosEstimate;\n+    private IntakeSystem intake = new IntakeSystem(hardwareMap.get(DcMotor.class, \"IntakeSystem\"));\n+    private boolean first = true;\n+    TrajectoryBuilder trajectoryBuilder = RoadRunnerDriveSystem.trajectoryBuilder(currentPosition);\n+    private RoadRunnerDriveSystem roadRunnerDriveSystem;\n+\n+    @Override\n+    public void loop() {\n+        double x = time;\n+        int i = 0;\n+        switch (currentGameState) { // TODO: This monstrosity.\n+            //TODO Do we need a trajectory as a field?\n+            case TEST_ENCODERS:\n+                boolean bool = true;\n+                for (DcMotorEx motors : roadRunnerDriveSystem.getMotors()) {\n+                    Encoder encoder = new Encoder(motors);\n+                    if (encoder.getCorrectedVelocity() != 0) {\n+                        bool = false;\n+                    }\n+                    if (encoder.getCorrectedVelocity() != 0) {\n+                        bool = false;\n+                    }\n+                    Encoder.Direction direction = encoder.getDirection();\n+                    encoder.setDirection(encoder.getDirection());\n+                    if (direction != encoder.getDirection()) {\n+                        bool = false;\n+                    }\n+                    // if (encoderTicksToInches == ) TODO: we need a way to check that our conversions are correct\n+                    if (bool = false) {\n+                        telemetry.addLine(\"we have an issue with this encoder\");\n+                    } else {\n+                        telemetry.addLine(\"all good!\");\n+                    }\n+\n+                }\n+                newGameState(GameState.TEST_IMU);\n+\n+            case TEST_ROADRUNNER:\n+                Trajectory trajectory = RoadRunnerDriveSystem.trajectoryBuilder(new Pose2d())\n+                        .forward(12)\n+                        .splineTo(new Vector2d(0, 0), Math.toRadians(0)) // TODO - these numbers should be changed\n+                        .strafeLeft(6)\n+                        .strafeRight(6)\n+                        .build();\n+                roadRunnerDriveSystem.followTrajectory(trajectory);\n+                roadRunnerDriveSystem.turn(-90);\n+                roadRunnerDriveSystem.turn(90);\n+                if (roadRunnerDriveSystem.getPositionEstimate().equals(new Pose2d(0, 0))) { // TODO - Pose2D needs coordinates to compare and calculate\n+                    telemetry.addLine(\"RoadRunner: ✔\");\n+                } else {\n+                    telemetry.addLine(\"RoadRunner: ❌\");\n+                }\n+                newGameState(GameState.TEST_IMU);\n+                break;\n+            case TEST_IMU:\n+                shootingSystem.warmUp(Target.POWER_SHOT);\n+                shootingSystem.shoot();\n+                shootingSystem.shutDown();\n+                newGameState(GameState.TEST_ROADRUNNER);\n+            case TEST_INTAKE:\n+                intake.suck();\n+                intake.stop();\n+                newGameState(GameState.TEST_VUFORIA);\n+            case TEST_VUFORIA:\n+                vuforiaData();\n+                telemetry.addData(\"GameState\", currentGameState);\n+                telemetry.update();\n+                newGameState(GameState.TEST_TENSORFLOW);\n+            case TEST_TENSORFLOW:\n+                targetRegion = tensorflow.getTargetRegion();\n+                if (targetRegion == Tensorflow.SquareState.BOX_C) {\n+                    telemetry.addData(\"TensorFlow Target Correct (Viewing 0 Rings)\", targetRegion);\n+                    telemetry.update();\n+                } else {\n+                    telemetry.addData(\"TensorFlow Target Inorrect (Viewing >0 Rings)\", targetRegion);\n+\n+                }\n+                newGameState(GameState.TEST_ROADRUNNER);\n+\n+            case COMPLETE:\n+                //TODO park the robot, shut down system, and release used resources\n+                stop();\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (tensorflow != null) {\n+            tensorflow.shutdown();\n+        }\n+    }\n+}\n+\n+\n+"
  },
  {
    "sha": "14493d07a72e5cb15626187ed1b3e02f5f9d2488",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/LocalizationTest.java",
    "status": "added",
    "additions": 34,
    "deletions": 0,
    "changes": 34,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/LocalizationTest.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/LocalizationTest.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/LocalizationTest.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -0,0 +1,34 @@\n+package org.firstinspires.ftc.teamcode.tests;\n+\n+import com.acmerobotics.roadrunner.geometry.Pose2d;\n+import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+\n+import org.firstinspires.ftc.teamcode.components.RoadRunnerDriveSystem;\n+\n+/**\n+ * This is a simple teleop routine for testing localization. Drive the robot around like a normal\n+ * teleop routine and make sure the robot's estimated pose matches the robot's actual pose (slight\n+ * errors are not out of the ordinary, especially with sudden drive motions). The goal of this\n+ * exercise is to ascertain whether the localizer has been configured properly (note: the pure\n+ * encoder localizer heading may be significantly off if the track width has not been tuned).\n+ */\n+@TeleOp(group = \"drive\")\n+public class LocalizationTest extends OpMode {\n+    RoadRunnerDriveSystem drive;\n+\n+    public void init() {\n+        drive = new RoadRunnerDriveSystem(hardwareMap);\n+    }\n+\n+    @Override\n+    public void loop() {\n+        drive.updatePoseEstimate();\n+        drive.update();\n+        Pose2d poseEstimate = drive.getPoseEstimate();\n+        telemetry.addData(\"x\", poseEstimate.getX());\n+        telemetry.addData(\"y\", poseEstimate.getY());\n+        telemetry.addData(\"heading\", poseEstimate.getHeading());\n+        telemetry.update();\n+    }\n+}"
  },
  {
    "sha": "2997c8dc09b5928749bd0715d307f039837dab6a",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/ManualFeedforwardTuner.java",
    "status": "renamed",
    "additions": 5,
    "deletions": 5,
    "changes": 10,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/ManualFeedforwardTuner.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/ManualFeedforwardTuner.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/ManualFeedforwardTuner.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -1,4 +1,4 @@\n-package org.firstinspires.ftc.teamcode.opmodes.teleop;\n+package org.firstinspires.ftc.teamcode.tests;\n \n import com.acmerobotics.dashboard.FtcDashboard;\n import com.acmerobotics.dashboard.config.Config;\n@@ -13,14 +13,14 @@\n import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n import com.qualcomm.robotcore.util.RobotLog;\n \n-import org.firstinspires.ftc.teamcode.Constants;\n+import org.firstinspires.ftc.teamcode.helpers.Constants;\n import org.firstinspires.ftc.teamcode.components.RoadRunnerDriveSystem;\n \n import java.util.Objects;\n \n-import static org.firstinspires.ftc.teamcode.Constants.MAX_RPM;\n-import static org.firstinspires.ftc.teamcode.Constants.RUN_USING_ENCODER;\n-import static org.firstinspires.ftc.teamcode.Constants.rpmToVelocity;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.MAX_RPM;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.RUN_USING_ENCODER;\n+import static org.firstinspires.ftc.teamcode.helpers.Constants.rpmToVelocity;\n \n /*\n  * This routine is designed to tune the open-loop feedforward coefficients. Although it may seem unnecessary,",
    "previous_filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/teleop/ManualFeedforwardTuner.java"
  },
  {
    "sha": "c71786ef195818d1bfe5ddbf8e90edc2a1f24884",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/TeleOpDriveTest.java",
    "status": "renamed",
    "additions": 3,
    "deletions": 2,
    "changes": 5,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/TeleOpDriveTest.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/TeleOpDriveTest.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/TeleOpDriveTest.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -1,9 +1,10 @@\n-package org.firstinspires.ftc.teamcode.opmodes.autonomous;\n+package org.firstinspires.ftc.teamcode.tests;\n \n import com.acmerobotics.roadrunner.geometry.Pose2d;\n import com.acmerobotics.roadrunner.geometry.Vector2d;\n import com.acmerobotics.roadrunner.trajectory.Trajectory;\n import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+\n import org.firstinspires.ftc.teamcode.components.RoadRunnerDriveSystem;\n import org.firstinspires.ftc.teamcode.opmodes.base.BaseOpMode;\n \n@@ -13,7 +14,7 @@\n public class TeleOpDriveTest extends BaseOpMode {\n \n     private boolean homing = false;\n-    private Trajectory home = roadRunnerDriveSystem.trajectoryBuilder(new Pose2d()).splineTo(new Vector2d(0, 0), Math.toRadians(0)).build();\n+    private Trajectory home = RoadRunnerDriveSystem.trajectoryBuilder(new Pose2d()).splineTo(new Vector2d(0, 0), Math.toRadians(0)).build();\n \n     public void loop(){\n         roadRunnerDriveSystem.update();",
    "previous_filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/opmodes/autonomous/TeleOpDriveTest.java"
  },
  {
    "sha": "27f3db09f6503e74fb1f04371c6eb3da749a9b4d",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/TestTrajectories.java",
    "status": "added",
    "additions": 60,
    "deletions": 0,
    "changes": 60,
    "blob_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/blob/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/TestTrajectories.java",
    "raw_url": "https://github.com/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/raw/377110340bb0cac914be7aef0f1a62df71c4a76a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/TestTrajectories.java",
    "contents_url": "https://api.github.com/repos/OverlakeRobotics/Nocturnal-2020-Ultimate-Goal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/TestTrajectories.java?ref=377110340bb0cac914be7aef0f1a62df71c4a76a",
    "patch": "@@ -0,0 +1,60 @@\n+package org.firstinspires.ftc.teamcode.tests;\n+\n+import com.acmerobotics.roadrunner.geometry.Pose2d;\n+import com.acmerobotics.roadrunner.geometry.Vector2d;\n+import com.acmerobotics.roadrunner.trajectory.Trajectory;\n+import com.acmerobotics.roadrunner.trajectory.TrajectoryBuilder;\n+\n+import org.firstinspires.ftc.teamcode.components.RoadRunnerDriveSystem;\n+import org.firstinspires.ftc.teamcode.helpers.Coordinates;\n+import org.firstinspires.ftc.teamcode.helpers.GameState;\n+\n+public class TestTrajectories {\n+\n+    /**\n+     * Gets the trajectory for a given state\n+     * @param currentState to draw trajectory for\n+     * @param posEstimate current position estimate\n+     * @return Trajectory for currentState\n+     */\n+    public static Trajectory getTrajectory(GameState currentState, Pose2d posEstimate) {\n+        TrajectoryBuilder trajectoryBuilder = RoadRunnerDriveSystem.trajectoryBuilder(posEstimate);\n+        switch (currentState) {\n+            case DELIVER_WOBBLE:\n+                trajectoryBuilder.lineTo(new Vector2d(60, 5));\n+                break;\n+\n+            case CALIBRATE_LOCATION:\n+                //TODO drive to shooting line in front of the tower goal and update RoadRunner position\n+                trajectoryBuilder.lineTo(new Vector2d(60, -5));\n+                break;\n+\n+            case DRIVE_TO_SHOOTING_LOCATION:\n+                //TODO get coordinate and orientation of robot to fire first powershot\n+                trajectoryBuilder.lineToConstantHeading(Coordinates.POWERSHOT_1.getCoordinates());\n+                break;\n+\n+            case SHOOT2:\n+                //TODO roadrunner adjust to optimal shooting position\n+                trajectoryBuilder.lineToConstantHeading(Coordinates.POWERSHOT_2.getCoordinates());\n+                break;\n+\n+            case SHOOT3:\n+                //TODO roadrunner adjust to optimal shooting position\n+                trajectoryBuilder.lineToConstantHeading(Coordinates.POWERSHOT_3.getCoordinates());\n+                break;\n+\n+            case DELIVER_SECOND_WOBBLE:\n+                trajectoryBuilder.lineToConstantHeading(Coordinates.SECOND_WOBBLE.getCoordinates());\n+                break;\n+\n+            case RETURN_TO_NEST:\n+                trajectoryBuilder.lineToConstantHeading(Coordinates.PARKING_POSITION.getCoordinates());\n+                break;\n+            default:\n+                return null;\n+        }\n+\n+        return trajectoryBuilder.build();\n+    }\n+}"
  }
]
