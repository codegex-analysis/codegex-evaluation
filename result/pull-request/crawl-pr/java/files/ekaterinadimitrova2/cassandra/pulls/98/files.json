[
  {
    "sha": "a834de7d2f73af45f4f775215c756830488d0761",
    "filename": "test/distributed/org/apache/cassandra/distributed/test/GossipTest.java",
    "status": "modified",
    "additions": 77,
    "deletions": 0,
    "changes": 77,
    "blob_url": "https://github.com/ekaterinadimitrova2/cassandra/blob/eea1204e14de549fb37425485308298adad68a30/test/distributed/org/apache/cassandra/distributed/test/GossipTest.java",
    "raw_url": "https://github.com/ekaterinadimitrova2/cassandra/raw/eea1204e14de549fb37425485308298adad68a30/test/distributed/org/apache/cassandra/distributed/test/GossipTest.java",
    "contents_url": "https://api.github.com/repos/ekaterinadimitrova2/cassandra/contents/test/distributed/org/apache/cassandra/distributed/test/GossipTest.java?ref=eea1204e14de549fb37425485308298adad68a30",
    "patch": "@@ -19,13 +19,17 @@\n package org.apache.cassandra.distributed.test;\n \n import java.io.Closeable;\n+import java.net.InetAddress;\n import java.util.Collection;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.stream.Collectors;\n \n+import com.google.common.collect.Iterables;\n import com.google.common.util.concurrent.Uninterruptibles;\n import org.junit.Assert;\n import org.junit.Test;\n@@ -35,7 +39,12 @@\n import net.bytebuddy.implementation.MethodDelegation;\n import org.apache.cassandra.dht.Token;\n import org.apache.cassandra.distributed.Cluster;\n+import org.apache.cassandra.gms.ApplicationState;\n+import org.apache.cassandra.gms.EndpointState;\n+import org.apache.cassandra.gms.Gossiper;\n import org.apache.cassandra.service.StorageService;\n+import org.apache.cassandra.utils.FBUtilities;\n+import org.apache.cassandra.locator.InetAddressAndPort;\n \n import static net.bytebuddy.matcher.ElementMatchers.named;\n import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n@@ -44,6 +53,74 @@\n \n public class GossipTest extends TestBaseImpl\n {\n+    @Test\n+    public void nodeDownDuringMove() throws Throwable\n+    {\n+        int liveCount = 1;\n+        try (Cluster cluster = Cluster.build(2 + liveCount)\n+                                      .withConfig(config -> config.with(NETWORK).with(GOSSIP))\n+                                      .createWithoutStarting())\n+        {\n+            int fail = liveCount + 1;\n+            int late = fail + 1;\n+            for (int i = 1 ; i <= liveCount ; ++i)\n+                cluster.get(i).startup();\n+            cluster.get(fail).startup();\n+            Collection<String> expectTokens = cluster.get(fail).callsOnInstance(() ->\n+                                                                                StorageService.instance.getTokenMetadata().getTokens(FBUtilities.getBroadcastAddressAndPort())\n+                                                                                                       .stream().map(Object::toString).collect(Collectors.toList())\n+            ).call();\n+\n+            String failAddress = cluster.get(fail).broadcastAddress().getHostString();\n+            InetAddressAndPort failAddressAndPort = InetAddressAndPort.getByName(failAddress);\n+            // wait for NORMAL state\n+            for (int i = 1 ; i <= liveCount ; ++i)\n+            {\n+                cluster.get(i).acceptsOnInstance((InetAddressAndPort endpoint) -> {\n+                    EndpointState ep;\n+                    while (null == (ep = Gossiper.instance.getEndpointStateForEndpoint(endpoint))\n+                           || ep.getApplicationState(ApplicationState.STATUS_WITH_PORT) == null\n+                           || !ep.getApplicationState(ApplicationState.STATUS_WITH_PORT).value.startsWith(\"NORMAL\"))\n+                        LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(10L));\n+                }).accept(failAddressAndPort);\n+            }\n+\n+            // set ourselves to MOVING, and wait for it to propagate\n+            cluster.get(fail).runOnInstance(() -> {\n+\n+                Token token = Iterables.getFirst(StorageService.instance.getTokenMetadata().getTokens(FBUtilities.getBroadcastAddressAndPort()), null);\n+                Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS_WITH_PORT, StorageService.instance.valueFactory.moving(token));\n+            });\n+\n+            for (int i = 1 ; i <= liveCount ; ++i)\n+            {\n+                cluster.get(i).acceptsOnInstance((InetAddressAndPort endpoint) -> {\n+                    EndpointState ep;\n+                    while (null == (ep = Gossiper.instance.getEndpointStateForEndpoint(endpoint))\n+                           || (ep.getApplicationState(ApplicationState.STATUS_WITH_PORT) == null\n+                               || !ep.getApplicationState(ApplicationState.STATUS_WITH_PORT).value.startsWith(\"MOVING\")))\n+                        LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(10L));\n+                }).accept(failAddressAndPort);\n+            }\n+\n+            cluster.get(fail).shutdown(false).get();\n+            cluster.get(late).startup();\n+            cluster.get(late).acceptsOnInstance((InetAddressAndPort endpoint) -> {\n+                EndpointState ep;\n+                while (null == (ep = Gossiper.instance.getEndpointStateForEndpoint(endpoint))\n+                       || !ep.getApplicationState(ApplicationState.STATUS_WITH_PORT).value.startsWith(\"MOVING\"))\n+                    LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(10L));\n+            }).accept(failAddressAndPort);\n+\n+            Collection<String> tokens = cluster.get(late).appliesOnInstance((InetAddress endpoint) ->\n+                                                                            StorageService.instance.getTokenMetadata().getTokens(failAddressAndPort)\n+                                                                                                   .stream().map(Object::toString).collect(Collectors.toList())\n+            ).apply(failAddressAndPort.address);\n+\n+            Assert.assertEquals(expectTokens, tokens);\n+        }\n+    }\n+\n     public static class BBBootstrapInterceptor\n     {\n         final static CountDownLatch bootstrapReady = new CountDownLatch(1);"
  }
]
