[
  {
    "sha": "81310c42c7c32da6f0153ef359de93b7a5f02bd1",
    "filename": "docs/configuration.md",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/docs/configuration.md",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/docs/configuration.md",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/docs/configuration.md?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -35,7 +35,7 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.importer.db.username`                                 | mirror_node             | The Importer username the processor uses to connect to the database                            |\n | `hedera.mirror.importer.downloader.accessKey`                        | \"\"                      | The cloud storage access key                                                                   |\n | `hedera.mirror.importer.downloader.allowAnonymousAccess`             |                         | Whether the cloud storage bucket allows for anonymous access.                                  |\n-| `hedera.mirror.importer.downloader.balance.batchSize`                | 15                      | The number of signature files to download per node before downloading the signed files         |\n+| `hedera.mirror.importer.downloader.balance.batchSize`                | 30                      | The number of signature files to download per node before downloading the signed files         |\n | `hedera.mirror.importer.downloader.balance.enabled`                  | true                    | Whether to enable balance file downloads                                                       |\n | `hedera.mirror.importer.downloader.balance.frequency`                | 30s                     | The fixed period between invocations. Can accept duration units like `10s`, `2m`, etc.          |\n | `hedera.mirror.importer.downloader.balance.keepSignatures`           | false                   | Whether to keep balance signature files after successful verification. If false, files are deleted. |"
  },
  {
    "sha": "2dc8739f3cbdfffa49a8d80659a82750f48b085f",
    "filename": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java",
    "status": "modified",
    "additions": 2,
    "deletions": 4,
    "changes": 6,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -112,8 +112,7 @@ public void update(FileData fileData) {\n     @Override\n     @Cacheable\n     public AddressBook getCurrent() {\n-        Instant now = Instant.now();\n-        long consensusTimestamp = Utility.convertToNanosMax(now.getEpochSecond(), now.getNano());\n+        long consensusTimestamp = Utility.convertToNanosMax(Instant.now());\n \n         // retrieve latest address book. If address_book is empty parse initial and historic address book files\n         return addressBookRepository\n@@ -139,8 +138,7 @@ public boolean isAddressBook(EntityId entityId) {\n      * @return Latest AddressBook from historical files\n      */\n     private synchronized AddressBook migrate() {\n-        Instant now = Instant.now();\n-        long consensusTimestamp = Utility.convertToNanosMax(now.getEpochSecond(), now.getNano());\n+        long consensusTimestamp = Utility.convertToNanosMax(Instant.now());\n         AddressBook currentAddressBook = addressBookRepository\n                 .findLatestAddressBook(consensusTimestamp, ADDRESS_BOOK_102_ENTITY_ID.getId())\n                 .orElse(null);"
  },
  {
    "sha": "003018ca5ae7422509a41c281f7fa212b795f1f6",
    "filename": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java",
    "status": "modified",
    "additions": 8,
    "deletions": 5,
    "changes": 13,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -29,6 +29,9 @@\n import java.util.Optional;\n import java.util.concurrent.ConcurrentHashMap;\n import javax.inject.Named;\n+\n+import com.hedera.mirror.importer.domain.StreamFilename;\n+\n import lombok.RequiredArgsConstructor;\n import lombok.Value;\n import lombok.extern.log4j.Log4j2;\n@@ -80,7 +83,7 @@ private DateRangeFilter newDateRangeFilter(StreamType streamType) {\n         Instant startDate = mirrorProperties.getStartDate();\n         Instant endDate = mirrorProperties.getEndDate();\n         Instant lastFileInstant = findLatest(streamType).map(StreamFile::getName)\n-                .map(Utility::getInstantFromFilename)\n+                .map(StreamFilename::getInstantFromStreamFilename)\n                 .orElse(null);\n         Instant filterStartDate = lastFileInstant;\n \n@@ -118,7 +121,7 @@ private DateRangeFilter newDateRangeFilter(StreamType streamType) {\n         Instant startDate = mirrorProperties.getStartDate();\n         Optional<T> streamFile = findLatest(streamType);\n         Instant lastFileInstant = streamFile.map(StreamFile::getName)\n-                .map(Utility::getInstantFromFilename)\n+                .map(StreamFilename::getInstantFromStreamFilename)\n                 .orElse(null);\n         Duration adjustment = mirrorProperties.getStartDateAdjustment();\n         Instant effectiveStartDate = STARTUP_TIME.minus(adjustment);\n@@ -152,7 +155,7 @@ private DateRangeFilter newDateRangeFilter(StreamType streamType) {\n                 log.debug(\"Set verifyHashAfter to {}\", effectiveStartDate);\n             }\n \n-            String filename = Utility.getStreamFilenameFromInstant(streamType, effectiveStartDate);\n+            String filename = StreamFilename.getDataFilenameWithLastExtension(streamType, effectiveStartDate);\n             T effectiveStreamFile = (T) ReflectUtils.newInstance(streamType.getStreamFileClass());\n             effectiveStreamFile.setName(filename);\n             effectiveStreamFile.setIndex(streamFile.map(StreamFile::getIndex).orElse(null));\n@@ -197,12 +200,12 @@ public DateRangeFilter(Instant startDate, Instant endDate) {\n             if (startDate == null) {\n                 startDate = Instant.EPOCH;\n             }\n-            start = Utility.convertToNanosMax(startDate.getEpochSecond(), startDate.getNano());\n+            start = Utility.convertToNanosMax(startDate);\n \n             if (endDate == null) {\n                 end = Long.MAX_VALUE;\n             } else {\n-                end = Utility.convertToNanosMax(endDate.getEpochSecond(), endDate.getNano());\n+                end = Utility.convertToNanosMax(endDate);\n             }\n         }\n "
  },
  {
    "sha": "6996a5bc0fffd060068f469c3e290145a7f09fd1",
    "filename": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/StreamFileData.java",
    "status": "modified",
    "additions": 17,
    "deletions": 3,
    "changes": 20,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/StreamFileData.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/StreamFileData.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/StreamFileData.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -22,8 +22,13 @@\n \n import java.io.ByteArrayInputStream;\n import java.io.File;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.nio.charset.StandardCharsets;\n+import java.util.zip.GZIPInputStream;\n+\n+import com.hedera.mirror.importer.exception.InvalidStreamFileException;\n+\n import lombok.NonNull;\n import lombok.Value;\n import org.apache.commons.io.FileUtils;\n@@ -33,8 +38,8 @@\n @Value\n public class StreamFileData {\n \n-    private final String filename;\n-    private final byte[] bytes;\n+    String filename;\n+    byte[] bytes;\n \n     public static StreamFileData from(@NonNull File file) {\n         try {\n@@ -51,7 +56,16 @@ public static StreamFileData from(@NonNull String filename, @NonNull String cont\n     }\n \n     public InputStream getInputStream() {\n-        return new ByteArrayInputStream(bytes);\n+        try {\n+            InputStream is = new ByteArrayInputStream(bytes);\n+            if (filename.endsWith(\".\" + StreamType.GZ_EXTENSION)) {\n+                is = new GZIPInputStream(is);\n+            }\n+\n+            return is;\n+        } catch (IOException ex) {\n+            throw new InvalidStreamFileException(\"Unable to open gzipped file \" + filename, ex);\n+        }\n     }\n \n     @Override"
  },
  {
    "sha": "d0e96be2de6b9f8ea7d505188bd4bce0c3b83efe",
    "filename": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/StreamFilename.java",
    "status": "added",
    "additions": 159,
    "deletions": 0,
    "changes": 159,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/StreamFilename.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/StreamFilename.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/StreamFilename.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -0,0 +1,159 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * ‌\n+ * Hedera Mirror Node\n+ * ​\n+ * Copyright (C) 2019 - 2021 Hedera Hashgraph, LLC\n+ * ​\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * ‍\n+ */\n+\n+import java.time.Instant;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.time.format.DateTimeParseException;\n+import java.time.format.ResolverStyle;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.Value;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import com.hedera.mirror.importer.exception.InvalidStreamFileException;\n+\n+@Getter\n+public class StreamFilename {\n+\n+    private static final char COMPATIBLE_TIME_SEPARATOR = '_';\n+    private static final char STANDARD_TIME_SEPARATOR = ':';\n+    private static final DateTimeFormatter ISO_INSTANT_FULL_NANOS = new DateTimeFormatterBuilder()\n+            .parseCaseInsensitive()\n+            .appendInstant(9)\n+            .toFormatter()\n+            .withResolverStyle(ResolverStyle.STRICT);\n+\n+    private final String extension;\n+    private final String filename;\n+    private final FileType fileType;\n+    private final Instant instant;\n+    private final StreamType streamType;\n+    private final String timestamp;\n+\n+    public StreamFilename(String filename) {\n+        this.filename = filename;\n+\n+        TypeInfo typeInfo = extractTypeInfo(filename);\n+        this.extension = typeInfo.extension;\n+        this.fileType = typeInfo.fileType;\n+        this.streamType = typeInfo.streamType;\n+\n+        this.instant = extractInstant(filename, this.extension, this.streamType);\n+        this.timestamp = ISO_INSTANT_FULL_NANOS.format(this.instant);\n+    }\n+\n+    /**\n+     * Gets the data filename with the last extension of the specified streamType with instant.\n+     *\n+     * @param streamType\n+     * @param instant\n+     * @return the data filename\n+     */\n+    public static String getDataFilenameWithLastExtension(StreamType streamType, Instant instant) {\n+        String timestamp = instant.toString().replace(STANDARD_TIME_SEPARATOR, COMPATIBLE_TIME_SEPARATOR);\n+        String suffix = streamType.getSuffix();\n+        String extension = streamType.getLastDataExtension();\n+        return StringUtils.joinWith(\".\", StringUtils.join(timestamp, suffix), extension);\n+    }\n+\n+    /**\n+     * Gets the instant from the stream filename.\n+     *\n+     * @param filename\n+     * @return instant from the stream filename\n+     */\n+    public static Instant getInstantFromStreamFilename(String filename) {\n+        if (StringUtils.isBlank(filename)) {\n+            return Instant.EPOCH;\n+        }\n+\n+        return new StreamFilename(filename).getInstant();\n+    }\n+\n+    /**\n+     * Gets the corresponding data filename\n+     *\n+     * @return data filename\n+     */\n+    public String getDataFilename() {\n+        if (fileType == FileType.DATA) {\n+            return filename;\n+        }\n+\n+        String dataExtension = streamType.getSignatureToDataExtensionMap().get(extension);\n+        if (dataExtension == null) {\n+            throw new InvalidStreamFileException(\"No matching data extension for signature extension \" + extension);\n+        }\n+\n+        return StringUtils.join(StringUtils.removeEnd(filename, extension), dataExtension);\n+    }\n+\n+    /**\n+     * Gets the signature file name with the alphabetically last extension\n+     *\n+     * @return signature file name with the alphabetically last extension\n+     */\n+    public String getSignatureFilenameWithLastExtension() {\n+        return StringUtils.join(StringUtils.removeEnd(filename, extension), streamType.getLastSignatureExtension());\n+    }\n+\n+    private static TypeInfo extractTypeInfo(String filename) {\n+        for (StreamType type : StreamType.values()) {\n+            String suffix = type.getSuffix();\n+            for (FileType fileType : FileType.values()) {\n+                List<String> extensions = fileType == FileType.DATA ? type.getDataExtensions() : type\n+                        .getSignatureExtensions();\n+                for (String extension : extensions) {\n+                    if (filename.endsWith(extension) && (suffix != null && filename.contains(suffix))) {\n+                        return new TypeInfo(extension, fileType, type);\n+                    }\n+                }\n+            }\n+        }\n+\n+        throw new InvalidStreamFileException(\"Failed to determine StreamType for filename: \" + filename);\n+    }\n+\n+    private static Instant extractInstant(String filename, String extension, StreamType streamType) {\n+        try {\n+            String suffix = StringUtils.join(streamType.getSuffix(), \".\" + extension);\n+            String dateTime = StringUtils.removeEnd(filename, suffix);\n+            dateTime = dateTime.replace(COMPATIBLE_TIME_SEPARATOR, STANDARD_TIME_SEPARATOR);\n+            return Instant.parse(dateTime);\n+        } catch (DateTimeParseException ex) {\n+            throw new InvalidStreamFileException(\"Invalid datetime string in filename \" + filename, ex);\n+        }\n+    }\n+\n+    public enum FileType {\n+        DATA,\n+        SIGNATURE\n+    }\n+\n+    @Value\n+    private static class TypeInfo {\n+        String extension;\n+        FileType fileType;\n+        StreamType streamType;\n+    }\n+}"
  },
  {
    "sha": "0a4bc94e374a8b3573416777ee8310ad1395b4b9",
    "filename": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/StreamType.java",
    "status": "modified",
    "additions": 64,
    "deletions": 24,
    "changes": 88,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/StreamType.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/StreamType.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/StreamType.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -20,30 +20,76 @@\n  * ‍\n  */\n \n+import com.google.common.collect.ImmutableMap;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n import lombok.Getter;\n-import lombok.RequiredArgsConstructor;\n-import org.apache.commons.io.FilenameUtils;\n+import lombok.Value;\n+import org.apache.commons.lang3.StringUtils;\n \n @Getter\n-@RequiredArgsConstructor\n public enum StreamType {\n \n-    BALANCE(AccountBalanceFile.class, \"accountBalances\", \"balance\", \"_Balances\", \"csv\"),\n-    EVENT(EventFile.class, \"eventsStreams\", \"events_\", \"\", \"evts\"),\n-    RECORD(RecordFile.class, \"recordstreams\", \"record\", \"\", \"rcd\");\n+    BALANCE(AccountBalanceFile.class, \"accountBalances\", \"balance\", \"_Balances\",\n+            List.of(Extension.of(\"pb\", true), Extension.of(\"csv\", false))),\n+    EVENT(EventFile.class, \"eventsStreams\", \"events_\", \"\", List.of(Extension.of(\"evts\", false))),\n+    RECORD(RecordFile.class, \"recordstreams\", \"record\", \"\", List.of(Extension.of(\"rcd\", false)));\n+\n+    public static final String GZ_EXTENSION = \"gz\";\n+    public static final String SIGNATURE_SUFFIX = \"_sig\";\n \n     private static final String PARSED = \"parsed\";\n     private static final String SIGNATURES = \"signatures\";\n-    private static final String SIGNATURE_EXTENSION = \"_sig\";\n \n-    private final Class<? extends StreamFile> streamFileClass;\n-    private final String path;\n+    private final List<String> dataExtensions;\n+    private final String lastDataExtension;\n+    private final String lastSignatureExtension;\n     private final String nodePrefix;\n+    private final String path;\n+    private final List<String> signatureExtensions;\n+    private final Map<String, String> signatureToDataExtensionMap;\n+    private final Class<? extends StreamFile> streamFileClass;\n     private final String suffix;\n-    private final String extension;\n \n-    public String getSignatureExtension() {\n-        return extension + SIGNATURE_EXTENSION;\n+    StreamType(Class<? extends StreamFile> streamFileClass, String path, String nodePrefix, String suffix,\n+            List<Extension> extensions) {\n+        this.streamFileClass = streamFileClass;\n+        this.path = path;\n+        this.nodePrefix = nodePrefix;\n+        this.suffix = suffix;\n+\n+        // build extensions and the map. extensions are passed in priority order. For signature extensions,\n+        // the gzipped one comes first. The last*Extension is the alphabetically last\n+        List<String> dataExtensionList = new ArrayList<>();\n+        List<String> signatureExtensionList = new ArrayList<>();\n+        Map<String, String> extensionMap = new HashMap<>();\n+\n+        for (Extension ext : extensions) {\n+            // signature file can be not gzipped when the data file is gzipped\n+            String dataExtension = ext.getName();\n+            String signatureExtension = StringUtils.join(ext.getName(), SIGNATURE_SUFFIX);\n+\n+            if (ext.isGzipped()) {\n+                dataExtension = StringUtils.joinWith(\".\", dataExtension, GZ_EXTENSION);\n+                String gzippedSignatureExtension = StringUtils.joinWith(\".\", signatureExtension, GZ_EXTENSION);\n+\n+                signatureExtensionList.add(gzippedSignatureExtension);\n+                extensionMap.put(gzippedSignatureExtension, dataExtension);\n+            }\n+\n+            dataExtensionList.add(dataExtension);\n+            signatureExtensionList.add(signatureExtension);\n+            extensionMap.put(signatureExtension, dataExtension);\n+        }\n+\n+        this.lastDataExtension = dataExtensionList.stream().max(Comparator.naturalOrder()).orElseThrow();\n+        this.lastSignatureExtension = signatureExtensionList.stream().max(Comparator.naturalOrder()).orElseThrow();\n+        this.dataExtensions = List.copyOf(dataExtensionList);\n+        this.signatureExtensions = List.copyOf(signatureExtensionList);\n+        this.signatureToDataExtensionMap = ImmutableMap.copyOf(extensionMap);\n     }\n \n     public String getParsed() {\n@@ -54,19 +100,13 @@ public String getSignatures() {\n         return SIGNATURES;\n     }\n \n-    public static StreamType fromFilename(String filename) {\n-        String extension = FilenameUtils.getExtension(filename);\n-\n-        for (StreamType streamType : values()) {\n-            if (streamType.getExtension().equals(extension) || streamType.getSignatureExtension().equals(extension)) {\n-                return streamType;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n     public boolean isChained() {\n         return this != BALANCE;\n     }\n+\n+    @Value(staticConstructor = \"of\")\n+    private static class Extension {\n+        String name;\n+        boolean gzipped;\n+    }\n }"
  },
  {
    "sha": "f8b034448312ba3664ed84a4920997b015aa86e2",
    "filename": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java",
    "status": "modified",
    "additions": 132,
    "deletions": 75,
    "changes": 207,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -21,9 +21,12 @@\n  */\n \n import static com.hedera.mirror.importer.domain.DigestAlgorithm.SHA384;\n+import static com.hedera.mirror.importer.domain.StreamFilename.FileType.SIGNATURE;\n \n import com.google.common.base.Stopwatch;\n+import com.google.common.collect.ListMultimap;\n import com.google.common.collect.Multimap;\n+import com.google.common.collect.MultimapBuilder;\n import com.google.common.collect.Multimaps;\n import com.google.common.collect.TreeMultimap;\n import io.micrometer.core.instrument.Counter;\n@@ -39,20 +42,20 @@\n import java.util.Optional;\n import java.util.Set;\n import java.util.concurrent.Callable;\n-import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FilenameUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import software.amazon.awssdk.core.async.AsyncResponseTransformer;\n import software.amazon.awssdk.services.s3.S3AsyncClient;\n import software.amazon.awssdk.services.s3.model.GetObjectRequest;\n import software.amazon.awssdk.services.s3.model.ListObjectsRequest;\n-import software.amazon.awssdk.services.s3.model.ListObjectsResponse;\n import software.amazon.awssdk.services.s3.model.RequestPayer;\n import software.amazon.awssdk.services.s3.model.S3Object;\n \n@@ -64,6 +67,8 @@\n import com.hedera.mirror.importer.domain.FileStreamSignature;\n import com.hedera.mirror.importer.domain.StreamFile;\n import com.hedera.mirror.importer.domain.StreamFileData;\n+import com.hedera.mirror.importer.domain.StreamFilename;\n+import com.hedera.mirror.importer.domain.StreamType;\n import com.hedera.mirror.importer.exception.HashMismatchException;\n import com.hedera.mirror.importer.exception.SignatureVerificationException;\n import com.hedera.mirror.importer.reader.StreamFileReader;\n@@ -85,6 +90,7 @@\n     protected final StreamFileReader<T, ?> streamFileReader;\n     protected final StreamFileNotifier streamFileNotifier;\n     protected final MirrorDateRangePropertiesProcessor mirrorDateRangePropertiesProcessor;\n+    private final StreamType streamType;\n \n     protected final AtomicReference<Optional<T>> lastStreamFile = new AtomicReference<>(Optional.empty());\n \n@@ -94,11 +100,11 @@\n     private final Timer.Builder streamVerificationMetric;\n \n     protected Downloader(S3AsyncClient s3Client,\n-                         AddressBookService addressBookService, DownloaderProperties downloaderProperties,\n-                         MeterRegistry meterRegistry, NodeSignatureVerifier nodeSignatureVerifier,\n-                         SignatureFileReader signatureFileReader, StreamFileReader<T, ?> streamFileReader,\n-                         StreamFileNotifier streamFileNotifier,\n-                         MirrorDateRangePropertiesProcessor mirrorDateRangePropertiesProcessor) {\n+            AddressBookService addressBookService, DownloaderProperties downloaderProperties,\n+            MeterRegistry meterRegistry, NodeSignatureVerifier nodeSignatureVerifier,\n+            SignatureFileReader signatureFileReader, StreamFileReader<T, ?> streamFileReader,\n+            StreamFileNotifier streamFileNotifier,\n+            MirrorDateRangePropertiesProcessor mirrorDateRangePropertiesProcessor) {\n         this.s3Client = s3Client;\n         this.addressBookService = addressBookService;\n         this.downloaderProperties = downloaderProperties;\n@@ -113,16 +119,16 @@ protected Downloader(S3AsyncClient s3Client,\n         mirrorProperties = downloaderProperties.getMirrorProperties();\n         commonDownloaderProperties = downloaderProperties.getCommon();\n \n-        String streamType = downloaderProperties.getStreamType().toString();\n+        streamType = downloaderProperties.getStreamType();\n \n         // Metrics\n         signatureVerificationMetric = Counter.builder(\"hedera.mirror.download.signature.verification\")\n                 .description(\"The number of signatures verified from a particular node\")\n-                .tag(\"type\", streamType);\n+                .tag(\"type\", streamType.toString());\n \n         streamVerificationMetric = Timer.builder(\"hedera.mirror.download.stream.verification\")\n                 .description(\"The duration in seconds it took to verify consensus and hash chain of a stream file\")\n-                .tag(\"type\", streamType);\n+                .tag(\"type\", streamType.toString());\n     }\n \n     public abstract void download();\n@@ -159,7 +165,8 @@ protected void downloadNextBatch() {\n      * Download and parse all signature files with a timestamp later than the last valid file. Put signature files into\n      * a multi-map sorted and grouped by the timestamp.\n      *\n-     * @param addressBook the current address book\n+     * @param addressBook\n+     *         the current address book\n      * @return a multi-map of signature file objects from different nodes, grouped by filename\n      */\n     private Multimap<String, FileStreamSignature> downloadAndParseSigFiles(AddressBook addressBook)\n@@ -173,67 +180,29 @@ protected void downloadNextBatch() {\n         var totalDownloads = new AtomicInteger();\n         log.info(\"Downloading signature files created after file: {}\", lastValidSigFileName);\n \n-        /**\n+        /*\n          * For each node, create a thread that will make S3 ListObject requests as many times as necessary to\n          * start maxDownloads download operations.\n          */\n         for (EntityId nodeAccountId : nodeAccountIds) {\n-            String nodeAccountIdStr = nodeAccountId.entityIdToString();\n             tasks.add(Executors.callable(() -> {\n+                String nodeAccountIdStr = nodeAccountId.entityIdToString();\n                 Stopwatch stopwatch = Stopwatch.createStarted();\n-                // Get a list of objects in the bucket, 100 at a time\n                 String s3Prefix = downloaderProperties.getPrefix() + nodeAccountIdStr + \"/\";\n \n                 try {\n-                    // batchSize (number of items we plan do download in a single batch) times 2 for file + sig.\n-                    var listSize = (downloaderProperties.getBatchSize() * 2);\n-                    // Not using ListObjectsV2Request because it does not work with GCP.\n-                    ListObjectsRequest listRequest = ListObjectsRequest.builder()\n-                            .bucket(commonDownloaderProperties.getBucketName())\n-                            .prefix(s3Prefix)\n-                            .delimiter(\"/\")\n-                            .marker(s3Prefix + lastValidSigFileName)\n-                            .maxKeys(listSize)\n-                            .requestPayer(RequestPayer.REQUESTER)\n-                            .build();\n-                    CompletableFuture<ListObjectsResponse> response = s3Client.listObjects(listRequest);\n-                    Collection<PendingDownload> pendingDownloads = new ArrayList<>(downloaderProperties.getBatchSize());\n-\n-                    // Loop through the list of remote files beginning a download for each relevant sig file\n-                    for (S3Object content : response.get().contents()) {\n-                        String s3ObjectKey = content.key();\n-                        if (s3ObjectKey.endsWith(\"_sig\")) {\n-                            pendingDownloads.add(pendingDownload(s3ObjectKey));\n-                            totalDownloads.incrementAndGet();\n-                        }\n-                    }\n-\n-                    /*\n-                     * With the list of pending downloads - wait for them to complete, parse them,  and add them to\n-                     * the list of signature files.\n-                     */\n-                    AtomicLong count = new AtomicLong();\n-                    pendingDownloads.forEach(pendingDownload -> {\n-                        try {\n-                            if (pendingDownload.waitForCompletion()) {\n-                                StreamFileData streamFileData = new StreamFileData(pendingDownload\n-                                        .getFilename(), pendingDownload.getBytes());\n-                                FileStreamSignature fileStreamSignature = signatureFileReader.read(streamFileData);\n-                                fileStreamSignature.setNodeAccountId(nodeAccountId);\n-                                sigFilesMap.put(fileStreamSignature.getFilename(), fileStreamSignature);\n-                                count.incrementAndGet();\n-                            }\n-                        } catch (InterruptedException ex) {\n-                            log.warn(\"Failed downloading {} in {}\", pendingDownload.getS3key(),\n-                                    pendingDownload.getStopwatch(), ex);\n-                            Thread.currentThread().interrupt();\n-                        } catch (Exception ex) {\n-                            log.warn(\"Failed to parse signature file {}: {}\", pendingDownload.getS3key(), ex);\n-                        }\n-                    });\n-                    if (count.get() > 0) {\n-                        log.info(\"Downloaded {} signatures for node {} in {}\", count\n-                                .get(), nodeAccountIdStr, stopwatch);\n+                    List<S3Object> s3Objects = listFiles(s3Prefix, lastValidSigFileName);\n+                    List<String> signatureFilenames = getSignatureFilenames(s3Objects);\n+                    List<FileStreamSignature> fileStreamSignatures = signatureFilenames.stream()\n+                            .map(filename -> pendingDownload(s3Prefix + filename))\n+                            .map(pendingDownload -> parseDownloadedSignatureFile(pendingDownload, nodeAccountId))\n+                            .filter(Objects::nonNull)\n+                            .collect(Collectors.toList());\n+                    fileStreamSignatures.forEach(fileStreamSignature -> sigFilesMap\n+                            .put(fileStreamSignature.getFilename(), fileStreamSignature));\n+                    int count = fileStreamSignatures.size();\n+                    if (count > 0) {\n+                        log.info(\"Downloaded {} signatures for node {} in {}\", count, nodeAccountIdStr, stopwatch);\n                     }\n                 } catch (Exception e) {\n                     log.error(\"Error downloading signature files for node {} after {}\", nodeAccountIdStr, stopwatch, e);\n@@ -252,6 +221,87 @@ protected void downloadNextBatch() {\n         return sigFilesMap;\n     }\n \n+    private List<S3Object> listFiles(String s3Prefix, String lastFilename) throws ExecutionException,\n+            InterruptedException {\n+        // batchSize (number of items we plan do download in a single batch) times 2 for file + sig.\n+        int listSize = (downloaderProperties.getBatchSize() * 2);\n+        // Not using ListObjectsV2Request because it does not work with GCP.\n+        ListObjectsRequest listRequest = ListObjectsRequest.builder()\n+                .bucket(commonDownloaderProperties.getBucketName())\n+                .prefix(s3Prefix)\n+                .delimiter(\"/\")\n+                .marker(s3Prefix + lastFilename)\n+                .maxKeys(listSize)\n+                .requestPayer(RequestPayer.REQUESTER)\n+                .build();\n+        return s3Client.listObjects(listRequest).get().contents();\n+    }\n+\n+    private List<String> getSignatureFilenames(List<S3Object> s3Objects) {\n+        List<String> signatureFilenames = new ArrayList<>();\n+\n+        // some stream types have files with different formats, build a multimap with timestamp as the key\n+        ListMultimap<String, StreamFilename> filenameByTimestamp = s3Objects.stream()\n+                .map(S3Object::key)\n+                .map(FilenameUtils::getName)\n+                .map(StreamFilename::new)\n+                .filter(streamFilename -> streamFilename.getFileType() == SIGNATURE)\n+                .collect(Multimaps.toMultimap(\n+                        StreamFilename::getTimestamp,\n+                        streamFilename -> streamFilename,\n+                        MultimapBuilder.treeKeys().arrayListValues()::build\n+                ));\n+        for (String timestamp : filenameByTimestamp.keySet()) {\n+            boolean matched = false;\n+            List<String> extensions = streamType.getSignatureExtensions();\n+            List<StreamFilename> streamFilenames = filenameByTimestamp.get(timestamp);\n+\n+            for (String extension : extensions) {\n+                matched = streamFilenames.stream()\n+                        .filter(streamFilename -> streamFilename.getExtension().equals(extension))\n+                        .findFirst()\n+                        .map(StreamFilename::getFilename)\n+                        .map(signatureFilenames::add)\n+                        .orElse(false);\n+                if (matched) {\n+                    break;\n+                }\n+            }\n+\n+            if (!matched) {\n+                log.error(\"Failed to find a valid signature file to download among files: {}\",\n+                        streamFilenames.stream().map(StreamFilename::getFilename).collect(Collectors.joining(\",\")));\n+            }\n+        }\n+\n+        return signatureFilenames;\n+    }\n+\n+    private FileStreamSignature parseDownloadedSignatureFile(PendingDownload pendingDownload, EntityId nodeAccountId) {\n+        FileStreamSignature fileStreamSignature = null;\n+        String s3Key = pendingDownload.getS3key();\n+        Stopwatch stopwatch = pendingDownload.getStopwatch();\n+\n+        try {\n+            if (!pendingDownload.waitForCompletion()) {\n+                log.warn(\"Failed downloading {} in {}\", s3Key, stopwatch);\n+                return null;\n+            }\n+\n+            StreamFileData streamFileData = new StreamFileData(pendingDownload.getFilename(),\n+                    pendingDownload.getBytes());\n+            fileStreamSignature = signatureFileReader.read(streamFileData);\n+            fileStreamSignature.setNodeAccountId(nodeAccountId);\n+        } catch (InterruptedException ex) {\n+            log.warn(\"Failed downloading {} in {}\", s3Key, stopwatch, ex);\n+            Thread.currentThread().interrupt();\n+        } catch (Exception ex) {\n+            log.warn(\"Failed to parse signature file {}: {}\", s3Key, ex);\n+        }\n+\n+        return fileStreamSignature;\n+    }\n+\n     /**\n      * Returns the last signature file name that was successfully verified. On startup, this will be the last file\n      * successfully imported into the database since all files are downloaded into memory will have been discarded. If\n@@ -269,7 +319,7 @@ private String getLastSignature() {\n                     return streamFile;\n                 })\n                 .map(StreamFile::getName)\n-                .map(name -> name + \"_sig\")\n+                .map(name -> new StreamFilename(name).getSignatureFilenameWithLastExtension())\n                 .orElse(\"\");\n     }\n \n@@ -305,7 +355,8 @@ private void moveSignatureFile(FileStreamSignature signature) {\n      * the data file into `valid` directory; else download the data file from other valid node folder and compare the\n      * hash until we find a match.\n      *\n-     * @param sigFilesMap signature files grouped by file name\n+     * @param sigFilesMap\n+     *         signature files grouped by file name\n      */\n     private void verifySigsAndDownloadDataFiles(Multimap<String, FileStreamSignature> sigFilesMap) {\n         Instant endDate = mirrorProperties.getEndDate();\n@@ -364,7 +415,7 @@ private void verifySigsAndDownloadDataFiles(Multimap<String, FileStreamSignature\n \n                     verify(streamFile, signature);\n \n-                    if (Utility.isStreamFileAfterInstant(sigFilename, endDate)) {\n+                    if (new StreamFilename(sigFilename).getInstant().isAfter(endDate)) {\n                         downloaderProperties.setEnabled(false);\n                         log.warn(\"Disabled polling after downloading all files <= endDate ({})\", endDate);\n                         return;\n@@ -397,7 +448,7 @@ private void verifySigsAndDownloadDataFiles(Multimap<String, FileStreamSignature\n     }\n \n     private PendingDownload downloadSignedDataFile(FileStreamSignature fileStreamSignature) {\n-        String fileName = fileStreamSignature.getFilename().replace(\"_sig\", \"\");\n+        String fileName = new StreamFilename(fileStreamSignature.getFilename()).getDataFilename();\n         String s3Prefix = downloaderProperties.getPrefix();\n         String nodeAccountId = fileStreamSignature.getNodeAccountIdString();\n         String s3ObjectKey = s3Prefix + nodeAccountId + \"/\" + fileName;\n@@ -411,7 +462,8 @@ protected void onVerified(T streamFile) {\n     /**\n      * Sets the index of the streamFile to the last index plus 1, or 0 if it's the first stream file.\n      *\n-     * @param streamFile the stream file object\n+     * @param streamFile\n+     *         the stream file object\n      */\n     private void setStreamFileIndex(StreamFile streamFile) {\n         long index = lastStreamFile.get()\n@@ -425,8 +477,10 @@ private void setStreamFileIndex(StreamFile streamFile) {\n      * Verifies the stream file is the next file in the hashchain if it's chained and the hash of the stream file\n      * matches the expected hash in the signature.\n      *\n-     * @param streamFile the stream file object\n-     * @param signature  the signature object corresponding to the stream file\n+     * @param streamFile\n+     *         the stream file object\n+     * @param signature\n+     *         the signature object corresponding to the stream file\n      */\n     private void verify(StreamFile streamFile, FileStreamSignature signature) {\n         String filename = streamFile.getName();\n@@ -443,9 +497,12 @@ private void verify(StreamFile streamFile, FileStreamSignature signature) {\n     /**\n      * Verifies if the two hashes match.\n      *\n-     * @param filename filename the hash is from\n-     * @param actual   the actual hash\n-     * @param expected the expected hash\n+     * @param filename\n+     *         filename the hash is from\n+     * @param actual\n+     *         the actual hash\n+     * @param expected\n+     *         the expected hash\n      */\n     private void verifyHash(String filename, String actual, String expected) {\n         if (!Objects.equals(actual, expected)) {\n@@ -459,7 +516,7 @@ boolean verifyHashChain(StreamFile streamFile, String expectedPreviousHash) {\n         }\n \n         Instant verifyHashAfter = downloaderProperties.getMirrorProperties().getVerifyHashAfter();\n-        var fileInstant = Utility.getInstantFromFilename(streamFile.getName());\n+        var fileInstant = new StreamFilename(streamFile.getName()).getInstant();\n \n         if (!verifyHashAfter.isBefore(fileInstant)) {\n             return true;"
  },
  {
    "sha": "4385ab996a19e41623d85722616993a1462fbdb8",
    "filename": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/balance/BalanceDownloaderProperties.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/balance/BalanceDownloaderProperties.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/balance/BalanceDownloaderProperties.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/balance/BalanceDownloaderProperties.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -44,7 +44,7 @@\n     private final CommonDownloaderProperties common;\n \n     @Min(1)\n-    private int batchSize = 15;\n+    private int batchSize = 30;\n \n     private boolean enabled = true;\n "
  },
  {
    "sha": "493dd5d65d9aa424921e6f0182c8ce82c67bd81d",
    "filename": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/exception/InvalidStreamFileException.java",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/exception/InvalidStreamFileException.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/exception/InvalidStreamFileException.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/exception/InvalidStreamFileException.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -31,4 +31,8 @@ public InvalidStreamFileException(String message) {\n     public InvalidStreamFileException(Throwable throwable) {\n         super(throwable);\n     }\n+\n+    public InvalidStreamFileException(String message, Throwable throwable) {\n+        super(message, throwable);\n+    }\n }"
  },
  {
    "sha": "71f05a692b6469f4371d807d377797511683cbbf",
    "filename": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/BalanceFileReaderImplV1.java",
    "status": "modified",
    "additions": 0,
    "deletions": 2,
    "changes": 2,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/BalanceFileReaderImplV1.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/BalanceFileReaderImplV1.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/BalanceFileReaderImplV1.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -24,14 +24,12 @@\n import java.io.IOException;\n import java.time.format.DateTimeParseException;\n import javax.inject.Named;\n-import lombok.extern.log4j.Log4j2;\n import org.apache.commons.lang3.StringUtils;\n \n import com.hedera.mirror.importer.exception.InvalidDatasetException;\n import com.hedera.mirror.importer.parser.balance.BalanceParserProperties;\n import com.hedera.mirror.importer.reader.balance.line.AccountBalanceLineParserV1;\n \n-@Log4j2\n @Named\n public class BalanceFileReaderImplV1 extends CsvBalanceFileReader {\n "
  },
  {
    "sha": "e2814d708afccaa5914a29ccfb2abf6c5f80574b",
    "filename": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/BalanceFileReaderImplV2.java",
    "status": "modified",
    "additions": 0,
    "deletions": 2,
    "changes": 2,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/BalanceFileReaderImplV2.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/BalanceFileReaderImplV2.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/BalanceFileReaderImplV2.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -24,14 +24,12 @@\n import java.io.IOException;\n import java.time.format.DateTimeParseException;\n import javax.inject.Named;\n-import lombok.extern.log4j.Log4j2;\n import org.apache.commons.lang3.StringUtils;\n \n import com.hedera.mirror.importer.exception.InvalidDatasetException;\n import com.hedera.mirror.importer.parser.balance.BalanceParserProperties;\n import com.hedera.mirror.importer.reader.balance.line.AccountBalanceLineParserV2;\n \n-@Log4j2\n @Named\n public class BalanceFileReaderImplV2 extends CsvBalanceFileReader {\n "
  },
  {
    "sha": "fc6f27f8539ae664807d3dd6311330b6488f0d6c",
    "filename": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/CompositeBalanceFileReader.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/CompositeBalanceFileReader.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/CompositeBalanceFileReader.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/CompositeBalanceFileReader.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -36,6 +36,7 @@\n \n     private final BalanceFileReaderImplV1 balanceFileReaderImplV1;\n     private final BalanceFileReaderImplV2 balanceFileReaderImplV2;\n+    private final ProtoBalanceFileReader protoBalanceFileReader;\n \n     @Override\n     public boolean supports(StreamFileData streamFileData) {\n@@ -49,6 +50,10 @@ public AccountBalanceFile read(StreamFileData streamFileData, Consumer<AccountBa\n     }\n \n     private BalanceFileReader getReader(StreamFileData streamFileData) {\n+        if (protoBalanceFileReader.supports(streamFileData)) {\n+            return protoBalanceFileReader;\n+        }\n+\n         return balanceFileReaderImplV2.supports(streamFileData) ? balanceFileReaderImplV2 : balanceFileReaderImplV1;\n     }\n }"
  },
  {
    "sha": "36eb5d0e2da2e353dcb943ef2eb9cc0fb03674be",
    "filename": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/CsvBalanceFileReader.java",
    "status": "modified",
    "additions": 4,
    "deletions": 6,
    "changes": 10,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/CsvBalanceFileReader.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/CsvBalanceFileReader.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/CsvBalanceFileReader.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -79,12 +79,11 @@ protected boolean supports(String firstLine) {\n     @Override\n     public AccountBalanceFile read(StreamFileData streamFileData, Consumer<AccountBalance> itemConsumer) {\n         MessageDigest messageDigest = DigestUtils.getSha384Digest();\n-        InputStream inputStream = new DigestInputStream(streamFileData.getInputStream(), messageDigest);\n         int bufferSize = balanceParserProperties.getFileBufferSize();\n-        itemConsumer = itemConsumer != null ? itemConsumer : accountBalance -> {\n-        };\n+        itemConsumer = itemConsumer != null ? itemConsumer : accountBalance -> {};\n \n-        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, CHARSET), bufferSize)) {\n+        try (InputStream inputStream = new DigestInputStream(streamFileData.getInputStream(), messageDigest);\n+             BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, CHARSET), bufferSize)) {\n             long consensusTimestamp = parseConsensusTimestamp(reader);\n             AtomicLong count = new AtomicLong(0L);\n \n@@ -110,7 +109,6 @@ public AccountBalanceFile read(StreamFileData streamFileData, Consumer<AccountBa\n \n             accountBalanceFile.setCount(count.get());\n             accountBalanceFile.setFileHash(Utility.bytesToHex(messageDigest.digest()));\n-            accountBalanceFile.setLoadEnd(Instant.now().getEpochSecond());\n             return accountBalanceFile;\n         } catch (IOException ex) {\n             throw new InvalidDatasetException(\"Error reading account balance file\", ex);\n@@ -121,6 +119,6 @@ public AccountBalanceFile read(StreamFileData streamFileData, Consumer<AccountBa\n \n     protected long convertTimestamp(String timestamp) {\n         Instant instant = Instant.parse(timestamp);\n-        return Utility.convertToNanosMax(instant.getEpochSecond(), instant.getNano());\n+        return Utility.convertToNanosMax(instant);\n     }\n }"
  },
  {
    "sha": "882ad717d8bd8f4dd09f373b63c580a35a2e899c",
    "filename": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/ProtoBalanceFileReader.java",
    "status": "added",
    "additions": 98,
    "deletions": 0,
    "changes": 98,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/ProtoBalanceFileReader.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/ProtoBalanceFileReader.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/balance/ProtoBalanceFileReader.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -0,0 +1,98 @@\n+package com.hedera.mirror.importer.reader.balance;\n+\n+/*-\n+ * ‌\n+ * Hedera Mirror Node\n+ * ​\n+ * Copyright (C) 2019 - 2021 Hedera Hashgraph, LLC\n+ * ​\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * ‍\n+ */\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.DigestInputStream;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import javax.inject.Named;\n+import org.apache.commons.codec.digest.DigestUtils;\n+\n+import com.hedera.mirror.importer.domain.AccountBalance;\n+import com.hedera.mirror.importer.domain.AccountBalanceFile;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.StreamFileData;\n+import com.hedera.mirror.importer.domain.TokenBalance;\n+import com.hedera.mirror.importer.exception.InvalidStreamFileException;\n+import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.services.stream.proto.AllAccountBalances;\n+import com.hedera.services.stream.proto.SingleAccountBalances;\n+\n+@Named\n+public class ProtoBalanceFileReader implements BalanceFileReader {\n+\n+    public static final String FILE_SUFFIX = \"pb.gz\";\n+\n+    @Override\n+    public boolean supports(StreamFileData streamFileData) {\n+        return streamFileData.getFilename().endsWith(FILE_SUFFIX);\n+    }\n+\n+    @Override\n+    public AccountBalanceFile read(StreamFileData streamFileData, Consumer<AccountBalance> itemConsumer) {\n+        MessageDigest messageDigest = DigestUtils.getSha384Digest();\n+        itemConsumer = itemConsumer != null ? itemConsumer : accountBalance -> {\n+        };\n+\n+        try (InputStream inputStream = new DigestInputStream(streamFileData.getInputStream(), messageDigest)) {\n+            AccountBalanceFile.AccountBalanceFileBuilder builder = AccountBalanceFile.builder()\n+                    .bytes(streamFileData.getBytes())\n+                    .loadStart(Instant.now().getEpochSecond());\n+\n+            AllAccountBalances allAccountBalances = AllAccountBalances.parseFrom(inputStream.readAllBytes());\n+            long consensusTimestamp = Utility.timeStampInNanos(allAccountBalances.getConsensusTimestamp());\n+            allAccountBalances.getAllAccountsList().stream()\n+                    .map((balances -> this.readSingleAccountBalances(consensusTimestamp, balances)))\n+                    .forEachOrdered(itemConsumer);\n+\n+            return builder.consensusTimestamp(consensusTimestamp)\n+                    .count((long) allAccountBalances.getAllAccountsCount())\n+                    .fileHash(Utility.bytesToHex(messageDigest.digest()))\n+                    .items(new ArrayList<>())\n+                    .name(streamFileData.getFilename())\n+                    .build();\n+        } catch (IOException ex) {\n+            throw new InvalidStreamFileException(\"Error reading account balance pb file\", ex);\n+        }\n+    }\n+\n+    private AccountBalance readSingleAccountBalances(long consensusTimestamp, SingleAccountBalances balances) {\n+        EntityId accountId = EntityId.of(balances.getAccountID());\n+        List<TokenBalance> tokenBalances = balances.getTokenUnitBalancesList().stream()\n+                .map(tokenBalance -> {\n+                    EntityId tokenId = EntityId.of(tokenBalance.getTokenId());\n+                    TokenBalance.Id id = new TokenBalance.Id(consensusTimestamp, accountId, tokenId);\n+                    return new TokenBalance(tokenBalance.getBalance(), id);\n+                })\n+                .collect(Collectors.toList());\n+        return new AccountBalance(\n+                balances.getHbarBalance(),\n+                tokenBalances,\n+                new AccountBalance.Id(consensusTimestamp, accountId)\n+        );\n+    }\n+}"
  },
  {
    "sha": "4a99f3cc66a8a142ee16a093f8c72fe1e4afb86a",
    "filename": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/util/Utility.java",
    "status": "modified",
    "additions": 13,
    "deletions": 34,
    "changes": 47,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/util/Utility.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/util/Utility.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/util/Utility.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -39,11 +39,7 @@\n import lombok.experimental.UtilityClass;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.codec.binary.Hex;\n-import org.apache.commons.io.FilenameUtils;\n import org.apache.commons.lang3.ArrayUtils;\n-import org.apache.commons.lang3.StringUtils;\n-\n-import com.hedera.mirror.importer.domain.StreamType;\n \n @Log4j2\n @UtilityClass\n@@ -153,6 +149,19 @@ public static Long convertToNanosMax(long second, long nanos) {\n         }\n     }\n \n+    /**\n+     * Converts instant to time in only nanos, with a fallback if overflow: If positive overflow, return\n+     * the max time in the future (Long.MAX_VALUE). If negative overflow, return the max time in the past\n+     * (Long.MIN_VALUE).\n+     */\n+    public static Long convertToNanosMax(Instant instant) {\n+        if (instant == null) {\n+            instant = Instant.EPOCH;\n+        }\n+\n+        return convertToNanosMax(instant.getEpochSecond(), instant.getNano());\n+    }\n+\n     /**\n      * Convert Timestamp to a Long type timeStampInNanos\n      */\n@@ -188,36 +197,6 @@ public static void archiveFile(String filename, byte[] contents, Path destinatio\n         }\n     }\n \n-    public static final Instant getInstantFromFilename(String filename) {\n-        if (StringUtils.isBlank(filename)) {\n-            return Instant.EPOCH;\n-        }\n-\n-        StreamType streamType = StreamType.fromFilename(filename);\n-        String date = FilenameUtils.removeExtension(filename);\n-\n-        if (streamType != null) {\n-            date = StringUtils.removeEnd(date, streamType.getSuffix());\n-        }\n-\n-        date = date.replace('_', ':');\n-        return Instant.parse(date);\n-    }\n-\n-    public static final long getTimestampFromFilename(String filename) {\n-        Instant instant = getInstantFromFilename(filename);\n-        return Utility.convertToNanosMax(instant.getEpochSecond(), instant.getNano());\n-    }\n-\n-    public static final String getStreamFilenameFromInstant(StreamType streamType, Instant instant) {\n-        String timestamp = instant.toString().replace(':', '_');\n-        return timestamp + streamType.getSuffix() + \".\" + streamType.getExtension();\n-    }\n-\n-    public static final boolean isStreamFileAfterInstant(String filename, Instant instant) {\n-        return instant != null && getInstantFromFilename(filename).isAfter(instant);\n-    }\n-\n     /**\n      * Generates a TransactionID object\n      *"
  },
  {
    "sha": "153d6b785b33bd835be96f4ad3bc6f7c42034068",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessorTest.java",
    "status": "modified",
    "additions": 7,
    "deletions": 5,
    "changes": 12,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessorTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessorTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessorTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -42,6 +42,7 @@\n \n import com.hedera.mirror.importer.MirrorProperties;\n import com.hedera.mirror.importer.domain.StreamFile;\n+import com.hedera.mirror.importer.domain.StreamFilename;\n import com.hedera.mirror.importer.domain.StreamType;\n import com.hedera.mirror.importer.downloader.CommonDownloaderProperties;\n import com.hedera.mirror.importer.downloader.DownloaderProperties;\n@@ -157,7 +158,7 @@ void startDateNotSetAndEndDateAfterLongMaxAndDatabaseNotEmpty() {\n     }\n \n     @ParameterizedTest(name = \"startDate {0}ns before application status, endDate\")\n-    @ValueSource(longs = {0, 1})\n+    @ValueSource(longs = { 0, 1 })\n     void startDateNotAfterDatabase(long nanos) {\n         Instant past = STARTUP_TIME.minusSeconds(100);\n         mirrorProperties.setStartDate(past.minusNanos(nanos));\n@@ -176,7 +177,7 @@ void startDateNotAfterDatabase(long nanos) {\n     }\n \n     @ParameterizedTest(name = \"startDate is {0}ns after application status\")\n-    @ValueSource(longs = {1, 2_000_000_000L, 200_000_000_000L})\n+    @ValueSource(longs = { 1, 2_000_000_000L, 200_000_000_000L })\n     void startDateAfterDatabase(long diffNanos) {\n         Instant lastFileInstant = Instant.now().minusSeconds(200);\n \n@@ -233,7 +234,7 @@ void startDateNotBeforeEndDate(Instant startDate, Instant endDate, Instant lastF\n     }\n \n     @ParameterizedTest(name = \"timestamp {0} does not pass empty filter\")\n-    @ValueSource(longs = {-10L, 0L, 1L, 10L, 8L, 100L})\n+    @ValueSource(longs = { -10L, 0L, 1L, 10L, 8L, 100L })\n     void emptyFilter(long timestamp) {\n         DateRangeFilter filter = DateRangeFilter.empty();\n         assertThat(filter.filter(timestamp)).isFalse();\n@@ -259,12 +260,13 @@ private Instant adjustStartDate(Instant startDate) {\n     }\n \n     private boolean matches(Optional<StreamFile> streamFile, Instant instant) {\n-        return instant.equals(streamFile.map(StreamFile::getName).map(Utility::getInstantFromFilename).orElse(null));\n+        return instant.equals(streamFile.map(StreamFile::getName).map(StreamFilename::getInstantFromStreamFilename)\n+                        .orElse(null));\n     }\n \n     private Optional<StreamFile> streamFile(StreamType streamType, Instant instant) {\n         StreamFile streamFile = (StreamFile) ReflectUtils.newInstance(streamType.getStreamFileClass());\n-        streamFile.setName(Utility.getStreamFilenameFromInstant(streamType, instant));\n+        streamFile.setName(StreamFilename.getDataFilenameWithLastExtension(streamType, instant));\n         return Optional.of(streamFile);\n     }\n }"
  },
  {
    "sha": "0b091daeb384a70039f47fe0267a6f4cf76a7ecd",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/domain/StreamFileDataTest.java",
    "status": "modified",
    "additions": 17,
    "deletions": 0,
    "changes": 17,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/domain/StreamFileDataTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/domain/StreamFileDataTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/domain/StreamFileDataTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -43,11 +43,15 @@\n import static org.assertj.core.api.Assertions.assertThat;\n import static org.junit.jupiter.api.Assertions.*;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.File;\n import java.io.IOException;\n+import java.io.OutputStream;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Path;\n+import java.util.zip.GZIPOutputStream;\n import org.apache.commons.io.FileUtils;\n+import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.io.TempDir;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.CsvSource;\n@@ -86,4 +90,17 @@ void from(boolean createFile, boolean writeData, boolean createDirectory, String\n             assertThrows(RuntimeException.class, () -> StreamFileData.from(file), testName);\n         }\n     }\n+\n+    @Test\n+    void fromGzippedData() throws IOException {\n+        String filename = \"foobar.gz\";\n+        byte[] uncompressedBytes = \"foobar\".getBytes();\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        OutputStream os = new GZIPOutputStream(baos);\n+        os.write(uncompressedBytes);\n+        os.close();\n+\n+        StreamFileData streamFileData = new StreamFileData(filename, baos.toByteArray());\n+        assertThat(streamFileData.getInputStream().readAllBytes()).isEqualTo(uncompressedBytes);\n+    }\n }"
  },
  {
    "sha": "0be3f52dbd64c81fe4fb12553b7f8cb859d8f5df",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/domain/StreamFilenameTest.java",
    "status": "added",
    "additions": 129,
    "deletions": 0,
    "changes": 129,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/domain/StreamFilenameTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/domain/StreamFilenameTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/domain/StreamFilenameTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -0,0 +1,129 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * ‌\n+ * Hedera Mirror Node\n+ * ​\n+ * Copyright (C) 2019 - 2021 Hedera Hashgraph, LLC\n+ * ​\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * ‍\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import java.time.Instant;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import com.hedera.mirror.importer.exception.InvalidStreamFileException;\n+\n+class StreamFilenameTest {\n+\n+    @ParameterizedTest(name = \"Create StreamFilename from {0}\")\n+    @CsvSource({\n+            // @formatter:off\n+            \"2020-06-03T16_45_00.1Z_Balances.csv_sig, csv_sig, SIGNATURE, 2020-06-03T16:45:00.1Z, BALANCE, 2020-06-03T16:45:00.100000000Z\",\n+            \"2020-06-03T16_45_00.1Z_Balances.pb_sig, pb_sig, SIGNATURE, 2020-06-03T16:45:00.1Z, BALANCE, 2020-06-03T16:45:00.100000000Z\",\n+            \"2020-06-03T16_45_00.1Z_Balances.pb_sig.gz, pb_sig.gz, SIGNATURE, 2020-06-03T16:45:00.1Z, BALANCE, 2020-06-03T16:45:00.100000000Z\",\n+            \"2020-06-03T16_45_00.1Z_Balances.csv, csv, DATA, 2020-06-03T16:45:00.1Z, BALANCE, 2020-06-03T16:45:00.100000000Z\",\n+            \"2020-06-03T16_45_00.1Z_Balances.pb.gz, pb.gz, DATA, 2020-06-03T16:45:00.1Z, BALANCE, 2020-06-03T16:45:00.100000000Z\",\n+            \"2020-06-03T16_45_00.1Z.evts_sig, evts_sig, SIGNATURE, 2020-06-03T16:45:00.1Z, EVENT, 2020-06-03T16:45:00.100000000Z\",\n+            \"2020-06-03T16_45_00.1Z.evts, evts, DATA, 2020-06-03T16:45:00.1Z, EVENT, 2020-06-03T16:45:00.100000000Z\",\n+            \"2020-06-03T16_45_00.1Z.rcd_sig, rcd_sig, SIGNATURE, 2020-06-03T16:45:00.1Z, RECORD, 2020-06-03T16:45:00.100000000Z\",\n+            \"2020-06-03T16_45_00.1Z.rcd, rcd, DATA, 2020-06-03T16:45:00.1Z, RECORD, 2020-06-03T16:45:00.100000000Z\",\n+            // @formatter:on\n+    })\n+    void newStreamFile(String filename, String extension, StreamFilename.FileType fileType,\n+            Instant instant, StreamType streamType, String timestamp) {\n+        StreamFilename streamFilename = new StreamFilename(filename);\n+\n+        assertThat(streamFilename)\n+                .extracting(\"filename\", \"extension\", \"fileType\", \"instant\", \"streamType\", \"timestamp\")\n+                .containsExactly(filename, extension, fileType, instant, streamType, timestamp);\n+    }\n+\n+    @ParameterizedTest(name = \"Exception creating StreamFilename from {0}\")\n+    @ValueSource(strings = { \"2020-06-03_Balances.csv_sig\", \"2020-06-03T16_45_00.1Z\", \"2020-06-03T16_45_00.1Z.stream\",\n+            \"2020-06-03T16_45_00.1Z.csv_sig\" })\n+    void newStreamFileFromInvalidFilename(String filename) {\n+        assertThrows(InvalidStreamFileException.class, () -> new StreamFilename(filename));\n+    }\n+\n+    @ParameterizedTest(name = \"Get data filename from {0}\")\n+    @CsvSource({\n+            \"2020-06-03T16_45_00.1Z_Balances.csv_sig, 2020-06-03T16_45_00.1Z_Balances.csv\",\n+            \"2020-06-03T16_45_00.1Z_Balances.pb_sig, 2020-06-03T16_45_00.1Z_Balances.pb.gz\",\n+            \"2020-06-03T16_45_00.1Z_Balances.pb_sig.gz, 2020-06-03T16_45_00.1Z_Balances.pb.gz\",\n+            \"2020-06-03T16_45_00.1Z_Balances.csv, 2020-06-03T16_45_00.1Z_Balances.csv\",\n+            \"2020-06-03T16_45_00.1Z_Balances.pb.gz, 2020-06-03T16_45_00.1Z_Balances.pb.gz\",\n+            \"2020-06-03T16_45_00.1Z.evts_sig, 2020-06-03T16_45_00.1Z.evts\",\n+            \"2020-06-03T16_45_00.1Z.evts, 2020-06-03T16_45_00.1Z.evts\",\n+            \"2020-06-03T16_45_00.1Z.rcd_sig, 2020-06-03T16_45_00.1Z.rcd\",\n+            \"2020-06-03T16_45_00.1Z.rcd, 2020-06-03T16_45_00.1Z.rcd\",\n+    })\n+    void getDataFilename(String filename, String expected) {\n+        assertThat(new StreamFilename(filename).getDataFilename()).isEqualTo(expected);\n+    }\n+\n+    @ParameterizedTest(name = \"Get signature filename with last extension from {0}\")\n+    @CsvSource({\n+            \"2020-06-03T16_45_00.1Z_Balances.csv_sig, 2020-06-03T16_45_00.1Z_Balances.pb_sig.gz\",\n+            \"2020-06-03T16_45_00.1Z_Balances.pb_sig, 2020-06-03T16_45_00.1Z_Balances.pb_sig.gz\",\n+            \"2020-06-03T16_45_00.1Z_Balances.pb_sig.gz, 2020-06-03T16_45_00.1Z_Balances.pb_sig.gz\",\n+            \"2020-06-03T16_45_00.1Z_Balances.csv, 2020-06-03T16_45_00.1Z_Balances.pb_sig.gz\",\n+            \"2020-06-03T16_45_00.1Z_Balances.pb.gz, 2020-06-03T16_45_00.1Z_Balances.pb_sig.gz\",\n+            \"2020-06-03T16_45_00.1Z.evts_sig, 2020-06-03T16_45_00.1Z.evts_sig\",\n+            \"2020-06-03T16_45_00.1Z.evts, 2020-06-03T16_45_00.1Z.evts_sig\",\n+            \"2020-06-03T16_45_00.1Z.rcd_sig, 2020-06-03T16_45_00.1Z.rcd_sig\",\n+            \"2020-06-03T16_45_00.1Z.rcd, 2020-06-03T16_45_00.1Z.rcd_sig\",\n+    })\n+    void getSignatureFilenameWithLastExtension(String filename, String expected) {\n+        assertThat(new StreamFilename(filename).getSignatureFilenameWithLastExtension()).isEqualTo(expected);\n+    }\n+\n+    @ParameterizedTest(name = \"Get timestamp from filename {0}\")\n+    @CsvSource({\n+            \"2020-06-03T16_45_00.1Z.rcd, 2020-06-03T16:45:00.100000000Z\",\n+            \"2020-06-03T16_45_00.01Z.rcd, 2020-06-03T16:45:00.010000000Z\",\n+            \"2020-06-03T16_45_00.123456789Z.rcd, 2020-06-03T16:45:00.123456789Z\",\n+    })\n+    void getTimestamp(String filename, String expected) {\n+        assertThat(new StreamFilename(filename).getTimestamp()).isEqualTo(expected);\n+    }\n+\n+    @ParameterizedTest(name = \"Get data filename with last extension from {0} and {1}\")\n+    @CsvSource({\n+            \"BALANCE, 2020-06-03T16:45:00.123456789Z, 2020-06-03T16_45_00.123456789Z_Balances.pb.gz\",\n+            \"EVENT, 2020-06-03T16:45:00.123456789Z, 2020-06-03T16_45_00.123456789Z.evts\",\n+            \"RECORD, 2020-06-03T16:45:00.123456789Z, 2020-06-03T16_45_00.123456789Z.rcd\",\n+    })\n+    void getDataFilenameWithLastExtension(StreamType streamType, Instant instant, String expected) {\n+        assertThat(StreamFilename.getDataFilenameWithLastExtension(streamType, instant)).isEqualTo(expected);\n+    }\n+\n+    @ParameterizedTest(name = \"Get instant from filename ''{0}''\")\n+    @CsvSource({\n+            \"2020-06-03T16_45_00.100000000Z_Balances.pb.gz, 2020-06-03T16:45:00.1Z\",\n+            \"2020-06-03T16_45_00.010000000Z.evts, 2020-06-03T16:45:00.01Z\",\n+            \"2020-06-03T16_45_00.123456789Z.rcd, 2020-06-03T16:45:00.123456789Z\",\n+            \", 1970-01-01T00:00:00Z\",\n+            \"'', 1970-01-01T00:00:00Z\",\n+            \"' ', 1970-01-01T00:00:00Z\",\n+    })\n+    void getInstantFromStreamFilename(String filename, Instant expected) {\n+        assertThat(StreamFilename.getInstantFromStreamFilename(filename)).isEqualTo(expected);\n+    }\n+}"
  },
  {
    "sha": "3afa71b9500024f44058f5f6288729b0f4dc93eb",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/domain/StreamTypeTest.java",
    "status": "added",
    "additions": 140,
    "deletions": 0,
    "changes": 140,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/domain/StreamTypeTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/domain/StreamTypeTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/domain/StreamTypeTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -0,0 +1,140 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * ‌\n+ * Hedera Mirror Node\n+ * ​\n+ * Copyright (C) 2019 - 2021 Hedera Hashgraph, LLC\n+ * ​\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * ‍\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableMap;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class StreamTypeTest {\n+\n+    private static final Map<StreamType, List<String>> dataExtensions = ImmutableMap.<StreamType, List<String>>builder()\n+            .put(StreamType.BALANCE, List.of(\"pb.gz\", \"csv\"))\n+            .put(StreamType.EVENT, List.of(\"evts\"))\n+            .put(StreamType.RECORD, List.of(\"rcd\"))\n+            .build();\n+    private static final Map<StreamType, List<String>> signatureExtensions =\n+            ImmutableMap.<StreamType, List<String>>builder()\n+            .put(StreamType.BALANCE, List.of(\"pb_sig.gz\", \"pb_sig\", \"csv_sig\"))\n+            .put(StreamType.EVENT, List.of(\"evts_sig\"))\n+            .put(StreamType.RECORD, List.of(\"rcd_sig\"))\n+            .build();\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideTypeAndDataExtensions\")\n+    void getDataExtensions(StreamType streamType, List<String> dataExtensions) {\n+        assertThat(streamType.getDataExtensions()).containsExactlyElementsOf(dataExtensions);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideTypeAndLastDataExtension\")\n+    void getLastDataExtension(StreamType streamType, String dataExtension) {\n+        assertThat(streamType.getLastDataExtension()).isEqualTo(dataExtension);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideTypeAndLastSignatureExtension\")\n+    void getLastSignatureExtension(StreamType streamType, String signatureExtension) {\n+        assertThat(streamType.getLastSignatureExtension()).isEqualTo(signatureExtension);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideTypeAndSignatureExtensions\")\n+    void getSignatureExtensions(StreamType streamType, List<String> signatureExtensions) {\n+        assertThat(streamType.getSignatureExtensions()).containsExactlyElementsOf(signatureExtensions);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideTypeAndSignatureToDataExtensionMap\")\n+    void getSignatureToDataExtensionMap(StreamType streamType, Map<String, String> expected) {\n+        assertThat(streamType.getSignatureToDataExtensionMap()).isEqualTo(expected);\n+    }\n+\n+    private static Stream<Arguments> provideTypeAndExtensions(boolean isDataExtension, boolean onlyLast) {\n+        Map<StreamType, List<String>> extensionsMap = isDataExtension ? dataExtensions : signatureExtensions;\n+        List<Arguments> argumentsList = new ArrayList<>();\n+        for (StreamType streamType : StreamType.values()) {\n+            List<String> extensions = extensionsMap.get(streamType);\n+            if (extensions == null) {\n+                throw new IllegalArgumentException(\"Unknown StreamType \" + streamType);\n+            }\n+\n+            if (onlyLast) {\n+                argumentsList.add(Arguments.of(streamType, extensions.get(0)));\n+            } else {\n+                argumentsList.add(Arguments.of(streamType, extensions));\n+            }\n+        }\n+\n+        return argumentsList.stream();\n+    }\n+\n+    private static Stream<Arguments> provideTypeAndDataExtensions() {\n+        return provideTypeAndExtensions(true, false);\n+    }\n+\n+    private static Stream<Arguments> provideTypeAndSignatureExtensions() {\n+        return provideTypeAndExtensions(false, false);\n+    }\n+\n+    private static Stream<Arguments> provideTypeAndLastDataExtension() {\n+        return provideTypeAndExtensions(true, true);\n+    }\n+\n+    private static Stream<Arguments> provideTypeAndLastSignatureExtension() {\n+        return provideTypeAndExtensions(false, true);\n+    }\n+\n+    private static Stream<Arguments> provideTypeAndSignatureToDataExtensionMap() {\n+        List<Arguments> argumentsList = new ArrayList<>();\n+\n+        for (StreamType streamType : StreamType.values()) {\n+            Map<String, String> extensionMap = new HashMap<>();\n+            switch (streamType) {\n+                case BALANCE:\n+                    extensionMap.put(\"pb_sig\", \"pb.gz\");\n+                    extensionMap.put(\"pb_sig.gz\", \"pb.gz\");\n+                    extensionMap.put(\"csv_sig\", \"csv\");\n+                    break;\n+                case EVENT:\n+                    extensionMap.put(\"evts_sig\", \"evts\");\n+                    break;\n+                case RECORD:\n+                    extensionMap.put(\"rcd_sig\", \"rcd\");\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown StreamType \" + streamType);\n+            }\n+\n+            argumentsList.add(Arguments.of(streamType, extensionMap));\n+        }\n+\n+        return argumentsList.stream();\n+    }\n+}"
  },
  {
    "sha": "c95308ae841cb00842b87402c0e0d25c5956e169",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractDownloaderTest.java",
    "status": "modified",
    "additions": 11,
    "deletions": 38,
    "changes": 49,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractDownloaderTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractDownloaderTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractDownloaderTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -61,7 +61,6 @@\n import org.junit.jupiter.api.extension.ExtendWith;\n import org.junit.jupiter.api.io.TempDir;\n import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.converter.ConvertWith;\n import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.CsvSource;\n import org.junit.jupiter.params.provider.MethodSource;\n@@ -81,19 +80,18 @@\n import com.hedera.mirror.importer.config.MetricsExecutionInterceptor;\n import com.hedera.mirror.importer.config.MirrorDateRangePropertiesProcessor;\n import com.hedera.mirror.importer.config.MirrorImporterConfiguration;\n-import com.hedera.mirror.importer.converter.InstantConverter;\n import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.AddressBookEntry;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.RecordFile;\n import com.hedera.mirror.importer.domain.StreamFile;\n+import com.hedera.mirror.importer.domain.StreamFilename;\n import com.hedera.mirror.importer.domain.StreamType;\n import com.hedera.mirror.importer.reader.signature.CompositeSignatureFileReader;\n import com.hedera.mirror.importer.reader.signature.SignatureFileReader;\n import com.hedera.mirror.importer.reader.signature.SignatureFileReaderV2;\n import com.hedera.mirror.importer.reader.signature.SignatureFileReaderV5;\n-import com.hedera.mirror.importer.util.Utility;\n \n @ExtendWith(MockitoExtension.class)\n @Log4j2\n@@ -439,7 +437,7 @@ void startDate(long seconds, String fileChoice) throws Exception {\n         expectLastStreamFile(null, 100L, startDate);\n         List<String> expectedFiles = List.of(file1, file2)\n                 .stream()\n-                .filter(name -> Utility.getInstantFromFilename(name).isAfter(startDate))\n+                .filter(name -> StreamFilename.getInstantFromStreamFilename(name).isAfter(startDate))\n                 .collect(Collectors.toList());\n \n         fileCopier.copy();\n@@ -460,7 +458,7 @@ void endDate(long seconds, String fileChoice) {\n         downloaderProperties.setBatchSize(1);\n         List<String> expectedFiles = List.of(file1, file2)\n                 .stream()\n-                .filter(name -> !Utility.getInstantFromFilename(name).isAfter(mirrorProperties.getEndDate()))\n+                .filter(name -> !StreamFilename.getInstantFromStreamFilename(name).isAfter(mirrorProperties.getEndDate()))\n                 .collect(Collectors.toList());\n         expectLastStreamFile(Instant.EPOCH);\n \n@@ -510,45 +508,20 @@ void maxDownloadItemsReached() throws Exception {\n         verifyStreamFiles(List.of(file1));\n     }\n \n-    @ParameterizedTest(name = \"verifyHashChain {5}\")\n-    @CsvSource({\n-            // @formatter:off\n-            \"'', '', 1970-01-01T00:00:00Z,        2000-01-01T10_00_00.000000Z.stream, true,  passes if both hashes are empty\",\n-            \"xx, '', 1970-01-01T00:00:00Z,        2000-01-01T10_00_00.000000Z.stream, true,  passes if hash mismatch and expected hash is empty\", // starting stream in middle\n-            \"'', xx, 1970-01-01T00:00:00Z,        2000-01-01T10_00_00.000000Z.stream, false, fails if hash mismatch and actual hash is empty\", // bad db state\n-            \"xx, yy, 1970-01-01T00:00:00Z,        2000-01-01T10_00_00.000000Z.stream, false, fails if hash mismatch and hashes are non-empty\",\n-            \"xx, yy, 2000-01-01T10:00:00.000001Z, 2000-01-01T10_00_00.000000Z.stream, true,  passes if hash mismatch but verifyHashAfter is after filename\",\n-            \"xx, yy, 2000-01-01T10:00:00.000001Z, 2000-01-01T10_00_00.000000Z.stream, true,  passes if hash mismatch but verifyHashAfter is same as filename\",\n-            \"xx, yy, 2000-01-01T09:59:59.999999Z, 2000-01-01T10_00_00.000000Z.stream, false, fails if hash mismatch and verifyHashAfter is before filename\",\n-            \"xx, xx, 1970-01-01T00:00:00Z,        2000-01-01T10_00_00.000000Z.stream, true,  passes if hashes are equal\"\n-            // @formatter:on\n-    })\n-    void testVerifyHashChain(String actualPrevFileHash, String expectedPrevFileHash,\n-                             @ConvertWith(InstantConverter.class) Instant verifyHashAfter, String fileName,\n-                             Boolean expectedResult, String testName) {\n-        downloaderProperties.getMirrorProperties().setVerifyHashAfter(verifyHashAfter);\n-        RecordFile streamFile = new RecordFile();\n-        streamFile.setName(fileName);\n-        streamFile.setPreviousHash(actualPrevFileHash);\n-        assertThat(downloader.verifyHashChain(streamFile, expectedPrevFileHash))\n-                .as(testName)\n-                .isEqualTo(expectedResult);\n-    }\n-\n     private void differentFilenames(Duration offset) throws Exception {\n         // Copy all files and modify only node 0.0.3's files to have a different timestamp\n         fileCopier.filterFiles(file2 + \"*\").copy();\n         Path basePath = fileCopier.getTo().resolve(streamType.getNodePrefix() + \"0.0.3\");\n \n         // Construct a new filename with the offset added to the last valid file\n         long nanoOffset = getCloseInterval().plus(offset).toNanos();\n-        long timestamp = Utility.getTimestampFromFilename(file1) + nanoOffset;\n-        String baseFilename = Instant.ofEpochSecond(0, timestamp) + streamType.getSuffix() + \".\";\n+        Instant instant = StreamFilename.getInstantFromStreamFilename(file1).plusNanos(nanoOffset);\n+        String baseFilename = instant + streamType.getSuffix() + \".\";\n         baseFilename = baseFilename.replace(':', '_');\n \n         // Rename the good files to have a bad timestamp\n-        String signature = baseFilename + streamType.getSignatureExtension();\n-        String signed = baseFilename + streamType.getExtension();\n+        String signature = baseFilename + streamType.getLastSignatureExtension();\n+        String signed = baseFilename + streamType.getLastDataExtension();\n         Files.move(basePath.resolve(file2 + \"_sig\"), basePath.resolve(signature));\n         Files.move(basePath.resolve(file2), basePath.resolve(signed));\n \n@@ -565,7 +538,7 @@ protected void verifyUnsuccessful() {\n         verifyStreamFiles(Collections.emptyList());\n     }\n \n-    private void verifyForSuccess() throws Exception {\n+    protected void verifyForSuccess() throws Exception {\n         verifyForSuccess(List.of(file1, file2));\n     }\n \n@@ -601,8 +574,8 @@ protected void setTestFilesAndInstants(List<String> files) {\n         this.file1 = files.get(0);\n         this.file2 = files.get(1);\n \n-        file1Instant = Utility.getInstantFromFilename(file1);\n-        file2Instant = Utility.getInstantFromFilename(file2);\n+        file1Instant = StreamFilename.getInstantFromStreamFilename(file1);\n+        file2Instant = StreamFilename.getInstantFromStreamFilename(file2);\n     }\n \n     /**\n@@ -614,7 +587,7 @@ protected void setTestFilesAndInstants(List<String> files) {\n      */\n     protected void expectLastStreamFile(String hash, Long index, Instant instant) {\n         StreamFile streamFile = (StreamFile) ReflectUtils.newInstance(streamType.getStreamFileClass());\n-        streamFile.setName(Utility.getStreamFilenameFromInstant(streamType, instant));\n+        streamFile.setName(StreamFilename.getDataFilenameWithLastExtension(streamType, instant));\n         streamFile.setHash(hash);\n         streamFile.setIndex(index);\n "
  },
  {
    "sha": "d26436d19eed7f0a9c2baa7cb76f8daaffe83bcf",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractLinkedStreamDownloaderTest.java",
    "status": "modified",
    "additions": 29,
    "deletions": 0,
    "changes": 29,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractLinkedStreamDownloaderTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractLinkedStreamDownloaderTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractLinkedStreamDownloaderTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -20,10 +20,14 @@\n  * ‍\n  */\n \n+import static org.assertj.core.api.Assertions.assertThat;\n+\n import java.time.Instant;\n import java.util.List;\n import org.junit.jupiter.api.DisplayName;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n \n import com.hedera.mirror.importer.domain.RecordFile;\n \n@@ -50,4 +54,29 @@ void hashMismatchWithBypass() {\n         downloader.download();\n         verifyStreamFiles(List.of(file2));\n     }\n+\n+    @ParameterizedTest(name = \"verifyHashChain {5}\")\n+    @CsvSource({\n+            // @formatter:off\n+            \"'', '', 1970-01-01T00:00:00Z,        2000-01-01T10_00_00.000000Z.rcd, true,  passes if both hashes are empty\",\n+            \"xx, '', 1970-01-01T00:00:00Z,        2000-01-01T10_00_00.000000Z.rcd, true,  passes if hash mismatch and expected hash is empty\", // starting stream in middle\n+            \"'', xx, 1970-01-01T00:00:00Z,        2000-01-01T10_00_00.000000Z.rcd, false, fails if hash mismatch and actual hash is empty\", // bad db state\n+            \"xx, yy, 1970-01-01T00:00:00Z,        2000-01-01T10_00_00.000000Z.rcd, false, fails if hash mismatch and hashes are non-empty\",\n+            \"xx, yy, 2000-01-01T10:00:00.000001Z, 2000-01-01T10_00_00.000000Z.rcd, true,  passes if hash mismatch but verifyHashAfter is after filename\",\n+            \"xx, yy, 2000-01-01T10:00:00.000001Z, 2000-01-01T10_00_00.000000Z.rcd, true,  passes if hash mismatch but verifyHashAfter is same as filename\",\n+            \"xx, yy, 2000-01-01T09:59:59.999999Z, 2000-01-01T10_00_00.000000Z.rcd, false, fails if hash mismatch and verifyHashAfter is before filename\",\n+            \"xx, xx, 1970-01-01T00:00:00Z,        2000-01-01T10_00_00.000000Z.rcd, true,  passes if hashes are equal\"\n+            // @formatter:on\n+    })\n+    void verifyHashChain(String actualPrevFileHash, String expectedPrevFileHash,\n+            Instant verifyHashAfter, String fileName,\n+            Boolean expectedResult, String testName) {\n+        downloaderProperties.getMirrorProperties().setVerifyHashAfter(verifyHashAfter);\n+        RecordFile streamFile = new RecordFile();\n+        streamFile.setName(fileName);\n+        streamFile.setPreviousHash(actualPrevFileHash);\n+        assertThat(downloader.verifyHashChain(streamFile, expectedPrevFileHash))\n+                .as(testName)\n+                .isEqualTo(expectedResult);\n+    }\n }"
  },
  {
    "sha": "45789b93bc358b2c5a9d803dd3aa14ee73088d07",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/balance/AccountBalancesDownloaderTest.java",
    "status": "modified",
    "additions": 43,
    "deletions": 30,
    "changes": 73,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/balance/AccountBalancesDownloaderTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/balance/AccountBalancesDownloaderTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/balance/AccountBalancesDownloaderTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -20,27 +20,28 @@\n  * ‍\n  */\n \n+import static org.assertj.core.api.Assertions.assertThat;\n+\n import java.nio.file.Path;\n import java.time.Duration;\n-import java.util.HashMap;\n+import java.time.Instant;\n import java.util.List;\n-import java.util.Map;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n \n-import com.hedera.mirror.importer.domain.AccountBalanceFile;\n+import com.hedera.mirror.importer.FileCopier;\n+import com.hedera.mirror.importer.TestUtils;\n import com.hedera.mirror.importer.downloader.AbstractDownloaderTest;\n import com.hedera.mirror.importer.downloader.Downloader;\n import com.hedera.mirror.importer.downloader.DownloaderProperties;\n import com.hedera.mirror.importer.parser.balance.BalanceParserProperties;\n import com.hedera.mirror.importer.reader.balance.BalanceFileReader;\n import com.hedera.mirror.importer.reader.balance.BalanceFileReaderImplV1;\n+import com.hedera.mirror.importer.reader.balance.ProtoBalanceFileReader;\n import com.hedera.mirror.importer.reader.balance.line.AccountBalanceLineParserV1;\n-import com.hedera.mirror.importer.util.Utility;\n \n class AccountBalancesDownloaderTest extends AbstractDownloaderTest {\n \n-    private final Map<String, AccountBalanceFile> accountBalanceFileMap = new HashMap<>();\n-\n     @Override\n     protected DownloaderProperties getDownloaderProperties() {\n         return new BalanceDownloaderProperties(mirrorProperties, commonDownloaderProperties);\n@@ -73,31 +74,43 @@ protected void beforeEach() throws Exception {\n                 \"2019-08-30T18_15_00.016002001Z_Balances.csv\",\n                 \"2019-08-30T18_30_00.010147001Z_Balances.csv\"\n         ));\n+    }\n+\n+    void setUpMixedScenario() {\n+        // for the mixed scenario, all .csv and .csv_sig files are empty files. Also for the second file\n+        // 2021-03-10T22_27_56.236886Z_Balances.pb.gz, both the gzipped and plain signature files exists\n+        ProtoBalanceFileReader protoBalanceFileReader = new ProtoBalanceFileReader();\n+        downloader = new AccountBalancesDownloader(s3AsyncClient, addressBookService,\n+                (BalanceDownloaderProperties) downloaderProperties, meterRegistry, nodeSignatureVerifier,\n+                signatureFileReader, protoBalanceFileReader, streamFileNotifier, dateRangeProcessor);\n+        fileCopier = FileCopier.create(TestUtils.getResource(\"data\").toPath(), s3Path)\n+                .from(Path.of(\"accountBalances\", \"mixed\"))\n+                .to(commonDownloaderProperties.getBucketName(), streamType.getPath());\n+        setTestFilesAndInstants(List.of(\n+                \"2021-03-10T22_12_56.075092Z_Balances.pb.gz\",\n+                \"2021-03-10T22_27_56.236886Z_Balances.pb.gz\"\n+        ));\n+    }\n+\n+    @Test\n+    void downloadWithAllGzippedSignatureFiles() throws Exception {\n+        setUpMixedScenario();\n+        fileCopier.filterFiles(file -> !file.getName().endsWith(\"2021-03-10T22_27_56.236886Z_Balances.pb_sig\")).copy();\n+        expectLastStreamFile(Instant.EPOCH);\n+        downloader.download();\n+\n+        verifyForSuccess();\n+        assertThat(downloaderProperties.getSignaturesPath()).doesNotExist();\n+    }\n \n-        long timestamp = Utility.convertToNanosMax(file1Instant.getEpochSecond(), file1Instant.getNano());\n-        AccountBalanceFile abf1 = AccountBalanceFile.builder()\n-                .consensusTimestamp(timestamp)\n-                .count(0L)\n-                .fileHash(\n-                        \"c1a6ffb5df216a1e8331f949f45cb9400fc474150d57d977c77f21318687eb18d407c780147d0435791a02743a0f7bfc\")\n-                .loadEnd(0L)\n-                .loadStart(0L)\n-                .name(file1)\n-                .nodeAccountId(null)\n-                .build();\n-        accountBalanceFileMap.put(file1, abf1);\n+    @Test\n+    void downloadWithSecondSignatureFilePlain() throws Exception {\n+        setUpMixedScenario();\n+        fileCopier.filterFiles(file -> !file.getName().endsWith(\"2021-03-10T22_27_56.236886Z_Balances.pb_sig.gz\")).copy();\n+        expectLastStreamFile(Instant.EPOCH);\n+        downloader.download();\n \n-        timestamp = Utility.convertToNanosMax(file2Instant.getEpochSecond(), file2Instant.getNano());\n-        AccountBalanceFile abf2 = AccountBalanceFile.builder()\n-                .consensusTimestamp(timestamp)\n-                .count(0L)\n-                .fileHash(\n-                        \"c197898e485e92a85752d475b536e6dc09879a18d358b1e72a9a1160bb24c8bb7a4c58610383ac80fd1c7659214eccd4\")\n-                .loadEnd(0L)\n-                .loadStart(0L)\n-                .name(file2)\n-                .nodeAccountId(null)\n-                .build();\n-        accountBalanceFileMap.put(file2, abf2);\n+        verifyForSuccess();\n+        assertThat(downloaderProperties.getSignaturesPath()).doesNotExist();\n     }\n }"
  },
  {
    "sha": "bea7185c6eb5500e5d7d68204d1a15458b4237fa",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/balance/AccountBalanceFileParserTest.java",
    "status": "modified",
    "additions": 5,
    "deletions": 1,
    "changes": 6,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/balance/AccountBalanceFileParserTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/balance/AccountBalanceFileParserTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/balance/AccountBalanceFileParserTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -30,6 +30,9 @@\n import java.util.List;\n import java.util.stream.Collectors;\n import javax.annotation.Resource;\n+\n+import com.hedera.mirror.importer.domain.StreamFilename;\n+\n import org.assertj.core.api.IterableAssert;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n@@ -172,7 +175,8 @@ void assertAccountBalances(AccountBalanceFile... balanceFiles) {\n     }\n \n     private AccountBalanceFile accountBalanceFile(long timestamp) {\n-        String filename = Utility.getStreamFilenameFromInstant(StreamType.BALANCE, Instant.ofEpochSecond(0, timestamp));\n+        String filename = StreamFilename\n+                .getDataFilenameWithLastExtension(StreamType.BALANCE, Instant.ofEpochSecond(0, timestamp));\n         return AccountBalanceFile.builder()\n                 .bytes(Longs.toByteArray(timestamp))\n                 .consensusTimestamp(timestamp)"
  },
  {
    "sha": "1c58792359c8de91af458b70c7e016dea4d40ae0",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/event/EventFileParserTest.java",
    "status": "modified",
    "additions": 4,
    "deletions": 1,
    "changes": 5,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/event/EventFileParserTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/event/EventFileParserTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/event/EventFileParserTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -29,6 +29,9 @@\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.time.Instant;\n+\n+import com.hedera.mirror.importer.domain.StreamFilename;\n+\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n@@ -158,7 +161,7 @@ private void assertFilesArchived(String... fileNames) throws Exception {\n     private EventFile eventFile() {\n         long id = ++count;\n         Instant instant = Instant.ofEpochSecond(0L, id);\n-        String filename = Utility.getStreamFilenameFromInstant(parserProperties.getStreamType(), instant);\n+        String filename = StreamFilename.getDataFilenameWithLastExtension(parserProperties.getStreamType(), instant);\n         EventFile eventFile = new EventFile();\n         eventFile.setBytes(new byte[] {0, 1, 2});\n         eventFile.setConsensusEnd(id);"
  },
  {
    "sha": "9a4b93e81eebbca99870f3bef7fbbcc7fa5a246b",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/RecordFileParserTest.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/RecordFileParserTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/RecordFileParserTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/RecordFileParserTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -27,6 +27,8 @@\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.verify;\n \n+import com.hedera.mirror.importer.domain.StreamFilename;\n+\n import com.hederahashgraph.api.proto.java.CryptoTransferTransactionBody;\n import com.hederahashgraph.api.proto.java.SignatureMap;\n import com.hederahashgraph.api.proto.java.SignedTransaction;\n@@ -226,7 +228,7 @@ private void assertFilesArchived(String... fileNames) throws Exception {\n     private RecordFile recordFile() {\n         long id = ++count;\n         Instant instant = Instant.ofEpochSecond(0L, id);\n-        String filename = Utility.getStreamFilenameFromInstant(parserProperties.getStreamType(), instant);\n+        String filename = StreamFilename.getDataFilenameWithLastExtension(parserProperties.getStreamType(), instant);\n         RecordFile recordFile = new RecordFile();\n         recordFile.setBytes(new byte[] {0, 1, 2});\n         recordFile.setConsensusEnd(id);"
  },
  {
    "sha": "5a976e8c0e68cf074927b9d25b6c0cbab6409d43",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java",
    "status": "modified",
    "additions": 5,
    "deletions": 2,
    "changes": 7,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -26,6 +26,9 @@\n \n import com.google.protobuf.ByteString;\n import com.google.protobuf.InvalidProtocolBufferException;\n+\n+import com.hedera.mirror.importer.domain.StreamFilename;\n+\n import com.hederahashgraph.api.proto.java.AccountAmount;\n import com.hederahashgraph.api.proto.java.AccountID;\n import com.hederahashgraph.api.proto.java.ContractID;\n@@ -170,7 +173,7 @@ protected final void assertContract(ContractID contractId, Entities dbEntity) {\n \n     protected void parseRecordItemAndCommit(RecordItem recordItem) {\n         Instant instant = Instant.ofEpochSecond(0, recordItem.getConsensusTimestamp());\n-        String filename = Utility.getStreamFilenameFromInstant(StreamType.RECORD, instant);\n+        String filename = StreamFilename.getDataFilenameWithLastExtension(StreamType.RECORD, instant);\n         long consensusStart = recordItem.getConsensusTimestamp();\n         RecordFile recordFile = recordFile(consensusStart, consensusStart + 1, filename);\n \n@@ -182,7 +185,7 @@ protected void parseRecordItemAndCommit(RecordItem recordItem) {\n \n     protected void parseRecordItemsAndCommit(RecordItem... recordItems) {\n         Instant instant = Instant.ofEpochSecond(0, recordItems[0].getConsensusTimestamp());\n-        String filename = Utility.getStreamFilenameFromInstant(StreamType.RECORD, instant);\n+        String filename = StreamFilename.getDataFilenameWithLastExtension(StreamType.RECORD, instant);\n         long consensusStart = recordItems[0].getConsensusTimestamp();\n         long consensusEnd = recordItems[recordItems.length - 1].getConsensusTimestamp();\n         RecordFile recordFile = recordFile(consensusStart, consensusEnd, filename);"
  },
  {
    "sha": "723206a3e58f74e090dfa86bb5db74bc7a3839eb",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/balance/CompositeBalanceFileReaderTest.java",
    "status": "modified",
    "additions": 21,
    "deletions": 2,
    "changes": 23,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/balance/CompositeBalanceFileReaderTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/balance/CompositeBalanceFileReaderTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/balance/CompositeBalanceFileReaderTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -20,11 +20,13 @@\n  * ‍\n  */\n \n+import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import java.util.function.Consumer;\n+import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.ExtendWith;\n import org.mockito.InjectMocks;\n@@ -43,6 +45,9 @@\n     @Mock\n     private BalanceFileReaderImplV2 readerImplV2;\n \n+    @Mock\n+    private ProtoBalanceFileReader protoBalanceFileReader;\n+\n     @InjectMocks\n     private CompositeBalanceFileReader compositeBalanceFileReader;\n \n@@ -52,18 +57,32 @@\n     @Test\n     void defaultsToVersion1Reader() {\n         StreamFileData streamFileData = StreamFileData.from(\"foo.csv\", \"timestamp:1\");\n+        when(protoBalanceFileReader.supports(streamFileData)).thenReturn(false);\n         when(readerImplV2.supports(streamFileData)).thenReturn(false);\n         compositeBalanceFileReader.read(streamFileData, consumer);\n         verify(readerImplV1, times(1)).read(streamFileData, consumer);\n-        verify(readerImplV2, times(0)).read(streamFileData, consumer);\n+        verify(readerImplV2, never()).read(streamFileData, consumer);\n+        verify(protoBalanceFileReader, never()).read(streamFileData, consumer);\n     }\n \n     @Test\n     void usesVersion2Reader() {\n         StreamFileData streamFileData = StreamFileData.from(\"foo.csv\", \"# version:2\");\n+        when(protoBalanceFileReader.supports(streamFileData)).thenReturn(false);\n         when(readerImplV2.supports(streamFileData)).thenReturn(true);\n         compositeBalanceFileReader.read(streamFileData, consumer);\n         verify(readerImplV2, times(1)).read(streamFileData, consumer);\n-        verify(readerImplV1, times(0)).read(streamFileData, consumer);\n+        verify(readerImplV1, never()).read(streamFileData, consumer);\n+        verify(protoBalanceFileReader, never()).read(streamFileData, consumer);\n+    }\n+\n+    @Test\n+    void usesProtoBalanceFileReader() {\n+        StreamFileData streamFileData = StreamFileData.from(\"foo.pb.gz\", \"proto-based balance file\");\n+        when(protoBalanceFileReader.supports(streamFileData)).thenReturn(true);\n+        compositeBalanceFileReader.read(streamFileData, consumer);\n+        verify(protoBalanceFileReader, times(1)).read(streamFileData, consumer);\n+        verify(readerImplV1, never()).read(streamFileData, consumer);\n+        verify(readerImplV2, never()).read(streamFileData, consumer);\n     }\n }"
  },
  {
    "sha": "96ac35ec0cb78478f292a0bedbfed22706c14152",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/balance/CsvBalanceFileReaderTest.java",
    "status": "modified",
    "additions": 4,
    "deletions": 3,
    "changes": 7,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/balance/CsvBalanceFileReaderTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/balance/CsvBalanceFileReaderTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/balance/CsvBalanceFileReaderTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -33,6 +33,7 @@\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.security.MessageDigest;\n+import java.time.Instant;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.LinkedList;\n@@ -49,6 +50,7 @@\n import com.hedera.mirror.importer.domain.AccountBalance;\n import com.hedera.mirror.importer.domain.AccountBalanceFile;\n import com.hedera.mirror.importer.domain.StreamFileData;\n+import com.hedera.mirror.importer.domain.StreamFilename;\n import com.hedera.mirror.importer.exception.InvalidDatasetException;\n import com.hedera.mirror.importer.reader.balance.line.AccountBalanceLineParser;\n import com.hedera.mirror.importer.util.Utility;\n@@ -79,7 +81,8 @@\n \n     @BeforeEach\n     void setup() throws IOException {\n-        consensusTimestamp = Utility.getTimestampFromFilename(balanceFile.getName());\n+        Instant instant = StreamFilename.getInstantFromStreamFilename(balanceFile.getName());\n+        consensusTimestamp = Utility.convertToNanosMax(instant);\n         testFile = tempDir.resolve(balanceFile.getName()).toFile();\n         assertThat(testFile.createNewFile()).isTrue();\n     }\n@@ -243,8 +246,6 @@ protected void assertAccountBalanceFile(AccountBalanceFile accountBalanceFile) {\n         assertThat(accountBalanceFile.getCount()).isEqualTo(expectedCount);\n         assertThat(accountBalanceFile.getConsensusTimestamp()).isEqualTo(consensusTimestamp);\n         assertThat(accountBalanceFile.getLoadStart()).isNotNull().isPositive();\n-        assertThat(accountBalanceFile.getLoadEnd()).isNotNull()\n-                .isGreaterThanOrEqualTo(accountBalanceFile.getLoadStart());\n         assertThat(accountBalanceFile.getName()).isEqualTo(balanceFile.getName());\n     }\n "
  },
  {
    "sha": "844042141909fb5536a535de702ac82310acb4ff",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/balance/ProtoBalanceFileReaderTest.java",
    "status": "added",
    "additions": 113,
    "deletions": 0,
    "changes": 113,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/balance/ProtoBalanceFileReaderTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/balance/ProtoBalanceFileReaderTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/balance/ProtoBalanceFileReaderTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -0,0 +1,113 @@\n+package com.hedera.mirror.importer.reader.balance;\n+\n+/*-\n+ * ‌\n+ * Hedera Mirror Node\n+ * ​\n+ * Copyright (C) 2019 - 2021 Hedera Hashgraph, LLC\n+ * ​\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * ‍\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import java.io.File;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import com.hedera.mirror.importer.TestUtils;\n+import com.hedera.mirror.importer.domain.AccountBalance;\n+import com.hedera.mirror.importer.domain.AccountBalanceFile;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.StreamFileData;\n+import com.hedera.mirror.importer.domain.TokenBalance;\n+import com.hedera.mirror.importer.exception.InvalidStreamFileException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+class ProtoBalanceFileReaderTest {\n+\n+    private static final String TIMESTAMP = \"2021-03-08T20_15_00Z\";\n+    private static final String FILEPATH = \"data/accountBalances/proto/\" + TIMESTAMP + \"_Balances.pb.gz\";\n+\n+    private AccountBalanceFile expected;\n+    private ProtoBalanceFileReader protoBalanceFileReader;\n+    private StreamFileData streamFileData;\n+\n+    @BeforeEach\n+    void setUp() {\n+        File file = TestUtils.getResource(FILEPATH).toPath().toFile();\n+        streamFileData = StreamFileData.from(file);\n+        expected = getExpectedAccountBalanceFile(streamFileData);\n+\n+        protoBalanceFileReader = new ProtoBalanceFileReader();\n+    }\n+\n+    @Test\n+    void readGzippedProtoBalanceFile() {\n+        AccountBalanceFile actual = protoBalanceFileReader.read(streamFileData);\n+        assertThat(actual).usingRecursiveComparison()\n+                .ignoringFields(\"loadStart\", \"nodeAccountId\")\n+                .isEqualTo(expected);\n+        assertThat(actual.getLoadStart()).isNotNull().isPositive();\n+    }\n+\n+    @Test\n+    void readCorruptedBytes() {\n+        corrupt(streamFileData.getBytes());\n+\n+        assertThrows(InvalidStreamFileException.class, () -> protoBalanceFileReader.read(streamFileData));\n+    }\n+\n+    private void corrupt(byte[] bytes) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            bytes[i] = (byte) (bytes[i] ^ 0xff);\n+        }\n+    }\n+\n+    private AccountBalanceFile getExpectedAccountBalanceFile(StreamFileData streamFileData) {\n+        Instant instant = Instant.parse(TIMESTAMP.replace(\"_\", \":\"));\n+        long consensusTimestamp = Utility.convertToNanosMax(instant);\n+\n+        long accountNum = 2000;\n+        long hbarBalance = 3000;\n+        long tokenNum = 5000;\n+        long tokenBalance = 6000;\n+\n+        List<AccountBalance> accountBalances = IntStream.range(0, 10).mapToObj(i -> {\n+            EntityId accountId = EntityId.of(0, 0, accountNum + i, EntityTypeEnum.ACCOUNT);\n+            List<TokenBalance> tokenBalances = IntStream.range(0, 5).mapToObj(j -> {\n+                EntityId tokenId = EntityId.of(0, 0, tokenNum + i * 5 + j, EntityTypeEnum.TOKEN);\n+                return new TokenBalance(tokenBalance + i * 5 + j,\n+                        new TokenBalance.Id(consensusTimestamp, accountId, tokenId));\n+            })\n+                    .collect(Collectors.toList());\n+            return new AccountBalance(hbarBalance + i, tokenBalances, new AccountBalance.Id(consensusTimestamp, accountId));\n+        })\n+                .collect(Collectors.toList());\n+        return AccountBalanceFile.builder()\n+                .bytes(streamFileData.getBytes())\n+                .consensusTimestamp(consensusTimestamp)\n+                .count(10L)\n+                .fileHash(\"67c2fd054621366dd5a37b6ee36a51bc590361379d539fdac2265af08cb8097729218c7d9ff1f1e354c85b820c5b8cf8\")\n+                .items(accountBalances)\n+                .name(streamFileData.getFilename())\n+                .build();\n+    }\n+}"
  },
  {
    "sha": "8764314b80299472f1c2fcbe19c595e171deea3e",
    "filename": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/record/RecordFileReaderTest.java",
    "status": "modified",
    "additions": 5,
    "deletions": 3,
    "changes": 8,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/record/RecordFileReaderTest.java",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/f72695a06b48a1c579b546cb5463c7d10bf204ec/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/record/RecordFileReaderTest.java",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/reader/record/RecordFileReaderTest.java?ref=f72695a06b48a1c579b546cb5463c7d10bf204ec",
    "patch": "@@ -81,7 +81,8 @@ void setup() throws Exception {\n                     RecordFile actual = recordFileReader.read(streamFileData, itemConsumer);\n \n                     // then\n-                    assertThat(actual).isEqualToIgnoringGivenFields(recordFile, \"bytes\", \"items\", \"loadStart\");\n+                    assertThat(actual).usingRecursiveComparison().ignoringFields(\"bytes\", \"items\", \"loadStart\")\n+                            .isEqualTo(recordFile);\n                     assertThat(actual.getBytes()).isNotEmpty().isEqualTo(streamFileData.getBytes());\n                     assertThat(actual.getLoadStart()).isNotNull().isPositive();\n                     ArgumentCaptor<RecordItem> captor = ArgumentCaptor.forClass(RecordItem.class);\n@@ -111,7 +112,8 @@ void setup() throws Exception {\n                     RecordFile actual = recordFileReader.read(streamFileData);\n \n                     // then\n-                    assertThat(actual).isEqualToIgnoringGivenFields(recordFile, \"bytes\", \"items\", \"loadStart\");\n+                    assertThat(actual).usingRecursiveComparison().ignoringFields(\"bytes\", \"items\", \"loadStart\")\n+                            .isEqualTo(recordFile);\n                     assertThat(actual.getBytes()).isNotEmpty().isEqualTo(streamFileData.getBytes());\n                     assertThat(actual.getLoadStart()).isNotNull().isPositive();\n                 });\n@@ -128,7 +130,7 @@ void setup() throws Exception {\n                     // given\n                     Path testFile = getTestFile(recordFile);\n                     byte[] bytes = FileUtils.readFileToByteArray(testFile.toFile());\n-                    byte[] bytesCorrupted = ArrayUtils.addAll(bytes, new byte[] {0, 1, 2, 3});\n+                    byte[] bytesCorrupted = ArrayUtils.addAll(bytes, new byte[] { 0, 1, 2, 3 });\n                     StreamFileData streamFileData = new StreamFileData(recordFile.getName(), bytesCorrupted);\n \n                     // when"
  }
]
