[
  {
    "sha": "8152c9d503500d971744334a23c4a389961634a0",
    "filename": "hedera-mirror-rest/entity-info-updater/README.md",
    "status": "added",
    "additions": 82,
    "deletions": 0,
    "changes": 82,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/README.md",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/README.md",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-rest/entity-info-updater/README.md?ref=69d0220582fe4e7fd7474a101273b8ee655ad504",
    "patch": "@@ -0,0 +1,82 @@\n+# Hedera Mirror Entity Info Updater\n+\n+The Mirror Node Entity Info Updater provides the ability to verify if a list of entities present in the mirror db are correct and update them if they don't match the up to date network values.\n+\n+A node based CLI tool `entity-info-updater` is provided here to showcase the steps necessary to independently update stale entities.\n+\n+## Logic\n+The CLI takes the following steps\n+\n+1. Attempts to read a csv of entity ids at the `hedera.mirror.entityUpdate.filePath` value provided in the `application.yml`\n+2. Pulls entity info for each entity from the mirror db (using a pg connection) and the network (using the js-sdk)\n+3. Compares each entity's db values to its network values to verify if they are equal.\n+    If there's a mismatch, a new entity object based on the db copy but with values updated from the network is returned.\n+    If there is no mismatch, the entity is skipped.\n+4. Updates each entity returned in step 3 in the db.\n+\n+## Requirements\n+To run the CLI you must\n+1. Install the node application\n+2. Configure the `hedera.mirror.entityUpdate` values in the `application.yml` to point to your desired mirror db and Hedera network.\n+\n+### Install CLI\n+The node based CLI tool `entity-info-updater` can be installed as follows\n+1. Ensure you've installed [NodeJS](https://nodejs.org/en/about/)\n+2. Navigate to the `hedera-mirror-rest/entity-info-updater` directory\n+3. (Optional) Npm install the tool -  `npm install -g .`\n+\n+To verify correct installation simply run `entity-info-updater --help` or `npm start -- --help` to show usage instructions.\n+\n+## Run Entity-Info-Updater CLI\n+First ensure the importer has been stopped from parsing record stream files. This ensures data won't be updated inaccurately.\n+\n+Then, from command line run\n+\n+`npm start`\n+\n+or\n+\n+`entity-info-updater`\n+\n+### Environment\n+The tool can be run against a public environment with the following configuration\n+\n+```yaml\n+hedera:\n+  mirror:\n+    entityUpdate:\n+      ...\n+      sdkClient:\n+        network: <MAINNET|TESTNET|PREVIEWNET|OTHER>\n+        nodeAddress: <nodeAddress>\n+        nodeId: <nodeId>\n+        operatorId: <operatorId>\n+        operatorKey: <operatorKey>\n+```\n+\n+### Custom DB Endpoint Case\n+The tool can be run against any DB host and database as long as it's reachable. To achieve this configure the following\n+\n+```yaml\n+hedera:\n+  mirror:\n+    entityUpdate:\n+      db:\n+        host: 127.0.0.1\n+        name: mirror_node\n+        password: mirror_node_pass\n+        port: 5432\n+        username: mirror_node\n+```\n+\n+### Input File\n+The tool requires a valid input CSV file at the location `hedera.mirror.entityUpdate.filePath` provided in the `application.yml`.\n+The structure of the file should matching the following\n+\n+| entity        | Col B | ... |\n+| ------------- |  ---- | --- |\n+| 0.0.123456    | ...   | ... |\n+| ...           | ...   | ... |\n+\n+Currently only the first column is required and must contain valid Hedera entityIds in the form `x.y.z`\n+"
  },
  {
    "sha": "8ed3ecd7d1f218f2beba159fae309b095e1d0be7",
    "filename": "hedera-mirror-rest/entity-info-updater/config.js",
    "status": "added",
    "additions": 56,
    "deletions": 0,
    "changes": 56,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/config.js",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/config.js",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-rest/entity-info-updater/config.js?ref=69d0220582fe4e7fd7474a101273b8ee655ad504",
    "patch": "@@ -0,0 +1,56 @@\n+/*-\n+ * ‌\n+ * Hedera Mirror Node\n+ * ​\n+ * Copyright (C) 2019 - 2021 Hedera Hashgraph, LLC\n+ * ​\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * ‍\n+ */\n+\n+'use strict';\n+\n+const fs = require('fs');\n+const log4js = require('log4js');\n+const path = require('path');\n+const yaml = require('js-yaml');\n+\n+const logger = log4js.getLogger();\n+let config = {};\n+let loaded = false;\n+\n+const loadYaml = () => {\n+  try {\n+    const configFile = path.join(__dirname, 'config', `application.yml`);\n+    config = yaml.load(fs.readFileSync(configFile, 'utf-8'));\n+    logger.info(`Loaded configurations from source: ${configFile}`);\n+    if (config.hedera.mirror.entityUpdate.dryRun === true) {\n+      logger.info(\n+        `Db update of entities will be skipped as 'hedera.mirror.entityUpdate.dryRun' is set to ${config.hedera.mirror.entityUpdate.dryRun}`\n+      );\n+    }\n+  } catch (err) {\n+    logger.info(err);\n+  }\n+};\n+\n+if (!loaded) {\n+  loadYaml();\n+  loaded = true;\n+}\n+\n+const getConfig = () => {\n+  return config.hedera && config.hedera.mirror ? config.hedera.mirror.entityUpdate : config;\n+};\n+\n+module.exports = getConfig();"
  },
  {
    "sha": "4b6ee27c5e2bfb3aba659e9af1e48a223dfa7aa5",
    "filename": "hedera-mirror-rest/entity-info-updater/config/application.yml",
    "status": "added",
    "additions": 20,
    "deletions": 0,
    "changes": 20,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/config/application.yml",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/config/application.yml",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-rest/entity-info-updater/config/application.yml?ref=69d0220582fe4e7fd7474a101273b8ee655ad504",
    "patch": "@@ -0,0 +1,20 @@\n+# This file contains application defaults for the entity-info-update package\n+hedera:\n+  mirror:\n+    entityUpdate:\n+      db:\n+        host: 127.0.0.1\n+        name: mirror_node\n+        password: mirror_node_pass\n+        port: 5432\n+        username: mirror_node\n+      filePath:\n+      dryRun: true\n+      log:\n+        level: debug\n+      sdkClient:\n+        network: TESTNET\n+        nodeAddress:\n+        nodeId:\n+        operatorId:\n+        operatorKey:"
  },
  {
    "sha": "00a321b2372640d6373d2f2e2aaef5ae238327c3",
    "filename": "hedera-mirror-rest/entity-info-updater/dbEntityService.js",
    "status": "added",
    "additions": 124,
    "deletions": 0,
    "changes": 124,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/dbEntityService.js",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/dbEntityService.js",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-rest/entity-info-updater/dbEntityService.js?ref=69d0220582fe4e7fd7474a101273b8ee655ad504",
    "patch": "@@ -0,0 +1,124 @@\n+/*-\n+ * ‌\n+ * Hedera Mirror Node\n+ * ​\n+ * Copyright (C) 2019 - 2021 Hedera Hashgraph, LLC\n+ * ​\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * ‍\n+ */\n+\n+'use strict';\n+\n+// external libraries\n+const log4js = require('log4js');\n+const Pool = require('pg-pool');\n+\n+// local\n+const config = require('./config');\n+\n+const logger = log4js.getLogger();\n+\n+const pool = new Pool({\n+  user: config.db.username,\n+  host: config.db.host,\n+  database: config.db.name,\n+  password: config.db.password,\n+  port: config.db.port,\n+});\n+\n+/**\n+ * Extract entity object with shard, relam and num from entity id string\n+ * @param {String} id\n+ * @returns {{num: number, realm: number, shard: number}} entity\n+ */\n+const getEntityObFromString = (id) => {\n+  let entityIdObj = {\n+    shard: 0,\n+    realm: 0,\n+    num: 0,\n+  };\n+\n+  const idParts = id.split('.');\n+  if (idParts.length === 1) {\n+    entityIdObj.num = id;\n+  } else if (idParts.length === 3) {\n+    entityIdObj.shard = idParts[0];\n+    entityIdObj.realm = idParts[1];\n+    entityIdObj.num = idParts[2];\n+  } else {\n+    throw Error('Id format is incorrect');\n+  }\n+\n+  return entityIdObj;\n+};\n+\n+/**\n+ * Retrieve entity json object from db\n+ * @param {String} id\n+ * @returns {Promise<*>}\n+ */\n+const getEntity = async (id) => {\n+  const entityIdObj = getEntityObFromString(id);\n+\n+  logger.trace(`getEntity for ${id} from ${config.db.entitiesTableName}`);\n+  const paramValues = [entityIdObj.shard, entityIdObj.realm, entityIdObj.num];\n+  const entityFromDb = await pool.query(\n+    `select *\n+       from t_entities\n+       where entity_shard = $1\n+         and entity_realm = $2\n+         and entity_num = $3`,\n+    paramValues\n+  );\n+\n+  return entityFromDb.rows[0];\n+};\n+\n+/**\n+ * Update matching entity in db\n+ * @param entity\n+ * @returns {Promise<void>}\n+ */\n+const updateEntity = async (entity) => {\n+  const paramValues = [\n+    entity.auto_renew_period,\n+    entity.deleted,\n+    entity.ed25519_public_key_hex,\n+    entity.exp_time_ns,\n+    entity.key,\n+    entity.proxy_account_id,\n+    entity.id,\n+  ];\n+\n+  if (config.dryRun === false) {\n+    await pool.query(\n+      `update t_entities\n+         set auto_renew_period      = $1,\n+             deleted                = $2,\n+             ed25519_public_key_hex = $3,\n+             exp_time_ns            = $4,\n+             key                    = $5,\n+             proxy_account_id       = $6\n+         where id = $7`,\n+      paramValues\n+    );\n+  }\n+\n+  logger.trace(`Updated entity ${entity.id}`);\n+};\n+\n+module.exports = {\n+  getEntity,\n+  updateEntity,\n+};"
  },
  {
    "sha": "0e6c7126a088f9a295467d6f83b90999879ab026",
    "filename": "hedera-mirror-rest/entity-info-updater/entityUpdateHandler.js",
    "status": "added",
    "additions": 217,
    "deletions": 0,
    "changes": 217,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/entityUpdateHandler.js",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/entityUpdateHandler.js",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-rest/entity-info-updater/entityUpdateHandler.js?ref=69d0220582fe4e7fd7474a101273b8ee655ad504",
    "patch": "@@ -0,0 +1,217 @@\n+/*-\n+ * ‌\n+ * Hedera Mirror Node\n+ * ​\n+ * Copyright (C) 2019 - 2021 Hedera Hashgraph, LLC\n+ * ​\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * ‍\n+ */\n+\n+'use strict';\n+\n+// external libraries\n+const log4js = require('log4js');\n+\n+// local\n+const networkEntityService = require('./networkEntityService');\n+const dbEntityService = require('./dbEntityService');\n+const utils = require('./utils');\n+\n+const logger = log4js.getLogger();\n+\n+const getUpdateCriteriaCount = () => {\n+  return {\n+    auto_renew_period: 0,\n+    deleted: 0,\n+    exp_time_ns: 0,\n+    ed25519_public_key_hex: 0,\n+    key: 0,\n+    memo: 0,\n+    proxy_account_id: 0,\n+  };\n+};\n+\n+const getCombinedUpdateCriteriaCount = (updateList) => {\n+  const updateCriteriaCount = getUpdateCriteriaCount();\n+  for (const counts of updateList) {\n+    Object.keys(counts).forEach((x) => {\n+      updateCriteriaCount[x] += counts[x];\n+    });\n+  }\n+\n+  return updateCriteriaCount;\n+};\n+\n+/**\n+ * Create merge entity object that takes the base db entity and updates it with more recent network retrieved values\n+ * @param dbEntity\n+ * @param networkEntity\n+ * @returns {Object} Updated db entity to insert\n+ */\n+const getUpdatedEntity = (dbEntity, networkEntity) => {\n+  // create duplicate of db entity to update with network values to eventually insert into db\n+  let updateEntity = {\n+    ...dbEntity,\n+  };\n+\n+  let updateNeeded = false;\n+  const updateCriteriaCount = getUpdateCriteriaCount();\n+\n+  if (dbEntity.auto_renew_period !== networkEntity.autoRenewPeriod.seconds.toString()) {\n+    updateEntity.auto_renew_period = networkEntity.autoRenewPeriod.seconds.toString();\n+    updateNeeded = true;\n+    updateCriteriaCount.auto_renew_period += 1;\n+    logger.trace(\n+      `auto_renew_period mismatch on ${dbEntity.id}, db: ${dbEntity.auto_renew_period}, network: ${networkEntity.autoRenewPeriod.seconds}`\n+    );\n+  }\n+\n+  // Accounts can't be undeleted\n+  if (dbEntity.deleted !== networkEntity.isDeleted && networkEntity.isDeleted === true) {\n+    updateEntity.deleted = networkEntity.isDeleted;\n+    updateNeeded = true;\n+    updateCriteriaCount.deleted += 1;\n+    logger.trace(`deleted mismatch on ${dbEntity.id}, db: ${dbEntity.deleted}, network: ${networkEntity.isDeleted}`);\n+  }\n+\n+  const ns = utils.secNsToNs(networkEntity.expirationTime.seconds, networkEntity.expirationTime.nanos);\n+  if (dbEntity.exp_time_ns !== ns) {\n+    updateEntity.exp_time_ns = ns;\n+    updateNeeded = true;\n+    updateCriteriaCount.exp_time_ns += 1;\n+    logger.trace(\n+      `expirationTime mismatch on ${dbEntity.id}, db: ${dbEntity.exp_time_ns}, network: ${JSON.stringify(\n+        networkEntity.expirationTime\n+      )}`\n+    );\n+  }\n+\n+  const {protoBuffer, ed25519Hex} = utils.getBufferAndEd25519HexFromKey(networkEntity.key);\n+  if (!utils.isEd25519PublicHexMatch(dbEntity.ed25519_public_key_hex, ed25519Hex)) {\n+    updateEntity.ed25519_public_key_hex = ed25519Hex;\n+    updateNeeded = true;\n+    updateCriteriaCount.ed25519_public_key_hex += 1;\n+    logger.trace(\n+      `ed25519 public key mismatch on ${dbEntity.id}, db: ${dbEntity.ed25519_public_key_hex}, network: ${ed25519Hex}`\n+    );\n+  }\n+\n+  if (Buffer.compare(updateEntity.key, protoBuffer) !== 0) {\n+    updateEntity.key = protoBuffer;\n+    updateNeeded = true;\n+    updateCriteriaCount.key += 1;\n+    logger.trace(`key mismatch on ${dbEntity.id}, db: ${dbEntity.key}, network: ${protoBuffer}`);\n+  }\n+\n+  if (networkEntity.proxy_account_id !== null && dbEntity.proxy_account_id !== networkEntity.proxyAccountId) {\n+    updateEntity.proxy_account_id = networkEntity.proxyAccountId;\n+    updateNeeded = true;\n+    updateCriteriaCount.proxy_account_id += 1;\n+    logger.trace(\n+      `proxy_account_id mismatch on ${dbEntity.id}, db: ${dbEntity.proxy_account_id}, network: ${networkEntity.proxyAccountId}`\n+    );\n+  }\n+\n+  if (updateNeeded) {\n+    logger.trace(\n+      `created update entity for ${dbEntity.id}: ${JSON.stringify(\n+        updateEntity\n+      )} to replace current db entity: ${JSON.stringify(dbEntity)}, updateCriteriaCount: ${JSON.stringify(\n+        updateCriteriaCount\n+      )}.`\n+    );\n+  }\n+\n+  return updateNeeded ? {updateEntity, updateCriteriaCount} : null;\n+};\n+\n+/**\n+ * Using csv entity id, compare entity information in mirror db and network state to obtained verified object\n+ * @param csvEntity\n+ * @returns {Promise<null>}\n+ */\n+const getVerifiedEntity = async (csvEntity) => {\n+  let networkEntity;\n+  try {\n+    networkEntity = await networkEntityService.getAccountInfo(csvEntity.entity);\n+  } catch (e) {\n+    logger.trace(`Error retrieving account ${csvEntity.entity} from network: ${e}`);\n+    return null;\n+  }\n+\n+  const dbEntity = await dbEntityService.getEntity(csvEntity.entity);\n+  if (!dbEntity) {\n+    logger.trace(`Null db entity, skipping`);\n+    return null;\n+  }\n+\n+  return getUpdatedEntity(dbEntity, networkEntity);\n+};\n+\n+/**\n+ * Retrieve list of objects to update mirror db with. List represents correct information for out-of-date entities\n+ * @param csvEntities\n+ * @returns {Promise<unknown[]|[]>}\n+ */\n+const getUpdateList = async (csvEntities) => {\n+  logger.info(`Validating entities against db and network entries ...`);\n+  const mergeStart = process.hrtime();\n+  let updateList = [];\n+  if (!csvEntities || csvEntities.length === 0) {\n+    return updateList;\n+  }\n+\n+  const startBalance = await networkEntityService.getAccountBalance();\n+\n+  updateList = (await Promise.all(csvEntities.map(getVerifiedEntity))).filter((x) => !!x);\n+  const elapsedTime = process.hrtime(mergeStart);\n+\n+  logger.info(\n+    `${csvEntities.length} entities were retrieved and compared in ${utils.getElapsedTimeString(elapsedTime)}`\n+  );\n+  logger.debug(\n+    `${updateList.length} were found to be out-of-date, updateCriteriaCount ${JSON.stringify(\n+      getCombinedUpdateCriteriaCount(updateList.map((x) => x.updateCriteriaCount))\n+    )}`\n+  );\n+\n+  const endBalance = await networkEntityService.getAccountBalance();\n+  logger.debug(`Network accountInfo calls cost ${startBalance.hbars.toTinybars() - endBalance.hbars.toTinybars()} tℏ`);\n+\n+  return updateList.map((x) => x.updateEntity);\n+};\n+\n+/**\n+ * Update mirror db with list of corrected entities\n+ * @param entitiesToUpdate\n+ * @returns {Promise<void>}\n+ */\n+const updateStaleDBEntities = async (entitiesToUpdate) => {\n+  if (!entitiesToUpdate || entitiesToUpdate.length === 0) {\n+    logger.info(`No entities to update, skipping update`);\n+    return;\n+  }\n+\n+  logger.info(`Updating ${entitiesToUpdate.length} stale db entries with updated information ...`);\n+  const updateStart = process.hrtime();\n+  const updatedList = await Promise.all(entitiesToUpdate.map(dbEntityService.updateEntity));\n+  const elapsedTime = process.hrtime(updateStart);\n+\n+  logger.info(`Updated ${updatedList.length} entities in ${utils.getElapsedTimeString(elapsedTime)}`);\n+};\n+\n+module.exports = {\n+  updateStaleDBEntities,\n+  getUpdateList,\n+};"
  },
  {
    "sha": "aaff9630edfb9cfda01dbaa01bb1cef6f02ee128",
    "filename": "hedera-mirror-rest/entity-info-updater/index.js",
    "status": "added",
    "additions": 78,
    "deletions": 0,
    "changes": 78,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/index.js",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/index.js",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-rest/entity-info-updater/index.js?ref=69d0220582fe4e7fd7474a101273b8ee655ad504",
    "patch": "@@ -0,0 +1,78 @@\n+#!/usr/bin/env node\n+/*-\n+ * ‌\n+ * Hedera Mirror Node\n+ * ​\n+ * Copyright (C) 2019 - 2021 Hedera Hashgraph, LLC\n+ * ​\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * ‍\n+ */\n+\n+'use strict';\n+\n+// external libraries\n+const log4js = require('log4js');\n+\n+const getConfiguredLogger = (loglevel) => {\n+  return log4js\n+    .configure({\n+      appenders: {\n+        console: {\n+          layout: {\n+            pattern: '%d{yyyy-MM-ddThh:mm:ss.SSSO} %p %m',\n+            type: 'pattern',\n+          },\n+          type: 'stdout',\n+        },\n+      },\n+      categories: {\n+        default: {\n+          appenders: ['console'],\n+          level: loglevel,\n+        },\n+      },\n+    })\n+    .getLogger();\n+};\n+\n+// configure logger with base settings to ensure we at least get debug logging for files that run logic on load\n+let logger = getConfiguredLogger('debug');\n+\n+// local\n+const config = require('./config');\n+const entityUpdateHandler = require('./entityUpdateHandler');\n+const utils = require('./utils');\n+\n+// re-configure logger based on values from config file\n+logger = getConfiguredLogger(config.log.level);\n+\n+const getUpdateList = async (entities) => {\n+  return entityUpdateHandler.getUpdateList(entities);\n+};\n+\n+const handleUpdateEntities = async (entitiesToUpdate) => {\n+  await entityUpdateHandler.updateStaleDBEntities(entitiesToUpdate);\n+};\n+\n+const migrationStart = process.hrtime();\n+\n+// get entity objects from CSV\n+const entitiesToValidate = utils.readEntityCSVFileSync();\n+\n+// get updated list of entities based on csv ids and update existing db entities with correct values\n+getUpdateList(entitiesToValidate).then(async (entitiesToUpdate) => {\n+  await handleUpdateEntities(entitiesToUpdate);\n+  const elapsedTime = process.hrtime(migrationStart);\n+  logger.info(`entity-info-update migration completed in ${utils.getElapsedTimeString(elapsedTime)}`);\n+});"
  },
  {
    "sha": "6b8693648fc98a900870d8332ab604f9cd9f35d7",
    "filename": "hedera-mirror-rest/entity-info-updater/networkEntityService.js",
    "status": "added",
    "additions": 102,
    "deletions": 0,
    "changes": 102,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/networkEntityService.js",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/networkEntityService.js",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-rest/entity-info-updater/networkEntityService.js?ref=69d0220582fe4e7fd7474a101273b8ee655ad504",
    "patch": "@@ -0,0 +1,102 @@\n+/*-\n+ * ‌\n+ * Hedera Mirror Node\n+ * ​\n+ * Copyright (C) 2019 - 2021 Hedera Hashgraph, LLC\n+ * ​\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * ‍\n+ */\n+\n+'use strict';\n+\n+// external libraries\n+const {AccountBalanceQuery, AccountId, AccountInfoQuery, Client, PrivateKey} = require('@hashgraph/sdk');\n+const log4js = require('log4js');\n+\n+// local\n+const config = require('./config');\n+\n+const logger = log4js.getLogger();\n+\n+let operatorId;\n+let client;\n+let clientConfigured = false;\n+\n+/**\n+ * Get account info from network\n+ * @param accountId\n+ * @returns {Promise<AccountInfo>}\n+ */\n+const getAccountInfo = async (accountId) => {\n+  logger.trace(`Retrieve account info for ${accountId}`);\n+  const accountInfo = await new AccountInfoQuery().setAccountId(accountId).execute(client);\n+\n+  logger.trace(`Retrieved account info from network: ${JSON.stringify(accountInfo)}`);\n+  return accountInfo;\n+};\n+\n+/**\n+ * Get account balance from network\n+ * @returns {Promise<AccountBalance>}\n+ */\n+const getAccountBalance = async () => {\n+  logger.trace(`Retrieve account balance for ${operatorId}`);\n+  const accountBalance = await new AccountBalanceQuery().setAccountId(operatorId).execute(client);\n+\n+  logger.trace(`Retrieved account balance of ${accountBalance.hbars.toTinybars()} for ${operatorId} from network`);\n+  return accountBalance;\n+};\n+\n+// configure sdk client on file load based off of config values\n+if (!clientConfigured) {\n+  logger.info(`Configure SDK client for ${config.sdkClient.network}`);\n+  if (config.sdkClient.network !== 'OTHER') {\n+    // prod env\n+    switch (config.sdkClient.network.toLowerCase()) {\n+      case 'mainnet':\n+        client = Client.forMainnet();\n+        break;\n+      case 'previewnet':\n+        client = Client.forPreviewnet();\n+        break;\n+      default:\n+        client = Client.forTestnet();\n+    }\n+  } else {\n+    const OTHERNET = {\n+      network: {\n+        [config.sdkClient.nodeAddress]: AccountId.fromString(config.sdkClient.nodeId),\n+      },\n+    };\n+\n+    client = Client.fromConfig(OTHERNET);\n+  }\n+\n+  if (!config.sdkClient.operatorId || !config.sdkClient.operatorKey) {\n+    throw new Error(\n+      'operatorId and operatorKey values must both be set under config.hedera.mirror.entityUpdate.sdkClient.'\n+    );\n+  }\n+\n+  operatorId = AccountId.fromString(config.sdkClient.operatorId);\n+  const operatorKey = PrivateKey.fromString(config.sdkClient.operatorKey);\n+  client.setOperator(operatorId, operatorKey);\n+  clientConfigured = true;\n+  logger.info(`SDK client successfully configured for Operator ID ${operatorId}`);\n+}\n+\n+module.exports = {\n+  getAccountBalance,\n+  getAccountInfo,\n+};"
  },
  {
    "sha": "3797ede3d8fef5e90b5fc4ce3dfcedf4b7287d86",
    "filename": "hedera-mirror-rest/entity-info-updater/package-lock.json",
    "status": "added",
    "additions": 5446,
    "deletions": 0,
    "changes": 5446,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/package-lock.json",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/package-lock.json",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-rest/entity-info-updater/package-lock.json?ref=69d0220582fe4e7fd7474a101273b8ee655ad504"
  },
  {
    "sha": "ae0d9e4257ea3dd10bdcb363c6628232fcc7d365",
    "filename": "hedera-mirror-rest/entity-info-updater/package.json",
    "status": "added",
    "additions": 51,
    "deletions": 0,
    "changes": 51,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/package.json",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/package.json",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-rest/entity-info-updater/package.json?ref=69d0220582fe4e7fd7474a101273b8ee655ad504",
    "patch": "@@ -0,0 +1,51 @@\n+{\n+  \"name\": \"hedera-mirror-entity-info-updater\",\n+  \"version\": \"1.0.0\",\n+  \"description\": \"An example implementation of using the js-sdk to query the Hedera network and update a desired set of entity rows in the mirror node database\",\n+  \"main\": \"index.js\",\n+  \"scripts\": {\n+    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n+    \"start\": \"node index.js\"\n+  },\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"git+https://github.com/hashgraph/hedera-mirror-node.git\"\n+  },\n+  \"keywords\": [\n+    \"hedera\",\n+    \"entity\",\n+    \"update\"\n+  ],\n+  \"author\": \"Hedera Mirror Node Team\",\n+  \"license\": \"Apache-2.0\",\n+  \"bugs\": {\n+    \"url\": \"https://github.com/hashgraph/hedera-mirror-node/issues\"\n+  },\n+  \"homepage\": \"https://github.com/hashgraph/hedera-mirror-node#readme\",\n+  \"bin\": {\n+    \"entity-info-updater\": \"./index.js\"\n+  },\n+  \"devDependencies\": {\n+    \"@hashgraph/sdk\": \"^2.0.17\",\n+    \"fs\": \"0.0.2\",\n+    \"jest\": \"^26.6.3\",\n+    \"lodash\": \"^4.17.21\",\n+    \"path\": \"^0.12.7\",\n+    \"pg\": \"^8.5.1\"\n+  },\n+  \"bundleDependencies\": [\n+    \"pg\",\n+    \"@hashgraph/sdk\",\n+    \"jest\",\n+    \"lodash\",\n+    \"fs\",\n+    \"path\"\n+  ],\n+  \"dependencies\": {\n+    \"@hashgraph/proto\": \"^1.0.22\",\n+    \"js-yaml\": \"^4.0.0\",\n+    \"log4js\": \"^6.3.0\",\n+    \"mathjs\": \"^9.3.0\",\n+    \"pg-pool\": \"^3.2.2\"\n+  }\n+}"
  },
  {
    "sha": "39dd61f0a0825541fbab7d74f033136489d264b0",
    "filename": "hedera-mirror-rest/entity-info-updater/utils.js",
    "status": "added",
    "additions": 169,
    "deletions": 0,
    "changes": 169,
    "blob_url": "https://github.com/hashgraph/hedera-mirror-node/blob/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/utils.js",
    "raw_url": "https://github.com/hashgraph/hedera-mirror-node/raw/69d0220582fe4e7fd7474a101273b8ee655ad504/hedera-mirror-rest/entity-info-updater/utils.js",
    "contents_url": "https://api.github.com/repos/hashgraph/hedera-mirror-node/contents/hedera-mirror-rest/entity-info-updater/utils.js?ref=69d0220582fe4e7fd7474a101273b8ee655ad504",
    "patch": "@@ -0,0 +1,169 @@\n+/*-\n+ * ‌\n+ * Hedera Mirror Node\n+ * ​\n+ * Copyright (C) 2019 - 2021 Hedera Hashgraph, LLC\n+ * ​\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * ‍\n+ */\n+\n+'use strict';\n+\n+// external libraries\n+\n+const proto = require('@hashgraph/proto');\n+const {KeyList, PublicKey} = require('@hashgraph/sdk');\n+const _ = require('lodash');\n+const fs = require('fs');\n+const log4js = require('log4js');\n+const math = require('mathjs');\n+\n+// local\n+const config = require('./config');\n+\n+const logger = log4js.getLogger();\n+\n+const constructEntity = (index, headerRow, entityRow) => {\n+  const entityObj = {};\n+  const splitEntityRow = Array.from(entityRow.split(',')).filter((x) => x != null);\n+\n+  for (let i = 0; i < headerRow.length; i++) {\n+    entityObj[headerRow[i].trim()] = splitEntityRow[i].trim();\n+  }\n+\n+  return entityObj;\n+};\n+\n+const readEntityCSVFileSync = () => {\n+  logger.info(`Parsing csv entity file ...`);\n+  const csvStart = process.hrtime();\n+  const entities = [];\n+\n+  const data = fs.readFileSync(config.filePath, 'utf-8');\n+\n+  const fileContent = data.split('\\n');\n+  const headers = Array.from(fileContent[0].split(',')).filter((x) => x != null);\n+\n+  // ensure first column is entity num of expected format\n+  if (!_.eq(headers[0], 'entity')) {\n+    throw Error(\"CSV must have a header column with first column being 'entity'\");\n+  }\n+\n+  for (let i = 1; i < fileContent.length; i++) {\n+    if (!fileContent[i]) {\n+      // End of file\n+      break;\n+    }\n+\n+    entities.push(constructEntity(i, headers, fileContent[i]));\n+  }\n+\n+  const elapsedTime = process.hrtime(csvStart);\n+  logger.info(\n+    `${entities.length} entities were extracted from ${config.filePath} in ${getElapsedTimeString(elapsedTime)}`\n+  );\n+\n+  return entities;\n+};\n+\n+/**\n+ * Converts seconds since epoch (seconds nnnnnnnnn format) to  nanoseconds\n+ * @param {String} Seconds since epoch (seconds.nnnnnnnnn format)\n+ * @return {String} ns Nanoseconds since epoch\n+ */\n+const secNsToNs = (secNs, ns) => {\n+  return math\n+    .add(math.multiply(math.bignumber(secNs.toString()), math.bignumber(1e9)), math.bignumber(ns.toString()))\n+    .toString();\n+};\n+\n+const keyListToProto = (keyList) => {\n+  const keys = [];\n+\n+  for (const key of keyList) {\n+    keys.push(keyToProto(key));\n+  }\n+\n+  return {\n+    keys,\n+  };\n+};\n+\n+const keyToProto = (key) => {\n+  if (key instanceof PublicKey) {\n+    return {\n+      ed25519: key.toBytes(),\n+    };\n+  }\n+\n+  if (key instanceof KeyList) {\n+    return {\n+      keyList: keyListToProto(key),\n+    };\n+  }\n+\n+  throw Error('Unsupported key type');\n+};\n+\n+const getProtoAndEd25519HexFromPublicKey = (key) => {\n+  const protoKey = {\n+    ed25519: key.toBytes(),\n+  };\n+  const ed25519Hex = key.toString();\n+\n+  return {protoKey, ed25519Hex};\n+};\n+\n+const getProtoAndEd25519HexFromKeyList = (key) => {\n+  const protoKey = {\n+    keyList: keyListToProto(key),\n+  };\n+  const ed25519HexParts = key._keys.toString().split(',');\n+  const ed25519Hex = ed25519HexParts.length === 1 ? ed25519HexParts[0] : null;\n+\n+  return {protoKey, ed25519Hex};\n+};\n+\n+const getBufferAndEd25519HexFromKey = (key) => {\n+  const {protoKey, ed25519Hex} =\n+    key instanceof PublicKey ? getProtoAndEd25519HexFromPublicKey(key) : getProtoAndEd25519HexFromKeyList(key);\n+  let protoBuffer = null;\n+  protoBuffer = proto.Key.encode(protoKey, protoBuffer).finish();\n+\n+  return {protoBuffer, ed25519Hex};\n+};\n+\n+const getElapsedTimeString = (elapsedTime) => {\n+  return `${elapsedTime[0]} s ${elapsedTime[1] / 1000000} ms`;\n+};\n+\n+const isEd25519PublicHexMatch = (dbHex, networkHex) => {\n+  let match;\n+  match = dbHex === networkHex;\n+\n+  if (!match && dbHex !== null) {\n+    // check for derPrefix (302a300506032b6570032100) case\n+    match = PublicKey.fromString(dbHex).toString() === networkHex;\n+  }\n+\n+  return match;\n+};\n+\n+module.exports = {\n+  getBufferAndEd25519HexFromKey,\n+  getElapsedTimeString,\n+  isEd25519PublicHexMatch,\n+  readEntityCSVFileSync,\n+  secNsToNs,\n+};"
  }
]
