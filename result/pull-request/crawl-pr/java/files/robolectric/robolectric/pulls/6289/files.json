[
  {
    "sha": "0c0f82a49cabf0309c2e9680fc6cf0f544abae98",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java",
    "status": "modified",
    "additions": 169,
    "deletions": 0,
    "changes": 169,
    "blob_url": "https://github.com/robolectric/robolectric/blob/7f06b3afaa6b7d788be543ca2e86d9638a35c400/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/7f06b3afaa6b7d788be543ca2e86d9638a35c400/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java?ref=7f06b3afaa6b7d788be543ca2e86d9638a35c400",
    "patch": "@@ -3,6 +3,10 @@\n import static android.app.AppOpsManager.MODE_ALLOWED;\n import static android.app.AppOpsManager.MODE_DEFAULT;\n import static android.app.AppOpsManager.MODE_ERRORED;\n+import static android.app.AppOpsManager.MODE_FOREGROUND;\n+import static android.app.AppOpsManager.MODE_IGNORED;\n+import static android.app.AppOpsManager.OPSTR_BODY_SENSORS;\n+import static android.app.AppOpsManager.OPSTR_COARSE_LOCATION;\n import static android.app.AppOpsManager.OPSTR_FINE_LOCATION;\n import static android.app.AppOpsManager.OPSTR_GPS;\n import static android.app.AppOpsManager.OPSTR_READ_PHONE_STATE;\n@@ -12,6 +16,7 @@\n import static android.app.AppOpsManager.OP_SEND_SMS;\n import static android.app.AppOpsManager.OP_VIBRATE;\n import static android.os.Build.VERSION_CODES.KITKAT;\n+import static android.os.Build.VERSION_CODES.Q;\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n import static org.mockito.Mockito.mock;\n@@ -393,6 +398,140 @@ public void checkPackage_belongs() {\n     // check passes without exception\n   }\n \n+  @Config(minSdk = KITKAT)\n+  @Test\n+  public void getPackageForOps_setOne_getOne() {\n+    String packageName = \"com.android.package\";\n+    int uid = 111;\n+    appOps.setMode(0, uid, packageName, MODE_ALLOWED);\n+\n+    int[] intNull = null;\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(intNull);\n+    assertThat(containsPackageOpPair(packageOps, packageName, 0, MODE_ALLOWED)).isTrue();\n+  }\n+\n+  @Config(minSdk = KITKAT)\n+  @Test\n+  public void getPackageForOps_setMultiple_getMultiple() {\n+    String packageName1 = \"com.android.package\";\n+    String packageName2 = \"com.android.other\";\n+    int uid1 = 111;\n+    int uid2 = 112;\n+    appOps.setMode(0, uid1, packageName1, MODE_ALLOWED);\n+    appOps.setMode(1, uid1, packageName1, MODE_DEFAULT);\n+    appOps.setMode(2, uid1, packageName1, MODE_ERRORED);\n+    appOps.setMode(3, uid1, packageName1, MODE_FOREGROUND);\n+    appOps.setMode(4, uid1, packageName1, MODE_IGNORED);\n+    appOps.setMode(0, uid2, packageName2, MODE_ALLOWED);\n+\n+    int[] intNull = null;\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(intNull);\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 0, MODE_ALLOWED)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 1, MODE_DEFAULT)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 2, MODE_ERRORED)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 3, MODE_FOREGROUND)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 4, MODE_IGNORED)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName2, 0, MODE_ALLOWED)).isTrue();\n+  }\n+\n+  @Config(minSdk = KITKAT)\n+  @Test\n+  public void getPackageForOps_setMultiple_onlyGetThoseAskedFor() {\n+    String packageName1 = \"com.android.package\";\n+    String packageName2 = \"com.android.other\";\n+    int uid1 = 111;\n+    int uid2 = 112;\n+    appOps.setMode(0, uid1, packageName1, MODE_ALLOWED);\n+    appOps.setMode(1, uid1, packageName1, MODE_DEFAULT);\n+    appOps.setMode(2, uid1, packageName1, MODE_ERRORED);\n+    appOps.setMode(3, uid1, packageName1, MODE_FOREGROUND);\n+    appOps.setMode(4, uid1, packageName1, MODE_IGNORED);\n+    appOps.setMode(0, uid2, packageName2, MODE_ALLOWED);\n+\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(new int[] {0, 1});\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 0, MODE_ALLOWED)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 1, MODE_DEFAULT)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 2, MODE_ERRORED)).isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 3, MODE_FOREGROUND)).isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 4, MODE_IGNORED)).isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName2, 0, MODE_ALLOWED)).isTrue();\n+  }\n+\n+  @Config(minSdk = Q)\n+  @Test\n+  public void getPackageForOpsStr_setOne_getOne() {\n+    String packageName = \"com.android.package\";\n+    int uid = 111;\n+    appOps.setMode(AppOpsManager.OPSTR_COARSE_LOCATION, uid, packageName, MODE_ALLOWED);\n+\n+    String[] stringNull = null;\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(stringNull);\n+    assertThat(containsPackageOpPair(packageOps, packageName, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+  }\n+\n+  @Config(minSdk = Q)\n+  @Test\n+  public void getPackageForOpsStr_setMultiple_getMultiple() {\n+    String packageName1 = \"com.android.package\";\n+    String packageName2 = \"com.android.other\";\n+    int uid1 = 111;\n+    int uid2 = 112;\n+    appOps.setMode(OPSTR_COARSE_LOCATION, uid1, packageName1, MODE_ALLOWED);\n+    appOps.setMode(OPSTR_FINE_LOCATION, uid1, packageName1, MODE_DEFAULT);\n+    appOps.setMode(OPSTR_READ_PHONE_STATE, uid1, packageName1, MODE_ERRORED);\n+    appOps.setMode(OPSTR_RECORD_AUDIO, uid1, packageName1, MODE_FOREGROUND);\n+    appOps.setMode(OPSTR_BODY_SENSORS, uid1, packageName1, MODE_IGNORED);\n+    appOps.setMode(OPSTR_COARSE_LOCATION, uid2, packageName2, MODE_ALLOWED);\n+\n+    String[] stringNull = null;\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(stringNull);\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_FINE_LOCATION, MODE_DEFAULT))\n+        .isTrue();\n+    assertThat(\n+            containsPackageOpPair(packageOps, packageName1, OPSTR_READ_PHONE_STATE, MODE_ERRORED))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_RECORD_AUDIO, MODE_FOREGROUND))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_BODY_SENSORS, MODE_IGNORED))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName2, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+  }\n+\n+  @Config(minSdk = Q)\n+  @Test\n+  public void getPackageForOpsStr_setMultiple_onlyGetThoseAskedFor() {\n+    String packageName1 = \"com.android.package\";\n+    String packageName2 = \"com.android.other\";\n+    int uid1 = 111;\n+    int uid2 = 112;\n+    appOps.setMode(OPSTR_COARSE_LOCATION, uid1, packageName1, MODE_ALLOWED);\n+    appOps.setMode(OPSTR_FINE_LOCATION, uid1, packageName1, MODE_DEFAULT);\n+    appOps.setMode(OPSTR_READ_PHONE_STATE, uid1, packageName1, MODE_ERRORED);\n+    appOps.setMode(OPSTR_RECORD_AUDIO, uid1, packageName1, MODE_FOREGROUND);\n+    appOps.setMode(OPSTR_BODY_SENSORS, uid1, packageName1, MODE_IGNORED);\n+    appOps.setMode(OPSTR_COARSE_LOCATION, uid2, packageName2, MODE_ALLOWED);\n+\n+    List<PackageOps> packageOps =\n+        appOps.getPackagesForOps(new String[] {OPSTR_COARSE_LOCATION, OPSTR_FINE_LOCATION});\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_FINE_LOCATION, MODE_DEFAULT))\n+        .isTrue();\n+    assertThat(\n+            containsPackageOpPair(packageOps, packageName1, OPSTR_READ_PHONE_STATE, MODE_ERRORED))\n+        .isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_RECORD_AUDIO, MODE_FOREGROUND))\n+        .isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_BODY_SENSORS, MODE_IGNORED))\n+        .isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName2, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+  }\n+\n   /** Assert that the results contain the expected op codes. */\n   private void assertOps(List<PackageOps> pkgOps, Integer... expectedOps) {\n     Set<Integer> actualOps = new HashSet<>();\n@@ -404,4 +543,34 @@ private void assertOps(List<PackageOps> pkgOps, Integer... expectedOps) {\n \n     assertThat(actualOps).containsAtLeastElementsIn(expectedOps);\n   }\n+\n+  /** True if the given (package, op, mode) tuple is present in the given list. */\n+  private boolean containsPackageOpPair(\n+      List<PackageOps> pkgOps, String packageName, int op, int mode) {\n+    for (PackageOps pkgOp : pkgOps) {\n+      for (OpEntry entry : pkgOp.getOps()) {\n+        if (packageName.equals(pkgOp.getPackageName())\n+            && entry.getOp() == op\n+            && entry.getMode() == mode) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /** True if the given (package, op, mode) tuple is present in the given list. */\n+  private boolean containsPackageOpPair(\n+      List<PackageOps> pkgOps, String packageName, String op, int mode) {\n+    for (PackageOps pkgOp : pkgOps) {\n+      for (OpEntry entry : pkgOp.getOps()) {\n+        if (packageName.equals(pkgOp.getPackageName())\n+            && op.equals(entry.getOpStr())\n+            && entry.getMode() == mode) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n }"
  },
  {
    "sha": "7880e19ffd8b766070a754c52033b8fa1b9eca4b",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java",
    "status": "modified",
    "additions": 18,
    "deletions": 1,
    "changes": 19,
    "blob_url": "https://github.com/robolectric/robolectric/blob/7f06b3afaa6b7d788be543ca2e86d9638a35c400/robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/7f06b3afaa6b7d788be543ca2e86d9638a35c400/robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java?ref=7f06b3afaa6b7d788be543ca2e86d9638a35c400",
    "patch": "@@ -10,6 +10,7 @@\n import static com.google.common.truth.TruthJUnit.assume;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertSame;\n import static org.junit.Assert.assertTrue;\n@@ -664,6 +665,23 @@ public void shouldClearStartedServiceIntents() {\n     assertNull(shadowOf(context).getNextStartedService());\n   }\n \n+  @Test\n+  public void getAllStartedServices() {\n+    Intent intent1 = getSomeActionIntent(\"some.action\");\n+    Intent intent2 = getSomeActionIntent(\"another.action\");\n+\n+    context.startService(intent1);\n+    context.startService(intent2);\n+    List<Intent> startedServiceIntents = shadowOf(context).getAllStartedServices();\n+\n+    assertThat(startedServiceIntents).hasSize(2);\n+    assertThat(startedServiceIntents.get(0).filterEquals(intent1)).isTrue();\n+    assertThat(startedServiceIntents.get(1).filterEquals(intent2)).isTrue();\n+    assertNotNull(shadowOf(context).getNextStartedService());\n+    assertNotNull(shadowOf(context).getNextStartedService());\n+    assertNull(shadowOf(context).getNextStartedService());\n+  }\n+\n   @Test\n   public void shouldThrowIfContainsRegisteredReceiverOfAction() {\n     Activity activity = Robolectric.setupActivity(Activity.class);\n@@ -899,4 +917,3 @@ public void onReceive(Context context, Intent intent) {\n     }\n   }\n }\n-"
  },
  {
    "sha": "253e64b46d1f810191ccf5a23840a3b82cd076a6",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java",
    "status": "modified",
    "additions": 12,
    "deletions": 6,
    "changes": 18,
    "blob_url": "https://github.com/robolectric/robolectric/blob/7f06b3afaa6b7d788be543ca2e86d9638a35c400/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/7f06b3afaa6b7d788be543ca2e86d9638a35c400/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java?ref=7f06b3afaa6b7d788be543ca2e86d9638a35c400",
    "patch": "@@ -77,11 +77,13 @@ public void requestAudioFocus2_shouldRecordArgumentsOfMostRecentCall() {\n     AudioAttributes atts = new AudioAttributes.Builder().build();\n     android.media.AudioFocusRequest request =\n         new android.media.AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)\n+            .setOnAudioFocusChangeListener(listener)\n             .setAudioAttributes(atts)\n             .build();\n \n     audioManager.requestAudioFocus(request);\n-    assertThat(shadowOf(audioManager).getLastAudioFocusRequest().listener).isNull();\n+    assertThat(shadowOf(audioManager).getLastAudioFocusRequest().listener)\n+        .isSameInstanceAs(listener);\n     assertThat(shadowOf(audioManager).getLastAudioFocusRequest().streamType).isEqualTo(-1);\n     assertThat(shadowOf(audioManager).getLastAudioFocusRequest().durationHint).isEqualTo(-1);\n     assertThat(shadowOf(audioManager).getLastAudioFocusRequest().audioFocusRequest)\n@@ -118,10 +120,14 @@ public void abandonAudioFocus_shouldRecordTheListenerOfTheMostRecentCall() {\n   @Config(minSdk = O)\n   public void abandonAudioFocusRequest_shouldRecordTheListenerOfTheMostRecentCall() {\n     android.media.AudioFocusRequest request =\n-        new android.media.AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN).build();\n+        new android.media.AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)\n+            .setOnAudioFocusChangeListener(listener)\n+            .build();\n     audioManager.abandonAudioFocusRequest(request);\n     assertThat(shadowOf(audioManager).getLastAbandonedAudioFocusRequest())\n         .isSameInstanceAs(request);\n+    assertThat(shadowOf(audioManager).getLastAbandonedAudioFocusListener())\n+        .isSameInstanceAs(listener);\n   }\n \n   @Test\n@@ -491,7 +497,7 @@ public void adjustStreamVolume_lower() {\n     int volumeBefore = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n \n     audioManager.adjustStreamVolume(\n-            AudioManager.STREAM_MUSIC, AudioManager.ADJUST_LOWER, /* flags= */ 0);\n+        AudioManager.STREAM_MUSIC, AudioManager.ADJUST_LOWER, /* flags= */ 0);\n \n     int volumeAfter = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n     assertThat(volumeAfter).isLessThan(volumeBefore);\n@@ -504,7 +510,7 @@ public void adjustStreamVolume_lowerAtMinVolume_remainsSame() {\n     int volumeBefore = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n \n     audioManager.adjustStreamVolume(\n-            AudioManager.STREAM_MUSIC, AudioManager.ADJUST_LOWER, /* flags= */ 0);\n+        AudioManager.STREAM_MUSIC, AudioManager.ADJUST_LOWER, /* flags= */ 0);\n \n     int volumeAfter = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n     assertThat(volumeAfter).isEqualTo(volumeBefore);\n@@ -517,7 +523,7 @@ public void adjustStreamVolume_raise() {\n     int volumeBefore = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n \n     audioManager.adjustStreamVolume(\n-            AudioManager.STREAM_MUSIC, AudioManager.ADJUST_RAISE, /* flags= */ 0);\n+        AudioManager.STREAM_MUSIC, AudioManager.ADJUST_RAISE, /* flags= */ 0);\n \n     int volumeAfter = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n     assertThat(volumeAfter).isGreaterThan(volumeBefore);\n@@ -531,7 +537,7 @@ public void adjustStreamVolume_raiseAtMaxVolume_remainsSame() {\n     int volumeBefore = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n \n     audioManager.adjustStreamVolume(\n-            AudioManager.STREAM_MUSIC, AudioManager.ADJUST_RAISE, /* flags= */ 0);\n+        AudioManager.STREAM_MUSIC, AudioManager.ADJUST_RAISE, /* flags= */ 0);\n \n     int volumeAfter = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n     assertThat(volumeAfter).isEqualTo(volumeBefore);"
  },
  {
    "sha": "76eb107b4756ffe949282c008bb7b0a0bd72eedd",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowBugreportManagerTest.java",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/robolectric/robolectric/blob/7f06b3afaa6b7d788be543ca2e86d9638a35c400/robolectric/src/test/java/org/robolectric/shadows/ShadowBugreportManagerTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/7f06b3afaa6b7d788be543ca2e86d9638a35c400/robolectric/src/test/java/org/robolectric/shadows/ShadowBugreportManagerTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowBugreportManagerTest.java?ref=7f06b3afaa6b7d788be543ca2e86d9638a35c400",
    "patch": "@@ -41,6 +41,14 @@ public void setUp() {\n     shadowBugreportManager = Shadow.extract(context.getSystemService(Context.BUGREPORT_SERVICE));\n   }\n \n+  @Test\n+  public void requestBugreport() {\n+    shadowBugreportManager.requestBugreport(\n+        new BugreportParams(BugreportParams.BUGREPORT_MODE_INTERACTIVE), \"title\", \"description\");\n+\n+    assertThat(shadowBugreportManager.wasBugreportRequested()).isTrue();\n+  }\n+\n   @Test\n   public void startBugreport() throws Exception {\n     BugreportCallback callback = mock(BugreportCallback.class);"
  },
  {
    "sha": "786654650c3de8b6fb1f575195f8351a160dd4b9",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java",
    "status": "modified",
    "additions": 66,
    "deletions": 0,
    "changes": 66,
    "blob_url": "https://github.com/robolectric/robolectric/blob/7f06b3afaa6b7d788be543ca2e86d9638a35c400/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/7f06b3afaa6b7d788be543ca2e86d9638a35c400/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java?ref=7f06b3afaa6b7d788be543ca2e86d9638a35c400",
    "patch": "@@ -8,11 +8,13 @@\n import static android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI;\n import static com.google.common.truth.Truth.assertThat;\n import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.fail;\n import static org.mockito.ArgumentMatchers.same;\n import static org.mockito.Mockito.doReturn;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n import static org.robolectric.Shadows.shadowOf;\n import static org.robolectric.annotation.Config.NONE;\n \n@@ -54,6 +56,7 @@\n import java.util.List;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -475,6 +478,69 @@ public String toString() {\n     assertThat(streamCreateCount.get()).isEqualTo(2);\n   }\n \n+  @Test\n+  @Config(minSdk = KITKAT)\n+  public void openFileDescriptor_noFileRegistered_throwsNotFound() throws Exception {\n+    // WHEN a not-yet-registered file is being opened\n+\n+    // THEN it calls through to the framework, which then throws.\n+    assertThrows(FileNotFoundException.class, () -> contentResolver.openFileDescriptor(\n+        Uri.parse(\"content://com.unknown.authority/path\"),\n+        /* mode= */ \"r\",\n+        /* cancellationSignal= */ null));\n+  }\n+\n+  @Test\n+  @Config(minSdk = KITKAT)\n+  public void openFileDescriptor_noFileRegistered_providerExists_returnsDescriptor()\n+      throws Exception {\n+    // WHEN a not-yet-registered file is being opened\n+\n+    // ... but there is an underlying provider registered already\n+    Robolectric.setupContentProvider(MyContentProvider.class, AUTHORITY);\n+\n+    // THEN we call through to the framework, which returns a descriptor.\n+    Uri uri = Uri.parse(\"content://\" + AUTHORITY + \"/path\");\n+    ParcelFileDescriptor descriptor = contentResolver.openFileDescriptor(\n+        uri,\n+        /* mode= */ \"r\",\n+        /* cancellationSignal= */ null);\n+\n+    assertThat(descriptor).isNotNull();\n+    descriptor.close();\n+  }\n+\n+  @Test\n+  @Config(minSdk = KITKAT)\n+  public void registerFileDescriptorSupplier_noCall_doesNotCallSupplier() throws Exception {\n+    // WHEN a supplier is registered\n+    Uri uri = Uri.parse(\"content://\" + AUTHORITY + \"/path\");\n+    Supplier<ParcelFileDescriptor> mockSupplier = mock(Supplier.class);\n+    shadowOf(contentResolver).registerFileDescriptorSupplier(uri, mockSupplier);\n+\n+    // THEN it is not called until someone actually requests the file\n+    verifyNoMoreInteractions(mockSupplier);\n+  }\n+\n+  @Test\n+  @Config(minSdk = KITKAT)\n+  public void openFileDescriptor_supplierRegistered_asksSupplier() throws Exception {\n+    // WHEN a supplier is registered\n+    Uri uri = Uri.parse(\"content://\" + AUTHORITY + \"/path\");\n+    ParcelFileDescriptor descriptorToReturn =\n+        new MyContentProvider().openFile(/* uri= */ null, /* mode= */ null);\n+    shadowOf(contentResolver).registerFileDescriptorSupplier(uri, () -> descriptorToReturn);\n+\n+    // WHEN the file is opened\n+    ParcelFileDescriptor descriptor =\n+        contentResolver.openFileDescriptor(uri, /* mode= */ \"r\", /* cancellationSignal= */ null);\n+\n+    // THEN we get the same descriptor back\n+    assertThat(descriptor).isSameInstanceAs(descriptorToReturn);\n+\n+    descriptorToReturn.close();\n+  }\n+\n   @Test\n   public void shouldTrackNotifiedUris() {\n     contentResolver.notifyChange(Uri.parse(\"foo\"), null, true);"
  },
  {
    "sha": "57b0399fef34e478709dd7d9e1bc97c518a68a63",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java",
    "status": "added",
    "additions": 27,
    "deletions": 0,
    "changes": 27,
    "blob_url": "https://github.com/robolectric/robolectric/blob/7f06b3afaa6b7d788be543ca2e86d9638a35c400/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/7f06b3afaa6b7d788be543ca2e86d9638a35c400/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java?ref=7f06b3afaa6b7d788be543ca2e86d9638a35c400",
    "patch": "@@ -0,0 +1,27 @@\n+package org.robolectric.shadows;\n+\n+import static android.os.Build.VERSION_CODES.JELLY_BEAN_MR1;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import android.hardware.display.DisplayManagerGlobal;\n+import android.view.Display;\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.annotation.Config;\n+import org.robolectric.annotation.LazyLoadApplication;\n+import org.robolectric.annotation.LazyLoadApplication.LazyLoad;\n+\n+/** Unit tests for {@link ShadowDisplayManagerGlobal} */\n+@RunWith(AndroidJUnit4.class)\n+public class ShadowDisplayManagerGlobalTest {\n+\n+  @LazyLoadApplication(LazyLoad.ON)\n+  @Test\n+  @Config(minSdk = JELLY_BEAN_MR1)\n+  public void testDisplayManagerGlobalIsLazyLoaded() {\n+    assertThat(ShadowDisplayManagerGlobal.getGlobalInstance()).isNull();\n+    assertThat(DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY))\n+        .isNotNull();\n+  }\n+}"
  },
  {
    "sha": "31de614d58ac917f5f5e2e2e7f30e0e8b0ed3b2c",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java",
    "status": "modified",
    "additions": 118,
    "deletions": 36,
    "changes": 154,
    "blob_url": "https://github.com/robolectric/robolectric/blob/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java?ref=7f06b3afaa6b7d788be543ca2e86d9638a35c400",
    "patch": "@@ -6,8 +6,10 @@\n import static android.os.Build.VERSION_CODES.P;\n import static android.os.Build.VERSION_CODES.Q;\n import static android.os.Build.VERSION_CODES.R;\n+import static java.util.stream.Collectors.toSet;\n import static org.robolectric.shadow.api.Shadow.invokeConstructor;\n \n+import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.annotation.RequiresPermission;\n import android.annotation.SystemApi;\n@@ -26,20 +28,24 @@\n import android.util.LongSparseArray;\n import android.util.LongSparseLongArray;\n import com.android.internal.app.IAppOpsService;\n+import com.google.auto.value.AutoValue;\n import com.google.common.collect.BiMap;\n import com.google.common.collect.HashBiMap;\n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Multimap;\n+import com.google.common.collect.MultimapBuilder;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.stream.IntStream;\n import org.robolectric.RuntimeEnvironment;\n import org.robolectric.annotation.HiddenApi;\n import org.robolectric.annotation.Implementation;\n@@ -62,19 +68,19 @@\n \n   @RealObject private AppOpsManager realObject;\n \n-  // Recorded operations, keyed by \"uid|packageName\"\n-  private Multimap<String, Integer> mStoredOps = HashMultimap.create();\n-  // \"uid|packageName|opCode\" => opMode\n-  private Map<String, Integer> appModeMap = new HashMap<>();\n+  // Recorded operations, keyed by (uid, packageName)\n+  private final Multimap<Key, Integer> storedOps = HashMultimap.create();\n+  // (uid, packageName, opCode) => opMode\n+  private final Map<Key, Integer> appModeMap = new HashMap<>();\n \n-  // \"uid|packageName|opCode\" => opMode\n-  private Set<String> longRunningOp = new HashSet<>();\n+  // (uid, packageName, opCode)\n+  private final Set<Key> longRunningOp = new HashSet<>();\n \n-  // \"packageName|opCode\" => listener\n-  private BiMap<String, OnOpChangedListener> appOpListeners = HashBiMap.create();\n+  // (packageName, opCode) => listener\n+  private final BiMap<Key, OnOpChangedListener> appOpListeners = HashBiMap.create();\n \n   // op | (usage << 8) => ModeAndExcpetion\n-  private Map<Integer, ModeAndException> audioRestrictions = new HashMap<>();\n+  private final Map<Integer, ModeAndException> audioRestrictions = new HashMap<>();\n \n   private Context context;\n \n@@ -120,21 +126,93 @@ public void setMode(String op, int uid, String packageName, int mode) {\n   @HiddenApi\n   @RequiresPermission(android.Manifest.permission.MANAGE_APP_OPS_MODES)\n   public void setMode(int op, int uid, String packageName, int mode) {\n-    Integer oldMode = appModeMap.put(getOpMapKey(uid, packageName, op), mode);\n-    OnOpChangedListener listener = appOpListeners.get(getListenerKey(op, packageName));\n+    Integer oldMode = appModeMap.put(Key.create(uid, packageName, op), mode);\n+    OnOpChangedListener listener = appOpListeners.get(Key.create(null, packageName, op));\n     if (listener != null && !Objects.equals(oldMode, mode)) {\n       String[] sOpToString = ReflectionHelpers.getStaticField(AppOpsManager.class, \"sOpToString\");\n       listener.onOpChanged(sOpToString[op], packageName);\n     }\n   }\n \n+  /**\n+   * Returns app op details for all packages for which one of {@link #setMode} methods was used to\n+   * set the value of one of the given app ops (it does return those set to 'default' mode, while\n+   * the true implementation usually doesn't). Also, we don't enforce any permission checks which\n+   * might be needed in the true implementation.\n+   *\n+   * @param ops The set of operations you are interested in, or null if you want all of them.\n+   * @return app ops information about each package, containing only ops that were specified as an\n+   *     argument\n+   */\n+  @Implementation(minSdk = Q)\n+  @HiddenApi\n+  @SystemApi\n+  @NonNull\n+  protected List<AppOpsManager.PackageOps> getPackagesForOps(@Nullable String[] ops) {\n+    if (ops == null) {\n+      int[] intOps = null;\n+      return getPackagesForOps(intOps);\n+    }\n+\n+    List<Integer> intOpsList = new ArrayList<>();\n+    for (String op : ops) {\n+      intOpsList.add(AppOpsManager.strOpToOp(op));\n+    }\n+\n+    return getPackagesForOps(intOpsList.stream().mapToInt(i -> i).toArray());\n+  }\n+\n+  /**\n+   * Returns app op details for all packages for which one of {@link #setMode} methods was used to\n+   * set the value of one of the given app ops (it does return those set to 'default' mode, while\n+   * the true implementation usually doesn't). Also, we don't enforce any permission checks which\n+   * might be needed in the true implementation.\n+   *\n+   * @param ops The set of operations you are interested in, or null if you want all of them.\n+   * @return app ops information about each package, containing only ops that were specified as an\n+   *     argument\n+   */\n+  @Implementation(minSdk = KITKAT) // to be consistent with setMode() shadow implementations\n+  @HiddenApi\n+  protected List<PackageOps> getPackagesForOps(int[] ops) {\n+    Set<Integer> relevantOps;\n+    if (ops != null) {\n+      relevantOps = IntStream.of(ops).boxed().collect(toSet());\n+    } else {\n+      relevantOps = new HashSet<>();\n+    }\n+\n+    // Aggregating op data per each package.\n+    // (uid, packageName) => [(op, mode)]\n+    Multimap<Key, OpEntry> perPackageMap = MultimapBuilder.hashKeys().hashSetValues().build();\n+    for (Map.Entry<Key, Integer> appOpInfo : appModeMap.entrySet()) {\n+      Key key = appOpInfo.getKey();\n+      if (ops == null || relevantOps.contains(key.getOpCode())) {\n+        Key packageKey = Key.create(key.getUid(), key.getPackageName(), null);\n+        OpEntry opEntry = toOpEntry(key.getOpCode(), appOpInfo.getValue());\n+        perPackageMap.put(packageKey, opEntry);\n+      }\n+    }\n+\n+    List<PackageOps> result = new ArrayList<>();\n+    // Creating resulting PackageOps objects using all op info collected per package.\n+    for (Map.Entry<Key, Collection<OpEntry>> packageInfo : perPackageMap.asMap().entrySet()) {\n+      Key key = packageInfo.getKey();\n+      result.add(\n+          new PackageOps(\n+              key.getPackageName(), key.getUid(), new ArrayList<>(packageInfo.getValue())));\n+    }\n+\n+    return result;\n+  }\n+\n   @Implementation(minSdk = Q)\n   public int unsafeCheckOpNoThrow(String op, int uid, String packageName) {\n     return checkOpNoThrow(AppOpsManager.strOpToOp(op), uid, packageName);\n   }\n \n   private int unsafeCheckOpRawNoThrow(int op, int uid, String packageName) {\n-    Integer mode = appModeMap.get(getOpMapKey(uid, packageName, op));\n+    Integer mode = appModeMap.get(Key.create(uid, packageName, op));\n     if (mode == null) {\n       return AppOpsManager.MODE_ALLOWED;\n     }\n@@ -147,15 +225,15 @@ protected int startOp(\n       String op, int uid, String packageName, String attributionTag, String message) {\n     int mode = unsafeCheckOpRawNoThrow(op, uid, packageName);\n     if (mode == AppOpsManager.MODE_ALLOWED) {\n-      longRunningOp.add(getOpMapKey(uid, packageName, AppOpsManager.strOpToOp(op)));\n+      longRunningOp.add(Key.create(uid, packageName, AppOpsManager.strOpToOp(op)));\n     }\n     return mode;\n   }\n \n   /** Removes a fake long-running operation from the set. */\n   @Implementation(minSdk = R)\n   protected void finishOp(String op, int uid, String packageName, String attributionTag) {\n-    longRunningOp.remove(getOpMapKey(uid, packageName, AppOpsManager.strOpToOp(op)));\n+    longRunningOp.remove(Key.create(uid, packageName, AppOpsManager.strOpToOp(op)));\n   }\n \n   /**\n@@ -164,7 +242,7 @@ protected void finishOp(String op, int uid, String packageName, String attributi\n    */\n   @Implementation(minSdk = R)\n   protected boolean isOpActive(String op, int uid, String packageName) {\n-    return longRunningOp.contains(getOpMapKey(uid, packageName, AppOpsManager.strOpToOp(op)));\n+    return longRunningOp.contains(Key.create(uid, packageName, AppOpsManager.strOpToOp(op)));\n   }\n \n   /**\n@@ -198,7 +276,7 @@ public int checkOpNoThrow(int op, int uid, String packageName) {\n \n   @Implementation(minSdk = KITKAT)\n   public int noteOp(int op, int uid, String packageName) {\n-    mStoredOps.put(getInternalKey(uid, packageName), op);\n+    storedOps.put(Key.create(uid, packageName, null), op);\n \n     // Permission check not currently implemented in this shadow.\n     return AppOpsManager.MODE_ALLOWED;\n@@ -211,7 +289,7 @@ protected int noteOp(int op, int uid, String packageName, String attributionTag,\n \n   @Implementation(minSdk = KITKAT)\n   protected int noteOpNoThrow(int op, int uid, String packageName) {\n-    mStoredOps.put(getInternalKey(uid, packageName), op);\n+    storedOps.put(Key.create(uid, packageName, null), op);\n     return checkOpNoThrow(op, uid, packageName);\n   }\n \n@@ -228,7 +306,7 @@ protected int noteOpNoThrow(\n   @Implementation(minSdk = M, maxSdk = Q)\n   @HiddenApi\n   protected int noteProxyOpNoThrow(int op, String proxiedPackageName) {\n-    mStoredOps.put(getInternalKey(Binder.getCallingUid(), proxiedPackageName), op);\n+    storedOps.put(Key.create(Binder.getCallingUid(), proxiedPackageName, null), op);\n     return checkOpNoThrow(op, Binder.getCallingUid(), proxiedPackageName);\n   }\n \n@@ -243,9 +321,9 @@ protected int noteProxyOpNoThrow(int op, String proxiedPackageName) {\n     }\n \n     List<OpEntry> opEntries = new ArrayList<>();\n-    for (Integer op : mStoredOps.get(getInternalKey(uid, packageName))) {\n+    for (Integer op : storedOps.get(Key.create(uid, packageName, null))) {\n       if (opFilter.isEmpty() || opFilter.contains(op)) {\n-        opEntries.add(toOpEntry(op));\n+        opEntries.add(toOpEntry(op, AppOpsManager.MODE_ALLOWED));\n       }\n     }\n \n@@ -313,7 +391,7 @@ public ModeAndException getRestriction(int code, @AttributeUsage int usage) {\n   @HiddenApi\n   @RequiresPermission(value = android.Manifest.permission.WATCH_APPOPS)\n   protected void startWatchingMode(int op, String packageName, OnOpChangedListener callback) {\n-    appOpListeners.put(getListenerKey(op, packageName), callback);\n+    appOpListeners.put(Key.create(null, packageName, op), callback);\n   }\n \n   @Implementation(minSdk = KITKAT)\n@@ -322,20 +400,20 @@ protected void stopWatchingMode(OnOpChangedListener callback) {\n     appOpListeners.inverse().remove(callback);\n   }\n \n-  protected OpEntry toOpEntry(Integer op) {\n+  protected OpEntry toOpEntry(Integer op, int mode) {\n     if (RuntimeEnvironment.getApiLevel() < Build.VERSION_CODES.M) {\n       return ReflectionHelpers.callConstructor(\n           OpEntry.class,\n           ClassParameter.from(int.class, op),\n-          ClassParameter.from(int.class, AppOpsManager.MODE_ALLOWED),\n+          ClassParameter.from(int.class, mode),\n           ClassParameter.from(long.class, OP_TIME),\n           ClassParameter.from(long.class, REJECT_TIME),\n           ClassParameter.from(int.class, DURATION));\n     } else if (RuntimeEnvironment.getApiLevel() < Build.VERSION_CODES.Q) {\n       return ReflectionHelpers.callConstructor(\n           OpEntry.class,\n           ClassParameter.from(int.class, op),\n-          ClassParameter.from(int.class, AppOpsManager.MODE_ALLOWED),\n+          ClassParameter.from(int.class, mode),\n           ClassParameter.from(long.class, OP_TIME),\n           ClassParameter.from(long.class, REJECT_TIME),\n           ClassParameter.from(int.class, DURATION),\n@@ -364,7 +442,7 @@ protected OpEntry toOpEntry(Integer op) {\n           OpEntry.class,\n           ClassParameter.from(int.class, op),\n           ClassParameter.from(boolean.class, false),\n-          ClassParameter.from(int.class, AppOpsManager.MODE_ALLOWED),\n+          ClassParameter.from(int.class, mode),\n           ClassParameter.from(LongSparseLongArray.class, accessTimes),\n           ClassParameter.from(LongSparseLongArray.class, rejectTimes),\n           ClassParameter.from(LongSparseLongArray.class, durations),\n@@ -384,26 +462,30 @@ protected OpEntry toOpEntry(Integer op) {\n \n       return new OpEntry(\n           op,\n-          AppOpsManager.MODE_ALLOWED,\n+          mode,\n           Collections.singletonMap(\n               null, new AttributedOpEntry(op, false, accessEvents, rejectEvents)));\n     }\n   }\n \n-  private static String getInternalKey(int uid, String packageName) {\n-    return uid + \"|\" + packageName;\n-  }\n-\n-  private static String getOpMapKey(int uid, String packageName, int opInt) {\n-    return String.format(\"%s|%s|%s\", uid, packageName, opInt);\n-  }\n-\n   private static int getAudioRestrictionKey(int code, @AttributeUsage int usage) {\n     return code | (usage << 8);\n   }\n \n-  private static String getListenerKey(int op, String packageName) {\n-    return String.format(\"%s|%s\", op, packageName);\n+  @AutoValue\n+  abstract static class Key {\n+    @Nullable\n+    abstract Integer getUid();\n+\n+    @Nullable\n+    abstract String getPackageName();\n+\n+    @Nullable\n+    abstract Integer getOpCode();\n+\n+    static Key create(Integer uid, String packageName, Integer opCode) {\n+      return new AutoValue_ShadowAppOpsManager_Key(uid, packageName, opCode);\n+    }\n   }\n \n   /** Class holding usage mode and excpetion packages. */"
  },
  {
    "sha": "5e500fc4b090071346b7c52a9f89b3bc8e326de1",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/robolectric/robolectric/blob/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java?ref=7f06b3afaa6b7d788be543ca2e86d9638a35c400",
    "patch": "@@ -40,6 +40,7 @@\n @SuppressWarnings({\"UnusedDeclaration\"})\n @Implements(value = AudioManager.class, looseSignatures = true)\n public class ShadowAudioManager {\n+\n   public static final int MAX_VOLUME_MUSIC_DTMF = 15;\n   public static final int DEFAULT_MAX_VOLUME = 7;\n   public static final int MIN_VOLUME = 0;\n@@ -166,6 +167,7 @@ protected int abandonAudioFocus(AudioManager.OnAudioFocusChangeListener l) {\n    */\n   @Implementation(minSdk = O)\n   protected int abandonAudioFocusRequest(android.media.AudioFocusRequest audioFocusRequest) {\n+    lastAbandonedAudioFocusListener = audioFocusRequest.getOnAudioFocusChangeListener();\n     lastAbandonedAudioFocusRequest = audioFocusRequest;\n     return nextResponseValue;\n   }\n@@ -637,7 +639,7 @@ private AudioFocusRequest(\n     }\n \n     private AudioFocusRequest(android.media.AudioFocusRequest audioFocusRequest) {\n-      this.listener = null;\n+      this.listener = audioFocusRequest.getOnAudioFocusChangeListener();\n       this.streamType = this.durationHint = -1;\n       this.audioFocusRequest = audioFocusRequest;\n     }"
  },
  {
    "sha": "b1632bf5e4f09340b488ef7c54c417439a8435d8",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/robolectric/robolectric/blob/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java?ref=7f06b3afaa6b7d788be543ca2e86d9638a35c400",
    "patch": "@@ -88,6 +88,7 @@ protected static Bitmap decodeFile(String pathName) {\n     return decodeFile(pathName, null);\n   }\n \n+  @SuppressWarnings(\"Var\")\n   @Implementation\n   protected static Bitmap decodeFile(String pathName, BitmapFactory.Options options) {\n     // If a real file is used, attempt to get the image size from that file.\n@@ -113,7 +114,7 @@ protected static Bitmap decodeFile(String pathName, BitmapFactory.Options option\n     return bitmap;\n   }\n \n-  @SuppressWarnings(\"ObjectToString\")\n+  @SuppressWarnings({\"ObjectToString\", \"Var\"})\n   @Implementation\n   protected static Bitmap decodeFileDescriptor(\n       FileDescriptor fd, Rect outPadding, BitmapFactory.Options opts) {"
  },
  {
    "sha": "6f0a9ec975b222bbd22b8669160e347116e40c8b",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowBugreportManager.java",
    "status": "modified",
    "additions": 20,
    "deletions": 0,
    "changes": 20,
    "blob_url": "https://github.com/robolectric/robolectric/blob/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBugreportManager.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBugreportManager.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBugreportManager.java?ref=7f06b3afaa6b7d788be543ca2e86d9638a35c400",
    "patch": "@@ -1,6 +1,7 @@\n package org.robolectric.shadows;\n \n import static android.os.Build.VERSION_CODES.Q;\n+import static android.os.Build.VERSION_CODES.R;\n \n import android.os.BugreportManager;\n import android.os.BugreportManager.BugreportCallback;\n@@ -25,6 +26,7 @@\n   private ParcelFileDescriptor screenshotFd;\n   private Executor executor;\n   private BugreportCallback callback;\n+  private boolean bugreportRequested;\n \n   /**\n    * Starts a bugreport with which can execute callback methods on the provided executor.\n@@ -50,6 +52,18 @@ protected void startBugreport(\n     }\n   }\n \n+  /**\n+   * Normally requests the platform/system to take a bugreport and make the final bugreport\n+   * available to the user.\n+   *\n+   * <p>This implementation just sets a boolean recording that the method was invoked.\n+   */\n+  @Implementation(minSdk = R)\n+  protected void requestBugreport(\n+      BugreportParams params, CharSequence shareTitle, CharSequence shareDescription) {\n+    this.bugreportRequested = true;\n+  }\n+\n   /** Cancels bugreport in progress and executes {@link BugreportCallback#onError}. */\n   @Implementation\n   protected void cancelBugreport() {\n@@ -87,6 +101,11 @@ public boolean isBugreportInProgress() {\n     return executor != null && callback != null;\n   }\n \n+  /** Returns true if {@link #requestBugreport} was called. */\n+  public boolean wasBugreportRequested() {\n+    return bugreportRequested;\n+  }\n+\n   /**\n    * Simulates if the calling process has the required permissions to call BugreportManager methods.\n    *\n@@ -116,5 +135,6 @@ private void resetParams() {\n     screenshotFd = null;\n     executor = null;\n     callback = null;\n+    bugreportRequested = false;\n   }\n }"
  },
  {
    "sha": "3c6c7a63e70f77805f1bb76ee38f1a2a360ea521",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java",
    "status": "modified",
    "additions": 36,
    "deletions": 0,
    "changes": 36,
    "blob_url": "https://github.com/robolectric/robolectric/blob/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java?ref=7f06b3afaa6b7d788be543ca2e86d9638a35c400",
    "patch": "@@ -8,6 +8,7 @@\n import static android.os.Build.VERSION_CODES.KITKAT;\n import static android.os.Build.VERSION_CODES.O;\n import static android.os.Build.VERSION_CODES.Q;\n+import static org.robolectric.shadow.api.Shadow.directlyOn;\n \n import android.accounts.Account;\n import android.annotation.NonNull;\n@@ -30,7 +31,9 @@\n import android.net.Uri;\n import android.os.Bundle;\n import android.os.CancellationSignal;\n+import android.os.ParcelFileDescriptor;\n import com.google.common.base.Splitter;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n@@ -40,6 +43,7 @@\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n import java.util.Objects;\n import java.util.concurrent.CopyOnWriteArrayList;\n@@ -71,6 +75,7 @@\n   private Map<Uri, BaseCursor> uriCursorMap = new HashMap<>();\n   private Map<Uri, Supplier<InputStream>> inputStreamMap = new HashMap<>();\n   private Map<Uri, Supplier<OutputStream>> outputStreamMap = new HashMap<>();\n+  private Map<Uri, Supplier<ParcelFileDescriptor>> fileDescriptorMap = new HashMap<>();\n   private final Map<String, List<ContentProviderOperation>> contentProviderOperations =\n       new HashMap<>();\n   private ContentProviderResult[] contentProviderResults;\n@@ -159,6 +164,13 @@ public void registerOutputStreamSupplier(Uri uri, Supplier<OutputStream> supplie\n     outputStreamMap.put(uri, supplier);\n   }\n \n+  /**\n+   * Registers a supplier of file descriptors that can be opened with {@link #openFileDescriptor}.\n+   */\n+  public void registerFileDescriptorSupplier(Uri uri, Supplier<ParcelFileDescriptor> supplier) {\n+    fileDescriptorMap.put(uri, supplier);\n+  }\n+\n   @Implementation\n   protected final InputStream openInputStream(final Uri uri) {\n     Supplier<InputStream> supplier = inputStreamMap.get(uri);\n@@ -191,6 +203,30 @@ public String toString() {\n     };\n   }\n \n+  /**\n+   * If a supplier is registered with {@link #registerFileDescriptorSupplier} for the URI passed in,\n+   * it will be called and the result returned. Otherwise, the framework implementation is invoked,\n+   * calling through to any {@link ContentProvider}s registered.\n+   */\n+  @Implementation(minSdk = 19)\n+  protected final ParcelFileDescriptor openFileDescriptor(\n+      final Uri uri, String mode, CancellationSignal cancellationSignal)\n+      throws FileNotFoundException {\n+    Supplier<ParcelFileDescriptor> supplier = fileDescriptorMap.get(uri);\n+    if (supplier != null) {\n+      ParcelFileDescriptor fd = supplier.get();\n+      if (fd == null) {\n+        throw new FileNotFoundException(\n+            String.format(Locale.US, \"Supplier for %s returned null file descriptor\", uri));\n+      }\n+\n+      return fd;\n+    }\n+\n+    return directlyOn(realContentResolver, ContentResolver.class)\n+        .openFileDescriptor(uri, mode, cancellationSignal);\n+  }\n+\n   /**\n    * If a {@link ContentProvider} is registered for the given {@link Uri}, its {@link\n    * ContentProvider#insert(Uri, ContentValues)} method will be invoked."
  },
  {
    "sha": "3f821b7d647f4d0154ae03d29a6d906d2f0aa98d",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java",
    "status": "modified",
    "additions": 19,
    "deletions": 10,
    "changes": 29,
    "blob_url": "https://github.com/robolectric/robolectric/blob/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java?ref=7f06b3afaa6b7d788be543ca2e86d9638a35c400",
    "patch": "@@ -16,8 +16,7 @@\n @Implements(ContextWrapper.class)\n public class ShadowContextWrapper {\n \n-  @RealObject\n-  private ContextWrapper realContextWrapper;\n+  @RealObject private ContextWrapper realContextWrapper;\n \n   /** Returns the broadcast intents sent during the tests (for all users). */\n   public List<Intent> getBroadcastIntents() {\n@@ -98,8 +97,8 @@ public Intent getNextStartedService() {\n   }\n \n   /**\n-   * Returns the most recent {@code Intent} started by\n-   * {@link android.content.Context#startService(android.content.Intent)} without consuming it.\n+   * Returns the most recent {@code Intent} started by {@link\n+   * android.content.Context#startService(android.content.Intent)} without consuming it.\n    *\n    * @return the most recently started {@code Intent}\n    */\n@@ -108,17 +107,27 @@ public Intent peekNextStartedService() {\n   }\n \n   /**\n-   * Clears all {@code Intent} started by\n-   * {@link android.content.Context#startService(android.content.Intent)}.\n+   * Returns all {@code Intent} started by {@link #startService(android.content.Intent)} without\n+   * consuming them.\n+   *\n+   * @return the list of {@code Intent}\n+   */\n+  public List<Intent> getAllStartedServices() {\n+    return getShadowInstrumentation().getAllStartedServices();\n+  }\n+\n+  /**\n+   * Clears all {@code Intent} started by {@link\n+   * android.content.Context#startService(android.content.Intent)}.\n    */\n   public void clearStartedServices() {\n     getShadowInstrumentation().clearStartedServices();\n   }\n \n   /**\n-   * Consumes the {@code Intent} requested to stop a service by\n-   * {@link android.content.Context#stopService(android.content.Intent)}\n-   * from the bottom of the stack of stop requests.\n+   * Consumes the {@code Intent} requested to stop a service by {@link\n+   * android.content.Context#stopService(android.content.Intent)} from the bottom of the stack of\n+   * stop requests.\n    */\n   public Intent getNextStoppedService() {\n     return getShadowInstrumentation().getNextStoppedService();\n@@ -137,7 +146,7 @@ public void grantPermissions(int pid, int uid, String... permissions) {\n   /**\n    * Revoke the given permissions for the current process and user.\n    *\n-   * Has no effect if permissions were not previously granted.\n+   * <p>Has no effect if permissions were not previously granted.\n    */\n   public void denyPermissions(String... permissionNames) {\n     getShadowInstrumentation().denyPermissions(permissionNames);"
  },
  {
    "sha": "76ed5068c88488a3074ecee159a9da3332484519",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/robolectric/robolectric/blob/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java?ref=7f06b3afaa6b7d788be543ca2e86d9638a35c400",
    "patch": "@@ -15,6 +15,7 @@\n import android.util.SparseArray;\n import android.view.Display;\n import android.view.DisplayInfo;\n+import com.google.common.annotations.VisibleForTesting;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.TreeMap;\n@@ -65,6 +66,11 @@ public static synchronized DisplayManagerGlobal getInstance() {\n     return instance;\n   }\n \n+  @VisibleForTesting\n+  static DisplayManagerGlobal getGlobalInstance() {\n+    return instance;\n+  }\n+\n   @Implementation\n   protected WifiDisplayStatus getWifiDisplayStatus() {\n     return new WifiDisplayStatus();"
  },
  {
    "sha": "68532aa71f9bd75a7a2145be4f0a7bfbdf24a5f0",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java",
    "status": "modified",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/robolectric/robolectric/blob/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/7f06b3afaa6b7d788be543ca2e86d9638a35c400/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java?ref=7f06b3afaa6b7d788be543ca2e86d9638a35c400",
    "patch": "@@ -793,6 +793,20 @@ void clearStartedServices() {\n     startedServices.clear();\n   }\n \n+  /**\n+   * Returns all {@code Intent} started by {@link #startService(android.content.Intent)} without\n+   * consuming them.\n+   *\n+   * @return the list of {@code Intent}\n+   */\n+  List<Intent> getAllStartedServices() {\n+    ArrayList<Intent> startedServicesIntents = new ArrayList<>();\n+    for (Intent.FilterComparison filterComparison : startedServices) {\n+      startedServicesIntents.add(filterComparison.getIntent());\n+    }\n+    return startedServicesIntents;\n+  }\n+\n   /**\n    * Consumes the {@code Intent} requested to stop a service by {@link\n    * #stopService(android.content.Intent)} from the bottom of the stack of stop requests."
  }
]
