[
  {
    "sha": "8f8d5211f882c01567045b306efa9764b5212e70",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/FrameMetricsBuilderTest.java",
    "status": "modified",
    "additions": 21,
    "deletions": 0,
    "changes": 21,
    "blob_url": "https://github.com/robolectric/robolectric/blob/3ee953f161503edf457c2a6e29c9906009694604/robolectric/src/test/java/org/robolectric/shadows/FrameMetricsBuilderTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/3ee953f161503edf457c2a6e29c9906009694604/robolectric/src/test/java/org/robolectric/shadows/FrameMetricsBuilderTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/FrameMetricsBuilderTest.java?ref=3ee953f161503edf457c2a6e29c9906009694604",
    "patch": "@@ -69,4 +69,25 @@ public void allTimeMetrics() throws Exception {\n     // syncDelayTimeNanos is 3.\n     assertThat(metrics.getMetric(FrameMetrics.TOTAL_DURATION)).isEqualTo(1L + 2L * 7 + 3L);\n   }\n+\n+  @Test\n+  public void totalDurationExcludesNonDurationValues() throws Exception {\n+    long unknownDelay = 1L;\n+    long animation = 20L;\n+    long inputHandling = 300L;\n+    long largeValue = 40000L;\n+    assertThat(\n+        new org.robolectric.shadows.FrameMetricsBuilder()\n+            .setMetric(FrameMetrics.UNKNOWN_DELAY_DURATION, unknownDelay)\n+            .setMetric(FrameMetrics.ANIMATION_DURATION, animation)\n+            .setMetric(FrameMetrics.INPUT_HANDLING_DURATION, inputHandling)\n+\n+            // metrics that should not impact TOTAL_DURATION\n+            .setMetric(FrameMetrics.FIRST_DRAW_FRAME, 1)\n+            .setMetric(FrameMetrics.INTENDED_VSYNC_TIMESTAMP, largeValue)\n+            .setMetric(FrameMetrics.VSYNC_TIMESTAMP,  largeValue)\n+            .build()\n+            .getMetric(FrameMetrics.TOTAL_DURATION))\n+        .isEqualTo(unknownDelay + animation + inputHandling);\n+  }\n }"
  },
  {
    "sha": "0c0f82a49cabf0309c2e9680fc6cf0f544abae98",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java",
    "status": "modified",
    "additions": 169,
    "deletions": 0,
    "changes": 169,
    "blob_url": "https://github.com/robolectric/robolectric/blob/3ee953f161503edf457c2a6e29c9906009694604/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/3ee953f161503edf457c2a6e29c9906009694604/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java?ref=3ee953f161503edf457c2a6e29c9906009694604",
    "patch": "@@ -3,6 +3,10 @@\n import static android.app.AppOpsManager.MODE_ALLOWED;\n import static android.app.AppOpsManager.MODE_DEFAULT;\n import static android.app.AppOpsManager.MODE_ERRORED;\n+import static android.app.AppOpsManager.MODE_FOREGROUND;\n+import static android.app.AppOpsManager.MODE_IGNORED;\n+import static android.app.AppOpsManager.OPSTR_BODY_SENSORS;\n+import static android.app.AppOpsManager.OPSTR_COARSE_LOCATION;\n import static android.app.AppOpsManager.OPSTR_FINE_LOCATION;\n import static android.app.AppOpsManager.OPSTR_GPS;\n import static android.app.AppOpsManager.OPSTR_READ_PHONE_STATE;\n@@ -12,6 +16,7 @@\n import static android.app.AppOpsManager.OP_SEND_SMS;\n import static android.app.AppOpsManager.OP_VIBRATE;\n import static android.os.Build.VERSION_CODES.KITKAT;\n+import static android.os.Build.VERSION_CODES.Q;\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n import static org.mockito.Mockito.mock;\n@@ -393,6 +398,140 @@ public void checkPackage_belongs() {\n     // check passes without exception\n   }\n \n+  @Config(minSdk = KITKAT)\n+  @Test\n+  public void getPackageForOps_setOne_getOne() {\n+    String packageName = \"com.android.package\";\n+    int uid = 111;\n+    appOps.setMode(0, uid, packageName, MODE_ALLOWED);\n+\n+    int[] intNull = null;\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(intNull);\n+    assertThat(containsPackageOpPair(packageOps, packageName, 0, MODE_ALLOWED)).isTrue();\n+  }\n+\n+  @Config(minSdk = KITKAT)\n+  @Test\n+  public void getPackageForOps_setMultiple_getMultiple() {\n+    String packageName1 = \"com.android.package\";\n+    String packageName2 = \"com.android.other\";\n+    int uid1 = 111;\n+    int uid2 = 112;\n+    appOps.setMode(0, uid1, packageName1, MODE_ALLOWED);\n+    appOps.setMode(1, uid1, packageName1, MODE_DEFAULT);\n+    appOps.setMode(2, uid1, packageName1, MODE_ERRORED);\n+    appOps.setMode(3, uid1, packageName1, MODE_FOREGROUND);\n+    appOps.setMode(4, uid1, packageName1, MODE_IGNORED);\n+    appOps.setMode(0, uid2, packageName2, MODE_ALLOWED);\n+\n+    int[] intNull = null;\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(intNull);\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 0, MODE_ALLOWED)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 1, MODE_DEFAULT)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 2, MODE_ERRORED)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 3, MODE_FOREGROUND)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 4, MODE_IGNORED)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName2, 0, MODE_ALLOWED)).isTrue();\n+  }\n+\n+  @Config(minSdk = KITKAT)\n+  @Test\n+  public void getPackageForOps_setMultiple_onlyGetThoseAskedFor() {\n+    String packageName1 = \"com.android.package\";\n+    String packageName2 = \"com.android.other\";\n+    int uid1 = 111;\n+    int uid2 = 112;\n+    appOps.setMode(0, uid1, packageName1, MODE_ALLOWED);\n+    appOps.setMode(1, uid1, packageName1, MODE_DEFAULT);\n+    appOps.setMode(2, uid1, packageName1, MODE_ERRORED);\n+    appOps.setMode(3, uid1, packageName1, MODE_FOREGROUND);\n+    appOps.setMode(4, uid1, packageName1, MODE_IGNORED);\n+    appOps.setMode(0, uid2, packageName2, MODE_ALLOWED);\n+\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(new int[] {0, 1});\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 0, MODE_ALLOWED)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 1, MODE_DEFAULT)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 2, MODE_ERRORED)).isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 3, MODE_FOREGROUND)).isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 4, MODE_IGNORED)).isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName2, 0, MODE_ALLOWED)).isTrue();\n+  }\n+\n+  @Config(minSdk = Q)\n+  @Test\n+  public void getPackageForOpsStr_setOne_getOne() {\n+    String packageName = \"com.android.package\";\n+    int uid = 111;\n+    appOps.setMode(AppOpsManager.OPSTR_COARSE_LOCATION, uid, packageName, MODE_ALLOWED);\n+\n+    String[] stringNull = null;\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(stringNull);\n+    assertThat(containsPackageOpPair(packageOps, packageName, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+  }\n+\n+  @Config(minSdk = Q)\n+  @Test\n+  public void getPackageForOpsStr_setMultiple_getMultiple() {\n+    String packageName1 = \"com.android.package\";\n+    String packageName2 = \"com.android.other\";\n+    int uid1 = 111;\n+    int uid2 = 112;\n+    appOps.setMode(OPSTR_COARSE_LOCATION, uid1, packageName1, MODE_ALLOWED);\n+    appOps.setMode(OPSTR_FINE_LOCATION, uid1, packageName1, MODE_DEFAULT);\n+    appOps.setMode(OPSTR_READ_PHONE_STATE, uid1, packageName1, MODE_ERRORED);\n+    appOps.setMode(OPSTR_RECORD_AUDIO, uid1, packageName1, MODE_FOREGROUND);\n+    appOps.setMode(OPSTR_BODY_SENSORS, uid1, packageName1, MODE_IGNORED);\n+    appOps.setMode(OPSTR_COARSE_LOCATION, uid2, packageName2, MODE_ALLOWED);\n+\n+    String[] stringNull = null;\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(stringNull);\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_FINE_LOCATION, MODE_DEFAULT))\n+        .isTrue();\n+    assertThat(\n+            containsPackageOpPair(packageOps, packageName1, OPSTR_READ_PHONE_STATE, MODE_ERRORED))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_RECORD_AUDIO, MODE_FOREGROUND))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_BODY_SENSORS, MODE_IGNORED))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName2, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+  }\n+\n+  @Config(minSdk = Q)\n+  @Test\n+  public void getPackageForOpsStr_setMultiple_onlyGetThoseAskedFor() {\n+    String packageName1 = \"com.android.package\";\n+    String packageName2 = \"com.android.other\";\n+    int uid1 = 111;\n+    int uid2 = 112;\n+    appOps.setMode(OPSTR_COARSE_LOCATION, uid1, packageName1, MODE_ALLOWED);\n+    appOps.setMode(OPSTR_FINE_LOCATION, uid1, packageName1, MODE_DEFAULT);\n+    appOps.setMode(OPSTR_READ_PHONE_STATE, uid1, packageName1, MODE_ERRORED);\n+    appOps.setMode(OPSTR_RECORD_AUDIO, uid1, packageName1, MODE_FOREGROUND);\n+    appOps.setMode(OPSTR_BODY_SENSORS, uid1, packageName1, MODE_IGNORED);\n+    appOps.setMode(OPSTR_COARSE_LOCATION, uid2, packageName2, MODE_ALLOWED);\n+\n+    List<PackageOps> packageOps =\n+        appOps.getPackagesForOps(new String[] {OPSTR_COARSE_LOCATION, OPSTR_FINE_LOCATION});\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_FINE_LOCATION, MODE_DEFAULT))\n+        .isTrue();\n+    assertThat(\n+            containsPackageOpPair(packageOps, packageName1, OPSTR_READ_PHONE_STATE, MODE_ERRORED))\n+        .isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_RECORD_AUDIO, MODE_FOREGROUND))\n+        .isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_BODY_SENSORS, MODE_IGNORED))\n+        .isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName2, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+  }\n+\n   /** Assert that the results contain the expected op codes. */\n   private void assertOps(List<PackageOps> pkgOps, Integer... expectedOps) {\n     Set<Integer> actualOps = new HashSet<>();\n@@ -404,4 +543,34 @@ private void assertOps(List<PackageOps> pkgOps, Integer... expectedOps) {\n \n     assertThat(actualOps).containsAtLeastElementsIn(expectedOps);\n   }\n+\n+  /** True if the given (package, op, mode) tuple is present in the given list. */\n+  private boolean containsPackageOpPair(\n+      List<PackageOps> pkgOps, String packageName, int op, int mode) {\n+    for (PackageOps pkgOp : pkgOps) {\n+      for (OpEntry entry : pkgOp.getOps()) {\n+        if (packageName.equals(pkgOp.getPackageName())\n+            && entry.getOp() == op\n+            && entry.getMode() == mode) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /** True if the given (package, op, mode) tuple is present in the given list. */\n+  private boolean containsPackageOpPair(\n+      List<PackageOps> pkgOps, String packageName, String op, int mode) {\n+    for (PackageOps pkgOp : pkgOps) {\n+      for (OpEntry entry : pkgOp.getOps()) {\n+        if (packageName.equals(pkgOp.getPackageName())\n+            && op.equals(entry.getOpStr())\n+            && entry.getMode() == mode) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n }"
  },
  {
    "sha": "7880e19ffd8b766070a754c52033b8fa1b9eca4b",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java",
    "status": "modified",
    "additions": 18,
    "deletions": 1,
    "changes": 19,
    "blob_url": "https://github.com/robolectric/robolectric/blob/3ee953f161503edf457c2a6e29c9906009694604/robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/3ee953f161503edf457c2a6e29c9906009694604/robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java?ref=3ee953f161503edf457c2a6e29c9906009694604",
    "patch": "@@ -10,6 +10,7 @@\n import static com.google.common.truth.TruthJUnit.assume;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertSame;\n import static org.junit.Assert.assertTrue;\n@@ -664,6 +665,23 @@ public void shouldClearStartedServiceIntents() {\n     assertNull(shadowOf(context).getNextStartedService());\n   }\n \n+  @Test\n+  public void getAllStartedServices() {\n+    Intent intent1 = getSomeActionIntent(\"some.action\");\n+    Intent intent2 = getSomeActionIntent(\"another.action\");\n+\n+    context.startService(intent1);\n+    context.startService(intent2);\n+    List<Intent> startedServiceIntents = shadowOf(context).getAllStartedServices();\n+\n+    assertThat(startedServiceIntents).hasSize(2);\n+    assertThat(startedServiceIntents.get(0).filterEquals(intent1)).isTrue();\n+    assertThat(startedServiceIntents.get(1).filterEquals(intent2)).isTrue();\n+    assertNotNull(shadowOf(context).getNextStartedService());\n+    assertNotNull(shadowOf(context).getNextStartedService());\n+    assertNull(shadowOf(context).getNextStartedService());\n+  }\n+\n   @Test\n   public void shouldThrowIfContainsRegisteredReceiverOfAction() {\n     Activity activity = Robolectric.setupActivity(Activity.class);\n@@ -899,4 +917,3 @@ public void onReceive(Context context, Intent intent) {\n     }\n   }\n }\n-"
  },
  {
    "sha": "253e64b46d1f810191ccf5a23840a3b82cd076a6",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java",
    "status": "modified",
    "additions": 12,
    "deletions": 6,
    "changes": 18,
    "blob_url": "https://github.com/robolectric/robolectric/blob/3ee953f161503edf457c2a6e29c9906009694604/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/3ee953f161503edf457c2a6e29c9906009694604/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java?ref=3ee953f161503edf457c2a6e29c9906009694604",
    "patch": "@@ -77,11 +77,13 @@ public void requestAudioFocus2_shouldRecordArgumentsOfMostRecentCall() {\n     AudioAttributes atts = new AudioAttributes.Builder().build();\n     android.media.AudioFocusRequest request =\n         new android.media.AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)\n+            .setOnAudioFocusChangeListener(listener)\n             .setAudioAttributes(atts)\n             .build();\n \n     audioManager.requestAudioFocus(request);\n-    assertThat(shadowOf(audioManager).getLastAudioFocusRequest().listener).isNull();\n+    assertThat(shadowOf(audioManager).getLastAudioFocusRequest().listener)\n+        .isSameInstanceAs(listener);\n     assertThat(shadowOf(audioManager).getLastAudioFocusRequest().streamType).isEqualTo(-1);\n     assertThat(shadowOf(audioManager).getLastAudioFocusRequest().durationHint).isEqualTo(-1);\n     assertThat(shadowOf(audioManager).getLastAudioFocusRequest().audioFocusRequest)\n@@ -118,10 +120,14 @@ public void abandonAudioFocus_shouldRecordTheListenerOfTheMostRecentCall() {\n   @Config(minSdk = O)\n   public void abandonAudioFocusRequest_shouldRecordTheListenerOfTheMostRecentCall() {\n     android.media.AudioFocusRequest request =\n-        new android.media.AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN).build();\n+        new android.media.AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)\n+            .setOnAudioFocusChangeListener(listener)\n+            .build();\n     audioManager.abandonAudioFocusRequest(request);\n     assertThat(shadowOf(audioManager).getLastAbandonedAudioFocusRequest())\n         .isSameInstanceAs(request);\n+    assertThat(shadowOf(audioManager).getLastAbandonedAudioFocusListener())\n+        .isSameInstanceAs(listener);\n   }\n \n   @Test\n@@ -491,7 +497,7 @@ public void adjustStreamVolume_lower() {\n     int volumeBefore = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n \n     audioManager.adjustStreamVolume(\n-            AudioManager.STREAM_MUSIC, AudioManager.ADJUST_LOWER, /* flags= */ 0);\n+        AudioManager.STREAM_MUSIC, AudioManager.ADJUST_LOWER, /* flags= */ 0);\n \n     int volumeAfter = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n     assertThat(volumeAfter).isLessThan(volumeBefore);\n@@ -504,7 +510,7 @@ public void adjustStreamVolume_lowerAtMinVolume_remainsSame() {\n     int volumeBefore = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n \n     audioManager.adjustStreamVolume(\n-            AudioManager.STREAM_MUSIC, AudioManager.ADJUST_LOWER, /* flags= */ 0);\n+        AudioManager.STREAM_MUSIC, AudioManager.ADJUST_LOWER, /* flags= */ 0);\n \n     int volumeAfter = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n     assertThat(volumeAfter).isEqualTo(volumeBefore);\n@@ -517,7 +523,7 @@ public void adjustStreamVolume_raise() {\n     int volumeBefore = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n \n     audioManager.adjustStreamVolume(\n-            AudioManager.STREAM_MUSIC, AudioManager.ADJUST_RAISE, /* flags= */ 0);\n+        AudioManager.STREAM_MUSIC, AudioManager.ADJUST_RAISE, /* flags= */ 0);\n \n     int volumeAfter = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n     assertThat(volumeAfter).isGreaterThan(volumeBefore);\n@@ -531,7 +537,7 @@ public void adjustStreamVolume_raiseAtMaxVolume_remainsSame() {\n     int volumeBefore = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n \n     audioManager.adjustStreamVolume(\n-            AudioManager.STREAM_MUSIC, AudioManager.ADJUST_RAISE, /* flags= */ 0);\n+        AudioManager.STREAM_MUSIC, AudioManager.ADJUST_RAISE, /* flags= */ 0);\n \n     int volumeAfter = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n     assertThat(volumeAfter).isEqualTo(volumeBefore);"
  },
  {
    "sha": "57b0399fef34e478709dd7d9e1bc97c518a68a63",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java",
    "status": "added",
    "additions": 27,
    "deletions": 0,
    "changes": 27,
    "blob_url": "https://github.com/robolectric/robolectric/blob/3ee953f161503edf457c2a6e29c9906009694604/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/3ee953f161503edf457c2a6e29c9906009694604/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java?ref=3ee953f161503edf457c2a6e29c9906009694604",
    "patch": "@@ -0,0 +1,27 @@\n+package org.robolectric.shadows;\n+\n+import static android.os.Build.VERSION_CODES.JELLY_BEAN_MR1;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import android.hardware.display.DisplayManagerGlobal;\n+import android.view.Display;\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.annotation.Config;\n+import org.robolectric.annotation.LazyLoadApplication;\n+import org.robolectric.annotation.LazyLoadApplication.LazyLoad;\n+\n+/** Unit tests for {@link ShadowDisplayManagerGlobal} */\n+@RunWith(AndroidJUnit4.class)\n+public class ShadowDisplayManagerGlobalTest {\n+\n+  @LazyLoadApplication(LazyLoad.ON)\n+  @Test\n+  @Config(minSdk = JELLY_BEAN_MR1)\n+  public void testDisplayManagerGlobalIsLazyLoaded() {\n+    assertThat(ShadowDisplayManagerGlobal.getGlobalInstance()).isNull();\n+    assertThat(DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY))\n+        .isNotNull();\n+  }\n+}"
  },
  {
    "sha": "106732a9d5d14651f052721218f1571d89378cec",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/FrameMetricsBuilder.java",
    "status": "modified",
    "additions": 2,
    "deletions": 5,
    "changes": 7,
    "blob_url": "https://github.com/robolectric/robolectric/blob/3ee953f161503edf457c2a6e29c9906009694604/shadows/framework/src/main/java/org/robolectric/shadows/FrameMetricsBuilder.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/3ee953f161503edf457c2a6e29c9906009694604/shadows/framework/src/main/java/org/robolectric/shadows/FrameMetricsBuilder.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/FrameMetricsBuilder.java?ref=3ee953f161503edf457c2a6e29c9906009694604",
    "patch": "@@ -4,8 +4,6 @@\n \n import android.view.FrameMetrics;\n import android.view.FrameMetrics.Metric;\n-import com.google.common.primitives.Longs;\n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n import org.robolectric.util.ReflectionHelpers;\n@@ -87,10 +85,9 @@ public FrameMetrics build() throws Exception {\n           timingData[getStartIndexForMetric(metric)] + getMetric(metric);\n     }\n \n-    // Even as FrameMetrics are added, the end point of TOTAL_DURATION should always equal the\n-    // maximum of this list.\n+    // SWAP_BUFFERS_DURATION is the current endpoint in the chain of supported FrameMetrics.\n     timingData[getEndIndexForMetric(FrameMetrics.TOTAL_DURATION)] =\n-        Collections.max(Longs.asList(timingData));\n+        timingData[getEndIndexForMetric(FrameMetrics.SWAP_BUFFERS_DURATION)];\n     return metrics;\n   }\n "
  },
  {
    "sha": "31de614d58ac917f5f5e2e2e7f30e0e8b0ed3b2c",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java",
    "status": "modified",
    "additions": 118,
    "deletions": 36,
    "changes": 154,
    "blob_url": "https://github.com/robolectric/robolectric/blob/3ee953f161503edf457c2a6e29c9906009694604/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/3ee953f161503edf457c2a6e29c9906009694604/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java?ref=3ee953f161503edf457c2a6e29c9906009694604",
    "patch": "@@ -6,8 +6,10 @@\n import static android.os.Build.VERSION_CODES.P;\n import static android.os.Build.VERSION_CODES.Q;\n import static android.os.Build.VERSION_CODES.R;\n+import static java.util.stream.Collectors.toSet;\n import static org.robolectric.shadow.api.Shadow.invokeConstructor;\n \n+import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.annotation.RequiresPermission;\n import android.annotation.SystemApi;\n@@ -26,20 +28,24 @@\n import android.util.LongSparseArray;\n import android.util.LongSparseLongArray;\n import com.android.internal.app.IAppOpsService;\n+import com.google.auto.value.AutoValue;\n import com.google.common.collect.BiMap;\n import com.google.common.collect.HashBiMap;\n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Multimap;\n+import com.google.common.collect.MultimapBuilder;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.stream.IntStream;\n import org.robolectric.RuntimeEnvironment;\n import org.robolectric.annotation.HiddenApi;\n import org.robolectric.annotation.Implementation;\n@@ -62,19 +68,19 @@\n \n   @RealObject private AppOpsManager realObject;\n \n-  // Recorded operations, keyed by \"uid|packageName\"\n-  private Multimap<String, Integer> mStoredOps = HashMultimap.create();\n-  // \"uid|packageName|opCode\" => opMode\n-  private Map<String, Integer> appModeMap = new HashMap<>();\n+  // Recorded operations, keyed by (uid, packageName)\n+  private final Multimap<Key, Integer> storedOps = HashMultimap.create();\n+  // (uid, packageName, opCode) => opMode\n+  private final Map<Key, Integer> appModeMap = new HashMap<>();\n \n-  // \"uid|packageName|opCode\" => opMode\n-  private Set<String> longRunningOp = new HashSet<>();\n+  // (uid, packageName, opCode)\n+  private final Set<Key> longRunningOp = new HashSet<>();\n \n-  // \"packageName|opCode\" => listener\n-  private BiMap<String, OnOpChangedListener> appOpListeners = HashBiMap.create();\n+  // (packageName, opCode) => listener\n+  private final BiMap<Key, OnOpChangedListener> appOpListeners = HashBiMap.create();\n \n   // op | (usage << 8) => ModeAndExcpetion\n-  private Map<Integer, ModeAndException> audioRestrictions = new HashMap<>();\n+  private final Map<Integer, ModeAndException> audioRestrictions = new HashMap<>();\n \n   private Context context;\n \n@@ -120,21 +126,93 @@ public void setMode(String op, int uid, String packageName, int mode) {\n   @HiddenApi\n   @RequiresPermission(android.Manifest.permission.MANAGE_APP_OPS_MODES)\n   public void setMode(int op, int uid, String packageName, int mode) {\n-    Integer oldMode = appModeMap.put(getOpMapKey(uid, packageName, op), mode);\n-    OnOpChangedListener listener = appOpListeners.get(getListenerKey(op, packageName));\n+    Integer oldMode = appModeMap.put(Key.create(uid, packageName, op), mode);\n+    OnOpChangedListener listener = appOpListeners.get(Key.create(null, packageName, op));\n     if (listener != null && !Objects.equals(oldMode, mode)) {\n       String[] sOpToString = ReflectionHelpers.getStaticField(AppOpsManager.class, \"sOpToString\");\n       listener.onOpChanged(sOpToString[op], packageName);\n     }\n   }\n \n+  /**\n+   * Returns app op details for all packages for which one of {@link #setMode} methods was used to\n+   * set the value of one of the given app ops (it does return those set to 'default' mode, while\n+   * the true implementation usually doesn't). Also, we don't enforce any permission checks which\n+   * might be needed in the true implementation.\n+   *\n+   * @param ops The set of operations you are interested in, or null if you want all of them.\n+   * @return app ops information about each package, containing only ops that were specified as an\n+   *     argument\n+   */\n+  @Implementation(minSdk = Q)\n+  @HiddenApi\n+  @SystemApi\n+  @NonNull\n+  protected List<AppOpsManager.PackageOps> getPackagesForOps(@Nullable String[] ops) {\n+    if (ops == null) {\n+      int[] intOps = null;\n+      return getPackagesForOps(intOps);\n+    }\n+\n+    List<Integer> intOpsList = new ArrayList<>();\n+    for (String op : ops) {\n+      intOpsList.add(AppOpsManager.strOpToOp(op));\n+    }\n+\n+    return getPackagesForOps(intOpsList.stream().mapToInt(i -> i).toArray());\n+  }\n+\n+  /**\n+   * Returns app op details for all packages for which one of {@link #setMode} methods was used to\n+   * set the value of one of the given app ops (it does return those set to 'default' mode, while\n+   * the true implementation usually doesn't). Also, we don't enforce any permission checks which\n+   * might be needed in the true implementation.\n+   *\n+   * @param ops The set of operations you are interested in, or null if you want all of them.\n+   * @return app ops information about each package, containing only ops that were specified as an\n+   *     argument\n+   */\n+  @Implementation(minSdk = KITKAT) // to be consistent with setMode() shadow implementations\n+  @HiddenApi\n+  protected List<PackageOps> getPackagesForOps(int[] ops) {\n+    Set<Integer> relevantOps;\n+    if (ops != null) {\n+      relevantOps = IntStream.of(ops).boxed().collect(toSet());\n+    } else {\n+      relevantOps = new HashSet<>();\n+    }\n+\n+    // Aggregating op data per each package.\n+    // (uid, packageName) => [(op, mode)]\n+    Multimap<Key, OpEntry> perPackageMap = MultimapBuilder.hashKeys().hashSetValues().build();\n+    for (Map.Entry<Key, Integer> appOpInfo : appModeMap.entrySet()) {\n+      Key key = appOpInfo.getKey();\n+      if (ops == null || relevantOps.contains(key.getOpCode())) {\n+        Key packageKey = Key.create(key.getUid(), key.getPackageName(), null);\n+        OpEntry opEntry = toOpEntry(key.getOpCode(), appOpInfo.getValue());\n+        perPackageMap.put(packageKey, opEntry);\n+      }\n+    }\n+\n+    List<PackageOps> result = new ArrayList<>();\n+    // Creating resulting PackageOps objects using all op info collected per package.\n+    for (Map.Entry<Key, Collection<OpEntry>> packageInfo : perPackageMap.asMap().entrySet()) {\n+      Key key = packageInfo.getKey();\n+      result.add(\n+          new PackageOps(\n+              key.getPackageName(), key.getUid(), new ArrayList<>(packageInfo.getValue())));\n+    }\n+\n+    return result;\n+  }\n+\n   @Implementation(minSdk = Q)\n   public int unsafeCheckOpNoThrow(String op, int uid, String packageName) {\n     return checkOpNoThrow(AppOpsManager.strOpToOp(op), uid, packageName);\n   }\n \n   private int unsafeCheckOpRawNoThrow(int op, int uid, String packageName) {\n-    Integer mode = appModeMap.get(getOpMapKey(uid, packageName, op));\n+    Integer mode = appModeMap.get(Key.create(uid, packageName, op));\n     if (mode == null) {\n       return AppOpsManager.MODE_ALLOWED;\n     }\n@@ -147,15 +225,15 @@ protected int startOp(\n       String op, int uid, String packageName, String attributionTag, String message) {\n     int mode = unsafeCheckOpRawNoThrow(op, uid, packageName);\n     if (mode == AppOpsManager.MODE_ALLOWED) {\n-      longRunningOp.add(getOpMapKey(uid, packageName, AppOpsManager.strOpToOp(op)));\n+      longRunningOp.add(Key.create(uid, packageName, AppOpsManager.strOpToOp(op)));\n     }\n     return mode;\n   }\n \n   /** Removes a fake long-running operation from the set. */\n   @Implementation(minSdk = R)\n   protected void finishOp(String op, int uid, String packageName, String attributionTag) {\n-    longRunningOp.remove(getOpMapKey(uid, packageName, AppOpsManager.strOpToOp(op)));\n+    longRunningOp.remove(Key.create(uid, packageName, AppOpsManager.strOpToOp(op)));\n   }\n \n   /**\n@@ -164,7 +242,7 @@ protected void finishOp(String op, int uid, String packageName, String attributi\n    */\n   @Implementation(minSdk = R)\n   protected boolean isOpActive(String op, int uid, String packageName) {\n-    return longRunningOp.contains(getOpMapKey(uid, packageName, AppOpsManager.strOpToOp(op)));\n+    return longRunningOp.contains(Key.create(uid, packageName, AppOpsManager.strOpToOp(op)));\n   }\n \n   /**\n@@ -198,7 +276,7 @@ public int checkOpNoThrow(int op, int uid, String packageName) {\n \n   @Implementation(minSdk = KITKAT)\n   public int noteOp(int op, int uid, String packageName) {\n-    mStoredOps.put(getInternalKey(uid, packageName), op);\n+    storedOps.put(Key.create(uid, packageName, null), op);\n \n     // Permission check not currently implemented in this shadow.\n     return AppOpsManager.MODE_ALLOWED;\n@@ -211,7 +289,7 @@ protected int noteOp(int op, int uid, String packageName, String attributionTag,\n \n   @Implementation(minSdk = KITKAT)\n   protected int noteOpNoThrow(int op, int uid, String packageName) {\n-    mStoredOps.put(getInternalKey(uid, packageName), op);\n+    storedOps.put(Key.create(uid, packageName, null), op);\n     return checkOpNoThrow(op, uid, packageName);\n   }\n \n@@ -228,7 +306,7 @@ protected int noteOpNoThrow(\n   @Implementation(minSdk = M, maxSdk = Q)\n   @HiddenApi\n   protected int noteProxyOpNoThrow(int op, String proxiedPackageName) {\n-    mStoredOps.put(getInternalKey(Binder.getCallingUid(), proxiedPackageName), op);\n+    storedOps.put(Key.create(Binder.getCallingUid(), proxiedPackageName, null), op);\n     return checkOpNoThrow(op, Binder.getCallingUid(), proxiedPackageName);\n   }\n \n@@ -243,9 +321,9 @@ protected int noteProxyOpNoThrow(int op, String proxiedPackageName) {\n     }\n \n     List<OpEntry> opEntries = new ArrayList<>();\n-    for (Integer op : mStoredOps.get(getInternalKey(uid, packageName))) {\n+    for (Integer op : storedOps.get(Key.create(uid, packageName, null))) {\n       if (opFilter.isEmpty() || opFilter.contains(op)) {\n-        opEntries.add(toOpEntry(op));\n+        opEntries.add(toOpEntry(op, AppOpsManager.MODE_ALLOWED));\n       }\n     }\n \n@@ -313,7 +391,7 @@ public ModeAndException getRestriction(int code, @AttributeUsage int usage) {\n   @HiddenApi\n   @RequiresPermission(value = android.Manifest.permission.WATCH_APPOPS)\n   protected void startWatchingMode(int op, String packageName, OnOpChangedListener callback) {\n-    appOpListeners.put(getListenerKey(op, packageName), callback);\n+    appOpListeners.put(Key.create(null, packageName, op), callback);\n   }\n \n   @Implementation(minSdk = KITKAT)\n@@ -322,20 +400,20 @@ protected void stopWatchingMode(OnOpChangedListener callback) {\n     appOpListeners.inverse().remove(callback);\n   }\n \n-  protected OpEntry toOpEntry(Integer op) {\n+  protected OpEntry toOpEntry(Integer op, int mode) {\n     if (RuntimeEnvironment.getApiLevel() < Build.VERSION_CODES.M) {\n       return ReflectionHelpers.callConstructor(\n           OpEntry.class,\n           ClassParameter.from(int.class, op),\n-          ClassParameter.from(int.class, AppOpsManager.MODE_ALLOWED),\n+          ClassParameter.from(int.class, mode),\n           ClassParameter.from(long.class, OP_TIME),\n           ClassParameter.from(long.class, REJECT_TIME),\n           ClassParameter.from(int.class, DURATION));\n     } else if (RuntimeEnvironment.getApiLevel() < Build.VERSION_CODES.Q) {\n       return ReflectionHelpers.callConstructor(\n           OpEntry.class,\n           ClassParameter.from(int.class, op),\n-          ClassParameter.from(int.class, AppOpsManager.MODE_ALLOWED),\n+          ClassParameter.from(int.class, mode),\n           ClassParameter.from(long.class, OP_TIME),\n           ClassParameter.from(long.class, REJECT_TIME),\n           ClassParameter.from(int.class, DURATION),\n@@ -364,7 +442,7 @@ protected OpEntry toOpEntry(Integer op) {\n           OpEntry.class,\n           ClassParameter.from(int.class, op),\n           ClassParameter.from(boolean.class, false),\n-          ClassParameter.from(int.class, AppOpsManager.MODE_ALLOWED),\n+          ClassParameter.from(int.class, mode),\n           ClassParameter.from(LongSparseLongArray.class, accessTimes),\n           ClassParameter.from(LongSparseLongArray.class, rejectTimes),\n           ClassParameter.from(LongSparseLongArray.class, durations),\n@@ -384,26 +462,30 @@ protected OpEntry toOpEntry(Integer op) {\n \n       return new OpEntry(\n           op,\n-          AppOpsManager.MODE_ALLOWED,\n+          mode,\n           Collections.singletonMap(\n               null, new AttributedOpEntry(op, false, accessEvents, rejectEvents)));\n     }\n   }\n \n-  private static String getInternalKey(int uid, String packageName) {\n-    return uid + \"|\" + packageName;\n-  }\n-\n-  private static String getOpMapKey(int uid, String packageName, int opInt) {\n-    return String.format(\"%s|%s|%s\", uid, packageName, opInt);\n-  }\n-\n   private static int getAudioRestrictionKey(int code, @AttributeUsage int usage) {\n     return code | (usage << 8);\n   }\n \n-  private static String getListenerKey(int op, String packageName) {\n-    return String.format(\"%s|%s\", op, packageName);\n+  @AutoValue\n+  abstract static class Key {\n+    @Nullable\n+    abstract Integer getUid();\n+\n+    @Nullable\n+    abstract String getPackageName();\n+\n+    @Nullable\n+    abstract Integer getOpCode();\n+\n+    static Key create(Integer uid, String packageName, Integer opCode) {\n+      return new AutoValue_ShadowAppOpsManager_Key(uid, packageName, opCode);\n+    }\n   }\n \n   /** Class holding usage mode and excpetion packages. */"
  },
  {
    "sha": "5e500fc4b090071346b7c52a9f89b3bc8e326de1",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/robolectric/robolectric/blob/3ee953f161503edf457c2a6e29c9906009694604/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/3ee953f161503edf457c2a6e29c9906009694604/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java?ref=3ee953f161503edf457c2a6e29c9906009694604",
    "patch": "@@ -40,6 +40,7 @@\n @SuppressWarnings({\"UnusedDeclaration\"})\n @Implements(value = AudioManager.class, looseSignatures = true)\n public class ShadowAudioManager {\n+\n   public static final int MAX_VOLUME_MUSIC_DTMF = 15;\n   public static final int DEFAULT_MAX_VOLUME = 7;\n   public static final int MIN_VOLUME = 0;\n@@ -166,6 +167,7 @@ protected int abandonAudioFocus(AudioManager.OnAudioFocusChangeListener l) {\n    */\n   @Implementation(minSdk = O)\n   protected int abandonAudioFocusRequest(android.media.AudioFocusRequest audioFocusRequest) {\n+    lastAbandonedAudioFocusListener = audioFocusRequest.getOnAudioFocusChangeListener();\n     lastAbandonedAudioFocusRequest = audioFocusRequest;\n     return nextResponseValue;\n   }\n@@ -637,7 +639,7 @@ private AudioFocusRequest(\n     }\n \n     private AudioFocusRequest(android.media.AudioFocusRequest audioFocusRequest) {\n-      this.listener = null;\n+      this.listener = audioFocusRequest.getOnAudioFocusChangeListener();\n       this.streamType = this.durationHint = -1;\n       this.audioFocusRequest = audioFocusRequest;\n     }"
  },
  {
    "sha": "b1632bf5e4f09340b488ef7c54c417439a8435d8",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/robolectric/robolectric/blob/3ee953f161503edf457c2a6e29c9906009694604/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/3ee953f161503edf457c2a6e29c9906009694604/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java?ref=3ee953f161503edf457c2a6e29c9906009694604",
    "patch": "@@ -88,6 +88,7 @@ protected static Bitmap decodeFile(String pathName) {\n     return decodeFile(pathName, null);\n   }\n \n+  @SuppressWarnings(\"Var\")\n   @Implementation\n   protected static Bitmap decodeFile(String pathName, BitmapFactory.Options options) {\n     // If a real file is used, attempt to get the image size from that file.\n@@ -113,7 +114,7 @@ protected static Bitmap decodeFile(String pathName, BitmapFactory.Options option\n     return bitmap;\n   }\n \n-  @SuppressWarnings(\"ObjectToString\")\n+  @SuppressWarnings({\"ObjectToString\", \"Var\"})\n   @Implementation\n   protected static Bitmap decodeFileDescriptor(\n       FileDescriptor fd, Rect outPadding, BitmapFactory.Options opts) {"
  },
  {
    "sha": "3f821b7d647f4d0154ae03d29a6d906d2f0aa98d",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java",
    "status": "modified",
    "additions": 19,
    "deletions": 10,
    "changes": 29,
    "blob_url": "https://github.com/robolectric/robolectric/blob/3ee953f161503edf457c2a6e29c9906009694604/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/3ee953f161503edf457c2a6e29c9906009694604/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java?ref=3ee953f161503edf457c2a6e29c9906009694604",
    "patch": "@@ -16,8 +16,7 @@\n @Implements(ContextWrapper.class)\n public class ShadowContextWrapper {\n \n-  @RealObject\n-  private ContextWrapper realContextWrapper;\n+  @RealObject private ContextWrapper realContextWrapper;\n \n   /** Returns the broadcast intents sent during the tests (for all users). */\n   public List<Intent> getBroadcastIntents() {\n@@ -98,8 +97,8 @@ public Intent getNextStartedService() {\n   }\n \n   /**\n-   * Returns the most recent {@code Intent} started by\n-   * {@link android.content.Context#startService(android.content.Intent)} without consuming it.\n+   * Returns the most recent {@code Intent} started by {@link\n+   * android.content.Context#startService(android.content.Intent)} without consuming it.\n    *\n    * @return the most recently started {@code Intent}\n    */\n@@ -108,17 +107,27 @@ public Intent peekNextStartedService() {\n   }\n \n   /**\n-   * Clears all {@code Intent} started by\n-   * {@link android.content.Context#startService(android.content.Intent)}.\n+   * Returns all {@code Intent} started by {@link #startService(android.content.Intent)} without\n+   * consuming them.\n+   *\n+   * @return the list of {@code Intent}\n+   */\n+  public List<Intent> getAllStartedServices() {\n+    return getShadowInstrumentation().getAllStartedServices();\n+  }\n+\n+  /**\n+   * Clears all {@code Intent} started by {@link\n+   * android.content.Context#startService(android.content.Intent)}.\n    */\n   public void clearStartedServices() {\n     getShadowInstrumentation().clearStartedServices();\n   }\n \n   /**\n-   * Consumes the {@code Intent} requested to stop a service by\n-   * {@link android.content.Context#stopService(android.content.Intent)}\n-   * from the bottom of the stack of stop requests.\n+   * Consumes the {@code Intent} requested to stop a service by {@link\n+   * android.content.Context#stopService(android.content.Intent)} from the bottom of the stack of\n+   * stop requests.\n    */\n   public Intent getNextStoppedService() {\n     return getShadowInstrumentation().getNextStoppedService();\n@@ -137,7 +146,7 @@ public void grantPermissions(int pid, int uid, String... permissions) {\n   /**\n    * Revoke the given permissions for the current process and user.\n    *\n-   * Has no effect if permissions were not previously granted.\n+   * <p>Has no effect if permissions were not previously granted.\n    */\n   public void denyPermissions(String... permissionNames) {\n     getShadowInstrumentation().denyPermissions(permissionNames);"
  },
  {
    "sha": "76ed5068c88488a3074ecee159a9da3332484519",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/robolectric/robolectric/blob/3ee953f161503edf457c2a6e29c9906009694604/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/3ee953f161503edf457c2a6e29c9906009694604/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java?ref=3ee953f161503edf457c2a6e29c9906009694604",
    "patch": "@@ -15,6 +15,7 @@\n import android.util.SparseArray;\n import android.view.Display;\n import android.view.DisplayInfo;\n+import com.google.common.annotations.VisibleForTesting;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.TreeMap;\n@@ -65,6 +66,11 @@ public static synchronized DisplayManagerGlobal getInstance() {\n     return instance;\n   }\n \n+  @VisibleForTesting\n+  static DisplayManagerGlobal getGlobalInstance() {\n+    return instance;\n+  }\n+\n   @Implementation\n   protected WifiDisplayStatus getWifiDisplayStatus() {\n     return new WifiDisplayStatus();"
  },
  {
    "sha": "68532aa71f9bd75a7a2145be4f0a7bfbdf24a5f0",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java",
    "status": "modified",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/robolectric/robolectric/blob/3ee953f161503edf457c2a6e29c9906009694604/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/3ee953f161503edf457c2a6e29c9906009694604/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java?ref=3ee953f161503edf457c2a6e29c9906009694604",
    "patch": "@@ -793,6 +793,20 @@ void clearStartedServices() {\n     startedServices.clear();\n   }\n \n+  /**\n+   * Returns all {@code Intent} started by {@link #startService(android.content.Intent)} without\n+   * consuming them.\n+   *\n+   * @return the list of {@code Intent}\n+   */\n+  List<Intent> getAllStartedServices() {\n+    ArrayList<Intent> startedServicesIntents = new ArrayList<>();\n+    for (Intent.FilterComparison filterComparison : startedServices) {\n+      startedServicesIntents.add(filterComparison.getIntent());\n+    }\n+    return startedServicesIntents;\n+  }\n+\n   /**\n    * Consumes the {@code Intent} requested to stop a service by {@link\n    * #stopService(android.content.Intent)} from the bottom of the stack of stop requests."
  }
]
