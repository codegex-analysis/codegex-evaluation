[
  {
    "sha": "34f451f42d48f5714e589b52263a42a442f65f67",
    "filename": "integration_tests/ctesque/src/test/java/android/content/res/ResourcesTest.java",
    "status": "modified",
    "additions": 10,
    "deletions": 0,
    "changes": 10,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/integration_tests/ctesque/src/test/java/android/content/res/ResourcesTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/integration_tests/ctesque/src/test/java/android/content/res/ResourcesTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/integration_tests/ctesque/src/test/java/android/content/res/ResourcesTest.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -574,6 +574,16 @@ public void testGetXml_nonxmlfile() {\n     resources.getXml(R.drawable.an_image);\n   }\n \n+  @Test\n+  public void testGetXml_notNPEAfterClose() {\n+    XmlResourceParser parser = resources.getXml(R.xml.preferences);\n+    parser.close();\n+    // the following methods should not NPE if the XmlResourceParser has been closed.\n+    assertThat(parser.getName()).isNull();\n+    assertThat(parser.getNamespace()).isEmpty();\n+    assertThat(parser.getText()).isNull();\n+  }\n+\n   @Test\n   public void openRawResource_shouldLoadRawResources() throws Exception {\n     InputStream resourceStream = resources.openRawResource(R.raw.raw_resource);"
  },
  {
    "sha": "8f8d5211f882c01567045b306efa9764b5212e70",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/FrameMetricsBuilderTest.java",
    "status": "modified",
    "additions": 21,
    "deletions": 0,
    "changes": 21,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/FrameMetricsBuilderTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/FrameMetricsBuilderTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/FrameMetricsBuilderTest.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -69,4 +69,25 @@ public void allTimeMetrics() throws Exception {\n     // syncDelayTimeNanos is 3.\n     assertThat(metrics.getMetric(FrameMetrics.TOTAL_DURATION)).isEqualTo(1L + 2L * 7 + 3L);\n   }\n+\n+  @Test\n+  public void totalDurationExcludesNonDurationValues() throws Exception {\n+    long unknownDelay = 1L;\n+    long animation = 20L;\n+    long inputHandling = 300L;\n+    long largeValue = 40000L;\n+    assertThat(\n+        new org.robolectric.shadows.FrameMetricsBuilder()\n+            .setMetric(FrameMetrics.UNKNOWN_DELAY_DURATION, unknownDelay)\n+            .setMetric(FrameMetrics.ANIMATION_DURATION, animation)\n+            .setMetric(FrameMetrics.INPUT_HANDLING_DURATION, inputHandling)\n+\n+            // metrics that should not impact TOTAL_DURATION\n+            .setMetric(FrameMetrics.FIRST_DRAW_FRAME, 1)\n+            .setMetric(FrameMetrics.INTENDED_VSYNC_TIMESTAMP, largeValue)\n+            .setMetric(FrameMetrics.VSYNC_TIMESTAMP,  largeValue)\n+            .build()\n+            .getMetric(FrameMetrics.TOTAL_DURATION))\n+        .isEqualTo(unknownDelay + animation + inputHandling);\n+  }\n }"
  },
  {
    "sha": "bdeb5f1a9ba74af9c7072d580a3205a551435ebf",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java",
    "status": "modified",
    "additions": 185,
    "deletions": 0,
    "changes": 185,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -3,6 +3,10 @@\n import static android.app.AppOpsManager.MODE_ALLOWED;\n import static android.app.AppOpsManager.MODE_DEFAULT;\n import static android.app.AppOpsManager.MODE_ERRORED;\n+import static android.app.AppOpsManager.MODE_FOREGROUND;\n+import static android.app.AppOpsManager.MODE_IGNORED;\n+import static android.app.AppOpsManager.OPSTR_BODY_SENSORS;\n+import static android.app.AppOpsManager.OPSTR_COARSE_LOCATION;\n import static android.app.AppOpsManager.OPSTR_FINE_LOCATION;\n import static android.app.AppOpsManager.OPSTR_GPS;\n import static android.app.AppOpsManager.OPSTR_READ_PHONE_STATE;\n@@ -12,6 +16,7 @@\n import static android.app.AppOpsManager.OP_SEND_SMS;\n import static android.app.AppOpsManager.OP_VIBRATE;\n import static android.os.Build.VERSION_CODES.KITKAT;\n+import static android.os.Build.VERSION_CODES.Q;\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n import static org.mockito.Mockito.mock;\n@@ -393,6 +398,156 @@ public void checkPackage_belongs() {\n     // check passes without exception\n   }\n \n+  @Config(minSdk = KITKAT)\n+  @Test\n+  public void getPackageForOps_setNone_getNull() {\n+    int[] intNull = null;\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(intNull);\n+    assertThat(packageOps).isNull();\n+  }\n+\n+  @Config(minSdk = KITKAT)\n+  @Test\n+  public void getPackageForOps_setOne_getOne() {\n+    String packageName = \"com.android.package\";\n+    int uid = 111;\n+    appOps.setMode(0, uid, packageName, MODE_ALLOWED);\n+\n+    int[] intNull = null;\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(intNull);\n+    assertThat(containsPackageOpPair(packageOps, packageName, 0, MODE_ALLOWED)).isTrue();\n+  }\n+\n+  @Config(minSdk = KITKAT)\n+  @Test\n+  public void getPackageForOps_setMultiple_getMultiple() {\n+    String packageName1 = \"com.android.package\";\n+    String packageName2 = \"com.android.other\";\n+    int uid1 = 111;\n+    int uid2 = 112;\n+    appOps.setMode(0, uid1, packageName1, MODE_ALLOWED);\n+    appOps.setMode(1, uid1, packageName1, MODE_DEFAULT);\n+    appOps.setMode(2, uid1, packageName1, MODE_ERRORED);\n+    appOps.setMode(3, uid1, packageName1, MODE_FOREGROUND);\n+    appOps.setMode(4, uid1, packageName1, MODE_IGNORED);\n+    appOps.setMode(0, uid2, packageName2, MODE_ALLOWED);\n+\n+    int[] intNull = null;\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(intNull);\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 0, MODE_ALLOWED)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 1, MODE_DEFAULT)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 2, MODE_ERRORED)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 3, MODE_FOREGROUND)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 4, MODE_IGNORED)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName2, 0, MODE_ALLOWED)).isTrue();\n+  }\n+\n+  @Config(minSdk = KITKAT)\n+  @Test\n+  public void getPackageForOps_setMultiple_onlyGetThoseAskedFor() {\n+    String packageName1 = \"com.android.package\";\n+    String packageName2 = \"com.android.other\";\n+    int uid1 = 111;\n+    int uid2 = 112;\n+    appOps.setMode(0, uid1, packageName1, MODE_ALLOWED);\n+    appOps.setMode(1, uid1, packageName1, MODE_DEFAULT);\n+    appOps.setMode(2, uid1, packageName1, MODE_ERRORED);\n+    appOps.setMode(3, uid1, packageName1, MODE_FOREGROUND);\n+    appOps.setMode(4, uid1, packageName1, MODE_IGNORED);\n+    appOps.setMode(0, uid2, packageName2, MODE_ALLOWED);\n+\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(new int[] {0, 1});\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 0, MODE_ALLOWED)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 1, MODE_DEFAULT)).isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 2, MODE_ERRORED)).isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 3, MODE_FOREGROUND)).isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, 4, MODE_IGNORED)).isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName2, 0, MODE_ALLOWED)).isTrue();\n+  }\n+\n+  @Config(minSdk = Q)\n+  @Test\n+  public void getPackageForOpsStr_setNone_getEmptyList() {\n+    String[] stringNull = null;\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(stringNull);\n+    assertThat(packageOps).isEmpty();\n+  }\n+\n+  @Config(minSdk = Q)\n+  @Test\n+  public void getPackageForOpsStr_setOne_getOne() {\n+    String packageName = \"com.android.package\";\n+    int uid = 111;\n+    appOps.setMode(AppOpsManager.OPSTR_COARSE_LOCATION, uid, packageName, MODE_ALLOWED);\n+\n+    String[] stringNull = null;\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(stringNull);\n+    assertThat(containsPackageOpPair(packageOps, packageName, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+  }\n+\n+  @Config(minSdk = Q)\n+  @Test\n+  public void getPackageForOpsStr_setMultiple_getMultiple() {\n+    String packageName1 = \"com.android.package\";\n+    String packageName2 = \"com.android.other\";\n+    int uid1 = 111;\n+    int uid2 = 112;\n+    appOps.setMode(OPSTR_COARSE_LOCATION, uid1, packageName1, MODE_ALLOWED);\n+    appOps.setMode(OPSTR_FINE_LOCATION, uid1, packageName1, MODE_DEFAULT);\n+    appOps.setMode(OPSTR_READ_PHONE_STATE, uid1, packageName1, MODE_ERRORED);\n+    appOps.setMode(OPSTR_RECORD_AUDIO, uid1, packageName1, MODE_FOREGROUND);\n+    appOps.setMode(OPSTR_BODY_SENSORS, uid1, packageName1, MODE_IGNORED);\n+    appOps.setMode(OPSTR_COARSE_LOCATION, uid2, packageName2, MODE_ALLOWED);\n+\n+    String[] stringNull = null;\n+    List<PackageOps> packageOps = appOps.getPackagesForOps(stringNull);\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_FINE_LOCATION, MODE_DEFAULT))\n+        .isTrue();\n+    assertThat(\n+            containsPackageOpPair(packageOps, packageName1, OPSTR_READ_PHONE_STATE, MODE_ERRORED))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_RECORD_AUDIO, MODE_FOREGROUND))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_BODY_SENSORS, MODE_IGNORED))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName2, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+  }\n+\n+  @Config(minSdk = Q)\n+  @Test\n+  public void getPackageForOpsStr_setMultiple_onlyGetThoseAskedFor() {\n+    String packageName1 = \"com.android.package\";\n+    String packageName2 = \"com.android.other\";\n+    int uid1 = 111;\n+    int uid2 = 112;\n+    appOps.setMode(OPSTR_COARSE_LOCATION, uid1, packageName1, MODE_ALLOWED);\n+    appOps.setMode(OPSTR_FINE_LOCATION, uid1, packageName1, MODE_DEFAULT);\n+    appOps.setMode(OPSTR_READ_PHONE_STATE, uid1, packageName1, MODE_ERRORED);\n+    appOps.setMode(OPSTR_RECORD_AUDIO, uid1, packageName1, MODE_FOREGROUND);\n+    appOps.setMode(OPSTR_BODY_SENSORS, uid1, packageName1, MODE_IGNORED);\n+    appOps.setMode(OPSTR_COARSE_LOCATION, uid2, packageName2, MODE_ALLOWED);\n+\n+    List<PackageOps> packageOps =\n+        appOps.getPackagesForOps(new String[] {OPSTR_COARSE_LOCATION, OPSTR_FINE_LOCATION});\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_FINE_LOCATION, MODE_DEFAULT))\n+        .isTrue();\n+    assertThat(\n+            containsPackageOpPair(packageOps, packageName1, OPSTR_READ_PHONE_STATE, MODE_ERRORED))\n+        .isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_RECORD_AUDIO, MODE_FOREGROUND))\n+        .isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName1, OPSTR_BODY_SENSORS, MODE_IGNORED))\n+        .isFalse();\n+    assertThat(containsPackageOpPair(packageOps, packageName2, OPSTR_COARSE_LOCATION, MODE_ALLOWED))\n+        .isTrue();\n+  }\n+\n   /** Assert that the results contain the expected op codes. */\n   private void assertOps(List<PackageOps> pkgOps, Integer... expectedOps) {\n     Set<Integer> actualOps = new HashSet<>();\n@@ -404,4 +559,34 @@ private void assertOps(List<PackageOps> pkgOps, Integer... expectedOps) {\n \n     assertThat(actualOps).containsAtLeastElementsIn(expectedOps);\n   }\n+\n+  /** True if the given (package, op, mode) tuple is present in the given list. */\n+  private boolean containsPackageOpPair(\n+      List<PackageOps> pkgOps, String packageName, int op, int mode) {\n+    for (PackageOps pkgOp : pkgOps) {\n+      for (OpEntry entry : pkgOp.getOps()) {\n+        if (packageName.equals(pkgOp.getPackageName())\n+            && entry.getOp() == op\n+            && entry.getMode() == mode) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /** True if the given (package, op, mode) tuple is present in the given list. */\n+  private boolean containsPackageOpPair(\n+      List<PackageOps> pkgOps, String packageName, String op, int mode) {\n+    for (PackageOps pkgOp : pkgOps) {\n+      for (OpEntry entry : pkgOp.getOps()) {\n+        if (packageName.equals(pkgOp.getPackageName())\n+            && op.equals(entry.getOpStr())\n+            && entry.getMode() == mode) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n }"
  },
  {
    "sha": "07a8ca2edd44e9921438bee58ded8e58c39ad1a1",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java",
    "status": "modified",
    "additions": 25,
    "deletions": 0,
    "changes": 25,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -1,6 +1,7 @@\n package org.robolectric.shadows;\n \n import static android.os.Build.VERSION_CODES.L;\n+import static android.os.Build.VERSION_CODES.O;\n import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n@@ -179,6 +180,30 @@ public void getInstalledProvidersForProfile_returnsWidgetList() {\n     assertTrue(installedProvidersForProfile.contains(info2));\n   }\n \n+  @Test\n+  @Config(minSdk = O)\n+  public void getInstalledProvidersForPackage_returnsWidgetList() {\n+    UserHandle userHandle = UserHandle.CURRENT;\n+    String packageName = \"com.google.fakeapp\";\n+\n+    assertTrue(appWidgetManager.getInstalledProvidersForPackage(packageName, userHandle).isEmpty());\n+\n+    AppWidgetProviderInfo info1 = new AppWidgetProviderInfo();\n+    info1.label = \"abc\";\n+    info1.provider = new ComponentName(packageName, \"123\");\n+    AppWidgetProviderInfo info2 = new AppWidgetProviderInfo();\n+    info2.label = \"def\";\n+    info2.provider = new ComponentName(packageName, \"456\");\n+    shadowAppWidgetManager.addInstalledProvidersForProfile(userHandle, info1);\n+    shadowAppWidgetManager.addInstalledProvidersForProfile(userHandle, info2);\n+    List<AppWidgetProviderInfo> installedProvidersForProfile =\n+        appWidgetManager.getInstalledProvidersForPackage(packageName, userHandle);\n+\n+    assertEquals(2, installedProvidersForProfile.size());\n+    assertTrue(installedProvidersForProfile.contains(info1));\n+    assertTrue(installedProvidersForProfile.contains(info2));\n+  }\n+\n   private void assertContains(String expectedText, View view) {\n     String actualText = shadowOf(view).innerText();\n     assertTrue("
  },
  {
    "sha": "7880e19ffd8b766070a754c52033b8fa1b9eca4b",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java",
    "status": "modified",
    "additions": 18,
    "deletions": 1,
    "changes": 19,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowApplicationTest.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -10,6 +10,7 @@\n import static com.google.common.truth.TruthJUnit.assume;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertSame;\n import static org.junit.Assert.assertTrue;\n@@ -664,6 +665,23 @@ public void shouldClearStartedServiceIntents() {\n     assertNull(shadowOf(context).getNextStartedService());\n   }\n \n+  @Test\n+  public void getAllStartedServices() {\n+    Intent intent1 = getSomeActionIntent(\"some.action\");\n+    Intent intent2 = getSomeActionIntent(\"another.action\");\n+\n+    context.startService(intent1);\n+    context.startService(intent2);\n+    List<Intent> startedServiceIntents = shadowOf(context).getAllStartedServices();\n+\n+    assertThat(startedServiceIntents).hasSize(2);\n+    assertThat(startedServiceIntents.get(0).filterEquals(intent1)).isTrue();\n+    assertThat(startedServiceIntents.get(1).filterEquals(intent2)).isTrue();\n+    assertNotNull(shadowOf(context).getNextStartedService());\n+    assertNotNull(shadowOf(context).getNextStartedService());\n+    assertNull(shadowOf(context).getNextStartedService());\n+  }\n+\n   @Test\n   public void shouldThrowIfContainsRegisteredReceiverOfAction() {\n     Activity activity = Robolectric.setupActivity(Activity.class);\n@@ -899,4 +917,3 @@ public void onReceive(Context context, Intent intent) {\n     }\n   }\n }\n-"
  },
  {
    "sha": "253e64b46d1f810191ccf5a23840a3b82cd076a6",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java",
    "status": "modified",
    "additions": 12,
    "deletions": 6,
    "changes": 18,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -77,11 +77,13 @@ public void requestAudioFocus2_shouldRecordArgumentsOfMostRecentCall() {\n     AudioAttributes atts = new AudioAttributes.Builder().build();\n     android.media.AudioFocusRequest request =\n         new android.media.AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)\n+            .setOnAudioFocusChangeListener(listener)\n             .setAudioAttributes(atts)\n             .build();\n \n     audioManager.requestAudioFocus(request);\n-    assertThat(shadowOf(audioManager).getLastAudioFocusRequest().listener).isNull();\n+    assertThat(shadowOf(audioManager).getLastAudioFocusRequest().listener)\n+        .isSameInstanceAs(listener);\n     assertThat(shadowOf(audioManager).getLastAudioFocusRequest().streamType).isEqualTo(-1);\n     assertThat(shadowOf(audioManager).getLastAudioFocusRequest().durationHint).isEqualTo(-1);\n     assertThat(shadowOf(audioManager).getLastAudioFocusRequest().audioFocusRequest)\n@@ -118,10 +120,14 @@ public void abandonAudioFocus_shouldRecordTheListenerOfTheMostRecentCall() {\n   @Config(minSdk = O)\n   public void abandonAudioFocusRequest_shouldRecordTheListenerOfTheMostRecentCall() {\n     android.media.AudioFocusRequest request =\n-        new android.media.AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN).build();\n+        new android.media.AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)\n+            .setOnAudioFocusChangeListener(listener)\n+            .build();\n     audioManager.abandonAudioFocusRequest(request);\n     assertThat(shadowOf(audioManager).getLastAbandonedAudioFocusRequest())\n         .isSameInstanceAs(request);\n+    assertThat(shadowOf(audioManager).getLastAbandonedAudioFocusListener())\n+        .isSameInstanceAs(listener);\n   }\n \n   @Test\n@@ -491,7 +497,7 @@ public void adjustStreamVolume_lower() {\n     int volumeBefore = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n \n     audioManager.adjustStreamVolume(\n-            AudioManager.STREAM_MUSIC, AudioManager.ADJUST_LOWER, /* flags= */ 0);\n+        AudioManager.STREAM_MUSIC, AudioManager.ADJUST_LOWER, /* flags= */ 0);\n \n     int volumeAfter = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n     assertThat(volumeAfter).isLessThan(volumeBefore);\n@@ -504,7 +510,7 @@ public void adjustStreamVolume_lowerAtMinVolume_remainsSame() {\n     int volumeBefore = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n \n     audioManager.adjustStreamVolume(\n-            AudioManager.STREAM_MUSIC, AudioManager.ADJUST_LOWER, /* flags= */ 0);\n+        AudioManager.STREAM_MUSIC, AudioManager.ADJUST_LOWER, /* flags= */ 0);\n \n     int volumeAfter = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n     assertThat(volumeAfter).isEqualTo(volumeBefore);\n@@ -517,7 +523,7 @@ public void adjustStreamVolume_raise() {\n     int volumeBefore = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n \n     audioManager.adjustStreamVolume(\n-            AudioManager.STREAM_MUSIC, AudioManager.ADJUST_RAISE, /* flags= */ 0);\n+        AudioManager.STREAM_MUSIC, AudioManager.ADJUST_RAISE, /* flags= */ 0);\n \n     int volumeAfter = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n     assertThat(volumeAfter).isGreaterThan(volumeBefore);\n@@ -531,7 +537,7 @@ public void adjustStreamVolume_raiseAtMaxVolume_remainsSame() {\n     int volumeBefore = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n \n     audioManager.adjustStreamVolume(\n-            AudioManager.STREAM_MUSIC, AudioManager.ADJUST_RAISE, /* flags= */ 0);\n+        AudioManager.STREAM_MUSIC, AudioManager.ADJUST_RAISE, /* flags= */ 0);\n \n     int volumeAfter = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC);\n     assertThat(volumeAfter).isEqualTo(volumeBefore);"
  },
  {
    "sha": "76eb107b4756ffe949282c008bb7b0a0bd72eedd",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowBugreportManagerTest.java",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/ShadowBugreportManagerTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/ShadowBugreportManagerTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowBugreportManagerTest.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -41,6 +41,14 @@ public void setUp() {\n     shadowBugreportManager = Shadow.extract(context.getSystemService(Context.BUGREPORT_SERVICE));\n   }\n \n+  @Test\n+  public void requestBugreport() {\n+    shadowBugreportManager.requestBugreport(\n+        new BugreportParams(BugreportParams.BUGREPORT_MODE_INTERACTIVE), \"title\", \"description\");\n+\n+    assertThat(shadowBugreportManager.wasBugreportRequested()).isTrue();\n+  }\n+\n   @Test\n   public void startBugreport() throws Exception {\n     BugreportCallback callback = mock(BugreportCallback.class);"
  },
  {
    "sha": "57b0399fef34e478709dd7d9e1bc97c518a68a63",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java",
    "status": "added",
    "additions": 27,
    "deletions": 0,
    "changes": 27,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -0,0 +1,27 @@\n+package org.robolectric.shadows;\n+\n+import static android.os.Build.VERSION_CODES.JELLY_BEAN_MR1;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import android.hardware.display.DisplayManagerGlobal;\n+import android.view.Display;\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.annotation.Config;\n+import org.robolectric.annotation.LazyLoadApplication;\n+import org.robolectric.annotation.LazyLoadApplication.LazyLoad;\n+\n+/** Unit tests for {@link ShadowDisplayManagerGlobal} */\n+@RunWith(AndroidJUnit4.class)\n+public class ShadowDisplayManagerGlobalTest {\n+\n+  @LazyLoadApplication(LazyLoad.ON)\n+  @Test\n+  @Config(minSdk = JELLY_BEAN_MR1)\n+  public void testDisplayManagerGlobalIsLazyLoaded() {\n+    assertThat(ShadowDisplayManagerGlobal.getGlobalInstance()).isNull();\n+    assertThat(DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY))\n+        .isNotNull();\n+  }\n+}"
  },
  {
    "sha": "648b30d8a22417cfd4d1b89a428161a58860b521",
    "filename": "robolectric/src/test/java/org/robolectric/shadows/ShadowLocationManagerTest.java",
    "status": "modified",
    "additions": 102,
    "deletions": 0,
    "changes": 102,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/ShadowLocationManagerTest.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/robolectric/src/test/java/org/robolectric/shadows/ShadowLocationManagerTest.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/robolectric/src/test/java/org/robolectric/shadows/ShadowLocationManagerTest.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -1,8 +1,10 @@\n package org.robolectric.shadows;\n \n import static android.location.LocationManager.GPS_PROVIDER;\n+import static android.location.LocationManager.MODE_CHANGED_ACTION;\n import static android.location.LocationManager.NETWORK_PROVIDER;\n import static android.location.LocationManager.PASSIVE_PROVIDER;\n+import static android.location.LocationManager.PROVIDERS_CHANGED_ACTION;\n import static android.os.Build.VERSION_CODES.N;\n import static android.os.Build.VERSION_CODES.Q;\n import static android.provider.Settings.Secure.LOCATION_MODE;\n@@ -244,24 +246,78 @@ public void testIsProviderEnabled_Passive() {\n   @Config(maxSdk = VERSION_CODES.O)\n   public void testSetProviderEnabled_Mode() {\n     shadowLocationManager.setProviderEnabled(MY_PROVIDER, true);\n+    assertBroadcast(new Intent(PROVIDERS_CHANGED_ACTION));\n+    assertNotBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n \n     shadowLocationManager.setProviderEnabled(GPS_PROVIDER, false);\n+    assertBroadcast(new Intent(PROVIDERS_CHANGED_ACTION));\n+    assertBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n+\n     shadowLocationManager.setProviderEnabled(NETWORK_PROVIDER, false);\n+    assertNotBroadcast(new Intent(PROVIDERS_CHANGED_ACTION));\n+    assertNotBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n+\n     assertThat(getLocationMode()).isEqualTo(LOCATION_MODE_OFF);\n \n     shadowLocationManager.setProviderEnabled(GPS_PROVIDER, true);\n+    assertBroadcast(new Intent(PROVIDERS_CHANGED_ACTION));\n+    assertBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n+\n     shadowLocationManager.setProviderEnabled(NETWORK_PROVIDER, false);\n+    assertNotBroadcast(new Intent(PROVIDERS_CHANGED_ACTION));\n+    assertNotBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n+\n     assertThat(getLocationMode()).isEqualTo(LOCATION_MODE_SENSORS_ONLY);\n \n     shadowLocationManager.setProviderEnabled(GPS_PROVIDER, false);\n+    assertBroadcast(new Intent(PROVIDERS_CHANGED_ACTION));\n+    assertBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n+\n     shadowLocationManager.setProviderEnabled(NETWORK_PROVIDER, true);\n+    assertBroadcast(new Intent(PROVIDERS_CHANGED_ACTION));\n+    assertBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n+\n     assertThat(getLocationMode()).isEqualTo(LOCATION_MODE_BATTERY_SAVING);\n \n     shadowLocationManager.setProviderEnabled(GPS_PROVIDER, true);\n+    assertBroadcast(new Intent(PROVIDERS_CHANGED_ACTION));\n+    assertBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n+\n     shadowLocationManager.setProviderEnabled(NETWORK_PROVIDER, true);\n+    assertNotBroadcast(new Intent(PROVIDERS_CHANGED_ACTION));\n+    assertNotBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n+\n     assertThat(getLocationMode()).isEqualTo(LOCATION_MODE_HIGH_ACCURACY);\n   }\n \n+  @Test\n+  @Config(minSdk = VERSION_CODES.R)\n+  public void testSetProviderEnabled_RPlus() {\n+    shadowLocationManager.setProviderEnabled(MY_PROVIDER, true);\n+    assertBroadcast(new Intent(PROVIDERS_CHANGED_ACTION));\n+    assertNotBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n+\n+    shadowLocationManager.setProviderEnabled(GPS_PROVIDER, false);\n+    assertBroadcast(new Intent(PROVIDERS_CHANGED_ACTION));\n+    assertNotBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n+\n+    shadowLocationManager.setProviderEnabled(NETWORK_PROVIDER, true);\n+    assertBroadcast(new Intent(PROVIDERS_CHANGED_ACTION));\n+    assertNotBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n+  }\n+\n   @Test\n   public void testSetProviderEnabled_Listeners() {\n     TestLocationListener myListener = new TestLocationListener();\n@@ -295,6 +351,18 @@ public void testRemoveProvider() {\n     assertThat(myListener.locations).isEmpty();\n   }\n \n+  @Test\n+  @Config(minSdk = VERSION_CODES.P)\n+  public void testSetLocationEnabled() {\n+    shadowLocationManager.setLocationEnabled(false);\n+    assertBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n+\n+    shadowLocationManager.setLocationEnabled(false);\n+    assertBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n+  }\n+\n   @Test\n   @Config(sdk = VERSION_CODES.P)\n   public void testIsLocationEnabled_POnly() {\n@@ -385,6 +453,8 @@ public void testSetLocationMode() {\n     assertThat(locationManager.isProviderEnabled(NETWORK_PROVIDER)).isFalse();\n     assertThat(getLocationMode()).isEqualTo(LOCATION_MODE_OFF);\n     assertThat(getProvidersAllowed()).containsExactly(MY_PROVIDER);\n+    assertBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n \n     shadowLocationManager.setLocationMode(LOCATION_MODE_SENSORS_ONLY);\n     assertThat(locationManager.isProviderEnabled(MY_PROVIDER)).isTrue();\n@@ -393,6 +463,8 @@ public void testSetLocationMode() {\n     assertThat(locationManager.isProviderEnabled(NETWORK_PROVIDER)).isFalse();\n     assertThat(getLocationMode()).isEqualTo(LOCATION_MODE_SENSORS_ONLY);\n     assertThat(getProvidersAllowed()).containsExactly(MY_PROVIDER, GPS_PROVIDER);\n+    assertBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n \n     shadowLocationManager.setLocationMode(LOCATION_MODE_BATTERY_SAVING);\n     assertThat(locationManager.isProviderEnabled(MY_PROVIDER)).isTrue();\n@@ -401,6 +473,8 @@ public void testSetLocationMode() {\n     assertThat(locationManager.isProviderEnabled(NETWORK_PROVIDER)).isTrue();\n     assertThat(getLocationMode()).isEqualTo(LOCATION_MODE_BATTERY_SAVING);\n     assertThat(getProvidersAllowed()).containsExactly(MY_PROVIDER, NETWORK_PROVIDER);\n+    assertBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n \n     shadowLocationManager.setLocationMode(LOCATION_MODE_HIGH_ACCURACY);\n     assertThat(locationManager.isProviderEnabled(MY_PROVIDER)).isTrue();\n@@ -409,6 +483,8 @@ public void testSetLocationMode() {\n     assertThat(locationManager.isProviderEnabled(NETWORK_PROVIDER)).isTrue();\n     assertThat(getLocationMode()).isEqualTo(LOCATION_MODE_HIGH_ACCURACY);\n     assertThat(getProvidersAllowed()).containsExactly(MY_PROVIDER, GPS_PROVIDER, NETWORK_PROVIDER);\n+    assertBroadcast(new Intent(MODE_CHANGED_ACTION));\n+    shadowOf(context).clearBroadcastIntents();\n   }\n \n   @Test\n@@ -1022,6 +1098,32 @@ private int getLocationMode() {\n     return new HashSet<>(Arrays.asList(providersAllowed.split(\",\")));\n   }\n \n+  private void assertBroadcast(Intent... intents) {\n+    for (Intent intent : intents) {\n+      boolean found = false;\n+      for (Intent broadcast : shadowOf(context).getBroadcastIntents()) {\n+        if (broadcast.filterEquals(intent)) {\n+          found = true;\n+          break;\n+        }\n+      }\n+\n+      if (!found) {\n+        assertThat(shadowOf(context).getBroadcastIntents()).contains(intent);\n+      }\n+    }\n+  }\n+\n+  private void assertNotBroadcast(Intent... intents) {\n+    for (Intent intent : intents) {\n+      for (Intent broadcast : shadowOf(context).getBroadcastIntents()) {\n+        if (broadcast.filterEquals(intent)) {\n+          assertThat(shadowOf(context).getBroadcastIntents()).doesNotContain(broadcast);\n+        }\n+      }\n+    }\n+  }\n+\n   private static class TestLocationReceiver extends BroadcastReceiver {\n     private boolean providerEnabled = false;\n     private final PendingIntent pendingIntent;"
  },
  {
    "sha": "d291dc5b612aa9fa377837369128af453e603c84",
    "filename": "shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java",
    "status": "modified",
    "additions": 6,
    "deletions": 4,
    "changes": 10,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -182,6 +182,11 @@ public static String getQualifiers(Configuration configuration, DisplayMetrics d\n   public static void setQualifiers(String newQualifiers) {\n     Configuration configuration;\n     DisplayMetrics displayMetrics = new DisplayMetrics();\n+    // Loading at the beginning, rather than at the end, ensures that the application is already\n+    // loaded when Resources.getSystem() is called. Adding a load inside ShadowResources is not an\n+    // option as it is called from within the loading logic itself.\n+    Application application = getApplication();\n+\n     if (newQualifiers.startsWith(\"+\")) {\n       configuration = new Configuration(Resources.getSystem().getConfiguration());\n       displayMetrics.setTo(Resources.getSystem().getDisplayMetrics());\n@@ -192,10 +197,7 @@ public static void setQualifiers(String newQualifiers) {\n \n     Resources systemResources = Resources.getSystem();\n     systemResources.updateConfiguration(configuration, displayMetrics);\n-\n-    if (getApplication() != null) {\n-      getApplication().getResources().updateConfiguration(configuration, displayMetrics);\n-    }\n+    application.getResources().updateConfiguration(configuration, displayMetrics);\n   }\n \n   public static int getApiLevel() {"
  },
  {
    "sha": "106732a9d5d14651f052721218f1571d89378cec",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/FrameMetricsBuilder.java",
    "status": "modified",
    "additions": 2,
    "deletions": 5,
    "changes": 7,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/FrameMetricsBuilder.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/FrameMetricsBuilder.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/FrameMetricsBuilder.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -4,8 +4,6 @@\n \n import android.view.FrameMetrics;\n import android.view.FrameMetrics.Metric;\n-import com.google.common.primitives.Longs;\n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n import org.robolectric.util.ReflectionHelpers;\n@@ -87,10 +85,9 @@ public FrameMetrics build() throws Exception {\n           timingData[getStartIndexForMetric(metric)] + getMetric(metric);\n     }\n \n-    // Even as FrameMetrics are added, the end point of TOTAL_DURATION should always equal the\n-    // maximum of this list.\n+    // SWAP_BUFFERS_DURATION is the current endpoint in the chain of supported FrameMetrics.\n     timingData[getEndIndexForMetric(FrameMetrics.TOTAL_DURATION)] =\n-        Collections.max(Longs.asList(timingData));\n+        timingData[getEndIndexForMetric(FrameMetrics.SWAP_BUFFERS_DURATION)];\n     return metrics;\n   }\n "
  },
  {
    "sha": "176e9dfa3833d8f31efa77c63da3c796c66922d0",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java",
    "status": "modified",
    "additions": 121,
    "deletions": 36,
    "changes": 157,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -6,8 +6,10 @@\n import static android.os.Build.VERSION_CODES.P;\n import static android.os.Build.VERSION_CODES.Q;\n import static android.os.Build.VERSION_CODES.R;\n+import static java.util.stream.Collectors.toSet;\n import static org.robolectric.shadow.api.Shadow.invokeConstructor;\n \n+import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.annotation.RequiresPermission;\n import android.annotation.SystemApi;\n@@ -26,20 +28,24 @@\n import android.util.LongSparseArray;\n import android.util.LongSparseLongArray;\n import com.android.internal.app.IAppOpsService;\n+import com.google.auto.value.AutoValue;\n import com.google.common.collect.BiMap;\n import com.google.common.collect.HashBiMap;\n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Multimap;\n+import com.google.common.collect.MultimapBuilder;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.stream.IntStream;\n import org.robolectric.RuntimeEnvironment;\n import org.robolectric.annotation.HiddenApi;\n import org.robolectric.annotation.Implementation;\n@@ -62,19 +68,19 @@\n \n   @RealObject private AppOpsManager realObject;\n \n-  // Recorded operations, keyed by \"uid|packageName\"\n-  private Multimap<String, Integer> mStoredOps = HashMultimap.create();\n-  // \"uid|packageName|opCode\" => opMode\n-  private Map<String, Integer> appModeMap = new HashMap<>();\n+  // Recorded operations, keyed by (uid, packageName)\n+  private final Multimap<Key, Integer> storedOps = HashMultimap.create();\n+  // (uid, packageName, opCode) => opMode\n+  private final Map<Key, Integer> appModeMap = new HashMap<>();\n \n-  // \"uid|packageName|opCode\" => opMode\n-  private Set<String> longRunningOp = new HashSet<>();\n+  // (uid, packageName, opCode)\n+  private final Set<Key> longRunningOp = new HashSet<>();\n \n-  // \"packageName|opCode\" => listener\n-  private BiMap<String, OnOpChangedListener> appOpListeners = HashBiMap.create();\n+  // (packageName, opCode) => listener\n+  private final BiMap<Key, OnOpChangedListener> appOpListeners = HashBiMap.create();\n \n   // op | (usage << 8) => ModeAndExcpetion\n-  private Map<Integer, ModeAndException> audioRestrictions = new HashMap<>();\n+  private final Map<Integer, ModeAndException> audioRestrictions = new HashMap<>();\n \n   private Context context;\n \n@@ -120,21 +126,96 @@ public void setMode(String op, int uid, String packageName, int mode) {\n   @HiddenApi\n   @RequiresPermission(android.Manifest.permission.MANAGE_APP_OPS_MODES)\n   public void setMode(int op, int uid, String packageName, int mode) {\n-    Integer oldMode = appModeMap.put(getOpMapKey(uid, packageName, op), mode);\n-    OnOpChangedListener listener = appOpListeners.get(getListenerKey(op, packageName));\n+    Integer oldMode = appModeMap.put(Key.create(uid, packageName, op), mode);\n+    OnOpChangedListener listener = appOpListeners.get(Key.create(null, packageName, op));\n     if (listener != null && !Objects.equals(oldMode, mode)) {\n       String[] sOpToString = ReflectionHelpers.getStaticField(AppOpsManager.class, \"sOpToString\");\n       listener.onOpChanged(sOpToString[op], packageName);\n     }\n   }\n \n+  /**\n+   * Returns app op details for all packages for which one of {@link #setMode} methods was used to\n+   * set the value of one of the given app ops (it does return those set to 'default' mode, while\n+   * the true implementation usually doesn't). Also, we don't enforce any permission checks which\n+   * might be needed in the true implementation.\n+   *\n+   * @param ops The set of operations you are interested in, or null if you want all of them.\n+   * @return app ops information about each package, containing only ops that were specified as an\n+   *     argument\n+   */\n+  @Implementation(minSdk = Q)\n+  @HiddenApi\n+  @SystemApi\n+  @NonNull\n+  protected List<PackageOps> getPackagesForOps(@Nullable String[] ops) {\n+    List<PackageOps> result = null;\n+\n+    if (ops == null) {\n+      int[] intOps = null;\n+      result = getPackagesForOps(intOps);\n+    } else {\n+      List<Integer> intOpsList = new ArrayList<>();\n+      for (String op : ops) {\n+        intOpsList.add(AppOpsManager.strOpToOp(op));\n+      }\n+      result = getPackagesForOps(intOpsList.stream().mapToInt(i -> i).toArray());\n+    }\n+\n+    return result != null ? result : new ArrayList<>();\n+  }\n+\n+  /**\n+   * Returns app op details for all packages for which one of {@link #setMode} methods was used to\n+   * set the value of one of the given app ops (it does return those set to 'default' mode, while\n+   * the true implementation usually doesn't). Also, we don't enforce any permission checks which\n+   * might be needed in the true implementation.\n+   *\n+   * @param ops The set of operations you are interested in, or null if you want all of them.\n+   * @return app ops information about each package, containing only ops that were specified as an\n+   *     argument\n+   */\n+  @Implementation(minSdk = KITKAT) // to be consistent with setMode() shadow implementations\n+  @HiddenApi\n+  protected List<PackageOps> getPackagesForOps(int[] ops) {\n+    Set<Integer> relevantOps;\n+    if (ops != null) {\n+      relevantOps = IntStream.of(ops).boxed().collect(toSet());\n+    } else {\n+      relevantOps = new HashSet<>();\n+    }\n+\n+    // Aggregating op data per each package.\n+    // (uid, packageName) => [(op, mode)]\n+    Multimap<Key, OpEntry> perPackageMap = MultimapBuilder.hashKeys().hashSetValues().build();\n+    for (Map.Entry<Key, Integer> appOpInfo : appModeMap.entrySet()) {\n+      Key key = appOpInfo.getKey();\n+      if (ops == null || relevantOps.contains(key.getOpCode())) {\n+        Key packageKey = Key.create(key.getUid(), key.getPackageName(), null);\n+        OpEntry opEntry = toOpEntry(key.getOpCode(), appOpInfo.getValue());\n+        perPackageMap.put(packageKey, opEntry);\n+      }\n+    }\n+\n+    List<PackageOps> result = new ArrayList<>();\n+    // Creating resulting PackageOps objects using all op info collected per package.\n+    for (Map.Entry<Key, Collection<OpEntry>> packageInfo : perPackageMap.asMap().entrySet()) {\n+      Key key = packageInfo.getKey();\n+      result.add(\n+          new PackageOps(\n+              key.getPackageName(), key.getUid(), new ArrayList<>(packageInfo.getValue())));\n+    }\n+\n+    return result.isEmpty() ? null : result;\n+  }\n+\n   @Implementation(minSdk = Q)\n   public int unsafeCheckOpNoThrow(String op, int uid, String packageName) {\n     return checkOpNoThrow(AppOpsManager.strOpToOp(op), uid, packageName);\n   }\n \n   private int unsafeCheckOpRawNoThrow(int op, int uid, String packageName) {\n-    Integer mode = appModeMap.get(getOpMapKey(uid, packageName, op));\n+    Integer mode = appModeMap.get(Key.create(uid, packageName, op));\n     if (mode == null) {\n       return AppOpsManager.MODE_ALLOWED;\n     }\n@@ -147,15 +228,15 @@ protected int startOp(\n       String op, int uid, String packageName, String attributionTag, String message) {\n     int mode = unsafeCheckOpRawNoThrow(op, uid, packageName);\n     if (mode == AppOpsManager.MODE_ALLOWED) {\n-      longRunningOp.add(getOpMapKey(uid, packageName, AppOpsManager.strOpToOp(op)));\n+      longRunningOp.add(Key.create(uid, packageName, AppOpsManager.strOpToOp(op)));\n     }\n     return mode;\n   }\n \n   /** Removes a fake long-running operation from the set. */\n   @Implementation(minSdk = R)\n   protected void finishOp(String op, int uid, String packageName, String attributionTag) {\n-    longRunningOp.remove(getOpMapKey(uid, packageName, AppOpsManager.strOpToOp(op)));\n+    longRunningOp.remove(Key.create(uid, packageName, AppOpsManager.strOpToOp(op)));\n   }\n \n   /**\n@@ -164,7 +245,7 @@ protected void finishOp(String op, int uid, String packageName, String attributi\n    */\n   @Implementation(minSdk = R)\n   protected boolean isOpActive(String op, int uid, String packageName) {\n-    return longRunningOp.contains(getOpMapKey(uid, packageName, AppOpsManager.strOpToOp(op)));\n+    return longRunningOp.contains(Key.create(uid, packageName, AppOpsManager.strOpToOp(op)));\n   }\n \n   /**\n@@ -198,7 +279,7 @@ public int checkOpNoThrow(int op, int uid, String packageName) {\n \n   @Implementation(minSdk = KITKAT)\n   public int noteOp(int op, int uid, String packageName) {\n-    mStoredOps.put(getInternalKey(uid, packageName), op);\n+    storedOps.put(Key.create(uid, packageName, null), op);\n \n     // Permission check not currently implemented in this shadow.\n     return AppOpsManager.MODE_ALLOWED;\n@@ -211,7 +292,7 @@ protected int noteOp(int op, int uid, String packageName, String attributionTag,\n \n   @Implementation(minSdk = KITKAT)\n   protected int noteOpNoThrow(int op, int uid, String packageName) {\n-    mStoredOps.put(getInternalKey(uid, packageName), op);\n+    storedOps.put(Key.create(uid, packageName, null), op);\n     return checkOpNoThrow(op, uid, packageName);\n   }\n \n@@ -228,7 +309,7 @@ protected int noteOpNoThrow(\n   @Implementation(minSdk = M, maxSdk = Q)\n   @HiddenApi\n   protected int noteProxyOpNoThrow(int op, String proxiedPackageName) {\n-    mStoredOps.put(getInternalKey(Binder.getCallingUid(), proxiedPackageName), op);\n+    storedOps.put(Key.create(Binder.getCallingUid(), proxiedPackageName, null), op);\n     return checkOpNoThrow(op, Binder.getCallingUid(), proxiedPackageName);\n   }\n \n@@ -243,9 +324,9 @@ protected int noteProxyOpNoThrow(int op, String proxiedPackageName) {\n     }\n \n     List<OpEntry> opEntries = new ArrayList<>();\n-    for (Integer op : mStoredOps.get(getInternalKey(uid, packageName))) {\n+    for (Integer op : storedOps.get(Key.create(uid, packageName, null))) {\n       if (opFilter.isEmpty() || opFilter.contains(op)) {\n-        opEntries.add(toOpEntry(op));\n+        opEntries.add(toOpEntry(op, AppOpsManager.MODE_ALLOWED));\n       }\n     }\n \n@@ -313,7 +394,7 @@ public ModeAndException getRestriction(int code, @AttributeUsage int usage) {\n   @HiddenApi\n   @RequiresPermission(value = android.Manifest.permission.WATCH_APPOPS)\n   protected void startWatchingMode(int op, String packageName, OnOpChangedListener callback) {\n-    appOpListeners.put(getListenerKey(op, packageName), callback);\n+    appOpListeners.put(Key.create(null, packageName, op), callback);\n   }\n \n   @Implementation(minSdk = KITKAT)\n@@ -322,20 +403,20 @@ protected void stopWatchingMode(OnOpChangedListener callback) {\n     appOpListeners.inverse().remove(callback);\n   }\n \n-  protected OpEntry toOpEntry(Integer op) {\n+  protected OpEntry toOpEntry(Integer op, int mode) {\n     if (RuntimeEnvironment.getApiLevel() < Build.VERSION_CODES.M) {\n       return ReflectionHelpers.callConstructor(\n           OpEntry.class,\n           ClassParameter.from(int.class, op),\n-          ClassParameter.from(int.class, AppOpsManager.MODE_ALLOWED),\n+          ClassParameter.from(int.class, mode),\n           ClassParameter.from(long.class, OP_TIME),\n           ClassParameter.from(long.class, REJECT_TIME),\n           ClassParameter.from(int.class, DURATION));\n     } else if (RuntimeEnvironment.getApiLevel() < Build.VERSION_CODES.Q) {\n       return ReflectionHelpers.callConstructor(\n           OpEntry.class,\n           ClassParameter.from(int.class, op),\n-          ClassParameter.from(int.class, AppOpsManager.MODE_ALLOWED),\n+          ClassParameter.from(int.class, mode),\n           ClassParameter.from(long.class, OP_TIME),\n           ClassParameter.from(long.class, REJECT_TIME),\n           ClassParameter.from(int.class, DURATION),\n@@ -364,7 +445,7 @@ protected OpEntry toOpEntry(Integer op) {\n           OpEntry.class,\n           ClassParameter.from(int.class, op),\n           ClassParameter.from(boolean.class, false),\n-          ClassParameter.from(int.class, AppOpsManager.MODE_ALLOWED),\n+          ClassParameter.from(int.class, mode),\n           ClassParameter.from(LongSparseLongArray.class, accessTimes),\n           ClassParameter.from(LongSparseLongArray.class, rejectTimes),\n           ClassParameter.from(LongSparseLongArray.class, durations),\n@@ -384,26 +465,30 @@ protected OpEntry toOpEntry(Integer op) {\n \n       return new OpEntry(\n           op,\n-          AppOpsManager.MODE_ALLOWED,\n+          mode,\n           Collections.singletonMap(\n               null, new AttributedOpEntry(op, false, accessEvents, rejectEvents)));\n     }\n   }\n \n-  private static String getInternalKey(int uid, String packageName) {\n-    return uid + \"|\" + packageName;\n-  }\n-\n-  private static String getOpMapKey(int uid, String packageName, int opInt) {\n-    return String.format(\"%s|%s|%s\", uid, packageName, opInt);\n-  }\n-\n   private static int getAudioRestrictionKey(int code, @AttributeUsage int usage) {\n     return code | (usage << 8);\n   }\n \n-  private static String getListenerKey(int op, String packageName) {\n-    return String.format(\"%s|%s\", op, packageName);\n+  @AutoValue\n+  abstract static class Key {\n+    @Nullable\n+    abstract Integer getUid();\n+\n+    @Nullable\n+    abstract String getPackageName();\n+\n+    @Nullable\n+    abstract Integer getOpCode();\n+\n+    static Key create(Integer uid, String packageName, Integer opCode) {\n+      return new AutoValue_ShadowAppOpsManager_Key(uid, packageName, opCode);\n+    }\n   }\n \n   /** Class holding usage mode and excpetion packages. */"
  },
  {
    "sha": "ae0fdffe2959e86edd399b634ae7e4cf928621d8",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java",
    "status": "modified",
    "additions": 31,
    "deletions": 16,
    "changes": 47,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -3,6 +3,7 @@\n import static android.os.Build.VERSION_CODES.KITKAT;\n import static android.os.Build.VERSION_CODES.L;\n import static android.os.Build.VERSION_CODES.LOLLIPOP;\n+import static android.os.Build.VERSION_CODES.O;\n \n import android.appwidget.AppWidgetManager;\n import android.appwidget.AppWidgetProvider;\n@@ -21,6 +22,7 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.stream.Collectors;\n import org.robolectric.RuntimeEnvironment;\n import org.robolectric.annotation.HiddenApi;\n import org.robolectric.annotation.Implementation;\n@@ -32,8 +34,7 @@\n @Implements(AppWidgetManager.class)\n public class ShadowAppWidgetManager {\n \n-  @RealObject\n-  private AppWidgetManager realAppWidgetManager;\n+  @RealObject private AppWidgetManager realAppWidgetManager;\n \n   private Context context;\n   private final Map<Integer, WidgetInfo> widgetInfos = new HashMap<>();\n@@ -106,6 +107,17 @@ protected void updateAppWidget(int appWidgetId, RemoteViews views) {\n     return ImmutableList.copyOf(installedProvidersForProfile.get(profile));\n   }\n \n+  @Implementation(minSdk = O)\n+  protected List<AppWidgetProviderInfo> getInstalledProvidersForPackage(\n+      String packageName, UserHandle profile) {\n+    return ImmutableList.copyOf(\n+        installedProvidersForProfile.get(profile).stream()\n+            .filter(\n+                (AppWidgetProviderInfo providerInfo) ->\n+                    providerInfo.provider.getPackageName().equals(packageName))\n+            .collect(Collectors.toList()));\n+  }\n+\n   public void addInstalledProvider(AppWidgetProviderInfo appWidgetProviderInfo) {\n     installedProviders.add(appWidgetProviderInfo);\n   }\n@@ -133,7 +145,8 @@ protected AppWidgetProviderInfo getAppWidgetInfo(int appWidgetId) {\n     return widgetInfo.info;\n   }\n \n-  @HiddenApi @Implementation\n+  @HiddenApi\n+  @Implementation\n   public void bindAppWidgetId(int appWidgetId, ComponentName provider) {\n     WidgetInfo widgetInfo = new WidgetInfo(provider);\n     widgetInfos.put(appWidgetId, widgetInfo);\n@@ -155,8 +168,8 @@ protected boolean bindAppWidgetIdIfAllowed(int appWidgetId, ComponentName provid\n   }\n \n   /**\n-   * Triggers a reapplication of the most recent set of actions against the widget, which is what happens when the\n-   * phone is rotated. Does not attempt to simulate a change in screen geometry.\n+   * Triggers a reapplication of the most recent set of actions against the widget, which is what\n+   * happens when the phone is rotated. Does not attempt to simulate a change in screen geometry.\n    *\n    * @param appWidgetId the ID of the widget to be affected\n    */\n@@ -170,22 +183,26 @@ public void reconstructWidgetViewAsIfPhoneWasRotated(int appWidgetId) {\n    * Creates a widget by inflating its layout.\n    *\n    * @param appWidgetProviderClass the app widget provider class\n-   * @param widgetLayoutId         id of the layout to inflate\n+   * @param widgetLayoutId id of the layout to inflate\n    * @return the ID of the new widget\n    */\n-  public int createWidget(Class<? extends AppWidgetProvider> appWidgetProviderClass, int widgetLayoutId) {\n+  public int createWidget(\n+      Class<? extends AppWidgetProvider> appWidgetProviderClass, int widgetLayoutId) {\n     return createWidgets(appWidgetProviderClass, widgetLayoutId, 1)[0];\n   }\n \n   /**\n    * Creates a bunch of widgets by inflating the same layout multiple times.\n    *\n    * @param appWidgetProviderClass the app widget provider class\n-   * @param widgetLayoutId         id of the layout to inflate\n-   * @param howManyToCreate        number of new widgets to create\n+   * @param widgetLayoutId id of the layout to inflate\n+   * @param howManyToCreate number of new widgets to create\n    * @return the IDs of the new widgets\n    */\n-  public int[] createWidgets(Class<? extends AppWidgetProvider> appWidgetProviderClass, int widgetLayoutId, int howManyToCreate) {\n+  public int[] createWidgets(\n+      Class<? extends AppWidgetProvider> appWidgetProviderClass,\n+      int widgetLayoutId,\n+      int howManyToCreate) {\n     AppWidgetProvider appWidgetProvider = ReflectionHelpers.callConstructor(appWidgetProviderClass);\n \n     int[] newWidgetIds = new int[howManyToCreate];\n@@ -223,19 +240,17 @@ public AppWidgetProvider getAppWidgetProviderFor(int widgetId) {\n   }\n \n   /**\n-   * Enables testing of widget behavior when all of the views are recreated on every\n-   * update. This is useful for ensuring that your widget will behave correctly even\n-   * if it is restarted by the OS between events.\n+   * Enables testing of widget behavior when all of the views are recreated on every update. This is\n+   * useful for ensuring that your widget will behave correctly even if it is restarted by the OS\n+   * between events.\n    *\n    * @param alwaysRecreate whether or not to always recreate the views\n    */\n   public void setAlwaysRecreateViewsDuringUpdate(boolean alwaysRecreate) {\n     alwaysRecreateViewsDuringUpdate = alwaysRecreate;\n   }\n \n-  /**\n-   * @return the state of the{@code alwaysRecreateViewsDuringUpdate} flag\n-   */\n+  /** @return the state of the{@code alwaysRecreateViewsDuringUpdate} flag */\n   public boolean getAlwaysRecreateViewsDuringUpdate() {\n     return alwaysRecreateViewsDuringUpdate;\n   }"
  },
  {
    "sha": "5e500fc4b090071346b7c52a9f89b3bc8e326de1",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -40,6 +40,7 @@\n @SuppressWarnings({\"UnusedDeclaration\"})\n @Implements(value = AudioManager.class, looseSignatures = true)\n public class ShadowAudioManager {\n+\n   public static final int MAX_VOLUME_MUSIC_DTMF = 15;\n   public static final int DEFAULT_MAX_VOLUME = 7;\n   public static final int MIN_VOLUME = 0;\n@@ -166,6 +167,7 @@ protected int abandonAudioFocus(AudioManager.OnAudioFocusChangeListener l) {\n    */\n   @Implementation(minSdk = O)\n   protected int abandonAudioFocusRequest(android.media.AudioFocusRequest audioFocusRequest) {\n+    lastAbandonedAudioFocusListener = audioFocusRequest.getOnAudioFocusChangeListener();\n     lastAbandonedAudioFocusRequest = audioFocusRequest;\n     return nextResponseValue;\n   }\n@@ -637,7 +639,7 @@ private AudioFocusRequest(\n     }\n \n     private AudioFocusRequest(android.media.AudioFocusRequest audioFocusRequest) {\n-      this.listener = null;\n+      this.listener = audioFocusRequest.getOnAudioFocusChangeListener();\n       this.streamType = this.durationHint = -1;\n       this.audioFocusRequest = audioFocusRequest;\n     }"
  },
  {
    "sha": "b1632bf5e4f09340b488ef7c54c417439a8435d8",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -88,6 +88,7 @@ protected static Bitmap decodeFile(String pathName) {\n     return decodeFile(pathName, null);\n   }\n \n+  @SuppressWarnings(\"Var\")\n   @Implementation\n   protected static Bitmap decodeFile(String pathName, BitmapFactory.Options options) {\n     // If a real file is used, attempt to get the image size from that file.\n@@ -113,7 +114,7 @@ protected static Bitmap decodeFile(String pathName, BitmapFactory.Options option\n     return bitmap;\n   }\n \n-  @SuppressWarnings(\"ObjectToString\")\n+  @SuppressWarnings({\"ObjectToString\", \"Var\"})\n   @Implementation\n   protected static Bitmap decodeFileDescriptor(\n       FileDescriptor fd, Rect outPadding, BitmapFactory.Options opts) {"
  },
  {
    "sha": "6f0a9ec975b222bbd22b8669160e347116e40c8b",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowBugreportManager.java",
    "status": "modified",
    "additions": 20,
    "deletions": 0,
    "changes": 20,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBugreportManager.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBugreportManager.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBugreportManager.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -1,6 +1,7 @@\n package org.robolectric.shadows;\n \n import static android.os.Build.VERSION_CODES.Q;\n+import static android.os.Build.VERSION_CODES.R;\n \n import android.os.BugreportManager;\n import android.os.BugreportManager.BugreportCallback;\n@@ -25,6 +26,7 @@\n   private ParcelFileDescriptor screenshotFd;\n   private Executor executor;\n   private BugreportCallback callback;\n+  private boolean bugreportRequested;\n \n   /**\n    * Starts a bugreport with which can execute callback methods on the provided executor.\n@@ -50,6 +52,18 @@ protected void startBugreport(\n     }\n   }\n \n+  /**\n+   * Normally requests the platform/system to take a bugreport and make the final bugreport\n+   * available to the user.\n+   *\n+   * <p>This implementation just sets a boolean recording that the method was invoked.\n+   */\n+  @Implementation(minSdk = R)\n+  protected void requestBugreport(\n+      BugreportParams params, CharSequence shareTitle, CharSequence shareDescription) {\n+    this.bugreportRequested = true;\n+  }\n+\n   /** Cancels bugreport in progress and executes {@link BugreportCallback#onError}. */\n   @Implementation\n   protected void cancelBugreport() {\n@@ -87,6 +101,11 @@ public boolean isBugreportInProgress() {\n     return executor != null && callback != null;\n   }\n \n+  /** Returns true if {@link #requestBugreport} was called. */\n+  public boolean wasBugreportRequested() {\n+    return bugreportRequested;\n+  }\n+\n   /**\n    * Simulates if the calling process has the required permissions to call BugreportManager methods.\n    *\n@@ -116,5 +135,6 @@ private void resetParams() {\n     screenshotFd = null;\n     executor = null;\n     callback = null;\n+    bugreportRequested = false;\n   }\n }"
  },
  {
    "sha": "3f821b7d647f4d0154ae03d29a6d906d2f0aa98d",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java",
    "status": "modified",
    "additions": 19,
    "deletions": 10,
    "changes": 29,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextWrapper.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -16,8 +16,7 @@\n @Implements(ContextWrapper.class)\n public class ShadowContextWrapper {\n \n-  @RealObject\n-  private ContextWrapper realContextWrapper;\n+  @RealObject private ContextWrapper realContextWrapper;\n \n   /** Returns the broadcast intents sent during the tests (for all users). */\n   public List<Intent> getBroadcastIntents() {\n@@ -98,8 +97,8 @@ public Intent getNextStartedService() {\n   }\n \n   /**\n-   * Returns the most recent {@code Intent} started by\n-   * {@link android.content.Context#startService(android.content.Intent)} without consuming it.\n+   * Returns the most recent {@code Intent} started by {@link\n+   * android.content.Context#startService(android.content.Intent)} without consuming it.\n    *\n    * @return the most recently started {@code Intent}\n    */\n@@ -108,17 +107,27 @@ public Intent peekNextStartedService() {\n   }\n \n   /**\n-   * Clears all {@code Intent} started by\n-   * {@link android.content.Context#startService(android.content.Intent)}.\n+   * Returns all {@code Intent} started by {@link #startService(android.content.Intent)} without\n+   * consuming them.\n+   *\n+   * @return the list of {@code Intent}\n+   */\n+  public List<Intent> getAllStartedServices() {\n+    return getShadowInstrumentation().getAllStartedServices();\n+  }\n+\n+  /**\n+   * Clears all {@code Intent} started by {@link\n+   * android.content.Context#startService(android.content.Intent)}.\n    */\n   public void clearStartedServices() {\n     getShadowInstrumentation().clearStartedServices();\n   }\n \n   /**\n-   * Consumes the {@code Intent} requested to stop a service by\n-   * {@link android.content.Context#stopService(android.content.Intent)}\n-   * from the bottom of the stack of stop requests.\n+   * Consumes the {@code Intent} requested to stop a service by {@link\n+   * android.content.Context#stopService(android.content.Intent)} from the bottom of the stack of\n+   * stop requests.\n    */\n   public Intent getNextStoppedService() {\n     return getShadowInstrumentation().getNextStoppedService();\n@@ -137,7 +146,7 @@ public void grantPermissions(int pid, int uid, String... permissions) {\n   /**\n    * Revoke the given permissions for the current process and user.\n    *\n-   * Has no effect if permissions were not previously granted.\n+   * <p>Has no effect if permissions were not previously granted.\n    */\n   public void denyPermissions(String... permissionNames) {\n     getShadowInstrumentation().denyPermissions(permissionNames);"
  },
  {
    "sha": "76ed5068c88488a3074ecee159a9da3332484519",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -15,6 +15,7 @@\n import android.util.SparseArray;\n import android.view.Display;\n import android.view.DisplayInfo;\n+import com.google.common.annotations.VisibleForTesting;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.TreeMap;\n@@ -65,6 +66,11 @@ public static synchronized DisplayManagerGlobal getInstance() {\n     return instance;\n   }\n \n+  @VisibleForTesting\n+  static DisplayManagerGlobal getGlobalInstance() {\n+    return instance;\n+  }\n+\n   @Implementation\n   protected WifiDisplayStatus getWifiDisplayStatus() {\n     return new WifiDisplayStatus();"
  },
  {
    "sha": "68532aa71f9bd75a7a2145be4f0a7bfbdf24a5f0",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java",
    "status": "modified",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -793,6 +793,20 @@ void clearStartedServices() {\n     startedServices.clear();\n   }\n \n+  /**\n+   * Returns all {@code Intent} started by {@link #startService(android.content.Intent)} without\n+   * consuming them.\n+   *\n+   * @return the list of {@code Intent}\n+   */\n+  List<Intent> getAllStartedServices() {\n+    ArrayList<Intent> startedServicesIntents = new ArrayList<>();\n+    for (Intent.FilterComparison filterComparison : startedServices) {\n+      startedServicesIntents.add(filterComparison.getIntent());\n+    }\n+    return startedServicesIntents;\n+  }\n+\n   /**\n    * Consumes the {@code Intent} requested to stop a service by {@link\n    * #stopService(android.content.Intent)} from the bottom of the stack of stop requests."
  },
  {
    "sha": "f69ec92e5f57a21450cf96cace4f6901e31c599e",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -904,6 +904,10 @@ public void setEnabled(boolean enabled) {\n         // this sets LOCATION_MODE and LOCATION_PROVIDERS_ALLOWED\n         setLocationModeInternal(newLocationMode);\n       } else if (RuntimeEnvironment.getApiLevel() >= Q) {\n+        if (enabled == this.enabled) {\n+          return;\n+        }\n+\n         this.enabled = enabled;\n         // set LOCATION_PROVIDERS_ALLOWED directly, without setting LOCATION_MODE. do this even\n         // though LOCATION_PROVIDERS_ALLOWED is not the source of truth - we keep it up to date, but"
  },
  {
    "sha": "10eddbe96f0e73807d79c66fb74558cdaf947f6a",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java",
    "status": "modified",
    "additions": 42,
    "deletions": 14,
    "changes": 56,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSettings.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -6,9 +6,13 @@\n import static android.os.Build.VERSION_CODES.LOLLIPOP;\n import static android.os.Build.VERSION_CODES.M;\n import static android.os.Build.VERSION_CODES.P;\n+import static android.os.Build.VERSION_CODES.Q;\n+import static android.os.Build.VERSION_CODES.R;\n+import static android.provider.Settings.Secure.LOCATION_MODE_OFF;\n \n import android.content.ContentResolver;\n import android.content.Context;\n+import android.content.Intent;\n import android.location.LocationManager;\n import android.os.Build;\n import android.provider.Settings;\n@@ -180,7 +184,7 @@ protected static float getFloat(ContentResolver cr, String name)\n         SECURE_DEFAULTS.put(Secure.LOCATION_MODE, Secure.LOCATION_MODE_BATTERY_SAVING);\n         SECURE_DEFAULTS.put(Secure.LOCATION_PROVIDERS_ALLOWED, \"network\");\n       } else {\n-        SECURE_DEFAULTS.put(Secure.LOCATION_MODE, Secure.LOCATION_MODE_OFF);\n+        SECURE_DEFAULTS.put(Secure.LOCATION_MODE, LOCATION_MODE_OFF);\n       }\n     }\n \n@@ -207,32 +211,56 @@ static boolean updateEnabledProviders(ContentResolver cr, String provider, boole\n         providers.addAll(Arrays.asList(oldProviders.split(\",\")));\n       }\n \n+      if (enabled == oldProviders.contains(provider)) {\n+        return true;\n+      }\n+\n       if (enabled) {\n         providers.add(provider);\n       } else {\n         providers.remove(provider);\n       }\n \n       String newProviders = TextUtils.join(\",\", providers.toArray());\n-      return Settings.Secure.putString(\n-          cr, Settings.Secure.LOCATION_PROVIDERS_ALLOWED, newProviders);\n+      boolean r =\n+          Settings.Secure.putString(cr, Settings.Secure.LOCATION_PROVIDERS_ALLOWED, newProviders);\n+\n+      Intent providersBroadcast = new Intent(LocationManager.PROVIDERS_CHANGED_ACTION);\n+      if (RuntimeEnvironment.getApiLevel() >= Q) {\n+        providersBroadcast.putExtra(LocationManager.EXTRA_PROVIDER_NAME, provider);\n+      }\n+      if (RuntimeEnvironment.getApiLevel() >= R) {\n+        providersBroadcast.putExtra(LocationManager.EXTRA_PROVIDER_ENABLED, enabled);\n+      }\n+      RuntimeEnvironment.getApplication().sendBroadcast(providersBroadcast);\n+\n+      return r;\n     }\n \n     @Implementation\n     protected static boolean putInt(ContentResolver cr, String name, int value) {\n       boolean changed = !Objects.equals(get(cr).put(name, value), value);\n \n-      if (Settings.Secure.LOCATION_MODE.equals(name) && RuntimeEnvironment.getApiLevel() <= P) {\n-        // do this after setting location mode but before invoking contentobservers, so that\n-        // observers for both settings will see the correct values\n-        boolean gps =\n-            (value == Settings.Secure.LOCATION_MODE_SENSORS_ONLY\n-                || value == Settings.Secure.LOCATION_MODE_HIGH_ACCURACY);\n-        boolean network =\n-            (value == Settings.Secure.LOCATION_MODE_BATTERY_SAVING\n-                || value == Settings.Secure.LOCATION_MODE_HIGH_ACCURACY);\n-        Settings.Secure.setLocationProviderEnabled(cr, LocationManager.GPS_PROVIDER, gps);\n-        Settings.Secure.setLocationProviderEnabled(cr, LocationManager.NETWORK_PROVIDER, network);\n+      if (Settings.Secure.LOCATION_MODE.equals(name)) {\n+        if (RuntimeEnvironment.getApiLevel() <= P) {\n+          // do this after setting location mode but before invoking contentobservers, so that\n+          // observers for both settings will see the correct values\n+          boolean gps =\n+              (value == Settings.Secure.LOCATION_MODE_SENSORS_ONLY\n+                  || value == Settings.Secure.LOCATION_MODE_HIGH_ACCURACY);\n+          boolean network =\n+              (value == Settings.Secure.LOCATION_MODE_BATTERY_SAVING\n+                  || value == Settings.Secure.LOCATION_MODE_HIGH_ACCURACY);\n+          Settings.Secure.setLocationProviderEnabled(cr, LocationManager.GPS_PROVIDER, gps);\n+          Settings.Secure.setLocationProviderEnabled(cr, LocationManager.NETWORK_PROVIDER, network);\n+        }\n+\n+        Intent modeBroadcast = new Intent(LocationManager.MODE_CHANGED_ACTION);\n+        if (RuntimeEnvironment.getApiLevel() >= R) {\n+          modeBroadcast.putExtra(\n+              LocationManager.EXTRA_LOCATION_ENABLED, value != LOCATION_MODE_OFF);\n+        }\n+        RuntimeEnvironment.getApplication().sendBroadcast(modeBroadcast);\n       }\n \n       if (changed && cr != null) {"
  },
  {
    "sha": "c2e1a4c306ba3ad56c22432b512eb097be8cfc60",
    "filename": "shadows/framework/src/main/java/org/robolectric/shadows/ShadowXmlBlock.java",
    "status": "modified",
    "additions": 12,
    "deletions": 3,
    "changes": 15,
    "blob_url": "https://github.com/robolectric/robolectric/blob/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowXmlBlock.java",
    "raw_url": "https://github.com/robolectric/robolectric/raw/6cfcdb5153ae26fe24f3e0501024dd8e18223b51/shadows/framework/src/main/java/org/robolectric/shadows/ShadowXmlBlock.java",
    "contents_url": "https://api.github.com/repos/robolectric/robolectric/contents/shadows/framework/src/main/java/org/robolectric/shadows/ShadowXmlBlock.java?ref=6cfcdb5153ae26fe24f3e0501024dd8e18223b51",
    "patch": "@@ -144,28 +144,37 @@ protected static int nativeGetNamespace(int state) {\n   @Implementation(minSdk = VERSION_CODES.LOLLIPOP)\n   protected static int nativeGetNamespace(long state) {\n     ResXMLParser resXMLParser = getResXMLParser(state);\n+    if (resXMLParser == null) {\n+      return -1;\n+    }\n     return resXMLParser.getElementNamespaceID();\n   }\n \n   @Implementation(maxSdk = VERSION_CODES.KITKAT_WATCH)\n   protected static int nativeGetName(int state) {\n-    return (int)nativeGetName((long)state);\n+    return nativeGetName((long) state);\n   }\n \n   @Implementation(minSdk = VERSION_CODES.LOLLIPOP)\n   protected static int nativeGetName(long state) {\n     ResXMLParser resXMLParser = getResXMLParser(state);\n+    if (resXMLParser == null) {\n+      return -1;\n+    }\n     return resXMLParser.getElementNameID();\n   }\n \n   @Implementation(maxSdk = VERSION_CODES.KITKAT_WATCH)\n   protected static int nativeGetText(int state) {\n-    return (int)nativeGetText((long)state);\n+    return nativeGetText((long) state);\n   }\n \n   @Implementation(minSdk = VERSION_CODES.LOLLIPOP)\n   protected static int nativeGetText(long state) {\n     ResXMLParser resXMLParser = getResXMLParser(state);\n+    if (resXMLParser == null) {\n+      return -1;\n+    }\n     return resXMLParser.getTextID();\n   }\n \n@@ -346,6 +355,6 @@ protected static void nativeDestroy(long obj) {\n   }\n \n   private static ResXMLParser getResXMLParser(long state) {\n-    return Registries.NATIVE_RES_XML_PARSERS.getNativeObject(state);\n+    return Registries.NATIVE_RES_XML_PARSERS.peekNativeObject(state);\n   }\n }"
  }
]
