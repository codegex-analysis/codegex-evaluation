[
  {
    "sha": "1e83f3e6dc8df8e7538db0ffc6d5fc8b7f6b4feb",
    "filename": "Assignment11-DSA-Stack-Expression/Streams Capacity.xlsx",
    "status": "added",
    "additions": 0,
    "deletions": 0,
    "changes": 0,
    "blob_url": "https://github.com/meta-ameet-khemani/GET2021/blob/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/Streams%20Capacity.xlsx",
    "raw_url": "https://github.com/meta-ameet-khemani/GET2021/raw/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/Streams%20Capacity.xlsx",
    "contents_url": "https://api.github.com/repos/meta-ameet-khemani/GET2021/contents/Assignment11-DSA-Stack-Expression/Streams%20Capacity.xlsx?ref=d5b5b2f1f70d264368a8cfaf91d74b543a752a7f"
  },
  {
    "sha": "7fe5bea2ec79126cca53725f210ad0771f4bc460",
    "filename": "Assignment11-DSA-Stack-Expression/Student Alloted Stream.xlsx",
    "status": "added",
    "additions": 0,
    "deletions": 0,
    "changes": 0,
    "blob_url": "https://github.com/meta-ameet-khemani/GET2021/blob/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/Student%20Alloted%20Stream.xlsx",
    "raw_url": "https://github.com/meta-ameet-khemani/GET2021/raw/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/Student%20Alloted%20Stream.xlsx",
    "contents_url": "https://api.github.com/repos/meta-ameet-khemani/GET2021/contents/Assignment11-DSA-Stack-Expression/Student%20Alloted%20Stream.xlsx?ref=d5b5b2f1f70d264368a8cfaf91d74b543a752a7f"
  },
  {
    "sha": "407271b88db8e8408a0e72b6af5b789ff879cf9a",
    "filename": "Assignment11-DSA-Stack-Expression/StudentPreferences.xlsx",
    "status": "added",
    "additions": 0,
    "deletions": 0,
    "changes": 0,
    "blob_url": "https://github.com/meta-ameet-khemani/GET2021/blob/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/StudentPreferences.xlsx",
    "raw_url": "https://github.com/meta-ameet-khemani/GET2021/raw/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/StudentPreferences.xlsx",
    "contents_url": "https://api.github.com/repos/meta-ameet-khemani/GET2021/contents/Assignment11-DSA-Stack-Expression/StudentPreferences.xlsx?ref=d5b5b2f1f70d264368a8cfaf91d74b543a752a7f"
  },
  {
    "sha": "28881812af04a9cac6a8d1093213f4c303512732",
    "filename": "Assignment11-DSA-Stack-Expression/src/com/metacube/Q1Stack/InfixExpression.java",
    "status": "added",
    "additions": 166,
    "deletions": 0,
    "changes": 166,
    "blob_url": "https://github.com/meta-ameet-khemani/GET2021/blob/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/Q1Stack/InfixExpression.java",
    "raw_url": "https://github.com/meta-ameet-khemani/GET2021/raw/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/Q1Stack/InfixExpression.java",
    "contents_url": "https://api.github.com/repos/meta-ameet-khemani/GET2021/contents/Assignment11-DSA-Stack-Expression/src/com/metacube/Q1Stack/InfixExpression.java?ref=d5b5b2f1f70d264368a8cfaf91d74b543a752a7f",
    "patch": "@@ -0,0 +1,166 @@\n+package com.metacube.Q1Stack;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * InfixExpression used to evaluate the infix expression\n+ * @author ameet.khemani_metacu\n+ *\n+ */\n+public class InfixExpression {\n+\n+\t/**\n+\t * evaluating infix expression\n+\t * @param expression which needs to be evaluated\n+\t * @return evaluated value of type Integer\n+\t */\n+\tpublic static Integer evaluateString (String expression) {\n+\t\t\n+\t\t// split expression with white space\n+\t\tString expressionTerms[] = expression.split(\" \");\n+\t\t\n+\t\t// create a stack for storing operands\n+\t\tStack<Integer> operands = new Stack<Integer>();\n+\t\t\n+\t\t//creates a stack for storing operators\n+\t\tStack<String> operators = new Stack<String>();\n+\t\t\n+\t\t// get the length of terms in expression\n+\t\tInteger length = expressionTerms.length;\n+\t\t\n+\t\t// iterate through terms in expression\n+\t\tfor (int termIndex = 0; termIndex < length; termIndex++) {\n+\t\t\ttry {\n+\t\t\t\t\n+\t\t\t\t// expecting first  term as operand of type Integer\n+\t\t\t\tInteger number = Integer.parseInt(expressionTerms[termIndex]);\n+\t\t\t\t\n+\t\t\t\t// adding to operand stack\n+\t\t\t\toperands.push(number);\n+\t\t\t} catch (Exception ex) {\n+\t\t\t\t\n+\t\t\t\t// checking for opening curly bracket\n+\t\t\t\tif (expressionTerms[termIndex].equalsIgnoreCase(\"(\")) {\n+\t\t\t\t\t\n+\t\t\t\t\t// adding to operator stack\n+\t\t\t\t\toperators.push(expressionTerms[termIndex]);\n+\t\t\t\t} else if (expressionTerms[termIndex].equalsIgnoreCase(\")\")) {\n+\t\t\t\t\t\n+\t\t\t\t\t// if closing curly bracket is found then evaluate the operator with top 2 operands and store them back\n+\t\t\t\t\twhile (!operators.getTop().equalsIgnoreCase(\"(\")) {\n+\t\t\t\t\t\tInteger evaluatedValue = evaluate (operands.pop(), operands.pop(), operators.pop());\n+\t\t\t\t\t\toperands.push(evaluatedValue);\n+\t\t\t\t\t}\n+\t\t\t\t\toperators.pop();\n+\t\t\t\t} else {\n+\t\t\t\t\t\n+\t\t\t\t\t// iterate through all operators untill we get the next highest precedence operator\n+\t\t\t\t\twhile (!operators.isEmpty() && checkPrecedence(expressionTerms[termIndex], operators.getTop()) && !operands.isEmpty()) {\n+\t\t\t\t\t\tInteger evaluatedValue = evaluate (operands.pop(), operands.pop(), operators.pop());\n+\t\t\t\t\t\toperands.push(evaluatedValue);\n+\t\t\t\t\t}\n+\t\t\t\t\toperators.push(expressionTerms[termIndex]);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\t// if their remains some operators then evaluates them and add them\n+\t\twhile (!operators.isEmpty()) {\n+\t\t\tInteger evaluatedValue = evaluate (operands.pop(), operands.pop(), operators.pop());\n+\t\t\toperands.push (evaluatedValue);\n+\t\t}\n+\t\treturn operands.pop();\n+\t}\n+\t\n+\t/**\n+\t * Used to check the precedence of 2 operators\n+\t * @param operator1\n+\t * @param operator2\n+\t * @return true if first one is of higher precedence else false\n+\t */\n+\tprivate static boolean checkPrecedence (String operator1, String operator2) {\n+\t\t\n+\t\t// creates a list of arithmetic operators\n+\t\tList<String> arithmeticOperators = new ArrayList<String>(Arrays.asList(\"+\", \"-\", \"*\", \"/\"));\n+\t\t\n+\t\t// creates a list of relational operators\n+\t\tList<String> relationalOperators = new ArrayList<String>(Arrays.asList(\"==\", \"!=\", \">\", \"<\", \"<=\", \">=\"));\n+\t\t\n+\t\t// creates a list of conditional operators\n+\t\tList<String> conditionalOperators = new ArrayList<String>(Arrays.asList(\"&&\", \"||\", \"!\"));\n+\t\t\n+\t\tif (operator2.equalsIgnoreCase(\"(\") || operator2.equalsIgnoreCase(\")\")) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (arithmeticOperators.contains(operator1)) {\n+\t\t\tif (relationalOperators.contains(operator2) || conditionalOperators.contains(operator2)) {\n+\t\t\t\treturn false;\n+\t\t\t} else {\n+\t\t\t\tif ((operator1.equals(\"*\") || operator1.equals(\"/\")) && operator2.equals(\"+\") || operator2.equals(\"-\")) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else if (relationalOperators.contains(operator1)) {\n+\t\t\tif (arithmeticOperators.contains(operator2)) {\n+\t\t\t\treturn true;\n+\t\t\t} else if (conditionalOperators.contains(operator2)) {\n+\t\t\t\treturn false;\n+\t\t\t} else {\n+\t\t\t\tif ((operator1.equalsIgnoreCase(\"<\") || operator1.equalsIgnoreCase(\"<=\") || operator1.equalsIgnoreCase(\">\") || operator1.equalsIgnoreCase(\">=\")) &&\n+\t\t\t\t\t(operator2.equalsIgnoreCase(\"==\") || operator2.equalsIgnoreCase(\"!=\"))) {\n+\t\t\t\t\t\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (conditionalOperators.contains(operator2)) {\n+\t\t\t\treturn false;\n+\t\t\t} else {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Evaluating a small expression\n+\t * @param number2\n+\t * @param number1\n+\t * @param operator\n+\t * @return evaluated value as Integer\n+\t */\n+\tprivate static Integer evaluate (Integer number2, Integer number1, String operator) {\n+\t\tif (operator.equalsIgnoreCase(\"+\")) {\n+\t\t\treturn number1 + number2;\n+\t\t} else if (operator.equalsIgnoreCase(\"-\")) {\n+\t\t\treturn number1 - number2;\n+\t\t} else if (operator.equalsIgnoreCase(\"*\")) {\n+\t\t\treturn number1 * number2;\n+\t\t} else if (operator.equalsIgnoreCase(\"/\")) {\n+\t\t\treturn number1 / number2;\n+\t\t} else if (operator.equalsIgnoreCase(\">\")) {\n+\t\t\treturn number1 > number2 ? 1 : 2;\n+\t\t} else if (operator.equalsIgnoreCase(\"<\")) {\n+\t\t\treturn number1 < number2 ? 1 : 2;\n+\t\t} else if (operator.equalsIgnoreCase(\"==\")) {\n+\t\t\treturn number1 == number2 ? 1 : 2;\n+\t\t} else if (operator.equalsIgnoreCase(\"!=\")) {\n+\t\t\treturn number1 != number2 ? 1 : 2;\n+\t\t} else if (operator.equalsIgnoreCase(\"&&\")) {\n+\t\t\treturn (number1 != 0 && number2 != 0) ? 1 : 2;\n+\t\t} else if (operator.equalsIgnoreCase(\"||\")) {\n+\t\t\treturn (number1 != 0 && number2 != 0) ? 1 : 2;\n+\t\t}\n+\t\treturn 0;\n+\t}\n+\t\n+\tpublic static void main (String args[]) {\n+\t\tSystem.out.println(InfixExpression.evaluateString(\"3 / 3 * ( 5 * 2 )\"));\n+\t}\n+\t\n+}"
  },
  {
    "sha": "410ed05082a0455f440f3b1226189c56fc41aea3",
    "filename": "Assignment11-DSA-Stack-Expression/src/com/metacube/Q1Stack/Node.java",
    "status": "added",
    "additions": 19,
    "deletions": 0,
    "changes": 19,
    "blob_url": "https://github.com/meta-ameet-khemani/GET2021/blob/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/Q1Stack/Node.java",
    "raw_url": "https://github.com/meta-ameet-khemani/GET2021/raw/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/Q1Stack/Node.java",
    "contents_url": "https://api.github.com/repos/meta-ameet-khemani/GET2021/contents/Assignment11-DSA-Stack-Expression/src/com/metacube/Q1Stack/Node.java?ref=d5b5b2f1f70d264368a8cfaf91d74b543a752a7f",
    "patch": "@@ -0,0 +1,19 @@\n+package com.metacube.Q1Stack;\n+\n+/**\n+ * Node class represents a single node in stack\n+ * @author ameet.khemani_metacu\n+ *\n+ * @param <T>\n+ */\n+public class Node<T> {\n+\t\n+\tT data;\n+\tNode<T> next;\n+\t\n+\tpublic Node (T data) {\n+\t\tthis.data = data;\n+\t\tthis.next = null;\n+\t}\n+\t\n+}"
  },
  {
    "sha": "21d9ae8228d06ac9b75a57c5a9e2ed81340cba05",
    "filename": "Assignment11-DSA-Stack-Expression/src/com/metacube/Q1Stack/Stack.java",
    "status": "added",
    "additions": 68,
    "deletions": 0,
    "changes": 68,
    "blob_url": "https://github.com/meta-ameet-khemani/GET2021/blob/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/Q1Stack/Stack.java",
    "raw_url": "https://github.com/meta-ameet-khemani/GET2021/raw/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/Q1Stack/Stack.java",
    "contents_url": "https://api.github.com/repos/meta-ameet-khemani/GET2021/contents/Assignment11-DSA-Stack-Expression/src/com/metacube/Q1Stack/Stack.java?ref=d5b5b2f1f70d264368a8cfaf91d74b543a752a7f",
    "patch": "@@ -0,0 +1,68 @@\n+package com.metacube.Q1Stack;\n+\n+/**\n+ * Stack implementation\n+ * @author ameet.khemani_metacu\n+ *\n+ * @param <T>\n+ */\n+public class Stack<T> {\n+\t\n+\t// creating the node as head\n+\tNode<T> head;\n+\t\n+\t// initialising stack with head pointing to null\n+\tpublic Stack () {\n+\t\tthis.head = null;\n+\t}\n+\t\n+\t/**\n+\t * Adding item to stack\n+\t * @param data to add in stack\n+\t */\n+\tpublic void push (T data) {\n+\t\t\n+\t\t// create a new node with data\n+\t\tNode<T> node = new Node<>(data);\n+\t\t\n+\t\t// check if stack is empty or not\n+\t\tif (this.head == null) {\n+\t\t\tthis.head = node;\n+\t\t} else {\n+\t\t\tnode.next = this.head;\n+\t\t\tthis.head = node;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Removes the element from stack\n+\t * @return removed element of type T\n+\t */\n+\tpublic T pop () {\n+\t\t// checks if stack is empty or not\n+\t\tif (this.head == null) {\n+\t\t\tthrow new AssertionError(\"Stack is empty !!!\");\n+\t\t}\n+\t\t\n+\t\t// remove the node\n+\t\tT data = (T)this.head.data;\n+\t\tthis.head = this.head.next;\n+\t\treturn data;\n+\t}\n+\t\n+\t/**\n+\t * Get the top most element in stack\n+\t * @return element of type T\n+\t */\n+\tpublic T getTop () {\n+\t\treturn this.head.data;\n+\t}\n+\t\n+\t/**\n+\t * Checks if stack is empty or not\n+\t * @return true if empty else false\n+\t */\n+\tpublic boolean isEmpty () {\n+\t\treturn this.head == null;\n+\t}\n+}"
  },
  {
    "sha": "b4e978ba920ed5198564f92c0339174b3b8bad8f",
    "filename": "Assignment11-DSA-Stack-Expression/src/com/metacube/Q2Queue/CircularQueue.java",
    "status": "added",
    "additions": 114,
    "deletions": 0,
    "changes": 114,
    "blob_url": "https://github.com/meta-ameet-khemani/GET2021/blob/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/Q2Queue/CircularQueue.java",
    "raw_url": "https://github.com/meta-ameet-khemani/GET2021/raw/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/Q2Queue/CircularQueue.java",
    "contents_url": "https://api.github.com/repos/meta-ameet-khemani/GET2021/contents/Assignment11-DSA-Stack-Expression/src/com/metacube/Q2Queue/CircularQueue.java?ref=d5b5b2f1f70d264368a8cfaf91d74b543a752a7f",
    "patch": "@@ -0,0 +1,114 @@\n+package com.metacube.Q2Queue;\n+\n+/**\n+ * Circle queue implementation \n+ * @author ameet.khemani_metacu\n+ *\n+ * @param <T>\n+ */\n+public class CircularQueue<T> implements Queue<T> {\n+\n+\t// represents the front and rear point of circular queue\n+\tInteger front, rear;\n+\t\n+\t// size of queue\n+\tInteger size;\n+\t\n+\t// elements of queue\n+\tInteger array[];\n+\t\n+\tpublic CircularQueue(Integer capacity) {\n+\t\tthis.size = capacity;\n+\t\tthis.front = this.rear = -1;\n+\t\tthis.array = new Integer[capacity];\n+\t}\n+\t\n+\t/**\n+\t * Add an element to queue\n+\t * @param T of type Queue is defined\n+\t * @return true if successfully added else false\n+\t */\n+\t@Override\n+\tpublic boolean enqueue(T element) {\n+\t\t\n+\t\t// checking if queue is already full or not\n+\t\tif (isFull()) {\n+\t\t\tthrow new AssertionError(\"Queue is full\");\n+\t\t} else {\n+\t\t\tif (this.front == -1) {\n+\t\t\t\tthis.front = 0;\n+\t\t\t}\n+\t\t\tthis.rear = (this.rear + 1) % this.size;\n+\t\t\tthis.array[this.rear] = (Integer)element;\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Deleting an element from queue\n+\t * @return removed element is returned of type T\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\t@Override\n+\tpublic T dequeue() {\n+\t\tT data;\n+\t\t\n+\t\t// checking if queue is empty or not\n+\t\tif (isEmtpy()) {\n+\t\t\tthrow new AssertionError(\"Queue is empty\");\n+\t\t} else {\n+\t\t\t\n+\t\t\t// remove element\n+\t\t\tdata = (T)this.array[this.front];\n+\t\t\t\n+\t\t\t// adjust both front and rear of queue\n+\t\t\tif (this.front == this.rear) {\n+\t\t\t\tthis.front = this.rear = -1;\n+\t\t\t} else {\n+\t\t\t\tthis.front = (this.front + 1) % this.size;\n+\t\t\t}\n+\t\t\treturn (T)data;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks if queue is empty or not\n+\t * @return true if empty else false\n+\t*/\n+\t@Override\n+\tpublic boolean isEmtpy() {\n+\t\tif (this.front == -1) {\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks if queue if full or not\n+\t * @return true if full else false\n+\t */\n+\t@Override\n+\tpublic boolean isFull() {\n+\t\tif (this.front == 0 && this.rear == this.size - 1) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (this.front == this.rear + 1) {\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tpublic static void main (String[] args) {\n+\t\tCircularQueue<Integer> queue = new CircularQueue<Integer>(5);\n+\t\tqueue.enqueue(1);\n+\t\tqueue.enqueue(2);\n+\t\tqueue.enqueue(3);\n+\t\tqueue.enqueue(4);\n+\t\tqueue.enqueue(5);\n+\t\tSystem.out.println(queue.dequeue());\n+\t\tqueue.enqueue(6);\n+\t\tSystem.out.println(queue.dequeue());\n+\t}\n+\t\n+}"
  },
  {
    "sha": "6fc5e0a5ec44bade01c56382a4da47c7d4ae06f9",
    "filename": "Assignment11-DSA-Stack-Expression/src/com/metacube/Q2Queue/Queue.java",
    "status": "added",
    "additions": 23,
    "deletions": 0,
    "changes": 23,
    "blob_url": "https://github.com/meta-ameet-khemani/GET2021/blob/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/Q2Queue/Queue.java",
    "raw_url": "https://github.com/meta-ameet-khemani/GET2021/raw/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/Q2Queue/Queue.java",
    "contents_url": "https://api.github.com/repos/meta-ameet-khemani/GET2021/contents/Assignment11-DSA-Stack-Expression/src/com/metacube/Q2Queue/Queue.java?ref=d5b5b2f1f70d264368a8cfaf91d74b543a752a7f",
    "patch": "@@ -0,0 +1,23 @@\n+package com.metacube.Q2Queue;\n+\n+/**\n+ * Queue interface to list down all possible functionalities\n+ * @author ameet.khemani_metacu\n+ *\n+ * @param <T> generic type data\n+ */\n+public interface Queue<T> {\n+\n+\t// operation to add element to queue\n+\tpublic boolean enqueue (T element);\n+\t\n+\t// operation to delete an element\n+\tpublic T dequeue ();\n+\t\n+\t// operation to check if queue is empty or not\n+\tpublic boolean isEmtpy ();\n+\t\n+\t// operation to check if queue is full or not\n+\tpublic boolean isFull ();\n+\t\n+}"
  },
  {
    "sha": "7e4dd2d44190931a4bf27ce3824e72a7b68d56d2",
    "filename": "Assignment11-DSA-Stack-Expression/src/com/metacube/Q3Counselling/Counselling.java",
    "status": "added",
    "additions": 407,
    "deletions": 0,
    "changes": 407,
    "blob_url": "https://github.com/meta-ameet-khemani/GET2021/blob/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/Q3Counselling/Counselling.java",
    "raw_url": "https://github.com/meta-ameet-khemani/GET2021/raw/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/Q3Counselling/Counselling.java",
    "contents_url": "https://api.github.com/repos/meta-ameet-khemani/GET2021/contents/Assignment11-DSA-Stack-Expression/src/com/metacube/Q3Counselling/Counselling.java?ref=d5b5b2f1f70d264368a8cfaf91d74b543a752a7f",
    "patch": "@@ -0,0 +1,407 @@\n+package com.metacube.Q3Counselling;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.apache.poi.ss.usermodel.Cell;\n+import org.apache.poi.ss.usermodel.Row;\n+import org.apache.poi.ss.usermodel.Sheet;\n+import org.apache.poi.xssf.usermodel.XSSFSheet;\n+import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n+\n+/**\n+ * Counselling class used to process the allotment of streams to students\n+ * @author ameet.khemani_metacu\n+ */\n+public class Counselling {\n+\t\n+\t// queue to maintain students\n+\tstatic Queue<String> students = new LinkedList<String>();\n+\t\n+\t// Map to store streams with maximum students allowed\n+\tstatic HashMap<String, Double> streamCapacity = new HashMap<>();\n+\t\n+\t// Map to store students prefered stream\n+\tstatic HashMap<String, String> studentPreference = new HashMap<>();\n+\t\n+\t/**\n+\t * Reads and processes the file which stores streams along with their student capacities\n+\t * @param filename name of the excel file to read\n+\t */\n+\tpublic void readStreamCapacityFile (String filename) {\n+\t\t\n+\t\ttry {\n+\t\t\t// convert file into stream\n+\t\t\tFileInputStream input = new FileInputStream(new File(filename));\n+\t\t\t\n+\t\t\t// create a workbook from stream\n+\t\t\tXSSFWorkbook workbook = new XSSFWorkbook(input);\n+\t\t\t\n+\t\t\t// select sheet from file\n+\t\t\tSheet firstSheet = workbook.getSheetAt(0);\n+\t\t\t\n+\t\t\tIterator<Row> iterator = firstSheet.iterator();\n+\t\t\t\n+\t\t\t// iterate through all rows\n+\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\t\n+\t\t\t\t// create a row object\n+\t\t\t\tRow nextRow = iterator.next();\n+\t\t\t\t\n+\t\t\t\t// iterate through columns of a row\n+\t\t\t\tIterator<Cell> cellIterator = nextRow.cellIterator();\n+\t\t\t\t\n+\t\t\t\tString programName = null;\n+\t\t\t\tDouble capacity = null;\n+\t\t\t\t\n+\t\t\t\twhile (cellIterator.hasNext()) {\n+\t\t\t\t\t\n+\t\t\t\t\t// create a column object\n+\t\t\t\t\tCell cell = cellIterator.next();\n+\t\t\t\t\tif (nextRow.getRowNum() > 0) {\n+\t\t\t\t\t\t\n+\t\t\t\t\t\t// check the type of the data in column\n+\t\t\t\t\t\tswitch (cell.getCellType()) {\n+\t\t\t\t\t\t\tcase NUMERIC:\n+\t\t\t\t\t\t\t\tcapacity = cell.getNumericCellValue();\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\tcase STRING:\n+\t\t\t\t\t\t\t\tprogramName = cell.getStringCellValue();\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\t// add row data to map\n+\t\t\t\tif (programName != null && capacity != null) {\n+\t\t\t\t\tstreamCapacity.put(programName, capacity);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\t// close workbook and stream\n+\t\t\tworkbook.close();\n+\t\t\tinput.close();\n+\t\t\n+\t\t} catch (FileNotFoundException exception) {\n+\t\t\texception.printStackTrace();\n+\t\t} catch (IOException exception) {\n+\t\t\texception.printStackTrace();\n+\t\t} catch (Exception exception) {\n+\t\t\texception.printStackTrace();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Reads and processes the file which stores student prefered streams\n+\t * @param filename name of the excel file to read\n+\t */\n+\tpublic void readStudentPreferenceFile (String filename) {\n+\t\t\n+\t\ttry {\n+\t\t\t// convert the file into stream\n+\t\t\tFileInputStream input = new FileInputStream(new File(filename));\n+\t\t\t\n+\t\t\t// create workbook from that stream\n+\t\t\tXSSFWorkbook workbook = new XSSFWorkbook(input);\n+\t\t\t\n+\t\t\t// read the first sheet of file\n+\t\t\tSheet firstSheet = workbook.getSheetAt(0);\n+\t\t\t\n+\t\t\tIterator<Row> iterator = firstSheet.iterator();\n+\t\t\t\n+\t\t\t// iterate through all rows\n+\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\t\n+\t\t\t\t// create row object\n+\t\t\t\tRow nextRow = iterator.next();\n+\t\t\t\tIterator<Cell> cellIterator = nextRow.cellIterator();\t\t\t\n+\t\t\t\tString student = null;\n+\t\t\t\tString preference = null;\n+\t\t\t\t\n+\t\t\t\t// iterate through all columns\n+\t\t\t\twhile (cellIterator.hasNext()) {\n+\t\t\t\t\t\n+\t\t\t\t\t// create a column object\n+\t\t\t\t\tCell cell = cellIterator.next();\n+\t\t\t\t\tif (nextRow.getRowNum() > 0) {\n+\t\t\t\t\t\tif (cell.getColumnIndex() == 0) {\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\t// check the type of data of column\n+\t\t\t\t\t\t\tswitch (cell.getCellType()) {\n+\t\t\t\t\t\t\t\tcase STRING:\n+\t\t\t\t\t\t\t\t\tstudent = cell.getStringCellValue();\n+\t\t\t\t\t\t\t\t\tstudents.add(student);\n+\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\t\n+\t\t\t\t\t\t} else if (cell.getColumnIndex() == 1) {\n+\t\t\t\t\t\t\tswitch (cell.getCellType()) {\n+\t\t\t\t\t\t\t\tcase STRING:\n+\t\t\t\t\t\t\t\t\tpreference = cell.getStringCellValue();\n+\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\t// add row to map\n+\t\t\t\tif (student != null && preference != null) {\n+\t\t\t\t\tstudentPreference.put(student, preference);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\t// close workbook and stream\n+\t\t\tworkbook.close();\n+\t\t\tinput.close();\n+\t\t} catch (FileNotFoundException exception) {\n+\t\t\texception.printStackTrace();\n+\t\t} catch (IOException exception) {\n+\t\t\texception.printStackTrace();\n+\t\t} catch (Exception exception) {\n+\t\t\texception.printStackTrace();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Used to process the allotment of stream to students\n+\t */\n+\tpublic void allotStreams () {\n+\t\t\n+\t\t// list to hold the data we need to write to file\n+\t\tList<StudentStream> dataToWrite = new ArrayList<StudentStream>();\n+\t\t\n+\t\t// heading of columns as first row\n+\t\tdataToWrite.add(new StudentStream(\"Student Name\", \"Alloted Stream\"));\n+\t\t\n+\t\twhile (!students.isEmpty()) {\n+\t\t\t\n+\t\t\t// get the name of student\n+\t\t\tString studentName = students.remove();\n+\t\t\t\n+\t\t\t// get all the preferences\n+\t\t\tString pref = studentPreference.get(studentName);\n+\t\t\tString preferences[] = pref.split(\",\");\n+\t\t\t\n+\t\t\t// iterate through preferences\n+\t\t\tfor (int loop = 0; loop < preferences.length; loop++) {\n+\t\t\t\tString subject = preferences[loop];\n+\t\t\t\t\n+\t\t\t\t// get the maximum students allowed in a stream\n+\t\t\t\tDouble capacity = streamCapacity.get(subject);\n+\t\t\t\t\n+\t\t\t\t// if capacity allows then add the student else select next prefered stream\n+\t\t\t\tif (capacity > 0) {\n+\t\t\t\t\tcapacity--;\n+\t\t\t\t\tdataToWrite.add(new StudentStream(studentName, preferences[loop]));\n+\t\t\t\t\tstreamCapacity.put(subject, capacity);\n+\t\t\t\t\tbreak;\n+\t\t\t\t} else {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tSystem.out.println(\"data to write\");\n+\t\tfor (StudentStream s : dataToWrite) {\n+\t\t\tSystem.out.println(s.getStudentName() + \" \" + s.getAllotedStream());\n+\t\t}\n+\t\t\n+\t\t// create a workbook object\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\t\n+\t\t// create a sheet object\n+\t\tXSSFSheet sheet = workbook.createSheet(\"Student Alloted Stream\");\n+\t\t\n+\t\tint rowCount = 0;\n+\t\tfor (int i = 0; i < dataToWrite.size(); i++) {\n+\t\t\t\n+\t\t\t// create a row object\n+\t\t\tRow row = sheet.createRow(rowCount++);\n+\t\t\t\n+\t\t\t// create student data as object\n+\t\t\tStudentStream data = dataToWrite.get(i);\n+\t\t\t\n+\t\t\tint columnCount = 0;\n+\t\t\t\n+\t\t\t// create a new column in row\n+\t\t\tCell cell = row.createCell(columnCount++);\n+\t\t\t\n+\t\t\tif (data.getStudentName() instanceof String) {\n+\t\t\t\tcell.setCellValue((String)data.getStudentName());\n+\t\t\t}\n+\t\t\t\n+\t\t\t// add another column in same row\n+\t\t\tcell = row.createCell(columnCount++);\n+\t\t\tif (data.getAllotedStream() instanceof String) {\n+\t\t\t\tcell.setCellValue((String)data.getAllotedStream());\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\t// add data to the file\n+\t\ttry (FileOutputStream outputStream = new FileOutputStream(\"Student Alloted Stream.xlsx\")) {\n+\t\t\tworkbook.write(outputStream);\n+\t\t} catch (FileNotFoundException e) {\n+\t\t\tSystem.out.println(\"File not found !!!\");\n+\t\t\te.printStackTrace();\n+\t\t} catch (IOException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t\t\n+\t\t// close workbook\n+\t\ttry {\n+\t\t\tworkbook.close();\n+\t\t} catch (IOException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Creates an excel file containing the names of students along with their prefered choices of stream separated by comma\n+\t */\n+\tprivate void createStudentPreferencesFile () {\n+\t\t\n+\t\t// create a workbook object\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\t\n+\t\t// create a sheet object\n+\t\tXSSFSheet sheet = workbook.createSheet(\"Student Preference\");\n+\t\t\n+\t\t// multidimensional array to store data\n+\t\tObject[][] studentPreferences = {\n+\t\t\t\t{\"Name\", \"Preferences\"},\n+\t\t\t\t{\"First\", \"CS,IT,EC,ME,CIVIL\"},\n+\t\t\t\t{\"Second\", \"IT,CS,EC,ME,CIVIL\"},\n+\t\t\t\t{\"Third\", \"CS,CIVIL,EC,ME,IT\"},\n+\t\t\t\t{\"Fourth\", \"CS,CIVIL,EC,ME,IT\"},\n+\t\t\t\t{\"Fifth\", \"IT,CIVIL,EC,ME,CIVIL\"},\n+\t\t};\n+\t\t\n+\t\tint rowCount = 0;\n+\t\t\n+\t\t// iterate through data\n+\t\tfor (Object[] studentPreference : studentPreferences) {\n+\t\t\t\n+\t\t\t// create a row object\n+\t\t\tRow row = sheet.createRow(rowCount++);\n+\t\t\t\n+\t\t\tint columnCount = 0;\n+\t\t\tfor (Object field : studentPreference) {\n+\t\t\t\t\n+\t\t\t\t// create a column object\n+\t\t\t\tCell cell = row.createCell(columnCount++);\n+\t\t\t\tif (field instanceof String) {\n+\t\t\t\t\t\n+\t\t\t\t\t// add data to column\n+\t\t\t\t\tcell.setCellValue((String)field);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\t// add complete data to excel file\n+\t\ttry (FileOutputStream outputStream = new FileOutputStream(\"StudentPreferences.xlsx\")) {\n+\t\t\tworkbook.write(outputStream);\n+\t\t} catch (FileNotFoundException e) {\n+\t\t\te.printStackTrace();\n+\t\t} catch (IOException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t\t\n+\t\t// close workbook\n+\t\ttry {\n+\t\t\tworkbook.close();\n+\t\t} catch (IOException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t\t\n+\t}\n+\n+\t/**\n+\t * Creates an excel file containing the name of stream along with their maximum number of students allowed\n+\t */\n+\tprivate void createStreamsWithCapacityFile () {\n+\t\t\t\n+\t\t// create a workbook\n+\t\tXSSFWorkbook workbook = new XSSFWorkbook();\n+\t\t\n+\t\t// create a sheet\n+\t\tXSSFSheet sheet = workbook.createSheet(\"Streams Capacity\");\n+\t\t\n+\t\t// create an object containing data\n+\t\tObject[][] streamsCapacity = {\n+\t\t\t\t{\"Stream\", \"Capacity\"},\n+\t\t\t\t{\"CS\", 1},\n+\t\t\t\t{\"IT\", 2},\n+\t\t\t\t{\"EC\", 3},\n+\t\t\t\t{\"ME\", 4},\n+\t\t\t\t{\"CIVIL\", 5},\n+\t\t};\n+\t\t\n+\t\tint rowCount = 0;\n+\t\t\n+\t\t// iterate through data\n+\t\tfor (Object[] streamCapacity : streamsCapacity) {\n+\t\t\t\n+\t\t\t// creates a row object\n+\t\t\tRow row = sheet.createRow(rowCount++);\n+\t\t\t\n+\t\t\tint columnCount = 0;\n+\t\t\tfor (Object field : streamCapacity) {\n+\t\t\t\t\n+\t\t\t\t// create a new column object\n+\t\t\t\tCell cell = row.createCell(columnCount++);\n+\t\t\t\tif (field instanceof String) {\n+\t\t\t\t\t\n+\t\t\t\t\t// add data to column\n+\t\t\t\t\tcell.setCellValue((String)field);\n+\t\t\t\t} else if (field instanceof Integer) {\n+\t\t\t\t\t\n+\t\t\t\t\t// add data to column\n+\t\t\t\t\tcell.setCellValue((Integer)field);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\t// add data to file\n+\t\ttry (FileOutputStream outputStream = new FileOutputStream(\"Streams Capacity.xlsx\")) {\n+\t\t\tworkbook.write(outputStream);\n+\t\t} catch (FileNotFoundException e) {\n+\t\t\te.printStackTrace();\n+\t\t} catch (IOException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t\t\n+\t\t// close workbook\n+\t\ttry {\n+\t\t\tworkbook.close();\n+\t\t} catch (IOException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic static void main (String args[]) throws IOException {\n+\t\t\n+\t\tCounselling counselling = new Counselling ();\n+\t\tcounselling.createStudentPreferencesFile ();\n+\t\tcounselling.createStreamsWithCapacityFile ();\n+\t\t\n+\t\tcounselling.readStreamCapacityFile (\"Streams Capacity.xlsx\");\n+\t\tcounselling.readStudentPreferenceFile (\"StudentPreferences.xlsx\");\n+\t\tstreamCapacity.entrySet ().forEach (program -> {\n+\t\t\tSystem.out.println (program.getKey () + \"  \" + program.getValue ());\n+\t\t});\n+\t\tSystem.out.println (\"=======================================\");\n+\t\tstudentPreference.entrySet ().forEach (student -> {\n+\t\t\tSystem.out.println (student.getKey () + \"  \" + student.getValue ());\n+\t\t});\n+\t\tSystem.out.println (\"=======================================\");\n+\t\tcounselling.allotStreams ();\n+\t}\n+\t\n+}"
  },
  {
    "sha": "5b6ac09bf0daccd8b6ffa21a28214a06b96b7afe",
    "filename": "Assignment11-DSA-Stack-Expression/src/com/metacube/Q3Counselling/StudentStream.java",
    "status": "added",
    "additions": 27,
    "deletions": 0,
    "changes": 27,
    "blob_url": "https://github.com/meta-ameet-khemani/GET2021/blob/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/Q3Counselling/StudentStream.java",
    "raw_url": "https://github.com/meta-ameet-khemani/GET2021/raw/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/Q3Counselling/StudentStream.java",
    "contents_url": "https://api.github.com/repos/meta-ameet-khemani/GET2021/contents/Assignment11-DSA-Stack-Expression/src/com/metacube/Q3Counselling/StudentStream.java?ref=d5b5b2f1f70d264368a8cfaf91d74b543a752a7f",
    "patch": "@@ -0,0 +1,27 @@\n+package com.metacube.Q3Counselling;\n+\n+/**\n+ * StudentStream model represents the content of file which contains\n+ * @author ameet.khemani_metacu\n+ */\n+public class StudentStream {\n+\t\n+\t// representing the name of student\n+\tString studentName;\n+\t\n+\t// Representing the stream alloted to student\n+\tString allotedStream;\n+\t\n+\tpublic StudentStream(String studentName, String allotedStream) {\n+\t\tthis.studentName = studentName;\n+\t\tthis.allotedStream = allotedStream;\n+\t}\n+\n+\tpublic String getStudentName() {\n+\t\treturn studentName;\n+\t}\n+\n+\tpublic String getAllotedStream() {\n+\t\treturn allotedStream;\n+\t}\n+}"
  },
  {
    "sha": "fff5603d4c994442b294e4d4d4bd6aea31a8c616",
    "filename": "Assignment11-DSA-Stack-Expression/src/com/metacube/test/Q1Stack.java",
    "status": "added",
    "additions": 25,
    "deletions": 0,
    "changes": 25,
    "blob_url": "https://github.com/meta-ameet-khemani/GET2021/blob/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/test/Q1Stack.java",
    "raw_url": "https://github.com/meta-ameet-khemani/GET2021/raw/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/test/Q1Stack.java",
    "contents_url": "https://api.github.com/repos/meta-ameet-khemani/GET2021/contents/Assignment11-DSA-Stack-Expression/src/com/metacube/test/Q1Stack.java?ref=d5b5b2f1f70d264368a8cfaf91d74b543a752a7f",
    "patch": "@@ -0,0 +1,25 @@\n+package com.metacube.test;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import com.metacube.Q1Stack.InfixExpression;\n+\n+/**\n+ * Test class for stack operations\n+ * @author ameet.khemani_metacu\n+ */\n+public class Q1Stack {\n+\n+\t// positive test case for expression\n+\t@Test\n+\tpublic void testExpressionTrue () {\n+\t\tAssert.assertEquals((Integer) 22, InfixExpression.evaluateString(\"3 * 4 + ( 5 * 2 )\"));\n+\t}\n+\t\n+\t// negative test case for expression\n+\t@Test\n+\tpublic void testExpressionFalse () {\n+\t\tAssert.assertNotEquals((Integer) 2, InfixExpression.evaluateString(\"3 * 4 + ( 5 * 2 )\"));\n+\t}\n+\n+}"
  },
  {
    "sha": "dff13cca9adcba7f2bd7c3ec523df5294cd723f5",
    "filename": "Assignment11-DSA-Stack-Expression/src/com/metacube/test/Q2Queue.java",
    "status": "added",
    "additions": 59,
    "deletions": 0,
    "changes": 59,
    "blob_url": "https://github.com/meta-ameet-khemani/GET2021/blob/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/test/Q2Queue.java",
    "raw_url": "https://github.com/meta-ameet-khemani/GET2021/raw/d5b5b2f1f70d264368a8cfaf91d74b543a752a7f/Assignment11-DSA-Stack-Expression/src/com/metacube/test/Q2Queue.java",
    "contents_url": "https://api.github.com/repos/meta-ameet-khemani/GET2021/contents/Assignment11-DSA-Stack-Expression/src/com/metacube/test/Q2Queue.java?ref=d5b5b2f1f70d264368a8cfaf91d74b543a752a7f",
    "patch": "@@ -0,0 +1,59 @@\n+package com.metacube.test;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import com.metacube.Q2Queue.CircularQueue;\n+\n+/**\n+ * Test class for queue operations\n+ * @author ameet.khemani_metacu\n+ *\n+ */\n+public class Q2Queue {\n+\t\n+\t// test case for adding queue\n+\t@Test\n+\tpublic void enqueueTest () {\n+\t\tCircularQueue<Integer> queue = new CircularQueue<Integer>(3);\n+\t\tAssert.assertEquals(true, queue.enqueue(1));\n+\t\tAssert.assertEquals(true, queue.enqueue(2));\n+\t\tAssert.assertEquals(true, queue.enqueue(3));\n+\t\tqueue.dequeue();\n+\t}\n+\t\n+\t// test case for overflowing queue\n+\t@Test(expected = AssertionError.class)\n+\tpublic void queueFullTest () {\n+\t\tCircularQueue<Integer> queue = new CircularQueue<Integer>(3);\n+\t\tqueue.enqueue(1);\n+\t\tqueue.enqueue(1);\n+\t\tqueue.enqueue(1);\n+\t\tqueue.enqueue(1);\n+\t}\n+\t\n+\t// test case for removing element\n+\t@Test\n+\tpublic void dequeueTest () {\n+\t\tCircularQueue<Integer> queue = new CircularQueue<Integer>(3);\n+\t\tqueue.enqueue(1);\n+\t\tqueue.enqueue(2);\n+\t\tAssert.assertEquals((Integer)1, (Integer)queue.dequeue());\n+\t\tqueue.enqueue(3);\n+\t\tAssert.assertEquals((Integer)2, (Integer)queue.dequeue());\n+\t\tqueue.enqueue(4);\n+\t\tAssert.assertEquals((Integer)3, (Integer)queue.dequeue());\n+\t\tAssert.assertEquals((Integer)4, (Integer)queue.dequeue());\n+\t}\n+\t\n+\t// test case for underflowing condition\n+\t@Test(expected = AssertionError.class)\n+\tpublic void dequeueEmptyTest () {\n+\t\tCircularQueue<Integer> queue = new CircularQueue<Integer>(3);\n+\t\tqueue.enqueue(1);\n+\t\tqueue.enqueue(2);\n+\t\tqueue.dequeue();\n+\t\tqueue.dequeue();\n+\t\tqueue.dequeue();\n+\t}\n+\t\n+}"
  }
]
