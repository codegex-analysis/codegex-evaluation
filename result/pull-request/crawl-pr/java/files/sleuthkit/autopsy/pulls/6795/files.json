[
  {
    "sha": "35d65db9321d7d0c93c39003a947421cbe6205c1",
    "filename": "Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/BaseDataSourceSummaryPanel.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/sleuthkit/autopsy/blob/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/BaseDataSourceSummaryPanel.java",
    "raw_url": "https://github.com/sleuthkit/autopsy/raw/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/BaseDataSourceSummaryPanel.java",
    "contents_url": "https://api.github.com/repos/sleuthkit/autopsy/contents/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/BaseDataSourceSummaryPanel.java?ref=3563ca6b7323519ae4876cafa798a7066a26452e",
    "patch": "@@ -47,7 +47,7 @@\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelExport.ExcelExportException;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelExport.ExcelSheetExport;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelTableExport;\n-import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelTableExport.ExcelCellModel;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelCellModel;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.GuiCellModel.DefaultMenuItem;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.GuiCellModel.MenuItem;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.LoadableComponent;"
  },
  {
    "sha": "4a47bcb09262463777a5f02531fba87c0e07c50b",
    "filename": "Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/Bundle.properties-MERGED",
    "status": "modified",
    "additions": 27,
    "deletions": 6,
    "changes": 33,
    "blob_url": "https://github.com/sleuthkit/autopsy/blob/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/Bundle.properties-MERGED",
    "raw_url": "https://github.com/sleuthkit/autopsy/raw/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/Bundle.properties-MERGED",
    "contents_url": "https://api.github.com/repos/sleuthkit/autopsy/contents/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/Bundle.properties-MERGED?ref=3563ca6b7323519ae4876cafa798a7066a26452e",
    "patch": "@@ -6,7 +6,21 @@ AnalysisPanel_keywordHits_tabName=Keyword Hits\n AnalysisPanel_keywordSearchModuleName=Keyword Search\n BaseDataSourceSummaryPanel_goToArtifact=View Source Result\n BaseDataSourceSummaryPanel_goToFile=View Source File in Directory\n+ContainerPanel_export_acquisitionDetails=Acquisition Details:\n+ContainerPanel_export_deviceId=Device ID:\n+ContainerPanel_export_displayName=Display Name:\n+ContainerPanel_export_filePaths=File Paths:\n+ContainerPanel_export_imageType=Image Type:\n+ContainerPanel_export_md5=MD5:\n+ContainerPanel_export_originalName=Name:\n+ContainerPanel_export_sectorSize=Sector Size:\n+ContainerPanel_export_sha1=SHA1:\n+ContainerPanel_export_sha256=SHA256:\n+ContainerPanel_export_size=Size:\n+ContainerPanel_export_timeZone=Time Zone:\n+ContainerPanel_export_unallocatedSize=Unallocated Space:\n ContainerPanel_setFieldsForNonImageDataSource_na=N/A\n+ContainerPanel_tabName=Container\n CTL_DataSourceSummaryAction=Data Source Summary\n DataSourceSummaryDialog.closeButton.text=Close\n ContainerPanel.displayNameLabel.text=Display Name:\n@@ -73,6 +87,12 @@ GeolocationPanel_mostCommon_tabName=Most Common Cities\n GeolocationPanel_mostRecent_tabName=Most Recent Cities\n GeolocationPanel_onNoCrIngest_message=No results will be shown because the GPX Parser was not run.\n GeolocationPanel_unknownRow_title=Unknown\n+IngestJobExcelExport_endTimeColumn=End Time\n+IngestJobExcelExport_ingestStatusTimeColumn=Ingest Status\n+IngestJobExcelExport_moduleNameTimeColumn=Module Name\n+IngestJobExcelExport_sheetName=Ingest History\n+IngestJobExcelExport_startTimeColumn=Start Time\n+IngestJobExcelExport_versionColumn=Module Version\n PastCasesPanel_caseColumn_title=Case\n PastCasesPanel_countColumn_title=Count\n PastCasesPanel_notableFileTable_tabName=Cases with Common Notable\n@@ -87,18 +107,19 @@ RecentFilesPanel_attachmentsTable_tabName=Recent Attachments\n RecentFilesPanel_col_head_date=Date\n RecentFilesPanel_docsTable_tabName=Recently Opened Documents\n RecentFilesPanel_downloadsTable_tabName=Recently Downloads\n-SizeRepresentationUtil_units_bytes=\\ bytes\n-SizeRepresentationUtil_units_gigabytes=\\ GB\n-SizeRepresentationUtil_units_kilobytes=\\ kB\n-SizeRepresentationUtil_units_megabytes=\\ MB\n-SizeRepresentationUtil_units_petabytes=\\ PB\n-SizeRepresentationUtil_units_terabytes=\\ TB\n+SizeRepresentationUtil_units_bytes=bytes\n+SizeRepresentationUtil_units_gigabytes=GB\n+SizeRepresentationUtil_units_kilobytes=KB\n+SizeRepresentationUtil_units_megabytes=MB\n+SizeRepresentationUtil_units_petabytes=PB\n+SizeRepresentationUtil_units_terabytes=TB\n TimelinePanel_earliestLabel_title=Earliest\n TimelinePanel_latestLabel_title=Latest\n TimlinePanel_last30DaysChart_artifactEvts_title=Result Events\n TimlinePanel_last30DaysChart_fileEvts_title=File Events\n TimlinePanel_last30DaysChart_title=Last 30 Days\n TypesPanel_artifactsTypesPieChart_title=Artifact Types\n+TypesPanel_excelTabName=Types\n TypesPanel_fileMimeTypesChart_audio_title=Audio\n TypesPanel_fileMimeTypesChart_documents_title=Documents\n TypesPanel_fileMimeTypesChart_executables_title=Executables"
  },
  {
    "sha": "a8e5fef64e13e5e8cf3bbe4e36de81b52fd18b3b",
    "filename": "Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/ContainerPanel.java",
    "status": "modified",
    "additions": 368,
    "deletions": 92,
    "changes": 460,
    "blob_url": "https://github.com/sleuthkit/autopsy/blob/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/ContainerPanel.java",
    "raw_url": "https://github.com/sleuthkit/autopsy/raw/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/ContainerPanel.java",
    "contents_url": "https://api.github.com/repos/sleuthkit/autopsy/contents/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/ContainerPanel.java?ref=3563ca6b7323519ae4876cafa798a7066a26452e",
    "patch": "@@ -19,21 +19,35 @@\n package org.sleuthkit.autopsy.datasourcesummary.ui;\n \n import java.beans.PropertyChangeEvent;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n import java.util.logging.Level;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.sleuthkit.autopsy.coreutils.Logger;\n import javax.swing.table.DefaultTableModel;\n+import org.apache.commons.lang.StringUtils;\n import org.openide.util.NbBundle.Messages;\n import org.sleuthkit.autopsy.casemodule.Case;\n import org.sleuthkit.autopsy.datasourcesummary.datamodel.ContainerSummary;\n+import org.sleuthkit.autopsy.datasourcesummary.datamodel.SleuthkitCaseProvider.SleuthkitCaseProviderException;\n+import static org.sleuthkit.autopsy.datasourcesummary.ui.BaseDataSourceSummaryPanel.getFetchResult;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.DataFetchResult.ResultType;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.DataFetchWorker.DataFetchComponents;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.DataFetcher;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.DefaultCellModel;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.DefaultUpdateGovernor;\n-import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelExport;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelExport.ExcelSheetExport;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelSpecialFormatExport;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelSpecialFormatExport.ExcelItemExportable;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelSpecialFormatExport.KeyValueItemExportable;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelSpecialFormatExport.SingleCellExportable;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelSpecialFormatExport.TitledExportable;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.UpdateGovernor;\n import org.sleuthkit.datamodel.DataSource;\n import org.sleuthkit.datamodel.Image;\n@@ -42,39 +56,184 @@\n /**\n  * Panel to display additional details associated with a specific DataSource\n  */\n+@Messages({\n+    \"ContainerPanel_tabName=Container\"\n+})\n class ContainerPanel extends BaseDataSourceSummaryPanel {\n \n     /**\n-     * Data payload for the Container panel.\n+     * View model data for data source images.\n      */\n-    private static class ContainerPanelData {\n+    private static class ImageViewModel {\n \n-        private final DataSource dataSource;\n-        private final Long unallocatedFilesSize;\n+        private final long unallocatedSize;\n+        private final long size;\n+        private final long sectorSize;\n+\n+        private final String timeZone;\n+        private final String imageType;\n+\n+        private final List<String> paths;\n+        private final String md5Hash;\n+        private final String sha1Hash;\n+        private final String sha256Hash;\n \n         /**\n          * Main constructor.\n          *\n-         * @param dataSource The original datasource.\n-         * @param unallocatedFilesSize The unallocated file size.\n+         * @param unallocatedSize Size in bytes of unallocated space.\n+         * @param size Total size in bytes.\n+         * @param sectorSize Sector size in bytes.\n+         * @param timeZone The time zone.\n+         * @param imageType The type of image.\n+         * @param paths The source paths for the image.\n+         * @param md5Hash The md5 hash or null.\n+         * @param sha1Hash The sha1 hash or null.\n+         * @param sha256Hash The sha256 hash or null.\n+         */\n+        ImageViewModel(long unallocatedSize, long size, long sectorSize,\n+                String timeZone, String imageType, List<String> paths, String md5Hash,\n+                String sha1Hash, String sha256Hash) {\n+            this.unallocatedSize = unallocatedSize;\n+            this.size = size;\n+            this.sectorSize = sectorSize;\n+            this.timeZone = timeZone;\n+            this.imageType = imageType;\n+            this.paths = paths == null ? Collections.emptyList() : new ArrayList<>(paths);\n+            this.md5Hash = md5Hash;\n+            this.sha1Hash = sha1Hash;\n+            this.sha256Hash = sha256Hash;\n+        }\n+\n+        /**\n+         * @return Size in bytes of unallocated space.\n+         */\n+        long getUnallocatedSize() {\n+            return unallocatedSize;\n+        }\n+\n+        /**\n+         * @return Total size in bytes.\n+         */\n+        long getSize() {\n+            return size;\n+        }\n+\n+        /**\n+         * @return Sector size in bytes.\n+         */\n+        long getSectorSize() {\n+            return sectorSize;\n+        }\n+\n+        /**\n+         * @return The time zone.\n+         */\n+        String getTimeZone() {\n+            return timeZone;\n+        }\n+\n+        /**\n+         * @return The type of image.\n+         */\n+        String getImageType() {\n+            return imageType;\n+        }\n+\n+        /**\n+         * @return The source paths for the image.\n+         */\n+        List<String> getPaths() {\n+            return paths;\n+        }\n+\n+        /**\n+         * @return The md5 hash or null.\n+         */\n+        String getMd5Hash() {\n+            return md5Hash;\n+        }\n+\n+        /**\n+         * @return The sha1 hash or null.\n+         */\n+        String getSha1Hash() {\n+            return sha1Hash;\n+        }\n+\n+        /**\n+         * @return The sha256 hash or null.\n+         */\n+        String getSha256Hash() {\n+            return sha256Hash;\n+        }\n+    }\n+\n+    /**\n+     * View model for container data.\n+     */\n+    private static class ContainerViewModel {\n+\n+        private final String displayName;\n+        private final String originalName;\n+        private final String deviceIdValue;\n+        private final String acquisitionDetails;\n+        private final ImageViewModel imageViewModel;\n+\n+        /**\n+         * Main constructor.\n+         *\n+         * @param displayName The display name for this data source.\n+         * @param originalName The original name for this data source.\n+         * @param deviceIdValue The device id value for this data source.\n+         * @param acquisitionDetails The acquisition details for this data\n+         * source or null.\n+         * @param imageViewModel If the data source is an image, the image view\n+         * model for this data source or null if non-image.\n+         */\n+        ContainerViewModel(String displayName, String originalName, String deviceIdValue,\n+                String acquisitionDetails, ImageViewModel imageViewModel) {\n+            this.displayName = displayName;\n+            this.originalName = originalName;\n+            this.deviceIdValue = deviceIdValue;\n+            this.acquisitionDetails = acquisitionDetails;\n+            this.imageViewModel = imageViewModel;\n+        }\n+\n+        /**\n+         * @return The display name for this data source.\n+         */\n+        String getDisplayName() {\n+            return displayName;\n+        }\n+\n+        /**\n+         * @return The original name for this data source.\n+         */\n+        String getOriginalName() {\n+            return originalName;\n+        }\n+\n+        /**\n+         * @return The device id value for this data source.\n          */\n-        ContainerPanelData(DataSource dataSource, Long unallocatedFilesSize) {\n-            this.dataSource = dataSource;\n-            this.unallocatedFilesSize = unallocatedFilesSize;\n+        String getDeviceId() {\n+            return deviceIdValue;\n         }\n \n         /**\n-         * @return The original datasource.\n+         * @return The acquisition details for this data source or null.\n          */\n-        DataSource getDataSource() {\n-            return dataSource;\n+        String getAcquisitionDetails() {\n+            return acquisitionDetails;\n         }\n \n         /**\n-         * @return The unallocated file size.\n+         * @return If the data source is an image, the image view model for this\n+         * data source or null if non-image.\n          */\n-        Long getUnallocatedFilesSize() {\n-            return unallocatedFilesSize;\n+        ImageViewModel getImageViewModel() {\n+            return imageViewModel;\n         }\n     }\n \n@@ -103,6 +262,7 @@ public boolean isRefreshRequiredForCaseEvent(PropertyChangeEvent evt) {\n     private static final Logger logger = Logger.getLogger(ContainerPanel.class.getName());\n \n     private final List<DataFetchComponents<DataSource, ?>> dataFetchComponents;\n+    private final DataFetcher<DataSource, ContainerViewModel> containerDataFetcher;\n \n     /**\n      * Creates a new form ContainerPanel.\n@@ -117,30 +277,23 @@ public boolean isRefreshRequiredForCaseEvent(PropertyChangeEvent evt) {\n     ContainerPanel(ContainerSummary containerSummary) {\n         super(containerSummary, CONTAINER_UPDATES);\n \n+        containerDataFetcher = (dataSource) -> getContainerViewModel(containerSummary, dataSource);\n+\n         dataFetchComponents = Arrays.asList(\n                 new DataFetchComponents<>(\n-                        (dataSource) -> {\n-                            return new ContainerPanelData(\n-                                    dataSource,\n-                                    containerSummary.getSizeOfUnallocatedFiles(dataSource)\n-                            );\n-                        },\n+                        containerDataFetcher,\n                         (result) -> {\n                             if (result != null && result.getResultType() == ResultType.SUCCESS) {\n-                                ContainerPanelData data = result.getData();\n-                                DataSource dataSource = (data == null) ? null : data.getDataSource();\n-                                Long unallocatedFileSize = (data == null) ? null : data.getUnallocatedFilesSize();\n-\n-                                updateDetailsPanelData(dataSource, unallocatedFileSize);\n+                                ContainerViewModel data = result.getData();\n+                                updateDetailsPanelData(data);\n                             } else {\n                                 if (result == null) {\n                                     logger.log(Level.WARNING, \"No data fetch result was provided to the ContainerPanel.\");\n                                 } else {\n                                     logger.log(Level.WARNING, \"An exception occurred while attempting to fetch data for the ContainerPanel.\",\n                                             result.getException());\n                                 }\n-\n-                                updateDetailsPanelData(null, null);\n+                                updateDetailsPanelData(null);\n                             }\n                         }\n                 )\n@@ -161,33 +314,113 @@ protected void fetchInformation(DataSource dataSource) {\n     }\n \n     /**\n-     * Update which DataSource this panel should display details about\n+     * A means of retrieving data that could potentially throw an exception.\n+     */\n+    private interface Retriever<O> {\n+\n+        /**\n+         * Retrieves data of a certain type and possibly throws an exception.\n+         *\n+         * @return The data type.\n+         * @throws TskCoreException\n+         * @throws SleuthkitCaseProviderException\n+         * @throws SQLException\n+         */\n+        O retrieve() throws TskCoreException, SleuthkitCaseProviderException, SQLException;\n+    }\n+\n+    /**\n+     * Retrieves data of a particular type and handles any exceptions that may\n+     * be thrown by logging.\n      *\n-     * @param selectedDataSource the DataSource to display details about.\n+     * @param retriever The retrieving function.\n+     * @return The retrieved data.\n      */\n-    private void updateDetailsPanelData(DataSource selectedDataSource, Long unallocatedFilesSize) {\n+    private static <O> O retrieve(Retriever<O> retriever) {\n+        try {\n+            return retriever.retrieve();\n+        } catch (TskCoreException | SleuthkitCaseProviderException | SQLException ex) {\n+            logger.log(Level.WARNING, \"Error while retrieving data.\", ex);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Generates a container view model object containing data to display about\n+     * the data source.\n+     *\n+     * @param containerSummary The service providing data about the data source.\n+     * @param ds The data source.\n+     * @return The generated view model.\n+     */\n+    private static ContainerViewModel getContainerViewModel(ContainerSummary containerSummary, DataSource ds) {\n+        if (ds == null) {\n+            return null;\n+        }\n+\n+        return new ContainerViewModel(\n+                ds.getName(),\n+                ds.getName(),\n+                ds.getDeviceId(),\n+                retrieve(() -> ds.getAcquisitionDetails()),\n+                ds instanceof Image ? getImageViewModel(containerSummary, (Image) ds) : null\n+        );\n+    }\n+\n+    /**\n+     * Generates an image view model object containing data to display about the\n+     * image.\n+     *\n+     * @param containerSummary The service providing data about the image.\n+     * @param image The image.\n+     * @return The generated view model.\n+     */\n+    private static ImageViewModel getImageViewModel(ContainerSummary containerSummary, Image image) {\n+        if (image == null) {\n+            return null;\n+        }\n+\n+        Long unallocSize = retrieve(() -> containerSummary.getSizeOfUnallocatedFiles(image));\n+        String imageType = image.getType().getName();\n+        Long size = image.getSize();\n+        Long sectorSize = image.getSsize();\n+        String timeZone = image.getTimeZone();\n+        List<String> paths = image.getPaths() == null ? Collections.emptyList() : Arrays.asList(image.getPaths());\n+        String md5 = retrieve(() -> image.getMd5());\n+        String sha1 = retrieve(() -> image.getSha1());\n+        String sha256 = retrieve(() -> image.getSha256());\n+\n+        return new ImageViewModel(unallocSize, size, sectorSize, timeZone, imageType, paths, md5, sha1, sha256);\n+    }\n+\n+    /**\n+     * Update the swing components with fetched data.\n+     *\n+     * @param viewModel The data source view model data.\n+     */\n+    private void updateDetailsPanelData(ContainerViewModel viewModel) {\n         clearTableValues();\n-        if (selectedDataSource != null) {\n-            displayNameValue.setText(selectedDataSource.getName());\n-            originalNameValue.setText(selectedDataSource.getName());\n-            deviceIdValue.setText(selectedDataSource.getDeviceId());\n-\n-            try {\n-                acquisitionDetailsTextArea.setText(selectedDataSource.getAcquisitionDetails());\n-            } catch (TskCoreException ex) {\n-                logger.log(Level.WARNING, \"Unable to get acquisition details for selected data source\", ex);\n-            }\n+        if (viewModel == null) {\n+            return;\n+        }\n \n-            if (selectedDataSource instanceof Image) {\n-                setFieldsForImage((Image) selectedDataSource, unallocatedFilesSize);\n-            } else {\n-                setFieldsForNonImageDataSource();\n-            }\n+        displayNameValue.setText(viewModel.getDisplayName());\n+        originalNameValue.setText(viewModel.getOriginalName());\n+        deviceIdValue.setText(viewModel.getDeviceId());\n+        acquisitionDetailsTextArea.setText(viewModel.getAcquisitionDetails());\n+\n+        if (viewModel.getImageViewModel() != null) {\n+            setFieldsForImage(viewModel.getImageViewModel());\n+        } else {\n+            setFieldsForNonImageDataSource();\n         }\n \n         this.repaint();\n     }\n \n+    /**\n+     * Sets image-only fields to N/A.\n+     */\n     @Messages({\n         \"ContainerPanel_setFieldsForNonImageDataSource_na=N/A\"\n     })\n@@ -208,54 +441,24 @@ private void setFieldsForNonImageDataSource() {\n     }\n \n     /**\n-     * Sets text fields for an image. This should be called after\n-     * clearTableValues and before updateFieldVisibility to ensure the proper\n-     * rendering.\n+     * Sets fields for images.\n      *\n-     * @param selectedImage The selected image.\n-     * @param unallocatedFilesSize Unallocated file size in bytes.\n+     * @param viewModel The image view model data.\n      */\n-    private void setFieldsForImage(Image selectedImage, Long unallocatedFilesSize) {\n-        unallocatedSizeValue.setText(SizeRepresentationUtil.getSizeString(unallocatedFilesSize));\n-        imageTypeValue.setText(selectedImage.getType().getName());\n-        sizeValue.setText(SizeRepresentationUtil.getSizeString(selectedImage.getSize()));\n-        sectorSizeValue.setText(SizeRepresentationUtil.getSizeString(selectedImage.getSsize()));\n-        timeZoneValue.setText(selectedImage.getTimeZone());\n-\n-        for (String path : selectedImage.getPaths()) {\n+    private void setFieldsForImage(ImageViewModel viewModel) {\n+        unallocatedSizeValue.setText(SizeRepresentationUtil.getSizeString(viewModel.getUnallocatedSize()));\n+        imageTypeValue.setText(viewModel.getImageType());\n+        sizeValue.setText(SizeRepresentationUtil.getSizeString(viewModel.getSize()));\n+        sectorSizeValue.setText(SizeRepresentationUtil.getSizeString(viewModel.getSectorSize()));\n+        timeZoneValue.setText(viewModel.getTimeZone());\n+\n+        for (String path : viewModel.getPaths()) {\n             ((DefaultTableModel) filePathsTable.getModel()).addRow(new Object[]{path});\n         }\n \n-        try {\n-            //older databases may have null as the hash values\n-            String md5String = selectedImage.getMd5();\n-            if (md5String == null) {\n-                md5String = \"\";\n-            }\n-            md5HashValue.setText(md5String);\n-        } catch (TskCoreException ex) {\n-            logger.log(Level.WARNING, \"Unable to get MD5 for selected data source\", ex);\n-        }\n-\n-        try {\n-            String sha1String = selectedImage.getSha1();\n-            if (sha1String == null) {\n-                sha1String = \"\";\n-            }\n-            sha1HashValue.setText(sha1String);\n-        } catch (TskCoreException ex) {\n-            logger.log(Level.WARNING, \"Unable to get SHA1 for selected data source\", ex);\n-        }\n-\n-        try {\n-            String sha256String = selectedImage.getSha256();\n-            if (sha256String == null) {\n-                sha256String = \"\";\n-            }\n-            sha256HashValue.setText(sha256String);\n-        } catch (TskCoreException ex) {\n-            logger.log(Level.WARNING, \"Unable to get SHA256 for selected data source\", ex);\n-        }\n+        md5HashValue.setText(viewModel.getMd5Hash());\n+        sha1HashValue.setText(viewModel.getSha1Hash());\n+        sha256HashValue.setText(viewModel.getSha256Hash());\n     }\n \n     /**\n@@ -277,9 +480,82 @@ private void clearTableValues() {\n         ((DefaultTableModel) filePathsTable.getModel()).setRowCount(0);\n     }\n \n+    /**\n+     * Divides acquisition details into key/value pairs to be displayed in\n+     * separate cells in an excel export.\n+     *\n+     * @param acquisitionDetails The acquisition details.\n+     * @return The list of key value pairs that can be incorporated into the\n+     * excel export.\n+     */\n+    private static List<? extends ExcelItemExportable> getAcquisitionDetails(String acquisitionDetails) {\n+        if (StringUtils.isBlank(acquisitionDetails)) {\n+            return Collections.emptyList();\n+        } else {\n+            return Stream.of(acquisitionDetails.split(\"\\\\r?\\\\n\"))\n+                    .map((line) -> (StringUtils.isBlank(line)) ? null : new SingleCellExportable(line))\n+                    .filter(item -> item != null)\n+                    .collect(Collectors.toList());\n+        }\n+    }\n+\n     @Override\n-    List<ExcelExport.ExcelSheetExport> getExports(DataSource ds) {\n-        return Collections.emptyList();\n+    @Messages({\n+        \"ContainerPanel_export_displayName=Display Name:\",\n+        \"ContainerPanel_export_originalName=Name:\",\n+        \"ContainerPanel_export_deviceId=Device ID:\",\n+        \"ContainerPanel_export_timeZone=Time Zone:\",\n+        \"ContainerPanel_export_acquisitionDetails=Acquisition Details:\",\n+        \"ContainerPanel_export_imageType=Image Type:\",\n+        \"ContainerPanel_export_size=Size:\",\n+        \"ContainerPanel_export_sectorSize=Sector Size:\",\n+        \"ContainerPanel_export_md5=MD5:\",\n+        \"ContainerPanel_export_sha1=SHA1:\",\n+        \"ContainerPanel_export_sha256=SHA256:\",\n+        \"ContainerPanel_export_unallocatedSize=Unallocated Space:\",\n+        \"ContainerPanel_export_filePaths=File Paths:\",})\n+    protected List<ExcelSheetExport> getExports(DataSource ds) {\n+        ContainerViewModel result = getFetchResult(containerDataFetcher, \"Container sheets\", ds);\n+        if (ds == null || result == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        String NA = Bundle.ContainerPanel_setFieldsForNonImageDataSource_na();\n+        DefaultCellModel<?> NACell = new DefaultCellModel<>(NA);\n+\n+        ImageViewModel imageModel = result.getImageViewModel();\n+        boolean hasImage = imageModel != null;\n+\n+        DefaultCellModel<?> timeZone = hasImage ? new DefaultCellModel<>(imageModel.getTimeZone()) : NACell;\n+        DefaultCellModel<?> imageType = hasImage ? new DefaultCellModel<>(imageModel.getImageType()) : NACell;\n+        DefaultCellModel<?> size = hasImage ? SizeRepresentationUtil.getBytesCell(imageModel.getSize()) : NACell;\n+        DefaultCellModel<?> sectorSize = hasImage ? SizeRepresentationUtil.getBytesCell(imageModel.getSectorSize()) : NACell;\n+        DefaultCellModel<?> md5 = hasImage ? new DefaultCellModel<>(imageModel.getMd5Hash()) : NACell;\n+        DefaultCellModel<?> sha1 = hasImage ? new DefaultCellModel<>(imageModel.getSha1Hash()) : NACell;\n+        DefaultCellModel<?> sha256 = hasImage ? new DefaultCellModel<>(imageModel.getSha256Hash()) : NACell;\n+        DefaultCellModel<?> unallocatedSize = hasImage ? SizeRepresentationUtil.getBytesCell(imageModel.getUnallocatedSize()) : NACell;\n+        List<String> paths = result.getImageViewModel() == null ? Collections.singletonList(NA) : result.getImageViewModel().getPaths();\n+        List<SingleCellExportable> cellPaths = paths.stream()\n+                .map(SingleCellExportable::new)\n+                .collect(Collectors.toList());\n+\n+        return Arrays.asList(\n+                new ExcelSpecialFormatExport(Bundle.ContainerPanel_tabName(), Arrays.asList(\n+                        new KeyValueItemExportable(Bundle.ContainerPanel_export_displayName(), new DefaultCellModel<>(result.getDisplayName())),\n+                        new KeyValueItemExportable(Bundle.ContainerPanel_export_originalName(), new DefaultCellModel<>(result.getOriginalName())),\n+                        new KeyValueItemExportable(Bundle.ContainerPanel_export_deviceId(), new DefaultCellModel<>(result.getDeviceId())),\n+                        new KeyValueItemExportable(Bundle.ContainerPanel_export_timeZone(), timeZone),\n+                        new TitledExportable(Bundle.ContainerPanel_export_acquisitionDetails(), getAcquisitionDetails(result.getAcquisitionDetails())),\n+                        new KeyValueItemExportable(Bundle.ContainerPanel_export_imageType(), imageType),\n+                        new KeyValueItemExportable(Bundle.ContainerPanel_export_size(), size),\n+                        new KeyValueItemExportable(Bundle.ContainerPanel_export_sectorSize(), sectorSize),\n+                        new KeyValueItemExportable(Bundle.ContainerPanel_export_md5(), md5),\n+                        new KeyValueItemExportable(Bundle.ContainerPanel_export_sha1(), sha1),\n+                        new KeyValueItemExportable(Bundle.ContainerPanel_export_sha256(), sha256),\n+                        new KeyValueItemExportable(Bundle.ContainerPanel_export_unallocatedSize(), unallocatedSize),\n+                        new TitledExportable(Bundle.ContainerPanel_export_filePaths(), cellPaths)\n+                )));\n+\n     }\n \n     /**"
  },
  {
    "sha": "4a77a8a4859f8fc1b244df14cc7319410ffc89e2",
    "filename": "Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/DataSourceSummaryTabbedPane.java",
    "status": "modified",
    "additions": 6,
    "deletions": 8,
    "changes": 14,
    "blob_url": "https://github.com/sleuthkit/autopsy/blob/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/DataSourceSummaryTabbedPane.java",
    "raw_url": "https://github.com/sleuthkit/autopsy/raw/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/DataSourceSummaryTabbedPane.java",
    "contents_url": "https://api.github.com/repos/sleuthkit/autopsy/contents/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/DataSourceSummaryTabbedPane.java?ref=3563ca6b7323519ae4876cafa798a7066a26452e",
    "patch": "@@ -68,7 +68,6 @@\n          *\n          * @param tabTitle The title of the tab.\n          * @param panel The component to be displayed in the tab.\n-         * @param notifyParentClose Notifies parent to trigger a close.\n          */\n         DataSourceTab(String tabTitle, BaseDataSourceSummaryPanel panel) {\n             this(tabTitle, panel, panel::setDataSource, panel::getExports, panel::close);\n@@ -138,10 +137,10 @@ public Runnable getOnClose() {\n \n     private Runnable notifyParentClose = null;\n     private final IngestJobInfoPanel ingestHistoryPanel = new IngestJobInfoPanel();\n-    \n+\n     // create an export panel whose button triggers the export to XLSX action\n     private final ExportPanel exportPanel = new ExportPanel();\n-    \n+\n     private final List<DataSourceTab> tabs = Arrays.asList(\n             new DataSourceTab(Bundle.DataSourceSummaryTabbedPane_typesTab_title(), new TypesPanel()),\n             new DataSourceTab(Bundle.DataSourceSummaryTabbedPane_userActivityTab_title(), new UserActivityPanel()),\n@@ -155,7 +154,7 @@ public Runnable getOnClose() {\n                     Bundle.DataSourceSummaryTabbedPane_ingestHistoryTab_title(),\n                     ingestHistoryPanel,\n                     ingestHistoryPanel::setDataSource,\n-                    null,\n+                    IngestJobExcelExport::getExports,\n                     null),\n             new DataSourceTab(Bundle.DataSourceSummaryTabbedPane_detailsTab_title(), new ContainerPanel()),\n             new DataSourceTab(\n@@ -165,10 +164,10 @@ public Runnable getOnClose() {\n                     null,\n                     null)\n     );\n-    \n+\n     // the action that does the export\n     private final ExcelExportAction exportAction = new ExcelExportAction(tabs);\n-  \n+\n     private DataSource dataSource = null;\n     private CardLayout cardLayout;\n \n@@ -222,7 +221,7 @@ private void postInit() {\n \n         // set this to no datasource initially\n         cardLayout.show(this, NO_DATASOURCE_PANE);\n-        \n+\n         // set action for when user requests xlsx export\n         exportPanel.setXlsxExportAction(() -> exportAction.accept(getDataSource()));\n     }\n@@ -270,7 +269,6 @@ public void close() {\n         Case.removeEventTypeSubscriber(EnumSet.of(Case.Events.CURRENT_CASE), caseEventsListener);\n     }\n \n-\n     /**\n      * This method is called from within the constructor to initialize the form.\n      * WARNING: Do NOT modify this code. The content of this method is always"
  },
  {
    "sha": "3ad757e7be11ad76fee872e39bcd5bd9e58c4692",
    "filename": "Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/IngestJobExcelExport.java",
    "status": "added",
    "additions": 253,
    "deletions": 0,
    "changes": 253,
    "blob_url": "https://github.com/sleuthkit/autopsy/blob/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/IngestJobExcelExport.java",
    "raw_url": "https://github.com/sleuthkit/autopsy/raw/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/IngestJobExcelExport.java",
    "contents_url": "https://api.github.com/repos/sleuthkit/autopsy/contents/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/IngestJobExcelExport.java?ref=3563ca6b7323519ae4876cafa798a7066a26452e",
    "patch": "@@ -0,0 +1,253 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2021 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datasourcesummary.ui;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.function.Function;\n+import java.util.logging.Level;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import org.openide.util.NbBundle.Messages;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.casemodule.NoCurrentCaseException;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ColumnModel;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.DefaultCellModel;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelExport.ExcelSheetExport;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelTableExport;\n+import org.sleuthkit.datamodel.DataSource;\n+import org.sleuthkit.datamodel.IngestJobInfo;\n+import org.sleuthkit.datamodel.IngestModuleInfo;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * Class that handles exporting information in IngestJobInfoPanel to excel.\n+ */\n+@Messages({\n+    \"IngestJobExcelExport_startTimeColumn=Start Time\",\n+    \"IngestJobExcelExport_endTimeColumn=End Time\",\n+    \"IngestJobExcelExport_ingestStatusTimeColumn=Ingest Status\",\n+    \"IngestJobExcelExport_moduleNameTimeColumn=Module Name\",\n+    \"IngestJobExcelExport_versionColumn=Module Version\",\n+    \"IngestJobExcelExport_sheetName=Ingest History\"\n+})\n+class IngestJobExcelExport {\n+\n+    /**\n+     * An entry to display in an excel export.\n+     */\n+    private static class IngestJobEntry {\n+\n+        private final Date startTime;\n+        private final Date endTime;\n+        private final String status;\n+        private final String ingestModule;\n+        private final String ingestModuleVersion;\n+\n+        /**\n+         * Main constructor.\n+         *\n+         * @param startTime The ingest start time.\n+         * @param endTime The ingest stop time.\n+         * @param status The ingest status.\n+         * @param ingestModule The ingest module.\n+         * @param ingestModuleVersion The ingest module version.\n+         */\n+        IngestJobEntry(Date startTime, Date endTime, String status, String ingestModule, String ingestModuleVersion) {\n+            this.startTime = startTime;\n+            this.endTime = endTime;\n+            this.status = status;\n+            this.ingestModule = ingestModule;\n+            this.ingestModuleVersion = ingestModuleVersion;\n+        }\n+\n+        /**\n+         * @return The ingest start time.\n+         */\n+        Date getStartTime() {\n+            return startTime;\n+        }\n+\n+        /**\n+         * @return The ingest stop time.\n+         */\n+        Date getEndTime() {\n+            return endTime;\n+        }\n+\n+        /**\n+         * @return The ingest status.\n+         */\n+        String getStatus() {\n+            return status;\n+        }\n+\n+        /**\n+         * @return The ingest module.\n+         */\n+        String getIngestModule() {\n+            return ingestModule;\n+        }\n+\n+        /**\n+         * @return The ingest module version.\n+         */\n+        String getIngestModuleVersion() {\n+            return ingestModuleVersion;\n+        }\n+    }\n+\n+    private static final Logger logger = Logger.getLogger(IngestJobExcelExport.class.getName());\n+    private static final String DATETIME_FORMAT_STR = \"yyyy/MM/dd HH:mm:ss\";\n+    private static final DateFormat DATETIME_FORMAT = new SimpleDateFormat(DATETIME_FORMAT_STR, Locale.getDefault());\n+\n+    // columns in the excel export table to be created.\n+    private static final List<ColumnModel<IngestJobEntry, DefaultCellModel<?>>> COLUMNS = Arrays.asList(\n+            new ColumnModel<>(\n+                    Bundle.IngestJobExcelExport_startTimeColumn(),\n+                    (entry) -> getDateCell(entry.getStartTime())),\n+            new ColumnModel<>(\n+                    Bundle.IngestJobExcelExport_endTimeColumn(),\n+                    (entry) -> getDateCell(entry.getEndTime())),\n+            new ColumnModel<>(\n+                    Bundle.IngestJobExcelExport_ingestStatusTimeColumn(),\n+                    (entry) -> new DefaultCellModel<>(entry.getStatus())),\n+            new ColumnModel<>(\n+                    Bundle.IngestJobExcelExport_moduleNameTimeColumn(),\n+                    (entry) -> new DefaultCellModel<>(entry.getIngestModule())),\n+            new ColumnModel<>(\n+                    Bundle.IngestJobExcelExport_versionColumn(),\n+                    (entry) -> new DefaultCellModel<>(entry.getIngestModuleVersion()))\n+    );\n+\n+    /**\n+     * Retrieves data for a date cell.\n+     *\n+     * @param date The date.\n+     * @return The data cell to be used in the excel export.\n+     */\n+    private static DefaultCellModel<?> getDateCell(Date date) {\n+        Function<Date, String> dateParser = (dt) -> dt == null ? \"\" : DATETIME_FORMAT.format(dt);\n+        return new DefaultCellModel<>(date, dateParser, DATETIME_FORMAT_STR);\n+    }\n+\n+    /**\n+     * Retrieves all the ingest job modules and versions for a job.\n+     *\n+     * @param job The ingest job.\n+     * @return All of the corresponding entries sorted by module name.\n+     */\n+    private static List<IngestJobEntry> getEntries(IngestJobInfo job) {\n+        List<IngestModuleInfo> infoList = job.getIngestModuleInfo();\n+        if (infoList == null) {\n+            return Collections.emptyList();\n+        } else {\n+            Date startTime = job.getStartDateTime();\n+            Date endTime = job.getEndDateTime();\n+            String status = job.getStatus().getDisplayName();\n+\n+            return infoList.stream()\n+                    .filter(info -> info != null)\n+                    .map(info -> new IngestJobEntry(startTime, endTime, status, info.getDisplayName(), info.getVersion()))\n+                    .sorted((a, b) -> {\n+                        boolean aIsNull = a == null || a.getIngestModule() == null;\n+                        boolean bIsNull = b == null || b.getIngestModule() == null;\n+                        if (aIsNull || bIsNull) {\n+                            return Boolean.compare(aIsNull, bIsNull);\n+                        } else {\n+                            return a.getIngestModule().compareTo(b.getIngestModule());\n+                        }\n+                    })\n+                    .collect(Collectors.toList());\n+        }\n+    }\n+\n+    /**\n+     * For output, show ingest job details in first row present. Otherwise, set\n+     * to null.\n+     *\n+     * @param list The list of entries for an ingest job.\n+     * @return The stream of entries to be displayed.\n+     */\n+    private static Stream<IngestJobEntry> showFirstRowOnly(List<IngestJobEntry> list) {\n+        return IntStream.range(0, list.size())\n+                .mapToObj(idx -> {\n+                    IngestJobEntry entry = list.get(idx);\n+                    if (entry == null || idx == 0) {\n+                        return entry;\n+                    } else {\n+                        return new IngestJobEntry(null, null, null, entry.getIngestModule(), entry.getIngestModuleVersion());\n+                    }\n+                });\n+\n+    }\n+\n+    /**\n+     * Returns a list of sheets to be exported for the Ingest History tab.\n+     *\n+     * @param dataSource The data source.\n+     * @return The list of sheets to be included in an export.\n+     */\n+    static List<ExcelSheetExport> getExports(DataSource dataSource) {\n+        if (dataSource == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<IngestJobInfo> info = null;\n+        try {\n+            info = Case.getCurrentCaseThrows().getSleuthkitCase().getIngestJobs();\n+        } catch (NoCurrentCaseException | TskCoreException ex) {\n+            logger.log(Level.WARNING, \"There was an error fetching ingest jobs\", ex);\n+        }\n+\n+        if (info == null) {\n+            info = Collections.emptyList();\n+        }\n+\n+        List<IngestJobEntry> toDisplay = info.stream()\n+                .filter(job -> job != null && dataSource.getId() == job.getObjectId())\n+                .sorted((a, b) -> {\n+                    // sort ingest jobs by time.\n+                    boolean aIsNull = a.getStartDateTime() == null;\n+                    boolean bIsNull = b.getStartDateTime() == null;\n+                    if (aIsNull || bIsNull) {\n+                        return Boolean.compare(aIsNull, bIsNull);\n+                    } else {\n+                        return a.getStartDateTime().compareTo(b.getStartDateTime());\n+                    }\n+                })\n+                .map((job) -> getEntries(job))\n+                .filter(lst -> lst != null)\n+                .flatMap((lst) -> showFirstRowOnly(lst))\n+                .filter(item -> item != null)\n+                .collect(Collectors.toList());\n+\n+        return Arrays.asList(new ExcelTableExport<>(Bundle.IngestJobExcelExport_sheetName(), COLUMNS, toDisplay));\n+    }\n+\n+    private IngestJobExcelExport() {\n+    }\n+}"
  },
  {
    "sha": "74b9be06a8967c610251c8cb0bb18e4f2201c0a6",
    "filename": "Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/SizeRepresentationUtil.java",
    "status": "modified",
    "additions": 115,
    "deletions": 36,
    "changes": 151,
    "blob_url": "https://github.com/sleuthkit/autopsy/blob/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/SizeRepresentationUtil.java",
    "raw_url": "https://github.com/sleuthkit/autopsy/raw/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/SizeRepresentationUtil.java",
    "contents_url": "https://api.github.com/repos/sleuthkit/autopsy/contents/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/SizeRepresentationUtil.java?ref=3563ca6b7323519ae4876cafa798a7066a26452e",
    "patch": "@@ -22,6 +22,7 @@\n import java.util.Arrays;\n import java.util.List;\n import org.openide.util.NbBundle;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.DefaultCellModel;\n \n /**\n  * This class provides utilities for representing storage size in most relevant\n@@ -32,71 +33,149 @@\n     private static final int SIZE_CONVERSION_CONSTANT = 1000;\n     private static final DecimalFormat APPROXIMATE_SIZE_FORMAT = new DecimalFormat(\"#.##\");\n \n-    private static List<String> UNITS = Arrays.asList(\n-            Bundle.SizeRepresentationUtil_units_bytes(),\n-            Bundle.SizeRepresentationUtil_units_kilobytes(),\n-            Bundle.SizeRepresentationUtil_units_megabytes(),\n-            Bundle.SizeRepresentationUtil_units_gigabytes(),\n-            Bundle.SizeRepresentationUtil_units_terabytes(),\n-            Bundle.SizeRepresentationUtil_units_petabytes()\n-    );\n+    /**\n+     * A size unit corresponding to orders of magnitude of bytes (kilobyte, gigabytes, etc.).\n+     */\n+    @NbBundle.Messages({\n+        \"SizeRepresentationUtil_units_bytes=bytes\",\n+        \"SizeRepresentationUtil_units_kilobytes=KB\",\n+        \"SizeRepresentationUtil_units_megabytes=MB\",\n+        \"SizeRepresentationUtil_units_gigabytes=GB\",\n+        \"SizeRepresentationUtil_units_terabytes=TB\",\n+        \"SizeRepresentationUtil_units_petabytes=PB\"\n+    })\n+    enum SizeUnit {\n+        BYTES(Bundle.SizeRepresentationUtil_units_bytes(), \"#\", 0),\n+        KB(Bundle.SizeRepresentationUtil_units_kilobytes(), \"#,##0.00,\", 1),\n+        MB(Bundle.SizeRepresentationUtil_units_megabytes(), \"#,##0.00,,\", 2),\n+        GB(Bundle.SizeRepresentationUtil_units_gigabytes(), \"#,##0.00,,,\", 3),\n+        TB(Bundle.SizeRepresentationUtil_units_terabytes(), \"#,##0.00,,,,\", 4),\n+        PB(Bundle.SizeRepresentationUtil_units_petabytes(), \"#,##0.00,,,,,\", 5);\n+\n+        private final String suffix;\n+        private final String excelFormatString;\n+        private final long divisor;\n+\n+        /**\n+         * Main constructor.\n+         * @param suffix The string suffix to use for size unit.\n+         * @param excelFormatString The excel format string to use for this size unit.\n+         * @param power The power of 1000 of bytes for this size unit.\n+         */\n+        SizeUnit(String suffix, String excelFormatString, int power) {\n+            this.suffix = suffix;\n+            \n+            // based on https://www.mrexcel.com/board/threads/how-do-i-format-cells-to-show-gb-mb-kb.140135/\n+            this.excelFormatString = String.format(\"%s \\\"%s\\\"\", excelFormatString, suffix);\n+            this.divisor = (long) Math.pow(SIZE_CONVERSION_CONSTANT, power);\n+        }\n+\n+        /**\n+         * @return The string suffix to use for size unit.\n+         */\n+        public String getSuffix() {\n+            return suffix;\n+        }\n+\n+        /**\n+         * @return The excel format string to use for this size unit.\n+         */\n+        public String getExcelFormatString() {\n+            return excelFormatString;\n+        }\n+\n+        /**\n+         * @return The divisor to convert from bytes to this unit.\n+         */\n+        public long getDivisor() {\n+            return divisor;\n+        }\n+    }\n \n     /**\n      * Get a long size in bytes as a string formated to be read by users.\n      *\n      * @param size Long value representing a size in bytes.\n      *\n      * @return Return a string formated with a user friendly version of the size\n-     *         as a string, returns empty String when provided empty size.\n+     * as a string, returns empty String when provided empty size.\n      */\n-    public static String getSizeString(Long size) {\n+    static String getSizeString(Long size) {\n         return getSizeString(size, APPROXIMATE_SIZE_FORMAT, true);\n     }\n \n+    /**\n+     * Determines the relevant size unit that should be used for a particular size.\n+     * @param size The size in bytes.\n+     * @return The relevant size unit.\n+     */\n+    static SizeUnit getSizeUnit(Long size) {\n+        if (size == null) {\n+            return SizeUnit.values()[0];\n+        }\n+        \n+        for (int unitsIndex = 0; unitsIndex < SizeUnit.values().length; unitsIndex++) {\n+            SizeUnit unit = SizeUnit.values()[unitsIndex];\n+            long result = size / unit.getDivisor();\n+            if (result < SIZE_CONVERSION_CONSTANT) {\n+                return unit;\n+            }\n+        }\n+        \n+        return SizeUnit.values()[SizeUnit.values().length - 1];\n+    }\n+\n     /**\n      * Get a long size in bytes as a string formated to be read by users.\n      *\n-     * @param size         Long value representing a size in byte.s\n-     * @param format       The means of formatting the number.\n+     * @param size Long value representing a size in byte.s\n+     * @param format The means of formatting the number.\n      * @param showFullSize Optionally show the number of bytes in the\n-     *                     datasource.\n+     * datasource.\n      *\n      * @return Return a string formated with a user friendly version of the size\n-     *         as a string, returns empty String when provided empty size.\n+     * as a string, returns empty String when provided empty size.\n      */\n-    @NbBundle.Messages({\n-        \"SizeRepresentationUtil_units_bytes= bytes\",\n-        \"SizeRepresentationUtil_units_kilobytes= kB\",\n-        \"SizeRepresentationUtil_units_megabytes= MB\",\n-        \"SizeRepresentationUtil_units_gigabytes= GB\",\n-        \"SizeRepresentationUtil_units_terabytes= TB\",\n-        \"SizeRepresentationUtil_units_petabytes= PB\"\n-    })\n-    public static String getSizeString(Long size, DecimalFormat format, boolean showFullSize) {\n+    static String getSizeString(Long size, DecimalFormat format, boolean showFullSize) {\n         if (size == null) {\n             return \"\";\n         }\n-        double approximateSize = size;\n-        int unitsIndex = 0;\n-        for (; unitsIndex < UNITS.size(); unitsIndex++) {\n-            if (approximateSize < SIZE_CONVERSION_CONSTANT) {\n-                break;\n-            } else {\n-                approximateSize /= SIZE_CONVERSION_CONSTANT;\n-            }\n-        }\n-\n-        String fullSize = size + UNITS.get(0);\n-        String closestUnitSize = format.format(approximateSize) + UNITS.get(unitsIndex);\n \n-        if (unitsIndex == 0) {\n+        SizeUnit sizeUnit = getSizeUnit(size);\n+        if (sizeUnit == null) {\n+            sizeUnit = SizeUnit.BYTES;\n+        }\n+        \n+        String closestUnitSize = String.format(\"%s %s\", \n+                format.format(((double) size) / sizeUnit.getDivisor()), sizeUnit.getSuffix());\n+        \n+        String fullSize = String.format(\"%d %s\", size, SizeUnit.BYTES.getSuffix());\n+        if (sizeUnit.equals(SizeUnit.BYTES)) {\n             return fullSize;\n         } else if (showFullSize) {\n             return String.format(\"%s (%s)\", closestUnitSize, fullSize);\n         } else {\n             return closestUnitSize;\n         }\n     }\n+    \n+    /**\n+     * Returns a default cell model using size units.\n+     * @param bytes The number of bytes.\n+     * @return The default cell model.\n+     */\n+    static DefaultCellModel<?> getBytesCell(Long bytes) {\n+        if (bytes == null) {\n+            return new DefaultCellModel<>(\"\");\n+        } else {\n+            SizeUnit unit = SizeRepresentationUtil.getSizeUnit(bytes);\n+            if (unit == null) {\n+                unit = SizeUnit.BYTES;\n+            }\n+\n+            return new DefaultCellModel<Long>(bytes, SizeRepresentationUtil::getSizeString, unit.getExcelFormatString());\n+        }\n+    }\n \n     private SizeRepresentationUtil() {\n     }"
  },
  {
    "sha": "97fc63fc512b5e0a82bb6c86e45379e27afaabe4",
    "filename": "Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/TypesPanel.java",
    "status": "modified",
    "additions": 87,
    "deletions": 40,
    "changes": 127,
    "blob_url": "https://github.com/sleuthkit/autopsy/blob/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/TypesPanel.java",
    "raw_url": "https://github.com/sleuthkit/autopsy/raw/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/TypesPanel.java",
    "contents_url": "https://api.github.com/repos/sleuthkit/autopsy/contents/Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/TypesPanel.java?ref=3563ca6b7323519ae4876cafa798a7066a26452e",
    "patch": "@@ -31,7 +31,6 @@\n import java.util.stream.Stream;\n import org.openide.util.NbBundle.Messages;\n import org.sleuthkit.autopsy.coreutils.FileTypeUtils.FileTypeCategory;\n-import org.sleuthkit.autopsy.coreutils.Logger;\n import org.sleuthkit.autopsy.datasourcesummary.datamodel.TypesSummary;\n import org.sleuthkit.autopsy.datasourcesummary.datamodel.ContainerSummary;\n import org.sleuthkit.autopsy.datasourcesummary.datamodel.MimeTypeSummary;\n@@ -40,13 +39,16 @@\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.DataFetchResult.ResultType;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.DataFetchWorker;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.DataFetchWorker.DataFetchComponents;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.DataFetcher;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.DefaultCellModel;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelExport;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelSpecialFormatExport;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelSpecialFormatExport.KeyValueItemExportable;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.IngestRunningLabel;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.LoadableComponent;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.LoadableLabel;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.PieChartPanel;\n import org.sleuthkit.autopsy.datasourcesummary.uiutils.PieChartPanel.PieChartItem;\n-import org.sleuthkit.autopsy.modules.filetypeid.FileTypeIdModuleFactory;\n \n import org.sleuthkit.datamodel.DataSource;\n import org.sleuthkit.datamodel.TskCoreException;\n@@ -72,7 +74,8 @@\n     \"TypesPanel_fileMimeTypesChart_notAnalyzed_title=Not Analyzed\",\n     \"TypesPanel_usageLabel_title=Usage\",\n     \"TypesPanel_osLabel_title=OS\",\n-    \"TypesPanel_sizeLabel_title=Size\"})\n+    \"TypesPanel_sizeLabel_title=Size\",\n+    \"TypesPanel_excelTabName=Types\"})\n class TypesPanel extends BaseDataSourceSummaryPanel {\n \n     /**\n@@ -167,10 +170,9 @@ Color getColor() {\n \n     private static final long serialVersionUID = 1L;\n     private static final DecimalFormat INTEGER_SIZE_FORMAT = new DecimalFormat(\"#\");\n-    private static final DecimalFormat COMMA_FORMATTER = new DecimalFormat(\"#,###\");\n-    private static final String FILE_TYPE_FACTORY = FileTypeIdModuleFactory.class.getCanonicalName();\n-    private static final String FILE_TYPE_MODULE_NAME = FileTypeIdModuleFactory.getModuleName();\n-    private static final Logger logger = Logger.getLogger(TypesPanel.class.getName());\n+    private static final String COMMA_FORMAT_STR = \"#,###\";\n+\n+    private static final DecimalFormat COMMA_FORMATTER = new DecimalFormat(COMMA_FORMAT_STR);\n \n     private static final Color IMAGES_COLOR = new Color(156, 39, 176);\n     private static final Color VIDEOS_COLOR = Color.YELLOW;\n@@ -191,6 +193,15 @@ Color getColor() {\n             new TypesPieCategory(Bundle.TypesPanel_fileMimeTypesChart_unknown_title(), new HashSet<>(Arrays.asList(\"application/octet-stream\")), UNKNOWN_COLOR)\n     );\n \n+    private final DataFetcher<DataSource, String> usageFetcher;\n+    private final DataFetcher<DataSource, String> osFetcher;\n+    private final DataFetcher<DataSource, Long> sizeFetcher;\n+\n+    private final DataFetcher<DataSource, Long> allocatedFetcher;\n+    private final DataFetcher<DataSource, Long> unallocatedFetcher;\n+    private final DataFetcher<DataSource, Long> slackFetcher;\n+    private final DataFetcher<DataSource, Long> directoriesFetcher;\n+\n     private final LoadableLabel usageLabel = new LoadableLabel(Bundle.TypesPanel_usageLabel_title());\n     private final LoadableLabel osLabel = new LoadableLabel(Bundle.TypesPanel_osLabel_title());\n     private final LoadableLabel sizeLabel = new LoadableLabel(Bundle.TypesPanel_sizeLabel_title());\n@@ -246,42 +257,34 @@ public TypesPanel(\n \n         super(mimeTypeData, typeData, containerData);\n \n+        this.usageFetcher = containerData::getDataSourceType;\n+        this.osFetcher = containerData::getOperatingSystems;\n+\n+        this.sizeFetcher = (dataSource) -> dataSource == null ? null : dataSource.getSize();\n+\n+        this.allocatedFetcher = (dataSource) -> typeData.getCountOfAllocatedFiles(dataSource);\n+        this.unallocatedFetcher = (dataSource) -> typeData.getCountOfUnallocatedFiles(dataSource);\n+        this.slackFetcher = (dataSource) -> typeData.getCountOfSlackFiles(dataSource);\n+        this.directoriesFetcher = (dataSource) -> typeData.getCountOfDirectories(dataSource);\n+\n         this.dataFetchComponents = Arrays.asList(\n-                // usage label worker\n-                new DataFetchWorker.DataFetchComponents<>(\n-                        containerData::getDataSourceType,\n-                        (result) -> usageLabel.showDataFetchResult(result)),\n-                // os label worker\n-                new DataFetchWorker.DataFetchComponents<>(\n-                        containerData::getOperatingSystems,\n-                        (result) -> osLabel.showDataFetchResult(result)),\n-                // size label worker\n-                new DataFetchWorker.DataFetchComponents<>(\n-                        (dataSource) -> {\n-                            Long size = dataSource == null ? null : dataSource.getSize();\n-                            return SizeRepresentationUtil.getSizeString(size, INTEGER_SIZE_FORMAT, false);\n-                        },\n-                        sizeLabel::showDataFetchResult),\n-                // file types worker\n+                new DataFetchWorker.DataFetchComponents<>(usageFetcher, usageLabel::showDataFetchResult),\n+                new DataFetchWorker.DataFetchComponents<>(osFetcher, osLabel::showDataFetchResult),\n+                new DataFetchWorker.DataFetchComponents<>(sizeFetcher,\n+                        (sizeResult) -> sizeLabel.showDataFetchResult(\n+                                DataFetchResult.getSubResult(sizeResult,\n+                                        size -> SizeRepresentationUtil.getSizeString(size, INTEGER_SIZE_FORMAT, false)))),\n                 new DataFetchWorker.DataFetchComponents<>(\n                         (dataSource) -> getMimeTypeCategoriesModel(mimeTypeData, dataSource),\n                         this::showMimeTypeCategories),\n-                // allocated files worker\n-                new DataFetchWorker.DataFetchComponents<>(\n-                        (dataSource) -> getStringOrZero(typeData.getCountOfAllocatedFiles(dataSource)),\n-                        allocatedLabel::showDataFetchResult),\n-                // unallocated files worker\n-                new DataFetchWorker.DataFetchComponents<>(\n-                        (dataSource) -> getStringOrZero(typeData.getCountOfUnallocatedFiles(dataSource)),\n-                        unallocatedLabel::showDataFetchResult),\n-                // slack files worker\n-                new DataFetchWorker.DataFetchComponents<>(\n-                        (dataSource) -> getStringOrZero(typeData.getCountOfSlackFiles(dataSource)),\n-                        slackLabel::showDataFetchResult),\n-                // directories worker\n-                new DataFetchWorker.DataFetchComponents<>(\n-                        (dataSource) -> getStringOrZero(typeData.getCountOfDirectories(dataSource)),\n-                        directoriesLabel::showDataFetchResult)\n+                new DataFetchWorker.DataFetchComponents<>(allocatedFetcher,\n+                        countRes -> allocatedLabel.showDataFetchResult(DataFetchResult.getSubResult(countRes, (count) -> getStringOrZero(count)))),\n+                new DataFetchWorker.DataFetchComponents<>(unallocatedFetcher,\n+                        countRes -> unallocatedLabel.showDataFetchResult(DataFetchResult.getSubResult(countRes, (count) -> getStringOrZero(count)))),\n+                new DataFetchWorker.DataFetchComponents<>(slackFetcher,\n+                        countRes -> slackLabel.showDataFetchResult(DataFetchResult.getSubResult(countRes, (count) -> getStringOrZero(count)))),\n+                new DataFetchWorker.DataFetchComponents<>(directoriesFetcher,\n+                        countRes -> directoriesLabel.showDataFetchResult(DataFetchResult.getSubResult(countRes, (count) -> getStringOrZero(count))))\n         );\n \n         initComponents();\n@@ -406,9 +409,53 @@ private static String getStringOrZero(Long longVal) {\n         return longVal == null ? \"0\" : COMMA_FORMATTER.format(longVal);\n     }\n \n+    /**\n+     * Returns a key value pair to be exported in a sheet.\n+     *\n+     * @param fetcher The means of fetching the data.\n+     * @param key The key to use.\n+     * @param dataSource The data source containing the data.\n+     * @return The key value pair to be exported.\n+     */\n+    private static KeyValueItemExportable getStrExportable(DataFetcher<DataSource, String> fetcher, String key, DataSource dataSource) {\n+        String result = getFetchResult(fetcher, \"Types\", dataSource);\n+        return (result == null) ? null : new KeyValueItemExportable(key, new DefaultCellModel<>(result));\n+    }\n+\n+    /**\n+     * Returns a key value pair to be exported in a sheet formatting the long\n+     * with commas separated by orders of 1000.\n+     *\n+     * @param fetcher The means of fetching the data.\n+     * @param key The string key for this key value pair.\n+     * @param dataSource The data source.\n+     * @return The key value pair.\n+     */\n+    private static KeyValueItemExportable getCountExportable(DataFetcher<DataSource, Long> fetcher, String key, DataSource dataSource) {\n+        Long count = getFetchResult(fetcher, \"Types\", dataSource);\n+        return (count == null) ? null : new KeyValueItemExportable(key,\n+                new DefaultCellModel<Long>(count, COMMA_FORMATTER::format, COMMA_FORMAT_STR));\n+    }\n+\n     @Override\n     List<ExcelExport.ExcelSheetExport> getExports(DataSource dataSource) {\n-        return Collections.emptyList();\n+        if (dataSource == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        return Arrays.asList(new ExcelSpecialFormatExport(Bundle.TypesPanel_excelTabName(),\n+                Stream.of(\n+                        getStrExportable(usageFetcher, Bundle.TypesPanel_usageLabel_title(), dataSource),\n+                        getStrExportable(osFetcher, Bundle.TypesPanel_osLabel_title(), dataSource),\n+                        new KeyValueItemExportable(Bundle.TypesPanel_sizeLabel_title(),\n+                                SizeRepresentationUtil.getBytesCell(getFetchResult(sizeFetcher, \"Types\", dataSource))),\n+                        getCountExportable(allocatedFetcher, Bundle.TypesPanel_filesByCategoryTable_allocatedRow_title(), dataSource),\n+                        getCountExportable(unallocatedFetcher, Bundle.TypesPanel_filesByCategoryTable_unallocatedRow_title(), dataSource),\n+                        getCountExportable(slackFetcher, Bundle.TypesPanel_filesByCategoryTable_slackRow_title(), dataSource),\n+                        getCountExportable(directoriesFetcher, Bundle.TypesPanel_filesByCategoryTable_directoryRow_title(), dataSource))\n+                        .filter(sheet -> sheet != null)\n+                        .collect(Collectors.toList())\n+        ));\n     }\n \n     /**"
  },
  {
    "sha": "60d7e27112c147b7fe82faf1faf2c8255d74b1ad",
    "filename": "Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/CellModel.java",
    "status": "modified",
    "additions": 15,
    "deletions": 4,
    "changes": 19,
    "blob_url": "https://github.com/sleuthkit/autopsy/blob/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/CellModel.java",
    "raw_url": "https://github.com/sleuthkit/autopsy/raw/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/CellModel.java",
    "contents_url": "https://api.github.com/repos/sleuthkit/autopsy/contents/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/CellModel.java?ref=3563ca6b7323519ae4876cafa798a7066a26452e",
    "patch": "@@ -19,6 +19,7 @@\n package org.sleuthkit.autopsy.datasourcesummary.uiutils;\n \n import javax.swing.JLabel;\n+import org.apache.poi.ss.usermodel.HorizontalAlignment;\n \n /**\n  * Basic interface for a cell model.\n@@ -29,20 +30,23 @@\n      * Describes the horizontal alignment.\n      */\n     public enum HorizontalAlign {\n-        LEFT(JLabel.LEFT),\n-        CENTER(JLabel.CENTER),\n-        RIGHT(JLabel.RIGHT);\n+        LEFT(JLabel.LEFT, HorizontalAlignment.LEFT),\n+        CENTER(JLabel.CENTER, HorizontalAlignment.CENTER),\n+        RIGHT(JLabel.RIGHT, HorizontalAlignment.RIGHT);\n \n         private final int jlabelAlignment;\n+        private final HorizontalAlignment poiAlignment;\n \n         /**\n          * Constructor for a HorizontalAlign enum.\n          *\n          * @param jlabelAlignment The corresponding JLabel horizontal alignment\n          * number.\n+         * @param poiAlignment Horizontal alignment for Apache POI.\n          */\n-        HorizontalAlign(int jlabelAlignment) {\n+        HorizontalAlign(int jlabelAlignment, HorizontalAlignment poiAlignment) {\n             this.jlabelAlignment = jlabelAlignment;\n+            this.poiAlignment = poiAlignment;\n         }\n \n         /**\n@@ -52,6 +56,13 @@\n         int getJLabelAlignment() {\n             return this.jlabelAlignment;\n         }\n+\n+        /**\n+         * @return Horizontal alignment for Apache POI.\n+         */\n+        HorizontalAlignment getPoiAlignment() {\n+            return poiAlignment;\n+        }\n     }\n \n     /**"
  },
  {
    "sha": "06165a30236715a5f41b246ec617277d08bdb783",
    "filename": "Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/DefaultCellModel.java",
    "status": "modified",
    "additions": 5,
    "deletions": 4,
    "changes": 9,
    "blob_url": "https://github.com/sleuthkit/autopsy/blob/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/DefaultCellModel.java",
    "raw_url": "https://github.com/sleuthkit/autopsy/raw/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/DefaultCellModel.java",
    "contents_url": "https://api.github.com/repos/sleuthkit/autopsy/contents/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/DefaultCellModel.java?ref=3563ca6b7323519ae4876cafa798a7066a26452e",
    "patch": "@@ -24,21 +24,21 @@\n import java.util.List;\n import java.util.function.Function;\n import java.util.function.Supplier;\n-import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelTableExport.ExcelCellModel;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelCellModel;\n \n /**\n  * The default cell model.\n  */\n public class DefaultCellModel<T> implements GuiCellModel, ExcelCellModel {\n \n-    private final T data;\n-    private final Function<T, String> stringConverter;\n+    final T data;\n+    final Function<T, String> stringConverter;\n     String tooltip;\n     CellModel.HorizontalAlign horizontalAlignment;\n     Insets insets;\n     List<MenuItem> popupMenu;\n     Supplier<List<MenuItem>> menuItemSupplier;\n-    private final String excelFormatString;\n+    final String excelFormatString;\n \n     /**\n      * Main constructor.\n@@ -76,6 +76,7 @@ public DefaultCellModel(T data, Function<T, String> stringConverter, String exce\n         this.data = data;\n         this.stringConverter = stringConverter;\n         this.excelFormatString = excelFormatString;\n+        this.tooltip = getText();\n     }\n \n     @Override"
  },
  {
    "sha": "0ca52f12e4f2a68e7db3c2d2c1d3712bbd5ae874",
    "filename": "Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelCellModel.java",
    "status": "added",
    "additions": 32,
    "deletions": 0,
    "changes": 32,
    "blob_url": "https://github.com/sleuthkit/autopsy/blob/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelCellModel.java",
    "raw_url": "https://github.com/sleuthkit/autopsy/raw/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelCellModel.java",
    "contents_url": "https://api.github.com/repos/sleuthkit/autopsy/contents/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelCellModel.java?ref=3563ca6b7323519ae4876cafa798a7066a26452e",
    "patch": "@@ -0,0 +1,32 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2021 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datasourcesummary.uiutils;\n+\n+/**\n+ * Basic interface for a cell model.\n+ */\n+public interface ExcelCellModel extends CellModel {\n+\n+    /**\n+     * @return The format string to be used with Apache POI during excel\n+     * export or null if none necessary.\n+     */\n+    String getExcelFormatString();\n+    \n+}"
  },
  {
    "sha": "fab6558c4adf0365ca2fdf51088276419f1800b6",
    "filename": "Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelExport.java",
    "status": "modified",
    "additions": 181,
    "deletions": 3,
    "changes": 184,
    "blob_url": "https://github.com/sleuthkit/autopsy/blob/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelExport.java",
    "raw_url": "https://github.com/sleuthkit/autopsy/raw/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelExport.java",
    "contents_url": "https://api.github.com/repos/sleuthkit/autopsy/contents/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelExport.java?ref=3563ca6b7323519ae4876cafa798a7066a26452e",
    "patch": "@@ -21,13 +21,23 @@\n import java.io.File;\n import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.poi.ss.usermodel.Cell;\n import org.apache.poi.ss.usermodel.CellStyle;\n import org.apache.poi.ss.usermodel.Font;\n+import org.apache.poi.ss.usermodel.HorizontalAlignment;\n+import org.apache.poi.ss.usermodel.Row;\n import org.apache.poi.ss.usermodel.Workbook;\n import org.apache.poi.ss.usermodel.Sheet;\n import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n import org.openide.util.NbBundle.Messages;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.CellModel.HorizontalAlign;\n \n /**\n  * Class for handling Excel exporting.\n@@ -59,25 +69,135 @@ public ExcelExportException(String string, Throwable thrwbl) {\n         }\n     }\n \n+    /**\n+     * A cell style key that can be used with the WorksheetEnv to generate a\n+     * cell style to be used in a POI excel document.\n+     */\n+    static class CellStyleKey {\n+\n+        private final String formatString;\n+        private final CellStyle cellStyle;\n+        private final HorizontalAlign alignment;\n+\n+        /**\n+         * Main constructor.\n+         *\n+         * @param formatString The format string or null if no special\n+         * formatting.\n+         * @param cellStyle The base cell style or null if default is to be\n+         * used.\n+         * @param alignment The horizontal alignment or null if default is to be\n+         * used.\n+         */\n+        CellStyleKey(String formatString, CellStyle cellStyle, HorizontalAlign alignment) {\n+            this.formatString = formatString;\n+            this.cellStyle = cellStyle;\n+            this.alignment = alignment;\n+        }\n+\n+        /**\n+         * @return The format string or null if no special formatting.\n+         */\n+        String getFormatString() {\n+            return formatString;\n+        }\n+\n+        /**\n+         * @return The base cell style or null if default is to be used.\n+         */\n+        CellStyle getCellStyle() {\n+            return cellStyle;\n+        }\n+\n+        /**\n+         * @return The horizontal alignment or null if default is to be used.\n+         */\n+        HorizontalAlign getAlignment() {\n+            return alignment;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int hash = 7;\n+            hash = 29 * hash + Objects.hashCode(this.formatString);\n+            hash = 29 * hash + Objects.hashCode(this.cellStyle);\n+            hash = 29 * hash + Objects.hashCode(this.alignment);\n+            return hash;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            final CellStyleKey other = (CellStyleKey) obj;\n+            if (!Objects.equals(this.formatString, other.formatString)) {\n+                return false;\n+            }\n+            if (!Objects.equals(this.cellStyle, other.cellStyle)) {\n+                return false;\n+            }\n+            if (this.alignment != other.alignment) {\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n     /**\n      * Class detailing aspects of the worksheet.\n      */\n     public static class WorksheetEnv {\n \n         private final CellStyle headerStyle;\n         private final Workbook parentWorkbook;\n+        private final CellStyle defaultStyle;\n+\n+        // maps a data format string / original cell style combination to a created cell style\n+        private final Map<CellStyleKey, CellStyle> cellStyleCache = new HashMap<>();\n \n         /**\n          * Main constructor.\n          *\n          * @param headerStyle The cell style to use for headers.\n+         * @param defaultStyle The cell style to use as a default.\n          * @param parentWorkbook The parent workbook.\n          */\n-        WorksheetEnv(CellStyle headerStyle, Workbook parentWorkbook) {\n+        WorksheetEnv(CellStyle headerStyle, CellStyle defaultStyle, Workbook parentWorkbook) {\n             this.headerStyle = headerStyle;\n+            this.defaultStyle = defaultStyle;\n             this.parentWorkbook = parentWorkbook;\n         }\n \n+        /**\n+         * Returns a cell style signified by the given cell style key. If the\n+         * key is already present, a cached version is returned.\n+         *\n+         * @param cellStyleKey The key.\n+         * @return The cell style representing this key.\n+         */\n+        public CellStyle getCellStyle(CellStyleKey cellStyleKey) {\n+            return cellStyleCache.computeIfAbsent(cellStyleKey, (pair) -> {\n+                CellStyle computed = this.parentWorkbook.createCellStyle();\n+                computed.cloneStyleFrom(cellStyleKey.getCellStyle() == null ? defaultStyle : cellStyleKey.getCellStyle());\n+\n+                if (cellStyleKey.getAlignment() != null) {\n+                    computed.setAlignment(cellStyleKey.getAlignment().getPoiAlignment());\n+                }\n+\n+                if (cellStyleKey.getFormatString() != null) {\n+                    computed.setDataFormat(this.parentWorkbook.getCreationHelper().createDataFormat().getFormat(cellStyleKey.getFormatString()));\n+                }\n+                return computed;\n+            });\n+        }\n+\n         /**\n          * Returns the cell style to use for headers.\n          *\n@@ -87,6 +207,15 @@ public CellStyle getHeaderStyle() {\n             return headerStyle;\n         }\n \n+        /**\n+         * Returns the cell style for default items.\n+         *\n+         * @return The cell style for default items.\n+         */\n+        public CellStyle getDefaultCellStyle() {\n+            return defaultStyle;\n+        }\n+\n         /**\n          * Returns the parent workbook.\n          *\n@@ -125,6 +254,7 @@ public Workbook getParentWorkbook() {\n \n     /**\n      * Retrieves a singleton instance of this class.\n+     *\n      * @return The instance.\n      */\n     public static ExcelExport getInstance() {\n@@ -141,10 +271,11 @@ private ExcelExport() {\n \n     /**\n      * Writes the exports to a workbook.\n+     *\n      * @param exports The sheets to export.\n      * @param path The path to the output file.\n      * @throws IOException\n-     * @throws ExcelExportException \n+     * @throws ExcelExportException\n      */\n     @Messages({\n         \"# {0} - sheetNumber\",\n@@ -160,10 +291,15 @@ public void writeExcel(List<ExcelSheetExport> exports, File path) throws IOExcep\n         //headerFont.setFontHeightInPoints((short) 14);\n \n         // Create a CellStyle with the font\n+        HorizontalAlignment alignment = HorizontalAlignment.LEFT;\n         CellStyle headerCellStyle = workbook.createCellStyle();\n         headerCellStyle.setFont(headerFont);\n+        headerCellStyle.setAlignment(alignment);\n+\n+        CellStyle defaultCellStyle = workbook.createCellStyle();\n+        defaultCellStyle.setAlignment(alignment);\n \n-        WorksheetEnv env = new WorksheetEnv(headerCellStyle, workbook);\n+        WorksheetEnv env = new WorksheetEnv(headerCellStyle, defaultCellStyle, workbook);\n \n         if (exports != null) {\n             for (int i = 0; i < exports.size(); i++) {\n@@ -190,4 +326,46 @@ public void writeExcel(List<ExcelSheetExport> exports, File path) throws IOExcep\n         // Closing the workbook\n         workbook.close();\n     }\n+\n+    /**\n+     * Creates an excel cell given the model.\n+     *\n+     * @param env The work sheet environment including the workbook.\n+     * @param row The row in the excel document.\n+     * @param colNum The column number (not zero-indexed).\n+     * @param cellModel The model for the cell.\n+     * @param cellStyle The style to use.\n+     * @return The created cell.\n+     */\n+    static Cell createCell(WorksheetEnv env, Row row, int colNum, ExcelCellModel cellModel, Optional<CellStyle> cellStyle) {\n+        CellStyle cellStyleToUse = cellStyle.orElse(env.getDefaultCellStyle());\n+\n+        if (cellModel.getExcelFormatString() != null || cellModel.getHorizontalAlignment() != null) {\n+            cellStyleToUse = env.getCellStyle(new CellStyleKey(cellModel.getExcelFormatString(), cellStyleToUse, cellModel.getHorizontalAlignment()));\n+        }\n+\n+        Object cellData = cellModel.getData();\n+        Cell cell = row.createCell(colNum);\n+        if (cellData instanceof Calendar) {\n+            cell.setCellValue((Calendar) cellData);\n+        } else if (cellData instanceof Date) {\n+            cell.setCellValue((Date) cellData);\n+        } else if (cellData instanceof Double) {\n+            cell.setCellValue((Double) cellData);\n+        } else if (cellData instanceof String) {\n+            cell.setCellValue((String) cellData);\n+        } else if (cellData instanceof Short) {\n+            cell.setCellValue((Short) cellData);\n+        } else if (cellData instanceof Integer) {\n+            cell.setCellValue((Integer) cellData);\n+        } else if (cellData instanceof Long) {\n+            cell.setCellValue((Long) cellData);\n+        } else if (cellData instanceof Float) {\n+            cell.setCellValue((Float) cellData);\n+        } else {\n+            cell.setCellValue(cellModel.getText());\n+        }\n+        cell.setCellStyle(cellStyleToUse);\n+        return cell;\n+    }\n }"
  },
  {
    "sha": "f9c46fa5e2e8a6e24ecc24e266d35e760434bbdb",
    "filename": "Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelSpecialFormatExport.java",
    "status": "added",
    "additions": 265,
    "deletions": 0,
    "changes": 265,
    "blob_url": "https://github.com/sleuthkit/autopsy/blob/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelSpecialFormatExport.java",
    "raw_url": "https://github.com/sleuthkit/autopsy/raw/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelSpecialFormatExport.java",
    "contents_url": "https://api.github.com/repos/sleuthkit/autopsy/contents/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelSpecialFormatExport.java?ref=3563ca6b7323519ae4876cafa798a7066a26452e",
    "patch": "@@ -0,0 +1,265 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2021 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datasourcesummary.uiutils;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import org.apache.poi.ss.usermodel.Row;\n+import org.apache.poi.ss.usermodel.Sheet;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelExport.ExcelExportException;\n+\n+/**\n+ * An excel export that has special row-by-row formatting.\n+ */\n+public class ExcelSpecialFormatExport implements ExcelExport.ExcelSheetExport {\n+\n+    /**\n+     * The dimensions consumed by an item in an ExcelSpecialFormatExport list of\n+     * items to be rendered.\n+     */\n+    public static class ItemDimensions {\n+\n+        private final int rowStart;\n+        private final int rowEnd;\n+        private final int colStart;\n+        private final int colEnd;\n+\n+        /**\n+         * Main constructor.\n+         *\n+         * @param rowStart The starting excel row of the item.\n+         * @param colStart The starting excel column of the item.\n+         * @param rowEnd The last excel row of the the item.\n+         * @param colEnd The last excel column of the item.\n+         */\n+        public ItemDimensions(int rowStart, int colStart, int rowEnd, int colEnd) {\n+            this.rowStart = rowStart;\n+            this.colStart = colStart;\n+            this.rowEnd = rowEnd;\n+            this.colEnd = colEnd;\n+        }\n+\n+        /**\n+         * @return The starting excel row of the item.\n+         */\n+        public int getRowStart() {\n+            return rowStart;\n+        }\n+\n+        /**\n+         * @return The last excel row of the the item.\n+         */\n+        public int getRowEnd() {\n+            return rowEnd;\n+        }\n+\n+        /**\n+         * @return The starting excel column of the item.\n+         */\n+        public int getColStart() {\n+            return colStart;\n+        }\n+\n+        /**\n+         * @return The last excel column of the item.\n+         */\n+        public int getColEnd() {\n+            return colEnd;\n+        }\n+    }\n+\n+    /**\n+     * An item to be exported in a specially formatted excel export.\n+     */\n+    public interface ExcelItemExportable {\n+\n+        /**\n+         * Writes the item to the sheet in the special format export sheet.\n+         *\n+         * @param sheet The sheet.\n+         * @param rowStart The starting row to start writing.\n+         * @param colStart The starting column to start writing.\n+         * @param env The excel export context.\n+         * @return The dimensions of what has been written.\n+         * @throws ExcelExportException\n+         */\n+        ItemDimensions write(Sheet sheet, int rowStart, int colStart, ExcelExport.WorksheetEnv env) throws ExcelExportException;\n+    }\n+\n+    /**\n+     * Writes a string to a single cell in a specially formatted excel export.\n+     */\n+    public static class SingleCellExportable implements ExcelItemExportable {\n+\n+        private final ExcelCellModel item;\n+\n+        /**\n+         * Main constructor.\n+         *\n+         * @param key The text to be written.\n+         */\n+        public SingleCellExportable(String key) {\n+            this(new DefaultCellModel<>(key));\n+        }\n+\n+        /**\n+         * Main constructor.\n+         *\n+         * @param item The cell model to be written.\n+         */\n+        public SingleCellExportable(ExcelCellModel item) {\n+            this.item = item;\n+        }\n+\n+        @Override\n+        public ItemDimensions write(Sheet sheet, int rowStart, int colStart, ExcelExport.WorksheetEnv env) throws ExcelExportException {\n+            Row row = sheet.createRow(rowStart);\n+            ExcelExport.createCell(env, row, colStart, item, Optional.empty());\n+            return new ItemDimensions(rowStart, colStart, rowStart, colStart);\n+        }\n+    }\n+\n+    /**\n+     * Writes a row consisting of first column as a key and second column as a\n+     * value.\n+     */\n+    public static class KeyValueItemExportable implements ExcelItemExportable {\n+\n+        private final ExcelCellModel key;\n+        private final ExcelCellModel value;\n+\n+        /**\n+         * Main constructor.\n+         *\n+         * @param key The string key to be exported.\n+         * @param value The cell model to be exported.\n+         */\n+        public KeyValueItemExportable(String key, ExcelCellModel value) {\n+            this(new DefaultCellModel<>(key), value);\n+        }\n+\n+        /**\n+         * Main constructor.\n+         *\n+         * @param key The cell key to be exported.\n+         * @param value The cell model to be exported.\n+         */\n+        public KeyValueItemExportable(ExcelCellModel key, ExcelCellModel value) {\n+            this.key = key;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public ItemDimensions write(Sheet sheet, int rowStart, int colStart, ExcelExport.WorksheetEnv env) throws ExcelExportException {\n+            Row row = sheet.createRow(rowStart);\n+            ExcelExport.createCell(env, row, colStart, key, Optional.of(env.getHeaderStyle()));\n+            ExcelExport.createCell(env, row, colStart + 1, value, Optional.empty());\n+            return new ItemDimensions(rowStart, colStart, rowStart, colStart + 1);\n+        }\n+    }\n+\n+    /**\n+     * A special format excel export item that shows a title and a list of items\n+     * indented one column.\n+     *\n+     * i.e.\n+     * <pre>\n+     * title\n+     *      item 1\n+     *      item 2\n+     * </pre>\n+     */\n+    public static class TitledExportable implements ExcelItemExportable {\n+\n+        private static final int DEFAULT_INDENT = 1;\n+\n+        private final String title;\n+        private final List<? extends ExcelItemExportable> children;\n+\n+        /**\n+         * Main constructor.\n+         *\n+         * @param title The title for the export.\n+         * @param children The children to be indented and enumerated.\n+         */\n+        public TitledExportable(String title, List<? extends ExcelItemExportable> children) {\n+            this.title = title;\n+            this.children = children;\n+        }\n+\n+        @Override\n+        public ItemDimensions write(Sheet sheet, int rowStart, int colStart, ExcelExport.WorksheetEnv env) throws ExcelExportException {\n+            ExcelExport.createCell(env, sheet.createRow(rowStart), colStart, new DefaultCellModel<>(title), Optional.of(env.getHeaderStyle()));\n+            int curRow = rowStart + 1;\n+            int maxCol = colStart;\n+            for (ExcelItemExportable export : children) {\n+                if (export == null) {\n+                    continue;\n+                }\n+\n+                ItemDimensions thisItemDim = export.write(sheet, curRow, colStart + DEFAULT_INDENT, env);\n+                curRow = thisItemDim.getRowEnd() + 1;\n+                maxCol = Math.max(thisItemDim.getColEnd(), maxCol);\n+            }\n+\n+            return new ItemDimensions(rowStart, colStart, curRow - 1, maxCol);\n+        }\n+    }\n+\n+    private final String sheetName;\n+    private final List<ExcelItemExportable> exports;\n+\n+    /**\n+     * Main constructor.\n+     *\n+     * @param sheetName The name of the sheet.\n+     * @param exports The row-by-row items to be exported.\n+     */\n+    public ExcelSpecialFormatExport(String sheetName, List<ExcelItemExportable> exports) {\n+        this.sheetName = sheetName;\n+        this.exports = exports == null ? Collections.emptyList() : exports;\n+    }\n+\n+    @Override\n+    public String getSheetName() {\n+        return sheetName;\n+    }\n+\n+    @Override\n+    public void renderSheet(Sheet sheet, ExcelExport.WorksheetEnv env) throws ExcelExportException {\n+        int rowStart = 0;\n+        int maxCol = 0;\n+        for (ExcelItemExportable export : exports) {\n+            if (export == null) {\n+                continue;\n+            }\n+\n+            ItemDimensions dimensions = export.write(sheet, rowStart, 0, env);\n+            rowStart = dimensions.getRowEnd() + 1;\n+            maxCol = Math.max(maxCol, dimensions.getColEnd());\n+        }\n+\n+        // Resize all columns to fit the content size\n+        for (int i = 0; i <= maxCol; i++) {\n+            sheet.autoSizeColumn(i);\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "5592344e2c907d1e995e6e938bb9ee09a950f530",
    "filename": "Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelTableExport.java",
    "status": "modified",
    "additions": 45,
    "deletions": 80,
    "changes": 125,
    "blob_url": "https://github.com/sleuthkit/autopsy/blob/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelTableExport.java",
    "raw_url": "https://github.com/sleuthkit/autopsy/raw/3563ca6b7323519ae4876cafa798a7066a26452e/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelTableExport.java",
    "contents_url": "https://api.github.com/repos/sleuthkit/autopsy/contents/Core/src/org/sleuthkit/autopsy/datasourcesummary/uiutils/ExcelTableExport.java?ref=3563ca6b7323519ae4876cafa798a7066a26452e",
    "patch": "@@ -18,40 +18,26 @@\n  */\n package org.sleuthkit.autopsy.datasourcesummary.uiutils;\n \n-import java.util.Calendar;\n import java.util.Collections;\n-import java.util.Date;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import org.apache.poi.ss.usermodel.Cell;\n-import org.apache.poi.ss.usermodel.CellStyle;\n import org.apache.poi.ss.usermodel.Row;\n import org.apache.poi.ss.usermodel.Sheet;\n-import org.apache.poi.ss.usermodel.Workbook;\n-import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelTableExport.ExcelCellModel;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelExport.ExcelExportException;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelExport.ExcelSheetExport;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelSpecialFormatExport.ExcelItemExportable;\n+import org.sleuthkit.autopsy.datasourcesummary.uiutils.ExcelSpecialFormatExport.ItemDimensions;\n \n /**\n  * An excel sheet export of table data.\n  */\n-public class ExcelTableExport<T, C extends ExcelCellModel> implements ExcelExport.ExcelSheetExport {\n-\n-    /**\n-     * Basic interface for a cell model.\n-     */\n-    public interface ExcelCellModel extends CellModel {\n-\n-        /**\n-         * @return The format string to be used with Apache POI during excel\n-         * export or null if none necessary.\n-         */\n-        String getExcelFormatString();\n-    }\n+public class ExcelTableExport<T, C extends ExcelCellModel> implements ExcelSheetExport, ExcelItemExportable {\n \n     private final String sheetName;\n     private final List<ColumnModel<T, C>> columns;\n     private final List<T> data;\n+    private final int columnIndent;\n \n     /**\n      * Main constructor.\n@@ -62,9 +48,23 @@\n      * @param data The data to export.\n      */\n     public ExcelTableExport(String sheetName, List<ColumnModel<T, C>> columns, List<T> data) {\n+        this(sheetName, columns, data, 0);\n+    }\n+\n+    /**\n+     * Main constructor.\n+     *\n+     * @param sheetName The name of the sheet. NOTE: There can be no duplicates\n+     * in a workbook.\n+     * @param columns The columns of the table.\n+     * @param data The data to export.\n+     * @param columnIndent The column indent.\n+     */\n+    public ExcelTableExport(String sheetName, List<ColumnModel<T, C>> columns, List<T> data, int columnIndent) {\n         this.sheetName = sheetName;\n         this.columns = columns;\n         this.data = data;\n+        this.columnIndent = columnIndent;\n     }\n \n     @Override\n@@ -74,100 +74,65 @@ public String getSheetName() {\n \n     @Override\n     public void renderSheet(Sheet sheet, ExcelExport.WorksheetEnv style) throws ExcelExport.ExcelExportException {\n-        renderSheet(sheet, style, columns, data);\n+        renderSheet(sheet, style, 0, columnIndent, columns, data);\n+\n         // Resize all columns to fit the content size\n         for (int i = 0; i < columns.size(); i++) {\n             sheet.autoSizeColumn(i);\n         }\n+\n+    }\n+\n+    @Override\n+    public ItemDimensions write(Sheet sheet, int rowStart, int colStart, ExcelExport.WorksheetEnv env) throws ExcelExportException {\n+        int columnStart = columnIndent + colStart;\n+        int rowsWritten = renderSheet(sheet, env, rowStart, columnStart, columns, data);\n+        return new ItemDimensions(rowStart, columnStart, rowStart + rowsWritten - 1, this.columns == null ? columnStart : columnStart + this.columns.size());\n     }\n \n     /**\n      * Renders the data into the excel sheet.\n      *\n      * @param sheet The sheet.\n      * @param worksheetEnv The worksheet environment and preferences.\n+     * @param rowStart The row to start in.\n+     * @param colStart The column to start in.\n      * @param columns The columns.\n      * @param data The data.\n      * @throws ExcelExportException\n+     * @return The number of rows (including the header) written.\n      */\n-    private static <T, C extends ExcelCellModel> void renderSheet(\n-            Sheet sheet, ExcelExport.WorksheetEnv worksheetEnv, List<ColumnModel<T, C>> columns, List<T> data)\n+    private static <T, C extends ExcelCellModel> int renderSheet(\n+            Sheet sheet,\n+            ExcelExport.WorksheetEnv worksheetEnv,\n+            int rowStart,\n+            int colStart,\n+            List<ColumnModel<T, C>> columns, List<T> data)\n             throws ExcelExport.ExcelExportException {\n \n         List<T> safeData = data == null ? Collections.emptyList() : data;\n         // Create a header row\n-        Row headerRow = sheet.createRow(0);\n+        Row headerRow = sheet.createRow(rowStart);\n         // Create header cells\n         for (int i = 0; i < columns.size(); i++) {\n-            Cell cell = headerRow.createCell(i);\n+            Cell cell = headerRow.createCell(i + colStart);\n             cell.setCellValue(columns.get(i).getHeaderTitle());\n             cell.setCellStyle(worksheetEnv.getHeaderStyle());\n         }\n         // freeze header row\n         sheet.createFreezePane(0, 1);\n         // Create Cell Style for each column (if one is needed)\n-        Map<String, CellStyle> cellStyles = new HashMap<>();\n+\n         for (int rowNum = 0; rowNum < safeData.size(); rowNum++) {\n             T rowData = safeData.get(rowNum);\n-            Row row = sheet.createRow(rowNum + 1);\n+            Row row = sheet.createRow(rowNum + rowStart + 1);\n             for (int colNum = 0; colNum < columns.size(); colNum++) {\n                 ColumnModel<T, ? extends ExcelCellModel> colModel = columns.get(colNum);\n                 ExcelCellModel cellModel = colModel.getCellRenderer().apply(rowData);\n-                String formatString = cellModel.getExcelFormatString();\n-                Optional<CellStyle> cellStyle = (formatString == null)\n-                        ? Optional.empty()\n-                        : Optional.of(cellStyles.computeIfAbsent(formatString, k -> createCellStyle(worksheetEnv.getParentWorkbook(), formatString)));\n-                createCell(row, colNum, cellModel, cellStyle);\n+                ExcelExport.createCell(worksheetEnv, row, colNum + colStart, cellModel, Optional.empty());\n             }\n         }\n-    }\n-\n-    /**\n-     * Create a cell style in the workbook with the given format string.\n-     *\n-     * @param workbook The workbook.\n-     * @param formatString The format string.\n-     * @return The cell style.\n-     */\n-    private static <T> CellStyle createCellStyle(Workbook workbook, String formatString) {\n-        CellStyle cellStyle = workbook.createCellStyle();\n-        cellStyle.setDataFormat(workbook.getCreationHelper().createDataFormat().getFormat(formatString));\n-        return cellStyle;\n-    }\n \n-    /**\n-     * Creates an excel cell given the model.\n-     *\n-     * @param row The row in the excel document.\n-     * @param colNum The column number (not zero-indexed).\n-     * @param cellModel The model for the cell.\n-     * @param cellStyle The style to use.\n-     * @return The created cell.\n-     */\n-    private static Cell createCell(Row row, int colNum, ExcelCellModel cellModel, Optional<CellStyle> cellStyle) {\n-        Object cellData = cellModel.getData();\n-        Cell cell = row.createCell(colNum);\n-        if (cellData instanceof Calendar) {\n-            cell.setCellValue((Calendar) cellData);\n-        } else if (cellData instanceof Date) {\n-            cell.setCellValue((Date) cellData);\n-        } else if (cellData instanceof Double) {\n-            cell.setCellValue((Double) cellData);\n-        } else if (cellData instanceof String) {\n-            cell.setCellValue((String) cellData);\n-        } else if (cellData instanceof Short) {\n-            cell.setCellValue((Short) cellData);\n-        } else if (cellData instanceof Integer) {\n-            cell.setCellValue((Integer) cellData);\n-        } else if (cellData instanceof Long) {\n-            cell.setCellValue((Long) cellData);\n-        } else if (cellData instanceof Float) {\n-            cell.setCellValue((Float) cellData);\n-        } else {\n-            cell.setCellValue(cellModel.getText());\n-        }\n-        cellStyle.ifPresent(cs -> cell.setCellStyle(cs));\n-        return cell;\n+        return safeData.size() + 1;\n     }\n-\n }"
  }
]
