[
  {
    "sha": "fc18d0a940bed6ec2305548b7004e7cbe8411be0",
    "filename": "pom.xml",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/icatproject/ids.server/blob/ce2094e4f97ab2221e8407b31639478e3ed7a305/pom.xml",
    "raw_url": "https://github.com/icatproject/ids.server/raw/ce2094e4f97ab2221e8407b31639478e3ed7a305/pom.xml",
    "contents_url": "https://api.github.com/repos/icatproject/ids.server/contents/pom.xml?ref=ce2094e4f97ab2221e8407b31639478e3ed7a305",
    "patch": "@@ -94,6 +94,13 @@\n \t\t\t<scope>test</scope>\n \t\t</dependency>\n \n+\t\t<dependency>\n+\t\t\t<groupId>org.mockito</groupId>\n+\t\t\t<artifactId>mockito-core</artifactId>\n+\t\t\t<version>2.28.2</version>\n+\t\t\t<scope>test</scope>\n+\t\t</dependency>\n+\n \t\t<dependency>\n \t\t\t<groupId>javax</groupId>\n \t\t\t<artifactId>javaee-api</artifactId>"
  },
  {
    "sha": "b9340dccac827add57afceb7fa2dc9e64f76723a",
    "filename": "src/main/java/org/icatproject/ids/DataSelection.java",
    "status": "modified",
    "additions": 81,
    "deletions": 54,
    "changes": 135,
    "blob_url": "https://github.com/icatproject/ids.server/blob/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/main/java/org/icatproject/ids/DataSelection.java",
    "raw_url": "https://github.com/icatproject/ids.server/raw/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/main/java/org/icatproject/ids/DataSelection.java",
    "contents_url": "https://api.github.com/repos/icatproject/ids.server/contents/src/main/java/org/icatproject/ids/DataSelection.java?ref=ce2094e4f97ab2221e8407b31639478e3ed7a305",
    "patch": "@@ -28,11 +28,69 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+/**\n+ * Class to convert 3 comma separated strings containing Investigation, \n+ * Dataset and Datafile IDs into a Map of DsInfo objects and a Set of\n+ * DfInfo objects, containing all the fields required to perform many\n+ * of the core IDS operations.\n+ */\n public class DataSelection {\n \n-\tprivate static final org.icatproject.icat.client.ICAT restIcat = PropertyHandler.getInstance().getRestIcat();\n \tprivate final static Logger logger = LoggerFactory.getLogger(DataSelection.class);\n \n+\tprivate ICAT icat;\n+\tprivate org.icatproject.icat.client.ICAT restIcat;\n+\tprivate String userSessionId;\n+\tprivate Session userRestSession;\n+\tprivate Session restSessionToUse;\n+\tprivate int maxEntities;\n+\tprivate List<Long> invids;\n+\tprivate List<Long> dsids;\n+\tprivate List<Long> dfids;\n+\tprivate Map<Long, DsInfo> dsInfos;\n+\tprivate Set<DfInfoImpl> dfInfos;\n+\tprivate Set<Long> emptyDatasets;\n+\tprivate boolean dsWanted;\n+\tprivate boolean dfWanted;\n+\n+\n+\tpublic enum Returns {\n+\t\tDATASETS, DATASETS_AND_DATAFILES, DATAFILES\n+\t}\n+\n+\tpublic DataSelection(PropertyHandler propertyHandler, IcatReader icatReader, String userSessionId, \n+\t\t\tString investigationIds, String datasetIds, String datafileIds,\tReturns returns)\n+\t\t\tthrows BadRequestException, NotFoundException, InsufficientPrivilegesException, InternalException {\n+\n+\t\tdfids = getValidIds(\"datafileIds\", datafileIds);\n+\t\tdsids = getValidIds(\"datasetIds\", datasetIds);\n+\t\tinvids = getValidIds(\"investigationIds\", investigationIds);\n+\t\tdfWanted = returns == Returns.DATASETS_AND_DATAFILES || returns == Returns.DATAFILES;\n+\t\tdsWanted = returns == Returns.DATASETS_AND_DATAFILES || returns == Returns.DATASETS;\n+\n+\t\tthis.icat = propertyHandler.getIcatService();\n+\t\tthis.restIcat = propertyHandler.getRestIcat();\n+\t\tmaxEntities = propertyHandler.getMaxEntities();\n+\t\tthis.userSessionId = userSessionId;\n+\t\tuserRestSession = restIcat.getSession(userSessionId);\n+\t\t// by default use the user's REST ICAT session\n+\t\trestSessionToUse = userRestSession;\n+\t\ttry {\n+\t\t\tlogger.debug(\"useReaderForPerformance = {}\", propertyHandler.getUseReaderForPerformance());\n+\t\t\tlogger.debug(\"isAvailablePublicStepDatasetToDatafile = {}\", icatReader.isAvailablePublicStepDatasetToDatafile());\n+\t\t\tif (propertyHandler.getUseReaderForPerformance() && icatReader.isAvailablePublicStepDatasetToDatafile()) {\n+\t\t\t\t// if these two criteria are met, use a REST session for the reader account \n+\t\t\t\t// where possible to improve performance due to the final database queries being simpler\n+\t\t\t\trestSessionToUse = restIcat.getSession(icatReader.getSessionId());\n+\t\t\t}\n+\t\t} catch (IcatException_Exception e) {\n+\t\t\tthrow new InternalException(e.getClass() + \" \" + e.getMessage());\n+\t\t}\n+\n+\t\tlogger.debug(\"dfids: {} dsids: {} invids: {}\", dfids, dsids, invids);\n+\t\tresolveDatasetIds();\n+\t}\n+\n \t/**\n \t * Checks to see if the investigation, dataset or datafile id list is a\n \t * valid comma separated list of longs. No spaces or leading 0's. Also\n@@ -58,45 +116,6 @@\n \t\treturn result;\n \t}\n \n-\tprivate Map<Long, DsInfo> dsInfos;\n-\tprivate ICAT icat;\n-\tprivate String sessionId;\n-\tprivate boolean dfWanted;\n-\tprivate List<Long> dfids;\n-\tprivate List<Long> dsids;\n-\tprivate List<Long> invids;\n-\tprivate Set<DfInfoImpl> dfInfos;\n-\tprivate Set<Long> emptyDatasets;\n-\tprivate boolean dsWanted;\n-\tprivate Session restSession;\n-\n-\tpublic static int maxEntities = PropertyHandler.getInstance().getMaxEntities();\n-\n-\tpublic enum Returns {\n-\t\tDATASETS, DATASETS_AND_DATAFILES, DATAFILES\n-\t}\n-\n-\tpublic DataSelection(ICAT icat, String sessionId, String investigationIds, String datasetIds, String datafileIds,\n-\t\t\tReturns returns)\n-\t\t\tthrows BadRequestException, NotFoundException, InsufficientPrivilegesException, InternalException {\n-\n-\t\tthis.icat = icat;\n-\t\tthis.sessionId = sessionId;\n-\t\tdfids = getValidIds(\"datafileIds\", datafileIds);\n-\t\tdsids = getValidIds(\"datasetIds\", datasetIds);\n-\t\tinvids = getValidIds(\"investigationIds\", investigationIds);\n-\t\tdfWanted = returns == Returns.DATASETS_AND_DATAFILES || returns == Returns.DATAFILES;\n-\t\tdsWanted = returns == Returns.DATASETS_AND_DATAFILES || returns == Returns.DATASETS;\n-\t\trestSession = restIcat.getSession(sessionId);\n-\t\tlogger.debug(\"dfids: {} dsids: {} invids: {}\", dfids, dsids, invids);\n-\t\tresolveDatasetIds();\n-\n-\t}\n-\n-\tpublic Map<Long, DsInfo> getDsInfo() {\n-\t\treturn dsInfos;\n-\t}\n-\n \tprivate void resolveDatasetIds()\n \t\t\tthrows NotFoundException, InsufficientPrivilegesException, InternalException, BadRequestException {\n \t\tdsInfos = new HashMap<>();\n@@ -107,31 +126,34 @@ private void resolveDatasetIds()\n \n \t\ttry {\n \t\t\tfor (Long dfid : dfids) {\n-\t\t\t\tList<Object> dss = icat.search(sessionId,\n+\t\t\t\tList<Object> dss = icat.search(userSessionId,\n \t\t\t\t\t\t\"SELECT ds FROM Dataset ds JOIN ds.datafiles df WHERE df.id = \" + dfid\n \t\t\t\t\t\t\t\t+ \" AND df.location IS NOT NULL INCLUDE ds.investigation.facility\");\n \t\t\t\tif (dss.size() == 1) {\n \t\t\t\t\tDataset ds = (Dataset) dss.get(0);\n \t\t\t\t\tlong dsid = ds.getId();\n \t\t\t\t\tdsInfos.put(dsid, new DsInfoImpl(ds));\n \t\t\t\t\tif (dfWanted) {\n-\t\t\t\t\t\tDatafile df = (Datafile) icat.get(sessionId, \"Datafile\", dfid);\n+\t\t\t\t\t\tDatafile df = (Datafile) icat.get(userSessionId, \"Datafile\", dfid);\n \t\t\t\t\t\tString location = IdsBean.getLocation(dfid, df.getLocation());\n \t\t\t\t\t\tdfInfos.add(\n \t\t\t\t\t\t\t\tnew DfInfoImpl(dfid, df.getName(), location, df.getCreateId(), df.getModId(), dsid));\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Next line may reveal a permissions problem\n-\t\t\t\t\ticat.get(sessionId, \"Datafile\", dfid);\n+\t\t\t\t\ticat.get(userSessionId, \"Datafile\", dfid);\n \t\t\t\t\tthrow new NotFoundException(\"Datafile \" + dfid);\n \t\t\t\t}\n \t\t\t}\n+\n \t\t\tfor (Long dsid : dsids) {\n-\t\t\t\tDataset ds = (Dataset) icat.get(sessionId, \"Dataset ds INCLUDE ds.investigation.facility\", dsid);\n+\t\t\t\tDataset ds = (Dataset) icat.get(userSessionId, \"Dataset ds INCLUDE ds.investigation.facility\", dsid);\n \t\t\t\tdsInfos.put(dsid, new DsInfoImpl(ds));\n+\t\t\t\t// dataset access for the user has been checked so the REST session for the \n+\t\t\t\t// reader account can be used if the IDS setting to allow this is enabled\n \t\t\t\tString query = \"SELECT min(df.id), max(df.id), count(df.id) FROM Datafile df WHERE df.dataset.id = \"\n \t\t\t\t\t\t+ dsid + \" AND df.location IS NOT NULL\";\n-\t\t\t\tJsonArray result = Json.createReader(new ByteArrayInputStream(restSession.search(query).getBytes()))\n+\t\t\t\tJsonArray result = Json.createReader(new ByteArrayInputStream(restSessionToUse.search(query).getBytes()))\n \t\t\t\t\t\t.readArray().getJsonArray(0);\n \t\t\t\tif (result.getJsonNumber(2).longValueExact() == 0) { // Count 0\n \t\t\t\t\temptyDatasets.add(dsid);\n@@ -143,7 +165,7 @@ private void resolveDatasetIds()\n \t\t\tfor (Long invid : invids) {\n \t\t\t\tString query = \"SELECT min(ds.id), max(ds.id), count(ds.id) FROM Dataset ds WHERE ds.investigation.id = \"\n \t\t\t\t\t\t+ invid;\n-\t\t\t\tJsonArray result = Json.createReader(new ByteArrayInputStream(restSession.search(query).getBytes()))\n+\t\t\t\tJsonArray result = Json.createReader(new ByteArrayInputStream(userRestSession.search(query).getBytes()))\n \t\t\t\t\t\t.readArray().getJsonArray(0);\n \t\t\t\tmanyDss(invid, result);\n \n@@ -190,7 +212,7 @@ private void manyDss(Long invid, JsonArray result)\n \t\t\tif (count <= maxEntities) {\n \t\t\t\tString query = \"SELECT inv.name, inv.visitId, inv.facility.id,  inv.facility.name FROM Investigation inv WHERE inv.id = \"\n \t\t\t\t\t\t+ invid;\n-\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(restSession.search(query).getBytes())).readArray();\n+\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(userRestSession.search(query).getBytes())).readArray();\n \t\t\t\tif (result.size() == 0) {\n \t\t\t\t\treturn;\n \t\t\t\t}\n@@ -202,7 +224,7 @@ private void manyDss(Long invid, JsonArray result)\n \n \t\t\t\tquery = \"SELECT ds.id, ds.name, ds.location FROM Dataset ds WHERE ds.investigation.id = \" + invid\n \t\t\t\t\t\t+ \" AND ds.id BETWEEN \" + min + \" AND \" + max;\n-\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(restSession.search(query).getBytes())).readArray();\n+\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(userRestSession.search(query).getBytes())).readArray();\n \t\t\t\tfor (JsonValue tupV : result) {\n \t\t\t\t\tJsonArray tup = (JsonArray) tupV;\n \t\t\t\t\tlong dsid = tup.getJsonNumber(0).longValueExact();\n@@ -211,7 +233,7 @@ private void manyDss(Long invid, JsonArray result)\n \n \t\t\t\t\tquery = \"SELECT min(df.id), max(df.id), count(df.id) FROM Datafile df WHERE df.dataset.id = \"\n \t\t\t\t\t\t\t+ dsid + \" AND df.location IS NOT NULL\";\n-\t\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(restSession.search(query).getBytes()))\n+\t\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(userRestSession.search(query).getBytes()))\n \t\t\t\t\t\t\t.readArray().getJsonArray(0);\n \t\t\t\t\tif (result.getJsonNumber(2).longValueExact() == 0) {\n \t\t\t\t\t\temptyDatasets.add(dsid);\n@@ -224,11 +246,11 @@ private void manyDss(Long invid, JsonArray result)\n \t\t\t\tlong half = (min + max) / 2;\n \t\t\t\tString query = \"SELECT min(ds.id), max(ds.id), count(ds.id) FROM Dataset ds WHERE ds.investigation.id = \"\n \t\t\t\t\t\t+ invid + \" AND ds.id BETWEEN \" + min + \" AND \" + half;\n-\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(restSession.search(query).getBytes())).readArray();\n+\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(userRestSession.search(query).getBytes())).readArray();\n \t\t\t\tmanyDss(invid, result);\n \t\t\t\tquery = \"SELECT min(ds.id), max(ds.id), count(ds.id) FROM Dataset ds WHERE ds.investigation.id = \"\n \t\t\t\t\t\t+ invid + \" AND ds.id BETWEEN \" + half + 1 + \" AND \" + max;\n-\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(restSession.search(query).getBytes())).readArray()\n+\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(userRestSession.search(query).getBytes())).readArray()\n \t\t\t\t\t\t.getJsonArray(0);\n \t\t\t\tmanyDss(invid, result);\n \t\t\t}\n@@ -238,6 +260,8 @@ private void manyDss(Long invid, JsonArray result)\n \n \tprivate void manyDfs(long dsid, JsonArray result)\n \t\t\tthrows IcatException, InsufficientPrivilegesException, InternalException {\n+\t\t// dataset access for the user has been checked so the REST session for the \n+\t\t// reader account can be used if the IDS setting to allow this is enabled\n \t\tlong min = result.getJsonNumber(0).longValueExact();\n \t\tlong max = result.getJsonNumber(1).longValueExact();\n \t\tlong count = result.getJsonNumber(2).longValueExact();\n@@ -246,7 +270,7 @@ private void manyDfs(long dsid, JsonArray result)\n \t\t\tif (count <= maxEntities) {\n \t\t\t\tString query = \"SELECT df.id, df.name, df.location, df.createId, df.modId FROM Datafile df WHERE df.dataset.id = \"\n \t\t\t\t\t\t+ dsid + \" AND df.location IS NOT NULL AND df.id BETWEEN \" + min + \" AND \" + max;\n-\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(restSession.search(query).getBytes())).readArray();\n+\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(restSessionToUse.search(query).getBytes())).readArray();\n \t\t\t\tfor (JsonValue tupV : result) {\n \t\t\t\t\tJsonArray tup = (JsonArray) tupV;\n \t\t\t\t\tlong dfid = tup.getJsonNumber(0).longValueExact();\n@@ -258,17 +282,20 @@ private void manyDfs(long dsid, JsonArray result)\n \t\t\t\tlong half = (min + max) / 2;\n \t\t\t\tString query = \"SELECT min(df.id), max(df.id), count(df.id) FROM Datafile df WHERE df.dataset.id = \"\n \t\t\t\t\t\t+ dsid + \" AND df.location IS NOT NULL AND df.id BETWEEN \" + min + \" AND \" + half;\n-\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(restSession.search(query).getBytes())).readArray()\n+\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(restSessionToUse.search(query).getBytes())).readArray()\n \t\t\t\t\t\t.getJsonArray(0);\n \t\t\t\tmanyDfs(dsid, result);\n \t\t\t\tquery = \"SELECT min(df.id), max(df.id), count(df.id) FROM Datafile df WHERE df.dataset.id = \" + dsid\n \t\t\t\t\t\t+ \" AND df.location IS NOT NULL AND df.id BETWEEN \" + (half + 1) + \" AND \" + max;\n-\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(restSession.search(query).getBytes())).readArray()\n+\t\t\t\tresult = Json.createReader(new ByteArrayInputStream(restSessionToUse.search(query).getBytes())).readArray()\n \t\t\t\t\t\t.getJsonArray(0);\n \t\t\t\tmanyDfs(dsid, result);\n \t\t\t}\n \t\t}\n+\t}\n \n+\tpublic Map<Long, DsInfo> getDsInfo() {\n+\t\treturn dsInfos;\n \t}\n \n \tpublic Set<DfInfoImpl> getDfInfo() {"
  },
  {
    "sha": "505c27995f7e064783382bba22646dcef3ff2a09",
    "filename": "src/main/java/org/icatproject/ids/IcatReader.java",
    "status": "modified",
    "additions": 46,
    "deletions": 1,
    "changes": 47,
    "blob_url": "https://github.com/icatproject/ids.server/blob/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/main/java/org/icatproject/ids/IcatReader.java",
    "raw_url": "https://github.com/icatproject/ids.server/raw/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/main/java/org/icatproject/ids/IcatReader.java",
    "contents_url": "https://api.github.com/repos/icatproject/ids.server/contents/src/main/java/org/icatproject/ids/IcatReader.java?ref=ce2094e4f97ab2221e8407b31639478e3ed7a305",
    "patch": "@@ -23,6 +23,22 @@\n \n \tprivate final static Logger logger = LoggerFactory.getLogger(IcatReader.class);\n \n+\t// use Boolean class to be able to check for null (not yet set)\n+\tprivate Boolean isAvailablePublicStepDatasetToDatafile;\n+\n+\tprivate PropertyHandler propertyHandler;\n+\n+\t// required for injection when other constructors exist\n+\tpublic IcatReader() {\n+\n+\t}\n+\n+\t// primarily required for testing to make it possible to use a mocked PropertyHandler\n+\tpublic IcatReader(PropertyHandler propertyHandler) {\n+\t\tthis.propertyHandler = propertyHandler;\n+\t\tinit();\n+\t}\n+\n \t@PostConstruct\n \tprivate void init() {\n \t\ttry {\n@@ -34,7 +50,9 @@ private void init() {\n \t}\n \n \tprivate void login() throws IcatException_Exception {\n-\t\tPropertyHandler propertyHandler = PropertyHandler.getInstance();\n+\t\tif (propertyHandler == null) {\n+\t\t\tpropertyHandler = PropertyHandler.getInstance();\n+\t\t}\n \t\ticat = propertyHandler.getIcatService();\n \t\tList<String> creds = propertyHandler.getReader();\n \t\tif (creds != null) {\n@@ -91,4 +109,31 @@ public String getSessionId() throws IcatException_Exception {\n \t\t}\n \t}\n \n+\t/**\n+\t * Check whether a PublicStep is defined from a Dataset to its Datafiles\n+\t * meaning that if a user can read a Dataset then they also have access\n+\t * to all of the Datafiles within it.\n+\t * \n+\t * @return true if the PublicStep exists\n+\t * @throws IcatException_Exception if there is a problem querying ICAT\n+\t */\n+\tpublic boolean isAvailablePublicStepDatasetToDatafile() throws IcatException_Exception {\n+\t\tif (isAvailablePublicStepDatasetToDatafile == null) {\n+\t\t\tString query = \"SELECT ps from PublicStep ps WHERE ps.origin='Dataset' AND ps.field='datafiles'\";\n+\t\t\ttry {\n+\t\t\t\t// if one result is returned then the PublicStep exists\n+\t\t\t\tisAvailablePublicStepDatasetToDatafile = search(query).size() == 1;\n+\t\t\t} catch (IcatException_Exception e) {\n+\t\t\t\tif (e.getFaultInfo().getType().equals(IcatExceptionType.SESSION)) {\n+\t\t\t\t\t// login and try again\n+\t\t\t\t\tlogin();\n+\t\t\t\t\tisAvailablePublicStepDatasetToDatafile = search(query).size() == 1;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow e;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn isAvailablePublicStepDatasetToDatafile;\n+\t}\n+\n }"
  },
  {
    "sha": "abb28512967150a1b9ab424ef1769cb082566ef5",
    "filename": "src/main/java/org/icatproject/ids/IdsBean.java",
    "status": "modified",
    "additions": 28,
    "deletions": 27,
    "changes": 55,
    "blob_url": "https://github.com/icatproject/ids.server/blob/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/main/java/org/icatproject/ids/IdsBean.java",
    "raw_url": "https://github.com/icatproject/ids.server/raw/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/main/java/org/icatproject/ids/IdsBean.java",
    "contents_url": "https://api.github.com/repos/icatproject/ids.server/contents/src/main/java/org/icatproject/ids/IdsBean.java?ref=ce2094e4f97ab2221e8407b31639478e3ed7a305",
    "patch": "@@ -549,15 +549,15 @@ public void archive(String sessionId, String investigationIds, String datasetIds\n \n \t\t// Do it\n \t\tif (storageUnit == StorageUnit.DATASET) {\n-\t\t\tDataSelection dataSelection = new DataSelection(icat, sessionId, investigationIds, datasetIds, datafileIds,\n-\t\t\t\t\tReturns.DATASETS);\n+\t\t\tDataSelection dataSelection = new DataSelection(propertyHandler, reader, sessionId, \n+\t\t\t\t\tinvestigationIds, datasetIds, datafileIds, Returns.DATASETS);\n \t\t\tMap<Long, DsInfo> dsInfos = dataSelection.getDsInfo();\n \t\t\tfor (DsInfo dsInfo : dsInfos.values()) {\n \t\t\t\tfsm.queue(dsInfo, DeferredOp.ARCHIVE);\n \t\t\t}\n \t\t} else if (storageUnit == StorageUnit.DATAFILE) {\n-\t\t\tDataSelection dataSelection = new DataSelection(icat, sessionId, investigationIds, datasetIds, datafileIds,\n-\t\t\t\t\tReturns.DATAFILES);\n+\t\t\tDataSelection dataSelection = new DataSelection(propertyHandler, reader, sessionId, \n+\t\t\t\t\tinvestigationIds, datasetIds, datafileIds, Returns.DATAFILES);\n \t\t\tSet<DfInfoImpl> dfInfos = dataSelection.getDfInfo();\n \t\t\tfor (DfInfoImpl dfInfo : dfInfos) {\n \t\t\t\tfsm.queue(dfInfo, DeferredOp.ARCHIVE);\n@@ -659,8 +659,8 @@ public void delete(String sessionId, String investigationIds, String datasetIds,\n \n \t\tIdsBean.validateUUID(\"sessionId\", sessionId);\n \n-\t\tDataSelection dataSelection = new DataSelection(icat, sessionId, investigationIds, datasetIds, datafileIds,\n-\t\t\t\tReturns.DATASETS_AND_DATAFILES);\n+\t\tDataSelection dataSelection = new DataSelection(propertyHandler, reader, sessionId, \n+\t\t\t\tinvestigationIds, datasetIds, datafileIds, Returns.DATASETS_AND_DATAFILES);\n \n \t\t// Do it\n \t\tCollection<DsInfo> dsInfos = dataSelection.getDsInfo().values();\n@@ -850,8 +850,8 @@ public Response getData(String sessionId, String investigationIds, String datase\n \n \t\tvalidateUUID(\"sessionId\", sessionId);\n \n-\t\tfinal DataSelection dataSelection = new DataSelection(icat, sessionId, investigationIds, datasetIds,\n-\t\t\t\tdatafileIds, Returns.DATASETS_AND_DATAFILES);\n+\t\tfinal DataSelection dataSelection = new DataSelection(propertyHandler, reader, sessionId, \n+\t\t\t\tinvestigationIds, datasetIds, datafileIds, Returns.DATASETS_AND_DATAFILES);\n \n \t\t// Do it\n \t\tMap<Long, DsInfo> dsInfos = dataSelection.getDsInfo();\n@@ -987,8 +987,8 @@ public String getDatafileIds(String sessionId, String investigationIds, String d\n \n \t\tvalidateUUID(\"sessionId\", sessionId);\n \n-\t\tfinal DataSelection dataSelection = new DataSelection(icat, sessionId, investigationIds, datasetIds,\n-\t\t\t\tdatafileIds, Returns.DATAFILES);\n+\t\tfinal DataSelection dataSelection = new DataSelection(propertyHandler, reader, sessionId, \n+\t\t\t\tinvestigationIds, datasetIds, datafileIds, Returns.DATAFILES);\n \n \t\t// Do it\n \t\tSet<DfInfoImpl> dfInfos = dataSelection.getDfInfo();\n@@ -1261,8 +1261,8 @@ public long getSize(String sessionId, String investigationIds, String datasetIds\n \t\t\t}\n \t\t} else {\n \t\t\tlogger.debug(\"Slow computation for normal case\");\n-\t\t\tfinal DataSelection dataSelection = new DataSelection(icat, sessionId, investigationIds, datasetIds,\n-\t\t\t\t\tdatafileIds, Returns.DATASETS_AND_DATAFILES);\n+\t\t\tfinal DataSelection dataSelection = new DataSelection(propertyHandler, reader, sessionId, \n+\t\t\t\t\tinvestigationIds, datasetIds, datafileIds, Returns.DATASETS_AND_DATAFILES);\n \n \t\t\tStringBuilder sb = new StringBuilder();\n \t\t\tint n = 0;\n@@ -1445,8 +1445,8 @@ public String getStatus(String sessionId, String investigationIds, String datase\n \t\tStatus status = Status.ONLINE;\n \n \t\tif (storageUnit == StorageUnit.DATASET) {\n-\t\t\tDataSelection dataSelection = new DataSelection(icat, sessionId, investigationIds, datasetIds,\n-\t\t\t\t\tdatafileIds, Returns.DATASETS);\n+\t\t\tDataSelection dataSelection = new DataSelection(propertyHandler, reader, sessionId, \n+\t\t\t\t\tinvestigationIds, datasetIds, datafileIds, Returns.DATASETS);\n \t\t\tMap<Long, DsInfo> dsInfos = dataSelection.getDsInfo();\n \n \t\t\tSet<DsInfo> restoring = fsm.getDsRestoring();\n@@ -1465,8 +1465,8 @@ public String getStatus(String sessionId, String investigationIds, String datase\n \t\t\t\t}\n \t\t\t}\n \t\t} else if (storageUnit == StorageUnit.DATAFILE) {\n-\t\t\tDataSelection dataSelection = new DataSelection(icat, sessionId, investigationIds, datasetIds,\n-\t\t\t\t\tdatafileIds, Returns.DATAFILES);\n+\t\t\tDataSelection dataSelection = new DataSelection(propertyHandler, reader, sessionId, \n+\t\t\t\t\tinvestigationIds, datasetIds, datafileIds, Returns.DATAFILES);\n \t\t\tSet<DfInfoImpl> dfInfos = dataSelection.getDfInfo();\n \n \t\t\tSet<DfInfo> restoring = fsm.getDfRestoring();\n@@ -1485,7 +1485,8 @@ public String getStatus(String sessionId, String investigationIds, String datase\n \t\t\t}\n \t\t} else {\n \t\t\t// Throw exception if selection does not exist\n-\t\t\tnew DataSelection(icat, sessionId, investigationIds, datasetIds, datafileIds, Returns.DATASETS);\n+\t\t\tnew DataSelection(propertyHandler, reader, sessionId, \n+\t\t\t\t\tinvestigationIds, datasetIds, datafileIds, Returns.DATASETS);\n \t\t}\n \n \t\tlogger.debug(\"Status is \" + status.name());\n@@ -1720,8 +1721,8 @@ public String prepareData(String sessionId, String investigationIds, String data\n \n \t\tvalidateUUID(\"sessionId\", sessionId);\n \n-\t\tfinal DataSelection dataSelection = new DataSelection(icat, sessionId, investigationIds, datasetIds,\n-\t\t\t\tdatafileIds, Returns.DATASETS_AND_DATAFILES);\n+\t\tfinal DataSelection dataSelection = new DataSelection(propertyHandler, reader, sessionId, \n+\t\t\t\tinvestigationIds, datasetIds, datafileIds, Returns.DATASETS_AND_DATAFILES);\n \n \t\t// Do it\n \t\tString preparedId = UUID.randomUUID().toString();\n@@ -2078,8 +2079,8 @@ public void reset(String sessionId, String investigationIds, String datasetIds,\n \n \t\tvalidateUUID(\"sessionId\", sessionId);\n \n-\t\tfinal DataSelection dataSelection = new DataSelection(icat, sessionId, investigationIds, datasetIds,\n-\t\t\t\tdatafileIds, Returns.DATASETS_AND_DATAFILES);\n+\t\tfinal DataSelection dataSelection = new DataSelection(propertyHandler, reader, sessionId, \n+\t\t\t\tinvestigationIds, datasetIds, datafileIds, Returns.DATASETS_AND_DATAFILES);\n \n \t\t// Do it\n \t\tif (storageUnit == StorageUnit.DATASET) {\n@@ -2171,15 +2172,15 @@ public void restore(String sessionId, String investigationIds, String datasetIds\n \n \t\t// Do it\n \t\tif (storageUnit == StorageUnit.DATASET) {\n-\t\t\tDataSelection dataSelection = new DataSelection(icat, sessionId, investigationIds, datasetIds, datafileIds,\n-\t\t\t\t\tReturns.DATASETS);\n+\t\t\tDataSelection dataSelection = new DataSelection(propertyHandler, reader, sessionId, \n+\t\t\t\t\tinvestigationIds, datasetIds, datafileIds, Returns.DATASETS);\n \t\t\tMap<Long, DsInfo> dsInfos = dataSelection.getDsInfo();\n \t\t\tfor (DsInfo dsInfo : dsInfos.values()) {\n \t\t\t\tfsm.queue(dsInfo, DeferredOp.RESTORE);\n \t\t\t}\n \t\t} else if (storageUnit == StorageUnit.DATAFILE) {\n-\t\t\tDataSelection dataSelection = new DataSelection(icat, sessionId, investigationIds, datasetIds, datafileIds,\n-\t\t\t\t\tReturns.DATAFILES);\n+\t\t\tDataSelection dataSelection = new DataSelection(propertyHandler, reader, sessionId, \n+\t\t\t\t\tinvestigationIds, datasetIds, datafileIds, Returns.DATAFILES);\n \t\t\tSet<DfInfoImpl> dfInfos = dataSelection.getDfInfo();\n \t\t\tfor (DfInfoImpl dfInfo : dfInfos) {\n \t\t\t\tfsm.queue(dfInfo, DeferredOp.RESTORE);\n@@ -2241,8 +2242,8 @@ public void write(String sessionId, String investigationIds, String datasetIds,\n \n \t\tvalidateUUID(\"sessionId\", sessionId);\n \n-\t\tfinal DataSelection dataSelection = new DataSelection(icat, sessionId, investigationIds, datasetIds,\n-\t\t\t\tdatafileIds, Returns.DATASETS_AND_DATAFILES);\n+\t\tfinal DataSelection dataSelection = new DataSelection(propertyHandler, reader, sessionId, \n+\t\t\t\tinvestigationIds, datasetIds, datafileIds, Returns.DATASETS_AND_DATAFILES);\n \n \t\t// Do it\n \t\tMap<Long, DsInfo> dsInfos = dataSelection.getDsInfo();"
  },
  {
    "sha": "13bf2fed4962762c3df88f7bf643c3d06b1ac6db",
    "filename": "src/main/java/org/icatproject/ids/PropertyHandler.java",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/icatproject/ids.server/blob/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/main/java/org/icatproject/ids/PropertyHandler.java",
    "raw_url": "https://github.com/icatproject/ids.server/raw/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/main/java/org/icatproject/ids/PropertyHandler.java",
    "contents_url": "https://api.github.com/repos/icatproject/ids.server/contents/src/main/java/org/icatproject/ids/PropertyHandler.java?ref=ce2094e4f97ab2221e8407b31639478e3ed7a305",
    "patch": "@@ -80,6 +80,7 @@ public static Logger getLogger() {\n \tprivate String jmsTopicConnectionFactory;\n \tprivate Set<CallType> logSet = new HashSet<>();\n \tprivate org.icatproject.icat.client.ICAT restIcat;\n+\tprivate boolean useReaderForPerformance;\n \n \t@SuppressWarnings(\"unchecked\")\n \tprivate PropertyHandler() {\n@@ -244,6 +245,8 @@ private PropertyHandler() {\n \t\t\t\tlogger.info(\"'log.list' entry not present so no JMS call logging will be performed\");\n \t\t\t}\n \n+\t\t\tuseReaderForPerformance = props.getBoolean(\"useReaderForPerformance\", false);\n+\n \t\t} catch (CheckedPropertyException e) {\n \t\t\tabort(e.getMessage());\n \t\t}\n@@ -417,4 +420,7 @@ public ZipMapperInterface getZipMapper() {\n \t\treturn restIcat;\n \t}\n \n+\tpublic boolean getUseReaderForPerformance() {\n+\t\treturn useReaderForPerformance;\n+\t}\n }"
  },
  {
    "sha": "16de6bb854c7420bbc30d9c1315c46aad7e96214",
    "filename": "src/site/xhtml/installation.xhtml.vm",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/icatproject/ids.server/blob/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/site/xhtml/installation.xhtml.vm",
    "raw_url": "https://github.com/icatproject/ids.server/raw/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/site/xhtml/installation.xhtml.vm",
    "contents_url": "https://api.github.com/repos/icatproject/ids.server/contents/src/site/xhtml/installation.xhtml.vm?ref=ce2094e4f97ab2221e8407b31639478e3ed7a305",
    "patch": "@@ -164,6 +164,13 @@\n \t\t\tdirectory. The file ids.logback.xml.example may be renamed to\n \t\t\tids.logback.xml to get started.</dd>\n \n+\t\t<dt>useReaderForPerformance</dt>\n+\t\t<dd>Optional. If true allows the IDS to make use of the reader account\n+\t\t\tto improve query performance. Use of this option will always be\n+\t\t\tsubject to an additional check that the user would be otherwise\n+\t\t\tallowed to perform the query, for example, that a PublicStep exists\n+\t\t\tand access to the parent entity is allowed.</dd>\n+\n \t</dl>\n \n \t<h3>Properties for archive storage</h3>"
  },
  {
    "sha": "0396879c9cd2076bb9b03966b6cd9f6e3b8e46c0",
    "filename": "src/test/java/org/icatproject/ids/DataSelectionDevTest.java",
    "status": "added",
    "additions": 113,
    "deletions": 0,
    "changes": 113,
    "blob_url": "https://github.com/icatproject/ids.server/blob/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/test/java/org/icatproject/ids/DataSelectionDevTest.java",
    "raw_url": "https://github.com/icatproject/ids.server/raw/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/test/java/org/icatproject/ids/DataSelectionDevTest.java",
    "contents_url": "https://api.github.com/repos/icatproject/ids.server/contents/src/test/java/org/icatproject/ids/DataSelectionDevTest.java?ref=ce2094e4f97ab2221e8407b31639478e3ed7a305",
    "patch": "@@ -0,0 +1,113 @@\n+package org.icatproject.ids;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.FileInputStream;\n+import java.net.URISyntaxException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import javax.json.Json;\n+import javax.json.JsonReader;\n+\n+import org.icatproject.ICAT;\n+import org.icatproject.IcatException_Exception;\n+import org.icatproject.icat.client.IcatException;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/**\n+ * This test was created to fix issue #115 and was run against the Diamond \n+ * pre-production ICAT using specifically selected usernames of users known\n+ * to have access to a lot of data.\n+ * \n+ * As well as monitoring the time taken to create the DataSelection, detailed\n+ * monitoring of the eclipselink SQL logging was done to confirm that the \n+ * changes were having the desired effect at the database level.\n+ * \n+ * It would be extremely difficult to recreate an equivalent setup on a test \n+ * ICAT in order to perform repeatable tests so this has not been attempted.\n+ * However, this test was invaluable for testing during development and may\n+ * prove useful in the future, so has been added to the test suite even if it\n+ * remains Ignored.\n+ * \n+ * The test runs from a small set of properties defined in  \n+ * DataSelectionDevTest.properties. These need to be configured to point at the\n+ * desired ICAT (not the one used by the integration tests), define user and \n+ * reader login details, and define the lists of investigation, dataset and \n+ * datafile IDs which the defined user has access to.\n+ */\n+public class DataSelectionDevTest {\n+\n+    @Mock\n+    private PropertyHandler mockedPropertyHandler;\n+\n+    private IcatReader icatReader;\n+\n+    private Properties testProps;\n+    private String icatUrl;\n+    private ICAT icatService;\n+    private org.icatproject.icat.client.ICAT restIcat;\n+    private int maxEntities;\n+    private String userSessionId;\n+    private List<String> readerCreds;\n+    // comma separated IDs as a single string from the properties file\n+    private String investigationIds;\n+    private String datasetIds;\n+    private String datafileIds;\n+    private boolean useReaderForPerformance;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        testProps = new Properties();\n+        testProps.load(new FileInputStream(\"src/test/resources/DataSelectionDevTest.properties\"));\n+        // set up the SOAP and REST ICAT clients\n+        icatUrl = ICATGetter.getCleanUrl(testProps.getProperty(\"icat.url\"));\n+        icatService = ICATGetter.getService(icatUrl);\n+        restIcat = new org.icatproject.icat.client.ICAT(icatUrl);\n+        // get session IDs for an end user and the reader user (with read-all permissions)\n+        String userCredsString = testProps.getProperty(\"login.user\");\n+        userSessionId = TestUtils.login(icatService, userCredsString);\n+        System.out.println(\"userSessionId = \" + userSessionId);\n+        List<String> readerCreds = Arrays.asList(testProps.getProperty(\"login.reader\").trim().split(\"\\\\s+\"));\n+        this.readerCreds = readerCreds;\n+        investigationIds = testProps.getProperty(\"investigation.ids\");\n+        datasetIds = testProps.getProperty(\"dataset.ids\");\n+        datafileIds = testProps.getProperty(\"datafile.ids\");\n+        useReaderForPerformance = testProps.getProperty(\"useReaderForPerformance\").equalsIgnoreCase(\"true\");\n+        // set up a mocked version of the PropertyHandler\n+        setupPropertyHandler();\n+        icatReader = new IcatReader(mockedPropertyHandler);\n+    }\n+\n+    private void setupPropertyHandler()\n+            throws URISyntaxException, IcatException_Exception, IcatException {\n+        JsonReader parser = Json.createReader(new ByteArrayInputStream(restIcat.getProperties().getBytes()));\n+        maxEntities = parser.readObject().getInt(\"maxEntities\");\n+        MockitoAnnotations.initMocks(this);\n+        when(mockedPropertyHandler.getMaxEntities()).thenReturn(maxEntities);\n+        when(mockedPropertyHandler.getIcatService()).thenReturn(icatService);\n+        when(mockedPropertyHandler.getRestIcat()).thenReturn(restIcat);\n+        when(mockedPropertyHandler.getReader()).thenReturn(readerCreds);\n+        when(mockedPropertyHandler.getUseReaderForPerformance()).thenReturn(useReaderForPerformance);\n+    }\n+\n+    @Ignore(\"Test requires a specific ICAT setup to produce meaningful results. See class javadoc comment.\")\n+    @Test\n+    public void testCreateDataSelection() throws Exception {\n+        long startMs = System.currentTimeMillis();\n+        DataSelection dataSelection = new DataSelection(mockedPropertyHandler, icatReader, userSessionId, \n+                investigationIds, datasetIds, datafileIds, DataSelection.Returns.DATASETS_AND_DATAFILES);\n+        System.out.println(\"Creating DataSelection took \" + (System.currentTimeMillis()-startMs) + \" ms\");\n+        System.out.println(\"DsInfo size: \" + dataSelection.getDsInfo().size());\n+        System.out.println(\"DfInfo size: \" + dataSelection.getDfInfo().size());\n+        // there must be at least one Datafile in the DataSelection\n+        assertTrue(\"message\", dataSelection.getDfInfo().size()>0 );\n+    }\n+}"
  },
  {
    "sha": "62d4529df04df13999a507cb19e06306c0a8bbea",
    "filename": "src/test/java/org/icatproject/ids/IcatReaderTest.java",
    "status": "added",
    "additions": 145,
    "deletions": 0,
    "changes": 145,
    "blob_url": "https://github.com/icatproject/ids.server/blob/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/test/java/org/icatproject/ids/IcatReaderTest.java",
    "raw_url": "https://github.com/icatproject/ids.server/raw/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/test/java/org/icatproject/ids/IcatReaderTest.java",
    "contents_url": "https://api.github.com/repos/icatproject/ids.server/contents/src/test/java/org/icatproject/ids/IcatReaderTest.java?ref=ce2094e4f97ab2221e8407b31639478e3ed7a305",
    "patch": "@@ -0,0 +1,145 @@\n+package org.icatproject.ids;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.icatproject.EntityBaseBean;\n+import org.icatproject.Grouping;\n+import org.icatproject.ICAT;\n+import org.icatproject.IcatException_Exception;\n+import org.icatproject.PublicStep;\n+import org.icatproject.Rule;\n+import org.icatproject.User;\n+import org.icatproject.UserGroup;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+public class IcatReaderTest {\n+\n+    @Mock\n+    private PropertyHandler mockedPropertyHandler;\n+\n+    private String icatUrl;\n+    private ICAT icatService;\n+    private List<String> readerCreds;\n+    private String rootSessionId;\n+\n+    private List<EntityBaseBean> createdIcatObjects = new ArrayList<>();\n+    private PublicStep publicStep;\n+\n+    @Before\n+    public void setup() throws FileNotFoundException, IOException, IcatException_Exception {\n+        Properties testProps = new Properties();\n+        testProps.load(new FileInputStream(\"src/test/resources/test.properties\"));\n+        readerCreds = Arrays.asList(testProps.getProperty(\"login.reader\").trim().split(\"\\\\s+\"));\n+        String rootCredsString = testProps.getProperty(\"login.root\");\n+        // serverUrl must be defined in the maven ~/.m2/settings.xml file\n+        icatUrl = ICATGetter.getCleanUrl(System.getProperty(\"serverUrl\"));\n+        icatService = ICATGetter.getService(icatUrl);\n+        rootSessionId = TestUtils.login(icatService, rootCredsString);\n+        setupPropertyHandler();\n+        createReaderAccessToPublicSteps();\n+    }\n+\n+    private void setupPropertyHandler() {\n+        MockitoAnnotations.initMocks(this);\n+        when(mockedPropertyHandler.getIcatService()).thenReturn(icatService);\n+        when(mockedPropertyHandler.getReader()).thenReturn(readerCreds);\n+    }\n+\n+    @Test\n+    public void testIcatReaderCreation() throws IcatException_Exception {\n+        IcatReader icatReader = new IcatReader(mockedPropertyHandler);\n+        assertNotNull(\"An ICAT session ID was expected\", icatReader.getSessionId());\n+    }\n+\n+    @Test\n+    public void testPublicStepAvailablability() throws IcatException_Exception {\n+        IcatReader icatReader1 = new IcatReader(mockedPropertyHandler);\n+        assertFalse(\"PublicStep Dataset to datafiles should not be available\",\n+                icatReader1.isAvailablePublicStepDatasetToDatafile());\n+        createPublicStep();\n+        // even though the PublicStep now exists, this is not re-checked by the\n+        // IcatReader (expected/desired behaviour) so the IcatReader should\n+        // still report that the PublicStep is not available\n+        assertFalse(\"PublicStep Dataset to datafiles should still not be available\",\n+                icatReader1.isAvailablePublicStepDatasetToDatafile());\n+        // however, if a new IcatReader is created it should be available\n+        IcatReader icatReader2 = new IcatReader(mockedPropertyHandler);\n+        assertTrue(\"PublicStep Dataset to datafiles should now be available\",\n+                icatReader2.isAvailablePublicStepDatasetToDatafile());\n+    }\n+\n+    private void createPublicStep() throws IcatException_Exception {\n+        publicStep = new PublicStep();\n+        publicStep.setOrigin(\"Dataset\");\n+        publicStep.setField(\"datafiles\");\n+        publicStep.setId(icatService.create(rootSessionId, publicStep));\n+        System.out.println(\"Created PublicStep with ID: \" + publicStep.getId());\n+    }\n+\n+    private void createReaderAccessToPublicSteps() throws IcatException_Exception {\n+        User readerUser = new User();\n+        // concatenate the mnemonic and the username from the reader credentials\n+        readerUser.setName(readerCreds.get(0) + \"/\" + readerCreds.get(2));\n+        readerUser.setId(icatService.create(rootSessionId, readerUser));\n+        createdIcatObjects.add(readerUser);\n+        System.out.println(\"Created User with ID: \" + readerUser.getId());\n+\n+        Grouping readAllGrouping = new Grouping();\n+        readAllGrouping.setName(\"readall\");\n+        readAllGrouping.setId(icatService.create(rootSessionId, readAllGrouping));\n+        createdIcatObjects.add(readAllGrouping);\n+        System.out.println(\"Created Grouping with ID: \" + readAllGrouping.getId());\n+\n+        UserGroup userGroup = new UserGroup();\n+        userGroup.setUser(readerUser);\n+        userGroup.setGrouping(readAllGrouping);\n+        userGroup.setId(icatService.create(rootSessionId, userGroup));\n+        createdIcatObjects.add(userGroup);\n+        System.out.println(\"Created UserGroup with ID: \" + userGroup.getId());\n+\n+        Rule rule = new Rule();\n+        rule.setWhat(\"PublicStep\");\n+        rule.setGrouping(readAllGrouping);\n+        rule.setCrudFlags(\"R\");\n+        rule.setId(icatService.create(rootSessionId, rule));\n+        createdIcatObjects.add(rule);\n+        System.out.println(\"Created Rule with ID: \" + rule.getId());\n+    }\n+    \n+    @After\n+    public void tearDown() throws IcatException_Exception {\n+        removeCreatedIcatObjects();\n+    }\n+\n+    private void removeCreatedIcatObjects() throws IcatException_Exception {\n+        // delete the created ICAT objects in the reverse\n+        // order that they were created\n+        for (int i=createdIcatObjects.size()-1; i>=0; i--) {\n+            EntityBaseBean objectToDelete = createdIcatObjects.get(i);\n+            System.out.println(\"Deleting \" + \n+                    objectToDelete.getClass().getSimpleName() + \n+                    \" with ID: \" + objectToDelete.getId());\n+            icatService.delete(rootSessionId, objectToDelete);\n+        }\n+        if (publicStep != null) {\n+            System.out.println(\"Deleting PublicStep with ID: \" + publicStep.getId());\n+            icatService.delete(rootSessionId, publicStep);\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "3f255f369a302fc1157acc592ac10f976a168721",
    "filename": "src/test/java/org/icatproject/ids/TestUtils.java",
    "status": "added",
    "additions": 36,
    "deletions": 0,
    "changes": 36,
    "blob_url": "https://github.com/icatproject/ids.server/blob/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/test/java/org/icatproject/ids/TestUtils.java",
    "raw_url": "https://github.com/icatproject/ids.server/raw/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/test/java/org/icatproject/ids/TestUtils.java",
    "contents_url": "https://api.github.com/repos/icatproject/ids.server/contents/src/test/java/org/icatproject/ids/TestUtils.java?ref=ce2094e4f97ab2221e8407b31639478e3ed7a305",
    "patch": "@@ -0,0 +1,36 @@\n+package org.icatproject.ids;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.icatproject.ICAT;\n+import org.icatproject.IcatException_Exception;\n+import org.icatproject.Login.Credentials;\n+import org.icatproject.Login.Credentials.Entry;\n+\n+public class TestUtils {\n+\n+    /**\n+     * Do an ICAT login and get the session ID using a list of credentials of \n+     * the format (as found in the properties files):\n+     * \"db username READER password READERpass\"\n+     * \n+     * @param icatService the ICAT to log in to\n+     * @param credsString a String of credentials in the format described above \n+     * @return an ICAT session ID\n+     * @throws IcatException_Exception if the login fails\n+     */\n+    public static String login(ICAT icatService, String credsString) throws IcatException_Exception {\n+        List<String> creds = Arrays.asList(credsString.trim().split(\"\\\\s+\"));\n+        Credentials credentials = new Credentials();\n+        List<Entry> entries = credentials.getEntry();\n+        for (int i = 1; i < creds.size(); i += 2) {\n+            Entry entry = new Entry();\n+            entry.setKey(creds.get(i));\n+            entry.setValue(creds.get(i + 1));\n+            entries.add(entry);\n+        }\n+        return icatService.login(creds.get(0), credentials);\n+    }\n+\n+}"
  },
  {
    "sha": "4c098235e3b19f765034e305f854ac4671f78cb6",
    "filename": "src/test/java/org/icatproject/ids/integration/BaseTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/icatproject/ids.server/blob/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/test/java/org/icatproject/ids/integration/BaseTest.java",
    "raw_url": "https://github.com/icatproject/ids.server/raw/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/test/java/org/icatproject/ids/integration/BaseTest.java",
    "contents_url": "https://api.github.com/repos/icatproject/ids.server/contents/src/test/java/org/icatproject/ids/integration/BaseTest.java?ref=ce2094e4f97ab2221e8407b31639478e3ed7a305",
    "patch": "@@ -115,7 +115,7 @@ public static void icatsetup() throws Exception {\n \t@Before\n \tpublic void before() throws Exception {\n \t\ttestingClient = new TestingClient(setup.getIdsUrl());\n-\t\tsessionId = setup.getGoodSessionId();\n+\t\tsessionId = setup.getRootSessionId();\n \t\twaitForIds();\n \t\tpopulateStorage(setup.isTwoLevel(), setup.getStorageUnit(), setup.getKey());\n \t}"
  },
  {
    "sha": "4051deef4d5bd46440b60aafbb59ba7bb59978a8",
    "filename": "src/test/java/org/icatproject/ids/integration/util/Setup.java",
    "status": "modified",
    "additions": 7,
    "deletions": 32,
    "changes": 39,
    "blob_url": "https://github.com/icatproject/ids.server/blob/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/test/java/org/icatproject/ids/integration/util/Setup.java",
    "raw_url": "https://github.com/icatproject/ids.server/raw/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/test/java/org/icatproject/ids/integration/util/Setup.java",
    "contents_url": "https://api.github.com/repos/icatproject/ids.server/contents/src/test/java/org/icatproject/ids/integration/util/Setup.java?ref=ce2094e4f97ab2221e8407b31639478e3ed7a305",
    "patch": "@@ -1,22 +1,17 @@\n package org.icatproject.ids.integration.util;\n \n import java.io.BufferedWriter;\n-import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.net.MalformedURLException;\n import java.net.URL;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n-import java.util.List;\n import java.util.Properties;\n \n import org.icatproject.ICAT;\n-import org.icatproject.IcatException_Exception;\n-import org.icatproject.Login.Credentials;\n-import org.icatproject.Login.Credentials.Entry;\n import org.icatproject.ids.ICATGetter;\n+import org.icatproject.ids.TestUtils;\n import org.icatproject.utils.CheckedProperties;\n import org.icatproject.utils.ShellCommand;\n \n@@ -30,7 +25,7 @@\n \tprivate URL icatUrl = null;\n \tprivate URL idsUrl = null;\n \n-\tprivate String goodSessionId = null;\n+\tprivate String rootSessionId = null;\n \tprivate String forbiddenSessionId = null;\n \n \tprivate Path home;\n@@ -101,10 +96,9 @@ public Setup(String runPropertyFile) throws Exception {\n \t\t}\n \t\tupdownDir = home.resolve(testProps.getProperty(\"updownDir\"));\n \t\ticatUrl = runProperties.getURL(\"icat.url\");\n-\t\tgoodSessionId = login(testProps.getProperty(\"authorizedIcatUsername\"),\n-\t\t\t\ttestProps.getProperty(\"authorizedIcatPassword\"));\n-\t\tforbiddenSessionId = login(testProps.getProperty(\"unauthorizedIcatUsername\"),\n-\t\t\t\ttestProps.getProperty(\"unauthorizedIcatPassword\"));\n+\t\tICAT icat = ICATGetter.getService(icatUrl.toString());\n+\t\trootSessionId = TestUtils.login(icat, testProps.getProperty(\"login.root\"));\n+\t\tforbiddenSessionId = TestUtils.login(icat, testProps.getProperty(\"login.unauthorized\"));\n \n \t\tstorageDir = runProperties.getPath(\"plugin.main.dir\");\n \n@@ -134,31 +128,12 @@ public void setReliability(double d) throws IOException {\n \t\t}\n \t}\n \n-\tpublic String login(String username, String password) throws IcatException_Exception, MalformedURLException {\n-\t\tICAT icat = ICATGetter.getService(icatUrl.toString());\n-\n-\t\tCredentials credentials = new Credentials();\n-\t\tList<Entry> entries = credentials.getEntry();\n-\n-\t\tEntry u = new Entry();\n-\t\tu.setKey(\"username\");\n-\t\tu.setValue(username);\n-\t\tentries.add(u);\n-\n-\t\tEntry p = new Entry();\n-\t\tp.setKey(\"password\");\n-\t\tp.setValue(password);\n-\t\tentries.add(p);\n-\t\tString sessionId = icat.login(\"db\", credentials);\n-\t\treturn sessionId;\n-\t}\n-\n \tpublic String getForbiddenSessionId() {\n \t\treturn forbiddenSessionId;\n \t}\n \n-\tpublic String getGoodSessionId() {\n-\t\treturn goodSessionId;\n+\tpublic String getRootSessionId() {\n+\t\treturn rootSessionId;\n \t}\n \n \tpublic URL getIdsUrl() {"
  },
  {
    "sha": "7bdef2c78fc86025df0d060b636cd5028bca7f6d",
    "filename": "src/test/resources/DataSelectionDevTest.properties",
    "status": "added",
    "additions": 17,
    "deletions": 0,
    "changes": 17,
    "blob_url": "https://github.com/icatproject/ids.server/blob/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/test/resources/DataSelectionDevTest.properties",
    "raw_url": "https://github.com/icatproject/ids.server/raw/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/test/resources/DataSelectionDevTest.properties",
    "contents_url": "https://api.github.com/repos/icatproject/ids.server/contents/src/test/resources/DataSelectionDevTest.properties?ref=ce2094e4f97ab2221e8407b31639478e3ed7a305",
    "patch": "@@ -0,0 +1,17 @@\n+# defined here rather than using the serverUrl property defined in ~/.m2/settings.xml\n+# so that this test can be run against a specific ICAT\n+icat.url = https://localhost:8181\n+\n+# login details for an instrument scientist or investigation user \n+login.user = db username jbloggs password jbpw\n+\n+# login details for a user with read access to the whole ICAT\n+login.reader = db username reader password readerpw\n+\n+# comma separated list of the IDs to use when creating the DataSelection\n+# (comment out the line if not specifying IDs, rather than leaving the value empty)\n+#investigation.ids = \n+#dataset.ids = \n+#dataset.ids = \n+\n+useReaderForPerformance = true"
  },
  {
    "sha": "ca4919e356c228caa296fe250f6108ec7a14d03e",
    "filename": "src/test/resources/test.properties",
    "status": "modified",
    "additions": 7,
    "deletions": 7,
    "changes": 14,
    "blob_url": "https://github.com/icatproject/ids.server/blob/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/test/resources/test.properties",
    "raw_url": "https://github.com/icatproject/ids.server/raw/ce2094e4f97ab2221e8407b31639478e3ed7a305/src/test/resources/test.properties",
    "contents_url": "https://api.github.com/repos/icatproject/ids.server/contents/src/test/resources/test.properties?ref=ce2094e4f97ab2221e8407b31639478e3ed7a305",
    "patch": "@@ -1,12 +1,12 @@\n-# These credentials must have permission to read and download\n-# the dataset and datafiles specified below.\n-authorizedIcatUsername=root\n-authorizedIcatPassword=password\n+# login credentials for a root user\n+login.root = db username root password password\n+\n+# reader account must have read-all permissions to the whole ICAT\n+login.reader = db username reader password readerpw\n \n # These credentials must NOT have permission to read and download\n-# the dataset and datafiles below (but they have to be a valid username/password pair)\n-unauthorizedIcatUsername=guest\n-unauthorizedIcatPassword=guess\n+# (but they have to be a valid username/password pair)\n+login.unauthorized = db username guest password guess\n \n # folder, where files should be downloaded to and uploaded from. This is relative to your home directory.\n updownDir = data/ids/updown"
  }
]
