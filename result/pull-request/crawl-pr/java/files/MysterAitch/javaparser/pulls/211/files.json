[
  {
    "sha": "cc9a55460104a0e52737f0b4cc6d5cd015e4b82e",
    "filename": "changelog.md",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/changelog.md",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/changelog.md",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/changelog.md?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -42,7 +42,7 @@ Version 3.20.0\n   (PR [#3129](https://github.com/javaparser/javaparser/pull/3129), by [@dependabot](https://github.com/dependabot))\n ### Fixed\n * Issue #3038 and Issue #3071 - Hanging when certain names are resolved\n-  (PR [#3072](https://github.com/javaparser/javaparser/pull/3072), by [@mernst](https://github.com/mernst))\n+  (PR [#3072](https://github.com/javaparser/javaparser/pull/3072), by [@col-e](https://github.com/Col-E))\n * Javadoc fixes\n   (PR [#3082](https://github.com/javaparser/javaparser/pull/3082), by [@mernst](https://github.com/mernst))\n * Update readme with correct Java support versions"
  },
  {
    "sha": "2f3b94849b93e6b33e5c202da0da8e5dd7bf1c92",
    "filename": "javaparser-core-generators/pom.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-core-generators/pom.xml",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-core-generators/pom.xml",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-core-generators/pom.xml?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -3,7 +3,7 @@\n     <parent>\n         <artifactId>javaparser-parent</artifactId>\n         <groupId>com.github.javaparser</groupId>\n-        <version>3.19.1-SNAPSHOT</version>\n+        <version>3.20.1-SNAPSHOT</version>\n     </parent>\n     <modelVersion>4.0.0</modelVersion>\n "
  },
  {
    "sha": "7401670754055379d1f761627e91baa9084a3bdf",
    "filename": "javaparser-core-metamodel-generator/pom.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-core-metamodel-generator/pom.xml",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-core-metamodel-generator/pom.xml",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-core-metamodel-generator/pom.xml?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -3,7 +3,7 @@\n     <parent>\n         <artifactId>javaparser-parent</artifactId>\n         <groupId>com.github.javaparser</groupId>\n-        <version>3.19.1-SNAPSHOT</version>\n+        <version>3.20.1-SNAPSHOT</version>\n     </parent>\n     <modelVersion>4.0.0</modelVersion>\n "
  },
  {
    "sha": "56727f47f876e669e5e717e282c58334617a090f",
    "filename": "javaparser-core-serialization/pom.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-core-serialization/pom.xml",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-core-serialization/pom.xml",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-core-serialization/pom.xml?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -2,7 +2,7 @@\n \t<parent>\n \t\t<artifactId>javaparser-parent</artifactId>\n \t\t<groupId>com.github.javaparser</groupId>\n-\t\t<version>3.19.1-SNAPSHOT</version>\n+\t\t<version>3.20.1-SNAPSHOT</version>\n \t</parent>\n \t<modelVersion>4.0.0</modelVersion>\n "
  },
  {
    "sha": "9ec364c47d4b2e6a9c23076a158ac5917c3790e0",
    "filename": "javaparser-core-testing-bdd/pom.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-core-testing-bdd/pom.xml",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-core-testing-bdd/pom.xml",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-core-testing-bdd/pom.xml?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -2,7 +2,7 @@\n     <parent>\n         <artifactId>javaparser-parent</artifactId>\n         <groupId>com.github.javaparser</groupId>\n-        <version>3.19.1-SNAPSHOT</version>\n+        <version>3.20.1-SNAPSHOT</version>\n     </parent>\n     <modelVersion>4.0.0</modelVersion>\n "
  },
  {
    "sha": "44eb23175e0afe4a36e58b5e02f3cd6157980d82",
    "filename": "javaparser-core-testing/pom.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-core-testing/pom.xml",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-core-testing/pom.xml",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-core-testing/pom.xml?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -2,7 +2,7 @@\n     <parent>\n         <artifactId>javaparser-parent</artifactId>\n         <groupId>com.github.javaparser</groupId>\n-        <version>3.19.1-SNAPSHOT</version>\n+        <version>3.20.1-SNAPSHOT</version>\n     </parent>\n     <modelVersion>4.0.0</modelVersion>\n "
  },
  {
    "sha": "c7a5f5856424d48039d27574a8a71f4350810bf1",
    "filename": "javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/ClassOrInterfaceTypeTest.java",
    "status": "added",
    "additions": 119,
    "deletions": 0,
    "changes": 119,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/ClassOrInterfaceTypeTest.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/ClassOrInterfaceTypeTest.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-core-testing/src/test/java/com/github/javaparser/ast/type/ClassOrInterfaceTypeTest.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -0,0 +1,119 @@\n+package com.github.javaparser.ast.type;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.expr.AnnotationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+import com.github.javaparser.metamodel.JavaParserMetaModel;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Optional;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ClassOrInterfaceTypeTest {\n+\n+    @Test\n+    void testSetName() {\n+        ClassOrInterfaceType classOrInterfaceType = new ClassOrInterfaceType();\n+\n+        assertNotEquals(\"A\", classOrInterfaceType.getName().toString());\n+        classOrInterfaceType.setName(\"A\");\n+        assertEquals(\"A\", classOrInterfaceType.getName().toString());\n+    }\n+\n+    @Test\n+    void testNestedClass() {\n+        ClassOrInterfaceType classA = new ClassOrInterfaceType();\n+        classA.setName(\"A\");\n+        ClassOrInterfaceType classB = new ClassOrInterfaceType(classA, \"B\");\n+\n+        assertEquals(\"A.B\", classB.getNameWithScope());\n+    }\n+\n+    @Test\n+    void testWithGeneric() {\n+        ClassOrInterfaceType classA = new ClassOrInterfaceType(null, \"A\");\n+        ClassOrInterfaceType classB = new ClassOrInterfaceType(classA, new SimpleName(\"B\"), new NodeList<>(classA));\n+\n+        assertTrue(classB.getTypeArguments().isPresent());\n+        assertEquals(1, classB.getTypeArguments().get().size());\n+        assertEquals(classA, classB.getTypeArguments().get().get(0));\n+\n+        assertEquals(\"A.B\", classB.getNameWithScope());\n+        assertEquals(\"A.B<A>\", classB.asString());\n+    }\n+\n+    @Test\n+    void testWithAnnotations() {\n+        AnnotationExpr annotationExpr = StaticJavaParser.parseAnnotation(\"@Override\");\n+        ClassOrInterfaceType classA = new ClassOrInterfaceType(\n+                null, new SimpleName(\"A\"), null, new NodeList<>(annotationExpr));\n+\n+        assertEquals(1, classA.getAnnotations().size());\n+        assertEquals(annotationExpr, classA.getAnnotation(0));\n+    }\n+\n+    @Test\n+    void testResolveWithoutCompilationUnit() {\n+        ClassOrInterfaceType classA = new ClassOrInterfaceType(null, \"A\");\n+        Assertions.assertThrows(IllegalStateException.class, classA::resolve);\n+    }\n+\n+    @Test\n+    void testToDescriptorWithoutCompilationUnit() {\n+        ClassOrInterfaceType classA = new ClassOrInterfaceType(null, \"A\");\n+        Assertions.assertThrows(IllegalStateException.class, classA::toDescriptor);\n+    }\n+\n+    @Test\n+    void testToClassOrInterfaceType() {\n+        ClassOrInterfaceType classA = new ClassOrInterfaceType(null, \"A\");\n+\n+        Optional<ClassOrInterfaceType> newClass = classA.toClassOrInterfaceType();\n+        assertTrue(newClass.isPresent());\n+        assertSame(classA, newClass.get());\n+    }\n+\n+    @Test\n+    void testIfClassOrInterfaceTypeIsCalled() {\n+        ClassOrInterfaceType classA = new ClassOrInterfaceType(null, \"A\");\n+        classA.ifClassOrInterfaceType(classOrInterfaceType -> assertSame(classA, classOrInterfaceType));\n+    }\n+\n+    @Test\n+    void testAsClassOrInterfaceTypeIsTheSame() {\n+        ClassOrInterfaceType classA = new ClassOrInterfaceType(null, \"A\");\n+\n+        assertTrue(classA.isClassOrInterfaceType());\n+        assertEquals(classA, classA.asClassOrInterfaceType());\n+    }\n+\n+    @Test\n+    void testCloneClass() {\n+        ClassOrInterfaceType classA = new ClassOrInterfaceType(null, \"A\");\n+        assertEquals(classA, classA.clone());\n+    }\n+\n+    @Test\n+    void testMetaModel() {\n+        ClassOrInterfaceType classA = new ClassOrInterfaceType(null, \"A\");\n+        assertEquals(JavaParserMetaModel.classOrInterfaceTypeMetaModel, classA.getMetaModel());\n+    }\n+\n+    @Test\n+    void testAcceptVoidVisitor() {\n+        ClassOrInterfaceType classA = new ClassOrInterfaceType(null, \"A\");\n+        classA.accept(new VoidVisitorAdapter<Object>() {\n+            @Override\n+            public void visit(ClassOrInterfaceType classOrInterfaceType, Object object) {\n+                super.visit(classOrInterfaceType, object);\n+\n+                assertEquals(classA, classOrInterfaceType);\n+            }\n+        }, null);\n+    }\n+\n+}"
  },
  {
    "sha": "43558b6d655a4d31f2dfa243986d8a54fd5e64f5",
    "filename": "javaparser-core/pom.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-core/pom.xml",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-core/pom.xml",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-core/pom.xml?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -2,7 +2,7 @@\n     <parent>\n         <artifactId>javaparser-parent</artifactId>\n         <groupId>com.github.javaparser</groupId>\n-        <version>3.19.1-SNAPSHOT</version>\n+        <version>3.20.1-SNAPSHOT</version>\n     </parent>\n     <modelVersion>4.0.0</modelVersion>\n "
  },
  {
    "sha": "f1b5cb5f12ee40fc3992cddb54e016b7c6adc238",
    "filename": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java",
    "status": "modified",
    "additions": 6,
    "deletions": 3,
    "changes": 9,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -74,6 +74,9 @@\n  * in its original formatting including the AST changes.\n  */\n public class LexicalPreservingPrinter {\n+    \n+    private static String JAVA_UTIL_OPTIONAL = Optional.class.getCanonicalName();\n+    private static String JAVAPARSER_AST_NODELIST = NodeList.class.getCanonicalName();\n \n     private static AstObserver observer;\n \n@@ -617,21 +620,21 @@ static NodeText getOrCreateNodeText(Node node) {\n     //\n \n     private static boolean isReturningOptionalNodeList(Method m) {\n-        if (!m.getReturnType().getCanonicalName().equals(Optional.class.getCanonicalName())) {\n+        if (!m.getReturnType().getCanonicalName().equals(JAVA_UTIL_OPTIONAL)) {\n             return false;\n         }\n         if (!(m.getGenericReturnType() instanceof ParameterizedType)) {\n             return false;\n         }\n         ParameterizedType parameterizedType = (ParameterizedType) m.getGenericReturnType();\n         java.lang.reflect.Type optionalArgument = parameterizedType.getActualTypeArguments()[0];\n-        return (optionalArgument.getTypeName().startsWith(NodeList.class.getCanonicalName()));\n+        return (optionalArgument.getTypeName().startsWith(JAVAPARSER_AST_NODELIST));\n     }\n \n     private static ObservableProperty findNodeListName(NodeList<?> nodeList) {\n         Node parent = nodeList.getParentNodeForChildren();\n         for (Method m : parent.getClass().getMethods()) {\n-            if (m.getParameterCount() == 0 && m.getReturnType().getCanonicalName().equals(NodeList.class.getCanonicalName())) {\n+            if (m.getParameterCount() == 0 && m.getReturnType().getCanonicalName().equals(JAVAPARSER_AST_NODELIST)) {\n                 try {\n                     Object raw = m.invoke(parent);\n                     if (!(raw instanceof NodeList)) {"
  },
  {
    "sha": "f9152a9a93296708b15b75c69b127aa53f250be2",
    "filename": "javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java",
    "status": "modified",
    "additions": 5,
    "deletions": 2,
    "changes": 7,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -51,6 +51,9 @@\n  */\n public abstract class ResolvedReferenceType implements ResolvedType,\n         ResolvedTypeParametrized, ResolvedTypeParameterValueProvider {\n+    \n+    protected static String JAVA_LANG_ENUM = java.lang.Enum.class.getCanonicalName();\n+    protected static String JAVA_LANG_OBJECT = java.lang.Object.class.getCanonicalName();\n \n     //\n     // Fields\n@@ -549,7 +552,7 @@ private boolean compareConsideringVariableTypeParameters(ResolvedType referenceT\n     public boolean isJavaLangObject() {\n         return this.isReferenceType()\n                 && hasName() // Consider anonymous classes\n-                && getQualifiedName().equals(java.lang.Object.class.getCanonicalName());\n+                && getQualifiedName().equals(JAVA_LANG_OBJECT);\n     }\n \n     /**\n@@ -559,7 +562,7 @@ public boolean isJavaLangObject() {\n     public boolean isJavaLangEnum() {\n         return this.isReferenceType()\n                 && hasName() // Consider anonymous classes\n-                && getQualifiedName().equals(java.lang.Enum.class.getCanonicalName());\n+                && getQualifiedName().equals(JAVA_LANG_ENUM);\n     }\n     \n     "
  },
  {
    "sha": "5a161e046ad2f14bdc91c5b1ff6ef58fbe85b657",
    "filename": "javaparser-symbol-solver-core/pom.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/pom.xml",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/pom.xml",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/pom.xml?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -3,7 +3,7 @@\n   <parent>\n       <artifactId>javaparser-parent</artifactId>\n       <groupId>com.github.javaparser</groupId>\n-      <version>3.19.1-SNAPSHOT</version>\n+      <version>3.20.1-SNAPSHOT</version>\n   </parent>    \n   <modelVersion>4.0.0</modelVersion>\n "
  },
  {
    "sha": "6013db16070ca1380b8604de0bbfbe717ea35ca8",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
    "status": "modified",
    "additions": 21,
    "deletions": 3,
    "changes": 24,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -91,7 +91,10 @@\n import com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n import com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\n+import com.github.javaparser.symbolsolver.reflectionmodel.ReflectionAnnotationDeclaration;\n import com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration;\n+import com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration;\n+import com.github.javaparser.symbolsolver.reflectionmodel.ReflectionInterfaceDeclaration;\n import com.github.javaparser.symbolsolver.resolution.ConstructorResolutionLogic;\n import com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\n import com.github.javaparser.symbolsolver.resolution.SymbolSolver;\n@@ -110,6 +113,9 @@\n     };\n \n     private static final Map<TypeSolver, JavaParserFacade> instances = new WeakHashMap<>();\n+    \n+    private static String JAVA_LANG_STRING = String.class.getCanonicalName();\n+    \n     private final TypeSolver typeSolver;\n     private final TypeExtractor typeExtractor;\n     private final SymbolSolver symbolSolver;\n@@ -510,9 +516,9 @@ protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solv\n \n         if (operator == BinaryExpr.Operator.PLUS) {\n             boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType()\n-                    .getQualifiedName().equals(String.class.getCanonicalName());\n+                    .getQualifiedName().equals(JAVA_LANG_STRING);\n             boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType()\n-                    .getQualifiedName().equals(String.class.getCanonicalName());\n+                    .getQualifiedName().equals(JAVA_LANG_STRING);\n             if (isLeftString || isRightString) {\n                 return isLeftString ? leftType : rightType;\n             }\n@@ -789,6 +795,18 @@ public ResolvedType classToResolvedType(Class<?> clazz) {\n         if (clazz.isPrimitive()) {\n             return ResolvedPrimitiveType.byName(clazz.getName());\n         }\n-        return new ReferenceTypeImpl(new ReflectionClassDeclaration(clazz, typeSolver), typeSolver);\n+\n+        ResolvedReferenceTypeDeclaration declaration;\n+        if (clazz.isAnnotation()) {\n+            declaration = new ReflectionAnnotationDeclaration(clazz, typeSolver);\n+        } else if (clazz.isEnum()) {\n+            declaration = new ReflectionEnumDeclaration(clazz, typeSolver);\n+        } else if (clazz.isInterface()) {\n+            declaration = new ReflectionInterfaceDeclaration(clazz, typeSolver);\n+        } else {\n+            declaration = new ReflectionClassDeclaration(clazz, typeSolver);\n+        }\n+        return new ReferenceTypeImpl(declaration, typeSolver);\n     }\n+\n }"
  },
  {
    "sha": "b1070d211e9ee4d8d7128ee9bd669e0c6f39cdf6",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
    "status": "modified",
    "additions": 27,
    "deletions": 0,
    "changes": 27,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -25,6 +25,7 @@\n import com.github.javaparser.ast.body.MethodDeclaration;\n import com.github.javaparser.ast.body.Parameter;\n import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.CastExpr;\n import com.github.javaparser.ast.expr.Expression;\n import com.github.javaparser.ast.expr.LambdaExpr;\n import com.github.javaparser.ast.expr.MethodCallExpr;\n@@ -171,6 +172,32 @@ public LambdaExprContext(LambdaExpr wrappedNode, TypeSolver typeSolver) {\n                                 throw new UnsupportedOperationException();\n                             }\n                         }\n+                    } else if (parentNode instanceof CastExpr) {\n+                        CastExpr castExpr = (CastExpr) parentNode;\n+                        ResolvedType t = JavaParserFacade.get(typeSolver).convertToUsage(castExpr.getType());\n+                        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n+\n+                        if (functionalMethod.isPresent()) {\n+                            ResolvedType lambdaType = functionalMethod.get().getParamType(index);\n+\n+                            // Replace parameter from declarator\n+                            Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();\n+                            if (lambdaType.isReferenceType()) {\n+                                for (com.github.javaparser.utils.Pair<ResolvedTypeParameterDeclaration, ResolvedType> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n+                                    if (entry.b.isTypeVariable() && entry.b.asTypeParameter().declaredOnType()) {\n+                                        ResolvedType ot = t.asReferenceType().typeParametersMap().getValue(entry.a);\n+                                        lambdaType = lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n+                                    }\n+                                }\n+                            } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n+                                lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n+                            }\n+\n+                            Value value = new Value(lambdaType, name);\n+                            return Optional.of(value);\n+                        } else {\n+                            throw new UnsupportedOperationException();\n+                        }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }"
  },
  {
    "sha": "b1d8d0157cb8e93d749ec0102e7f64c78c7ffcb6",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java",
    "status": "modified",
    "additions": 26,
    "deletions": 8,
    "changes": 34,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -21,6 +21,15 @@\n \n package com.github.javaparser.symbolsolver.javaparsermodel.declarations;\n \n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n import com.github.javaparser.ast.AccessSpecifier;\n import com.github.javaparser.ast.Node;\n import com.github.javaparser.ast.body.BodyDeclaration;\n@@ -30,7 +39,16 @@\n import com.github.javaparser.ast.type.ClassOrInterfaceType;\n import com.github.javaparser.resolution.MethodUsage;\n import com.github.javaparser.resolution.UnsolvedSymbolException;\n-import com.github.javaparser.resolution.declarations.*;\n+import com.github.javaparser.resolution.declarations.AssociableToAST;\n+import com.github.javaparser.resolution.declarations.ResolvedConstructorDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedEnumConstantDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedEnumDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedFieldDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedTypeDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\n import com.github.javaparser.resolution.types.ResolvedArrayType;\n import com.github.javaparser.resolution.types.ResolvedReferenceType;\n import com.github.javaparser.resolution.types.ResolvedType;\n@@ -48,16 +66,16 @@\n import com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\n import com.github.javaparser.symbolsolver.reflectionmodel.ReflectionFactory;\n \n-import java.io.Serializable;\n-import java.util.*;\n-import java.util.stream.Collectors;\n-\n /**\n  * @author Federico Tomassetti\n  */\n public class JavaParserEnumDeclaration extends AbstractTypeDeclaration\n         implements ResolvedEnumDeclaration, MethodResolutionCapability, MethodUsageResolutionCapability,\n         AssociableToAST<EnumDeclaration> {\n+    \n+    private static String JAVA_LANG_ENUM = java.lang.Enum.class.getCanonicalName();\n+    private static String JAVA_LANG_COMPARABLE = java.lang.Comparable.class.getCanonicalName();\n+    private static String JAVA_IO_SERIALIZABLE = Serializable.class.getCanonicalName();\n \n     private TypeSolver typeSolver;\n     private EnumDeclaration wrappedNode;\n@@ -123,14 +141,14 @@ public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other) {\n         if (otherName.equals(this.getQualifiedName())) {\n             return true;\n         }\n-        if (otherName.equals(Enum.class.getCanonicalName())) {\n+        if (otherName.equals(JAVA_LANG_ENUM)) {\n             return true;\n         }\n         // Enum implements Comparable and Serializable\n-        if (otherName.equals(Comparable.class.getCanonicalName())) {\n+        if (otherName.equals(JAVA_LANG_COMPARABLE)) {\n             return true;\n         }\n-        if (otherName.equals(Serializable.class.getCanonicalName())) {\n+        if (otherName.equals(JAVA_IO_SERIALIZABLE)) {\n             return true;\n         }\n         if (other.isJavaLangObject()) {"
  },
  {
    "sha": "3de3f475438314f92eaf32217d1744cb1428780c",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserSymbolDeclaration.java",
    "status": "modified",
    "additions": 10,
    "deletions": 2,
    "changes": 12,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserSymbolDeclaration.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserSymbolDeclaration.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserSymbolDeclaration.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -21,6 +21,8 @@\n \n package com.github.javaparser.symbolsolver.javaparsermodel.declarations;\n \n+import static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\n+\n import com.github.javaparser.ast.Node;\n import com.github.javaparser.ast.body.FieldDeclaration;\n import com.github.javaparser.ast.body.Parameter;\n@@ -39,8 +41,6 @@\n import com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFactory;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n \n-import static com.github.javaparser.symbolsolver.javaparser.Navigator.demandParentNode;\n-\n /**\n  * This should not be used to represent fields of parameters.\n  *\n@@ -127,6 +127,14 @@ public boolean isPattern() {\n //        return getWrappedNode() instanceof PatternExpr;\n         return false;\n     }\n+    \n+    /**\n+     * Does this declaration represents a variable?\n+     */\n+    @Override\n+    public boolean isVariable() {\n+        return getWrappedNode() instanceof VariableDeclarator;\n+    }\n \n     @Override\n     public boolean isType() {"
  },
  {
    "sha": "70c308fe949b1ba9f93633d2ef7c899790d6e796",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationDeclaration.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationDeclaration.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationDeclaration.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationDeclaration.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -59,7 +59,7 @@ public JavassistAnnotationDeclaration(CtClass ctClass, TypeSolver typeSolver) {\n         }\n         this.ctClass = ctClass;\n         this.typeSolver = typeSolver;\n-        this.javassistTypeDeclarationAdapter = new JavassistTypeDeclarationAdapter(ctClass, typeSolver);\n+        this.javassistTypeDeclarationAdapter = new JavassistTypeDeclarationAdapter(ctClass, typeSolver, this);\n     }\n \n     @Override\n@@ -100,7 +100,7 @@ public boolean isAssignableBy(ResolvedReferenceTypeDeclaration other) {\n \n     @Override\n     public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n-        throw new UnsupportedOperationException();\n+        return javassistTypeDeclarationAdapter.getAncestors(acceptIncompleteList);\n     }\n \n     @Override"
  },
  {
    "sha": "d16e20bda20e1ff661d6583bf48a5b48071f2326",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java",
    "status": "modified",
    "additions": 17,
    "deletions": 128,
    "changes": 145,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -40,24 +40,15 @@\n import com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n import com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\n-import com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\n import com.github.javaparser.symbolsolver.resolution.SymbolSolver;\n import javassist.CtClass;\n import javassist.CtField;\n-import javassist.CtMethod;\n import javassist.NotFoundException;\n-import javassist.bytecode.AccessFlag;\n-import javassist.bytecode.BadBytecode;\n-import javassist.bytecode.SignatureAttribute;\n-import javassist.bytecode.SyntheticAttribute;\n \n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.function.Predicate;\n import java.util.stream.Collectors;\n \n /**\n@@ -78,7 +69,7 @@ public JavassistClassDeclaration(CtClass ctClass, TypeSolver typeSolver) {\n         }\n         this.ctClass = ctClass;\n         this.typeSolver = typeSolver;\n-        this.javassistTypeDeclarationAdapter = new JavassistTypeDeclarationAdapter(ctClass, typeSolver);\n+        this.javassistTypeDeclarationAdapter = new JavassistTypeDeclarationAdapter(ctClass, typeSolver, this);\n     }\n \n     @Override\n@@ -138,7 +129,7 @@ public String getQualifiedName() {\n     @Deprecated\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes,\n                                                     Context invokationContext, List<ResolvedType> typeParameterValues) {\n-        return JavassistUtils.getMethodUsage(ctClass, name, argumentsTypes, typeSolver, getTypeParameters(), typeParameterValues);\n+        return JavassistUtils.solveMethodAsUsage(name, argumentsTypes, typeSolver, invokationContext, typeParameterValues, this, ctClass);\n     }\n \n     @Deprecated\n@@ -185,78 +176,13 @@ private String getSuperclassFQN() {\n \n     @Override\n     public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n-        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n-        try {\n-            getSuperClass().ifPresent(superClass -> ancestors.add(superClass));\n-        } catch (UnsolvedSymbolException e) {\n-            if (!acceptIncompleteList) {\n-                // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n-                throw e;\n-            }\n-        }\n-        try {\n-            ancestors.addAll(getInterfaces());\n-        } catch (UnsolvedSymbolException e) {\n-            if (!acceptIncompleteList) {\n-                // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n-                throw e;\n-            }\n-        }\n-        return ancestors;\n+        return javassistTypeDeclarationAdapter.getAncestors(acceptIncompleteList);\n     }\n \n     @Override\n     @Deprecated\n     public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly) {\n-        List<ResolvedMethodDeclaration> candidates = new ArrayList<>();\n-        Predicate<CtMethod> staticOnlyCheck = m -> !staticOnly || (staticOnly && Modifier.isStatic(m.getModifiers()));\n-        for (CtMethod method : ctClass.getDeclaredMethods()) {\n-            boolean isSynthetic = method.getMethodInfo().getAttribute(SyntheticAttribute.tag) != null;\n-            boolean isNotBridge = (method.getMethodInfo().getAccessFlags() & AccessFlag.BRIDGE) == 0;\n-            if (method.getName().equals(name) && !isSynthetic && isNotBridge && staticOnlyCheck.test(method)) {\n-                ResolvedMethodDeclaration candidate = new JavassistMethodDeclaration(method, typeSolver);\n-                candidates.add(candidate);\n-\n-                // no need to search for overloaded/inherited methods if the method has no parameters\n-                if (argumentsTypes.isEmpty() && candidate.getNumberOfParams() == 0) {\n-                    return SymbolReference.solved(candidate);\n-                }\n-            }\n-        }\n-\n-        // add the method declaration of the superclass to the candidates, if present\n-        getSuperClass()\n-                .flatMap(ResolvedReferenceType::getTypeDeclaration)\n-                .ifPresent(superclassTypeDeclaration -> {\n-                    SymbolReference<ResolvedMethodDeclaration> superClassMethodRef = MethodResolutionLogic.solveMethodInType(\n-                            superclassTypeDeclaration,\n-                            name,\n-                            argumentsTypes,\n-                            staticOnly\n-                    );\n-                    if (superClassMethodRef.isSolved()) {\n-                        candidates.add(superClassMethodRef.getCorrespondingDeclaration());\n-                    }\n-                });\n-\n-        // add the method declaration of the interfaces to the candidates, if present\n-        for (ResolvedReferenceType interfaceRef : getInterfaces()) {\n-            if (interfaceRef.getTypeDeclaration().isPresent()) {\n-                SymbolReference<ResolvedMethodDeclaration> interfaceMethodRef = MethodResolutionLogic.solveMethodInType(\n-                        interfaceRef.getTypeDeclaration().get(),\n-                        name,\n-                        argumentsTypes,\n-                        staticOnly\n-                );\n-                if (interfaceMethodRef.isSolved()) {\n-                    candidates.add(interfaceMethodRef.getCorrespondingDeclaration());\n-                }\n-            } else {\n-                // Consider IllegalStateException or similar?\n-            }\n-        }\n-\n-        return MethodResolutionLogic.findMostApplicable(candidates, name, argumentsTypes, typeSolver);\n+        return JavassistUtils.solveMethod(name, argumentsTypes, staticOnly, typeSolver, this, ctClass);\n     }\n \n     public ResolvedType getUsage(Node node) {\n@@ -277,19 +203,21 @@ public boolean isAssignableBy(ResolvedType type) {\n         if (type.describe().equals(this.getQualifiedName())) {\n             return true;\n         }\n-        try {\n-            if (this.ctClass.getSuperclass() != null\n-                    && new JavassistClassDeclaration(this.ctClass.getSuperclass(), typeSolver).isAssignableBy(type)) {\n+\n+        Optional<ResolvedReferenceType> superClassOpt = getSuperClass();\n+        if (superClassOpt.isPresent()) {\n+            ResolvedReferenceType superClass = superClassOpt.get();\n+            if (superClass.isAssignableBy(type)) {\n                 return true;\n             }\n-            for (CtClass interfaze : ctClass.getInterfaces()) {\n-                if (new JavassistInterfaceDeclaration(interfaze, typeSolver).isAssignableBy(type)) {\n-                    return true;\n-                }\n+        }\n+\n+        for (ResolvedReferenceType interfaceType : getInterfaces()) {\n+            if (interfaceType.isAssignableBy(type)) {\n+                return true;\n             }\n-        } catch (NotFoundException e) {\n-            throw new RuntimeException(e);\n         }\n+\n         return false;\n     }\n \n@@ -331,51 +259,12 @@ public boolean isClass() {\n \n     @Override\n     public Optional<ResolvedReferenceType> getSuperClass() {\n-        try {\n-            if (\"java.lang.Object\".equals(ctClass.getClassFile().getName())) {\n-                // If this is java.lang.Object, ignore the presence of any superclass (preventing any infinite loops).\n-                return Optional.empty();\n-            }\n-            if (ctClass.getGenericSignature() == null) {\n-                // Compiled classes have generic types erased, but can be made available for reflection via getGenericSignature().\n-                // If it is absent, then no further work is needed and we can return a reference type without generics.\n-                return Optional.of(new ReferenceTypeImpl(\n-                        typeSolver.solveType(JavassistUtils.internalNameToCanonicalName(ctClass.getClassFile().getSuperclass())),\n-                        typeSolver\n-                ));\n-            } else {\n-                // If there is a generic signature present, solve the types and return it.\n-                SignatureAttribute.ClassSignature classSignature = SignatureAttribute.toClassSignature(ctClass.getGenericSignature());\n-                return Optional.ofNullable(\n-                        JavassistUtils.signatureTypeToType(\n-                                classSignature.getSuperClass(),\n-                                typeSolver,\n-                                this\n-                        ).asReferenceType()\n-                );\n-            }\n-        } catch (BadBytecode e) {\n-            throw new RuntimeException(e);\n-        }\n+        return javassistTypeDeclarationAdapter.getSuperClass();\n     }\n \n     @Override\n     public List<ResolvedReferenceType> getInterfaces() {\n-        try {\n-            if (ctClass.getGenericSignature() == null) {\n-                return Arrays.stream(ctClass.getClassFile().getInterfaces())\n-                        .map(i -> typeSolver.solveType(JavassistUtils.internalNameToCanonicalName(i)))\n-                        .map(i -> new ReferenceTypeImpl(i, typeSolver))\n-                        .collect(Collectors.toList());\n-            } else {\n-                SignatureAttribute.ClassSignature classSignature = SignatureAttribute.toClassSignature(ctClass.getGenericSignature());\n-                return Arrays.stream(classSignature.getInterfaces())\n-                        .map(i -> JavassistUtils.signatureTypeToType(i, typeSolver, this).asReferenceType())\n-                        .collect(Collectors.toList());\n-            }\n-        } catch (BadBytecode e) {\n-            throw new RuntimeException(e);\n-        }\n+        return javassistTypeDeclarationAdapter.getInterfaces();\n     }\n \n     @Override"
  },
  {
    "sha": "d91364cd8cb867e4360cb27e964a472191fd1fe6",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistConstructorDeclaration.java",
    "status": "modified",
    "additions": 9,
    "deletions": 56,
    "changes": 65,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistConstructorDeclaration.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistConstructorDeclaration.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistConstructorDeclaration.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -22,31 +22,27 @@\n package com.github.javaparser.symbolsolver.javassistmodel;\n \n import com.github.javaparser.ast.AccessSpecifier;\n-import com.github.javaparser.ast.Modifier;\n import com.github.javaparser.ast.body.ConstructorDeclaration;\n import com.github.javaparser.resolution.declarations.*;\n import com.github.javaparser.resolution.types.ResolvedType;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n import javassist.CtConstructor;\n-import javassist.NotFoundException;\n-import javassist.bytecode.*;\n \n-import java.util.Arrays;\n-import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n-import java.util.stream.Collectors;\n \n /**\n  * @author Fred Lefévère-Laoide\n  */\n public class JavassistConstructorDeclaration implements ResolvedConstructorDeclaration {\n     private final CtConstructor ctConstructor;\n     private final TypeSolver typeSolver;\n+    private final JavassistMethodLikeDeclarationAdapter methodLikeAdaper;\n \n     public JavassistConstructorDeclaration(CtConstructor ctConstructor, TypeSolver typeSolver) {\n         this.ctConstructor = ctConstructor;\n         this.typeSolver = typeSolver;\n+        this.methodLikeAdaper = new JavassistMethodLikeDeclarationAdapter(ctConstructor, typeSolver, this);\n     }\n \n     @Override\n@@ -78,54 +74,23 @@ public boolean isType() {\n     }\n \n     @Override\n-    public ResolvedClassDeclaration declaringType() {\n-        return new JavassistClassDeclaration(ctConstructor.getDeclaringClass(), typeSolver);\n+    public ResolvedReferenceTypeDeclaration declaringType() {\n+        return JavassistFactory.toTypeDeclaration(ctConstructor.getDeclaringClass(), typeSolver);\n     }\n \n     @Override\n     public int getNumberOfParams() {\n-        try {\n-            return ctConstructor.getParameterTypes().length;\n-        } catch (NotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n+        return methodLikeAdaper.getNumberOfParams();\n     }\n \n     @Override\n     public ResolvedParameterDeclaration getParam(int i) {\n-        try {\n-            boolean variadic = false;\n-            if ((ctConstructor.getModifiers() & javassist.Modifier.VARARGS) > 0) {\n-                variadic = i == (ctConstructor.getParameterTypes().length - 1);\n-            }\n-            Optional<String> paramName = JavassistUtils.extractParameterName(ctConstructor, i);\n-            if (ctConstructor.getGenericSignature() != null) {\n-                SignatureAttribute.MethodSignature methodSignature = SignatureAttribute.toMethodSignature(ctConstructor.getGenericSignature());\n-                SignatureAttribute.Type signatureType = methodSignature.getParameterTypes()[i];\n-                return new JavassistParameterDeclaration(JavassistUtils.signatureTypeToType(signatureType,\n-                        typeSolver, this), typeSolver, variadic, paramName.orElse(null));\n-            } else {\n-                return new JavassistParameterDeclaration(ctConstructor.getParameterTypes()[i], typeSolver, variadic,\n-                        paramName.orElse(null));\n-            }\n-        } catch (NotFoundException e) {\n-            throw new RuntimeException(e);\n-        } catch (BadBytecode badBytecode) {\n-            throw new RuntimeException(badBytecode);\n-        }\n+        return methodLikeAdaper.getParam(i);\n     }\n \n     @Override\n     public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n-        try {\n-            if (ctConstructor.getGenericSignature() == null) {\n-                return Collections.emptyList();\n-            }\n-            SignatureAttribute.MethodSignature methodSignature = SignatureAttribute.toMethodSignature(ctConstructor.getGenericSignature());\n-            return Arrays.stream(methodSignature.getTypeParameters()).map((jasTp) -> new JavassistTypeParameter(jasTp, this, typeSolver)).collect(Collectors.toList());\n-        } catch (BadBytecode badBytecode) {\n-            throw new RuntimeException(badBytecode);\n-        }\n+        return methodLikeAdaper.getTypeParameters();\n     }\n \n     @Override\n@@ -135,24 +100,12 @@ public AccessSpecifier accessSpecifier() {\n \n     @Override\n     public int getNumberOfSpecifiedExceptions() {\n-        try {\n-            return ctConstructor.getExceptionTypes().length;\n-        } catch (NotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n+        return methodLikeAdaper.getNumberOfSpecifiedExceptions();\n     }\n \n     @Override\n     public ResolvedType getSpecifiedException(int index) {\n-        if (index < 0 || index >= getNumberOfSpecifiedExceptions()) {\n-            throw new IllegalArgumentException(String.format(\"No exception with index %d. Number of exceptions: %d\",\n-                    index, getNumberOfSpecifiedExceptions()));\n-        }\n-        try {\n-            return JavassistFactory.typeUsageFor(ctConstructor.getExceptionTypes()[index], typeSolver);\n-        } catch (NotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n+        return methodLikeAdaper.getSpecifiedException(index);\n     }\n \n     @Override"
  },
  {
    "sha": "a95ce8f621b1ed9f30b7d1340575dada69afe544",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java",
    "status": "modified",
    "additions": 4,
    "deletions": 71,
    "changes": 75,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -33,19 +33,13 @@\n import com.github.javaparser.symbolsolver.logic.MethodResolutionCapability;\n import com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n-import com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\n-import com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\n import com.github.javaparser.symbolsolver.resolution.SymbolSolver;\n import javassist.CtClass;\n import javassist.CtField;\n-import javassist.CtMethod;\n import javassist.NotFoundException;\n import javassist.bytecode.AccessFlag;\n-import javassist.bytecode.SyntheticAttribute;\n \n-import java.lang.reflect.Modifier;\n import java.util.*;\n-import java.util.function.Predicate;\n import java.util.stream.Collectors;\n \n /**\n@@ -67,7 +61,7 @@ public JavassistEnumDeclaration(CtClass ctClass, TypeSolver typeSolver) {\n         }\n         this.ctClass = ctClass;\n         this.typeSolver = typeSolver;\n-        this.javassistTypeDeclarationAdapter = new JavassistTypeDeclarationAdapter(ctClass, typeSolver);\n+        this.javassistTypeDeclarationAdapter = new JavassistTypeDeclarationAdapter(ctClass, typeSolver, this);\n     }\n \n     @Override\n@@ -96,34 +90,7 @@ public String getQualifiedName() {\n \n     @Override\n     public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n-        // Direct ancestors of an enum are java.lang.Enum and interfaces\n-        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n-\n-        String superClassName = ctClass.getClassFile().getSuperclass();\n-\n-        if (superClassName != null) {\n-            try {\n-                ancestors.add(new ReferenceTypeImpl(typeSolver.solveType(superClassName), typeSolver));\n-            } catch (UnsolvedSymbolException e) {\n-                if (!acceptIncompleteList) {\n-                    // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n-                    throw e;\n-                }\n-            }\n-        }\n-\n-        for (String interfazeName : ctClass.getClassFile().getInterfaces()) {\n-            try {\n-                ancestors.add(new ReferenceTypeImpl(typeSolver.solveType(interfazeName), typeSolver));\n-            } catch (UnsolvedSymbolException e) {\n-                if (!acceptIncompleteList) {\n-                    // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n-                    throw e;\n-                }\n-            }\n-        }\n-\n-        return ancestors;\n+        return javassistTypeDeclarationAdapter.getAncestors(acceptIncompleteList);\n     }\n \n     @Override\n@@ -181,46 +148,12 @@ public String getName() {\n \n     @Override\n     public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly) {\n-        List<ResolvedMethodDeclaration> candidates = new ArrayList<>();\n-        Predicate<CtMethod> staticOnlyCheck = m -> !staticOnly || (staticOnly && Modifier.isStatic(m.getModifiers()));\n-        for (CtMethod method : ctClass.getDeclaredMethods()) {\n-            boolean isSynthetic = method.getMethodInfo().getAttribute(SyntheticAttribute.tag) != null;\n-            boolean isNotBridge = (method.getMethodInfo().getAccessFlags() & AccessFlag.BRIDGE) == 0;\n-            if (method.getName().equals(name) && !isSynthetic && isNotBridge && staticOnlyCheck.test(method)) {\n-                candidates.add(new JavassistMethodDeclaration(method, typeSolver));\n-            }\n-        }\n-\n-        try {\n-            for (CtClass iface : ctClass.getInterfaces()) {\n-                SymbolReference<ResolvedMethodDeclaration> ref = new JavassistInterfaceDeclaration(iface, typeSolver)\n-                        .solveMethod(name, argumentsTypes, staticOnly);\n-                if (ref.isSolved()) {\n-                    candidates.add(ref.getCorrespondingDeclaration());\n-                }\n-            }\n-        } catch (NotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-        try {\n-            CtClass superClass = ctClass.getSuperclass();\n-            if (superClass != null) {\n-                SymbolReference<ResolvedMethodDeclaration> ref = new JavassistClassDeclaration(superClass, typeSolver).solveMethod(name, argumentsTypes, staticOnly);\n-                if (ref.isSolved()) {\n-                    candidates.add(ref.getCorrespondingDeclaration());\n-                }\n-            }\n-        } catch (NotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-        return MethodResolutionLogic.findMostApplicable(candidates, name, argumentsTypes, typeSolver);\n+        return JavassistUtils.solveMethod(name, argumentsTypes, staticOnly, typeSolver, this, ctClass);\n     }\n \n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes,\n                                                     Context invokationContext, List<ResolvedType> typeParameterValues) {\n-        return JavassistUtils.getMethodUsage(ctClass, name, argumentsTypes, typeSolver, getTypeParameters(), typeParameterValues);\n+        return JavassistUtils.solveMethodAsUsage(name, argumentsTypes, typeSolver, invokationContext, typeParameterValues, this, ctClass);\n     }\n \n     @Override"
  },
  {
    "sha": "fa202eb84c4808329bf0e6a678c4afeaf98bf023",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistFieldDeclaration.java",
    "status": "modified",
    "additions": 6,
    "deletions": 7,
    "changes": 13,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistFieldDeclaration.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistFieldDeclaration.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistFieldDeclaration.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -28,7 +28,6 @@\n import com.github.javaparser.resolution.types.ResolvedType;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n import javassist.CtField;\n-import javassist.NotFoundException;\n import javassist.bytecode.BadBytecode;\n import javassist.bytecode.SignatureAttribute;\n \n@@ -49,13 +48,13 @@ public JavassistFieldDeclaration(CtField ctField, TypeSolver typeSolver) {\n     @Override\n     public ResolvedType getType() {\n         try {\n-            if (ctField.getGenericSignature() != null && declaringType() instanceof ResolvedTypeParametrizable) {\n-                javassist.bytecode.SignatureAttribute.Type genericSignatureType = SignatureAttribute.toFieldSignature(ctField.getGenericSignature());\n-                return JavassistUtils.signatureTypeToType(genericSignatureType, typeSolver, (ResolvedTypeParametrizable) declaringType());\n-            } else {\n-                return JavassistFactory.typeUsageFor(ctField.getType(), typeSolver);\n+            String signature = ctField.getGenericSignature();\n+            if (signature == null) {\n+                signature = ctField.getSignature();\n             }\n-        } catch (NotFoundException | BadBytecode e) {\n+            SignatureAttribute.Type genericSignatureType = SignatureAttribute.toTypeSignature(signature);\n+            return JavassistUtils.signatureTypeToType(genericSignatureType, typeSolver, (ResolvedTypeParametrizable) declaringType());\n+        } catch (BadBytecode e) {\n             throw new RuntimeException(e);\n         }\n     }"
  },
  {
    "sha": "5c7f9433135f9f64b4a9d04123085c86b33f9d0c",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java",
    "status": "modified",
    "additions": 7,
    "deletions": 86,
    "changes": 93,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -40,26 +40,16 @@\n import com.github.javaparser.symbolsolver.logic.MethodResolutionCapability;\n import com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n-import com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\n-import com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\n import com.github.javaparser.symbolsolver.resolution.SymbolSolver;\n import javassist.CtClass;\n import javassist.CtField;\n-import javassist.CtMethod;\n import javassist.NotFoundException;\n-import javassist.bytecode.AccessFlag;\n-import javassist.bytecode.BadBytecode;\n-import javassist.bytecode.SignatureAttribute;\n-import javassist.bytecode.SyntheticAttribute;\n \n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.function.Predicate;\n import java.util.stream.Collectors;\n \n /**\n@@ -86,13 +76,12 @@ public JavassistInterfaceDeclaration(CtClass ctClass, TypeSolver typeSolver) {\n         }\n         this.ctClass = ctClass;\n         this.typeSolver = typeSolver;\n-        this.javassistTypeDeclarationAdapter = new JavassistTypeDeclarationAdapter(ctClass, typeSolver);\n+        this.javassistTypeDeclarationAdapter = new JavassistTypeDeclarationAdapter(ctClass, typeSolver, this);\n     }\n \n     @Override\n     public List<ResolvedReferenceType> getInterfacesExtended() {\n-        return Arrays.stream(ctClass.getClassFile().getInterfaces()).map(i -> typeSolver.solveType(i))\n-                .map(i -> new ReferenceTypeImpl(i, typeSolver)).collect(Collectors.toList());\n+        return javassistTypeDeclarationAdapter.getInterfaces();\n     }\n \n     @Override\n@@ -117,52 +106,18 @@ public String getQualifiedName() {\n     @Deprecated\n     public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes,\n                                                     Context invokationContext, List<ResolvedType> typeParameterValues) {\n-\n-        return JavassistUtils.getMethodUsage(ctClass, name, argumentsTypes, typeSolver, getTypeParameters(), typeParameterValues);\n+        return JavassistUtils.solveMethodAsUsage(name, argumentsTypes, typeSolver, invokationContext, typeParameterValues, this, ctClass);\n     }\n \n     @Override\n     @Deprecated\n     public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly) {\n-        List<ResolvedMethodDeclaration> candidates = new ArrayList<>();\n-        Predicate<CtMethod> staticOnlyCheck = m -> !staticOnly || (staticOnly && Modifier.isStatic(m.getModifiers()));\n-        for (CtMethod method : ctClass.getDeclaredMethods()) {\n-            boolean isSynthetic = method.getMethodInfo().getAttribute(SyntheticAttribute.tag) != null;\n-            boolean isNotBridge =  (method.getMethodInfo().getAccessFlags() & AccessFlag.BRIDGE) == 0;\n-            if (method.getName().equals(name) && !isSynthetic && isNotBridge && staticOnlyCheck.test(method)) {\n-                candidates.add(new JavassistMethodDeclaration(method, typeSolver));\n-            }\n-        }\n-\n-        try {\n-            CtClass superClass = ctClass.getSuperclass();\n-            if (superClass != null) {\n-                SymbolReference<ResolvedMethodDeclaration> ref = new JavassistClassDeclaration(superClass, typeSolver).solveMethod(name, argumentsTypes, staticOnly);\n-                if (ref.isSolved()) {\n-                    candidates.add(ref.getCorrespondingDeclaration());\n-                }\n-            }\n-        } catch (NotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-        try {\n-            for (CtClass interfaze : ctClass.getInterfaces()) {\n-                SymbolReference<ResolvedMethodDeclaration> ref = new JavassistInterfaceDeclaration(interfaze, typeSolver).solveMethod(name, argumentsTypes, staticOnly);\n-                if (ref.isSolved()) {\n-                    candidates.add(ref.getCorrespondingDeclaration());\n-                }\n-            }\n-        } catch (NotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-        return MethodResolutionLogic.findMostApplicable(candidates, name, argumentsTypes, typeSolver);\n+        return JavassistUtils.solveMethod(name, argumentsTypes, staticOnly, typeSolver, this, ctClass);\n     }\n \n     @Override\n     public boolean isAssignableBy(ResolvedType type) {\n-        throw new UnsupportedOperationException();\n+        return javassistTypeDeclarationAdapter.isAssignableBy(type);\n     }\n \n     @Override\n@@ -172,46 +127,12 @@ public boolean isAssignableBy(ResolvedType type) {\n \n     @Override\n     public boolean isAssignableBy(ResolvedReferenceTypeDeclaration other) {\n-        throw new UnsupportedOperationException();\n+        return javassistTypeDeclarationAdapter.isAssignableBy(other);\n     }\n \n     @Override\n     public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n-        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n-        if (ctClass.getGenericSignature() == null) {\n-            for (String superInterface : ctClass.getClassFile().getInterfaces()) {\n-                try {\n-                    ancestors.add(new ReferenceTypeImpl(typeSolver.solveType(JavassistUtils.internalNameToCanonicalName(superInterface)), typeSolver));\n-                } catch (UnsolvedSymbolException e) {\n-                    if (!acceptIncompleteList) {\n-                        // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n-                        throw e;\n-                    }\n-                }\n-            }\n-        } else {\n-            try {\n-                SignatureAttribute.ClassSignature classSignature = SignatureAttribute.toClassSignature(ctClass.getGenericSignature());\n-                for (SignatureAttribute.ClassType superInterface : classSignature.getInterfaces()) {\n-                    try {\n-                        ancestors.add(JavassistUtils.signatureTypeToType(superInterface, typeSolver, this).asReferenceType());\n-                    } catch (UnsolvedSymbolException e) {\n-                        if (!acceptIncompleteList) {\n-                            // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully\n-                            throw e;\n-                        }\n-                    }\n-                }\n-            } catch (BadBytecode e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        // Remove all {@code java.lang.Object}, then add precisely one.\n-        ancestors.removeIf(ResolvedReferenceType::isJavaLangObject);\n-        ancestors.add(new ReferenceTypeImpl(typeSolver.getSolvedJavaLangObject(), typeSolver));\n-\n-        return ancestors;\n+        return javassistTypeDeclarationAdapter.getAncestors(acceptIncompleteList);\n     }\n \n     @Override"
  },
  {
    "sha": "400cc85c88aeaa87eb76eab18a53d127ac1362c9",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodDeclaration.java",
    "status": "modified",
    "additions": 10,
    "deletions": 125,
    "changes": 135,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodDeclaration.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodDeclaration.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodDeclaration.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -34,27 +34,23 @@\n import com.github.javaparser.symbolsolver.core.resolution.TypeVariableResolutionCapability;\n import com.github.javaparser.symbolsolver.declarations.common.MethodDeclarationCommonLogic;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n-import com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\n import javassist.CtMethod;\n-import javassist.NotFoundException;\n-import javassist.bytecode.BadBytecode;\n-import javassist.bytecode.MethodInfo;\n-import javassist.bytecode.SignatureAttribute;\n \n import java.lang.reflect.Modifier;\n import java.util.*;\n-import java.util.stream.Collectors;\n \n /**\n  * @author Federico Tomassetti\n  */\n public class JavassistMethodDeclaration implements ResolvedMethodDeclaration, TypeVariableResolutionCapability {\n     private CtMethod ctMethod;\n     private TypeSolver typeSolver;\n+    private final JavassistMethodLikeDeclarationAdapter methodLikeAdaper;\n \n     public JavassistMethodDeclaration(CtMethod ctMethod, TypeSolver typeSolver) {\n         this.ctMethod = ctMethod;\n         this.typeSolver = typeSolver;\n+        this.methodLikeAdaper = new JavassistMethodLikeDeclarationAdapter(ctMethod, typeSolver, this);\n     }\n \n     @Override\n@@ -96,77 +92,29 @@ public boolean isType() {\n \n     @Override\n     public ResolvedReferenceTypeDeclaration declaringType() {\n-        if (ctMethod.getDeclaringClass().isInterface()) {\n-            return new JavassistInterfaceDeclaration(ctMethod.getDeclaringClass(), typeSolver);\n-        } else if (ctMethod.getDeclaringClass().isEnum()) {\n-            return new JavassistEnumDeclaration(ctMethod.getDeclaringClass(), typeSolver);\n-        } else {\n-            return new JavassistClassDeclaration(ctMethod.getDeclaringClass(), typeSolver);\n-        }\n+        return JavassistFactory.toTypeDeclaration(ctMethod.getDeclaringClass(), typeSolver);\n     }\n \n     @Override\n     public ResolvedType getReturnType() {\n-        try {\n-            if (ctMethod.getGenericSignature() != null) {\n-                javassist.bytecode.SignatureAttribute.Type genericSignatureType = SignatureAttribute\n-                    .toMethodSignature(ctMethod.getGenericSignature())\n-                    .getReturnType();\n-                return JavassistUtils.signatureTypeToType(genericSignatureType, typeSolver, this);\n-            } else {\n-                try {\n-                    return JavassistFactory.typeUsageFor(ctMethod.getReturnType(), typeSolver);\n-                } catch (NotFoundException e) {\n-                    /*\n-                        \"ctMethod.getReturnType()\" will use \"declaringClass.getClassPool()\" to solve the returnType,\n-                        but in some case ,the returnType cannot solve by \"declaringClass.getClassPool()\".\n-                        In this case, we try to use \"typeSolver\" to solve \"ctMethod.getReturnType()\"\n-                        See https://github.com/javaparser/javaparser/pull/2398\n-                     */\n-                    final String returnTypeClassRefPath = toClassRefPath(ctMethod.getMethodInfo());\n-                    final ResolvedReferenceTypeDeclaration typeDeclaration = typeSolver\n-                        .solveType(returnTypeClassRefPath);\n-                    return new ReferenceTypeImpl(typeDeclaration, typeSolver);\n-                }\n-            }\n-        } catch (BadBytecode e) {\n-            throw new RuntimeException(e);\n-        }\n+        return methodLikeAdaper.getReturnType();\n     }\n \n-\n     @Override\n     public int getNumberOfParams() {\n-        try {\n-            return ctMethod.getParameterTypes().length;\n-        } catch (NotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n+        return methodLikeAdaper.getNumberOfParams();\n     }\n \n     @Override\n     public ResolvedParameterDeclaration getParam(int i) {\n-        try {\n-            boolean variadic = false;\n-            if ((ctMethod.getModifiers() & javassist.Modifier.VARARGS) > 0) {\n-                variadic = i == (ctMethod.getParameterTypes().length - 1);\n-            }\n-            Optional<String> paramName = JavassistUtils.extractParameterName(ctMethod, i);\n-            String signature = ctMethod.getGenericSignature() == null ? ctMethod.getSignature() : ctMethod.getGenericSignature();\n-            SignatureAttribute.MethodSignature methodSignature = SignatureAttribute.toMethodSignature(signature);\n-            SignatureAttribute.Type signatureType = methodSignature.getParameterTypes()[i];\n-            return new JavassistParameterDeclaration(JavassistUtils.signatureTypeToType(signatureType,\n-                    typeSolver, this), typeSolver, variadic, paramName.orElse(null));\n-\n-        } catch (NotFoundException | BadBytecode e) {\n-            throw new RuntimeException(e);\n-        }\n+        return methodLikeAdaper.getParam(i);\n     }\n \n     public MethodUsage getUsage(Node node) {\n         throw new UnsupportedOperationException();\n     }\n \n+    @Override\n     public MethodUsage resolveTypeVariables(Context context, List<ResolvedType> parameterTypes) {\n         return new MethodDeclarationCommonLogic(this, typeSolver).resolveTypeVariables(context, parameterTypes);\n     }\n@@ -178,15 +126,7 @@ public boolean isAbstract() {\n \n     @Override\n     public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n-        try {\n-            if (ctMethod.getGenericSignature() == null) {\n-                return new ArrayList<>();\n-            }\n-            SignatureAttribute.MethodSignature methodSignature = SignatureAttribute.toMethodSignature(ctMethod.getGenericSignature());\n-            return Arrays.stream(methodSignature.getTypeParameters()).map((jasTp) -> new JavassistTypeParameter(jasTp, this, typeSolver)).collect(Collectors.toList());\n-        } catch (BadBytecode badBytecode) {\n-            throw new RuntimeException(badBytecode);\n-        }\n+        return methodLikeAdaper.getTypeParameters();\n     }\n \n     @Override\n@@ -196,72 +136,17 @@ public AccessSpecifier accessSpecifier() {\n \n     @Override\n     public int getNumberOfSpecifiedExceptions() {\n-        try {\n-            return ctMethod.getExceptionTypes().length;\n-        } catch (NotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n+        return methodLikeAdaper.getNumberOfSpecifiedExceptions();\n     }\n \n     @Override\n     public ResolvedType getSpecifiedException(int index) {\n-        if (index < 0 || index >= getNumberOfSpecifiedExceptions()) {\n-            throw new IllegalArgumentException(String.format(\"No exception with index %d. Number of exceptions: %d\",\n-                    index, getNumberOfSpecifiedExceptions()));\n-        }\n-        try {\n-            return JavassistFactory.typeUsageFor(ctMethod.getExceptionTypes()[index], typeSolver);\n-        } catch (NotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n+        return methodLikeAdaper.getSpecifiedException(index);\n     }\n \n     @Override\n     public Optional<MethodDeclaration> toAst() {\n         return Optional.empty();\n     }\n \n-    /**\n-     * copy from javassist.bytecode.Descriptor#toCtClass(javassist.ClassPool, java.lang.String, int,\n-     * javassist.CtClass[], int)\n-     *\n-     * convert methodInfo.getDescriptor() to class reference path\n-     * e.g: convert \"()Ljava/sql/Driver\" to \"java.sql.Driver\"\n-     *\n-     * @param methodInfo\n-     * @return class reference path,e.g: \"java.sql.Driver\"\n-     */\n-    private String toClassRefPath(MethodInfo methodInfo) {\n-        final String desc = methodInfo.getDescriptor();//e.g: ()Ljava/sql/Driver;\n-\n-        int i = desc.indexOf(')');\n-        int i2;\n-        String classRefPath = null;//e.g: java.sql.Driver\n-\n-        if (i < 0) {\n-            throw new RuntimeException(\"parse descriptor error:\" + desc);\n-        }\n-        i += 1;\n-        char c = desc.charAt(i);\n-        int arrayDim = 0;\n-        while (c == '[') {\n-            ++arrayDim;\n-            c = desc.charAt(++i);\n-        }\n-        if (c == 'L') {\n-            i2 = desc.indexOf(';', ++i);\n-            classRefPath = desc.substring(i, i2++).replace('/', '.');\n-        }\n-\n-        if (arrayDim > 0) {\n-            StringBuffer sbuf = new StringBuffer(classRefPath);\n-            while (arrayDim-- > 0) {\n-                sbuf.append(\"[]\");\n-            }\n-\n-            classRefPath = sbuf.toString();\n-        }\n-\n-        return classRefPath;\n-    }\n }"
  },
  {
    "sha": "5e3006f25625b149f9193ddcc875f3c66276cc8c",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodLikeDeclarationAdapter.java",
    "status": "added",
    "additions": 100,
    "deletions": 0,
    "changes": 100,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodLikeDeclarationAdapter.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodLikeDeclarationAdapter.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodLikeDeclarationAdapter.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright (C) 2015-2016 Federico Tomassetti\n+ * Copyright (C) 2017-2020 The JavaParser Team.\n+ *\n+ * This file is part of JavaParser.\n+ *\n+ * JavaParser can be used either under the terms of\n+ * a) the GNU Lesser General Public License as published by\n+ *     the Free Software Foundation, either version 3 of the License, or\n+ *     (at your option) any later version.\n+ * b) the terms of the Apache License\n+ *\n+ * You should have received a copy of both licenses in LICENCE.LGPL and\n+ * LICENCE.APACHE. Please refer to those files for details.\n+ *\n+ * JavaParser is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Lesser General Public License for more details.\n+ */\n+\n+package com.github.javaparser.symbolsolver.javassistmodel;\n+\n+import com.github.javaparser.resolution.declarations.ResolvedMethodLikeDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedParameterDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\n+import com.github.javaparser.resolution.types.ResolvedType;\n+import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n+import javassist.CtBehavior;\n+import javassist.bytecode.BadBytecode;\n+import javassist.bytecode.SignatureAttribute;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+public class JavassistMethodLikeDeclarationAdapter {\n+\n+    private CtBehavior ctBehavior;\n+    private TypeSolver typeSolver;\n+    private ResolvedMethodLikeDeclaration declaration;\n+\n+    private SignatureAttribute.MethodSignature methodSignature;\n+\n+    public JavassistMethodLikeDeclarationAdapter(CtBehavior ctBehavior, TypeSolver typeSolver, ResolvedMethodLikeDeclaration declaration) {\n+        this.ctBehavior = ctBehavior;\n+        this.typeSolver = typeSolver;\n+        this.declaration = declaration;\n+\n+        try {\n+            String signature = ctBehavior.getGenericSignature();\n+            if (signature == null) {\n+                signature = ctBehavior.getSignature();\n+            }\n+            methodSignature = SignatureAttribute.toMethodSignature(signature);\n+        } catch (BadBytecode e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public int getNumberOfParams() {\n+        return methodSignature.getParameterTypes().length;\n+    }\n+\n+    public ResolvedParameterDeclaration getParam(int i) {\n+        boolean variadic = false;\n+        if ((ctBehavior.getModifiers() & javassist.Modifier.VARARGS) > 0) {\n+            variadic = i == (methodSignature.getParameterTypes().length - 1);\n+        }\n+\n+        Optional<String> paramName = JavassistUtils.extractParameterName(ctBehavior, i);\n+        ResolvedType type = JavassistUtils.signatureTypeToType(methodSignature.getParameterTypes()[i], typeSolver, declaration);\n+        return new JavassistParameterDeclaration(type, typeSolver, variadic, paramName.orElse(null));\n+    }\n+\n+    public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n+        if (ctBehavior.getGenericSignature() == null) {\n+            return new ArrayList<>();\n+        }\n+        return Arrays.stream(methodSignature.getTypeParameters())\n+                .map(jasTp -> new JavassistTypeParameter(jasTp, declaration, typeSolver))\n+                .collect(Collectors.toList());\n+    }\n+\n+    public int getNumberOfSpecifiedExceptions() {\n+        return methodSignature.getExceptionTypes().length;\n+    }\n+\n+    public ResolvedType getSpecifiedException(int index) {\n+        if (index < 0 || index >= getNumberOfSpecifiedExceptions()) {\n+            throw new IllegalArgumentException(String.format(\"No exception with index %d. Number of exceptions: %d\",\n+                    index, getNumberOfSpecifiedExceptions()));\n+        }\n+\n+        return JavassistUtils.signatureTypeToType(methodSignature.getExceptionTypes()[index], typeSolver, declaration);\n+    }\n+\n+    public ResolvedType getReturnType() {\n+        return JavassistUtils.signatureTypeToType(methodSignature.getReturnType(), typeSolver, declaration);\n+    }\n+}"
  },
  {
    "sha": "fa503337419839ef850fa8eabbac7089a5c3794d",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java",
    "status": "modified",
    "additions": 167,
    "deletions": 61,
    "changes": 228,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -21,9 +21,15 @@\n \n package com.github.javaparser.symbolsolver.javassistmodel;\n \n+import com.github.javaparser.resolution.UnsolvedSymbolException;\n import com.github.javaparser.resolution.declarations.*;\n+import com.github.javaparser.resolution.types.ResolvedReferenceType;\n+import com.github.javaparser.resolution.types.ResolvedType;\n+import com.github.javaparser.symbolsolver.javaparsermodel.LambdaArgumentTypePlaceholder;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n+import com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\n import javassist.CtClass;\n+import javassist.CtField;\n import javassist.NotFoundException;\n import javassist.bytecode.AccessFlag;\n import javassist.bytecode.BadBytecode;\n@@ -37,68 +43,168 @@\n  */\n public class JavassistTypeDeclarationAdapter {\n \n-  private CtClass ctClass;\n-  private TypeSolver typeSolver;\n-\n-  public JavassistTypeDeclarationAdapter(CtClass ctClass, TypeSolver typeSolver) {\n-    this.ctClass = ctClass;\n-    this.typeSolver = typeSolver;\n-  }\n-\n-  public Set<ResolvedMethodDeclaration> getDeclaredMethods() {\n-    return Arrays.stream(ctClass.getDeclaredMethods())\n-        .filter(m -> ((m.getMethodInfo().getAccessFlags() & AccessFlag.BRIDGE) == 0)\n-                  && ((m.getMethodInfo().getAccessFlags() & AccessFlag.SYNTHETIC) == 0))\n-        .map(m -> new JavassistMethodDeclaration(m, typeSolver)).collect(Collectors.toSet());\n-  }\n-\n-  public List<ResolvedConstructorDeclaration> getConstructors() {\n-    return Arrays.stream(ctClass.getConstructors())\n-        .filter(m -> (m.getMethodInfo().getAccessFlags() & AccessFlag.SYNTHETIC) == 0)\n-        .map(m -> new JavassistConstructorDeclaration(m, typeSolver)).collect(Collectors.toList());\n-  }\n-\n-  public List<ResolvedFieldDeclaration> getDeclaredFields() {\n-    List<ResolvedFieldDeclaration> fieldDecls = new ArrayList<>();\n-    collectDeclaredFields(ctClass, fieldDecls);\n-    return fieldDecls;\n-  }\n-\n-  private void collectDeclaredFields(CtClass ctClass, List<ResolvedFieldDeclaration> fieldDecls) {\n-    if (ctClass != null) {\n-      Arrays.stream(ctClass.getDeclaredFields())\n-          .forEach(f -> fieldDecls.add(new JavassistFieldDeclaration(f, typeSolver)));\n-      try {\n-        collectDeclaredFields(ctClass.getSuperclass(), fieldDecls);\n-      } catch (NotFoundException e) {\n-        // We'll stop here\n-      }\n+    private CtClass ctClass;\n+    private TypeSolver typeSolver;\n+    private ResolvedReferenceTypeDeclaration typeDeclaration;\n+\n+    public JavassistTypeDeclarationAdapter(CtClass ctClass, TypeSolver typeSolver, ResolvedReferenceTypeDeclaration typeDeclaration) {\n+        this.ctClass = ctClass;\n+        this.typeSolver = typeSolver;\n+        this.typeDeclaration = typeDeclaration;\n+    }\n+\n+    public Optional<ResolvedReferenceType> getSuperClass() {\n+        try {\n+            if (\"java.lang.Object\".equals(ctClass.getClassFile().getName())) {\n+                // If this is java.lang.Object, ignore the presence of any superclass (preventing any infinite loops).\n+                return Optional.empty();\n+            }\n+            if (ctClass.getGenericSignature() == null) {\n+                // Compiled classes have generic types erased, but can be made available for reflection via getGenericSignature().\n+                // If it is absent, then no further work is needed and we can return a reference type without generics.\n+                return Optional.of(new ReferenceTypeImpl(\n+                        typeSolver.solveType(JavassistUtils.internalNameToCanonicalName(ctClass.getClassFile().getSuperclass())),\n+                        typeSolver\n+                ));\n+            } else {\n+                // If there is a generic signature present, solve the types and return it.\n+                SignatureAttribute.ClassSignature classSignature = SignatureAttribute.toClassSignature(ctClass.getGenericSignature());\n+                return Optional.ofNullable(\n+                        JavassistUtils.signatureTypeToType(\n+                                classSignature.getSuperClass(),\n+                                typeSolver,\n+                                typeDeclaration\n+                        ).asReferenceType()\n+                );\n+            }\n+        } catch (BadBytecode e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public List<ResolvedReferenceType> getInterfaces() {\n+        return getInterfaces(false);\n+    }\n+\n+    private List<ResolvedReferenceType> getInterfaces(boolean acceptIncompleteList) {\n+        List<ResolvedReferenceType> interfaces = new ArrayList<>();\n+        try {\n+            if (ctClass.getGenericSignature() == null) {\n+                for (String interfaceType : ctClass.getClassFile().getInterfaces()) {\n+                    try {\n+                        ResolvedReferenceTypeDeclaration declaration = typeSolver.solveType(JavassistUtils.internalNameToCanonicalName(interfaceType));\n+                        interfaces.add(new ReferenceTypeImpl(declaration, typeSolver));\n+                    } catch (UnsolvedSymbolException e) {\n+                        if (!acceptIncompleteList) {\n+                            throw e;\n+                        }\n+                    }\n+                }\n+            } else {\n+                SignatureAttribute.ClassSignature classSignature = SignatureAttribute.toClassSignature(ctClass.getGenericSignature());\n+                for (SignatureAttribute.ClassType interfaceType : classSignature.getInterfaces()) {\n+                    try {\n+                        interfaces.add(JavassistUtils.signatureTypeToType(interfaceType, typeSolver, typeDeclaration).asReferenceType());\n+                    } catch (UnsolvedSymbolException e) {\n+                        if (!acceptIncompleteList) {\n+                            throw e;\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (BadBytecode e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        return interfaces;\n+    }\n+\n+    public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList) {\n+        List<ResolvedReferenceType> ancestors = new ArrayList<>();\n+\n+        try {\n+            getSuperClass().ifPresent(superClass -> ancestors.add(superClass));\n+        } catch (UnsolvedSymbolException e) {\n+            if (!acceptIncompleteList) {\n+                throw e;\n+            }\n+        }\n+        ancestors.addAll(getInterfaces(acceptIncompleteList));\n+        return ancestors;\n+    }\n+\n+    public Set<ResolvedMethodDeclaration> getDeclaredMethods() {\n+        return Arrays.stream(ctClass.getDeclaredMethods())\n+                .filter(m -> ((m.getMethodInfo().getAccessFlags() & AccessFlag.BRIDGE) == 0)\n+                        && ((m.getMethodInfo().getAccessFlags() & AccessFlag.SYNTHETIC) == 0))\n+                .map(m -> new JavassistMethodDeclaration(m, typeSolver)).collect(Collectors.toSet());\n+    }\n+\n+    public List<ResolvedConstructorDeclaration> getConstructors() {\n+        return Arrays.stream(ctClass.getConstructors())\n+                .filter(m -> (m.getMethodInfo().getAccessFlags() & AccessFlag.SYNTHETIC) == 0)\n+                .map(m -> new JavassistConstructorDeclaration(m, typeSolver)).collect(Collectors.toList());\n     }\n-  }\n-\n-  public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n-    if (null == ctClass.getGenericSignature()) {\n-      return Collections.emptyList();\n-    } else {\n-      try {\n-        SignatureAttribute.ClassSignature classSignature =\n-            SignatureAttribute.toClassSignature(ctClass.getGenericSignature());\n-        return Arrays.<SignatureAttribute.TypeParameter>stream(classSignature.getParameters())\n-            .map((tp) -> new JavassistTypeParameter(tp, JavassistFactory.toTypeDeclaration(ctClass, typeSolver), typeSolver))\n-            .collect(Collectors.toList());\n-      } catch (BadBytecode badBytecode) {\n-        throw new RuntimeException(badBytecode);\n-      }\n+\n+    public List<ResolvedFieldDeclaration> getDeclaredFields() {\n+        List<ResolvedFieldDeclaration> fields = new ArrayList<>();\n+\n+        // First consider fields declared on this class\n+        for (CtField field : ctClass.getDeclaredFields()) {\n+            fields.add(new JavassistFieldDeclaration(field, typeSolver));\n+        }\n+\n+        // Then consider fields inherited from ancestors\n+        for (ResolvedReferenceType ancestor : typeDeclaration.getAllAncestors()) {\n+            ancestor.getTypeDeclaration().ifPresent(ancestorTypeDeclaration -> {\n+                fields.addAll(ancestorTypeDeclaration.getAllFields());\n+            });\n+        }\n+\n+        return fields;\n     }\n-  }\n-\n-  public Optional<ResolvedReferenceTypeDeclaration> containerType() {\n-    try {\n-      return ctClass.getDeclaringClass() == null ?\n-          Optional.empty() :\n-          Optional.of(JavassistFactory.toTypeDeclaration(ctClass.getDeclaringClass(), typeSolver));\n-    } catch (NotFoundException e) {\n-      throw new RuntimeException(e);\n+\n+    public List<ResolvedTypeParameterDeclaration> getTypeParameters() {\n+        if (null == ctClass.getGenericSignature()) {\n+            return Collections.emptyList();\n+        } else {\n+            try {\n+                SignatureAttribute.ClassSignature classSignature =\n+                        SignatureAttribute.toClassSignature(ctClass.getGenericSignature());\n+                return Arrays.<SignatureAttribute.TypeParameter>stream(classSignature.getParameters())\n+                        .map((tp) -> new JavassistTypeParameter(tp, JavassistFactory.toTypeDeclaration(ctClass, typeSolver), typeSolver))\n+                        .collect(Collectors.toList());\n+            } catch (BadBytecode badBytecode) {\n+                throw new RuntimeException(badBytecode);\n+            }\n+        }\n+    }\n+\n+    public Optional<ResolvedReferenceTypeDeclaration> containerType() {\n+        try {\n+            return ctClass.getDeclaringClass() == null ?\n+                    Optional.empty() :\n+                    Optional.of(JavassistFactory.toTypeDeclaration(ctClass.getDeclaringClass(), typeSolver));\n+        } catch (NotFoundException e) {\n+            throw new RuntimeException(e);\n+        }\n     }\n-  }\n+\n+    public boolean isAssignableBy(ResolvedType other) {\n+\n+        if (other.isNull()) {\n+            return true;\n+        }\n+\n+        if (other instanceof LambdaArgumentTypePlaceholder) {\n+            return typeDeclaration.isFunctionalInterface();\n+        }\n+\n+        return other.isAssignableBy(new ReferenceTypeImpl(typeDeclaration, typeSolver));\n+    }\n+\n+    public boolean isAssignableBy(ResolvedReferenceTypeDeclaration other) {\n+        return isAssignableBy(new ReferenceTypeImpl(other, typeSolver));\n+    }\n+\n }"
  },
  {
    "sha": "432571fd4c5db76d2521bd7b0f4115a20cf7c44a",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistUtils.java",
    "status": "modified",
    "additions": 49,
    "deletions": 18,
    "changes": 67,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistUtils.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistUtils.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistUtils.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -23,26 +23,34 @@\n \n import com.github.javaparser.resolution.MethodUsage;\n import com.github.javaparser.resolution.UnsolvedSymbolException;\n+import com.github.javaparser.resolution.declarations.ResolvedMethodDeclaration;\n import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\n import com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\n import com.github.javaparser.resolution.declarations.ResolvedTypeParametrizable;\n import com.github.javaparser.resolution.types.*;\n+import com.github.javaparser.symbolsolver.core.resolution.Context;\n+import com.github.javaparser.symbolsolver.javaparsermodel.contexts.ContextHelper;\n+import com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\n import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n import com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\n import com.github.javaparser.symbolsolver.resolution.MethodResolutionLogic;\n import javassist.*;\n import javassist.bytecode.*;\n \n import java.util.*;\n+import java.util.function.Predicate;\n import java.util.stream.Collectors;\n \n /**\n  * @author Federico Tomassetti\n  */\n class JavassistUtils {\n \n-    static Optional<MethodUsage> getMethodUsage(CtClass ctClass, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver,\n-                                                List<ResolvedTypeParameterDeclaration> typeParameters, List<ResolvedType> typeParameterValues) {\n+    static Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver,\n+                                                    Context invokationContext, List<ResolvedType> typeParameterValues,\n+                                                    ResolvedReferenceTypeDeclaration scopeType, CtClass ctClass) {\n+        List<ResolvedTypeParameterDeclaration> typeParameters = scopeType.getTypeParameters();\n+\n         List<MethodUsage> methods = new ArrayList<>();\n         for (CtMethod method : ctClass.getDeclaredMethods()) {\n             if (method.getName().equals(name)\n@@ -63,30 +71,53 @@\n             }\n         }\n \n-        try {\n-            CtClass superClass = ctClass.getSuperclass();\n-            if (superClass != null) {\n-                Optional<MethodUsage> ref = JavassistUtils.getMethodUsage(superClass, name, argumentsTypes, typeSolver, typeParameters, typeParameterValues);\n-                if (ref.isPresent()) {\n-                    methods.add(ref.get());\n+        for (ResolvedReferenceType ancestor : scopeType.getAncestors()) {\n+            ancestor.getTypeDeclaration()\n+                .flatMap(superClassTypeDeclaration -> ancestor.getTypeDeclaration())\n+                .flatMap(interfaceTypeDeclaration -> ContextHelper.solveMethodAsUsage(interfaceTypeDeclaration, name, argumentsTypes, invokationContext, typeParameterValues))\n+                .ifPresent(methods::add);\n+        }\n+\n+        return MethodResolutionLogic.findMostApplicableUsage(methods, name, argumentsTypes, typeSolver);\n+    }\n+\n+    static SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly,\n+                                                                  TypeSolver typeSolver, ResolvedReferenceTypeDeclaration scopeType, CtClass ctClass) {\n+        List<ResolvedMethodDeclaration> candidates = new ArrayList<>();\n+        Predicate<CtMethod> staticOnlyCheck = m -> !staticOnly || java.lang.reflect.Modifier.isStatic(m.getModifiers());\n+        for (CtMethod method : ctClass.getDeclaredMethods()) {\n+            boolean isSynthetic = method.getMethodInfo().getAttribute(SyntheticAttribute.tag) != null;\n+            boolean isNotBridge = (method.getMethodInfo().getAccessFlags() & AccessFlag.BRIDGE) == 0;\n+            if (method.getName().equals(name) && !isSynthetic && isNotBridge && staticOnlyCheck.test(method)) {\n+                ResolvedMethodDeclaration candidate = new JavassistMethodDeclaration(method, typeSolver);\n+                candidates.add(candidate);\n+\n+                // no need to search for overloaded/inherited methods if the method has no parameters\n+                if (argumentsTypes.isEmpty() && candidate.getNumberOfParams() == 0) {\n+                    return SymbolReference.solved(candidate);\n                 }\n             }\n-        } catch (NotFoundException e) {\n-            throw new RuntimeException(e);\n         }\n \n-        try {\n-            for (CtClass interfaze : ctClass.getInterfaces()) {\n-                Optional<MethodUsage> ref = JavassistUtils.getMethodUsage(interfaze, name, argumentsTypes, typeSolver, typeParameters, typeParameterValues);\n-                if (ref.isPresent()) {\n-                    methods.add(ref.get());\n+        // add the method declaration of the interfaces to the candidates, if present\n+        for (ResolvedReferenceType ancestorRefType : scopeType.getAncestors()) {\n+            Optional<ResolvedReferenceTypeDeclaration> ancestorTypeDeclOpt = ancestorRefType.getTypeDeclaration();\n+            if (ancestorTypeDeclOpt.isPresent()) {\n+                SymbolReference<ResolvedMethodDeclaration> ancestorMethodRef = MethodResolutionLogic.solveMethodInType(\n+                        ancestorTypeDeclOpt.get(),\n+                        name,\n+                        argumentsTypes,\n+                        staticOnly\n+                );\n+                if (ancestorMethodRef.isSolved()) {\n+                    candidates.add(ancestorMethodRef.getCorrespondingDeclaration());\n                 }\n+            } else {\n+                // Consider IllegalStateException or similar?\n             }\n-        } catch (NotFoundException e) {\n-            throw new RuntimeException(e);\n         }\n \n-        return MethodResolutionLogic.findMostApplicableUsage(methods, name, argumentsTypes, typeSolver);\n+        return MethodResolutionLogic.findMostApplicable(candidates, name, argumentsTypes, typeSolver);\n     }\n \n     static ResolvedType signatureTypeToType(SignatureAttribute.Type signatureType, TypeSolver typeSolver, ResolvedTypeParametrizable typeParametrizable) {"
  },
  {
    "sha": "425146cc03450b6ede8071c824a6dafa29989c11",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/FunctionalInterfaceLogic.java",
    "status": "modified",
    "additions": 7,
    "deletions": 5,
    "changes": 12,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/FunctionalInterfaceLogic.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/FunctionalInterfaceLogic.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/logic/FunctionalInterfaceLogic.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -21,10 +21,6 @@\n \n package com.github.javaparser.symbolsolver.logic;\n \n-import com.github.javaparser.resolution.MethodUsage;\n-import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\n-import com.github.javaparser.resolution.types.ResolvedType;\n-\n import java.lang.reflect.Method;\n import java.lang.reflect.Parameter;\n import java.util.Arrays;\n@@ -33,10 +29,16 @@\n import java.util.Set;\n import java.util.stream.Collectors;\n \n+import com.github.javaparser.resolution.MethodUsage;\n+import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\n+import com.github.javaparser.resolution.types.ResolvedType;\n+\n /**\n  * @author Federico Tomassetti\n  */\n public final class FunctionalInterfaceLogic {\n+    \n+    private static String JAVA_LANG_FUNCTIONAL_INTERFACE = FunctionalInterface.class.getCanonicalName();\n \n     private FunctionalInterfaceLogic() {\n         // prevent instantiation\n@@ -81,7 +83,7 @@ private FunctionalInterfaceLogic() {\n     public static boolean isFunctionalInterfaceType(ResolvedType type) {\n         if (type.isReferenceType()) {\n             Optional<ResolvedReferenceTypeDeclaration> optionalTypeDeclaration = type.asReferenceType().getTypeDeclaration();\n-            if (optionalTypeDeclaration.isPresent() && optionalTypeDeclaration.get().hasAnnotation(FunctionalInterface.class.getCanonicalName())) {\n+            if (optionalTypeDeclaration.isPresent() && optionalTypeDeclaration.get().hasAnnotation(JAVA_LANG_FUNCTIONAL_INTERFACE)) {\n                 return true;\n             }\n         }"
  },
  {
    "sha": "1fc42425ac1e9b0e33bebfd66f16d920c1c18a75",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/resolution/TypeSolver.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/resolution/TypeSolver.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/resolution/TypeSolver.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/model/resolution/TypeSolver.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -31,6 +31,8 @@\n  * @author Federico Tomassetti\n  */\n public interface TypeSolver {\n+    \n+    String JAVA_LANG_OBJECT = Object.class.getCanonicalName();\n \n     /**\n      * Get the root of the hierarchy of type solver.\n@@ -75,7 +77,7 @@ default ResolvedReferenceTypeDeclaration solveType(String name) throws UnsolvedS\n      * @return A resolved reference to {@code java.lang.Object}\n      */\n     default ResolvedReferenceTypeDeclaration getSolvedJavaLangObject() throws UnsolvedSymbolException {\n-        return solveType(Object.class.getCanonicalName());\n+        return solveType(JAVA_LANG_OBJECT);\n     }\n \n     default boolean hasType(String name) {"
  },
  {
    "sha": "03205575bafe303ab422b95e0a4e9775913b5baf",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionFactory.java",
    "status": "modified",
    "additions": 16,
    "deletions": 8,
    "changes": 24,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionFactory.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionFactory.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionFactory.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -21,13 +21,6 @@\n \n package com.github.javaparser.symbolsolver.reflectionmodel;\n \n-import com.github.javaparser.ast.AccessSpecifier;\n-import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\n-import com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\n-import com.github.javaparser.resolution.types.*;\n-import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n-import com.github.javaparser.symbolsolver.model.typesystem.*;\n-\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.Modifier;\n import java.lang.reflect.ParameterizedType;\n@@ -36,10 +29,25 @@\n import java.util.Arrays;\n import java.util.List;\n \n+import com.github.javaparser.ast.AccessSpecifier;\n+import com.github.javaparser.resolution.declarations.ResolvedReferenceTypeDeclaration;\n+import com.github.javaparser.resolution.declarations.ResolvedTypeParameterDeclaration;\n+import com.github.javaparser.resolution.types.ResolvedArrayType;\n+import com.github.javaparser.resolution.types.ResolvedPrimitiveType;\n+import com.github.javaparser.resolution.types.ResolvedReferenceType;\n+import com.github.javaparser.resolution.types.ResolvedType;\n+import com.github.javaparser.resolution.types.ResolvedTypeVariable;\n+import com.github.javaparser.resolution.types.ResolvedVoidType;\n+import com.github.javaparser.resolution.types.ResolvedWildcard;\n+import com.github.javaparser.symbolsolver.model.resolution.TypeSolver;\n+import com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\n+\n /**\n  * @author Federico Tomassetti\n  */\n public class ReflectionFactory {\n+    \n+    private static String JAVA_LANG_OBJECT = Object.class.getCanonicalName();\n \n     public static ResolvedReferenceTypeDeclaration typeDeclarationFor(Class<?> clazz, TypeSolver typeSolver) {\n         if (clazz.isArray()) {\n@@ -90,7 +98,7 @@ public static ResolvedType typeUsageFor(java.lang.reflect.Type type, TypeSolver\n         } else if (type instanceof WildcardType) {\n             WildcardType wildcardType = (WildcardType) type;\n             if (wildcardType.getLowerBounds().length > 0 && wildcardType.getUpperBounds().length > 0) {\n-                if (wildcardType.getUpperBounds().length == 1 && wildcardType.getUpperBounds()[0].getTypeName().equals(Object.class.getCanonicalName())) {\n+                if (wildcardType.getUpperBounds().length == 1 && wildcardType.getUpperBounds()[0].getTypeName().equals(JAVA_LANG_OBJECT)) {\n                     // ok, it does not matter\n                 }\n             }"
  },
  {
    "sha": "31456f75fa8f7fc7c17d941e0ccba81959ebde23",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
    "status": "modified",
    "additions": 24,
    "deletions": 10,
    "changes": 34,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -54,6 +54,8 @@\n  * @author Federico Tomassetti\n  */\n public class MethodResolutionLogic {\n+    \n+    private static String JAVA_LANG_OBJECT = Object.class.getCanonicalName();\n \n     private static List<ResolvedType> groupVariadicParamValues(List<ResolvedType> argumentsTypes, int startVariadic, ResolvedType variadicType) {\n         List<ResolvedType> res = new ArrayList<>(argumentsTypes.subList(0, startVariadic));\n@@ -326,7 +328,7 @@ public static ResolvedType replaceTypeParam(ResolvedType type, ResolvedTypeParam\n                 } else if (bounds.size() == 1) {\n                     return bounds.get(0).getType();\n                 } else {\n-                    return new ReferenceTypeImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver);\n+                    return new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver);\n                 }\n             }\n             return type;\n@@ -433,15 +435,15 @@ public static boolean isApplicable(MethodUsage methodUsage, String needleName, L\n             // Consider cases where type variables can be replaced (e.g. add(E element) vs add(String element))\n             for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                 if (tp.getBounds().isEmpty()) {\n-                    //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver));\n-                    expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver)));\n+                    //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n+                    expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver)));\n                 } else if (tp.getBounds().size() == 1) {\n                     ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                     if (bound.isExtends()) {\n                         //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), bound.getType());\n                         expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.extendsBound(bound.getType()));\n                     } else {\n-                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver));\n+                        //expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp.getName(), new ReferenceTypeUsageImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                         expectedArgumentType = expectedArgumentType.replaceTypeVariables(tp, ResolvedWildcard.superBound(bound.getType()));\n                     }\n                 } else {\n@@ -453,13 +455,13 @@ public static boolean isApplicable(MethodUsage methodUsage, String needleName, L\n             ResolvedType expectedTypeWithSubstitutions = expectedTypeWithoutSubstitutions;\n             for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                 if (tp.getBounds().isEmpty()) {\n-                    expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver));\n+                    expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                 } else if (tp.getBounds().size() == 1) {\n                     ResolvedTypeParameterDeclaration.Bound bound = tp.getBounds().get(0);\n                     if (bound.isExtends()) {\n                         expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, bound.getType());\n                     } else {\n-                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver));\n+                        expectedTypeWithSubstitutions = expectedTypeWithSubstitutions.replaceTypeVariables(tp, new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT), typeSolver));\n                     }\n                 } else {\n                     throw new UnsupportedOperationException();\n@@ -557,7 +559,7 @@ public static boolean isApplicable(MethodUsage methodUsage, String needleName, L\n         if (applicableMethods.size() == 1) {\n             return SymbolReference.solved(applicableMethods.get(0));\n         }\n-\n+        \n         // Examine the applicable methods found, and evaluate each to determine the \"best\" one\n         ResolvedMethodDeclaration winningCandidate = applicableMethods.get(0);\n         ResolvedMethodDeclaration other = null;\n@@ -570,21 +572,33 @@ public static boolean isApplicable(MethodUsage methodUsage, String needleName, L\n                 possibleAmbiguity = false;\n                 winningCandidate = other;\n             } else {\n-                if (winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName())) {\n+                // 15.12.2.5. Choosing the Most Specific Method\n+                // One applicable method m1 is more specific than another applicable method m2, for an invocation with argument\n+                // expressions e1, ..., ek, if any of the following are true:\n+                // m2 is generic, and m1 is inferred to be more specific than m2 for argument expressions e1, ..., ek by §18.5.4.\n+                // 18.5.4. More Specific Method Inference should be verified \n+                // ...\n+                if (winningCandidate.isGeneric() && !other.isGeneric()) {\n+                    winningCandidate = other;\n+                } else if (!winningCandidate.isGeneric() && other.isGeneric()) {\n+                    // nothing to do at this stage winningCandidate is the winner\n+                } else if (winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName())) {\n                     possibleAmbiguity = true;\n                 } else {\n                     // we expect the methods to be ordered such that inherited methods are later in the list\n                 }\n             }\n         }\n-\n+        \n         if (possibleAmbiguity) {\n             // pick the first exact match if it exists\n             if (!isExactMatch(winningCandidate, argumentsTypes)) {\n                 if (isExactMatch(other, argumentsTypes)) {\n                     winningCandidate = other;\n                 } else {\n-                    throw new MethodAmbiguityException(\"Ambiguous method call: cannot find a most applicable method: \" + winningCandidate + \", \" + other);\n+                    throw new MethodAmbiguityException(\n+                            \"Ambiguous method call: cannot find a most applicable method: \" + winningCandidate\n+                                    + \", \" + other);\n                 }\n             }\n         }"
  },
  {
    "sha": "f6d7f7d983c43ea5def76693733bfdde45e45ed9",
    "filename": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java",
    "status": "modified",
    "additions": 5,
    "deletions": 3,
    "changes": 8,
    "blob_url": "https://github.com/MysterAitch/javaparser/blob/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java",
    "raw_url": "https://github.com/MysterAitch/javaparser/raw/224e0130bf6e01e82536053e590e595e54994341/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java",
    "contents_url": "https://api.github.com/repos/MysterAitch/javaparser/contents/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java?ref=224e0130bf6e01e82536053e590e595e54994341",
    "patch": "@@ -51,11 +51,13 @@\n  * @author Federico Tomassetti\n  */\n public class BoundSet {\n+    \n+    private static String JAVA_LANG_RUNTIME_EXCEPTION = RuntimeException.class.getCanonicalName();\n+    \n+    private static final BoundSet EMPTY = new BoundSet();\n \n     private List<Bound> bounds = new LinkedList<>();\n \n-    private static final BoundSet EMPTY = new BoundSet();\n-\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) return true;\n@@ -713,7 +715,7 @@ private boolean hasProperty(Set<InferenceVariable> alphas, List<VariableDependen\n \n                     boolean throwsBound = bounds.stream().anyMatch(b -> b.isThrowsBoundOn(alphaI));\n                     if (Ti == null && throwsBound && properUpperBoundsAreAtMostExceptionThrowableAndObject(alphaI)) {\n-                        Ti = new ReferenceTypeImpl(typeSolver.solveType(RuntimeException.class.getCanonicalName()), typeSolver);\n+                        Ti = new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_RUNTIME_EXCEPTION), typeSolver);\n                     }\n \n                     //   - Otherwise, where αi has proper upper bounds U1, ..., Uk, Ti = glb(U1, ..., Uk) (§5.1.10)."
  }
]
