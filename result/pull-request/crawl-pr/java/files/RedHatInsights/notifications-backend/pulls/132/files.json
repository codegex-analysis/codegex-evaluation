[
  {
    "sha": "17b1513d758618d594284ff23fc9af70a743fe50",
    "filename": "pom.xml",
    "status": "modified",
    "additions": 9,
    "deletions": 22,
    "changes": 31,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/pom.xml",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/pom.xml",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/pom.xml?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -13,17 +13,13 @@\n         <maven.compiler.target>11</maven.compiler.target>\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n-        <quarkus.platform.version>1.10.1.Final</quarkus.platform.version>\n+        <quarkus.platform.version>1.12.2.Final</quarkus.platform.version>\n         <quarkus-plugin.version>${quarkus.platform.version}</quarkus-plugin.version>\n         <quarkus.platform.artifact-id>quarkus-bom</quarkus.platform.artifact-id>\n         <quarkus.platform.group-id>io.quarkus</quarkus.platform.group-id>\n         <surefire-plugin.version>2.22.1</surefire-plugin.version>\n-        <!-- r2dbc versions do not necessarily align -->\n-        <r2dbc-postgres.version>0.8.6.RELEASE</r2dbc-postgres.version>\n-        <r2dbc-pool.version>0.8.5.RELEASE</r2dbc-pool.version>\n         <checkstyle-plugin.version>3.1.1</checkstyle-plugin.version>\n         <checkstyle.version>8.36.2</checkstyle.version>\n-        <mutiny-reactor.version>0.10.0</mutiny-reactor.version>\n         <testcontainers.version>1.15.1</testcontainers.version>\n         <mockserver-client-java.version>5.5.4</mockserver-client-java.version> <!-- not the newest, but matches what is in org.testcontainers:mockserver -->\n         <version.cloud-commons>0.1.1</version.cloud-commons>\n@@ -119,6 +115,14 @@\n             <groupId>io.quarkus</groupId>\n             <artifactId>quarkus-resteasy-qute</artifactId>\n         </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-hibernate-reactive</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-reactive-pg-client</artifactId>\n+        </dependency>\n \n         <!-- Related to Quarkus, but outside the Quarkus namespace -->\n         <!-- https://github.com/quarkusio/quarkus/issues/12913 -->\n@@ -135,11 +139,6 @@\n             <groupId>io.smallrye.reactive</groupId>\n             <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n         </dependency>\n-        <dependency>\n-            <groupId>io.smallrye.reactive</groupId>\n-            <artifactId>mutiny-reactor</artifactId>\n-            <version>${mutiny-reactor.version}</version>\n-        </dependency>\n \n         <!-- Flyway specific dependencies -->\n         <dependency>\n@@ -151,18 +150,6 @@\n             <artifactId>quarkus-jdbc-postgresql</artifactId>\n         </dependency>\n \n-        <!-- R2DBC dependencies -->\n-        <dependency>\n-            <groupId>io.r2dbc</groupId> <!-- org.postgresql after 0.9.* -->\n-            <artifactId>r2dbc-postgresql</artifactId>\n-            <version>${r2dbc-postgres.version}</version>\n-        </dependency>\n-        <dependency>\n-            <groupId>io.r2dbc</groupId>\n-            <artifactId>r2dbc-pool</artifactId>\n-            <version>${r2dbc-pool.version}</version>\n-        </dependency>\n-\n         <!-- Test dependencies -->\n         <dependency>\n             <groupId>io.quarkus</groupId>"
  },
  {
    "sha": "273a765eb745680f47459d1485ee8c8cce9133d9",
    "filename": "src/main/java/com/redhat/cloud/notifications/auth/RHIdentityAuthMechanism.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/auth/RHIdentityAuthMechanism.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/auth/RHIdentityAuthMechanism.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/auth/RHIdentityAuthMechanism.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -51,7 +51,7 @@\n                     good = true;\n                 }\n             } else if (path.startsWith(\"/openapi.json\") || path.startsWith(\"/internal\")\n-                    || path.startsWith(\"/admin\") || path.startsWith(\"/health\")) {\n+                    || path.startsWith(\"/admin\") || path.startsWith(\"/health\") || path.startsWith(\"/q/health\")) {\n                 good = true;\n             }\n "
  },
  {
    "sha": "cf02f8f7a84ca690ab19448302fda2dbd6c75ede",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/AbstractGenericResource.java",
    "status": "removed",
    "additions": 0,
    "deletions": 37,
    "changes": 37,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/4513da97584698a734a26e462b7a52632db1a981/src/main/java/com/redhat/cloud/notifications/db/AbstractGenericResource.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/4513da97584698a734a26e462b7a52632db1a981/src/main/java/com/redhat/cloud/notifications/db/AbstractGenericResource.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/AbstractGenericResource.java?ref=4513da97584698a734a26e462b7a52632db1a981",
    "patch": "@@ -1,37 +0,0 @@\n-package com.redhat.cloud.notifications.db;\n-\n-import io.r2dbc.postgresql.api.PostgresqlConnection;\n-import io.r2dbc.postgresql.api.PostgresqlResult;\n-import io.smallrye.mutiny.Multi;\n-import io.smallrye.mutiny.Uni;\n-import reactor.core.publisher.Flux;\n-\n-import javax.inject.Inject;\n-import javax.inject.Provider;\n-import java.util.UUID;\n-\n-/**\n- * A base class for some of the resources stuff\n- */\n-public abstract class AbstractGenericResource {\n-\n-    @Inject\n-    Provider<Uni<PostgresqlConnection>> connectionPublisher;\n-\n-    protected Uni<Boolean> runDeleteQuery(UUID eventTypeId, String query) {\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                    c2 -> {\n-                        Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                .bind(\"$1\", eventTypeId)\n-                                .execute();\n-                        return execute.flatMap(PostgresqlResult::getRowsUpdated)\n-                                .map(i -> true).next();\n-\n-                    })\n-                    .withFinalizer(postgresqlConnection -> {\n-                        postgresqlConnection.close().subscribe();\n-                    })\n-                ).toUni();\n-    }\n-}"
  },
  {
    "sha": "8d709650e1a4a13a432dcc29f7108c38c8746ae7",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/ApplicationResources.java",
    "status": "modified",
    "additions": 95,
    "deletions": 216,
    "changes": 311,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/ApplicationResources.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/ApplicationResources.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/ApplicationResources.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -1,274 +1,153 @@\n package com.redhat.cloud.notifications.db;\n \n+import com.redhat.cloud.notifications.db.entities.ApplicationEntity;\n+import com.redhat.cloud.notifications.db.entities.EventTypeEntity;\n+import com.redhat.cloud.notifications.db.mappers.ApplicationMapper;\n+import com.redhat.cloud.notifications.db.mappers.EventTypeMapper;\n import com.redhat.cloud.notifications.models.Application;\n import com.redhat.cloud.notifications.models.EventType;\n-import io.r2dbc.postgresql.api.PostgresqlConnection;\n-import io.r2dbc.postgresql.api.PostgresqlResult;\n-import io.r2dbc.postgresql.api.PostgresqlStatement;\n import io.smallrye.mutiny.Multi;\n import io.smallrye.mutiny.Uni;\n-import reactor.core.publisher.Flux;\n+import org.hibernate.reactive.mutiny.Mutiny;\n \n import javax.enterprise.context.ApplicationScoped;\n import javax.inject.Inject;\n-import javax.inject.Provider;\n import javax.validation.constraints.NotNull;\n-import java.util.Date;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.Set;\n import java.util.UUID;\n \n @ApplicationScoped\n-public class ApplicationResources extends AbstractGenericResource {\n+public class ApplicationResources {\n \n-    private static final String APPLICATION_QUERY = \"SELECT a.id, a.name, a.display_name, a.created, a.updated, a.bundle_id FROM public.applications a\";\n-    private static final String APPLICATION_QUERY_BY_BUNDLE_NAME = APPLICATION_QUERY + \" JOIN bundles AS b ON a.bundle_id = b.id WHERE b.name = $1\";\n     @Inject\n-    Provider<Uni<PostgresqlConnection>> connectionPublisher;\n+    Mutiny.Session session;\n+\n+    @Inject\n+    ApplicationMapper applicationMapper;\n+\n+    @Inject\n+    EventTypeMapper eventTypeMapper;\n \n     public Uni<Application> createApplication(Application app) {\n-        String query = \"INSERT INTO public.applications (name, display_name, bundle_id) VALUES ($1, $2, $3)\";\n         // Return filled with id\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> c2.createStatement(query)\n-                                .bind(\"$1\", app.getName())\n-                                .bind(\"$2\", app.getDisplay_name())\n-                                .bind(\"$3\", app.getBundleId())\n-                                .returnGeneratedValues(\"id\", \"created\")\n-                                .execute()\n-                                .flatMap(res -> res.map((row, rowMetadata) -> {\n-                                    app.setId(row.get(\"id\", UUID.class));\n-                                    app.setCreated(row.get(\"created\", Date.class));\n-                                    return app;\n-                                })))\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        return Uni.createFrom().item(() -> applicationMapper.dtoToEntity(app))\n+                .flatMap(applicationEntity -> session.persist(applicationEntity)\n+                        .replaceWith(applicationEntity))\n+                .call(() -> session.flush())\n+                .onItem().transform(applicationMapper::entityToDto);\n     }\n \n     public Uni<Boolean> deleteApplication(UUID applicationId) {\n-        String query = \"DELETE FROM public.applications WHERE id = $1\";\n-\n-        return runDeleteQuery(applicationId, query);\n+        String query = \"DELETE FROM ApplicationEntity WHERE id = :applicationId\";\n+        return session.createQuery(query)\n+                .setParameter(\"applicationId\", applicationId)\n+                .executeUpdate()\n+                .call(() -> session.flush())\n+                .onItem().transform(rowCount -> rowCount > 0);\n     }\n \n     public Uni<EventType> addEventTypeToApplication(UUID applicationId, EventType type) {\n-        String insertQuery = \"INSERT INTO public.event_type (name, display_name, application_id, description) VALUES ($1, $2, $3, $4)\";\n-\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            PostgresqlStatement bind = c2.createStatement(insertQuery)\n-                                    .bind(\"$1\", type.getName())\n-                                    .bind(\"$2\", type.getDisplay_name())\n-                                    .bind(\"$3\", applicationId)\n-\n-                                    .returnGeneratedValues(\"id\");\n-\n-                            if (type.getDescription() != null) {\n-                                bind.bind(\"$4\", type.getDescription());\n-                            } else {\n-                                bind.bindNull(\"$4\", String.class);\n-                            }\n-\n-                            return bind\n-                                    .execute()\n-                                    .flatMap(res -> res.map((row, rowMetadata) -> {\n-                                        type.setId(row.get(\"id\", UUID.class));\n-                                        return type;\n-                                    }));\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        // FIXME It should be possible to avoid querying the app before the event type insert\n+        return session.find(ApplicationEntity.class, applicationId)\n+                .onItem().transform(applicationEntity -> {\n+                    EventTypeEntity eventTypeEntity = eventTypeMapper.dtoToEntity(type);\n+                    eventTypeEntity.application = applicationEntity;\n+                    return eventTypeEntity;\n+                })\n+                .flatMap(eventTypeEntity -> session.persist(eventTypeEntity)\n+                        .replaceWith(eventTypeEntity)\n+                )\n+                .call(() -> session.flush())\n+                .onItem().transform(eventTypeMapper::entityToDto);\n     }\n \n     public Multi<Application> getApplications(String bundleName) {\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(APPLICATION_QUERY_BY_BUNDLE_NAME)\n-                                    .bind(\"$1\", bundleName)\n-                                    .execute();\n-\n-                            return mapResultSetToApplication(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n-    }\n-\n-    private Flux<Application> mapResultSetToApplication(Flux<PostgresqlResult> resultFlux) {\n-        return resultFlux.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-            Application app = new Application();\n-            app.setId(row.get(\"id\", UUID.class));\n-            app.setBundleId(row.get(\"bundle_id\", UUID.class));\n-            app.setName(row.get(\"name\", String.class));\n-            app.setDisplay_name(row.get(\"display_name\", String.class));\n-            app.setCreated(row.get(\"created\", Date.class));\n-            app.setUpdated(row.get(\"updated\", Date.class));\n-            return app;\n-        }));\n+        String query = \"FROM ApplicationEntity WHERE bundle.name = :bundleName\";\n+        return session.createQuery(query, ApplicationEntity.class)\n+                .setParameter(\"bundleName\", bundleName)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(applicationMapper::entityToDto);\n     }\n \n     public Uni<Application> getApplication(UUID applicationId) {\n-        String query = APPLICATION_QUERY + \" WHERE id = $1\";\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", applicationId)\n-                                    .execute();\n-\n-                            return mapResultSetToApplication(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        })).toUni();\n+        return session.find(ApplicationEntity.class, applicationId)\n+                .onItem().ifNotNull().transform(applicationMapper::entityToDto);\n     }\n \n     public Uni<Application> getApplication(String bundleName, String applicationName) {\n-        final String query = APPLICATION_QUERY_BY_BUNDLE_NAME + \" AND a.name = $2\";\n-\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", bundleName)\n-                                    .bind(\"$2\", applicationName)\n-                                    .execute();\n-\n-                            return mapResultSetToApplication(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        })).toUni();\n+        String query = \"FROM ApplicationEntity WHERE bundle.name = :bundleName AND name = :applicationName\";\n+        return session.createQuery(query, ApplicationEntity.class)\n+                .setParameter(\"bundleName\", bundleName)\n+                .setParameter(\"applicationName\", applicationName)\n+                .getSingleResultOrNull()\n+                .onItem().ifNotNull().transform(applicationMapper::entityToDto);\n     }\n \n     public Multi<EventType> getEventTypes(UUID applicationId) {\n-        String query = \"SELECT et.id, et.name, et.display_name FROM public.event_type et \" +\n-                \"WHERE et.application_id = $1\";\n-\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", applicationId)\n-                                    .execute();\n-\n-                            return execute.flatMap(res -> res.map((row, rowMetadata) -> {\n-                                EventType eventType = new EventType();\n-                                eventType.setId(row.get(\"id\", UUID.class));\n-                                eventType.setName(row.get(\"name\", String.class));\n-                                eventType.setDisplay_name(row.get(\"display_name\", String.class));\n-                                return eventType;\n-                            }));\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n+        String query = \"FROM EventTypeEntity WHERE application.id = :applicationId\";\n+        return session.createQuery(query, EventTypeEntity.class)\n+                .setParameter(\"applicationId\", applicationId)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(eventTypeMapper::entityToDto);\n     }\n \n     public Uni<Boolean> deleteEventTypeById(UUID eventTypeId) {\n-        String query = \"DELETE FROM public.event_type WHERE id = $1\";\n-        return runDeleteQuery(eventTypeId, query);\n-    }\n-\n-    public Multi<EventType> getEventTypes(Query limiter) {\n-        return this.getEventTypes(limiter, null, null);\n+        String query = \"DELETE FROM EventTypeEntity WHERE id = :eventTypeId\";\n+        return session.createQuery(query)\n+                .setParameter(\"eventTypeId\", eventTypeId)\n+                .executeUpdate()\n+                .call(() -> session.flush())\n+                .onItem().transform(rowCount -> rowCount > 0);\n     }\n \n     public Multi<EventType> getEventTypes(Query limiter, Set<UUID> applicationId, UUID bundleId) {\n-        String basicQuery = \"SELECT et.id AS et_id, et.name AS et_name, et.display_name AS et_din, et.description AS et_description, a.id AS a_id, a.name AS a_name, a.display_name as a_displayName, a.bundle_id as a_bundle_id FROM public.event_type et \" +\n-                \"JOIN public.applications a ON a.id = et.application_id \";\n-\n-        String whereClause = \"\";\n-        boolean hasWhere = false;\n-        String bundleIdParam = \"$1\";\n+        String query = \"SELECT e FROM EventTypeEntity e LEFT JOIN FETCH e.application\";\n \n+        List<String> conditions = new ArrayList<>();\n         if (applicationId != null && applicationId.size() > 0) {\n-            whereClause += \" a.id = ANY ($1) \";\n-            bundleIdParam = \"$2\";\n-            hasWhere = true;\n+            conditions.add(\"e.application.id IN (:applicationId)\");\n         }\n-\n         if (bundleId != null) {\n-            if (hasWhere) {\n-                whereClause += \" AND \";\n-            }\n-            whereClause += \" a.bundle_id = \" + bundleIdParam + \" \";\n+            conditions.add(\"e.application.bundle.id = :bundleId\");\n         }\n-\n-        if (!whereClause.equals(\"\")) {\n-            basicQuery += \" WHERE \" + whereClause;\n+        if (conditions.size() > 0) {\n+            query += \" WHERE \" + String.join(\" AND \", conditions);\n         }\n \n-        String query = limiter.getModifiedQuery(basicQuery);\n-\n-        final String finalBundleIdParam = bundleIdParam;\n-\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            PostgresqlStatement statement = c2.createStatement(query);\n-\n-                            if (applicationId != null && applicationId.size() > 0) {\n-                                statement = statement.bind(\"$1\", applicationId.toArray(new UUID[applicationId.size()]));\n-                            }\n+        if (limiter != null) {\n+            query = limiter.getModifiedQuery(query);\n+        }\n \n-                            if (bundleId != null) {\n-                                statement = statement.bind(finalBundleIdParam, bundleId);\n-                            }\n+        Mutiny.Query<EventTypeEntity> mutinyQuery = session.createQuery(query, EventTypeEntity.class);\n+        if (applicationId != null && applicationId.size() > 0) {\n+            mutinyQuery = mutinyQuery.setParameter(\"applicationId\", applicationId);\n+        }\n+        if (bundleId != null) {\n+            mutinyQuery = mutinyQuery.setParameter(\"bundleId\", bundleId);\n+        }\n \n-                            Flux<PostgresqlResult> execute = statement.execute();\n+        if (limiter != null && limiter.getLimit() != null && limiter.getLimit().getLimit() > 0) {\n+            mutinyQuery = mutinyQuery.setMaxResults(limiter.getLimit().getLimit())\n+                    .setFirstResult(limiter.getLimit().getOffset());\n+        }\n \n-                            return mapResultSetToEventTypes(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n+        return mutinyQuery.getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(eventTypeMapper::entityToDto);\n     }\n \n     public Multi<EventType> getEventTypesByEndpointId(@NotNull String accountId, @NotNull UUID endpointId) {\n-        String query = \"SELECT et.id AS et_id, et.name AS et_name, et.display_name AS et_din, et.description AS et_description, a.id AS a_id, a.name AS a_name, a.display_name as a_displayName, a.bundle_id as a_bundle_id FROM public.event_type et \" +\n-                \"JOIN public.applications a ON a.id = et.application_id \" +\n-                \"JOIN public.endpoint_targets endt ON  endt.event_type_id = et.id \" +\n-                \"WHERE endt.endpoint_id = $1 AND endt.account_id = $2\";\n-\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", endpointId)\n-                                    .bind(\"$2\", accountId)\n-                                    .execute();\n-\n-                            return mapResultSetToEventTypes(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n-    }\n-\n-    private Flux<EventType> mapResultSetToEventTypes(Flux<PostgresqlResult> resultFlux) {\n-        return resultFlux.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-            Application app = new Application();\n-            app.setBundleId(row.get(\"a_bundle_id\", UUID.class));\n-            app.setId(row.get(\"a_id\", UUID.class));\n-            app.setName(row.get(\"a_name\", String.class));\n-            app.setDisplay_name(row.get(\"a_displayName\", String.class));\n-\n-            EventType eventType = new EventType();\n-            eventType.setId(row.get(\"et_id\", UUID.class));\n-            eventType.setName(row.get(\"et_name\", String.class));\n-            eventType.setDisplay_name(row.get(\"et_din\", String.class));\n-            eventType.setDescription(row.get(\"et_description\", String.class));\n-\n-            eventType.setApplication(app);\n-\n-            return eventType;\n-        }));\n+        String query = \"SELECT e FROM EventTypeEntity e LEFT JOIN FETCH e.application JOIN e.targets t \" +\n+                \"WHERE t.id.accountId = :accountId AND t.endpoint.id = :endpointId\";\n+        return session.createQuery(query, EventTypeEntity.class)\n+                .setParameter(\"accountId\", accountId)\n+                .setParameter(\"endpointId\", endpointId)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(eventTypeMapper::entityToDto);\n     }\n }"
  },
  {
    "sha": "fd42b91d50a9778a79701e4cff6d86641584f91a",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/BundleResources.java",
    "status": "modified",
    "additions": 48,
    "deletions": 111,
    "changes": 159,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/BundleResources.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/BundleResources.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/BundleResources.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -1,146 +1,83 @@\n package com.redhat.cloud.notifications.db;\n \n+import com.redhat.cloud.notifications.db.entities.ApplicationEntity;\n+import com.redhat.cloud.notifications.db.entities.BundleEntity;\n+import com.redhat.cloud.notifications.db.mappers.ApplicationMapper;\n+import com.redhat.cloud.notifications.db.mappers.BundleMapper;\n import com.redhat.cloud.notifications.models.Application;\n import com.redhat.cloud.notifications.models.Bundle;\n-import io.r2dbc.postgresql.api.PostgresqlResult;\n import io.smallrye.mutiny.Multi;\n import io.smallrye.mutiny.Uni;\n-import reactor.core.publisher.Flux;\n+import org.hibernate.reactive.mutiny.Mutiny;\n \n import javax.enterprise.context.ApplicationScoped;\n-import java.util.Date;\n+import javax.inject.Inject;\n import java.util.UUID;\n \n /**\n  * Deal with Bundles.\n- * More or less stupid copy & paste & search & replace of\n- * code in BundleResources\n  */\n @ApplicationScoped\n-public class BundleResources extends  AbstractGenericResource {\n+public class BundleResources {\n \n-    public static final String PUBLIC_APPLICATIONS = \"public.applications\";\n-    public static final String PUBLIC_BUNDLES = \"public.bundles\";\n+    @Inject\n+    Mutiny.Session session;\n+\n+    @Inject\n+    BundleMapper bundleMapper;\n+\n+    @Inject\n+    ApplicationMapper applicationMapper;\n \n     public Uni<Bundle> createBundle(Bundle bundle) {\n-        String query = \"INSERT INTO \" + PUBLIC_BUNDLES + \" (name, display_name) VALUES ($1, $2)\";\n         // Return filled with id\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                    c2 -> c2.createStatement(query)\n-                    .bind(\"$1\", bundle.getName())\n-                    .bind(\"$2\", bundle.getDisplay_name())\n-                    .returnGeneratedValues(\"id\", \"created\")\n-                    .execute()\n-                    .flatMap(res -> res.map((row, rowMetadata) -> {\n-                        bundle.setId(row.get(\"id\", UUID.class));\n-                        bundle.setCreated(row.get(\"created\", Date.class));\n-                        return bundle;\n-                    })))\n-            .withFinalizer(postgresqlConnection -> {\n-                postgresqlConnection.close().subscribe();\n-            }))\n-                .toUni();\n+        return Uni.createFrom().item(() -> bundleMapper.dtoToEntity(bundle))\n+                .flatMap(bundleEntity -> session.persist(bundleEntity)\n+                        .call(() -> session.flush())\n+                        .replaceWith(bundleEntity)\n+                )\n+                .onItem().transform(bundleMapper::entityToDto);\n     }\n \n-    private static final String BUNDLE_QUERY = \"SELECT b.id, b.name, b.display_name, b.created, b.updated FROM \" + PUBLIC_BUNDLES + \" b\";\n-\n     public Multi<Bundle> getBundles() {\n-        return connectionPublisher.get().onItem()\n-            .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                c2 -> {\n-                    Flux<PostgresqlResult> execute = c2.createStatement(BUNDLE_QUERY)\n-                        .execute();\n-\n-                    return mapResultSetToBundle(execute);\n-                })\n-                .withFinalizer(postgresqlConnection -> {\n-                    postgresqlConnection.close().subscribe();\n-                }));\n-    }\n-\n-    private Flux<Bundle> mapResultSetToBundle(Flux<PostgresqlResult> resultFlux) {\n-        return resultFlux.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-            Bundle bundle = new Bundle();\n-            bundle.setId(row.get(\"id\", UUID.class));\n-            bundle.setName(row.get(\"name\", String.class));\n-            bundle.setDisplay_name(row.get(\"display_name\", String.class));\n-            bundle.setCreated(row.get(\"created\", Date.class));\n-            bundle.setUpdated(row.get(\"updated\", Date.class));\n-            return bundle;\n-        }));\n+        String query = \"FROM BundleEntity\";\n+        return session.createQuery(query, BundleEntity.class)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(bundleMapper::entityToDto);\n     }\n \n     public Uni<Bundle> getBundle(UUID bundleId) {\n-        String query = BUNDLE_QUERY + \" WHERE id = $1\";\n-        return connectionPublisher.get().onItem()\n-            .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                c2 -> {\n-                    Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                            .bind(\"$1\", bundleId)\n-                            .execute();\n-\n-                    return mapResultSetToBundle(execute);\n-                })\n-                .withFinalizer(postgresqlConnection -> {\n-                    postgresqlConnection.close().subscribe();\n-                })).toUni();\n+        return session.find(BundleEntity.class, bundleId)\n+                .onItem().ifNotNull().transform(bundleMapper::entityToDto);\n     }\n \n     public Uni<Boolean> deleteBundle(UUID bundleId) {\n-\n-        String query = \"DELETE FROM \" + PUBLIC_BUNDLES + \" WHERE id = $1\";\n-        return runDeleteQuery(bundleId, query);\n+        String query = \"DELETE FROM BundleEntity WHERE id = :bundleId\";\n+        return session.createQuery(query)\n+                .setParameter(\"bundleId\", bundleId)\n+                .executeUpdate()\n+                .call(() -> session.flush())\n+                .onItem().transform(rowCount -> rowCount > 0);\n     }\n \n-\n     public Multi<Application> getApplications(UUID bundleId) {\n-        String query = \"SELECT et.id, et.name, et.display_name FROM \" + PUBLIC_APPLICATIONS + \" et \" +\n-                \"WHERE et.bundle_id = $1\";\n-\n-        return connectionPublisher.get().onItem()\n-            .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                c2 -> {\n-                    Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                            .bind(\"$1\", bundleId)\n-                            .execute();\n-\n-                    return execute.flatMap(res -> res.map((row, rowMetadata) -> {\n-                        Application application = new Application();\n-                        application.setId(row.get(\"id\", UUID.class));\n-                        application.setName(row.get(\"name\", String.class));\n-                        application.setDisplay_name(row.get(\"display_name\", String.class));\n-                        application.setBundleId(bundleId);\n-                        return application;\n-                    }));\n-                })\n-                .withFinalizer(postgresqlConnection -> {\n-                    postgresqlConnection.close().subscribe();\n-                }));\n+        String query = \"FROM ApplicationEntity WHERE bundle.id = :bundleId\";\n+        return session.createQuery(query, ApplicationEntity.class)\n+                .setParameter(\"bundleId\", bundleId)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(applicationMapper::entityToDtoWithoutTimestamps);\n     }\n \n     public Uni<Application> addApplicationToBundle(UUID bundleId, Application app) {\n-        String insertQuery = \"INSERT INTO \" + PUBLIC_APPLICATIONS + \" (name, display_name, bundle_Id) VALUES ($1, $2, $3)\";\n-\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                    c2 ->  c2.createStatement(insertQuery)\n-                            .bind(\"$1\", app.getName())\n-                            .bind(\"$2\", app.getDisplay_name())\n-                            .bind(\"$3\", bundleId)\n-                            .returnGeneratedValues(\"id\")\n-                            .execute()\n-                            .flatMap(res -> res.map((row, rowMetadata) -> {\n-                                app.setId(row.get(\"id\", UUID.class));\n-                                return app;\n-                            }))\n-\n-                )\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        return Uni.createFrom().item(() -> {\n+            app.setBundleId(bundleId);\n+            return applicationMapper.dtoToEntity(app);\n+        })\n+        .flatMap(applicationEntity -> session.persist(applicationEntity)\n+                .replaceWith(applicationEntity))\n+        .call(() -> session.flush())\n+        .onItem().transform(applicationMapper::entityToDto);\n     }\n-\n-\n }"
  },
  {
    "sha": "21868efeb39442d2b3fa776fbfc61ede176dfc50",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/DatasourceProvider.java",
    "status": "removed",
    "additions": 0,
    "deletions": 57,
    "changes": 57,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/4513da97584698a734a26e462b7a52632db1a981/src/main/java/com/redhat/cloud/notifications/db/DatasourceProvider.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/4513da97584698a734a26e462b7a52632db1a981/src/main/java/com/redhat/cloud/notifications/db/DatasourceProvider.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/DatasourceProvider.java?ref=4513da97584698a734a26e462b7a52632db1a981",
    "patch": "@@ -1,57 +0,0 @@\n-package com.redhat.cloud.notifications.db;\n-\n-import io.r2dbc.pool.ConnectionPool;\n-import io.r2dbc.postgresql.PostgresqlConnectionFactory;\n-import io.r2dbc.postgresql.api.PostgresqlConnection;\n-import io.r2dbc.spi.ConnectionFactories;\n-import io.r2dbc.spi.ConnectionFactory;\n-import io.r2dbc.spi.ConnectionFactoryOptions;\n-import io.smallrye.mutiny.Uni;\n-import org.eclipse.microprofile.config.inject.ConfigProperty;\n-import reactor.core.publisher.Mono;\n-\n-import javax.annotation.PostConstruct;\n-import javax.enterprise.context.ApplicationScoped;\n-import javax.enterprise.inject.Produces;\n-\n-@ApplicationScoped\n-public class DatasourceProvider {\n-\n-    @ConfigProperty(name = \"quarkus.datasource.jdbc.url\")\n-    String dataSourceUrl;\n-\n-    @ConfigProperty(name = \"quarkus.datasource.username\")\n-    String username;\n-\n-    @ConfigProperty(name = \"quarkus.datasource.password\")\n-    String password;\n-\n-    private ConnectionFactory pool;\n-\n-    @PostConstruct\n-    void init() {\n-        ConnectionFactoryOptions parse = ConnectionFactoryOptions.parse(dataSourceUrl.replaceFirst(\"jdbc\", \"r2dbc:pool\"));\n-        ConnectionFactoryOptions options = parse.mutate()\n-                .option(ConnectionFactoryOptions.USER, username)\n-                .option(ConnectionFactoryOptions.PASSWORD, password)\n-                .build();\n-\n-        this.pool = ConnectionFactories.get(options);\n-    }\n-\n-    @Produces\n-    Mono<PostgresqlConnection> getPostgresConnection() {\n-        ConnectionPool connectionPool = (ConnectionPool) pool;\n-        PostgresqlConnectionFactory postgresqlConnectionFactory = (PostgresqlConnectionFactory) connectionPool.unwrap();\n-\n-        return postgresqlConnectionFactory.create();\n-    }\n-\n-    @Produces\n-    Uni<PostgresqlConnection> getConnection() {\n-        ConnectionPool connectionPool = (ConnectionPool) pool;\n-        PostgresqlConnectionFactory postgresqlConnectionFactory = (PostgresqlConnectionFactory) connectionPool.unwrap();\n-\n-        return Uni.createFrom().publisher(postgresqlConnectionFactory.create());\n-    }\n-}"
  },
  {
    "sha": "ecbc91b2e2691934b879083b1919cffa109b4a57",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/EmailAggregationResources.java",
    "status": "modified",
    "additions": 36,
    "deletions": 94,
    "changes": 130,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/EmailAggregationResources.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/EmailAggregationResources.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/EmailAggregationResources.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -1,122 +1,64 @@\n package com.redhat.cloud.notifications.db;\n \n+import com.redhat.cloud.notifications.db.entities.EmailAggregationEntity;\n+import com.redhat.cloud.notifications.db.mappers.EmailAggregationMapper;\n import com.redhat.cloud.notifications.models.EmailAggregation;\n import com.redhat.cloud.notifications.models.EmailAggregationKey;\n-import io.r2dbc.postgresql.api.PostgresqlConnection;\n-import io.r2dbc.postgresql.api.PostgresqlResult;\n-import io.r2dbc.postgresql.codec.Json;\n import io.smallrye.mutiny.Multi;\n import io.smallrye.mutiny.Uni;\n-import io.vertx.core.json.JsonObject;\n-import reactor.core.publisher.Flux;\n+import org.hibernate.reactive.mutiny.Mutiny;\n \n import javax.enterprise.context.ApplicationScoped;\n import javax.inject.Inject;\n-import javax.inject.Provider;\n import java.time.LocalDateTime;\n \n @ApplicationScoped\n-public class EmailAggregationResources extends DatasourceProvider {\n+public class EmailAggregationResources {\n \n     @Inject\n-    Provider<Uni<PostgresqlConnection>> connectionPublisherUni;\n+    Mutiny.Session session;\n \n+    @Inject\n+    EmailAggregationMapper emailAggregationMapper;\n \n     public Uni<Boolean> addEmailAggregation(EmailAggregation aggregation) {\n-        String query = \"INSERT INTO public.email_aggregation(account_id, bundle, application, payload) \" +\n-                \"VALUES ($1, $2, $3, $4)\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                .bind(\"$1\", aggregation.getAccountId())\n-                                .bind(\"$2\", aggregation.getBundle())\n-                                .bind(\"$3\", aggregation.getApplication())\n-                                .bind(\"$4\", Json.of(aggregation.getPayload().encode()))\n-                                .execute();\n-                            return execute.flatMap(PostgresqlResult::getRowsUpdated).map(i -> i > 0);\n-                        })\n-                        .withFinalizer(psqlConnection -> {\n-                            psqlConnection.close().subscribe();\n-                        })\n-                ).toUni();\n+        return Uni.createFrom().item(() -> emailAggregationMapper.dtoToEntity(aggregation))\n+                .flatMap(aggregationEntity -> session.persist(aggregationEntity))\n+                .call(() -> session.flush())\n+                .replaceWith(Boolean.TRUE)\n+                .onFailure().recoverWithItem(Boolean.FALSE);\n     }\n \n     public Multi<EmailAggregationKey> getApplicationsWithPendingAggregation(LocalDateTime start, LocalDateTime end) {\n-        String query = \"SELECT DISTINCT account_id, bundle, application FROM public.email_aggregation \" +\n-                \"WHERE created > $1 AND created <= $2 \";\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", start)\n-                                    .bind(\"$2\", end)\n-                                    .execute();\n-                            return execute.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-                                EmailAggregationKey key = new EmailAggregationKey();\n-                                key.setApplication(row.get(\"application\", String.class));\n-                                key.setBundle(row.get(\"bundle\", String.class));\n-                                key.setAccountId(row.get(\"account_id\", String.class));\n-                                return key;\n-                            }));\n-                        })\n-                        .withFinalizer(psqlConnection -> {\n-                            psqlConnection.close().subscribe();\n-                        })\n-                );\n+        String query = \"SELECT DISTINCT NEW com.redhat.cloud.notifications.models.EmailAggregationKey(accountId, bundleName, applicationName) FROM EmailAggregationEntity WHERE created > :start AND created <= :end\";\n+        return session.createQuery(query, EmailAggregationKey.class)\n+                .setParameter(\"start\", start)\n+                .setParameter(\"end\", end)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n \n     public Multi<EmailAggregation> getEmailAggregation(EmailAggregationKey key, LocalDateTime start, LocalDateTime end) {\n-        String query = \"SELECT id, account_id, bundle, application, created, payload FROM public.email_aggregation \" +\n-                \"WHERE account_id = $1 AND bundle = $5 AND application = $2 AND created > $3 AND created <= $4 \" +\n-                \"ORDER BY created\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", key.getAccountId())\n-                                    .bind(\"$2\", key.getApplication())\n-                                    .bind(\"$3\", start)\n-                                    .bind(\"$4\", end)\n-                                    .bind(\"$5\", key.getBundle())\n-                                    .execute();\n-                            return execute.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-                                EmailAggregation emailAggregation = new EmailAggregation();\n-                                emailAggregation.setId(row.get(\"id\", Integer.class));\n-                                emailAggregation.setAccountId(row.get(\"account_id\", String.class));\n-                                emailAggregation.setCreated(row.get(\"created\", LocalDateTime.class));\n-                                emailAggregation.setBundle(row.get(\"bundle\", String.class));\n-                                emailAggregation.setApplication(row.get(\"application\", String.class));\n-                                emailAggregation.setPayload(new JsonObject(row.get(\"payload\", String.class)));\n-\n-                                return emailAggregation;\n-                            }));\n-                        })\n-                        .withFinalizer(psqlConnection -> {\n-                            psqlConnection.close().subscribe();\n-                        })\n-                );\n+        String query = \"FROM EmailAggregationEntity WHERE accountId = :accountId AND bundleName = :bundleName AND applicationName = :applicationName AND created > :start AND created <= :end ORDER BY created\";\n+        return session.createQuery(query, EmailAggregationEntity.class)\n+                .setParameter(\"accountId\", key.getAccountId())\n+                .setParameter(\"bundleName\", key.getBundle())\n+                .setParameter(\"applicationName\", key.getApplication())\n+                .setParameter(\"start\", start)\n+                .setParameter(\"end\", end)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(emailAggregationMapper::entityToDto);\n     }\n \n     public Uni<Integer> purgeOldAggregation(EmailAggregationKey key, LocalDateTime lastUsedTime) {\n-        String query = \"DELETE FROM public.email_aggregation WHERE account_id = $1 AND bundle = $4 AND application = $2 AND created <= $3\";\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", key.getAccountId())\n-                                    .bind(\"$2\", key.getApplication())\n-                                    .bind(\"$3\", lastUsedTime)\n-                                    .bind(\"$4\", key.getBundle())\n-                                    .execute();\n-                            return execute.flatMap(PostgresqlResult::getRowsUpdated);\n-                        })\n-                        .withFinalizer(psqlConnection -> {\n-                            psqlConnection.close().subscribe();\n-                        })\n-                ).toUni();\n+        String query = \"DELETE FROM EmailAggregationEntity WHERE account_id = :accountId AND bundleName = :bundleName AND applicationName = :applicationName AND created <= :created\";\n+        return session.createQuery(query)\n+                .setParameter(\"accountId\", key.getAccountId())\n+                .setParameter(\"bundleName\", key.getBundle())\n+                .setParameter(\"applicationName\", key.getApplication())\n+                .setParameter(\"created\", lastUsedTime)\n+                .executeUpdate()\n+                .call(() -> session.flush());\n     }\n-\n }"
  },
  {
    "sha": "9580c244099040ab54de9862ee5230aa5261947c",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/EndpointEmailSubscriptionResources.java",
    "status": "modified",
    "additions": 72,
    "deletions": 119,
    "changes": 191,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/EndpointEmailSubscriptionResources.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/EndpointEmailSubscriptionResources.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/EndpointEmailSubscriptionResources.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -1,148 +1,101 @@\n package com.redhat.cloud.notifications.db;\n \n+import com.redhat.cloud.notifications.db.entities.EndpointEmailSubscriptionEntity;\n+import com.redhat.cloud.notifications.db.mappers.EmailSubscriptionMapper;\n import com.redhat.cloud.notifications.models.EmailSubscription;\n import com.redhat.cloud.notifications.models.EmailSubscription.EmailSubscriptionType;\n-import io.r2dbc.postgresql.api.PostgresqlConnection;\n-import io.r2dbc.postgresql.api.PostgresqlResult;\n import io.smallrye.mutiny.Multi;\n import io.smallrye.mutiny.Uni;\n-import reactor.core.publisher.Flux;\n+import org.hibernate.reactive.mutiny.Mutiny;\n \n import javax.enterprise.context.ApplicationScoped;\n import javax.inject.Inject;\n-import javax.inject.Provider;\n \n @ApplicationScoped\n-public class EndpointEmailSubscriptionResources extends DatasourceProvider {\n+public class EndpointEmailSubscriptionResources {\n \n-    private final String COMMON_WHERE_FILTER = \" WHERE account_id = $1 AND bundle = $2 AND application = $3 AND subscription_type = $4 \";\n+    @Inject\n+    Mutiny.Session session;\n \n     @Inject\n-    Provider<Uni<PostgresqlConnection>> connectionPublisherUni;\n+    EmailSubscriptionMapper emailSubscriptionMapper;\n \n-    public Uni<Boolean> subscribe(String accountNumber, String username, String bundle, String application, EmailSubscriptionType type) {\n-        String query = \"INSERT INTO public.endpoint_email_subscriptions(account_id, user_id, bundle, application, subscription_type) VALUES($1, $2, $3, $4, $5) \" +\n+    public Uni<Boolean> subscribe(String accountNumber, String username, String bundleName, String applicationName, EmailSubscriptionType subscriptionType) {\n+        String query = \"INSERT INTO public.endpoint_email_subscriptions(account_id, user_id, bundle, application, subscription_type) \" +\n+                \"VALUES(:accountId, :userId, :bundleName, :application, :subscriptionType) \" +\n                 \"ON CONFLICT (account_id, user_id, bundle, application, subscription_type) DO NOTHING\"; // The value is already on the database, this is OK\n-        return this.executeBooleanQuery(query, accountNumber, username, bundle, application, type);\n+        // HQL does not support the ON CONFLICT clause so we need a native query here\n+        return session.createNativeQuery(query)\n+                .setParameter(\"accountId\", accountNumber)\n+                .setParameter(\"userId\", username)\n+                .setParameter(\"bundleName\", bundleName)\n+                .setParameter(\"application\", applicationName)\n+                .setParameter(\"subscriptionType\", subscriptionType.name())\n+                .executeUpdate()\n+                .replaceWith(Boolean.TRUE)\n+                .onFailure().recoverWithItem(Boolean.FALSE);\n     }\n \n-    public Uni<Boolean> unsubscribe(String accountNumber, String username, String bundle, String application, EmailSubscriptionType type) {\n-        String query = \"DELETE FROM public.endpoint_email_subscriptions where account_id = $1 AND user_id = $2 AND bundle = $3 AND application = $4 AND subscription_type = $5\";\n-\n-        return this.executeBooleanQuery(query, accountNumber, username, bundle, application, type);\n+    public Uni<Boolean> unsubscribe(String accountNumber, String username, String bundleName, String applicationName, EmailSubscriptionType subscriptionType) {\n+        String query = \"DELETE FROM EndpointEmailSubscriptionEntity WHERE id.accountId = :accountId AND id.userId = :userId \" +\n+                \"AND id.bundleName = :bundleName AND id.applicationName = :applicationName AND id.subscriptionType = :subscriptionType\";\n+        return session.createQuery(query)\n+                .setParameter(\"accountId\", accountNumber)\n+                .setParameter(\"userId\", username)\n+                .setParameter(\"bundleName\", bundleName)\n+                .setParameter(\"applicationName\", applicationName)\n+                .setParameter(\"subscriptionType\", subscriptionType.name())\n+                .executeUpdate()\n+                .call(() -> session.flush())\n+                .replaceWith(Boolean.TRUE)\n+                .onFailure().recoverWithItem(Boolean.FALSE);\n     }\n \n-    public Uni<EmailSubscription> getEmailSubscription(String accountNumber, String username, String bundle, String application, EmailSubscriptionType type) {\n-        String query = \"SELECT account_id, bundle, application, user_id, subscription_type FROM public.endpoint_email_subscriptions \" + COMMON_WHERE_FILTER + \" AND user_id = $5 LIMIT 1\";\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute =  c2.createStatement(query)\n-                                    .bind(\"$1\", accountNumber)\n-                                    .bind(\"$2\", bundle)\n-                                    .bind(\"$3\", application)\n-                                    .bind(\"$4\", type.toString())\n-                                    .bind(\"$5\", username)\n-                                    .execute();\n-                            return this.mapResultSetToEmailSubscription(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        })\n-                ).toUni();\n+    public Uni<EmailSubscription> getEmailSubscription(String accountNumber, String username, String bundleName, String applicationName, EmailSubscriptionType subscriptionType) {\n+        String query = \"FROM EndpointEmailSubscriptionEntity WHERE id.accountId = :accountId AND id.userId = :userId \" +\n+                \"AND id.bundleName = :bundleName AND id.applicationName = :applicationName AND id.subscriptionType = :subscriptionType\";\n+        return session.createQuery(query, EndpointEmailSubscriptionEntity.class)\n+                .setParameter(\"accountId\", accountNumber)\n+                .setParameter(\"userId\", username)\n+                .setParameter(\"bundleName\", bundleName)\n+                .setParameter(\"applicationName\", applicationName)\n+                .setParameter(\"subscriptionType\", subscriptionType.name())\n+                .setMaxResults(1)\n+                .getSingleResultOrNull()\n+                .onItem().ifNotNull().transform(emailSubscriptionMapper::entityToDto);\n     }\n \n     public Multi<EmailSubscription> getEmailSubscriptionsForUser(String accountNumber, String username) {\n-        String query = \"SELECT account_id, bundle, application, user_id, subscription_type FROM public.endpoint_email_subscriptions WHERE account_id = $1 AND user_id = $2\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute =  c2.createStatement(query)\n-                                    .bind(\"$1\", accountNumber)\n-                                    .bind(\"$2\", username)\n-                                    .execute();\n-                            return this.mapResultSetToEmailSubscription(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        })\n-                );\n-    }\n-\n-    public Uni<Integer> getEmailSubscribersCount(String accountNumber, String bundle, String application, EmailSubscriptionType type) {\n-        String query = \"SELECT count(user_id) FROM public.endpoint_email_subscriptions \" + COMMON_WHERE_FILTER;\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                    c2 -> {\n-                        Flux<PostgresqlResult> execute =  c2.createStatement(query)\n-                                .bind(\"$1\", accountNumber)\n-                                .bind(\"$2\", bundle)\n-                                .bind(\"$3\", application)\n-                                .bind(\"$4\", type.toString())\n-                                .execute();\n-                        return execute.flatMap(r -> r.map((row, rowMetadata) -> row.get(0, Integer.class)));\n-                    })\n-                    .withFinalizer(postgresqlConnection -> {\n-                        postgresqlConnection.close().subscribe();\n-                    })\n-        ).toUni();\n+        String query = \"FROM EndpointEmailSubscriptionEntity WHERE id.accountId = :accountId AND id.userId = :userId\";\n+        return session.createQuery(query, EndpointEmailSubscriptionEntity.class)\n+                .setParameter(\"accountId\", accountNumber)\n+                .setParameter(\"userId\", username)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(emailSubscriptionMapper::entityToDto);\n     }\n \n-    public Multi<EmailSubscription> getEmailSubscribers(String accountNumber, String bundle, String application, EmailSubscriptionType type) {\n-        String query = \"SELECT account_id, bundle, application, user_id, subscription_type FROM public.endpoint_email_subscriptions \" + COMMON_WHERE_FILTER;\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute =  c2.createStatement(query)\n-                                    .bind(\"$1\", accountNumber)\n-                                    .bind(\"$2\", bundle)\n-                                    .bind(\"$3\", application)\n-                                    .bind(\"$4\", type.toString())\n-                                    .execute();\n-                            return this.mapResultSetToEmailSubscription(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        })\n-                );\n-    }\n-\n-    private Flux<EmailSubscription> mapResultSetToEmailSubscription(Flux<PostgresqlResult> resultFlux) {\n-        return resultFlux.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-            EmailSubscriptionType subscriptionType = EmailSubscriptionType.valueOf(row.get(\"subscription_type\", String.class));\n-            EmailSubscription emailSubscription = new EmailSubscription();\n-\n-            emailSubscription.setAccountId(row.get(\"account_id\", String.class));\n-            emailSubscription.setUsername(row.get(\"user_id\", String.class));\n-            emailSubscription.setBundle(row.get(\"bundle\", String.class));\n-            emailSubscription.setApplication(row.get(\"application\", String.class));\n-            emailSubscription.setType(subscriptionType);\n-\n-            return emailSubscription;\n-        }));\n+    public Uni<Long> getEmailSubscribersCount(String accountNumber, String bundleName, String applicationName, EmailSubscriptionType subscriptionType) {\n+        String query = \"SELECT COUNT(id.userId) FROM EndpointEmailSubscriptionEntity WHERE id.accountId = :accountId \" +\n+                \"AND id.bundleName = :bundleName AND id.applicationName = :applicationName AND id.subscriptionType = :subscriptionType\";\n+        return session.createQuery(query, Long.class)\n+                .setParameter(\"accountId\", accountNumber)\n+                .setParameter(\"bundleName\", bundleName)\n+                .setParameter(\"applicationName\", applicationName)\n+                .setParameter(\"subscriptionType\", subscriptionType.name())\n+                .getSingleResult();\n     }\n \n-    private Uni<Boolean> executeBooleanQuery(String query, String accountNumber, String username, String bundle, String application, EmailSubscriptionType type) {\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", accountNumber)\n-                                    .bind(\"$2\", username)\n-                                    .bind(\"$3\", bundle)\n-                                    .bind(\"$4\", application)\n-                                    .bind(\"$5\", type.toString())\n-                                    .execute();\n-                            return execute.flatMap(PostgresqlResult::getRowsUpdated)\n-                                    .map(i -> true).next();\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        })\n-                ).toUni();\n+    public Multi<EmailSubscription> getEmailSubscribers(String accountNumber, String bundleName, String applicationName, EmailSubscriptionType subscriptionType) {\n+        String query = \"FROM EndpointEmailSubscriptionEntity WHERE id.accountId = :accountId AND id.bundleName = :bundleName \" +\n+                \"AND id.applicationName = :applicationName AND id.subscriptionType = :subscriptionType\";\n+        return session.createQuery(query, EndpointEmailSubscriptionEntity.class)\n+                .setParameter(\"accountId\", accountNumber)\n+                .setParameter(\"bundleName\", bundleName)\n+                .setParameter(\"applicationName\", applicationName)\n+                .setParameter(\"subscriptionType\", subscriptionType.name())\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(emailSubscriptionMapper::entityToDto);\n     }\n-\n }"
  },
  {
    "sha": "f8eaeb841afd4ca33791a173c480343c6412e04f",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/EndpointResources.java",
    "status": "modified",
    "additions": 197,
    "deletions": 455,
    "changes": 652,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/EndpointResources.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/EndpointResources.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/EndpointResources.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -1,321 +1,153 @@\n package com.redhat.cloud.notifications.db;\n \n+import com.redhat.cloud.notifications.db.entities.EndpointDefaultEntity;\n+import com.redhat.cloud.notifications.db.entities.EndpointEntity;\n+import com.redhat.cloud.notifications.db.entities.EndpointTargetEntity;\n+import com.redhat.cloud.notifications.db.entities.EventTypeEntity;\n+import com.redhat.cloud.notifications.db.mappers.EndpointMapper;\n import com.redhat.cloud.notifications.models.Endpoint;\n import com.redhat.cloud.notifications.models.WebhookAttributes;\n-import io.r2dbc.postgresql.api.PostgresqlConnection;\n-import io.r2dbc.postgresql.api.PostgresqlResult;\n-import io.r2dbc.postgresql.api.PostgresqlStatement;\n-import io.r2dbc.spi.R2dbcDataIntegrityViolationException;\n import io.smallrye.mutiny.Multi;\n import io.smallrye.mutiny.Uni;\n-import io.smallrye.mutiny.converters.uni.UniReactorConverters;\n-import io.vertx.core.json.Json;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n+import org.hibernate.reactive.mutiny.Mutiny;\n \n import javax.enterprise.context.ApplicationScoped;\n import javax.inject.Inject;\n-import javax.inject.Provider;\n+import javax.persistence.PersistenceException;\n import javax.ws.rs.BadRequestException;\n-import java.time.LocalDateTime;\n-import java.util.Date;\n import java.util.UUID;\n \n+import static com.redhat.cloud.notifications.models.Endpoint.EndpointType;\n+\n @ApplicationScoped\n-public class EndpointResources extends DatasourceProvider {\n+public class EndpointResources {\n \n     @Inject\n-    Provider<Mono<PostgresqlConnection>> connectionPublisher;\n+    Mutiny.Session session;\n \n     @Inject\n-    Provider<Uni<PostgresqlConnection>> connectionPublisherUni;\n-\n-    // TODO Modify to use PreparedStatements\n+    EndpointMapper endpointMapper;\n \n     public Uni<Endpoint> createEndpoint(Endpoint endpoint) {\n-        Mono<Endpoint> endpointMono =\n-                Mono.usingWhen(\n-                        connectionPublisher.get(),\n-                        conn -> {\n-                            Flux<Endpoint> endpointFlux = insertEndpointStatement(endpoint, conn);\n-                            Flux<Endpoint> endpointFlux1 = endpointFlux.flatMap(ep -> {\n-                                if (endpoint.getProperties() != null && ep.getType() == Endpoint.EndpointType.WEBHOOK) {\n-                                    return insertWebhooksStatement(ep, conn);\n-                                } else {\n-                                    // Other types are not supported at this point\n-                                    return Flux.just(ep);\n-                                }\n-                            });\n-                            return endpointFlux1.next();\n-                        },\n-                        PostgresqlConnection::close);\n-\n-        return Uni.createFrom().converter(UniReactorConverters.fromMono(), endpointMono);\n-    }\n-\n-    private Flux<Endpoint> insertEndpointStatement(Endpoint endpoint, PostgresqlConnection conn) {\n-        Flux<PostgresqlResult> execute = conn.createStatement(\"INSERT INTO public.endpoints (account_id, endpoint_type, enabled, name, description, created) VALUES ($1, $2, $3, $4, $5, $6)\")\n-                .bind(\"$1\", endpoint.getTenant())\n-                .bind(\"$2\", endpoint.getType().ordinal())\n-                .bind(\"$3\", endpoint.isEnabled())\n-                .bind(\"$4\", endpoint.getName())\n-                .bind(\"$5\", endpoint.getDescription())\n-                .bind(\"$6\", LocalDateTime.now())\n-                .returnGeneratedValues(\"id\", \"created\")\n-                .execute();\n-\n-        return execute.flatMap(res -> res\n-                .map(((row, rowMetadata) -> {\n-                    endpoint.setId(row.get(\"id\", UUID.class));\n-                    endpoint.setCreated(row.get(\"created\", Date.class));\n-                    return endpoint;\n-                })));\n+        return Uni.createFrom().item(() -> endpointMapper.dtoToEntity(endpoint))\n+                .flatMap(endpointEntity -> session.persist(endpointEntity)\n+                        .call(() -> session.flush())\n+                        .replaceWith(endpointEntity)\n+                )\n+                .onItem().transform(endpointMapper::entityToDto);\n     }\n \n-    private Flux<Endpoint> insertWebhooksStatement(Endpoint endpoint, PostgresqlConnection conn) {\n-        WebhookAttributes attr = (WebhookAttributes) endpoint.getProperties();\n-        PostgresqlStatement bind = conn.createStatement(\"INSERT INTO public.endpoint_webhooks (endpoint_id, url, method, disable_ssl_verification, secret_token, basic_authentication) VALUES ($1, $2, $3, $4, $5, $6)\")\n-                .bind(\"$1\", endpoint.getId())\n-                .bind(\"$2\", attr.getUrl())\n-                .bind(\"$3\", attr.getMethod().toString())\n-                .bind(\"$4\", attr.isDisableSSLVerification());\n-\n-        if (attr.getSecretToken() != null) {\n-            bind.bind(\"$5\", attr.getSecretToken());\n-        } else {\n-            bind.bindNull(\"$5\", String.class);\n+    public Multi<Endpoint> getEndpointsPerType(String tenant, Endpoint.EndpointType type, Boolean activeOnly, Query limiter) {\n+        // TODO Modify the parameter to take a vararg of Functions that modify the query\n+        // TODO Modify to take account selective joins (JOIN (..) UNION (..)) based on the type, same for getEndpoints\n+        String query = \"SELECT e FROM EndpointEntity e LEFT JOIN FETCH e.webhook WHERE e.accountId = :accountId AND e.endpointType = :endpointType\";\n+        if (activeOnly != null) {\n+            query += \" AND enabled = :enabled\";\n         }\n \n-        if (attr.getBasicAuthentication() != null) {\n-            String encodedJson = Json.encode(attr.getBasicAuthentication());\n-            bind.bind(\"$6\", io.r2dbc.postgresql.codec.Json.of(encodedJson));\n-        } else {\n-            bind.bindNull(\"$6\", io.r2dbc.postgresql.codec.Json.class);\n+        if (limiter != null) {\n+            query = limiter.getModifiedQuery(query);\n         }\n \n-        Flux<PostgresqlResult> execute = bind\n-                .returnGeneratedValues(\"id\")\n-                .execute();\n+        Mutiny.Query<EndpointEntity> mutinyQuery = session.createQuery(query, EndpointEntity.class)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"endpointType\", type.ordinal());\n \n-        return execute.flatMap(res -> res\n-                .map(((row, rowMetadata) -> {\n-                    // Should we update the id here? row.get(\"id\", Integer.class); since it's the generated value\n-                    endpoint.setProperties(attr);\n-                    return endpoint;\n-                })));\n-    }\n+        if (activeOnly != null) {\n+            mutinyQuery = mutinyQuery.setParameter(\"enabled\", activeOnly);\n+        }\n \n-    private static final String basicEndpointSelectQuery = \"SELECT e.account_id, e.id AS endpoint_id, e.endpoint_type, e.enabled, e.name, e.description, e.created, e.updated\";\n-    private static final String webhookEndpointSelectQuery = \", ew.id AS webhook_id, ew.url, ew.method, ew.disable_ssl_verification, ew.secret_token, ew.basic_authentication\";\n-    private static final String basicEndpointGetQuery = basicEndpointSelectQuery + webhookEndpointSelectQuery + \" FROM public.endpoints AS e LEFT JOIN public.endpoint_webhooks AS ew ON ew.endpoint_id = e.id \";\n-    private static final String basicEndpointCountQuery = \"SELECT count(e.id) as count FROM public.endpoints AS e \";\n+        if (limiter != null && limiter.getLimit() != null && limiter.getLimit().getLimit() > 0) {\n+            mutinyQuery = mutinyQuery.setMaxResults(limiter.getLimit().getLimit())\n+                    .setFirstResult(limiter.getLimit().getOffset());\n+        }\n \n-    public Multi<Endpoint> getEndpointsPerType(String tenant, Endpoint.EndpointType type, Boolean activeOnly, Query limiter) {\n-        // TODO Modify the parameter to take a vararg of Functions that modify the query\n-        // TODO Modify to take account selective joins (JOIN (..) UNION (..)) based on the type, same for getEndpoints\n-        StringBuilder queryBuilder = new StringBuilder();\n-        queryBuilder\n-                .append(basicEndpointGetQuery)\n-                .append(\"WHERE e.account_id = $1 AND e.endpoint_type = $2\");\n+        return mutinyQuery.getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(endpointMapper::entityToDto);\n+    }\n \n+    public Uni<Long> getEndpointsCountPerType(String tenant, Endpoint.EndpointType type, Boolean activeOnly) {\n+        String query = \"SELECT COUNT(*) FROM EndpointEntity WHERE accountId = :accountId AND endpointType = :endpointType\";\n         if (activeOnly != null) {\n-            queryBuilder.append(\" AND e.enabled = $3\");\n+            query += \" AND enabled = :enabled\";\n         }\n \n-        final String query = limiter == null ? queryBuilder.toString() : limiter.getModifiedQuery(queryBuilder.toString());\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            PostgresqlStatement statement = c.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", type.ordinal());\n-\n-                            if (activeOnly != null) {\n-                                statement = statement.bind(\"$3\", activeOnly);\n-                            }\n-\n-                            Flux<PostgresqlResult> execute = statement.execute();\n-                            return this.mapResultSetToEndpoint(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n-    }\n-\n-    public Uni<Integer> getEndpointsCountPerType(String tenant, Endpoint.EndpointType type, Boolean activeOnly) {\n-        StringBuilder queryBuilder = new StringBuilder();\n-        queryBuilder\n-                .append(basicEndpointCountQuery)\n-                .append(\"WHERE e.account_id = $1 AND e.endpoint_type = $2\");\n+        Mutiny.Query<Long> mutinyQuery = session.createQuery(query, Long.class)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"endpointType\", type.ordinal());\n \n         if (activeOnly != null) {\n-            queryBuilder.append(\" AND e.enabled = $3\");\n+            mutinyQuery = mutinyQuery.setParameter(\"enabled\", activeOnly);\n         }\n \n-        final String query = queryBuilder.toString();\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            PostgresqlStatement statement = c.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", type.ordinal());\n-\n-                            if (activeOnly != null) {\n-                                statement = statement.bind(\"$3\", activeOnly);\n-                            }\n-\n-                            Flux<PostgresqlResult> execute = statement.execute();\n-                            return execute.flatMap(r -> r.map((row, rowMetadata) -> row.get(0, Integer.class)));\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        return mutinyQuery.getSingleResult();\n     }\n \n     public Multi<Endpoint> getTargetEndpoints(String tenant, String bundleName, String applicationName, String eventTypeName) {\n         // TODO Add UNION JOIN for different endpoint types here\n-        String query = \"WITH accepted_event_types AS ( \" +\n-                \"SELECT et.id FROM public.event_type et \" +\n-                \"JOIN public.applications a ON a.id = et.application_id \" +\n-                \"JOIN public.bundles b ON b.id = a.bundle_id \" +\n-                \"WHERE a.name = $1 AND et.name = $2 AND b.name = $4) \" +\n-                basicEndpointGetQuery +\n-                \"JOIN public.endpoint_targets et ON et.endpoint_id = e.id \" +\n-                \"JOIN accepted_event_types aet ON aet.id = et.event_type_id \" +\n-                \"WHERE et.account_id = $3 AND e.enabled = true\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", applicationName)\n-                                    .bind(\"$2\", eventTypeName)\n-                                    .bind(\"$3\", tenant)\n-                                    .bind(\"$4\", bundleName)\n-                                    .execute();\n-\n-                            return this.mapResultSetToEndpoint(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n+        String query = \"SELECT e FROM EndpointEntity e LEFT JOIN FETCH e.webhook JOIN e.targets t \" +\n+                \"WHERE e.enabled = TRUE AND t.eventType.name = :eventTypeName AND t.id.accountId = :accountId \" +\n+                \"AND t.eventType.application.name = :applicationName AND t.eventType.application.bundle.name = :bundleName\";\n+\n+        return session.createQuery(query, EndpointEntity.class)\n+                .setParameter(\"applicationName\", applicationName)\n+                .setParameter(\"eventTypeName\", eventTypeName)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"bundleName\", bundleName)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(endpointMapper::entityToDto);\n     }\n \n     public Multi<Endpoint> getEndpoints(String tenant, Query limiter) {\n         // TODO Add the ability to modify the getEndpoints to return also with JOIN to application_eventtypes_endpoints link table\n         //      or should I just create a new method for it?\n-        String allAccountEndpointsQuery = basicEndpointGetQuery + \" WHERE e.account_id = $1\";\n+        String query = \"SELECT e FROM EndpointEntity e LEFT JOIN FETCH e.webhook WHERE e.accountId = :accountId\";\n \n-        String query = limiter.getModifiedQuery(allAccountEndpointsQuery);\n+        if (limiter != null) {\n+            query = limiter.getModifiedQuery(query);\n+        }\n         // TODO Add JOIN ON clause to proper table, such as webhooks and then read the results\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .execute();\n-\n-                            return this.mapResultSetToEndpoint(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n-    }\n \n-    public Uni<Integer> getEndpointsCount(String tenant) {\n-        String query = basicEndpointCountQuery + \" WHERE e.account_id = $1\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .execute();\n-                            return execute.flatMap(r -> r.map((row, rowMetadata) -> row.get(0, Integer.class)));\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n-    }\n+        Mutiny.Query<EndpointEntity> mutinyQuery = session.createQuery(query, EndpointEntity.class)\n+                .setParameter(\"accountId\", tenant);\n \n-    private Flux<Endpoint> mapResultSetToEndpoint(Flux<PostgresqlResult> resultFlux) {\n-        return resultFlux.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-            Endpoint.EndpointType endpointType = Endpoint.EndpointType.values()[row.get(\"endpoint_type\", Integer.class)];\n-\n-            Endpoint endpoint = new Endpoint();\n-            endpoint.setTenant(row.get(\"account_id\", String.class));\n-            endpoint.setId(row.get(\"endpoint_id\", UUID.class));\n-            endpoint.setEnabled(row.get(\"enabled\", Boolean.class));\n-            endpoint.setType(endpointType);\n-            endpoint.setName(row.get(\"name\", String.class));\n-            endpoint.setDescription(row.get(\"description\", String.class));\n-            endpoint.setCreated(row.get(\"created\", Date.class));\n-            endpoint.setUpdated(row.get(\"updated\", Date.class));\n-\n-            switch (endpointType) {\n-                case WEBHOOK:\n-                    WebhookAttributes attr = new WebhookAttributes();\n-                    attr.setId(row.get(\"webhook_id\", Integer.class));\n-                    attr.setDisableSSLVerification(row.get(\"disable_ssl_verification\", Boolean.class));\n-                    attr.setSecretToken(row.get(\"secret_token\", String.class));\n-                    String method = row.get(\"method\", String.class);\n-                    attr.setMethod(WebhookAttributes.HttpType.valueOf(method));\n-                    attr.setUrl(row.get(\"url\", String.class));\n-\n-                    String basicAuthentication = row.get(\"basic_authentication\", String.class);\n-                    if (basicAuthentication != null) {\n-                        attr.setBasicAuthentication(Json.decodeValue(basicAuthentication, WebhookAttributes.BasicAuthentication.class));\n-                    }\n+        if (limiter != null && limiter.getLimit() != null && limiter.getLimit().getLimit() > 0) {\n+            mutinyQuery = mutinyQuery.setMaxResults(limiter.getLimit().getLimit())\n+                    .setFirstResult(limiter.getLimit().getOffset());\n+        }\n \n-                    endpoint.setProperties(attr);\n-                    break;\n-                default:\n-            }\n+        return mutinyQuery.getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(endpointMapper::entityToDto);\n+    }\n \n-            return endpoint;\n-        }));\n+    public Uni<Long> getEndpointsCount(String tenant) {\n+        String query = \"SELECT COUNT(*) FROM EndpointEntity WHERE accountId = :accountId\";\n+        return session.createQuery(query, Long.class)\n+                .setParameter(\"accountId\", tenant)\n+                .getSingleResult();\n     }\n \n     public Uni<Endpoint> getEndpoint(String tenant, UUID id) {\n-        String allAccountEndpointsQuery = basicEndpointGetQuery + \" WHERE e.account_id = $1\";\n-        String query = allAccountEndpointsQuery + \" AND e.id = $2\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", id)\n-                                    .execute();\n-                            return this.mapResultSetToEndpoint(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        String query = \"SELECT e FROM EndpointEntity e LEFT JOIN FETCH e.webhook WHERE e.accountId = :accountId AND e.id = :id\";\n+        return session.createQuery(query, EndpointEntity.class)\n+                .setParameter(\"id\", id)\n+                .setParameter(\"accountId\", tenant)\n+                .getSingleResultOrNull()\n+                .onItem().ifNotNull().transform(endpointMapper::entityToDto);\n     }\n \n     public Uni<Boolean> deleteEndpoint(String tenant, UUID id) {\n-        String query = \"DELETE FROM public.endpoints WHERE account_id = $1 AND id = $2\";\n-        Mono<Boolean> monoResult =\n-                Mono.usingWhen(connectionPublisher.get(),\n-                        conn -> {\n-                            Flux<PostgresqlResult> resultFlux = conn.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", id)\n-                                    .execute();\n-\n-                            // Actually, the endpoint targeting this should be repeatable\n-                            return resultFlux.flatMap(PostgresqlResult::getRowsUpdated)\n-                                    .map(i -> i > 0).next();\n-                        },\n-                        PostgresqlConnection::close);\n-\n-        return Uni.createFrom().converter(UniReactorConverters.fromMono(), monoResult);\n+        String query = \"DELETE FROM EndpointEntity WHERE accountId = :accountId AND id = :id\";\n+        return session.createQuery(query)\n+                .setParameter(\"id\", id)\n+                .setParameter(\"accountId\", tenant)\n+                .executeUpdate()\n+                .call(() -> session.flush())\n+                .onItem().transform(rowCount -> rowCount > 0);\n+        // Actually, the endpoint targeting this should be repeatable\n     }\n \n     public Uni<Boolean> disableEndpoint(String tenant, UUID id) {\n@@ -326,226 +158,136 @@\n         return modifyEndpointStatus(tenant, id, true);\n     }\n \n-    public Uni<Boolean> modifyEndpointStatus(String tenant, UUID id, boolean enabled) {\n-        String query = \"UPDATE public.endpoints SET enabled = $1 WHERE account_id = $2 AND id = $3\";\n-\n-        Mono<Boolean> monoResult =\n-                Mono.usingWhen(connectionPublisher.get(),\n-                        conn -> {\n-                            Flux<PostgresqlResult> resultFlux = conn.createStatement(query)\n-                                    .bind(\"$1\", enabled)\n-                                    .bind(\"$2\", tenant)\n-                                    .bind(\"$3\", id)\n-                                    .execute();\n-\n-                            return resultFlux.flatMap(PostgresqlResult::getRowsUpdated)\n-                                    .map(i -> i > 0).next();\n-                        },\n-                        PostgresqlConnection::close);\n+    private Uni<Boolean> modifyEndpointStatus(String tenant, UUID id, boolean enabled) {\n+        String query = \"UPDATE EndpointEntity SET enabled = :enabled WHERE accountId = :accountId AND id = :id\";\n \n-        return Uni.createFrom().converter(UniReactorConverters.fromMono(), monoResult);\n+        return session.createQuery(query)\n+                .setParameter(\"id\", id)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"enabled\", enabled)\n+                .executeUpdate()\n+                .call(() -> session.flush())\n+                .onItem().transform(rowCount -> rowCount > 0);\n     }\n \n     public Uni<Boolean> linkEndpoint(String tenant, UUID endpointId, UUID eventTypeId) {\n-        String query = \"INSERT INTO public.endpoint_targets (account_id, event_type_id, endpoint_id) VALUES ($1, $2, $3)\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", eventTypeId)\n-                                    .bind(\"$3\", endpointId)\n-                                    .execute();\n-                            return execute.flatMap(PostgresqlResult::getRowsUpdated)\n-                                    .map(i -> i > 0).next();\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        return Uni.createFrom().item(() -> {\n+            EndpointEntity endpoint = session.getReference(EndpointEntity.class, endpointId);\n+            EventTypeEntity eventType = session.getReference(EventTypeEntity.class, eventTypeId);\n+            return new EndpointTargetEntity(tenant, endpoint, eventType);\n+        }).flatMap(endpointTargetEntity -> session.persist(endpointTargetEntity))\n+                .call(() -> session.flush())\n+                .replaceWith(Boolean.TRUE)\n+                .onFailure().recoverWithItem(Boolean.FALSE);\n     }\n \n     public Uni<Boolean> unlinkEndpoint(String tenant, UUID endpointId, UUID eventTypeId) {\n-        String query = \"DELETE FROM public.endpoint_targets WHERE account_id = $1 AND event_type_id = $2 AND endpoint_id = $3\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", eventTypeId)\n-                                    .bind(\"$3\", endpointId)\n-                                    .execute();\n-                            return execute.flatMap(PostgresqlResult::getRowsUpdated)\n-                                    .map(i -> i > 0).next();\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        String query = \"DELETE FROM EndpointTargetEntity WHERE id.accountId = :accountId AND eventType.id = :eventTypeId AND endpoint.id = :endpointId\";\n+\n+        return session.createQuery(query)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"eventTypeId\", eventTypeId)\n+                .setParameter(\"endpointId\", endpointId)\n+                .executeUpdate()\n+                .call(() -> session.flush())\n+                .onItem().transform(rowCount -> rowCount > 0);\n     }\n \n     public Multi<Endpoint> getLinkedEndpoints(String tenant, UUID eventTypeId, Query limiter) {\n-        String basicQuery = basicEndpointGetQuery +\n-                \"JOIN public.endpoint_targets et ON et.endpoint_id = e.id \" +\n-                \"WHERE et.account_id = $1 AND et.event_type_id = $2\";\n-\n-        String query = limiter.getModifiedQuery(basicQuery);\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", eventTypeId)\n-                                    .execute();\n-\n-                            return this.mapResultSetToEndpoint(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n+        String query = \"SELECT e FROM EndpointEntity e LEFT JOIN FETCH e.webhook JOIN e.targets t WHERE t.id.accountId = :accountId AND t.eventType.id = :eventTypeId\";\n+\n+        if (limiter != null) {\n+            query = limiter.getModifiedQuery(query);\n+        }\n+\n+        Mutiny.Query<EndpointEntity> mutinyQuery = session.createQuery(query, EndpointEntity.class)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"eventTypeId\", eventTypeId);\n+\n+        if (limiter != null && limiter.getLimit() != null && limiter.getLimit().getLimit() > 0) {\n+            mutinyQuery = mutinyQuery.setMaxResults(limiter.getLimit().getLimit())\n+                    .setFirstResult(limiter.getLimit().getOffset());\n+        }\n+\n+        return mutinyQuery.getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(endpointMapper::entityToDto);\n     }\n \n     public Multi<Endpoint> getDefaultEndpoints(String tenant) {\n-        String query = \"WITH default_endpoints AS ( \" +\n-                \"SELECT endpoint_id \" +\n-                \"FROM public.endpoint_defaults \" +\n-                \"WHERE account_id = $1 \" +\n-                \")\" +\n-                basicEndpointGetQuery +\n-                \"JOIN default_endpoints ae ON ae.endpoint_id = e.id\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .execute();\n-\n-                            return this.mapResultSetToEndpoint(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n+        String query = \"SELECT e FROM EndpointEntity e LEFT JOIN FETCH e.webhook JOIN e.defaults d WHERE d.id.accountId = :accountId\";\n+\n+        return session.createQuery(query, EndpointEntity.class)\n+                .setParameter(\"accountId\", tenant)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(endpointMapper::entityToDto);\n     }\n \n     public Uni<Boolean> endpointInDefaults(String tenant, UUID endpointId) {\n-        String query = \"SELECT count(endpoint_id) FROM public.endpoint_defaults WHERE account_id = $1 and endpoint_id = $2\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", endpointId)\n-                                    .execute();\n-\n-                            return execute.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> row.get(0, Integer.class) > 0));\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        })).toUni();\n+        String query = \"SELECT COUNT(*) FROM EndpointDefaultEntity WHERE id.accountId = :accountId AND endpoint.id = :endpointId\";\n+\n+        return session.createQuery(query, Long.class)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"endpointId\", endpointId)\n+                .getSingleResult()\n+                .onItem().transform(count -> count > 0);\n     }\n \n     public Uni<Boolean> addEndpointToDefaults(String tenant, UUID endpointId) {\n-        String query = \"INSERT INTO public.endpoint_defaults (account_id, endpoint_id) VALUES ($1, $2)\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", endpointId)\n-                                    .execute();\n-                            return execute.flatMap(PostgresqlResult::getRowsUpdated)\n-                                    .map(i -> i > 0).next();\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni()\n-                .onFailure()\n-                .transform(t -> {\n-                    if (t instanceof R2dbcDataIntegrityViolationException) {\n-                        return new BadRequestException(\"Given endpoint id can not be linked to default\");\n-                    }\n-                    return t;\n-                });\n+        return Uni.createFrom().item(() -> {\n+            EndpointEntity endpoint = session.getReference(EndpointEntity.class, endpointId);\n+            return new EndpointDefaultEntity(tenant, endpoint);\n+        }).flatMap(endpointDefaultEntity -> session.persist(endpointDefaultEntity))\n+                .call(() -> session.flush())\n+                .onFailure(PersistenceException.class).transform(a -> new BadRequestException(\"Given endpoint id can not be linked to default\"))\n+                .replaceWith(Boolean.TRUE);\n     }\n \n     public Uni<Boolean> deleteEndpointFromDefaults(String tenant, UUID endpointId) {\n-        String query = \"DELETE FROM public.endpoint_defaults WHERE account_id = $1 AND endpoint_id = $2\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", endpointId)\n-                                    .execute();\n-                            return execute.flatMap(PostgresqlResult::getRowsUpdated)\n-                                    .map(i -> i > 0).next();\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        String query = \"DELETE FROM EndpointDefaultEntity WHERE accountId = :accountId AND endpointId = :endpointId\";\n+\n+        return session.createQuery(query)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"endpointId\", endpointId)\n+                .executeUpdate()\n+                .call(() -> session.flush())\n+                .onItem().transform(rowCount -> rowCount > 0);\n     }\n \n     public Uni<Boolean> updateEndpoint(Endpoint endpoint) {\n         // TODO Update could fail because the item did not exist, throw 404 in that case?\n         // TODO Fix transaction so that we don't end up with half the updates applied\n-        Mono<Boolean> endpointMono =\n-                Mono.usingWhen(connectionPublisher.get(),\n-                        conn -> updateEndpointStatement(endpoint, conn)\n-                                .flatMap(ep -> {\n-                                    if (endpoint.getProperties() != null && endpoint.getType() == Endpoint.EndpointType.WEBHOOK) {\n-                                        return updateWebhooksStatement(endpoint, conn);\n-                                    }\n-                                    return Mono.empty();\n-                                }),\n-                        PostgresqlConnection::close);\n-\n-        return Uni.createFrom().converter(UniReactorConverters.fromMono(), endpointMono);\n-    }\n-\n-    private Mono<Boolean> updateEndpointStatement(Endpoint endpoint, PostgresqlConnection conn) {\n-        String endpointQuery = \"UPDATE public.endpoints SET name = $3, description = $4, enabled = $5, updated = $6 WHERE account_id = $1 AND id = $2\";\n-        PostgresqlStatement bindSt = conn.createStatement(endpointQuery)\n-                .bind(\"$1\", endpoint.getTenant())\n-                .bind(\"$2\", endpoint.getId())\n-                .bind(\"$3\", endpoint.getName())\n-                .bind(\"$4\", endpoint.getDescription())\n-                .bind(\"$5\", endpoint.isEnabled())\n-                .bind(\"$6\", LocalDateTime.now());\n-\n-        return bindSt\n-                .execute()\n-                .flatMap(PostgresqlResult::getRowsUpdated)\n-                .map(i -> i > 0).next();\n-    }\n-\n-    private Mono<Boolean> updateWebhooksStatement(Endpoint endpoint, PostgresqlConnection conn) {\n-        WebhookAttributes attr = (WebhookAttributes) endpoint.getProperties();\n-        String webhookQuery = \"UPDATE public.endpoint_webhooks SET url = $2, method = $3, disable_ssl_verification = $4, secret_token = $5 WHERE endpoint_id = $1 \";\n-\n-        PostgresqlStatement bindSt = conn.createStatement(webhookQuery)\n-                .bind(\"$1\", endpoint.getId())\n-                .bind(\"$2\", attr.getUrl())\n-                .bind(\"$3\", attr.getMethod().toString())\n-                .bind(\"$4\", attr.isDisableSSLVerification());\n-\n-        if (attr.getSecretToken() != null) {\n-            bindSt.bind(\"$5\", attr.getSecretToken());\n-        } else {\n-            bindSt.bindNull(\"$5\", String.class);\n-        }\n-\n-        return bindSt\n-                .execute()\n-                .flatMap(PostgresqlResult::getRowsUpdated)\n-                .map(i -> i > 0).next();\n+        String endpointQuery = \"UPDATE EndpointEntity SET name = :name, description = :description, enabled = :enabled \" +\n+                \"WHERE accountId = :accountId AND id = :id\";\n+        String webhookQuery = \"UPDATE EndpointWebhookEntity SET url = :url, method = :method, \" +\n+                \"disableSslVerification = :disableSslVerification, secretToken = :secretToken WHERE endpoint.id = :endpointId\";\n+\n+        return session.createQuery(endpointQuery)\n+                .setParameter(\"name\", endpoint.getName())\n+                .setParameter(\"description\", endpoint.getDescription())\n+                .setParameter(\"enabled\", endpoint.isEnabled())\n+                .setParameter(\"accountId\", endpoint.getTenant())\n+                .setParameter(\"id\", endpoint.getId())\n+                .executeUpdate()\n+                .call(() -> session.flush())\n+                .flatMap(endpointRowCount -> {\n+                    if (endpointRowCount == 0) {\n+                        return Uni.createFrom().item(Boolean.FALSE);\n+                    } else if (endpoint.getProperties() == null || endpoint.getType() != EndpointType.WEBHOOK) {\n+                        return Uni.createFrom().item(Boolean.TRUE);\n+                    } else {\n+                        WebhookAttributes attr = (WebhookAttributes) endpoint.getProperties();\n+                        return session.createQuery(webhookQuery)\n+                                .setParameter(\"url\", attr.getUrl())\n+                                .setParameter(\"method\", attr.getMethod().name())\n+                                .setParameter(\"disableSslVerification\", attr.isDisableSSLVerification())\n+                                .setParameter(\"secretToken\", attr.getSecretToken())\n+                                .setParameter(\"endpointId\", endpoint.getId())\n+                                .executeUpdate()\n+                                .call(() -> session.flush())\n+                                .onItem().transform(rowCount -> rowCount > 0);\n+                    }\n+                });\n     }\n }"
  },
  {
    "sha": "714de7c0026ec2d1f6fb91bb787e9a1b7622cd24",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/FlywayWorkaround.java",
    "status": "added",
    "additions": 34,
    "deletions": 0,
    "changes": 34,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/FlywayWorkaround.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/FlywayWorkaround.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/FlywayWorkaround.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,34 @@\n+package com.redhat.cloud.notifications.db;\n+\n+import io.quarkus.runtime.StartupEvent;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.flywaydb.core.Flyway;\n+import org.jboss.logging.Logger;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+/**\n+ * This is a temporary workaround for a quarkus-flyway / quarkus-hibernate-reactive incompatibility.\n+ * See https://github.com/quarkusio/quarkus/issues/10716 for more details.\n+ */\n+@ApplicationScoped\n+public class FlywayWorkaround {\n+\n+    private static final Logger LOGGER = Logger.getLogger(FlywayWorkaround.class);\n+\n+    @ConfigProperty(name = \"quarkus.datasource.reactive.url\")\n+    String datasourceUrl;\n+\n+    @ConfigProperty(name = \"quarkus.datasource.username\")\n+    String datasourceUsername;\n+\n+    @ConfigProperty(name = \"quarkus.datasource.password\")\n+    String datasourcePassword;\n+\n+    public void runFlywayMigration(@Observes StartupEvent event) {\n+        LOGGER.warn(\"Starting Flyway workaround... remove it ASAP!\");\n+        Flyway flyway = Flyway.configure().dataSource(\"jdbc:\" + datasourceUrl, datasourceUsername, datasourcePassword).load();\n+        flyway.migrate();\n+    }\n+}"
  },
  {
    "sha": "431258a241fe872bd79d54dace5f7876b4e77462",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/NotificationResources.java",
    "status": "modified",
    "additions": 36,
    "deletions": 85,
    "changes": 121,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/NotificationResources.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/NotificationResources.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/NotificationResources.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -1,112 +1,63 @@\n package com.redhat.cloud.notifications.db;\n \n+import com.redhat.cloud.notifications.db.entities.NotificationHistoryEntity;\n+import com.redhat.cloud.notifications.db.mappers.NotificationHistoryMapper;\n import com.redhat.cloud.notifications.models.NotificationHistory;\n-import io.r2dbc.postgresql.api.PostgresqlConnection;\n-import io.r2dbc.postgresql.api.PostgresqlResult;\n-import io.r2dbc.postgresql.api.PostgresqlStatement;\n-import io.r2dbc.postgresql.codec.Json;\n import io.smallrye.mutiny.Multi;\n import io.smallrye.mutiny.Uni;\n-import io.smallrye.mutiny.converters.multi.MultiReactorConverters;\n-import io.smallrye.mutiny.converters.uni.UniReactorConverters;\n import io.vertx.core.json.JsonObject;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n+import org.hibernate.reactive.mutiny.Mutiny;\n \n import javax.enterprise.context.ApplicationScoped;\n import javax.inject.Inject;\n-import javax.inject.Provider;\n-import java.util.Date;\n import java.util.UUID;\n \n @ApplicationScoped\n public class NotificationResources {\n \n     @Inject\n-    Provider<Mono<PostgresqlConnection>> connectionPublisher;\n+    Mutiny.Session session;\n \n     @Inject\n-    Provider<Uni<PostgresqlConnection>> connectionPublisherUni;\n+    NotificationHistoryMapper notificationHistoryMapper;\n \n     public Uni<NotificationHistory> createNotificationHistory(NotificationHistory history) {\n-        Flux<NotificationHistory> notificationHistoryFlux = Flux.usingWhen(connectionPublisher.get(),\n-                conn -> {\n-                    String query = \"INSERT INTO public.notification_history (account_id, endpoint_id, invocation_time, invocation_result, event_id, details) VALUES ($1, $2, $3, $4, $5, $6)\";\n-\n-                    PostgresqlStatement st = conn.createStatement(query)\n-                            .bind(\"$1\", history.getTenant())\n-                            .bind(\"$2\", history.getEndpoint().getId())\n-                            .bind(\"$3\", history.getInvocationTime())\n-                            .bind(\"$4\", history.isInvocationResult())\n-                            .bind(\"$5\", history.getEventId());\n-\n-                    if (history.getDetails() != null) {\n-                        st.bind(\"$6\", Json.of(new JsonObject(history.getDetails()).encode()));\n-                    } else {\n-                        st.bindNull(\"$6\", Json.class);\n-                    }\n-                    Flux<PostgresqlResult> execute = st.returnGeneratedValues(\"id\", \"created\").execute();\n-                    return execute.flatMap(res -> res.map((row, rowMetadata) -> {\n-                        history.setCreated(row.get(\"created\", Date.class));\n-                        history.setId(row.get(\"id\", Integer.class));\n-                        return history;\n-                    }));\n-                },\n-                PostgresqlConnection::close);\n-\n-        return Uni.createFrom().converter(UniReactorConverters.fromMono(), notificationHistoryFlux.next());\n+        return Uni.createFrom().item(() -> notificationHistoryMapper.dtoToEntity(history))\n+                .flatMap(notificationHistoryEntity -> session.persist(notificationHistoryEntity)\n+                        .call(() -> session.flush())\n+                        .replaceWith(notificationHistoryEntity)\n+                )\n+                .onItem().transform(notificationHistoryMapper::entityToDto);\n     }\n \n     public Multi<NotificationHistory> getNotificationHistory(String tenant, UUID endpoint) {\n-        String query = \"SELECT id, endpoint_id, created, invocation_time, invocation_result, event_id FROM public.notification_history WHERE account_id = $1 AND endpoint_id = $2\";\n-        Flux<NotificationHistory> endpointFlux = Flux.usingWhen(connectionPublisher.get(),\n-                conn -> {\n-                    Flux<PostgresqlResult> resultFlux = conn.createStatement(query)\n-                            .bind(\"$1\", tenant)\n-                            .bind(\"$2\", endpoint)\n-                            .execute();\n-                    return mapResultSetToNotificationHistory(resultFlux);\n-                },\n-                PostgresqlConnection::close);\n-\n-        return Multi.createFrom().converter(MultiReactorConverters.fromFlux(), endpointFlux);\n-    }\n-\n-    private Flux<NotificationHistory> mapResultSetToNotificationHistory(Flux<PostgresqlResult> resultFlux) {\n-        return resultFlux.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-            NotificationHistory history = new NotificationHistory();\n-            history.setId(row.get(\"id\", Integer.class));\n-            history.setCreated(row.get(\"created\", Date.class));\n-            history.setEndpointId(row.get(\"endpoint_id\", UUID.class));\n-            history.setInvocationResult(row.get(\"invocation_result\", Boolean.class));\n-            history.setInvocationTime(row.get(\"invocation_time\", Integer.class));\n-            history.setEventId(row.get(\"event_id\", String.class));\n-\n-            return history;\n-        }));\n+        // FIXME This loads more fields than before (accountId and details)\n+        String query = \"FROM NotificationHistoryEntity WHERE accountId = :accountId AND endpoint.id = :endpointId\";\n+        return session.createQuery(query, NotificationHistoryEntity.class)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"endpointId\", endpoint)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable)\n+                .onItem().transform(notificationHistoryMapper::entityToDto);\n     }\n \n     public Uni<JsonObject> getNotificationDetails(String tenant, Query limiter, UUID endpoint, Integer historyId) {\n-        String basicQuery = \"SELECT details FROM public.notification_history WHERE account_id = $1 AND endpoint_id = $2 AND id = $3\";\n-        String query = limiter.getModifiedQuery(basicQuery);\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", endpoint)\n-                                    .bind(\"$3\", historyId)\n-                                    .execute();\n-                            return execute.flatMap(res -> res.map((row, rowMetadata) -> {\n-                                String json = row.get(\"details\", String.class);\n-                                // TODO json field is not necessarily available!\n-                                return new JsonObject(json);\n-                            }));\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        String query = \"SELECT details FROM NotificationHistoryEntity WHERE accountId = :accountId AND endpoint.id = :endpointId AND id = :historyId\";\n+        if (limiter != null) {\n+            query = limiter.getModifiedQuery(query);\n+        }\n+\n+        Mutiny.Query<String> mutinyQuery = session.createQuery(query, String.class)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"endpointId\", endpoint)\n+                .setParameter(\"historyId\", historyId);\n+\n+        if (limiter != null && limiter.getLimit() != null && limiter.getLimit().getLimit() > 0) {\n+            mutinyQuery = mutinyQuery.setMaxResults(limiter.getLimit().getLimit())\n+                    .setFirstResult(limiter.getLimit().getOffset());\n+        }\n+\n+        return mutinyQuery.getSingleResultOrNull()\n+                .onItem().ifNotNull().transform(JsonObject::new);\n     }\n }"
  },
  {
    "sha": "64ed8e2e7182fe9bb26b60904c72fa5cfbe472a8",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/Query.java",
    "status": "modified",
    "additions": 0,
    "deletions": 21,
    "changes": 21,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/Query.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/Query.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/Query.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -104,13 +104,6 @@ public Sort getSort() {\n         return sort;\n     }\n \n-    public static String getLimiterQuery(Limit limiter) {\n-        return \"LIMIT \" +\n-                limiter.getLimit() +\n-                \" OFFSET \" +\n-                limiter.getOffset();\n-    }\n-\n     public String getModifiedQuery(String basicQuery) {\n         // Use the internal Query\n         // What's the proper order? SORT first, then LIMIT? COUNT as last one?\n@@ -119,23 +112,9 @@ public String getModifiedQuery(String basicQuery) {\n         if (sort != null) {\n             query = modifyWithSort(query, sort);\n         }\n-        Limit limiter = getLimit();\n-        if (limiter != null && (limiter.getLimit() > 0)) {\n-            query = modifyQueryWithOffsetLimit(query, limiter);\n-        }\n         return query;\n     }\n \n-    private static String modifyQueryWithOffsetLimit(String basicQuery, Query.Limit limiter) {\n-        if (limiter != null && limiter.getLimit() > 0) {\n-            return basicQuery +\n-                    \" \" +\n-                    Query.getLimiterQuery(limiter);\n-        }\n-\n-        return basicQuery;\n-    }\n-\n     public static Function<String, String> modifyToCountQuery() {\n         return s -> \"SELECT COUNT(*) FROM (\" +\n                 s +"
  },
  {
    "sha": "b4a7afadb6695eab6cf5d1ec0e04f6652cf826e7",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/ApplicationEntity.java",
    "status": "added",
    "additions": 62,
    "deletions": 0,
    "changes": 62,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/ApplicationEntity.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/ApplicationEntity.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/ApplicationEntity.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,62 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Pattern;\n+import javax.validation.constraints.Size;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+@Entity\n+@Table(name = \"applications\")\n+public class ApplicationEntity extends CreationUpdateTimestampedEntity {\n+\n+    @Id\n+    @GeneratedValue\n+    @NotNull\n+    public UUID id;\n+\n+    @NotNull\n+    @Size(max = 255)\n+    @Pattern(regexp = \"[a-z][a-z_0-9-]*\")\n+    public String name;\n+\n+    @Column(name = \"display_name\")\n+    @NotNull\n+    public String displayName;\n+\n+    @ManyToOne(fetch = FetchType.LAZY, optional = false)\n+    @JoinColumn(name = \"bundle_id\")\n+    @NotNull\n+    public BundleEntity bundle;\n+\n+    @OneToMany(mappedBy = \"application\", cascade = CascadeType.REMOVE)\n+    public Set<EventTypeEntity> eventTypes;\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof ApplicationEntity) {\n+            ApplicationEntity other = (ApplicationEntity) o;\n+            return Objects.equals(id, other.id);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n+    }\n+}"
  },
  {
    "sha": "3baa0e1ac933cbee98a88a9a09b103f2e478415f",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/BundleEntity.java",
    "status": "added",
    "additions": 55,
    "deletions": 0,
    "changes": 55,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/BundleEntity.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/BundleEntity.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/BundleEntity.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,55 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+import javax.persistence.OneToMany;\n+import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Pattern;\n+import javax.validation.constraints.Size;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+@Entity\n+@Table(name = \"bundles\")\n+public class BundleEntity extends CreationUpdateTimestampedEntity {\n+\n+    @Id\n+    @GeneratedValue\n+    @NotNull\n+    public UUID id;\n+\n+    @Column(unique = true)\n+    @NotNull\n+    @Size(max = 255)\n+    @Pattern(regexp = \"[a-z][a-z_0-9-]*\")\n+    public String name;\n+\n+    @Column(name = \"display_name\")\n+    @NotNull\n+    public String displayName;\n+\n+    @OneToMany(mappedBy = \"bundle\", cascade = CascadeType.REMOVE)\n+    public Set<ApplicationEntity> applications;\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof BundleEntity) {\n+            BundleEntity other = (BundleEntity) o;\n+            return Objects.equals(id, other.id);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n+    }\n+}"
  },
  {
    "sha": "78bacebe1d653083bcbff1b4baedf2391dee3d17",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/CreationTimestampedEntity.java",
    "status": "added",
    "additions": 21,
    "deletions": 0,
    "changes": 21,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/CreationTimestampedEntity.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/CreationTimestampedEntity.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/CreationTimestampedEntity.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,21 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.MappedSuperclass;\n+import javax.persistence.PrePersist;\n+import javax.validation.constraints.NotNull;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+\n+@MappedSuperclass\n+public abstract class CreationTimestampedEntity {\n+\n+    protected static final ZoneId UTC = ZoneId.of(\"UTC\");\n+\n+    @NotNull\n+    public LocalDateTime created;\n+\n+    @PrePersist\n+    public void prePersist() {\n+        created = LocalDateTime.now(UTC);\n+    }\n+}"
  },
  {
    "sha": "df10e3171b9eff52e6a3c8adcc3bae8dd1d27325",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/CreationUpdateTimestampedEntity.java",
    "status": "added",
    "additions": 16,
    "deletions": 0,
    "changes": 16,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/CreationUpdateTimestampedEntity.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/CreationUpdateTimestampedEntity.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/CreationUpdateTimestampedEntity.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,16 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.MappedSuperclass;\n+import javax.persistence.PreUpdate;\n+import java.time.LocalDateTime;\n+\n+@MappedSuperclass\n+public abstract class CreationUpdateTimestampedEntity extends CreationTimestampedEntity {\n+\n+    public LocalDateTime updated;\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        updated = LocalDateTime.now(UTC);\n+    }\n+}"
  },
  {
    "sha": "a01931c4738f752024cb7480efb3bb99b5277347",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/EmailAggregationEntity.java",
    "status": "added",
    "additions": 56,
    "deletions": 0,
    "changes": 56,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EmailAggregationEntity.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EmailAggregationEntity.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/EmailAggregationEntity.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,56 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+import java.util.Objects;\n+\n+@Entity\n+@Table(name = \"email_aggregation\")\n+public class EmailAggregationEntity extends CreationTimestampedEntity {\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO, generator = \"email_aggregation_id_seq\")\n+    @NotNull\n+    public Integer id;\n+\n+    @Column(name = \"account_id\")\n+    @NotNull\n+    @Size(max = 50)\n+    public String accountId;\n+\n+    @NotNull\n+    public String payload;\n+\n+    @Column(name = \"application\")\n+    @NotNull\n+    @Size(max = 255)\n+    public String applicationName;\n+\n+    @Column(name = \"bundle\")\n+    @NotNull\n+    @Size(max = 255)\n+    public String bundleName;\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof EmailAggregationEntity) {\n+            EmailAggregationEntity other = (EmailAggregationEntity) o;\n+            return Objects.equals(id, other.id);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n+    }\n+}"
  },
  {
    "sha": "fb7207706d8360ad094872bfaee0c847d892439c",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/EndpointDefaultEntity.java",
    "status": "added",
    "additions": 48,
    "deletions": 0,
    "changes": 48,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointDefaultEntity.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointDefaultEntity.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointDefaultEntity.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,48 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.MapsId;\n+import javax.persistence.Table;\n+import java.util.Objects;\n+\n+@Entity\n+@Table(name = \"endpoint_defaults\")\n+public class EndpointDefaultEntity {\n+\n+    @EmbeddedId\n+    public EndpointDefaultEntityId id;\n+\n+    @ManyToOne\n+    @MapsId(\"endpointId\")\n+    @JoinColumn(name = \"endpoint_id\")\n+    public EndpointEntity endpoint;\n+\n+    public EndpointDefaultEntity() {\n+    }\n+\n+    public EndpointDefaultEntity(String accountId, EndpointEntity endpoint) {\n+        id = new EndpointDefaultEntityId();\n+        id.accountId = accountId;\n+        this.endpoint = endpoint;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof EndpointDefaultEntity) {\n+            EndpointDefaultEntity other = (EndpointDefaultEntity) o;\n+            return Objects.equals(id, other.id);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n+    }\n+}"
  },
  {
    "sha": "519bfeb503973f01d9e934db959f8bc76494302d",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/EndpointDefaultEntityId.java",
    "status": "added",
    "additions": 38,
    "deletions": 0,
    "changes": 38,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointDefaultEntityId.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointDefaultEntityId.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointDefaultEntityId.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,38 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Embeddable;\n+import javax.validation.constraints.NotNull;\n+import java.io.Serializable;\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+@Embeddable\n+public class EndpointDefaultEntityId implements Serializable {\n+\n+    @Column(name = \"endpoint_id\")\n+    @NotNull\n+    public UUID endpointId;\n+\n+    @Column(name = \"account_id\")\n+    @NotNull\n+    public String accountId;\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof EndpointDefaultEntityId) {\n+            EndpointDefaultEntityId other = (EndpointDefaultEntityId) o;\n+            return Objects.equals(endpointId, other.endpointId) &&\n+                    Objects.equals(accountId, other.accountId);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(endpointId, accountId);\n+    }\n+}"
  },
  {
    "sha": "c8210ef5d7a8df3e36e5e3a3970eb34dbff9c6c3",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/EndpointEmailSubscriptionEntity.java",
    "status": "added",
    "additions": 31,
    "deletions": 0,
    "changes": 31,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointEmailSubscriptionEntity.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointEmailSubscriptionEntity.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointEmailSubscriptionEntity.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,31 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import javax.persistence.Table;\n+import java.util.Objects;\n+\n+@Entity\n+@Table(name = \"endpoint_email_subscriptions\")\n+public class EndpointEmailSubscriptionEntity {\n+\n+    @EmbeddedId\n+    public EndpointEmailSubscriptionEntityId id;\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof EndpointEmailSubscriptionEntity) {\n+            EndpointEmailSubscriptionEntity other = (EndpointEmailSubscriptionEntity) o;\n+            return Objects.equals(id, other.id);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n+    }\n+}"
  },
  {
    "sha": "08a3fbb68f4a65e28a2dc91afa0e4f5b878a7415",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/EndpointEmailSubscriptionEntityId.java",
    "status": "added",
    "additions": 58,
    "deletions": 0,
    "changes": 58,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointEmailSubscriptionEntityId.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointEmailSubscriptionEntityId.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointEmailSubscriptionEntityId.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,58 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Embeddable;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+import java.io.Serializable;\n+import java.util.Objects;\n+\n+@Embeddable\n+public class EndpointEmailSubscriptionEntityId implements Serializable {\n+\n+    @Column(name = \"account_id\")\n+    @NotNull\n+    @Size(max = 50)\n+    public String accountId;\n+\n+    @Column(name = \"user_id\")\n+    @NotNull\n+    @Size(max = 50)\n+    public String userId;\n+\n+    @Column(name = \"subscription_type\")\n+    @NotNull\n+    @Size(max = 50)\n+    public String subscriptionType;\n+\n+    @Column(name = \"bundle\")\n+    @NotNull\n+    @Size(max = 255)\n+    public String bundleName;\n+\n+    @Column(name = \"application\")\n+    @NotNull\n+    @Size(max = 255)\n+    public String applicationName;\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof EndpointEmailSubscriptionEntityId) {\n+            EndpointEmailSubscriptionEntityId other = (EndpointEmailSubscriptionEntityId) o;\n+            return Objects.equals(accountId, other.accountId) &&\n+                    Objects.equals(userId, other.userId) &&\n+                    Objects.equals(subscriptionType, other.subscriptionType) &&\n+                    Objects.equals(bundleName, other.bundleName) &&\n+                    Objects.equals(applicationName, other.applicationName);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(accountId, userId, subscriptionType, applicationName, bundleName);\n+    }\n+}"
  },
  {
    "sha": "5f09d002a247095fee3eeea96e18e7c3209cb4ce",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/EndpointEntity.java",
    "status": "added",
    "additions": 73,
    "deletions": 0,
    "changes": 73,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointEntity.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointEntity.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointEntity.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,73 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+import javax.persistence.OneToMany;\n+import javax.persistence.OneToOne;\n+import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+@Entity\n+@Table(name = \"endpoints\")\n+public class EndpointEntity extends CreationUpdateTimestampedEntity {\n+\n+    @Id\n+    @GeneratedValue\n+    @NotNull\n+    public UUID id;\n+\n+    @Column(name = \"account_id\")\n+    @NotNull\n+    @Size(max = 50)\n+    public String accountId;\n+\n+    @Column(name = \"endpoint_type\")\n+    @NotNull\n+    public Integer endpointType;\n+\n+    @NotNull\n+    public Boolean enabled;\n+\n+    @NotNull\n+    @Size(max = 255)\n+    public String name;\n+\n+    public String description;\n+\n+    @OneToOne(mappedBy = \"endpoint\", fetch = FetchType.LAZY, cascade = CascadeType.ALL)\n+    public EndpointWebhookEntity webhook;\n+\n+    @OneToMany(mappedBy = \"endpoint\", cascade = CascadeType.ALL)\n+    public Set<EndpointTargetEntity> targets;\n+\n+    @OneToMany(mappedBy = \"endpoint\", cascade = CascadeType.ALL)\n+    public Set<EndpointDefaultEntity> defaults;\n+\n+    @OneToMany(mappedBy = \"endpoint\", cascade = CascadeType.ALL)\n+    public Set<NotificationHistoryEntity> notificationHistories;\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof EndpointEntity) {\n+            EndpointEntity other = (EndpointEntity) o;\n+            return Objects.equals(id, other.id);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n+    }\n+}"
  },
  {
    "sha": "3347bdc774b1f5cb1077b44bdfe406a0972f5c2e",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/EndpointTargetEntity.java",
    "status": "added",
    "additions": 54,
    "deletions": 0,
    "changes": 54,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointTargetEntity.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointTargetEntity.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointTargetEntity.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,54 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.MapsId;\n+import javax.persistence.Table;\n+import java.util.Objects;\n+\n+@Entity\n+@Table(name = \"endpoint_targets\")\n+public class EndpointTargetEntity {\n+\n+    @EmbeddedId\n+    public EndpointTargetEntityId id;\n+\n+    @ManyToOne\n+    @MapsId(\"endpointId\")\n+    @JoinColumn(name = \"endpoint_id\")\n+    public EndpointEntity endpoint;\n+\n+    @ManyToOne\n+    @MapsId(\"eventTypeId\")\n+    @JoinColumn(name = \"event_type_id\")\n+    public EventTypeEntity eventType;\n+\n+    public EndpointTargetEntity() {\n+    }\n+\n+    public EndpointTargetEntity(String accountId, EndpointEntity endpoint, EventTypeEntity eventType) {\n+        id = new EndpointTargetEntityId();\n+        id.accountId = accountId;\n+        this.endpoint = endpoint;\n+        this.eventType = eventType;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof EndpointTargetEntity) {\n+            EndpointTargetEntity other = (EndpointTargetEntity) o;\n+            return Objects.equals(id, other.id);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n+    }\n+}"
  },
  {
    "sha": "51cdbfde861848afff35b6a7e894643f879fbf24",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/EndpointTargetEntityId.java",
    "status": "added",
    "additions": 44,
    "deletions": 0,
    "changes": 44,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointTargetEntityId.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointTargetEntityId.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointTargetEntityId.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,44 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Embeddable;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+import java.io.Serializable;\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+@Embeddable\n+public class EndpointTargetEntityId implements Serializable {\n+\n+    @Column(name = \"endpoint_id\")\n+    @NotNull\n+    public UUID endpointId;\n+\n+    @Column(name = \"event_type_id\")\n+    public UUID eventTypeId;\n+\n+    @Column(name = \"account_id\")\n+    @NotNull\n+    @Size(max = 50)\n+    public String accountId;\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof EndpointTargetEntityId) {\n+            EndpointTargetEntityId other = (EndpointTargetEntityId) o;\n+            return Objects.equals(endpointId, other.endpointId) &&\n+                    Objects.equals(eventTypeId, other.eventTypeId) &&\n+                    Objects.equals(accountId, other.accountId);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(endpointId, eventTypeId, accountId);\n+    }\n+}"
  },
  {
    "sha": "5821e406c6faa3daf9e9db365589e1116fbc2ced",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/EndpointWebhookEntity.java",
    "status": "added",
    "additions": 63,
    "deletions": 0,
    "changes": 63,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointWebhookEntity.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointWebhookEntity.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/EndpointWebhookEntity.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,63 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.OneToOne;\n+import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+import java.util.Objects;\n+\n+@Entity\n+@Table(name = \"endpoint_webhooks\")\n+public class EndpointWebhookEntity {\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO, generator = \"endpoint_webhooks_id_seq\")\n+    @NotNull\n+    public Integer id;\n+\n+    @OneToOne\n+    @JoinColumn(name = \"endpoint_id\")\n+    @NotNull\n+    public EndpointEntity endpoint;\n+\n+    @NotNull\n+    public String url;\n+\n+    @NotNull\n+    @Size(max = 10)\n+    public String method;\n+\n+    @Column(name = \"disable_ssl_verification\")\n+    @NotNull\n+    public Boolean disableSslVerification;\n+\n+    @Column(name = \"secret_token\")\n+    @Size(max = 255)\n+    public String secretToken;\n+\n+    @Column(name = \"basic_authentication\")\n+    public String basicAuthentication;\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof EndpointWebhookEntity) {\n+            EndpointWebhookEntity other = (EndpointWebhookEntity) o;\n+            return Objects.equals(id, other.id);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n+    }\n+}"
  },
  {
    "sha": "527953aaf808f30cb6a0175da77e6a18cdff274e",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/EventTypeEntity.java",
    "status": "added",
    "additions": 63,
    "deletions": 0,
    "changes": 63,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EventTypeEntity.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/EventTypeEntity.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/EventTypeEntity.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,63 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Pattern;\n+import javax.validation.constraints.Size;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+@Entity\n+@Table(name = \"event_type\")\n+public class EventTypeEntity {\n+\n+    @Id\n+    @GeneratedValue\n+    @NotNull\n+    public UUID id;\n+\n+    @NotNull\n+    @Pattern(regexp = \"[a-z][a-z_0-9-]*\")\n+    @Size(max = 255)\n+    public String name;\n+\n+    @Column(name = \"display_name\")\n+    @NotNull\n+    public String displayName;\n+\n+    public String description;\n+\n+    @ManyToOne(fetch = FetchType.LAZY, optional = false)\n+    @JoinColumn(name = \"application_id\")\n+    public ApplicationEntity application;\n+\n+    @OneToMany(mappedBy = \"eventType\", cascade = CascadeType.ALL)\n+    public Set<EndpointTargetEntity> targets;\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof EventTypeEntity) {\n+            EventTypeEntity other = (EventTypeEntity) o;\n+            return Objects.equals(id, other.id);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n+    }\n+}"
  },
  {
    "sha": "2bdd53916fe076b6addacebbc7b79741fbf9d628",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/entities/NotificationHistoryEntity.java",
    "status": "added",
    "additions": 64,
    "deletions": 0,
    "changes": 64,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/NotificationHistoryEntity.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/entities/NotificationHistoryEntity.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/entities/NotificationHistoryEntity.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,64 @@\n+package com.redhat.cloud.notifications.db.entities;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+import java.util.Objects;\n+\n+@Entity\n+@Table(name = \"notification_history\")\n+public class NotificationHistoryEntity extends CreationTimestampedEntity {\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO, generator = \"notification_history_id_seq\")\n+    @NotNull\n+    public Integer id;\n+\n+    @Column(name = \"account_id\")\n+    @NotNull\n+    @Size(max = 50)\n+    public String accountId;\n+\n+    @Column(name = \"invocation_time\")\n+    @NotNull\n+    public Long invocationTime;\n+\n+    @Column(name = \"invocation_result\")\n+    @NotNull\n+    public Boolean invocationResult;\n+\n+    public String details;\n+\n+    @Column(name = \"event_id\")\n+    public String eventId;\n+\n+    @ManyToOne(fetch = FetchType.LAZY, optional = false)\n+    @JoinColumn(name = \"endpoint_id\")\n+    @NotNull\n+    public EndpointEntity endpoint;\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof NotificationHistoryEntity) {\n+            NotificationHistoryEntity other = (NotificationHistoryEntity) o;\n+            return Objects.equals(id, other.id);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n+    }\n+}"
  },
  {
    "sha": "fcc6d21986bf962067dc28efa8cfc7e959f2c945",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/mappers/ApplicationMapper.java",
    "status": "added",
    "additions": 45,
    "deletions": 0,
    "changes": 45,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/mappers/ApplicationMapper.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/mappers/ApplicationMapper.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/mappers/ApplicationMapper.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,45 @@\n+package com.redhat.cloud.notifications.db.mappers;\n+\n+import com.redhat.cloud.notifications.db.entities.ApplicationEntity;\n+import com.redhat.cloud.notifications.db.entities.BundleEntity;\n+import com.redhat.cloud.notifications.models.Application;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+@ApplicationScoped\n+public class ApplicationMapper {\n+\n+    @Inject\n+    Mutiny.Session session;\n+\n+    public ApplicationEntity dtoToEntity(Application dto) {\n+        ApplicationEntity entity = new ApplicationEntity();\n+        entity.name = dto.getName();\n+        entity.displayName = dto.getDisplay_name();\n+        if (dto.getBundleId() != null) {\n+            entity.bundle = session.getReference(BundleEntity.class, dto.getBundleId());\n+        }\n+        return entity;\n+    }\n+\n+    public Application entityToDto(ApplicationEntity entity) {\n+        Application dto = entityToDtoWithoutTimestamps(entity);\n+        dto.setCreated(entity.created);\n+        dto.setUpdated(entity.updated);\n+        return dto;\n+    }\n+\n+    public Application entityToDtoWithoutTimestamps(ApplicationEntity entity) {\n+        Application dto = new Application();\n+        dto.setId(entity.id);\n+        dto.setName(entity.name);\n+        dto.setDisplay_name(entity.displayName);\n+        if (entity.bundle != null) {\n+            dto.setBundleId(entity.bundle.id);\n+        }\n+        return dto;\n+    }\n+}\n+"
  },
  {
    "sha": "add91021f9c1e29bb84bfaa84dba589af287bfb5",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/mappers/BundleMapper.java",
    "status": "added",
    "additions": 27,
    "deletions": 0,
    "changes": 27,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/mappers/BundleMapper.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/mappers/BundleMapper.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/mappers/BundleMapper.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,27 @@\n+package com.redhat.cloud.notifications.db.mappers;\n+\n+import com.redhat.cloud.notifications.db.entities.BundleEntity;\n+import com.redhat.cloud.notifications.models.Bundle;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+@ApplicationScoped\n+public class BundleMapper {\n+\n+    public BundleEntity dtoToEntity(Bundle dto) {\n+        BundleEntity entity = new BundleEntity();\n+        entity.name = dto.getName();\n+        entity.displayName = dto.getDisplay_name();\n+        return entity;\n+    }\n+\n+    public Bundle entityToDto(BundleEntity entity) {\n+        Bundle dto = new Bundle();\n+        dto.setId(entity.id);\n+        dto.setName(entity.name);\n+        dto.setDisplay_name(entity.displayName);\n+        dto.setCreated(entity.created);\n+        dto.setUpdated(entity.updated);\n+        return dto;\n+    }\n+}"
  },
  {
    "sha": "c8d8f724200ad7bf4fe3251db69e29cb28e6dc86",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/mappers/EmailAggregationMapper.java",
    "status": "added",
    "additions": 35,
    "deletions": 0,
    "changes": 35,
    "blob_url": "https://github.com/RedHatInsights/notifications-backend/blob/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/mappers/EmailAggregationMapper.java",
    "raw_url": "https://github.com/RedHatInsights/notifications-backend/raw/3f49f253fb711bc781edd5c57f92ad9c5078d1ee/src/main/java/com/redhat/cloud/notifications/db/mappers/EmailAggregationMapper.java",
    "contents_url": "https://api.github.com/repos/RedHatInsights/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/mappers/EmailAggregationMapper.java?ref=3f49f253fb711bc781edd5c57f92ad9c5078d1ee",
    "patch": "@@ -0,0 +1,35 @@\n+package com.redhat.cloud.notifications.db.mappers;\n+\n+import com.redhat.cloud.notifications.db.entities.EmailAggregationEntity;\n+import com.redhat.cloud.notifications.models.EmailAggregation;\n+import io.vertx.core.json.JsonObject;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+@ApplicationScoped\n+public class EmailAggregationMapper {\n+\n+    public EmailAggregationEntity dtoToEntity(EmailAggregation dto) {\n+        EmailAggregationEntity entity = new EmailAggregationEntity();\n+        entity.accountId = dto.getAccountId();\n+        entity.bundleName = dto.getBundle();\n+        entity.applicationName = dto.getApplication();\n+        if (dto.getPayload() != null) {\n+            entity.payload = dto.getPayload().encode();\n+        }\n+        return entity;\n+    }\n+\n+    public EmailAggregation entityToDto(EmailAggregationEntity entity) {\n+        EmailAggregation dto = new EmailAggregation();\n+        dto.setId(entity.id);\n+        dto.setAccountId(entity.accountId);\n+        dto.setBundle(entity.bundleName);\n+        dto.setApplication(entity.applicationName);\n+        if (entity.payload != null) {\n+            dto.setPayload(new JsonObject(entity.payload));\n+        }\n+        dto.setCreated(entity.created);\n+        return dto;\n+    }\n+}"
  }
]
