[
  {
    "sha": "e7c53ca6dd4adc4f835bd217a5ce99fcdaa36fc1",
    "filename": "universal-application-tool-0.0.1/app/services/applicant/ApplicantData.java",
    "status": "modified",
    "additions": 63,
    "deletions": 24,
    "changes": 87,
    "blob_url": "https://github.com/seattle-uat/civiform/blob/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/applicant/ApplicantData.java",
    "raw_url": "https://github.com/seattle-uat/civiform/raw/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/applicant/ApplicantData.java",
    "contents_url": "https://api.github.com/repos/seattle-uat/civiform/contents/universal-application-tool-0.0.1/app/services/applicant/ApplicantData.java?ref=c8651499c107a5c4a1289b814fb5a974588d742b",
    "patch": "@@ -4,11 +4,9 @@\n \n import com.google.common.base.Splitter;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-import com.jayway.jsonpath.Configuration;\n import com.jayway.jsonpath.DocumentContext;\n import com.jayway.jsonpath.JsonPath;\n-import com.jayway.jsonpath.Option;\n+import com.jayway.jsonpath.PathNotFoundException;\n import com.jayway.jsonpath.spi.mapper.MappingException;\n import java.time.Instant;\n import java.util.HashMap;\n@@ -22,12 +20,7 @@\n import services.WellKnownPaths;\n \n public class ApplicantData {\n-  // Suppress errors thrown by JsonPath and instead return null if a path does not exist in a JSON\n-  // blob.\n-  private static final Configuration CONFIGURATION =\n-      Configuration.defaultConfiguration().addOptions(Option.SUPPRESS_EXCEPTIONS);\n   private static final String EMPTY_APPLICANT_DATA_JSON = \"{ \\\"applicant\\\": {}, \\\"metadata\\\": {} }\";\n-\n   private static final Locale DEFAULT_LOCALE = Locale.US;\n \n   private Locale preferredLocale;\n@@ -43,7 +36,7 @@ public ApplicantData(String jsonData) {\n \n   public ApplicantData(Locale preferredLocale, String jsonData) {\n     this.preferredLocale = preferredLocale;\n-    this.jsonData = JsonPath.using(CONFIGURATION).parse(checkNotNull(jsonData));\n+    this.jsonData = JsonPath.parse(checkNotNull(jsonData));\n   }\n \n   public Locale preferredLocale() {\n@@ -54,16 +47,68 @@ public void setPreferredLocale(Locale locale) {\n     this.preferredLocale = locale;\n   }\n \n+  /**\n+   * Checks whether the given path exists in the JSON data. Returns true if the path is present;\n+   * false otherwise. Semantically, this checks whether the applicant has answered this question\n+   * before.\n+   *\n+   * @param path the {@link Path} to check\n+   * @return true if path is present for this applicant; false otherwise\n+   */\n+  public boolean hasPath(Path path) {\n+    try {\n+      this.jsonData.read(path.path());\n+    } catch (PathNotFoundException e) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Returns true if there is a non-null value at the given {@link Path}; false otherwise. Will\n+   * return false if there is a null value at the path.\n+   *\n+   * @param path the {@link Path} to check\n+   * @return true if there is a non-null value at the given path; false otherwise\n+   */\n+  public boolean hasValueAtPath(Path path) {\n+    try {\n+      return read(path, Object.class).isPresent();\n+    } catch (JsonPathTypeMismatchException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Write the given string at the given {@link Path}. If the string is empty, it will write a null\n+   * value instead.\n+   */\n   public void putString(Path path, String value) {\n-    put(path, value);\n+    if (value.isEmpty()) {\n+      putNull(path);\n+    } else {\n+      put(path, value);\n+    }\n   }\n \n-  public void putInteger(Path path, int value) {\n+  public void putLong(Path path, long value) {\n     put(path, value);\n   }\n \n-  public <K, V> void putObject(Path path, ImmutableMap<K, V> value) {\n-    put(path, value);\n+  /**\n+   * Parses and writes a long value, given as a string. If the string is empty, a null value is\n+   * written.\n+   */\n+  public void putLong(Path path, String value) {\n+    if (value.isEmpty()) {\n+      putNull(path);\n+    } else {\n+      put(path, Long.parseLong(value));\n+    }\n+  }\n+\n+  private void putNull(Path path) {\n+    put(path, null);\n   }\n \n   /**\n@@ -78,7 +123,7 @@ private void put(Path path, Object value) {\n     path.parentPaths()\n         .forEach(\n             segmentPath -> {\n-              if (this.jsonData.read(segmentPath.path()) == null) {\n+              if (!hasPath(segmentPath)) {\n                 this.jsonData.put(\n                     segmentPath.parentPath().path(), segmentPath.keyName(), new HashMap<>());\n               }\n@@ -103,9 +148,9 @@ private void put(Path path, Object value) {\n    * Attempt to read a integer at the given path. Returns {@code Optional#empty} if the path does\n    * not exist or a value other than Integer is found.\n    */\n-  public Optional<Integer> readInteger(Path path) {\n+  public Optional<Long> readLong(Path path) {\n     try {\n-      return this.read(path, Integer.class);\n+      return this.read(path, Long.class);\n     } catch (JsonPathTypeMismatchException e) {\n       return Optional.empty();\n     }\n@@ -123,6 +168,8 @@ private void put(Path path, Object value) {\n   private <T> Optional<T> read(Path path, Class<T> type) throws JsonPathTypeMismatchException {\n     try {\n       return Optional.ofNullable(this.jsonData.read(path.path(), type));\n+    } catch (PathNotFoundException e) {\n+      return Optional.empty();\n     } catch (MappingException e) {\n       throw new JsonPathTypeMismatchException(path.path(), type, e);\n     }\n@@ -151,14 +198,6 @@ public boolean equals(@Nullable Object object) {\n     return false;\n   }\n \n-  public boolean hasPath(Path path) {\n-    try {\n-      return read(path, Object.class).isPresent();\n-    } catch (JsonPathTypeMismatchException e) {\n-      return false;\n-    }\n-  }\n-\n   @Override\n   public int hashCode() {\n     return Objects.hash(jsonData.jsonString());"
  },
  {
    "sha": "846a6969e8107437514fe427ef52de86a63921ac",
    "filename": "universal-application-tool-0.0.1/app/services/applicant/ApplicantQuestion.java",
    "status": "modified",
    "additions": 32,
    "deletions": 8,
    "changes": 40,
    "blob_url": "https://github.com/seattle-uat/civiform/blob/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/applicant/ApplicantQuestion.java",
    "raw_url": "https://github.com/seattle-uat/civiform/raw/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/applicant/ApplicantQuestion.java",
    "contents_url": "https://api.github.com/repos/seattle-uat/civiform/contents/universal-application-tool-0.0.1/app/services/applicant/ApplicantQuestion.java?ref=c8651499c107a5c4a1289b814fb5a974588d742b",
    "patch": "@@ -130,15 +130,15 @@ public boolean hasTypeSpecificErrors() {\n     }\n \n     public ImmutableSet<ValidationErrorMessage> getStreetErrors() {\n-      if (hasStreetValue() && getStreetValue().get().isEmpty()) {\n+      if (streetAnswered() && getStreetValue().isEmpty()) {\n         return ImmutableSet.of(ValidationErrorMessage.create(\"Street is required.\"));\n       }\n \n       return ImmutableSet.of();\n     }\n \n     public ImmutableSet<ValidationErrorMessage> getCityErrors() {\n-      if (hasCityValue() && getCityValue().get().isEmpty()) {\n+      if (cityAnswered() && getCityValue().isEmpty()) {\n         return ImmutableSet.of(ValidationErrorMessage.create(\"City is required.\"));\n       }\n \n@@ -147,22 +147,22 @@ public boolean hasTypeSpecificErrors() {\n \n     public ImmutableSet<ValidationErrorMessage> getStateErrors() {\n       // TODO: Validate state further.\n-      if (hasStateValue() && getStateValue().get().isEmpty()) {\n+      if (stateAnswered() && getStateValue().isEmpty()) {\n         return ImmutableSet.of(ValidationErrorMessage.create(\"State is required.\"));\n       }\n \n       return ImmutableSet.of();\n     }\n \n     public ImmutableSet<ValidationErrorMessage> getZipErrors() {\n-      if (hasZipValue()) {\n-        String zipValue = getZipValue().get();\n+      if (zipAnswered()) {\n+        Optional<String> zipValue = getZipValue();\n         if (zipValue.isEmpty()) {\n           return ImmutableSet.of(ValidationErrorMessage.create(\"Zip code is required.\"));\n         }\n \n         Pattern pattern = Pattern.compile(\"^[0-9]{5}(?:-[0-9]{4})?$\");\n-        Matcher matcher = pattern.matcher(zipValue);\n+        Matcher matcher = pattern.matcher(zipValue.get());\n         if (!matcher.matches()) {\n           return ImmutableSet.of(ValidationErrorMessage.create(\"Invalid zip code.\"));\n         }\n@@ -252,6 +252,22 @@ public Path getStatePath() {\n     public Path getZipPath() {\n       return getQuestionDefinition().getZipPath();\n     }\n+\n+    private boolean streetAnswered() {\n+      return applicantData.hasPath(getStreetPath());\n+    }\n+\n+    private boolean cityAnswered() {\n+      return applicantData.hasPath(getCityPath());\n+    }\n+\n+    private boolean stateAnswered() {\n+      return applicantData.hasPath(getStatePath());\n+    }\n+\n+    private boolean zipAnswered() {\n+      return applicantData.hasPath(getZipPath());\n+    }\n   }\n \n   public class TextQuestion implements PresentsErrors {\n@@ -366,15 +382,15 @@ public boolean hasTypeSpecificErrors() {\n     }\n \n     public ImmutableSet<ValidationErrorMessage> getFirstNameErrors() {\n-      if (hasFirstNameValue() && getFirstNameValue().get().isEmpty()) {\n+      if (firstNameAnswered() && getFirstNameValue().isEmpty()) {\n         return ImmutableSet.of(ValidationErrorMessage.create(\"First name is required.\"));\n       }\n \n       return ImmutableSet.of();\n     }\n \n     public ImmutableSet<ValidationErrorMessage> getLastNameErrors() {\n-      if (hasLastNameValue() && getLastNameValue().get().isEmpty()) {\n+      if (lastNameAnswered() && getLastNameValue().isEmpty()) {\n         return ImmutableSet.of(ValidationErrorMessage.create(\"Last name is required.\"));\n       }\n \n@@ -448,5 +464,13 @@ public Path getFirstNamePath() {\n     public Path getLastNamePath() {\n       return getQuestionDefinition().getLastNamePath();\n     }\n+\n+    private boolean firstNameAnswered() {\n+      return applicantData.hasPath(getFirstNamePath());\n+    }\n+\n+    private boolean lastNameAnswered() {\n+      return applicantData.hasPath(getLastNamePath());\n+    }\n   }\n }"
  },
  {
    "sha": "471ee90635fb7ce6388cfabc5155ee7454fabb1a",
    "filename": "universal-application-tool-0.0.1/app/services/applicant/ApplicantService.java",
    "status": "modified",
    "additions": 0,
    "deletions": 8,
    "changes": 8,
    "blob_url": "https://github.com/seattle-uat/civiform/blob/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/applicant/ApplicantService.java",
    "raw_url": "https://github.com/seattle-uat/civiform/raw/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/applicant/ApplicantService.java",
    "contents_url": "https://api.github.com/repos/seattle-uat/civiform/contents/universal-application-tool-0.0.1/app/services/applicant/ApplicantService.java?ref=c8651499c107a5c4a1289b814fb5a974588d742b",
    "patch": "@@ -1,7 +1,6 @@\n package services.applicant;\n \n import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n import java.util.concurrent.CompletionStage;\n import models.Applicant;\n import models.Application;\n@@ -28,13 +27,6 @@\n    *     <p>A ProgramNotFoundException may be thrown when the future completes if the programId does\n    *     not correspond to a real Program.\n    */\n-  CompletionStage<ErrorAnd<ReadOnlyApplicantProgramService, Exception>> stageAndUpdateIfValid(\n-      long applicantId, long programId, long blockId, ImmutableSet<Update> updates);\n-\n-  /**\n-   * Equivalent to the other {@link ApplicantService#stageAndUpdateIfValid(long, long, long,\n-   * ImmutableSet<Update>)}, but takes a map representing the {@link Update}s.\n-   */\n   CompletionStage<ErrorAnd<ReadOnlyApplicantProgramService, Exception>> stageAndUpdateIfValid(\n       long applicantId, long programId, long blockId, ImmutableMap<String, String> updateMap);\n "
  },
  {
    "sha": "59ec7febc3a9ecbc98a347c4efde8abe77e68a66",
    "filename": "universal-application-tool-0.0.1/app/services/applicant/ApplicantServiceImpl.java",
    "status": "modified",
    "additions": 74,
    "deletions": 42,
    "changes": 116,
    "blob_url": "https://github.com/seattle-uat/civiform/blob/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/applicant/ApplicantServiceImpl.java",
    "raw_url": "https://github.com/seattle-uat/civiform/raw/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/applicant/ApplicantServiceImpl.java",
    "contents_url": "https://api.github.com/repos/seattle-uat/civiform/contents/universal-application-tool-0.0.1/app/services/applicant/ApplicantServiceImpl.java?ref=c8651499c107a5c4a1289b814fb5a974588d742b",
    "patch": "@@ -4,6 +4,7 @@\n \n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n+import java.time.Clock;\n import java.util.NoSuchElementException;\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n@@ -23,28 +24,81 @@\n import services.program.ProgramBlockNotFoundException;\n import services.program.ProgramDefinition;\n import services.program.ProgramService;\n+import services.question.QuestionDefinition;\n import services.question.ScalarType;\n import services.question.UnsupportedScalarTypeException;\n \n public class ApplicantServiceImpl implements ApplicantService {\n+  private static final ImmutableSet<String> RESERVED_SCALAR_KEYS =\n+      ImmutableSet.of(\n+          QuestionDefinition.METADATA_UPDATE_TIME_KEY,\n+          QuestionDefinition.METADATA_UPDATE_PROGRAM_ID_KEY);\n \n   private final ApplicantRepository applicantRepository;\n   private final ProgramService programService;\n+  private final Clock clock;\n   private final HttpExecutionContext httpExecutionContext;\n   private final Logger log = LoggerFactory.getLogger(ApplicantService.class);\n \n   @Inject\n   public ApplicantServiceImpl(\n       ApplicantRepository applicantRepository,\n       ProgramService programService,\n+      Clock clock,\n       HttpExecutionContext httpExecutionContext) {\n     this.applicantRepository = checkNotNull(applicantRepository);\n     this.programService = checkNotNull(programService);\n+    this.clock = checkNotNull(clock);\n     this.httpExecutionContext = checkNotNull(httpExecutionContext);\n   }\n \n+  @Override\n+  public CompletionStage<Applicant> createApplicant(long userId) {\n+    Applicant applicant = new Applicant();\n+    return applicantRepository.insertApplicant(applicant).thenApply((unused) -> applicant);\n+  }\n+\n+  @Override\n+  public CompletionStage<ReadOnlyApplicantProgramService> getReadOnlyApplicantProgramService(\n+      long applicantId, long programId) {\n+    CompletableFuture<Optional<Applicant>> applicantCompletableFuture =\n+        applicantRepository.lookupApplicant(applicantId).toCompletableFuture();\n+    CompletableFuture<ProgramDefinition> programDefinitionCompletableFuture =\n+        programService.getProgramDefinitionAsync(programId).toCompletableFuture();\n+\n+    return CompletableFuture.allOf(applicantCompletableFuture, programDefinitionCompletableFuture)\n+        .thenApplyAsync(\n+            (v) -> {\n+              Applicant applicant = applicantCompletableFuture.join().get();\n+              ProgramDefinition programDefinition = programDefinitionCompletableFuture.join();\n+\n+              return new ReadOnlyApplicantProgramServiceImpl(\n+                  applicant.getApplicantData(), programDefinition);\n+            },\n+            httpExecutionContext.current());\n+  }\n+\n   @Override\n   public CompletionStage<ErrorAnd<ReadOnlyApplicantProgramService, Exception>>\n+      stageAndUpdateIfValid(\n+          long applicantId, long programId, long blockId, ImmutableMap<String, String> updateMap) {\n+    ImmutableSet<Update> updates =\n+        updateMap.entrySet().stream()\n+            .map(entry -> Update.create(Path.create(entry.getKey()), entry.getValue()))\n+            .collect(ImmutableSet.toImmutableSet());\n+\n+    boolean updatePathsContainReservedKeys =\n+        updates.stream().anyMatch(u -> RESERVED_SCALAR_KEYS.contains(u.path().keyName()));\n+    if (updatePathsContainReservedKeys) {\n+      return CompletableFuture.completedFuture(\n+          ErrorAnd.error(\n+              ImmutableSet.of(new IllegalArgumentException(\"Path contained reserved scalar key\"))));\n+    }\n+\n+    return stageAndUpdateIfValid(applicantId, programId, blockId, updates);\n+  }\n+\n+  protected CompletionStage<ErrorAnd<ReadOnlyApplicantProgramService, Exception>>\n       stageAndUpdateIfValid(\n           long applicantId, long programId, long blockId, ImmutableSet<Update> updates) {\n     CompletableFuture<Optional<Applicant>> applicantCompletableFuture =\n@@ -91,44 +145,6 @@ public ApplicantServiceImpl(\n             httpExecutionContext.current());\n   }\n \n-  @Override\n-  public CompletionStage<ErrorAnd<ReadOnlyApplicantProgramService, Exception>>\n-      stageAndUpdateIfValid(\n-          long applicantId, long programId, long blockId, ImmutableMap<String, String> updateMap) {\n-    ImmutableSet<Update> updates =\n-        updateMap.entrySet().stream()\n-            .map(entry -> Update.create(Path.create(entry.getKey()), entry.getValue()))\n-            .collect(ImmutableSet.toImmutableSet());\n-\n-    return stageAndUpdateIfValid(applicantId, programId, blockId, updates);\n-  }\n-\n-  @Override\n-  public CompletionStage<Applicant> createApplicant(long userId) {\n-    Applicant applicant = new Applicant();\n-    return applicantRepository.insertApplicant(applicant).thenApply((unused) -> applicant);\n-  }\n-\n-  @Override\n-  public CompletionStage<ReadOnlyApplicantProgramService> getReadOnlyApplicantProgramService(\n-      long applicantId, long programId) {\n-    CompletableFuture<Optional<Applicant>> applicantCompletableFuture =\n-        applicantRepository.lookupApplicant(applicantId).toCompletableFuture();\n-    CompletableFuture<ProgramDefinition> programDefinitionCompletableFuture =\n-        programService.getProgramDefinitionAsync(programId).toCompletableFuture();\n-\n-    return CompletableFuture.allOf(applicantCompletableFuture, programDefinitionCompletableFuture)\n-        .thenApplyAsync(\n-            (v) -> {\n-              Applicant applicant = applicantCompletableFuture.join().get();\n-              ProgramDefinition programDefinition = programDefinitionCompletableFuture.join();\n-\n-              return new ReadOnlyApplicantProgramServiceImpl(\n-                  applicant.getApplicantData(), programDefinition);\n-            },\n-            httpExecutionContext.current());\n-  }\n-\n   @Override\n   public String applicantName(Application application) {\n     try {\n@@ -156,28 +172,44 @@ private void stageUpdates(\n         programDefinition\n             .getBlockDefinition(blockId)\n             .orElseThrow(() -> new ProgramBlockNotFoundException(programDefinition.id(), blockId));\n-    stageUpdates(applicant.getApplicantData(), blockDefinition, updates);\n+    stageUpdates(applicant.getApplicantData(), blockDefinition, programDefinition.id(), updates);\n   }\n \n   /** In-place update of {@link ApplicantData}. */\n   private void stageUpdates(\n-      ApplicantData applicantData, BlockDefinition blockDefinition, ImmutableSet<Update> updates)\n+      ApplicantData applicantData,\n+      BlockDefinition blockDefinition,\n+      long programId,\n+      ImmutableSet<Update> updates)\n       throws UnsupportedScalarTypeException, PathNotInBlockException {\n+    ImmutableSet.Builder<Path> questionPaths = ImmutableSet.builder();\n     for (Update update : updates) {\n       ScalarType type =\n           blockDefinition\n               .getScalarType(update.path())\n               .orElseThrow(() -> new PathNotInBlockException(blockDefinition, update.path()));\n+      questionPaths.add(update.path().parentPath());\n       switch (type) {\n         case STRING:\n           applicantData.putString(update.path(), update.value());\n           break;\n-        case INT:\n-          applicantData.putInteger(update.path(), Integer.valueOf(update.value()));\n+        case LONG:\n+          applicantData.putLong(update.path(), update.value());\n           break;\n         default:\n           throw new UnsupportedScalarTypeException(type);\n       }\n     }\n+\n+    questionPaths.build().forEach(path -> writeMetadataForPath(path, applicantData, programId));\n+  }\n+\n+  private void writeMetadataForPath(Path path, ApplicantData data, long programId) {\n+    data.putLong(\n+        path.toBuilder().append(QuestionDefinition.METADATA_UPDATE_PROGRAM_ID_KEY).build(),\n+        programId);\n+    data.putLong(\n+        path.toBuilder().append(QuestionDefinition.METADATA_UPDATE_TIME_KEY).build(),\n+        clock.millis());\n   }\n }"
  },
  {
    "sha": "718b13d8ffbce1b540b660235c10678c0ad2a969",
    "filename": "universal-application-tool-0.0.1/app/services/question/AddressQuestionDefinition.java",
    "status": "modified",
    "additions": 8,
    "deletions": 9,
    "changes": 17,
    "blob_url": "https://github.com/seattle-uat/civiform/blob/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/question/AddressQuestionDefinition.java",
    "raw_url": "https://github.com/seattle-uat/civiform/raw/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/question/AddressQuestionDefinition.java",
    "contents_url": "https://api.github.com/repos/seattle-uat/civiform/contents/universal-application-tool-0.0.1/app/services/question/AddressQuestionDefinition.java?ref=c8651499c107a5c4a1289b814fb5a974588d742b",
    "patch": "@@ -78,15 +78,14 @@ public QuestionType getQuestionType() {\n \n   @Override\n   public ImmutableMap<Path, ScalarType> getScalars() {\n-    return ImmutableMap.of(\n-        getStreetPath(),\n-        getStreetType(),\n-        getCityPath(),\n-        getCityType(),\n-        getStatePath(),\n-        getStateType(),\n-        getZipPath(),\n-        getZipType());\n+    return ImmutableMap.<Path, ScalarType>builder()\n+        .put(getStreetPath(), getStreetType())\n+        .put(getCityPath(), getCityType())\n+        .put(getStatePath(), getStateType())\n+        .put(getZipPath(), getZipType())\n+        .put(getLastUpdatedTimePath(), getLastUpdatedTimeType())\n+        .put(getProgramIdPath(), getProgramIdType())\n+        .build();\n   }\n \n   public Path getStreetPath() {"
  },
  {
    "sha": "990895d553c7d0703adfeaf09efc8c14b2168e76",
    "filename": "universal-application-tool-0.0.1/app/services/question/NameQuestionDefinition.java",
    "status": "modified",
    "additions": 5,
    "deletions": 1,
    "changes": 6,
    "blob_url": "https://github.com/seattle-uat/civiform/blob/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/question/NameQuestionDefinition.java",
    "raw_url": "https://github.com/seattle-uat/civiform/raw/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/question/NameQuestionDefinition.java",
    "contents_url": "https://api.github.com/repos/seattle-uat/civiform/contents/universal-application-tool-0.0.1/app/services/question/NameQuestionDefinition.java?ref=c8651499c107a5c4a1289b814fb5a974588d742b",
    "patch": "@@ -84,7 +84,11 @@ public QuestionType getQuestionType() {\n         getMiddleNamePath(),\n         getMiddleNameType(),\n         getLastNamePath(),\n-        getLastNameType());\n+        getLastNameType(),\n+        getLastUpdatedTimePath(),\n+        getLastUpdatedTimeType(),\n+        getProgramIdPath(),\n+        getProgramIdType());\n   }\n \n   public Path getFirstNamePath() {"
  },
  {
    "sha": "82b5fcb60b178ffdd4562877bb502b975fc31d7c",
    "filename": "universal-application-tool-0.0.1/app/services/question/QuestionDefinition.java",
    "status": "modified",
    "additions": 19,
    "deletions": 0,
    "changes": 19,
    "blob_url": "https://github.com/seattle-uat/civiform/blob/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/question/QuestionDefinition.java",
    "raw_url": "https://github.com/seattle-uat/civiform/raw/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/question/QuestionDefinition.java",
    "contents_url": "https://api.github.com/repos/seattle-uat/civiform/contents/universal-application-tool-0.0.1/app/services/question/QuestionDefinition.java?ref=c8651499c107a5c4a1289b814fb5a974588d742b",
    "patch": "@@ -18,6 +18,9 @@\n \n /** Defines a single question. */\n public abstract class QuestionDefinition {\n+  public static final String METADATA_UPDATE_TIME_KEY = \"updated_at\";\n+  public static final String METADATA_UPDATE_PROGRAM_ID_KEY = \"updated_in_program\";\n+\n   private final OptionalLong id;\n   private final long version;\n   private final String name;\n@@ -169,6 +172,22 @@ public String getValidationPredicatesAsString() {\n   /** Get the type of this question. */\n   public abstract QuestionType getQuestionType();\n \n+  public Path getLastUpdatedTimePath() {\n+    return getPath().toBuilder().append(METADATA_UPDATE_TIME_KEY).build();\n+  }\n+\n+  public ScalarType getLastUpdatedTimeType() {\n+    return ScalarType.LONG;\n+  }\n+\n+  public Path getProgramIdPath() {\n+    return getPath().toBuilder().append(METADATA_UPDATE_PROGRAM_ID_KEY).build();\n+  }\n+\n+  public ScalarType getProgramIdType() {\n+    return ScalarType.LONG;\n+  }\n+\n   /** Get a map of scalars stored by this question definition. */\n   public abstract ImmutableMap<Path, ScalarType> getScalars();\n "
  },
  {
    "sha": "ac2399f9b778435f96b326429f4018d22dd5096e",
    "filename": "universal-application-tool-0.0.1/app/services/question/ScalarType.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/seattle-uat/civiform/blob/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/question/ScalarType.java",
    "raw_url": "https://github.com/seattle-uat/civiform/raw/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/question/ScalarType.java",
    "contents_url": "https://api.github.com/repos/seattle-uat/civiform/contents/universal-application-tool-0.0.1/app/services/question/ScalarType.java?ref=c8651499c107a5c4a1289b814fb5a974588d742b",
    "patch": "@@ -9,7 +9,7 @@\n  * models.Applicant} JSON column and serialized using {@link services.applicant.ApplicantData}.\n  */\n public enum ScalarType {\n-  INT(int.class),\n+  LONG(long.class),\n   STRING(String.class);\n \n   private final Class classOf;"
  },
  {
    "sha": "ded3f14aa8c6b717f11cf75e1ae081a72895c8a2",
    "filename": "universal-application-tool-0.0.1/app/services/question/TextQuestionDefinition.java",
    "status": "modified",
    "additions": 7,
    "deletions": 1,
    "changes": 8,
    "blob_url": "https://github.com/seattle-uat/civiform/blob/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/question/TextQuestionDefinition.java",
    "raw_url": "https://github.com/seattle-uat/civiform/raw/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/app/services/question/TextQuestionDefinition.java",
    "contents_url": "https://api.github.com/repos/seattle-uat/civiform/contents/universal-application-tool-0.0.1/app/services/question/TextQuestionDefinition.java?ref=c8651499c107a5c4a1289b814fb5a974588d742b",
    "patch": "@@ -113,7 +113,13 @@ public QuestionType getQuestionType() {\n \n   @Override\n   public ImmutableMap<Path, ScalarType> getScalars() {\n-    return ImmutableMap.of(getTextPath(), getTextType());\n+    return ImmutableMap.of(\n+        getTextPath(),\n+        getTextType(),\n+        getLastUpdatedTimePath(),\n+        getLastUpdatedTimeType(),\n+        getProgramIdPath(),\n+        getProgramIdType());\n   }\n \n   public Path getTextPath() {"
  },
  {
    "sha": "c63f07f3ea70de860cadce54e0f012291f9df157",
    "filename": "universal-application-tool-0.0.1/test/controllers/applicant/ApplicantProgramBlocksControllerTest.java",
    "status": "modified",
    "additions": 15,
    "deletions": 0,
    "changes": 15,
    "blob_url": "https://github.com/seattle-uat/civiform/blob/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/test/controllers/applicant/ApplicantProgramBlocksControllerTest.java",
    "raw_url": "https://github.com/seattle-uat/civiform/raw/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/test/controllers/applicant/ApplicantProgramBlocksControllerTest.java",
    "contents_url": "https://api.github.com/repos/seattle-uat/civiform/contents/universal-application-tool-0.0.1/test/controllers/applicant/ApplicantProgramBlocksControllerTest.java?ref=c8651499c107a5c4a1289b814fb5a974588d742b",
    "patch": "@@ -20,6 +20,7 @@\n import play.mvc.Http.Request;\n import play.mvc.Result;\n import repository.WithPostgresContainer;\n+import services.question.QuestionDefinition;\n import support.ProgramBuilder;\n import support.TestQuestionBank;\n \n@@ -130,6 +131,20 @@ public void update_invalidPathsInRequest_returnsBadRequest() {\n     assertThat(result.status()).isEqualTo(BAD_REQUEST);\n   }\n \n+  @Test\n+  public void update_reservedPathsInRequest_returnsBadRequest() {\n+    String reservedPath = \"metadata.\" + QuestionDefinition.METADATA_UPDATE_PROGRAM_ID_KEY;\n+    Request request =\n+        fakeRequest(routes.ApplicantProgramBlocksController.update(applicant.id, program.id, 1L))\n+            .bodyForm(ImmutableMap.of(reservedPath, \"value\"))\n+            .build();\n+\n+    Result result =\n+        subject.update(request, applicant.id, program.id, 1L).toCompletableFuture().join();\n+\n+    assertThat(result.status()).isEqualTo(BAD_REQUEST);\n+  }\n+\n   @Test\n   public void update_withValidationErrors_isOK() {\n     Request request ="
  },
  {
    "sha": "766051f681c418670c33fe151a6ba22c0f3f4b33",
    "filename": "universal-application-tool-0.0.1/test/services/applicant/ApplicantDataTest.java",
    "status": "modified",
    "additions": 68,
    "deletions": 16,
    "changes": 84,
    "blob_url": "https://github.com/seattle-uat/civiform/blob/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/test/services/applicant/ApplicantDataTest.java",
    "raw_url": "https://github.com/seattle-uat/civiform/raw/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/test/services/applicant/ApplicantDataTest.java",
    "contents_url": "https://api.github.com/repos/seattle-uat/civiform/contents/universal-application-tool-0.0.1/test/services/applicant/ApplicantDataTest.java?ref=c8651499c107a5c4a1289b814fb5a974588d742b",
    "patch": "@@ -2,7 +2,6 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n-import com.google.common.collect.ImmutableMap;\n import com.google.common.testing.EqualsTester;\n import java.time.Instant;\n import java.util.Locale;\n@@ -39,16 +38,57 @@ public void preferredLocale_defaultsToEnglish() {\n   }\n \n   @Test\n-  public void put_addsAScalar() {\n+  public void hasPath_returnsTrueForExistingPath() {\n     ApplicantData data = new ApplicantData();\n+    Path path = Path.create(\"applicant.school\");\n+    data.putString(path, \"Elementary School\");\n \n-    data.putInteger(Path.create(\"applicant.age\"), 99);\n+    assertThat(data.hasPath(path)).isTrue();\n+  }\n+\n+  @Test\n+  public void hasPath_returnsFalseForMissingPath() {\n+    ApplicantData data = new ApplicantData();\n+\n+    assertThat(data.hasPath(Path.create(\"I_don't_exist!\"))).isFalse();\n+  }\n+\n+  @Test\n+  public void hasValueAtPath_returnsTrueIfValuePresent() {\n+    ApplicantData data = new ApplicantData();\n+    Path path = Path.create(\"applicant.horses\");\n+    data.putLong(path, 278);\n+\n+    assertThat(data.hasValueAtPath(path)).isTrue();\n+  }\n+\n+  @Test\n+  public void hasValueAtPath_returnsFalseForNull() {\n+    ApplicantData data = new ApplicantData();\n+    Path path = Path.create(\"applicant.horses\");\n+    data.putLong(path, \"\");\n+\n+    assertThat(data.hasValueAtPath(path)).isFalse();\n+  }\n+\n+  @Test\n+  public void hasValueAtPath_returnsFalseForMissingPath() {\n+    ApplicantData data = new ApplicantData();\n+\n+    assertThat(data.hasValueAtPath(Path.create(\"not_here!\"))).isFalse();\n+  }\n+\n+  @Test\n+  public void putLong_addsAScalar() {\n+    ApplicantData data = new ApplicantData();\n+\n+    data.putLong(Path.create(\"applicant.age\"), 99);\n \n     assertThat(data.asJsonString()).isEqualTo(\"{\\\"applicant\\\":{\\\"age\\\":99},\\\"metadata\\\":{}}\");\n   }\n \n   @Test\n-  public void put_addsANestedScalar() {\n+  public void putString_addsANestedScalar() {\n     ApplicantData data = new ApplicantData();\n     String expected =\n         \"{\\\"applicant\\\":{\\\"favorites\\\":{\\\"food\\\":{\\\"apple\\\":\\\"Granny Smith\\\"}}},\\\"metadata\\\":{}}\";\n@@ -59,15 +99,27 @@ public void put_addsANestedScalar() {\n   }\n \n   @Test\n-  public void put_addsAMap() {\n+  public void putString_writesNullIfStringIsEmpty() {\n     ApplicantData data = new ApplicantData();\n-    ImmutableMap<String, String> map = ImmutableMap.of(\"sandwich\", \"PB&J\", \"color\", \"blue\");\n-    String expected =\n-        \"{\\\"applicant\\\":{\\\"favorites\\\":{\\\"sandwich\\\":\\\"PB&J\\\",\\\"color\\\":\\\"blue\\\"}},\\\"metadata\\\":{}}\";\n+    Path path = Path.create(\"applicant.name\");\n+    String expected = \"{\\\"applicant\\\":{\\\"name\\\":null},\\\"metadata\\\":{}}\";\n+\n+    data.putString(path, \"\");\n+\n+    assertThat(data.asJsonString()).isEqualTo(expected);\n+    assertThat(data.readString(path)).isEmpty();\n+  }\n+\n+  @Test\n+  public void putLong_writesNullIfStringIsEmpty() {\n+    ApplicantData data = new ApplicantData();\n+    Path path = Path.create(\"applicant.age\");\n+    String expected = \"{\\\"applicant\\\":{\\\"age\\\":null},\\\"metadata\\\":{}}\";\n \n-    data.putObject(Path.create(\"applicant.favorites\"), map);\n+    data.putLong(path, \"\");\n \n     assertThat(data.asJsonString()).isEqualTo(expected);\n+    assertThat(data.readLong(path)).isEmpty();\n   }\n \n   @Test\n@@ -81,13 +133,13 @@ public void readString_findsCorrectValue() throws Exception {\n   }\n \n   @Test\n-  public void readInteger_findsCorrectValue() throws Exception {\n+  public void readLong_findsCorrectValue() throws Exception {\n     String testData = \"{ \\\"applicant\\\": { \\\"age\\\": 30 } }\";\n     ApplicantData data = new ApplicantData(testData);\n \n-    Optional<Integer> found = data.readInteger(Path.create(\"applicant.age\"));\n+    Optional<Long> found = data.readLong(Path.create(\"applicant.age\"));\n \n-    assertThat(found).hasValue(30);\n+    assertThat(found).hasValue(30L);\n   }\n \n   @Test\n@@ -100,10 +152,10 @@ public void readString_pathNotPresent_returnsEmptyOptional() throws Exception {\n   }\n \n   @Test\n-  public void readInteger_pathNotPresent_returnsEmptyOptional() throws Exception {\n+  public void readLong_pathNotPresent_returnsEmptyOptional() throws Exception {\n     ApplicantData data = new ApplicantData();\n \n-    Optional<Integer> found = data.readInteger(Path.create(\"my.fake.path\"));\n+    Optional<Long> found = data.readLong(Path.create(\"my.fake.path\"));\n \n     assertThat(found).isEmpty();\n   }\n@@ -119,11 +171,11 @@ public void readString_returnsEmptyWhenTypeMismatch() {\n   }\n \n   @Test\n-  public void readInteger_returnsEmptyWhenTypeMismatch() {\n+  public void readLong_returnsEmptyWhenTypeMismatch() {\n     String testData = \"{ \\\"applicant\\\": { \\\"object\\\": { \\\"name\\\": \\\"John\\\" } } }\";\n     ApplicantData data = new ApplicantData(testData);\n \n-    Optional<Integer> found = data.readInteger(Path.create(\"applicant.object.name\"));\n+    Optional<Long> found = data.readLong(Path.create(\"applicant.object.name\"));\n \n     assertThat(found).isEmpty();\n   }"
  },
  {
    "sha": "ef86c7da30d7ef28eb2272244b7401e7a7e5985c",
    "filename": "universal-application-tool-0.0.1/test/services/applicant/ApplicantServiceImplTest.java",
    "status": "modified",
    "additions": 46,
    "deletions": 0,
    "changes": 46,
    "blob_url": "https://github.com/seattle-uat/civiform/blob/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/test/services/applicant/ApplicantServiceImplTest.java",
    "raw_url": "https://github.com/seattle-uat/civiform/raw/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/test/services/applicant/ApplicantServiceImplTest.java",
    "contents_url": "https://api.github.com/repos/seattle-uat/civiform/contents/universal-application-tool-0.0.1/test/services/applicant/ApplicantServiceImplTest.java?ref=c8651499c107a5c4a1289b814fb5a974588d742b",
    "patch": "@@ -89,6 +89,35 @@ public void stageAndUpdateIfValid_withUpdates_isOk() {\n     assertThat(applicantDataAfter.asJsonString()).contains(\"Alice\", \"Doe\");\n   }\n \n+  @Test\n+  public void stageAndUpdateIfValid_updatesMetadataForQuestionOnce() {\n+    Applicant applicant = subject.createApplicant(1L).toCompletableFuture().join();\n+\n+    ImmutableSet<Update> updates =\n+        ImmutableSet.of(\n+            Update.create(Path.create(\"applicant.name.first\"), \"Alice\"),\n+            Update.create(Path.create(\"applicant.name.last\"), \"Doe\"));\n+\n+    ErrorAnd<ReadOnlyApplicantProgramService, Exception> errorAnd =\n+        subject\n+            .stageAndUpdateIfValid(applicant.id, programDefinition.id(), 1L, updates)\n+            .toCompletableFuture()\n+            .join();\n+\n+    assertThat(errorAnd.isError()).isFalse();\n+    assertThat(errorAnd.getResult()).isInstanceOf(ReadOnlyApplicantProgramService.class);\n+\n+    ApplicantData applicantDataAfter =\n+        applicantRepository.lookupApplicantSync(applicant.id).get().getApplicantData();\n+\n+    Path programIdPath =\n+        Path.create(\"applicant.name.\" + QuestionDefinition.METADATA_UPDATE_PROGRAM_ID_KEY);\n+    Path timestampPath =\n+        Path.create(\"applicant.name.\" + QuestionDefinition.METADATA_UPDATE_TIME_KEY);\n+    assertThat(applicantDataAfter.readLong(programIdPath)).hasValue(programDefinition.id());\n+    assertThat(applicantDataAfter.readLong(timestampPath)).isPresent();\n+  }\n+\n   @Test\n   public void stageAndUpdateIfValid_hasApplicantNotFoundException() {\n     ImmutableSet<Update> updates = ImmutableSet.of();\n@@ -160,6 +189,23 @@ public void stageAndUpdateIfValid_hasPathNotInBlockException() {\n     assertThat(errorAnd.getErrors().asList().get(0)).isInstanceOf(PathNotInBlockException.class);\n   }\n \n+  @Test\n+  public void stageAndUpdateIfValid_hasIllegalArgumentExceptionForReservedScalarKeys() {\n+    Applicant applicant = subject.createApplicant(1L).toCompletableFuture().join();\n+    String reservedScalar = \"applicant.name.\" + QuestionDefinition.METADATA_UPDATE_TIME_KEY;\n+    ImmutableMap<String, String> updates = ImmutableMap.of(reservedScalar, \"12345\");\n+\n+    ErrorAnd<ReadOnlyApplicantProgramService, Exception> errorAnd =\n+        subject\n+            .stageAndUpdateIfValid(applicant.id, programDefinition.id(), 1L, updates)\n+            .toCompletableFuture()\n+            .join();\n+\n+    assertThat(errorAnd.hasResult()).isFalse();\n+    assertThat(errorAnd.getErrors()).hasSize(1);\n+    assertThat(errorAnd.getErrors().asList().get(0)).isInstanceOf(IllegalArgumentException.class);\n+  }\n+\n   @Test\n   public void createApplicant_createsANewApplicant() {\n     Applicant applicant = subject.createApplicant(1l).toCompletableFuture().join();"
  },
  {
    "sha": "484afcdaf5dc2513ed871d3778c77d7759d2a701",
    "filename": "universal-application-tool-0.0.1/test/services/question/QuestionDefinitionTest.java",
    "status": "modified",
    "additions": 9,
    "deletions": 3,
    "changes": 12,
    "blob_url": "https://github.com/seattle-uat/civiform/blob/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/test/services/question/QuestionDefinitionTest.java",
    "raw_url": "https://github.com/seattle-uat/civiform/raw/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/test/services/question/QuestionDefinitionTest.java",
    "contents_url": "https://api.github.com/repos/seattle-uat/civiform/contents/universal-application-tool-0.0.1/test/services/question/QuestionDefinitionTest.java?ref=c8651499c107a5c4a1289b814fb5a974588d742b",
    "patch": "@@ -2,7 +2,6 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.catchThrowable;\n-import static org.assertj.core.api.Assertions.entry;\n \n import com.google.common.collect.ImmutableMap;\n import java.util.Locale;\n@@ -212,8 +211,15 @@ public void newQuestionHasStringScalar() {\n             \"description\",\n             ImmutableMap.of(),\n             ImmutableMap.of());\n-    assertThat(question.getScalars())\n-        .containsOnly(entry(Path.create(\"path.to.question.text\"), ScalarType.STRING));\n+    ImmutableMap<Path, ScalarType> expectedScalars =\n+        ImmutableMap.of(\n+            Path.create(\"path.to.question.text\"),\n+            ScalarType.STRING,\n+            Path.create(\"path.to.question.updated_at\"),\n+            ScalarType.LONG,\n+            Path.create(\"path.to.question.updated_in_program\"),\n+            ScalarType.LONG);\n+    assertThat(question.getScalars()).containsAllEntriesOf(expectedScalars);\n     assertThat(question.getScalarType(Path.create(\"path.to.question.text\")).get())\n         .isEqualTo(ScalarType.STRING);\n     assertThat("
  },
  {
    "sha": "3f9e743087dd5fa2ed13dc4503ec45b7f6be93bc",
    "filename": "universal-application-tool-0.0.1/test/views/questiontypes/TextQuestionRendererTest.java",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/seattle-uat/civiform/blob/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/test/views/questiontypes/TextQuestionRendererTest.java",
    "raw_url": "https://github.com/seattle-uat/civiform/raw/c8651499c107a5c4a1289b814fb5a974588d742b/universal-application-tool-0.0.1/test/views/questiontypes/TextQuestionRendererTest.java",
    "contents_url": "https://api.github.com/repos/seattle-uat/civiform/contents/universal-application-tool-0.0.1/test/views/questiontypes/TextQuestionRendererTest.java?ref=c8651499c107a5c4a1289b814fb5a974588d742b",
    "patch": "@@ -23,7 +23,7 @@\n           \"description\",\n           ImmutableMap.of(Locale.US, \"question?\"),\n           ImmutableMap.of(Locale.US, \"help text\"),\n-          TextValidationPredicates.create(1, 3));\n+          TextValidationPredicates.create(2, 3));\n \n   private final ApplicantData applicantData = new ApplicantData();\n \n@@ -44,11 +44,11 @@ public void render_withoutQuestionErrors() {\n \n   @Test\n   public void render_withMinLengthError() {\n-    applicantData.putString(TEXT_QUESTION_DEFINITION.getTextPath(), \"\");\n+    applicantData.putString(TEXT_QUESTION_DEFINITION.getTextPath(), \"a\");\n \n     Tag result = renderer.render();\n \n-    assertThat(result.render()).contains(\"This answer must be at least 1 characters long.\");\n+    assertThat(result.render()).contains(\"This answer must be at least 2 characters long.\");\n   }\n \n   @Test"
  }
]
