[
  {
    "sha": "f2f96e89e66b3e96e491a1199e084d4461778ab9",
    "filename": "checkstyle/suppressions.xml",
    "status": "modified",
    "additions": 3,
    "deletions": 0,
    "changes": 3,
    "blob_url": "https://github.com/confluentinc/kafka/blob/4a7ea802b734295dc4d55a995382ef788c17357c/checkstyle/suppressions.xml",
    "raw_url": "https://github.com/confluentinc/kafka/raw/4a7ea802b734295dc4d55a995382ef788c17357c/checkstyle/suppressions.xml",
    "contents_url": "https://api.github.com/repos/confluentinc/kafka/contents/checkstyle/suppressions.xml?ref=4a7ea802b734295dc4d55a995382ef788c17357c",
    "patch": "@@ -147,6 +147,9 @@\n     <suppress checks=\"MethodLength\"\n               files=\"(RequestResponse|WorkerSinkTask)Test.java\"/>\n \n+    <suppress checks=\"JavaNCSS\"\n+              files=\"DistributedHerderTest.java\"/>\n+\n     <!-- Streams -->\n     <suppress checks=\"ClassFanOutComplexity\"\n               files=\"(KafkaStreams|KStreamImpl|KTableImpl|StreamsPartitionAssignor).java\"/>"
  },
  {
    "sha": "d60250bed8532c4c49c34e1d8ab7cdbc1b8bb41f",
    "filename": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java",
    "status": "modified",
    "additions": 5,
    "deletions": 4,
    "changes": 9,
    "blob_url": "https://github.com/confluentinc/kafka/blob/4a7ea802b734295dc4d55a995382ef788c17357c/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java",
    "raw_url": "https://github.com/confluentinc/kafka/raw/4a7ea802b734295dc4d55a995382ef788c17357c/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java",
    "contents_url": "https://api.github.com/repos/confluentinc/kafka/contents/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java?ref=4a7ea802b734295dc4d55a995382ef788c17357c",
    "patch": "@@ -402,7 +402,7 @@ public void tick() {\n             log.debug(\"Scheduled rebalance at: {} (now: {} nextRequestTimeoutMs: {}) \",\n                     scheduledRebalance, now, nextRequestTimeoutMs);\n         }\n-        if (internalRequestValidationEnabled() && keyExpiration < Long.MAX_VALUE) {\n+        if (isLeader() && internalRequestValidationEnabled() && keyExpiration < Long.MAX_VALUE) {\n             nextRequestTimeoutMs = Math.min(nextRequestTimeoutMs, Math.max(keyExpiration - now, 0));\n             log.debug(\"Scheduled next key rotation at: {} (now: {} nextRequestTimeoutMs: {}) \",\n                     keyExpiration, now, nextRequestTimeoutMs);\n@@ -1573,10 +1573,11 @@ public void onSessionKeyUpdate(SessionKey sessionKey) {\n \n             synchronized (DistributedHerder.this) {\n                 DistributedHerder.this.sessionKey = sessionKey.key();\n-                // Track the expiration of the key if and only if this worker is the leader\n+                // Track the expiration of the key.\n                 // Followers will receive rotated keys from the leader and won't be responsible for\n-                // tracking expiration and distributing new keys themselves\n-                if (isLeader() && keyRotationIntervalMs > 0) {\n+                // tracking expiration and distributing new keys themselves, but may become leaders\n+                // later on and will need to know when to update the key.\n+                if (keyRotationIntervalMs > 0) {\n                     DistributedHerder.this.keyExpiration = sessionKey.creationTimestamp() + keyRotationIntervalMs;\n                 }\n             }"
  },
  {
    "sha": "933e526427fa22d2965a65b16eeb9fda19a7f2bb",
    "filename": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/distributed/DistributedHerderTest.java",
    "status": "modified",
    "additions": 104,
    "deletions": 3,
    "changes": 107,
    "blob_url": "https://github.com/confluentinc/kafka/blob/4a7ea802b734295dc4d55a995382ef788c17357c/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/distributed/DistributedHerderTest.java",
    "raw_url": "https://github.com/confluentinc/kafka/raw/4a7ea802b734295dc4d55a995382ef788c17357c/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/distributed/DistributedHerderTest.java",
    "contents_url": "https://api.github.com/repos/confluentinc/kafka/contents/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/distributed/DistributedHerderTest.java?ref=4a7ea802b734295dc4d55a995382ef788c17357c",
    "patch": "@@ -28,6 +28,7 @@\n import org.apache.kafka.connect.runtime.ConnectorConfig;\n import org.apache.kafka.connect.runtime.Herder;\n import org.apache.kafka.connect.runtime.MockConnectMetrics;\n+import org.apache.kafka.connect.runtime.SessionKey;\n import org.apache.kafka.connect.runtime.SinkConnectorConfig;\n import org.apache.kafka.connect.runtime.TargetState;\n import org.apache.kafka.connect.runtime.TaskConfig;\n@@ -67,6 +68,7 @@\n import org.powermock.modules.junit4.PowerMockRunner;\n import org.powermock.reflect.Whitebox;\n \n+import javax.crypto.SecretKey;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -2071,6 +2073,84 @@ public void testPutConnectorConfig() throws Exception {\n         PowerMock.verifyAll();\n     }\n \n+    @Test\n+    public void testKeyRotationWhenWorkerBecomesLeader() throws Exception {\n+        EasyMock.expect(member.memberId()).andStubReturn(\"member\");\n+        EasyMock.expect(member.currentProtocolVersion()).andStubReturn(CONNECT_PROTOCOL_V2);\n+\n+        expectRebalance(1, Collections.emptyList(), Collections.emptyList());\n+        expectPostRebalanceCatchup(SNAPSHOT);\n+        // First rebalance: poll indefinitely as no key has been read yet, so expiration doesn't come into play\n+        member.poll(Long.MAX_VALUE);\n+        EasyMock.expectLastCall();\n+\n+        expectRebalance(2, Collections.emptyList(), Collections.emptyList());\n+        SessionKey initialKey = new SessionKey(EasyMock.mock(SecretKey.class), 0);\n+        ClusterConfigState snapshotWithKey =  new ClusterConfigState(2, initialKey, Collections.singletonMap(CONN1, 3),\n+            Collections.singletonMap(CONN1, CONN1_CONFIG), Collections.singletonMap(CONN1, TargetState.STARTED),\n+            TASK_CONFIGS_MAP, Collections.<String>emptySet());\n+        expectPostRebalanceCatchup(snapshotWithKey);\n+        // Second rebalance: poll indefinitely as worker is follower, so expiration still doesn't come into play\n+        member.poll(Long.MAX_VALUE);\n+        EasyMock.expectLastCall();\n+\n+        expectRebalance(2, Collections.emptyList(), Collections.emptyList(), \"member\", MEMBER_URL);\n+        Capture<SessionKey> updatedKey = EasyMock.newCapture();\n+        configBackingStore.putSessionKey(EasyMock.capture(updatedKey));\n+        EasyMock.expectLastCall().andAnswer(() -> {\n+            configUpdateListener.onSessionKeyUpdate(updatedKey.getValue());\n+            return null;\n+        });\n+        // Third rebalance: poll for a limited time as worker has become leader and must wake up for key expiration\n+        Capture<Long> pollTimeout = EasyMock.newCapture();\n+        member.poll(EasyMock.captureLong(pollTimeout));\n+        EasyMock.expectLastCall();\n+\n+        PowerMock.replayAll();\n+\n+        herder.tick();\n+        configUpdateListener.onSessionKeyUpdate(initialKey);\n+        herder.tick();\n+        herder.tick();\n+\n+        assertTrue(pollTimeout.getValue() <= DistributedConfig.INTER_WORKER_KEY_TTL_MS_MS_DEFAULT);\n+\n+        PowerMock.verifyAll();\n+    }\n+\n+    @Test\n+    public void testKeyRotationDisabledWhenWorkerBecomesFollower() throws Exception {\n+        EasyMock.expect(member.memberId()).andStubReturn(\"member\");\n+        EasyMock.expect(member.currentProtocolVersion()).andStubReturn(CONNECT_PROTOCOL_V2);\n+\n+        expectRebalance(1, Collections.emptyList(), Collections.emptyList(), \"member\", MEMBER_URL);\n+        SecretKey initialSecretKey = EasyMock.mock(SecretKey.class);\n+        EasyMock.expect(initialSecretKey.getAlgorithm()).andReturn(DistributedConfig.INTER_WORKER_KEY_GENERATION_ALGORITHM_DEFAULT).anyTimes();\n+        EasyMock.expect(initialSecretKey.getEncoded()).andReturn(new byte[32]).anyTimes();\n+        SessionKey initialKey = new SessionKey(initialSecretKey, time.milliseconds());\n+        ClusterConfigState snapshotWithKey =  new ClusterConfigState(1, initialKey, Collections.singletonMap(CONN1, 3),\n+            Collections.singletonMap(CONN1, CONN1_CONFIG), Collections.singletonMap(CONN1, TargetState.STARTED),\n+            TASK_CONFIGS_MAP, Collections.<String>emptySet());\n+        expectPostRebalanceCatchup(snapshotWithKey);\n+        // First rebalance: poll for a limited time as worker is leader and must wake up for key expiration\n+        Capture<Long> firstPollTimeout = EasyMock.newCapture();\n+        member.poll(EasyMock.captureLong(firstPollTimeout));\n+        EasyMock.expectLastCall();\n+\n+        expectRebalance(1, Collections.emptyList(), Collections.emptyList());\n+        // Second rebalance: poll indefinitely as worker is no longer leader, so key expiration doesn't come into play\n+        member.poll(Long.MAX_VALUE);\n+        EasyMock.expectLastCall();\n+\n+        PowerMock.replayAll(initialSecretKey);\n+\n+        configUpdateListener.onSessionKeyUpdate(initialKey);\n+        herder.tick();\n+        assertTrue(firstPollTimeout.getValue() <= DistributedConfig.INTER_WORKER_KEY_TTL_MS_MS_DEFAULT);\n+        herder.tick();\n+\n+        PowerMock.verifyAll();\n+    }\n \n     @Test\n     public void testPutTaskConfigsSignatureNotRequiredV0() {\n@@ -2229,6 +2309,14 @@ private void expectRebalance(final long offset,\n                 ConnectProtocol.Assignment.NO_ERROR, offset, assignedConnectors, assignedTasks, 0);\n     }\n \n+    private void expectRebalance(final long offset,\n+                                 final List<String> assignedConnectors,\n+                                 final List<ConnectorTaskId> assignedTasks,\n+                                 String leader, String leaderUrl) {\n+        expectRebalance(Collections.emptyList(), Collections.emptyList(),\n+                ConnectProtocol.Assignment.NO_ERROR, offset, leader, leaderUrl, assignedConnectors, assignedTasks, 0);\n+    }\n+\n     // Handles common initial part of rebalance callback. Does not handle instantiation of connectors and tasks.\n     private void expectRebalance(final Collection<String> revokedConnectors,\n                                  final List<ConnectorTaskId> revokedTasks,\n@@ -2247,21 +2335,34 @@ private void expectRebalance(final Collection<String> revokedConnectors,\n                                  final List<String> assignedConnectors,\n                                  final List<ConnectorTaskId> assignedTasks,\n                                  int delay) {\n+        expectRebalance(revokedConnectors, revokedTasks, error, offset, \"leader\", \"leaderUrl\", assignedConnectors, assignedTasks, delay);\n+    }\n+\n+    // Handles common initial part of rebalance callback. Does not handle instantiation of connectors and tasks.\n+    private void expectRebalance(final Collection<String> revokedConnectors,\n+                                 final List<ConnectorTaskId> revokedTasks,\n+                                 final short error,\n+                                 final long offset,\n+                                 String leader,\n+                                 String leaderUrl,\n+                                 final List<String> assignedConnectors,\n+                                 final List<ConnectorTaskId> assignedTasks,\n+                                 int delay) {\n         member.ensureActive();\n         PowerMock.expectLastCall().andAnswer(() -> {\n             ExtendedAssignment assignment;\n             if (!revokedConnectors.isEmpty() || !revokedTasks.isEmpty()) {\n-                rebalanceListener.onRevoked(\"leader\", revokedConnectors, revokedTasks);\n+                rebalanceListener.onRevoked(leader, revokedConnectors, revokedTasks);\n             }\n \n             if (connectProtocolVersion == CONNECT_PROTOCOL_V0) {\n                 assignment = new ExtendedAssignment(\n-                        connectProtocolVersion, error, \"leader\", \"leaderUrl\", offset,\n+                        connectProtocolVersion, error, leader, leaderUrl, offset,\n                         assignedConnectors, assignedTasks,\n                         Collections.emptyList(), Collections.emptyList(), 0);\n             } else {\n                 assignment = new ExtendedAssignment(\n-                        connectProtocolVersion, error, \"leader\", \"leaderUrl\", offset,\n+                        connectProtocolVersion, error, leader, leaderUrl, offset,\n                         assignedConnectors, assignedTasks,\n                         new ArrayList<>(revokedConnectors), new ArrayList<>(revokedTasks), delay);\n             }"
  }
]
