[
  {
    "sha": "6fa408deac1436fad35ca60e06d4f68fd965d622",
    "filename": "engine/src/main/java/io/zeebe/engine/processing/EngineProcessors.java",
    "status": "modified",
    "additions": 7,
    "deletions": 4,
    "changes": 11,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/EngineProcessors.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/EngineProcessors.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/processing/EngineProcessors.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -63,13 +63,15 @@ public static TypedRecordProcessors createEngineProcessors(\n         new ExpressionProcessor(\n             ExpressionLanguageFactory.createExpressionLanguage(), variablesState::getVariable);\n \n+    final DueDateTimerChecker timerChecker = new DueDateTimerChecker(zeebeState.getTimerState());\n     final CatchEventBehavior catchEventBehavior =\n         new CatchEventBehavior(\n             zeebeState,\n             expressionProcessor,\n             subscriptionCommandSender,\n             writers.state(),\n-            partitionsCount);\n+            partitionsCount,\n+            timerChecker);\n \n     addDeploymentRelatedProcessorAndServices(\n         catchEventBehavior,\n@@ -92,7 +94,8 @@ public static TypedRecordProcessors createEngineProcessors(\n             typedRecordProcessors,\n             subscriptionCommandSender,\n             catchEventBehavior,\n-            writers);\n+            writers,\n+            timerChecker);\n \n     addJobProcessors(\n         zeebeState, typedRecordProcessors, onJobsAvailableCallback, maxFragmentSize, writers);\n@@ -108,8 +111,8 @@ public static TypedRecordProcessors createEngineProcessors(\n       final TypedRecordProcessors typedRecordProcessors,\n       final SubscriptionCommandSender subscriptionCommandSender,\n       final CatchEventBehavior catchEventBehavior,\n-      final Writers writers) {\n-    final DueDateTimerChecker timerChecker = new DueDateTimerChecker(zeebeState.getTimerState());\n+      final Writers writers,\n+      final DueDateTimerChecker timerChecker) {\n     return ProcessEventProcessors.addProcessProcessors(\n         zeebeState,\n         expressionProcessor,"
  },
  {
    "sha": "7ffe405a223183d3086739bdc247cae1dcbdf9be",
    "filename": "engine/src/main/java/io/zeebe/engine/processing/ProcessEventProcessors.java",
    "status": "modified",
    "additions": 16,
    "deletions": 7,
    "changes": 23,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/ProcessEventProcessors.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/ProcessEventProcessors.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/processing/ProcessEventProcessors.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -23,7 +23,6 @@\n import io.zeebe.engine.processing.streamprocessor.writers.StateWriter;\n import io.zeebe.engine.processing.streamprocessor.writers.Writers;\n import io.zeebe.engine.processing.timer.CancelTimerProcessor;\n-import io.zeebe.engine.processing.timer.CreateTimerProcessor;\n import io.zeebe.engine.processing.timer.DueDateTimerChecker;\n import io.zeebe.engine.processing.timer.TriggerTimerProcessor;\n import io.zeebe.engine.processing.variable.UpdateVariableDocumentProcessor;\n@@ -68,7 +67,12 @@\n     addMessageStreamProcessors(\n         typedRecordProcessors, subscriptionState, subscriptionCommandSender, zeebeState, writers);\n     addTimerStreamProcessors(\n-        typedRecordProcessors, timerChecker, zeebeState, catchEventBehavior, expressionProcessor);\n+        typedRecordProcessors,\n+        timerChecker,\n+        zeebeState,\n+        catchEventBehavior,\n+        expressionProcessor,\n+        writers);\n     addVariableDocumentStreamProcessors(\n         typedRecordProcessors,\n         variableBehavior,\n@@ -146,19 +150,24 @@ private static void addTimerStreamProcessors(\n       final DueDateTimerChecker timerChecker,\n       final MutableZeebeState zeebeState,\n       final CatchEventBehavior catchEventOutput,\n-      final ExpressionProcessor expressionProcessor) {\n+      final ExpressionProcessor expressionProcessor,\n+      final Writers writers) {\n \n     typedRecordProcessors\n-        .onCommand(\n-            ValueType.TIMER, TimerIntent.CREATE, new CreateTimerProcessor(zeebeState, timerChecker))\n         .onCommand(\n             ValueType.TIMER,\n             TimerIntent.TRIGGER,\n-            new TriggerTimerProcessor(zeebeState, catchEventOutput, expressionProcessor))\n+            new TriggerTimerProcessor(\n+                zeebeState,\n+                catchEventOutput,\n+                expressionProcessor,\n+                writers.state(),\n+                writers.rejection()))\n         .onCommand(\n             ValueType.TIMER,\n             TimerIntent.CANCEL,\n-            new CancelTimerProcessor(zeebeState.getTimerState()))\n+            new CancelTimerProcessor(\n+                zeebeState.getTimerState(), writers.state(), writers.rejection()))\n         .withListener(timerChecker);\n   }\n "
  },
  {
    "sha": "b6ddd386b144a8993f865261e6e526204d24d89e",
    "filename": "engine/src/main/java/io/zeebe/engine/processing/bpmn/behavior/BpmnEventSubscriptionBehavior.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/bpmn/behavior/BpmnEventSubscriptionBehavior.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/bpmn/behavior/BpmnEventSubscriptionBehavior.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/processing/bpmn/behavior/BpmnEventSubscriptionBehavior.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -94,7 +94,7 @@ public BpmnEventSubscriptionBehavior(\n       final T element, final BpmnElementContext context) {\n \n     try {\n-      catchEventBehavior.subscribeToEvents(context, element, commandWriter, sideEffects);\n+      catchEventBehavior.subscribeToEvents(context, element, sideEffects);\n       return Either.right(null);\n \n     } catch (final MessageCorrelationKeyException e) {"
  },
  {
    "sha": "10c357466a207c4c441b6eb0039cecd617b853a5",
    "filename": "engine/src/main/java/io/zeebe/engine/processing/common/CatchEventBehavior.java",
    "status": "modified",
    "additions": 22,
    "deletions": 6,
    "changes": 28,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/common/CatchEventBehavior.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/common/CatchEventBehavior.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/processing/common/CatchEventBehavior.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -20,9 +20,12 @@\n import io.zeebe.engine.processing.message.MessageNameException;\n import io.zeebe.engine.processing.message.command.SubscriptionCommandSender;\n import io.zeebe.engine.processing.streamprocessor.MigratedStreamProcessors;\n+import io.zeebe.engine.processing.streamprocessor.sideeffect.SideEffectProducer;\n import io.zeebe.engine.processing.streamprocessor.sideeffect.SideEffects;\n import io.zeebe.engine.processing.streamprocessor.writers.StateWriter;\n import io.zeebe.engine.processing.streamprocessor.writers.TypedCommandWriter;\n+import io.zeebe.engine.processing.timer.DueDateTimerChecker;\n+import io.zeebe.engine.state.KeyGenerator;\n import io.zeebe.engine.state.immutable.TimerInstanceState;\n import io.zeebe.engine.state.instance.TimerInstance;\n import io.zeebe.engine.state.message.ProcessMessageSubscription;\n@@ -42,6 +45,7 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.function.Consumer;\n import org.agrona.DirectBuffer;\n \n public final class CatchEventBehavior {\n@@ -50,10 +54,12 @@\n   private final SubscriptionCommandSender subscriptionCommandSender;\n   private final int partitionsCount;\n   private final StateWriter stateWriter;\n+  private final DueDateTimerChecker dueDateTimerChecker;\n \n   private final MutableEventScopeInstanceState eventScopeInstanceState;\n   private final MutableProcessMessageSubscriptionState processMessageSubscriptionState;\n   private final TimerInstanceState timerInstanceState;\n+  private final KeyGenerator keyGenerator;\n \n   private final ProcessMessageSubscriptionRecord subscription =\n       new ProcessMessageSubscriptionRecord();\n@@ -66,15 +72,18 @@ public CatchEventBehavior(\n       final ExpressionProcessor expressionProcessor,\n       final SubscriptionCommandSender subscriptionCommandSender,\n       final StateWriter stateWriter,\n-      final int partitionsCount) {\n+      final int partitionsCount,\n+      final DueDateTimerChecker dueDateTimerChecker) {\n     this.expressionProcessor = expressionProcessor;\n     this.subscriptionCommandSender = subscriptionCommandSender;\n     this.stateWriter = stateWriter;\n     this.partitionsCount = partitionsCount;\n+    this.dueDateTimerChecker = dueDateTimerChecker;\n \n     eventScopeInstanceState = zeebeState.getEventScopeInstanceState();\n     timerInstanceState = zeebeState.getTimerState();\n     processMessageSubscriptionState = zeebeState.getProcessMessageSubscriptionState();\n+    keyGenerator = zeebeState.getKeyGenerator();\n   }\n \n   public void unsubscribeFromEvents(\n@@ -94,7 +103,6 @@ public void unsubscribeFromEvents(\n   public void subscribeToEvents(\n       final BpmnElementContext context,\n       final ExecutableCatchEventSupplier supplier,\n-      final TypedCommandWriter commandWriter,\n       final SideEffects sideEffects)\n       throws MessageCorrelationKeyException {\n \n@@ -120,7 +128,7 @@ public void subscribeToEvents(\n             context.getProcessDefinitionKey(),\n             event.getId(),\n             evaluatedTimers.get(event.getId()),\n-            commandWriter);\n+            sideEffects::add);\n       } else if (event.isMessage()) {\n         subscribeToMessageEvent(\n             context,\n@@ -144,16 +152,24 @@ public void subscribeToTimerEvent(\n       final long processDefinitionKey,\n       final DirectBuffer handlerNodeId,\n       final Timer timer,\n-      final TypedCommandWriter commandWriter) {\n+      final Consumer<SideEffectProducer> sideEffects) {\n+    final long dueDate = timer.getDueDate(ActorClock.currentTimeMillis());\n     timerRecord.reset();\n     timerRecord\n         .setRepetitions(timer.getRepetitions())\n-        .setDueDate(timer.getDueDate(ActorClock.currentTimeMillis()))\n+        .setDueDate(dueDate)\n         .setElementInstanceKey(elementInstanceKey)\n         .setProcessInstanceKey(processInstanceKey)\n         .setTargetElementId(handlerNodeId)\n         .setProcessDefinitionKey(processDefinitionKey);\n-    commandWriter.appendNewCommand(TimerIntent.CREATE, timerRecord);\n+\n+    final long timerKey = keyGenerator.nextKey();\n+    sideEffects.accept(\n+        () -> {\n+          dueDateTimerChecker.scheduleTimer(dueDate);\n+          return true;\n+        });\n+    stateWriter.appendFollowUpEvent(timerKey, TimerIntent.CREATED, timerRecord);\n   }\n \n   private void unsubscribeFromTimerEvents("
  },
  {
    "sha": "937d7f1792a7caf85ab19384f7d4f1b17cb9e7fb",
    "filename": "engine/src/main/java/io/zeebe/engine/processing/deployment/DeploymentCreateProcessor.java",
    "status": "modified",
    "additions": 5,
    "deletions": 3,
    "changes": 8,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/deployment/DeploymentCreateProcessor.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/deployment/DeploymentCreateProcessor.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/processing/deployment/DeploymentCreateProcessor.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -91,7 +91,7 @@ public void processRecord(\n       final long key = keyGenerator.nextKey();\n \n       try {\n-        createTimerIfTimerStartEvent(command, streamWriter);\n+        createTimerIfTimerStartEvent(command, streamWriter, sideEffect);\n       } catch (final RuntimeException e) {\n         final String reason = String.format(COULD_NOT_CREATE_TIMER_MESSAGE, e.getMessage());\n         responseWriter.writeRejectionOnCommand(command, RejectionType.PROCESSING_ERROR, reason);\n@@ -119,7 +119,9 @@ public void processRecord(\n   }\n \n   private void createTimerIfTimerStartEvent(\n-      final TypedRecord<DeploymentRecord> record, final TypedStreamWriter streamWriter) {\n+      final TypedRecord<DeploymentRecord> record,\n+      final TypedStreamWriter streamWriter,\n+      Consumer<SideEffectProducer> sideEffects) {\n     for (final ProcessRecord processRecord : record.getValue().processes()) {\n       final List<ExecutableStartEvent> startEvents =\n           processState.getProcessByKey(processRecord.getKey()).getProcess().getStartEvents();\n@@ -144,7 +146,7 @@ private void createTimerIfTimerStartEvent(\n               processRecord.getKey(),\n               startEvent.getId(),\n               timerOrError.get(),\n-              streamWriter);\n+              sideEffects);\n         }\n       }\n     }"
  },
  {
    "sha": "8f3c90b7e731d43358cfd3ef96b5463227d6d591",
    "filename": "engine/src/main/java/io/zeebe/engine/processing/streamprocessor/MigratedStreamProcessors.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/streamprocessor/MigratedStreamProcessors.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/streamprocessor/MigratedStreamProcessors.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/processing/streamprocessor/MigratedStreamProcessors.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -76,6 +76,7 @@\n     MIGRATED_VALUE_TYPES.put(ValueType.VARIABLE_DOCUMENT, MIGRATED);\n     MIGRATED_VALUE_TYPES.put(ValueType.VARIABLE, MIGRATED);\n     MIGRATED_VALUE_TYPES.put(ValueType.INCIDENT, MIGRATED);\n+    MIGRATED_VALUE_TYPES.put(ValueType.TIMER, MIGRATED);\n   }\n \n   private MigratedStreamProcessors() {}"
  },
  {
    "sha": "bbbf84f4b01f88d874869eadb7153f2ed72f9abf",
    "filename": "engine/src/main/java/io/zeebe/engine/processing/timer/CancelTimerProcessor.java",
    "status": "modified",
    "additions": 14,
    "deletions": 6,
    "changes": 20,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/timer/CancelTimerProcessor.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/timer/CancelTimerProcessor.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/processing/timer/CancelTimerProcessor.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -9,10 +9,12 @@\n \n import io.zeebe.engine.processing.streamprocessor.TypedRecord;\n import io.zeebe.engine.processing.streamprocessor.TypedRecordProcessor;\n+import io.zeebe.engine.processing.streamprocessor.writers.StateWriter;\n+import io.zeebe.engine.processing.streamprocessor.writers.TypedRejectionWriter;\n import io.zeebe.engine.processing.streamprocessor.writers.TypedResponseWriter;\n import io.zeebe.engine.processing.streamprocessor.writers.TypedStreamWriter;\n+import io.zeebe.engine.state.immutable.TimerInstanceState;\n import io.zeebe.engine.state.instance.TimerInstance;\n-import io.zeebe.engine.state.mutable.MutableTimerInstanceState;\n import io.zeebe.protocol.impl.record.value.timer.TimerRecord;\n import io.zeebe.protocol.record.RejectionType;\n import io.zeebe.protocol.record.intent.TimerIntent;\n@@ -21,10 +23,17 @@\n   public static final String NO_TIMER_FOUND_MESSAGE =\n       \"Expected to cancel timer with key '%d', but no such timer was found\";\n \n-  private final MutableTimerInstanceState timerInstanceState;\n+  private final TimerInstanceState timerInstanceState;\n+  private final StateWriter stateWriter;\n+  private final TypedRejectionWriter rejectionWriter;\n \n-  public CancelTimerProcessor(final MutableTimerInstanceState timerInstanceState) {\n+  public CancelTimerProcessor(\n+      final TimerInstanceState timerInstanceState,\n+      final StateWriter stateWriter,\n+      final TypedRejectionWriter rejectionWriter) {\n     this.timerInstanceState = timerInstanceState;\n+    this.stateWriter = stateWriter;\n+    this.rejectionWriter = rejectionWriter;\n   }\n \n   @Override\n@@ -37,11 +46,10 @@ public void processRecord(\n         timerInstanceState.get(timer.getElementInstanceKey(), record.getKey());\n \n     if (timerInstance == null) {\n-      streamWriter.appendRejection(\n+      rejectionWriter.appendRejection(\n           record, RejectionType.NOT_FOUND, String.format(NO_TIMER_FOUND_MESSAGE, record.getKey()));\n     } else {\n-      streamWriter.appendFollowUpEvent(record.getKey(), TimerIntent.CANCELED, timer);\n-      timerInstanceState.remove(timerInstance);\n+      stateWriter.appendFollowUpEvent(record.getKey(), TimerIntent.CANCELED, timer);\n     }\n   }\n }"
  },
  {
    "sha": "3538c48eba0c2beb173f2af733a5621e575df75a",
    "filename": "engine/src/main/java/io/zeebe/engine/processing/timer/CreateTimerProcessor.java",
    "status": "removed",
    "additions": 0,
    "deletions": 69,
    "changes": 69,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/c5249267435844fb6e67be803bb3aec8f977ff87/engine/src/main/java/io/zeebe/engine/processing/timer/CreateTimerProcessor.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/c5249267435844fb6e67be803bb3aec8f977ff87/engine/src/main/java/io/zeebe/engine/processing/timer/CreateTimerProcessor.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/processing/timer/CreateTimerProcessor.java?ref=c5249267435844fb6e67be803bb3aec8f977ff87",
    "patch": "@@ -1,69 +0,0 @@\n-/*\n- * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n- * one or more contributor license agreements. See the NOTICE file distributed\n- * with this work for additional information regarding copyright ownership.\n- * Licensed under the Zeebe Community License 1.1. You may not use this file\n- * except in compliance with the Zeebe Community License 1.1.\n- */\n-package io.zeebe.engine.processing.timer;\n-\n-import io.zeebe.engine.processing.streamprocessor.TypedRecord;\n-import io.zeebe.engine.processing.streamprocessor.TypedRecordProcessor;\n-import io.zeebe.engine.processing.streamprocessor.sideeffect.SideEffectProducer;\n-import io.zeebe.engine.processing.streamprocessor.writers.TypedResponseWriter;\n-import io.zeebe.engine.processing.streamprocessor.writers.TypedStreamWriter;\n-import io.zeebe.engine.state.KeyGenerator;\n-import io.zeebe.engine.state.instance.TimerInstance;\n-import io.zeebe.engine.state.mutable.MutableTimerInstanceState;\n-import io.zeebe.engine.state.mutable.MutableZeebeState;\n-import io.zeebe.protocol.impl.record.value.timer.TimerRecord;\n-import io.zeebe.protocol.record.intent.TimerIntent;\n-import java.util.function.Consumer;\n-\n-public final class CreateTimerProcessor implements TypedRecordProcessor<TimerRecord> {\n-\n-  private final DueDateTimerChecker timerChecker;\n-\n-  private final MutableTimerInstanceState timerInstanceState;\n-  private final TimerInstance timerInstance = new TimerInstance();\n-  private final KeyGenerator keyGenerator;\n-\n-  public CreateTimerProcessor(\n-      final MutableZeebeState zeebeState, final DueDateTimerChecker timerChecker) {\n-    this.timerChecker = timerChecker;\n-    timerInstanceState = zeebeState.getTimerState();\n-    keyGenerator = zeebeState.getKeyGenerator();\n-  }\n-\n-  @Override\n-  public void processRecord(\n-      final TypedRecord<TimerRecord> record,\n-      final TypedResponseWriter responseWriter,\n-      final TypedStreamWriter streamWriter,\n-      final Consumer<SideEffectProducer> sideEffect) {\n-\n-    final TimerRecord timer = record.getValue();\n-\n-    final long timerKey = keyGenerator.nextKey();\n-\n-    timerInstance.setElementInstanceKey(timer.getElementInstanceKey());\n-    timerInstance.setDueDate(timer.getDueDate());\n-    timerInstance.setKey(timerKey);\n-    timerInstance.setHandlerNodeId(timer.getTargetElementIdBuffer());\n-    timerInstance.setRepetitions(timer.getRepetitions());\n-    timerInstance.setProcessDefinitionKey(timer.getProcessDefinitionKey());\n-    timerInstance.setProcessInstanceKey(timer.getProcessInstanceKey());\n-\n-    sideEffect.accept(this::scheduleTimer);\n-\n-    streamWriter.appendFollowUpEvent(timerKey, TimerIntent.CREATED, timer);\n-\n-    timerInstanceState.put(timerInstance);\n-  }\n-\n-  private boolean scheduleTimer() {\n-    timerChecker.scheduleTimer(timerInstance);\n-\n-    return true;\n-  }\n-}"
  },
  {
    "sha": "f5210f3642d15ce61ba19625c1859fc74655230b",
    "filename": "engine/src/main/java/io/zeebe/engine/processing/timer/DueDateTimerChecker.java",
    "status": "modified",
    "additions": 5,
    "deletions": 6,
    "changes": 11,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/timer/DueDateTimerChecker.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/timer/DueDateTimerChecker.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/processing/timer/DueDateTimerChecker.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -36,7 +36,7 @@ public DueDateTimerChecker(final TimerInstanceState timerInstanceState) {\n     this.timerInstanceState = timerInstanceState;\n   }\n \n-  public void scheduleTimer(final TimerInstance timer) {\n+  public void scheduleTimer(final long dueDate) {\n \n     // We schedule only one runnable for all timers.\n     // - The runnable is scheduled when the first timer is scheduled.\n@@ -45,18 +45,17 @@ public void scheduleTimer(final TimerInstance timer) {\n     // - Otherwise, we don't need to cancel the runnable. It will be rescheduled when it is\n     // executed.\n \n-    final Duration duration =\n-        Duration.ofMillis(timer.getDueDate() - ActorClock.currentTimeMillis());\n+    final Duration duration = Duration.ofMillis(dueDate - ActorClock.currentTimeMillis());\n \n     if (scheduledTimer == null) {\n       scheduledTimer = actor.runDelayed(duration, this::triggerTimers);\n-      nextDueDate = timer.getDueDate();\n+      nextDueDate = dueDate;\n \n-    } else if (nextDueDate - timer.getDueDate() > TIMER_RESOLUTION) {\n+    } else if (nextDueDate - dueDate > TIMER_RESOLUTION) {\n       scheduledTimer.cancel();\n \n       scheduledTimer = actor.runDelayed(duration, this::triggerTimers);\n-      nextDueDate = timer.getDueDate();\n+      nextDueDate = dueDate;\n     }\n   }\n "
  },
  {
    "sha": "27d1b80f4c749136bb194a455a0aeecdb5e849b3",
    "filename": "engine/src/main/java/io/zeebe/engine/processing/timer/TriggerTimerProcessor.java",
    "status": "modified",
    "additions": 103,
    "deletions": 59,
    "changes": 162,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/timer/TriggerTimerProcessor.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/processing/timer/TriggerTimerProcessor.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/processing/timer/TriggerTimerProcessor.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -8,138 +8,177 @@\n package io.zeebe.engine.processing.timer;\n \n import io.zeebe.engine.processing.common.CatchEventBehavior;\n-import io.zeebe.engine.processing.common.EventHandle;\n import io.zeebe.engine.processing.common.ExpressionProcessor;\n import io.zeebe.engine.processing.common.Failure;\n import io.zeebe.engine.processing.deployment.model.element.ExecutableCatchEvent;\n+import io.zeebe.engine.processing.deployment.model.element.ExecutableFlowElement;\n+import io.zeebe.engine.processing.deployment.model.element.ExecutableStartEvent;\n import io.zeebe.engine.processing.streamprocessor.TypedRecord;\n import io.zeebe.engine.processing.streamprocessor.TypedRecordProcessor;\n+import io.zeebe.engine.processing.streamprocessor.sideeffect.SideEffectProducer;\n+import io.zeebe.engine.processing.streamprocessor.writers.StateWriter;\n+import io.zeebe.engine.processing.streamprocessor.writers.TypedRejectionWriter;\n import io.zeebe.engine.processing.streamprocessor.writers.TypedResponseWriter;\n import io.zeebe.engine.processing.streamprocessor.writers.TypedStreamWriter;\n+import io.zeebe.engine.state.KeyGenerator;\n import io.zeebe.engine.state.immutable.ElementInstanceState;\n+import io.zeebe.engine.state.immutable.EventScopeInstanceState;\n import io.zeebe.engine.state.immutable.ProcessState;\n-import io.zeebe.engine.state.instance.TimerInstance;\n import io.zeebe.engine.state.mutable.MutableTimerInstanceState;\n import io.zeebe.engine.state.mutable.MutableZeebeState;\n import io.zeebe.model.bpmn.util.time.Interval;\n import io.zeebe.model.bpmn.util.time.RepeatingInterval;\n import io.zeebe.model.bpmn.util.time.Timer;\n+import io.zeebe.protocol.impl.record.value.processinstance.ProcessInstanceRecord;\n import io.zeebe.protocol.impl.record.value.timer.TimerRecord;\n import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.intent.ProcessInstanceIntent;\n import io.zeebe.protocol.record.intent.TimerIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n import io.zeebe.util.Either;\n import io.zeebe.util.buffer.BufferUtil;\n-import org.agrona.DirectBuffer;\n-import org.agrona.concurrent.UnsafeBuffer;\n+import java.util.function.Consumer;\n \n public final class TriggerTimerProcessor implements TypedRecordProcessor<TimerRecord> {\n+\n   private static final String NO_TIMER_FOUND_MESSAGE =\n       \"Expected to trigger timer with key '%d', but no such timer was found\";\n   private static final String NO_ACTIVE_TIMER_MESSAGE =\n       \"Expected to trigger a timer with key '%d', but the timer is not active anymore\";\n \n-  private static final DirectBuffer NO_VARIABLES = new UnsafeBuffer();\n-\n   private final CatchEventBehavior catchEventBehavior;\n   private final ProcessState processState;\n   private final ElementInstanceState elementInstanceState;\n   private final MutableTimerInstanceState timerInstanceState;\n-  private final EventHandle eventHandle;\n   private final ExpressionProcessor expressionProcessor;\n+  private final KeyGenerator keyGenerator;\n+  private final EventScopeInstanceState eventScopeInstanceState;\n+  private final StateWriter stateWriter;\n+  private final TypedRejectionWriter rejectionWriter;\n+\n+  private final ProcessInstanceRecord eventOccurredRecord = new ProcessInstanceRecord();\n \n   public TriggerTimerProcessor(\n       final MutableZeebeState zeebeState,\n       final CatchEventBehavior catchEventBehavior,\n-      final ExpressionProcessor expressionProcessor) {\n+      final ExpressionProcessor expressionProcessor,\n+      final StateWriter stateWriter,\n+      final TypedRejectionWriter rejectionWriter) {\n     this.catchEventBehavior = catchEventBehavior;\n     this.expressionProcessor = expressionProcessor;\n+    this.stateWriter = stateWriter;\n+    this.rejectionWriter = rejectionWriter;\n+\n     processState = zeebeState.getProcessState();\n     elementInstanceState = zeebeState.getElementInstanceState();\n     timerInstanceState = zeebeState.getTimerState();\n-\n-    eventHandle =\n-        new EventHandle(zeebeState.getKeyGenerator(), zeebeState.getEventScopeInstanceState());\n+    keyGenerator = zeebeState.getKeyGenerator();\n+    eventScopeInstanceState = zeebeState.getEventScopeInstanceState();\n   }\n \n   @Override\n   public void processRecord(\n       final TypedRecord<TimerRecord> record,\n       final TypedResponseWriter responseWriter,\n-      final TypedStreamWriter streamWriter) {\n-    final TimerRecord timer = record.getValue();\n-    final long elementInstanceKey = timer.getElementInstanceKey();\n+      final TypedStreamWriter streamWriter,\n+      final Consumer<SideEffectProducer> sideEffects) {\n+    final var timer = record.getValue();\n+    final var elementInstanceKey = timer.getElementInstanceKey();\n+    final var processDefinitionKey = timer.getProcessDefinitionKey();\n \n-    final TimerInstance timerInstance = timerInstanceState.get(elementInstanceKey, record.getKey());\n+    final var timerInstance = timerInstanceState.get(elementInstanceKey, record.getKey());\n     if (timerInstance == null) {\n-      streamWriter.appendRejection(\n+      rejectionWriter.appendRejection(\n           record, RejectionType.NOT_FOUND, String.format(NO_TIMER_FOUND_MESSAGE, record.getKey()));\n       return;\n     }\n-    timerInstanceState.remove(timerInstance);\n-\n-    processTimerTrigger(record, streamWriter, timer, elementInstanceKey);\n-  }\n \n-  private void processTimerTrigger(\n-      final TypedRecord<TimerRecord> record,\n-      final TypedStreamWriter streamWriter,\n-      final TimerRecord timer,\n-      final long elementInstanceKey) {\n+    if (!hasActiveTimer(elementInstanceKey, processDefinitionKey)) {\n+      rejectionWriter.appendRejection(\n+          record,\n+          RejectionType.INVALID_STATE,\n+          String.format(NO_ACTIVE_TIMER_MESSAGE, record.getKey()));\n+      return;\n+    }\n \n-    final var processDefinitionKey = timer.getProcessDefinitionKey();\n+    final long eventOccurredKey;\n     final var catchEvent =\n         processState.getFlowElement(\n             processDefinitionKey, timer.getTargetElementIdBuffer(), ExecutableCatchEvent.class);\n \n-    final boolean isTriggered =\n-        triggerEvent(streamWriter, timer, elementInstanceKey, processDefinitionKey, catchEvent);\n+    eventOccurredRecord.reset();\n+    if (isStartEvent(elementInstanceKey)) {\n+      eventOccurredKey = prepareStartEventOccurred(timer, processDefinitionKey);\n+    } else {\n+      eventOccurredKey = prepareIntermediateEventOccurred(elementInstanceKey, catchEvent);\n+    }\n \n-    if (isTriggered) {\n-      streamWriter.appendFollowUpEvent(record.getKey(), TimerIntent.TRIGGERED, timer);\n+    stateWriter.appendFollowUpEvent(record.getKey(), TimerIntent.TRIGGERED, timer);\n+    stateWriter.appendFollowUpEvent(\n+        eventOccurredKey, ProcessInstanceIntent.EVENT_OCCURRED, eventOccurredRecord);\n \n-      if (shouldReschedule(timer)) {\n-        rescheduleTimer(timer, streamWriter, catchEvent);\n-      }\n-    } else {\n-      streamWriter.appendRejection(\n-          record,\n-          RejectionType.INVALID_STATE,\n-          String.format(NO_ACTIVE_TIMER_MESSAGE, record.getKey()));\n+    if (shouldReschedule(timer)) {\n+      rescheduleTimer(timer, catchEvent, sideEffects);\n     }\n   }\n \n-  private boolean triggerEvent(\n-      final TypedStreamWriter streamWriter,\n-      final TimerRecord timer,\n-      final long elementInstanceKey,\n-      final long processDefinitionKey,\n-      final ExecutableCatchEvent catchEvent) {\n-\n-    if (elementInstanceKey > 0) {\n-      final var elementInstance = elementInstanceState.getInstance(elementInstanceKey);\n+  private long prepareIntermediateEventOccurred(\n+      final long elementInstanceKey, final ExecutableCatchEvent catchEvent) {\n+    final long eventOccurredKey;\n+    final var elementInstance = elementInstanceState.getInstance(elementInstanceKey);\n+\n+    eventOccurredRecord.wrap(elementInstance.getValue());\n+    if (isEventSubprocess(catchEvent)) {\n+      eventOccurredKey = keyGenerator.nextKey();\n+      eventOccurredRecord\n+          .setElementId(catchEvent.getId())\n+          .setBpmnElementType(BpmnElementType.START_EVENT)\n+          .setFlowScopeKey(elementInstance.getKey());\n+    } else {\n+      eventOccurredKey = elementInstanceKey;\n+    }\n \n-      if (elementInstance != null && elementInstance.isActive()) {\n-        return eventHandle.triggerEvent(streamWriter, elementInstance, catchEvent, NO_VARIABLES);\n+    return eventOccurredKey;\n+  }\n \n-      } else {\n-        return false;\n-      }\n+  private long prepareStartEventOccurred(final TimerRecord timer, final long processDefinitionKey) {\n+    final long eventOccurredKey;\n+    final var processInstanceKey = keyGenerator.nextKey();\n+    eventOccurredKey = keyGenerator.nextKey();\n+    eventOccurredRecord\n+        .setBpmnElementType(BpmnElementType.START_EVENT)\n+        .setProcessDefinitionKey(processDefinitionKey)\n+        .setProcessInstanceKey(processInstanceKey)\n+        .setElementId(timer.getTargetElementIdBuffer());\n+    return eventOccurredKey;\n+  }\n \n+  private boolean hasActiveTimer(final long elementInstanceKey, final long processDefinitionKey) {\n+    final boolean result;\n+    if (isStartEvent(elementInstanceKey)) {\n+      result = eventScopeInstanceState.isAcceptingEvent(processDefinitionKey);\n     } else {\n-      final var processInstanceKey =\n-          eventHandle.triggerStartEvent(\n-              streamWriter, processDefinitionKey, timer.getTargetElementIdBuffer(), NO_VARIABLES);\n-\n-      return processInstanceKey > 0;\n+      final var elementInstance = elementInstanceState.getInstance(elementInstanceKey);\n+      result =\n+          (elementInstance != null\n+              && elementInstance.isActive()\n+              && eventScopeInstanceState.isAcceptingEvent(elementInstanceKey));\n     }\n+    return result;\n+  }\n+\n+  private boolean isStartEvent(final long elementInstanceKey) {\n+    return elementInstanceKey < 0;\n   }\n \n   private boolean shouldReschedule(final TimerRecord timer) {\n     return timer.getRepetitions() == RepeatingInterval.INFINITE || timer.getRepetitions() > 1;\n   }\n \n   private void rescheduleTimer(\n-      final TimerRecord record, final TypedStreamWriter writer, final ExecutableCatchEvent event) {\n+      final TimerRecord record,\n+      final ExecutableCatchEvent event,\n+      final Consumer<SideEffectProducer> sideEffects) {\n     final Either<Failure, Timer> timer =\n         event.getTimerFactory().apply(expressionProcessor, record.getElementInstanceKey());\n     if (timer.isLeft()) {\n@@ -164,6 +203,11 @@ private void rescheduleTimer(\n         record.getProcessDefinitionKey(),\n         event.getId(),\n         repeatingInterval,\n-        writer);\n+        sideEffects);\n+  }\n+\n+  private boolean isEventSubprocess(final ExecutableFlowElement catchEvent) {\n+    return catchEvent instanceof ExecutableStartEvent\n+        && ((ExecutableStartEvent) catchEvent).getEventSubProcess() != null;\n   }\n }"
  },
  {
    "sha": "b8e015f3f198070592d83acac0dc77d667bb6372",
    "filename": "engine/src/main/java/io/zeebe/engine/state/appliers/EventAppliers.java",
    "status": "modified",
    "additions": 11,
    "deletions": 0,
    "changes": 11,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/state/appliers/EventAppliers.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/state/appliers/EventAppliers.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/state/appliers/EventAppliers.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -24,6 +24,7 @@\n import io.zeebe.protocol.record.intent.ProcessInstanceIntent;\n import io.zeebe.protocol.record.intent.ProcessIntent;\n import io.zeebe.protocol.record.intent.ProcessMessageSubscriptionIntent;\n+import io.zeebe.protocol.record.intent.TimerIntent;\n import io.zeebe.protocol.record.intent.VariableIntent;\n import java.util.HashMap;\n import java.util.Map;\n@@ -66,6 +67,16 @@ public EventAppliers(final MutableZeebeState state) {\n     register(JobBatchIntent.ACTIVATED, new JobBatchActivatedApplier(state));\n     registerIncidentEventAppliers(state);\n     registerProcessMessageSubscriptionEventAppliers(state);\n+    registerTimeEventAppliers(state);\n+  }\n+\n+  private void registerTimeEventAppliers(final MutableZeebeState state) {\n+    register(TimerIntent.CREATED, new TimerCreatedApplier(state.getTimerState()));\n+    register(TimerIntent.CANCELED, new TimerCancelledApplier(state.getTimerState()));\n+    register(\n+        TimerIntent.TRIGGERED,\n+        new TimerTriggeredApplier(\n+            state.getEventScopeInstanceState(), state.getTimerState(), state.getProcessState()));\n   }\n \n   private void registerDeploymentAppliers(final MutableZeebeState state) {"
  },
  {
    "sha": "cc3bbea83ca0de88272dce7d4f9d44cc3b065146",
    "filename": "engine/src/main/java/io/zeebe/engine/state/appliers/TimerCancelledApplier.java",
    "status": "added",
    "additions": 29,
    "deletions": 0,
    "changes": 29,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/state/appliers/TimerCancelledApplier.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/state/appliers/TimerCancelledApplier.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/state/appliers/TimerCancelledApplier.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.1. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.1.\n+ */\n+package io.zeebe.engine.state.appliers;\n+\n+import io.zeebe.engine.state.TypedEventApplier;\n+import io.zeebe.engine.state.instance.TimerInstance;\n+import io.zeebe.engine.state.mutable.MutableTimerInstanceState;\n+import io.zeebe.protocol.impl.record.value.timer.TimerRecord;\n+import io.zeebe.protocol.record.intent.TimerIntent;\n+\n+class TimerCancelledApplier implements TypedEventApplier<TimerIntent, TimerRecord> {\n+\n+  private final MutableTimerInstanceState timerInstanceState;\n+\n+  TimerCancelledApplier(final MutableTimerInstanceState timerInstanceState) {\n+    this.timerInstanceState = timerInstanceState;\n+  }\n+\n+  @Override\n+  public void applyState(final long key, final TimerRecord value) {\n+    final TimerInstance timerInstance = timerInstanceState.get(value.getElementInstanceKey(), key);\n+    timerInstanceState.remove(timerInstance);\n+  }\n+}"
  },
  {
    "sha": "e753d4573dd1081b5794c59b775a09bd6c1b2d13",
    "filename": "engine/src/main/java/io/zeebe/engine/state/appliers/TimerCreatedApplier.java",
    "status": "added",
    "additions": 37,
    "deletions": 0,
    "changes": 37,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/state/appliers/TimerCreatedApplier.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/state/appliers/TimerCreatedApplier.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/state/appliers/TimerCreatedApplier.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.1. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.1.\n+ */\n+package io.zeebe.engine.state.appliers;\n+\n+import io.zeebe.engine.state.TypedEventApplier;\n+import io.zeebe.engine.state.instance.TimerInstance;\n+import io.zeebe.engine.state.mutable.MutableTimerInstanceState;\n+import io.zeebe.protocol.impl.record.value.timer.TimerRecord;\n+import io.zeebe.protocol.record.intent.TimerIntent;\n+\n+final class TimerCreatedApplier implements TypedEventApplier<TimerIntent, TimerRecord> {\n+\n+  private final MutableTimerInstanceState timerInstanceState;\n+  private final TimerInstance timerInstance = new TimerInstance();\n+\n+  TimerCreatedApplier(final MutableTimerInstanceState timerInstanceState) {\n+    this.timerInstanceState = timerInstanceState;\n+  }\n+\n+  @Override\n+  public void applyState(final long key, final TimerRecord value) {\n+    timerInstance.setElementInstanceKey(value.getElementInstanceKey());\n+    timerInstance.setDueDate(value.getDueDate());\n+    timerInstance.setKey(key);\n+    timerInstance.setHandlerNodeId(value.getTargetElementIdBuffer());\n+    timerInstance.setRepetitions(value.getRepetitions());\n+    timerInstance.setProcessDefinitionKey(value.getProcessDefinitionKey());\n+    timerInstance.setProcessInstanceKey(value.getProcessInstanceKey());\n+\n+    timerInstanceState.put(timerInstance);\n+  }\n+}"
  },
  {
    "sha": "49f75c622334b32ee964af6c01aba78ae3a90cce",
    "filename": "engine/src/main/java/io/zeebe/engine/state/appliers/TimerTriggeredApplier.java",
    "status": "added",
    "additions": 61,
    "deletions": 0,
    "changes": 61,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/state/appliers/TimerTriggeredApplier.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/state/appliers/TimerTriggeredApplier.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/state/appliers/TimerTriggeredApplier.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.1. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.1.\n+ */\n+package io.zeebe.engine.state.appliers;\n+\n+import io.zeebe.engine.processing.deployment.model.element.ExecutableCatchEvent;\n+import io.zeebe.engine.state.TypedEventApplier;\n+import io.zeebe.engine.state.immutable.ProcessState;\n+import io.zeebe.engine.state.instance.TimerInstance;\n+import io.zeebe.engine.state.mutable.MutableEventScopeInstanceState;\n+import io.zeebe.engine.state.mutable.MutableTimerInstanceState;\n+import io.zeebe.protocol.impl.record.value.timer.TimerRecord;\n+import io.zeebe.protocol.record.intent.TimerIntent;\n+import org.agrona.DirectBuffer;\n+import org.agrona.concurrent.UnsafeBuffer;\n+\n+final class TimerTriggeredApplier implements TypedEventApplier<TimerIntent, TimerRecord> {\n+\n+  private static final UnsafeBuffer NO_VARIABLES = new UnsafeBuffer();\n+  private final MutableEventScopeInstanceState eventScopeInstanceState;\n+  private final MutableTimerInstanceState timerInstanceState;\n+  private final ProcessState processState;\n+\n+  public TimerTriggeredApplier(\n+      final MutableEventScopeInstanceState eventScopeInstanceState,\n+      final MutableTimerInstanceState timerInstanceState,\n+      final ProcessState processState) {\n+    this.eventScopeInstanceState = eventScopeInstanceState;\n+    this.timerInstanceState = timerInstanceState;\n+    this.processState = processState;\n+  }\n+\n+  @Override\n+  public void applyState(final long key, final TimerRecord value) {\n+    final long elementInstanceKey = value.getElementInstanceKey();\n+    final TimerInstance timerInstance = timerInstanceState.get(elementInstanceKey, key);\n+    final long processDefinitionKey = value.getProcessDefinitionKey();\n+    final DirectBuffer targetElementId = value.getTargetElementIdBuffer();\n+\n+    timerInstanceState.remove(timerInstance);\n+\n+    if (isStartEvent(elementInstanceKey)) {\n+      eventScopeInstanceState.triggerEvent(\n+          processDefinitionKey, key, targetElementId, NO_VARIABLES);\n+    } else {\n+      final ExecutableCatchEvent catchEvent =\n+          processState.getFlowElement(\n+              processDefinitionKey, targetElementId, ExecutableCatchEvent.class);\n+      eventScopeInstanceState.triggerEvent(\n+          elementInstanceKey, key, catchEvent.getId(), NO_VARIABLES);\n+    }\n+  }\n+\n+  private boolean isStartEvent(final long elementInstanceKey) {\n+    return elementInstanceKey < 0;\n+  }\n+}"
  },
  {
    "sha": "2a74297c96ec53d2e7c0f92d1c407c20267f3a24",
    "filename": "engine/src/main/java/io/zeebe/engine/state/instance/DbTimerInstanceState.java",
    "status": "modified",
    "additions": 10,
    "deletions": 10,
    "changes": 20,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/state/instance/DbTimerInstanceState.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/state/instance/DbTimerInstanceState.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/state/instance/DbTimerInstanceState.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -64,6 +64,16 @@ public void put(final TimerInstance timer) {\n     dueDateColumnFamily.put(dueDateCompositeKey, DbNil.INSTANCE);\n   }\n \n+  @Override\n+  public void remove(final TimerInstance timer) {\n+    elementInstanceKey.wrapLong(timer.getElementInstanceKey());\n+    timerKey.wrapLong(timer.getKey());\n+    timerInstanceColumnFamily.delete(elementAndTimerKey);\n+\n+    dueDateKey.wrapLong(timer.getDueDate());\n+    dueDateColumnFamily.delete(dueDateCompositeKey);\n+  }\n+\n   @Override\n   public long findTimersWithDueDateBefore(final long timestamp, final TimerVisitor consumer) {\n     nextDueDate = -1L;\n@@ -107,14 +117,4 @@ public TimerInstance get(final long elementInstanceKey, final long timerKey) {\n \n     return timerInstanceColumnFamily.get(elementAndTimerKey);\n   }\n-\n-  @Override\n-  public void remove(final TimerInstance timer) {\n-    elementInstanceKey.wrapLong(timer.getElementInstanceKey());\n-    timerKey.wrapLong(timer.getKey());\n-    timerInstanceColumnFamily.delete(elementAndTimerKey);\n-\n-    dueDateKey.wrapLong(timer.getDueDate());\n-    dueDateColumnFamily.delete(dueDateCompositeKey);\n-  }\n }"
  },
  {
    "sha": "7f386caa1b12c50242d4221322a7af2b8f96d275",
    "filename": "engine/src/main/java/io/zeebe/engine/state/instance/TimerInstance.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/state/instance/TimerInstance.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/main/java/io/zeebe/engine/state/instance/TimerInstance.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/main/java/io/zeebe/engine/state/instance/TimerInstance.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -17,7 +17,7 @@\n \n public final class TimerInstance extends UnpackedObject implements DbValue {\n \n-  public static final int NO_ELEMENT_INSTANCE = -1;\n+  public static final long NO_ELEMENT_INSTANCE = -1L;\n \n   private final StringProperty handlerNodeIdProp = new StringProperty(\"handlerNodeId\", \"\");\n   private final LongProperty processDefinitionKeyProp ="
  },
  {
    "sha": "04ac62b6f176d1b6241381fcdeec8c240e6ab2cc",
    "filename": "engine/src/test/java/io/zeebe/engine/processing/bpmn/ProcessInstanceStreamProcessorRule.java",
    "status": "modified",
    "additions": 5,
    "deletions": 2,
    "changes": 7,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/bpmn/ProcessInstanceStreamProcessorRule.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/bpmn/ProcessInstanceStreamProcessorRule.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/test/java/io/zeebe/engine/processing/bpmn/ProcessInstanceStreamProcessorRule.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -112,6 +112,8 @@ protected void before() {\n                   variablesState::getVariable);\n \n           final var writers = processingContext.getWriters();\n+          final DueDateTimerChecker dueDateTimerChecker =\n+              new DueDateTimerChecker(zeebeState.getTimerState());\n           ProcessEventProcessors.addProcessProcessors(\n               zeebeState,\n               expressionProcessor,\n@@ -122,8 +124,9 @@ protected void before() {\n                   expressionProcessor,\n                   mockSubscriptionCommandSender,\n                   writers.state(),\n-                  1),\n-              new DueDateTimerChecker(zeebeState.getTimerState()),\n+                  1,\n+                  dueDateTimerChecker),\n+              dueDateTimerChecker,\n               writers);\n \n           JobEventProcessors.addJobProcessors("
  },
  {
    "sha": "d76cb333cbf7a59e1c017471818e22bdc65d0741",
    "filename": "engine/src/test/java/io/zeebe/engine/processing/bpmn/ProcessInstanceStreamProcessorTest.java",
    "status": "modified",
    "additions": 0,
    "deletions": 1,
    "changes": 1,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/bpmn/ProcessInstanceStreamProcessorTest.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/bpmn/ProcessInstanceStreamProcessorTest.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/test/java/io/zeebe/engine/processing/bpmn/ProcessInstanceStreamProcessorTest.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -438,7 +438,6 @@ public void shouldNotTriggerBoundaryEventIfTaskIsCompleted() {\n     assertThat(envRule.events().onlyTimerRecords().collect(Collectors.toList()))\n         .extracting(r -> tuple(r.getRecordType(), r.getIntent()))\n         .containsSubsequence(\n-            tuple(RecordType.COMMAND, TimerIntent.CREATE),\n             tuple(RecordType.EVENT, TimerIntent.CREATED),\n             tuple(RecordType.COMMAND, TimerIntent.TRIGGER),\n             tuple(RecordType.COMMAND_REJECTION, TimerIntent.TRIGGER));"
  },
  {
    "sha": "4cac5f910b24f522fa7d53ec6e2831d40e4e5f8a",
    "filename": "engine/src/test/java/io/zeebe/engine/processing/bpmn/activity/ActivityTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/bpmn/activity/ActivityTest.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/bpmn/activity/ActivityTest.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/test/java/io/zeebe/engine/processing/bpmn/activity/ActivityTest.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -141,7 +141,7 @@ public void shouldSubscribeToBoundaryEventTriggersOnReady() {\n     assertThat(records).hasSize(4);\n     assertThat(records)\n         .extracting(Record::getIntent)\n-        .contains(ELEMENT_ACTIVATING, TimerIntent.CREATE, TimerIntent.CREATE, ELEMENT_ACTIVATED);\n+        .contains(ELEMENT_ACTIVATING, TimerIntent.CREATED, TimerIntent.CREATED, ELEMENT_ACTIVATED);\n   }\n \n   @Test"
  },
  {
    "sha": "e2104d3d8cc5011888fc09ad0627f892e6ed5602",
    "filename": "engine/src/test/java/io/zeebe/engine/processing/bpmn/boundary/BoundaryEventTest.java",
    "status": "modified",
    "additions": 4,
    "deletions": 4,
    "changes": 8,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/bpmn/boundary/BoundaryEventTest.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/bpmn/boundary/BoundaryEventTest.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/test/java/io/zeebe/engine/processing/bpmn/boundary/BoundaryEventTest.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -128,8 +128,8 @@ public void shouldActivateBoundaryEventWhenEventTriggered() {\n     assertThat(records)\n         .extracting(Record::getValueType, Record::getIntent)\n         .containsSequence(\n-            tuple(ValueType.PROCESS_INSTANCE, ProcessInstanceIntent.EVENT_OCCURRED),\n             tuple(ValueType.TIMER, TimerIntent.TRIGGERED),\n+            tuple(ValueType.PROCESS_INSTANCE, ProcessInstanceIntent.EVENT_OCCURRED),\n             tuple(ValueType.PROCESS_INSTANCE, ProcessInstanceIntent.ELEMENT_TERMINATING),\n             tuple(ValueType.JOB, JobIntent.CANCEL),\n             tuple(ValueType.PROCESS_INSTANCE, ProcessInstanceIntent.ELEMENT_TERMINATED),\n@@ -252,8 +252,8 @@ public void shouldTerminateSubProcessBeforeTriggeringBoundaryEvent() {\n     assertThat(records)\n         .extracting(Record::getValueType, Record::getIntent)\n         .endsWith(\n-            tuple(ValueType.PROCESS_INSTANCE, ProcessInstanceIntent.EVENT_OCCURRED),\n             tuple(ValueType.TIMER, TimerIntent.TRIGGERED),\n+            tuple(ValueType.PROCESS_INSTANCE, ProcessInstanceIntent.EVENT_OCCURRED),\n             tuple(ValueType.PROCESS_INSTANCE, ProcessInstanceIntent.ELEMENT_TERMINATING),\n             tuple(ValueType.PROCESS_INSTANCE, ProcessInstanceIntent.ELEMENT_TERMINATING),\n             tuple(ValueType.JOB, JobIntent.CANCEL),\n@@ -299,9 +299,9 @@ public void shouldNotTerminateActivityForNonInterruptingBoundaryEvents() {\n     assertThat(records)\n         .extracting(Record::getValueType, Record::getIntent)\n         .containsSubsequence(\n-            tuple(ValueType.PROCESS_INSTANCE, ProcessInstanceIntent.EVENT_OCCURRED),\n             tuple(ValueType.TIMER, TimerIntent.TRIGGERED),\n-            tuple(ValueType.TIMER, TimerIntent.CREATE),\n+            tuple(ValueType.PROCESS_INSTANCE, ProcessInstanceIntent.EVENT_OCCURRED),\n+            tuple(ValueType.TIMER, TimerIntent.CREATED),\n             tuple(ValueType.JOB, JobIntent.COMPLETED),\n             tuple(ValueType.PROCESS_INSTANCE, ProcessInstanceIntent.ELEMENT_COMPLETING),\n             tuple(ValueType.TIMER, TimerIntent.CANCEL),"
  },
  {
    "sha": "91c9d0861e89ed92b542875b5333500f9860211d",
    "filename": "engine/src/test/java/io/zeebe/engine/processing/bpmn/gateway/EventbasedGatewayTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/bpmn/gateway/EventbasedGatewayTest.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/bpmn/gateway/EventbasedGatewayTest.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/test/java/io/zeebe/engine/processing/bpmn/gateway/EventbasedGatewayTest.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -262,7 +262,7 @@ public void shouldOnlyExecuteOneBranchWithEqualTimers() {\n \n     // then\n     final List<String> timers =\n-        RecordingExporter.timerRecords(TimerIntent.CREATE)\n+        RecordingExporter.timerRecords(TimerIntent.CREATED)\n             .withProcessInstanceKey(processInstanceKey)\n             .limit(2)\n             .map(r -> r.getValue().getTargetElementId())"
  },
  {
    "sha": "a1cfc7157762fc8dc36717866266e696c4088195",
    "filename": "engine/src/test/java/io/zeebe/engine/processing/incident/IncidentStreamProcessorRule.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/incident/IncidentStreamProcessorRule.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/incident/IncidentStreamProcessorRule.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/test/java/io/zeebe/engine/processing/incident/IncidentStreamProcessorRule.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -96,7 +96,8 @@ protected void before() {\n                       expressionProcessor,\n                       mockSubscriptionCommandSender,\n                       writers.state(),\n-                      1),\n+                      1,\n+                      mockTimerEventScheduler),\n                   mockTimerEventScheduler,\n                   writers);\n "
  },
  {
    "sha": "92f0e7fa66376f947048e715f72569cf222575dd",
    "filename": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/BlacklistInstanceTest.java",
    "status": "modified",
    "additions": 0,
    "deletions": 1,
    "changes": 1,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/streamprocessor/BlacklistInstanceTest.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/streamprocessor/BlacklistInstanceTest.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/test/java/io/zeebe/engine/processing/streamprocessor/BlacklistInstanceTest.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -140,7 +140,6 @@\n       ////////////////////////////////////////\n       //////////////// TIMERS ////////////////\n       ////////////////////////////////////////\n-      {ValueType.TIMER, TimerIntent.CREATE, true},\n       {ValueType.TIMER, TimerIntent.CREATED, true},\n       {ValueType.TIMER, TimerIntent.TRIGGER, true},\n       {ValueType.TIMER, TimerIntent.TRIGGERED, true},"
  },
  {
    "sha": "1cc122be79965cc810254fe8c31a7bff1604344b",
    "filename": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/ReplayStateTest.java",
    "status": "modified",
    "additions": 103,
    "deletions": 5,
    "changes": 108,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/streamprocessor/ReplayStateTest.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/streamprocessor/ReplayStateTest.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/test/java/io/zeebe/engine/processing/streamprocessor/ReplayStateTest.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -16,10 +16,13 @@\n import io.zeebe.model.bpmn.Bpmn;\n import io.zeebe.model.bpmn.BpmnModelInstance;\n import io.zeebe.protocol.record.Record;\n+import io.zeebe.protocol.record.intent.DeploymentIntent;\n import io.zeebe.protocol.record.intent.JobIntent;\n import io.zeebe.protocol.record.intent.MessageIntent;\n import io.zeebe.protocol.record.intent.ProcessInstanceIntent;\n+import io.zeebe.protocol.record.intent.TimerIntent;\n import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.protocol.record.value.TimerRecordValue;\n import io.zeebe.test.util.record.RecordingExporter;\n import java.time.Duration;\n import java.util.Collection;\n@@ -40,17 +43,15 @@\n public final class ReplayStateTest {\n \n   private static final String PROCESS_ID = \"process\";\n+  @Parameter public TestCase testCase;\n+  private long lastProcessedPosition = -1L;\n \n   @Rule\n   public final EngineRule engine =\n       EngineRule.singlePartition()\n           .withOnProcessedCallback(record -> lastProcessedPosition = record.getPosition())\n           .withOnSkippedCallback(record -> lastProcessedPosition = record.getPosition());\n \n-  @Parameter public TestCase testCase;\n-\n-  private long lastProcessedPosition = -1L;\n-\n   @Parameters(name = \"{0}\")\n   public static Collection<TestCase> testRecords() {\n     return List.of(\n@@ -88,6 +89,99 @@\n                           timeToLive.plus(MessageObserver.MESSAGE_TIME_TO_LIVE_CHECK_INTERVAL));\n \n                   return RecordingExporter.messageRecords(MessageIntent.EXPIRED).getFirst();\n+                }),\n+        // TODO(npepinpe): remove after https://github.com/camunda-cloud/zeebe/issues/6568\n+        testCase(\"timer start event\")\n+            .withProcess(\n+                Bpmn.createExecutableProcess(\"process\")\n+                    .startEvent(\"timer\")\n+                    .timerWithCycle(\"R/PT1M\")\n+                    .endEvent()\n+                    .done())\n+            .withExecution(\n+                engine ->\n+                    RecordingExporter.deploymentRecords(DeploymentIntent.FULLY_DISTRIBUTED)\n+                        .getFirst()),\n+        // TODO(npepinpe): remove after https://github.com/camunda-cloud/zeebe/issues/6568\n+        testCase(\"intermediate timer catch event\")\n+            .withProcess(\n+                Bpmn.createExecutableProcess(\"process\")\n+                    .startEvent()\n+                    .intermediateCatchEvent(\"timer\")\n+                    .timerWithDuration(\"PT30S\")\n+                    .endEvent()\n+                    .done())\n+            .withExecution(\n+                engine -> {\n+                  final long piKey = engine.processInstance().ofBpmnProcessId(\"process\").create();\n+                  final Record<TimerRecordValue> timer =\n+                      RecordingExporter.timerRecords(TimerIntent.CREATED)\n+                          .withProcessInstanceKey(piKey)\n+                          .getFirst();\n+\n+                  assertThat(timer).as(\"timer start event was created\").isNotNull();\n+                  engine.getClock().addTime(Duration.ofSeconds(30));\n+\n+                  return RecordingExporter.processInstanceRecords(\n+                          ProcessInstanceIntent.ELEMENT_COMPLETED)\n+                      .withProcessInstanceKey(piKey)\n+                      .withElementType(BpmnElementType.PROCESS)\n+                      .getFirst();\n+                }),\n+        // TODO(npepinpe): remove after https://github.com/camunda-cloud/zeebe/issues/6568\n+        testCase(\"interrupting timer boundary event\")\n+            .withProcess(\n+                Bpmn.createExecutableProcess(\"process\")\n+                    .startEvent()\n+                    .serviceTask(\"task\", b -> b.zeebeJobType(\"type\"))\n+                    .boundaryEvent(\"timer\", b -> b.cancelActivity(true))\n+                    .timerWithDuration(\"PT30S\")\n+                    .endEvent(\"end\")\n+                    .done())\n+            .withExecution(\n+                engine -> {\n+                  final long piKey = engine.processInstance().ofBpmnProcessId(\"process\").create();\n+                  final Record<TimerRecordValue> timer =\n+                      RecordingExporter.timerRecords(TimerIntent.CREATED)\n+                          .withProcessInstanceKey(piKey)\n+                          .getFirst();\n+\n+                  assertThat(timer).as(\"timer start event was created\").isNotNull();\n+                  engine.getClock().addTime(Duration.ofSeconds(30));\n+\n+                  return RecordingExporter.processInstanceRecords(\n+                          ProcessInstanceIntent.ELEMENT_COMPLETED)\n+                      .withProcessInstanceKey(piKey)\n+                      .withElementType(BpmnElementType.PROCESS)\n+                      .getFirst();\n+                }),\n+        // TODO(npepinpe): remove after https://github.com/camunda-cloud/zeebe/issues/6568\n+        testCase(\"non-interrupting timer boundary event\")\n+            .withProcess(\n+                Bpmn.createExecutableProcess(\"process\")\n+                    .startEvent()\n+                    .serviceTask(\"task\", b -> b.zeebeJobType(\"type\"))\n+                    .boundaryEvent(\"timer\", b -> b.cancelActivity(false))\n+                    .timerWithCycle(\"R/PT30S\")\n+                    .endEvent(\"end\")\n+                    .done())\n+            .withExecution(\n+                engine -> {\n+                  final long piKey = engine.processInstance().ofBpmnProcessId(\"process\").create();\n+                  final Record<TimerRecordValue> timer =\n+                      RecordingExporter.timerRecords(TimerIntent.CREATED)\n+                          .withProcessInstanceKey(piKey)\n+                          .getFirst();\n+\n+                  assertThat(timer).as(\"timer start event was created\").isNotNull();\n+                  engine.getClock().addTime(Duration.ofSeconds(30));\n+\n+                  return RecordingExporter.processInstanceRecords(\n+                          ProcessInstanceIntent.ELEMENT_COMPLETED)\n+                      .withProcessInstanceKey(piKey)\n+                      .withElementType(BpmnElementType.END_EVENT)\n+                      .withElementId(\"end\")\n+                      .getFirst();\n                 }));\n   }\n \n@@ -145,7 +239,11 @@ public void shouldRestoreState() {\n               }\n             });\n \n-    softly.assertAll();\n+    try {\n+      softly.assertAll();\n+    } catch (final AssertionError e) {\n+      throw e;\n+    }\n   }\n \n   private static TestCase testCase(final String description) {"
  },
  {
    "sha": "57b5c630f3a4abea05f05d8e5e8dfbd7feec9c18",
    "filename": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/SkipFailingEventsTest.java",
    "status": "modified",
    "additions": 33,
    "deletions": 11,
    "changes": 44,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/streamprocessor/SkipFailingEventsTest.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/streamprocessor/SkipFailingEventsTest.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/test/java/io/zeebe/engine/processing/streamprocessor/SkipFailingEventsTest.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -31,14 +31,18 @@\n import io.zeebe.engine.util.TestStreams;\n import io.zeebe.logstreams.log.LoggedEvent;\n import io.zeebe.logstreams.util.SynchronousLogStream;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n import io.zeebe.protocol.impl.record.RecordMetadata;\n import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.impl.record.value.deployment.DeploymentRecord;\n import io.zeebe.protocol.impl.record.value.error.ErrorRecord;\n import io.zeebe.protocol.impl.record.value.job.JobRecord;\n import io.zeebe.protocol.impl.record.value.processinstance.ProcessInstanceRecord;\n import io.zeebe.protocol.impl.record.value.timer.TimerRecord;\n import io.zeebe.protocol.record.RecordType;\n import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.DeploymentIntent;\n import io.zeebe.protocol.record.intent.ErrorIntent;\n import io.zeebe.protocol.record.intent.JobIntent;\n import io.zeebe.protocol.record.intent.ProcessInstanceIntent;\n@@ -384,23 +388,41 @@ public void shouldNotBlacklistInstanceAndIgnoreTimerStartEvents() {\n     // given\n     when(commandResponseWriter.tryWriteResponse(anyInt(), anyLong())).thenReturn(true);\n     final List<Long> processedInstances = new ArrayList<>();\n-    final TypedRecordProcessor<TimerRecord> errorProneProcessor =\n+    final TypedRecordProcessor<DeploymentRecord> errorProneProcessor =\n         new TypedRecordProcessor<>() {\n           @Override\n           public void processRecord(\n-              final TypedRecord<TimerRecord> record,\n+              final TypedRecord<DeploymentRecord> record,\n               final TypedResponseWriter responseWriter,\n               final TypedStreamWriter streamWriter) {\n             if (record.getKey() == 0) {\n               throw new RuntimeException(\"expected\");\n             }\n-            processedInstances.add(record.getValue().getProcessInstanceKey());\n+            processedInstances.add(TimerInstance.NO_ELEMENT_INSTANCE);\n             streamWriter.appendFollowUpEvent(\n                 record.getKey(),\n                 TimerIntent.CREATED,\n                 Records.timer(TimerInstance.NO_ELEMENT_INSTANCE));\n           }\n         };\n+    final BpmnModelInstance process =\n+        Bpmn.createExecutableProcess(\"process\")\n+            .startEvent()\n+            .timerWithDuration(\"PT1S\")\n+            .endEvent()\n+            .done();\n+    final DeploymentRecord firstDeploymentRecord = new DeploymentRecord();\n+    firstDeploymentRecord\n+        .resources()\n+        .add()\n+        .setResourceName(\"process.bpmn\")\n+        .setResource(Bpmn.convertToString(process).getBytes());\n+    final DeploymentRecord secondDeploymentRecord = new DeploymentRecord();\n+    secondDeploymentRecord\n+        .resources()\n+        .add()\n+        .setResourceName(\"process2.bpmn\")\n+        .setResource(Bpmn.convertToString(process).getBytes());\n \n     streams.startStreamProcessor(\n         STREAM_NAME,\n@@ -409,22 +431,22 @@ public void processRecord(\n           zeebeState = processingContext.getZeebeState();\n           return TypedRecordProcessors.processors(\n                   zeebeState.getKeyGenerator(), processingContext.getWriters())\n-              .onCommand(ValueType.TIMER, TimerIntent.CREATE, errorProneProcessor);\n+              .onCommand(ValueType.DEPLOYMENT, DeploymentIntent.CREATE, errorProneProcessor);\n         });\n \n     streams\n         .newRecord(STREAM_NAME)\n-        .event(Records.timer(TimerInstance.NO_ELEMENT_INSTANCE))\n+        .event(firstDeploymentRecord)\n         .recordType(RecordType.COMMAND)\n-        .intent(TimerIntent.CREATE)\n-        .key(keyGenerator.nextKey())\n+        .intent(DeploymentIntent.CREATE)\n+        .key(0)\n         .write();\n     streams\n         .newRecord(STREAM_NAME)\n-        .event(Records.timer(TimerInstance.NO_ELEMENT_INSTANCE))\n+        .event(secondDeploymentRecord)\n         .recordType(RecordType.COMMAND)\n-        .intent(TimerIntent.CREATE)\n-        .key(keyGenerator.nextKey())\n+        .intent(DeploymentIntent.CREATE)\n+        .key(1)\n         .write();\n \n     // when\n@@ -436,7 +458,7 @@ public void processRecord(\n     final MockTypedRecord<TimerRecord> mockTypedRecord =\n         new MockTypedRecord<>(0, metadata, Records.timer(TimerInstance.NO_ELEMENT_INSTANCE));\n     Assertions.assertThat(zeebeState.getBlackListState().isOnBlacklist(mockTypedRecord)).isFalse();\n-    assertThat(processedInstances).containsExactly((long) TimerInstance.NO_ELEMENT_INSTANCE);\n+    assertThat(processedInstances).containsExactly(TimerInstance.NO_ELEMENT_INSTANCE);\n   }\n \n   private void waitForRecordWhichSatisfies(final Predicate<LoggedEvent> filter) {"
  },
  {
    "sha": "3057d65dd4c356d39080de9021b09d4bddd50a64",
    "filename": "engine/src/test/java/io/zeebe/engine/processing/timer/TimerCatchEventTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 2,
    "changes": 3,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/timer/TimerCatchEventTest.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/processing/timer/TimerCatchEventTest.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/test/java/io/zeebe/engine/processing/timer/TimerCatchEventTest.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -113,8 +113,7 @@ public void testLifeCycle() {\n     assertThat(\n             RecordingExporter.records().limitToProcessInstance(processInstanceKey).timerRecords())\n         .extracting(Record::getIntent)\n-        .containsSubsequence(\n-            TimerIntent.CREATE, TimerIntent.CREATED, TimerIntent.TRIGGER, TimerIntent.TRIGGERED);\n+        .containsSubsequence(TimerIntent.CREATED, TimerIntent.TRIGGER, TimerIntent.TRIGGERED);\n   }\n \n   @Test"
  },
  {
    "sha": "a8a47039c2839bfc3e8f6d383f7fa017cee594c0",
    "filename": "engine/src/test/java/io/zeebe/engine/util/Records.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/util/Records.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/engine/src/test/java/io/zeebe/engine/util/Records.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/engine/src/test/java/io/zeebe/engine/util/Records.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -166,7 +166,7 @@ public static JobRecord job(final int instanceKey) {\n     return event;\n   }\n \n-  public static TimerRecord timer(final int instanceKey) {\n+  public static TimerRecord timer(final long instanceKey) {\n     final TimerRecord event = new TimerRecord();\n     event\n         .setProcessInstanceKey(instanceKey)"
  },
  {
    "sha": "d6561cc4040b1394ebd91691290a55ad646f0bb2",
    "filename": "protocol/src/main/java/io/zeebe/protocol/record/intent/TimerIntent.java",
    "status": "modified",
    "additions": 9,
    "deletions": 12,
    "changes": 21,
    "blob_url": "https://github.com/camunda-cloud/zeebe/blob/51862550940c10a5853b36ccd94df400a29114f5/protocol/src/main/java/io/zeebe/protocol/record/intent/TimerIntent.java",
    "raw_url": "https://github.com/camunda-cloud/zeebe/raw/51862550940c10a5853b36ccd94df400a29114f5/protocol/src/main/java/io/zeebe/protocol/record/intent/TimerIntent.java",
    "contents_url": "https://api.github.com/repos/camunda-cloud/zeebe/contents/protocol/src/main/java/io/zeebe/protocol/record/intent/TimerIntent.java?ref=51862550940c10a5853b36ccd94df400a29114f5",
    "patch": "@@ -16,14 +16,13 @@\n package io.zeebe.protocol.record.intent;\n \n public enum TimerIntent implements ProcessInstanceRelatedIntent {\n-  CREATE((short) 0),\n-  CREATED((short) 1),\n+  CREATED((short) 0),\n \n-  TRIGGER((short) 2),\n-  TRIGGERED((short) 3),\n+  TRIGGER((short) 1),\n+  TRIGGERED((short) 2),\n \n-  CANCEL((short) 4),\n-  CANCELED((short) 5);\n+  CANCEL((short) 3),\n+  CANCELED((short) 4);\n \n   private final short value;\n   private final boolean shouldBlacklist;\n@@ -45,16 +44,14 @@ public short value() {\n   public static Intent from(final short value) {\n     switch (value) {\n       case 0:\n-        return CREATE;\n-      case 1:\n         return CREATED;\n-      case 2:\n+      case 1:\n         return TRIGGER;\n-      case 3:\n+      case 2:\n         return TRIGGERED;\n-      case 4:\n+      case 3:\n         return CANCEL;\n-      case 5:\n+      case 4:\n         return CANCELED;\n       default:\n         return Intent.UNKNOWN;"
  }
]
