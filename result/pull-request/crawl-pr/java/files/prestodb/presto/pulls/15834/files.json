[
  {
    "sha": "1aa534eeeae7214884a91556189306cea437c7e0",
    "filename": "presto-main/src/main/java/com/facebook/presto/SessionRepresentation.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/SessionRepresentation.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/SessionRepresentation.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/SessionRepresentation.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -284,6 +284,7 @@ public long getStartTime()\n         return preparedStatements;\n     }\n \n+    @ThriftField(23)\n     @JsonProperty\n     public Map<SqlFunctionId, SqlInvokedFunction> getSessionFunctions()\n     {"
  },
  {
    "sha": "341b86431ff68eb6e9dfa1543848918149a950cf",
    "filename": "presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchManager.java",
    "status": "modified",
    "additions": 8,
    "deletions": 1,
    "changes": 9,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchManager.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchManager.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchManager.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -25,6 +25,7 @@\n import com.facebook.presto.execution.resourceGroups.ResourceGroupManager;\n import com.facebook.presto.execution.warnings.WarningCollectorFactory;\n import com.facebook.presto.metadata.SessionPropertyManager;\n+import com.facebook.presto.resourcemanager.ClusterStatusSender;\n import com.facebook.presto.security.AccessControl;\n import com.facebook.presto.server.BasicQueryInfo;\n import com.facebook.presto.server.SessionContext;\n@@ -78,6 +79,8 @@\n     private final Executor queryExecutor;\n     private final BoundedExecutor boundedQueryExecutor;\n \n+    private final ClusterStatusSender clusterStatusSender;\n+\n     private final QueryTracker<DispatchQuery> queryTracker;\n \n     private final QueryManagerStats stats = new QueryManagerStats();\n@@ -95,7 +98,8 @@ public DispatchManager(\n             SessionSupplier sessionSupplier,\n             SessionPropertyDefaults sessionPropertyDefaults,\n             QueryManagerConfig queryManagerConfig,\n-            DispatchExecutor dispatchExecutor)\n+            DispatchExecutor dispatchExecutor,\n+            ClusterStatusSender clusterStatusSender)\n     {\n         this.queryIdGenerator = requireNonNull(queryIdGenerator, \"queryIdGenerator is null\");\n         this.queryPreparer = requireNonNull(queryPreparer, \"queryPreparer is null\");\n@@ -113,6 +117,8 @@ public DispatchManager(\n         this.queryExecutor = requireNonNull(dispatchExecutor, \"dispatchExecutor is null\").getExecutor();\n         this.boundedQueryExecutor = requireNonNull(dispatchExecutor, \"dispatchExecutor is null\").getBoundedExecutor();\n \n+        this.clusterStatusSender = requireNonNull(clusterStatusSender, \"clusterStatusSender is null\");\n+\n         this.queryTracker = new QueryTracker<>(queryManagerConfig, dispatchExecutor.getScheduledExecutor());\n     }\n \n@@ -210,6 +216,7 @@ public QueryId createQueryId()\n             boolean queryAdded = queryCreated(dispatchQuery);\n             if (queryAdded && !dispatchQuery.isDone()) {\n                 try {\n+                    clusterStatusSender.registerQuery(dispatchQuery);\n                     resourceGroupManager.submit(preparedQuery.getStatement(), dispatchQuery, selectionContext, queryExecutor);\n                 }\n                 catch (Throwable e) {"
  },
  {
    "sha": "5df5d0e48f42e649ee029823bfa6028e2b7ed9c1",
    "filename": "presto-main/src/main/java/com/facebook/presto/execution/QueryManagerConfig.java",
    "status": "modified",
    "additions": 28,
    "deletions": 0,
    "changes": 28,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/execution/QueryManagerConfig.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/execution/QueryManagerConfig.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/execution/QueryManagerConfig.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -58,6 +58,8 @@\n     private int maxTotalRunningTaskCountToKillQuery = Integer.MAX_VALUE;\n     private int maxQueryRunningTaskCount = Integer.MAX_VALUE;\n     private int maxTotalRunningTaskCountToNotExecuteNewQuery = Integer.MAX_VALUE;\n+    private double concurrencyThresholdToEnableResourceGroupRefresh = 1.0;\n+    private Duration resourceGroupRunTimeInfoRefreshInterval = new Duration(100, TimeUnit.MILLISECONDS);\n \n     private Duration clientTimeout = new Duration(5, TimeUnit.MINUTES);\n \n@@ -303,6 +305,32 @@ public QueryManagerConfig setMaxQueryRunningTaskCount(int maxQueryRunningTaskCou\n         return this;\n     }\n \n+    @Config(\"concurrency-threshold-to-enable-resource-group-refresh\")\n+    @ConfigDescription(\"Resource group concurrency threshold precentage, once crossed new queries won't run till updated resource group info comes from resource manager\")\n+    public QueryManagerConfig setConcurrencyThresholdToEnableResourceGroupRefresh(double concurrencyThresholdToEnableResourceGroupRefresh)\n+    {\n+        this.concurrencyThresholdToEnableResourceGroupRefresh = concurrencyThresholdToEnableResourceGroupRefresh;\n+        return this;\n+    }\n+\n+    public Double getConcurrencyThresholdToEnableResourceGroupRefresh()\n+    {\n+        return concurrencyThresholdToEnableResourceGroupRefresh;\n+    }\n+\n+    public Duration getResourceGroupRunTimeInfoRefreshInterval()\n+    {\n+        return resourceGroupRunTimeInfoRefreshInterval;\n+    }\n+\n+    @Config(\"resource-group-runtimeinfo-refresh-interval\")\n+    @ConfigDescription(\"Resource Group Runtime Info Refresh Interval\")\n+    public QueryManagerConfig setResourceGroupRunTimeInfoRefreshInterval(Duration resourceGroupRunTimeInfoRefreshInterval)\n+    {\n+        this.resourceGroupRunTimeInfoRefreshInterval = resourceGroupRunTimeInfoRefreshInterval;\n+        return this;\n+    }\n+\n     @MinDuration(\"5s\")\n     @NotNull\n     public Duration getClientTimeout()"
  },
  {
    "sha": "bbe69bd42a0fac85089228319d97026c293b76aa",
    "filename": "presto-main/src/main/java/com/facebook/presto/execution/resourceGroups/InternalResourceGroup.java",
    "status": "modified",
    "additions": 92,
    "deletions": 16,
    "changes": 108,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/execution/resourceGroups/InternalResourceGroup.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/execution/resourceGroups/InternalResourceGroup.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/execution/resourceGroups/InternalResourceGroup.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -42,8 +42,10 @@\n import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.Executor;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.BiConsumer;\n \n import static com.facebook.presto.SystemSessionProperties.getQueryPriority;\n@@ -67,6 +69,7 @@\n import static io.airlift.units.DataSize.Unit.BYTE;\n import static java.lang.Math.min;\n import static java.lang.String.format;\n+import static java.lang.System.currentTimeMillis;\n import static java.util.Objects.requireNonNull;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n \n@@ -88,6 +91,8 @@\n     private final BiConsumer<InternalResourceGroup, Boolean> jmxExportListener;\n     private final Executor executor;\n     private final boolean staticResourceGroup;\n+    private final Map<ResourceGroupId, ResourceGroupRuntimeInfo> resourceGroupRuntimeInfos;\n+    private final double concurrencyThreshold;\n \n     // Configuration\n     // =============\n@@ -140,13 +145,20 @@\n     private long lastStartMillis;\n     @GuardedBy(\"root\")\n     private final CounterStat timeBetweenStartsSec = new CounterStat();\n+    @GuardedBy(\"root\")\n+    private final AtomicLong lastUpdatedResourceGroupRuntimeInfo;\n+    @GuardedBy(\"root\")\n+    private AtomicLong lastRunningQueryStartTime = new AtomicLong();\n \n     protected InternalResourceGroup(\n             Optional<InternalResourceGroup> parent,\n             String name,\n             BiConsumer<InternalResourceGroup, Boolean> jmxExportListener,\n             Executor executor,\n-            boolean staticResourceGroup)\n+            boolean staticResourceGroup,\n+            Map<ResourceGroupId, ResourceGroupRuntimeInfo> resourceGroupRuntimeInfos,\n+            AtomicLong lastUpdatedResourceGroupRuntimeInfo,\n+            Double concurrencyThreshold)\n     {\n         this.parent = requireNonNull(parent, \"parent is null\");\n         this.jmxExportListener = requireNonNull(jmxExportListener, \"jmxExportListener is null\");\n@@ -161,6 +173,10 @@ protected InternalResourceGroup(\n             root = this;\n         }\n         this.staticResourceGroup = staticResourceGroup;\n+        this.resourceGroupRuntimeInfos = resourceGroupRuntimeInfos;\n+        this.lastUpdatedResourceGroupRuntimeInfo = lastUpdatedResourceGroupRuntimeInfo;\n+        checkArgument(concurrencyThreshold > 0 && concurrencyThreshold <= 1, \"Concurrency threshold must be between (0, 1]\");\n+        this.concurrencyThreshold = concurrencyThreshold;\n     }\n \n     public ResourceGroupInfo getResourceGroupInfo(boolean includeQueryInfo, boolean summarizeSubgroups, boolean includeStaticSubgroupsOnly)\n@@ -593,7 +609,10 @@ public InternalResourceGroup getOrCreateSubGroup(String name, boolean staticSegm\n                     name,\n                     jmxExportListener,\n                     executor,\n-                    staticResourceGroup && staticSegment);\n+                    staticResourceGroup && staticSegment,\n+                    resourceGroupRuntimeInfos,\n+                    lastUpdatedResourceGroupRuntimeInfo,\n+                    concurrencyThreshold);\n             // Sub group must use query priority to ensure ordering\n             if (schedulingPolicy == QUERY_PRIORITY) {\n                 subGroup.setSchedulingPolicy(QUERY_PRIORITY);\n@@ -642,7 +661,8 @@ public void run(ManagedQueryExecution query)\n                 query.fail(new QueryQueueFullException(id));\n                 return;\n             }\n-            if (canRun) {\n+            boolean waitingForResourceGroupUpdate = waitingForResourceGroupRunTimeInfoUpdate();\n+            if (canRun && !waitingForResourceGroupUpdate && queuedQueries.isEmpty()) {\n                 startInBackground(query);\n             }\n             else {\n@@ -682,8 +702,10 @@ private void updateEligibility()\n                 parent.get().addOrUpdateSubGroup(this);\n             }\n             else {\n-                parent.get().eligibleSubGroups.remove(this);\n-                lastStartMillis = 0;\n+                if (queuedQueries.isEmpty() && eligibleSubGroups.isEmpty()) {\n+                    parent.get().eligibleSubGroups.remove(this);\n+                    lastStartMillis = 0;\n+                }\n             }\n             parent.get().updateEligibility();\n         }\n@@ -702,6 +724,7 @@ private void startInBackground(ManagedQueryExecution query)\n             }\n             updateEligibility();\n             executor.execute(query::startWaitingForResources);\n+            lastRunningQueryStartTime.set(currentTimeMillis());\n         }\n     }\n \n@@ -750,6 +773,10 @@ protected void internalRefreshStats()\n                 for (ManagedQueryExecution query : runningQueries) {\n                     cachedMemoryUsageBytes += query.getUserMemoryReservation().toBytes();\n                 }\n+                ResourceGroupRuntimeInfo resourceGroupRuntimeInfo = resourceGroupRuntimeInfos.get(getId());\n+                if (resourceGroupRuntimeInfo != null) {\n+                    cachedMemoryUsageBytes += resourceGroupRuntimeInfo.getMemoryUsageBytes();\n+                }\n             }\n             else {\n                 for (Iterator<InternalResourceGroup> iterator = dirtySubGroups.iterator(); iterator.hasNext(); ) {\n@@ -791,6 +818,11 @@ protected boolean internalStartNext()\n             if (!canRunMore()) {\n                 return false;\n             }\n+\n+            if (waitingForResourceGroupRunTimeInfoUpdate()) {\n+                return false;\n+            }\n+\n             ManagedQueryExecution query = queuedQueries.poll();\n             if (query != null) {\n                 startInBackground(query);\n@@ -802,21 +834,23 @@ protected boolean internalStartNext()\n             if (subGroup == null) {\n                 return false;\n             }\n+\n             boolean started = subGroup.internalStartNext();\n-            checkState(started, \"Eligible sub group had no queries to run\");\n+            if (started == true) {\n+                long currentTime = System.currentTimeMillis();\n+                if (lastStartMillis != 0) {\n+                    timeBetweenStartsSec.update(Math.max(0, (currentTime - lastStartMillis) / 1000));\n+                }\n+                lastStartMillis = currentTime;\n \n-            long currentTime = System.currentTimeMillis();\n-            if (lastStartMillis != 0) {\n-                timeBetweenStartsSec.update(Math.max(0, (currentTime - lastStartMillis) / 1000));\n+                descendantQueuedQueries--;\n             }\n-            lastStartMillis = currentTime;\n \n-            descendantQueuedQueries--;\n             // Don't call updateEligibility here, as we're in a recursive call, and don't want to repeatedly update our ancestors.\n             if (subGroup.isEligibleToStartNext()) {\n                 addOrUpdateSubGroup(subGroup);\n             }\n-            return true;\n+            return started;\n         }\n     }\n \n@@ -889,6 +923,10 @@ private boolean canQueueMore()\n     {\n         checkState(Thread.holdsLock(root), \"Must hold lock\");\n         synchronized (root) {\n+            ResourceGroupRuntimeInfo resourceGroupRuntimeInfo = resourceGroupRuntimeInfos.get(getId());\n+            if (resourceGroupRuntimeInfo != null) {\n+                return descendantQueuedQueries + queuedQueries.size() + resourceGroupRuntimeInfo.getQueuedQueries() + resourceGroupRuntimeInfo.getDescendantQueuedQueries() < maxQueuedQueries;\n+            }\n             return descendantQueuedQueries + queuedQueries.size() < maxQueuedQueries;\n         }\n     }\n@@ -905,6 +943,23 @@ private boolean canRunMore()\n                 return false;\n             }\n \n+            int hardConcurrencyLimit = getHardConcurrencyLimitBasedOnCpuUsage();\n+\n+            int totalRunningQueries = runningQueries.size() + descendantRunningQueries;\n+\n+            ResourceGroupRuntimeInfo resourceGroupRuntimeInfo = resourceGroupRuntimeInfos.get(getId());\n+            if (resourceGroupRuntimeInfo != null) {\n+                totalRunningQueries += resourceGroupRuntimeInfo.getRunningQueries() + resourceGroupRuntimeInfo.getDescendantRunningQueries();\n+            }\n+\n+            return totalRunningQueries < hardConcurrencyLimit && cachedMemoryUsageBytes <= softMemoryLimitBytes;\n+        }\n+    }\n+\n+    private int getHardConcurrencyLimitBasedOnCpuUsage()\n+    {\n+        checkState(Thread.holdsLock(root), \"Must hold lock\");\n+        synchronized (root) {\n             int hardConcurrencyLimit = this.hardConcurrencyLimit;\n             if (cpuUsageMillis >= softCpuLimitMillis) {\n                 // TODO: Consider whether cpu limit math should be performed on softConcurrency or hardConcurrency\n@@ -916,8 +971,24 @@ private boolean canRunMore()\n                 // Always allow at least one running query\n                 hardConcurrencyLimit = Math.max(1, hardConcurrencyLimit);\n             }\n-            return runningQueries.size() + descendantRunningQueries < hardConcurrencyLimit &&\n-                    cachedMemoryUsageBytes <= softMemoryLimitBytes;\n+\n+            return hardConcurrencyLimit;\n+        }\n+    }\n+\n+    protected boolean waitingForResourceGroupRunTimeInfoUpdate()\n+    {\n+        checkState(Thread.holdsLock(root), \"Must hold lock\");\n+        synchronized (root) {\n+            int hardConcurrencyLimit = getHardConcurrencyLimitBasedOnCpuUsage();\n+\n+            int totalRunningQueries = runningQueries.size() + descendantRunningQueries;\n+\n+            ResourceGroupRuntimeInfo resourceGroupRuntimeInfo = resourceGroupRuntimeInfos.get(getId());\n+            if (resourceGroupRuntimeInfo != null) {\n+                totalRunningQueries += resourceGroupRuntimeInfo.getRunningQueries() + resourceGroupRuntimeInfo.getDescendantRunningQueries();\n+            }\n+            return totalRunningQueries >= (hardConcurrencyLimit * concurrencyThreshold) && lastUpdatedResourceGroupRuntimeInfo.get() <= lastRunningQueryStartTime.get();\n         }\n     }\n \n@@ -964,14 +1035,19 @@ public int hashCode()\n         public RootInternalResourceGroup(\n                 String name,\n                 BiConsumer<InternalResourceGroup, Boolean> jmxExportListener,\n-                Executor executor)\n+                Executor executor,\n+                ConcurrentMap<ResourceGroupId, ResourceGroupRuntimeInfo> resourceGroupRuntimeInfos,\n+                AtomicLong lastUpdatedResourceGroupRuntimeInfo,\n+                Double concurrencyThreshold)\n         {\n-            super(Optional.empty(), name, jmxExportListener, executor, true);\n+            super(Optional.empty(), name, jmxExportListener, executor, true, resourceGroupRuntimeInfos,\n+                    lastUpdatedResourceGroupRuntimeInfo, concurrencyThreshold);\n         }\n \n         public synchronized void processQueuedQueries()\n         {\n             internalRefreshStats();\n+\n             while (internalStartNext()) {\n                 // start all the queries we can\n             }"
  },
  {
    "sha": "dd2b6e45219e29c984f7df71a7e929e40a38e117",
    "filename": "presto-main/src/main/java/com/facebook/presto/execution/resourceGroups/InternalResourceGroupManager.java",
    "status": "modified",
    "additions": 39,
    "deletions": 4,
    "changes": 43,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/execution/resourceGroups/InternalResourceGroupManager.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/execution/resourceGroups/InternalResourceGroupManager.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/execution/resourceGroups/InternalResourceGroupManager.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -18,6 +18,7 @@\n import com.facebook.presto.execution.ManagedQueryExecution;\n import com.facebook.presto.execution.QueryManagerConfig;\n import com.facebook.presto.execution.resourceGroups.InternalResourceGroup.RootInternalResourceGroup;\n+import com.facebook.presto.resourcemanager.ResourceGroupService;\n import com.facebook.presto.server.ResourceGroupInfo;\n import com.facebook.presto.spi.PrestoException;\n import com.facebook.presto.spi.memory.ClusterMemoryPoolManager;\n@@ -30,6 +31,9 @@\n import com.facebook.presto.sql.tree.Statement;\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+import io.airlift.units.Duration;\n import org.weakref.jmx.JmxException;\n import org.weakref.jmx.MBeanExporter;\n import org.weakref.jmx.Managed;\n@@ -45,6 +49,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.OptionalInt;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.CopyOnWriteArrayList;\n@@ -60,10 +65,11 @@\n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.base.Strings.isNullOrEmpty;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n import static java.lang.String.format;\n import static java.lang.System.currentTimeMillis;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static java.util.concurrent.TimeUnit.NANOSECONDS;\n \n@@ -75,7 +81,7 @@\n     private static final File RESOURCE_GROUPS_CONFIGURATION = new File(\"etc/resource-groups.properties\");\n     private static final String CONFIGURATION_MANAGER_PROPERTY_NAME = \"resource-groups.configuration-manager\";\n \n-    private final ScheduledExecutorService refreshExecutor = newSingleThreadScheduledExecutor(daemonThreadsNamed(\"ResourceGroupManager\"));\n+    private final ScheduledExecutorService refreshExecutor = newScheduledThreadPool(2, daemonThreadsNamed(\"ResourceGroupManager\"));\n     private final List<RootInternalResourceGroup> rootGroups = new CopyOnWriteArrayList<>();\n     private final ConcurrentMap<ResourceGroupId, InternalResourceGroup> groups = new ConcurrentHashMap<>();\n     private final AtomicReference<ResourceGroupConfigurationManager<C>> configurationManager;\n@@ -88,21 +94,31 @@\n     private final AtomicBoolean taskLimitExceeded = new AtomicBoolean();\n     private final int maxTotalRunningTaskCountToNotExecuteNewQuery;\n     private final AtomicLong lastSchedulingCycleRunTimeMs = new AtomicLong(currentTimeMillis());\n+    private final ResourceGroupService resourceGroupService;\n+    private final ConcurrentMap<ResourceGroupId, ResourceGroupRuntimeInfo> resourceGroupRuntimeInfos = new ConcurrentHashMap<>();\n+    private final AtomicLong lastUpdatedResourceGroupRuntimeInfo = new AtomicLong(0L);\n+    private final double concurrencyThreshold;\n+    private final Duration resourceGroupRuntimeInfoRefreshInterval;\n \n     @Inject\n     public InternalResourceGroupManager(\n             LegacyResourceGroupConfigurationManager legacyManager,\n             ClusterMemoryPoolManager memoryPoolManager,\n             QueryManagerConfig queryManagerConfig,\n             NodeInfo nodeInfo,\n-            MBeanExporter exporter)\n+            MBeanExporter exporter,\n+            // TODO: move this to a different class\n+            ResourceGroupService resourceGroupService)\n     {\n         requireNonNull(queryManagerConfig, \"queryManagerConfig is null\");\n         this.exporter = requireNonNull(exporter, \"exporter is null\");\n         this.configurationManagerContext = new ResourceGroupConfigurationManagerContextInstance(memoryPoolManager, nodeInfo.getEnvironment());\n         this.legacyManager = requireNonNull(legacyManager, \"legacyManager is null\");\n         this.configurationManager = new AtomicReference<>(cast(legacyManager));\n         this.maxTotalRunningTaskCountToNotExecuteNewQuery = queryManagerConfig.getMaxTotalRunningTaskCountToNotExecuteNewQuery();\n+        this.resourceGroupService = requireNonNull(resourceGroupService, \"resourceGroupService is null\");\n+        this.concurrencyThreshold = queryManagerConfig.getConcurrencyThresholdToEnableResourceGroupRefresh();\n+        this.resourceGroupRuntimeInfoRefreshInterval = queryManagerConfig.getResourceGroupRunTimeInfoRefreshInterval();\n     }\n \n     @Override\n@@ -203,6 +219,24 @@ public void start()\n                     throw t;\n                 }\n             }, 1, 1, MILLISECONDS);\n+            refreshExecutor.scheduleWithFixedDelay(() -> {\n+                refreshResourceGroupRuntimeInfo();\n+            }, 1, resourceGroupRuntimeInfoRefreshInterval.toMillis(), MILLISECONDS);\n+        }\n+    }\n+\n+    private void refreshResourceGroupRuntimeInfo()\n+    {\n+        try {\n+            List<ResourceGroupRuntimeInfo> resourceGroupInfos = resourceGroupService.getResourceGroupInfo();\n+            Set<ResourceGroupId> resourceGroupIds = resourceGroupInfos.stream().map(ResourceGroupRuntimeInfo::getResourceGroupId).collect(toImmutableSet());\n+            Set<ResourceGroupId> toRemove = ImmutableSet.copyOf(Sets.difference(resourceGroupRuntimeInfos.keySet(), resourceGroupIds));\n+            resourceGroupRuntimeInfos.keySet().removeAll(toRemove);\n+            resourceGroupInfos.forEach(resourceGroupRuntimeInfo -> resourceGroupRuntimeInfos.put(resourceGroupRuntimeInfo.getResourceGroupId(), resourceGroupRuntimeInfo));\n+            lastUpdatedResourceGroupRuntimeInfo.set(currentTimeMillis());\n+        }\n+        catch (Throwable t) {\n+            log.error(t, \"Error while executing refreshAndStartQueries\");\n         }\n     }\n \n@@ -256,7 +290,8 @@ private synchronized void createGroupIfNecessary(SelectionContext<C> context, Ex\n                 group = parent.getOrCreateSubGroup(id.getLastSegment(), !context.getFirstDynamicSegmentPosition().equals(OptionalInt.of(subGroupSegmentIndex)));\n             }\n             else {\n-                RootInternalResourceGroup root = new RootInternalResourceGroup(id.getSegments().get(0), this::exportGroup, executor);\n+                RootInternalResourceGroup root = new RootInternalResourceGroup(id.getSegments().get(0), this::exportGroup, executor, resourceGroupRuntimeInfos,\n+                        lastUpdatedResourceGroupRuntimeInfo, concurrencyThreshold);\n                 group = root;\n                 rootGroups.add(root);\n             }"
  },
  {
    "sha": "7f45200e3afd596d25e70fdbb16937462c1ac2c5",
    "filename": "presto-main/src/main/java/com/facebook/presto/execution/resourceGroups/ResourceGroupRuntimeInfo.java",
    "status": "added",
    "additions": 136,
    "deletions": 0,
    "changes": 136,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/execution/resourceGroups/ResourceGroupRuntimeInfo.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/execution/resourceGroups/ResourceGroupRuntimeInfo.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/execution/resourceGroups/ResourceGroupRuntimeInfo.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.resourceGroups;\n+\n+import com.facebook.drift.annotations.ThriftConstructor;\n+import com.facebook.drift.annotations.ThriftField;\n+import com.facebook.drift.annotations.ThriftStruct;\n+import com.facebook.presto.spi.resourceGroups.ResourceGroupId;\n+\n+import static java.lang.Math.addExact;\n+import static java.util.Objects.requireNonNull;\n+\n+@ThriftStruct\n+public class ResourceGroupRuntimeInfo\n+{\n+    private final ResourceGroupId resourceGroupId;\n+    private final long memoryUsageBytes;\n+    private final int queuedQueries;\n+    private final int descendantQueuedQueries;\n+    private final int runningQueries;\n+    private final int descendantRunningQueries;\n+\n+    @ThriftConstructor\n+    public ResourceGroupRuntimeInfo(ResourceGroupId resourceGroupId, long memoryUsageBytes, int queuedQueries, int descendantQueuedQueries, int runningQueries, int descendantRunningQueries)\n+    {\n+        this.resourceGroupId = requireNonNull(resourceGroupId, \"resourceGroupId is null\");\n+        this.memoryUsageBytes = memoryUsageBytes;\n+        this.queuedQueries = queuedQueries;\n+        this.descendantQueuedQueries = descendantQueuedQueries;\n+        this.runningQueries = runningQueries;\n+        this.descendantRunningQueries = descendantRunningQueries;\n+    }\n+\n+    public static Builder builder(ResourceGroupId resourceGroupId)\n+    {\n+        return new Builder(resourceGroupId);\n+    }\n+\n+    @ThriftField(1)\n+    public ResourceGroupId getResourceGroupId()\n+    {\n+        return resourceGroupId;\n+    }\n+\n+    @ThriftField(2)\n+    public long getMemoryUsageBytes()\n+    {\n+        return memoryUsageBytes;\n+    }\n+\n+    @ThriftField(3)\n+    public int getQueuedQueries()\n+    {\n+        return queuedQueries;\n+    }\n+\n+    @ThriftField(4)\n+    public int getDescendantQueuedQueries()\n+    {\n+        return descendantQueuedQueries;\n+    }\n+\n+    @ThriftField(5)\n+    public int getRunningQueries()\n+    {\n+        return runningQueries;\n+    }\n+\n+    @ThriftField(6)\n+    public int getDescendantRunningQueries()\n+    {\n+        return descendantRunningQueries;\n+    }\n+\n+    public static class Builder\n+    {\n+        private final ResourceGroupId resourceGroupId;\n+\n+        private long userMemoryReservationBytes;\n+        private int queuedQueries;\n+        private int descendantQueuedQueries;\n+        private int runningQueries;\n+        private int descendantRunningQueries;\n+\n+        private Builder(ResourceGroupId resourceGroupId)\n+        {\n+            this.resourceGroupId = resourceGroupId;\n+        }\n+\n+        public Builder addUserMemoryReservationBytes(long userMemoryReservationBytes)\n+        {\n+            this.userMemoryReservationBytes = addExact(this.userMemoryReservationBytes, userMemoryReservationBytes);\n+            return this;\n+        }\n+\n+        public Builder addQueuedQueries(int queuedQueries)\n+        {\n+            this.queuedQueries = addExact(this.queuedQueries, queuedQueries);\n+            return this;\n+        }\n+\n+        public Builder addDescendantQueuedQueries(int descendantQueuedQueries)\n+        {\n+            this.descendantQueuedQueries += descendantQueuedQueries;\n+            return this;\n+        }\n+\n+        public Builder addRunningQueries(int runningQueries)\n+        {\n+            this.runningQueries = addExact(this.runningQueries, runningQueries);\n+            return this;\n+        }\n+\n+        public Builder addDescendantRunningQueries(int descendantRunningQueries)\n+        {\n+            this.descendantRunningQueries += descendantRunningQueries;\n+            return this;\n+        }\n+\n+        public ResourceGroupRuntimeInfo build()\n+        {\n+            return new ResourceGroupRuntimeInfo(resourceGroupId, userMemoryReservationBytes, queuedQueries, descendantQueuedQueries, runningQueries, descendantRunningQueries);\n+        }\n+    }\n+}"
  },
  {
    "sha": "f656f85b37192da89b64a58dc1a87c65125e7c7b",
    "filename": "presto-main/src/main/java/com/facebook/presto/memory/ClusterMemoryManager.java",
    "status": "modified",
    "additions": 47,
    "deletions": 20,
    "changes": 67,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/memory/ClusterMemoryManager.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/memory/ClusterMemoryManager.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/memory/ClusterMemoryManager.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -23,13 +23,15 @@\n import com.facebook.presto.memory.LowMemoryKiller.QueryMemoryInfo;\n import com.facebook.presto.metadata.InternalNode;\n import com.facebook.presto.metadata.InternalNodeManager;\n+import com.facebook.presto.resourcemanager.MemoryManagerService;\n import com.facebook.presto.server.BasicQueryInfo;\n import com.facebook.presto.server.InternalCommunicationConfig;\n import com.facebook.presto.server.ServerConfig;\n import com.facebook.presto.server.codec.Codec;\n import com.facebook.presto.server.smile.SmileCodec;\n import com.facebook.presto.spi.PrestoException;\n import com.facebook.presto.spi.QueryId;\n+import com.facebook.presto.spi.memory.ClusterMemoryPoolInfo;\n import com.facebook.presto.spi.memory.ClusterMemoryPoolManager;\n import com.facebook.presto.spi.memory.MemoryPoolId;\n import com.facebook.presto.spi.memory.MemoryPoolInfo;\n@@ -102,6 +104,7 @@\n     private final ClusterMemoryLeakDetector memoryLeakDetector = new ClusterMemoryLeakDetector();\n     private final InternalNodeManager nodeManager;\n     private final LocationFactory locationFactory;\n+    private final Optional<MemoryManagerService> memoryManagerService;\n     private final HttpClient httpClient;\n     private final MBeanExporter exporter;\n     private final Codec<MemoryInfo> memoryInfoCodec;\n@@ -140,6 +143,7 @@ public ClusterMemoryManager(\n             @ForMemoryManager HttpClient httpClient,\n             InternalNodeManager nodeManager,\n             LocationFactory locationFactory,\n+            Optional<MemoryManagerService> memoryManagerService,\n             MBeanExporter exporter,\n             JsonCodec<MemoryInfo> memoryInfoJsonCodec,\n             SmileCodec<MemoryInfo> memoryInfoSmileCodec,\n@@ -160,6 +164,7 @@ public ClusterMemoryManager(\n         requireNonNull(communicationConfig, \"communicationConfig is null\");\n         this.nodeManager = requireNonNull(nodeManager, \"nodeManager is null\");\n         this.locationFactory = requireNonNull(locationFactory, \"locationFactory is null\");\n+        this.memoryManagerService = requireNonNull(memoryManagerService, \"memoryManagerService is null\");\n         this.httpClient = requireNonNull(httpClient, \"httpClient is null\");\n         this.exporter = requireNonNull(exporter, \"exporter is null\");\n         this.lowMemoryKiller = requireNonNull(lowMemoryKiller, \"lowMemoryKiller is null\");\n@@ -413,8 +418,8 @@ private void logQueryKill(QueryId killedQueryId, List<MemoryInfo> nodes)\n \n     private synchronized boolean isClusterOutOfMemory()\n     {\n-        ClusterMemoryPool reservedPool = pools.get(RESERVED_POOL);\n-        ClusterMemoryPool generalPool = pools.get(GENERAL_POOL);\n+        ClusterMemoryPoolInfo reservedPool = getClusterInfo(RESERVED_POOL);\n+        ClusterMemoryPoolInfo generalPool = getClusterInfo(GENERAL_POOL);\n         if (reservedPool == null) {\n             return generalPool.getBlockedNodes() > 0;\n         }\n@@ -425,30 +430,16 @@ private synchronized boolean isClusterOutOfMemory()\n     // RemoteNodeMemory as we don't need to POST anything.\n     private synchronized MemoryPoolAssignmentsRequest updateAssignments(Iterable<QueryExecution> queries)\n     {\n-        ClusterMemoryPool reservedPool = pools.get(RESERVED_POOL);\n-        ClusterMemoryPool generalPool = pools.get(GENERAL_POOL);\n+        ClusterMemoryPoolInfo reservedPool = getClusterInfo(RESERVED_POOL);\n+        ClusterMemoryPoolInfo generalPool = getClusterInfo(GENERAL_POOL);\n         verify(generalPool != null, \"generalPool is null\");\n         verify(reservedPool != null, \"reservedPool is null\");\n         long version = memoryPoolAssignmentsVersion.incrementAndGet();\n         // Check that all previous assignments have propagated to the visible nodes. This doesn't account for temporary network issues,\n         // and is more of a safety check than a guarantee\n         if (allAssignmentsHavePropagated(queries)) {\n             if (reservedPool.getAssignedQueries() == 0 && generalPool.getBlockedNodes() > 0) {\n-                QueryExecution biggestQuery = null;\n-                long maxMemory = -1;\n-                for (QueryExecution queryExecution : queries) {\n-                    if (resourceOvercommit(queryExecution.getSession())) {\n-                        // Don't promote queries that requested resource overcommit to the reserved pool,\n-                        // since their memory usage is unbounded.\n-                        continue;\n-                    }\n-\n-                    long bytesUsed = getQueryMemoryReservation(queryExecution);\n-                    if (bytesUsed > maxMemory) {\n-                        biggestQuery = queryExecution;\n-                        maxMemory = bytesUsed;\n-                    }\n-                }\n+                QueryExecution biggestQuery = findLargestMemoryQuery(generalPool, queries);\n                 if (biggestQuery != null) {\n                     log.info(\"Moving query %s to the reserved pool\", biggestQuery.getQueryId());\n                     biggestQuery.setMemoryPool(new VersionedMemoryPoolId(RESERVED_POOL, version));\n@@ -463,6 +454,31 @@ private synchronized MemoryPoolAssignmentsRequest updateAssignments(Iterable<Que\n         return new MemoryPoolAssignmentsRequest(coordinatorId, version, assignments.build());\n     }\n \n+    private QueryExecution findLargestMemoryQuery(ClusterMemoryPoolInfo generalPool, Iterable<QueryExecution> queries)\n+    {\n+        QueryExecution biggestQuery = null;\n+        long maxMemory = -1;\n+        Optional<QueryId> largestMemoryQuery = generalPool.getLargestMemoryQuery();\n+        for (QueryExecution queryExecution : queries) {\n+            QueryId queryId = queryExecution.getQueryId();\n+            if (largestMemoryQuery.map(queryId::equals).orElse(false)) {\n+                return queryExecution;\n+            }\n+            if (resourceOvercommit(queryExecution.getSession())) {\n+                // Don't promote queries that requested resource overcommit to the reserved pool,\n+                // since their memory usage is unbounded.\n+                continue;\n+            }\n+\n+            long bytesUsed = getQueryMemoryReservation(queryExecution);\n+            if (bytesUsed > maxMemory) {\n+                biggestQuery = queryExecution;\n+                maxMemory = bytesUsed;\n+            }\n+        }\n+        return biggestQuery;\n+    }\n+\n     private QueryMemoryInfo createQueryMemoryInfo(QueryExecution query)\n     {\n         return new QueryMemoryInfo(query.getQueryId(), query.getMemoryPool().getId(), query.getTotalMemoryReservation().toBytes());\n@@ -555,7 +571,7 @@ private synchronized void updatePools(Map<MemoryPoolId, Integer> queryCounts)\n         for (ClusterMemoryPool pool : pools.values()) {\n             pool.update(nodeMemoryInfos, queryCounts.getOrDefault(pool.getId(), 0));\n             if (changeListeners.containsKey(pool.getId())) {\n-                MemoryPoolInfo info = pool.getInfo();\n+                MemoryPoolInfo info = getClusterInfo(pool.getId()).getMemoryPoolInfo();\n                 for (Consumer<MemoryPoolInfo> listener : changeListeners.get(pool.getId())) {\n                     listenerExecutor.execute(() -> listener.accept(info));\n                 }\n@@ -574,6 +590,17 @@ private synchronized void updatePools(Map<MemoryPoolId, Integer> queryCounts)\n         return memoryInfo;\n     }\n \n+    @VisibleForTesting\n+    synchronized ClusterMemoryPoolInfo getClusterInfo(MemoryPoolId poolId)\n+    {\n+        return memoryManagerService\n+                .map(service -> service.getMemoryPoolInfo().get(poolId))\n+                .orElseGet(() -> {\n+                    ClusterMemoryPool clusterMemoryPool = pools.get(poolId);\n+                    return clusterMemoryPool != null ? clusterMemoryPool.getClusterInfo() : null;\n+                });\n+    }\n+\n     @PreDestroy\n     public synchronized void destroy()\n             throws IOException"
  },
  {
    "sha": "8c1251cf35cb47d5bbede0f355f492b8ecab4d3d",
    "filename": "presto-main/src/main/java/com/facebook/presto/memory/ClusterMemoryPool.java",
    "status": "modified",
    "additions": 12,
    "deletions": 0,
    "changes": 12,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/memory/ClusterMemoryPool.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/memory/ClusterMemoryPool.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/memory/ClusterMemoryPool.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -14,6 +14,7 @@\n package com.facebook.presto.memory;\n \n import com.facebook.presto.spi.QueryId;\n+import com.facebook.presto.spi.memory.ClusterMemoryPoolInfo;\n import com.facebook.presto.spi.memory.MemoryAllocation;\n import com.facebook.presto.spi.memory.MemoryPoolId;\n import com.facebook.presto.spi.memory.MemoryPoolInfo;\n@@ -28,6 +29,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.Optional;\n \n import static com.google.common.base.MoreObjects.toStringHelper;\n import static java.util.Objects.requireNonNull;\n@@ -81,6 +83,16 @@ public synchronized MemoryPoolInfo getInfo()\n                 ImmutableMap.copyOf(queryMemoryRevocableReservations));\n     }\n \n+    public synchronized ClusterMemoryPoolInfo getClusterInfo()\n+    {\n+        return getClusterInfo(Optional.empty());\n+    }\n+\n+    public synchronized ClusterMemoryPoolInfo getClusterInfo(Optional<QueryId> largestMemoryQuery)\n+    {\n+        return new ClusterMemoryPoolInfo(getInfo(), blockedNodes, assignedQueries, largestMemoryQuery);\n+    }\n+\n     public MemoryPoolId getId()\n     {\n         return id;"
  },
  {
    "sha": "b08bbd0a61f86c8a7ad37a06065214a01a783f6b",
    "filename": "presto-main/src/main/java/com/facebook/presto/metadata/AllNodes.java",
    "status": "modified",
    "additions": 11,
    "deletions": 3,
    "changes": 14,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/metadata/AllNodes.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/metadata/AllNodes.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/metadata/AllNodes.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -26,13 +26,15 @@\n     private final Set<InternalNode> inactiveNodes;\n     private final Set<InternalNode> shuttingDownNodes;\n     private final Set<InternalNode> activeCoordinators;\n+    private final Set<InternalNode> activeResourceManagers;\n \n-    public AllNodes(Set<InternalNode> activeNodes, Set<InternalNode> inactiveNodes, Set<InternalNode> shuttingDownNodes, Set<InternalNode> activeCoordinators)\n+    public AllNodes(Set<InternalNode> activeNodes, Set<InternalNode> inactiveNodes, Set<InternalNode> shuttingDownNodes, Set<InternalNode> activeCoordinators, Set<InternalNode> activeResourceManagers)\n     {\n         this.activeNodes = ImmutableSet.copyOf(requireNonNull(activeNodes, \"activeNodes is null\"));\n         this.inactiveNodes = ImmutableSet.copyOf(requireNonNull(inactiveNodes, \"inactiveNodes is null\"));\n         this.shuttingDownNodes = ImmutableSet.copyOf(requireNonNull(shuttingDownNodes, \"shuttingDownNodes is null\"));\n         this.activeCoordinators = ImmutableSet.copyOf(requireNonNull(activeCoordinators, \"activeCoordinators is null\"));\n+        this.activeResourceManagers = ImmutableSet.copyOf(requireNonNull(activeResourceManagers, \"activeResourceManagers is null\"));\n     }\n \n     public Set<InternalNode> getActiveNodes()\n@@ -55,6 +57,11 @@ public AllNodes(Set<InternalNode> activeNodes, Set<InternalNode> inactiveNodes,\n         return activeCoordinators;\n     }\n \n+    public Set<InternalNode> getActiveResourceManagers()\n+    {\n+        return activeResourceManagers;\n+    }\n+\n     @Override\n     public boolean equals(Object o)\n     {\n@@ -68,12 +75,13 @@ public boolean equals(Object o)\n         return Objects.equals(activeNodes, allNodes.activeNodes) &&\n                 Objects.equals(inactiveNodes, allNodes.inactiveNodes) &&\n                 Objects.equals(shuttingDownNodes, allNodes.shuttingDownNodes) &&\n-                Objects.equals(activeCoordinators, allNodes.activeCoordinators);\n+                Objects.equals(activeCoordinators, allNodes.activeCoordinators) &&\n+                Objects.equals(activeResourceManagers, allNodes.activeResourceManagers);\n     }\n \n     @Override\n     public int hashCode()\n     {\n-        return Objects.hash(activeNodes, inactiveNodes, shuttingDownNodes, activeCoordinators);\n+        return Objects.hash(activeNodes, inactiveNodes, shuttingDownNodes, activeCoordinators, activeResourceManagers);\n     }\n }"
  },
  {
    "sha": "310e81b85ba3367a6de02999c7264ffdb2fd74f0",
    "filename": "presto-main/src/main/java/com/facebook/presto/metadata/DiscoveryNodeManager.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/metadata/DiscoveryNodeManager.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/metadata/DiscoveryNodeManager.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/metadata/DiscoveryNodeManager.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -301,7 +301,7 @@ private synchronized void refreshNodesInternal()\n         // nodes by connector id changes anytime a node adds or removes a connector (note: this is not part of the listener system)\n         activeNodesByConnectorId = byConnectorIdBuilder.build();\n \n-        AllNodes allNodes = new AllNodes(activeNodesBuilder.build(), inactiveNodesBuilder.build(), shuttingDownNodesBuilder.build(), coordinatorsBuilder.build());\n+        AllNodes allNodes = new AllNodes(activeNodesBuilder.build(), inactiveNodesBuilder.build(), shuttingDownNodesBuilder.build(), coordinatorsBuilder.build(), resourceManagersBuilder.build());\n         // only update if all nodes actually changed (note: this does not include the connectors registered with the nodes)\n         if (!allNodes.equals(this.allNodes)) {\n             // assign allNodes to a local variable for use in the callback below"
  },
  {
    "sha": "83640f03dec5fa0654ea6535563dcaf6f854dbdc",
    "filename": "presto-main/src/main/java/com/facebook/presto/metadata/InMemoryNodeManager.java",
    "status": "modified",
    "additions": 4,
    "deletions": 5,
    "changes": 9,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/metadata/InMemoryNodeManager.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/metadata/InMemoryNodeManager.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/metadata/InMemoryNodeManager.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -30,11 +30,9 @@\n import java.util.List;\n import java.util.Set;\n import java.util.function.Consumer;\n-import java.util.stream.Stream;\n \n import static com.google.common.collect.ImmutableSet.toImmutableSet;\n import static java.util.Objects.requireNonNull;\n-import static java.util.stream.Stream.concat;\n \n public class InMemoryNodeManager\n         implements InternalNodeManager\n@@ -106,7 +104,8 @@ public AllNodes getAllNodes()\n                 ImmutableSet.<InternalNode>builder().add(localNode).addAll(remoteNodes.values()).build(),\n                 ImmutableSet.of(),\n                 ImmutableSet.of(),\n-                concat(Stream.of(localNode), remoteNodes.values().stream().filter(InternalNode::isCoordinator)).collect(toImmutableSet()));\n+                remoteNodes.values().stream().filter(InternalNode::isCoordinator).collect(toImmutableSet()),\n+                remoteNodes.values().stream().filter(InternalNode::isResourceManager).collect(toImmutableSet()));\n     }\n \n     @Override\n@@ -119,14 +118,14 @@ public InternalNode getCurrentNode()\n     public Set<InternalNode> getCoordinators()\n     {\n         // always use localNode as coordinator\n-        return ImmutableSet.of(localNode);\n+        return getAllNodes().getActiveCoordinators();\n     }\n \n     @Override\n     public Set<InternalNode> getResourceManagers()\n     {\n         // always use localNode as resource manager\n-        return ImmutableSet.of(localNode);\n+        return getAllNodes().getActiveNodes().stream().filter(InternalNode::isResourceManager).collect(toImmutableSet());\n     }\n \n     @Override"
  },
  {
    "sha": "f7fa1743271dbb701e603088a0a10511c9a2840c",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/ClusterMemoryManagerService.java",
    "status": "added",
    "additions": 101,
    "deletions": 0,
    "changes": 101,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ClusterMemoryManagerService.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ClusterMemoryManagerService.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/ClusterMemoryManagerService.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import com.facebook.drift.client.DriftClient;\n+import com.facebook.presto.memory.NodeMemoryConfig;\n+import com.facebook.presto.spi.memory.ClusterMemoryPoolInfo;\n+import com.facebook.presto.spi.memory.MemoryPoolId;\n+import com.facebook.presto.spi.memory.MemoryPoolInfo;\n+import com.facebook.presto.util.PeriodicTaskExecutor;\n+import com.google.common.collect.ImmutableMap;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static com.facebook.presto.memory.LocalMemoryManager.GENERAL_POOL;\n+import static com.facebook.presto.memory.LocalMemoryManager.RESERVED_POOL;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ClusterMemoryManagerService\n+        implements MemoryManagerService\n+{\n+    private static final ClusterMemoryPoolInfo EMPTY_MEMORY_POOL = new ClusterMemoryPoolInfo(\n+            new MemoryPoolInfo(0, 0, 0, ImmutableMap.of(), ImmutableMap.of(), ImmutableMap.of()),\n+            0,\n+            0);\n+\n+    private final DriftClient<ResourceManagerClient> resourceManagerClient;\n+    private final ScheduledExecutorService executorService;\n+    private final AtomicReference<Map<MemoryPoolId, ClusterMemoryPoolInfo>> memoryPools;\n+    private final long memoryPoolFetchIntervalMillis;\n+    private final boolean isReservedPoolEnabled;\n+\n+    private PeriodicTaskExecutor memoryPoolUpdater;\n+\n+    @Inject\n+    public ClusterMemoryManagerService(\n+            @ForResourceManager DriftClient<ResourceManagerClient> resourceManagerClient,\n+            @ForResourceManager ScheduledExecutorService executorService,\n+            ResourceManagerConfig resourceManagerConfig,\n+            NodeMemoryConfig nodeMemoryConfig)\n+    {\n+        this.resourceManagerClient = requireNonNull(resourceManagerClient, \"resourceManagerClient is null\");\n+        this.executorService = requireNonNull(executorService, \"executorService is null\");\n+        this.memoryPoolFetchIntervalMillis = requireNonNull(resourceManagerConfig, \"resourceManagerConfig is null\").getMemoryPoolFetchInterval().toMillis();\n+        this.isReservedPoolEnabled = requireNonNull(nodeMemoryConfig, \"nodeMemoryConfig is null\").isReservedPoolEnabled();\n+\n+        ImmutableMap.Builder<MemoryPoolId, ClusterMemoryPoolInfo> defaultPoolBuilder = ImmutableMap.<MemoryPoolId, ClusterMemoryPoolInfo>builder()\n+                .put(GENERAL_POOL, EMPTY_MEMORY_POOL);\n+        if (isReservedPoolEnabled) {\n+            defaultPoolBuilder.put(RESERVED_POOL, EMPTY_MEMORY_POOL);\n+        }\n+        this.memoryPools = new AtomicReference<>(defaultPoolBuilder.build());\n+    }\n+\n+    @PostConstruct\n+    public void init()\n+    {\n+        this.memoryPoolUpdater = new PeriodicTaskExecutor(memoryPoolFetchIntervalMillis, executorService, () -> memoryPools.set(updateMemoryPoolInfo()));\n+    }\n+\n+    @PreDestroy\n+    public void stop()\n+    {\n+        if (memoryPoolUpdater != null) {\n+            memoryPoolUpdater.stop();\n+        }\n+    }\n+\n+    @Override\n+    public Map<MemoryPoolId, ClusterMemoryPoolInfo> getMemoryPoolInfo()\n+    {\n+        return memoryPools.get();\n+    }\n+\n+    private Map<MemoryPoolId, ClusterMemoryPoolInfo> updateMemoryPoolInfo()\n+    {\n+        Map<MemoryPoolId, ClusterMemoryPoolInfo> memoryPoolInfos = resourceManagerClient.get().getMemoryPoolInfo();\n+        memoryPoolInfos.putIfAbsent(GENERAL_POOL, EMPTY_MEMORY_POOL);\n+        if (isReservedPoolEnabled) {\n+            memoryPoolInfos.putIfAbsent(RESERVED_POOL, EMPTY_MEMORY_POOL);\n+        }\n+        return ImmutableMap.copyOf(memoryPoolInfos);\n+    }\n+}"
  },
  {
    "sha": "d504d5af423f186a4e6631797482e75ddba185a8",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/ClusterStatusSender.java",
    "status": "added",
    "additions": 21,
    "deletions": 0,
    "changes": 21,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ClusterStatusSender.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ClusterStatusSender.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/ClusterStatusSender.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,21 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import com.facebook.presto.execution.ManagedQueryExecution;\n+\n+public interface ClusterStatusSender\n+{\n+    void registerQuery(ManagedQueryExecution queryExecution);\n+}"
  },
  {
    "sha": "3b85130bcf02e381aceb30d42a1c8388d1fd5be2",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/DistributedClusterStatsResource.java",
    "status": "added",
    "additions": 139,
    "deletions": 0,
    "changes": 139,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/DistributedClusterStatsResource.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/DistributedClusterStatsResource.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/DistributedClusterStatsResource.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import com.facebook.presto.execution.QueryState;\n+import com.facebook.presto.execution.scheduler.NodeSchedulerConfig;\n+import com.facebook.presto.metadata.InternalNodeManager;\n+import com.facebook.presto.server.BasicQueryInfo;\n+import com.facebook.presto.server.ClusterStatsResource;\n+import com.facebook.presto.spi.NodeState;\n+import com.facebook.presto.spi.memory.MemoryPoolId;\n+import com.facebook.presto.spi.memory.MemoryPoolInfo;\n+import com.google.common.base.Joiner;\n+\n+import javax.annotation.security.RolesAllowed;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import java.util.Map;\n+\n+import static com.facebook.presto.server.security.RoleType.ADMIN;\n+import static com.facebook.presto.server.security.RoleType.USER;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.net.HttpHeaders.ACCEPT;\n+import static com.google.common.net.HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS;\n+import static com.google.common.net.HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS;\n+import static com.google.common.net.HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN;\n+import static com.google.common.net.HttpHeaders.ACCESS_CONTROL_MAX_AGE;\n+import static com.google.common.net.HttpHeaders.AUTHORIZATION;\n+import static com.google.common.net.HttpHeaders.CONTENT_TYPE;\n+import static com.google.common.net.HttpHeaders.ORIGIN;\n+import static com.google.common.net.HttpHeaders.X_REQUESTED_WITH;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+@Path(\"/v1/cluster\")\n+@RolesAllowed({USER, ADMIN})\n+public class DistributedClusterStatsResource\n+{\n+    private final boolean isIncludeCoordinator;\n+    private final ResourceManagerClusterStateProvider clusterStateProvider;\n+    private final InternalNodeManager internalNodeManager;\n+\n+    @Inject\n+    public DistributedClusterStatsResource(NodeSchedulerConfig nodeSchedulerConfig, ResourceManagerClusterStateProvider clusterStateProvider, InternalNodeManager internalNodeManager)\n+    {\n+        this.isIncludeCoordinator = requireNonNull(nodeSchedulerConfig, \"nodeSchedulerConfig is null\").isIncludeCoordinator();\n+        this.clusterStateProvider = requireNonNull(clusterStateProvider, \"nodeStateManager is null\");\n+        this.internalNodeManager = requireNonNull(internalNodeManager, \"internalNodeManager is null\");\n+    }\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response getClusterStats()\n+    {\n+        long runningQueries = 0;\n+        long blockedQueries = 0;\n+        long queuedQueries = 0;\n+\n+        long activeNodes = internalNodeManager.getNodes(NodeState.ACTIVE).size();\n+        if (!isIncludeCoordinator) {\n+            activeNodes -= internalNodeManager.getCoordinators().size();\n+        }\n+        activeNodes -= internalNodeManager.getResourceManagers().size();\n+\n+        long runningDrivers = 0;\n+        double memoryReservation = 0;\n+\n+        // TODO: these stats may differ from the ones found in ClusterStatsResource\n+        long totalInputRows = 0;\n+        long totalInputBytes = 0;\n+        long totalCpuTimeSecs = 0;\n+\n+        for (BasicQueryInfo query : clusterStateProvider.getQueryInfos()) {\n+            if (query.getState() == QueryState.QUEUED) {\n+                queuedQueries++;\n+            }\n+            else if (query.getState() == QueryState.RUNNING) {\n+                if (query.getQueryStats().isFullyBlocked()) {\n+                    blockedQueries++;\n+                }\n+                else {\n+                    runningQueries++;\n+                }\n+            }\n+\n+            if (!query.getState().isDone()) {\n+                totalInputBytes += query.getQueryStats().getRawInputDataSize().toBytes();\n+                totalInputRows += query.getQueryStats().getRawInputPositions();\n+                totalCpuTimeSecs += query.getQueryStats().getTotalCpuTime().getValue(SECONDS);\n+\n+                memoryReservation += query.getQueryStats().getUserMemoryReservation().toBytes();\n+                runningDrivers += query.getQueryStats().getRunningDrivers();\n+            }\n+        }\n+\n+        return Response.ok(new ClusterStatsResource.ClusterStats(runningQueries, blockedQueries, queuedQueries, activeNodes, runningDrivers, memoryReservation, totalInputRows, totalInputBytes, totalCpuTimeSecs))\n+                .header(ACCESS_CONTROL_ALLOW_ORIGIN, \"*\")\n+                .header(ACCESS_CONTROL_ALLOW_HEADERS, Joiner.on(\", \").join(ORIGIN, CONTENT_TYPE, ACCEPT, AUTHORIZATION, X_REQUESTED_WITH))\n+                .header(ACCESS_CONTROL_ALLOW_METHODS, \"GET, OPTIONS\")\n+                .header(ACCESS_CONTROL_MAX_AGE, \"300\")\n+                .build();\n+    }\n+\n+    @GET\n+    @Path(\"memory\")\n+    public Response getClusterMemoryPoolInfo()\n+    {\n+        Map<MemoryPoolId, MemoryPoolInfo> memoryPoolInfos = clusterStateProvider.getClusterMemoryPoolInfos().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, e -> e.getValue().getMemoryPoolInfo()));\n+        return Response.ok()\n+                .entity(memoryPoolInfos)\n+                .build();\n+    }\n+\n+    @GET\n+    @Path(\"workerMemory\")\n+    public Response getWorkerMemoryInfo()\n+    {\n+        return Response.ok()\n+                .entity(clusterStateProvider.getWorkerMemoryInfo())\n+                .build();\n+    }\n+}"
  },
  {
    "sha": "55270d40cba37eba23524a3718a0f7141fc3423d",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/DistributedQueryResource.java",
    "status": "added",
    "additions": 168,
    "deletions": 0,
    "changes": 168,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/DistributedQueryResource.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/DistributedQueryResource.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/DistributedQueryResource.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import com.facebook.airlift.http.client.HttpClient;\n+import com.facebook.airlift.http.client.Request;\n+import com.facebook.airlift.http.client.ResponseHandler;\n+import com.facebook.presto.execution.QueryState;\n+import com.facebook.presto.server.BasicQueryInfo;\n+import com.facebook.presto.server.ForQueryInfo;\n+import com.facebook.presto.spi.QueryId;\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.security.RolesAllowed;\n+import javax.inject.Inject;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Response;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import static com.facebook.airlift.http.client.HttpUriBuilder.uriBuilderFrom;\n+import static com.facebook.presto.server.security.RoleType.ADMIN;\n+import static com.facebook.presto.server.security.RoleType.USER;\n+import static com.google.common.net.HttpHeaders.ACCEPT;\n+import static com.google.common.net.HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS;\n+import static com.google.common.net.HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS;\n+import static com.google.common.net.HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN;\n+import static com.google.common.net.HttpHeaders.ACCESS_CONTROL_MAX_AGE;\n+import static com.google.common.net.HttpHeaders.AUTHORIZATION;\n+import static com.google.common.net.HttpHeaders.CONTENT_TYPE;\n+import static com.google.common.net.HttpHeaders.ORIGIN;\n+import static com.google.common.net.HttpHeaders.X_REQUESTED_WITH;\n+import static java.util.Objects.requireNonNull;\n+import static javax.ws.rs.core.MediaType.APPLICATION_JSON;\n+import static javax.ws.rs.core.MediaType.APPLICATION_JSON_TYPE;\n+import static javax.ws.rs.core.Response.Status.NOT_FOUND;\n+\n+@Path(\"/v1/query\")\n+@RolesAllowed({USER, ADMIN})\n+public class DistributedQueryResource\n+{\n+    private final ResourceManagerClusterStateProvider clusterStateProvider;\n+    private final HttpClient httpClient;\n+\n+    @Inject\n+    public DistributedQueryResource(ResourceManagerClusterStateProvider clusterStateProvider, @ForQueryInfo HttpClient httpClient)\n+    {\n+        this.clusterStateProvider = requireNonNull(clusterStateProvider, \"nodeStateManager is null\");\n+        this.httpClient = requireNonNull(httpClient, \"httpClient is null\");\n+    }\n+\n+    @GET\n+    public Response getAllQueryInfo(@QueryParam(\"state\") String stateFilter)\n+    {\n+        QueryState expectedState = stateFilter == null ? null : QueryState.valueOf(stateFilter.toUpperCase(Locale.ENGLISH));\n+        List<BasicQueryInfo> queries;\n+        if (stateFilter == null) {\n+            queries = clusterStateProvider.getQueryInfos();\n+        }\n+        else {\n+            ImmutableList.Builder<BasicQueryInfo> builder = new ImmutableList.Builder<>();\n+            for (BasicQueryInfo queryInfo : clusterStateProvider.getQueryInfos()) {\n+                if (queryInfo.getState() == expectedState) {\n+                    builder.add(queryInfo);\n+                }\n+            }\n+            queries = builder.build();\n+        }\n+        return Response.ok(queries)\n+                .header(ACCESS_CONTROL_ALLOW_ORIGIN, \"*\")\n+                .header(ACCESS_CONTROL_ALLOW_HEADERS, Joiner.on(\", \").join(ORIGIN, CONTENT_TYPE, ACCEPT, AUTHORIZATION, X_REQUESTED_WITH))\n+                .header(ACCESS_CONTROL_ALLOW_METHODS, \"GET, OPTIONS\")\n+                .header(ACCESS_CONTROL_MAX_AGE, \"300\")\n+                .build();\n+    }\n+\n+    @GET\n+    @Path(\"{queryId}\")\n+    public Response getQueryInfo(@PathParam(\"queryId\") QueryId queryId)\n+    {\n+        return proxyResponse(queryId, \"GET\", \"\");\n+    }\n+\n+    @DELETE\n+    @Path(\"{queryId}\")\n+    public Response cancelQuery(@PathParam(\"queryId\") QueryId queryId)\n+    {\n+        return proxyResponse(queryId, \"DELETE\", \"\");\n+    }\n+\n+    @PUT\n+    @Path(\"{queryId}/killed\")\n+    public Response killQuery(@PathParam(\"queryId\") QueryId queryId, String message)\n+    {\n+        return proxyResponse(queryId, \"PUT\", \"killed\");\n+    }\n+\n+    @PUT\n+    @Path(\"{queryId}/preempted\")\n+    public Response preemptQuery(@PathParam(\"queryId\") QueryId queryId, String message)\n+    {\n+        return proxyResponse(queryId, \"PUT\", \"preempted\");\n+    }\n+\n+    // TODO: add a trace from original client IP address\n+    private Response proxyResponse(QueryId queryId, String httpMethod, String additionalPath)\n+    {\n+        Optional<BasicQueryInfo> queryInfo = clusterStateProvider.getQueryInfos().stream()\n+                .filter(query -> query.getQueryId().equals(queryId))\n+                .findFirst();\n+\n+        if (!queryInfo.isPresent()) {\n+            return Response.status(NOT_FOUND).build();\n+        }\n+\n+        Request request = new Request.Builder()\n+                .setMethod(httpMethod)\n+                .setUri(uriBuilderFrom(queryInfo.get().getSelf()).appendPath(additionalPath).build())\n+                .build();\n+        InputStream responseStream = httpClient.execute(request, new StreamingJsonResponseHandler());\n+        return Response.ok(responseStream, APPLICATION_JSON_TYPE).build();\n+    }\n+\n+    private static class StreamingJsonResponseHandler\n+            implements ResponseHandler<InputStream, RuntimeException>\n+    {\n+        @Override\n+        public InputStream handleException(Request request, Exception exception)\n+        {\n+            throw new RuntimeException(\"Request to coordinator failed\", exception);\n+        }\n+\n+        @Override\n+        public InputStream handle(Request request, com.facebook.airlift.http.client.Response response)\n+        {\n+            try {\n+                if (APPLICATION_JSON.equals(response.getHeader(CONTENT_TYPE))) {\n+                    return response.getInputStream();\n+                }\n+                throw new RuntimeException(\"Response received was not of type \" + APPLICATION_JSON);\n+            }\n+            catch (IOException e) {\n+                throw new RuntimeException(\"Unable to read response from coordinator\", e);\n+            }\n+        }\n+    }\n+}"
  },
  {
    "sha": "8cb358309e76f31815d49334634a4feb11dbdbab",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/ForResourceManager.java",
    "status": "added",
    "additions": 31,
    "deletions": 0,
    "changes": 31,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ForResourceManager.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ForResourceManager.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/ForResourceManager.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,31 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import javax.inject.Qualifier;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.PARAMETER;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+\n+@Retention(RUNTIME)\n+@Target({FIELD, PARAMETER, METHOD})\n+@Qualifier\n+public @interface ForResourceManager\n+{\n+}"
  },
  {
    "sha": "8c040240819b9b70b0d727b4036d6a9249c28bfd",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/MemoryManagerService.java",
    "status": "added",
    "additions": 24,
    "deletions": 0,
    "changes": 24,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/MemoryManagerService.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/MemoryManagerService.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/MemoryManagerService.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,24 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import com.facebook.presto.spi.memory.ClusterMemoryPoolInfo;\n+import com.facebook.presto.spi.memory.MemoryPoolId;\n+\n+import java.util.Map;\n+\n+public interface MemoryManagerService\n+{\n+    Map<MemoryPoolId, ClusterMemoryPoolInfo> getMemoryPoolInfo();\n+}"
  },
  {
    "sha": "04a9203c3ef8bc0d2315986a3d25e7a5a52eeb26",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/NoopResourceGroupService.java",
    "status": "added",
    "additions": 29,
    "deletions": 0,
    "changes": 29,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/NoopResourceGroupService.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/NoopResourceGroupService.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/NoopResourceGroupService.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,29 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import com.facebook.presto.execution.resourceGroups.ResourceGroupRuntimeInfo;\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.List;\n+\n+public class NoopResourceGroupService\n+        implements ResourceGroupService\n+{\n+    @Override\n+    public List<ResourceGroupRuntimeInfo> getResourceGroupInfo()\n+    {\n+        return ImmutableList.of();\n+    }\n+}"
  },
  {
    "sha": "c063c8e392f93f8121a00299cde4c54ff685932e",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/RandomResourceManagerAddressSelector.java",
    "status": "added",
    "additions": 81,
    "deletions": 0,
    "changes": 81,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/RandomResourceManagerAddressSelector.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/RandomResourceManagerAddressSelector.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/RandomResourceManagerAddressSelector.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import com.facebook.drift.client.address.AddressSelector;\n+import com.facebook.presto.metadata.InternalNodeManager;\n+import com.facebook.presto.spi.HostAddress;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.net.HostAndPort;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.function.Function;\n+\n+import static com.facebook.drift.client.address.SimpleAddressSelector.SimpleAddress;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class RandomResourceManagerAddressSelector\n+        implements AddressSelector<SimpleAddress>\n+{\n+    private final InternalNodeManager internalNodeManager;\n+    private final Function<List<HostAndPort>, Optional<HostAndPort>> hostSelector;\n+\n+    @Inject\n+    public RandomResourceManagerAddressSelector(InternalNodeManager internalNodeManager)\n+    {\n+        this(internalNodeManager, RandomResourceManagerAddressSelector::selectRandomHost);\n+    }\n+\n+    @VisibleForTesting\n+    RandomResourceManagerAddressSelector(\n+            InternalNodeManager internalNodeManager,\n+            Function<List<HostAndPort>, Optional<HostAndPort>> hostSelector)\n+    {\n+        this.internalNodeManager = requireNonNull(internalNodeManager, \"internalNodeManager is null\");\n+        this.hostSelector = requireNonNull(hostSelector, \"hostSelector is null\");\n+    }\n+\n+    @Override\n+    public Optional<SimpleAddress> selectAddress(Optional<String> addressSelectionContext)\n+    {\n+        if (addressSelectionContext.isPresent()) {\n+            return addressSelectionContext\n+                    .map(HostAndPort::fromString)\n+                    .map(SimpleAddress::new);\n+        }\n+        List<HostAndPort> resourceManagers = internalNodeManager.getResourceManagers()\n+                .stream()\n+                .filter(node -> node.getThriftPort().isPresent())\n+                .map(resourceManagerNode -> {\n+                    HostAddress hostAndPort = resourceManagerNode.getHostAndPort();\n+                    return HostAndPort.fromParts(hostAndPort.getHostText(), resourceManagerNode.getThriftPort().getAsInt());\n+                })\n+                .collect(toImmutableList());\n+        return hostSelector.apply(resourceManagers)\n+                .map(SimpleAddress::new);\n+    }\n+\n+    private static Optional<HostAndPort> selectRandomHost(List<HostAndPort> hostAndPorts)\n+    {\n+        if (hostAndPorts.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        return Optional.of(hostAndPorts.get(ThreadLocalRandom.current().nextInt(hostAndPorts.size())));\n+    }\n+}"
  },
  {
    "sha": "e832696042f6897577ec2e590ed62f7438f21603",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceGroupService.java",
    "status": "added",
    "additions": 23,
    "deletions": 0,
    "changes": 23,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceGroupService.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceGroupService.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceGroupService.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,23 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import com.facebook.presto.execution.resourceGroups.ResourceGroupRuntimeInfo;\n+\n+import java.util.List;\n+\n+public interface ResourceGroupService\n+{\n+    List<ResourceGroupRuntimeInfo> getResourceGroupInfo();\n+}"
  },
  {
    "sha": "9aadb25007f3162718c17fdfc44a2ad36ce4e639",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerClient.java",
    "status": "added",
    "additions": 42,
    "deletions": 0,
    "changes": 42,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerClient.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerClient.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerClient.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import com.facebook.drift.annotations.ThriftMethod;\n+import com.facebook.drift.annotations.ThriftService;\n+import com.facebook.presto.execution.resourceGroups.ResourceGroupRuntimeInfo;\n+import com.facebook.presto.metadata.InternalNode;\n+import com.facebook.presto.server.BasicQueryInfo;\n+import com.facebook.presto.server.NodeStatus;\n+import com.facebook.presto.spi.memory.ClusterMemoryPoolInfo;\n+import com.facebook.presto.spi.memory.MemoryPoolId;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+@ThriftService(\"PrestoResourceManager\")\n+public interface ResourceManagerClient\n+{\n+    @ThriftMethod\n+    void queryHeartbeat(String internalNode, BasicQueryInfo basicQueryInfo);\n+\n+    @ThriftMethod\n+    List<ResourceGroupRuntimeInfo> getResourceGroupInfo(InternalNode internalNode);\n+\n+    @ThriftMethod\n+    void nodeHeartbeat(NodeStatus nodeStatus);\n+\n+    @ThriftMethod\n+    Map<MemoryPoolId, ClusterMemoryPoolInfo> getMemoryPoolInfo();\n+}"
  },
  {
    "sha": "74dd7c6d1569860e04b1e74f7b64e9d1a4ebab4e",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerClusterStateProvider.java",
    "status": "added",
    "additions": 411,
    "deletions": 0,
    "changes": 411,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerClusterStateProvider.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerClusterStateProvider.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerClusterStateProvider.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import com.facebook.presto.execution.resourceGroups.ResourceGroupRuntimeInfo;\n+import com.facebook.presto.memory.ClusterMemoryPool;\n+import com.facebook.presto.memory.MemoryInfo;\n+import com.facebook.presto.memory.NodeMemoryConfig;\n+import com.facebook.presto.metadata.SessionPropertyManager;\n+import com.facebook.presto.server.BasicQueryInfo;\n+import com.facebook.presto.server.NodeStatus;\n+import com.facebook.presto.spi.QueryId;\n+import com.facebook.presto.spi.memory.ClusterMemoryPoolInfo;\n+import com.facebook.presto.spi.memory.MemoryPoolId;\n+import com.facebook.presto.spi.resourceGroups.ResourceGroupId;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.Duration;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.inject.Inject;\n+import javax.validation.constraints.NotNull;\n+\n+import java.net.URI;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.facebook.presto.SystemSessionProperties.resourceOvercommit;\n+import static com.facebook.presto.execution.QueryState.QUEUED;\n+import static com.facebook.presto.memory.LocalMemoryManager.GENERAL_POOL;\n+import static com.facebook.presto.memory.LocalMemoryManager.RESERVED_POOL;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class ResourceManagerClusterStateProvider\n+{\n+    private final Map<String, NodeQueryState> nodeQueryStates = new ConcurrentHashMap<>();\n+    private final Map<String, InternalNodeState> nodeStatuses = new ConcurrentHashMap<>();\n+\n+    private final SessionPropertyManager sessionPropertyManager;\n+    private final int maxCompletedQueries;\n+    private final Duration queryExpirationTimeout;\n+    private final Duration completedQueryExpirationTimeout;\n+    private final boolean isReservedPoolEnabled;\n+\n+    @Inject\n+    public ResourceManagerClusterStateProvider(\n+            SessionPropertyManager sessionPropertyManager,\n+            ResourceManagerConfig resourceManagerConfig,\n+            NodeMemoryConfig nodeMemoryConfig,\n+            @ForResourceManager ScheduledExecutorService scheduledExecutorService)\n+    {\n+        this(\n+                sessionPropertyManager,\n+                requireNonNull(resourceManagerConfig, \"resourceManagerConfig is null\").getMaxCompletedQueries(),\n+                requireNonNull(resourceManagerConfig, \"resourceManagerConfig is null\").getQueryExpirationTimeout(),\n+                requireNonNull(resourceManagerConfig, \"resourceManagerConfig is null\").getCompletedQueryExpirationTimeout(),\n+                requireNonNull(resourceManagerConfig, \"resourceManagerConfig is null\").getNodeStatusTimeout(),\n+                requireNonNull(nodeMemoryConfig, \"nodeMemoryConfig is null\").isReservedPoolEnabled(),\n+                scheduledExecutorService);\n+    }\n+\n+    public ResourceManagerClusterStateProvider(\n+            SessionPropertyManager sessionPropertyManager,\n+            int maxCompletedQueries,\n+            Duration queryExpirationTimeout,\n+            Duration completedQueryExpirationTimeout,\n+            Duration nodeStatusTimeout,\n+            boolean isReservedPoolEnabled,\n+            ScheduledExecutorService scheduledExecutorService)\n+    {\n+        this.sessionPropertyManager = requireNonNull(sessionPropertyManager, \"sessionPropertyManager is null\");\n+        this.maxCompletedQueries = maxCompletedQueries;\n+        this.queryExpirationTimeout = queryExpirationTimeout;\n+        this.completedQueryExpirationTimeout = completedQueryExpirationTimeout;\n+        this.isReservedPoolEnabled = isReservedPoolEnabled;\n+\n+        requireNonNull(scheduledExecutorService, \"scheduledExecutorService is null\");\n+        scheduledExecutorService.scheduleAtFixedRate(() -> {\n+            for (NodeQueryState nodeQueryState : ImmutableList.copyOf(nodeQueryStates.values())) {\n+                nodeQueryState.purgeExpiredQueries();\n+            }\n+        }, 100, 100, MILLISECONDS);\n+\n+        scheduledExecutorService.scheduleAtFixedRate(() -> {\n+            for (Map.Entry<String, InternalNodeState> nodeEntry : ImmutableList.copyOf(nodeStatuses.entrySet())) {\n+                if ((System.currentTimeMillis() - nodeEntry.getValue().getLastHeartbeatInMillis()) > nodeStatusTimeout.toMillis()) {\n+                    nodeStatuses.remove(nodeEntry.getKey());\n+                }\n+            }\n+        }, 100, 100, MILLISECONDS);\n+    }\n+\n+    public void registerHeartbeat(String nodeId, BasicQueryInfo basicQueryInfo)\n+    {\n+        NodeQueryState state = nodeQueryStates.computeIfAbsent(nodeId, identifier -> new NodeQueryState(\n+                nodeId,\n+                maxCompletedQueries,\n+                queryExpirationTimeout.toMillis(),\n+                completedQueryExpirationTimeout.toMillis()));\n+        state.updateQuery(basicQueryInfo);\n+    }\n+\n+    public void registerHeartbeat(NodeStatus nodeStatus)\n+    {\n+        InternalNodeState nodeState = nodeStatuses.get(nodeStatus.getNodeId());\n+        if (nodeState == null) {\n+            nodeStatuses.put(nodeStatus.getNodeId(), new InternalNodeState(nodeStatus));\n+        }\n+        else {\n+            nodeState.updateNodeStatus(nodeStatus);\n+        }\n+    }\n+\n+    public List<ResourceGroupRuntimeInfo> getResourceGroups(String excludingNode)\n+    {\n+        Map<ResourceGroupId, ResourceGroupRuntimeInfo.Builder> resourceGroupBuilders = new HashMap<>();\n+        nodeQueryStates.values().stream()\n+                .filter(state -> !state.getNodeId().equals(excludingNode))\n+                .map(NodeQueryState::getActiveQueries)\n+                .flatMap(Collection::stream)\n+                .map(Query::getBasicQueryInfo)\n+                .filter(info -> info.getResourceGroupId().isPresent())\n+                .forEach(info -> {\n+                    ResourceGroupId resourceGroupId = info.getResourceGroupId().get();\n+                    ResourceGroupRuntimeInfo.Builder builder = resourceGroupBuilders.computeIfAbsent(resourceGroupId, ResourceGroupRuntimeInfo::builder);\n+                    if (info.getState() == QUEUED) {\n+                        builder.addQueuedQueries(1);\n+                    }\n+                    else if (!info.getState().isDone()) {\n+                        builder.addRunningQueries(1);\n+                    }\n+                    builder.addUserMemoryReservationBytes(info.getQueryStats().getUserMemoryReservation().toBytes());\n+                    while (resourceGroupId.getParent().isPresent()) {\n+                        resourceGroupId = resourceGroupId.getParent().get();\n+                        ResourceGroupRuntimeInfo.Builder parentBuilder = resourceGroupBuilders.computeIfAbsent(resourceGroupId, ResourceGroupRuntimeInfo::builder);\n+                        if (info.getState() == QUEUED) {\n+                            parentBuilder.addDescendantQueuedQueries(1);\n+                        }\n+                        else if (!info.getState().isDone()) {\n+                            parentBuilder.addDescendantRunningQueries(1);\n+                        }\n+                    }\n+                });\n+        return resourceGroupBuilders.values().stream().map(ResourceGroupRuntimeInfo.Builder::build).collect(toImmutableList());\n+    }\n+\n+    public List<BasicQueryInfo> getQueryInfos()\n+    {\n+        return ImmutableList.copyOf(nodeQueryStates.values()).stream()\n+                .map(NodeQueryState::getAllQueries)\n+                .flatMap(Collection::stream)\n+                .map(Query::getBasicQueryInfo)\n+                .collect(toImmutableList());\n+    }\n+\n+    public Map<MemoryPoolId, ClusterMemoryPoolInfo> getClusterMemoryPoolInfos()\n+    {\n+        List<MemoryInfo> memoryInfos = nodeStatuses.values().stream()\n+                .map(nodeStatus -> nodeStatus.getNodeStatus().getMemoryInfo())\n+                .collect(toImmutableList());\n+\n+        int generalPoolCounts = 0;\n+        int reservedPoolCounts = 0;\n+        Query largestGeneralPoolQuery = null;\n+        for (NodeQueryState nodeQueryState : nodeQueryStates.values()) {\n+            for (Query query : nodeQueryState.getActiveQueries()) {\n+                MemoryPoolId memoryPool = query.getBasicQueryInfo().getMemoryPool();\n+                if (GENERAL_POOL.equals(memoryPool)) {\n+                    generalPoolCounts = Math.incrementExact(generalPoolCounts);\n+                    if (!resourceOvercommit(query.getBasicQueryInfo().getSession().toSession(sessionPropertyManager))) {\n+                        largestGeneralPoolQuery = getLargestMemoryQuery(largestGeneralPoolQuery, query);\n+                    }\n+                }\n+                else if (RESERVED_POOL.equals(memoryPool)) {\n+                    reservedPoolCounts = Math.incrementExact(reservedPoolCounts);\n+                }\n+                else {\n+                    throw new IllegalArgumentException(\"Unrecognized memory pool: \" + memoryPool);\n+                }\n+            }\n+        }\n+\n+        ImmutableMap.Builder<MemoryPoolId, ClusterMemoryPoolInfo> memoryPoolInfos = ImmutableMap.builder();\n+        ClusterMemoryPool pool = new ClusterMemoryPool(GENERAL_POOL);\n+        pool.update(memoryInfos, generalPoolCounts);\n+        ClusterMemoryPoolInfo clusterInfo = pool.getClusterInfo(Optional.ofNullable(largestGeneralPoolQuery).map(Query::getQueryId));\n+        memoryPoolInfos.put(GENERAL_POOL, clusterInfo);\n+        if (isReservedPoolEnabled) {\n+            pool = new ClusterMemoryPool(RESERVED_POOL);\n+            pool.update(memoryInfos, reservedPoolCounts);\n+            memoryPoolInfos.put(RESERVED_POOL, pool.getClusterInfo());\n+        }\n+        return memoryPoolInfos.build();\n+    }\n+\n+    private Query getLargestMemoryQuery(@Nullable Query existingLargeQuery, @NotNull Query newQuery)\n+    {\n+        requireNonNull(newQuery, \"newQuery must not be null\");\n+        if (existingLargeQuery == null) {\n+            return newQuery;\n+        }\n+        long largestGeneralBytes = existingLargeQuery.getBasicQueryInfo().getQueryStats().getTotalMemoryReservation().toBytes();\n+        long currentGeneralBytes = newQuery.getBasicQueryInfo().getQueryStats().getTotalMemoryReservation().toBytes();\n+        if (currentGeneralBytes > largestGeneralBytes) {\n+            return newQuery;\n+        }\n+        return existingLargeQuery;\n+    }\n+\n+    public synchronized Map<String, MemoryInfo> getWorkerMemoryInfo()\n+    {\n+        return nodeStatuses.entrySet().stream().collect(toImmutableMap(e -> {\n+            String nodeIdentifier = e.getValue().getNodeStatus().getNodeId();\n+            String nodeHost = URI.create(e.getValue().getNodeStatus().getExternalAddress()).getHost();\n+            return nodeIdentifier + \" [\" + nodeHost + \"]\";\n+        }, e -> e.getValue().getNodeStatus().getMemoryInfo()));\n+    }\n+\n+    private static class NodeQueryState\n+    {\n+        private final String nodeId;\n+        private final int maxCompletedQueries;\n+        private final long queryExpirationTimeoutMillis;\n+        private final long completedQueryExpirationTimeoutMillis;\n+\n+        @GuardedBy(\"this\")\n+        private final Map<QueryId, Query> activeQueries = new HashMap<>();\n+        @GuardedBy(\"this\")\n+        private final Map<QueryId, Query> completedQueries = new LinkedHashMap<>();\n+\n+        public NodeQueryState(String nodeId, int maxCompletedQueries, long queryExpirationTimeoutMillis, long completedQueryExpirationTimeoutMillis)\n+        {\n+            this.nodeId = requireNonNull(nodeId, \"nodeId is null\");\n+            checkArgument(maxCompletedQueries > 0);\n+            checkArgument(queryExpirationTimeoutMillis > 0);\n+            checkArgument(completedQueryExpirationTimeoutMillis > 0);\n+            this.maxCompletedQueries = maxCompletedQueries;\n+            this.queryExpirationTimeoutMillis = queryExpirationTimeoutMillis;\n+            this.completedQueryExpirationTimeoutMillis = completedQueryExpirationTimeoutMillis;\n+        }\n+\n+        public synchronized NodeQueryState updateQuery(BasicQueryInfo basicQueryInfo)\n+        {\n+            QueryId queryId = basicQueryInfo.getQueryId();\n+            Query query = activeQueries.get(queryId);\n+            if (query == null) {\n+                query = new Query(basicQueryInfo);\n+                activeQueries.put(queryId, query);\n+            }\n+            else {\n+                query = query.updateQueryInfo(basicQueryInfo);\n+            }\n+            if (isQueryCompleted(query)) {\n+                completedQueries.put(query.getQueryId(), query);\n+                activeQueries.remove(query.getQueryId());\n+            }\n+            return this;\n+        }\n+\n+        public synchronized void purgeExpiredQueries()\n+        {\n+            long currentTimeMillis = System.currentTimeMillis();\n+\n+            Iterator<Query> queryIterator = activeQueries.values().iterator();\n+            while (queryIterator.hasNext()) {\n+                Query query = queryIterator.next();\n+                if (isQueryExpired(query, currentTimeMillis, queryExpirationTimeoutMillis)) {\n+                    completedQueries.put(query.getQueryId(), query);\n+                    queryIterator.remove();\n+                }\n+            }\n+\n+            Iterator<Query> completedQueriesIterator = completedQueries.values().iterator();\n+            while (completedQueriesIterator.hasNext()) {\n+                Query query = completedQueriesIterator.next();\n+                if (completedQueries.size() <= maxCompletedQueries && !isQueryExpired(query, currentTimeMillis, completedQueryExpirationTimeoutMillis)) {\n+                    break;\n+                }\n+                completedQueriesIterator.remove();\n+            }\n+        }\n+\n+        private boolean isQueryExpired(Query query, long currentTimeMillis, long timeout)\n+        {\n+            return (currentTimeMillis - query.getLastHeartbeatInMillis()) > timeout;\n+        }\n+\n+        private boolean isQueryCompleted(Query query)\n+        {\n+            return query.getBasicQueryInfo().getState().isDone();\n+        }\n+\n+        public String getNodeId()\n+        {\n+            return nodeId;\n+        }\n+\n+        public synchronized List<Query> getActiveQueries()\n+        {\n+            return ImmutableList.copyOf(activeQueries.values());\n+        }\n+\n+        public synchronized List<Query> getAllQueries()\n+        {\n+            purgeExpiredQueries();\n+            return ImmutableList.<Query>builder().addAll(activeQueries.values()).addAll(completedQueries.values()).build();\n+        }\n+    }\n+\n+    private static final class InternalNodeState\n+    {\n+        private volatile NodeStatus nodeStatus;\n+        private final AtomicLong lastHeartbeatInMillis = new AtomicLong();\n+\n+        private InternalNodeState(NodeStatus nodeStatus)\n+        {\n+            this.nodeStatus = nodeStatus;\n+            recordHeartbeat();\n+        }\n+\n+        private void recordHeartbeat()\n+        {\n+            this.lastHeartbeatInMillis.set(System.currentTimeMillis());\n+        }\n+\n+        public long getLastHeartbeatInMillis()\n+        {\n+            return lastHeartbeatInMillis.get();\n+        }\n+\n+        public InternalNodeState updateNodeStatus(NodeStatus nodeStatus)\n+        {\n+            this.nodeStatus = nodeStatus;\n+            recordHeartbeat();\n+            return this;\n+        }\n+\n+        public NodeStatus getNodeStatus()\n+        {\n+            return nodeStatus;\n+        }\n+    }\n+\n+    public static class Query\n+    {\n+        private final QueryId queryId;\n+\n+        private volatile BasicQueryInfo basicQueryInfo;\n+        private final AtomicLong lastHeartbeatInMillis = new AtomicLong();\n+\n+        public Query(BasicQueryInfo basicQueryInfo)\n+        {\n+            this.queryId = basicQueryInfo.getQueryId();\n+            this.basicQueryInfo = basicQueryInfo;\n+            recordHeartbeat();\n+        }\n+\n+        private void recordHeartbeat()\n+        {\n+            this.lastHeartbeatInMillis.set(System.currentTimeMillis());\n+        }\n+\n+        public long getLastHeartbeatInMillis()\n+        {\n+            return lastHeartbeatInMillis.get();\n+        }\n+\n+        public Query updateQueryInfo(BasicQueryInfo basicQueryInfo)\n+        {\n+            if (basicQueryInfo.getState().getValue() >= this.basicQueryInfo.getState().getValue()) {\n+                this.basicQueryInfo = basicQueryInfo;\n+            }\n+            recordHeartbeat();\n+            return this;\n+        }\n+\n+        public QueryId getQueryId()\n+        {\n+            return queryId;\n+        }\n+\n+        public BasicQueryInfo getBasicQueryInfo()\n+        {\n+            return basicQueryInfo;\n+        }\n+    }\n+}"
  },
  {
    "sha": "86f32279ed952e2e6e8d3168c0f45c08b867da49",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerClusterStatusSender.java",
    "status": "added",
    "additions": 142,
    "deletions": 0,
    "changes": 142,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerClusterStatusSender.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerClusterStatusSender.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerClusterStatusSender.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import com.facebook.drift.client.DriftClient;\n+import com.facebook.presto.execution.ManagedQueryExecution;\n+import com.facebook.presto.metadata.InternalNodeManager;\n+import com.facebook.presto.server.BasicQueryInfo;\n+import com.facebook.presto.server.NodeStatus;\n+import com.facebook.presto.server.StatusResource;\n+import com.facebook.presto.spi.HostAddress;\n+import com.facebook.presto.spi.QueryId;\n+import com.facebook.presto.util.PeriodicTaskExecutor;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Supplier;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ResourceManagerClusterStatusSender\n+        implements ClusterStatusSender\n+{\n+    private final DriftClient<ResourceManagerClient> resourceManagerClient;\n+    private final InternalNodeManager internalNodeManager;\n+    private final Supplier<NodeStatus> statusSupplier;\n+    private final ScheduledExecutorService executor;\n+    private final ResourceManagerConfig resourceManagerConfig;\n+\n+    private final ConcurrentMap<QueryId, PeriodicTaskExecutor> queries = new ConcurrentHashMap<>();\n+\n+    private PeriodicTaskExecutor nodeHeartbeatSender;\n+\n+    @Inject\n+    public ResourceManagerClusterStatusSender(\n+            @ForResourceManager DriftClient<ResourceManagerClient> resourceManagerClient,\n+            InternalNodeManager internalNodeManager,\n+            StatusResource statusResource,\n+            @ForResourceManager ScheduledExecutorService executor,\n+            ResourceManagerConfig resourceManagerConfig)\n+    {\n+        this.resourceManagerClient = requireNonNull(resourceManagerClient, \"resourceManagerService is null\");\n+        this.internalNodeManager = requireNonNull(internalNodeManager, \"internalNodeManager is null\");\n+        requireNonNull(statusResource, \"statusResource is null\");\n+        this.statusSupplier = statusResource::getStatus;\n+        this.executor = requireNonNull(executor, \"executor is null\");\n+        this.resourceManagerConfig = requireNonNull(resourceManagerConfig, \"resourceManagerConfig is null\");\n+    }\n+\n+    public ResourceManagerClusterStatusSender(\n+            DriftClient<ResourceManagerClient> resourceManagerClient,\n+            InternalNodeManager internalNodeManager,\n+            Supplier<NodeStatus> statusResource,\n+            ScheduledExecutorService executor,\n+            ResourceManagerConfig resourceManagerConfig)\n+    {\n+        this.resourceManagerClient = requireNonNull(resourceManagerClient, \"resourceManagerService is null\");\n+        this.internalNodeManager = requireNonNull(internalNodeManager, \"internalNodeManager is null\");\n+        this.statusSupplier = requireNonNull(statusResource, \"statusResource is null\");\n+        this.executor = requireNonNull(executor, \"executor is null\");\n+        this.resourceManagerConfig = requireNonNull(resourceManagerConfig, \"resourceManagerConfig is null\");\n+    }\n+\n+    @PostConstruct\n+    public void init()\n+    {\n+        nodeHeartbeatSender = new PeriodicTaskExecutor(resourceManagerConfig.getNodeHeartbeatInterval().toMillis(), executor, this::sendNodeHeartbeat);\n+    }\n+\n+    @PreDestroy\n+    public void stop()\n+    {\n+        queries.values().forEach(PeriodicTaskExecutor::stop);\n+        if (nodeHeartbeatSender != null) {\n+            nodeHeartbeatSender.stop();\n+        }\n+    }\n+\n+    @Override\n+    public void registerQuery(ManagedQueryExecution queryExecution)\n+    {\n+        QueryId queryId = queryExecution.getBasicQueryInfo().getQueryId();\n+        queries.computeIfAbsent(queryId, unused -> new PeriodicTaskExecutor(\n+                resourceManagerConfig.getQueryHeartbeatInterval().toMillis(),\n+                executor,\n+                () -> sendQueryHeartbeat(queryExecution)));\n+        queryExecution.addStateChangeListener(newState -> {\n+            if (newState.isDone()) {\n+                queries.computeIfPresent(queryId, (unused, queryHeartbeatSender) -> {\n+                    queryHeartbeatSender.forceRun();\n+                    queryHeartbeatSender.stop();\n+                    return null;\n+                });\n+            }\n+        });\n+    }\n+\n+    private void sendQueryHeartbeat(ManagedQueryExecution queryExecution)\n+    {\n+        BasicQueryInfo basicQueryInfo = queryExecution.getBasicQueryInfo();\n+        String nodeIdentifier = internalNodeManager.getCurrentNode().getNodeIdentifier();\n+        getResourceManagers().forEach(hostAndPort ->\n+                resourceManagerClient.get(Optional.of(hostAndPort.toString())).queryHeartbeat(nodeIdentifier, basicQueryInfo));\n+    }\n+\n+    private void sendNodeHeartbeat()\n+    {\n+        getResourceManagers().forEach(hostAndPort ->\n+                resourceManagerClient.get(Optional.of(hostAndPort.toString())).nodeHeartbeat(statusSupplier.get()));\n+    }\n+\n+    private List<HostAddress> getResourceManagers()\n+    {\n+        return internalNodeManager.getResourceManagers()\n+                .stream()\n+                .filter(node -> node.getThriftPort().isPresent())\n+                .map(resourceManagerNode -> {\n+                    HostAddress hostAndPort = resourceManagerNode.getHostAndPort();\n+                    return HostAddress.fromParts(hostAndPort.getHostText(), resourceManagerNode.getThriftPort().getAsInt());\n+                })\n+                .collect(toImmutableList());\n+    }\n+}"
  },
  {
    "sha": "b80a65552cfe6f917daf295d42f573ee1085c28f",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerConfig.java",
    "status": "added",
    "additions": 156,
    "deletions": 0,
    "changes": 156,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerConfig.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerConfig.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerConfig.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import com.facebook.airlift.configuration.Config;\n+import com.facebook.airlift.configuration.ConfigDescription;\n+import io.airlift.units.Duration;\n+import io.airlift.units.MinDuration;\n+\n+import javax.validation.constraints.Min;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public class ResourceManagerConfig\n+{\n+    private Duration queryExpirationTimeout = new Duration(10, SECONDS);\n+    private Duration completedQueryExpirationTimeout = new Duration(10, MINUTES);\n+    private int maxCompletedQueries = 100;\n+    private Duration nodeStatusTimeout = new Duration(30, SECONDS);\n+    private Duration queryHeartbeatInterval = new Duration(1, SECONDS);\n+    private Duration nodeHeartbeatInterval = new Duration(1, SECONDS);\n+    private int heartbeatThreads = 3;\n+    private int heartbeatConcurrency = 3;\n+    private Duration memoryPoolFetchInterval = new Duration(1, SECONDS);\n+\n+    @MinDuration(\"1ms\")\n+    public Duration getQueryExpirationTimeout()\n+    {\n+        return queryExpirationTimeout;\n+    }\n+\n+    @Config(\"resource-manager.query-expiration-timeout\")\n+    public ResourceManagerConfig setQueryExpirationTimeout(Duration queryExpirationTimeout)\n+    {\n+        this.queryExpirationTimeout = queryExpirationTimeout;\n+        return this;\n+    }\n+\n+    @MinDuration(\"1ms\")\n+    public Duration getCompletedQueryExpirationTimeout()\n+    {\n+        return completedQueryExpirationTimeout;\n+    }\n+\n+    @Config(\"resource-manager.completed-query-expiration-timeout\")\n+    public ResourceManagerConfig setCompletedQueryExpirationTimeout(Duration completedQueryExpirationTimeout)\n+    {\n+        this.completedQueryExpirationTimeout = completedQueryExpirationTimeout;\n+        return this;\n+    }\n+\n+    @Min(1)\n+    public int getMaxCompletedQueries()\n+    {\n+        return maxCompletedQueries;\n+    }\n+\n+    @Config(\"resource-manager.max-completed-queries\")\n+    public ResourceManagerConfig setMaxCompletedQueries(int maxCompletedQueries)\n+    {\n+        this.maxCompletedQueries = maxCompletedQueries;\n+        return this;\n+    }\n+\n+    @MinDuration(\"1ms\")\n+    public Duration getNodeStatusTimeout()\n+    {\n+        return nodeStatusTimeout;\n+    }\n+\n+    @Config(\"resource-manager.node-status-timeout\")\n+    public ResourceManagerConfig setNodeStatusTimeout(Duration nodeStatusTimeout)\n+    {\n+        this.nodeStatusTimeout = nodeStatusTimeout;\n+        return this;\n+    }\n+\n+    @MinDuration(\"1ms\")\n+    public Duration getQueryHeartbeatInterval()\n+    {\n+        return queryHeartbeatInterval;\n+    }\n+\n+    @Config(\"resource-manager.query-heartbeat-interval\")\n+    public ResourceManagerConfig setQueryHeartbeatInterval(Duration queryHeartbeatInterval)\n+    {\n+        this.queryHeartbeatInterval = queryHeartbeatInterval;\n+        return this;\n+    }\n+\n+    @MinDuration(\"1ms\")\n+    public Duration getNodeHeartbeatInterval()\n+    {\n+        return nodeHeartbeatInterval;\n+    }\n+\n+    @Config(\"resource-manager.node-heartbeat-interval\")\n+    public ResourceManagerConfig setNodeHeartbeatInterval(Duration nodeHeartbeatInterval)\n+    {\n+        this.nodeHeartbeatInterval = nodeHeartbeatInterval;\n+        return this;\n+    }\n+\n+    @Min(1)\n+    public int getHeartbeatThreads()\n+    {\n+        return heartbeatThreads;\n+    }\n+\n+    @Config(\"resource-manager.heartbeat-threads\")\n+    @ConfigDescription(\"Total number of timeout threads across all timeout thread pools\")\n+    public ResourceManagerConfig setHeartbeatThreads(int heartbeatThreads)\n+    {\n+        this.heartbeatThreads = heartbeatThreads;\n+        return this;\n+    }\n+\n+    @Min(1)\n+    public int getHeartbeatConcurrency()\n+    {\n+        return heartbeatConcurrency;\n+    }\n+\n+    @Config(\"resource-manager.heartbeat-concurrency\")\n+    @ConfigDescription(\"Number of thread pools to handle timeouts. Threads per pool is calculated by http-timeout-threads / http-timeout-concurrency\")\n+    public ResourceManagerConfig setHeartbeatConcurrency(int heartbeatConcurrency)\n+    {\n+        this.heartbeatConcurrency = heartbeatConcurrency;\n+        return this;\n+    }\n+\n+    @MinDuration(\"1ms\")\n+    public Duration getMemoryPoolFetchInterval()\n+    {\n+        return memoryPoolFetchInterval;\n+    }\n+\n+    @Config(\"resource-manager.memory-pool-fetch-interval\")\n+    public ResourceManagerConfig setMemoryPoolFetchInterval(Duration memoryPoolFetchInterval)\n+    {\n+        this.memoryPoolFetchInterval = memoryPoolFetchInterval;\n+        return this;\n+    }\n+}"
  },
  {
    "sha": "df0150cab38f88a2ca6a49c4168d797bd3e567c9",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerResourceGroupService.java",
    "status": "added",
    "additions": 72,
    "deletions": 0,
    "changes": 72,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerResourceGroupService.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerResourceGroupService.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerResourceGroupService.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import com.facebook.drift.client.DriftClient;\n+import com.facebook.presto.execution.resourceGroups.ResourceGroupRuntimeInfo;\n+import com.facebook.presto.metadata.InternalNode;\n+import com.facebook.presto.metadata.InternalNodeManager;\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+\n+import static com.google.common.cache.CacheLoader.asyncReloading;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public class ResourceManagerResourceGroupService\n+        implements ResourceGroupService\n+{\n+    private final DriftClient<ResourceManagerClient> resourceManagerClient;\n+    private final InternalNodeManager internalNodeManager;\n+    private final Cache<InternalNode, List<ResourceGroupRuntimeInfo>> cache;\n+    private final Executor executor = Executors.newCachedThreadPool();\n+\n+    @Inject\n+    public ResourceManagerResourceGroupService(\n+            @ForResourceManager DriftClient<ResourceManagerClient> resourceManagerClient,\n+            InternalNodeManager internalNodeManager)\n+    {\n+        this.resourceManagerClient = requireNonNull(resourceManagerClient, \"resourceManagerService is null\");\n+        this.internalNodeManager = requireNonNull(internalNodeManager, \"internalNodeManager is null\");\n+        this.cache = CacheBuilder.newBuilder()\n+                .expireAfterWrite(10, SECONDS)\n+                .refreshAfterWrite(1, SECONDS)\n+                .build(asyncReloading(CacheLoader.from(this::getResourceGroupInfos), executor));\n+    }\n+\n+    @Override\n+    public List<ResourceGroupRuntimeInfo> getResourceGroupInfo()\n+    {\n+        try {\n+            InternalNode currentNode = internalNodeManager.getCurrentNode();\n+            return cache.get(currentNode, () -> getResourceGroupInfos(currentNode));\n+        }\n+        catch (ExecutionException e) {\n+            throw new RuntimeException(e.getCause());\n+        }\n+    }\n+\n+    private List<ResourceGroupRuntimeInfo> getResourceGroupInfos(InternalNode internalNode)\n+    {\n+        return resourceManagerClient.get().getResourceGroupInfo(internalNode);\n+    }\n+}"
  },
  {
    "sha": "6fc0d60b367e6ead671242b473b9d4dde5ef1783",
    "filename": "presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerServer.java",
    "status": "added",
    "additions": 66,
    "deletions": 0,
    "changes": 66,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerServer.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerServer.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/resourcemanager/ResourceManagerServer.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.resourcemanager;\n+\n+import com.facebook.drift.annotations.ThriftMethod;\n+import com.facebook.drift.annotations.ThriftService;\n+import com.facebook.presto.execution.resourceGroups.ResourceGroupRuntimeInfo;\n+import com.facebook.presto.metadata.InternalNode;\n+import com.facebook.presto.server.BasicQueryInfo;\n+import com.facebook.presto.server.NodeStatus;\n+import com.facebook.presto.spi.memory.ClusterMemoryPoolInfo;\n+import com.facebook.presto.spi.memory.MemoryPoolId;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+@ThriftService(value = \"presto-resource-manager\", idlName = \"PrestoResourceManager\")\n+public class ResourceManagerServer\n+{\n+    private final ResourceManagerClusterStateProvider clusterStateProvider;\n+\n+    @Inject\n+    public ResourceManagerServer(ResourceManagerClusterStateProvider clusterStateProvider)\n+    {\n+        this.clusterStateProvider = requireNonNull(clusterStateProvider, \"internalNodeManager is null\");\n+    }\n+\n+    @ThriftMethod\n+    public void queryHeartbeat(String nodeId, BasicQueryInfo basicQueryInfo)\n+    {\n+        clusterStateProvider.registerHeartbeat(nodeId, basicQueryInfo);\n+    }\n+\n+    @ThriftMethod\n+    public List<ResourceGroupRuntimeInfo> getResourceGroupInfo(InternalNode excludingNode)\n+    {\n+        return clusterStateProvider.getResourceGroups(excludingNode.getNodeIdentifier());\n+    }\n+\n+    @ThriftMethod\n+    public Map<MemoryPoolId, ClusterMemoryPoolInfo> getMemoryPoolInfo()\n+    {\n+        return clusterStateProvider.getClusterMemoryPoolInfos();\n+    }\n+\n+    @ThriftMethod\n+    public void nodeHeartbeat(NodeStatus nodeStatus)\n+    {\n+        clusterStateProvider.registerHeartbeat(nodeStatus);\n+    }\n+}"
  },
  {
    "sha": "359bd6eca70f05ac1fdc6c3404401acffdc51987",
    "filename": "presto-main/src/main/java/com/facebook/presto/server/ClusterStatsResource.java",
    "status": "modified",
    "additions": 62,
    "deletions": 5,
    "changes": 67,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/server/ClusterStatsResource.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/server/ClusterStatsResource.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/server/ClusterStatsResource.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -13,10 +13,13 @@\n  */\n package com.facebook.presto.server;\n \n+import com.facebook.airlift.http.client.HttpClient;\n+import com.facebook.airlift.http.client.Request;\n import com.facebook.presto.dispatcher.DispatchManager;\n import com.facebook.presto.execution.QueryState;\n import com.facebook.presto.execution.scheduler.NodeSchedulerConfig;\n import com.facebook.presto.memory.ClusterMemoryManager;\n+import com.facebook.presto.metadata.InternalNode;\n import com.facebook.presto.metadata.InternalNodeManager;\n import com.facebook.presto.spi.NodeState;\n import com.fasterxml.jackson.annotation.JsonCreator;\n@@ -25,15 +28,24 @@\n import javax.annotation.security.RolesAllowed;\n import javax.inject.Inject;\n import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n import javax.ws.rs.Path;\n import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriInfo;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n \n import static com.facebook.presto.server.security.RoleType.ADMIN;\n import static com.facebook.presto.server.security.RoleType.USER;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static com.google.common.net.HttpHeaders.X_FORWARDED_PROTO;\n import static java.util.Objects.requireNonNull;\n import static java.util.concurrent.TimeUnit.SECONDS;\n+import static javax.ws.rs.core.MediaType.APPLICATION_JSON_TYPE;\n \n @Path(\"/v1/cluster\")\n @RolesAllowed({ADMIN, USER})\n@@ -42,21 +54,39 @@\n     private final InternalNodeManager nodeManager;\n     private final DispatchManager dispatchManager;\n     private final boolean isIncludeCoordinator;\n+    private final boolean resourceManagerEnabled;\n     private final ClusterMemoryManager clusterMemoryManager;\n+    private final InternalNodeManager internalNodeManager;\n+    private final HttpClient httpClient;\n \n     @Inject\n-    public ClusterStatsResource(NodeSchedulerConfig nodeSchedulerConfig, InternalNodeManager nodeManager, DispatchManager dispatchManager, ClusterMemoryManager clusterMemoryManager)\n+    public ClusterStatsResource(\n+            NodeSchedulerConfig nodeSchedulerConfig,\n+            ServerConfig serverConfig,\n+            InternalNodeManager nodeManager,\n+            DispatchManager dispatchManager,\n+            ClusterMemoryManager clusterMemoryManager,\n+            InternalNodeManager internalNodeManager,\n+            @ForClusterStats HttpClient httpClient)\n     {\n         this.isIncludeCoordinator = requireNonNull(nodeSchedulerConfig, \"nodeSchedulerConfig is null\").isIncludeCoordinator();\n+        this.resourceManagerEnabled = requireNonNull(serverConfig, \"serverConfig is null\").isResourceManagerEnabled();\n         this.nodeManager = requireNonNull(nodeManager, \"nodeManager is null\");\n         this.dispatchManager = requireNonNull(dispatchManager, \"dispatchManager is null\");\n         this.clusterMemoryManager = requireNonNull(clusterMemoryManager, \"clusterMemoryManager is null\");\n+        this.internalNodeManager = requireNonNull(internalNodeManager, \"internalNodeManager is null\");\n+        this.httpClient = requireNonNull(httpClient, \"httpClient is null\");\n     }\n \n     @GET\n     @Produces(MediaType.APPLICATION_JSON)\n-    public ClusterStats getClusterStats()\n+    public Response getClusterStats(@HeaderParam(X_FORWARDED_PROTO) String xForwardedProto, @Context UriInfo uriInfo)\n+            throws IOException\n     {\n+        if (resourceManagerEnabled) {\n+            return proxyClusterStats(xForwardedProto, uriInfo);\n+        }\n+\n         long runningQueries = 0;\n         long blockedQueries = 0;\n         long queuedQueries = 0;\n@@ -96,12 +126,21 @@ else if (query.getState() == QueryState.RUNNING) {\n             }\n         }\n \n-        return new ClusterStats(runningQueries, blockedQueries, queuedQueries, activeNodes, runningDrivers, memoryReservation, totalInputRows, totalInputBytes, totalCpuTimeSecs);\n+        return Response.ok(new ClusterStats(\n+                runningQueries,\n+                blockedQueries,\n+                queuedQueries,\n+                activeNodes,\n+                runningDrivers,\n+                memoryReservation,\n+                totalInputRows,\n+                totalInputBytes,\n+                totalCpuTimeSecs)).build();\n     }\n \n     @GET\n     @Path(\"memory\")\n-    public Response getClusterMemoryPoolInfo()\n+    public Response getClusterMemoryPoolInfo(@HeaderParam(X_FORWARDED_PROTO) String xForwardedProto, @Context UriInfo uriInfo)\n     {\n         return Response.ok()\n                 .entity(clusterMemoryManager.getMemoryPoolInfo())\n@@ -110,13 +149,31 @@ public Response getClusterMemoryPoolInfo()\n \n     @GET\n     @Path(\"workerMemory\")\n-    public Response getWorkerMemoryInfo()\n+    public Response getWorkerMemoryInfo(@HeaderParam(X_FORWARDED_PROTO) String xForwardedProto, @Context UriInfo uriInfo)\n     {\n         return Response.ok()\n                 .entity(clusterMemoryManager.getWorkerMemoryInfo())\n                 .build();\n     }\n \n+    private Response proxyClusterStats(String xForwardedProto, UriInfo uriInfo)\n+            throws IOException\n+    {\n+        InternalNode resourceManagerNode = internalNodeManager.getResourceManagers().iterator().next();\n+        String scheme = isNullOrEmpty(xForwardedProto) ? uriInfo.getRequestUri().getScheme() : xForwardedProto;\n+\n+        Request request = new Request.Builder()\n+                .setMethod(\"GET\")\n+                .setUri(uriInfo.getRequestUriBuilder()\n+                        .scheme(scheme)\n+                        .host(resourceManagerNode.getHostAndPort().toInetAddress().getHostName())\n+                        .port(resourceManagerNode.getInternalUri().getPort())\n+                        .build())\n+                .build();\n+        InputStream responseStream = httpClient.execute(request, new StreamingJsonResponseHandler());\n+        return Response.ok(responseStream, APPLICATION_JSON_TYPE).build();\n+    }\n+\n     public static class ClusterStats\n     {\n         private final long runningQueries;"
  },
  {
    "sha": "939277f77436df00b9a7a2073896151746c9338a",
    "filename": "presto-main/src/main/java/com/facebook/presto/server/CoordinatorModule.java",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/server/CoordinatorModule.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/server/CoordinatorModule.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/server/CoordinatorModule.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -221,6 +221,7 @@ protected void setup(Binder binder)\n \n         // query manager\n         jaxrsBinder(binder).bind(QueryResource.class);\n+        httpClientBinder(binder).bindHttpClient(\"queryInfo\", ForQueryInfo.class);\n         jaxrsBinder(binder).bind(StageResource.class);\n         jaxrsBinder(binder).bind(QueryStateInfoResource.class);\n         jaxrsBinder(binder).bind(ResourceGroupStateInfoResource.class);\n@@ -273,6 +274,7 @@ protected void setup(Binder binder)\n \n         // cluster statistics\n         jaxrsBinder(binder).bind(ClusterStatsResource.class);\n+        httpClientBinder(binder).bindHttpClient(\"clusterStats\", ForClusterStats.class);\n \n         // planner\n         binder.bind(PlanFragmenter.class).in(Scopes.SINGLETON);"
  },
  {
    "sha": "8bda5847264c87a97b27820948ee89a4aafb1836",
    "filename": "presto-main/src/main/java/com/facebook/presto/server/ForClusterStats.java",
    "status": "added",
    "additions": 31,
    "deletions": 0,
    "changes": 31,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/server/ForClusterStats.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/server/ForClusterStats.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/server/ForClusterStats.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,31 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.server;\n+\n+import javax.inject.Qualifier;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.PARAMETER;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+\n+@Retention(RUNTIME)\n+@Target({FIELD, PARAMETER, METHOD})\n+@Qualifier\n+public @interface ForClusterStats\n+{\n+}"
  },
  {
    "sha": "a38f4137631c0450059192a3dcfb32fb6410d1ac",
    "filename": "presto-main/src/main/java/com/facebook/presto/server/ForQueryInfo.java",
    "status": "added",
    "additions": 31,
    "deletions": 0,
    "changes": 31,
    "blob_url": "https://github.com/prestodb/presto/blob/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/server/ForQueryInfo.java",
    "raw_url": "https://github.com/prestodb/presto/raw/f412cfa15800b2bcdbcbbafebdc2948b959b8342/presto-main/src/main/java/com/facebook/presto/server/ForQueryInfo.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/server/ForQueryInfo.java?ref=f412cfa15800b2bcdbcbbafebdc2948b959b8342",
    "patch": "@@ -0,0 +1,31 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.server;\n+\n+import javax.inject.Qualifier;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.PARAMETER;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+\n+@Retention(RUNTIME)\n+@Target({FIELD, PARAMETER, METHOD})\n+@Qualifier\n+public @interface ForQueryInfo\n+{\n+}"
  }
]
