[
  {
    "sha": "e2a2510e584895d30d0bba536e95fac43d7e7415",
    "filename": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/PlanNodeDecorrelator.java",
    "status": "modified",
    "additions": 163,
    "deletions": 3,
    "changes": 166,
    "blob_url": "https://github.com/prestodb/presto/blob/4c57c905854a353cddc87df21664ab7f4e27d057/presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/PlanNodeDecorrelator.java",
    "raw_url": "https://github.com/prestodb/presto/raw/4c57c905854a353cddc87df21664ab7f4e27d057/presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/PlanNodeDecorrelator.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/PlanNodeDecorrelator.java?ref=4c57c905854a353cddc87df21664ab7f4e27d057",
    "patch": "@@ -18,16 +18,23 @@\n import com.facebook.presto.spi.plan.Assignments;\n import com.facebook.presto.spi.plan.FilterNode;\n import com.facebook.presto.spi.plan.LimitNode;\n+import com.facebook.presto.spi.plan.Ordering;\n+import com.facebook.presto.spi.plan.OrderingScheme;\n import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TopNNode;\n import com.facebook.presto.spi.relation.VariableReferenceExpression;\n import com.facebook.presto.sql.ExpressionUtils;\n import com.facebook.presto.sql.planner.PlanVariableAllocator;\n import com.facebook.presto.sql.planner.VariablesExtractor;\n import com.facebook.presto.sql.planner.iterative.Lookup;\n import com.facebook.presto.sql.planner.plan.EnforceSingleRowNode;\n import com.facebook.presto.sql.planner.plan.InternalPlanVisitor;\n+import com.facebook.presto.sql.planner.plan.RowNumberNode;\n+import com.facebook.presto.sql.planner.plan.TopNRowNumberNode;\n+import com.facebook.presto.sql.planner.plan.WindowNode.Specification;\n import com.facebook.presto.sql.tree.ComparisonExpression;\n import com.facebook.presto.sql.tree.Expression;\n import com.facebook.presto.sql.tree.SymbolReference;\n@@ -44,13 +51,15 @@\n import java.util.Set;\n import java.util.stream.Collectors;\n \n+import static com.facebook.presto.common.type.BigintType.BIGINT;\n import static com.facebook.presto.spi.plan.AggregationNode.singleGroupingSet;\n import static com.facebook.presto.sql.planner.plan.AssignmentUtils.identitiesAsSymbolReferences;\n import static com.facebook.presto.sql.relational.OriginalExpressionUtils.castToExpression;\n import static com.facebook.presto.sql.relational.OriginalExpressionUtils.castToRowExpression;\n import static com.facebook.presto.sql.tree.ComparisonExpression.Operator.EQUAL;\n import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.lang.Math.toIntExact;\n import static java.util.Objects.requireNonNull;\n \n public class PlanNodeDecorrelator\n@@ -159,10 +168,28 @@ public PlanNodeDecorrelator(PlanNodeIdAllocator idAllocator, PlanVariableAllocat\n                 return childDecorrelationResultOptional;\n             }\n \n-            if (node.getCount() != 1) {\n-                return Optional.empty();\n+            if (node.getCount() == 1) {\n+                return rewriteLimitWithRowCountOne(childDecorrelationResult, node.getId());\n             }\n+            return rewriteLimitWithRowCountGreaterThanOne(childDecorrelationResult, node);\n+        }\n \n+        // TODO Limit (1) could be decorrelated by the method rewriteLimitWithRowCountGreaterThanOne() as well.\n+        // The current decorrelation method for Limit (1) cannot deal with subqueries outputting other symbols\n+        // than constants.\n+        //\n+        // An example query that is currently not supported:\n+        // SELECT (\n+        //      SELECT a+b\n+        //      FROM (VALUES (1, 2), (1, 2)) inner_relation(a, b)\n+        //      WHERE a=x\n+        //      LIMIT 1)\n+        // FROM (VALUES (1)) outer_relation(x)\n+        //\n+        // Switching the decorrelation method would change the way that queries with EXISTS are executed,\n+        // and thus it needs benchmarking.\n+        private Optional<DecorrelationResult> rewriteLimitWithRowCountOne(DecorrelationResult childDecorrelationResult, PlanNodeId nodeId)\n+        {\n             Set<VariableReferenceExpression> constantVariables = childDecorrelationResult.getConstantVariables();\n             PlanNode decorrelatedChildNode = childDecorrelationResult.node;\n \n@@ -173,7 +200,7 @@ public PlanNodeDecorrelator(PlanNodeIdAllocator idAllocator, PlanVariableAllocat\n \n             // Rewrite limit to aggregation on constant symbols\n             AggregationNode aggregationNode = new AggregationNode(\n-                    idAllocator.getNextId(),\n+                    nodeId,\n                     decorrelatedChildNode,\n                     ImmutableMap.of(),\n                     singleGroupingSet(decorrelatedChildNode.getOutputVariables()),\n@@ -190,6 +217,139 @@ public PlanNodeDecorrelator(PlanNodeIdAllocator idAllocator, PlanVariableAllocat\n                     true));\n         }\n \n+        private Optional<DecorrelationResult> rewriteLimitWithRowCountGreaterThanOne(DecorrelationResult childDecorrelationResult, LimitNode node)\n+        {\n+            PlanNode decorrelatedChildNode = childDecorrelationResult.node;\n+\n+            // no rewrite needed (no symbols to partition by)\n+            if (childDecorrelationResult.variablesToPropagate.isEmpty()) {\n+                return Optional.of(new DecorrelationResult(\n+                        node.replaceChildren(ImmutableList.of(decorrelatedChildNode)),\n+                        childDecorrelationResult.variablesToPropagate,\n+                        childDecorrelationResult.correlatedPredicates,\n+                        childDecorrelationResult.correlatedVariablesMapping,\n+                        false));\n+            }\n+\n+            Set<VariableReferenceExpression> constantVariables = childDecorrelationResult.getConstantVariables();\n+            if (!constantVariables.containsAll(childDecorrelationResult.variablesToPropagate)) {\n+                return Optional.empty();\n+            }\n+\n+            // rewrite Limit to RowNumberNode partitioned by constant symbols\n+            RowNumberNode rowNumberNode = new RowNumberNode(\n+                    node.getId(),\n+                    decorrelatedChildNode,\n+                    ImmutableList.copyOf(childDecorrelationResult.variablesToPropagate),\n+                    variableAllocator.newVariable(\"row_number\", BIGINT),\n+                    Optional.of(toIntExact(node.getCount())),\n+                    Optional.empty());\n+\n+            return Optional.of(new DecorrelationResult(\n+                    rowNumberNode,\n+                    childDecorrelationResult.variablesToPropagate,\n+                    childDecorrelationResult.correlatedPredicates,\n+                    childDecorrelationResult.correlatedVariablesMapping,\n+                    false));\n+        }\n+\n+        @Override\n+        public Optional<DecorrelationResult> visitTopN(TopNNode node, Void context)\n+        {\n+            Optional<DecorrelationResult> childDecorrelationResultOptional = lookup.resolve(node.getSource()).accept(this, null);\n+            if (!childDecorrelationResultOptional.isPresent()) {\n+                return Optional.empty();\n+            }\n+\n+            DecorrelationResult childDecorrelationResult = childDecorrelationResultOptional.get();\n+            if (childDecorrelationResult.atMostSingleRow) {\n+                return childDecorrelationResultOptional;\n+            }\n+\n+            PlanNode decorrelatedChildNode = childDecorrelationResult.node;\n+            Set<VariableReferenceExpression> constantVariables = childDecorrelationResult.getConstantVariables();\n+            Optional<OrderingScheme> decorrelatedOrderingScheme = decorrelateOrderingScheme(node.getOrderingScheme(), constantVariables);\n+\n+            // no partitioning needed (no symbols to partition by)\n+            if (childDecorrelationResult.variablesToPropagate.isEmpty()) {\n+                return decorrelatedOrderingScheme\n+                        .map(orderingScheme -> Optional.of(new DecorrelationResult(\n+                                // ordering symbols are present - return decorrelated TopNNode\n+                                new TopNNode(node.getId(), decorrelatedChildNode, node.getCount(), orderingScheme, node.getStep()),\n+                                childDecorrelationResult.variablesToPropagate,\n+                                childDecorrelationResult.correlatedPredicates,\n+                                childDecorrelationResult.correlatedVariablesMapping,\n+                                node.getCount() == 1)))\n+                        .orElseGet(() -> Optional.of(new DecorrelationResult(\n+                                // no ordering symbols are left - convert to LimitNode\n+                                new LimitNode(node.getId(), decorrelatedChildNode, node.getCount(), LimitNode.Step.FINAL),\n+                                childDecorrelationResult.variablesToPropagate,\n+                                childDecorrelationResult.correlatedPredicates,\n+                                childDecorrelationResult.correlatedVariablesMapping,\n+                                node.getCount() == 1)));\n+            }\n+\n+            if (!constantVariables.containsAll(childDecorrelationResult.variablesToPropagate)) {\n+                return Optional.empty();\n+            }\n+\n+            return decorrelatedOrderingScheme\n+                    .map(orderingScheme -> {\n+                        // ordering symbols are present - rewrite TopN to TopNRowNumberNode partitioned by constant symbols\n+                        TopNRowNumberNode topNRowNumberNode = new TopNRowNumberNode(\n+                                node.getId(),\n+                                decorrelatedChildNode,\n+                                new Specification(\n+                                        ImmutableList.copyOf(childDecorrelationResult.variablesToPropagate),\n+                                        Optional.of(orderingScheme)),\n+                                variableAllocator.newVariable(\"row_number\", BIGINT),\n+                                toIntExact(node.getCount()),\n+                                false,\n+                                Optional.empty());\n+\n+                        return Optional.of(new DecorrelationResult(\n+                                topNRowNumberNode,\n+                                childDecorrelationResult.variablesToPropagate,\n+                                childDecorrelationResult.correlatedPredicates,\n+                                childDecorrelationResult.correlatedVariablesMapping,\n+                                node.getCount() == 1));\n+                    })\n+                    .orElseGet(() -> {\n+                        // no ordering symbols are left - rewrite TopN to RowNumberNode partitioned by constant symbols\n+                        RowNumberNode rowNumberNode = new RowNumberNode(\n+                                node.getId(),\n+                                decorrelatedChildNode,\n+                                ImmutableList.copyOf(childDecorrelationResult.variablesToPropagate),\n+                                variableAllocator.newVariable(\"row_number\", BIGINT),\n+                                Optional.of(toIntExact(node.getCount())),\n+                                Optional.empty());\n+\n+                        return Optional.of(new DecorrelationResult(\n+                                rowNumberNode,\n+                                childDecorrelationResult.variablesToPropagate,\n+                                childDecorrelationResult.correlatedPredicates,\n+                                childDecorrelationResult.correlatedVariablesMapping,\n+                                node.getCount() == 1));\n+                    });\n+        }\n+\n+        private Optional<OrderingScheme> decorrelateOrderingScheme(OrderingScheme orderingScheme, Set<VariableReferenceExpression> constantVariables)\n+        {\n+            // remove local and remote constant sort symbols from the OrderingScheme\n+            ImmutableList.Builder<Ordering> nonConstantOrderings = ImmutableList.builder();\n+\n+            for (Ordering ordering : orderingScheme.getOrderBy()) {\n+                if (!constantVariables.contains(ordering.getVariable()) && !correlation.contains(ordering.getVariable())) {\n+                    nonConstantOrderings.add(ordering);\n+                }\n+            }\n+\n+            if (nonConstantOrderings.build().isEmpty()) {\n+                return Optional.empty();\n+            }\n+            return Optional.of(new OrderingScheme(nonConstantOrderings.build()));\n+        }\n+\n         @Override\n         public Optional<DecorrelationResult> visitEnforceSingleRow(EnforceSingleRowNode node, Void context)\n         {"
  },
  {
    "sha": "4b0620c76b2819b9a6131706b2d9fc0c4b429672",
    "filename": "presto-main/src/test/java/com/facebook/presto/sql/planner/TestLogicalPlanner.java",
    "status": "modified",
    "additions": 68,
    "deletions": 0,
    "changes": 68,
    "blob_url": "https://github.com/prestodb/presto/blob/4c57c905854a353cddc87df21664ab7f4e27d057/presto-main/src/test/java/com/facebook/presto/sql/planner/TestLogicalPlanner.java",
    "raw_url": "https://github.com/prestodb/presto/raw/4c57c905854a353cddc87df21664ab7f4e27d057/presto-main/src/test/java/com/facebook/presto/sql/planner/TestLogicalPlanner.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/test/java/com/facebook/presto/sql/planner/TestLogicalPlanner.java?ref=4c57c905854a353cddc87df21664ab7f4e27d057",
    "patch": "@@ -14,6 +14,7 @@\n package com.facebook.presto.sql.planner;\n \n import com.facebook.presto.Session;\n+import com.facebook.presto.common.block.SortOrder;\n import com.facebook.presto.spi.plan.AggregationNode;\n import com.facebook.presto.spi.plan.DistinctLimitNode;\n import com.facebook.presto.spi.plan.FilterNode;\n@@ -606,6 +607,73 @@ public void testCorrelatedSubqueries()\n                                 tableScan(\"orders\", ImmutableMap.of(\"X\", \"orderkey\")))));\n     }\n \n+    @Test\n+    public void testCorrelatedJoinWithLimit()\n+    {\n+        // rewrite Limit to RowNumberNode\n+        assertPlan(\n+                \"SELECT regionkey, n.name FROM region CROSS JOIN LATERAL (SELECT name FROM nation WHERE region.regionkey = regionkey LIMIT 2) n\",\n+                any(\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(equiJoinClause(\"region_regionkey\", \"nation_regionkey\")),\n+                                any(tableScan(\"region\", ImmutableMap.of(\"region_regionkey\", \"regionkey\"))),\n+                                any(rowNumber(\n+                                        pattern -> pattern\n+                                                .partitionBy(ImmutableList.of(\"nation_regionkey\"))\n+                                                .maxRowCountPerPartition(Optional.of(2)),\n+                                        anyTree(tableScan(\"nation\", ImmutableMap.of(\"nation_name\", \"name\", \"nation_regionkey\", \"regionkey\"))))))));\n+\n+        // rewrite Limit to decorrelated Limit\n+        assertPlan(\"SELECT regionkey, n.nationkey FROM region CROSS JOIN LATERAL (SELECT nationkey FROM nation WHERE region.regionkey = 3 LIMIT 2) n\",\n+                any(\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                Optional.empty(),\n+                                //Optional.of(\"region_regionkey = BIGINT '3'\"),\n+                                any(tableScan(\"region\", ImmutableMap.of(\"region_regionkey\", \"regionkey\"))),\n+                                limit(\n+                                        2,\n+                                        any(tableScan(\"nation\", ImmutableMap.of(\"nation_nationkey\", \"nationkey\")))))));\n+    }\n+\n+    @Test\n+    public void testCorrelatedJoinWithTopN()\n+    {\n+        // rewrite TopN to TopNRowNumberNode\n+        assertPlan(\n+                \"SELECT regionkey, n.name FROM region CROSS JOIN LATERAL (SELECT name FROM nation WHERE region.regionkey = regionkey ORDER BY name LIMIT 2) n\",\n+                any(\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(equiJoinClause(\"region_regionkey\", \"nation_regionkey\")),\n+                                any(tableScan(\"region\", ImmutableMap.of(\"region_regionkey\", \"regionkey\"))),\n+                                any(topNRowNumber(\n+                                        pattern -> pattern\n+                                                .specification(\n+                                                        ImmutableList.of(\"nation_regionkey\"),\n+                                                        ImmutableList.of(\"nation_name\"),\n+                                                        ImmutableMap.of(\"nation_name\", SortOrder.ASC_NULLS_LAST))\n+                                                .maxRowCountPerPartition(2)\n+                                                .partial(false),\n+                                        anyTree(tableScan(\"nation\", ImmutableMap.of(\"nation_name\", \"name\", \"nation_regionkey\", \"regionkey\"))))))));\n+\n+        // rewrite TopN to RowNumberNode\n+        assertPlan(\n+                \"SELECT regionkey, n.name FROM region CROSS JOIN LATERAL (SELECT name FROM nation WHERE region.regionkey = regionkey ORDER BY regionkey LIMIT 2) n\",\n+                any(\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(equiJoinClause(\"region_regionkey\", \"nation_regionkey\")),\n+                                any(tableScan(\"region\", ImmutableMap.of(\"region_regionkey\", \"regionkey\"))),\n+                                any(rowNumber(\n+                                        pattern -> pattern\n+                                                .partitionBy(ImmutableList.of(\"nation_regionkey\"))\n+                                                .maxRowCountPerPartition(Optional.of(2)),\n+                                        anyTree(tableScan(\"nation\", ImmutableMap.of(\"nation_name\", \"name\", \"nation_regionkey\", \"regionkey\"))))))));\n+    }\n+\n     @Test\n     public void testCorrelatedScalarSubqueryInSelect()\n     {"
  },
  {
    "sha": "e89a1bc792886fd57029452e1385fcd35bc68175",
    "filename": "presto-main/src/test/java/com/facebook/presto/sql/query/TestSubqueries.java",
    "status": "modified",
    "additions": 118,
    "deletions": 2,
    "changes": 120,
    "blob_url": "https://github.com/prestodb/presto/blob/4c57c905854a353cddc87df21664ab7f4e27d057/presto-main/src/test/java/com/facebook/presto/sql/query/TestSubqueries.java",
    "raw_url": "https://github.com/prestodb/presto/raw/4c57c905854a353cddc87df21664ab7f4e27d057/presto-main/src/test/java/com/facebook/presto/sql/query/TestSubqueries.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-main/src/test/java/com/facebook/presto/sql/query/TestSubqueries.java?ref=4c57c905854a353cddc87df21664ab7f4e27d057",
    "patch": "@@ -111,10 +111,34 @@ public void testCorrelatedSubqueriesWithLimit()\n         assertions.assertQuery(\n                 \"SELECT (SELECT t.a FROM (VALUES 1, 2) t(a) WHERE t.a=t2.b LIMIT 2) FROM (VALUES 1) t2(b)\",\n                 \"VALUES 1\");\n-        // cannot enforce limit 2 on correlated subquery\n-        assertions.assertFails(\n+        assertions.assertQuery(\n                 \"select (select t.a from (values 1, 2, 3) t(a) where t.a=t2.b limit 2) from (values 1) t2(b)\",\n+                \"VALUES 1\");\n+        assertions.assertFails(\n+                \"SELECT (SELECT t.a FROM (VALUES 1, 1, 2, 3) t(a) WHERE t.a = t2.b LIMIT 2) FROM (VALUES 1) t2(b)\",\n+                \"Scalar sub-query has returned multiple rows\");\n+        // Limit(1) and non-constant output symbol of the subquery\n+        assertions.assertFails(\n+                \"SELECT (SELECT count(*) FROM (VALUES (1, 0), (1, 1)) t(a, b) WHERE a = c GROUP BY b LIMIT 1) FROM (VALUES (1)) t2(c)\",\n+                UNSUPPORTED_CORRELATED_SUBQUERY_ERROR_MSG);\n+        // Limit(1) and non-constant output symbol of the subquery\n+        assertions.assertFails(\n+                \"SELECT (SELECT a + b FROM (VALUES (1, 1), (1, 1)) t(a, b) WHERE a = c LIMIT 1) FROM (VALUES (1)) t2(c)\",\n+                UNSUPPORTED_CORRELATED_SUBQUERY_ERROR_MSG);\n+        // Limit and correlated non-equality predicate in the subquery\n+        assertions.assertFails(\n+                \"SELECT (SELECT t.b FROM (VALUES (1, 2), (1, 3)) t(a, b) WHERE t.a = t2.a AND t.b > t2.b LIMIT 1) FROM (VALUES (1, 2)) t2(a, b)\",\n+                UNSUPPORTED_CORRELATED_SUBQUERY_ERROR_MSG);\n+        assertions.assertQuery(\n+                \"SELECT (SELECT t.a FROM (VALUES (1, 2), (1, 3)) t(a, b) WHERE t.a = t2.a AND t2.b > 1 LIMIT 1) FROM (VALUES (1, 2)) t2(a, b)\",\n+                \"VALUES 1\");\n+        // TopN and correlated non-equality predicate in the subquery\n+        assertions.assertFails(\n+                \"SELECT (SELECT t.b FROM (VALUES (1, 2), (1, 3)) t(a, b) WHERE t.a = t2.a AND t.b > t2.b ORDER BY t.b LIMIT 1) FROM (VALUES (1, 2)) t2(a, b)\",\n                 UNSUPPORTED_CORRELATED_SUBQUERY_ERROR_MSG);\n+        assertions.assertQuery(\n+                \"SELECT (SELECT t.b FROM (VALUES (1, 2), (1, 3)) t(a, b) WHERE t.a = t2.a AND t2.b > 1 ORDER BY t.b LIMIT 1) FROM (VALUES (1, 2)) t2(a, b)\",\n+                \"VALUES 2\");\n         assertions.assertQuery(\n                 \"select (select sum(t.a) from (values 1, 2) t(a) where t.a=t2.b group by t.a limit 2) from (values 1) t2(b)\",\n                 \"VALUES BIGINT '1'\");\n@@ -136,6 +160,98 @@ public void testCorrelatedSubqueriesWithLimit()\n                         \"FROM (values 1) t(cid)\",\n                 \"VALUES true\",\n                 false);\n+        assertions.assertQuery(\n+                \"SELECT * \" +\n+                        \"FROM (VALUES 1, 2, 3, null) outer_relation(id) \" +\n+                        \"CROSS JOIN LATERAL \" +\n+                        \"(SELECT value FROM \" +\n+                        \"(VALUES \" +\n+                        \"(1, 'a'), \" +\n+                        \"(1, 'a'), \" +\n+                        \"(1, 'a'), \" +\n+                        \"(1, 'a'), \" +\n+                        \"(2, 'b'), \" +\n+                        \"(null, 'c')) inner_relation(id, value) \" +\n+                        \"WHERE outer_relation.id = inner_relation.id \" +\n+                        \"LIMIT 2) \",\n+                \"VALUES \" +\n+                        \"(1, 'a'), \" +\n+                        \"(1, 'a'), \" +\n+                        \"(2, 'b')\");\n+        // TopN in correlated subquery\n+        assertions.assertQuery(\n+                \"SELECT * \" +\n+                        \"FROM (VALUES 1, 2, 3, null) outer_relation(id) \" +\n+                        \"CROSS JOIN LATERAL \" +\n+                        \"(SELECT value FROM \" +\n+                        \"(VALUES \" +\n+                        \"(1, 'd'), \" +\n+                        \"(1, 'c'), \" +\n+                        \"(1, 'b'), \" +\n+                        \"(1, 'a'), \" +\n+                        \"(2, 'w'), \" +\n+                        \"(null, 'x')) inner_relation(id, value) \" +\n+                        \"WHERE outer_relation.id = inner_relation.id \" +\n+                        \"ORDER BY inner_relation.value LIMIT 2) \",\n+                \"VALUES \" +\n+                        \"(1, 'a'), \" +\n+                        \"(1, 'b'), \" +\n+                        \"(2, 'w')\");\n+        // correlated symbol in predicate not bound to inner relation + Limit\n+        assertions.assertQuery(\n+                \"SELECT * \" +\n+                        \"FROM (VALUES 1, 2, 3, null) outer_relation(id) \" +\n+                        \"CROSS JOIN LATERAL \" +\n+                        \"(SELECT value FROM (VALUES 'a', 'a', 'a') inner_relation(value) \" +\n+                        \"   WHERE outer_relation.id = 3 LIMIT 2) \",\n+                \"VALUES (3, 'a'), (3, 'a')\");\n+        assertions.assertQuery(\n+                \"SELECT * \" +\n+                        \"FROM (VALUES 1, 2, 3, null) outer_relation(id) \" +\n+                        \"CROSS JOIN LATERAL \" +\n+                        \"(SELECT 1 FROM (VALUES 'a', 'a', 'a') inner_relation(value) \" +\n+                        \"   WHERE outer_relation.id = 3 LIMIT 2) \",\n+                \"VALUES (3, 1), (3, 1)\");\n+        // correlated symbol in predicate not bound to inner relation + TopN\n+        assertions.assertQuery(\n+                \"SELECT * \" +\n+                        \"FROM (VALUES 1, 2, 3, null) outer_relation(id) \" +\n+                        \"CROSS JOIN LATERAL \" +\n+                        \"(SELECT value FROM (VALUES 'c', 'a', 'b') inner_relation(value) \" +\n+                        \"   WHERE outer_relation.id = 3 ORDER BY value LIMIT 2) \",\n+                \"VALUES (3, 'a'), (3, 'b')\");\n+        // TopN with ordering not decorrelating\n+        assertions.assertFails(\n+                \"SELECT * \" +\n+                        \"FROM (VALUES 1, 2, 3, null) outer_relation(id) \" +\n+                        \"CROSS JOIN LATERAL \" +\n+                        \"(SELECT value FROM (VALUES 'c', 'a', 'b') inner_relation(value) \" +\n+                        \"   WHERE outer_relation.id = 3 ORDER BY outer_relation.id LIMIT 2) \",\n+                UNSUPPORTED_CORRELATED_SUBQUERY_ERROR_MSG);\n+        // TopN with ordering only by constants\n+        assertions.assertQuery(\n+                \"SELECT * \" +\n+                        \"FROM (VALUES 1, 2, 3, null) outer_relation(id) \" +\n+                        \"CROSS JOIN LATERAL \" +\n+                        \"(SELECT value FROM (VALUES (3, 'b'), (3, 'a'), (null, 'b')) inner_relation(id, value) \" +\n+                        \"   WHERE outer_relation.id = inner_relation.id ORDER BY id LIMIT 2) \",\n+                \"VALUES (3, 'a'), (3, 'b')\");\n+        // TopN with ordering by constants and non-constant local symbols\n+        assertions.assertQuery(\n+                \"SELECT * \" +\n+                        \"FROM (VALUES 1, 2, 3, null) outer_relation(id) \" +\n+                        \"CROSS JOIN LATERAL \" +\n+                        \"(SELECT value FROM (VALUES (3, 'b'), (3, 'a'), (null, 'b')) inner_relation(id, value) \" +\n+                        \"   WHERE outer_relation.id = inner_relation.id ORDER BY id, value LIMIT 2) \",\n+                \"VALUES (3, 'a'), (3, 'b')\");\n+        // TopN with ordering by non-constant local symbols\n+        assertions.assertQuery(\n+                \"SELECT * \" +\n+                        \"FROM (VALUES 1, 2, 3, null) outer_relation(id) \" +\n+                        \"CROSS JOIN LATERAL \" +\n+                        \"(SELECT value FROM (VALUES (3, 'b'), (3, 'a'), (null, 'b')) inner_relation(id, value) \" +\n+                        \"   WHERE outer_relation.id = inner_relation.id ORDER BY value LIMIT 2) \",\n+                \"VALUES (3, 'a'), (3, 'b')\");\n     }\n \n     @Test"
  },
  {
    "sha": "ad16ba0d26d681e3c04a9dbac6c9ef3f78c15d0c",
    "filename": "presto-tests/src/main/java/com/facebook/presto/tests/AbstractTestQueries.java",
    "status": "modified",
    "additions": 24,
    "deletions": 3,
    "changes": 27,
    "blob_url": "https://github.com/prestodb/presto/blob/4c57c905854a353cddc87df21664ab7f4e27d057/presto-tests/src/main/java/com/facebook/presto/tests/AbstractTestQueries.java",
    "raw_url": "https://github.com/prestodb/presto/raw/4c57c905854a353cddc87df21664ab7f4e27d057/presto-tests/src/main/java/com/facebook/presto/tests/AbstractTestQueries.java",
    "contents_url": "https://api.github.com/repos/prestodb/presto/contents/presto-tests/src/main/java/com/facebook/presto/tests/AbstractTestQueries.java?ref=4c57c905854a353cddc87df21664ab7f4e27d057",
    "patch": "@@ -3425,9 +3425,11 @@ public void testCorrelatedScalarSubqueries()\n         assertQuery(\"SELECT (SELECT count(*) FROM (VALUES (7,1)) t(orderkey, value) WHERE orderkey = corr_key LIMIT 1) FROM (values 7) t(corr_key)\");\n \n         // explicit LIMIT in subquery\n-        assertQueryFails(\n-                \"SELECT (SELECT count(*) FROM (VALUES (7,1)) t(orderkey, value) WHERE orderkey = corr_key GROUP BY value LIMIT 2) FROM (values 7) t(corr_key)\",\n-                \"line 1:9: Given correlated subquery is not supported\");\n+        assertQuery(\n+                \"SELECT (SELECT count(*) FROM (VALUES (7,1)) t(orderkey, value) WHERE orderkey = corr_key GROUP BY value LIMIT 2) FROM (values 7) t(corr_key)\");\n+        // Limit(1) and non-constant output symbol of the subquery (count)\n+        assertQueryFails(\"SELECT (SELECT count(*) FROM (VALUES (7,1), (7,2)) t(orderkey, value) WHERE orderkey = corr_key GROUP BY value LIMIT 1) FROM (values 7) t(corr_key)\",\n+                UNSUPPORTED_CORRELATED_SUBQUERY_ERROR_MSG);\n     }\n \n     @Test\n@@ -3854,6 +3856,25 @@ public void testCorrelatedExistsSubqueries()\n                 \"VALUES 14999\");\n     }\n \n+    @Test\n+    public void testCorrelatedJoin()\n+    {\n+        // TopN in correlated subquery\n+        assertQuery(\n+                \"SELECT regionkey, n.name FROM region CROSS JOIN LATERAL (SELECT name FROM nation WHERE region.regionkey = regionkey ORDER BY nationkey LIMIT 2) n\",\n+                \"VALUES \" +\n+                        \"(0, 'ETHIOPIA'), \" +\n+                        \"(0, 'ALGERIA'), \" +\n+                        \"(1, 'BRAZIL'), \" +\n+                        \"(1, 'ARGENTINA'), \" +\n+                        \"(2, 'INDONESIA'), \" +\n+                        \"(2, 'INDIA'), \" +\n+                        \"(3, 'GERMANY'), \" +\n+                        \"(3, 'FRANCE'), \" +\n+                        \"(4, 'IRAN'), \" +\n+                        \"(4, 'EGYPT')\");\n+    }\n+\n     @Test\n     public void testTwoCorrelatedExistsSubqueries()\n     {"
  }
]
