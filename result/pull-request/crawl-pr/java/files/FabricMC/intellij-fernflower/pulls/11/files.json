[
  {
    "sha": "3edbce1d13f029e023a18a10385a0da9b50f2b26",
    "filename": ".github/workflows/build.yml",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/.github/workflows/build.yml",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/.github/workflows/build.yml",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/.github/workflows/build.yml?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -4,12 +4,12 @@ jobs:\n   build:\n     strategy:\n       matrix:\n-        java: [8-jdk, 11-jdk, 15-jdk]\n+        java: [11-jdk, 15-jdk]\n     runs-on: ubuntu-20.04\n     container:\n       image: openjdk:${{ matrix.java }}\n       options: --user root\n     steps:\n-      - uses: actions/checkout@v1\n+      - uses: actions/checkout@v2\n       - uses: gradle/wrapper-validation-action@v1\n       - run: ./gradlew build --stacktrace"
  },
  {
    "sha": "583b8a893cea006d9a6e29142d50a47ebbb43c61",
    "filename": ".github/workflows/release.yml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/.github/workflows/release.yml",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/.github/workflows/release.yml",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/.github/workflows/release.yml?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -7,7 +7,7 @@ jobs:\n       image: openjdk:15-jdk\n       options: --user root\n     steps:\n-      - uses: actions/checkout@v1\n+      - uses: actions/checkout@v2\n       - uses: gradle/wrapper-validation-action@v1\n       - run: ./gradlew build publish --stacktrace\n         env:"
  },
  {
    "sha": "5828c03e8a52940e7f0ad3ea2ab2baa83258e16e",
    "filename": "build.gradle",
    "status": "modified",
    "additions": 10,
    "deletions": 7,
    "changes": 17,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/build.gradle",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/build.gradle",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/build.gradle?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,10 +1,10 @@\n-// Copyright 2000-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n apply plugin: 'java'\n apply plugin: 'maven-publish'\n \n compileJava {\n-  sourceCompatibility '1.8'\n-  targetCompatibility '1.8'\n+  sourceCompatibility '11'\n+  targetCompatibility '11'\n }\n \n group = 'net.fabricmc'\n@@ -20,7 +20,7 @@ sourceSets {\n   test.java.srcDirs 'test'\n }\n \n-repositories { jcenter() }\n+repositories { mavenCentral() }\n dependencies {\n   testCompile 'junit:junit:4.12'\n   testCompile 'org.assertj:assertj-core:3.12.2'\n@@ -40,9 +40,12 @@ task sourceJar(type:Jar) {\n tasks.withType(JavaCompile).configureEach {\n   it.options.encoding = \"UTF-8\"\n \n-  if (JavaVersion.current().isJava9Compatible()) {\n-    it.options.release = 8\n-  }\n+  it.options.release = 11\n+}\n+\n+java {\n+  sourceCompatibility = JavaVersion.toVersion(11)\n+  targetCompatibility = JavaVersion.toVersion(11)\n }\n \n publishing {"
  },
  {
    "sha": "e708b1c023ec8b20f512888fe07c5bd3ff77bb8f",
    "filename": "gradle/wrapper/gradle-wrapper.jar",
    "status": "modified",
    "additions": 0,
    "deletions": 0,
    "changes": 0,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/gradle/wrapper/gradle-wrapper.jar",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/gradle/wrapper/gradle-wrapper.jar",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/gradle/wrapper/gradle-wrapper.jar?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d"
  },
  {
    "sha": "442d9132ea32808ad980df4bd233b359f76341a7",
    "filename": "gradle/wrapper/gradle-wrapper.properties",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/gradle/wrapper/gradle-wrapper.properties",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/gradle/wrapper/gradle-wrapper.properties",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/gradle/wrapper/gradle-wrapper.properties?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,5 +1,5 @@\n distributionBase=GRADLE_USER_HOME\n distributionPath=wrapper/dists\n-distributionUrl=https\\://services.gradle.org/distributions/gradle-6.7-bin.zip\n+distributionUrl=https\\://services.gradle.org/distributions/gradle-6.8.3-bin.zip\n zipStoreBase=GRADLE_USER_HOME\n zipStorePath=wrapper/dists"
  },
  {
    "sha": "4f906e0c811fc9e230eb44819f509cd0627f2600",
    "filename": "gradlew",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/gradlew",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/gradlew",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/gradlew?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -82,6 +82,7 @@ esac\n \n CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar\n \n+\n # Determine the Java command to use to start the JVM.\n if [ -n \"$JAVA_HOME\" ] ; then\n     if [ -x \"$JAVA_HOME/jre/sh/java\" ] ; then\n@@ -129,6 +130,7 @@ fi\n if [ \"$cygwin\" = \"true\" -o \"$msys\" = \"true\" ] ; then\n     APP_HOME=`cygpath --path --mixed \"$APP_HOME\"`\n     CLASSPATH=`cygpath --path --mixed \"$CLASSPATH\"`\n+\n     JAVACMD=`cygpath --unix \"$JAVACMD\"`\n \n     # We build the pattern for arguments to be converted via cygpath"
  },
  {
    "sha": "107acd32c4e687021ef32db511e8a206129b88ec",
    "filename": "gradlew.bat",
    "status": "modified",
    "additions": 4,
    "deletions": 18,
    "changes": 22,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/gradlew.bat",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/gradlew.bat",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/gradlew.bat?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -40,7 +40,7 @@ if defined JAVA_HOME goto findJavaFromJavaHome\n \n set JAVA_EXE=java.exe\n %JAVA_EXE% -version >NUL 2>&1\n-if \"%ERRORLEVEL%\" == \"0\" goto init\n+if \"%ERRORLEVEL%\" == \"0\" goto execute\n \n echo.\n echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\n@@ -54,7 +54,7 @@ goto fail\n set JAVA_HOME=%JAVA_HOME:\"=%\n set JAVA_EXE=%JAVA_HOME%/bin/java.exe\n \n-if exist \"%JAVA_EXE%\" goto init\n+if exist \"%JAVA_EXE%\" goto execute\n \n echo.\n echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\n@@ -64,28 +64,14 @@ echo location of your Java installation.\n \n goto fail\n \n-:init\n-@rem Get command-line arguments, handling Windows variants\n-\n-if not \"%OS%\" == \"Windows_NT\" goto win9xME_args\n-\n-:win9xME_args\n-@rem Slurp the command line arguments.\n-set CMD_LINE_ARGS=\n-set _SKIP=2\n-\n-:win9xME_args_slurp\n-if \"x%~1\" == \"x\" goto execute\n-\n-set CMD_LINE_ARGS=%*\n-\n :execute\n @rem Setup the command line\n \n set CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\n \n+\n @rem Execute Gradle\n-\"%JAVA_EXE%\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \"-Dorg.gradle.appname=%APP_BASE_NAME%\" -classpath \"%CLASSPATH%\" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%\n+\"%JAVA_EXE%\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \"-Dorg.gradle.appname=%APP_BASE_NAME%\" -classpath \"%CLASSPATH%\" org.gradle.wrapper.GradleWrapperMain %*\n \n :end\n @rem End local scope for the variables with windows NT shell"
  },
  {
    "sha": "2c5cb42f61d96c40d52603f02600a9097a645eb9",
    "filename": "src/org/jetbrains/java/decompiler/code/CodeConstants.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/code/CodeConstants.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/code/CodeConstants.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/code/CodeConstants.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.code;\n \n @SuppressWarnings({\"unused\", \"SpellCheckingInspection\"})"
  },
  {
    "sha": "f060fbdca807c0313716c3fe7242af3c9302742e",
    "filename": "src/org/jetbrains/java/decompiler/code/cfg/ControlFlowGraph.java",
    "status": "modified",
    "additions": 6,
    "deletions": 5,
    "changes": 11,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/code/cfg/ControlFlowGraph.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/code/cfg/ControlFlowGraph.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/code/cfg/ControlFlowGraph.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,10 +1,11 @@\n-// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.code.cfg;\n \n import org.jetbrains.java.decompiler.code.*;\n import org.jetbrains.java.decompiler.code.interpreter.InstructionImpact;\n import org.jetbrains.java.decompiler.main.DecompilerContext;\n import org.jetbrains.java.decompiler.modules.code.DeadCodeHelper;\n+import org.jetbrains.java.decompiler.struct.StructClass;\n import org.jetbrains.java.decompiler.struct.StructMethod;\n import org.jetbrains.java.decompiler.struct.consts.ConstantPool;\n import org.jetbrains.java.decompiler.struct.gen.DataPoint;\n@@ -96,9 +97,9 @@ public String toString() {\n     return buf.toString();\n   }\n \n-  public void inlineJsr(StructMethod mt) {\n+  public void inlineJsr(StructClass cl, StructMethod mt) {\n     processJsr();\n-    removeJsr(mt);\n+    removeJsr(cl, mt);\n \n     removeMarkers();\n \n@@ -668,8 +669,8 @@ private void splitJsrExceptionRanges(Set<BasicBlock> common_blocks, Map<Integer,\n     }\n   }\n \n-  private void removeJsr(StructMethod mt) {\n-    removeJsrInstructions(mt.getClassStruct().getPool(), first, DataPoint.getInitialDataPoint(mt));\n+  private void removeJsr(StructClass cl, StructMethod mt) {\n+    removeJsrInstructions(cl.getPool(), first, DataPoint.getInitialDataPoint(mt));\n   }\n \n   private static void removeJsrInstructions(ConstantPool pool, BasicBlock block, DataPoint data) {"
  },
  {
    "sha": "395d03dd5ac88e2f7872fb23b6054a98376c6151",
    "filename": "src/org/jetbrains/java/decompiler/code/cfg/ExceptionRangeCFG.java",
    "status": "modified",
    "additions": 10,
    "deletions": 3,
    "changes": 13,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/code/cfg/ExceptionRangeCFG.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/code/cfg/ExceptionRangeCFG.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/code/cfg/ExceptionRangeCFG.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.code.cfg;\n \n import org.jetbrains.java.decompiler.main.DecompilerContext;\n@@ -31,9 +31,16 @@ public String toString() {\n     StringBuilder buf = new StringBuilder();\n \n     buf.append(\"exceptionType:\");\n-    for (String exception_type : exceptionTypes) {\n-      buf.append(\" \").append(exception_type);\n+\n+    if (exceptionTypes == null) {\n+      buf.append(\" null\");\n+    }\n+    else {\n+      for (String exception_type : exceptionTypes) {\n+        buf.append(\" \").append(exception_type);\n+      }\n     }\n+\n     buf.append(new_line_separator);\n \n     buf.append(\"handler: \").append(handler.id).append(new_line_separator);"
  },
  {
    "sha": "ce193168e07647317365709c09fd912f6ccf47f1",
    "filename": "src/org/jetbrains/java/decompiler/main/ClassWriter.java",
    "status": "modified",
    "additions": 129,
    "deletions": 140,
    "changes": 269,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/main/ClassWriter.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/main/ClassWriter.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/main/ClassWriter.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.main;\n \n import net.fabricmc.fernflower.api.IFabricJavadocProvider;\n@@ -44,7 +44,7 @@ private static void invokeProcessors(ClassNode node) {\n     InitializerProcessor.extractInitializers(wrapper);\n \n     if (node.type == ClassNode.CLASS_ROOT &&\n-        !cl.isVersionGE_1_5() &&\n+        !cl.isVersion5() &&\n         DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_CLASS_1_4)) {\n       ClassReference14Processor.processClassReferences(node);\n     }\n@@ -252,12 +252,6 @@ else if (enumFields) {\n         }\n       }\n \n-      boolean isModuleInfo = cl.hasModifier(CodeConstants.ACC_MODULE) && cl.hasAttribute(StructGeneralAttribute.ATTRIBUTE_MODULE);\n-\n-      if (isModuleInfo) {\n-        writeModuleInfoBody(buffer, cl);\n-      }\n-\n       buffer.appendIndent(indent).append('}');\n \n       if (node.type != ClassNode.CLASS_ANONYMOUS) {\n@@ -271,117 +265,115 @@ else if (enumFields) {\n     DecompilerContext.getLogger().endWriteClass();\n   }\n \n-  private static boolean isSyntheticRecordMethod(StructMethod mt, TextBuffer code) {\n-    if (mt.getClassStruct().getRecordComponents() == null) return false;\n-    String name = mt.getName();\n-    String descriptor = mt.getDescriptor();\n-    if (name.equals(\"equals\") && descriptor.equals(\"(Ljava/lang/Object;)Z\") ||\n-        name.equals(\"hashCode\") && descriptor.equals(\"()I\") ||\n-        name.equals(\"toString\") && descriptor.equals(\"()Ljava/lang/String;\")) {\n-      if (code.countLines() == 1) {\n-        String str = code.toString().trim();\n-        return str.startsWith(\"return this.\" + name + \"<invokedynamic>(this\");\n+  @SuppressWarnings(\"SpellCheckingInspection\")\n+  private static boolean isSyntheticRecordMethod(StructClass cl, StructMethod mt, TextBuffer code) {\n+    if (cl.getRecordComponents() != null) {\n+      String name = mt.getName(), descriptor = mt.getDescriptor();\n+      if (name.equals(\"equals\") && descriptor.equals(\"(Ljava/lang/Object;)Z\") ||\n+          name.equals(\"hashCode\") && descriptor.equals(\"()I\") ||\n+          name.equals(\"toString\") && descriptor.equals(\"()Ljava/lang/String;\")) {\n+        if (code.countLines() == 1) {\n+          String str = code.toString().trim();\n+          return str.startsWith(\"return this.\" + name + \"<invokedynamic>(this\");\n+        }\n       }\n     }\n     return false;\n   }\n \n-  private void writeModuleInfoBody(TextBuffer buffer, StructClass cl) {\n-    StructModuleAttribute moduleAttribute = cl.getAttribute(StructGeneralAttribute.ATTRIBUTE_MODULE);\n+  public static void packageInfoToJava(StructClass cl, TextBuffer buffer) {\n+    appendAnnotations(buffer, 0, cl, -1);\n \n-    for (StructModuleAttribute.RequiresEntry requires : moduleAttribute.requires) {\n-      String moduleName = requires.moduleName.replace('/', '.');\n+    int index = cl.qualifiedName.lastIndexOf('/');\n+    String packageName = cl.qualifiedName.substring(0, index).replace('/', '.');\n+    buffer.append(\"package \").append(packageName).append(';').appendLineSeparator().appendLineSeparator();\n+  }\n+\n+  public static void moduleInfoToJava(StructClass cl, TextBuffer buffer) {\n+    appendAnnotations(buffer, 0, cl, -1);\n+\n+    StructModuleAttribute moduleAttribute = cl.getAttribute(StructGeneralAttribute.ATTRIBUTE_MODULE);\n \n-      buffer.appendIndent(1)\n-        .append(\"requires \")\n-        .append(moduleName)\n-        .append(';')\n-        .appendLineSeparator();\n+    if ((moduleAttribute.moduleFlags & CodeConstants.ACC_OPEN) != 0) {\n+      buffer.append(\"open \");\n     }\n \n-    for (StructModuleAttribute.ExportsEntry exports : moduleAttribute.exports) {\n-      String packageName = exports.packageName.replace('/', '.');\n+    buffer.append(\"module \").append(moduleAttribute.moduleName).append(\" {\").appendLineSeparator();\n \n-      buffer.appendIndent(1).append(\"exports \").append(packageName);\n+    writeModuleInfoBody(buffer, moduleAttribute);\n \n-      List<String> exportToModules = exports.exportToModules;\n-      if (exportToModules.size() > 0) {\n-        buffer.append(\" to\").appendLineSeparator();\n+    buffer.append('}').appendLineSeparator();\n+  }\n \n-        int lastIndex = exportToModules.size() - 1;\n-        for (int i = 0; i < exportToModules.size(); i++) {\n-          String moduleName = exportToModules.get(i).replace('/', '.');\n-          char separator = i == lastIndex ? ';' : ',';\n+  private static void writeModuleInfoBody(TextBuffer buffer, StructModuleAttribute moduleAttribute) {\n+    boolean newLineNeeded = false;\n \n-          buffer.appendIndent(2)\n-            .append(moduleName)\n-            .append(separator)\n-            .appendLineSeparator();\n+    List<StructModuleAttribute.RequiresEntry> requiresEntries = moduleAttribute.requires;\n+    if (!requiresEntries.isEmpty()) {\n+      for (StructModuleAttribute.RequiresEntry requires : requiresEntries) {\n+        if (!isGenerated(requires.flags)) {\n+          buffer.appendIndent(1).append(\"requires \").append(requires.moduleName.replace('/', '.')).append(';').appendLineSeparator();\n+          newLineNeeded = true;\n         }\n-      } else {\n-        buffer.append(';').appendLineSeparator();\n       }\n     }\n \n-    for (StructModuleAttribute.OpensEntry opens : moduleAttribute.opens) {\n-      String packageName = opens.packageName.replace('/', '.');\n-\n-      buffer.appendIndent(1).append(\"opens \").append(packageName);\n-\n-      List<String> opensToModules = opens.opensToModules;\n-      if (opensToModules.size() > 0) {\n-        buffer.append(\" to\").appendLineSeparator();\n-\n-        int lastIndex = opensToModules.size() - 1;\n-        for (int i = 0; i < opensToModules.size(); i++) {\n-          String moduleName = opensToModules.get(i).replace('/', '.');\n-          char separator = i == lastIndex ? ';' : ',';\n-\n-          buffer.appendIndent(2)\n-            .append(moduleName)\n-            .append(separator)\n-            .appendLineSeparator();\n+    List<StructModuleAttribute.ExportsEntry> exportsEntries = moduleAttribute.exports;\n+    if (!exportsEntries.isEmpty()) {\n+      if (newLineNeeded) buffer.appendLineSeparator();\n+      for (StructModuleAttribute.ExportsEntry exports : exportsEntries) {\n+        if (!isGenerated(exports.flags)) {\n+          buffer.appendIndent(1).append(\"exports \").append(exports.packageName.replace('/', '.'));\n+          List<String> exportToModules = exports.exportToModules;\n+          if (exportToModules.size() > 0) {\n+            buffer.append(\" to\").appendLineSeparator();\n+            appendFQClassNames(buffer, exportToModules);\n+          }\n+          buffer.append(';').appendLineSeparator();\n+          newLineNeeded = true;\n         }\n-      } else {\n-        buffer.append(';').appendLineSeparator();\n       }\n     }\n \n-    for (String uses : moduleAttribute.uses) {\n-      String className = internalClassNameToJava(uses);\n-\n-      buffer.appendIndent(1)\n-        .append(\"uses \")\n-        .append(className)\n-        .append(';')\n-        .appendLineSeparator();\n+    List<StructModuleAttribute.OpensEntry> opensEntries = moduleAttribute.opens;\n+    if (!opensEntries.isEmpty()) {\n+      if (newLineNeeded) buffer.appendLineSeparator();\n+      for (StructModuleAttribute.OpensEntry opens : opensEntries) {\n+        if (!isGenerated(opens.flags)) {\n+          buffer.appendIndent(1).append(\"opens \").append(opens.packageName.replace('/', '.'));\n+          List<String> opensToModules = opens.opensToModules;\n+          if (opensToModules.size() > 0) {\n+            buffer.append(\" to\").appendLineSeparator();\n+            appendFQClassNames(buffer, opensToModules);\n+          }\n+          buffer.append(';').appendLineSeparator();\n+          newLineNeeded = true;\n+        }\n+      }\n     }\n \n-    for (StructModuleAttribute.ProvidesEntry provides : moduleAttribute.provides) {\n-      String interfaceName = internalClassNameToJava(provides.interfaceName);\n-\n-      buffer.appendIndent(1)\n-        .append(\"provides \")\n-        .append(interfaceName)\n-        .append(\" with\")\n-        .appendLineSeparator();\n-\n-      int lastIndex = provides.implementationNames.size() - 1;\n-      for (int i = 0; i < provides.implementationNames.size(); i++) {\n-        String className = internalClassNameToJava(provides.implementationNames.get(i));\n-        char separator = i == lastIndex ? ';' : ',';\n+    List<String> usesEntries = moduleAttribute.uses;\n+    if (!usesEntries.isEmpty()) {\n+      if (newLineNeeded) buffer.appendLineSeparator();\n+      for (String uses : usesEntries) {\n+        buffer.appendIndent(1).append(\"uses \").append(ExprProcessor.buildJavaClassName(uses)).append(';').appendLineSeparator();\n+      }\n+      newLineNeeded = true;\n+    }\n \n-        buffer.appendIndent(2)\n-          .append(className)\n-          .append(separator)\n-          .appendLineSeparator();\n+    List<StructModuleAttribute.ProvidesEntry> providesEntries = moduleAttribute.provides;\n+    if (!providesEntries.isEmpty()) {\n+      if (newLineNeeded) buffer.appendLineSeparator();\n+      for (StructModuleAttribute.ProvidesEntry provides : providesEntries) {\n+        buffer.appendIndent(1).append(\"provides \").append(ExprProcessor.buildJavaClassName(provides.interfaceName)).append(\" with\").appendLineSeparator();\n+        appendFQClassNames(buffer, provides.implementationNames.stream().map(ExprProcessor::buildJavaClassName).collect(Collectors.toList()));\n+        buffer.append(';').appendLineSeparator();\n       }\n     }\n   }\n \n-  private static String internalClassNameToJava(String internal) {\n-    // TODO: replace both at once...?\n-    return internal.replace('/', '.').replace('$', '.');\n+  private static boolean isGenerated(int flags) {\n+    return (flags & (CodeConstants.ACC_SYNTHETIC | CodeConstants.ACC_MANDATED)) != 0;\n   }\n \n   private static void addTracer(StructClass cls, StructMethod method, BytecodeMappingTracer tracer) {\n@@ -406,7 +398,6 @@ private void writeClassDefinition(ClassNode node, TextBuffer buffer, int indent)\n     boolean isEnum = DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM) && (flags & CodeConstants.ACC_ENUM) != 0;\n     boolean isInterface = (flags & CodeConstants.ACC_INTERFACE) != 0;\n     boolean isAnnotation = (flags & CodeConstants.ACC_ANNOTATION) != 0;\n-    boolean isModuleInfo = (flags & CodeConstants.ACC_MODULE) != 0 && cl.hasAttribute(StructGeneralAttribute.ATTRIBUTE_MODULE);\n \n     if (isDeprecated) {\n       appendDeprecation(buffer, indent);\n@@ -453,26 +444,13 @@ else if (isInterface) {\n       }\n       buffer.append(\"interface \");\n     }\n-    else if (isModuleInfo) {\n-      StructModuleAttribute moduleAttribute = cl.getAttribute(StructGeneralAttribute.ATTRIBUTE_MODULE);\n-\n-      if ((moduleAttribute.moduleFlags & CodeConstants.ACC_OPEN) != 0) {\n-        buffer.append(\"open \");\n-      }\n-\n-      buffer.append(\"module \");\n-      buffer.append(moduleAttribute.moduleName);\n-    }\n     else if (components != null) {\n       buffer.append(\"record \");\n     }\n     else {\n       buffer.append(\"class \");\n     }\n-\n-    if (!isModuleInfo) {\n-      buffer.append(node.simpleName);\n-    }\n+    buffer.append(node.simpleName);\n \n     GenericClassDescriptor descriptor = getGenericClassDescriptor(cl);\n     if (descriptor != null && !descriptor.fparameters.isEmpty()) {\n@@ -530,11 +508,11 @@ else if (components != null) {\n     buffer.append('{').appendLineSeparator();\n   }\n \n-  private boolean isVarArgRecord(StructClass cl) {\n+  private static boolean isVarArgRecord(StructClass cl) {\n     String canonicalConstructorDescriptor = \n       cl.getRecordComponents().stream().map(c -> c.getDescriptor()).collect(Collectors.joining(\"\", \"(\", \")V\"));\n-    StructMethod ctor = cl.getMethod(CodeConstants.INIT_NAME, canonicalConstructorDescriptor);\n-    return ctor != null && ctor.hasModifier(CodeConstants.ACC_VARARGS);\n+    StructMethod init = cl.getMethod(CodeConstants.INIT_NAME, canonicalConstructorDescriptor);\n+    return init != null && init.hasModifier(CodeConstants.ACC_VARARGS);\n   }\n \n   private void fieldToJava(ClassWrapper wrapper, StructClass cl, StructField fd, TextBuffer buffer, int indent, BytecodeMappingTracer tracer) {\n@@ -567,15 +545,9 @@ private void fieldToJava(ClassWrapper wrapper, StructClass cl, StructField fd, T\n       appendModifiers(buffer, fd.getAccessFlags(), FIELD_ALLOWED, isInterface, FIELD_EXCLUDED);\n     }\n \n-    VarType fieldType = new VarType(fd.getDescriptor(), false);\n-\n-    GenericFieldDescriptor descriptor = null;\n-    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {\n-      StructGenericSignatureAttribute attr = fd.getAttribute(StructGeneralAttribute.ATTRIBUTE_SIGNATURE);\n-      if (attr != null) {\n-        descriptor = GenericMain.parseFieldSignature(attr.getSignature());\n-      }\n-    }\n+    Map.Entry<VarType, GenericFieldDescriptor> fieldTypeData = getFieldTypeData(fd);\n+    VarType fieldType = fieldTypeData.getKey();\n+    GenericFieldDescriptor descriptor = fieldTypeData.getValue();\n \n     if (!isEnum) {\n       if (descriptor != null) {\n@@ -633,15 +605,9 @@ else if (fd.hasModifier(CodeConstants.ACC_FINAL) && fd.hasModifier(CodeConstants\n   private static void recordComponentToJava(StructRecordComponent cd, TextBuffer buffer, boolean varArgComponent) {\n     appendAnnotations(buffer, -1, cd, TypeAnnotation.FIELD);\n \n-    VarType fieldType = new VarType(cd.getDescriptor(), false);\n-\n-    GenericFieldDescriptor descriptor = null;\n-    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {\n-      StructGenericSignatureAttribute attr = cd.getAttribute(StructGeneralAttribute.ATTRIBUTE_SIGNATURE);\n-      if (attr != null) {\n-        descriptor = GenericMain.parseFieldSignature(attr.getSignature());\n-      }\n-    }\n+    Map.Entry<VarType, GenericFieldDescriptor> fieldTypeData = getFieldTypeData(cd);\n+    VarType fieldType = fieldTypeData.getKey();\n+    GenericFieldDescriptor descriptor = fieldTypeData.getValue();\n \n     if (descriptor != null) {\n       buffer.append(GenericMain.getGenericCastTypeName(varArgComponent ? descriptor.type.decreaseArrayDim() : descriptor.type));\n@@ -784,7 +750,7 @@ private boolean methodToJava(ClassNode node, StructMethod mt, TextBuffer buffer,\n       boolean isAnnotation = cl.hasModifier(CodeConstants.ACC_ANNOTATION);\n       boolean isEnum = cl.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);\n       boolean isDeprecated = mt.hasAttribute(StructGeneralAttribute.ATTRIBUTE_DEPRECATED);\n-      boolean clinit = false, init = false, dinit = false;\n+      boolean clInit = false, init = false, dInit = false;\n \n       MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());\n \n@@ -832,7 +798,7 @@ private boolean methodToJava(ClassNode node, StructMethod mt, TextBuffer buffer,\n       if (CodeConstants.INIT_NAME.equals(name)) {\n         if (node.type == ClassNode.CLASS_ANONYMOUS) {\n           name = \"\";\n-          dinit = true;\n+          dInit = true;\n         }\n         else {\n           name = node.simpleName;\n@@ -841,7 +807,7 @@ private boolean methodToJava(ClassNode node, StructMethod mt, TextBuffer buffer,\n       }\n       else if (CodeConstants.CLINIT_NAME.equals(name)) {\n         name = \"\";\n-        clinit = true;\n+        clInit = true;\n       }\n \n       GenericMethodDescriptor descriptor = null;\n@@ -870,7 +836,7 @@ else if (isEnum && init) {\n       boolean throwsExceptions = false;\n       int paramCount = 0;\n \n-      if (!clinit && !dinit) {\n+      if (!clInit && !dInit) {\n         boolean thisVar = !mt.hasModifier(CodeConstants.ACC_STATIC);\n \n         if (descriptor != null && !descriptor.typeParameters.isEmpty()) {\n@@ -1009,7 +975,7 @@ else if (methodWrapper.varproc.getVarFinal(new VarVersionPair(index, 0)) == VarT\n         buffer.appendLineSeparator();\n       }\n       else {\n-        if (!clinit && !dinit) {\n+        if (!clInit && !dInit) {\n           buffer.append(' ');\n         }\n \n@@ -1025,8 +991,8 @@ else if (methodWrapper.varproc.getVarFinal(new VarVersionPair(index, 0)) == VarT\n             BytecodeMappingTracer codeTracer = new BytecodeMappingTracer(tracer.getCurrentSourceLine());\n             TextBuffer code = root.toJava(indent + 1, codeTracer);\n \n-            hideMethod = (code.length() == 0) && (clinit || dinit || hideConstructor(node, init, throwsExceptions, paramCount, flags))\n-                  || isSyntheticRecordMethod(mt, code);\n+            hideMethod = code.length() == 0 && (clInit || dInit || hideConstructor(node, init, throwsExceptions, paramCount, flags)) ||\n+                         isSyntheticRecordMethod(cl, mt, code);\n \n             buffer.append(code);\n \n@@ -1066,19 +1032,18 @@ else if (root != null) {\n   }\n \n   private static boolean hideConstructor(ClassNode node, boolean init, boolean throwsExceptions, int paramCount, int methodAccessFlags) {\n-\n     if (!init || throwsExceptions || paramCount > 0 || !DecompilerContext.getOption(IFernflowerPreferences.HIDE_DEFAULT_CONSTRUCTOR)) {\n       return false;\n     }\n \n     ClassWrapper wrapper = node.getWrapper();\n \t  StructClass cl = wrapper.getClassStruct();\n \n-\t  int classAccesFlags = node.type == ClassNode.CLASS_ROOT ? cl.getAccessFlags() : node.access;\n+\t  int classAccessFlags = node.type == ClassNode.CLASS_ROOT ? cl.getAccessFlags() : node.access;\n     boolean isEnum = cl.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);\n \n     // default constructor requires same accessibility flags. Exception: enum constructor which is always private\n-  \tif(!isEnum && ((classAccesFlags & ACCESSIBILITY_FLAGS) != (methodAccessFlags & ACCESSIBILITY_FLAGS))) {\n+  \tif(!isEnum && ((classAccessFlags & ACCESSIBILITY_FLAGS) != (methodAccessFlags & ACCESSIBILITY_FLAGS))) {\n   \t  return false;\n   \t}\n \n@@ -1094,6 +1059,20 @@ private static boolean hideConstructor(ClassNode node, boolean init, boolean thr\n     return true;\n   }\n \n+  private static Map.Entry<VarType, GenericFieldDescriptor> getFieldTypeData(StructField fd) {\n+    VarType fieldType = new VarType(fd.getDescriptor(), false);\n+\n+    GenericFieldDescriptor descriptor = null;\n+    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {\n+      StructGenericSignatureAttribute attr = fd.getAttribute(StructGeneralAttribute.ATTRIBUTE_SIGNATURE);\n+      if (attr != null) {\n+        descriptor = GenericMain.parseFieldSignature(attr.getSignature());\n+      }\n+    }\n+\n+    return new AbstractMap.SimpleImmutableEntry<>(fieldType, descriptor);\n+  }\n+\n   private static void appendDeprecation(TextBuffer buffer, int indent) {\n     buffer.appendIndent(indent).append(\"/** @deprecated */\").appendLineSeparator();\n   }\n@@ -1161,11 +1140,11 @@ private static void appendJavadoc(TextBuffer buffer, String javaDoc, int indent)\n     buffer.appendIndent(indent).append(\" */\").appendLineSeparator();\n   }\n \n-  private static final StructGeneralAttribute.Key[] ANNOTATION_ATTRIBUTES = {\n+  private static final StructGeneralAttribute.Key<?>[] ANNOTATION_ATTRIBUTES = {\n     StructGeneralAttribute.ATTRIBUTE_RUNTIME_VISIBLE_ANNOTATIONS, StructGeneralAttribute.ATTRIBUTE_RUNTIME_INVISIBLE_ANNOTATIONS};\n-  private static final StructGeneralAttribute.Key[] PARAMETER_ANNOTATION_ATTRIBUTES = {\n+  private static final StructGeneralAttribute.Key<?>[] PARAMETER_ANNOTATION_ATTRIBUTES = {\n     StructGeneralAttribute.ATTRIBUTE_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, StructGeneralAttribute.ATTRIBUTE_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS};\n-  private static final StructGeneralAttribute.Key[] TYPE_ANNOTATION_ATTRIBUTES = {\n+  private static final StructGeneralAttribute.Key<?>[] TYPE_ANNOTATION_ATTRIBUTES = {\n     StructGeneralAttribute.ATTRIBUTE_RUNTIME_VISIBLE_TYPE_ANNOTATIONS, StructGeneralAttribute.ATTRIBUTE_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS};\n \n   private static void appendAnnotations(TextBuffer buffer, int indent, StructMember mb, int targetType) {\n@@ -1309,4 +1288,14 @@ public static void appendTypeParameters(TextBuffer buffer, List<String> paramete\n \n     buffer.append('>');\n   }\n+\n+  private static void appendFQClassNames(TextBuffer buffer, List<String> names) {\n+    for (int i = 0; i < names.size(); i++) {\n+      String name = names.get(i);\n+      buffer.appendIndent(2).append(name);\n+      if (i < names.size() - 1) {\n+        buffer.append(',').appendLineSeparator();\n+      }\n+    }\n+  }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "c6f651255ed16ef3ad77d0f8a52cc56b6b0797cc",
    "filename": "src/org/jetbrains/java/decompiler/main/ClassesProcessor.java",
    "status": "modified",
    "additions": 47,
    "deletions": 37,
    "changes": 84,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.main;\n \n import org.jetbrains.java.decompiler.code.CodeConstants;\n@@ -246,7 +246,7 @@ else if (cl.superClass == null) { // neither interface nor super class defined\n       }\n \n       try {\n-        mt.expandData();\n+        mt.expandData(enclosingCl);\n \n         InstructionSequence seq = mt.getInstructionSequence();\n         if (seq != null) {\n@@ -303,55 +303,65 @@ public void writeClass(StructClass cl, TextBuffer buffer) throws IOException {\n       return;\n     }\n \n+    boolean packageInfo = cl.isSynthetic() && \"package-info\".equals(root.simpleName);\n+    boolean moduleInfo = cl.hasModifier(CodeConstants.ACC_MODULE) && cl.hasAttribute(StructGeneralAttribute.ATTRIBUTE_MODULE);\n+\n     DecompilerContext.getLogger().startReadingClass(cl.qualifiedName);\n     try {\n       ImportCollector importCollector = new ImportCollector(root);\n       DecompilerContext.startClass(importCollector);\n \n-      new LambdaProcessor().processClass(root);\n+      if (packageInfo) {\n+        ClassWriter.packageInfoToJava(cl, buffer);\n \n-      // add simple class names to implicit import\n-      addClassnameToImport(root, importCollector);\n+        importCollector.writeImports(buffer, false);\n+      }\n+      else if (moduleInfo) {\n+        TextBuffer moduleBuffer = new TextBuffer(AVERAGE_CLASS_SIZE);\n+        ClassWriter.moduleInfoToJava(cl, moduleBuffer);\n \n-      // build wrappers for all nested classes (that's where actual processing takes place)\n-      initWrappers(root);\n+        importCollector.writeImports(buffer, true);\n \n-      new NestedClassProcessor().processClass(root, root);\n+        buffer.append(moduleBuffer);\n+      }\n+      else {\n+        new LambdaProcessor().processClass(root);\n \n-      new NestedMemberAccess().propagateMemberAccess(root);\n+        // add simple class names to implicit import\n+        addClassNameToImport(root, importCollector);\n \n-      TextBuffer classBuffer = new TextBuffer(AVERAGE_CLASS_SIZE);\n-      new ClassWriter().classToJava(root, classBuffer, 0, null);\n+        // build wrappers for all nested classes (that's where actual processing takes place)\n+        initWrappers(root);\n \n-      int index = cl.qualifiedName.lastIndexOf(\"/\");\n-      if (index >= 0) {\n-        String packageName = cl.qualifiedName.substring(0, index).replace('/', '.');\n+        new NestedClassProcessor().processClass(root, root);\n \n-        buffer.append(\"package \");\n-        buffer.append(packageName);\n-        buffer.append(\";\");\n-        buffer.appendLineSeparator();\n-        buffer.appendLineSeparator();\n-      }\n+        new NestedMemberAccess().propagateMemberAccess(root);\n \n-      int import_lines_written = importCollector.writeImports(buffer);\n-      if (import_lines_written > 0) {\n-        buffer.appendLineSeparator();\n-      }\n+        TextBuffer classBuffer = new TextBuffer(AVERAGE_CLASS_SIZE);\n+        new ClassWriter().classToJava(root, classBuffer, 0, null);\n \n-      int offsetLines = buffer.countLines();\n+        int index = cl.qualifiedName.lastIndexOf('/');\n+        if (index >= 0) {\n+          String packageName = cl.qualifiedName.substring(0, index).replace('/', '.');\n+          buffer.append(\"package \").append(packageName).append(';').appendLineSeparator().appendLineSeparator();\n+        }\n \n-      buffer.append(classBuffer);\n+        importCollector.writeImports(buffer, true);\n \n-      if (DecompilerContext.getOption(IFernflowerPreferences.BYTECODE_SOURCE_MAPPING)) {\n-        BytecodeSourceMapper mapper = DecompilerContext.getBytecodeSourceMapper();\n-        mapper.addTotalOffset(offsetLines);\n-        if (DecompilerContext.getOption(IFernflowerPreferences.DUMP_ORIGINAL_LINES)) {\n-          buffer.dumpOriginalLineNumbers(mapper.getOriginalLinesMapping());\n-        }\n-        if (DecompilerContext.getOption(IFernflowerPreferences.UNIT_TEST_MODE)) {\n-          buffer.appendLineSeparator();\n-          mapper.dumpMapping(buffer, true);\n+        int offsetLines = buffer.countLines();\n+\n+        buffer.append(classBuffer);\n+\n+        if (DecompilerContext.getOption(IFernflowerPreferences.BYTECODE_SOURCE_MAPPING)) {\n+          BytecodeSourceMapper mapper = DecompilerContext.getBytecodeSourceMapper();\n+          mapper.addTotalOffset(offsetLines);\n+          if (DecompilerContext.getOption(IFernflowerPreferences.DUMP_ORIGINAL_LINES)) {\n+            buffer.dumpOriginalLineNumbers(mapper.getOriginalLinesMapping());\n+          }\n+          if (DecompilerContext.getOption(IFernflowerPreferences.UNIT_TEST_MODE)) {\n+            buffer.appendLineSeparator();\n+            mapper.dumpMapping(buffer, true);\n+          }\n         }\n       }\n     }\n@@ -376,13 +386,13 @@ private static void initWrappers(ClassNode node) {\n     }\n   }\n \n-  private static void addClassnameToImport(ClassNode node, ImportCollector imp) {\n+  private static void addClassNameToImport(ClassNode node, ImportCollector imp) {\n     if (node.simpleName != null && node.simpleName.length() > 0) {\n       imp.getShortName(node.type == ClassNode.CLASS_ROOT ? node.classStruct.qualifiedName : node.simpleName, false);\n     }\n \n     for (ClassNode nd : node.nested) {\n-      addClassnameToImport(nd, imp);\n+      addClassNameToImport(nd, imp);\n     }\n   }\n "
  },
  {
    "sha": "647ac7c3dd15323b0580cc42a6ca046c64c01138",
    "filename": "src/org/jetbrains/java/decompiler/main/collectors/ImportCollector.java",
    "status": "modified",
    "additions": 7,
    "deletions": 14,
    "changes": 21,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/main/collectors/ImportCollector.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/main/collectors/ImportCollector.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/main/collectors/ImportCollector.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.main.collectors;\n \n import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;\n@@ -150,21 +150,14 @@ else if (!mapSimpleNames.containsKey(shortName)) {\n     return result == null ? shortName : result;\n   }\n \n-  public int writeImports(TextBuffer buffer) {\n-    int importLinesWritten = 0;\n-\n+  public void writeImports(TextBuffer buffer, boolean addSeparator) {\n     List<String> imports = packImports();\n-\n-    for (String s : imports) {\n-      buffer.append(\"import \");\n-      buffer.append(s);\n-      buffer.append(';');\n+    for (String line : imports) {\n+      buffer.append(\"import \").append(line).append(';').appendLineSeparator();\n+    }\n+    if (addSeparator && !imports.isEmpty()) {\n       buffer.appendLineSeparator();\n-\n-      importLinesWritten++;\n     }\n-\n-    return importLinesWritten;\n   }\n \n   private List<String> packImports() {\n@@ -181,4 +174,4 @@ public int writeImports(TextBuffer buffer) {\n       .map(ent -> ent.getValue() + \".\" + ent.getKey())\n       .collect(Collectors.toList());\n   }\n-}\n\\ No newline at end of file\n+}"
  },
  {
    "sha": "7837939efab2b1caf023dc2f5b0a52659ce032bd",
    "filename": "src/org/jetbrains/java/decompiler/main/decompiler/BaseDecompiler.java",
    "status": "modified",
    "additions": 0,
    "deletions": 11,
    "changes": 11,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/main/decompiler/BaseDecompiler.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/main/decompiler/BaseDecompiler.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/main/decompiler/BaseDecompiler.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -25,17 +25,6 @@ public void addLibrary(File library) {\n     engine.addLibrary(library);\n   }\n \n-  /** @deprecated use {@link #addSource(File)} / {@link #addLibrary(File)} instead */\n-  @Deprecated\n-  public void addSpace(File file, boolean own) {\n-    if (own) {\n-      addSource(file);\n-    }\n-    else {\n-      addLibrary(file);\n-    }\n-  }\n-\n   public void decompileContext() {\n     try {\n       engine.decompileContext();"
  },
  {
    "sha": "d0b73c07d62ceedf205d020166e170249b5bb93a",
    "filename": "src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/main/rels/ClassWrapper.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.main.rels;\n \n import org.jetbrains.java.decompiler.code.CodeConstants;\n@@ -59,10 +59,10 @@ public void init() {\n       try {\n         if (mt.containsCode()) {\n           if (maxSec == 0 || testMode) {\n-            root = MethodProcessorRunnable.codeToJava(mt, md, varProc);\n+            root = MethodProcessorRunnable.codeToJava(classStruct, mt, md, varProc);\n           }\n           else {\n-            MethodProcessorRunnable mtProc = new MethodProcessorRunnable(mt, md, varProc, DecompilerContext.getCurrentContext());\n+            MethodProcessorRunnable mtProc = new MethodProcessorRunnable(classStruct, mt, md, varProc, DecompilerContext.getCurrentContext());\n \n             Thread mtThread = new Thread(mtProc, \"Java decompiler\");\n             long stopAt = System.currentTimeMillis() + maxSec * 1000L;"
  },
  {
    "sha": "2ad5b20116396973442a5e956a9c30f0a1bada13",
    "filename": "src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java",
    "status": "modified",
    "additions": 9,
    "deletions": 10,
    "changes": 19,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.main.rels;\n \n import org.jetbrains.java.decompiler.code.CodeConstants;\n@@ -33,17 +33,16 @@ public void processClass(ClassNode node) throws IOException {\n     ClassesProcessor clProcessor = DecompilerContext.getClassProcessor();\n     StructClass cl = node.classStruct;\n \n-    if (cl.getBytecodeVersion() < CodeConstants.BYTECODE_JAVA_8) { // lambda beginning with Java 8\n+    if (!cl.isVersion8()) { // lambda beginning with Java 8\n       return;\n     }\n \n-    StructBootstrapMethodsAttribute bootstrap =\n-      cl.getAttribute(StructGeneralAttribute.ATTRIBUTE_BOOTSTRAP_METHODS);\n+    StructBootstrapMethodsAttribute bootstrap = cl.getAttribute(StructGeneralAttribute.ATTRIBUTE_BOOTSTRAP_METHODS);\n     if (bootstrap == null || bootstrap.getMethodsNumber() == 0) {\n       return; // no bootstrap constants in pool\n     }\n \n-    BitSet lambda_methods = new BitSet();\n+    BitSet lambdaMethods = new BitSet();\n \n     // find lambda bootstrap constants\n     for (int i = 0; i < bootstrap.getMethodsNumber(); ++i) {\n@@ -52,19 +51,19 @@ public void processClass(ClassNode node) throws IOException {\n       // FIXME: extend for Eclipse etc. at some point\n       if (JAVAC_LAMBDA_CLASS.equals(method_ref.classname) &&\n           (JAVAC_LAMBDA_METHOD.equals(method_ref.elementname) || JAVAC_LAMBDA_ALT_METHOD.equals(method_ref.elementname))) {\n-        lambda_methods.set(i);\n+        lambdaMethods.set(i);\n       }\n     }\n \n-    if (lambda_methods.isEmpty()) {\n+    if (lambdaMethods.isEmpty()) {\n       return; // no lambda bootstrap constant found\n     }\n \n     Map<String, String> mapMethodsLambda = new HashMap<>();\n \n     // iterate over code and find invocations of bootstrap methods. Replace them with anonymous classes.\n     for (StructMethod mt : cl.getMethods()) {\n-      mt.expandData();\n+      mt.expandData(cl);\n \n       InstructionSequence seq = mt.getInstructionSequence();\n       if (seq != null && seq.length() > 0) {\n@@ -76,7 +75,7 @@ public void processClass(ClassNode node) throws IOException {\n           if (instr.opcode == CodeConstants.opc_invokedynamic) {\n             LinkConstant invoke_dynamic = cl.getPool().getLinkConstant(instr.operand(0));\n \n-            if (lambda_methods.get(invoke_dynamic.index1)) { // lambda invocation found\n+            if (lambdaMethods.get(invoke_dynamic.index1)) { // lambda invocation found\n \n               List<PooledConstant> bootstrap_arguments = bootstrap.getMethodArguments(invoke_dynamic.index1);\n               MethodDescriptor md = MethodDescriptor.parseDescriptor(invoke_dynamic.descriptor);\n@@ -123,4 +122,4 @@ public void processClass(ClassNode node) throws IOException {\n \n     // FIXME: mixed hierarchy?\n   }\n-}\n\\ No newline at end of file\n+}"
  },
  {
    "sha": "d9de3d584a63ba323914e165410ba8c63a118d2c",
    "filename": "src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java",
    "status": "modified",
    "additions": 12,
    "deletions": 11,
    "changes": 23,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/main/rels/MethodProcessorRunnable.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.main.rels;\n \n import org.jetbrains.java.decompiler.code.CodeConstants;\n@@ -22,6 +22,7 @@\n public class MethodProcessorRunnable implements Runnable {\n   public final Object lock = new Object();\n \n+  private final StructClass klass;\n   private final StructMethod method;\n   private final MethodDescriptor methodDescriptor;\n   private final VarProcessor varProc;\n@@ -31,10 +32,12 @@\n   private volatile Throwable error;\n   private volatile boolean finished = false;\n \n-  public MethodProcessorRunnable(StructMethod method,\n+  public MethodProcessorRunnable(StructClass klass,\n+                                 StructMethod method,\n                                  MethodDescriptor methodDescriptor,\n                                  VarProcessor varProc,\n                                  DecompilerContext parentContext) {\n+    this.klass = klass;\n     this.method = method;\n     this.methodDescriptor = methodDescriptor;\n     this.varProc = varProc;\n@@ -48,7 +51,7 @@ public void run() {\n \n     try {\n       DecompilerContext.setCurrentContext(parentContext);\n-      root = codeToJava(method, methodDescriptor, varProc);\n+      root = codeToJava(klass, method, methodDescriptor, varProc);\n     }\n     catch (Throwable t) {\n       error = t;\n@@ -63,17 +66,15 @@ public void run() {\n     }\n   }\n \n-  public static RootStatement codeToJava(StructMethod mt, MethodDescriptor md, VarProcessor varProc) throws IOException {\n-    StructClass cl = mt.getClassStruct();\n-\n+  public static RootStatement codeToJava(StructClass cl, StructMethod mt, MethodDescriptor md, VarProcessor varProc) throws IOException {\n     boolean isInitializer = CodeConstants.CLINIT_NAME.equals(mt.getName()); // for now static initializer only\n \n-    mt.expandData();\n+    mt.expandData(cl);\n     InstructionSequence seq = mt.getInstructionSequence();\n     ControlFlowGraph graph = new ControlFlowGraph(seq);\n \n     DeadCodeHelper.removeDeadBlocks(graph);\n-    graph.inlineJsr(mt);\n+    graph.inlineJsr(cl, mt);\n \n     // TODO: move to the start, before jsr inlining\n     DeadCodeHelper.connectDummyExitBlock(graph);\n@@ -110,13 +111,13 @@ public static RootStatement codeToJava(StructMethod mt, MethodDescriptor md, Var\n       if (!ExceptionDeobfuscator.handleMultipleEntryExceptionRanges(graph)) {\n         DecompilerContext.getLogger().writeMessage(\"Found multiple entry exception ranges which could not be splitted\", IFernflowerLogger.Severity.WARN);\n       }\n-      ExceptionDeobfuscator.insertDummyExceptionHandlerBlocks(graph, cl.getBytecodeVersion());\n+      ExceptionDeobfuscator.insertDummyExceptionHandlerBlocks(graph, mt.getBytecodeVersion());\n     }\n \n     RootStatement root = DomHelper.parseGraph(graph);\n \n     FinallyProcessor fProc = new FinallyProcessor(md, varProc);\n-    while (fProc.iterateGraph(mt, root, graph)) {\n+    while (fProc.iterateGraph(cl, mt, root, graph)) {\n       root = DomHelper.parseGraph(graph);\n     }\n \n@@ -200,4 +201,4 @@ public RootStatement getResult() throws Throwable {\n   public boolean isFinished() {\n     return finished;\n   }\n-}\n\\ No newline at end of file\n+}"
  },
  {
    "sha": "13106f59850df585d4c9589fc88346ab173b6832",
    "filename": "src/org/jetbrains/java/decompiler/modules/code/DeadCodeHelper.java",
    "status": "modified",
    "additions": 10,
    "deletions": 5,
    "changes": 15,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/modules/code/DeadCodeHelper.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/modules/code/DeadCodeHelper.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/modules/code/DeadCodeHelper.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -267,7 +267,9 @@ public static void extendSynchronizedRangeToMonitorexit(ControlFlowGraph graph)\n         for (BasicBlock block : range.getProtectedRange()) {\n           setPreds.addAll(block.getPreds());\n         }\n-        setPreds.removeAll(range.getProtectedRange());\n+        for (BasicBlock basicBlock : range.getProtectedRange()) {\n+          setPreds.remove(basicBlock);\n+        }\n \n         if(setPreds.size() != 1) {\n           continue; // multiple predecessors, obfuscated range\n@@ -280,8 +282,7 @@ public static void extendSynchronizedRangeToMonitorexit(ControlFlowGraph graph)\n         }\n \n         boolean monitorexit_in_range = false;\n-        Set<BasicBlock> setProtectedBlocks = new HashSet<>();\n-        setProtectedBlocks.addAll(range.getProtectedRange());\n+        Set<BasicBlock> setProtectedBlocks = new HashSet<>(range.getProtectedRange());\n         setProtectedBlocks.add(range.getHandler());\n \n         for (BasicBlock block : setProtectedBlocks) {\n@@ -305,7 +306,9 @@ public static void extendSynchronizedRangeToMonitorexit(ControlFlowGraph graph)\n         for (BasicBlock block : range.getProtectedRange()) {\n           setSuccs.addAll(block.getSuccs());\n         }\n-        setSuccs.removeAll(range.getProtectedRange());\n+        for (BasicBlock basicBlock : range.getProtectedRange()) {\n+          setSuccs.remove(basicBlock);\n+        }\n \n         if(setSuccs.size() != 1) {\n           continue; // non-unique successor\n@@ -461,7 +464,9 @@ else if (seq.getLastInstr().opcode != CodeConstants.opc_return) {\n             }\n \n             // add exception ranges from predecessors\n-            setPredHandlersIntersection.removeAll(block.getSuccExceptions());\n+            for (BasicBlock basicBlock : block.getSuccExceptions()) {\n+              setPredHandlersIntersection.remove(basicBlock);\n+            }\n             BasicBlock predecessor = block.getPreds().get(0);\n \n             for (BasicBlock handler : setPredHandlersIntersection) {"
  },
  {
    "sha": "9f5289507e7d8f25b4f2f269ee239643b3cd7698",
    "filename": "src/org/jetbrains/java/decompiler/modules/decompiler/FinallyProcessor.java",
    "status": "modified",
    "additions": 11,
    "deletions": 16,
    "changes": 27,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/modules/decompiler/FinallyProcessor.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/modules/decompiler/FinallyProcessor.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/modules/decompiler/FinallyProcessor.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.modules.decompiler;\n \n import org.jetbrains.java.decompiler.code.CodeConstants;\n@@ -26,6 +26,7 @@\n import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;\n import org.jetbrains.java.decompiler.modules.decompiler.vars.VarProcessor;\n import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;\n+import org.jetbrains.java.decompiler.struct.StructClass;\n import org.jetbrains.java.decompiler.struct.StructMethod;\n import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;\n import org.jetbrains.java.decompiler.struct.gen.VarType;\n@@ -46,12 +47,8 @@ public FinallyProcessor(MethodDescriptor md, VarProcessor varProc) {\n     varProcessor = varProc;\n   }\n \n-  public boolean iterateGraph(StructMethod mt, RootStatement root, ControlFlowGraph graph) {\n-    return processStatementEx(mt, root, graph);\n-  }\n-\n-  private boolean processStatementEx(StructMethod mt, RootStatement root, ControlFlowGraph graph) {\n-    int bytecode_version = mt.getClassStruct().getBytecodeVersion();\n+  public boolean iterateGraph(StructClass cl, StructMethod mt, RootStatement root, ControlFlowGraph graph) {\n+    int bytecodeVersion = mt.getBytecodeVersion();\n \n     LinkedList<Statement> stack = new LinkedList<>();\n     stack.add(root);\n@@ -77,22 +74,20 @@ else if (finallyBlockIDs.containsKey(handler.id)) {\n           fin.setMonitor(var == null ? null : new VarExprent(var, VarType.VARTYPE_INT, varProcessor));\n         }\n         else {\n-          Record inf = getFinallyInformation(mt, root, fin);\n+          Record inf = getFinallyInformation(cl, mt, root, fin);\n \n           if (inf == null) { // inconsistent finally\n             catchallBlockIDs.put(handler.id, null);\n           }\n           else {\n-\n             if (DecompilerContext.getOption(IFernflowerPreferences.FINALLY_DEINLINE) && verifyFinallyEx(graph, fin, inf)) {\n               finallyBlockIDs.put(handler.id, null);\n             }\n             else {\n+              int varIndex = DecompilerContext.getCounterContainer().getCounterAndIncrement(CounterContainer.VAR_COUNTER);\n+              insertSemaphore(graph, getAllBasicBlocks(fin.getFirst()), head, handler, varIndex, inf, bytecodeVersion);\n \n-              int varindex = DecompilerContext.getCounterContainer().getCounterAndIncrement(CounterContainer.VAR_COUNTER);\n-              insertSemaphore(graph, getAllBasicBlocks(fin.getFirst()), head, handler, varindex, inf, bytecode_version);\n-\n-              finallyBlockIDs.put(handler.id, varindex);\n+              finallyBlockIDs.put(handler.id, varIndex);\n             }\n \n             DeadCodeHelper.removeDeadBlocks(graph); // e.g. multiple return blocks after a nested finally\n@@ -120,7 +115,7 @@ private Record(int firstCode, Map<BasicBlock, Boolean> mapLast) {\n     }\n   }\n \n-  private Record getFinallyInformation(StructMethod mt, RootStatement root, CatchAllStatement fstat) {\n+  private Record getFinallyInformation(StructClass cl, StructMethod mt, RootStatement root, CatchAllStatement fstat) {\n     Map<BasicBlock, Boolean> mapLast = new HashMap<>();\n \n     BasicBlockStatement firstBlockStatement = fstat.getHandler().getBasichead();\n@@ -138,7 +133,7 @@ private Record getFinallyInformation(StructMethod mt, RootStatement root, CatchA\n     }\n \n     ExprProcessor proc = new ExprProcessor(methodDescriptor, varProcessor);\n-    proc.processStatement(root, mt.getClassStruct());\n+    proc.processStatement(root, cl);\n \n     SSAConstructorSparseEx ssa = new SSAConstructorSparseEx();\n     ssa.splitVariables(root, mt);\n@@ -977,4 +972,4 @@ private static void removeExceptionInstructionsEx(BasicBlock block, int blocktyp\n       }\n     }\n   }\n-}\n\\ No newline at end of file\n+}"
  },
  {
    "sha": "fcea19f0836ed3729d855b1efe3136905b623bee",
    "filename": "src/org/jetbrains/java/decompiler/modules/decompiler/StrongConnectivityHelper.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/modules/decompiler/StrongConnectivityHelper.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/modules/decompiler/StrongConnectivityHelper.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/modules/decompiler/StrongConnectivityHelper.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -90,7 +90,9 @@ public static boolean isExitComponent(List<? extends Statement> lst) {\n     for (Statement stat : lst) {\n       set.addAll(stat.getNeighbours(StatEdge.TYPE_REGULAR, Statement.DIRECTION_FORWARD));\n     }\n-    set.removeAll(lst);\n+    for (Statement stat : lst) {\n+      set.remove(stat);\n+    }\n \n     return (set.size() == 0);\n   }"
  },
  {
    "sha": "d0a2260b1c5b597bab6caec1cb616aaeb70351a4",
    "filename": "src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java",
    "status": "modified",
    "additions": 2,
    "deletions": 3,
    "changes": 5,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.modules.decompiler.exps;\n \n import org.jetbrains.java.decompiler.code.CodeConstants;\n@@ -30,7 +30,6 @@\n import java.util.List;\n \n public class VarExprent extends Exprent {\n-\n   public static final int STACK_BASE = 10000;\n   public static final String VAR_NAMELESS_ENCLOSURE = \"<VAR_NAMELESS_ENCLOSURE>\";\n \n@@ -122,7 +121,7 @@ public String getDebugName(StructMethod method) {\n       Integer origIndex = processor.getVarOriginalIndex(index);\n       if (origIndex != null) {\n         String name = attr.getName(origIndex, visibleOffset);\n-        if (name != null && TextUtil.isValidIdentifier(name, method.getClassStruct().getBytecodeVersion())) {\n+        if (name != null && TextUtil.isValidIdentifier(name, method.getBytecodeVersion())) {\n           return name;\n         }\n       }"
  },
  {
    "sha": "8d766e0412cc952c42d53eae5cec74db5c992c0d",
    "filename": "src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java",
    "status": "modified",
    "additions": 4,
    "deletions": 8,
    "changes": 12,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarProcessor.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.modules.decompiler.vars;\n \n import org.jetbrains.java.decompiler.main.collectors.VarNamesCollector;\n@@ -55,7 +55,7 @@ public void setDebugVarNames(Map<Integer, String> mapDebugVarNames) {\n       Integer index = mapOriginalVarIndices.get(pair.var);\n       if (index != null) {\n         String debugName = mapDebugVarNames.get(index);\n-        if (debugName != null && TextUtil.isValidIdentifier(debugName, method.getClassStruct().getBytecodeVersion())) {\n+        if (debugName != null && TextUtil.isValidIdentifier(debugName, method.getBytecodeVersion())) {\n           name = debugName;\n         }\n       }\n@@ -72,11 +72,7 @@ public void setDebugVarNames(Map<Integer, String> mapDebugVarNames) {\n   }\n \n   public Integer getVarOriginalIndex(int index) {\n-    if (varVersions == null) {\n-      return null;\n-    }\n-\n-    return varVersions.getMapOriginalVarIndices().get(index);\n+    return varVersions == null ? null : varVersions.getMapOriginalVarIndices().get(index);\n   }\n \n   public void refreshVarNames(VarNamesCollector vc) {\n@@ -125,4 +121,4 @@ public void setVarFinal(VarVersionPair pair, int finalType) {\n   public Set<VarVersionPair> getExternalVars() {\n     return externalVars;\n   }\n-}\n\\ No newline at end of file\n+}"
  },
  {
    "sha": "07237bedb1963dd47dabb32f0c3f4821d9e12178",
    "filename": "src/org/jetbrains/java/decompiler/struct/ContextUnit.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/ContextUnit.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/ContextUnit.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/struct/ContextUnit.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.struct;\n \n import net.fabricmc.fernflower.api.IFabricResultSaver;\n@@ -69,7 +69,7 @@ public void reload(LazyLoader loader) throws IOException {\n \n       StructClass newCl;\n       try (DataInputFullStream in = loader.getClassStream(oldName)) {\n-        newCl = new StructClass(in, cl.isOwn(), loader);\n+        newCl = StructClass.create(in, cl.isOwn(), loader);\n       }\n \n       lstClasses.add(newCl);"
  },
  {
    "sha": "134813e5a764ec4c0cbd2f9efb0a0a2a4e69e1d1",
    "filename": "src/org/jetbrains/java/decompiler/struct/StructClass.java",
    "status": "modified",
    "additions": 62,
    "deletions": 50,
    "changes": 112,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/StructClass.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/StructClass.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/struct/StructClass.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.struct;\n \n import org.jetbrains.java.decompiler.code.CodeConstants;\n@@ -13,6 +13,7 @@\n \n import java.io.IOException;\n import java.util.List;\n+import java.util.Map;\n \n /*\n   class_file {\n@@ -35,71 +36,86 @@\n   }\n */\n public class StructClass extends StructMember {\n-\n-  public final String qualifiedName;\n-  public final PrimitiveConstant superClass;\n-\n-  private final boolean own;\n-  private final LazyLoader loader;\n-  private final int minorVersion;\n-  private final int majorVersion;\n-  private final int[] interfaces;\n-  private final String[] interfaceNames;\n-  private final VBStyleCollection<StructField, String> fields;\n-  private final VBStyleCollection<StructMethod, String> methods;\n-\n-  private ConstantPool pool;\n-\n-  public StructClass(byte[] bytes, boolean own, LazyLoader loader) throws IOException {\n-    this(new DataInputFullStream(bytes), own, loader);\n-  }\n-\n-  public StructClass(DataInputFullStream in, boolean own, LazyLoader loader) throws IOException {\n-    this.own = own;\n-    this.loader = loader;\n-\n+  public static StructClass create(DataInputFullStream in, boolean own, LazyLoader loader) throws IOException {\n     in.discard(4);\n+    int minorVersion = in.readUnsignedShort();\n+    int majorVersion = in.readUnsignedShort();\n+    int bytecodeVersion = Math.max(majorVersion, CodeConstants.BYTECODE_JAVA_LE_4);\n \n-    minorVersion = in.readUnsignedShort();\n-    majorVersion = in.readUnsignedShort();\n+    ConstantPool pool = new ConstantPool(in);\n \n-    pool = new ConstantPool(in);\n-\n-    accessFlags = in.readUnsignedShort();\n+    int accessFlags = in.readUnsignedShort();\n     int thisClassIdx = in.readUnsignedShort();\n     int superClassIdx = in.readUnsignedShort();\n-    qualifiedName = pool.getPrimitiveConstant(thisClassIdx).getString();\n-    superClass = pool.getPrimitiveConstant(superClassIdx);\n+    String qualifiedName = pool.getPrimitiveConstant(thisClassIdx).getString();\n+    PrimitiveConstant superClass = pool.getPrimitiveConstant(superClassIdx);\n \n-    // interfaces\n     int length = in.readUnsignedShort();\n-    interfaces = new int[length];\n-    interfaceNames = new String[length];\n+    int[] interfaces = new int[length];\n+    String[] interfaceNames = new String[length];\n     for (int i = 0; i < length; i++) {\n       interfaces[i] = in.readUnsignedShort();\n       interfaceNames[i] = pool.getPrimitiveConstant(interfaces[i]).getString();\n     }\n \n-    // fields\n     length = in.readUnsignedShort();\n-    fields = new VBStyleCollection<>(length);\n+    VBStyleCollection<StructField, String>fields = new VBStyleCollection<>(length);\n     for (int i = 0; i < length; i++) {\n-      StructField field = new StructField(in, this);\n+      StructField field = StructField.create(in, pool, qualifiedName);\n       fields.addWithKey(field, InterpreterUtil.makeUniqueKey(field.getName(), field.getDescriptor()));\n     }\n \n-    // methods\n     length = in.readUnsignedShort();\n-    methods = new VBStyleCollection<>(length);\n+    VBStyleCollection<StructMethod, String>methods = new VBStyleCollection<>(length);\n     for (int i = 0; i < length; i++) {\n-      StructMethod method = new StructMethod(in, this);\n+      StructMethod method = StructMethod.create(in, pool, qualifiedName, bytecodeVersion, own);\n       methods.addWithKey(method, InterpreterUtil.makeUniqueKey(method.getName(), method.getDescriptor()));\n     }\n \n-    // attributes\n-    attributes = readAttributes(in, pool);\n+    Map<String, StructGeneralAttribute> attributes = readAttributes(in, pool);\n+\n+    StructClass cl = new StructClass(\n+      accessFlags, attributes, qualifiedName, superClass, own, loader, minorVersion, majorVersion, interfaces, interfaceNames, fields, methods);\n+    if (loader == null) cl.pool = pool;\n+    return cl;\n+  }\n+\n+  public final String qualifiedName;\n+  public final PrimitiveConstant superClass;\n+  private final boolean own;\n+  private final LazyLoader loader;\n+  private final int minorVersion;\n+  private final int majorVersion;\n+  private final int[] interfaces;\n+  private final String[] interfaceNames;\n+  private final VBStyleCollection<StructField, String> fields;\n+  private final VBStyleCollection<StructMethod, String> methods;\n+\n+  private ConstantPool pool;\n \n-    releaseResources();\n+  private StructClass(int accessFlags,\n+                      Map<String, StructGeneralAttribute> attributes,\n+                      String qualifiedName,\n+                      PrimitiveConstant superClass,\n+                      boolean own,\n+                      LazyLoader loader,\n+                      int minorVersion,\n+                      int majorVersion,\n+                      int[] interfaces,\n+                      String[] interfaceNames,\n+                      VBStyleCollection<StructField, String> fields,\n+                      VBStyleCollection<StructMethod, String> methods) {\n+    super(accessFlags, attributes);\n+    this.qualifiedName = qualifiedName;\n+    this.superClass = superClass;\n+    this.own = own;\n+    this.loader = loader;\n+    this.minorVersion = minorVersion;\n+    this.majorVersion = majorVersion;\n+    this.interfaces = interfaces;\n+    this.interfaceNames = interfaceNames;\n+    this.fields = fields;\n+    this.methods = methods;\n   }\n \n   public boolean hasField(String name, String descriptor) {\n@@ -168,17 +184,13 @@ public LazyLoader getLoader() {\n     return loader;\n   }\n \n-  public boolean isVersionGE_1_5() {\n+  public boolean isVersion5() {\n     return (majorVersion > CodeConstants.BYTECODE_JAVA_LE_4 ||\n             (majorVersion == CodeConstants.BYTECODE_JAVA_LE_4 && minorVersion > 0)); // FIXME: check second condition\n   }\n \n-  public boolean isVersionGE_1_7() {\n-    return (majorVersion >= CodeConstants.BYTECODE_JAVA_7);\n-  }\n-\n-  public int getBytecodeVersion() {\n-    return Math.max(majorVersion, CodeConstants.BYTECODE_JAVA_LE_4);\n+  public boolean isVersion8() {\n+    return majorVersion >= CodeConstants.BYTECODE_JAVA_8;\n   }\n \n   @Override"
  },
  {
    "sha": "61486aa06985324eb48a931d50cec4749719a0a1",
    "filename": "src/org/jetbrains/java/decompiler/struct/StructContext.java",
    "status": "modified",
    "additions": 4,
    "deletions": 5,
    "changes": 9,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/StructContext.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/StructContext.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/struct/StructContext.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.struct;\n \n import org.jetbrains.java.decompiler.main.DecompilerContext;\n@@ -17,7 +17,6 @@\n import java.util.zip.ZipFile;\n \n public class StructContext {\n-\n   private final IResultSaver saver;\n   private final IDecompiledData decompiledData;\n   private final LazyLoader loader;\n@@ -106,7 +105,7 @@ else if (filename.endsWith(\".zip\")) {\n \n       if (filename.endsWith(\".class\")) {\n         try (DataInputFullStream in = loader.getClassStream(file.getAbsolutePath(), null)) {\n-          StructClass cl = new StructClass(in, isOwn, loader);\n+          StructClass cl = StructClass.create(in, isOwn, loader);\n           classes.put(cl.qualifiedName, cl);\n           unit.addClass(cl, filename);\n           loader.addClassLink(cl.qualifiedName, new LazyLoader.Link(file.getAbsolutePath(), null));\n@@ -141,7 +140,7 @@ private void addArchive(String path, File file, int type, boolean isOwn) throws\n         if (!entry.isDirectory()) {\n           if (name.endsWith(\".class\")) {\n             byte[] bytes = InterpreterUtil.getBytes(archive, entry);\n-            StructClass cl = new StructClass(bytes, isOwn, loader);\n+            StructClass cl = StructClass.create(new DataInputFullStream(bytes), isOwn, loader);\n             classes.put(cl.qualifiedName, cl);\n             unit.addClass(cl, name);\n             loader.addClassLink(cl.qualifiedName, new LazyLoader.Link(file.getAbsolutePath(), name));\n@@ -160,4 +159,4 @@ private void addArchive(String path, File file, int type, boolean isOwn) throws\n   public Map<String, StructClass> getClasses() {\n     return classes;\n   }\n-}\n\\ No newline at end of file\n+}"
  },
  {
    "sha": "cfa64d2087246cc980bb25f0d80779e11da04232",
    "filename": "src/org/jetbrains/java/decompiler/struct/StructField.java",
    "status": "modified",
    "additions": 19,
    "deletions": 14,
    "changes": 33,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/StructField.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/StructField.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/struct/StructField.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,10 +1,12 @@\n-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.struct;\n \n+import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;\n import org.jetbrains.java.decompiler.struct.consts.ConstantPool;\n import org.jetbrains.java.decompiler.util.DataInputFullStream;\n \n import java.io.IOException;\n+import java.util.Map;\n \n /*\n   field_info {\n@@ -16,29 +18,32 @@\n    }\n */\n public class StructField extends StructMember {\n+  public static StructField create(DataInputFullStream in, ConstantPool pool, String clQualifiedName) throws IOException {\n+    int accessFlags = in.readUnsignedShort();\n+    int nameIndex = in.readUnsignedShort();\n+    int descriptorIndex = in.readUnsignedShort();\n \n-  private final String name;\n-  private final String descriptor;\n+    String[] values = pool.getClassElement(ConstantPool.FIELD, clQualifiedName, nameIndex, descriptorIndex);\n \n+    Map<String, StructGeneralAttribute> attributes = readAttributes(in, pool);\n \n-  public StructField(DataInputFullStream in, StructClass clStruct) throws IOException {\n-    accessFlags = in.readUnsignedShort();\n-    int nameIndex = in.readUnsignedShort();\n-    int descriptorIndex = in.readUnsignedShort();\n+    return new StructField(accessFlags, attributes, values[0], values[1]);\n+  }\n \n-    ConstantPool pool = clStruct.getPool();\n-    String[] values = pool.getClassElement(ConstantPool.FIELD, clStruct.qualifiedName, nameIndex, descriptorIndex);\n-    name = values[0];\n-    descriptor = values[1];\n+  private final String name;\n+  private final String descriptor;\n \n-    attributes = readAttributes(in, pool);\n+  protected StructField(int accessFlags, Map<String, StructGeneralAttribute> attributes, String name, String descriptor) {\n+    super(accessFlags, attributes);\n+    this.name = name;\n+    this.descriptor = descriptor;\n   }\n \n-  public String getName() {\n+  public final String getName() {\n     return name;\n   }\n \n-  public String getDescriptor() {\n+  public final String getDescriptor() {\n     return descriptor;\n   }\n "
  },
  {
    "sha": "920e7f9af2c86e1e20cee2f167026097bd828ae0",
    "filename": "src/org/jetbrains/java/decompiler/struct/StructMember.java",
    "status": "modified",
    "additions": 24,
    "deletions": 29,
    "changes": 53,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/StructMember.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/StructMember.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/struct/StructMember.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.struct;\n \n import org.jetbrains.java.decompiler.code.CodeConstants;\n@@ -12,23 +12,26 @@\n import java.util.HashMap;\n import java.util.Map;\n \n-public class StructMember {\n-\n-  protected int accessFlags;\n-  protected Map<String, StructGeneralAttribute> attributes;\n+public abstract class StructMember {\n+  private final int accessFlags;\n+  private final Map<String, StructGeneralAttribute> attributes;\n \n+  protected StructMember(int accessFlags, Map<String, StructGeneralAttribute> attributes) {\n+    this.accessFlags = accessFlags;\n+    this.attributes = attributes;\n+  }\n \n   public int getAccessFlags() {\n     return accessFlags;\n   }\n \n   public <T extends StructGeneralAttribute> T getAttribute(StructGeneralAttribute.Key<T> attribute) {\n-    //noinspection unchecked\n-    return (T)attributes.get(attribute.getName());\n+    @SuppressWarnings(\"unchecked\") T t = (T)attributes.get(attribute.name);\n+    return t;\n   }\n \n   public boolean hasAttribute(StructGeneralAttribute.Key<?> attribute) {\n-    return attributes.containsKey(attribute.getName());\n+    return attributes.containsKey(attribute.name);\n   }\n \n   public boolean hasModifier(int modifier) {\n@@ -39,45 +42,37 @@ public boolean isSynthetic() {\n     return hasModifier(CodeConstants.ACC_SYNTHETIC) || hasAttribute(StructGeneralAttribute.ATTRIBUTE_SYNTHETIC);\n   }\n \n-  protected Map<String, StructGeneralAttribute> readAttributes(DataInputFullStream in, ConstantPool pool) throws IOException {\n+  public static Map<String, StructGeneralAttribute> readAttributes(DataInputFullStream in, ConstantPool pool) throws IOException {\n     int length = in.readUnsignedShort();\n-\n     Map<String, StructGeneralAttribute> attributes = new HashMap<>(length);\n+\n     for (int i = 0; i < length; i++) {\n       int nameIndex = in.readUnsignedShort();\n       String name = pool.getPrimitiveConstant(nameIndex).getString();\n \n-      StructGeneralAttribute attribute = readAttribute(in, pool, name);\n-\n-      if (attribute != null) {\n-        if (StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE.getName().equals(name) && attributes.containsKey(name)) {\n+      StructGeneralAttribute attribute = StructGeneralAttribute.createAttribute(name);\n+      int attLength = in.readInt();\n+      if (attribute == null) {\n+        in.discard(attLength);\n+      }\n+      else {\n+        attribute.initContent(in, pool);\n+        if (StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE.name.equals(name) && attributes.containsKey(name)) {\n           // merge all variable tables\n           StructLocalVariableTableAttribute table = (StructLocalVariableTableAttribute)attributes.get(name);\n           table.add((StructLocalVariableTableAttribute)attribute);\n         }\n-        else if (StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE.getName().equals(name) && attributes.containsKey(name)) {\n+        else if (StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE.name.equals(name) && attributes.containsKey(name)) {\n           // merge all variable tables\n           StructLocalVariableTypeTableAttribute table = (StructLocalVariableTypeTableAttribute)attributes.get(name);\n           table.add((StructLocalVariableTypeTableAttribute)attribute);\n         }\n         else {\n-          attributes.put(attribute.getName(), attribute);\n+          attributes.put(name, attribute);\n         }\n       }\n     }\n \n     return attributes;\n   }\n-\n-  protected StructGeneralAttribute readAttribute(DataInputFullStream in, ConstantPool pool, String name) throws IOException {\n-    StructGeneralAttribute attribute = StructGeneralAttribute.createAttribute(name);\n-    int length = in.readInt();\n-    if (attribute == null) {\n-      in.discard(length);\n-    }\n-    else {\n-      attribute.initContent(in, pool);\n-    }\n-    return attribute;\n-  }\n-}\n\\ No newline at end of file\n+}"
  },
  {
    "sha": "a71559379c0aecb53fe8d6d43b8630fa3c16cb10",
    "filename": "src/org/jetbrains/java/decompiler/struct/StructMethod.java",
    "status": "modified",
    "additions": 51,
    "deletions": 67,
    "changes": 118,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/StructMethod.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/StructMethod.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/struct/StructMethod.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,7 +1,8 @@\n-// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.struct;\n \n import org.jetbrains.java.decompiler.code.*;\n+import org.jetbrains.java.decompiler.struct.attr.StructCodeAttribute;\n import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;\n import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute;\n import org.jetbrains.java.decompiler.struct.consts.ConstantPool;\n@@ -25,80 +26,66 @@\n   }\n */\n public class StructMethod extends StructMember {\n+  public static StructMethod create(DataInputFullStream in, ConstantPool pool, String clQualifiedName, int bytecodeVersion, boolean own) throws IOException {\n+    int accessFlags = in.readUnsignedShort();\n+    int nameIndex = in.readUnsignedShort();\n+    int descriptorIndex = in.readUnsignedShort();\n+\n+    String[] values = pool.getClassElement(ConstantPool.METHOD, clQualifiedName, nameIndex, descriptorIndex);\n+\n+    Map<String, StructGeneralAttribute> attributes = readAttributes(in, pool);\n+    StructCodeAttribute code = (StructCodeAttribute)attributes.remove(StructGeneralAttribute.ATTRIBUTE_CODE.name);\n+    if (code != null) {\n+      attributes.putAll(code.codeAttributes);\n+    }\n+\n+    return new StructMethod(accessFlags, attributes, values[0], values[1], bytecodeVersion, own ? code : null);\n+  }\n+\n   private static final int[] opr_iconst = {-1, 0, 1, 2, 3, 4, 5};\n   private static final int[] opr_loadstore = {0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3};\n   private static final int[] opcs_load = {opc_iload, opc_lload, opc_fload, opc_dload, opc_aload};\n   private static final int[] opcs_store = {opc_istore, opc_lstore, opc_fstore, opc_dstore, opc_astore};\n \n-  private final StructClass classStruct;\n   private final String name;\n   private final String descriptor;\n-\n-  private boolean containsCode = false;\n-  private int localVariables = 0;\n-  private int codeLength = 0;\n-  private int codeFullLength = 0;\n-  private InstructionSequence seq;\n+  private final int bytecodeVersion;\n+  private final int localVariables;\n+  private final int codeLength;\n+  private final int codeFullLength;\n+  private InstructionSequence seq = null;\n   private boolean expanded = false;\n-  private Map<String, StructGeneralAttribute> codeAttributes;\n-\n-  public StructMethod(DataInputFullStream in, StructClass clStruct) throws IOException {\n-    classStruct = clStruct;\n \n-    accessFlags = in.readUnsignedShort();\n-    int nameIndex = in.readUnsignedShort();\n-    int descriptorIndex = in.readUnsignedShort();\n-\n-    ConstantPool pool = clStruct.getPool();\n-    String[] values = pool.getClassElement(ConstantPool.METHOD, clStruct.qualifiedName, nameIndex, descriptorIndex);\n-    name = values[0];\n-    descriptor = values[1];\n-\n-    attributes = readAttributes(in, pool);\n-    if (codeAttributes != null) {\n-      attributes.putAll(codeAttributes);\n-      codeAttributes = null;\n+  private StructMethod(int accessFlags,\n+                       Map<String, StructGeneralAttribute> attributes,\n+                       String name,\n+                       String descriptor,\n+                       int bytecodeVersion,\n+                       StructCodeAttribute code) {\n+    super(accessFlags, attributes);\n+    this.name = name;\n+    this.descriptor = descriptor;\n+    this.bytecodeVersion = bytecodeVersion;\n+    if (code != null) {\n+      this.localVariables = code.localVariables;\n+      this.codeLength = code.codeLength;\n+      this.codeFullLength = code.codeFullLength;\n     }\n-  }\n-\n-  @Override\n-  protected StructGeneralAttribute readAttribute(DataInputFullStream in, ConstantPool pool, String name) throws IOException {\n-    if (StructGeneralAttribute.ATTRIBUTE_CODE.getName().equals(name)) {\n-      if (!classStruct.isOwn()) {\n-        // skip code in foreign classes\n-        in.discard(8);\n-        in.discard(in.readInt());\n-        in.discard(8 * in.readUnsignedShort());\n-      }\n-      else {\n-        containsCode = true;\n-        in.discard(6);\n-        localVariables = in.readUnsignedShort();\n-        codeLength = in.readInt();\n-        in.discard(codeLength);\n-        int excLength = in.readUnsignedShort();\n-        in.discard(excLength * 8);\n-        codeFullLength = codeLength + excLength * 8 + 2;\n-      }\n-\n-      codeAttributes = readAttributes(in, pool);\n-\n-      return null;\n+    else {\n+      this.localVariables = this.codeLength = this.codeFullLength = -1;\n     }\n-\n-    return super.readAttribute(in, pool, name);\n   }\n \n-  public void expandData() throws IOException {\n-    if (containsCode && !expanded) {\n-      byte[] code = classStruct.getLoader().loadBytecode(this, codeFullLength);\n+  public void expandData(StructClass classStruct) throws IOException {\n+    if (codeLength >= 0 && !expanded) {\n+      byte[] code = classStruct.getLoader().loadBytecode(classStruct, this, codeFullLength);\n       seq = parseBytecode(new DataInputFullStream(code), codeLength, classStruct.getPool());\n       expanded = true;\n     }\n   }\n \n   public void releaseResources() {\n-    if (containsCode && expanded) {\n+    if (codeLength >= 0 && expanded) {\n       seq = null;\n       expanded = false;\n     }\n@@ -108,10 +95,7 @@ public void releaseResources() {\n   private InstructionSequence parseBytecode(DataInputFullStream in, int length, ConstantPool pool) throws IOException {\n     VBStyleCollection<Instruction, Integer> instructions = new VBStyleCollection<>();\n \n-    int bytecode_version = classStruct.getBytecodeVersion();\n-\n     for (int i = 0; i < length; ) {\n-\n       int offset = i;\n \n       int opcode = in.readUnsignedByte();\n@@ -197,7 +181,7 @@ else if (opcode >= opc_invokevirtual && opcode <= opc_invokestatic) {\n             }\n             break;\n           case opc_invokedynamic:\n-            if (classStruct.isVersionGE_1_7()) { // instruction unused in Java 6 and before\n+            if (bytecodeVersion >= CodeConstants.BYTECODE_JAVA_7) { // instruction unused in Java 6 and before\n               operands.add(in.readUnsignedShort());\n               in.discard(2);\n               group = GROUP_INVOCATION;\n@@ -313,7 +297,7 @@ else if (opcode >= opc_invokevirtual && opcode <= opc_invokestatic) {\n         }\n       }\n \n-      Instruction instr = Instruction.create(opcode, wide, group, bytecode_version, ops);\n+      Instruction instr = Instruction.create(opcode, wide, group, bytecodeVersion, ops);\n \n       instructions.addWithKey(instr, offset);\n \n@@ -355,10 +339,6 @@ else if (opcode >= opc_invokevirtual && opcode <= opc_invokestatic) {\n     return seq;\n   }\n \n-  public StructClass getClassStruct() {\n-    return classStruct;\n-  }\n-\n   public String getName() {\n     return name;\n   }\n@@ -367,8 +347,12 @@ public String getDescriptor() {\n     return descriptor;\n   }\n \n+  public int getBytecodeVersion() {\n+    return bytecodeVersion;\n+  }\n+\n   public boolean containsCode() {\n-    return containsCode;\n+    return codeLength >= 0;\n   }\n \n   public int getLocalVariables() {\n@@ -387,4 +371,4 @@ public StructLocalVariableTableAttribute getLocalVariableAttr() {\n   public String toString() {\n     return name;\n   }\n-}\n\\ No newline at end of file\n+}"
  },
  {
    "sha": "e50983daf2a1bf6c93ec92c99221587d7c4f7c6a",
    "filename": "src/org/jetbrains/java/decompiler/struct/StructRecordComponent.java",
    "status": "modified",
    "additions": 11,
    "deletions": 22,
    "changes": 33,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/StructRecordComponent.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/StructRecordComponent.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/struct/StructRecordComponent.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -1,11 +1,13 @@\n-// Copyright 2000-2017 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n package org.jetbrains.java.decompiler.struct;\n \n+import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;\n import org.jetbrains.java.decompiler.struct.consts.ConstantPool;\n import org.jetbrains.java.decompiler.struct.consts.PrimitiveConstant;\n import org.jetbrains.java.decompiler.util.DataInputFullStream;\n \n import java.io.IOException;\n+import java.util.Map;\n \n /*\n   record_component_info {\n@@ -15,33 +17,20 @@\n     attribute_info attributes[attributes_count];\n    }\n */\n-public class StructRecordComponent extends StructMember {\n-\n-  private final String name;\n-  private final String descriptor;\n-\n-\n-  public StructRecordComponent(DataInputFullStream in, ConstantPool pool) throws IOException {\n-    accessFlags = 0;\n+public class StructRecordComponent extends StructField {\n+  public static StructRecordComponent create(DataInputFullStream in, ConstantPool pool) throws IOException {\n     int nameIndex = in.readUnsignedShort();\n     int descriptorIndex = in.readUnsignedShort();\n \n-    name = ((PrimitiveConstant)pool.getConstant(nameIndex)).getString();\n-    descriptor = ((PrimitiveConstant)pool.getConstant(descriptorIndex)).getString();\n+    String name = ((PrimitiveConstant)pool.getConstant(nameIndex)).getString();\n+    String descriptor = ((PrimitiveConstant)pool.getConstant(descriptorIndex)).getString();\n \n-    attributes = readAttributes(in, pool);\n-  }\n-\n-  public String getName() {\n-    return name;\n-  }\n+    Map<String, StructGeneralAttribute> attributes = readAttributes(in, pool);\n \n-  public String getDescriptor() {\n-    return descriptor;\n+    return new StructRecordComponent(0, attributes, name, descriptor);\n   }\n \n-  @Override\n-  public String toString() {\n-    return name;\n+  private StructRecordComponent(int flags, Map<String, StructGeneralAttribute> attributes, String name, String descriptor) {\n+    super(flags, attributes, name, descriptor);\n   }\n }"
  },
  {
    "sha": "87f02bebde29769e0ab7ed1e06b15b8f589179f1",
    "filename": "src/org/jetbrains/java/decompiler/struct/attr/StructCodeAttribute.java",
    "status": "added",
    "additions": 43,
    "deletions": 0,
    "changes": 43,
    "blob_url": "https://github.com/FabricMC/intellij-fernflower/blob/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/attr/StructCodeAttribute.java",
    "raw_url": "https://github.com/FabricMC/intellij-fernflower/raw/70506761a4f16ec9a77e4800b1a775a51a78e09d/src/org/jetbrains/java/decompiler/struct/attr/StructCodeAttribute.java",
    "contents_url": "https://api.github.com/repos/FabricMC/intellij-fernflower/contents/src/org/jetbrains/java/decompiler/struct/attr/StructCodeAttribute.java?ref=70506761a4f16ec9a77e4800b1a775a51a78e09d",
    "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.\n+package org.jetbrains.java.decompiler.struct.attr;\n+\n+import org.jetbrains.java.decompiler.struct.StructMember;\n+import org.jetbrains.java.decompiler.struct.consts.ConstantPool;\n+import org.jetbrains.java.decompiler.util.DataInputFullStream;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+/*\n+  u2 max_stack;\n+  u2 max_locals;\n+  u4 code_length;\n+  u1 code[];\n+  u2 exception_table_length;\n+  exception_table[] {\n+     u2 start_pc;\n+     u2 end_pc;\n+     u2 handler_pc;\n+     u2 catch_type;\n+  };\n+  u2 attributes_count;\n+  attribute_info attributes[];\n+*/\n+public class StructCodeAttribute extends StructGeneralAttribute {\n+  public int localVariables = 0;\n+  public int codeLength = 0;\n+  public int codeFullLength = 0;\n+  public Map<String, StructGeneralAttribute> codeAttributes;\n+\n+  @Override\n+  public void initContent(DataInputFullStream data, ConstantPool pool) throws IOException {\n+    data.discard(2);\n+    localVariables = data.readUnsignedShort();\n+    codeLength = data.readInt();\n+    data.discard(codeLength);\n+    int excLength = data.readUnsignedShort();\n+    data.discard(excLength * 8);\n+    codeFullLength = codeLength + excLength * 8 + 2;\n+    codeAttributes = StructMember.readAttributes(data, pool);\n+  }\n+}"
  }
]
