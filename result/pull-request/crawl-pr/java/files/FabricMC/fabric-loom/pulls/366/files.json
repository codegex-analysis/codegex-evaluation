[
  {
    "sha": "5e6514671777eaa99ee7fec7d38e301108956b89",
    "filename": "src/main/java/net/fabricmc/loom/decompilers/fernflower/TinyJavadocProvider.java",
    "status": "modified",
    "additions": 54,
    "deletions": 1,
    "changes": 55,
    "blob_url": "https://github.com/FabricMC/fabric-loom/blob/9d38f487feb2022d7b52458b693eb66f3065f05c/src/main/java/net/fabricmc/loom/decompilers/fernflower/TinyJavadocProvider.java",
    "raw_url": "https://github.com/FabricMC/fabric-loom/raw/9d38f487feb2022d7b52458b693eb66f3065f05c/src/main/java/net/fabricmc/loom/decompilers/fernflower/TinyJavadocProvider.java",
    "contents_url": "https://api.github.com/repos/FabricMC/fabric-loom/contents/src/main/java/net/fabricmc/loom/decompilers/fernflower/TinyJavadocProvider.java?ref=9d38f487feb2022d7b52458b693eb66f3065f05c",
    "patch": "@@ -36,6 +36,8 @@\n import org.jetbrains.java.decompiler.struct.StructClass;\n import org.jetbrains.java.decompiler.struct.StructField;\n import org.jetbrains.java.decompiler.struct.StructMethod;\n+import org.jetbrains.java.decompiler.struct.StructRecordComponent;\n+import org.objectweb.asm.Opcodes;\n \n import net.fabricmc.fernflower.api.IFabricJavadocProvider;\n import net.fabricmc.mapping.tree.ClassDef;\n@@ -73,7 +75,54 @@ public TinyJavadocProvider(File tinyFile) {\n \t@Override\n \tpublic String getClassDoc(StructClass structClass) {\n \t\tClassDef classDef = classes.get(structClass.qualifiedName);\n-\t\treturn classDef != null ? classDef.getComment() : null;\n+\n+\t\tif (classDef == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tif (!isRecord(structClass)) {\n+\t\t\treturn classDef.getComment();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Handle the record component docs here.\n+\t\t *\n+\t\t * Record components are mapped via the field name, thus take the docs from the fields and display them on then class.\n+\t\t */\n+\t\tList<String> parts = new ArrayList<>();\n+\n+\t\tif (classDef.getComment() != null) {\n+\t\t\tparts.add(classDef.getComment());\n+\t\t}\n+\n+\t\tboolean addedParam = false;\n+\n+\t\tfor (StructRecordComponent component : structClass.getRecordComponents()) {\n+\t\t\t// The component will always match the field name and descriptor\n+\t\t\tFieldDef fieldDef = fields.get(new EntryTriple(structClass.qualifiedName, component.getName(), component.getDescriptor()));\n+\n+\t\t\tif (fieldDef == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tString comment = fieldDef.getComment();\n+\n+\t\t\tif (comment != null) {\n+\t\t\t\tif (!addedParam && classDef.getComment() != null) {\n+\t\t\t\t\t//Add a blank line before components when the class has a comment\n+\t\t\t\t\tparts.add(\"\");\n+\t\t\t\t\taddedParam = true;\n+\t\t\t\t}\n+\n+\t\t\t\tparts.add(String.format(\"@param %s %s\", fieldDef.getName(namespace), comment));\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (parts.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn String.join(\"\\n\", parts);\n \t}\n \n \t@Override\n@@ -126,4 +175,8 @@ private static TinyTree readMappings(File input) {\n \t\t\tthrow new RuntimeException(\"Failed to read mappings\", e);\n \t\t}\n \t}\n+\n+\tpublic static boolean isRecord(StructClass structClass) {\n+\t\treturn (structClass.getAccessFlags() & Opcodes.ACC_RECORD) != 0;\n+\t}\n }"
  }
]
