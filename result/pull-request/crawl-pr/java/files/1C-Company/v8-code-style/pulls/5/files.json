[
  {
    "sha": "d6a21f1c33950c56d765a9207e2a0611af5ca296",
    "filename": "CONTRIBUTING.md",
    "status": "added",
    "additions": 268,
    "deletions": 0,
    "changes": 268,
    "blob_url": "https://github.com/1C-Company/v8-code-style/blob/cbc1309cfaf4548950d952c26d571afbf7d8863d/CONTRIBUTING.md",
    "raw_url": "https://github.com/1C-Company/v8-code-style/raw/cbc1309cfaf4548950d952c26d571afbf7d8863d/CONTRIBUTING.md",
    "contents_url": "https://api.github.com/repos/1C-Company/v8-code-style/contents/CONTRIBUTING.md?ref=cbc1309cfaf4548950d952c26d571afbf7d8863d",
    "patch": "@@ -0,0 +1,268 @@\n+# Участие в проекте 1С:Стандарты разработки V8\n+\n+Вначале, хотим поблагодарить Вас за желание участвовать в проекте!\n+\n+Далее описаны советы, как сделать свое участие наиболее эффективным для проекта и для себя. \n+Будьте благоразумны, если что-либо здесь не описано.\n+\n+## У меня есть вопрос\n+\n+1. Для начала убедитесь, что ответа нет в самой 1C:EDT.\n+2. Поищите информация в документации проекта\n+\n+**Вопрос есть, но ответа не нашел?** Создай `issue`  \n+\n+## Что я должен знать прежде чем начать\n+\n+Изучите текущую функциональность проекта, цели проекта, где находится граница возможностей плагина и 1C:EDT.\n+\n+Вопросы, которые не относятся к разаботке приложений в 1C:EDT по стандартам 1С, следует задавать в профильных сообществах.\n+\n+## Сообщить об ошибке\n+\n+Печально, что ошибка существует, но мы благодарны, что вы о ней нам сообщите!\n+\n+#### Прежде чем зарегистрировать ошибку\n+\n+* Проверьте [Wiki](https://github.com/1C-Company/v8-code-style/wiki) на наличие описания, что не является ошибкой\n+* Проверьте раздел [Issues](https://github.com/1C-Company/v8-code-style/issues), чтобы не создавать дубликатов\n+\n+#### Как сообщить об ошибке эффективно\n+\n+Следуйте простым правилам:\n+\n+1. Задайте понятный заголовок `issue`, лаконично и исчерпывающе определяющий проблему\n+    * постарайтесь не допускать двойного смысла, сленга из других областей и т.д. \n+    * Не используйте \"метки\" в заголовке - для этого используются метки (labels) на гитхабе\n+2. Опишите сценарий воспроизведения ошибки.\n+    * скриншоты очень сильно помогают, но не заменяют сценарий\n+    * добавьте логи ЖР, из лог-файлов (убедитесь, что они не содержат приватной информации)\n+3. Опишите, что есть ошибка по вашему мнению и почему\n+4. Опишите ожидаемое поведение\n+\n+\n+## Предложите улучшение функциональности\n+\n+1. Задайте понятный заголовок `issue`, лаконично и исчерпывающе определяющий новую функциональность\n+2. Опишите суть улучшений и обсудите в issue варианты реализации.\n+3. Убедитесь совместно с авторами проекта, что ваше предложение не противоречит идеологии Стандартов 1С и 1C:EDT. При этом авторы проекта всегда рады обсуждению новых идей, всегда на стороне участников, предлагающих улучшения, но при этом постараются максимально разъяснить случаи отказа в принятии идеи/реквеста, если таковые возникнут.\n+4. Реализуйте Ваше улучшение функциональности проекта в отдельном форке и предложите его через [Pull/merge request](#Pull-Requests-Merge-Requests)\n+\n+## Доработка кода\n+\n+### Написание проверок\n+\n+См. [Соглашение при создании проверок](Check_Convention.md)\n+\n+### Исправление ошибок\n+\n+* Создайте `issue` в проекте с описанием ошибки. Убедитесь, что владельцы проекта так же считают текущее поведение ошибочным.\n+* Создайте ветку в своем **форке** с именем `bugfix/issue-<Номер issue>-доп-название`\n+* Создайте **pull-request** из своей ветки в ветку **`master`** проекта v8-code-style\n+* Убедитесь, что модификация кода действительно исправляет ошибку, описанную в issue, и не привносит новую функциональность - новую функциональность следует делать отдельным issue и pull-request'ом.\n+* Следуйте общим правилам [Pull/merge request](#Pull-Requests-Merge-Requests)\n+\n+### Pull Requests (Merge Requests)\n+\n+* Создайте `issue` в проекте с описанием новой функциональности, желательно перед началом работы, чтобы исключить параллельную работу разных людей над одной задачей\n+* Создайте ветку в своем **форке** с именем `feature/issue-<Номер issue>-доп-название`\n+* Внесите изменения в конфигурацию или расширение\n+* Создайте **pull-request** из своей ветки в ветку **`master`** проекта v8-code-style\n+* Укажите ссылку на issue, которую закрывает данный pull-request\n+* Установите в своем PR флажок \"allow edits from maintainers\"\n+\n+### Правила оформления коммитов\n+\n+Правила необходимы для предотвращения написания бессмысленных заголовков, мешающих пониманию ситуации на проекте. Хорошие оформленные коммиты помогают значительно облегчить процесс выяснения причин внесенных в код изменений, анализируя историю коммитов. Так же это необходимо для стилистического единообразия сообщений коммитов в репозитории.\n+\n+#### Тексты сообщений коммитов\n+\n+При написании сообщения коммита следует использовать формат:\n+\n+```\n+#<НОМЕР ЗАДАЧИ> Короткое сообщение что сделано\n+\n+Длинное сообщение что сделано\n+```\n+\n+1. Начинаем с номера задачи (например, #12311). Идентификатор необходим для интеграции с задачами GitHub\n+2. В качестве разделителя между номером задачи и заголовком коммита используем пробел.\n+3. Далее идет заголовок коммита:\n+   - Пишем на русском языке.\n+   - Заголовок с большой буквы.\n+   - В конце заголовка точку не ставим.\n+   - Желательно использовать настоящее время, а не прошедшее (например, \"Исправление ошибок запуска при указанной web ИБ\").\n+   - Рекомендуем писать не слишком длинный заголовок, так как его отображение во многих интерфейсах выполнено в одну строку без переносов, так что, он может не влезть. Подробные детали пишем отдельным параграфом в описании коммита.\n+4. Описание коммита (опционально).\n+   - Отделяем от заголовка пустой строкой.\n+   - Пишем полноценные предложения (начинаем с большой буквы, заканчиваем точкой)\n+   - Хорошей практикой является ограничение длины строк в сообщении ≈72 символами, с добавлением переносов, если не влезает. Многие UI инструменты для GIT (в том числе EGit) не делают переносы текста описания, если он не влез.\n+\n+Контент сообщения коммита:\n+\n+В сообщении коммита пишем \"что\" и \"почему\" сделано, но избегаем деталей \"как\" сделано. Назначение комментария - дать коллегам понять, что происходит в проекте.\n+\n+1. Заголовок должен быть ёмкий и информативный.\n+2. Заголовок должен быть написан официальным языком, без разговорных оборотов.\n+3. Чтобы определить достаточность детализации заголовка коммита, попробуйте ответить на вопрос, не заглядывая в код:\n+   - `[Bug]` Какая конкретно проблема здесь исправлена?\n+   - `[Feature]` Какая функциональность здесь добавлена?\n+   - `[Refactoring]` В каких компонентах/классах произведен рефакторинг?\n+   - `[Tests]` Что они тестируют?\n+   - `[Baseline]` В каком компоненте/плагине/пакете подняли версию/версии?\n+   - `[Документация]` В каком компоненте добавлена документация?\n+   - `[Исправление замечаний]` Какие именно проблемы вы исправили?\n+4. Зачем писать сообщение коммита?\n+   - Когда сделанные изменения неочевидны коллегам, то, помимо комментария в самом коде, не будет лишним описать детальнее, зачем эти изменения были сделаны или, почему сделаны именно так, а не иначе.\n+   - При исправлении сложных багов можно воспользоваться методологией [Root_cause_analysis](https://en.wikipedia.org/wiki/Root_cause_analysis), и указать причину ошибочного поведения, а так же, каким образом это исправили. Человек (или даже вы сами), который через пару лет наткнется на неочевидное изменение, скажет вам спасибо.\n+\n+#### Количество коммитов\n+\n+Стоит ли делать один коммит на фичу - зависит от фичи. Коммит - логически завершенное изменение, а сложная фича может содержать много таких изменений, слияние которых в один коммит, приводит к потере информации о деталях ее выполнения. Это касается не только фич.\n+\n+Squash'ить коммиты стоит, если были сделаны лишнее изменения, которые в следующих коммитах отменили. Так же, стоит избегать коммитов вида \"Поднятие версий\", которые не являются самостоятельными (вызваны другими изменениями, без них билд проекта не будет выполнен).\n+   \n+### Лицензия\n+\n+Лицензирование расширений, размещенных в данном проекте, осуществляется на условиях свободной (открытой) лицензии Eclipse Public License - v 2.0 (полный текст лицензии - https://www.eclipse.org/legal/epl-2.0/)\n+\n+Это означает, что:\n+- Вы можете  свободно и бесплатно заимствовать код  и помещать  его в свои проекты, учитывая  однако, что  такой  код не становится вашей интеллектуальной собственностью, Вы лишь  получаете  неисключительные права его использования с учетом рамок и ограничений,  описанных  в EPL 2.0 \n+- Внося изменения в расширение, модифицируя и дорабатывая его, а также объединяя файлы расширения с иными материалами, не относящимися к расширению (далее по тексту как «результаты работ»), Вы также обязаны публиковать это  обновленный код на условиях EPL 2.0, т.е. автоматически предоставляете любым третьим лицам, включая ООО «1С-Софт» и иных контрибьюторов, безвозмездное право использования результатов Ваших работ на территории стран всего мира на условиях открытой лицензии EPL 2.0. \n+\n+Загружая свои разработки, доработки и исправления к программам  других авторов Вы также подтверждаете, что:\n+- являетесь единственным автором и обладателем имущественного права на результаты работ; в случае, если обладателем имущественного права на результаты работ является Ваш работодатель, Вы гарантируете наличие его согласия на публикацию кода на условиях открытой лицензии EPL 2.0;\n+- Вы снабдили  результаты Ваших работ всеми необходимыми уведомлениями,  свидетельствующими о том, что они подчиняются открытой лицензии EPL 2.0;\n+- Результаты Ваших работ доступны в виде исходного кода, или Вы обязуетесь сообщить, каким образом третьи лица без существенных затрат могут получить результаты Ваших работ в виде исходного кода; \n+- Bсе имеющиеся ранее уведомления других авторов (license notices) не были Вами удалены или изменены, а указанные Вами уведомления отражают достоверную информацию о Вас как правообладателе Вашего оригинального кода (включая ФИО или наименование организации-работодателя)\n+\n+\n+Пояснения выше приведены исключительно для удобства восприятия основных положений лицензии EPL 2.0. и не заменяет содержание понятий, приведенных по тексту лицензионного соглашения. Для более детального понимания Ваших прав и обязанностей рекомендуем ознакомиться с полным текстом открытой лицензии EPL 2.0.\n+\n+Все файлы проекта, подлежащие лицензированию, должны иметь заголовок.\n+\n+```java\n+/*******************************************************************************\n+ * Copyright (C) 2021, 1C-Soft LLC and others.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *     1C-Soft LLC - initial API and implementation\n+ *******************************************************************************/\n+```\n+\n+##### Использование Eclipse Releng Tools для установки лицензии\n+\n+Установите дополнительный инструмент `Eclipse Releng Tools` из репозитория для соответствующей версии Eclipse JDK, например: [The Eclipse Project Updates - http://download.eclipse.org/eclipse/updates/4.16](http://download.eclipse.org/eclipse/updates/4.16)\n+\n+Добавьте в настройки согласно инструкции:\n+\n+https://wiki.eclipse.org/Development_Resources/How_to_Use_Eclipse_Copyright_Tool\n+\n+текст копирайта:\n+\n+```\n+Copyright (C) ${date}, 1C-Soft LLC and others.\n+\n+This program and the accompanying materials are made\n+available under the terms of the Eclipse Public License 2.0\n+which is available at https://www.eclipse.org/legal/epl-2.0/\n+\n+SPDX-License-Identifier: EPL-2.0\n+\n+Contributors:\n+    1C-Soft LLC - initial API and implementation\n+```\n+\n+Если вы не являетесь сотрудником фирмы 1С - допишите актуальную информацию в секцию `Contributors:`\n+\n+Для всех новых или измененных файлов - выполняйте обновление копирайта: ПКМ по файлу - \"Fix Copyrights\".\n+\n+\n+### Язык проекта\n+\n+Исходный код должен быть написан на Английском языке. Английский язык - является языком по умолчанию. \n+Не допускается использование транслита или иных не английских слов и терминов. \n+В случае, если вы затрудняетесь в выборе подходящего термина на английском - обратитесь за помощью в issue по вашей функциональности к владельцам проекта - мы всегда поможем!\n+\n+Язык ведения проекта (issue, аудит и т.д.) - Русский, т.к. ориентация на русское сообщество программистов. \n+Поддержка разработчиков на других языка в будущем может быть решена дополнительно.\n+\n+Все интерфейсные тексты, которые видит пользователь, должны быть написаны на английском яызке и локализированы - вынесены в отдельные ресурсные файлы `*.properties`. \n+\n+Кодировка файлов  `*.properties` - UTF-8.\n+\n+Все локализируемые ресурсные файлы должны быть переведены на дополнительный русский язык.\n+\n+Например:\n+\n+- `messages.properties` - основной интерфейс, должен содержать английский интерфейс\n+- `messages_ru.properties` - дополнительный интерфейс на русском языке\n+\n+В проекте используется система локализации **Eclipse NLS**:\n+\n+- Необходимо создавать final-класс наследник `org.eclipse.osgi.util.NLS`\n+- В классе указывается консанта `BUNDLE_NAME` с полным квалификтором файла `messages` в котором хранятся локализованные сообщения.\n+- Создаются публичные константы, которые являются ключами в ресурсных файлах\n+\n+```java\n+final class Messages\n+    extends NLS\n+{\n+    private static final String BUNDLE_NAME = \"com.e1c.v8codestyle.md.check.messages\"; //$NON-NLS-1$\n+    public static String CommonModuleNameClient_description;\n+    public static String CommonModuleNameClient_message;\n+    static\n+    {\n+        // initialize resource bundle\n+        NLS.initializeMessages(BUNDLE_NAME, Messages.class);\n+    }\n+\n+    private Messages()\n+    {\n+    }\n+}\n+```\n+\n+Для большего удобства используйте помощник Eclipse Externalize Strings Wizard, который помогает переносить интерфейсные строки из кода в ресурсные файлы, с автоматическим созданием файла констант NLS.\n+\n+Для редактирования ресурсных файлов следует использовать плагин из Маркет-плайса Eclipse: [ResourceBundle Editor](https://marketplace.eclipse.org/node/2628188) или аналогичны, позволяющий синхронно редактировать интерфейсы на нескольких языках, корректно учитывающий кодировку UTF-8.\n+\n+### Code Style\n+\n+Необходимо использовать `1C:EDT Code style` из поставки JDT для разработки плагинов 1C:EDT из программы установки и запуска 1C:EDT Start.\n+\n+\n+### Документация не опциональна\n+\n+При добавлении новой функциональности или изменении существующей - необходимо актуализировать [документацию](/docs).\n+\n+### Тесты не опциональны\n+\n+Для каждой функциональности необходимо писать JUnit 4 тесты.\n+\n+Тесты должны включать в себя все варианты правильного и неправильного поведения системы, начальных условий.\n+\n+Не следует тестировать поведение 1C:EDT, но только лишь поведение кода текущего проекта.\n+\n+### Версионирование проекта\n+\n+В проекте используется семантическое версионирование [https://semver.org/lang/ru/](https://semver.org/lang/ru/)\n+\n+Текущая версия проекта \"0\" (еще нет \"мажорного релиза\"), это позволяет нам делать любые несовместимые изменения в каждой новой минорной версии.\n+Это так же связано с тем, что многие части API в таргет-платформе 1C:EDT еще не стабилизированы и часто меняются.\n+\n+При этом, каждая минорная версия до первой мажорной - является полноценным релизом, готовым к использованию в проде.\n+\n+\n+Дополнительно следует изучить про версионирование в  Eclipse:\n+\n+\n+[https://wiki.eclipse.org/Version_Numbering](https://wiki.eclipse.org/Version_Numbering)\n+\n+[https://wiki.eclipse.org/Platform-releng/Incrementing_Version_Numbers](https://wiki.eclipse.org/Platform-releng/Incrementing_Version_Numbers)"
  },
  {
    "sha": "88999a9cd107a9c274bad6619e85a43f351b33ed",
    "filename": "Check_Convention.md",
    "status": "added",
    "additions": 220,
    "deletions": 0,
    "changes": 220,
    "blob_url": "https://github.com/1C-Company/v8-code-style/blob/cbc1309cfaf4548950d952c26d571afbf7d8863d/Check_Convention.md",
    "raw_url": "https://github.com/1C-Company/v8-code-style/raw/cbc1309cfaf4548950d952c26d571afbf7d8863d/Check_Convention.md",
    "contents_url": "https://api.github.com/repos/1C-Company/v8-code-style/contents/Check_Convention.md?ref=cbc1309cfaf4548950d952c26d571afbf7d8863d",
    "patch": "@@ -0,0 +1,220 @@\n+# Check convention - Соглашения проверок\n+\n+\n+## Регистрация проверки\n+\n+### Категория проверки\n+\n+Проект 1С:Стандарты разработки V8 поставляет категории в разрезе типов объектов в метаданных.\n+Следует указывать категорию для каждой проверки из соответствующего бандла, где размещен класс проверки.\n+\n+### Код проверки\n+\n+1. cebab-case (кебаб-кейс) - с маленькой буквы, без пробелов, использовать тире между словами. Не следует использовать `CamelCase` т.к. он менее читабельный.\n+2. Префикс типа объекта (md, form, right, ql, dcs и т.д) - код должен содеражть префикс типа объекта или имя уникального класса объекта (`common-module`, `catalog`, `role` и т.д.) что бы не допустить неоднозначности толкования к чему применяется проверка\n+3. Префикс вендора (`v8codestyle`) в коде проверки не используется\n+4. Константа с кодом проверки должна быть приватной\n+\n+#### Код проверки должен отражать смысл проверяемой проблемы.\n+\n+Следует отражать в коде проверки находимую проблему или группу проблем (если проверка выполняет множество однотипных проверок).\n+\n+Код проверки не должен состоять лишь из имен найденных объектов. \n+\n+НЕПРАВИЛЬНО:\n+\n+Здесь ключ проверки отражает только имена объектов которые проверяет:\n+```\n+module-method-check\n+function-type-check\n+```\n+\n+\n+Не следует в коде проверки отражать процесс поиска проблемной ситуации.\n+\n+НЕПРАВИЛЬНО:\n+\n+```\n+check-method-usage\n+```\n+\n+ПРАВИЛЬНО:\n+\n+```\n+method-never-used\n+```\n+\n+#### Код проверки должен корректно читаться вместе с аннотацией\n+\n+Это чуть более актуально для проверок по модулю - т.к. это будет везде визуально читаться.\n+\n+Для других типов проверок (по метаданным) аналогичное правило подходит, хоть и не будет постоянно отображаться везде в интерфейсе (при открытии доп.формы).\n+\n+НЕПРАВИЛЬНО:\n+\n+```bsl\n+//@skip-check check-method-never-used\n+```\n+\n+ПРАВИЛЬНО\n+\n+```bsl\n+//@skip-check method-never-used\n+```\n+\n+#### Слова-паразиты\n+\n+Следует избегать использования \"слов-паразитов\", которые не добавляют никакого смысла в код проверки, например слова: check, error, warning, артикли a, the, to, is, are и т.д. problem, valid\n+\n+НЕПРАВИЛЬНО\n+\n+```\n+check-method-is-empty\n+to-find-my-awesome-problem\n+```\n+\n+ПРАВИЛЬНО:\n+\n+```\n+method-empty\n+awesome-problem\n+```\n+\n+#### Разделение по типам объектов метаданных\n+\n+Из кода проверки желательно сразу понимать к какому типу объектов она имеет отношение. Обычно это следует от типа ТОП-объектов (md, form, module/bsl, dcs, ql, moxel).  Если проверка диагностирует проблему в подчиненном объекте имя которого уникально - можно не указывать префикс топ-объекта.\n+\n+НЕПРАВИЛЬНО:\n+\n+```\n+attribute-type-empty\n+parameter-name-too-short\n+```\n+\n+ПРАВИЛЬНО:\n+\n+```\n+form-attribute-type-empty\n+md-attribute-type-empty\n+method-parameter-name-too-short\n+form-parameter-name-too-short\n+module-standard-regions\n+function-has-no-return-type\n+```\n+\n+### Наименование проверки\n+\n+- Что проверяем, какую ошибку находит\n+- Существительное, в именительном падеже\n+- Наименование должно быть локализовано через NLS класс\n+\n+\n+### Детальное описание\n+\n+1. Следует указывать описание при регистрации проверки в классе.\n+2. Детальное описание должно быть локализовано через NLS класс\n+2. Формируется описание в виде `check.descriptions/check-id.md` и `check.descriptions/ru/check-id.md` с детальным описанием\n+3. Ссылку на стандарт, по которому выполняется проверка, следует указывать в секции `## См.` (или `## See`) в файлах описаний `check-id.md`\n+4. Следует описывать все возможные варианты `НЕПРАВИЛЬНО` и `ПРАВИЛЬНО` которые находит проверка. Желательно использовать примеры из тестов.\n+\n+### Тип (issueType)\n+\n+Тип найденной диагностики\n+\n+- `ERROR` - Ошибка в приложении\n+- `WARNING` - Предупреждение о проблеме в приложении\n+- `SECURITY` - Уязвимость в приложении\n+- `PERFORMANCE` - Проблема производительности приложения\n+- `PORTABILITY` - Проблема универсальности метаданных и кода приложения.\n+- `LIBRARY_DEVELOPMENT_AND_USAGE` - Проблема внедрения библиотеки или нарушение принципов библиотечной разработки.\n+- `CODE_STYLE` - Соглашения при написании кода, некачественный код\n+- `UI_STYLE` - Проблема проектирования UI\n+- `SPELLING` - Опечатка в тексте, коде, в именах метаданных\n+\n+### Критичность (severity)\n+\n+Необходимо установить критичность найденной ошибки по умолчанию.\n+Критичность необходимо устанавливать адекватную проблеме уровню проблемы в приложении.\n+\n+- `BLOCKER` - ошибку необходимо исправлять немедленно\n+- `CRITICAL` - Критичная проблема, необходимо исправлять в первую очередь\n+- `MAJOR` - Обычная проблема, исправлять следут в обычном порядке\n+- `MINOR` - Незначительная проблема\n+- `TRIVIAL` - Тривиальная проблема\n+\n+### Сложность (complexity)\n+\n+- `NORMAL` - Сложность алгоритма поиска ошибочной ситуации низкая, не выполянется обращение к объектам из других ресурсов.\n+- `COMPLEX` - Большое количество вычислений, обращение к объектам из других ресурсов\n+\n+\n+### Параметры\n+\n+Принципы создания параметров:\n+- Возможность внести исключения в правило поиска проблемных мест\n+- Нет смысла в параметрах если проверяется единственный объект и какое-либо исключение равно отключению проверки\n+- Используйте паттерны в параметрах для поиска исключений\n+- Любые константные значения (текстовые, числовые, с большой вариабельностью, Булево), которое имеют отношение к логике проверки, следует задавать через параметры\n+\n+Типовые примеры:\n+- Исключение по имени метаданного\n+- Длина, количество символов и т.д. - числовые значения в проверке обычно являются кандидатами для вынесения в параметры\n+\n+Соглашения при создании параметров:\n+1. имена параметров должны быть понятны в контексте проверки\n+2. имена параметров пишутся в `camelCase`, с маленькой буквы\n+3. Константа с именем параметра должна быть публичной\n+4. Заголовок параметра должен быть локализован через NLS класс\n+\n+\n+### Компоненты, расширяющие функциональность\n+\n+- Проверки, проверяющие 1 объект на наличие ошибок, в общем случае следует наследовать от `com._1c.g5.v8.dt.check.components.BasicCheck` или аналогичных для специфичных областей `com.e1c.g5.v8.dt.bsl.check.DocumentationCommentBasicDelegateCheck`, `com.e1c.g5.v8.dt.ql.check.QlBasicDelegateCheck`\n+- При наличии нескольих повторяющихся фрагментов кода c параметризацией и фильтрацией объектов - желательно создавать компонент `com._1c.g5.v8.dt.check.components.IBasicCheckExtension` для переиспользования.\n+- При необходимости использовать существующие компоненты `com._1c.g5.v8.dt.check.components.ModuleTopObjectNameFilterExtension`, `com._1c.g5.v8.dt.check.components.TopObjectFilterExtension`\n+\n+\n+\n+## Логика проверки / код проверки\n+\n+- В общем случае, при регистрации проверки, следует выбирать тот объект, в котором будет найдена ошибка, от этого объекта следует вычислять/находить другие зависимые, влияющие объекты.\n+- Код поиска ошибочной ситуации следует строить максимально оптимальным способом.\n+- Не следует ухудшать читаемость кода, за исключением производительности.\n+\n+### Текст ошибки\n+\n+1. В чем ошибка\n+2. Формат текста: существительное, именительный падеж \n+3. Указание значений параметров в сообщении\n+4. Сообщение должно быть локализовано через NLS класс\n+\n+Примеры:\n+1. Переменная не была инициализирована\n+2. Конфигурация содержит некоректный режим блокировки данных\n+3. Метод пустой\n+4. Метод не используется\n+5. Длина имени объекта метаданного должна быть меньше чем `80`\n+\n+### Как проверять\n+\n+1. Одна проверка должна находить одно проблемное место в одном типе объектов\n+2. Учитывать параметры, а не хардкод конкретных значений\n+3. Учитывать исключения, место проверки исключения следует выбирать из оптимальности алгоритма\n+\n+При регистрации проверки следует указывать все фичи, от которых зависит логика проверки - это означает, что при изменении любого из второстепенных свойств объекта будет выполнена перевалидация по текущей проверке.\n+\n+## Тестирование проверок\n+\n+1. Для каждого варианта ошибочного состояния необходим тест. Если тестовые ситуации слишком разные, желательно написать различные тесты\n+2. Для корректного состояния необходимо добавить тест, в котором проверка не должна находить проблему.\n+\n+Каждый корректный и ошибочный вариант должны быть добавлены в разделы \"ПРАВИЛЬНО\" и \"НЕПРАВИЛЬНО\" описания проверки\n+\n+\n+## Проверка не по стандарту\n+\n+Если какая-либо проверка напрямую не описана в одном из стандартов, но при этом является полезной - такую проверку можно размещать в этом проекте.\n+\n+Проверку следует регистрировать по умолчанию выключенной - таким образом каждый проект 1С:Предприятия может сам решить какие дополнительные проверки активировать.\n+\n+Регистрация проверки не по стандарту, включенной по умолчанию, следует явно описывать в задаче (issue) в проекте, если контрибьютор считает, что ее необходимо активировать всегда."
  }
]
