[
  {
    "sha": "c18d6b6012582ab3dd5d5f6a677d25558c5649c0",
    "filename": "src/plugins/WebOfTrust/IdentityFileDiskQueue.java",
    "status": "modified",
    "additions": 15,
    "deletions": 3,
    "changes": 18,
    "blob_url": "https://github.com/ArneBab/plugin-WoT-staging/blob/2f41397cc2233afd1073022246bc584ceec34d5a/src/plugins/WebOfTrust/IdentityFileDiskQueue.java",
    "raw_url": "https://github.com/ArneBab/plugin-WoT-staging/raw/2f41397cc2233afd1073022246bc584ceec34d5a/src/plugins/WebOfTrust/IdentityFileDiskQueue.java",
    "contents_url": "https://api.github.com/repos/ArneBab/plugin-WoT-staging/contents/src/plugins/WebOfTrust/IdentityFileDiskQueue.java?ref=2f41397cc2233afd1073022246bc584ceec34d5a",
    "patch": "@@ -28,8 +28,11 @@\n  * marked as finished by {@link IdentityFileStreamWrapper#close()} the file will be lost.  \n  * Thus users of this implementation must be safe against complete loss of the queue across\n  * restarts.  \n- * This is also demanded by the JavaDoc of the interface {@link IdentityFileQueue} for sophisticated\n- * reasons.\n+ * This is also demanded by the JavaDoc of the interface {@link IdentityFileQueue} for other, more\n+ * sophisticated reasons which are NOT merely an implementation detail, it thus **must stay as\n+ * is**!  \n+ * TODO: Usability: Write a text file to the root dir of the queue which tells the user that it\n+ * is safe to delete the queue and it thus does not have to be included in backups.\n  * \n  * Deduplicating queue: Only the latest edition of each file is returned; see\n  * {@link IdentityFileQueue} for details.<br>\n@@ -376,6 +379,11 @@ private static String getEncodedIdentityID(FreenetURI identityURI) {\n \t}\n \n \t@Override public synchronized IdentityFileStreamWrapper poll() {\n+\t\t// Concurrent processing of files returned by poll() is not allowed, as specified in the\n+\t\t// parent interface. So mProcessingFiles should be 0 here unless the user violated that, or\n+\t\t// forgot to call close() upon a previously returned IdentityFileStreamWrapper.\n+\t\tassert(mStatistics.mProcessingFiles == 0);\n+\t\t\n \t\tFile[] queue = mQueueDir.listFiles();\n \t\tassert(queue.length == mStatistics.mQueuedFiles);\n \t\t\n@@ -517,7 +525,11 @@ public void close() throws IOException {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\t\n+\n+\t\t@Override protected void finalize() {\n+\t\t\tassert(mClosedAlready) : \"Error: close() was not called!\";\n+\t\t}\n+\n \t\t/** Must be called while synchronized(IdentityFileDiskQueue.this) */\n \t\tprivate void deleteFile() {\n \t\t\tif(logMINOR)"
  },
  {
    "sha": "d87a16df96e19e4b156f9f1770a12825650bde23",
    "filename": "src/plugins/WebOfTrust/network/input/EditionHint.java",
    "status": "modified",
    "additions": 60,
    "deletions": 4,
    "changes": 64,
    "blob_url": "https://github.com/ArneBab/plugin-WoT-staging/blob/2f41397cc2233afd1073022246bc584ceec34d5a/src/plugins/WebOfTrust/network/input/EditionHint.java",
    "raw_url": "https://github.com/ArneBab/plugin-WoT-staging/raw/2f41397cc2233afd1073022246bc584ceec34d5a/src/plugins/WebOfTrust/network/input/EditionHint.java",
    "contents_url": "https://api.github.com/repos/ArneBab/plugin-WoT-staging/contents/src/plugins/WebOfTrust/network/input/EditionHint.java?ref=2f41397cc2233afd1073022246bc584ceec34d5a",
    "patch": "@@ -136,13 +136,17 @@\n \t * valuable due to the USK subscriptions of {@link IdentityDownloaderFast} - which is why\n \t * we sort by capacity first as aforementioned.\n \t * \n-\t * Furthermore, sorting by capacity is critical to ensure the most \"stable\" behavior of WoT\n-\t * - where \"stable\" means that the results of {@link Score} computation should not depend on\n+\t * Furthermore, sorting by capacity is critical to ensure the \"stable\" behavior of {@link Score}\n+\t * computation - where \"stable\" means that the results of Score computation should not depend on\n \t * order of download:\n \t * The higher the capacity of an Identity, the more voting power it has in {@link Score}\n \t * computation. As identities with higher capacity can give higher capacity = voting power to\n \t * their trustees, by preferring to download hints with higher capacity, we prefer to download\n-\t * the identities with the highest potential voting power first.\n+\t * the identities with the highest potential voting power first.  \n+\t * See the comments inside of {@link WebOfTrust#shouldFetchIdentity(Identity)} for a detailed\n+\t * explanation of the concept of stability.\n+\t * FIXME: I'm hopefully capable of explaining the issue with stability in a more easy to\n+\t * understand fashion. Do so!\n \t * \n \t * The next fallback sorting key after this one is {@link #mSourceScore}.\n \t * It is also ensured that fallback will actually happen:\n@@ -197,6 +201,7 @@\n \t * (The most efficient storage for this would be byte[], but IIRC db4o does not handle that as\n \t * well as String.)\n \t * \n+\t * @see #computePriority(WebOfTrust, Date, byte, int, String, long)\n \t * @see #compareTo_ReferenceImplementation(EditionHint)\n \t * @see #compareTo(EditionHint) */\n \t@IndexedField\n@@ -309,9 +314,17 @@ public FreenetURI getURI() {\n \t\treturn mTargetIdentity.getRequestURI().setSuggestedEdition(mEdition).sskForUSK();\n \t}\n \n+\t/** @see #mPriority */\n \tprivate static String computePriority(WebOfTrust wot, Date roundedDate, byte capacity,\n \t\t\tint roundedScore, String targetID, long edition) {\n \t\t\n+\t\t// For detailed explanations of the reasons behind the order in which we put things into the\n+\t\t// resulting priority, see the JavaDoc of the member variables of class EditionHint.\n+\t\t// TODO: Code quality: Rename our parameters to match their naming more closely.\n+\t\t// TODO: Code quality: Perhaps the JavaDoc should be copied/moved to\n+\t\t// compareTo_ReferenceImplementation(), and we should point to that function for\n+\t\t// documentation instead. Also see the related TODO there.\n+\t\t\n \t\tassert(roundedDate.equals(roundToNearestDay(roundedDate)));\n \t\tassert(capacity >= MIN_CAPACITY && capacity <= 100);\n \t\tassert(roundedScore == -1 || roundedScore == 1);\n@@ -326,6 +339,30 @@ private static String computePriority(WebOfTrust wot, Date roundedDate, byte cap\n \t\t// bruteforce public-key generation to get an ID of \"aaaa...\" in order to maliciously get\n \t\t// a higher priority.\n \t\t// To prevent that, we encrypt the ID with a local, non-public random pad.\n+\t\t// IMHO we don't need a good encryption here and thus don't use one because:\n+\t\t// - the only thing which an outsider can use to guess the key is the order in which we\n+\t\t//   download Identitys. But Freenet is supposed to make our downloading anonymous so it's\n+\t\t//   already difficult enough to observe what we download in the first place.\n+\t\t// - the only incentive for cracking the key is that it would allow an attacker to specially\n+\t\t//   craft their Identity ID so their Identity would be downloaded more quickly by a single\n+\t\t//   target Identity. But that is a rather weak incentive because it only affects a single\n+\t\t//   target *and* that target would already download the malicious Identity anyway if it is\n+\t\t//   eligible to have its EditionHints queued for download, and that eligibility is required\n+\t\t//   for the attack to work. So the attacker really only would get downloaded more quickly,\n+\t\t//   notably the decision of whether to download them at all is not affected.\n+\t\t// - Gaining priority in terms being downloaded more quickly also is useless because it does\n+\t\t//   *not* allow a malicious Identity to block the download of another Identity by\n+\t\t//   distrusting them faster than positive Trusts for them can be downloaded from elsewhere,\n+\t\t//   the mechanism of capacity was specifically designed to prevent such \"which Trust do we\n+\t\t//   download first?\" race conditions. It ensures that the order in which we download\n+\t\t//   Identitys does not affect the result of Score computation, this concept is named\n+\t\t//   \"stability\" in its terms. See the comments inside of WebOfTrust.shouldFetchIdentity()\n+\t\t//   for a detailed explanation of that concept. Also see the JavaDoc of mSourceCapacity for\n+\t\t//   why we must use it as a top sorting key here to ensure the mechanism works.\n+\t\t// NOTICE: The poor encryption here isn't the only such race condition, using a better one\n+\t\t// will *not* void the need for capacity as priority! Instead, the very nature of network\n+\t\t// traffic is that we will download Identitys and thereby Trust values in random order, so\n+\t\t// a mechanism to prevent race conditions must always exist.\n \t\ttargetID = encryptIdentityID(wot, targetID);\n \t\t\n \t\tint length = 8 + 3 + 1 + IdentityID.LENGTH + 19;\n@@ -342,6 +379,11 @@ private static String computePriority(WebOfTrust wot, Date roundedDate, byte cap\n \t\treturn sb.toString();\n \t}\n \n+\t/** WARNING: This is not a real encryption: The random pad it uses is re-used for each input.  \n+\t *  It merely aims to sufficiently randomize the ID to ensure the low security constraints of\n+\t *  {@link #computePriority(WebOfTrust, Date, byte, int, String, long)} are met.  \n+\t *  See the comment inside that function for an explanation.  \n+\t *  TODO: Code quality: Rename to obfuscate*() to make this more apparent. */\n \tstatic String encryptIdentityID(WebOfTrust keyProvider, String id) {\n \t\tbyte[] idBytes;\n \t\ttry {\n@@ -362,10 +404,12 @@ static String encryptIdentityID(WebOfTrust keyProvider, String id) {\n \t\treturn Base64.encode(idBytes);\n \t}\n \n+\t/** @see #encryptIdentityID(WebOfTrust, String) */\n \tstatic String decryptIdentityID(WebOfTrust keyProvider, String id) {\n \t\treturn encryptIdentityID(keyProvider, id);\n \t}\n \n+\t/** @see #mPriority */\n \tprivate String getPriority() {\n \t\t// String is a db4o primitive type so 1 is enough even though it is a reference type\n \t\tcheckedActivate(1);\n@@ -391,10 +435,20 @@ int compareTo_ReferenceImplementation(EditionHint o) {\n \t\tthis.activateFully();\n \t\to.activateFully();\n \t\t\n+\t\t// For detailed explanations of the reasons behind the order in which we compare things, see\n+\t\t// the JavaDoc of the member variables which are being compared.\n+\t\t// TODO: Code quality: Perhaps it should be copied/moved here? Also see the related TODO in\n+\t\t// computePriority().\n+\t\t\n \t\tint dateCompared = mDate.compareTo(o.mDate);\n \t\tif(dateCompared != 0)\n \t\t\treturn dateCompared;\n \t\t\n+\t\t// Compare capacity before the Score because better capacity *must* gain higher download\n+\t\t// priority than the Score to ensure Score computation has the property of being independent\n+\t\t// of the order of downloading Identitys = the order of obtaining Trust values, a concept\n+\t\t// called \"stability\" in its context.  \n+\t\t// See the JavaDoc of mSourceCapacity for an explanation.\n \t\tint capacityCompared = Byte.compare(mSourceCapacity, o.mSourceCapacity);\n \t\tif(capacityCompared != 0)\n \t\t\treturn capacityCompared;\n@@ -428,9 +482,11 @@ int compareTo_ReferenceImplementation(EditionHint o) {\n \t\t// it will return the result of comparing the ID substrings\n \t\t// - so overall we must do that here in the non-optimized (= non-String based) sorting\n \t\t// function as well.\n-\t\t// Notice: We don't use the actual ID but encrypt it with a persistent, random key to\n+\t\t// Notice: We don't use the actual ID but pseudo-encrypt it with a persistent, random key to\n \t\t// to prevent attackers from maliciously brute forcing pubkey generation to get a hash with\n \t\t// prefix \"aaaa...\" to boost priority of their identity.\n+\t\t// See the large comment in computePriority() for why the poor encryption we use is good\n+\t\t// enough for this usecase.\n \t\t\n \t\t/*\n \t\tif(mTargetIdentity.getID().equals(o.mTargetIdentity.getID()))"
  },
  {
    "sha": "8712904be668f0d86b51db3707a6a17d837f6245",
    "filename": "src/plugins/WebOfTrust/network/input/IdentityDownloaderFast.java",
    "status": "modified",
    "additions": 15,
    "deletions": 8,
    "changes": 23,
    "blob_url": "https://github.com/ArneBab/plugin-WoT-staging/blob/2f41397cc2233afd1073022246bc584ceec34d5a/src/plugins/WebOfTrust/network/input/IdentityDownloaderFast.java",
    "raw_url": "https://github.com/ArneBab/plugin-WoT-staging/raw/2f41397cc2233afd1073022246bc584ceec34d5a/src/plugins/WebOfTrust/network/input/IdentityDownloaderFast.java",
    "contents_url": "https://api.github.com/repos/ArneBab/plugin-WoT-staging/contents/src/plugins/WebOfTrust/network/input/IdentityDownloaderFast.java?ref=2f41397cc2233afd1073022246bc584ceec34d5a",
    "patch": "@@ -1055,13 +1055,13 @@ private void storeAbortFetchCommandWithoutCommit_Checked(Identity identity) {\n \t\t *  We do not store a reference to the {@link Identity} object itself due to our child class\n \t\t *  {@link StopDownloadCommand}:  \n \t\t *  If the download is to be stopped because the {@link Identity} was deleted from the\n-\t\t *  database then that reference would be nulled on the StopDownloadCommand objects in the\n+\t\t *  database then that reference would be nulled on the StopDownloadCommand object in the\n \t\t *  database by db4o before the StopDownloadCommand could be processed.\n \t\t * \n-\t\t *  NOTICE: The child class {@link StartDownloadCommand} **does** include a pointer to the\n+\t\t *  NOTICE: The child class {@link StartDownloadCommand} **does** include a reference to the\n \t\t *  Identity object!  \n \t\t *  Thereby database transactions which query DownloadSchedulerCommand objects from the\n-\t\t *  database must acquire the WebOfTrust lock. */\n+\t\t *  database **must** acquire the WebOfTrust lock! */\n \t\t@IndexedField private final String mIdentityID;\n \n \t\tDownloadSchedulerCommand(WebOfTrust wot, final String identityID) {\n@@ -1618,17 +1618,24 @@ private DownloadSchedulerCommand getQueuedCommand(String identityID) {\n \t\n \t\n \t\tpublic IdentityDownloaderFastStatistics() {\n-\t\t\t// FIXME: Fix and document locking the same way as it was done at\n-\t\t\t// IdentityDownloaderSlowStatistics() by the previous commit.\n-\t\t\tsynchronized(IdentityDownloaderFast.this.mWoT) { // For getQueuedCommands()\n-\t\t\tsynchronized(IdentityDownloaderFast.this) {\n+\t\t\t// WebOfTrust lock: Necessary as we access one of its database tables via\n+\t\t\t//                  getQueuedCommands(): The DownloadSchedulerCommand objects which it\n+\t\t\t//                  returns can contain references to Identity objects.\n+\t\t\t// mLock:           Necessary because we access IdentityDownloaderFast's database table\n+\t\t\t//                  via getQueuedCommands(). Also because we access its member\n+\t\t\t//                  variables.\n+\t\t\t// transactionLock: Necessary because we access the database.\n+\t\t\tsynchronized(IdentityDownloaderFast.this.mWoT) {\n+\t\t\tsynchronized(IdentityDownloaderFast.this.mLock) {\n+\t\t\tsynchronized(Persistent.transactionLock(IdentityDownloaderFast.this.mDB)) {\n \t\t\t\tmRunningDownloads = IdentityDownloaderFast.this\n \t\t\t\t\t.mDownloads.size();\n \t\t\t\tmScheduledForStartingDownloads = IdentityDownloaderFast.this\n \t\t\t\t\t.getQueuedCommands(StartDownloadCommand.class).size();\n \t\t\t\tmScheduledForStoppingDownloads = IdentityDownloaderFast.this\n \t\t\t\t\t.getQueuedCommands(StopDownloadCommand.class).size();\n-\t\t\t}}\n+\t\t\t}}}\n+\t\t\t// AtomicIntegers can be accessed without locking.\n \t\t\tmDownloadedEditions = IdentityDownloaderFast.this\n \t\t\t\t.mDownloadedEditions.get();\n \t\t\tmDownloadProcessingFailures = IdentityDownloaderFast.this"
  },
  {
    "sha": "fa629d1481bd752e5836d1ea515d52c3ae93bbfd",
    "filename": "src/plugins/WebOfTrust/network/input/IdentityDownloaderSlow.java",
    "status": "modified",
    "additions": 25,
    "deletions": 0,
    "changes": 25,
    "blob_url": "https://github.com/ArneBab/plugin-WoT-staging/blob/2f41397cc2233afd1073022246bc584ceec34d5a/src/plugins/WebOfTrust/network/input/IdentityDownloaderSlow.java",
    "raw_url": "https://github.com/ArneBab/plugin-WoT-staging/raw/2f41397cc2233afd1073022246bc584ceec34d5a/src/plugins/WebOfTrust/network/input/IdentityDownloaderSlow.java",
    "contents_url": "https://api.github.com/repos/ArneBab/plugin-WoT-staging/contents/src/plugins/WebOfTrust/network/input/IdentityDownloaderSlow.java?ref=2f41397cc2233afd1073022246bc584ceec34d5a",
    "patch": "@@ -638,6 +638,19 @@ private void stop() {\n \t\t\t\t//   a faster discovery of all remote identities because the more trust lists we\n \t\t\t\t//   download from different identities the higher the chance of discovering new\n \t\t\t\t//   ones in them.\n+\t\t\t\t// - Because we download more diverse trust lists we also might get more fresh hints\n+\t\t\t\t//   from the more various Identitys we download and thus a higher chance of\n+\t\t\t\t//   avoiding usage of obsolete edition hints, i.e. hints for editions which\n+\t\t\t\t//   are lower than the actual most recent edition of an Identity.\n+\t\t\t\t//   (This is a weak conclusion though because EditionHint.getPriority(), which\n+\t\t\t\t//   sorts our download queue, uses the hint's date as the first sorting key so old\n+\t\t\t\t//   hints will be deferred anyway.\n+\t\t\t\t//   Notice that even though currently this is the date when they were gathered from\n+\t\t\t\t//   trust lists and thus is mostly the same for new databases and thereby the\n+\t\t\t\t//   deferring is voided, in a near update remote Identitys will be allowed to\n+\t\t\t\t//   propagate the date on which they observed a hint to ensure usage of old hints\n+\t\t\t\t//   is indeed deferred. Nevertheless lets document this here for future\n+\t\t\t\t//   considerations.)\n \t\t\t\t// (We could avoid having to ignore the Identitys here by instead ensuring that\n \t\t\t\t// no EditionHints are stored which have almost the same priority as others.\n \t\t\t\t// However ignoring them here is a lot easier than changing the storage\n@@ -690,6 +703,10 @@ private void stop() {\n \t\t\t\t\t// Instead the hint will stay in the queue until the IdentityFileProcessor\n \t\t\t\t\t// imports the edition from disk - and it delays that for 1 minute for batch\n \t\t\t\t\t// processing typically, so much re-downloading could happen during that time.\n+\t\t\t\t\t//\n+\t\t\t\t\t// In addition this has the same positive effects as those of ignoring Identitys\n+\t\t\t\t\t// for which there is a running download, they had been explained in a long\n+\t\t\t\t\t// comment some lines above.\n \t\t\t\t\tif(mOutputQueue.containsAnyEditionOf(h.getURI())) {\n \t\t\t\t\t\t// Opportunistically cache `containsAnyEditionOf() == true` via our\n \t\t\t\t\t\t// identitiesToIgnore HashSet so we can skip further EditionHints for the\n@@ -891,6 +908,14 @@ private void download(EditionHint h) throws FetchException {\n \t@Override public void onSuccess(FetchResult result, ClientGetter state) {\n \t\t// Count it before doing anything else to ensure breakage in the processing is apparent by\n \t\t// mismatching numbers on the web interface.\n+\t\t// FIXME: This causes downloads to stall in memory while the IdentityFileProcessor is busy\n+\t\t// holding the lock for a long time. Avoiding that was the whole purpose of implementing\n+\t\t// the IdentityFile(Disk)Queue, its idiotic that I am voiding that whole large piece of work\n+\t\t// for the trivial purpose of counting this number!\n+\t\t// Instead do it after storing the download to the IdentityFileQueue, or use an\n+\t\t// AtomicInteger like IdentityDownloaderFast does in onFound() so we don't need a lock.\n+\t\t// And anyway: The proper approach to counting failures as well is to use the finally{}\n+\t\t// block!\n \t\tsynchronized(mLock) {\n \t\t\t++mSucceededDownloads;\n \t\t}"
  },
  {
    "sha": "4ec952d99a8e55e197c1a90442e2ade5d574f32f",
    "filename": "src/plugins/WebOfTrust/util/StopWatch.java",
    "status": "modified",
    "additions": 11,
    "deletions": 4,
    "changes": 15,
    "blob_url": "https://github.com/ArneBab/plugin-WoT-staging/blob/2f41397cc2233afd1073022246bc584ceec34d5a/src/plugins/WebOfTrust/util/StopWatch.java",
    "raw_url": "https://github.com/ArneBab/plugin-WoT-staging/raw/2f41397cc2233afd1073022246bc584ceec34d5a/src/plugins/WebOfTrust/util/StopWatch.java",
    "contents_url": "https://api.github.com/repos/ArneBab/plugin-WoT-staging/contents/src/plugins/WebOfTrust/util/StopWatch.java?ref=2f41397cc2233afd1073022246bc584ceec34d5a",
    "patch": "@@ -11,10 +11,17 @@\n \n \tprivate final long mStartTime = System.nanoTime();\n \n-\t/**\n-\t * We use Long so we can flag as \"empty\" using a value of null.\n-\t * We do not use long and \"-1\" instead of null because {@link System#nanoTime()} does not\n-\t * specify whether the return value is always positive. */\n+\t/** {@link #mStartTime} plus the runtime of the StopWatch.  \n+\t *  Null if {@link #stop()} was not called yet.\n+\t * \n+\t *  NOTICE: This does NOT accurately represent the absolute point in time at which the\n+\t *  StopWatch was stopped! It merely can be used to accurately compute the delta\n+\t *  `mStopTime - {@link #mStartTime}` as a means to compute the runtime of the StopWatch.  \n+\t *  See {@link #add(StopWatch)} for the reason.\n+\t * \n+\t *  We use Long so we can flag the StopWatch as \"empty\" using a value of null.  \n+\t *  We do not use long and \"-1\" instead of null because {@link System#nanoTime()} does not\n+\t *  specify whether the return value is always positive. */\n \tprivate Long mStopTime = null;\n \n "
  }
]
