[
  {
    "sha": "b293bb80d641cf073cb6ab391052d718815c21e2",
    "filename": "src/main/java/five/Main.java",
    "status": "added",
    "additions": 113,
    "deletions": 0,
    "changes": 113,
    "blob_url": "https://github.com/zbist/algoritmi/blob/b9d77fa2189a0897ec36087079feb0721ea1f5aa/src/main/java/five/Main.java",
    "raw_url": "https://github.com/zbist/algoritmi/raw/b9d77fa2189a0897ec36087079feb0721ea1f5aa/src/main/java/five/Main.java",
    "contents_url": "https://api.github.com/repos/zbist/algoritmi/contents/src/main/java/five/Main.java?ref=b9d77fa2189a0897ec36087079feb0721ea1f5aa",
    "patch": "@@ -0,0 +1,113 @@\n+package five;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+public class Main {\n+    public static void main(String[] args) {\n+        // Пример рекурсии - подсчёт факториалов\n+\n+        // 5.3 немного не понял сути задания, если не лень, подскажите в коментах что нужно сделать\n+\n+        // 5.4\n+        long start = System.nanoTime();\n+        System.out.println(noInfinityRec(10));\n+        System.out.println(System.nanoTime() - start);\n+\n+        start = System.nanoTime();\n+        int factorial = 1;\n+        for (int i = 2; i <= 10; i++){\n+            factorial *= i;\n+        }\n+        System.out.println(factorial);\n+        System.out.println(System.nanoTime() - start);\n+\n+        ///////////// 5.5\n+        Random rnd = new Random();\n+        int[] arr = new int[1_000_000];\n+        int[] arrCopy;\n+        for(int i = 0; i < arr.length; i++){\n+            arr[i] = rnd.nextInt();\n+        }\n+        arr[1] = 21;\n+        Arrays.sort(arr);\n+        start = System.nanoTime();\n+        System.out.println(\"/////////////////////////////\");\n+        System.out.println(searchNoRec(arr,21));\n+        System.out.println(System.nanoTime() - start);\n+\n+        start = System.nanoTime();\n+        System.out.println(searchRec(arr, 0, arr.length - 1, 21));\n+        System.out.println(System.nanoTime() - start);\n+\n+\n+    }\n+\n+    // Бесконечная рекурсия\n+    public static void infinityRec(){\n+        System.out.println(\"Hi\");\n+        infinityRec();\n+    }\n+\n+    // Не бесконечная рекурсия с условием выхода\n+    public static int noInfinityRec(int k){\n+        if (k == 1) return 1;\n+        return k * noInfinityRec(k - 1);\n+    }\n+\n+    public static int searchNoRec(int[] arr, int key){\n+        int topIndex = arr.length - 1, bottomIndex = 0;\n+        while (bottomIndex <= topIndex){\n+            int middleIndex = (bottomIndex + topIndex) / 2;\n+            if (key < arr[middleIndex]) topIndex = middleIndex - 1;\n+            else if (key > arr[middleIndex]) bottomIndex = middleIndex + 1;\n+            else {\n+                return middleIndex;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public static int searchRec(int[] arr, int bottomIndex, int topIndex, int key){\n+        if (bottomIndex <= topIndex) {\n+            int middleIndex = (topIndex + bottomIndex) / 2;\n+            if (arr[middleIndex] == key) return middleIndex;\n+            if (key < arr[middleIndex]) return searchRec(arr, bottomIndex, middleIndex - 1, key);\n+            if (key > arr[middleIndex]) return searchRec(arr, middleIndex + 1, topIndex, key);\n+        }\n+        return -1;\n+    }\n+\n+    public int [] sortArray(int[] arrayA){\n+        if (arrayA == null) return null;\n+        if (arrayA.length < 2) return arrayA;\n+        int [] arrayB = new int[arrayA.length / 2];\n+        System.arraycopy(arrayA, 0, arrayB, 0, arrayA.length / 2);\n+        int [] arrayC = new int[arrayA.length - arrayA.length / 2];\n+        System.arraycopy(arrayA, arrayA.length / 2, arrayC, 0, arrayA.length - arrayA.length / 2);\n+        arrayB = sortArray(arrayB);\n+        arrayC = sortArray(arrayC);\n+        return mergeArray(arrayB, arrayC);\n+    }\n+\n+    public int [] mergeArray(int [] arrayА, int [] arrayB) {\n+        int[] arrayC = new int[arrayА.length + arrayB.length];\n+        int positionA = 0, positionB = 0;\n+        for (int i = 0; i < arrayC.length; i++) {\n+            if (positionA == arrayА.length) {\n+                arrayC[i] = arrayB[i - positionB];\n+                positionB++;\n+            } else if (positionB == arrayB.length) {\n+                arrayC[i] = arrayА[i - positionA];\n+                positionA++;\n+            } else if (arrayА[i - positionA] < arrayB[i - positionB]) {\n+                arrayC[i] = arrayА[i - positionA];\n+                positionB++;\n+            } else {\n+                arrayC[i] = arrayB[i - positionB];\n+                positionA++;\n+            }\n+        }\n+        return arrayC;\n+    }\n+}\n\\ No newline at end of file"
  }
]
