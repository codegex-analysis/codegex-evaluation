[
  {
    "sha": "4a7f8691f2e2e920ce80b654f2535b11558361db",
    "filename": "src/main/java/frc/robot/RobotContainer.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/SaintsRobotics/simulatorPractice2021/blob/a7ef490fc91d234c22ceb835782f0968bd2fff24/src/main/java/frc/robot/RobotContainer.java",
    "raw_url": "https://github.com/SaintsRobotics/simulatorPractice2021/raw/a7ef490fc91d234c22ceb835782f0968bd2fff24/src/main/java/frc/robot/RobotContainer.java",
    "contents_url": "https://api.github.com/repos/SaintsRobotics/simulatorPractice2021/contents/src/main/java/frc/robot/RobotContainer.java?ref=a7ef490fc91d234c22ceb835782f0968bd2fff24",
    "patch": "@@ -11,6 +11,7 @@\n import edu.wpi.first.wpilibj.XboxController;\n \n import edu.wpi.first.wpilibj2.command.Command;\n+import frc.robot.commands.GoToPositionCommand;\n import frc.robot.commands.SwerveJoystickCommand;\n import frc.robot.subsystems.SwerveDrivetrain;\n \n@@ -26,6 +27,7 @@\n   // The robot's subsystems and commands are defined here...\n   SwerveDrivetrain swerveDrivetrain = new SwerveDrivetrain();\n   SwerveJoystickCommand swerveJoystickCommand = new SwerveJoystickCommand(swerveDrivetrain);\n+  GoToPositionCommand goToPositionCommand = new GoToPositionCommand(swerveDrivetrain, 1, 1, 0);\n \n   /**\n    * The container for the robot. Contains subsystems, OI devices, and commands.\n@@ -52,7 +54,7 @@ private void configureButtonBindings() {\n    */\n   public Command getAutonomousCommand() {\n     // An ExampleCommand will run in autonomous\n-    return null;\n+    return goToPositionCommand;\n   }\n \n   public Command getTeleCommand() {"
  },
  {
    "sha": "9fb8e4dc2f3368ec9fab3a9da3e043a15c246bfb",
    "filename": "src/main/java/frc/robot/Utils.java",
    "status": "modified",
    "additions": 3,
    "deletions": 0,
    "changes": 3,
    "blob_url": "https://github.com/SaintsRobotics/simulatorPractice2021/blob/a7ef490fc91d234c22ceb835782f0968bd2fff24/src/main/java/frc/robot/Utils.java",
    "raw_url": "https://github.com/SaintsRobotics/simulatorPractice2021/raw/a7ef490fc91d234c22ceb835782f0968bd2fff24/src/main/java/frc/robot/Utils.java",
    "contents_url": "https://api.github.com/repos/SaintsRobotics/simulatorPractice2021/contents/src/main/java/frc/robot/Utils.java?ref=a7ef490fc91d234c22ceb835782f0968bd2fff24",
    "patch": "@@ -25,4 +25,7 @@ public static double deadZones(double input, double deadZone) { // controller de\n     public static double oddSquare(double input) {\n         return input * Math.abs(input);\n     }\n+    public static double normalizeAngle(double angle, double max){\n+        return ((angle % max) + max) % max;\n+    }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "39a402b9a693f54f316d2adc910ae5cc6853bd82",
    "filename": "src/main/java/frc/robot/commands/GoToPositionCommand.java",
    "status": "modified",
    "additions": 37,
    "deletions": 12,
    "changes": 49,
    "blob_url": "https://github.com/SaintsRobotics/simulatorPractice2021/blob/a7ef490fc91d234c22ceb835782f0968bd2fff24/src/main/java/frc/robot/commands/GoToPositionCommand.java",
    "raw_url": "https://github.com/SaintsRobotics/simulatorPractice2021/raw/a7ef490fc91d234c22ceb835782f0968bd2fff24/src/main/java/frc/robot/commands/GoToPositionCommand.java",
    "contents_url": "https://api.github.com/repos/SaintsRobotics/simulatorPractice2021/contents/src/main/java/frc/robot/commands/GoToPositionCommand.java?ref=a7ef490fc91d234c22ceb835782f0968bd2fff24",
    "patch": "@@ -7,31 +7,48 @@\n \n package frc.robot.commands;\n \n+import edu.wpi.first.wpilibj.controller.PIDController;\n+\n+import javax.security.auth.x500.X500PrivateCredential;\n+\n import edu.wpi.first.wpilibj.XboxController;\n import edu.wpi.first.wpilibj.GenericHID.Hand;\n+import edu.wpi.first.wpilibj.geometry.Pose2d;\n import edu.wpi.first.wpilibj.geometry.Translation2d;\n import edu.wpi.first.wpilibj2.command.CommandBase;\n+import edu.wpi.first.wpilibj2.command.PIDCommand;\n import frc.robot.Utils;\n import frc.robot.subsystems.SwerveDrivetrain;\n import frc.robot.Constants.SwerveConstants;\n \n public class GoToPositionCommand extends CommandBase {\n     private SwerveDrivetrain m_drivetrain;\n-    private XboxController m_controller;\n-    private Translation2d m_currentPosition;\n-    private Translation2d m_targetPosition;\n+    private Pose2d m_currentPosition;\n+    private PIDController m_xPID;\n+    private PIDController m_yPID;\n+    private PIDController m_rotationPID;\n+    private int m_counter;\n+\n \n     /**\n      * Creates a new GoToPositionCommand.\n      */\n-    public GoToPositionCommand(SwerveDrivetrain drivetrain, Translation2d currentPosition,\n-            Translation2d targetPosition) {\n+    public GoToPositionCommand(SwerveDrivetrain drivetrain, double targetX, double targetY, double targetRotation) {\n         // Use addRequirements() here to declare subsystem dependencies.\n         addRequirements(drivetrain);\n         m_drivetrain = drivetrain;\n-        m_currentPosition = currentPosition;\n-        m_targetPosition = targetPosition;\n \n+        m_xPID = new PIDController(10, 0, 0);\n+        m_yPID = new PIDController(10, 0, 0);\n+        m_rotationPID = new PIDController(10, 0, 0);\n+\n+        m_xPID.setSetpoint(targetX);\n+        m_yPID.setSetpoint(targetY);\n+        m_rotationPID.setSetpoint(targetRotation);\n+\n+        m_xPID.setTolerance(0.05);\n+        m_yPID.setTolerance(0.05);\n+        m_rotationPID.setTolerance(0.05);\n     }\n \n     // Called when the command is initially scheduled.\n@@ -42,20 +59,28 @@ public void initialize() {\n     // Called every time the scheduler runs while the command is scheduled.\n     @Override\n     public void execute() {\n-\n-        // m_drivetrain.move(xSpeed, ySpeed, rotSpeed, false);\n-\n+        m_currentPosition = m_drivetrain.getCurrentPosition();\n+        m_drivetrain.move(\n+            m_xPID.calculate(m_currentPosition.getX()),\n+            m_yPID.calculate(m_currentPosition.getY()),\n+            m_rotationPID.calculate(m_currentPosition.getRotation().getRadians()),\n+            true);\n     }\n \n     // Called once the command ends or is interrupted.\n     @Override\n     public void end(boolean interrupted) {\n-        // m_drivetrain.move(0, 0, 0, false);\n+        m_drivetrain.move(0, 0, 0, false);\n     }\n \n     // Returns true when the command should end.\n     @Override\n     public boolean isFinished() {\n-        return false;\n+        if (m_xPID.atSetpoint() && m_yPID.atSetpoint() && m_rotationPID.atSetpoint()) {\n+            m_counter++;\n+        } else {\n+            m_counter = 0;\n+        }\n+        return m_counter > 10;\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "1c1d7e23f9a27cf06c778fb758b0322e66aa81bf",
    "filename": "src/main/java/frc/robot/commands/SwerveJoystickCommand.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/SaintsRobotics/simulatorPractice2021/blob/a7ef490fc91d234c22ceb835782f0968bd2fff24/src/main/java/frc/robot/commands/SwerveJoystickCommand.java",
    "raw_url": "https://github.com/SaintsRobotics/simulatorPractice2021/raw/a7ef490fc91d234c22ceb835782f0968bd2fff24/src/main/java/frc/robot/commands/SwerveJoystickCommand.java",
    "contents_url": "https://api.github.com/repos/SaintsRobotics/simulatorPractice2021/contents/src/main/java/frc/robot/commands/SwerveJoystickCommand.java?ref=a7ef490fc91d234c22ceb835782f0968bd2fff24",
    "patch": "@@ -41,7 +41,7 @@ public void execute() { // if dont apply deadzone, then relation between joystic\n     double x = Utils.oddSquare(Utils.deadZones(-m_controller.getY(Hand.kLeft), 0.2))\n         * SwerveConstants.MAX_METERS_PER_SECOND; // apply functions to controller values to 1) check deadzone 2) apply\n     // quadratic relation between controller/speed\n-    double y = Utils.oddSquare(Utils.deadZones(m_controller.getX(Hand.kLeft), 0.2))\n+    double y = Utils.oddSquare(Utils.deadZones(-m_controller.getX(Hand.kLeft), 0.2))\n         * SwerveConstants.MAX_METERS_PER_SECOND;\n     double rot = Utils.oddSquare(Utils.deadZones(m_controller.getX(Hand.kRight), 0.2))\n         * SwerveConstants.MAX_RADIANS_PER_SECOND;"
  },
  {
    "sha": "da66cc6d34d6b75f956482fe177a636fc83e1996",
    "filename": "src/main/java/frc/robot/subsystems/SwerveDrivetrain.java",
    "status": "modified",
    "additions": 54,
    "deletions": 24,
    "changes": 78,
    "blob_url": "https://github.com/SaintsRobotics/simulatorPractice2021/blob/a7ef490fc91d234c22ceb835782f0968bd2fff24/src/main/java/frc/robot/subsystems/SwerveDrivetrain.java",
    "raw_url": "https://github.com/SaintsRobotics/simulatorPractice2021/raw/a7ef490fc91d234c22ceb835782f0968bd2fff24/src/main/java/frc/robot/subsystems/SwerveDrivetrain.java",
    "contents_url": "https://api.github.com/repos/SaintsRobotics/simulatorPractice2021/contents/src/main/java/frc/robot/subsystems/SwerveDrivetrain.java?ref=a7ef490fc91d234c22ceb835782f0968bd2fff24",
    "patch": "@@ -14,15 +14,20 @@\n import edu.wpi.first.hal.SimDouble;\n import edu.wpi.first.hal.simulation.SimDeviceDataJNI;\n import edu.wpi.first.wpilibj.controller.PIDController;\n+import edu.wpi.first.wpilibj.geometry.Pose2d;\n import edu.wpi.first.wpilibj.geometry.Rotation2d;\n import edu.wpi.first.wpilibj.interfaces.Gyro;\n import edu.wpi.first.wpilibj.kinematics.ChassisSpeeds;\n import edu.wpi.first.wpilibj.kinematics.SwerveDriveKinematics;\n+import edu.wpi.first.wpilibj.kinematics.SwerveDriveOdometry;\n import edu.wpi.first.wpilibj.kinematics.SwerveModuleState;\n+import edu.wpi.first.wpilibj.smartdashboard.Field2d;\n+import edu.wpi.first.wpilibj.smartdashboard.FieldObject2d;\n import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\n import edu.wpi.first.wpilibj2.command.SubsystemBase;\n import frc.robot.AbsoluteEncoder;\n import frc.robot.Robot;\n+import frc.robot.Utils;\n import frc.robot.Constants.SwervePorts;\n import frc.robot.Constants.SwerveConstants;\n \n@@ -53,33 +58,45 @@\n         private double m_rotationSpeed;\n         private boolean m_isFieldRelative;\n         private AHRS m_gyro;\n-\n+        private SwerveDriveOdometry m_odometry;\n         private SwerveDriveKinematics m_kinematics;\n-\n+        private double time;\n+        private final Field2d m_field = new Field2d();\n+        \n         // need pid to save headings/dynamic controls\n         private PIDController m_rotationPID;\n \n         /**\n          * Creates a new SwerveDrivetrain.\n          */\n         public SwerveDrivetrain() {\n+                SmartDashboard.putData(\"Field\", m_field);\n                 m_frontLeftDriveMotor = new CANSparkMax(SwervePorts.FRONT_LEFT_DRIVE_MOTOR_PORT, MotorType.kBrushless);\n-                m_frontRightDriveMotor = new CANSparkMax(SwervePorts.FRONT_RIGHT_DRIVE_MOTOR_PORT, MotorType.kBrushless);\n+                m_frontRightDriveMotor = new CANSparkMax(SwervePorts.FRONT_RIGHT_DRIVE_MOTOR_PORT,\n+                                MotorType.kBrushless);\n                 m_backLeftDriveMotor = new CANSparkMax(SwervePorts.BACK_LEFT_DRIVE_MOTOR_PORT, MotorType.kBrushless);\n                 m_backRightDriveMotor = new CANSparkMax(SwervePorts.BACK_RIGHT_DRIVE_MOTOR_PORT, MotorType.kBrushless);\n \n-                m_frontLeftTurningMotor = new CANSparkMax(SwervePorts.FRONT_LEFT_TURNING_MOTOR_PORT, MotorType.kBrushless);\n-                m_frontRightTurningMotor = new CANSparkMax(SwervePorts.FRONT_RIGHT_TURNING_MOTOR_PORT, MotorType.kBrushless);\n-                m_backLeftTurningMotor = new CANSparkMax(SwervePorts.BACK_LEFT_TURNING_MOTOR_PORT, MotorType.kBrushless);\n-                m_backRightTurningMotor = new CANSparkMax(SwervePorts.BACK_RIGHT_TURNING_MOTOR_PORT, MotorType.kBrushless);\n+                m_frontLeftTurningMotor = new CANSparkMax(SwervePorts.FRONT_LEFT_TURNING_MOTOR_PORT,\n+                                MotorType.kBrushless);\n+                m_frontRightTurningMotor = new CANSparkMax(SwervePorts.FRONT_RIGHT_TURNING_MOTOR_PORT,\n+                                MotorType.kBrushless);\n+                m_backLeftTurningMotor = new CANSparkMax(SwervePorts.BACK_LEFT_TURNING_MOTOR_PORT,\n+                                MotorType.kBrushless);\n+                m_backRightTurningMotor = new CANSparkMax(SwervePorts.BACK_RIGHT_TURNING_MOTOR_PORT,\n+                                MotorType.kBrushless);\n \n                 m_frontLeftDriveMotor.setInverted(true);\n                 m_backLeftDriveMotor.setInverted(true);\n \n-                m_frontLeftTurningEncoder = new AbsoluteEncoder(SwervePorts.FRONT_LEFT_TURNING_ENCODER_PORT, true, SwerveConstants.FRONT_LEFT_ROTATION_OFFSET);\n-                m_frontRightTurningEncoder = new AbsoluteEncoder(SwervePorts.FRONT_RIGHT_TURNING_ENCODER_PORT, true, SwerveConstants.FRONT_RIGHT_ROTATION_OFFSET);\n-                m_backLeftTurningEncoder = new AbsoluteEncoder(SwervePorts.BACK_LEFT_TURNING_ENCODER_PORT, true, SwerveConstants.BACK_LEFT_ROTATION_OFFSET);\n-                m_backRightTurningEncoder = new AbsoluteEncoder(SwervePorts.BACK_RIGHT_TURNING_ENCODER_PORT, true, SwerveConstants.BACK_RIGHT_ROTATION_OFFSET);\n+                m_frontLeftTurningEncoder = new AbsoluteEncoder(SwervePorts.FRONT_LEFT_TURNING_ENCODER_PORT, true,\n+                                SwerveConstants.FRONT_LEFT_ROTATION_OFFSET);\n+                m_frontRightTurningEncoder = new AbsoluteEncoder(SwervePorts.FRONT_RIGHT_TURNING_ENCODER_PORT, true,\n+                                SwerveConstants.FRONT_RIGHT_ROTATION_OFFSET);\n+                m_backLeftTurningEncoder = new AbsoluteEncoder(SwervePorts.BACK_LEFT_TURNING_ENCODER_PORT, true,\n+                                SwerveConstants.BACK_LEFT_ROTATION_OFFSET);\n+                m_backRightTurningEncoder = new AbsoluteEncoder(SwervePorts.BACK_RIGHT_TURNING_ENCODER_PORT, true,\n+                                SwerveConstants.BACK_RIGHT_ROTATION_OFFSET);\n \n                 // Robot is facing towards positive x direction\n                 m_frontLeftSwerveWheel = new SwerveWheel(m_frontLeftDriveMotor, m_frontLeftTurningMotor,\n@@ -91,18 +108,17 @@ public SwerveDrivetrain() {\n                 m_backRightSwerveWheel = new SwerveWheel(m_backRightDriveMotor, m_backRightTurningMotor,\n                                 -SwerveConstants.SWERVE_X, -SwerveConstants.SWERVE_Y, m_backRightTurningEncoder);\n \n-                m_kinematics = new SwerveDriveKinematics(\n-                                m_frontLeftSwerveWheel.getLocation(),\n-                                m_frontRightSwerveWheel.getLocation(),\n-                                m_backLeftSwerveWheel.getLocation(),\n+                m_kinematics = new SwerveDriveKinematics(m_frontLeftSwerveWheel.getLocation(),\n+                                m_frontRightSwerveWheel.getLocation(), m_backLeftSwerveWheel.getLocation(),\n                                 m_backRightSwerveWheel.getLocation());\n \n-                m_rotationPID = new PIDController(Math.toRadians((SwerveConstants.MAX_METERS_PER_SECOND / 180) * 5), 0, 0);\n+                m_rotationPID = new PIDController(Math.toRadians((SwerveConstants.MAX_METERS_PER_SECOND / 180) * 5), 0,\n+                                0);\n                 m_rotationPID.enableContinuousInput(0, Math.PI * 2);\n                 m_rotationPID.setTolerance(1 / 36); // if off by a lil bit, then dont do anything (is in radians)\n \n                 m_gyro = new AHRS();\n-                \n+                m_odometry = new SwerveDriveOdometry(m_kinematics, m_gyro.getRotation2d());\n         }\n \n         public void move(double xSpeed, double ySpeed, double rotationSpeed, boolean isFieldRelative) {\n@@ -118,40 +134,54 @@ public void move(double xSpeed, double ySpeed, double rotationSpeed, boolean isF\n \n         @Override\n         public void periodic() {\n-                Rotation2d gyroAngle = m_gyro.getRotation2d();\n-\n+               double gyroAngle = m_gyro.getYaw();\n+               if (time > 10){\n+                        m_odometry.update(m_gyro.getRotation2d(), m_frontLeftSwerveWheel.getState(),   m_frontRightSwerveWheel.getState(),m_backLeftSwerveWheel.getState(),   m_backRightSwerveWheel.getState());\n+                        m_field.setRobotPose(m_odometry.getPoseMeters());\n+                }\n+                time ++;        \n                 ChassisSpeeds desiredSpeed;\n \n                 // convert to robot relative if in field relative\n                 if (this.m_isFieldRelative) {\n-                        desiredSpeed = ChassisSpeeds.fromFieldRelativeSpeeds(m_xSpeed, m_ySpeed, m_rotationSpeed, gyroAngle);\n+                        desiredSpeed = ChassisSpeeds.fromFieldRelativeSpeeds(m_xSpeed, m_ySpeed, m_rotationSpeed,\n+                                        Rotation2d.fromDegrees(gyroAngle));\n                 } else {\n                         desiredSpeed = new ChassisSpeeds(m_xSpeed, m_ySpeed, m_rotationSpeed);\n                 }\n \n                 SwerveModuleState[] desiredSwerveModuleStates = m_kinematics.toSwerveModuleStates(desiredSpeed);\n-                SwerveDriveKinematics.normalizeWheelSpeeds(desiredSwerveModuleStates, SwerveConstants.MAX_METERS_PER_SECOND);\n+                SwerveDriveKinematics.normalizeWheelSpeeds(desiredSwerveModuleStates,\n+                                SwerveConstants.MAX_METERS_PER_SECOND);\n                 m_frontLeftSwerveWheel.setState(desiredSwerveModuleStates[0]);\n                 m_frontRightSwerveWheel.setState(desiredSwerveModuleStates[1]);\n                 m_backLeftSwerveWheel.setState(desiredSwerveModuleStates[2]);\n                 m_backRightSwerveWheel.setState(desiredSwerveModuleStates[3]);\n-                \n+\n                 // updates the gyro yaw value and prints it to the simulator\n                 double m_degreeRotationSpeed = Math.toDegrees(m_rotationSpeed);\n                 double m_degreesSinceLastTick = m_degreeRotationSpeed * Robot.kDefaultPeriod;\n                 printSimulatedGyro(m_gyro.getYaw() + m_degreesSinceLastTick);\n-\n+                SmartDashboard.putNumber(\"OdometryX\", m_odometry.getPoseMeters().getX());\n+                SmartDashboard.putNumber(\"OdometryY\", m_odometry.getPoseMeters().getY());\n+                SmartDashboard.putNumber(\"Odometryrot\", m_odometry.getPoseMeters().getRotation().getDegrees());\n                 SmartDashboard.putNumber(\"Front Left Turning Encoder\", m_frontLeftTurningEncoder.getRadians());\n                 SmartDashboard.putNumber(\"Front Right Turning Encoder\", m_frontRightTurningEncoder.getRadians());\n                 SmartDashboard.putNumber(\"Back Left Turning Encoder\", m_backLeftTurningEncoder.getRadians());\n                 SmartDashboard.putNumber(\"Back Right Turning Encoder\", m_backRightTurningEncoder.getRadians());\n                 SmartDashboard.putNumber(\"Gyro Heading\", m_gyro.getYaw());\n+                \n+                \n         }\n \n-        public void printSimulatedGyro(double printHeading){ \n+        public void printSimulatedGyro(double printHeading) {\n                 int dev = SimDeviceDataJNI.getSimDeviceHandle(\"navX-Sensor[0]\");\n                 SimDouble angle = new SimDouble(SimDeviceDataJNI.getSimValueHandle(dev, \"Yaw\"));\n                 angle.set(printHeading);\n \n         }\n+\n+        public Pose2d getCurrentPosition() {\n+                return m_odometry.getPoseMeters();\n+        }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "c1d5089ecc0939f4ce665b1a3f029854e078a1d0",
    "filename": "src/main/java/frc/robot/subsystems/SwerveWheel.java",
    "status": "modified",
    "additions": 6,
    "deletions": 1,
    "changes": 7,
    "blob_url": "https://github.com/SaintsRobotics/simulatorPractice2021/blob/a7ef490fc91d234c22ceb835782f0968bd2fff24/src/main/java/frc/robot/subsystems/SwerveWheel.java",
    "raw_url": "https://github.com/SaintsRobotics/simulatorPractice2021/raw/a7ef490fc91d234c22ceb835782f0968bd2fff24/src/main/java/frc/robot/subsystems/SwerveWheel.java",
    "contents_url": "https://api.github.com/repos/SaintsRobotics/simulatorPractice2021/contents/src/main/java/frc/robot/subsystems/SwerveWheel.java?ref=a7ef490fc91d234c22ceb835782f0968bd2fff24",
    "patch": "@@ -10,7 +10,9 @@\n import com.revrobotics.CANSparkMax;\n \n import edu.wpi.first.wpilibj.controller.PIDController;\n+import edu.wpi.first.wpilibj.geometry.Rotation2d;\n import edu.wpi.first.wpilibj.geometry.Translation2d;\n+import edu.wpi.first.wpilibj.kinematics.SwerveDriveOdometry;\n import edu.wpi.first.wpilibj.kinematics.SwerveModuleState;\n import frc.robot.AbsoluteEncoder;\n import frc.robot.Robot;\n@@ -48,10 +50,13 @@ public void setState(SwerveModuleState state) {\n         }\n \n         m_turningMotor.set(percentVoltage);\n+        m_state = new SwerveModuleState(state.speedMetersPerSecond, new Rotation2d(m_turningEncoder.getRadians()));\n     }\n \n     public Translation2d getLocation() {\n         return m_location;\n     }\n-\n+    public SwerveModuleState getState(){\n+        return m_state;\n+    }\n }\n\\ No newline at end of file"
  }
]
