[
  {
    "sha": "f1d108fa142e3f8720653e32585a79ef3a3fdbe2",
    "filename": "detour/src/main/java/org/recast4j/detour/LegacyNavMeshQuery.java",
    "status": "added",
    "additions": 750,
    "deletions": 0,
    "changes": 750,
    "blob_url": "https://github.com/ppiastucki/recast4j/blob/d3d279fef1f6267818e437fd4da4ad6848f93df9/detour/src/main/java/org/recast4j/detour/LegacyNavMeshQuery.java",
    "raw_url": "https://github.com/ppiastucki/recast4j/raw/d3d279fef1f6267818e437fd4da4ad6848f93df9/detour/src/main/java/org/recast4j/detour/LegacyNavMeshQuery.java",
    "contents_url": "https://api.github.com/repos/ppiastucki/recast4j/contents/detour/src/main/java/org/recast4j/detour/LegacyNavMeshQuery.java?ref=d3d279fef1f6267818e437fd4da4ad6848f93df9",
    "patch": "@@ -0,0 +1,750 @@\n+/*\n+recast4j copyright (c) 2021 Piotr Piastucki piotr@jtilia.org\n+\n+This software is provided 'as-is', without any express or implied\n+warranty.  In no event will the authors be held liable for any damages\n+arising from the use of this software.\n+Permission is granted to anyone to use this software for any purpose,\n+including commercial applications, and to alter it and redistribute it\n+freely, subject to the following restrictions:\n+1. The origin of this software must not be misrepresented; you must not\n+ claim that you wrote the original software. If you use this software\n+ in a product, an acknowledgment in the product documentation would be\n+ appreciated but is not required.\n+2. Altered source versions must be plainly marked as such, and must not be\n+ misrepresented as being the original software.\n+3. This notice may not be removed or altered from any source distribution.\n+*/\n+\n+package org.recast4j.detour;\n+\n+import static org.recast4j.detour.DetourCommon.distancePtSegSqr2D;\n+import static org.recast4j.detour.DetourCommon.sqr;\n+import static org.recast4j.detour.DetourCommon.vCopy;\n+import static org.recast4j.detour.DetourCommon.vDist;\n+import static org.recast4j.detour.DetourCommon.vDistSqr;\n+import static org.recast4j.detour.DetourCommon.vIsFinite;\n+import static org.recast4j.detour.DetourCommon.vNormalize;\n+import static org.recast4j.detour.DetourCommon.vSub;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class LegacyNavMeshQuery extends NavMeshQuery {\n+\n+    public LegacyNavMeshQuery(NavMesh nav) {\n+        super(nav);\n+    }\n+\n+    @Override\n+    public Result<List<Long>> findPath(long startRef, long endRef, float[] startPos, float[] endPos,\n+            QueryFilter filter) {\n+        // Validate input\n+        if (!m_nav.isValidPolyRef(startRef) || !m_nav.isValidPolyRef(endRef) || Objects.isNull(startPos)\n+                || !vIsFinite(startPos) || Objects.isNull(endPos) || !vIsFinite(endPos) || Objects.isNull(filter)) {\n+            return Result.invalidParam();\n+        }\n+\n+        if (startRef == endRef) {\n+            List<Long> path = new ArrayList<>(1);\n+            path.add(startRef);\n+            return Result.success(path);\n+        }\n+\n+        m_nodePool.clear();\n+        m_openList.clear();\n+\n+        Node startNode = m_nodePool.getNode(startRef);\n+        vCopy(startNode.pos, startPos);\n+        startNode.pidx = 0;\n+        startNode.cost = 0;\n+        startNode.total = vDist(startPos, endPos) * H_SCALE;\n+        startNode.id = startRef;\n+        startNode.flags = Node.DT_NODE_OPEN;\n+        m_openList.push(startNode);\n+\n+        Node lastBestNode = startNode;\n+        float lastBestNodeCost = startNode.total;\n+\n+        Status status = Status.SUCCSESS;\n+\n+        while (!m_openList.isEmpty()) {\n+            // Remove node from open list and put it in closed list.\n+            Node bestNode = m_openList.pop();\n+            bestNode.flags &= ~Node.DT_NODE_OPEN;\n+            bestNode.flags |= Node.DT_NODE_CLOSED;\n+\n+            // Reached the goal, stop searching.\n+            if (bestNode.id == endRef) {\n+                lastBestNode = bestNode;\n+                break;\n+            }\n+\n+            // Get current poly and tile.\n+            // The API input has been cheked already, skip checking internal data.\n+            long bestRef = bestNode.id;\n+            Tupple2<MeshTile, Poly> tileAndPoly = m_nav.getTileAndPolyByRefUnsafe(bestRef);\n+            MeshTile bestTile = tileAndPoly.first;\n+            Poly bestPoly = tileAndPoly.second;\n+\n+            // Get parent poly and tile.\n+            long parentRef = 0;\n+            MeshTile parentTile = null;\n+            Poly parentPoly = null;\n+            if (bestNode.pidx != 0) {\n+                parentRef = m_nodePool.getNodeAtIdx(bestNode.pidx).id;\n+            }\n+            if (parentRef != 0) {\n+                tileAndPoly = m_nav.getTileAndPolyByRefUnsafe(parentRef);\n+                parentTile = tileAndPoly.first;\n+                parentPoly = tileAndPoly.second;\n+            }\n+\n+            for (int i = bestPoly.firstLink; i != NavMesh.DT_NULL_LINK; i = bestTile.links.get(i).next) {\n+                long neighbourRef = bestTile.links.get(i).ref;\n+\n+                // Skip invalid ids and do not expand back to where we came from.\n+                if (neighbourRef == 0 || neighbourRef == parentRef) {\n+                    continue;\n+                }\n+\n+                // Get neighbour poly and tile.\n+                // The API input has been cheked already, skip checking internal data.\n+                tileAndPoly = m_nav.getTileAndPolyByRefUnsafe(neighbourRef);\n+                MeshTile neighbourTile = tileAndPoly.first;\n+                Poly neighbourPoly = tileAndPoly.second;\n+\n+                if (!filter.passFilter(neighbourRef, neighbourTile, neighbourPoly)) {\n+                    continue;\n+                }\n+\n+                // deal explicitly with crossing tile boundaries\n+                int crossSide = 0;\n+                if (bestTile.links.get(i).side != 0xff) {\n+                    crossSide = bestTile.links.get(i).side >> 1;\n+                }\n+\n+                // get the node\n+                Node neighbourNode = m_nodePool.getNode(neighbourRef, crossSide);\n+\n+                // If the node is visited the first time, calculate node position.\n+                if (neighbourNode.flags == 0) {\n+                    Result<float[]> midpod = getEdgeMidPoint(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly,\n+                            neighbourTile);\n+                    if (!midpod.failed()) {\n+                        neighbourNode.pos = midpod.result;\n+                    }\n+                }\n+\n+                // Calculate cost and heuristic.\n+                float cost = 0;\n+                float heuristic = 0;\n+\n+                // Special case for last node.\n+                if (neighbourRef == endRef) {\n+                    // Cost\n+                    float curCost = filter.getCost(bestNode.pos, neighbourNode.pos, parentRef, parentTile, parentPoly,\n+                            bestRef, bestTile, bestPoly, neighbourRef, neighbourTile, neighbourPoly);\n+                    float endCost = filter.getCost(neighbourNode.pos, endPos, bestRef, bestTile, bestPoly, neighbourRef,\n+                            neighbourTile, neighbourPoly, 0L, null, null);\n+\n+                    cost = bestNode.cost + curCost + endCost;\n+                    heuristic = 0;\n+                } else {\n+                    // Cost\n+                    float curCost = filter.getCost(bestNode.pos, neighbourNode.pos, parentRef, parentTile, parentPoly,\n+                            bestRef, bestTile, bestPoly, neighbourRef, neighbourTile, neighbourPoly);\n+                    cost = bestNode.cost + curCost;\n+                    heuristic = vDist(neighbourNode.pos, endPos) * H_SCALE;\n+                }\n+\n+                float total = cost + heuristic;\n+\n+                // The node is already in open list and the new result is worse, skip.\n+                if ((neighbourNode.flags & Node.DT_NODE_OPEN) != 0 && total >= neighbourNode.total) {\n+                    continue;\n+                }\n+                // The node is already visited and process, and the new result is worse, skip.\n+                if ((neighbourNode.flags & Node.DT_NODE_CLOSED) != 0 && total >= neighbourNode.total) {\n+                    continue;\n+                }\n+\n+                // Add or update the node.\n+                neighbourNode.pidx = m_nodePool.getNodeIdx(bestNode);\n+                neighbourNode.id = neighbourRef;\n+                neighbourNode.flags = (neighbourNode.flags & ~Node.DT_NODE_CLOSED);\n+                neighbourNode.cost = cost;\n+                neighbourNode.total = total;\n+\n+                if ((neighbourNode.flags & Node.DT_NODE_OPEN) != 0) {\n+                    // Already in open, update node location.\n+                    m_openList.modify(neighbourNode);\n+                } else {\n+                    // Put the node in open list.\n+                    neighbourNode.flags |= Node.DT_NODE_OPEN;\n+                    m_openList.push(neighbourNode);\n+                }\n+\n+                // Update nearest node to target so far.\n+                if (heuristic < lastBestNodeCost) {\n+                    lastBestNodeCost = heuristic;\n+                    lastBestNode = neighbourNode;\n+                }\n+            }\n+        }\n+\n+        List<Long> path = getPathToNode(lastBestNode);\n+\n+        if (lastBestNode.id != endRef) {\n+            status = Status.PARTIAL_RESULT;\n+        }\n+\n+        return Result.of(status, path);\n+    }\n+\n+    /**\n+     * Updates an in-progress sliced path query.\n+     *\n+     * @param maxIter\n+     *            The maximum number of iterations to perform.\n+     * @return The status flags for the query.\n+     */\n+    @Override\n+    public Result<Integer> updateSlicedFindPath(int maxIter) {\n+        if (!m_query.status.isInProgress()) {\n+            return Result.of(m_query.status, 0);\n+        }\n+\n+        // Make sure the request is still valid.\n+        if (!m_nav.isValidPolyRef(m_query.startRef) || !m_nav.isValidPolyRef(m_query.endRef)) {\n+            m_query.status = Status.FAILURE;\n+            return Result.of(m_query.status, 0);\n+        }\n+\n+        int iter = 0;\n+        while (iter < maxIter && !m_openList.isEmpty()) {\n+            iter++;\n+\n+            // Remove node from open list and put it in closed list.\n+            Node bestNode = m_openList.pop();\n+            bestNode.flags &= ~Node.DT_NODE_OPEN;\n+            bestNode.flags |= Node.DT_NODE_CLOSED;\n+\n+            // Reached the goal, stop searching.\n+            if (bestNode.id == m_query.endRef) {\n+                m_query.lastBestNode = bestNode;\n+                m_query.status = Status.SUCCSESS;\n+                return Result.of(m_query.status, iter);\n+            }\n+\n+            // Get current poly and tile.\n+            // The API input has been cheked already, skip checking internal\n+            // data.\n+            long bestRef = bestNode.id;\n+            Result<Tupple2<MeshTile, Poly>> tileAndPoly = m_nav.getTileAndPolyByRef(bestRef);\n+            if (tileAndPoly.failed()) {\n+                m_query.status = Status.FAILURE;\n+                // The polygon has disappeared during the sliced query, fail.\n+                return Result.of(m_query.status, iter);\n+            }\n+            MeshTile bestTile = tileAndPoly.result.first;\n+            Poly bestPoly = tileAndPoly.result.second;\n+            // Get parent and grand parent poly and tile.\n+            long parentRef = 0, grandpaRef = 0;\n+            MeshTile parentTile = null;\n+            Poly parentPoly = null;\n+            Node parentNode = null;\n+            if (bestNode.pidx != 0) {\n+                parentNode = m_nodePool.getNodeAtIdx(bestNode.pidx);\n+                parentRef = parentNode.id;\n+                if (parentNode.pidx != 0) {\n+                    grandpaRef = m_nodePool.getNodeAtIdx(parentNode.pidx).id;\n+                }\n+            }\n+            if (parentRef != 0) {\n+                boolean invalidParent = false;\n+                tileAndPoly = m_nav.getTileAndPolyByRef(parentRef);\n+                invalidParent = tileAndPoly.failed();\n+                if (invalidParent || (grandpaRef != 0 && !m_nav.isValidPolyRef(grandpaRef))) {\n+                    // The polygon has disappeared during the sliced query,\n+                    // fail.\n+                    m_query.status = Status.FAILURE;\n+                    return Result.of(m_query.status, iter);\n+                }\n+                parentTile = tileAndPoly.result.first;\n+                parentPoly = tileAndPoly.result.second;\n+            }\n+\n+            // decide whether to test raycast to previous nodes\n+            boolean tryLOS = false;\n+            if ((m_query.options & DT_FINDPATH_ANY_ANGLE) != 0) {\n+                if ((parentRef != 0) && (vDistSqr(parentNode.pos, bestNode.pos) < m_query.raycastLimitSqr)) {\n+                    tryLOS = true;\n+                }\n+            }\n+\n+            for (int i = bestPoly.firstLink; i != NavMesh.DT_NULL_LINK; i = bestTile.links.get(i).next) {\n+                long neighbourRef = bestTile.links.get(i).ref;\n+\n+                // Skip invalid ids and do not expand back to where we came\n+                // from.\n+                if (neighbourRef == 0 || neighbourRef == parentRef) {\n+                    continue;\n+                }\n+\n+                // Get neighbour poly and tile.\n+                // The API input has been cheked already, skip checking internal\n+                // data.\n+                Tupple2<MeshTile, Poly> tileAndPolyUns = m_nav.getTileAndPolyByRefUnsafe(neighbourRef);\n+                MeshTile neighbourTile = tileAndPolyUns.first;\n+                Poly neighbourPoly = tileAndPolyUns.second;\n+\n+                if (!m_query.filter.passFilter(neighbourRef, neighbourTile, neighbourPoly)) {\n+                    continue;\n+                }\n+\n+                // get the neighbor node\n+                Node neighbourNode = m_nodePool.getNode(neighbourRef, 0);\n+\n+                // do not expand to nodes that were already visited from the\n+                // same parent\n+                if (neighbourNode.pidx != 0 && neighbourNode.pidx == bestNode.pidx) {\n+                    continue;\n+                }\n+\n+                // If the node is visited the first time, calculate node\n+                // position.\n+                if (neighbourNode.flags == 0) {\n+                    Result<float[]> midpod = getEdgeMidPoint(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly,\n+                            neighbourTile);\n+                    if (!midpod.failed()) {\n+                        neighbourNode.pos = midpod.result;\n+                    }\n+                }\n+\n+                // Calculate cost and heuristic.\n+                float cost = 0;\n+                float heuristic = 0;\n+\n+                // raycast parent\n+                boolean foundShortCut = false;\n+                if (tryLOS) {\n+                    Result<RaycastHit> rayHit = raycast(parentRef, parentNode.pos, neighbourNode.pos, m_query.filter,\n+                            DT_RAYCAST_USE_COSTS, grandpaRef);\n+                    if (rayHit.succeeded()) {\n+                        foundShortCut = rayHit.result.t >= 1.0f;\n+                        if (foundShortCut) {\n+                            // shortcut found using raycast. Using shorter cost\n+                            // instead\n+                            cost = parentNode.cost + rayHit.result.pathCost;\n+                        }\n+                    }\n+                }\n+\n+                // update move cost\n+                if (!foundShortCut) {\n+                    // No shortcut found.\n+                    float curCost = m_query.filter.getCost(bestNode.pos, neighbourNode.pos, parentRef, parentTile,\n+                            parentPoly, bestRef, bestTile, bestPoly, neighbourRef, neighbourTile, neighbourPoly);\n+                    cost = bestNode.cost + curCost;\n+                }\n+\n+                // Special case for last node.\n+                if (neighbourRef == m_query.endRef) {\n+                    float endCost = m_query.filter.getCost(neighbourNode.pos, m_query.endPos, bestRef, bestTile,\n+                            bestPoly, neighbourRef, neighbourTile, neighbourPoly, 0, null, null);\n+\n+                    cost = cost + endCost;\n+                    heuristic = 0;\n+                } else {\n+                    heuristic = vDist(neighbourNode.pos, m_query.endPos) * H_SCALE;\n+                }\n+\n+                float total = cost + heuristic;\n+\n+                // The node is already in open list and the new result is worse,\n+                // skip.\n+                if ((neighbourNode.flags & Node.DT_NODE_OPEN) != 0 && total >= neighbourNode.total) {\n+                    continue;\n+                }\n+                // The node is already visited and process, and the new result\n+                // is worse, skip.\n+                if ((neighbourNode.flags & Node.DT_NODE_CLOSED) != 0 && total >= neighbourNode.total) {\n+                    continue;\n+                }\n+\n+                // Add or update the node.\n+                neighbourNode.pidx = foundShortCut ? bestNode.pidx : m_nodePool.getNodeIdx(bestNode);\n+                neighbourNode.id = neighbourRef;\n+                neighbourNode.flags = (neighbourNode.flags & ~(Node.DT_NODE_CLOSED | Node.DT_NODE_PARENT_DETACHED));\n+                neighbourNode.cost = cost;\n+                neighbourNode.total = total;\n+                if (foundShortCut) {\n+                    neighbourNode.flags = (neighbourNode.flags | Node.DT_NODE_PARENT_DETACHED);\n+                }\n+\n+                if ((neighbourNode.flags & Node.DT_NODE_OPEN) != 0) {\n+                    // Already in open, update node location.\n+                    m_openList.modify(neighbourNode);\n+                } else {\n+                    // Put the node in open list.\n+                    neighbourNode.flags |= Node.DT_NODE_OPEN;\n+                    m_openList.push(neighbourNode);\n+                }\n+\n+                // Update nearest node to target so far.\n+                if (heuristic < m_query.lastBestNodeCost) {\n+                    m_query.lastBestNodeCost = heuristic;\n+                    m_query.lastBestNode = neighbourNode;\n+                }\n+            }\n+        }\n+\n+        // Exhausted all nodes, but could not find path.\n+        if (m_openList.isEmpty()) {\n+            m_query.status = Status.PARTIAL_RESULT;\n+        }\n+\n+        return Result.of(m_query.status, iter);\n+    }\n+\n+    /// Finalizes and returns the results of a sliced path query.\n+    /// @param[out] path An ordered list of polygon references representing the path. (Start to end.)\n+    /// [(polyRef) * @p pathCount]\n+    /// @returns The status flags for the query.\n+    @Override\n+    public Result<List<Long>> finalizeSlicedFindPath() {\n+\n+        List<Long> path = new ArrayList<>(64);\n+        if (m_query.status.isFailed()) {\n+            // Reset query.\n+            m_query = new QueryData();\n+            return Result.failure(path);\n+        }\n+\n+        if (m_query.startRef == m_query.endRef) {\n+            // Special case: the search starts and ends at same poly.\n+            path.add(m_query.startRef);\n+        } else {\n+            // Reverse the path.\n+            if (m_query.lastBestNode.id != m_query.endRef) {\n+                m_query.status = Status.PARTIAL_RESULT;\n+            }\n+\n+            Node prev = null;\n+            Node node = m_query.lastBestNode;\n+            int prevRay = 0;\n+            do {\n+                Node next = m_nodePool.getNodeAtIdx(node.pidx);\n+                node.pidx = m_nodePool.getNodeIdx(prev);\n+                prev = node;\n+                int nextRay = node.flags & Node.DT_NODE_PARENT_DETACHED; // keep track of whether parent is not adjacent\n+                                                                         // (i.e. due to raycast shortcut)\n+                node.flags = (node.flags & ~Node.DT_NODE_PARENT_DETACHED) | prevRay; // and store it in the reversed\n+                                                                                     // path's node\n+                prevRay = nextRay;\n+                node = next;\n+            } while (node != null);\n+\n+            // Store path\n+            node = prev;\n+            do {\n+                Node next = m_nodePool.getNodeAtIdx(node.pidx);\n+                if ((node.flags & Node.DT_NODE_PARENT_DETACHED) != 0) {\n+                    Result<RaycastHit> iresult = raycast(node.id, node.pos, next.pos, m_query.filter, 0, 0);\n+                    if (iresult.succeeded()) {\n+                        path.addAll(iresult.result.path);\n+                    }\n+                    // raycast ends on poly boundary and the path might include the next poly boundary.\n+                    if (path.get(path.size() - 1) == next.id) {\n+                        path.remove(path.size() - 1); // remove to avoid duplicates\n+                    }\n+                } else {\n+                    path.add(node.id);\n+                }\n+\n+                node = next;\n+            } while (node != null);\n+        }\n+\n+        Status status = m_query.status;\n+        // Reset query.\n+        m_query = new QueryData();\n+\n+        return Result.of(status, path);\n+    }\n+    protected Result<float[]> getEdgeMidPoint(long from, Poly fromPoly, MeshTile fromTile, long to,\n+            Poly toPoly, MeshTile toTile) {\n+        Result<PortalResult> ppoints = getPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, 0, 0);\n+        if (ppoints.failed()) {\n+            return Result.of(ppoints.status, ppoints.message);\n+        }\n+        float[] left = ppoints.result.left;\n+        float[] right = ppoints.result.right;\n+        float[] mid = new float[3];\n+        mid[0] = (left[0] + right[0]) * 0.5f;\n+        mid[1] = (left[1] + right[1]) * 0.5f;\n+        mid[2] = (left[2] + right[2]) * 0.5f;\n+        return Result.success(mid);\n+    }\n+\n+    /// Finalizes and returns the results of an incomplete sliced path query, returning the path to the furthest\n+    /// polygon on the existing path that was visited during the search.\n+    /// @param[in] existing An array of polygon references for the existing path.\n+    /// @param[in] existingSize The number of polygon in the @p existing array.\n+    /// @param[out] path An ordered list of polygon references representing the path. (Start to end.)\n+    /// [(polyRef) * @p pathCount]\n+    /// @returns The status flags for the query.\n+    @Override\n+    public Result<List<Long>> finalizeSlicedFindPathPartial(List<Long> existing) {\n+\n+        List<Long> path = new ArrayList<>(64);\n+        if (Objects.isNull(existing) || existing.size() <= 0) {\n+            return Result.failure(path);\n+        }\n+        if (m_query.status.isFailed()) {\n+            // Reset query.\n+            m_query = new QueryData();\n+            return Result.failure(path);\n+        }\n+        if (m_query.startRef == m_query.endRef) {\n+            // Special case: the search starts and ends at same poly.\n+            path.add(m_query.startRef);\n+        } else {\n+            // Find furthest existing node that was visited.\n+            Node prev = null;\n+            Node node = null;\n+            for (int i = existing.size() - 1; i >= 0; --i) {\n+                node = m_nodePool.findNode(existing.get(i));\n+                if (node != null) {\n+                    break;\n+                }\n+            }\n+\n+            if (node == null) {\n+                m_query.status = Status.PARTIAL_RESULT;\n+                node = m_query.lastBestNode;\n+            }\n+\n+            // Reverse the path.\n+            int prevRay = 0;\n+            do {\n+                Node next = m_nodePool.getNodeAtIdx(node.pidx);\n+                node.pidx = m_nodePool.getNodeIdx(prev);\n+                prev = node;\n+                int nextRay = node.flags & Node.DT_NODE_PARENT_DETACHED; // keep track of whether parent is not adjacent\n+                                                                         // (i.e. due to raycast shortcut)\n+                node.flags = (node.flags & ~Node.DT_NODE_PARENT_DETACHED) | prevRay; // and store it in the reversed\n+                                                                                     // path's node\n+                prevRay = nextRay;\n+                node = next;\n+            } while (node != null);\n+\n+            // Store path\n+            node = prev;\n+            do {\n+                Node next = m_nodePool.getNodeAtIdx(node.pidx);\n+                if ((node.flags & Node.DT_NODE_PARENT_DETACHED) != 0) {\n+                    Result<RaycastHit> iresult = raycast(node.id, node.pos, next.pos, m_query.filter, 0, 0);\n+                    if (iresult.succeeded()) {\n+                        path.addAll(iresult.result.path);\n+                    }\n+                    // raycast ends on poly boundary and the path might include the next poly boundary.\n+                    if (path.get(path.size() - 1) == next.id) {\n+                        path.remove(path.size() - 1); // remove to avoid duplicates\n+                    }\n+                } else {\n+                    path.add(node.id);\n+                }\n+\n+                node = next;\n+            } while (node != null);\n+        }\n+        Status status = m_query.status;\n+        // Reset query.\n+        m_query = new QueryData();\n+\n+        return Result.of(status, path);\n+    }\n+\n+    @Override\n+    public Result<FindDistanceToWallResult> findDistanceToWall(long startRef, float[] centerPos, float maxRadius,\n+            QueryFilter filter) {\n+\n+        // Validate input\n+        if (!m_nav.isValidPolyRef(startRef) || Objects.isNull(centerPos) || !vIsFinite(centerPos) || maxRadius < 0\n+                || !Float.isFinite(maxRadius) || Objects.isNull(filter)) {\n+            return Result.invalidParam();\n+        }\n+\n+        m_nodePool.clear();\n+        m_openList.clear();\n+\n+        Node startNode = m_nodePool.getNode(startRef);\n+        vCopy(startNode.pos, centerPos);\n+        startNode.pidx = 0;\n+        startNode.cost = 0;\n+        startNode.total = 0;\n+        startNode.id = startRef;\n+        startNode.flags = Node.DT_NODE_OPEN;\n+        m_openList.push(startNode);\n+\n+        float radiusSqr = sqr(maxRadius);\n+        float[] hitPos = new float[3];\n+        VectorPtr bestvj = null;\n+        VectorPtr bestvi = null;\n+        while (!m_openList.isEmpty()) {\n+            Node bestNode = m_openList.pop();\n+            bestNode.flags &= ~Node.DT_NODE_OPEN;\n+            bestNode.flags |= Node.DT_NODE_CLOSED;\n+\n+            // Get poly and tile.\n+            // The API input has been cheked already, skip checking internal data.\n+            long bestRef = bestNode.id;\n+            Tupple2<MeshTile, Poly> tileAndPoly = m_nav.getTileAndPolyByRefUnsafe(bestRef);\n+            MeshTile bestTile = tileAndPoly.first;\n+            Poly bestPoly = tileAndPoly.second;\n+\n+            // Get parent poly and tile.\n+            long parentRef = 0;\n+            if (bestNode.pidx != 0) {\n+                parentRef = m_nodePool.getNodeAtIdx(bestNode.pidx).id;\n+            }\n+\n+            // Hit test walls.\n+            for (int i = 0, j = bestPoly.vertCount - 1; i < bestPoly.vertCount; j = i++) {\n+                // Skip non-solid edges.\n+                if ((bestPoly.neis[j] & NavMesh.DT_EXT_LINK) != 0) {\n+                    // Tile border.\n+                    boolean solid = true;\n+                    for (int k = bestPoly.firstLink; k != NavMesh.DT_NULL_LINK; k = bestTile.links.get(k).next) {\n+                        Link link = bestTile.links.get(k);\n+                        if (link.edge == j) {\n+                            if (link.ref != 0) {\n+                                Tupple2<MeshTile, Poly> linkTileAndPoly = m_nav.getTileAndPolyByRefUnsafe(link.ref);\n+                                MeshTile neiTile = linkTileAndPoly.first;\n+                                Poly neiPoly = linkTileAndPoly.second;\n+                                if (filter.passFilter(link.ref, neiTile, neiPoly)) {\n+                                    solid = false;\n+                                }\n+                            }\n+                            break;\n+                        }\n+                    }\n+                    if (!solid) {\n+                        continue;\n+                    }\n+                } else if (bestPoly.neis[j] != 0) {\n+                    // Internal edge\n+                    int idx = (bestPoly.neis[j] - 1);\n+                    long ref = m_nav.getPolyRefBase(bestTile) | idx;\n+                    if (filter.passFilter(ref, bestTile, bestTile.data.polys[idx])) {\n+                        continue;\n+                    }\n+                }\n+\n+                // Calc distance to the edge.\n+                int vj = bestPoly.verts[j] * 3;\n+                int vi = bestPoly.verts[i] * 3;\n+                Tupple2<Float, Float> distseg = distancePtSegSqr2D(centerPos, bestTile.data.verts, vj, vi);\n+                float distSqr = distseg.first;\n+                float tseg = distseg.second;\n+\n+                // Edge is too far, skip.\n+                if (distSqr > radiusSqr) {\n+                    continue;\n+                }\n+\n+                // Hit wall, update radius.\n+                radiusSqr = distSqr;\n+                // Calculate hit pos.\n+                hitPos[0] = bestTile.data.verts[vj] + (bestTile.data.verts[vi] - bestTile.data.verts[vj]) * tseg;\n+                hitPos[1] = bestTile.data.verts[vj + 1]\n+                        + (bestTile.data.verts[vi + 1] - bestTile.data.verts[vj + 1]) * tseg;\n+                hitPos[2] = bestTile.data.verts[vj + 2]\n+                        + (bestTile.data.verts[vi + 2] - bestTile.data.verts[vj + 2]) * tseg;\n+                bestvj = new VectorPtr(bestTile.data.verts, vj);\n+                bestvi = new VectorPtr(bestTile.data.verts, vi);\n+            }\n+\n+            for (int i = bestPoly.firstLink; i != NavMesh.DT_NULL_LINK; i = bestTile.links.get(i).next) {\n+                Link link = bestTile.links.get(i);\n+                long neighbourRef = link.ref;\n+                // Skip invalid neighbours and do not follow back to parent.\n+                if (neighbourRef == 0 || neighbourRef == parentRef) {\n+                    continue;\n+                }\n+\n+                // Expand to neighbour.\n+                Tupple2<MeshTile, Poly> neighbourTileAndPoly = m_nav.getTileAndPolyByRefUnsafe(neighbourRef);\n+                MeshTile neighbourTile = neighbourTileAndPoly.first;\n+                Poly neighbourPoly = neighbourTileAndPoly.second;\n+\n+                // Skip off-mesh connections.\n+                if (neighbourPoly.getType() == Poly.DT_POLYTYPE_OFFMESH_CONNECTION) {\n+                    continue;\n+                }\n+\n+                // Calc distance to the edge.\n+                int va = bestPoly.verts[link.edge] * 3;\n+                int vb = bestPoly.verts[(link.edge + 1) % bestPoly.vertCount] * 3;\n+                Tupple2<Float, Float> distseg = distancePtSegSqr2D(centerPos, bestTile.data.verts, va, vb);\n+                float distSqr = distseg.first;\n+                // If the circle is not touching the next polygon, skip it.\n+                if (distSqr > radiusSqr) {\n+                    continue;\n+                }\n+\n+                if (!filter.passFilter(neighbourRef, neighbourTile, neighbourPoly)) {\n+                    continue;\n+                }\n+\n+                Node neighbourNode = m_nodePool.getNode(neighbourRef);\n+\n+                if ((neighbourNode.flags & Node.DT_NODE_CLOSED) != 0) {\n+                    continue;\n+                }\n+\n+                // Cost\n+                if (neighbourNode.flags == 0) {\n+                    Result<float[]> midPoint = getEdgeMidPoint(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly,\n+                            neighbourTile);\n+                    if (midPoint.succeeded()) {\n+                        neighbourNode.pos = midPoint.result;\n+                    }\n+                }\n+\n+                float total = bestNode.total + vDist(bestNode.pos, neighbourNode.pos);\n+\n+                // The node is already in open list and the new result is worse, skip.\n+                if ((neighbourNode.flags & Node.DT_NODE_OPEN) != 0 && total >= neighbourNode.total) {\n+                    continue;\n+                }\n+\n+                neighbourNode.id = neighbourRef;\n+                neighbourNode.flags = (neighbourNode.flags & ~Node.DT_NODE_CLOSED);\n+                neighbourNode.pidx = m_nodePool.getNodeIdx(bestNode);\n+                neighbourNode.total = total;\n+\n+                if ((neighbourNode.flags & Node.DT_NODE_OPEN) != 0) {\n+                    m_openList.modify(neighbourNode);\n+                } else {\n+                    neighbourNode.flags |= Node.DT_NODE_OPEN;\n+                    m_openList.push(neighbourNode);\n+                }\n+            }\n+        }\n+\n+        // Calc hit normal.\n+        float[] hitNormal = new float[3];\n+        if (bestvi != null && bestvj != null) {\n+            float[] tangent = vSub(bestvi, bestvj);\n+            hitNormal[0] = tangent[2];\n+            hitNormal[1] = 0;\n+            hitNormal[2] = -tangent[0];\n+            vNormalize(hitNormal);\n+        }\n+        return Result.success(new FindDistanceToWallResult((float) Math.sqrt(radiusSqr), hitPos, hitNormal));\n+    }\n+}"
  },
  {
    "sha": "3a4aa57362acdef51ee5f5c378e47892fec82b32",
    "filename": "detour/src/main/java/org/recast4j/detour/NavMeshQuery.java",
    "status": "modified",
    "additions": 64,
    "deletions": 79,
    "changes": 143,
    "blob_url": "https://github.com/ppiastucki/recast4j/blob/d3d279fef1f6267818e437fd4da4ad6848f93df9/detour/src/main/java/org/recast4j/detour/NavMeshQuery.java",
    "raw_url": "https://github.com/ppiastucki/recast4j/raw/d3d279fef1f6267818e437fd4da4ad6848f93df9/detour/src/main/java/org/recast4j/detour/NavMeshQuery.java",
    "contents_url": "https://api.github.com/repos/ppiastucki/recast4j/contents/detour/src/main/java/org/recast4j/detour/NavMeshQuery.java?ref=d3d279fef1f6267818e437fd4da4ad6848f93df9",
    "patch": "@@ -18,6 +18,7 @@ recast4j copyright (c) 2015-2019 Piotr Piastucki piotr@jtilia.org\n */\n package org.recast4j.detour;\n \n+import static org.recast4j.detour.DetourCommon.EPS;\n import static org.recast4j.detour.DetourCommon.clamp;\n import static org.recast4j.detour.DetourCommon.distancePtPolyEdgesSqr;\n import static org.recast4j.detour.DetourCommon.distancePtSegSqr2D;\n@@ -81,11 +82,11 @@ recast4j copyright (c) 2015-2019 Piotr Piastucki piotr@jtilia.org\n \n     static float H_SCALE = 0.999f; // Search heuristic scale.\n \n-    private final NavMesh m_nav;\n-    private final NodePool m_nodePool;\n+    protected final NavMesh m_nav;\n+    protected final NodePool m_nodePool;\n     private final NodePool m_tinyNodePool;\n-    private final NodeQueue m_openList;\n-    private QueryData m_query; /// < Sliced query state.\n+    protected final NodeQueue m_openList;\n+    protected QueryData m_query; /// < Sliced query state.\n \n     public NavMeshQuery(NavMesh nav) {\n         m_nav = nav;\n@@ -285,11 +286,6 @@ public float frand() {\n             if (bestNode.pidx != 0) {\n                 parentRef = m_nodePool.getNodeAtIdx(bestNode.pidx).id;\n             }\n-            if (parentRef != 0) {\n-                Tupple2<MeshTile, Poly> parentTilePoly = m_nav.getTileAndPolyByRefUnsafe(parentRef);\n-                MeshTile parentTile = parentTilePoly.first;\n-                Poly parentPoly = parentTilePoly.second;\n-            }\n \n             for (int i = bestPoly.firstLink; i != NavMesh.DT_NULL_LINK; i = bestTile.links.get(i).next) {\n                 Link link = bestTile.links.get(i);\n@@ -743,44 +739,39 @@ public Status queryPolygons(float[] center, float[] halfExtents, QueryFilter fil\n                     continue;\n                 }\n \n-                // deal explicitly with crossing tile boundaries\n-                int crossSide = 0;\n-                if (bestTile.links.get(i).side != 0xff) {\n-                    crossSide = bestTile.links.get(i).side >> 1;\n-                }\n-\n                 // get the node\n-                Node neighbourNode = m_nodePool.getNode(neighbourRef, crossSide);\n+                Node neighbourNode = m_nodePool.getNode(neighbourRef, 0);\n+\n+                // do not expand to nodes that were already visited from the\n+                // same parent\n+                if (neighbourNode.pidx != 0 && neighbourNode.pidx == bestNode.pidx) {\n+                    continue;\n+                }\n \n                 // If the node is visited the first time, calculate node position.\n-                if (neighbourNode.flags == 0) {\n-                    Result<float[]> midpod = getEdgeMidPoint(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly,\n-                            neighbourTile);\n-                    if (!midpod.failed()) {\n-                        neighbourNode.pos = midpod.result;\n-                    }\n+                float[] neighbourPos = neighbourNode.pos;\n+                Result<float[]> midpod = getEdgeMidPoint(bestNode.pos, bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly,\n+                        neighbourTile);\n+                if (!midpod.failed()) {\n+                    neighbourPos = midpod.result;\n                 }\n \n                 // Calculate cost and heuristic.\n                 float cost = 0;\n-                float heuristic = 0;\n+                float curCost = filter.getCost(bestNode.pos, neighbourPos, parentRef, parentTile, parentPoly,\n+                        bestRef, bestTile, bestPoly, neighbourRef, neighbourTile, neighbourPoly);\n+                cost = bestNode.cost + curCost;\n \n+                float heuristic = 0;\n                 // Special case for last node.\n                 if (neighbourRef == endRef) {\n                     // Cost\n-                    float curCost = filter.getCost(bestNode.pos, neighbourNode.pos, parentRef, parentTile, parentPoly,\n-                            bestRef, bestTile, bestPoly, neighbourRef, neighbourTile, neighbourPoly);\n-                    float endCost = filter.getCost(neighbourNode.pos, endPos, bestRef, bestTile, bestPoly, neighbourRef,\n+                    float endCost = filter.getCost(neighbourPos, endPos, bestRef, bestTile, bestPoly, neighbourRef,\n                             neighbourTile, neighbourPoly, 0L, null, null);\n-\n-                    cost = bestNode.cost + curCost + endCost;\n-                    heuristic = 0;\n+                    cost = cost + endCost;\n                 } else {\n                     // Cost\n-                    float curCost = filter.getCost(bestNode.pos, neighbourNode.pos, parentRef, parentTile, parentPoly,\n-                            bestRef, bestTile, bestPoly, neighbourRef, neighbourTile, neighbourPoly);\n-                    cost = bestNode.cost + curCost;\n-                    heuristic = vDist(neighbourNode.pos, endPos) * H_SCALE;\n+                    heuristic = vDist(neighbourPos, endPos) * H_SCALE;\n                 }\n \n                 float total = cost + heuristic;\n@@ -800,6 +791,7 @@ public Status queryPolygons(float[] center, float[] halfExtents, QueryFilter fil\n                 neighbourNode.flags = (neighbourNode.flags & ~Node.DT_NODE_CLOSED);\n                 neighbourNode.cost = cost;\n                 neighbourNode.total = total;\n+                neighbourNode.pos = neighbourPos;\n \n                 if ((neighbourNode.flags & Node.DT_NODE_OPEN) != 0) {\n                     // Already in open, update node location.\n@@ -1010,12 +1002,11 @@ public Status initSlicedFindPath(long startRef, long endRef, float[] startPos, f\n \n                 // If the node is visited the first time, calculate node\n                 // position.\n-                if (neighbourNode.flags == 0) {\n-                    Result<float[]> midpod = getEdgeMidPoint(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly,\n-                            neighbourTile);\n-                    if (!midpod.failed()) {\n-                        neighbourNode.pos = midpod.result;\n-                    }\n+                float[] neighbourPos = neighbourNode.pos;\n+                Result<float[]> midpod = getEdgeMidPoint(bestNode.pos, bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly,\n+                        neighbourTile);\n+                if (!midpod.failed()) {\n+                    neighbourPos = midpod.result;\n                 }\n \n                 // Calculate cost and heuristic.\n@@ -1025,7 +1016,7 @@ public Status initSlicedFindPath(long startRef, long endRef, float[] startPos, f\n                 // raycast parent\n                 boolean foundShortCut = false;\n                 if (tryLOS) {\n-                    Result<RaycastHit> rayHit = raycast(parentRef, parentNode.pos, neighbourNode.pos, m_query.filter,\n+                    Result<RaycastHit> rayHit = raycast(parentRef, parentNode.pos, neighbourPos, m_query.filter,\n                             DT_RAYCAST_USE_COSTS, grandpaRef);\n                     if (rayHit.succeeded()) {\n                         foundShortCut = rayHit.result.t >= 1.0f;\n@@ -1040,20 +1031,20 @@ public Status initSlicedFindPath(long startRef, long endRef, float[] startPos, f\n                 // update move cost\n                 if (!foundShortCut) {\n                     // No shortcut found.\n-                    float curCost = m_query.filter.getCost(bestNode.pos, neighbourNode.pos, parentRef, parentTile,\n+                    float curCost = m_query.filter.getCost(bestNode.pos, neighbourPos, parentRef, parentTile,\n                             parentPoly, bestRef, bestTile, bestPoly, neighbourRef, neighbourTile, neighbourPoly);\n                     cost = bestNode.cost + curCost;\n                 }\n \n                 // Special case for last node.\n                 if (neighbourRef == m_query.endRef) {\n-                    float endCost = m_query.filter.getCost(neighbourNode.pos, m_query.endPos, bestRef, bestTile,\n+                    float endCost = m_query.filter.getCost(neighbourPos, m_query.endPos, bestRef, bestTile,\n                             bestPoly, neighbourRef, neighbourTile, neighbourPoly, 0, null, null);\n \n                     cost = cost + endCost;\n                     heuristic = 0;\n                 } else {\n-                    heuristic = vDist(neighbourNode.pos, m_query.endPos) * H_SCALE;\n+                    heuristic = vDist(neighbourPos, m_query.endPos) * H_SCALE;\n                 }\n \n                 float total = cost + heuristic;\n@@ -1075,6 +1066,7 @@ public Status initSlicedFindPath(long startRef, long endRef, float[] startPos, f\n                 neighbourNode.flags = (neighbourNode.flags & ~(Node.DT_NODE_CLOSED | Node.DT_NODE_PARENT_DETACHED));\n                 neighbourNode.cost = cost;\n                 neighbourNode.total = total;\n+                neighbourNode.pos = neighbourPos;\n                 if (foundShortCut) {\n                     neighbourNode.flags = (neighbourNode.flags | Node.DT_NODE_PARENT_DETACHED);\n                 }\n@@ -1808,22 +1800,7 @@ public PortalResult(float[] left, float[] right, int fromType, int toType) {\n         return Result.success(new PortalResult(left, right, fromType, toType));\n     }\n \n-    // Returns edge mid point between two polygons.\n-    protected Result<float[]> getEdgeMidPoint(long from, long to) {\n-        Result<PortalResult> ppoints = getPortalPoints(from, to);\n-        if (ppoints.failed()) {\n-            return Result.of(ppoints.status, ppoints.message);\n-        }\n-        float[] left = ppoints.result.left;\n-        float[] right = ppoints.result.right;\n-        float[] mid = new float[3];\n-        mid[0] = (left[0] + right[0]) * 0.5f;\n-        mid[1] = (left[1] + right[1]) * 0.5f;\n-        mid[2] = (left[2] + right[2]) * 0.5f;\n-        return Result.success(mid);\n-    }\n-\n-    protected Result<float[]> getEdgeMidPoint(long from, Poly fromPoly, MeshTile fromTile, long to, Poly toPoly,\n+    protected Result<float[]> getEdgeMidPoint(float[] fromPos, long from, Poly fromPoly, MeshTile fromTile, long to, Poly toPoly,\n             MeshTile toTile) {\n         Result<PortalResult> ppoints = getPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, 0, 0);\n         if (ppoints.failed()) {\n@@ -1832,9 +1809,24 @@ public PortalResult(float[] left, float[] right, int fromType, int toType) {\n         float[] left = ppoints.result.left;\n         float[] right = ppoints.result.right;\n         float[] mid = new float[3];\n-        mid[0] = (left[0] + right[0]) * 0.5f;\n-        mid[1] = (left[1] + right[1]) * 0.5f;\n-        mid[2] = (left[2] + right[2]) * 0.5f;\n+        float ex = right[0] - left[0];\n+        float ey = right[1] - left[1];\n+        float ez = right[2] - left[2];\n+        float e2 = ex * ex + ey * ey + ez * ez;\n+        if (e2 < EPS) {\n+            mid[0] = (left[0] + right[0]) * 0.5f;\n+            mid[1] = (left[1] + right[1]) * 0.5f;\n+            mid[2] = (left[2] + right[2]) * 0.5f;\n+        } else {\n+            float px = (fromPos[0] - left[0]) * ex;\n+            float py = (fromPos[1] - left[1]) * ey;\n+            float pz = (fromPos[2] - left[2]) * ez;\n+            float dot = (px + py + pz) / e2;\n+            dot = Math.max(0.05f, Math.min(dot, 0.95f));\n+            mid[0] = left[0] + ex * dot;\n+            mid[1] = left[1] + ey * dot;\n+            mid[2] = left[2] + ez * dot;\n+        }\n         return Result.success(mid);\n     }\n \n@@ -2301,9 +2293,9 @@ public PortalResult(float[] left, float[] right, int fromType, int toType) {\n     /// @param[out] resultCount The number of polygons found.\n     /// @param[in] maxResult The maximum number of polygons the result arrays can hold.\n     /// @returns The status flags for the query.\n-    public Result<FindPolysAroundResult> findPolysAroundShape(long startRef, float[] verts, int nverts,\n-            QueryFilter filter) {\n+    public Result<FindPolysAroundResult> findPolysAroundShape(long startRef, float[] verts, QueryFilter filter) {\n         // Validate input\n+        int nverts = verts.length / 3;\n         if (!m_nav.isValidPolyRef(startRef) || Objects.isNull(verts) || nverts < 3 || Objects.isNull(filter)) {\n             return Result.invalidParam();\n         }\n@@ -2813,16 +2805,9 @@ protected void insertInterval(List<SegInterval> ints, int tmin, int tmax, long r\n \n             // Get parent poly and tile.\n             long parentRef = 0;\n-            MeshTile parentTile = null;\n-            Poly parentPoly = null;\n             if (bestNode.pidx != 0) {\n                 parentRef = m_nodePool.getNodeAtIdx(bestNode.pidx).id;\n             }\n-            if (parentRef != 0) {\n-                tileAndPoly = m_nav.getTileAndPolyByRefUnsafe(parentRef);\n-                parentTile = tileAndPoly.first;\n-                parentPoly = tileAndPoly.second;\n-            }\n \n             // Hit test walls.\n             for (int i = 0, j = bestPoly.vertCount - 1; i < bestPoly.vertCount; j = i++) {\n@@ -2834,9 +2819,9 @@ protected void insertInterval(List<SegInterval> ints, int tmin, int tmax, long r\n                         Link link = bestTile.links.get(k);\n                         if (link.edge == j) {\n                             if (link.ref != 0) {\n-                                tileAndPoly = m_nav.getTileAndPolyByRefUnsafe(link.ref);\n-                                MeshTile neiTile = tileAndPoly.first;\n-                                Poly neiPoly = tileAndPoly.second;\n+                                Tupple2<MeshTile, Poly> linkTileAndPoly = m_nav.getTileAndPolyByRefUnsafe(link.ref);\n+                                MeshTile neiTile = linkTileAndPoly.first;\n+                                Poly neiPoly = linkTileAndPoly.second;\n                                 if (filter.passFilter(link.ref, neiTile, neiPoly)) {\n                                     solid = false;\n                                 }\n@@ -2889,9 +2874,9 @@ protected void insertInterval(List<SegInterval> ints, int tmin, int tmax, long r\n                 }\n \n                 // Expand to neighbour.\n-                tileAndPoly = m_nav.getTileAndPolyByRefUnsafe(neighbourRef);\n-                MeshTile neighbourTile = tileAndPoly.first;\n-                Poly neighbourPoly = tileAndPoly.second;\n+                Tupple2<MeshTile, Poly> neighbourTileAndPoly = m_nav.getTileAndPolyByRefUnsafe(neighbourRef);\n+                MeshTile neighbourTile = neighbourTileAndPoly.first;\n+                Poly neighbourPoly = neighbourTileAndPoly.second;\n \n                 // Skip off-mesh connections.\n                 if (neighbourPoly.getType() == Poly.DT_POLYTYPE_OFFMESH_CONNECTION) {\n@@ -2920,7 +2905,7 @@ protected void insertInterval(List<SegInterval> ints, int tmin, int tmax, long r\n \n                 // Cost\n                 if (neighbourNode.flags == 0) {\n-                    Result<float[]> midPoint = getEdgeMidPoint(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly,\n+                    Result<float[]> midPoint = getEdgeMidPoint(bestNode.pos, bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly,\n                             neighbourTile);\n                     if (midPoint.succeeded()) {\n                         neighbourNode.pos = midPoint.result;\n@@ -3009,7 +2994,7 @@ public NavMesh getAttachedNavMesh() {\n     /**\n      * Gets the path leading to the specified end node.\n      */\n-    private List<Long> getPathToNode(Node endNode) {\n+    protected List<Long> getPathToNode(Node endNode) {\n         List<Long> path = new ArrayList<>();\n         // Reverse the path.\n         Node curNode = endNode;"
  },
  {
    "sha": "c19eb695adbf2269cb35c7f27bb695473a3ba314",
    "filename": "detour/src/test/java/org/recast4j/detour/AbstractDetourTest.java",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/ppiastucki/recast4j/blob/d3d279fef1f6267818e437fd4da4ad6848f93df9/detour/src/test/java/org/recast4j/detour/AbstractDetourTest.java",
    "raw_url": "https://github.com/ppiastucki/recast4j/raw/d3d279fef1f6267818e437fd4da4ad6848f93df9/detour/src/test/java/org/recast4j/detour/AbstractDetourTest.java",
    "contents_url": "https://api.github.com/repos/ppiastucki/recast4j/contents/detour/src/test/java/org/recast4j/detour/AbstractDetourTest.java?ref=d3d279fef1f6267818e437fd4da4ad6848f93df9",
    "patch": "@@ -36,12 +36,14 @@ recast4j Copyright (c) 2015-2019 Piotr Piastucki piotr@jtilia.org\n             { 0.8635526f, 10.197294f, -10.31032f }, { 18.784092f, 10.197294f, 3.0543678f } };\n \n     protected NavMeshQuery query;\n+    protected LegacyNavMeshQuery legacyQuery;\n     protected NavMesh navmesh;\n \n     @Before\n     public void setUp() {\n         navmesh = createNavMesh();\n         query = new NavMeshQuery(navmesh);\n+        legacyQuery = new LegacyNavMeshQuery(navmesh);\n     }\n \n     protected NavMesh createNavMesh() {"
  },
  {
    "sha": "5bf48df408f1adec59dec177e958fb577ae22aca",
    "filename": "detour/src/test/java/org/recast4j/detour/FindDistanceToWallTest.java",
    "status": "modified",
    "additions": 21,
    "deletions": 1,
    "changes": 22,
    "blob_url": "https://github.com/ppiastucki/recast4j/blob/d3d279fef1f6267818e437fd4da4ad6848f93df9/detour/src/test/java/org/recast4j/detour/FindDistanceToWallTest.java",
    "raw_url": "https://github.com/ppiastucki/recast4j/raw/d3d279fef1f6267818e437fd4da4ad6848f93df9/detour/src/test/java/org/recast4j/detour/FindDistanceToWallTest.java",
    "contents_url": "https://api.github.com/repos/ppiastucki/recast4j/contents/detour/src/test/java/org/recast4j/detour/FindDistanceToWallTest.java?ref=d3d279fef1f6267818e437fd4da4ad6848f93df9",
    "patch": "@@ -27,6 +27,8 @@ recast4j Copyright (c) 2015-2019 Piotr Piastucki piotr@jtilia.org\n             { 18.108675f, 15.743596f, -73.236839f }, { 1.984785f, 10.197294f, -8.441269f },\n             { -22.315216f, 4.997294f, -11.441269f } };\n     float[][] hitNormal = { { -0.955779f, 0.0f, -0.29408592f }, { 0.0f, 0.0f, 1.0f },\n+            { 0.97014254f, 0.0f, 0.24253564f }, { -0.124032885f, 0.0f, 0.99227804f }, { 1.0f, 0.0f, 0.0f } };\n+    float[][] hitNormalLegacy = { { -0.955779f, 0.0f, -0.29408592f }, { 0.0f, 0.0f, 1.0f },\n             { 0.97014254f, 0.0f, 0.24253564f }, { -1.0f, 0.0f, 0.0f }, { 1.0f, 0.0f, 0.0f } };\n \n     @Test\n@@ -36,12 +38,30 @@ public void testFindDistanceToWall() {\n             float[] startPos = startPoss[i];\n             Result<FindDistanceToWallResult> result = query.findDistanceToWall(startRefs[i], startPos, 3.5f, filter);\n             FindDistanceToWallResult hit = result.result;\n+            Assert.assertEquals(distancesToWall[i], hit.getDistance(), 0.0001f);\n+            for (int v = 0; v < 3; v++) {\n+                Assert.assertEquals(hitPosition[i][v], hit.getPosition()[v], 0.0001f);\n+            }\n+            for (int v = 0; v < 3; v++) {\n+                Assert.assertEquals(hitNormal[i][v], hit.getNormal()[v], 0.0001f);\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testFindDistanceToWallLegacy() {\n+        QueryFilter filter = new DefaultQueryFilter();\n+        for (int i = 0; i < startRefs.length; i++) {\n+            float[] startPos = startPoss[i];\n+            Result<FindDistanceToWallResult> result = legacyQuery.findDistanceToWall(startRefs[i], startPos, 3.5f, filter);\n+            FindDistanceToWallResult hit = result.result;\n             Assert.assertEquals(distancesToWall[i], hit.getDistance(), 0.001f);\n             for (int v = 0; v < 3; v++) {\n                 Assert.assertEquals(hitPosition[i][v], hit.getPosition()[v], 0.001f);\n             }\n             for (int v = 0; v < 3; v++) {\n-                Assert.assertEquals(hitNormal[i][v], hit.getNormal()[v], 0.001f);\n+                Assert.assertEquals(hitNormalLegacy[i][v], hit.getNormal()[v], 0.001f);\n             }\n         }\n "
  },
  {
    "sha": "d993bea84121ef6b84946d768012d26e5f62af07",
    "filename": "detour/src/test/java/org/recast4j/detour/FindPolysAroundShapeTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/ppiastucki/recast4j/blob/d3d279fef1f6267818e437fd4da4ad6848f93df9/detour/src/test/java/org/recast4j/detour/FindPolysAroundShapeTest.java",
    "raw_url": "https://github.com/ppiastucki/recast4j/raw/d3d279fef1f6267818e437fd4da4ad6848f93df9/detour/src/test/java/org/recast4j/detour/FindPolysAroundShapeTest.java",
    "contents_url": "https://api.github.com/repos/ppiastucki/recast4j/contents/detour/src/test/java/org/recast4j/detour/FindPolysAroundShapeTest.java?ref=d3d279fef1f6267818e437fd4da4ad6848f93df9",
    "patch": "@@ -87,7 +87,7 @@ public void testFindPolysAroundShape() {\n             long startRef = startRefs[i];\n             float[] startPos = startPoss[i];\n             Result<FindPolysAroundResult> polys = query.findPolysAroundShape(startRef,\n-                    getQueryPoly(startPos, endPoss[i]), 4, filter);\n+                    getQueryPoly(startPos, endPoss[i]), filter);\n             Assert.assertEquals(refs[i].length, polys.result.getRefs().size());\n             for (int v = 0; v < refs[i].length; v++) {\n                 boolean found = false;"
  },
  {
    "sha": "2d8c53bdca17b05ba533239a19d68c707849b717",
    "filename": "detour/src/test/java/org/recast4j/detour/TiledFindPathTest.java",
    "status": "modified",
    "additions": 26,
    "deletions": 1,
    "changes": 27,
    "blob_url": "https://github.com/ppiastucki/recast4j/blob/d3d279fef1f6267818e437fd4da4ad6848f93df9/detour/src/test/java/org/recast4j/detour/TiledFindPathTest.java",
    "raw_url": "https://github.com/ppiastucki/recast4j/raw/d3d279fef1f6267818e437fd4da4ad6848f93df9/detour/src/test/java/org/recast4j/detour/TiledFindPathTest.java",
    "contents_url": "https://api.github.com/repos/ppiastucki/recast4j/contents/detour/src/test/java/org/recast4j/detour/TiledFindPathTest.java?ref=d3d279fef1f6267818e437fd4da4ad6848f93df9",
    "patch": "@@ -26,7 +26,13 @@ recast4j Copyright (c) 2015-2019 Piotr Piastucki piotr@jtilia.org\n public class TiledFindPathTest {\n \n     private final Status[] statuses = { Status.SUCCSESS };\n-    private final long[][] results = { { 281475015507969L, 281475014459393L, 281475014459392L, 281475013410816L,\n+    private final long[][] results = { { 281475015507969L, 281475014459393L, 281475014459392L, 281475006070784L,\n+            281475005022208L, 281475003973636L, 281475012362240L, 281475012362241L, 281475012362242L, 281475003973634L,\n+            281475003973635L, 281475003973633L, 281475002925059L, 281475002925057L, 281475002925056L, 281474998730753L,\n+            281474998730754L, 281474994536450L, 281474994536451L, 281474994536452L, 281474994536448L, 281474990342146L,\n+            281474990342145L, 281474991390723L, 281474991390724L, 281474991390725L, 281474987196418L, 281474987196417L,\n+            281474988244996L, 281474988244995L, 281474988244997L, 281474985099266L } };\n+    private final long[][] resultsLegacy = { { 281475015507969L, 281475014459393L, 281475014459392L, 281475013410816L,\n             281475012362240L, 281475012362241L, 281475012362242L, 281475003973634L, 281475003973635L, 281475003973633L,\n             281475002925059L, 281475002925057L, 281475002925056L, 281474998730753L, 281474998730754L, 281474994536450L,\n             281474994536451L, 281474994536452L, 281474994536448L, 281474990342146L, 281474990342145L, 281474991390723L,\n@@ -39,11 +45,13 @@ recast4j Copyright (c) 2015-2019 Piotr Piastucki piotr@jtilia.org\n \n     protected NavMeshQuery query;\n     protected NavMesh navmesh;\n+    private LegacyNavMeshQuery legacyQuery;\n \n     @Before\n     public void setUp() {\n         navmesh = createNavMesh();\n         query = new NavMeshQuery(navmesh);\n+        legacyQuery = new LegacyNavMeshQuery(navmesh);\n     }\n \n     protected NavMesh createNavMesh() {\n@@ -66,4 +74,21 @@ public void testFindPath() {\n             }\n         }\n     }\n+\n+    @Test\n+    public void testFindPathLegacy() {\n+        QueryFilter filter = new DefaultQueryFilter();\n+        for (int i = 0; i < startRefs.length; i++) {\n+            long startRef = startRefs[i];\n+            long endRef = endRefs[i];\n+            float[] startPos = startPoss[i];\n+            float[] endPos = endPoss[i];\n+            Result<List<Long>> path = legacyQuery.findPath(startRef, endRef, startPos, endPos, filter);\n+            Assert.assertEquals(statuses[i], path.status);\n+            Assert.assertEquals(resultsLegacy[i].length, path.result.size());\n+            for (int j = 0; j < resultsLegacy[i].length; j++) {\n+                Assert.assertEquals(resultsLegacy[i][j], path.result.get(j).longValue());\n+            }\n+        }\n+    }\n }"
  },
  {
    "sha": "15a69059bec208c5ca8607336f885918a98e2335",
    "filename": "recast-demo/src/main/java/org/recast4j/demo/tool/TestNavmeshTool.java",
    "status": "modified",
    "additions": 1,
    "deletions": 2,
    "changes": 3,
    "blob_url": "https://github.com/ppiastucki/recast4j/blob/d3d279fef1f6267818e437fd4da4ad6848f93df9/recast-demo/src/main/java/org/recast4j/demo/tool/TestNavmeshTool.java",
    "raw_url": "https://github.com/ppiastucki/recast4j/raw/d3d279fef1f6267818e437fd4da4ad6848f93df9/recast-demo/src/main/java/org/recast4j/demo/tool/TestNavmeshTool.java",
    "contents_url": "https://api.github.com/repos/ppiastucki/recast4j/contents/recast-demo/src/main/java/org/recast4j/demo/tool/TestNavmeshTool.java?ref=d3d279fef1f6267818e437fd4da4ad6848f93df9",
    "patch": "@@ -456,8 +456,7 @@ private void recalc() {\n                 m_queryPoly[10] = m_epos[1] + agentHeight / 2;\n                 m_queryPoly[11] = m_epos[2] + nz;\n \n-                Result<FindPolysAroundResult> result = m_navQuery.findPolysAroundShape(m_startRef, m_queryPoly, 4,\n-                        m_filter);\n+                Result<FindPolysAroundResult> result = m_navQuery.findPolysAroundShape(m_startRef, m_queryPoly, m_filter);\n                 if (result.succeeded()) {\n                     m_polys = result.result.getRefs();\n                     m_parent = result.result.getParentRefs();"
  }
]
