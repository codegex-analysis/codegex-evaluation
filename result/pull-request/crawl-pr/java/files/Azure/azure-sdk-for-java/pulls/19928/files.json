[
  {
    "sha": "6325876265d49e7b290c9b81988618db04c453be",
    "filename": "eng/versioning/version_client.txt",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/eng/versioning/version_client.txt",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/eng/versioning/version_client.txt",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/eng/versioning/version_client.txt?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -222,6 +222,7 @@ com.azure.resourcemanager:azure-resourcemanager-resourcegraph;1.0.0-beta.1;1.0.0\n # unreleased_<groupId>:<artifactId>;dependency-version\n # note: The unreleased dependencies will not be manipulated with the automatic PR creation code.\n unreleased_com.azure:azure-core;1.15.0-beta.1\n+unreleased_com.azure:azure-core-amqp;2.1.0-beta.1\n \n # Released Beta dependencies: Copy the entry from above, prepend \"beta_\", remove the current\n # version and set the version to the released beta. Released beta dependencies are only valid"
  },
  {
    "sha": "243fb54ea52525b63b659c75ac01bbca5f6fa78b",
    "filename": "sdk/core/azure-core-amqp/pom.xml",
    "status": "modified",
    "additions": 10,
    "deletions": 10,
    "changes": 20,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/pom.xml",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/pom.xml",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/pom.xml?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -134,16 +134,16 @@\n         </configuration>\n       </plugin>\n \n-<!--      <plugin>-->\n-<!--        <groupId>org.apache.maven.plugins</groupId>-->\n-<!--        <artifactId>maven-compiler-plugin</artifactId>-->\n-<!--        <version>3.8.1</version> &lt;!&ndash; {x-version-update;org.apache.maven.plugins:maven-compiler-plugin;external_dependency} &ndash;&gt;-->\n-<!--        <configuration>-->\n-<!--          <compilerArgs>-->\n-<!--            <arg>-Xlint:deprecation</arg>-->\n-<!--          </compilerArgs>-->\n-<!--        </configuration>-->\n-<!--      </plugin>-->\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>3.8.1</version> <!-- {x-version-update;org.apache.maven.plugins:maven-compiler-plugin;external_dependency} -->\n+        <configuration>\n+          <compilerArgs>\n+            <arg>-Xlint:deprecation</arg>\n+          </compilerArgs>\n+        </configuration>\n+      </plugin>\n     </plugins>\n   </build>\n "
  },
  {
    "sha": "a74a380dd562b42573208e9ebc20980c1dd4326f",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ActiveClientTokenManager.java",
    "status": "modified",
    "additions": 55,
    "deletions": 20,
    "changes": 75,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ActiveClientTokenManager.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ActiveClientTokenManager.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ActiveClientTokenManager.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -9,11 +9,9 @@\n import com.azure.core.exception.AzureException;\n import com.azure.core.util.logging.ClientLogger;\n import reactor.core.Disposable;\n-import reactor.core.publisher.EmitterProcessor;\n import reactor.core.publisher.Flux;\n-import reactor.core.publisher.FluxSink;\n import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n+import reactor.core.publisher.Sinks;\n \n import java.time.Duration;\n import java.time.OffsetDateTime;\n@@ -31,11 +29,8 @@\n     private final Mono<ClaimsBasedSecurityNode> cbsNode;\n     private final String tokenAudience;\n     private final String scopes;\n-    private final ReplayProcessor<AmqpResponseCode> authorizationResults = ReplayProcessor.create(1);\n-    private final FluxSink<AmqpResponseCode> authorizationResultsSink =\n-        authorizationResults.sink(FluxSink.OverflowStrategy.BUFFER);\n-    private final EmitterProcessor<Duration> durationSource = EmitterProcessor.create();\n-    private final FluxSink<Duration> durationSourceSink = durationSource.sink();\n+    private final Sinks.Many<AmqpResponseCode> authorizationResults = Sinks.many().replay().latest();\n+    private final Sinks.Many<Duration> durationSource = Sinks.many().multicast().onBackpressureBuffer();\n     private final AtomicReference<Duration> lastRefreshInterval = new AtomicReference<>(Duration.ofMinutes(1));\n \n     private volatile Disposable subscription;\n@@ -54,7 +49,7 @@ public ActiveClientTokenManager(Mono<ClaimsBasedSecurityNode> cbsNode, String to\n      */\n     @Override\n     public Flux<AmqpResponseCode> getAuthorizationResults() {\n-        return authorizationResults;\n+        return authorizationResults.asFlux();\n     }\n \n     /**\n@@ -85,7 +80,11 @@ public ActiveClientTokenManager(Mono<ClaimsBasedSecurityNode> cbsNode, String to\n \n                     final Duration firstInterval = Duration.ofMillis(refreshIntervalMS);\n                     lastRefreshInterval.set(firstInterval);\n-                    authorizationResultsSink.next(AmqpResponseCode.ACCEPTED);\n+                    authorizationResults.emitNext(AmqpResponseCode.ACCEPTED, (signalType, emitResult) -> {\n+                        logger.verbose(\"signalType[{}] result[{}] Could not emit ACCEPTED.\", signalType, emitResult);\n+                        return false;\n+                    });\n+\n                     subscription = scheduleRefreshTokenTask(firstInterval);\n                 }\n \n@@ -99,8 +98,14 @@ public void close() {\n             return;\n         }\n \n-        authorizationResultsSink.complete();\n-        durationSourceSink.complete();\n+        authorizationResults.emitComplete((signalType, emitResult) -> {\n+            logger.verbose(\"signalType[{}] result[{}] Could not close authorizationResults.\", signalType, emitResult);\n+            return false;\n+        });\n+        durationSource.emitComplete((signalType, emitResult) -> {\n+            logger.verbose(\"signalType[{}] result[{}] Could not close durationSource.\", signalType, emitResult);\n+            return false;\n+        });\n \n         if (subscription != null) {\n             subscription.dispose();\n@@ -109,9 +114,13 @@ public void close() {\n \n     private Disposable scheduleRefreshTokenTask(Duration initialRefresh) {\n         // EmitterProcessor can queue up an initial refresh interval before any subscribers are received.\n-        durationSourceSink.next(initialRefresh);\n+        durationSource.emitNext(initialRefresh, (signalType, emitResult) -> {\n+            logger.verbose(\"signalType[{}] result[{}] Could not emit initial refresh interval.\", signalType,\n+                emitResult);\n+            return false;\n+        });\n \n-        return Flux.switchOnNext(durationSource.map(Flux::interval))\n+        return Flux.switchOnNext(durationSource.asFlux().map(Flux::interval))\n             .flatMap(delay -> {\n                 logger.info(\"Refreshing token. scopes[{}] \", scopes);\n                 return authorize();\n@@ -123,15 +132,30 @@ private Disposable scheduleRefreshTokenTask(Duration initialRefresh) {\n \n                     logger.error(\"Error is transient. Rescheduling authorization task at interval {} ms. scopes[{}]\",\n                         lastRefresh.toMillis(), scopes, amqpException);\n-                    durationSourceSink.next(lastRefreshInterval.get());\n+                    durationSource.emitNext(lastRefresh, (signalType, emitResult) -> {\n+                        logger.verbose(\"signalType[{}] result[{}] Could not emit lastRefresh[{}].\", signalType,\n+                            emitResult, lastRefresh);\n+\n+                        return false;\n+                    });\n                 })\n             .subscribe(interval -> {\n-                logger.info(\"Authorization successful. Refreshing token in {} ms. scopes[{}]\", interval, scopes);\n-                authorizationResultsSink.next(AmqpResponseCode.ACCEPTED);\n+                logger.verbose(\"Authorization successful. Refreshing token in {} ms. scopes[{}]\", interval, scopes);\n+                authorizationResults.emitNext(AmqpResponseCode.ACCEPTED, (signalType, emitResult) -> {\n+                    logger.verbose(\"signalType[{}] result[{}] Could not emit ACCEPTED after refresh.\", signalType,\n+                        emitResult);\n+                    return false;\n+                });\n \n                 final Duration nextRefresh = Duration.ofMillis(interval);\n                 lastRefreshInterval.set(nextRefresh);\n-                durationSourceSink.next(Duration.ofMillis(interval));\n+\n+                durationSource.emitNext(nextRefresh, (signalType, emitResult) -> {\n+                    logger.verbose(\"signalType[{}] result[{}] Could not emit nextRefresh[{}].\", signalType,\n+                        emitResult, nextRefresh);\n+\n+                    return false;\n+                });\n             }, error -> {\n                     logger.error(\"Error occurred while refreshing token that is not retriable. Not scheduling\"\n                         + \" refresh task. Use ActiveClientTokenManager.authorize() to schedule task again. audience[{}]\"\n@@ -140,8 +164,19 @@ private Disposable scheduleRefreshTokenTask(Duration initialRefresh) {\n                     // This hasn't been disposed yet.\n                     if (!hasDisposed.getAndSet(true)) {\n                         hasScheduled.set(false);\n-                        durationSourceSink.complete();\n-                        authorizationResultsSink.error(error);\n+                        durationSource.emitComplete((signalType, emitResult) -> {\n+                            logger.verbose(\"signalType[{}] result[{}] Could not close durationSource.\", signalType,\n+                                emitResult);\n+\n+                            return false;\n+                        });\n+\n+                        authorizationResults.emitError(error, (signalType, emitResult) -> {\n+                            logger.verbose(\"signalType[{}] result[{}] Could not emit authorization error.\", signalType,\n+                                emitResult, error);\n+\n+                            return false;\n+                        });\n                     }\n                 });\n     }"
  },
  {
    "sha": "1bda86dce4bb6ef344a00fde166902d1ab2a1b20",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java",
    "status": "modified",
    "additions": 24,
    "deletions": 18,
    "changes": 42,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -22,11 +22,9 @@\n import org.apache.qpid.proton.message.Message;\n import org.apache.qpid.proton.reactor.Reactor;\n import reactor.core.Disposable;\n-import reactor.core.publisher.DirectProcessor;\n import reactor.core.publisher.Flux;\n-import reactor.core.publisher.FluxSink;\n import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n+import reactor.core.publisher.Sinks;\n import reactor.core.scheduler.Scheduler;\n import reactor.core.scheduler.Schedulers;\n \n@@ -48,9 +46,8 @@\n     private final ConcurrentMap<String, SessionSubscription> sessionMap = new ConcurrentHashMap<>();\n \n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final DirectProcessor<AmqpShutdownSignal> shutdownSignals = DirectProcessor.create();\n-    private final FluxSink<AmqpShutdownSignal> shutdownSignalsSink = shutdownSignals.sink();\n-    private final ReplayProcessor<AmqpEndpointState> endpointStates;\n+    private final Sinks.One<AmqpShutdownSignal> shutdownSignalSink = Sinks.one();\n+    private final Flux<AmqpEndpointState> endpointStates;\n \n     private final String connectionId;\n     private final Mono<Connection> connectionMono;\n@@ -104,11 +101,12 @@ public ReactorConnection(String connectionId, ConnectionOptions connectionOption\n         this.connectionMono = Mono.fromCallable(this::getOrCreateConnection);\n \n         this.endpointStates = this.handler.getEndpointStates()\n-            .takeUntilOther(shutdownSignals)\n+            .takeUntilOther(shutdownSignalSink.asMono())\n             .map(state -> {\n                 logger.verbose(\"connectionId[{}]: State {}\", connectionId, state);\n                 return AmqpEndpointStateUtil.getConnectionState(state);\n-            }).subscribeWith(ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED));\n+            })\n+            .cache(1);\n     }\n \n     /**\n@@ -121,7 +119,7 @@ public ReactorConnection(String connectionId, ConnectionOptions connectionOption\n \n     @Override\n     public Flux<AmqpShutdownSignal> getShutdownSignals() {\n-        return shutdownSignals;\n+        return shutdownSignalSink.asMono().cache().flux();\n     }\n \n     /**\n@@ -245,21 +243,26 @@ public boolean isDisposed() {\n     @Override\n     public void dispose() {\n         dispose(null);\n-        shutdownSignalsSink.next(new AmqpShutdownSignal(false, true,\n-            \"Disposed by client.\"));\n+        shutdownSignalSink.emitValue(new AmqpShutdownSignal(false, true,\n+            \"Disposed by client.\"),\n+            (signalType, emitResult) -> {\n+                logger.warning(\"connectionId[{}] signal[{}] result[{}] Could not emit shutdown signal for dispose()\"\n+                    + \" call.\", connectionId, signalType, emitResult);\n+                return false;\n+            });\n     }\n \n     void dispose(ErrorCondition errorCondition) {\n         if (isDisposed.getAndSet(true)) {\n             return;\n         }\n \n-        logger.info(\"connectionId[{}], errorCondition[{}]: Disposing of ReactorConnection.\", connectionId,\n+        logger.verbose(\"connectionId[{}], errorCondition[{}]: Disposing of ReactorConnection.\", connectionId,\n             errorCondition != null ? errorCondition : NOT_APPLICABLE);\n \n         final String[] keys = sessionMap.keySet().toArray(new String[0]);\n         for (String key : keys) {\n-            logger.info(\"connectionId[{}]: Removing session '{}'\", connectionId, key);\n+            logger.verbose(\"connectionId[{}]: Removing session '{}'\", connectionId, key);\n             removeSession(key, errorCondition);\n         }\n \n@@ -371,10 +374,9 @@ public void onConnectionError(Throwable exception) {\n             }\n \n             logger.warning(\n-                \"onReactorError connectionId[{}], hostName[{}], message[Starting new reactor], error[{}]\",\n+                \"onConnectionError connectionId[{}], hostName[{}], message[Starting new reactor], error[{}]\",\n                 getId(), getFullyQualifiedNamespace(), exception.getMessage());\n \n-            endpointStates.onError(exception);\n             ReactorConnection.this.dispose();\n         }\n \n@@ -386,11 +388,15 @@ void onConnectionShutdown(AmqpShutdownSignal shutdownSignal) {\n             }\n \n             logger.warning(\n-                \"onReactorError connectionId[{}], hostName[{}], message[Shutting down], shutdown signal[{}]\",\n+                \"onConnectionShutdown connectionId[{}], hostName[{}], message[Shutting down], shutdown signal[{}]\",\n                 getId(), getFullyQualifiedNamespace(), shutdownSignal.isInitiatedByClient(), shutdownSignal);\n \n-            dispose(new ErrorCondition(Symbol.getSymbol(\"onReactorError\"), shutdownSignal.toString()));\n-            shutdownSignalsSink.next(shutdownSignal);\n+            dispose(new ErrorCondition(Symbol.getSymbol(\"onConnectionShutdown\"), shutdownSignal.toString()));\n+            shutdownSignalSink.emitValue(shutdownSignal, (signalType, emitResult) -> {\n+                logger.warning(\"connectionId[{}] signal[{}] result[{}] onConnectionShutdown could not emit signal.\",\n+                    connectionId, signalType, emitResult);\n+                return false;\n+            });\n         }\n     }\n "
  },
  {
    "sha": "85f2240993bf907b579144aab0029b5abdacb837",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorReceiver.java",
    "status": "modified",
    "additions": 5,
    "deletions": 8,
    "changes": 13,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorReceiver.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorReceiver.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorReceiver.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -13,9 +13,7 @@\n import org.apache.qpid.proton.engine.Receiver;\n import org.apache.qpid.proton.message.Message;\n import reactor.core.Disposable;\n-import reactor.core.publisher.EmitterProcessor;\n import reactor.core.publisher.Flux;\n-import reactor.core.publisher.ReplayProcessor;\n \n import java.io.IOException;\n import java.util.Objects;\n@@ -38,9 +36,9 @@\n     private final ReactorDispatcher dispatcher;\n     private final Disposable subscriptions;\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final EmitterProcessor<Message> messagesProcessor;\n+    private final Flux<Message> messagesProcessor;\n     private final ClientLogger logger = new ClientLogger(ReactorReceiver.class);\n-    private final ReplayProcessor<AmqpEndpointState> endpointStates;\n+    private final Flux<AmqpEndpointState> endpointStates;\n \n     private final AtomicReference<Supplier<Integer>> creditSupplier = new AtomicReference<>();\n \n@@ -66,14 +64,15 @@ protected ReactorReceiver(String entityPath, Receiver receiver, ReceiveLinkHandl\n                     }\n                 }\n             })\n-            .subscribeWith(EmitterProcessor.create());\n+            .publish()\n+            .autoConnect();\n         this.endpointStates = this.handler.getEndpointStates()\n             .map(state -> {\n                 logger.verbose(\"connectionId[{}], path[{}], linkName[{}]: State {}\", handler.getConnectionId(),\n                     entityPath, getLinkName(), state);\n                 return AmqpEndpointStateUtil.getConnectionState(state);\n             })\n-            .subscribeWith(ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED));\n+            .cache(1);\n \n         this.subscriptions = this.tokenManager.getAuthorizationResults().subscribe(\n             response -> {\n@@ -150,7 +149,6 @@ public void dispose() {\n         }\n \n         subscriptions.dispose();\n-        messagesProcessor.onComplete();\n         tokenManager.close();\n         receiver.close();\n \n@@ -196,7 +194,6 @@ void dispose(ErrorCondition condition) {\n             handler.close();\n         }\n \n-        messagesProcessor.onComplete();\n         tokenManager.close();\n     }\n "
  },
  {
    "sha": "daa322dcab7b2a7eb6fa3c15aa2482b634f08c69",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -32,7 +32,6 @@\n import reactor.core.Disposables;\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n \n import java.io.IOException;\n import java.io.Serializable;\n@@ -76,7 +75,7 @@\n     private final PriorityQueue<WeightedDeliveryTag> pendingSendsQueue =\n         new PriorityQueue<>(1000, new DeliveryTagComparator());\n     private final ClientLogger logger = new ClientLogger(ReactorSender.class);\n-    private final ReplayProcessor<AmqpEndpointState> endpointStates;\n+    private final Flux<AmqpEndpointState> endpointStates;\n \n     private final TokenManager tokenManager;\n     private final MessageSerializer messageSerializer;\n@@ -112,7 +111,8 @@\n                     entityPath, getLinkName(), state);\n                 this.hasConnected.set(state == EndpointState.ACTIVE);\n                 return AmqpEndpointStateUtil.getConnectionState(state);\n-            }).subscribeWith(ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED));\n+            })\n+            .cache(1);\n \n         this.subscriptions = Disposables.composite(\n             this.handler.getDeliveredMessages().subscribe(this::processDeliveredMessage),"
  },
  {
    "sha": "83bf559e3b092be91b378a46284c667de550db9d",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java",
    "status": "modified",
    "additions": 2,
    "deletions": 3,
    "changes": 5,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -29,7 +29,6 @@\n import reactor.core.Disposable;\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n \n import java.io.IOException;\n import java.time.Duration;\n@@ -51,7 +50,7 @@\n \n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n     private final ClientLogger logger = new ClientLogger(ReactorSession.class);\n-    private final ReplayProcessor<AmqpEndpointState> endpointStates;\n+    private final Flux<AmqpEndpointState> endpointStates;\n \n     private final Session session;\n     private final SessionHandler sessionHandler;\n@@ -103,7 +102,7 @@ public ReactorSession(Session session, SessionHandler sessionHandler, String ses\n                     sessionName, state);\n                 return AmqpEndpointStateUtil.getConnectionState(state);\n             })\n-            .subscribeWith(ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED));\n+            .cache(1);\n \n         session.open();\n     }"
  },
  {
    "sha": "87b3720f87fbc67345f76f2bc7a827a5003ae0e1",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java",
    "status": "modified",
    "additions": 21,
    "deletions": 11,
    "changes": 32,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -28,10 +28,10 @@\n import reactor.core.Disposable;\n import reactor.core.Disposables;\n import reactor.core.publisher.Flux;\n-import reactor.core.publisher.FluxSink;\n import reactor.core.publisher.Mono;\n import reactor.core.publisher.MonoSink;\n-import reactor.core.publisher.ReplayProcessor;\n+import reactor.core.publisher.SignalType;\n+import reactor.core.publisher.Sinks;\n \n import java.io.IOException;\n import java.time.Duration;\n@@ -51,10 +51,7 @@\n     private final ConcurrentSkipListMap<UnsignedLong, MonoSink<Message>> unconfirmedSends =\n         new ConcurrentSkipListMap<>();\n     private final AtomicBoolean hasError = new AtomicBoolean();\n-    private final ReplayProcessor<AmqpEndpointState> endpointStates =\n-        ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED);\n-    private final FluxSink<AmqpEndpointState> endpointStatesSink =\n-        endpointStates.sink(FluxSink.OverflowStrategy.BUFFER);\n+    private final Sinks.Many<AmqpEndpointState> endpointStates = Sinks.many().multicast().onBackpressureBuffer();\n     private final ClientLogger logger = new ClientLogger(RequestResponseChannel.class);\n \n     private final Sender sendLink;\n@@ -144,11 +141,15 @@ protected RequestResponseChannel(String connectionId, String fullyQualifiedNames\n                 }),\n \n             receiveLinkHandler.getEndpointStates().subscribe(\n-                state -> endpointStatesSink.next(AmqpEndpointStateUtil.getConnectionState(state)),\n+                state -> endpointStates.emitNext(AmqpEndpointStateUtil.getConnectionState(state),\n+                    (signalType, emitResult) -> onEmitSinkFailure(signalType, emitResult,\n+                        \"ReceiveLinkHandler. Error emitting endpoint state.\")),\n                 this::handleError, this::dispose),\n \n-            sendLinkHandler.getEndpointStates().subscribe(state ->\n-                endpointStatesSink.next(AmqpEndpointStateUtil.getConnectionState(state)),\n+            sendLinkHandler.getEndpointStates().subscribe(\n+                state -> endpointStates.emitNext(AmqpEndpointStateUtil.getConnectionState(state),\n+                    (signalType, emitResult) -> onEmitSinkFailure(signalType, emitResult,\n+                        \"ReceiveLinkHandler. Error emitting endpoint state.\")),\n                 this::handleError, this::dispose)\n         );\n \n@@ -173,7 +174,7 @@ protected RequestResponseChannel(String connectionId, String fullyQualifiedNames\n      * @return The endpoint states for the request/response channel.\n      */\n     public Flux<AmqpEndpointState> getEndpointStates() {\n-        return endpointStates;\n+        return endpointStates.asFlux();\n     }\n \n     @Override\n@@ -314,12 +315,21 @@ private void handleError(Throwable error) {\n             return;\n         }\n \n-        endpointStatesSink.error(error);\n+        endpointStates.emitError(error,\n+            (signalType, emitResult) -> onEmitSinkFailure(signalType, emitResult,\n+                \"Could not emit error. \" + error));\n         logger.error(\"{} - Exception in RequestResponse links. Disposing and clearing unconfirmed sends.\", linkName,\n             error);\n         dispose();\n \n         unconfirmedSends.forEach((key, value) -> value.error(error));\n         unconfirmedSends.clear();\n     }\n+\n+    private boolean onEmitSinkFailure(SignalType signalType, Sinks.EmitResult emitResult, String message) {\n+        logger.verbose(\"connectionId[{}] linkName[{}] signal[{}] result[{}] {}\",\n+            connectionId, linkName, signalType, emitResult, message);\n+\n+        return false;\n+    }\n }"
  },
  {
    "sha": "f0fa5d77fd0c4276a5349299131dacd0f35bec48",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/ConnectionHandler.java",
    "status": "modified",
    "additions": 7,
    "deletions": 7,
    "changes": 14,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/ConnectionHandler.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/ConnectionHandler.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/ConnectionHandler.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -44,7 +44,6 @@\n     static final int MAX_FRAME_SIZE = 65536;\n \n     private final Map<String, Object> connectionProperties;\n-    private final ClientLogger logger = new ClientLogger(ConnectionHandler.class);\n     private final ConnectionOptions connectionOptions;\n     private final SslPeerDetails peerDetails;\n \n@@ -57,7 +56,8 @@\n     public ConnectionHandler(final String connectionId, final ConnectionOptions connectionOptions,\n         SslPeerDetails peerDetails) {\n         super(connectionId,\n-            Objects.requireNonNull(connectionOptions, \"'connectionOptions' cannot be null.\").getHostname());\n+            Objects.requireNonNull(connectionOptions, \"'connectionOptions' cannot be null.\").getHostname(),\n+            new ClientLogger(ConnectionHandler.class));\n         add(new Handshaker());\n \n         this.connectionOptions = connectionOptions;\n@@ -144,7 +144,7 @@ protected void addTransportLayers(Event event, TransportInternal transport) {\n             sslDomain.setSslContext(defaultSslContext);\n             sslDomain.setPeerAuthentication(SslDomain.VerifyMode.VERIFY_PEER);\n         } else if (verifyMode == SslDomain.VerifyMode.ANONYMOUS_PEER) {\n-            logger.warning(\"{} is not secure.\", verifyMode);\n+            logger.warning(\"connectionId[{}] '{}' is not secure.\", getConnectionId(), verifyMode);\n             sslDomain.setPeerAuthentication(SslDomain.VerifyMode.ANONYMOUS_PEER);\n         } else {\n             throw logger.logExceptionAsError(new UnsupportedOperationException(\n@@ -156,8 +156,8 @@ protected void addTransportLayers(Event event, TransportInternal transport) {\n \n     @Override\n     public void onConnectionInit(Event event) {\n-        logger.info(\"onConnectionInit hostname[{}], connectionId[{}], amqpHostname[{}]\", getHostname(),\n-            getConnectionId(), connectionOptions.getFullyQualifiedNamespace());\n+        logger.info(\"onConnectionInit connectionId[{}] hostname[{}] amqpHostname[{}]\",\n+            getConnectionId(), getHostname(), connectionOptions.getFullyQualifiedNamespace());\n \n         final Connection connection = event.getConnection();\n \n@@ -318,10 +318,10 @@ private void notifyErrorContext(Connection connection, ErrorCondition condition)\n     }\n \n     private void logErrorCondition(String eventName, Connection connection, ErrorCondition error) {\n-        logger.info(\"{} hostname[{}], connectionId[{}], errorCondition[{}], errorDescription[{}]\",\n+        logger.info(\"{} connectionId[{}] hostname[{}] errorCondition[{}] errorDescription[{}]\",\n             eventName,\n-            connection.getHostname(),\n             getConnectionId(),\n+            connection.getHostname(),\n             error != null ? error.getCondition() : ClientConstants.NOT_APPLICABLE,\n             error != null ? error.getDescription() : ClientConstants.NOT_APPLICABLE);\n     }"
  },
  {
    "sha": "6c7053c41aec232e725a80bb13b0c90703894791",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/DispatchHandler.java",
    "status": "modified",
    "additions": 0,
    "deletions": 1,
    "changes": 1,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/DispatchHandler.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/DispatchHandler.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/DispatchHandler.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -31,7 +31,6 @@ public DispatchHandler(Runnable work) {\n      */\n     @Override\n     public void onTimerTask(Event e) {\n-        logger.verbose(\"Running task for event: {}\", e);\n         this.work.run();\n     }\n }"
  },
  {
    "sha": "407272ed5d0490ea7f4b84cc402c17e986c552b9",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/Handler.java",
    "status": "modified",
    "additions": 28,
    "deletions": 12,
    "changes": 40,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/Handler.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/Handler.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/Handler.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -3,11 +3,11 @@\n \n package com.azure.core.amqp.implementation.handler;\n \n+import com.azure.core.util.logging.ClientLogger;\n import org.apache.qpid.proton.engine.BaseHandler;\n import org.apache.qpid.proton.engine.EndpointState;\n import reactor.core.publisher.Flux;\n-import reactor.core.publisher.FluxSink;\n-import reactor.core.publisher.ReplayProcessor;\n+import reactor.core.publisher.Sinks;\n \n import java.io.Closeable;\n import java.util.Objects;\n@@ -18,12 +18,13 @@\n  */\n public abstract class Handler extends BaseHandler implements Closeable {\n     private final AtomicBoolean isTerminal = new AtomicBoolean();\n-    private final ReplayProcessor<EndpointState> endpointStateProcessor =\n-        ReplayProcessor.cacheLastOrDefault(EndpointState.UNINITIALIZED);\n-    private final FluxSink<EndpointState> endpointSink = endpointStateProcessor.sink();\n+    private final Sinks.Many<EndpointState> endpointStates = Sinks.many().replay()\n+        .latestOrDefault(EndpointState.UNINITIALIZED);\n     private final String connectionId;\n     private final String hostname;\n \n+    final ClientLogger logger;\n+\n     /**\n      * Creates an instance with the parameters.\n      *\n@@ -32,11 +33,13 @@\n      *     connection. Usually of the form {@literal \"<your-namespace>.service.windows.net\"} but can change if the\n      *     messages are brokered through an intermediary.\n      *\n+     * @param logger\n      * @throws NullPointerException if {@code connectionId} or {@code hostname} is null.\n      */\n-    Handler(final String connectionId, final String hostname) {\n+    Handler(final String connectionId, final String hostname, ClientLogger logger) {\n         this.connectionId = Objects.requireNonNull(connectionId, \"'connectionId' cannot be null.\");\n         this.hostname = Objects.requireNonNull(hostname, \"'hostname' cannot be null.\");\n+        this.logger = logger;\n     }\n \n     /**\n@@ -65,20 +68,29 @@ public String getHostname() {\n      * @return The endpoint states of the handler.\n      */\n     public Flux<EndpointState> getEndpointStates() {\n-        return endpointStateProcessor.distinct();\n+        return endpointStates.asFlux().distinct();\n     }\n \n     void onNext(EndpointState state) {\n-        endpointSink.next(state);\n+        endpointStates.emitNext(state, (signalType, emitResult) -> {\n+            logger.warning(\"connectionId[{}] signal[{}] result[{}] could not emit endpoint state.\", connectionId,\n+                signalType, emitResult);\n+\n+            return false;\n+        });\n     }\n \n     void onError(Throwable error) {\n         if (isTerminal.getAndSet(true)) {\n             return;\n         }\n \n-        endpointSink.next(EndpointState.CLOSED);\n-        endpointSink.error(error);\n+        endpointStates.emitError(error, (signalType, emitResult) -> {\n+            logger.warning(\"connectionId[{}] signal[{}] result[{}] Could not emit error.\", connectionId,\n+                signalType, emitResult, error);\n+\n+            return false;\n+        });\n     }\n \n     /**\n@@ -91,7 +103,11 @@ public void close() {\n             return;\n         }\n \n-        endpointSink.next(EndpointState.CLOSED);\n-        endpointSink.complete();\n+        endpointStates.emitComplete((signalType, emitResult) -> {\n+            logger.warning(\"connectionId[{}] signal[{}] result[{}] Could not emit complete.\", connectionId,\n+                signalType, emitResult);\n+\n+            return false;\n+        });\n     }\n }"
  },
  {
    "sha": "244eb66361140c20bae490defba66140cfa386bd",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/LinkHandler.java",
    "status": "modified",
    "additions": 13,
    "deletions": 28,
    "changes": 41,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/LinkHandler.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/LinkHandler.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/LinkHandler.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -17,20 +17,18 @@\n \n abstract class LinkHandler extends Handler {\n     private final String entityPath;\n-    final ClientLogger logger;\n \n     LinkHandler(String connectionId, String hostname, String entityPath, ClientLogger logger) {\n-        super(connectionId, hostname);\n+        super(connectionId, hostname, logger);\n         this.entityPath = entityPath;\n-        this.logger = logger;\n     }\n \n     @Override\n     public void onLinkLocalClose(Event event) {\n         final Link link = event.getLink();\n         final ErrorCondition condition = link.getCondition();\n \n-        logger.info(\"onLinkLocalClose connectionId[{}], linkName[{}], errorCondition[{}], errorDescription[{}]\",\n+        logger.verbose(\"onLinkLocalClose connectionId[{}], linkName[{}], errorCondition[{}], errorDescription[{}]\",\n             getConnectionId(),\n             link.getName(),\n             condition != null ? condition.getCondition() : NOT_APPLICABLE,\n@@ -39,28 +37,12 @@ public void onLinkLocalClose(Event event) {\n \n     @Override\n     public void onLinkRemoteClose(Event event) {\n-        final Link link = event.getLink();\n-        final ErrorCondition condition = link.getRemoteCondition();\n-\n-        logger.info(\"onLinkRemoteClose connectionId[{}], linkName[{}], errorCondition[{}], errorDescription[{}]\",\n-            getConnectionId(), link.getName(),\n-            condition != null ? condition.getCondition() : NOT_APPLICABLE,\n-            condition != null ? condition.getDescription() : NOT_APPLICABLE);\n-\n-        handleRemoteLinkClosed(event);\n+        handleRemoteLinkClosed(\"onLinkRemoteClose\", event);\n     }\n \n     @Override\n     public void onLinkRemoteDetach(Event event) {\n-        final Link link = event.getLink();\n-        final ErrorCondition condition = link.getCondition();\n-\n-        logger.info(\"onLinkRemoteClose connectionId[{}], linkName[{}], errorCondition[{}], errorDescription[{}]\",\n-            getConnectionId(), link.getName(),\n-            condition != null ? condition.getCondition() : NOT_APPLICABLE,\n-            condition != null ? condition.getDescription() : NOT_APPLICABLE);\n-\n-        handleRemoteLinkClosed(event);\n+        handleRemoteLinkClosed(\"onLinkRemoteDetach\", event);\n     }\n \n     @Override\n@@ -83,20 +65,23 @@ public AmqpErrorContext getErrorContext(Link link) {\n         return new LinkErrorContext(getHostname(), entityPath, referenceId, link.getCredit());\n     }\n \n-    private void handleRemoteLinkClosed(final Event event) {\n+    private void handleRemoteLinkClosed(final String eventName, final Event event) {\n         final Link link = event.getLink();\n         final ErrorCondition condition = link.getRemoteCondition();\n \n+        logger.info(\"{} connectionId[{}] linkName[{}], errorCondition[{}] errorDescription[{}]\",\n+            eventName, getConnectionId(), link.getName(),\n+            condition != null ? condition.getCondition() : NOT_APPLICABLE,\n+            condition != null ? condition.getDescription() : NOT_APPLICABLE);\n+\n         if (link.getLocalState() != EndpointState.CLOSED) {\n+            logger.info(\"connectionId[{}] linkName[{}] state[{}] Local link state is not closed.\", getConnectionId(),\n+                link.getName(), link.getLocalState());\n+\n             link.setCondition(condition);\n             link.close();\n         }\n \n-        logger.info(\"processOnClose connectionId[{}], linkName[{}], errorCondition[{}], errorDescription[{}]\",\n-            getConnectionId(), link.getName(),\n-            condition != null ? condition.getCondition() : NOT_APPLICABLE,\n-            condition != null ? condition.getDescription() : NOT_APPLICABLE);\n-\n         if (condition != null && condition.getCondition() != null) {\n             final Throwable exception = ExceptionUtil.toException(condition.getCondition().toString(),\n                 condition.getDescription(), getErrorContext(link));"
  },
  {
    "sha": "bb4d141511aa064f829b2a90239843bbdc6521cf",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/ReceiveLinkHandler.java",
    "status": "modified",
    "additions": 21,
    "deletions": 11,
    "changes": 32,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/ReceiveLinkHandler.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/ReceiveLinkHandler.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/ReceiveLinkHandler.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -10,9 +10,8 @@\n import org.apache.qpid.proton.engine.Event;\n import org.apache.qpid.proton.engine.Link;\n import org.apache.qpid.proton.engine.Receiver;\n-import reactor.core.publisher.DirectProcessor;\n import reactor.core.publisher.Flux;\n-import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Sinks;\n \n import java.util.Collections;\n import java.util.Set;\n@@ -22,15 +21,12 @@\n public class ReceiveLinkHandler extends LinkHandler {\n     private final String linkName;\n     private final AtomicBoolean isFirstResponse = new AtomicBoolean(true);\n-    private final DirectProcessor<Delivery> deliveries;\n-    private final FluxSink<Delivery> deliverySink;\n+    private final Sinks.Many<Delivery> deliveries = Sinks.many().multicast().directBestEffort();\n     private final Set<Delivery> queuedDeliveries = Collections.newSetFromMap(new ConcurrentHashMap<>());\n     private final String entityPath;\n \n     public ReceiveLinkHandler(String connectionId, String hostname, String linkName, String entityPath) {\n         super(connectionId, hostname, entityPath, new ClientLogger(ReceiveLinkHandler.class));\n-        this.deliveries = DirectProcessor.create();\n-        this.deliverySink = deliveries.sink(FluxSink.OverflowStrategy.BUFFER);\n         this.linkName = linkName;\n         this.entityPath = entityPath;\n     }\n@@ -40,12 +36,17 @@ public String getLinkName() {\n     }\n \n     public Flux<Delivery> getDeliveredMessages() {\n-        return deliveries.doOnNext(delivery -> queuedDeliveries.remove(delivery));\n+        return deliveries.asFlux().doOnNext(delivery -> queuedDeliveries.remove(delivery));\n     }\n \n     @Override\n     public void close() {\n-        deliverySink.complete();\n+        deliveries.emitComplete((signalType, emitResult) -> {\n+            logger.verbose(\"connectionId[{}], entityPath[{}], linkName[{}] Could not emit complete.\",\n+                getConnectionId(), entityPath, linkName);\n+            return false;\n+        });\n+\n         super.close();\n \n         queuedDeliveries.forEach(delivery -> {\n@@ -60,7 +61,7 @@ public void close() {\n     public void onLinkLocalOpen(Event event) {\n         final Link link = event.getLink();\n         if (link instanceof Receiver) {\n-            logger.info(\"onLinkLocalOpen connectionId[{}], entityPath[{}], linkName[{}], localSource[{}]\",\n+            logger.verbose(\"onLinkLocalOpen connectionId[{}], entityPath[{}], linkName[{}], localSource[{}]\",\n                 getConnectionId(), entityPath, link.getName(), link.getSource());\n         }\n     }\n@@ -122,7 +123,11 @@ public void onDelivery(Event event) {\n                     delivery.settle();\n                 } else {\n                     queuedDeliveries.add(delivery);\n-                    deliverySink.next(delivery);\n+                    deliveries.emitNext(delivery, (signalType, emitResult) -> {\n+                        logger.warning(\"connectionId[{}], entityPath[{}], linkName[{}] Could not emit delivery. {}\",\n+                            getConnectionId(), entityPath, linkName, delivery);\n+                        return false;\n+                    });\n                 }\n             }\n         }\n@@ -137,7 +142,12 @@ public void onDelivery(Event event) {\n \n     @Override\n     public void onLinkRemoteClose(Event event) {\n-        deliverySink.complete();\n+        deliveries.emitComplete((signalType, emitResult) -> {\n+            logger.info(\"connectionId[{}] linkName[{}] signalType[{}] emitResult[{}] Could not complete 'deliveries'.\",\n+                getConnectionId(), linkName, signalType, emitResult);\n+            return false;\n+        });\n+\n         super.onLinkRemoteClose(event);\n     }\n }"
  },
  {
    "sha": "9ed999521ba09dcc40738650c8629674a214cab8",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/SendLinkHandler.java",
    "status": "modified",
    "additions": 31,
    "deletions": 16,
    "changes": 47,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/SendLinkHandler.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/SendLinkHandler.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/SendLinkHandler.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -9,10 +9,8 @@\n import org.apache.qpid.proton.engine.Event;\n import org.apache.qpid.proton.engine.Link;\n import org.apache.qpid.proton.engine.Sender;\n-import reactor.core.publisher.DirectProcessor;\n import reactor.core.publisher.Flux;\n-import reactor.core.publisher.FluxSink;\n-import reactor.core.publisher.UnicastProcessor;\n+import reactor.core.publisher.Sinks;\n \n import java.nio.charset.StandardCharsets;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -21,10 +19,8 @@\n     private final String linkName;\n     private final String entityPath;\n     private final AtomicBoolean isFirstFlow = new AtomicBoolean(true);\n-    private final UnicastProcessor<Integer> creditProcessor = UnicastProcessor.create();\n-    private final DirectProcessor<Delivery> deliveryProcessor = DirectProcessor.create();\n-    private final FluxSink<Integer> creditSink = creditProcessor.sink();\n-    private final FluxSink<Delivery> deliverySink = deliveryProcessor.sink();\n+    private final Sinks.Many<Integer> creditProcessor = Sinks.many().unicast().onBackpressureBuffer();\n+    private final Sinks.Many<Delivery> deliveryProcessor = Sinks.many().multicast().directBestEffort();\n \n     public SendLinkHandler(String connectionId, String hostname, String linkName, String entityPath) {\n         super(connectionId, hostname, entityPath, new ClientLogger(SendLinkHandler.class));\n@@ -37,17 +33,26 @@ public String getLinkName() {\n     }\n \n     public Flux<Integer> getLinkCredits() {\n-        return creditProcessor;\n+        return creditProcessor.asFlux();\n     }\n \n     public Flux<Delivery> getDeliveredMessages() {\n-        return deliveryProcessor;\n+        return deliveryProcessor.asFlux();\n     }\n \n     @Override\n     public void close() {\n-        creditSink.complete();\n-        deliverySink.complete();\n+        creditProcessor.emitComplete((signalType, emitResult) -> {\n+            logger.warning(\"connectionId[{}] linkName[{}] signal[{}] result[{}] Unable to complete creditProcessor.\",\n+                getConnectionId(), linkName, signalType, emitResult);\n+            return false;\n+        });\n+\n+        deliveryProcessor.emitComplete((signalType, emitResult) -> {\n+            logger.warning(\"connectionId[{}] linkName[{}] signal[{}] result[{}] Unable to complete deliveryProcessor.\",\n+                getConnectionId(), linkName, signalType, emitResult);\n+            return false;\n+        });\n         super.close();\n     }\n \n@@ -88,7 +93,12 @@ public void onLinkFlow(Event event) {\n         }\n \n         final Sender sender = event.getSender();\n-        creditSink.next(sender.getRemoteCredit());\n+        final int credits = sender.getRemoteCredit();\n+        creditProcessor.emitNext(credits, (signalType, emitResult) -> {\n+            logger.verbose(\"connectionId[{}] linkName[{}] signal[{}] result[{}] Unable to emit credits [{}].\",\n+                getConnectionId(), linkName, signalType, emitResult, credits);\n+            return false;\n+        });\n \n         logger.verbose(\"onLinkFlow connectionId[{}], entityPath[{}], linkName[{}], unsettled[{}], credit[{}]\",\n             getConnectionId(), entityPath, sender.getName(), sender.getUnsettled(), sender.getCredit());\n@@ -99,15 +109,20 @@ public void onDelivery(Event event) {\n         Delivery delivery = event.getDelivery();\n \n         while (delivery != null) {\n-            Sender sender = (Sender) delivery.getLink();\n+            final Sender sender = (Sender) delivery.getLink();\n+            final String deliveryTag = new String(delivery.getTag(), StandardCharsets.UTF_8);\n \n             logger.verbose(\"onDelivery connectionId[{}], entityPath[{}], linkName[{}], unsettled[{}], credit[{}],\"\n                     + \" deliveryState[{}], delivery.isBuffered[{}], delivery.id[{}]\",\n                 getConnectionId(), entityPath, sender.getName(), sender.getUnsettled(), sender.getRemoteCredit(),\n-                delivery.getRemoteState(), delivery.isBuffered(), new String(delivery.getTag(),\n-                    StandardCharsets.UTF_8));\n+                delivery.getRemoteState(), delivery.isBuffered(), deliveryTag);\n+\n+            deliveryProcessor.emitNext(delivery, (signalType, emitResult) -> {\n+                logger.warning(\"connectionId[{}] linkName[{}] signal[{}] result[{}] Unable to emit delivery [{}].\",\n+                    getConnectionId(), linkName, signalType, emitResult, deliveryTag);\n+                return false;\n+            });\n \n-            deliverySink.next(delivery);\n             delivery.settle();\n             delivery = sender.current();\n         }"
  },
  {
    "sha": "ae70253d0b3487a1cf4cc387878e648140c0846a",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/SessionHandler.java",
    "status": "modified",
    "additions": 1,
    "deletions": 3,
    "changes": 4,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/SessionHandler.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/SessionHandler.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/SessionHandler.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -20,15 +20,13 @@\n import java.util.Locale;\n \n public class SessionHandler extends Handler {\n-    private final ClientLogger logger = new ClientLogger(SessionHandler.class);\n-\n     private final String entityName;\n     private final Duration openTimeout;\n     private final ReactorDispatcher reactorDispatcher;\n \n     public SessionHandler(String connectionId, String hostname, String entityName, ReactorDispatcher reactorDispatcher,\n                           Duration openTimeout) {\n-        super(connectionId, hostname);\n+        super(connectionId, hostname, new ClientLogger(SessionHandler.class));\n         this.entityName = entityName;\n         this.openTimeout = openTimeout;\n         this.reactorDispatcher = reactorDispatcher;"
  },
  {
    "sha": "f53d96c3cf0585ff5e5464a9b85ffb19ce66279c",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ActiveClientTokenManagerTest.java",
    "status": "modified",
    "additions": 7,
    "deletions": 3,
    "changes": 10,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ActiveClientTokenManagerTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ActiveClientTokenManagerTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ActiveClientTokenManagerTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -36,6 +36,7 @@\n \n     @Mock\n     private ClaimsBasedSecurityNode cbsNode;\n+    private AutoCloseable mocksCloseable;\n \n     @BeforeAll\n     static void beforeAll() {\n@@ -49,13 +50,16 @@ static void afterAll() {\n \n     @BeforeEach\n     void setup() {\n-        MockitoAnnotations.initMocks(this);\n+        mocksCloseable = MockitoAnnotations.openMocks(this);\n     }\n \n     @AfterEach\n-    void teardown() {\n+    void teardown() throws Exception {\n         Mockito.framework().clearInlineMocks();\n-        cbsNode = null;\n+\n+        if (mocksCloseable != null) {\n+            mocksCloseable.close();\n+        }\n     }\n \n     /**"
  },
  {
    "sha": "7153896d0cb6194a5682b5682614bfb5f7601413",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/AmqpChannelProcessorTest.java",
    "status": "modified",
    "additions": 19,
    "deletions": 23,
    "changes": 42,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/AmqpChannelProcessorTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/AmqpChannelProcessorTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/AmqpChannelProcessorTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -22,7 +22,6 @@\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.FluxSink;\n import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n import reactor.test.StepVerifier;\n import reactor.test.publisher.TestPublisher;\n \n@@ -48,6 +47,7 @@\n     @Mock\n     private AmqpRetryPolicy retryPolicy;\n     private AmqpChannelProcessor<TestObject> channelProcessor;\n+    private AutoCloseable mocksCloseable;\n \n     @BeforeAll\n     static void beforeAll() {\n@@ -61,18 +61,22 @@ static void afterAll() {\n \n     @BeforeEach\n     void setup() {\n-        MockitoAnnotations.initMocks(this);\n+        mocksCloseable = MockitoAnnotations.openMocks(this);\n \n         channelProcessor = new AmqpChannelProcessor<>(\"connection-test\", \"test-path\",\n             TestObject::getStates, retryPolicy,\n             new ClientLogger(AmqpChannelProcessor.class + \"<TestObject>\"));\n     }\n \n     @AfterEach\n-    void teardown() {\n+    void teardown() throws Exception {\n         // Tear down any inline mocks to avoid memory leaks.\n         // https://github.com/mockito/mockito/wiki/What's-new-in-Mockito-2#mockito-2250\n         Mockito.framework().clearInlineMocks();\n+\n+        if (mocksCloseable != null) {\n+            mocksCloseable.close();\n+        }\n     }\n \n     /**\n@@ -126,17 +130,15 @@ void newConnectionOnClose() {\n         final AmqpChannelProcessor<TestObject> processor = publisher.next(connection1)\n             .flux().subscribeWith(channelProcessor);\n \n-        final FluxSink<AmqpEndpointState> endpointSink = connection1.getSink();\n-\n         // Act & Assert\n         // Verify that we get the first connection.\n         StepVerifier.create(processor)\n-            .then(() -> endpointSink.next(AmqpEndpointState.ACTIVE))\n+            .then(() -> connection1.getSink().next(AmqpEndpointState.ACTIVE))\n             .expectNext(connection1)\n             .verifyComplete();\n \n         // Close that connection.\n-        endpointSink.complete();\n+        connection1.getSink().complete();\n \n         // Expect that the next connection is returned to us.\n         StepVerifier.create(processor)\n@@ -216,7 +218,6 @@ void nonRetryableError() {\n         final TestPublisher<TestObject> publisher = TestPublisher.createCold();\n         final AmqpChannelProcessor<TestObject> processor = publisher.next(connection1).flux()\n             .subscribeWith(channelProcessor);\n-        final FluxSink<AmqpEndpointState> endpointSink = connection1.getSink();\n \n         /*\n          * Beginning in Mockito 3.4.0+ the default value for duration changed from null to Duration.ZERO\n@@ -226,12 +227,12 @@ void nonRetryableError() {\n         // Act & Assert\n         // Verify that we get the first connection.\n         StepVerifier.create(processor)\n-            .then(() -> endpointSink.next(AmqpEndpointState.ACTIVE))\n+            .then(() -> connection1.getSink().next(AmqpEndpointState.ACTIVE))\n             .expectNext(connection1)\n             .expectComplete()\n             .verify();\n \n-        endpointSink.error(amqpException);\n+        connection1.getSink().error(amqpException);\n \n         // Expect that the error is returned to us.\n         StepVerifier.create(processor)\n@@ -269,12 +270,11 @@ void errorsWhenResubscribingOnTerminated() {\n         final TestPublisher<TestObject> publisher = TestPublisher.createCold();\n         final AmqpChannelProcessor<TestObject> processor = publisher.next(connection1).flux()\n             .subscribeWith(channelProcessor);\n-        final FluxSink<AmqpEndpointState> endpointSink = connection1.getSink();\n \n         // Act & Assert\n         // Verify that we get the first connection.\n         StepVerifier.create(processor)\n-            .then(() -> endpointSink.next(AmqpEndpointState.ACTIVE))\n+            .then(() -> connection1.getSink().next(AmqpEndpointState.ACTIVE))\n             .expectNext(connection1)\n             .expectComplete()\n             .verify();\n@@ -291,15 +291,14 @@ void errorsWhenResubscribingOnTerminated() {\n     void doesNotEmitConnectionWhenNotActive() {\n         // Arrange\n         final TestPublisher<TestObject> publisher = TestPublisher.createCold();\n-        final FluxSink<AmqpEndpointState> endpointSink = connection1.getSink();\n \n         // Act & Assert\n         StepVerifier.withVirtualTime(() -> publisher.next(connection1).flux()\n             .subscribeWith(channelProcessor))\n             .expectSubscription()\n             .thenAwait(Duration.ofMinutes(10))\n             .expectNoEvent(Duration.ofMinutes(10))\n-            .then(() -> endpointSink.next(AmqpEndpointState.UNINITIALIZED))\n+            .then(() -> connection1.getSink().next(AmqpEndpointState.UNINITIALIZED))\n             .expectNoEvent(Duration.ofMinutes(10))\n             .thenCancel()\n             .verify();\n@@ -320,14 +319,13 @@ void requiresNonNull() {\n     void waitsLongPeriodOfTimeForConnection() {\n         // Arrange\n         final TestPublisher<TestObject> publisher = TestPublisher.createCold();\n-        final FluxSink<AmqpEndpointState> endpointSink = connection1.getSink();\n \n         // Act & Assert\n         StepVerifier.withVirtualTime(() -> publisher.next(connection1).flux()\n             .subscribeWith(channelProcessor))\n             .expectSubscription()\n             .thenAwait(Duration.ofMinutes(10))\n-            .then(() -> endpointSink.next(AmqpEndpointState.ACTIVE))\n+            .then(() -> connection1.getSink().next(AmqpEndpointState.ACTIVE))\n             .expectNext(connection1)\n             .verifyComplete();\n     }\n@@ -340,7 +338,6 @@ void waitsLongPeriodOfTimeForConnection() {\n     void waitsLongPeriodOfTimeForChainedConnections() {\n         // Arrange\n         final TestPublisher<TestObject> publisher = TestPublisher.createCold();\n-        final FluxSink<AmqpEndpointState> endpointSink = connection1.getSink();\n         final String contents = \"Emitted something after 10 minutes.\";\n \n         // Act & Assert\n@@ -350,7 +347,7 @@ void waitsLongPeriodOfTimeForChainedConnections() {\n         })\n             .expectSubscription()\n             .thenAwait(Duration.ofMinutes(10))\n-            .then(() -> endpointSink.next(AmqpEndpointState.ACTIVE))\n+            .then(() -> connection1.getSink().next(AmqpEndpointState.ACTIVE))\n             .expectNext(contents)\n             .verifyComplete();\n     }\n@@ -377,15 +374,14 @@ void waitsLongPeriodOfTimeForChainedConnections() {\n     }\n \n     static final class TestObject {\n-        private final ReplayProcessor<AmqpEndpointState> processor = ReplayProcessor.cacheLast();\n-        private final FluxSink<AmqpEndpointState> sink = processor.sink(FluxSink.OverflowStrategy.BUFFER);\n+        private final TestPublisher<AmqpEndpointState> processor = TestPublisher.createCold();\n \n         public Flux<AmqpEndpointState> getStates() {\n-            return processor;\n+            return processor.flux();\n         }\n \n-        public FluxSink<AmqpEndpointState> getSink() {\n-            return sink;\n+        public TestPublisher<AmqpEndpointState> getSink() {\n+            return processor;\n         }\n     }\n }"
  },
  {
    "sha": "8f3fb2bd5d5cb3ecae759a9134c3815c69896976",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/AzureTokenManagerProviderTest.java",
    "status": "modified",
    "additions": 7,
    "deletions": 2,
    "changes": 9,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/AzureTokenManagerProviderTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/AzureTokenManagerProviderTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/AzureTokenManagerProviderTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -31,15 +31,20 @@\n \n     @Mock\n     private ClaimsBasedSecurityNode cbsNode;\n+    private AutoCloseable mocksCloseable;\n \n     @BeforeEach\n     void setup() {\n-        MockitoAnnotations.initMocks(this);\n+        mocksCloseable = MockitoAnnotations.openMocks(this);\n     }\n \n     @AfterEach\n-    void teardown() {\n+    void teardown() throws Exception {\n         Mockito.framework().clearInlineMocks();\n+\n+        if (mocksCloseable != null) {\n+            mocksCloseable.close();\n+        }\n     }\n \n     @Test"
  },
  {
    "sha": "3cfb11b4d835f83c610b38ca7f8215ebc0a5c749",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ClaimsBasedSecurityChannelTest.java",
    "status": "modified",
    "additions": 7,
    "deletions": 2,
    "changes": 9,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ClaimsBasedSecurityChannelTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ClaimsBasedSecurityChannelTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ClaimsBasedSecurityChannelTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -67,6 +67,7 @@\n     private TokenCredential tokenCredential;\n     private Message acceptedResponse;\n     private Message unauthorizedResponse;\n+    private AutoCloseable mocksCloseable;\n \n     @BeforeAll\n     static void beforeAll() {\n@@ -80,7 +81,7 @@ static void afterAll() {\n \n     @BeforeEach\n     public void setup() {\n-        MockitoAnnotations.initMocks(this);\n+        mocksCloseable = MockitoAnnotations.openMocks(this);\n \n         acceptedResponse = Proton.message();\n         final Map<String, Object> responseProperties = new HashMap<>();\n@@ -95,10 +96,14 @@ public void setup() {\n     }\n \n     @AfterEach\n-    public void teardown() {\n+    public void teardown() throws Exception {\n         Mockito.framework().clearInlineMocks();\n         requestResponseChannel = null;\n         tokenCredential = null;\n+\n+        if (mocksCloseable != null) {\n+            mocksCloseable.close();\n+        }\n     }\n \n     /**"
  },
  {
    "sha": "e4ef8fef13c0d7e0a8d3c9610f56aedb43abf771",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ConnectionOptionsTest.java",
    "status": "modified",
    "additions": 10,
    "deletions": 1,
    "changes": 11,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ConnectionOptionsTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ConnectionOptionsTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ConnectionOptionsTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -10,6 +10,7 @@\n import com.azure.core.credential.TokenCredential;\n import com.azure.core.util.ClientOptions;\n import org.apache.qpid.proton.engine.SslDomain;\n+import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.mockito.Mock;\n@@ -27,10 +28,18 @@\n     private TokenCredential tokenCredential;\n     @Mock\n     private Scheduler scheduler;\n+    private AutoCloseable mocksCloseable;\n \n     @BeforeEach\n     public void beforeEach() {\n-        MockitoAnnotations.initMocks(this);\n+        mocksCloseable = MockitoAnnotations.openMocks(this);\n+    }\n+\n+    @AfterEach\n+    public void afterEach() throws Exception {\n+        if (mocksCloseable != null) {\n+            mocksCloseable.close();\n+        }\n     }\n \n     @Test"
  },
  {
    "sha": "66feb8bc8367f50a861cd108950f9d028f1b1648",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorConnectionTest.java",
    "status": "modified",
    "additions": 8,
    "deletions": 3,
    "changes": 11,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorConnectionTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorConnectionTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorConnectionTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -66,7 +66,7 @@\n         + \"://test-event-hub.servicebus.windows.net/;SharedAccessKeyName=dummySharedKeyName;\"\n         + \"SharedAccessKey=dummySharedKeyValue;EntityPath=eventhub1;\");\n     private static final String FULLY_QUALIFIED_NAMESPACE = CREDENTIAL_INFO.getEndpoint().getHost();\n-    private static final Scheduler SCHEDULER = Schedulers.elastic();\n+    private static final Scheduler SCHEDULER = Schedulers.boundedElastic();\n     private static final String PRODUCT = \"test\";\n     private static final String CLIENT_VERSION = \"1.0.0-test\";\n     private static final SslDomain.VerifyMode VERIFY_MODE = SslDomain.VerifyMode.VERIFY_PEER_NAME;\n@@ -100,6 +100,7 @@\n     private ReactorProvider reactorProvider;\n     @Mock\n     private ReactorHandlerProvider reactorHandlerProvider;\n+    private AutoCloseable mocksCloseable;\n \n     @BeforeAll\n     static void beforeAll() {\n@@ -113,7 +114,7 @@ static void afterAll() {\n \n     @BeforeEach\n     void setup() throws IOException {\n-        MockitoAnnotations.initMocks(this);\n+        mocksCloseable = MockitoAnnotations.openMocks(this);\n \n         final AmqpRetryOptions retryOptions = new AmqpRetryOptions().setMaxRetries(0).setTryTimeout(TEST_DURATION);\n         final ConnectionOptions connectionOptions = new ConnectionOptions(CREDENTIAL_INFO.getEndpoint().getHost(),\n@@ -147,11 +148,15 @@ void setup() throws IOException {\n     }\n \n     @AfterEach\n-    void teardown() {\n+    void teardown() throws Exception {\n         connection.dispose();\n         // Tear down any inline mocks to avoid memory leaks.\n         // https://github.com/mockito/mockito/wiki/What's-new-in-Mockito-2#mockito-2250\n         Mockito.framework().clearInlineMocks();\n+\n+        if (mocksCloseable != null) {\n+            mocksCloseable.close();\n+        }\n     }\n \n     /**"
  },
  {
    "sha": "404771c67a35eaf9b08ebe16aa256c3ea751c546",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorHandlerProviderTest.java",
    "status": "modified",
    "additions": 7,
    "deletions": 2,
    "changes": 9,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorHandlerProviderTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorHandlerProviderTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorHandlerProviderTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -84,6 +84,7 @@\n     private ReactorHandlerProvider provider;\n     private ProxySelector originalProxySelector;\n     private ProxySelector proxySelector;\n+    private AutoCloseable mocksCloseable;\n \n     public static Stream<ProxyOptions> getProxyConfigurations() {\n         return Stream.of(ProxyOptions.SYSTEM_DEFAULTS,\n@@ -94,7 +95,7 @@\n \n     @BeforeEach\n     public void setup() throws IOException {\n-        MockitoAnnotations.initMocks(this);\n+        mocksCloseable = MockitoAnnotations.openMocks(this);\n \n         when(reactorProvider.createReactor(eq(CONNECTION_ID), anyInt())).thenReturn(reactor);\n         when(reactorProvider.getReactor()).thenReturn(reactor);\n@@ -108,9 +109,13 @@ public void setup() throws IOException {\n     }\n \n     @AfterEach\n-    public void teardown() {\n+    public void teardown() throws Exception {\n         Mockito.framework().clearInlineMocks();\n         ProxySelector.setDefault(originalProxySelector);\n+\n+        if (mocksCloseable != null) {\n+            mocksCloseable.close();\n+        }\n     }\n \n     @Test"
  },
  {
    "sha": "ca3400fa8b851f857c05d99916eb062d95e9130d",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorReceiverTest.java",
    "status": "modified",
    "additions": 6,
    "deletions": 6,
    "changes": 12,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorReceiverTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorReceiverTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorReceiverTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -72,6 +72,7 @@\n \n     private ReceiveLinkHandler receiverHandler;\n     private ReactorReceiver reactorReceiver;\n+    private AutoCloseable mocksCloseable;\n \n     @BeforeAll\n     static void beforeAll() {\n@@ -85,7 +86,7 @@ static void afterAll() {\n \n     @BeforeEach\n     void setup() {\n-        MockitoAnnotations.initMocks(this);\n+        mocksCloseable = MockitoAnnotations.openMocks(this);\n \n         when(cbsNode.authorize(any(), any())).thenReturn(Mono.empty());\n \n@@ -105,12 +106,12 @@ void setup() {\n     }\n \n     @AfterEach\n-    void teardown() {\n+    void teardown() throws Exception {\n         Mockito.framework().clearInlineMocks();\n \n-        receiver = null;\n-        cbsNode = null;\n-        event = null;\n+        if (mocksCloseable != null) {\n+            mocksCloseable.close();\n+        }\n     }\n \n     /**\n@@ -143,7 +144,6 @@ void updateEndpointState() {\n             .then(() -> receiverHandler.onLinkRemoteOpen(event))\n             .expectNext(AmqpEndpointState.ACTIVE)\n             .then(() -> receiverHandler.close())\n-            .expectNext(AmqpEndpointState.CLOSED)\n             .verifyComplete();\n     }\n "
  },
  {
    "sha": "101ca9c3e9ab5b635533421da5edb4678b8ddb09",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java",
    "status": "modified",
    "additions": 11,
    "deletions": 8,
    "changes": 19,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -32,10 +32,9 @@\n import org.mockito.Mockito;\n import org.mockito.MockitoAnnotations;\n import reactor.core.publisher.Flux;\n-import reactor.core.publisher.FluxSink;\n import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n \n import java.io.IOException;\n import java.time.Duration;\n@@ -85,10 +84,11 @@\n \n     private Message message;\n     private AmqpRetryOptions options;\n+    private AutoCloseable mocksCloseable;\n \n     @BeforeEach\n     public void setup() throws IOException {\n-        MockitoAnnotations.initMocks(this);\n+        mocksCloseable = MockitoAnnotations.openMocks(this);\n \n         Delivery delivery = mock(Delivery.class);\n         when(delivery.getRemoteState()).thenReturn(Accepted.getInstance());\n@@ -98,10 +98,9 @@ public void setup() throws IOException {\n \n         when(handler.getLinkCredits()).thenReturn(Flux.just(100));\n \n-        final ReplayProcessor<EndpointState> endpointStateReplayProcessor = ReplayProcessor.cacheLast();\n-        when(handler.getEndpointStates()).thenReturn(endpointStateReplayProcessor);\n-        FluxSink<EndpointState> sink1 = endpointStateReplayProcessor.sink();\n-        sink1.next(EndpointState.ACTIVE);\n+        final TestPublisher<EndpointState> endpointStates = TestPublisher.createCold();\n+        when(handler.getEndpointStates()).thenReturn(endpointStates.flux());\n+        endpointStates.next(EndpointState.ACTIVE);\n \n         when(tokenManager.getAuthorizationResults()).thenReturn(Flux.just(AmqpResponseCode.ACCEPTED));\n         when(sender.getCredit()).thenReturn(100);\n@@ -141,10 +140,14 @@ public void clear() {\n     }\n \n     @AfterEach\n-    void teardown() {\n+    public void teardown() throws Exception {\n         // Tear down any inline mocks to avoid memory leaks.\n         // https://github.com/mockito/mockito/wiki/What's-new-in-Mockito-2#mockito-2250\n         Mockito.framework().clearInlineMocks();\n+\n+        if (mocksCloseable != null) {\n+            mocksCloseable.close();\n+        }\n     }\n \n     @Test"
  },
  {
    "sha": "768e17db50244ef3257a6779b75919b0b3d6b1f1",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSessionTest.java",
    "status": "modified",
    "additions": 8,
    "deletions": 4,
    "changes": 12,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSessionTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSessionTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSessionTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -84,10 +84,11 @@\n     private TokenManagerProvider tokenManagerProvider;\n \n     private Mono<ClaimsBasedSecurityNode> cbsNodeSupplier;\n+    private AutoCloseable mocksCloseable;\n \n     @BeforeEach\n     public void setup() throws IOException {\n-        MockitoAnnotations.initMocks(this);\n+        mocksCloseable = MockitoAnnotations.openMocks(this);\n \n         this.handler = new SessionHandler(ID, HOST, ENTITY_PATH, reactorDispatcher, Duration.ofSeconds(60));\n         this.cbsNodeSupplier = Mono.just(cbsNode);\n@@ -111,8 +112,12 @@ public void setup() throws IOException {\n     }\n \n     @AfterEach\n-    public void teardown() {\n+    public void teardown() throws Exception {\n         Mockito.framework().clearInlineMocks();\n+\n+        if (mocksCloseable != null) {\n+            mocksCloseable.close();\n+        }\n     }\n \n     @Test\n@@ -134,9 +139,8 @@ public void verifyEndpointStates() {\n             .then(() -> handler.onSessionRemoteOpen(event))\n             .expectNext(AmqpEndpointState.ACTIVE)\n             .then(() -> handler.close())\n-            .expectNext(AmqpEndpointState.CLOSED)\n             .expectComplete()\n-            .verify(Duration.ofSeconds(10));\n+            .verify();\n     }\n \n     @Test"
  },
  {
    "sha": "e31b1bc8735e8947efea200c82bd5e5a7c44223f",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RequestResponseChannelTest.java",
    "status": "modified",
    "additions": 18,
    "deletions": 16,
    "changes": 34,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RequestResponseChannelTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RequestResponseChannelTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RequestResponseChannelTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -30,10 +30,8 @@\n import org.mockito.Mock;\n import org.mockito.Mockito;\n import org.mockito.MockitoAnnotations;\n-import reactor.core.publisher.DirectProcessor;\n-import reactor.core.publisher.FluxSink;\n-import reactor.core.publisher.ReplayProcessor;\n import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n \n import java.io.IOException;\n import java.time.Duration;\n@@ -63,9 +61,8 @@\n     private static final Duration TIMEOUT = Duration.ofSeconds(23);\n \n     private final AmqpRetryOptions retryOptions = new AmqpRetryOptions().setTryTimeout(TIMEOUT);\n-    private final DirectProcessor<Delivery> deliveryProcessor = DirectProcessor.create();\n-    private final FluxSink<Delivery> deliverySink = deliveryProcessor.sink();\n-    private final ReplayProcessor<EndpointState> endpointStateReplayProcessor = ReplayProcessor.cacheLast();\n+    private final TestPublisher<Delivery> deliveryProcessor = TestPublisher.createCold();\n+    private final TestPublisher<EndpointState> endpointStates = TestPublisher.createCold();\n \n     @Mock\n     private ReactorHandlerProvider handlerProvider;\n@@ -88,6 +85,7 @@\n     private MessageSerializer serializer;\n     @Captor\n     private ArgumentCaptor<Runnable> dispatcherCaptor;\n+    private AutoCloseable mocksCloseable;\n \n     @BeforeAll\n     static void beforeAll() {\n@@ -101,7 +99,7 @@ static void afterAll() {\n \n     @BeforeEach\n     void beforeEach() {\n-        MockitoAnnotations.initMocks(this);\n+        mocksCloseable = MockitoAnnotations.openMocks(this);\n \n         when(reactorProvider.getReactorDispatcher()).thenReturn(reactorDispatcher);\n \n@@ -117,17 +115,21 @@ void beforeEach() {\n         when(handlerProvider.createSendLinkHandler(CONNECTION_ID, NAMESPACE, LINK_NAME, ENTITY_PATH))\n             .thenReturn(sendLinkHandler);\n \n-        FluxSink<EndpointState> sink1 = endpointStateReplayProcessor.sink();\n-        sink1.next(EndpointState.ACTIVE);\n-        when(receiveLinkHandler.getEndpointStates()).thenReturn(endpointStateReplayProcessor);\n-        when(receiveLinkHandler.getDeliveredMessages()).thenReturn(deliveryProcessor);\n+        when(receiveLinkHandler.getEndpointStates()).thenReturn(endpointStates.flux());\n+        when(receiveLinkHandler.getDeliveredMessages()).thenReturn(deliveryProcessor.flux());\n \n-        when(sendLinkHandler.getEndpointStates()).thenReturn(endpointStateReplayProcessor);\n+        when(sendLinkHandler.getEndpointStates()).thenReturn(endpointStates.flux());\n+\n+        endpointStates.next(EndpointState.ACTIVE);\n     }\n \n     @AfterEach\n-    void afterEach() {\n+    void afterEach() throws Exception {\n         Mockito.framework().clearInlineMocks();\n+\n+        if (mocksCloseable != null) {\n+            mocksCloseable.close();\n+        }\n     }\n \n     /**\n@@ -266,7 +268,7 @@ void sendMessageWithTransaction() throws IOException {\n \n         // Act\n         StepVerifier.create(channel.sendWithAck(message, transactionalState))\n-            .then(() -> deliverySink.next(delivery))\n+            .then(() -> deliveryProcessor.next(delivery))\n             .assertNext(received -> assertEquals(messageId, received.getCorrelationId()))\n             .verifyComplete();\n \n@@ -326,7 +328,7 @@ void sendMessage() throws IOException {\n \n         // Act\n         StepVerifier.create(channel.sendWithAck(message))\n-            .then(() -> deliverySink.next(delivery))\n+            .then(() -> deliveryProcessor.next(delivery))\n             .assertNext(received -> assertEquals(messageId, received.getCorrelationId()))\n             .verifyComplete();\n \n@@ -360,7 +362,7 @@ void clearMessagesOnError() {\n \n         // Act\n         StepVerifier.create(channel.sendWithAck(message))\n-            .then(() -> endpointStateReplayProcessor.sink().error(error))\n+            .then(() -> endpointStates.error(error))\n             .verifyError(AmqpException.class);\n \n         // Assert"
  },
  {
    "sha": "3604c28277bca51fb74c5b61536d11806e6eeaf6",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RetryUtilTest.java",
    "status": "modified",
    "additions": 32,
    "deletions": 0,
    "changes": 32,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RetryUtilTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RetryUtilTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RetryUtilTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -86,6 +86,38 @@ void withRetryFlux() {\n         assertEquals(options.getMaxRetries() + 1, resubscribe.get());\n     }\n \n+    /**\n+     * Tests a retry that times out on a Flux.\n+     */\n+    @Test\n+    void withRetryFluxEmitsItemsLaterThanTimeout() {\n+        // Arrange\n+        final String timeoutMessage = \"Operation timed out.\";\n+        final Duration timeout = Duration.ofMillis(500);\n+        final AmqpRetryOptions options = new AmqpRetryOptions()\n+            .setDelay(Duration.ofSeconds(1))\n+            .setMaxRetries(2)\n+            .setTryTimeout(timeout);\n+        final Duration totalWaitTime = Duration.ofSeconds(options.getMaxRetries() * options.getDelay().getSeconds());\n+\n+        final AtomicInteger resubscribe = new AtomicInteger();\n+        final TestPublisher<AmqpTransportType> singleItem = TestPublisher.create();\n+\n+        final Flux<AmqpTransportType> flux = singleItem.flux()\n+            .doOnSubscribe(s -> resubscribe.incrementAndGet());\n+\n+        // Act & Assert\n+        StepVerifier.create(RetryUtil.withRetry(flux, options, timeoutMessage))\n+            .expectSubscription()\n+            .then(() -> singleItem.next(AmqpTransportType.AMQP_WEB_SOCKETS))\n+            .expectNext(AmqpTransportType.AMQP_WEB_SOCKETS)\n+            .expectNoEvent(totalWaitTime)\n+            .thenCancel()\n+            .verify();\n+\n+        assertEquals(1, resubscribe.get());\n+    }\n+\n     /**\n      * Tests a retry that times out on a Mono.\n      */"
  },
  {
    "sha": "7c44521e2232a9447881eb05c985ec5bc8d41526",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TracerProviderTest.java",
    "status": "modified",
    "additions": 15,
    "deletions": 4,
    "changes": 19,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TracerProviderTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TracerProviderTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TracerProviderTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -22,8 +22,14 @@\n import java.util.Optional;\n \n import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.mockito.ArgumentMatchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.isNull;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n public class TracerProviderTest {\n     private static final String SERVICE_BASE_NAME = \"serviceBaseName\";\n@@ -34,18 +40,23 @@\n \n     private List<Tracer> tracers;\n     private TracerProvider tracerProvider;\n+    private AutoCloseable mocksCloseable;\n \n     @BeforeEach\n     public void setup() {\n-        MockitoAnnotations.initMocks(this);\n+        mocksCloseable = MockitoAnnotations.openMocks(this);\n \n         tracers = Collections.singletonList(tracer);\n         tracerProvider = new TracerProvider(tracers);\n     }\n \n     @AfterEach\n-    public void teardown() {\n+    public void teardown() throws Exception {\n         Mockito.framework().clearInlineMocks();\n+\n+        if (mocksCloseable != null) {\n+            mocksCloseable.close();\n+        }\n     }\n \n     @Test"
  },
  {
    "sha": "60bf7734f246b9551272860de33e58b2050db848",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TransactionCoordinatorTest.java",
    "status": "modified",
    "additions": 17,
    "deletions": 12,
    "changes": 29,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TransactionCoordinatorTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TransactionCoordinatorTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TransactionCoordinatorTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -3,17 +3,7 @@\n \n package com.azure.core.amqp.implementation;\n \n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n-import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.ArgumentMatchers.isNull;\n-import static org.mockito.Mockito.doReturn;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.Mockito.verify;\n-\n import com.azure.core.amqp.AmqpTransaction;\n-import java.nio.ByteBuffer;\n-\n import org.apache.qpid.proton.amqp.Binary;\n import org.apache.qpid.proton.amqp.messaging.Accepted;\n import org.apache.qpid.proton.amqp.messaging.Rejected;\n@@ -31,6 +21,16 @@\n import reactor.core.publisher.Mono;\n import reactor.test.StepVerifier;\n \n+import java.nio.ByteBuffer;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.isNull;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n /**\n  * Unit tests for {@link TransactionCoordinator}\n  */\n@@ -40,17 +40,22 @@\n     private MessageSerializer messageSerializer;\n     @Mock\n     private AmqpSendLink sendLink;\n+    private AutoCloseable mocksCloseable;\n \n     @BeforeEach\n     public void setup() {\n-        MockitoAnnotations.initMocks(this);\n+        mocksCloseable = MockitoAnnotations.openMocks(this);\n     }\n \n     @AfterEach\n-    void teardown() {\n+    void teardown() throws Exception {\n         // Tear down any inline mocks to avoid memory leaks.\n         // https://github.com/mockito/mockito/wiki/What's-new-in-Mockito-2#mockito-2250\n         Mockito.framework().clearInlineMocks();\n+\n+        if (mocksCloseable != null) {\n+            mocksCloseable.close();\n+        }\n     }\n \n     @ParameterizedTest"
  },
  {
    "sha": "7f4f6d6d2e9f3247b4ea230d8f8e357cef9b087b",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/handler/ConnectionHandlerTest.java",
    "status": "modified",
    "additions": 8,
    "deletions": 3,
    "changes": 11,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/handler/ConnectionHandlerTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/c0dca608b797c649f9cfe58a358a46ae6478bf72/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/handler/ConnectionHandlerTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/handler/ConnectionHandlerTest.java?ref=c0dca608b797c649f9cfe58a358a46ae6478bf72",
    "patch": "@@ -78,9 +78,11 @@\n \n     private ConnectionOptions connectionOptions;\n     private ConnectionHandler handler;\n+    private AutoCloseable mocksCloseable;\n+\n     @BeforeEach\n     public void setup() {\n-        MockitoAnnotations.initMocks(this);\n+        mocksCloseable = MockitoAnnotations.openMocks(this);\n \n         this.connectionOptions = new ConnectionOptions(HOSTNAME, tokenCredential,\n             CbsAuthorizationType.SHARED_ACCESS_SIGNATURE, AmqpTransportType.AMQP, new AmqpRetryOptions(),\n@@ -89,13 +91,16 @@ public void setup() {\n     }\n \n     @AfterEach\n-    public void teardown() {\n+    public void teardown() throws Exception {\n         if (handler != null) {\n             handler.close();\n         }\n \n         Mockito.framework().clearInlineMocks();\n-        argumentCaptor = null;\n+\n+        if (mocksCloseable != null) {\n+            mocksCloseable.close();\n+        }\n     }\n \n     @Test"
  }
]
