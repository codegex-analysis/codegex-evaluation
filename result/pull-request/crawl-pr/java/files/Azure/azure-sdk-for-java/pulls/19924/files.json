[
  {
    "sha": "9d9b425e7fcce41e11087afb77524dccc8ab7cef",
    "filename": "eng/versioning/version_client.txt",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/eng/versioning/version_client.txt",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/eng/versioning/version_client.txt",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/eng/versioning/version_client.txt?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -220,6 +220,7 @@ com.azure.resourcemanager:azure-resourcemanager-kubernetesconfiguration;1.0.0-be\n # Format;\n # unreleased_<groupId>:<artifactId>;dependency-version\n # note: The unreleased dependencies will not be manipulated with the automatic PR creation code.\n+unreleased_com.azure:azure-core-amqp;2.1.0-beta.1\n \n # Released Beta dependencies: Copy the entry from above, prepend \"beta_\", remove the current\n # version and set the version to the released beta. Released beta dependencies are only valid"
  },
  {
    "sha": "180e90064befc4a1a1cf5e215daff5e33efcff0c",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java",
    "status": "modified",
    "additions": 245,
    "deletions": 118,
    "changes": 363,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -5,15 +5,15 @@\n \n import com.azure.core.amqp.AmqpConnection;\n import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpRetryOptions;\n import com.azure.core.amqp.AmqpRetryPolicy;\n import com.azure.core.amqp.AmqpSession;\n import com.azure.core.amqp.AmqpShutdownSignal;\n import com.azure.core.amqp.ClaimsBasedSecurityNode;\n+import com.azure.core.amqp.exception.AmqpException;\n import com.azure.core.amqp.implementation.handler.ConnectionHandler;\n import com.azure.core.amqp.implementation.handler.SessionHandler;\n import com.azure.core.util.logging.ClientLogger;\n-import org.apache.qpid.proton.amqp.Symbol;\n-import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;\n import org.apache.qpid.proton.amqp.transport.SenderSettleMode;\n import org.apache.qpid.proton.engine.BaseHandler;\n@@ -22,35 +22,40 @@\n import org.apache.qpid.proton.message.Message;\n import org.apache.qpid.proton.reactor.Reactor;\n import reactor.core.Disposable;\n-import reactor.core.publisher.DirectProcessor;\n+import reactor.core.Disposables;\n import reactor.core.publisher.Flux;\n-import reactor.core.publisher.FluxSink;\n import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n+import reactor.core.publisher.SignalType;\n+import reactor.core.publisher.Sinks;\n import reactor.core.scheduler.Scheduler;\n import reactor.core.scheduler.Schedulers;\n \n import java.io.IOException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n import java.util.Map;\n import java.util.Objects;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n-import static com.azure.core.amqp.implementation.ClientConstants.NOT_APPLICABLE;\n-\n public class ReactorConnection implements AmqpConnection {\n     private static final String CBS_SESSION_NAME = \"cbs-session\";\n     private static final String CBS_ADDRESS = \"$cbs\";\n     private static final String CBS_LINK_NAME = \"cbs\";\n+    /**\n+     * Taken from {@link AmqpRetryPolicy} where MAX_SERVER_BUSY_TIME\n+     */\n+    private static final Duration MAX_BUSY_SERVER_TIME = Duration.ofSeconds(3);\n \n     private final ClientLogger logger = new ClientLogger(ReactorConnection.class);\n+    private final Object closeLock = new Object();\n     private final ConcurrentMap<String, SessionSubscription> sessionMap = new ConcurrentHashMap<>();\n \n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final DirectProcessor<AmqpShutdownSignal> shutdownSignals = DirectProcessor.create();\n-    private final FluxSink<AmqpShutdownSignal> shutdownSignalsSink = shutdownSignals.sink();\n-    private final ReplayProcessor<AmqpEndpointState> endpointStates;\n+    private final Sinks.One<AmqpShutdownSignal> shutdownSignalSink = Sinks.one();\n+    private final Flux<AmqpEndpointState> endpointStates;\n+    private final Sinks.Empty<Void> isClosedMono = Sinks.empty();\n \n     private final String connectionId;\n     private final Mono<Connection> connectionMono;\n@@ -63,12 +68,13 @@\n     private final AmqpRetryPolicy retryPolicy;\n     private final SenderSettleMode senderSettleMode;\n     private final ReceiverSettleMode receiverSettleMode;\n+    private final Duration operationTimeout;\n+    private final Composite subscriptions;\n \n     private ReactorExecutor executor;\n-    //TODO (conniey): handle failures and recreating the Reactor. Resubscribing the handlers, etc.\n-    private ReactorExceptionHandler reactorExceptionHandler;\n \n     private volatile ClaimsBasedSecurityChannel cbsChannel;\n+    private volatile AmqpChannelProcessor<RequestResponseChannel> cbsChannelProcessor;\n     private volatile Connection connection;\n \n     /**\n@@ -98,17 +104,57 @@ public ReactorConnection(String connectionId, ConnectionOptions connectionOption\n         this.handler = handlerProvider.createConnectionHandler(connectionId, connectionOptions);\n \n         this.retryPolicy = RetryUtil.getRetryPolicy(connectionOptions.getRetry());\n+        this.operationTimeout = connectionOptions.getRetry().getTryTimeout();\n         this.senderSettleMode = senderSettleMode;\n         this.receiverSettleMode = receiverSettleMode;\n \n-        this.connectionMono = Mono.fromCallable(this::getOrCreateConnection);\n+        this.connectionMono = Mono.fromCallable(this::getOrCreateConnection)\n+            .flatMap(reactorConnection -> {\n+                final Mono<AmqpEndpointState> activeEndpoint = getEndpointStates()\n+                    .filter(x -> x == AmqpEndpointState.ACTIVE)\n+                    .next()\n+                    .timeout(operationTimeout, Mono.error(new AmqpException(false, String.format(\n+                        \"Connection '%s' not opened within operation timeout: %s\", connectionId, operationTimeout),\n+                        handler.getErrorContext())));\n+                return activeEndpoint.thenReturn(reactorConnection);\n+            })\n+            .or(onClosedError(\"Could not get active connection.\"))\n+            .doOnError(error -> {\n+                final String message = String.format(\n+                    \"connectionId[%s] Error occurred while connection was starting. Error: %s\", connectionId, error);\n+\n+                if (isDisposed.getAndSet(true)) {\n+                    logger.verbose(\"connectionId[{}] was already disposed. {}\", connectionId, message);\n+                } else {\n+                    dispose(new AmqpShutdownSignal(false, false, message));\n+                }\n+            });\n \n         this.endpointStates = this.handler.getEndpointStates()\n-            .takeUntilOther(shutdownSignals)\n+            .takeUntilOther(shutdownSignalSink.asMono())\n             .map(state -> {\n                 logger.verbose(\"connectionId[{}]: State {}\", connectionId, state);\n                 return AmqpEndpointStateUtil.getConnectionState(state);\n-            }).subscribeWith(ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED));\n+            })\n+            .doOnError(error -> {\n+                if (!isDisposed.getAndSet(true)) {\n+                    logger.verbose(\"connectionId[{}]: Disposing of active sessions due to error.\", connectionId);\n+                    dispose(new AmqpShutdownSignal(false, false,\n+                        error.getMessage()));\n+                }\n+            })\n+            .doOnComplete(() -> {\n+                if (!isDisposed.getAndSet(true)) {\n+                    logger.verbose(\"connectionId[{}]: Disposing of active sessions due to connection close.\",\n+                        connectionId);\n+\n+                    dispose(new AmqpShutdownSignal(false, false,\n+                        \"Connection handler closed.\"));\n+                }\n+            })\n+            .cache(1);\n+\n+        this.subscriptions = Disposables.composite(this.endpointStates.subscribe());\n     }\n \n     /**\n@@ -119,26 +165,23 @@ public ReactorConnection(String connectionId, ConnectionOptions connectionOption\n         return endpointStates;\n     }\n \n+    /**\n+     * Gets the shutdown signal associated with this connection. When it emits, the underlying connection is closed.\n+     *\n+     * @return Shutdown signals associated with this connection. It emits a signal when the underlying connection is\n+     *     closed.\n+     */\n     @Override\n     public Flux<AmqpShutdownSignal> getShutdownSignals() {\n-        return shutdownSignals;\n+        return shutdownSignalSink.asMono().cache().flux();\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public Mono<ClaimsBasedSecurityNode> getClaimsBasedSecurityNode() {\n-        if (isDisposed()) {\n-            return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n-                \"connectionId[%s]: Connection is disposed. Cannot get CBS node.\", connectionId))));\n-        }\n-\n-        final Flux<AmqpEndpointState> activeEndpointState = RetryUtil.withRetry(\n-            getEndpointStates().takeUntil(x -> x == AmqpEndpointState.ACTIVE), connectionOptions.getRetry(),\n-            \"ReactorConnection: Retries exhausted waiting for ACTIVE endpoint state on CBS node.\");\n-\n-        return Mono.when(connectionMono, activeEndpointState).then(Mono.fromCallable(() -> getOrCreateCBSNode()));\n+        return connectionMono.then(Mono.fromCallable(() -> getOrCreateCBSNode()));\n     }\n \n     @Override\n@@ -175,41 +218,43 @@ public int getMaxFrameSize() {\n      */\n     @Override\n     public Mono<AmqpSession> createSession(String sessionName) {\n-        if (isDisposed()) {\n-            return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n-                \"connectionId[%s]: Connection is disposed. Cannot create session '%s'.\", connectionId, sessionName))));\n-        }\n-\n-        final SessionSubscription existing = sessionMap.get(sessionName);\n-        if (existing != null) {\n-            return Mono.just(existing.getSession());\n-        }\n-\n         return connectionMono.map(connection -> {\n-            final SessionSubscription sessionSubscription = sessionMap.computeIfAbsent(sessionName, key -> {\n-                final SessionHandler handler = handlerProvider.createSessionHandler(connectionId,\n-                    getFullyQualifiedNamespace(), key, connectionOptions.getRetry().getTryTimeout());\n-                final Session session = connection.session();\n-\n-                BaseHandler.setHandler(session, handler);\n-                final AmqpSession amqpSession = createSession(key, session, handler);\n-                final Disposable subscription = amqpSession.getEndpointStates()\n-                    .subscribe(state -> {\n-                    }, error -> {\n+            final SessionSubscription sessionSubscription;\n+            synchronized (closeLock) {\n+                sessionSubscription = sessionMap.computeIfAbsent(sessionName, key -> {\n+                    final SessionHandler sessionHandler = handlerProvider.createSessionHandler(connectionId,\n+                        getFullyQualifiedNamespace(), key, connectionOptions.getRetry().getTryTimeout());\n+                    final Session session = connection.session();\n+\n+                    BaseHandler.setHandler(session, sessionHandler);\n+                    final AmqpSession amqpSession = createSession(key, session, sessionHandler);\n+                    final Disposable subscription = amqpSession.getEndpointStates()\n+                        .subscribe(state -> {\n+                        }, error -> {\n                             logger.info(\"connectionId[{}] sessionName[{}]: Error occurred. Removing and disposing\"\n-                                    + \" session.\", connectionId, sessionName, error);\n+                                + \" session.\", connectionId, sessionName, error);\n                             removeSession(key);\n                         }, () -> {\n                             logger.info(\"connectionId[{}] sessionName[{}]: Complete. Removing and disposing session.\",\n                                 connectionId, sessionName);\n                             removeSession(key);\n                         });\n \n-                return new SessionSubscription(amqpSession, subscription);\n-            });\n+                    return new SessionSubscription(amqpSession, subscription);\n+                });\n+            }\n \n-            return sessionSubscription.getSession();\n-        });\n+            return sessionSubscription;\n+        }).flatMap(sessionSubscription -> {\n+            final Mono<AmqpEndpointState> activeSession = sessionSubscription.getSession().getEndpointStates()\n+                .filter(e -> e == AmqpEndpointState.ACTIVE)\n+                .next()\n+                .timeout(retryPolicy.getRetryOptions().getTryTimeout(), Mono.error(new AmqpException(true,\n+                    String.format(\"connectionId[%s] sessionName[%s] Timeout waiting for session to be active.\",\n+                        connectionId, sessionName), handler.getErrorContext())));\n+\n+            return activeSession.thenReturn(sessionSubscription.getSession());\n+        }).or(onClosedError(\"Could not create session: \" + sessionName));\n     }\n \n     /**\n@@ -222,16 +267,28 @@ public int getMaxFrameSize() {\n      * @return A new instance of AMQP session.\n      */\n     protected AmqpSession createSession(String sessionName, Session session, SessionHandler handler) {\n-        return new ReactorSession(session, handler, sessionName, reactorProvider, handlerProvider,\n-            getClaimsBasedSecurityNode(), tokenManagerProvider, messageSerializer, connectionOptions.getRetry());\n+        return new ReactorSession(this, session, handler, sessionName, reactorProvider,\n+            handlerProvider, getClaimsBasedSecurityNode(), tokenManagerProvider, messageSerializer,\n+            connectionOptions.getRetry());\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public boolean removeSession(String sessionName) {\n-        return removeSession(sessionName, null);\n+        if (sessionName == null) {\n+            return false;\n+        }\n+\n+        synchronized (closeLock) {\n+            final SessionSubscription removed = sessionMap.remove(sessionName);\n+            if (removed != null) {\n+                removed.dispose();\n+            }\n+\n+            return removed != null;\n+        }\n     }\n \n     @Override\n@@ -244,38 +301,25 @@ public boolean isDisposed() {\n      */\n     @Override\n     public void dispose() {\n-        dispose(null);\n-        shutdownSignalsSink.next(new AmqpShutdownSignal(false, true,\n-            \"Disposed by client.\"));\n-    }\n-\n-    void dispose(ErrorCondition errorCondition) {\n         if (isDisposed.getAndSet(true)) {\n+            logger.verbose(\"connectionId[{}] Was already closed. Not disposing again.\", connectionId);\n             return;\n         }\n \n-        logger.info(\"connectionId[{}], errorCondition[{}]: Disposing of ReactorConnection.\", connectionId,\n-            errorCondition != null ? errorCondition : NOT_APPLICABLE);\n-\n-        final String[] keys = sessionMap.keySet().toArray(new String[0]);\n-        for (String key : keys) {\n-            logger.info(\"connectionId[{}]: Removing session '{}'\", connectionId, key);\n-            removeSession(key, errorCondition);\n-        }\n-\n-        if (connection != null) {\n-            connection.close();\n-        }\n-\n-        if (executor != null) {\n-            executor.close();\n-        }\n+        // Because the reactor executor schedules the pending close after the timeout, we want to give sufficient time\n+        // for the rest of the tasks to run.\n+        final Duration timeout = operationTimeout.plus(operationTimeout);\n+        dispose(new AmqpShutdownSignal(false, true, \"Disposed by client.\"))\n+            .block(timeout);\n     }\n \n     /**\n-     * Gets the AMQP connection for this instance.\n+     * Gets the active AMQP connection for this instance.\n      *\n      * @return The AMQP connection.\n+     *\n+     * @throws AmqpException if the {@link Connection} was not transitioned to an active state within the given\n+     *     {@link AmqpRetryOptions#getTryTimeout() operation timeout}.\n      */\n     protected Mono<Connection> getReactorConnection() {\n         return connectionMono;\n@@ -290,44 +334,117 @@ void dispose(ErrorCondition errorCondition) {\n      *\n      * @return A new {@link RequestResponseChannel} to communicate with the message broker.\n      */\n-    protected Mono<RequestResponseChannel> createRequestResponseChannel(String sessionName, String linkName,\n-        String entityPath) {\n-\n-        final Flux<RequestResponseChannel> createChannel = createSession(sessionName).cast(ReactorSession.class)\n-            .map(reactorSession -> new RequestResponseChannel(getId(), getFullyQualifiedNamespace(), linkName,\n+    protected AmqpChannelProcessor<RequestResponseChannel> createRequestResponseChannel(String sessionName,\n+        String linkName, String entityPath) {\n+\n+        final Flux<RequestResponseChannel> createChannel = createSession(sessionName)\n+            .onErrorResume(error -> {\n+                final boolean isAmqpException = error instanceof AmqpException;\n+                return isDisposed.get() && isAmqpException;\n+            }, error -> Mono.empty())\n+            .cast(ReactorSession.class)\n+            .map(reactorSession -> new RequestResponseChannel(this, getId(), getFullyQualifiedNamespace(), linkName,\n                 entityPath, reactorSession.session(), connectionOptions.getRetry(), handlerProvider, reactorProvider,\n                 messageSerializer, senderSettleMode, receiverSettleMode))\n             .doOnNext(e -> {\n-                logger.info(\"Emitting new response channel. connectionId: {}. entityPath: {}. linkName: {}.\",\n+                logger.info(\"connectionId[{}] entityPath[{}] linkName[{}] Emitting new response channel.\",\n                     getId(), entityPath, linkName);\n             })\n-            .repeat();\n+            .repeat(() -> !isDisposed.get());\n \n         return createChannel.subscribeWith(new AmqpChannelProcessor<>(connectionId, entityPath,\n             channel -> channel.getEndpointStates(), retryPolicy,\n-            new ClientLogger(RequestResponseChannel.class)));\n+            new ClientLogger(RequestResponseChannel.class + \":\" + entityPath)));\n     }\n \n-    private boolean removeSession(String sessionName, ErrorCondition errorCondition) {\n-        if (sessionName == null) {\n-            return false;\n+    /**\n+     * Returns a Mono that completes when the connection handler is closed. If it does, an {@link AmqpException} is\n+     * returned. It indicates that a shutdown was initiated and we should stop.\n+     *\n+     * @return A Mono that completes when the shutdown signal is emitted. If it does, returns an error.\n+     */\n+    private <T> Mono<T> onClosedError(String message) {\n+        return Mono.firstWithSignal(isClosedMono.asMono(), shutdownSignalSink.asMono())\n+            .then(Mono.error(new AmqpException(false,\n+                String.format(\"connectionId[%s] Connection closed. %s\", connectionId, message),\n+                handler.getErrorContext())));\n+    }\n+\n+    private boolean onEmitSinkFailure(SignalType signalType, Sinks.EmitResult emitResult, String message) {\n+        logger.warning(\"connectionId[{}] signal[{}] result[{}] {}\",\n+            connectionId, signalType, emitResult, message);\n+\n+        return false;\n+    }\n+\n+    private Mono<Void> dispose(AmqpShutdownSignal shutdownSignal) {\n+        logger.info(\"connectionId[{}] signal[{}]: Disposing of ReactorConnection.\", connectionId, shutdownSignal);\n+\n+        if (cbsChannelProcessor != null) {\n+            cbsChannelProcessor.dispose();\n+        }\n+\n+        final Sinks.EmitResult result = shutdownSignalSink.tryEmitValue(shutdownSignal);\n+        if (result.isFailure()) {\n+            // It's possible that another one was already emitted, so it's all good.\n+            logger.info(\"connectionId[{}] signal[{}] result[{}] Unable to emit shutdown signal.\", connectionId, result);\n+        }\n+\n+        return Mono.fromRunnable(() -> {\n+            try {\n+                reactorProvider.getReactorDispatcher().invoke(this::closeConnectionWork);\n+            } catch (IOException e) {\n+                logger.warning(\"connectionId[{}] Error while scheduling closeConnection work. Manually disposing.\",\n+                    connectionId, e);\n+                closeConnectionWork();\n+            }\n+        }).then(isClosedMono.asMono());\n+    }\n+\n+    private void closeConnectionWork() {\n+        if (connection == null) {\n+            isClosedMono.emitEmpty((signalType, emitResult) -> onEmitSinkFailure(signalType, emitResult,\n+                \"Unable to complete closeMono when there is no connection.\"));\n+            return;\n         }\n \n-        final SessionSubscription removed = sessionMap.remove(sessionName);\n+        connection.close();\n \n-        if (removed != null) {\n-            removed.dispose(errorCondition);\n+        final ArrayList<Mono<Void>> closingSessions = new ArrayList<>();\n+        synchronized (closeLock) {\n+            sessionMap.forEach((key, link) -> closingSessions.add(link.isClosed()));\n         }\n \n-        return removed != null;\n+        executor.close();\n+\n+        // Close all the children.\n+        Mono<Void> closeSessionsMono = Mono.when(closingSessions)\n+            .timeout(operationTimeout)\n+            .onErrorResume(error -> {\n+                logger.warning(\"connectionId[{}]: Timed out waiting for all sessions to close.\", connectionId, error);\n+                return Mono.empty();\n+            })\n+            .then(executor.isClosed())\n+            .then(Mono.fromRunnable(() -> {\n+                isClosedMono.emitEmpty((signalType, result) -> {\n+                    logger.warning(\"connectionId[{}] signal[{}] result[{}]: Unable to emit connection closed signal\",\n+                        connectionId, signalType, result);\n+                    return false;\n+                });\n+\n+                handler.close();\n+                subscriptions.dispose();\n+            }));\n+\n+        subscriptions.add(closeSessionsMono.subscribe());\n     }\n \n     private synchronized ClaimsBasedSecurityNode getOrCreateCBSNode() {\n         if (cbsChannel == null) {\n             logger.info(\"Setting CBS channel.\");\n-\n+            cbsChannelProcessor = createRequestResponseChannel(CBS_SESSION_NAME, CBS_LINK_NAME, CBS_ADDRESS);\n             cbsChannel = new ClaimsBasedSecurityChannel(\n-                createRequestResponseChannel(CBS_SESSION_NAME, CBS_LINK_NAME, CBS_ADDRESS),\n+                cbsChannelProcessor,\n                 connectionOptions.getTokenCredential(), connectionOptions.getAuthorizationType(),\n                 connectionOptions.getRetry());\n         }\n@@ -343,13 +460,20 @@ private synchronized Connection getOrCreateConnection() throws IOException {\n             final Reactor reactor = reactorProvider.createReactor(connectionId, handler.getMaxFrameSize());\n             connection = reactor.connectionToHost(handler.getHostname(), handler.getProtocolPort(), handler);\n \n-            reactorExceptionHandler = new ReactorExceptionHandler();\n+            ReactorExceptionHandler reactorExceptionHandler = new ReactorExceptionHandler();\n+\n             // Use a new single-threaded scheduler for this connection as QPID's Reactor is not thread-safe.\n             // Using Schedulers.single() will use the same thread for all connections in this process which\n             // limits the scalability of the no. of concurrent connections a single process can have.\n-            Scheduler scheduler = Schedulers.newSingle(\"reactor-executor\");\n+            // This could be a long timeout depending on the user's operation timeout. It's probable that the\n+            // connection's long disposed.\n+            final Duration timeoutDivided = connectionOptions.getRetry().getTryTimeout().dividedBy(2);\n+            final Duration pendingTasksDuration = MAX_BUSY_SERVER_TIME.compareTo(timeoutDivided) < 0\n+                ? MAX_BUSY_SERVER_TIME\n+                : timeoutDivided;\n+            final Scheduler scheduler = Schedulers.newSingle(\"reactor-executor\");\n             executor = new ReactorExecutor(reactor, scheduler, connectionId,\n-                reactorExceptionHandler, connectionOptions.getRetry().getTryTimeout(),\n+                reactorExceptionHandler, pendingTasksDuration,\n                 connectionOptions.getFullyQualifiedNamespace());\n \n             executor.start();\n@@ -365,32 +489,28 @@ private ReactorExceptionHandler() {\n \n         @Override\n         public void onConnectionError(Throwable exception) {\n-            if (isDisposed.get()) {\n-                super.onConnectionError(exception);\n-                return;\n-            }\n-\n             logger.warning(\n                 \"onReactorError connectionId[{}], hostName[{}], message[Starting new reactor], error[{}]\",\n-                getId(), getFullyQualifiedNamespace(), exception.getMessage());\n+                getId(), getFullyQualifiedNamespace(), exception.getMessage(), exception);\n \n-            endpointStates.onError(exception);\n-            ReactorConnection.this.dispose();\n+            if (!isDisposed.getAndSet(true)) {\n+                logger.verbose(\"onReactorError connectionId[{}], hostName[{}]: disposing.\");\n+                dispose(new AmqpShutdownSignal(false, false,\n+                    \"onReactorError: \" + exception.toString()))\n+                    .subscribe();\n+            }\n         }\n \n         @Override\n         void onConnectionShutdown(AmqpShutdownSignal shutdownSignal) {\n-            if (isDisposed()) {\n-                super.onConnectionShutdown(shutdownSignal);\n-                return;\n-            }\n-\n-            logger.warning(\n-                \"onReactorError connectionId[{}], hostName[{}], message[Shutting down], shutdown signal[{}]\",\n+            logger.info(\n+                \"onConnectionShutdown connectionId[{}], hostName[{}], message[Shutting down], shutdown signal[{}]\",\n                 getId(), getFullyQualifiedNamespace(), shutdownSignal.isInitiatedByClient(), shutdownSignal);\n \n-            dispose(new ErrorCondition(Symbol.getSymbol(\"onReactorError\"), shutdownSignal.toString()));\n-            shutdownSignalsSink.next(shutdownSignal);\n+            if (!isDisposed.getAndSet(true)) {\n+                logger.verbose(\"onConnectionShutdown connectionId[{}], hostName[{}]: disposing.\");\n+                dispose(shutdownSignal).subscribe();\n+            }\n         }\n     }\n \n@@ -404,22 +524,29 @@ private SessionSubscription(AmqpSession session, Disposable subscription) {\n             this.subscription = subscription;\n         }\n \n-        public AmqpSession getSession() {\n+        private AmqpSession getSession() {\n             return session;\n         }\n \n-        void dispose(ErrorCondition errorCondition) {\n+        private void dispose() {\n             if (isDisposed.getAndSet(true)) {\n                 return;\n             }\n \n             if (session instanceof ReactorSession) {\n-                final ReactorSession reactorSession = (ReactorSession) session;\n-                reactorSession.dispose(errorCondition);\n+                ((ReactorSession) session).dispose(\"Closing session.\", null, true);\n             } else {\n                 session.dispose();\n             }\n             subscription.dispose();\n         }\n+\n+        private Mono<Void> isClosed() {\n+            if (session instanceof ReactorSession) {\n+                return ((ReactorSession) session).isClosed();\n+            } else {\n+                return Mono.empty();\n+            }\n+        }\n     }\n }"
  },
  {
    "sha": "662fcf68933fcc7cfc36b187a21c05538b449cbc",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorExecutor.java",
    "status": "modified",
    "additions": 31,
    "deletions": 31,
    "changes": 62,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorExecutor.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorExecutor.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorExecutor.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -10,6 +10,8 @@\n import com.azure.core.util.logging.ClientLogger;\n import org.apache.qpid.proton.engine.HandlerException;\n import org.apache.qpid.proton.reactor.Reactor;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Sinks;\n import reactor.core.scheduler.Scheduler;\n \n import java.io.Closeable;\n@@ -18,7 +20,6 @@\n import java.util.Locale;\n import java.util.Objects;\n import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n@@ -28,7 +29,7 @@\n     private final ClientLogger logger = new ClientLogger(ReactorExecutor.class);\n     private final AtomicBoolean hasStarted = new AtomicBoolean();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final Semaphore disposeSemaphore = new Semaphore(1);\n+    private final Sinks.Empty<Void> isClosedMono = Sinks.empty();\n \n     private final Object lock = new Object();\n     private final Reactor reactor;\n@@ -127,33 +128,36 @@ private void run() {\n         } finally {\n             if (!rescheduledReactor) {\n                 if (hasStarted.getAndSet(false)) {\n+                    logger.verbose(\"Scheduling reactor to complete pending tasks.\");\n                     scheduleCompletePendingTasks();\n                 } else {\n                     final String reason =\n                         \"Stopping the reactor because thread was interrupted or the reactor has no more events to \"\n                             + \"process.\";\n \n                     logger.info(LOG_MESSAGE, connectionId, reason);\n-                    close(false, reason);\n+                    close(reason);\n                 }\n             }\n         }\n     }\n \n-    private void scheduleCompletePendingTasks() {\n-        try {\n-            if (!disposeSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n-                logger.info(\"Unable to acquire dispose reactor semaphore within timeout to schedule pending tasks.\");\n-            }\n-        } catch (InterruptedException e) {\n-            logger.warning(\"Could not acquire dispose semaphore to schedule pending tasks\", e);\n-        }\n+    Mono<Void> isClosed() {\n+        return isClosedMono.asMono();\n+    }\n \n+    /**\n+     * Schedules the release of the current reactor after operation timeout has elapsed.\n+     */\n+    private void scheduleCompletePendingTasks() {\n         this.scheduler.schedule(() -> {\n             logger.info(LOG_MESSAGE, connectionId, \"Processing all pending tasks and closing old reactor.\");\n             try {\n+                if (reactor.process()) {\n+                    logger.verbose(\"Had more tasks to process on reactor but it is shutting down.\");\n+                }\n+\n                 reactor.stop();\n-                reactor.process();\n             } catch (HandlerException e) {\n                 logger.warning(LOG_MESSAGE, connectionId,\n                     StringUtil.toStackTraceString(e, \"scheduleCompletePendingTasks - exception occurred while \"\n@@ -166,35 +170,31 @@ private void scheduleCompletePendingTasks() {\n                     // session before we were able to schedule this work.\n                 }\n \n-                disposeSemaphore.release();\n+                close(\"Finished processing pending tasks.\");\n             }\n-        });\n+        }, timeout.toMillis(), TimeUnit.MILLISECONDS);\n     }\n \n     @Override\n     public void close() {\n-        if (!isDisposed.getAndSet(true)) {\n-            close(true, \"ReactorExecutor.close() was called.\");\n-        }\n-    }\n-\n-    private void close(boolean isUserInitialized, String reason) {\n-        if (!hasStarted.getAndSet(false)) {\n+        if (isDisposed.getAndSet(true)) {\n             return;\n         }\n \n-        if (isUserInitialized) {\n+        if (hasStarted.get()) {\n             scheduleCompletePendingTasks();\n-            // wait for the scheduled pending tasks to complete\n-            try {\n-                if (!disposeSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n-                    logger.info(\"Unable to acquire dispose reactor semaphore within timeout.\");\n-                }\n-            } catch (InterruptedException e) {\n-                logger.warning(\"Could not acquire semaphore to finish close operation.\", e);\n-            }\n         }\n-        exceptionHandler.onConnectionShutdown(new AmqpShutdownSignal(false, isUserInitialized, reason));\n+    }\n+\n+    private void close(String reason) {\n+        logger.verbose(\"Completing close and disposing scheduler. {}\", reason);\n+\n+        isClosedMono.emitEmpty((signalType, emitResult) -> {\n+            logger.verbose(\"signalType[{}] emitResult[{}]: Unable to emit close event on reactor\", signalType,\n+                emitResult);\n+            return false;\n+        });\n+        exceptionHandler.onConnectionShutdown(new AmqpShutdownSignal(false, false, reason));\n         scheduler.dispose();\n     }\n }"
  },
  {
    "sha": "b38dcfe499e4bb2c2cb1ded14fa7459fede0d9b0",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorProvider.java",
    "status": "modified",
    "additions": 15,
    "deletions": 11,
    "changes": 26,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorProvider.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorProvider.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorProvider.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -55,24 +55,28 @@ public Reactor createReactor(String connectionId, int maxFrameSize) throws IOExc\n      * @return A new reactor instance.\n      */\n     private Reactor createReactor(final int maxFrameSize, final Handler globalHandler,\n-                                  final BaseHandler... baseHandlers) throws IOException {\n+        final BaseHandler... baseHandlers) throws IOException {\n         Objects.requireNonNull(baseHandlers);\n         Objects.requireNonNull(globalHandler);\n \n-        if (maxFrameSize <= 0) {\n-            throw logger.logExceptionAsError(new IllegalArgumentException(\"'maxFrameSize' must be a positive number.\"));\n-        }\n+        synchronized (lock) {\n+            if (this.reactor != null) {\n+                return this.reactor;\n+            }\n \n-        final ReactorOptions reactorOptions = new ReactorOptions();\n-        reactorOptions.setMaxFrameSize(maxFrameSize);\n-        reactorOptions.setEnableSaslByDefault(true);\n+            if (maxFrameSize <= 0) {\n+                throw logger.logExceptionAsError(new IllegalArgumentException(\"'maxFrameSize' must be a positive number.\"));\n+            }\n \n-        final Reactor reactor = Proton.reactor(reactorOptions, baseHandlers);\n-        reactor.setGlobalHandler(globalHandler);\n+            final ReactorOptions reactorOptions = new ReactorOptions();\n+            reactorOptions.setMaxFrameSize(maxFrameSize);\n+            reactorOptions.setEnableSaslByDefault(true);\n \n-        final ReactorDispatcher dispatcher = new ReactorDispatcher(reactor);\n+            final Reactor reactor = Proton.reactor(reactorOptions, baseHandlers);\n+            reactor.setGlobalHandler(globalHandler);\n+\n+            final ReactorDispatcher dispatcher = new ReactorDispatcher(reactor);\n \n-        synchronized (lock) {\n             this.reactor = reactor;\n             this.reactorDispatcher = dispatcher;\n         }"
  },
  {
    "sha": "daff87cc9a00909399ac48960bd48b0db897cb7f",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorReceiver.java",
    "status": "modified",
    "additions": 114,
    "deletions": 61,
    "changes": 175,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorReceiver.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorReceiver.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorReceiver.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -3,7 +3,9 @@\n \n package com.azure.core.amqp.implementation;\n \n+import com.azure.core.amqp.AmqpConnection;\n import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpRetryOptions;\n import com.azure.core.amqp.implementation.handler.ReceiveLinkHandler;\n import com.azure.core.util.logging.ClientLogger;\n import org.apache.qpid.proton.Proton;\n@@ -13,16 +15,19 @@\n import org.apache.qpid.proton.engine.Receiver;\n import org.apache.qpid.proton.message.Message;\n import reactor.core.Disposable;\n-import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.Disposables;\n import reactor.core.publisher.Flux;\n-import reactor.core.publisher.ReplayProcessor;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Sinks;\n \n import java.io.IOException;\n import java.util.Objects;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.function.Supplier;\n \n+import static com.azure.core.amqp.implementation.ClientConstants.NOT_APPLICABLE;\n+\n /**\n  * Handles receiving events from Event Hubs service and translating them to proton-j messages.\n  */\n@@ -38,20 +43,25 @@\n     private final ReactorDispatcher dispatcher;\n     private final Disposable subscriptions;\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final EmitterProcessor<Message> messagesProcessor;\n+    private final Sinks.Empty<Void> isClosedMono = Sinks.empty();\n+    private final Flux<Message> messagesProcessor;\n+    private final AmqpRetryOptions retryOptions;\n     private final ClientLogger logger = new ClientLogger(ReactorReceiver.class);\n-    private final ReplayProcessor<AmqpEndpointState> endpointStates;\n+    private final Flux<AmqpEndpointState> endpointStates;\n \n     private final AtomicReference<Supplier<Integer>> creditSupplier = new AtomicReference<>();\n \n-    protected ReactorReceiver(String entityPath, Receiver receiver, ReceiveLinkHandler handler,\n-        TokenManager tokenManager, ReactorDispatcher dispatcher) {\n+    protected ReactorReceiver(AmqpConnection amqpConnection, String entityPath, Receiver receiver,\n+        ReceiveLinkHandler handler, TokenManager tokenManager, ReactorDispatcher dispatcher,\n+        AmqpRetryOptions retryOptions) {\n         this.entityPath = entityPath;\n         this.receiver = receiver;\n         this.handler = handler;\n         this.tokenManager = tokenManager;\n         this.dispatcher = dispatcher;\n-        this.messagesProcessor = this.handler.getDeliveredMessages()\n+\n+        this.messagesProcessor =\n+            this.handler.getDeliveredMessages()\n             .map(this::decodeDelivery)\n             .doOnNext(next -> {\n                 if (receiver.getRemoteCredit() == 0 && !isDisposed.get()) {\n@@ -65,25 +75,55 @@ protected ReactorReceiver(String entityPath, Receiver receiver, ReceiveLinkHandl\n                         addCredits(credits);\n                     }\n                 }\n-            })\n-            .subscribeWith(EmitterProcessor.create());\n+            }).publish().autoConnect();\n+        this.retryOptions = retryOptions;\n+\n         this.endpointStates = this.handler.getEndpointStates()\n             .map(state -> {\n                 logger.verbose(\"connectionId[{}], path[{}], linkName[{}]: State {}\", handler.getConnectionId(),\n                     entityPath, getLinkName(), state);\n                 return AmqpEndpointStateUtil.getConnectionState(state);\n             })\n-            .subscribeWith(ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED));\n+            .doOnError(error -> {\n+                final String message = isDisposed.getAndSet(true)\n+                    ? \"This was already disposed. Dropping error.\"\n+                    : \"Freeing resources due to error.\";\n+                logger.warning(\"connectionId[{}] entityPath[{}] linkName[{}] {}\",\n+                    handler.getConnectionId(), entityPath, getLinkName(), message, error);\n+\n+                completeClose();\n+            })\n+            .doOnComplete(() -> {\n+                final String message = isDisposed.getAndSet(true)\n+                    ? \"This was already disposed.\"\n+                    : \"Freeing resources.\";\n+                logger.verbose(\"connectionId[{}] entityPath[{}] linkName[{}] {}\", handler.getConnectionId(),\n+                    entityPath, getLinkName(), message);\n+\n+                completeClose();\n+            })\n+            .cache(1);\n+\n+        this.subscriptions = Disposables.composite(\n+            this.endpointStates.subscribe(),\n \n-        this.subscriptions = this.tokenManager.getAuthorizationResults().subscribe(\n-            response -> {\n+            this.tokenManager.getAuthorizationResults().subscribe(\n+                response -> {\n                 logger.verbose(\"Token refreshed: {}\", response);\n                 hasAuthorized.set(true);\n             }, error -> {\n+                //TODO (conniey): Close reactor receiver because we are no longer authorized.\n                 logger.info(\"connectionId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n                     handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n                 hasAuthorized.set(false);\n-            }, () -> hasAuthorized.set(false));\n+            }, () -> hasAuthorized.set(false)),\n+\n+            amqpConnection.getShutdownSignals().subscribe(signal -> {\n+                logger.verbose(\"connectionId[{}] linkName[{}]: Shutdown signal received.\", handler.getConnectionId(),\n+                    getLinkName());\n+\n+                dispose(\"Connection shutdown.\", null).subscribe();\n+            }));\n     }\n \n     @Override\n@@ -145,72 +185,85 @@ public boolean isDisposed() {\n \n     @Override\n     public void dispose() {\n-        if (isDisposed.getAndSet(true)) {\n-            return;\n-        }\n+        dispose(\"Dispose invoked\", null).block(retryOptions.getTryTimeout());\n+    }\n \n-        subscriptions.dispose();\n-        messagesProcessor.onComplete();\n-        tokenManager.close();\n-        receiver.close();\n-\n-        try {\n-            dispatcher.invoke(() -> {\n-                receiver.free();\n-                handler.close();\n-            });\n-        } catch (IOException e) {\n-            logger.warning(\"Could not schedule disposing of receiver on ReactorDispatcher.\", e);\n-            handler.close();\n-        }\n+    protected Message decodeDelivery(Delivery delivery) {\n+        final int messageSize = delivery.pending();\n+        final byte[] buffer = new byte[messageSize];\n+        final int read = receiver.recv(buffer, 0, messageSize);\n+        receiver.advance();\n+\n+        final Message message = Proton.message();\n+        message.decode(buffer, 0, read);\n+\n+        delivery.settle();\n+        return message;\n     }\n \n     /**\n-     * Disposes of the sender when an exception is encountered.\n+     * Disposes of the receiver when an exception is encountered.\n      *\n-     * @param condition Error condition associated with close operation.\n+     * @param message Message to log.\n+     * @param errorCondition Error condition associated with close operation.\n      */\n-    void dispose(ErrorCondition condition) {\n+    Mono<Void> dispose(String message, ErrorCondition errorCondition) {\n         if (isDisposed.getAndSet(true)) {\n-            return;\n+            return isClosedMono.asMono();\n         }\n \n-        logger.verbose(\"connectionId[{}], path[{}], linkName[{}]: setting error condition {}\",\n-            handler.getConnectionId(), entityPath, getLinkName(), condition);\n+        final String condition = errorCondition != null ? errorCondition.toString() : NOT_APPLICABLE;\n+        logger.verbose(\"connectionId[{}], path[{}], linkName[{}] errorCondition[{}]: Setting error condition and \"\n+                + \"disposing. {}\",\n+            handler.getConnectionId(), entityPath, getLinkName(), condition, message);\n \n-        if (receiver.getLocalState() != EndpointState.CLOSED) {\n-            receiver.close();\n+        final Runnable closeReceiver = () -> {\n+            if (receiver.getLocalState() != EndpointState.CLOSED) {\n+                receiver.close();\n \n-            if (receiver.getCondition() == null) {\n-                receiver.setCondition(condition);\n+                if (receiver.getCondition() == null) {\n+                    receiver.setCondition(errorCondition);\n+                }\n             }\n-        }\n+        };\n \n-        try {\n-            dispatcher.invoke(() -> {\n-                receiver.free();\n-                handler.close();\n-            });\n-        } catch (IOException e) {\n-            logger.warning(\"Could not schedule disposing of receiver on ReactorDispatcher.\", e);\n-            handler.close();\n-        }\n+        return Mono.fromRunnable(() -> {\n+            try {\n+                dispatcher.invoke(closeReceiver);\n+            } catch (IOException e) {\n+                logger.warning(\"Could not schedule disposing of receiver on ReactorDispatcher.\", e);\n+                closeReceiver.run();\n+            }\n+        }).then(isClosedMono.asMono());\n+    }\n \n-        messagesProcessor.onComplete();\n-        tokenManager.close();\n+    /**\n+     * A mono that completes when the sender has completely closed.\n+     *\n+     * @return mono that completes when the sender has completely closed.\n+     */\n+    Mono<Void> isClosed() {\n+        return isClosedMono.asMono();\n     }\n \n-    protected Message decodeDelivery(Delivery delivery) {\n-        final int messageSize = delivery.pending();\n-        final byte[] buffer = new byte[messageSize];\n-        final int read = receiver.recv(buffer, 0, messageSize);\n-        receiver.advance();\n+    /**\n+     * Takes care of disposing of subscriptions, reactor resources after they've been closed.\n+     */\n+    private void completeClose() {\n+        isClosedMono.emitEmpty((signalType, result) -> {\n+            logger.warning(\"connectionId[{}], signal[{}], result[{}]. Unable to emit shutdown signal.\",\n+                handler.getConnectionId(), signalType, result);\n+            return false;\n+        });\n \n-        final Message message = Proton.message();\n-        message.decode(buffer, 0, read);\n+        subscriptions.dispose();\n \n-        delivery.settle();\n-        return message;\n+        if (tokenManager != null) {\n+            tokenManager.close();\n+        }\n+\n+        handler.close();\n+        receiver.free();\n     }\n \n     @Override"
  },
  {
    "sha": "785fdfb883eb68d9e0c01b59b1761bcfec21642f",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java",
    "status": "modified",
    "additions": 132,
    "deletions": 29,
    "changes": 161,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -3,6 +3,7 @@\n \n package com.azure.core.amqp.implementation;\n \n+import com.azure.core.amqp.AmqpConnection;\n import com.azure.core.amqp.AmqpEndpointState;\n import com.azure.core.amqp.AmqpRetryOptions;\n import com.azure.core.amqp.AmqpRetryPolicy;\n@@ -32,7 +33,7 @@\n import reactor.core.Disposables;\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n+import reactor.core.publisher.Sinks;\n \n import java.io.IOException;\n import java.io.Serializable;\n@@ -70,13 +71,14 @@\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n     private final AtomicBoolean hasAuthorized = new AtomicBoolean(true);\n     private final AtomicInteger retryAttempts = new AtomicInteger();\n+    private final Sinks.Empty<Void> isClosedMono = Sinks.empty();\n \n     private final Object pendingSendLock = new Object();\n     private final ConcurrentHashMap<String, RetriableWorkItem> pendingSendsMap = new ConcurrentHashMap<>();\n     private final PriorityQueue<WeightedDeliveryTag> pendingSendsQueue =\n         new PriorityQueue<>(1000, new DeliveryTagComparator());\n     private final ClientLogger logger = new ClientLogger(ReactorSender.class);\n-    private final ReplayProcessor<AmqpEndpointState> endpointStates;\n+    private final Flux<AmqpEndpointState> endpointStates;\n \n     private final TokenManager tokenManager;\n     private final MessageSerializer messageSerializer;\n@@ -91,9 +93,9 @@\n     private volatile Instant lastKnownErrorReportedAt;\n     private volatile int linkSize;\n \n-    ReactorSender(String entityPath, Sender sender, SendLinkHandler handler, ReactorProvider reactorProvider,\n-        TokenManager tokenManager, MessageSerializer messageSerializer, AmqpRetryOptions retryOptions) {\n-\n+    ReactorSender(AmqpConnection amqpConnection, String entityPath, Sender sender, SendLinkHandler handler,\n+        ReactorProvider reactorProvider, TokenManager tokenManager, MessageSerializer messageSerializer,\n+        AmqpRetryOptions retryOptions) {\n         this.entityPath = entityPath;\n         this.sender = sender;\n         this.handler = handler;\n@@ -108,19 +110,38 @@\n \n         this.endpointStates = this.handler.getEndpointStates()\n             .map(state -> {\n-                logger.verbose(\"connectionId[{}], path[{}], linkName[{}]: State {}\", handler.getConnectionId(),\n+                logger.verbose(\"connectionId[{}] entityPath[{}] linkName[{}]: State {}\", handler.getConnectionId(),\n                     entityPath, getLinkName(), state);\n                 this.hasConnected.set(state == EndpointState.ACTIVE);\n                 return AmqpEndpointStateUtil.getConnectionState(state);\n-            }).subscribeWith(ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED));\n+            })\n+            .doOnError(error -> {\n+                hasConnected.set(false);\n+                handleError(error);\n+            })\n+            .doOnComplete(() -> {\n+                hasConnected.set(false);\n+                handleClose();\n+            })\n+            .cache(1);\n \n         this.subscriptions = Disposables.composite(\n-            this.handler.getDeliveredMessages().subscribe(this::processDeliveredMessage),\n+            this.endpointStates.subscribe(),\n \n-            this.handler.getLinkCredits().subscribe(credit -> {\n-                logger.verbose(\"connectionId[{}], entityPath[{}], linkName[{}]: Credits on link: {}\",\n+            handler.getDeliveredMessages().subscribe(this::processDeliveredMessage),\n+\n+            handler.getLinkCredits().subscribe(credit -> {\n+                logger.verbose(\"connectionId[{}] entityPath[{}] linkName[{}]: Credits on link: {}\",\n                     handler.getConnectionId(), entityPath, getLinkName(), credit);\n                 this.scheduleWorkOnDispatcher();\n+            }),\n+\n+            amqpConnection.getShutdownSignals().subscribe(signal -> {\n+                logger.verbose(\"connectionId[{}] linkName[{}]: Shutdown signal received.\", handler.getConnectionId(),\n+                    getLinkName());\n+\n+                hasConnected.set(false);\n+                dispose(\"Connection shutdown.\", null).subscribe();\n             })\n         );\n \n@@ -132,6 +153,7 @@\n                     hasAuthorized.set(true);\n                 },\n                 error -> {\n+                    //TODO (conniey): Close link or sender when it is no longer authorized.\n                     logger.info(\"connectionId[{}], entityPath[{}], linkName[{}]: tokenRenewalFailure[{}]\",\n                         handler.getConnectionId(), entityPath, getLinkName(), error.getMessage());\n                     hasAuthorized.set(false);\n@@ -232,7 +254,6 @@\n \n                 return send(bytes, byteArrayOffset, AmqpConstants.AMQP_BATCH_MESSAGE_FORMAT, deliveryState);\n             }).then();\n-\n     }\n \n     @Override\n@@ -288,37 +309,59 @@ public boolean isDisposed() {\n         return isDisposed.get();\n     }\n \n+    /**\n+     * Blocking call that disposes of the sender. See {@link #dispose(String, ErrorCondition)}.\n+     */\n     @Override\n     public void dispose() {\n-        dispose(null);\n+        dispose(\"Dispose called\", null)\n+            .block(retryOptions.getTryTimeout());\n     }\n \n     /**\n-     * Disposes of the sender when an exception is encountered.\n+     * Disposes of the sender.\n      *\n      * @param errorCondition Error condition associated with close operation.\n+     * @param message Message associated with why the sender was closed.\n+     *\n+     * @return A mono that completes when the send link has closed.\n      */\n-    void dispose(ErrorCondition errorCondition) {\n+    Mono<Void> dispose(String message, ErrorCondition errorCondition) {\n         if (isDisposed.getAndSet(true)) {\n-            return;\n+            return isClosedMono.asMono();\n         }\n \n-        subscriptions.dispose();\n-        tokenManager.close();\n+        final String condition = errorCondition != null ? errorCondition.toString() : NOT_APPLICABLE;\n+        logger.verbose(\"connectionId[{}], path[{}], linkName[{}] errorCondition[{}]. Setting error condition and \"\n+                + \"disposing. {}\",\n+            handler.getConnectionId(), entityPath, getLinkName(), condition, message);\n \n-        if (sender.getLocalState() == EndpointState.CLOSED) {\n-            return;\n-        }\n+        final Runnable closeWork = () -> {\n+            if (errorCondition != null && sender.getCondition() == null) {\n+                sender.setCondition(errorCondition);\n+            }\n \n-        logger.verbose(\"connectionId[{}], path[{}], linkName[{}]: setting error condition {}\",\n-            handler.getConnectionId(), entityPath, getLinkName(),\n-            errorCondition != null ? errorCondition : NOT_APPLICABLE);\n+            sender.close();\n+        };\n \n-        if (errorCondition != null && sender.getCondition() == null) {\n-            sender.setCondition(errorCondition);\n-        }\n+        return Mono.fromRunnable(() -> {\n+            try {\n+                reactorProvider.getReactorDispatcher().invoke(closeWork);\n+            } catch (IOException e) {\n+                logger.warning(\"connectionId[{}] entityPath[{}] linkName[{}]: Could not schedule close work. Running\"\n+                    + \" manually.\", handler.getConnectionId(), entityPath, getLinkName(), e);\n+                closeWork.run();\n+            }\n+        }).then(isClosedMono.asMono());\n+    }\n \n-        sender.close();\n+    /**\n+     * A mono that completes when the sender has completely closed.\n+     *\n+     * @return mono that completes when the sender has completely closed.\n+     */\n+    Mono<Void> isClosed() {\n+        return isClosedMono.asMono();\n     }\n \n     @Override\n@@ -358,6 +401,11 @@ private void processSendWork() {\n             return;\n         }\n \n+        if (isDisposed.get()) {\n+            logger.info(\"Sender is closed. Not executing work.\");\n+            return;\n+        }\n+\n         while (hasConnected.get() && sender.getCredit() > 0) {\n             final WeightedDeliveryTag weightedDelivery;\n             final RetriableWorkItem workItem;\n@@ -428,8 +476,8 @@ private void processSendWork() {\n                     \"Entity(%s): send operation failed. Please see cause for more details\", entityPath),\n                     sendException, context)\n                     : new OperationCancelledException(String.format(Locale.US,\n-                        \"Entity(%s): send operation failed while advancing delivery(tag: %s).\",\n-                        entityPath, deliveryTag), context);\n+                    \"Entity(%s): send operation failed while advancing delivery(tag: %s).\",\n+                    entityPath, deliveryTag), context);\n \n                 workItem.error(exception);\n             }\n@@ -525,6 +573,61 @@ private void cleanupFailedSend(final RetriableWorkItem workItem, final Exception\n         workItem.error(exception);\n     }\n \n+    private void completeClose() {\n+        isClosedMono.emitEmpty((signalType, result) -> {\n+            logger.warning(\"connectionId[{}], signal[{}], result[{}]. Unable to emit shutdown signal.\",\n+                handler.getConnectionId(), signalType, result);\n+            return false;\n+        });\n+\n+        subscriptions.dispose();\n+\n+        if (tokenManager != null) {\n+            tokenManager.close();\n+        }\n+    }\n+\n+    /**\n+     * Clears pending sends and puts an error in there.\n+     *\n+     * @param error Error to pass to pending sends.\n+     */\n+    private void handleError(Throwable error) {\n+        final String logMessage = isDisposed.getAndSet(true)\n+            ? \"This was already disposed. Dropping error.\"\n+            : \"Disposing pending sends with error.\";\n+        logger.verbose(\"connectionId[{}] entityPath[{}] linkName[{}] {}\", handler.getConnectionId(), entityPath,\n+            getLinkName(), logMessage, error);\n+\n+        synchronized (pendingSendLock) {\n+            pendingSendsMap.forEach((key, value) -> value.error(error));\n+            pendingSendsMap.clear();\n+            pendingSendsQueue.clear();\n+        }\n+\n+        completeClose();\n+    }\n+\n+    private void handleClose() {\n+        final String logMessage = isDisposed.getAndSet(true)\n+            ? \"This was already disposed.\"\n+            : \"Disposing pending sends.\";\n+        logger.verbose(\"connectionId[{}] entityPath[{}] linkName[{}] {}\", handler.getConnectionId(), entityPath,\n+            getLinkName(), logMessage);\n+\n+        final String message = String.format(\"Could not complete sends because link '%s' for '%s' is closed.\",\n+            getLinkName(), entityPath);\n+        final AmqpErrorContext context = handler.getErrorContext(sender);\n+\n+        synchronized (pendingSendLock) {\n+            pendingSendsMap.forEach((key, value) -> value.error(new AmqpException(true, message, context)));\n+            pendingSendsMap.clear();\n+            pendingSendsQueue.clear();\n+        }\n+\n+        completeClose();\n+    }\n+\n     private static boolean isGeneralSendError(Symbol amqpError) {\n         return (amqpError == AmqpErrorCode.SERVER_BUSY_ERROR || amqpError == AmqpErrorCode.TIMEOUT_ERROR\n             || amqpError == AmqpErrorCode.RESOURCE_LIMIT_EXCEEDED);"
  },
  {
    "sha": "0a8b7b4fecbc236ad59347a791dff30d92f59366",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java",
    "status": "modified",
    "additions": 178,
    "deletions": 54,
    "changes": 232,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -3,13 +3,15 @@\n \n package com.azure.core.amqp.implementation;\n \n+import com.azure.core.amqp.AmqpConnection;\n import com.azure.core.amqp.AmqpEndpointState;\n import com.azure.core.amqp.AmqpLink;\n import com.azure.core.amqp.AmqpRetryOptions;\n import com.azure.core.amqp.AmqpRetryPolicy;\n import com.azure.core.amqp.AmqpSession;\n import com.azure.core.amqp.AmqpTransaction;\n import com.azure.core.amqp.ClaimsBasedSecurityNode;\n+import com.azure.core.amqp.exception.AmqpException;\n import com.azure.core.amqp.implementation.handler.ReceiveLinkHandler;\n import com.azure.core.amqp.implementation.handler.SendLinkHandler;\n import com.azure.core.amqp.implementation.handler.SessionHandler;\n@@ -27,12 +29,14 @@\n import org.apache.qpid.proton.engine.Sender;\n import org.apache.qpid.proton.engine.Session;\n import reactor.core.Disposable;\n+import reactor.core.Disposables;\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n+import reactor.core.publisher.Sinks;\n \n import java.io.IOException;\n import java.time.Duration;\n+import java.util.ArrayList;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n@@ -50,9 +54,18 @@\n     private final ConcurrentMap<String, LinkSubscription<AmqpReceiveLink>> openReceiveLinks = new ConcurrentHashMap<>();\n \n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final Object closeLock = new Object();\n+\n+    /**\n+     * Mono that completes when the session is completely closed, that is that the session remote\n+     */\n+    private final Sinks.Empty<Void> isClosedMono = Sinks.empty();\n+    private Mono<Void> closeLinksMono = null;\n+\n     private final ClientLogger logger = new ClientLogger(ReactorSession.class);\n-    private final ReplayProcessor<AmqpEndpointState> endpointStates;\n+    private final Flux<AmqpEndpointState> endpointStates;\n \n+    private final AmqpConnection amqpConnection;\n     private final Session session;\n     private final SessionHandler sessionHandler;\n     private final String sessionName;\n@@ -64,6 +77,7 @@\n \n     private final ReactorHandlerProvider handlerProvider;\n     private final Mono<ClaimsBasedSecurityNode> cbsNodeSupplier;\n+    private final Disposable.Composite connectionSubscriptions;\n \n     private final AtomicReference<TransactionCoordinator> transactionCoordinator = new AtomicReference<>();\n \n@@ -80,10 +94,11 @@\n      *     operations on the message broker.\n      * @param retryOptions for the session operations.\n      */\n-    public ReactorSession(Session session, SessionHandler sessionHandler, String sessionName, ReactorProvider provider,\n-        ReactorHandlerProvider handlerProvider, Mono<ClaimsBasedSecurityNode> cbsNodeSupplier,\n-        TokenManagerProvider tokenManagerProvider, MessageSerializer messageSerializer,\n-        AmqpRetryOptions retryOptions) {\n+    public ReactorSession(AmqpConnection amqpConnection, Session session, SessionHandler sessionHandler,\n+        String sessionName, ReactorProvider provider, ReactorHandlerProvider handlerProvider,\n+        Mono<ClaimsBasedSecurityNode> cbsNodeSupplier, TokenManagerProvider tokenManagerProvider,\n+        MessageSerializer messageSerializer, AmqpRetryOptions retryOptions) {\n+        this.amqpConnection = amqpConnection;\n         this.session = session;\n         this.sessionHandler = sessionHandler;\n         this.handlerProvider = handlerProvider;\n@@ -103,7 +118,16 @@ public ReactorSession(Session session, SessionHandler sessionHandler, String ses\n                     sessionName, state);\n                 return AmqpEndpointStateUtil.getConnectionState(state);\n             })\n-            .subscribeWith(ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED));\n+            .doOnError(error -> handleError(error))\n+            .doOnComplete(() -> handleClose())\n+            .cache(1);\n+\n+        this.connectionSubscriptions = Disposables.composite(\n+            this.endpointStates.subscribe(),\n+\n+            amqpConnection.getShutdownSignals().subscribe(signal -> {\n+                dispose(\"Shutdown signal received\", null, false).subscribe();\n+            }));\n \n         session.open();\n     }\n@@ -127,27 +151,8 @@ public boolean isDisposed() {\n      */\n     @Override\n     public void dispose() {\n-        dispose(null);\n-    }\n-\n-    void dispose(ErrorCondition errorCondition) {\n-        if (isDisposed.getAndSet(true)) {\n-            return;\n-        }\n-\n-        logger.info(\"connectionId[{}], sessionId[{}], errorCondition[{}]: Disposing of session.\",\n-            sessionHandler.getConnectionId(), sessionName, errorCondition != null ? errorCondition : NOT_APPLICABLE);\n-\n-        if (session.getLocalState() != EndpointState.CLOSED) {\n-            session.close();\n-\n-            if (session.getCondition() == null) {\n-                session.setCondition(errorCondition);\n-            }\n-        }\n-\n-        openReceiveLinks.forEach((key, link) -> link.dispose(errorCondition));\n-        openSendLinks.forEach((key, link) -> link.dispose(errorCondition));\n+        dispose(\"Dispose called.\", null, true)\n+            .block(retryOptions.getTryTimeout());\n     }\n \n     /**\n@@ -220,7 +225,36 @@ public boolean removeLink(String linkName) {\n     }\n \n     /**\n+     * A Mono that completes when the session has completely closed.\n      *\n+     * @return Mono that completes when the session has completely closed.\n+     */\n+    Mono<Void> isClosed() {\n+        return isClosedMono.asMono();\n+    }\n+\n+    Mono<Void> dispose(String message, ErrorCondition errorCondition, boolean disposeLinks) {\n+        if (isDisposed.getAndSet(true)) {\n+            return isClosedMono.asMono();\n+        }\n+\n+        final String condition = errorCondition != null ? errorCondition.toString() : NOT_APPLICABLE;\n+        logger.verbose(\"connectionId[{}], sessionName[{}], errorCondition[{}]. Setting error condition and \"\n+                + \"disposing session. {}\",\n+            sessionHandler.getConnectionId(), sessionName, condition, message);\n+\n+        return Mono.fromRunnable(() -> {\n+            try {\n+                provider.getReactorDispatcher().invoke(() -> disposeWork(errorCondition, disposeLinks));\n+            } catch (IOException e) {\n+                logger.warning(\"connectionId[{}] sessionName[{}] Error while scheduling work. Manually disposing.\",\n+                    sessionHandler.getConnectionId(), sessionName, e);\n+                disposeWork(errorCondition, disposeLinks);\n+            }\n+        }).then(isClosedMono.asMono());\n+    }\n+\n+    /**\n      * @return {@link Mono} of {@link TransactionCoordinator}\n      */\n     private Mono<TransactionCoordinator> createTransactionCoordinator() {\n@@ -318,8 +352,8 @@ public boolean removeLink(String linkName) {\n      */\n     protected ReactorReceiver createConsumer(String entityPath, Receiver receiver,\n         ReceiveLinkHandler receiveLinkHandler, TokenManager tokenManager, ReactorProvider reactorProvider) {\n-        return new ReactorReceiver(entityPath, receiver, receiveLinkHandler, tokenManager,\n-            reactorProvider.getReactorDispatcher());\n+        return new ReactorReceiver(amqpConnection, entityPath, receiver, receiveLinkHandler, tokenManager,\n+            reactorProvider.getReactorDispatcher(), retryOptions);\n     }\n \n     /**\n@@ -334,7 +368,7 @@ protected ReactorReceiver createConsumer(String entityPath, Receiver receiver,\n      * @return A new instance of an {@link AmqpLink} with the correct properties set.\n      */\n     protected Mono<AmqpLink> createProducer(String linkName, String entityPath, Duration timeout,\n-         AmqpRetryPolicy retry, Map<Symbol, Object> linkProperties) {\n+        AmqpRetryPolicy retry, Map<Symbol, Object> linkProperties) {\n \n         final Target target = new Target();\n         target.setAddress(entityPath);\n@@ -430,22 +464,24 @@ protected ReactorReceiver createConsumer(String entityPath, Receiver receiver,\n \n         sender.open();\n \n-        final ReactorSender reactorSender = new ReactorSender(entityPath, sender, sendLinkHandler, provider,\n-            tokenManager, messageSerializer, options);\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, entityPath, sender, sendLinkHandler,\n+            provider, tokenManager, messageSerializer, options);\n \n         //@formatter:off\n         final Disposable subscription = reactorSender.getEndpointStates().subscribe(state -> {\n         }, error -> {\n-                logger.info(\"linkName[{}]: Error occurred. Removing and disposing send link.\",\n-                    linkName, error);\n-                removeLink(openSendLinks, linkName);\n-            }, () -> {\n-                logger.info(\"linkName[{}]: Complete. Removing and disposing send link.\", linkName);\n-                removeLink(openSendLinks, linkName);\n-            });\n+            logger.info(\"linkName[{}]: Error occurred. Removing and disposing send link.\",\n+                linkName, error);\n+            removeLink(openSendLinks, linkName);\n+        }, () -> {\n+            logger.info(\"linkName[{}]: Complete. Removing and disposing send link.\", linkName);\n+            removeLink(openSendLinks, linkName);\n+        });\n         //@formatter:on\n \n-        return new LinkSubscription<>(reactorSender, subscription);\n+        return new LinkSubscription<>(reactorSender, subscription,\n+            String.format(\"connectionId[%s] session[%s]: Setting error on receive link.\",\n+                sessionHandler.getConnectionId(), sessionName));\n     }\n \n     /**\n@@ -492,19 +528,21 @@ protected ReactorReceiver createConsumer(String entityPath, Receiver receiver,\n \n         final Disposable subscription = reactorReceiver.getEndpointStates().subscribe(state -> {\n         }, error -> {\n-                logger.info(\n-                    \"linkName[{}] entityPath[{}]: Error occurred. Removing receive link.\",\n-                    linkName, entityPath, error);\n+            logger.info(\n+                \"linkName[{}] entityPath[{}]: Error occurred. Removing receive link.\",\n+                linkName, entityPath, error);\n \n-                removeLink(openReceiveLinks, linkName);\n-            }, () -> {\n-                logger.info(\"linkName[{}] entityPath[{}]: Complete. Removing receive link.\",\n-                    linkName, entityPath);\n+            removeLink(openReceiveLinks, linkName);\n+        }, () -> {\n+            logger.info(\"linkName[{}] entityPath[{}]: Complete. Removing receive link.\",\n+                linkName, entityPath);\n \n-                removeLink(openReceiveLinks, linkName);\n-            });\n+            removeLink(openReceiveLinks, linkName);\n+        });\n \n-        return new LinkSubscription<>(reactorReceiver, subscription);\n+        return new LinkSubscription<>(reactorReceiver, subscription,\n+            String.format(\"connectionId[%s] session[%s]: Setting error on receive link.\", amqpConnection.getId(),\n+                sessionName));\n     }\n \n     /**\n@@ -518,6 +556,80 @@ protected ReactorReceiver createConsumer(String entityPath, Receiver receiver,\n             .then();\n     }\n \n+    private void handleClose() {\n+        logger.verbose(\"connectionId[{}] sessionName[{}]  Disposing of active links due to session close.\",\n+            sessionHandler.getConnectionId(), sessionName);\n+\n+        dispose(\"Session closed.\", null, true);\n+    }\n+\n+    private void handleError(Throwable error) {\n+        logger.verbose(\"connectionId[{}] sessionName[{}]  Disposing of active links due to error.\",\n+            sessionHandler.getConnectionId(), sessionName, error);\n+        final ErrorCondition condition;\n+        if (error instanceof AmqpException) {\n+            final AmqpException exception = ((AmqpException) error);\n+            condition = new ErrorCondition(\n+                Symbol.getSymbol(exception.getErrorCondition().getErrorCondition()), exception.getMessage());\n+            dispose(exception.getMessage(), condition, true);\n+        } else {\n+            condition = null;\n+        }\n+\n+        dispose(error.getMessage(), condition, true);\n+    }\n+\n+    /**\n+     * Takes care of setting the error condition on the session, closing the children if specified and then waiting\n+     *\n+     * @param errorCondition Condition to set on the session.\n+     * @param disposeLinks {@code true} to dispose of children. {@code false} to ignore them, this may be the case\n+     *     when the {@link AmqpConnection} passes a shutdown signal.\n+     */\n+    private void disposeWork(ErrorCondition errorCondition, boolean disposeLinks) {\n+        if (session.getLocalState() != EndpointState.CLOSED) {\n+            session.close();\n+\n+            if (errorCondition != null && session.getCondition() == null) {\n+                session.setCondition(errorCondition);\n+            }\n+        }\n+\n+        final ArrayList<Mono<Void>> closingLinks = new ArrayList<>();\n+        if (disposeLinks) {\n+            synchronized (closeLock) {\n+                openReceiveLinks.forEach((key, link) -> {\n+                    closingLinks.add(link.isClosed());\n+                    link.dispose(errorCondition);\n+                });\n+                openSendLinks.forEach((key, link) -> {\n+                    closingLinks.add(link.isClosed());\n+                    link.dispose(errorCondition);\n+                });\n+            }\n+        }\n+\n+        // We want to complete the session so that the parent connection isn't waiting.\n+        closeLinksMono = Mono.when(closingLinks).timeout(retryOptions.getTryTimeout())\n+            .onErrorResume(error -> {\n+                logger.warning(\"connectionId[{}], sessionName[{}]: Timed out waiting for all links to close.\",\n+                    sessionHandler.getConnectionId(), sessionName, error);\n+                return Mono.empty();\n+            })\n+            .then(Mono.fromRunnable(() -> {\n+                isClosedMono.emitEmpty((signalType, result) -> {\n+                    logger.warning(\"connectionId[{}], signal[{}], result[{}]. Unable to emit shutdown signal.\",\n+                        sessionHandler.getConnectionId(), signalType, result);\n+                    return false;\n+                });\n+\n+                sessionHandler.close();\n+                connectionSubscriptions.dispose();\n+            }));\n+\n+        connectionSubscriptions.add(closeLinksMono.subscribe());\n+    }\n+\n     private <T extends AmqpLink> boolean removeLink(ConcurrentMap<String, LinkSubscription<T>> openLinks, String key) {\n         if (key == null) {\n             return false;\n@@ -535,10 +647,12 @@ protected ReactorReceiver createConsumer(String entityPath, Receiver receiver,\n         private final AtomicBoolean isDisposed = new AtomicBoolean();\n         private final T link;\n         private final Disposable subscription;\n+        private final String errorMessage;\n \n-        private LinkSubscription(T link, Disposable subscription) {\n+        private LinkSubscription(T link, Disposable subscription, String errorMessage) {\n             this.link = link;\n             this.subscription = subscription;\n+            this.errorMessage = errorMessage;\n         }\n \n         public T getLink() {\n@@ -552,15 +666,25 @@ void dispose(ErrorCondition errorCondition) {\n \n             if (link instanceof ReactorReceiver) {\n                 final ReactorReceiver reactorReceiver = (ReactorReceiver) link;\n-                reactorReceiver.dispose(errorCondition);\n+                reactorReceiver.dispose(errorMessage, errorCondition).subscribe();\n             } else if (link instanceof ReactorSender) {\n                 final ReactorSender reactorSender = (ReactorSender) link;\n-                reactorSender.dispose(errorCondition);\n+                reactorSender.dispose(errorMessage, errorCondition).subscribe();\n             } else {\n                 link.dispose();\n             }\n \n             subscription.dispose();\n         }\n+\n+        Mono<Void> isClosed() {\n+            if (link instanceof ReactorReceiver) {\n+                return ((ReactorReceiver) link).isClosed();\n+            } else if (link instanceof ReactorSender) {\n+                return ((ReactorSender) link).isClosed();\n+            } else {\n+                return Mono.empty();\n+            }\n+        }\n     }\n }"
  },
  {
    "sha": "174103b33d6dcdba986faec1bf3e69b39ce73e5f",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java",
    "status": "modified",
    "additions": 98,
    "deletions": 28,
    "changes": 126,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -3,6 +3,7 @@\n \n package com.azure.core.amqp.implementation;\n \n+import com.azure.core.amqp.AmqpConnection;\n import com.azure.core.amqp.AmqpEndpointState;\n import com.azure.core.amqp.AmqpRetryOptions;\n import com.azure.core.amqp.exception.AmqpErrorContext;\n@@ -28,16 +29,16 @@\n import reactor.core.Disposable;\n import reactor.core.Disposables;\n import reactor.core.publisher.Flux;\n-import reactor.core.publisher.FluxSink;\n import reactor.core.publisher.Mono;\n import reactor.core.publisher.MonoSink;\n-import reactor.core.publisher.ReplayProcessor;\n+import reactor.core.publisher.SignalType;\n+import reactor.core.publisher.Sinks;\n \n import java.io.IOException;\n-import java.time.Duration;\n import java.util.UUID;\n import java.util.concurrent.ConcurrentSkipListMap;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n \n import static com.azure.core.util.FluxUtil.monoError;\n@@ -51,19 +52,19 @@\n     private final ConcurrentSkipListMap<UnsignedLong, MonoSink<Message>> unconfirmedSends =\n         new ConcurrentSkipListMap<>();\n     private final AtomicBoolean hasError = new AtomicBoolean();\n-    private final ReplayProcessor<AmqpEndpointState> endpointStates =\n-        ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED);\n-    private final FluxSink<AmqpEndpointState> endpointStatesSink =\n-        endpointStates.sink(FluxSink.OverflowStrategy.BUFFER);\n+    private final Sinks.Many<AmqpEndpointState> endpointStates = Sinks.many().multicast().onBackpressureBuffer();\n     private final ClientLogger logger = new ClientLogger(RequestResponseChannel.class);\n \n+    // The request response channel is closed when both the receive and send link component are disposed of.\n+    private final AtomicInteger pendingDisposes = new AtomicInteger(2);\n+    private final Sinks.One<Void> closeMono = Sinks.one();\n+\n     private final Sender sendLink;\n     private final Receiver receiveLink;\n     private final String replyTo;\n     private final MessageSerializer messageSerializer;\n     private final AmqpRetryOptions retryOptions;\n     private final ReactorProvider provider;\n-    private final Duration operationTimeout;\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n     private final AtomicLong requestId = new AtomicLong(0);\n     private final SendLinkHandler sendLinkHandler;\n@@ -89,15 +90,15 @@\n      * @param senderSettleMode to set as {@link SenderSettleMode} on sender.\n      * @param receiverSettleMode to set as {@link ReceiverSettleMode} on receiver.\n      */\n-    protected RequestResponseChannel(String connectionId, String fullyQualifiedNamespace, String linkName,\n-        String entityPath, Session session, AmqpRetryOptions retryOptions, ReactorHandlerProvider handlerProvider,\n-        ReactorProvider provider, MessageSerializer messageSerializer,\n-        SenderSettleMode senderSettleMode, ReceiverSettleMode receiverSettleMode) {\n+    protected RequestResponseChannel(AmqpConnection amqpConnection, String connectionId,\n+        String fullyQualifiedNamespace, String linkName, String entityPath, Session session,\n+        AmqpRetryOptions retryOptions, ReactorHandlerProvider handlerProvider, ReactorProvider provider,\n+        MessageSerializer messageSerializer, SenderSettleMode senderSettleMode,\n+        ReceiverSettleMode receiverSettleMode) {\n         this.connectionId = connectionId;\n         this.linkName = linkName;\n         this.retryOptions = retryOptions;\n         this.provider = provider;\n-        this.operationTimeout = retryOptions.getTryTimeout();\n         this.senderSettleMode = senderSettleMode;\n         this.activeEndpointTimeoutMessage = String.format(\n             \"RequestResponseChannel connectionId[%s], linkName[%s]: Waiting for send and receive handler to be ACTIVE\",\n@@ -144,12 +145,35 @@ protected RequestResponseChannel(String connectionId, String fullyQualifiedNames\n                 }),\n \n             receiveLinkHandler.getEndpointStates().subscribe(\n-                state -> endpointStatesSink.next(AmqpEndpointStateUtil.getConnectionState(state)),\n-                this::handleError, this::dispose),\n+                state -> endpointStates.emitNext(AmqpEndpointStateUtil.getConnectionState(state),\n+                    (signalType, emitResult) -> onEmitSinkFailure(signalType, emitResult,\n+                        \"ReceiveLinkHandler. Error emitting endpoint state.\")),\n+                error -> {\n+                    handleError(error, \"Error in ReceiveLinkHandler.\");\n+                    onTerminalState(\"ReceiveLinkHandler\");\n+                },\n+                () -> {\n+                    disposeAsync(\"ReceiveLinkHandler. Endpoint states complete.\").subscribe();\n+                    onTerminalState(\"ReceiveLinkHandler\");\n+                }),\n \n-            sendLinkHandler.getEndpointStates().subscribe(state ->\n-                endpointStatesSink.next(AmqpEndpointStateUtil.getConnectionState(state)),\n-                this::handleError, this::dispose)\n+            sendLinkHandler.getEndpointStates().subscribe(\n+                state -> endpointStates.emitNext(AmqpEndpointStateUtil.getConnectionState(state),\n+                    (signalType, emitResult) -> onEmitSinkFailure(signalType, emitResult,\n+                        \"SendLinkHandler. Error emitting endpoint state.\")),\n+                error -> {\n+                    handleError(error, \"Error in SendLinkHandler.\");\n+                    onTerminalState(\"SendLinkHandler\");\n+                },\n+                () -> {\n+                    disposeAsync(\"SendLinkHandler. Endpoint states complete.\").subscribe();\n+                    onTerminalState(\"SendLinkHandler\");\n+                }),\n+\n+            amqpConnection.getShutdownSignals().subscribe(signal -> {\n+                logger.verbose(\"connectionId[{}] linkName[{}]: Shutdown signal received.\", connectionId, linkName);\n+                disposeAsync(\"Connection shutdown.\").subscribe();\n+            })\n         );\n \n         //@formatter:on\n@@ -173,18 +197,38 @@ protected RequestResponseChannel(String connectionId, String fullyQualifiedNames\n      * @return The endpoint states for the request/response channel.\n      */\n     public Flux<AmqpEndpointState> getEndpointStates() {\n-        return endpointStates;\n+        return endpointStates.asFlux();\n     }\n \n     @Override\n     public void dispose() {\n+        disposeAsync().block(retryOptions.getTryTimeout());\n+    }\n+\n+    public Mono<Void> disposeAsync() {\n+        return disposeAsync(\"Dispose called.\");\n+    }\n+\n+    private Mono<Void> disposeAsync(String message) {\n         if (isDisposed.getAndSet(true)) {\n-            return;\n+            return closeMono.asMono();\n         }\n \n-        subscriptions.dispose();\n-        sendLink.close();\n-        receiveLink.close();\n+        return Mono.fromRunnable(() -> {\n+            logger.verbose(\"connectionId[{}] linkName[{}] {}\", connectionId, linkName, message);\n+\n+            try {\n+                provider.getReactorDispatcher().invoke(() -> {\n+                    sendLink.close();\n+                    receiveLink.close();\n+                });\n+            } catch (IOException e) {\n+                logger.warning(\"connectionId[{}] linkName[{}] Unable to schedule close work. Closing manually\",\n+                    connectionId, linkName);\n+                sendLink.close();\n+                receiveLink.close();\n+            }\n+        }).then(closeMono.asMono());\n     }\n \n     @Override\n@@ -302,24 +346,50 @@ private void settleMessage(Message message) {\n \n         if (sink == null) {\n             int size = unconfirmedSends.size();\n-            logger.warning(\"{} - Received delivery without pending messageId[{}]. Size[{}]\", linkName, id, size);\n+            logger.warning(\"connectionId[{}] linkName[{}] Received delivery without pending messageId[{}]. size[{}]\",\n+                connectionId, linkName, id, size);\n             return;\n         }\n \n         sink.success(message);\n     }\n \n-    private void handleError(Throwable error) {\n+    private void handleError(Throwable error, String message) {\n         if (hasError.getAndSet(true)) {\n             return;\n         }\n \n-        endpointStatesSink.error(error);\n-        logger.error(\"{} - Exception in RequestResponse links. Disposing and clearing unconfirmed sends.\", linkName,\n+        logger.error(\"connectionId[{}] linkName[{}] {} Disposing unconfirmed sends.\", connectionId, linkName, message,\n             error);\n-        dispose();\n+\n+        endpointStates.emitError(error, (signalType, emitResult) -> {\n+            logger.warning(\"connectionId[{}] linkName[{}] signal[{}] result[{}] Could not emit error to sink.\",\n+                connectionId, linkName, signalType, emitResult);\n+            return false;\n+        });\n \n         unconfirmedSends.forEach((key, value) -> value.error(error));\n         unconfirmedSends.clear();\n+\n+        disposeAsync(\"Disposing channel due to error.\").subscribe();\n+    }\n+\n+    private void onTerminalState(String handlerName) {\n+        final int remaining = pendingDisposes.decrementAndGet();\n+        logger.verbose(\"connectionId[{}] linkName[{}]: {} disposed. Remaining: {}\",\n+            connectionId, linkName, handlerName, remaining);\n+\n+        if (remaining == 0) {\n+            subscriptions.dispose();\n+            closeMono.emitEmpty((signalType, emitResult) -> onEmitSinkFailure(signalType, emitResult,\n+                handlerName + \". Error closing mono.\"));\n+        }\n+    }\n+\n+    private boolean onEmitSinkFailure(SignalType signalType, Sinks.EmitResult emitResult, String message) {\n+        logger.warning(\"connectionId[{}] linkName[{}] signal[{}] result[{}] {}\",\n+            connectionId, linkName, signalType, emitResult, message);\n+\n+        return false;\n     }\n }"
  },
  {
    "sha": "140800ac4ea2fcbaa682fc840c7a2a17d1b1a4e3",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java",
    "status": "modified",
    "additions": 4,
    "deletions": 2,
    "changes": 6,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -61,7 +61,8 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      *     Otherwise, propagates a {@link TimeoutException}.\n      */\n     public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n-        return source.timeout(retryOptions.getTryTimeout())\n+        return source\n+            .timeout(Mono.delay(retryOptions.getTryTimeout()))\n             .retryWhen(createRetry(retryOptions))\n             .doOnError(error -> LOGGER.error(timeoutMessage, error));\n     }\n@@ -75,7 +76,8 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      *     Otherwise, propagates a {@link TimeoutException}.\n      */\n     public static <T> Mono<T> withRetry(Mono<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n-        return source.timeout(retryOptions.getTryTimeout())\n+        return source\n+            .timeout(Mono.delay(retryOptions.getTryTimeout()))\n             .retryWhen(createRetry(retryOptions))\n             .doOnError(error -> LOGGER.error(timeoutMessage, error));\n     }"
  },
  {
    "sha": "6c7053c41aec232e725a80bb13b0c90703894791",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/DispatchHandler.java",
    "status": "modified",
    "additions": 0,
    "deletions": 1,
    "changes": 1,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/DispatchHandler.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/DispatchHandler.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/DispatchHandler.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -31,7 +31,6 @@ public DispatchHandler(Runnable work) {\n      */\n     @Override\n     public void onTimerTask(Event e) {\n-        logger.verbose(\"Running task for event: {}\", e);\n         this.work.run();\n     }\n }"
  },
  {
    "sha": "d379d79ee4dfc3dae5c2ed05341b04d5d45129d6",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/Handler.java",
    "status": "modified",
    "additions": 0,
    "deletions": 2,
    "changes": 2,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/Handler.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/Handler.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/Handler.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -77,7 +77,6 @@ void onError(Throwable error) {\n             return;\n         }\n \n-        endpointSink.next(EndpointState.CLOSED);\n         endpointSink.error(error);\n     }\n \n@@ -91,7 +90,6 @@ public void close() {\n             return;\n         }\n \n-        endpointSink.next(EndpointState.CLOSED);\n         endpointSink.complete();\n     }\n }"
  },
  {
    "sha": "4692c2c51c9f6f3e6ee82e58ab6f1b368959a830",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/SessionHandler.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/SessionHandler.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/SessionHandler.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/handler/SessionHandler.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -82,7 +82,7 @@ public void onSessionRemoteOpen(Event e) {\n                 getConnectionId(), entityName, session.getIncomingCapacity(), session.getOutgoingWindow());\n         }\n \n-        onNext(EndpointState.ACTIVE);\n+        onNext(session.getRemoteState());\n     }\n \n     @Override"
  },
  {
    "sha": "c823f1f06d41cb5481d3365159419c6a9f4ff8bb",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorConnectionTest.java",
    "status": "modified",
    "additions": 259,
    "deletions": 42,
    "changes": 301,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorConnectionTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorConnectionTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorConnectionTest.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -49,8 +49,14 @@\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.TimeoutException;\n-\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyString;\n import static org.mockito.Mockito.mock;\n@@ -61,12 +67,12 @@\n class ReactorConnectionTest {\n     private static final String CONNECTION_ID = \"test-connection-id\";\n     private static final String SESSION_NAME = \"test-session-name\";\n-    private static final Duration TEST_DURATION = Duration.ofSeconds(30);\n+    private static final Duration TEST_DURATION = Duration.ofSeconds(3);\n     private static final ConnectionStringProperties CREDENTIAL_INFO = new ConnectionStringProperties(\"Endpoint=sb\"\n         + \"://test-event-hub.servicebus.windows.net/;SharedAccessKeyName=dummySharedKeyName;\"\n         + \"SharedAccessKey=dummySharedKeyValue;EntityPath=eventhub1;\");\n     private static final String FULLY_QUALIFIED_NAMESPACE = CREDENTIAL_INFO.getEndpoint().getHost();\n-    private static final Scheduler SCHEDULER = Schedulers.elastic();\n+    private static final Scheduler SCHEDULER = Schedulers.boundedElastic();\n     private static final String PRODUCT = \"test\";\n     private static final String CLIENT_VERSION = \"1.0.0-test\";\n     private static final SslDomain.VerifyMode VERIFY_MODE = SslDomain.VerifyMode.VERIFY_PEER_NAME;\n@@ -100,6 +106,10 @@\n     private ReactorProvider reactorProvider;\n     @Mock\n     private ReactorHandlerProvider reactorHandlerProvider;\n+    @Mock\n+    private Event connectionEvent;\n+    @Mock\n+    private Event sessionEvent;\n \n     @BeforeAll\n     static void beforeAll() {\n@@ -113,21 +123,19 @@ static void afterAll() {\n \n     @BeforeEach\n     void setup() throws IOException {\n-        MockitoAnnotations.initMocks(this);\n+        MockitoAnnotations.openMocks(this);\n \n         final AmqpRetryOptions retryOptions = new AmqpRetryOptions().setMaxRetries(0).setTryTimeout(TEST_DURATION);\n         final ConnectionOptions connectionOptions = new ConnectionOptions(CREDENTIAL_INFO.getEndpoint().getHost(),\n             tokenCredential, CbsAuthorizationType.SHARED_ACCESS_SIGNATURE, AmqpTransportType.AMQP, retryOptions,\n             ProxyOptions.SYSTEM_DEFAULTS, SCHEDULER, CLIENT_OPTIONS, VERIFY_MODE, PRODUCT, CLIENT_VERSION);\n \n-        connectionHandler = new ConnectionHandler(CONNECTION_ID, connectionOptions,\n-            peerDetails);\n+        connectionHandler = new ConnectionHandler(CONNECTION_ID, connectionOptions, peerDetails);\n \n         when(reactor.selectable()).thenReturn(selectable);\n         when(reactor.connectionToHost(FULLY_QUALIFIED_NAMESPACE, connectionHandler.getProtocolPort(),\n             connectionHandler))\n             .thenReturn(connectionProtonJ);\n-        when(reactor.process()).thenReturn(true);\n \n         final ReactorDispatcher reactorDispatcher = new ReactorDispatcher(reactor);\n         when(reactorProvider.getReactor()).thenReturn(reactor);\n@@ -144,11 +152,19 @@ void setup() throws IOException {\n \n         connection = new ReactorConnection(CONNECTION_ID, connectionOptions, reactorProvider, reactorHandlerProvider,\n             tokenManager, messageSerializer, SenderSettleMode.SETTLED, ReceiverSettleMode.FIRST);\n+\n+        // Setting up onConnectionRemoteOpen.\n+        when(connectionEvent.getConnection()).thenReturn(connectionProtonJ);\n+        when(connectionEvent.getReactor()).thenReturn(reactor);\n+\n+        when(sessionEvent.getSession()).thenReturn(session);\n     }\n \n     @AfterEach\n     void teardown() {\n-        connection.dispose();\n+        connectionHandler.close();\n+        sessionHandler.close();\n+\n         // Tear down any inline mocks to avoid memory leaks.\n         // https://github.com/mockito/mockito/wiki/What's-new-in-Mockito-2#mockito-2250\n         Mockito.framework().clearInlineMocks();\n@@ -180,7 +196,7 @@ void createConnection() {\n             final String actual = String.valueOf(removed);\n             Assertions.assertEquals(expected, actual);\n         });\n-        Assertions.assertTrue(connection.getConnectionProperties().isEmpty());\n+        assertTrue(connection.getConnectionProperties().isEmpty());\n     }\n \n     /**\n@@ -195,14 +211,22 @@ void createSession() {\n         when(reactor.connectionToHost(connectionHandler.getHostname(), connectionHandler.getProtocolPort(),\n             connectionHandler)).thenReturn(connectionProtonJ);\n         when(connectionProtonJ.session()).thenReturn(session);\n+\n         when(session.attachments()).thenReturn(record);\n+        when(session.getRemoteState()).thenReturn(EndpointState.ACTIVE);\n+\n+        // We only want it to emit a session when it is active.\n+        when(connectionProtonJ.getRemoteState()).thenReturn(EndpointState.ACTIVE);\n+        connectionHandler.onConnectionRemoteOpen(connectionEvent);\n+\n+        sessionHandler.onSessionRemoteOpen(sessionEvent);\n \n         // Act & Assert\n         StepVerifier.create(connection.createSession(SESSION_NAME))\n             .assertNext(s -> {\n                 Assertions.assertNotNull(s);\n                 Assertions.assertEquals(SESSION_NAME, s.getSessionName());\n-                Assertions.assertTrue(s instanceof ReactorSession);\n+                assertTrue(s instanceof ReactorSession);\n                 Assertions.assertSame(session, ((ReactorSession) s).session());\n             }).verifyComplete();\n \n@@ -211,13 +235,39 @@ void createSession() {\n             .assertNext(s -> {\n                 Assertions.assertNotNull(s);\n                 Assertions.assertEquals(SESSION_NAME, s.getSessionName());\n-                Assertions.assertTrue(s instanceof ReactorSession);\n+                assertTrue(s instanceof ReactorSession);\n                 Assertions.assertSame(session, ((ReactorSession) s).session());\n             }).verifyComplete();\n \n         verify(record).set(Handler.class, Handler.class, sessionHandler);\n     }\n \n+    @Test\n+    void doesNotCreateSessionWhenConnectionInactive() {\n+        // Arrange\n+        // We want to ensure that the ReactorExecutor does not shutdown unexpectedly. There are still items to still\n+        // process.\n+        when(reactor.process()).thenReturn(true);\n+        when(reactor.connectionToHost(connectionHandler.getHostname(), connectionHandler.getProtocolPort(),\n+            connectionHandler)).thenReturn(connectionProtonJ);\n+        when(connectionProtonJ.session()).thenReturn(session);\n+\n+        when(session.attachments()).thenReturn(record);\n+        when(session.getRemoteState()).thenReturn(EndpointState.ACTIVE);\n+\n+        // We only want it to emit a session when it is active.\n+        when(connectionProtonJ.getLocalState()).thenReturn(EndpointState.ACTIVE);\n+        when(connectionProtonJ.getRemoteState()).thenReturn(EndpointState.UNINITIALIZED);\n+\n+        // Act & Assert\n+        StepVerifier.create(connection.createSession(SESSION_NAME))\n+            .expectErrorSatisfies(error -> {\n+                assertTrue(error instanceof AmqpException);\n+                assertFalse(((AmqpException) error).isTransient());\n+            })\n+            .verify();\n+    }\n+\n     /**\n      * Creates a session with the given name and set handler.\n      */\n@@ -227,11 +277,22 @@ void removeSessionThatExists() {\n         // We want to ensure that the ReactorExecutor does not shutdown unexpectedly. There are still items to still\n         // process.\n         when(reactor.process()).thenReturn(true);\n+\n+        final Record reactorRecord = mock(Record.class);\n+        when(reactor.attachments()).thenReturn(reactorRecord);\n         when(reactor.connectionToHost(connectionHandler.getHostname(), connectionHandler.getProtocolPort(),\n             connectionHandler)).thenReturn(connectionProtonJ);\n         when(connectionProtonJ.session()).thenReturn(session);\n         when(session.attachments()).thenReturn(record);\n \n+        when(session.getRemoteState()).thenReturn(EndpointState.ACTIVE);\n+\n+        // We only want it to emit a session when it is active.\n+        when(connectionProtonJ.getRemoteState()).thenReturn(EndpointState.ACTIVE);\n+        connectionHandler.onConnectionRemoteOpen(connectionEvent);\n+\n+        sessionHandler.onSessionRemoteOpen(sessionEvent);\n+\n         // Act & Assert\n         StepVerifier.create(connection.createSession(SESSION_NAME).map(s -> connection.removeSession(s.getSessionName())))\n             .expectNext(true)\n@@ -254,6 +315,14 @@ void removeSessionThatDoesNotExist() {\n         when(connectionProtonJ.session()).thenReturn(session);\n         when(session.attachments()).thenReturn(record);\n \n+        when(session.getRemoteState()).thenReturn(EndpointState.ACTIVE);\n+\n+        // We only want it to emit a session when it is active.\n+        when(connectionProtonJ.getRemoteState()).thenReturn(EndpointState.ACTIVE);\n+        connectionHandler.onConnectionRemoteOpen(connectionEvent);\n+\n+        sessionHandler.onSessionRemoteOpen(sessionEvent);\n+\n         // Act & Assert\n         StepVerifier.create(connection.createSession(SESSION_NAME).map(s -> connection.removeSession(\"does-not-exist\")))\n             .expectNext(false)\n@@ -267,11 +336,15 @@ void removeSessionThatDoesNotExist() {\n      */\n     @Test\n     void initialConnectionState() {\n+        // We want to ensure that the ReactorExecutor does not shutdown unexpectedly. There are still items to still\n+        // process.\n+        when(reactor.process()).thenReturn(true);\n+\n         // Assert\n         StepVerifier.create(connection.getEndpointStates())\n             .expectNext(AmqpEndpointState.UNINITIALIZED)\n-            .then(() -> connection.dispose())\n-            .verifyComplete();\n+            .thenCancel()\n+            .verify();\n     }\n \n     /**\n@@ -280,6 +353,10 @@ void initialConnectionState() {\n     @Test\n     void onConnectionStateOpen() {\n         // Arrange\n+        // We want to ensure that the ReactorExecutor does not shutdown unexpectedly. There are still items to still\n+        // process.\n+        when(reactor.process()).thenReturn(true);\n+\n         final Event event = mock(Event.class);\n         when(event.getConnection()).thenReturn(connectionProtonJ);\n         when(connectionProtonJ.getHostname()).thenReturn(FULLY_QUALIFIED_NAMESPACE);\n@@ -292,11 +369,9 @@ void onConnectionStateOpen() {\n             .then(() -> connectionHandler.onConnectionRemoteOpen(event))\n             .expectNext(AmqpEndpointState.ACTIVE)\n             // getConnectionStates is distinct. We don't expect to see another event with the same status.\n-            .then(() -> {\n-                connectionHandler.onConnectionRemoteOpen(event);\n-                connection.dispose();\n-            })\n-            .verifyComplete();\n+            .then(() -> connectionHandler.onConnectionRemoteOpen(event))\n+            .thenCancel()\n+            .verify();\n     }\n \n     /**\n@@ -305,14 +380,18 @@ void onConnectionStateOpen() {\n     @Test\n     void createCBSNode() {\n         // Arrange\n+        // We want to ensure that the ReactorExecutor does not shutdown unexpectedly. There are still items to still\n+        // process.\n+        when(reactor.process()).thenReturn(true);\n+\n         when(connectionProtonJ.getRemoteState()).thenReturn(EndpointState.ACTIVE);\n         final Event mock = mock(Event.class);\n         when(mock.getConnection()).thenReturn(connectionProtonJ);\n         connectionHandler.onConnectionRemoteOpen(mock);\n \n         // Act and Assert\n         StepVerifier.create(this.connection.getClaimsBasedSecurityNode())\n-            .assertNext(node -> Assertions.assertTrue(node instanceof ClaimsBasedSecurityChannel))\n+            .assertNext(node -> assertTrue(node instanceof ClaimsBasedSecurityChannel))\n             .verifyComplete();\n     }\n \n@@ -322,6 +401,10 @@ void createCBSNode() {\n     @Test\n     void createCBSNodeTimeoutException() {\n         // Arrange\n+        // We want to ensure that the ReactorExecutor does not shutdown unexpectedly. There are still items to still\n+        // process.\n+        when(reactor.process()).thenReturn(true);\n+\n         final Duration timeout = Duration.ofSeconds(2);\n         final AmqpRetryOptions retryOptions = new AmqpRetryOptions()\n             .setMaxRetries(1)\n@@ -348,14 +431,125 @@ void createCBSNodeTimeoutException() {\n             reactorProvider, provider, tokenManager, messageSerializer, SenderSettleMode.SETTLED,\n             ReceiverSettleMode.FIRST);\n \n-        try {\n-            StepVerifier.create(connectionBad.getClaimsBasedSecurityNode())\n-                .expectErrorSatisfies(error -> Assertions.assertTrue(error instanceof TimeoutException\n-                    || error.getCause() instanceof TimeoutException))\n-                .verify();\n-        } finally {\n-            connectionBad.dispose();\n-        }\n+        StepVerifier.create(connectionBad.getClaimsBasedSecurityNode())\n+            .expectErrorSatisfies(error -> {\n+                assertTrue(error instanceof AmqpException);\n+\n+                final AmqpException amqpException = (AmqpException) error;\n+                assertFalse(amqpException.isTransient());\n+                assertNull(amqpException.getErrorCondition());\n+\n+                assertNotNull(amqpException.getMessage());\n+                assertTrue(amqpException.getMessage().contains(\"not opened within operation timeout\"));\n+\n+                assertNotNull(amqpException.getContext());\n+                assertEquals(FULLY_QUALIFIED_NAMESPACE, amqpException.getContext().getNamespace());\n+            })\n+            .verify();\n+    }\n+\n+    /**\n+     * Ensures we get correct endpoints until connection is closed.\n+     */\n+    @Test\n+    void endpointStatesOnDispose() {\n+        // Arrange\n+        // We want to ensure that the ReactorExecutor does not shutdown unexpectedly. There are still items to still\n+        // process.\n+        when(reactor.process()).thenReturn(true);\n+\n+        when(connectionProtonJ.getRemoteState()).thenReturn(EndpointState.ACTIVE, EndpointState.CLOSED,\n+            EndpointState.CLOSED);\n+        final Event mock = mock(Event.class);\n+        when(mock.getConnection()).thenReturn(connectionProtonJ);\n+        connectionHandler.onConnectionRemoteOpen(mock);\n+\n+        final Event closeEvent = mock(Event.class);\n+        when(closeEvent.getConnection()).thenReturn(connectionProtonJ);\n+\n+        final Event finalEvent = mock(Event.class);\n+        when(finalEvent.getConnection()).thenReturn(connectionProtonJ);\n+\n+        // Act and Assert\n+        StepVerifier.create(connection.getEndpointStates())\n+            .expectNext(AmqpEndpointState.ACTIVE)\n+            .then(() -> connectionHandler.onConnectionRemoteClose(closeEvent))\n+            .expectNext(AmqpEndpointState.CLOSED)\n+            .then(() -> connectionHandler.onConnectionFinal(finalEvent))\n+            .verifyComplete();\n+\n+        StepVerifier.create(connection.getEndpointStates())\n+            .expectNext(AmqpEndpointState.CLOSED)\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Ensures we get correct shutdown signal when connection is closed.\n+     */\n+    @Test\n+    void shutdownSignalsOnDispose() {\n+        // Arrange\n+        final AtomicBoolean isOpen = new AtomicBoolean(true);\n+        // We want to ensure that the ReactorExecutor does not shutdown unexpectedly. There are still items to still\n+        // process.\n+        when(reactor.process()).thenAnswer(invocation -> isOpen.get());\n+\n+        when(connectionProtonJ.getRemoteState()).thenReturn(EndpointState.ACTIVE, EndpointState.CLOSED,\n+            EndpointState.CLOSED);\n+        final Event mock = mock(Event.class);\n+        when(mock.getConnection()).thenReturn(connectionProtonJ);\n+        connectionHandler.onConnectionRemoteOpen(mock);\n+\n+        final Event closeEvent = mock(Event.class);\n+        when(closeEvent.getConnection()).thenReturn(connectionProtonJ);\n+\n+        final Event finalEvent = mock(Event.class);\n+        when(finalEvent.getConnection()).thenReturn(connectionProtonJ);\n+\n+        // Act and Assert\n+        StepVerifier.create(connection.getShutdownSignals())\n+            .then(() -> {\n+                connection.getReactorConnection().subscribe();\n+                isOpen.set(false);\n+            })\n+            .assertNext(signal -> {\n+                assertFalse(signal.isInitiatedByClient());\n+                assertFalse(signal.isTransient());\n+            })\n+            .verifyComplete();\n+    }\n+\n+    @Test\n+    void connectionDisposeFinishesReactor() {\n+        // Arrange\n+        final AtomicBoolean isOpen = new AtomicBoolean(true);\n+        // We want to ensure that the ReactorExecutor does not shutdown unexpectedly. There are still items to still\n+        // process.\n+        when(reactor.process()).thenAnswer(invocation -> isOpen.get());\n+\n+        when(connectionProtonJ.getRemoteState()).thenReturn(EndpointState.ACTIVE, EndpointState.CLOSED,\n+            EndpointState.CLOSED);\n+        final Event mock = mock(Event.class);\n+        when(mock.getConnection()).thenReturn(connectionProtonJ);\n+        connectionHandler.onConnectionRemoteOpen(mock);\n+\n+        final Event closeEvent = mock(Event.class);\n+        when(closeEvent.getConnection()).thenReturn(connectionProtonJ);\n+\n+        final Event finalEvent = mock(Event.class);\n+        when(finalEvent.getConnection()).thenReturn(connectionProtonJ);\n+\n+        // Act and Assert\n+        StepVerifier.create(connection.getShutdownSignals())\n+            .then(() -> {\n+                connection.getReactorConnection().subscribe();\n+                isOpen.set(false);\n+            })\n+            .assertNext(signal -> {\n+                assertFalse(signal.isInitiatedByClient());\n+                assertFalse(signal.isTransient());\n+            })\n+            .verifyComplete();\n     }\n \n     /**\n@@ -364,11 +558,29 @@ void createCBSNodeTimeoutException() {\n     @Test\n     void cannotCreateResourcesOnFailure() {\n         // Arrange\n+        // We want to ensure that the ReactorExecutor does not shutdown unexpectedly. There are still items to still\n+        // process.\n+        when(reactor.process()).thenReturn(true);\n+\n         final Event event = mock(Event.class);\n         final Transport transport = mock(Transport.class);\n-        final AmqpErrorCondition condition = AmqpErrorCondition.NOT_FOUND;\n+        final AmqpErrorCondition condition = AmqpErrorCondition.LINK_STOLEN;\n         final ErrorCondition errorCondition = new ErrorCondition(Symbol.getSymbol(condition.getErrorCondition()),\n             \"Not found\");\n+        final Consumer<Throwable> assertException = error -> {\n+            final AmqpException amqpException;\n+            if (error instanceof AmqpException) {\n+                amqpException = (AmqpException) error;\n+            } else if (error.getCause() instanceof AmqpException) {\n+                amqpException = (AmqpException) error.getCause();\n+            } else {\n+                amqpException = null;\n+                Assertions.fail(\"Exception was not the correct type: \" + error);\n+            }\n+\n+            assertFalse(amqpException.isTransient());\n+            assertEquals(condition, amqpException.getErrorCondition());\n+        };\n \n         when(event.getTransport()).thenReturn(transport);\n         when(event.getConnection()).thenReturn(connectionProtonJ);\n@@ -381,19 +593,20 @@ void cannotCreateResourcesOnFailure() {\n \n         // Act & Assert\n         StepVerifier.create(connection.getClaimsBasedSecurityNode())\n-            .expectErrorSatisfies(e -> {\n-                final AmqpException amqpException;\n-                if (e instanceof AmqpException) {\n-                    amqpException = (AmqpException) e;\n-                } else if (e.getCause() instanceof AmqpException) {\n-                    amqpException = (AmqpException) e.getCause();\n-                } else {\n-                    amqpException = null;\n-                    Assertions.fail(\"Exception was not the correct type: \" + e);\n-                }\n-\n-                Assertions.assertEquals(condition, amqpException.getErrorCondition());\n-            })\n+            .expectErrorSatisfies(assertException)\n+            .verify();\n+\n+        StepVerifier.create(connection.getReactorConnection())\n+            .expectErrorSatisfies(assertException)\n+            .verify();\n+\n+        StepVerifier.create(connection.createRequestResponseChannel(SESSION_NAME, \"test-link-name\",\n+            \"test-entity-path\"))\n+            .expectErrorSatisfies(assertException)\n+            .verify();\n+\n+        StepVerifier.create(connection.createSession(SESSION_NAME))\n+            .expectErrorSatisfies(assertException)\n             .verify();\n \n         verify(transport, times(1)).unbind();\n@@ -404,6 +617,10 @@ void cannotCreateResourcesOnFailure() {\n      */\n     @Test\n     void setsPropertiesUsingCustomEndpoint() throws IOException {\n+        // We want to ensure that the ReactorExecutor does not shutdown unexpectedly. There are still items to still\n+        // process.\n+        when(reactor.process()).thenReturn(true);\n+\n         final String connectionId = \"new-connection-id\";\n         final String hostname = \"custom-endpoint.com\";\n         final int port = 10002;"
  },
  {
    "sha": "6a506f308aec625303af5633fea4a88f370afddd",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorReceiverTest.java",
    "status": "modified",
    "additions": 249,
    "deletions": 9,
    "changes": 258,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorReceiverTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorReceiverTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorReceiverTest.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -3,10 +3,14 @@\n \n package com.azure.core.amqp.implementation;\n \n+import com.azure.core.amqp.AmqpConnection;\n import com.azure.core.amqp.AmqpEndpointState;\n import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpShutdownSignal;\n import com.azure.core.amqp.ClaimsBasedSecurityNode;\n import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpException;\n import com.azure.core.amqp.implementation.handler.ReceiveLinkHandler;\n import org.apache.qpid.proton.amqp.Symbol;\n import org.apache.qpid.proton.amqp.messaging.Source;\n@@ -33,6 +37,7 @@\n import org.mockito.MockitoAnnotations;\n import reactor.core.publisher.Mono;\n import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n \n import java.io.IOException;\n import java.time.Duration;\n@@ -41,8 +46,13 @@\n import java.util.function.Supplier;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.times;\n@@ -63,13 +73,18 @@\n     @Mock\n     private Record record;\n     @Mock\n-    private ReactorDispatcher dispatcher;\n+    private ReactorDispatcher reactorDispatcher;\n     @Mock\n     private Supplier<Integer> creditSupplier;\n+    @Mock\n+    private AmqpConnection amqpConnection;\n \n     @Captor\n     private ArgumentCaptor<Runnable> dispatcherCaptor;\n \n+    private final TestPublisher<AmqpShutdownSignal> shutdownSignals = TestPublisher.create();\n+    private final AmqpRetryOptions retryOptions = new AmqpRetryOptions();\n+\n     private ReceiveLinkHandler receiverHandler;\n     private ReactorReceiver reactorReceiver;\n \n@@ -85,7 +100,7 @@ static void afterAll() {\n \n     @BeforeEach\n     void setup() {\n-        MockitoAnnotations.initMocks(this);\n+        MockitoAnnotations.openMocks(this);\n \n         when(cbsNode.authorize(any(), any())).thenReturn(Mono.empty());\n \n@@ -101,7 +116,10 @@ void setup() {\n         final ActiveClientTokenManager tokenManager = new ActiveClientTokenManager(Mono.just(cbsNode),\n             \"test-tokenAudience\", \"test-scopes\");\n \n-        reactorReceiver = new ReactorReceiver(entityPath, receiver, receiverHandler, tokenManager, dispatcher);\n+        when(amqpConnection.getShutdownSignals()).thenReturn(shutdownSignals.flux());\n+\n+        reactorReceiver = new ReactorReceiver(amqpConnection, entityPath, receiver, receiverHandler, tokenManager,\n+            reactorDispatcher, retryOptions);\n     }\n \n     @AfterEach\n@@ -122,7 +140,7 @@ void addCredits() throws IOException {\n         reactorReceiver.addCredits(credits);\n \n         // Assert\n-        verify(dispatcher).invoke(dispatcherCaptor.capture());\n+        verify(reactorDispatcher).invoke(dispatcherCaptor.capture());\n \n         final List<Runnable> invocations = dispatcherCaptor.getAllValues();\n         assertEquals(1, invocations.size());\n@@ -143,7 +161,6 @@ void updateEndpointState() {\n             .then(() -> receiverHandler.onLinkRemoteOpen(event))\n             .expectNext(AmqpEndpointState.ACTIVE)\n             .then(() -> receiverHandler.close())\n-            .expectNext(AmqpEndpointState.CLOSED)\n             .verifyComplete();\n     }\n \n@@ -239,17 +256,17 @@ void addsMoreCreditsWhenPrefetchIsDone() throws IOException {\n                 Assertions.assertNotNull(message.getMessageAnnotations());\n \n                 final Map<Symbol, Object> values = message.getMessageAnnotations().getValue();\n-                Assertions.assertTrue(values.containsKey(Symbol.getSymbol(AmqpMessageConstant.OFFSET_ANNOTATION_NAME.getValue())));\n-                Assertions.assertTrue(values.containsKey(Symbol.getSymbol(AmqpMessageConstant.SEQUENCE_NUMBER_ANNOTATION_NAME.getValue())));\n-                Assertions.assertTrue(values.containsKey(Symbol.getSymbol(AmqpMessageConstant.ENQUEUED_TIME_UTC_ANNOTATION_NAME.getValue())));\n+                assertTrue(values.containsKey(Symbol.getSymbol(AmqpMessageConstant.OFFSET_ANNOTATION_NAME.getValue())));\n+                assertTrue(values.containsKey(Symbol.getSymbol(AmqpMessageConstant.SEQUENCE_NUMBER_ANNOTATION_NAME.getValue())));\n+                assertTrue(values.containsKey(Symbol.getSymbol(AmqpMessageConstant.ENQUEUED_TIME_UTC_ANNOTATION_NAME.getValue())));\n             })\n             .thenCancel()\n             .verify();\n \n         verify(creditSupplier).get();\n \n         // Verify that the get addCredits was called on that dispatcher.\n-        verify(dispatcher).invoke(dispatcherCaptor.capture());\n+        verify(reactorDispatcher).invoke(dispatcherCaptor.capture());\n \n         final List<Runnable> invocations = dispatcherCaptor.getAllValues();\n         assertEquals(1, invocations.size());\n@@ -259,4 +276,227 @@ void addsMoreCreditsWhenPrefetchIsDone() throws IOException {\n \n         verify(receiver).flow(10);\n     }\n+\n+    /**\n+     * Verifies that when an exception occurs in the parent, the connection is also closed.\n+     */\n+    @Test\n+    void parentDisposesConnection() {\n+        // Arrange\n+        final AmqpShutdownSignal shutdownSignal = new AmqpShutdownSignal(false, false,\n+            \"Test-shutdown-signal\");\n+        final Event event = mock(Event.class);\n+        final Link link = mock(Link.class);\n+\n+        when(link.getLocalState()).thenReturn(EndpointState.ACTIVE);\n+\n+        when(event.getLink()).thenReturn(link);\n+\n+        doAnswer(invocationOnMock -> {\n+            receiverHandler.onLinkRemoteClose(event);\n+            return null;\n+        }).when(receiver).close();\n+\n+        // Act\n+        shutdownSignals.next(shutdownSignal);\n+\n+        invokeDispatcher();\n+\n+        // Assert\n+        assertTrue(reactorReceiver.isDisposed());\n+\n+        verify(receiver).close();\n+    }\n+\n+    /**\n+     * Verifies that when an exception occurs in the parent, the endpoints are also disposed.\n+     */\n+    @Test\n+    void parentClosesEndpoint() {\n+        // Arrange\n+        final AmqpShutdownSignal shutdownSignal = new AmqpShutdownSignal(false, false, \"Test-shutdown-signal\");\n+        final Event event = mock(Event.class);\n+        final Link link = mock(Link.class);\n+\n+        when(link.getLocalState()).thenReturn(EndpointState.ACTIVE);\n+\n+        when(event.getLink()).thenReturn(link);\n+\n+        doAnswer(invocationOnMock -> {\n+            receiverHandler.onLinkRemoteClose(event);\n+            return null;\n+        }).when(receiver).close();\n+\n+        // Act\n+        StepVerifier.create(reactorReceiver.getEndpointStates())\n+            .expectNext(AmqpEndpointState.UNINITIALIZED)\n+            .then(() -> {\n+                shutdownSignals.next(shutdownSignal);\n+                invokeDispatcher();\n+            })\n+            .expectComplete()\n+            .verify();\n+\n+        // Assert\n+        assertTrue(reactorReceiver.isDisposed());\n+\n+        verify(receiver).close();\n+    }\n+\n+    /**\n+     * An error in the handler will also close the sender.\n+     */\n+    @Test\n+    void disposesOnHandlerError() {\n+        // Arrange\n+        final AmqpErrorCondition amqpErrorCondition = AmqpErrorCondition.CONNECTION_FRAMING_ERROR;\n+        final Event event = mock(Event.class);\n+        final Link link = mock(Link.class);\n+        final ErrorCondition errorCondition = new ErrorCondition(\n+            Symbol.getSymbol(amqpErrorCondition.getErrorCondition()), \"Test error condition\");\n+\n+        when(link.getLocalState()).thenReturn(EndpointState.ACTIVE);\n+        when(link.getRemoteCondition()).thenReturn(errorCondition);\n+\n+        when(event.getLink()).thenReturn(link);\n+\n+        // Act and Assert\n+        StepVerifier.create(reactorReceiver.getEndpointStates())\n+            .expectNext(AmqpEndpointState.UNINITIALIZED)\n+            .then(() -> receiverHandler.onLinkRemoteClose(event))\n+            .expectErrorSatisfies(error -> {\n+                assertTrue(error instanceof AmqpException);\n+                assertEquals(((AmqpException) error).getErrorCondition(), amqpErrorCondition);\n+            })\n+            .verify();\n+\n+        assertTrue(reactorReceiver.isDisposed());\n+    }\n+\n+    /**\n+     * A complete in the handler will also close the sender.\n+     */\n+    @Test\n+    void disposesOnHandlerComplete() {\n+        // Arrange\n+        final Event event = mock(Event.class);\n+        final Link link = mock(Link.class);\n+\n+        when(link.getLocalState()).thenReturn(EndpointState.ACTIVE);\n+\n+        when(event.getLink()).thenReturn(link);\n+\n+        doAnswer(invocationOnMock -> {\n+            receiverHandler.onLinkRemoteClose(event);\n+            return null;\n+        }).when(receiver).close();\n+\n+        // Act and Assert\n+        StepVerifier.create(reactorReceiver.getEndpointStates())\n+            .expectNext(AmqpEndpointState.UNINITIALIZED)\n+            .then(() -> receiverHandler.onLinkFinal(event))\n+            .verifyComplete();\n+\n+        assertTrue(reactorReceiver.isDisposed());\n+    }\n+\n+    /**\n+     * Tests {@link ReactorReceiver#dispose(String, ErrorCondition)}.\n+     */\n+    @Test\n+    void disposeCompletes() {\n+        // Arrange\n+        final String message = \"some-message\";\n+        final AmqpErrorCondition errorCondition = AmqpErrorCondition.UNAUTHORIZED_ACCESS;\n+        final ErrorCondition condition = new ErrorCondition(Symbol.getSymbol(errorCondition.getErrorCondition()),\n+            \"Test-users\");\n+        final Event event = mock(Event.class);\n+\n+        when(receiver.getLocalState()).thenReturn(EndpointState.ACTIVE, EndpointState.CLOSED);\n+\n+        when(event.getLink()).thenReturn(receiver);\n+\n+        doAnswer(invocationOnMock -> {\n+            receiverHandler.onLinkRemoteClose(event);\n+            return null;\n+        }).when(receiver).close();\n+\n+        // Act\n+        StepVerifier.create(reactorReceiver.dispose(message, condition))\n+            .then(() -> invokeDispatcher())\n+            .expectComplete()\n+            .verify();\n+\n+        // Expect the same outcome.\n+        StepVerifier.create(reactorReceiver.dispose(\"something\", null))\n+            .expectComplete()\n+            .verify();\n+\n+        StepVerifier.create(reactorReceiver.isClosed())\n+            .expectComplete()\n+            .verify();\n+\n+        // Assert\n+        assertTrue(reactorReceiver.isDisposed());\n+\n+        verify(receiver).setCondition(condition);\n+        verify(receiver).close();\n+\n+        shutdownSignals.assertNoSubscribers();\n+    }\n+\n+    /**\n+     * Tests {@link ReactorReceiver#dispose()}.\n+     */\n+    @Test\n+    void disposeBlocking() throws IOException {\n+        // Arrange\n+        final Event event = mock(Event.class);\n+        final Link link = mock(Link.class);\n+\n+        when(link.getLocalState()).thenReturn(EndpointState.ACTIVE);\n+\n+        when(event.getLink()).thenReturn(link);\n+\n+        doAnswer(invocationOnMock -> {\n+            final Runnable runnable = invocationOnMock.getArgument(0);\n+            runnable.run();\n+            return null;\n+        }).when(reactorDispatcher).invoke(any(Runnable.class));\n+\n+        doAnswer(invocationOnMock -> {\n+            receiverHandler.onLinkRemoteClose(event);\n+            return null;\n+        }).when(receiver).close();\n+\n+        // Act\n+        reactorReceiver.dispose();\n+\n+        // Assert\n+        StepVerifier.create(reactorReceiver.isClosed())\n+            .expectComplete()\n+            .verify();\n+\n+        assertTrue(reactorReceiver.isDisposed());\n+\n+        verify(receiver).close();\n+\n+        shutdownSignals.assertNoSubscribers();\n+    }\n+\n+    /**\n+     * Manually captures the Runnable in the dispatcher so we can invoke it to verify contents.\n+     */\n+    private void invokeDispatcher() {\n+        try {\n+            verify(reactorDispatcher, atLeastOnce()).invoke(dispatcherCaptor.capture());\n+        } catch (IOException e) {\n+            fail(\"Should not have caused an IOException. \" + e);\n+        }\n+\n+        dispatcherCaptor.getAllValues().forEach(work -> {\n+            assertNotNull(work);\n+            work.run();\n+        });\n+    }\n }"
  },
  {
    "sha": "aa63154efa1afa25fabe2059aaedff59cbd2ee17",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java",
    "status": "modified",
    "additions": 297,
    "deletions": 25,
    "changes": 322,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -3,17 +3,23 @@\n \n package com.azure.core.amqp.implementation;\n \n+import com.azure.core.amqp.AmqpConnection;\n+import com.azure.core.amqp.AmqpEndpointState;\n import com.azure.core.amqp.AmqpRetryMode;\n import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpShutdownSignal;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n import com.azure.core.amqp.exception.AmqpException;\n import com.azure.core.amqp.exception.AmqpResponseCode;\n import com.azure.core.amqp.implementation.handler.SendLinkHandler;\n import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Symbol;\n import org.apache.qpid.proton.amqp.UnsignedLong;\n import org.apache.qpid.proton.amqp.messaging.Accepted;\n import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n import org.apache.qpid.proton.amqp.transaction.TransactionalState;\n import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n import org.apache.qpid.proton.engine.Delivery;\n import org.apache.qpid.proton.engine.EndpointState;\n import org.apache.qpid.proton.engine.Record;\n@@ -32,20 +38,25 @@\n import org.mockito.Mockito;\n import org.mockito.MockitoAnnotations;\n import reactor.core.publisher.Flux;\n-import reactor.core.publisher.FluxSink;\n import reactor.core.publisher.Mono;\n-import reactor.core.publisher.ReplayProcessor;\n import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n \n import java.io.IOException;\n import java.time.Duration;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.ArgumentMatchers.isNull;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.doNothing;\n import static org.mockito.Mockito.doReturn;\n import static org.mockito.Mockito.mock;\n@@ -58,9 +69,12 @@\n  * Unit tests for {@link ReactorSender}\n  */\n public class ReactorSenderTest {\n-\n     private static final String ENTITY_PATH = \"entity-path\";\n+    private final TestPublisher<AmqpShutdownSignal> shutdownSignals = TestPublisher.create();\n+    private final TestPublisher<EndpointState> endpointStatePublisher = TestPublisher.createCold();\n \n+    @Mock\n+    private AmqpConnection amqpConnection;\n     @Mock\n     private Sender sender;\n     @Mock\n@@ -77,6 +91,8 @@\n     private MessageSerializer messageSerializer;\n     @Mock\n     private TransactionalState transactionalState;\n+    @Mock\n+    private ReactorDispatcher reactorDispatcher;\n \n     @Captor\n     private ArgumentCaptor<Runnable> dispatcherCaptor;\n@@ -88,7 +104,9 @@\n \n     @BeforeEach\n     public void setup() throws IOException {\n-        MockitoAnnotations.initMocks(this);\n+        MockitoAnnotations.openMocks(this);\n+\n+        when(amqpConnection.getShutdownSignals()).thenReturn(shutdownSignals.flux());\n \n         Delivery delivery = mock(Delivery.class);\n         when(delivery.getRemoteState()).thenReturn(Accepted.getInstance());\n@@ -98,10 +116,8 @@ public void setup() throws IOException {\n \n         when(handler.getLinkCredits()).thenReturn(Flux.just(100));\n \n-        final ReplayProcessor<EndpointState> endpointStateReplayProcessor = ReplayProcessor.cacheLast();\n-        when(handler.getEndpointStates()).thenReturn(endpointStateReplayProcessor);\n-        FluxSink<EndpointState> sink1 = endpointStateReplayProcessor.sink();\n-        sink1.next(EndpointState.ACTIVE);\n+        when(handler.getEndpointStates()).thenReturn(endpointStatePublisher.flux());\n+        endpointStatePublisher.next(EndpointState.ACTIVE);\n \n         when(tokenManager.getAuthorizationResults()).thenReturn(Flux.just(AmqpResponseCode.ACCEPTED));\n         when(sender.getCredit()).thenReturn(100);\n@@ -112,7 +128,6 @@ public void setup() throws IOException {\n         doNothing().when(selectable).setReading(true);\n         doNothing().when(reactor).update(selectable);\n \n-        ReactorDispatcher reactorDispatcher = new ReactorDispatcher(reactor);\n         when(reactor.attachments()).thenReturn(new Record() {\n             @Override\n             public <T> T get(Object o, Class<T> aClass) {\n@@ -125,14 +140,13 @@ public void setup() throws IOException {\n \n             @Override\n             public void clear() {\n-\n             }\n         });\n         when(reactorProvider.getReactorDispatcher()).thenReturn(reactorDispatcher);\n         when(sender.getRemoteMaxMessageSize()).thenReturn(UnsignedLong.valueOf(1000));\n \n         options = new AmqpRetryOptions()\n-            .setTryTimeout(Duration.ofSeconds(1))\n+            .setTryTimeout(Duration.ofSeconds(10))\n             .setMode(AmqpRetryMode.EXPONENTIAL);\n \n         message = Proton.message();\n@@ -149,8 +163,8 @@ void teardown() {\n \n     @Test\n     public void testLinkSize() {\n-        final ReactorSender reactorSender = new ReactorSender(ENTITY_PATH, sender, handler, reactorProvider,\n-            tokenManager, messageSerializer, options);\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, ENTITY_PATH, sender, handler,\n+            reactorProvider, tokenManager, messageSerializer, options);\n \n         StepVerifier.create(reactorSender.getLinkSize())\n             .expectNext(1000)\n@@ -167,8 +181,8 @@ public void testSendWithTransactionFailed() {\n         // Arrange\n         final String exceptionString = \"fake exception\";\n \n-        final ReactorSender reactorSender = new ReactorSender(ENTITY_PATH, sender, handler, reactorProvider,\n-            tokenManager, messageSerializer, options);\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, ENTITY_PATH, sender, handler,\n+            reactorProvider, tokenManager, messageSerializer, options);\n         final ReactorSender spyReactorSender = spy(reactorSender);\n \n         final Throwable exception = new RuntimeException(exceptionString);\n@@ -191,8 +205,8 @@ public void testSendWithTransactionFailed() {\n     @Test\n     public void testSendWithTransaction() {\n         // Arrange\n-        final ReactorSender reactorSender = new ReactorSender(ENTITY_PATH, sender, handler, reactorProvider,\n-            tokenManager, messageSerializer, options);\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, ENTITY_PATH, sender, handler,\n+            reactorProvider, tokenManager, messageSerializer, options);\n         final ReactorSender spyReactorSender = spy(reactorSender);\n \n         doReturn(Mono.empty()).when(spyReactorSender).send(any(byte[].class), anyInt(), anyInt(),\n@@ -219,8 +233,8 @@ public void testSendWithTransactionDeliverySet() throws IOException {\n         // This is specific to this message and needs to align with this message.\n         when(sender.send(any(byte[].class), anyInt(), anyInt())).thenReturn(26);\n \n-        final ReactorSender reactorSender = new ReactorSender(ENTITY_PATH, sender, handler, reactorProvider,\n-            tokenManager, messageSerializer, options);\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, ENTITY_PATH, sender, handler,\n+            reactorProvider, tokenManager, messageSerializer, options);\n \n         final ReactorDispatcher reactorDispatcherMock = mock(ReactorDispatcher.class);\n         when(reactorProvider.getReactorDispatcher()).thenReturn(reactorDispatcherMock);\n@@ -252,8 +266,8 @@ public void testSendWithTransactionDeliverySet() throws IOException {\n     @Test\n     public void testSend() {\n         // Arrange\n-        final ReactorSender reactorSender = new ReactorSender(ENTITY_PATH, sender, handler, reactorProvider,\n-            tokenManager, messageSerializer, options);\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, ENTITY_PATH, sender, handler,\n+            reactorProvider, tokenManager, messageSerializer, options);\n         final ReactorSender spyReactorSender = spy(reactorSender);\n \n         doReturn(Mono.empty()).when(spyReactorSender).send(any(byte[].class), anyInt(), anyInt(), isNull());\n@@ -276,8 +290,8 @@ public void testSendBatch() {\n         message2.setMessageId(\"id2\");\n         message2.setBody(new AmqpValue(\"world\"));\n \n-        final ReactorSender reactorSender = new ReactorSender(ENTITY_PATH, sender, handler, reactorProvider,\n-            tokenManager, messageSerializer, options);\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, ENTITY_PATH, sender, handler,\n+            reactorProvider, tokenManager, messageSerializer, options);\n         final ReactorSender spyReactorSender = spy(reactorSender);\n \n         doReturn(Mono.empty()).when(spyReactorSender).send(any(byte[].class), anyInt(), anyInt(), isNull());\n@@ -298,8 +312,8 @@ public void testLinkSizeSmallerThanMessageSize() {\n         // Arrange\n         when(sender.getRemoteMaxMessageSize()).thenReturn(UnsignedLong.valueOf(10));\n \n-        final ReactorSender reactorSender = new ReactorSender(ENTITY_PATH, sender, handler, reactorProvider,\n-            tokenManager, messageSerializer, options);\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, ENTITY_PATH, sender, handler,\n+            reactorProvider, tokenManager, messageSerializer, options);\n         final ReactorSender spyReactorSender = spy(reactorSender);\n \n         doReturn(Mono.empty()).when(spyReactorSender).send(any(byte[].class), anyInt(), anyInt(), isNull());\n@@ -316,4 +330,262 @@ public void testLinkSizeSmallerThanMessageSize() {\n         verify(sender, times(1)).getRemoteMaxMessageSize();\n         verify(spyReactorSender, times(0)).send(any(byte[].class), anyInt(), anyInt(), isNull());\n     }\n+\n+    /**\n+     * Verifies that when an exception occurs in the parent, the connection is also closed.\n+     */\n+    @Test\n+    void parentDisposesConnection() {\n+        // Arrange\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, ENTITY_PATH, sender, handler,\n+            reactorProvider, tokenManager, messageSerializer, options);\n+        final AmqpShutdownSignal shutdownSignal = new AmqpShutdownSignal(false, false, \"Test-shutdown-signal\");\n+\n+        doAnswer(invocationOnMock -> {\n+            endpointStatePublisher.complete();\n+            return null;\n+        }).when(sender).close();\n+\n+        // Act\n+        shutdownSignals.next(shutdownSignal);\n+\n+        invokeDispatcher();\n+\n+        // Assert\n+        assertTrue(reactorSender.isDisposed());\n+\n+        verify(sender).close();\n+\n+        endpointStatePublisher.assertNoSubscribers();\n+        shutdownSignals.assertNoSubscribers();\n+    }\n+\n+    /**\n+     * Verifies that when an exception occurs in the parent, the endpoints are also disposed.\n+     */\n+    @Test\n+    void parentClosesEndpoint() {\n+        // Arrange\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, ENTITY_PATH, sender, handler,\n+            reactorProvider, tokenManager, messageSerializer, options);\n+        final AmqpShutdownSignal shutdownSignal = new AmqpShutdownSignal(false, false, \"Test-shutdown-signal\");\n+\n+        doAnswer(invocationOnMock -> {\n+            endpointStatePublisher.complete();\n+            return null;\n+        }).when(sender).close();\n+\n+        // Act\n+        StepVerifier.create(reactorSender.getEndpointStates())\n+            .expectNext(AmqpEndpointState.ACTIVE)\n+            .then(() -> {\n+                shutdownSignals.next(shutdownSignal);\n+                invokeDispatcher();\n+            })\n+            .expectComplete()\n+            .verify();\n+\n+        // Assert\n+        assertTrue(reactorSender.isDisposed());\n+\n+        verify(sender).close();\n+\n+        endpointStatePublisher.assertNoSubscribers();\n+        shutdownSignals.assertNoSubscribers();\n+    }\n+\n+    /**\n+     * An error in the handler will also close the sender.\n+     */\n+    @Test\n+    void disposesOnHandlerError() {\n+        // Arrange\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, ENTITY_PATH, sender, handler,\n+            reactorProvider, tokenManager, messageSerializer, options);\n+        final UnsupportedOperationException testException = new UnsupportedOperationException(\"test-exception\");\n+\n+        // Act and Assert\n+        StepVerifier.create(reactorSender.getEndpointStates())\n+            .expectNext(AmqpEndpointState.ACTIVE)\n+            .then(() -> {\n+                endpointStatePublisher.error(testException);\n+            })\n+            .expectError(UnsupportedOperationException.class)\n+            .verify();\n+\n+        // Expect that this Mono has completed.\n+        StepVerifier.create(reactorSender.isClosed())\n+            .expectComplete()\n+            .verify();\n+\n+        assertTrue(reactorSender.isDisposed());\n+\n+        endpointStatePublisher.assertNoSubscribers();\n+        shutdownSignals.assertNoSubscribers();\n+    }\n+\n+    /**\n+     * A complete in the handler will also close the sender.\n+     */\n+    @Test\n+    void disposesOnHandlerComplete() {\n+        // Arrange\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, ENTITY_PATH, sender, handler,\n+            reactorProvider, tokenManager, messageSerializer, options);\n+\n+        // Act and Assert\n+        StepVerifier.create(reactorSender.getEndpointStates())\n+            .expectNext(AmqpEndpointState.ACTIVE)\n+            .then(() -> endpointStatePublisher.complete())\n+            .verifyComplete();\n+\n+        // Expect that this Mono has completed.\n+        StepVerifier.create(reactorSender.isClosed())\n+            .expectComplete()\n+            .verify();\n+\n+        assertTrue(reactorSender.isDisposed());\n+\n+        verify(sender).close();\n+        verify(tokenManager).close();\n+\n+        endpointStatePublisher.assertNoSubscribers();\n+        shutdownSignals.assertNoSubscribers();\n+    }\n+\n+    @Test\n+    void disposeCompletes() {\n+        // Arrange\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, ENTITY_PATH, sender, handler,\n+            reactorProvider, tokenManager, messageSerializer, options);\n+        final String message = \"some-message\";\n+        final AmqpErrorCondition errorCondition = AmqpErrorCondition.UNAUTHORIZED_ACCESS;\n+        final ErrorCondition condition = new ErrorCondition(Symbol.getSymbol(errorCondition.getErrorCondition()),\n+            \"Test-users\");\n+\n+        doAnswer(invocationOnMock -> {\n+            endpointStatePublisher.complete();\n+            return null;\n+        }).when(sender).close();\n+\n+        // Act\n+        StepVerifier.create(reactorSender.dispose(message, condition))\n+            .then(() -> invokeDispatcher())\n+            .expectComplete()\n+            .verify();\n+\n+        // Expect the same outcome.\n+        StepVerifier.create(reactorSender.dispose(\"something\", null))\n+            .expectComplete()\n+            .verify();\n+\n+        // Assert\n+        assertTrue(reactorSender.isDisposed());\n+\n+        verify(sender).setCondition(condition);\n+        verify(sender).close();\n+        verify(tokenManager).close();\n+\n+        endpointStatePublisher.assertNoSubscribers();\n+        shutdownSignals.assertNoSubscribers();\n+    }\n+\n+    /**\n+     * When errors happen on the send link handler, any pending sends error out.\n+     */\n+    @Test\n+    void pendingMessagesError() throws IOException {\n+        // Arrange\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, ENTITY_PATH, sender, handler,\n+            reactorProvider, tokenManager, messageSerializer, options);\n+        final UnsupportedOperationException testException = new UnsupportedOperationException(\"test-exception\");\n+        final Message message = Proton.message();\n+        final UnsignedLong size = new UnsignedLong(2048L);\n+        when(sender.getRemoteMaxMessageSize()).thenReturn(size);\n+\n+        doAnswer(invocationOnMock -> {\n+            endpointStatePublisher.error(testException);\n+            return null;\n+        }).when(reactorDispatcher).invoke(any(Runnable.class));\n+\n+        // Act and Assert\n+        StepVerifier.create(reactorSender.send(message))\n+            .then(() -> {\n+            })\n+            .expectError(UnsupportedOperationException.class)\n+            .verify();\n+\n+        // Expect that this Mono has completed.\n+        StepVerifier.create(reactorSender.isClosed())\n+            .expectComplete()\n+            .verify();\n+\n+        assertTrue(reactorSender.isDisposed());\n+\n+        endpointStatePublisher.assertNoSubscribers();\n+        shutdownSignals.assertNoSubscribers();\n+    }\n+\n+    /**\n+     * When errors happen on the send link handler, any pending sends error out.\n+     */\n+    @Test\n+    void pendingMessagesErrorWithShutdown() throws IOException {\n+        // Arrange\n+        final ReactorSender reactorSender = new ReactorSender(amqpConnection, ENTITY_PATH, sender, handler,\n+            reactorProvider, tokenManager, messageSerializer, options);\n+        final Message message = Proton.message();\n+        final UnsignedLong size = new UnsignedLong(2048L);\n+        when(sender.getRemoteMaxMessageSize()).thenReturn(size);\n+\n+        final AmqpShutdownSignal shutdownSignal = new AmqpShutdownSignal(false, false, \"Test-shutdown-signal\");\n+\n+        final AtomicBoolean isEmitted = new AtomicBoolean();\n+        doAnswer(invocationOnMock -> {\n+            if (isEmitted.getAndSet(true)) {\n+                final Runnable runnable = invocationOnMock.getArgument(0);\n+                runnable.run();\n+            } else {\n+                shutdownSignals.next(shutdownSignal);\n+            }\n+            return null;\n+        }).when(reactorDispatcher).invoke(any(Runnable.class));\n+\n+        doAnswer(invocationOnMock -> {\n+            endpointStatePublisher.complete();\n+            return null;\n+        }).when(sender).close();\n+\n+        // Act and Assert\n+        StepVerifier.create(reactorSender.send(message))\n+            .expectErrorSatisfies(error -> {\n+                assertTrue(error instanceof AmqpException);\n+\n+                final AmqpException amqpException = (AmqpException) error;\n+                assertTrue(amqpException.isTransient());\n+                assertTrue(amqpException.getMessage().contains(\"not complete sends\"));\n+            })\n+            .verify();\n+\n+        assertTrue(reactorSender.isDisposed());\n+\n+        endpointStatePublisher.assertNoSubscribers();\n+        shutdownSignals.assertNoSubscribers();\n+    }\n+\n+    /**\n+     * Manually captures the Runnable in the dispatcher so we can invoke it to verify contents.\n+     */\n+    private void invokeDispatcher() {\n+        try {\n+            verify(reactorDispatcher, atLeastOnce()).invoke(dispatcherCaptor.capture());\n+        } catch (IOException e) {\n+            fail(\"Should not have caused an IOException. \" + e);\n+        }\n+\n+        dispatcherCaptor.getAllValues().forEach(work -> {\n+            assertNotNull(work);\n+            work.run();\n+        });\n+    }\n }"
  },
  {
    "sha": "ef29edc255cbbb845d167c82533fdd4f48efd704",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSessionTest.java",
    "status": "modified",
    "additions": 6,
    "deletions": 3,
    "changes": 9,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSessionTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSessionTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSessionTest.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -3,6 +3,7 @@\n \n package com.azure.core.amqp.implementation;\n \n+import com.azure.core.amqp.AmqpConnection;\n import com.azure.core.amqp.AmqpEndpointState;\n import com.azure.core.amqp.AmqpLink;\n import com.azure.core.amqp.AmqpRetryMode;\n@@ -82,12 +83,14 @@\n     private ReactorDispatcher reactorDispatcher;\n     @Mock\n     private TokenManagerProvider tokenManagerProvider;\n+    @Mock\n+    private AmqpConnection amqpConnection;\n \n     private Mono<ClaimsBasedSecurityNode> cbsNodeSupplier;\n \n     @BeforeEach\n     public void setup() throws IOException {\n-        MockitoAnnotations.initMocks(this);\n+        MockitoAnnotations.openMocks(this);\n \n         this.handler = new SessionHandler(ID, HOST, ENTITY_PATH, reactorDispatcher, Duration.ofSeconds(60));\n         this.cbsNodeSupplier = Mono.just(cbsNode);\n@@ -106,8 +109,8 @@ public void setup() throws IOException {\n         }).when(reactorDispatcher).invoke(any());\n \n         final AmqpRetryOptions options = new AmqpRetryOptions().setTryTimeout(TIMEOUT);\n-        this.reactorSession = new ReactorSession(session, handler, NAME, reactorProvider, reactorHandlerProvider,\n-            cbsNodeSupplier, tokenManagerProvider, serializer, options);\n+        this.reactorSession = new ReactorSession(amqpConnection, session, handler, NAME, reactorProvider,\n+            reactorHandlerProvider, cbsNodeSupplier, tokenManagerProvider, serializer, options);\n     }\n \n     @AfterEach"
  },
  {
    "sha": "678fb1e08c871c33e1c0325d1fcbea4fa1588baf",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RequestResponseChannelTest.java",
    "status": "modified",
    "additions": 122,
    "deletions": 42,
    "changes": 164,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RequestResponseChannelTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RequestResponseChannelTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RequestResponseChannelTest.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -3,7 +3,9 @@\n \n package com.azure.core.amqp.implementation;\n \n+import com.azure.core.amqp.AmqpConnection;\n import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpShutdownSignal;\n import com.azure.core.amqp.exception.AmqpErrorContext;\n import com.azure.core.amqp.exception.AmqpException;\n import com.azure.core.amqp.implementation.handler.ReceiveLinkHandler;\n@@ -30,23 +32,23 @@\n import org.mockito.Mock;\n import org.mockito.Mockito;\n import org.mockito.MockitoAnnotations;\n-import reactor.core.publisher.DirectProcessor;\n-import reactor.core.publisher.FluxSink;\n-import reactor.core.publisher.ReplayProcessor;\n import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n \n import java.io.IOException;\n import java.time.Duration;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.ArgumentMatchers.argThat;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.ArgumentMatchers.same;\n import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.doNothing;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n@@ -63,9 +65,10 @@\n     private static final Duration TIMEOUT = Duration.ofSeconds(23);\n \n     private final AmqpRetryOptions retryOptions = new AmqpRetryOptions().setTryTimeout(TIMEOUT);\n-    private final DirectProcessor<Delivery> deliveryProcessor = DirectProcessor.create();\n-    private final FluxSink<Delivery> deliverySink = deliveryProcessor.sink();\n-    private final ReplayProcessor<EndpointState> endpointStateReplayProcessor = ReplayProcessor.cacheLast();\n+    private final TestPublisher<Delivery> deliveryProcessor = TestPublisher.create();\n+    private final TestPublisher<EndpointState> receiveEndpoints = TestPublisher.createCold();\n+    private final TestPublisher<EndpointState> sendEndpoints = TestPublisher.createCold();\n+    private final TestPublisher<AmqpShutdownSignal> shutdownSignals = TestPublisher.create();\n \n     @Mock\n     private ReactorHandlerProvider handlerProvider;\n@@ -77,6 +80,8 @@\n     private ReceiveLinkHandler receiveLinkHandler;\n     @Mock\n     private SendLinkHandler sendLinkHandler;\n+    @Mock\n+    private AmqpConnection amqpConnection;\n \n     @Mock\n     private Session session;\n@@ -101,7 +106,7 @@ static void afterAll() {\n \n     @BeforeEach\n     void beforeEach() {\n-        MockitoAnnotations.initMocks(this);\n+        MockitoAnnotations.openMocks(this);\n \n         when(reactorProvider.getReactorDispatcher()).thenReturn(reactorDispatcher);\n \n@@ -117,12 +122,11 @@ void beforeEach() {\n         when(handlerProvider.createSendLinkHandler(CONNECTION_ID, NAMESPACE, LINK_NAME, ENTITY_PATH))\n             .thenReturn(sendLinkHandler);\n \n-        FluxSink<EndpointState> sink1 = endpointStateReplayProcessor.sink();\n-        sink1.next(EndpointState.ACTIVE);\n-        when(receiveLinkHandler.getEndpointStates()).thenReturn(endpointStateReplayProcessor);\n-        when(receiveLinkHandler.getDeliveredMessages()).thenReturn(deliveryProcessor);\n+        when(receiveLinkHandler.getEndpointStates()).thenReturn(receiveEndpoints.flux());\n+        when(receiveLinkHandler.getDeliveredMessages()).thenReturn(deliveryProcessor.flux());\n+        when(sendLinkHandler.getEndpointStates()).thenReturn(sendEndpoints.flux());\n \n-        when(sendLinkHandler.getEndpointStates()).thenReturn(endpointStateReplayProcessor);\n+        when(amqpConnection.getShutdownSignals()).thenReturn(shutdownSignals.flux());\n     }\n \n     @AfterEach\n@@ -141,13 +145,21 @@ void getsProperties() {\n         AmqpErrorContext expected = new AmqpErrorContext(\"namespace-test\");\n         when(receiveLinkHandler.getErrorContext(receiver)).thenReturn(expected);\n \n+        receiveEndpoints.next(EndpointState.ACTIVE);\n+        sendEndpoints.next(EndpointState.ACTIVE);\n+\n         // Act\n-        final RequestResponseChannel channel = new RequestResponseChannel(CONNECTION_ID, NAMESPACE, LINK_NAME,\n+        final RequestResponseChannel channel = new RequestResponseChannel(amqpConnection, CONNECTION_ID, NAMESPACE, LINK_NAME,\n             ENTITY_PATH, session, retryOptions, handlerProvider, reactorProvider, serializer, settleMode,\n             receiverSettleMode);\n         final AmqpErrorContext errorContext = channel.getErrorContext();\n \n-        channel.dispose();\n+        StepVerifier.create(channel.disposeAsync())\n+            .then(() -> {\n+                sendEndpoints.complete();\n+                receiveEndpoints.complete();\n+            })\n+            .verifyComplete();\n \n         // Assert\n         assertEquals(expected, errorContext);\n@@ -163,12 +175,22 @@ void getsProperties() {\n     @Test\n     void disposes() {\n         // Arrange\n-        final RequestResponseChannel channel = new RequestResponseChannel(CONNECTION_ID, NAMESPACE, LINK_NAME,\n+        final RequestResponseChannel channel = new RequestResponseChannel(amqpConnection, CONNECTION_ID, NAMESPACE, LINK_NAME,\n             ENTITY_PATH, session, retryOptions, handlerProvider, reactorProvider, serializer, SenderSettleMode.SETTLED,\n             ReceiverSettleMode.SECOND);\n \n+        receiveEndpoints.next(EndpointState.ACTIVE);\n+        sendEndpoints.next(EndpointState.ACTIVE);\n+\n         // Act\n-        channel.dispose();\n+        StepVerifier.create(channel.disposeAsync())\n+            .then(() -> {\n+                sendEndpoints.complete();\n+                receiveEndpoints.complete();\n+            })\n+            .verifyComplete();\n+\n+        invokeDispatcher();\n \n         // Assert\n         verify(sender).close();\n@@ -181,10 +203,13 @@ void disposes() {\n     @Test\n     void sendNull() {\n         // Arrange\n-        final RequestResponseChannel channel = new RequestResponseChannel(CONNECTION_ID, NAMESPACE, LINK_NAME,\n+        final RequestResponseChannel channel = new RequestResponseChannel(amqpConnection, CONNECTION_ID, NAMESPACE, LINK_NAME,\n             ENTITY_PATH, session, retryOptions, handlerProvider, reactorProvider, serializer, SenderSettleMode.SETTLED,\n             ReceiverSettleMode.SECOND);\n \n+        receiveEndpoints.next(EndpointState.ACTIVE);\n+        sendEndpoints.next(EndpointState.ACTIVE);\n+\n         // Act & Assert\n         StepVerifier.create(channel.sendWithAck(null))\n             .expectError(NullPointerException.class)\n@@ -197,7 +222,7 @@ void sendNull() {\n     @Test\n     void sendReplyToSet() {\n         // Arrange\n-        final RequestResponseChannel channel = new RequestResponseChannel(CONNECTION_ID, NAMESPACE, LINK_NAME,\n+        final RequestResponseChannel channel = new RequestResponseChannel(amqpConnection, CONNECTION_ID, NAMESPACE, LINK_NAME,\n             ENTITY_PATH, session, retryOptions, handlerProvider, reactorProvider, serializer, SenderSettleMode.SETTLED,\n             ReceiverSettleMode.SECOND);\n         final Message message = mock(Message.class);\n@@ -215,17 +240,21 @@ void sendReplyToSet() {\n     @Test\n     void sendMessageIdSet() {\n         // Arrange\n-        final RequestResponseChannel channel = new RequestResponseChannel(CONNECTION_ID, NAMESPACE, LINK_NAME,\n+        final RequestResponseChannel channel = new RequestResponseChannel(amqpConnection, CONNECTION_ID, NAMESPACE, LINK_NAME,\n             ENTITY_PATH, session, retryOptions, handlerProvider, reactorProvider, serializer, SenderSettleMode.SETTLED,\n             ReceiverSettleMode.SECOND);\n         final Message message = mock(Message.class);\n         when(message.getMessageId()).thenReturn(10L);\n \n+        receiveEndpoints.next(EndpointState.ACTIVE);\n+        sendEndpoints.next(EndpointState.ACTIVE);\n+\n         // Act & Assert\n         StepVerifier.create(channel.sendWithAck(message))\n             .expectError(IllegalArgumentException.class)\n             .verify();\n     }\n+\n     /**\n      * Verifies a message is received.\n      */\n@@ -240,9 +269,9 @@ void sendMessageWithTransaction() throws IOException {\n             64, 64, 0, 83, 116, -63, 49, 4, -95, 11, 115, 116, 97, 116, 117, 115, 45, 99, 111, 100, 101, 113, 0, 0, 0,\n             -54, -95, 18, 115, 116, 97, 116, 117, 115, 45, 100, 101, 115, 99, 114, 105, 112, 116, 105, 111, 110, -95, 8,\n             65, 99, 99, 101, 112, 116, 101, 100};\n-        final RequestResponseChannel channel = new RequestResponseChannel(CONNECTION_ID, NAMESPACE, LINK_NAME,\n-            ENTITY_PATH, session, retryOptions, handlerProvider, reactorProvider, serializer, SenderSettleMode.SETTLED,\n-            ReceiverSettleMode.SECOND);\n+        final RequestResponseChannel channel = new RequestResponseChannel(amqpConnection, CONNECTION_ID, NAMESPACE,\n+            LINK_NAME, ENTITY_PATH, session, retryOptions, handlerProvider, reactorProvider, serializer,\n+            SenderSettleMode.SETTLED, ReceiverSettleMode.SECOND);\n         final UnsignedLong messageId = UnsignedLong.valueOf(1);\n         final Message message = mock(Message.class);\n         final int encodedSize = 143;\n@@ -264,18 +293,16 @@ void sendMessageWithTransaction() throws IOException {\n             return messageBytes.length;\n         });\n \n+        receiveEndpoints.next(EndpointState.ACTIVE);\n+        sendEndpoints.next(EndpointState.ACTIVE);\n+\n         // Act\n         StepVerifier.create(channel.sendWithAck(message, transactionalState))\n-            .then(() -> deliverySink.next(delivery))\n+            .then(() -> deliveryProcessor.next(delivery))\n             .assertNext(received -> assertEquals(messageId, received.getCorrelationId()))\n             .verifyComplete();\n \n-        // Getting the runnable so we can manually invoke it and verify contents are correct.\n-        verify(reactorDispatcher, atLeastOnce()).invoke(dispatcherCaptor.capture());\n-        dispatcherCaptor.getAllValues().forEach(work -> {\n-            assertNotNull(work);\n-            work.run();\n-        });\n+        invokeDispatcher();\n \n         // Assert\n         verify(message).setMessageId(argThat(e -> e instanceof UnsignedLong && messageId.equals(e)));\n@@ -293,16 +320,16 @@ void sendMessageWithTransaction() throws IOException {\n      * Verifies a message is received.\n      */\n     @Test\n-    void sendMessage() throws IOException {\n+    void sendMessage() {\n         // Arrange\n         // This message was copied from one that was received.\n         final byte[] messageBytes = new byte[]{0, 83, 115, -64, 15, 13, 64, 64, 64, 64, 64, 83, 1, 64, 64, 64, 64, 64,\n             64, 64, 0, 83, 116, -63, 49, 4, -95, 11, 115, 116, 97, 116, 117, 115, 45, 99, 111, 100, 101, 113, 0, 0, 0,\n             -54, -95, 18, 115, 116, 97, 116, 117, 115, 45, 100, 101, 115, 99, 114, 105, 112, 116, 105, 111, 110, -95, 8,\n             65, 99, 99, 101, 112, 116, 101, 100};\n-        final RequestResponseChannel channel = new RequestResponseChannel(CONNECTION_ID, NAMESPACE, LINK_NAME,\n-            ENTITY_PATH, session, retryOptions, handlerProvider, reactorProvider, serializer, SenderSettleMode.SETTLED,\n-            ReceiverSettleMode.SECOND);\n+        final RequestResponseChannel channel = new RequestResponseChannel(amqpConnection, CONNECTION_ID, NAMESPACE,\n+            LINK_NAME, ENTITY_PATH, session, retryOptions, handlerProvider, reactorProvider, serializer,\n+            SenderSettleMode.SETTLED, ReceiverSettleMode.SECOND);\n         final UnsignedLong messageId = UnsignedLong.valueOf(1);\n         final Message message = mock(Message.class);\n         final int encodedSize = 143;\n@@ -324,18 +351,16 @@ void sendMessage() throws IOException {\n             return messageBytes.length;\n         });\n \n+        receiveEndpoints.next(EndpointState.ACTIVE);\n+        sendEndpoints.next(EndpointState.ACTIVE);\n+\n         // Act\n         StepVerifier.create(channel.sendWithAck(message))\n-            .then(() -> deliverySink.next(delivery))\n+            .then(() -> deliveryProcessor.next(delivery))\n             .assertNext(received -> assertEquals(messageId, received.getCorrelationId()))\n             .verifyComplete();\n \n-        // Getting the runnable so we can manually invoke it and verify contents are correct.\n-        verify(reactorDispatcher, atLeastOnce()).invoke(dispatcherCaptor.capture());\n-        dispatcherCaptor.getAllValues().forEach(work -> {\n-            assertNotNull(work);\n-            work.run();\n-        });\n+        invokeDispatcher();\n \n         // Assert\n         verify(message).setMessageId(argThat(e -> e instanceof UnsignedLong && messageId.equals(e)));\n@@ -350,21 +375,76 @@ void sendMessage() throws IOException {\n     @Test\n     void clearMessagesOnError() {\n         // Arrange\n-        final RequestResponseChannel channel = new RequestResponseChannel(CONNECTION_ID, NAMESPACE, LINK_NAME,\n+        final RequestResponseChannel channel = new RequestResponseChannel(amqpConnection, CONNECTION_ID, NAMESPACE, LINK_NAME,\n             ENTITY_PATH, session, retryOptions, handlerProvider, reactorProvider, serializer, SenderSettleMode.SETTLED,\n             ReceiverSettleMode.SECOND);\n         final AmqpException error = new AmqpException(true, \"Message\", new AmqpErrorContext(\"some-context\"));\n         final Message message = mock(Message.class);\n         when(serializer.getSize(message)).thenReturn(150);\n         when(message.encode(any(), eq(0), anyInt())).thenReturn(143);\n \n+        receiveEndpoints.next(EndpointState.ACTIVE);\n+        sendEndpoints.next(EndpointState.ACTIVE);\n+\n         // Act\n         StepVerifier.create(channel.sendWithAck(message))\n-            .then(() -> endpointStateReplayProcessor.sink().error(error))\n+            .then(() -> sendEndpoints.error(error))\n             .verifyError(AmqpException.class);\n \n         // Assert\n         assertTrue(channel.isDisposed());\n     }\n \n+    /**\n+     * Verifies that when an exception occurs in the parent, the connection is also closed.\n+     */\n+    @Test\n+    void parentDisposesConnection() {\n+        // Arrange\n+        final RequestResponseChannel channel = new RequestResponseChannel(amqpConnection, CONNECTION_ID, NAMESPACE,\n+            LINK_NAME, ENTITY_PATH, session, retryOptions, handlerProvider, reactorProvider, serializer,\n+            SenderSettleMode.SETTLED, ReceiverSettleMode.SECOND);\n+        final AmqpShutdownSignal shutdownSignal = new AmqpShutdownSignal(false, false, \"Test-shutdown-signal\");\n+\n+        doAnswer(invocationOnMock -> {\n+            sendEndpoints.complete();\n+            return null;\n+        }).when(sender).close();\n+\n+        doAnswer(invocationOnMock -> {\n+            receiveEndpoints.complete();\n+            return null;\n+        }).when(receiver).close();\n+\n+        // Act\n+        shutdownSignals.next(shutdownSignal);\n+\n+        invokeDispatcher();\n+\n+        // Assert\n+        assertTrue(channel.isDisposed());\n+\n+        verify(receiver).close();\n+        verify(sender).close();\n+\n+        receiveEndpoints.assertNoSubscribers();\n+        sendEndpoints.assertNoSubscribers();\n+        shutdownSignals.assertNoSubscribers();\n+    }\n+\n+    /**\n+     * Manually captures the Runnable in the dispatcher so we can invoke it to verify contents.\n+     */\n+    private void invokeDispatcher() {\n+        try {\n+            verify(reactorDispatcher, atLeastOnce()).invoke(dispatcherCaptor.capture());\n+        } catch (IOException e) {\n+            fail(\"Should not have caused an IOException. \" + e);\n+        }\n+\n+        dispatcherCaptor.getAllValues().forEach(work -> {\n+            assertNotNull(work);\n+            work.run();\n+        });\n+    }\n }"
  },
  {
    "sha": "592773b19d81f3f49dff1ca3af76e16767cf9227",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RetryUtilTest.java",
    "status": "modified",
    "additions": 33,
    "deletions": 0,
    "changes": 33,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RetryUtilTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RetryUtilTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RetryUtilTest.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -86,6 +86,39 @@ void withRetryFlux() {\n         assertEquals(options.getMaxRetries() + 1, resubscribe.get());\n     }\n \n+\n+    /**\n+     * Tests a retry that times out on a Flux.\n+     */\n+    @Test\n+    void withRetryFluxEmitsItemsLaterThanTimeout() {\n+        // Arrange\n+        final String timeoutMessage = \"Operation timed out.\";\n+        final Duration timeout = Duration.ofMillis(500);\n+        final AmqpRetryOptions options = new AmqpRetryOptions()\n+            .setDelay(Duration.ofSeconds(1))\n+            .setMaxRetries(2)\n+            .setTryTimeout(timeout);\n+        final Duration totalWaitTime = Duration.ofSeconds(options.getMaxRetries() * options.getDelay().getSeconds());\n+\n+        final AtomicInteger resubscribe = new AtomicInteger();\n+        final TestPublisher<AmqpTransportType> singleItem = TestPublisher.create();\n+\n+        final Flux<AmqpTransportType> flux = singleItem.flux()\n+            .doOnSubscribe(s -> resubscribe.incrementAndGet());\n+\n+        // Act & Assert\n+        StepVerifier.create(RetryUtil.withRetry(flux, options, timeoutMessage))\n+            .expectSubscription()\n+            .then(() -> singleItem.next(AmqpTransportType.AMQP_WEB_SOCKETS))\n+            .expectNext(AmqpTransportType.AMQP_WEB_SOCKETS)\n+            .expectNoEvent(totalWaitTime)\n+            .thenCancel()\n+            .verify();\n+\n+        assertEquals(1, resubscribe.get());\n+    }\n+\n     /**\n      * Tests a retry that times out on a Mono.\n      */"
  },
  {
    "sha": "9646ad008985da11abe7a4b388742e85f82c5eb4",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/handler/HandlerTest.java",
    "status": "modified",
    "additions": 2,
    "deletions": 7,
    "changes": 9,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/handler/HandlerTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/handler/HandlerTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/handler/HandlerTest.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -24,7 +24,6 @@ public void initialHandlerState() {\n         StepVerifier.create(handler.getEndpointStates())\n             .expectNext(EndpointState.UNINITIALIZED)\n             .then(handler::close)\n-            .expectNext(EndpointState.CLOSED)\n             .verifyComplete();\n     }\n \n@@ -37,7 +36,6 @@ public void propagatesStates() {\n             .expectNext(EndpointState.ACTIVE)\n             .then(() -> handler.onNext(EndpointState.ACTIVE))\n             .then(handler::close)\n-            .expectNext(EndpointState.CLOSED)\n             .verifyComplete();\n     }\n \n@@ -51,7 +49,6 @@ public void propagatesErrors() {\n         StepVerifier.create(handler.getEndpointStates())\n             .expectNext(EndpointState.UNINITIALIZED)\n             .then(() -> handler.onError(exception))\n-            .expectNext(EndpointState.CLOSED)\n             .expectErrorMatches(e -> e.equals(exception))\n             .verify();\n     }\n@@ -70,12 +67,11 @@ public void propagatesErrorsOnce() {\n                 handler.onError(exception);\n                 handler.onError(exception2);\n             })\n-            .expectNext(EndpointState.CLOSED)\n             .expectErrorMatches(e -> e.equals(exception))\n             .verify();\n \n         StepVerifier.create(handler.getEndpointStates())\n-            .expectNext(EndpointState.CLOSED)\n+            .expectNext(EndpointState.UNINITIALIZED)\n             .expectErrorMatches(e -> e.equals(exception))\n             .verify();\n     }\n@@ -88,13 +84,12 @@ public void completesOnce() {\n             .then(() -> handler.onNext(EndpointState.ACTIVE))\n             .expectNext(EndpointState.ACTIVE)\n             .then(() -> handler.close())\n-            .expectNext(EndpointState.CLOSED)\n             .expectComplete()\n             .verify();\n \n         // The last state is always replayed before it is closed.\n         StepVerifier.create(handler.getEndpointStates())\n-            .expectNext(EndpointState.CLOSED)\n+            .expectNext(EndpointState.ACTIVE)\n             .expectComplete()\n             .verify();\n     }"
  },
  {
    "sha": "181802622ad21b80121147ac38da9a64b1e0663e",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/handler/LinkHandlerTest.java",
    "status": "modified",
    "additions": 0,
    "deletions": 4,
    "changes": 4,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/handler/LinkHandlerTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/handler/LinkHandlerTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/handler/LinkHandlerTest.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -150,7 +150,6 @@ void onLinkRemoteClose() {\n         StepVerifier.create(handler.getEndpointStates())\n             .expectNext(EndpointState.UNINITIALIZED)\n             .then(() -> handler.onLinkRemoteClose(event))\n-            .expectNext(EndpointState.CLOSED)\n             .expectErrorSatisfies(error -> {\n                 Assertions.assertTrue(error instanceof AmqpException);\n \n@@ -184,7 +183,6 @@ void onLinkRemoteDetach() {\n         StepVerifier.create(handler.getEndpointStates())\n             .expectNext(EndpointState.UNINITIALIZED)\n             .then(() -> handler.onLinkRemoteDetach(event))\n-            .expectNext(EndpointState.CLOSED)\n             .expectErrorSatisfies(error -> {\n                 Assertions.assertTrue(error instanceof AmqpException);\n \n@@ -217,7 +215,6 @@ void onLinkRemoteCloseWithErrorCondition() {\n         StepVerifier.create(handler.getEndpointStates())\n             .expectNext(EndpointState.UNINITIALIZED)\n             .then(() -> handler.onLinkRemoteClose(event))\n-            .expectNext(EndpointState.CLOSED)\n             .expectErrorSatisfies(error -> {\n                 Assertions.assertTrue(error instanceof AmqpException);\n \n@@ -251,7 +248,6 @@ void onLinkRemoteCloseNoErrorCondition() {\n         StepVerifier.create(handler.getEndpointStates())\n             .expectNext(EndpointState.UNINITIALIZED)\n             .then(() -> handler.onLinkRemoteClose(event))\n-            .expectNext(EndpointState.CLOSED)\n             .then(() -> handler.onLinkFinal(finalEvent))\n             .expectComplete()\n             .verify();"
  },
  {
    "sha": "d7a70862d23998ee33446146a9d2db311d1a1de3",
    "filename": "sdk/eventhubs/azure-messaging-eventhubs/pom.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/eventhubs/azure-messaging-eventhubs/pom.xml",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/eventhubs/azure-messaging-eventhubs/pom.xml",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/eventhubs/azure-messaging-eventhubs/pom.xml?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -42,7 +42,7 @@\n     <dependency>\n       <groupId>com.azure</groupId>\n       <artifactId>azure-core-amqp</artifactId>\n-      <version>2.0.3</version> <!-- {x-version-update;com.azure:azure-core-amqp;dependency} -->\n+      <version>2.1.0-beta.1</version> <!-- {x-version-update;unreleased_com.azure:azure-core-amqp;dependency} -->\n     </dependency>\n \n     <!-- Test dependencies -->"
  },
  {
    "sha": "dcd57fb75dba806eb7091491f42a218dbe9335ca",
    "filename": "sdk/eventhubs/azure-messaging-eventhubs/src/main/java/com/azure/messaging/eventhubs/implementation/EventHubReactorAmqpConnection.java",
    "status": "modified",
    "additions": 2,
    "deletions": 4,
    "changes": 6,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/eventhubs/azure-messaging-eventhubs/src/main/java/com/azure/messaging/eventhubs/implementation/EventHubReactorAmqpConnection.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/eventhubs/azure-messaging-eventhubs/src/main/java/com/azure/messaging/eventhubs/implementation/EventHubReactorAmqpConnection.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/eventhubs/azure-messaging-eventhubs/src/main/java/com/azure/messaging/eventhubs/implementation/EventHubReactorAmqpConnection.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -133,8 +133,6 @@ public void dispose() {\n             return;\n         }\n \n-        logger.info(\"connectionId[{}]: Disposing of connection.\", connectionId);\n-\n         if (managementChannel != null) {\n             managementChannel.close();\n         }\n@@ -144,8 +142,8 @@ public void dispose() {\n \n     @Override\n     protected AmqpSession createSession(String sessionName, Session session, SessionHandler handler) {\n-        return new EventHubReactorSession(session, handler, sessionName, reactorProvider, handlerProvider,\n-            getClaimsBasedSecurityNode(), tokenManagerProvider, retryOptions, messageSerializer);\n+        return new EventHubReactorSession(this, session, handler, sessionName, reactorProvider,\n+            handlerProvider, getClaimsBasedSecurityNode(), tokenManagerProvider, retryOptions, messageSerializer);\n     }\n \n     private synchronized ManagementChannel getOrCreateManagementChannel() {"
  },
  {
    "sha": "2ffe834359058add0603cfaab5ea12dc0be33687",
    "filename": "sdk/eventhubs/azure-messaging-eventhubs/src/main/java/com/azure/messaging/eventhubs/implementation/EventHubReactorSession.java",
    "status": "modified",
    "additions": 7,
    "deletions": 6,
    "changes": 13,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/eventhubs/azure-messaging-eventhubs/src/main/java/com/azure/messaging/eventhubs/implementation/EventHubReactorSession.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/eventhubs/azure-messaging-eventhubs/src/main/java/com/azure/messaging/eventhubs/implementation/EventHubReactorSession.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/eventhubs/azure-messaging-eventhubs/src/main/java/com/azure/messaging/eventhubs/implementation/EventHubReactorSession.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -3,6 +3,7 @@\n \n package com.azure.messaging.eventhubs.implementation;\n \n+import com.azure.core.amqp.AmqpConnection;\n import com.azure.core.amqp.AmqpRetryOptions;\n import com.azure.core.amqp.AmqpRetryPolicy;\n import com.azure.core.amqp.ClaimsBasedSecurityNode;\n@@ -60,12 +61,12 @@\n      * @param retryOptions to be used for this session.\n      * @param messageSerializer to be used.\n      */\n-    EventHubReactorSession(Session session, SessionHandler sessionHandler, String sessionName,\n-                           ReactorProvider provider, ReactorHandlerProvider handlerProvider,\n-                           Mono<ClaimsBasedSecurityNode> cbsNodeSupplier, TokenManagerProvider tokenManagerProvider,\n-                           AmqpRetryOptions retryOptions, MessageSerializer messageSerializer) {\n-        super(session, sessionHandler, sessionName, provider, handlerProvider, cbsNodeSupplier, tokenManagerProvider,\n-            messageSerializer, retryOptions);\n+    EventHubReactorSession(AmqpConnection amqpConnection, Session session, SessionHandler sessionHandler,\n+        String sessionName, ReactorProvider provider, ReactorHandlerProvider handlerProvider,\n+        Mono<ClaimsBasedSecurityNode> cbsNodeSupplier, TokenManagerProvider tokenManagerProvider,\n+        AmqpRetryOptions retryOptions, MessageSerializer messageSerializer) {\n+        super(amqpConnection, session, sessionHandler, sessionName, provider, handlerProvider, cbsNodeSupplier,\n+            tokenManagerProvider, messageSerializer, retryOptions);\n     }\n \n     /**"
  },
  {
    "sha": "cf70a30f1385110cd21d7e0b5a87caf2a0cb41ec",
    "filename": "sdk/eventhubs/azure-messaging-eventhubs/src/test/java/com/azure/messaging/eventhubs/IntegrationTestBase.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/eventhubs/azure-messaging-eventhubs/src/test/java/com/azure/messaging/eventhubs/IntegrationTestBase.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/eventhubs/azure-messaging-eventhubs/src/test/java/com/azure/messaging/eventhubs/IntegrationTestBase.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/eventhubs/azure-messaging-eventhubs/src/test/java/com/azure/messaging/eventhubs/IntegrationTestBase.java?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -54,7 +54,7 @@\n     protected static final List<String> EXPECTED_PARTITION_IDS = IntStream.range(0, NUMBER_OF_PARTITIONS)\n         .mapToObj(String::valueOf)\n         .collect(Collectors.toList());\n-    protected static final Duration TIMEOUT = Duration.ofSeconds(45);\n+    protected static final Duration TIMEOUT = Duration.ofSeconds(30);\n     protected static final AmqpRetryOptions RETRY_OPTIONS = new AmqpRetryOptions().setTryTimeout(TIMEOUT);\n \n     protected final ClientLogger logger;\n@@ -296,6 +296,6 @@ protected void dispose(Closeable... closeables) {\n     }\n \n     private void skipIfNotRecordMode() {\n-        Assumptions.assumeTrue(getTestMode() == TestMode.RECORD);\n+        Assumptions.assumeTrue(getTestMode() != TestMode.PLAYBACK);\n     }\n }"
  },
  {
    "sha": "e65690cb57009b9ab05d90bf68319b92ddea48b9",
    "filename": "sdk/servicebus/azure-messaging-servicebus/pom.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/servicebus/azure-messaging-servicebus/pom.xml",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/ce4a58396f8a6e87ee82c47f174a10dcaa32c549/sdk/servicebus/azure-messaging-servicebus/pom.xml",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/servicebus/azure-messaging-servicebus/pom.xml?ref=ce4a58396f8a6e87ee82c47f174a10dcaa32c549",
    "patch": "@@ -47,7 +47,7 @@\n     <dependency>\n       <groupId>com.azure</groupId>\n       <artifactId>azure-core-amqp</artifactId>\n-      <version>2.0.3</version> <!-- {x-version-update;com.azure:azure-core-amqp;dependency} -->\n+      <version>2.1.0-beta.1</version> <!-- {x-version-update;unreleased_com.azure:azure-core-amqp;dependency} -->\n     </dependency>\n     <dependency>\n       <groupId>com.azure</groupId>"
  }
]
