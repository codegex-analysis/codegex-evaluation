[
  {
    "sha": "522b752debbfe1321247aafe66a3286c73137b88",
    "filename": "sdk/core/azure-core-amqp/CHANGELOG.md",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/CHANGELOG.md",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/CHANGELOG.md",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/CHANGELOG.md?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -1,6 +1,8 @@\n # Release History\n \n ## 2.1.0-beta.1 (Unreleased)\n+### New Features\n+- Added support for distributed transactions across entities. \n \n ## 2.0.3 (2021-03-09)\n "
  },
  {
    "sha": "8bd01b211cde8cce68346abfc15cbab3679e1012",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ConnectionOptions.java",
    "status": "modified",
    "additions": 50,
    "deletions": 1,
    "changes": 51,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ConnectionOptions.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ConnectionOptions.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ConnectionOptions.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -40,6 +40,7 @@\n     private final SslDomain.VerifyMode verifyMode;\n     private final String hostname;\n     private final int port;\n+    private final boolean distributedTransactionsSupport;\n \n     /**\n      * Creates an instance with the following options set. The AMQP connection is created to the\n@@ -66,9 +67,39 @@ public ConnectionOptions(String fullyQualifiedNamespace, TokenCredential tokenCr\n         SslDomain.VerifyMode verifyMode, String product, String clientVersion) {\n         this(fullyQualifiedNamespace, tokenCredential, authorizationType, transport, retryOptions,\n             proxyOptions, scheduler, clientOptions, verifyMode, product, clientVersion, fullyQualifiedNamespace,\n-            getPort(transport));\n+            getPort(transport), false);\n     }\n \n+    /**\n+     * Creates an instance with the following options set. The AMQP connection is created to the\n+     * {@code fullyQualifiedNamespace} using a port based on the {@code transport}.\n+     *\n+     * @param fullyQualifiedNamespace Fully qualified namespace for the AMQP broker. (ie.\n+     *     namespace.servicebus.windows.net)\n+     * @param tokenCredential The credential for connecting to the AMQP broker.\n+     * @param authorizationType The authorisation type used for authorizing with the CBS node.\n+     * @param transport The type connection used for the AMQP connection.\n+     * @param retryOptions Retry options for the connection.\n+     * @param proxyOptions Any proxy options to set.\n+     * @param scheduler Scheduler for async operations.\n+     * @param clientOptions Client options for the connection.\n+     * @param verifyMode How to verify SSL information.\n+     * @param distributedTransactionsSupport if AMQP session supports distributed transaction across different entities.\n+     *\n+     * @throws NullPointerException in the case that {@code fullyQualifiedNamespace}, {@code tokenCredential},\n+     *     {@code authorizationType}, {@code transport}, {@code retryOptions}, {@code scheduler}, {@code clientOptions}\n+     *     {@code proxyOptions} or {@code verifyMode} is null.\n+     */\n+    public ConnectionOptions(String fullyQualifiedNamespace, TokenCredential tokenCredential,\n+        CbsAuthorizationType authorizationType, AmqpTransportType transport, AmqpRetryOptions retryOptions,\n+        ProxyOptions proxyOptions, Scheduler scheduler, ClientOptions clientOptions,\n+        SslDomain.VerifyMode verifyMode, String product, String clientVersion, boolean distributedTransactionsSupport) {\n+        this(fullyQualifiedNamespace, tokenCredential, authorizationType, transport, retryOptions,\n+            proxyOptions, scheduler, clientOptions, verifyMode, product, clientVersion, fullyQualifiedNamespace,\n+            getPort(transport), distributedTransactionsSupport);\n+    }\n+\n+\n     /**\n      * Creates an instance with the connection options set. Used when an alternative address should be made for the\n      * connection rather than through the fullyQualifiedNamespace.\n@@ -96,7 +127,16 @@ public ConnectionOptions(String fullyQualifiedNamespace, TokenCredential tokenCr\n         CbsAuthorizationType authorizationType, AmqpTransportType transport, AmqpRetryOptions retryOptions,\n         ProxyOptions proxyOptions, Scheduler scheduler, ClientOptions clientOptions,\n         SslDomain.VerifyMode verifyMode, String product, String clientVersion, String hostname, int port) {\n+        this(fullyQualifiedNamespace, tokenCredential,\n+            authorizationType, transport,retryOptions,\n+            proxyOptions, scheduler, clientOptions,\n+            verifyMode,  product, clientVersion, hostname, port, false);\n+    }\n \n+    private ConnectionOptions(String fullyQualifiedNamespace, TokenCredential tokenCredential,\n+        CbsAuthorizationType authorizationType, AmqpTransportType transport, AmqpRetryOptions retryOptions,\n+        ProxyOptions proxyOptions, Scheduler scheduler, ClientOptions clientOptions,\n+        SslDomain.VerifyMode verifyMode, String product, String clientVersion, String hostname, int port, boolean distributedTransactionsSupport) {\n         this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n             \"'fullyQualifiedNamespace' is required.\");\n         this.tokenCredential = Objects.requireNonNull(tokenCredential, \"'tokenCredential' is required.\");\n@@ -112,6 +152,7 @@ public ConnectionOptions(String fullyQualifiedNamespace, TokenCredential tokenCr\n \n         this.product = Objects.requireNonNull(product, \"'product' cannot be null.\");\n         this.clientVersion = Objects.requireNonNull(clientVersion, \"'clientVersion' cannot be null.\");\n+        this.distributedTransactionsSupport = distributedTransactionsSupport;\n     }\n \n     /**\n@@ -240,4 +281,12 @@ private static int getPort(AmqpTransportType transport) {\n                     new IllegalArgumentException(\"Transport Type is not supported: \" + transport));\n         }\n     }\n+\n+    /**\n+     * Determine is distributed transactions are supported across different entities.\n+     * @return true if distributed transactions across different entities are supported.\n+     */\n+    public boolean isDistributedTransactionsSupported() {\n+        return this.distributedTransactionsSupport;\n+    }\n }"
  },
  {
    "sha": "eda013e87f11aa1faf868e31bb6952aaae5b32fb",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/CreateSessionOptions.java",
    "status": "added",
    "additions": 30,
    "deletions": 0,
    "changes": 30,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/CreateSessionOptions.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/CreateSessionOptions.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/CreateSessionOptions.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -0,0 +1,30 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import com.azure.core.annotation.Immutable;\n+\n+/**\n+ * An option bag to provide configuration required to create an AMQP session.\n+ */\n+@Immutable\n+public final class CreateSessionOptions {\n+    private final boolean distributedTransactionsSupport;\n+\n+    /**\n+     * Constructor to create {@link CreateSessionOptions}.\n+     * @param distributedTransactionsSupport if AMQP session supports distributed transaction across different entities.\n+     */\n+    public CreateSessionOptions(boolean distributedTransactionsSupport) {\n+        this.distributedTransactionsSupport = distributedTransactionsSupport;\n+    }\n+\n+    /**\n+     * Determine is distributed transactions are supported across different entities.\n+     * @return true if distributed transactions across different entities are supported.\n+     */\n+    public boolean isDistributedTransactionsSupported() {\n+        return this.distributedTransactionsSupport;\n+    }\n+}"
  },
  {
    "sha": "ee7607c5a7a1e790c4c6578b0f04f1a0e7564caa",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -223,7 +223,8 @@ public int getMaxFrameSize() {\n      */\n     protected AmqpSession createSession(String sessionName, Session session, SessionHandler handler) {\n         return new ReactorSession(session, handler, sessionName, reactorProvider, handlerProvider,\n-            getClaimsBasedSecurityNode(), tokenManagerProvider, messageSerializer, connectionOptions.getRetry());\n+            getClaimsBasedSecurityNode(), tokenManagerProvider, messageSerializer, connectionOptions.getRetry(),\n+            new CreateSessionOptions(connectionOptions.isDistributedTransactionsSupported()));\n     }\n \n     /**"
  },
  {
    "sha": "98dfc2d582b39c96c9da41a5ebe33485be5f731b",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -304,7 +304,9 @@ void dispose(ErrorCondition errorCondition) {\n         }\n \n         subscriptions.dispose();\n-        tokenManager.close();\n+        if (tokenManager != null) {\n+            tokenManager.close();\n+        }\n \n         if (sender.getLocalState() == EndpointState.CLOSED) {\n             return;"
  },
  {
    "sha": "160af82af84f9da558a6b6951b3b6bc3b4039e68",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java",
    "status": "modified",
    "additions": 37,
    "deletions": 1,
    "changes": 38,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -34,6 +34,7 @@\n import java.io.IOException;\n import java.time.Duration;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -80,10 +81,33 @@\n      *     operations on the message broker.\n      * @param retryOptions for the session operations.\n      */\n+    public ReactorSession(Session session, SessionHandler sessionHandler, String sessionName, ReactorProvider provider,\n+        ReactorHandlerProvider handlerProvider, Mono<ClaimsBasedSecurityNode> cbsNodeSupplier,\n+        TokenManagerProvider tokenManagerProvider, MessageSerializer messageSerializer, AmqpRetryOptions retryOptions) {\n+        this(session, sessionHandler, sessionName, provider, handlerProvider, cbsNodeSupplier, tokenManagerProvider,\n+            messageSerializer, retryOptions, new CreateSessionOptions(false));\n+    }\n+\n+    /**\n+     * Creates a new AMQP session using proton-j.\n+     *\n+     * @param session Proton-j session for this AMQP session.\n+     * @param sessionHandler Handler for events that occur in the session.\n+     * @param sessionName Name of the session.\n+     * @param provider Provides reactor instances for messages to sent with.\n+     * @param handlerProvider Providers reactor handlers for listening to proton-j reactor events.\n+     * @param cbsNodeSupplier Mono that returns a reference to the {@link ClaimsBasedSecurityNode}.\n+     * @param tokenManagerProvider Provides {@link TokenManager} that authorizes the client when performing\n+     *     operations on the message broker.\n+     * @param createSessionOptions options required to create the session.\n+     * @param retryOptions for the session operations.\n+     */\n     public ReactorSession(Session session, SessionHandler sessionHandler, String sessionName, ReactorProvider provider,\n         ReactorHandlerProvider handlerProvider, Mono<ClaimsBasedSecurityNode> cbsNodeSupplier,\n         TokenManagerProvider tokenManagerProvider, MessageSerializer messageSerializer,\n-        AmqpRetryOptions retryOptions) {\n+        AmqpRetryOptions retryOptions, CreateSessionOptions createSessionOptions) {\n+        Objects.requireNonNull(createSessionOptions, \"'createSessionOptions' cannot be null.\");\n+\n         this.session = session;\n         this.sessionHandler = sessionHandler;\n         this.handlerProvider = handlerProvider;\n@@ -106,6 +130,14 @@ public ReactorSession(Session session, SessionHandler sessionHandler, String ses\n             .subscribeWith(ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED));\n \n         session.open();\n+\n+        // setup 'Coordinator Send link' to enable cross entity transactions (i.e. distributed transaction).\n+        if (createSessionOptions.isDistributedTransactionsSupported()) {\n+            LinkSubscription<AmqpSendLink> sendLinkCoordinator = getSubscription(TRANSACTION_LINK_NAME,\n+                TRANSACTION_LINK_NAME, new Coordinator(), null, retryOptions, null);\n+            openSendLinks.put(TRANSACTION_LINK_NAME, sendLinkCoordinator);\n+            transactionCoordinator.set(new TransactionCoordinator(sendLinkCoordinator.getLink(), messageSerializer));\n+        }\n     }\n \n     Session session() {\n@@ -148,6 +180,10 @@ void dispose(ErrorCondition errorCondition) {\n \n         openReceiveLinks.forEach((key, link) -> link.dispose(errorCondition));\n         openSendLinks.forEach((key, link) -> link.dispose(errorCondition));\n+\n+        if (transactionCoordinator.get() != null) {\n+            transactionCoordinator.get().dispose();\n+        }\n     }\n \n     /**"
  },
  {
    "sha": "5cf5cd88e23df88355059220622fa2910e38bf8e",
    "filename": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/TransactionCoordinator.java",
    "status": "modified",
    "additions": 21,
    "deletions": 1,
    "changes": 22,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/TransactionCoordinator.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/TransactionCoordinator.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/TransactionCoordinator.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -14,19 +14,23 @@\n import org.apache.qpid.proton.amqp.transport.DeliveryState;\n import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n import org.apache.qpid.proton.message.Message;\n+import reactor.core.Disposable;\n import reactor.core.publisher.Mono;\n \n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n import static com.azure.core.amqp.implementation.ClientConstants.MAX_AMQP_HEADER_SIZE_BYTES;\n \n /**\n  * Encapsulates transaction functions.\n  */\n-final class TransactionCoordinator {\n+final class TransactionCoordinator implements Disposable {\n \n     private final ClientLogger logger = new ClientLogger(TransactionCoordinator.class);\n \n     private final AmqpSendLink sendLink;\n     private final MessageSerializer messageSerializer;\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n \n     TransactionCoordinator(AmqpSendLink sendLink, MessageSerializer messageSerializer) {\n         this.sendLink = sendLink;\n@@ -101,4 +105,20 @@\n                 }\n             });\n     }\n+\n+    @Override\n+    public void dispose() {\n+        if (isDisposed.getAndSet(true)) {\n+            return;\n+        }\n+\n+        if (this.sendLink != null) {\n+            this.sendLink.dispose();\n+        }\n+    }\n+\n+    @Override\n+    public boolean isDisposed() {\n+        return isDisposed.get();\n+    }\n }"
  },
  {
    "sha": "acf765d88d8c8d9d0d6c1be2461692e04fbb89af",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorConnectionTest.java",
    "status": "modified",
    "additions": 68,
    "deletions": 0,
    "changes": 68,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorConnectionTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorConnectionTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorConnectionTest.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -11,12 +11,14 @@\n import com.azure.core.amqp.exception.AmqpErrorCondition;\n import com.azure.core.amqp.exception.AmqpException;\n import com.azure.core.amqp.implementation.handler.ConnectionHandler;\n+import com.azure.core.amqp.implementation.handler.SendLinkHandler;\n import com.azure.core.amqp.implementation.handler.SessionHandler;\n import com.azure.core.credential.TokenCredential;\n import com.azure.core.util.ClientOptions;\n import com.azure.core.util.Header;\n import org.apache.qpid.proton.Proton;\n import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.transaction.Coordinator;\n import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;\n import org.apache.qpid.proton.amqp.transport.SenderSettleMode;\n@@ -25,6 +27,7 @@\n import org.apache.qpid.proton.engine.Event;\n import org.apache.qpid.proton.engine.Handler;\n import org.apache.qpid.proton.engine.Record;\n+import org.apache.qpid.proton.engine.Sender;\n import org.apache.qpid.proton.engine.Session;\n import org.apache.qpid.proton.engine.SslDomain;\n import org.apache.qpid.proton.engine.SslPeerDetails;\n@@ -53,6 +56,7 @@\n \n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doNothing;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n@@ -100,6 +104,8 @@\n     private ReactorProvider reactorProvider;\n     @Mock\n     private ReactorHandlerProvider reactorHandlerProvider;\n+    @Mock\n+    private Sender sender;\n \n     @BeforeAll\n     static void beforeAll() {\n@@ -218,6 +224,68 @@ void createSession() {\n         verify(record).set(Handler.class, Handler.class, sessionHandler);\n     }\n \n+    /**\n+     * Creates a session with the given name and set handler.\n+     */\n+    @Test\n+    void createCoordinatorSession() {\n+        // Arrange\n+        // We want to ensure that the ReactorExecutor does not shutdown unexpectedly. There are still items to still\n+        // process.\n+        final boolean coordinatorRequired = true;\n+        final String TRANSACTION_LINK_NAME = \"coordinator\";\n+        final String entityPath = \"coordinator\";\n+        final SendLinkHandler sendLinkHandler = new SendLinkHandler(CONNECTION_ID, FULLY_QUALIFIED_NAMESPACE, TRANSACTION_LINK_NAME, entityPath);\n+\n+        when(reactor.process()).thenReturn(true);\n+        when(reactor.connectionToHost(connectionHandler.getHostname(), connectionHandler.getProtocolPort(),\n+            connectionHandler)).thenReturn(connectionProtonJ);\n+        when(connectionProtonJ.session()).thenReturn(session);\n+        when(session.attachments()).thenReturn(record);\n+        doNothing().when(sender).setTarget(any(Coordinator.class));\n+\n+        when(session.sender(TRANSACTION_LINK_NAME)).thenReturn(sender);\n+        when(sender.attachments()).thenReturn(record);\n+        when(reactorHandlerProvider.createSendLinkHandler(CONNECTION_ID, FULLY_QUALIFIED_NAMESPACE, TRANSACTION_LINK_NAME, entityPath))\n+            .thenReturn(sendLinkHandler);\n+\n+        final AmqpRetryOptions retryOptions = new AmqpRetryOptions().setMaxRetries(0).setTryTimeout(TEST_DURATION);\n+\n+        final ConnectionOptions connectionOptions = new ConnectionOptions(CREDENTIAL_INFO.getEndpoint().getHost(),\n+            tokenCredential, CbsAuthorizationType.SHARED_ACCESS_SIGNATURE, AmqpTransportType.AMQP, retryOptions,\n+            ProxyOptions.SYSTEM_DEFAULTS, SCHEDULER, CLIENT_OPTIONS, VERIFY_MODE, PRODUCT, CLIENT_VERSION, coordinatorRequired);\n+\n+        when(reactorHandlerProvider.createConnectionHandler(CONNECTION_ID, connectionOptions))\n+            .thenReturn(connectionHandler);\n+        connection = new ReactorConnection(CONNECTION_ID, connectionOptions, reactorProvider, reactorHandlerProvider,\n+            tokenManager, messageSerializer, SenderSettleMode.SETTLED, ReceiverSettleMode.FIRST);\n+\n+        // Act & Assert\n+        StepVerifier.create(connection.createSession(SESSION_NAME))\n+            .assertNext(s -> {\n+                Assertions.assertNotNull(s);\n+                Assertions.assertEquals(SESSION_NAME, s.getSessionName());\n+                Assertions.assertTrue(s instanceof ReactorSession);\n+                Assertions.assertSame(session, ((ReactorSession) s).session());\n+            }).verifyComplete();\n+\n+        // Assert that the same instance is obtained and we don't get a new session with the same name.\n+        StepVerifier.create(connection.createSession(SESSION_NAME))\n+            .assertNext(s -> {\n+                Assertions.assertNotNull(s);\n+                Assertions.assertEquals(SESSION_NAME, s.getSessionName());\n+                Assertions.assertTrue(s instanceof ReactorSession);\n+                Assertions.assertSame(session, ((ReactorSession) s).session());\n+            }).verifyComplete();\n+\n+\n+        verify(record).set(Handler.class, Handler.class, sessionHandler);\n+\n+        verify(session).sender(TRANSACTION_LINK_NAME);\n+        verify(sender).setTarget(any(Coordinator.class));\n+        verify(session).open();\n+    }\n+\n     /**\n      * Creates a session with the given name and set handler.\n      */"
  },
  {
    "sha": "096817609fe3e96bfffa7bbab9df23f8fd7ac467",
    "filename": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSessionTest.java",
    "status": "modified",
    "additions": 35,
    "deletions": 0,
    "changes": 35,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSessionTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSessionTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSessionTest.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -15,6 +15,7 @@\n import com.azure.core.amqp.implementation.handler.SendLinkHandler;\n import com.azure.core.amqp.implementation.handler.SessionHandler;\n import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.transaction.Coordinator;\n import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n import org.apache.qpid.proton.engine.EndpointState;\n import org.apache.qpid.proton.engine.Event;\n@@ -43,6 +44,7 @@\n import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doNothing;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n@@ -233,6 +235,39 @@ void createProducerAgainAfterException() {\n         sendLinkHandler.onLinkRemoteClose(closeSendEvent);\n     }\n \n+    @Test\n+    void constructorCreateCoordinatorTest() {\n+        // Arrange\n+        final String TRANSACTION_LINK_NAME = \"coordinator\";\n+        final String entityPath = \"coordinator\";\n+        final boolean distributedTransactionsSupport = true;\n+\n+        final Duration timeout = Duration.ofSeconds(10);\n+        final AmqpRetryOptions options = new AmqpRetryOptions().setTryTimeout(timeout)\n+            .setMaxRetries(1)\n+            .setMode(AmqpRetryMode.FIXED);\n+\n+        final TokenManager tokenManager = mock(TokenManager.class);\n+        final SendLinkHandler sendLinkHandler = new SendLinkHandler(ID, HOST, TRANSACTION_LINK_NAME, entityPath);\n+\n+        doNothing().when(sender).setTarget(any(Coordinator.class));\n+\n+        when(session.sender(TRANSACTION_LINK_NAME)).thenReturn(sender);\n+        when(tokenManagerProvider.getTokenManager(cbsNodeSupplier, entityPath)).thenReturn(tokenManager);\n+        when(tokenManager.authorize()).thenReturn(Mono.just(1000L));\n+        when(tokenManager.getAuthorizationResults())\n+            .thenReturn(Flux.create(sink -> sink.next(AmqpResponseCode.ACCEPTED)));\n+        when(reactorHandlerProvider.createSendLinkHandler(ID, HOST, TRANSACTION_LINK_NAME, entityPath))\n+            .thenReturn(sendLinkHandler);\n+\n+        this.reactorSession = new ReactorSession(session, handler, NAME, reactorProvider, reactorHandlerProvider,\n+            cbsNodeSupplier, tokenManagerProvider, serializer, options, new CreateSessionOptions(distributedTransactionsSupport));\n+\n+        verify(session).sender(TRANSACTION_LINK_NAME);\n+        verify(sender).setTarget(any(Coordinator.class));\n+        verify(session).open();\n+    }\n+\n     @Test\n     void createConsumer() {\n         // Arrange"
  },
  {
    "sha": "0d466eb18f1db36a48e8a0aaf4a5872f192e7f1f",
    "filename": "sdk/eventhubs/azure-messaging-eventhubs/pom.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/eventhubs/azure-messaging-eventhubs/pom.xml",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/eventhubs/azure-messaging-eventhubs/pom.xml",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/eventhubs/azure-messaging-eventhubs/pom.xml?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -42,7 +42,7 @@\n     <dependency>\n       <groupId>com.azure</groupId>\n       <artifactId>azure-core-amqp</artifactId>\n-      <version>2.0.3</version> <!-- {x-version-update;com.azure:azure-core-amqp;dependency} -->\n+      <version>2.1.0-beta.1</version> <!-- {x-version-update;com.azure:azure-core-amqp;dependency} -->\n     </dependency>\n \n     <!-- Test dependencies -->"
  },
  {
    "sha": "7bfc5aa7a7043fdcca9950d5a9a43056790a4a3b",
    "filename": "sdk/servicebus/azure-messaging-servicebus/CHANGELOG.md",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/CHANGELOG.md",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/CHANGELOG.md",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/servicebus/azure-messaging-servicebus/CHANGELOG.md?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -1,5 +1,9 @@\n # Release History\n \n+## 7.2.0-beta.1 (2021-03-18)\n+### New Features\n+- Added support for distributed transactions across entities. Added API 'ServiceBusClientBuilder.enableCrossEntityTransactions()'.\n+\n ## 7.1.0 (2021-03-10)\n ### Bug Fixes\n - Continue to receive messages regardless of user not settling the received message in PEEK_LOCK mode [#19247](https://github.com/Azure/azure-sdk-for-java/issues/19247)."
  },
  {
    "sha": "cc2f982b29aea4f23046c0431a0f480aa68db226",
    "filename": "sdk/servicebus/azure-messaging-servicebus/pom.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/pom.xml",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/pom.xml",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/servicebus/azure-messaging-servicebus/pom.xml?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -47,7 +47,7 @@\n     <dependency>\n       <groupId>com.azure</groupId>\n       <artifactId>azure-core-amqp</artifactId>\n-      <version>2.0.3</version> <!-- {x-version-update;com.azure:azure-core-amqp;dependency} -->\n+      <version>2.1.0-beta.1</version> <!-- {x-version-update;com.azure:azure-core-amqp;dependency} -->\n     </dependency>\n     <dependency>\n       <groupId>com.azure</groupId>"
  },
  {
    "sha": "cf3a5744b4dfe028771e967d38eba638d352668b",
    "filename": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java",
    "status": "modified",
    "additions": 23,
    "deletions": 2,
    "changes": 25,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -91,7 +91,7 @@\n  * <li>{@link ServiceBusSessionReceiverAsyncClient}</li>\n  * <li>{@link ServiceBusSessionReceiverClient}</li>\n  * </ul>\n- *\n+ *ServiceBusClientBuilder\n  * <p><strong>Client for receiving messages using a callback-based processor</strong></p>\n  * <ul>\n  * <li>{@link ServiceBusProcessorClient}</li>\n@@ -134,6 +134,7 @@\n     private Scheduler scheduler;\n     private AmqpTransportType transport = AmqpTransportType.AMQP;\n     private SslDomain.VerifyMode verifyMode;\n+    private boolean crossEntityTransactions;\n \n     /**\n      * Keeps track of the open clients that were created from this builder when there is a shared connection.\n@@ -187,6 +188,26 @@ public ServiceBusClientBuilder connectionString(String connectionString) {\n         return credential(properties.getEndpoint().getHost(), tokenCredential);\n     }\n \n+    /**\n+     * Enable cross entity transaction on the connection to Service bus. Use this feature when your transaction is\n+     * involved in different Service Bus entities.\n+     * <p><strong>Avoid using non-transaction API on this client</strong></p>\n+     * Since this feature will set up connection to Service Bus in a\n+     * specific way, You should avoid using non transaction activities on the clients\n+     * which have this feature enabled. Once all the clients have been setup, the first receiver or sender used will initialise 'send-via'\n+     * <p><strong>When not to enable this feature</strong></p>\n+     * If your transaction involved in one Service bus entity only. For example you are receiving from a\n+     * queue/subscription and you want to settle your own messages which are part of one transaction.\n+     *\n+     * @return The updated {@link ServiceBusSenderClientBuilder} object.\n+     *\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions#transfers-and-send-via\">Service Bus transactions</a>\n+     */\n+    public ServiceBusClientBuilder enableCrossEntityTransactions() {\n+        this.crossEntityTransactions = true;\n+        return this;\n+    }\n+\n     private TokenCredential getTokenCredential(ConnectionStringProperties properties) {\n         TokenCredential tokenCredential;\n         if (properties.getSharedAccessSignature() == null) {\n@@ -440,7 +461,7 @@ private ConnectionOptions getConnectionOptions() {\n         final String clientVersion = properties.getOrDefault(VERSION_KEY, UNKNOWN);\n \n         return new ConnectionOptions(fullyQualifiedNamespace, credentials, authorizationType, transport, retryOptions,\n-            proxyOptions, scheduler, options, verificationMode, product, clientVersion);\n+            proxyOptions, scheduler, options, verificationMode, product, clientVersion, crossEntityTransactions);\n     }\n \n     private ProxyOptions getDefaultProxyConfiguration(Configuration configuration) {"
  },
  {
    "sha": "17c1e26537f2c40f167e3a781ecbe825fcdcce86",
    "filename": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorAmqpConnection.java",
    "status": "modified",
    "additions": 12,
    "deletions": 3,
    "changes": 15,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorAmqpConnection.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorAmqpConnection.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorAmqpConnection.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -37,6 +37,7 @@\n     private static final String MANAGEMENT_SESSION_NAME = \"mgmt-session\";\n     private static final String MANAGEMENT_LINK_NAME = \"mgmt\";\n     private static final String MANAGEMENT_ADDRESS = \"$management\";\n+    private static final String CROSS_ENTITY_TRANSACTIONS_LINK_NAME = \"crossentity-coordinator\";\n \n     private final ClientLogger logger = new ClientLogger(ServiceBusReactorAmqpConnection.class);\n     /**\n@@ -54,6 +55,7 @@\n     private final Scheduler scheduler;\n     private final String fullyQualifiedNamespace;\n     private final CbsAuthorizationType authorizationType;\n+    private final boolean distributedTransactionsSupport;\n \n     /**\n      * Creates a new AMQP connection that uses proton-j.\n@@ -80,6 +82,7 @@ public ServiceBusReactorAmqpConnection(String connectionId, ConnectionOptions co\n         this.messageSerializer = messageSerializer;\n         this.scheduler = connectionOptions.getScheduler();\n         this.fullyQualifiedNamespace = connectionOptions.getFullyQualifiedNamespace();\n+        this.distributedTransactionsSupport = connectionOptions.isDistributedTransactionsSupported();\n     }\n \n     @Override\n@@ -141,11 +144,11 @@ public ServiceBusReactorAmqpConnection(String connectionId, ConnectionOptions co\n     public Mono<AmqpSendLink> createSendLink(String linkName, String entityPath, AmqpRetryOptions retryOptions,\n          String transferEntityPath) {\n \n-        return createSession(entityPath).cast(ServiceBusSession.class).flatMap(session -> {\n+        return createSession(linkName).cast(ServiceBusSession.class).flatMap(session -> {\n             logger.verbose(\"Get or create sender link : '{}'\", linkName);\n             final AmqpRetryPolicy retryPolicy = RetryUtil.getRetryPolicy(retryOptions);\n \n-            return session.createProducer(linkName, entityPath, retryOptions.getTryTimeout(),\n+            return session.createProducer(linkName + entityPath, entityPath, retryOptions.getTryTimeout(),\n                 retryPolicy, transferEntityPath).cast(AmqpSendLink.class);\n         });\n     }\n@@ -176,6 +179,11 @@ public ServiceBusReactorAmqpConnection(String connectionId, ConnectionOptions co\n             });\n     }\n \n+    @Override\n+    public Mono<AmqpSession> createSession(String sessionName) {\n+        return super.createSession(distributedTransactionsSupport ? CROSS_ENTITY_TRANSACTIONS_LINK_NAME : sessionName);\n+    }\n+\n     /**\n      * Creates or gets an existing receive link. The same link is returned if there is an existing receive link with the\n      * same {@code linkName}. Otherwise, a new link is created and returned.\n@@ -215,6 +223,7 @@ public void dispose() {\n     @Override\n     protected AmqpSession createSession(String sessionName, Session session, SessionHandler handler) {\n         return new ServiceBusReactorSession(session, handler, sessionName, reactorProvider, handlerProvider,\n-            getClaimsBasedSecurityNode(), tokenManagerProvider, messageSerializer, retryOptions);\n+            getClaimsBasedSecurityNode(), tokenManagerProvider, messageSerializer, retryOptions,\n+            distributedTransactionsSupport);\n     }\n }"
  },
  {
    "sha": "0a7842526976ca08dac598614037977870c10804",
    "filename": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorSession.java",
    "status": "modified",
    "additions": 5,
    "deletions": 2,
    "changes": 7,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorSession.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorSession.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorSession.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -8,6 +8,7 @@\n import com.azure.core.amqp.AmqpRetryPolicy;\n import com.azure.core.amqp.ClaimsBasedSecurityNode;\n import com.azure.core.amqp.implementation.AmqpConstants;\n+import com.azure.core.amqp.implementation.CreateSessionOptions;\n import com.azure.core.amqp.implementation.MessageSerializer;\n import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n import com.azure.core.amqp.implementation.ReactorProvider;\n@@ -66,12 +67,14 @@\n      * @param tokenManagerProvider Provides {@link TokenManager} that authorizes the client when performing\n      *     operations on the message broker.\n      * @param retryOptions Retry options.\n+     * @param distributedTransactionsSupport if the session require support for distributed transactions across entity.\n      */\n     ServiceBusReactorSession(Session session, SessionHandler sessionHandler, String sessionName,\n         ReactorProvider provider, ReactorHandlerProvider handlerProvider, Mono<ClaimsBasedSecurityNode> cbsNodeSupplier,\n-        TokenManagerProvider tokenManagerProvider, MessageSerializer messageSerializer, AmqpRetryOptions retryOptions) {\n+        TokenManagerProvider tokenManagerProvider, MessageSerializer messageSerializer, AmqpRetryOptions retryOptions,\n+        boolean distributedTransactionsSupport) {\n         super(session, sessionHandler, sessionName, provider, handlerProvider, cbsNodeSupplier, tokenManagerProvider,\n-            messageSerializer, retryOptions);\n+            messageSerializer, retryOptions, new CreateSessionOptions(distributedTransactionsSupport));\n         this.retryOptions = retryOptions;\n         this.retryPolicy = RetryUtil.getRetryPolicy(retryOptions);\n         this.tokenManagerProvider = tokenManagerProvider;"
  },
  {
    "sha": "19f5232e1e37d11da0602ae56fb8173b58feb6e0",
    "filename": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusMixClientIntegrationTest.java",
    "status": "added",
    "additions": 337,
    "deletions": 0,
    "changes": 337,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusMixClientIntegrationTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusMixClientIntegrationTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusMixClientIntegrationTest.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -0,0 +1,337 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.models.CompleteOptions;\n+import com.azure.messaging.servicebus.models.ServiceBusReceiveMode;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Test where various clients are involved for example Sender, Receiver and Processor client.\n+ */\n+public class ServiceBusMixClientIntegrationTest extends IntegrationTestBase {\n+    private ServiceBusSenderAsyncClient sender;\n+    private ServiceBusReceiverAsyncClient receiver;\n+    private final AtomicInteger messagesPending = new AtomicInteger();\n+\n+    ServiceBusMixClientIntegrationTest() {\n+        super(new ClientLogger(ServiceBusSenderAsyncClientIntegrationTest.class));\n+    }\n+\n+    @Override\n+    protected void beforeTest() {\n+        sessionId = UUID.randomUUID().toString();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        dispose(sender);\n+\n+        final int numberOfMessages = messagesPending.get();\n+        if (numberOfMessages < 1) {\n+            dispose(receiver);\n+            return;\n+        }\n+\n+        try {\n+            if (receiver == null) {\n+                return;\n+            }\n+            receiver.receiveMessages()\n+                .take(numberOfMessages)\n+                .map(message -> {\n+                    logger.info(\"Message received: {}\", message.getSequenceNumber());\n+                    return message;\n+                })\n+                .timeout(Duration.ofSeconds(5), Mono.empty())\n+                .blockLast();\n+        } catch (Exception e) {\n+            logger.warning(\"Error occurred when draining queue.\", e);\n+        } finally {\n+            dispose(receiver);\n+        }\n+    }\n+\n+    /**\n+     * Use case: Test cross entity transaction using processor client and sender.\n+     * 1. Read messages from entity A.\n+     * 2. complete the messages from entity A and write to entity B.\n+     * 2. commit the transaction.\n+     */\n+    @MethodSource(\"com.azure.messaging.servicebus.IntegrationTestBase#messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void crossEntityTransactionWithProcessorTest(MessagingEntityType entityType, boolean isSessionEnabled) throws InterruptedException {\n+\n+        // Arrange\n+        final boolean useCredentials = false;\n+        final int receiveQueueAIndex = TestUtils.USE_CASE_TXN_1;\n+        final int sendQueueBIndex = TestUtils.USE_CASE_TXN_2;\n+        final String queueA = isSessionEnabled ? getSessionQueueName(receiveQueueAIndex) : getQueueName(receiveQueueAIndex);\n+        final String queueB = isSessionEnabled ? getSessionQueueName(sendQueueBIndex) : getQueueName(sendQueueBIndex);\n+        final String topicA = getTopicName(receiveQueueAIndex);\n+        final String topicB = getTopicName(sendQueueBIndex);\n+        final AtomicBoolean transactionComplete = new AtomicBoolean();\n+\n+        final CountDownLatch countdownLatch = new CountDownLatch(1);\n+        final AtomicInteger receivedMessages = new AtomicInteger();\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS_BYTES, messageId);\n+        message.setSessionId(sessionId);\n+        final List<ServiceBusMessage> messages = Arrays.asList(message);\n+\n+        ServiceBusClientBuilder builder = getBuilder(useCredentials).enableCrossEntityTransactions();\n+\n+        final ServiceBusSenderAsyncClient senderAsyncA;\n+        final ServiceBusSenderClient senderSyncB;\n+\n+        // Initialize sender\n+        switch (entityType) {\n+            case QUEUE:\n+                senderAsyncA = builder.sender().queueName(queueA).buildAsyncClient();\n+                senderSyncB = builder.sender().queueName(queueB).buildClient();\n+                break;\n+            case SUBSCRIPTION:\n+                senderAsyncA = builder.sender().topicName(topicA).buildAsyncClient();\n+                senderSyncB = builder.sender().topicName(topicB).buildClient();\n+                break;\n+            default:\n+                logger.error(\"Invalid entity type {}.\", entityType);\n+                throw new RuntimeException(\"Invalid entity type.\");\n+        }\n+\n+        Consumer<ServiceBusReceivedMessageContext> processMessage = (context) -> {\n+            receivedMessages.incrementAndGet();\n+            messagesPending.incrementAndGet();\n+            ServiceBusReceivedMessage myMessage = context.getMessage();\n+            System.out.printf(\"Processing message. MessageId: %s, Sequence #: %s. Contents: %s %n\", myMessage.getMessageId(),\n+                myMessage.getSequenceNumber(), myMessage.getBody());\n+            if (receivedMessages.get() == 1) {\n+\n+                //Start a transaction\n+                ServiceBusTransactionContext transactionId = senderSyncB.createTransaction();\n+                context.complete(new CompleteOptions().setTransactionContext(transactionId));\n+                senderSyncB.sendMessage(new ServiceBusMessage(CONTENTS_BYTES).setMessageId(messageId).setSessionId(sessionId), transactionId);\n+                senderSyncB.commitTransaction(transactionId);\n+                transactionComplete.set(true);\n+                countdownLatch.countDown();\n+                logger.verbose(\"Transaction committed.\");\n+            }\n+        };\n+\n+        Consumer<ServiceBusErrorContext> processError = context -> {\n+            System.out.printf(\"Error when receiving messages from namespace: '%s'. Entity: '%s'. Error Source: '%s' %n\",\n+                context.getFullyQualifiedNamespace(), context.getEntityPath(), context.getErrorSource());\n+            Assertions.fail(\"Failed processing of message.\", context.getException());\n+\n+            if (!(context.getException() instanceof ServiceBusException)) {\n+                System.out.printf(\"Non-ServiceBusException occurred: %s%n\", context.getException());\n+            }\n+        };\n+\n+        final ServiceBusProcessorClient processorA;\n+        // Initialize processor client\n+        switch (entityType) {\n+            case QUEUE:\n+                if (isSessionEnabled) {\n+                    processorA = builder.sessionProcessor().disableAutoComplete().queueName(queueA)\n+                        .processMessage(processMessage).processError(processError)\n+                        .buildProcessorClient();\n+                } else {\n+                    processorA = builder.processor().disableAutoComplete().queueName(queueA)\n+                        .processMessage(processMessage).processError(processError)\n+                        .buildProcessorClient();\n+                }\n+                break;\n+            case SUBSCRIPTION:\n+                if (isSessionEnabled) {\n+                    processorA = builder.sessionProcessor().disableAutoComplete().topicName(topicA).subscriptionName(\"session-subscription\")\n+                        .processMessage(processMessage).processError(processError)\n+                        .buildProcessorClient();\n+                } else {\n+                    processorA = builder.processor().disableAutoComplete().topicName(topicA).subscriptionName(\"subscription\")\n+                        .processMessage(processMessage).processError(processError)\n+                        .buildProcessorClient();\n+                }\n+                break;\n+            default:\n+                logger.error(\"Invalid entity type {}.\", entityType);\n+                throw new RuntimeException(\"Invalid entity type.\");\n+        }\n+\n+        // Send messages\n+        StepVerifier.create(senderAsyncA.sendMessages(messages)).verifyComplete();\n+        // Create an instance of the processor through the ServiceBusClientBuilder\n+\n+        // Act\n+        System.out.println(\"Starting the processor\");\n+        processorA.start();\n+\n+        // Assert\n+        System.out.println(\"Listening for 10 seconds...\");\n+        if (countdownLatch.await(10, TimeUnit.SECONDS)) {\n+            System.out.println(\"Completed processing successfully.\");\n+            Assertions.assertTrue(transactionComplete.get());\n+        } else {\n+            System.out.println(\"Closing processor.\");\n+            Assertions.fail(\"Failed to process message.\");\n+        }\n+\n+        processorA.close();\n+\n+\n+        // Verify that message is received by queue B\n+        if (!isSessionEnabled) {\n+            setSenderAndReceiver(entityType, sendQueueBIndex, false);\n+            StepVerifier.create(receiver.receiveMessages().take(1))\n+                .assertNext(receivedMessage -> {\n+                    assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+                    messagesPending.decrementAndGet();\n+                }).verifyComplete();\n+        }\n+    }\n+\n+    /**\n+     * Use case: Test cross entity transaction using receiver and senders.\n+     * 1. Read messages from entity A.\n+     * 2. complete the messages from entity A and write to entity B.\n+     * 2. commit the transaction.\n+     */\n+    @MethodSource(\"com.azure.messaging.servicebus.IntegrationTestBase#messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void crossEntityTransactionWithReceiverSenderTest(MessagingEntityType entityType, boolean isSessionEnabled) throws InterruptedException {\n+\n+        // Arrange\n+        final boolean useCredentials = false;\n+        final int receiveQueueAIndex = TestUtils.USE_CASE_TXN_1;\n+        final int sendQueueBIndex = TestUtils.USE_CASE_TXN_2;\n+        final String queueA = isSessionEnabled ? getSessionQueueName(receiveQueueAIndex) : getQueueName(receiveQueueAIndex);\n+        final String queueB = isSessionEnabled ? getSessionQueueName(sendQueueBIndex) : getQueueName(sendQueueBIndex);\n+        final String topicA = getTopicName(receiveQueueAIndex);\n+        final String topicB = getTopicName(sendQueueBIndex);\n+        final AtomicBoolean transactionComplete = new AtomicBoolean();\n+\n+        final CountDownLatch countdownLatch = new CountDownLatch(1);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS_BYTES, messageId);\n+        message.setSessionId(sessionId);\n+        final List<ServiceBusMessage> messages = Arrays.asList(message);\n+\n+        ServiceBusClientBuilder builder = getBuilder(useCredentials).enableCrossEntityTransactions();\n+\n+        final ServiceBusSenderAsyncClient senderAsyncA;\n+        final ServiceBusSenderClient senderSyncB;\n+\n+        // Initialize sender\n+        switch (entityType) {\n+            case QUEUE:\n+                senderAsyncA = builder.sender().queueName(queueA).buildAsyncClient();\n+                senderSyncB = builder.sender().queueName(queueB).buildClient();\n+                break;\n+            case SUBSCRIPTION:\n+                senderAsyncA = builder.sender().topicName(topicA).buildAsyncClient();\n+                senderSyncB = builder.sender().topicName(topicB).buildClient();\n+                break;\n+            default:\n+                logger.error(\"Invalid entity type {}.\", entityType);\n+                throw new RuntimeException(\"Invalid entity type.\");\n+        }\n+\n+        // Send messages\n+        StepVerifier.create(senderAsyncA.sendMessages(messages)).verifyComplete();\n+\n+        final ServiceBusReceiverAsyncClient receiverA;\n+\n+        switch (entityType) {\n+            case QUEUE:\n+                if (isSessionEnabled) {\n+                    receiverA = builder.sessionReceiver().disableAutoComplete().queueName(queueA)\n+                        .buildAsyncClient().acceptNextSession().block();\n+                } else {\n+                    receiverA = builder.receiver().disableAutoComplete().queueName(queueA)\n+                        .buildAsyncClient();\n+                }\n+                break;\n+            case SUBSCRIPTION:\n+                if (isSessionEnabled) {\n+                    receiverA = builder.sessionReceiver().disableAutoComplete().topicName(topicA).subscriptionName(\"session-subscription\")\n+                        .buildAsyncClient().acceptNextSession().block();\n+                } else {\n+                    receiverA = builder.receiver().disableAutoComplete().topicName(topicA).subscriptionName(\"subscription\")\n+                        .buildAsyncClient();\n+                }\n+                break;\n+            default:\n+                logger.error(\"Invalid entity type {}.\", entityType);\n+                throw new RuntimeException(\"Invalid entity type.\");\n+        }\n+\n+        receiverA.receiveMessages().flatMap(receivedMessage -> {\n+            //Start a transaction\n+            logger.verbose(\"Received message sequence number {}. Creating transaction\", receivedMessage.getSequenceNumber());\n+            ServiceBusTransactionContext transactionId = senderSyncB.createTransaction();\n+            receiverA.complete(receivedMessage, new CompleteOptions().setTransactionContext(transactionId)).block();\n+            senderSyncB.sendMessage(new ServiceBusMessage(CONTENTS_BYTES).setMessageId(messageId).setSessionId(sessionId), transactionId);\n+            senderSyncB.commitTransaction(transactionId);\n+            transactionComplete.set(true);\n+            countdownLatch.countDown();\n+            logger.verbose(\"Transaction committed.\");\n+            return Mono.just(receivedMessage);\n+        }).subscribe();\n+\n+\n+        // Act\n+        System.out.println(\"Listening for 10 seconds...\");\n+        if (countdownLatch.await(10, TimeUnit.SECONDS)) {\n+            System.out.println(\"Completed message processing successfully.\");\n+            Assertions.assertTrue(transactionComplete.get());\n+        } else {\n+            System.out.println(\"Some error.\");\n+            Assertions.fail(\"Failed to process message.\");\n+        }\n+\n+        // Assert\n+        // Verify that message is received by entity B\n+        if (!isSessionEnabled) {\n+            setSenderAndReceiver(entityType, sendQueueBIndex, false);\n+            StepVerifier.create(receiver.receiveMessages().take(1))\n+                .assertNext(receivedMessage -> {\n+                    assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+                    messagesPending.decrementAndGet();\n+                }).verifyComplete();\n+        }\n+    }\n+\n+    /**\n+     * Sets the sender and receiver. If session is enabled, then a single-named session receiver is created.\n+     */\n+    private void setSenderAndReceiver(MessagingEntityType entityType, int entityIndex, boolean useCredentials) {\n+        final boolean isSessionAware = false;\n+        final boolean sharedConnection = true;\n+\n+        this.sender = getSenderBuilder(useCredentials, entityType, entityIndex, isSessionAware, sharedConnection)\n+            .buildAsyncClient();\n+        this.receiver = getReceiverBuilder(useCredentials, entityType, entityIndex, sharedConnection)\n+            .receiveMode(ServiceBusReceiveMode.RECEIVE_AND_DELETE)\n+            .disableAutoComplete()\n+            .buildAsyncClient();\n+    }\n+}"
  },
  {
    "sha": "4fd2bc94f01211cdc58a3efec0c61188a0ac9662",
    "filename": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientIntegrationTest.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientIntegrationTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientIntegrationTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientIntegrationTest.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -153,8 +153,8 @@ void viaQueueMessageSendTest() {\n         // Arrange\n         final boolean useCredentials = false;\n         final Duration shortTimeout = Duration.ofSeconds(15);\n-        final int viaIntermediateEntity = TestUtils.USE_CASE_SEND_VIA_QUEUE_1;\n-        final int destinationEntity = TestUtils.USE_CASE_SEND_VIA_QUEUE_2;\n+        final int viaIntermediateEntity = TestUtils.USE_CASE_TXN_1;\n+        final int destinationEntity = TestUtils.USE_CASE_TXN_2;\n         final boolean shareConnection = true;\n         final MessagingEntityType entityType = MessagingEntityType.QUEUE;\n         final boolean isSessionEnabled = false;"
  },
  {
    "sha": "3adcaf743b49a127e531f7c069c1c9da300a1861",
    "filename": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/TestUtils.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/TestUtils.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/TestUtils.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/TestUtils.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -56,8 +56,8 @@\n     static final int USE_CASE_PEEK_RECEIVE_AND_DEFER = 10;\n     static final int USE_CASE_PEEK_TRANSACTION_SENDRECEIVE_AND_COMPLETE = 11;\n     static final int USE_CASE_SINGLE_SESSION = 12;\n-    static final int USE_CASE_SEND_VIA_QUEUE_1 = 13;\n-    static final int USE_CASE_SEND_VIA_QUEUE_2 = 14;\n+    static final int USE_CASE_TXN_1 = 13;\n+    static final int USE_CASE_TXN_2 = 14;\n     static final int USE_CASE_SEND_VIA_TOPIC_1 = 15;\n     static final int USE_CASE_SEND_VIA_TOPIC_2 = 16;\n     static final int USE_CASE_VALIDATE_AMQP_PROPERTIES = 17;"
  },
  {
    "sha": "c84588469fd34e5b4164028fe287c78e0a2c1105",
    "filename": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorSessionTest.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/Azure/azure-sdk-for-java/blob/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorSessionTest.java",
    "raw_url": "https://github.com/Azure/azure-sdk-for-java/raw/5b7209cec351af8c568a9bb89ee24c3a9f54bd35/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorSessionTest.java",
    "contents_url": "https://api.github.com/repos/Azure/azure-sdk-for-java/contents/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorSessionTest.java?ref=5b7209cec351af8c568a9bb89ee24c3a9f54bd35",
    "patch": "@@ -194,7 +194,8 @@ void setup(TestInfo testInfo) {\n         when(reactorProvider.getReactorDispatcher()).thenReturn(dispatcher);\n \n         serviceBusReactorSession = new ServiceBusReactorSession(session, handler, SESSION_NAME, reactorProvider,\n-            handlerProvider, cbsNodeSupplier, tokenManagerProvider, messageSerializer, retryOptions);\n+            handlerProvider, cbsNodeSupplier, tokenManagerProvider, messageSerializer, retryOptions,\n+            false);\n     }\n \n     @AfterEach"
  }
]
