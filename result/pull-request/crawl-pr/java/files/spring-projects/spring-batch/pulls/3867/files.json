[
  {
    "sha": "912386aa0576868da3e4939de2064c419e809b42",
    "filename": "spring-batch-core/src/main/java/org/springframework/batch/core/repository/dao/JdbcJobExecutionDao.java",
    "status": "modified",
    "additions": 43,
    "deletions": 30,
    "changes": 73,
    "blob_url": "https://github.com/spring-projects/spring-batch/blob/6fcbc2552d24bf1b50c76dfed49bde231ad326f9/spring-batch-core/src/main/java/org/springframework/batch/core/repository/dao/JdbcJobExecutionDao.java",
    "raw_url": "https://github.com/spring-projects/spring-batch/raw/6fcbc2552d24bf1b50c76dfed49bde231ad326f9/spring-batch-core/src/main/java/org/springframework/batch/core/repository/dao/JdbcJobExecutionDao.java",
    "contents_url": "https://api.github.com/repos/spring-projects/spring-batch/contents/spring-batch-core/src/main/java/org/springframework/batch/core/repository/dao/JdbcJobExecutionDao.java?ref=6fcbc2552d24bf1b50c76dfed49bde231ad326f9",
    "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2006-2019 the original author or authors.\n+ * Copyright 2006-2021 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,15 +16,16 @@\n \n package org.springframework.batch.core.repository.dao;\n \n+import java.sql.PreparedStatement;\n import java.sql.ResultSet;\n import java.sql.SQLException;\n import java.sql.Timestamp;\n import java.sql.Types;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Date;\n import java.util.Map;\n-import java.util.Map.Entry;\n import java.util.Set;\n \n import org.apache.commons.logging.Log;\n@@ -61,6 +62,7 @@\n  * @author Michael Minella\n  * @author Mahmoud Ben Hassine\n  * @author Dimitrios Liapis\n+ * @author Philippe Marschall\n  */\n public class JdbcJobExecutionDao extends AbstractJdbcBatchMetadataDao implements JobExecutionDao, InitializingBean {\n \n@@ -321,42 +323,53 @@ public void synchronizeStatus(JobExecution jobExecution) {\n \t */\n \tprivate void insertJobParameters(Long executionId, JobParameters jobParameters) {\n \n-\t\tfor (Entry<String, JobParameter> entry : jobParameters.getParameters()\n-\t\t\t\t.entrySet()) {\n-\t\t\tJobParameter jobParameter = entry.getValue();\n-\t\t\tinsertParameter(executionId, jobParameter.getType(), entry.getKey(),\n-\t\t\t\t\tjobParameter.getValue(), jobParameter.isIdentifying());\n+\t\tif (jobParameters.isEmpty()) {\n+\t\t\treturn;\n \t\t}\n-\t}\n \n+\t\tgetJdbcTemplate().batchUpdate(getQuery(CREATE_JOB_PARAMETERS), jobParameters.getParameters().entrySet(), 100, (ps, entry) -> {\n+\t\t\tJobParameter jobParameter = entry.getValue();\n+\t\t\tString key = entry.getKey();\n+\t\t\tParameterType type = jobParameter.getType();\n+\t\t\tObject value = jobParameter.getValue();\n+\t\t\tboolean identifying = jobParameter.isIdentifying();\n+\t\t\tsetJobParameters(executionId, type, key, value, identifying, ps);\n+\t\t});\n+\t}\n+\t\n \t/**\n \t * Convenience method that inserts an individual records into the\n \t * JobParameters table.\n \t */\n-\tprivate void insertParameter(Long executionId, ParameterType type, String key,\n-\t\t\tObject value, boolean identifying) {\n-\n-\t\tObject[] args = new Object[0];\n-\t\tint[] argTypes = new int[] { Types.BIGINT, Types.VARCHAR,\n-\t\t\t\tTypes.VARCHAR, Types.VARCHAR, Types.TIMESTAMP, Types.BIGINT,\n-\t\t\t\tTypes.DOUBLE, Types.CHAR };\n-\n-\t\tString identifyingFlag = identifying? \"Y\":\"N\";\n-\n+\tprivate static void setJobParameters(Long executionId, ParameterType type, String key,\n+\t\t\t\t\tObject value, boolean identifying, PreparedStatement preparedStatement)\n+\t\t\t\t\t\t\t\t\tthrows SQLException {\n+\t\t\n+\t\tpreparedStatement.setLong(1, executionId);\n+\t\tpreparedStatement.setString(2, key);\n+\t\tpreparedStatement.setString(3, type.toString());\n \t\tif (type == ParameterType.STRING) {\n-\t\t\targs = new Object[] { executionId, key, type, value, new Timestamp(0L),\n-\t\t\t\t\t0L, 0D, identifyingFlag};\n-\t\t} else if (type == ParameterType.LONG) {\n-\t\t\targs = new Object[] { executionId, key, type, \"\", new Timestamp(0L),\n-\t\t\t\t\tvalue, new Double(0), identifyingFlag};\n-\t\t} else if (type == ParameterType.DOUBLE) {\n-\t\t\targs = new Object[] { executionId, key, type, \"\", new Timestamp(0L), 0L,\n-\t\t\t\t\tvalue, identifyingFlag};\n-\t\t} else if (type == ParameterType.DATE) {\n-\t\t\targs = new Object[] { executionId, key, type, \"\", value, 0L, 0D, identifyingFlag};\n+\t\t\tpreparedStatement.setString(4, (String) value);\n+\t\t} else {\n+\t\t\tpreparedStatement.setString(4, \"\");\n \t\t}\n-\n-\t\tgetJdbcTemplate().update(getQuery(CREATE_JOB_PARAMETERS), args, argTypes);\n+\t\tif (type == ParameterType.DATE) {\n+\t\t\tpreparedStatement.setTimestamp(5, new Timestamp(((Date) value).getTime()));\n+\t\t} else {\n+\t\t\tpreparedStatement.setTimestamp(5, new Timestamp(0L));\n+\t\t}\n+\t\tif (type == ParameterType.LONG) {\n+\t\t\tpreparedStatement.setLong(6, (Long) value);\n+\t\t} else {\n+\t\t\tpreparedStatement.setLong(6, 0L);\n+\t\t}\n+\t\tif (type == ParameterType.DOUBLE) {\n+\t\t\tpreparedStatement.setDouble(7, (Double) value);\n+\t\t} else {\n+\t\t\tpreparedStatement.setDouble(7, 0.0d);\n+\t\t}\n+\t\tString identifyingFlag = identifying ? \"Y\" : \"N\";\n+\t\tpreparedStatement.setString(8, identifyingFlag);\n \t}\n \n \t/**"
  }
]
