[
  {
    "sha": "7b01db894711b1a53af78e3230109b6ec549f2f4",
    "filename": "AutonomousTest.java",
    "status": "added",
    "additions": 147,
    "deletions": 0,
    "changes": 147,
    "blob_url": "https://github.com/FTC7729/2020-FTC-UltimateGoal/blob/bd9469d7ba9a454a9c895468de88cacae7f05612/AutonomousTest.java",
    "raw_url": "https://github.com/FTC7729/2020-FTC-UltimateGoal/raw/bd9469d7ba9a454a9c895468de88cacae7f05612/AutonomousTest.java",
    "contents_url": "https://api.github.com/repos/FTC7729/2020-FTC-UltimateGoal/contents/AutonomousTest.java?ref=bd9469d7ba9a454a9c895468de88cacae7f05612",
    "patch": "@@ -0,0 +1,147 @@\n+package org.firstinspires.ftc.teamcode;\n+//THIS IS FOR THE BLUE SIDE\n+import com.qualcomm.hardware.bosch.BNO055IMU;\n+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n+import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n+import com.qualcomm.robotcore.hardware.ColorSensor;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.CRServo;\n+import com.qualcomm.robotcore.hardware.Servo;\n+import com.qualcomm.hardware.modernrobotics.ModernRoboticsI2cRangeSensor;\n+import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\n+import com.qualcomm.robotcore.hardware.DigitalChannel;\n+import java.util.ArrayList;\n+import com.qualcomm.hardware.bosch.JustLoggingAccelerationIntegrator;\n+import com.qualcomm.robotcore.hardware.DistanceSensor;\n+\n+import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\n+\n+/*\n+Parallel Lions 9681 Autonomous Blue Code\n+author: 9681 Software\n+GOALS: Place the wobble goal in the zone and put rings in lowest goal\n+DESCRIPTION: This code is used for our autonomous when we are located on the blue side\n+ */\n+@Autonomous(name=\"AutoTest\", group=\"Iterative Opmode\")\n+public class AutonomousTest extends OpMode\n+{\n+\n+\n+    /*\n+    ---MOTORS---\n+     */\n+    DcMotor leftFront;\n+    DcMotor rightFront;\n+    DcMotor leftBack;\n+    DcMotor rightBack; //make sure these are the right motors\n+    DcMotor extendArm;\n+    CRServo claw1, claw2;\n+    DcMotor raiseArm2;\n+    DcMotor raiseArmMotor;\n+\n+\n+    ArrayList<DcMotor> motors = new ArrayList<DcMotor>();\n+    ArrayList<CRServo> servos = new ArrayList<CRServo>();\n+\n+    private StateMachine machine;\n+\n+    driveState strafeLeft;\n+    driveState forward1;\n+    driveState turnLeft;\n+    extendArmState raiseArm1;\n+    extendArmState extendFirst;\n+\n+    CRServoState open1;\n+    driveState moveBackwards1;\n+\n+\n+\n+    public void init() {\n+\n+        /*\n+        ---HARDWARE MAP---\n+         */\n+        rightFront=hardwareMap.dcMotor.get(\"right front\");\n+        leftFront = hardwareMap.dcMotor.get(\"left front\");\n+        rightBack = hardwareMap.dcMotor.get(\"right back\");\n+        leftBack = hardwareMap.dcMotor.get(\"left back\");\n+        raiseArmMotor = hardwareMap.dcMotor.get(\"raise arm\");\n+        extendArm = hardwareMap.dcMotor.get(\"extend arm\");\n+\n+        claw1 = hardwareMap.crservo.get(\"claw 1\");\n+        claw2 = hardwareMap.crservo.get(\"claw 2\");\n+        //get the CRSERVO\n+\n+\n+        /*\n+        ---MOTOR DIRECTIONS---\n+         */\n+        rightBack.setDirection(DcMotor.Direction.REVERSE);\n+        rightFront.setDirection(DcMotor.Direction.REVERSE);\n+//could be wrong!!!! test\n+        /*\n+        ---GROUPING---\n+         */\n+        motors.add(rightFront);\n+        motors.add(leftFront);\n+        motors.add(rightBack);\n+        motors.add(leftBack);\n+        // CRServos.add(claw1);\n+        // CRServos.add(claw2);\n+        //extend, CRServos\n+        //maybe add an extra time?????? it was in colorstone\n+        /*\n+        ---USING STATES---\n+         */\n+\n+        strafeLeft = new driveState(70, 1.0, motors, \"left\"); //first move left\n+        //drive forward a little, then turn left 90 degrees, raise and extend arm. dispose rings, move backwards\n+        forward1 = new driveState(20, 1.0, motors, \"forward\");\n+        turnLeft = new driveState(10, 1.0, motors, \"turnLeft\");\n+        raiseArm1 = new extendArmState(500, -0.5, raiseArmMotor); //figure this out\n+        extendFirst = new extendArmState(400, 1.0, extendArm);\n+        open1 = new CRServoState(2000, 1.0, 1.0, servos);//ask abby if there are two servos\n+        moveBackwards1 = new driveState(5, 1.0, motors, \"backward\");\n+        //open the claws\n+        //back up\n+\n+\n+\n+        strafeLeft.setNextState(forward1);\n+        forward1.setNextState(turnLeft);\n+        turnLeft.setNextState(raiseArm1);\n+        raiseArm1.setNextState(extendFirst);\n+        extendFirst.setNextState(open1);\n+        open1.setNextState(moveBackwards1);\n+        moveBackwards1.setNextState(null);\n+\n+\n+\n+\n+\n+    }\n+\n+\n+    @Override\n+    public void start(){\n+\n+        machine = new StateMachine(strafeLeft);\n+\n+    }\n+\n+\n+\n+    public void loop()  {\n+\n+        machine.update();\n+\n+    }\n+\n+    public void wait(int time) {\n+        try {\n+            Thread.sleep(time * 1000);//milliseconds\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}"
  },
  {
    "sha": "7d9ba09cca367821d0d3677fef36fe3d12d2fed3",
    "filename": "TeleOpCurrent.java",
    "status": "added",
    "additions": 263,
    "deletions": 0,
    "changes": 263,
    "blob_url": "https://github.com/FTC7729/2020-FTC-UltimateGoal/blob/bd9469d7ba9a454a9c895468de88cacae7f05612/TeleOpCurrent.java",
    "raw_url": "https://github.com/FTC7729/2020-FTC-UltimateGoal/raw/bd9469d7ba9a454a9c895468de88cacae7f05612/TeleOpCurrent.java",
    "contents_url": "https://api.github.com/repos/FTC7729/2020-FTC-UltimateGoal/contents/TeleOpCurrent.java?ref=bd9469d7ba9a454a9c895468de88cacae7f05612",
    "patch": "@@ -0,0 +1,263 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+        import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n+        import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+        import com.qualcomm.robotcore.hardware.CRServo;\n+        import com.qualcomm.robotcore.hardware.DcMotor;\n+        import com.qualcomm.robotcore.hardware.DcMotorSimple;\n+        import com.qualcomm.robotcore.util.Range;\n+\n+        import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n+        import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+        import com.qualcomm.robotcore.hardware.CRServo;\n+        import com.qualcomm.robotcore.hardware.DcMotor;\n+        import com.qualcomm.robotcore.hardware.DcMotorSimple;\n+        import com.qualcomm.robotcore.hardware.DigitalChannel;\n+        import com.qualcomm.robotcore.util.ElapsedTime;\n+        import com.qualcomm.robotcore.util.Range;\n+        import com.qualcomm.robotcore.hardware.Servo;\n+\n+@TeleOp(name =\"TeleOpCurrent\", group = \"TeleOP\")\n+public class TeleOpCurrent extends OpMode {\n+    DcMotor frontRight;\n+    DcMotor frontLeft;\n+    DcMotor backRight;\n+    DcMotor backLeft;\n+    DcMotor raiseArm1;\n+    DcMotor raiseArm2;\n+    DcMotor extendArm;\n+    CRServo claw1;\n+    CRServo claw2;\n+    CRServo wrist;\n+    boolean powerControl = false;\n+    double powerGiven =0;\n+    boolean clamp = false;\n+    int powerButton;\n+    CRServo drag1, drag2;\n+\n+    double armPowerMultiplier = 0.5;\n+\n+\n+    public void init() {\n+        //hardware map is for phone\n+\n+        //    touchSense = hardwareMap.get(DigitalChannel.class, \"sensor_digital\");\n+        frontRight = hardwareMap.dcMotor.get(\"front right\");\n+        frontLeft = hardwareMap.dcMotor.get(\"front left\");\n+        backRight = hardwareMap.dcMotor.get(\"back right\");\n+        backLeft = hardwareMap.dcMotor.get(\"back left\");\n+     //   raiseArm1 = hardwareMap.dcMotor.get(\"raise arm 1\");\n+       // raiseArm2 = hardwareMap.dcMotor.get(\"raise arm 2\");\n+       // extendArm = hardwareMap.dcMotor.get(\"extend arm\");\n+        // claw1 = hardwareMap.crservo.get(\"claw 1\");\n+        //claw2 = hardwareMap.crservo.get(\"claw 2\");\n+       // drag1 = hardwareMap.crservo.get(\"drag front\");\n+     //   drag2 = hardwareMap.crservo.get(\"drag back\");\n+     //   wrist = hardwareMap.crservo.get(\"wrist\");\n+    }\n+\n+    private void setRaiseArmPower(float armPower, double multiplier){\n+        raiseArm1.setPower(armPower*multiplier);\n+        raiseArm2.setPower(armPower*multiplier);\n+        return;\n+    }\n+\n+    public void loop() {\n+        //              -----STICK VARIABLES-----\n+        //For driving\n+        float move = -gamepad1.left_stick_y;\n+        float crabWalk = gamepad1.left_stick_x;\n+        float rotation = -gamepad1.right_stick_x;\n+\n+        //For arm raising\n+        float rawRaiseValue = -gamepad2.left_stick_y;\n+\n+\n+\n+\n+        //              -----WHEEL LOGIC-----\n+        //Wheels: Holonomic drive formula uses values of gamestick position to move\n+        double fLeftPower = Range.clip(move + rotation + crabWalk, -1.0, 1.0);\n+        double bLeftPower = Range.clip(move + rotation - crabWalk, -1.0, 1.0);\n+        double fRightPower = Range.clip(move - rotation - crabWalk, -1.0, 1.0);\n+        double bRightPower = Range.clip(move - rotation + crabWalk, -1.0, 1.0);\n+        //Assignment of motor power in relation to wheels\n+        frontLeft.setPower(fLeftPower/powerButton);\n+        frontLeft.setDirection(DcMotorSimple.Direction.REVERSE);\n+\n+        backLeft.setPower(bLeftPower/powerButton);\n+        backLeft.setDirection(DcMotorSimple.Direction.REVERSE);\n+\n+        frontRight.setPower(fRightPower/powerButton);\n+\n+        backRight.setPower(bRightPower/powerButton);\n+\n+        //raiseArm1.setDirection(DcMotorSimple.Direction.FORWARD);\n+        //raiseArm2.setDirection(DcMotorSimple.Direction.REVERSE);\n+\n+\n+\n+        //          -----GAME PAD 1-----\n+\n+        //              ###SPEED BOOST###\n+        if(gamepad1.right_trigger>0.1){\n+            powerButton=1;\n+        }else{\n+            powerButton =2;\n+        }\n+\n+        //              ###DRAG SERVOS###\n+      /* if(gamepad1.a){\n+            drag1.setPower(.5);\n+            drag2.setPower(-.5);\n+        } */\n+       /* else if(gamepad1.b){\n+            drag1.setPower(-.5);\n+            drag2.setPower(.5);\n+        } */\n+       /* else{\n+            drag1.setPower(0);\n+            drag2.setPower(0);\n+        } */\n+\n+        /* if(gamepad1.x){\n+            drag2.setPower(.5);\n+        }\n+        else if(gamepad1.y){\n+            drag2.setPower(-.5);\n+        }\n+        else{\n+            drag2.setPower(0);\n+        }*/\n+\n+\n+\n+\n+        //          -----GAME PAD 2-----\n+\n+        //              ###CLAMPS###\n+       /* if (gamepad2.x){\n+            clamp = true;\n+        } */\n+      /*  if (gamepad2.y){\n+            claw1.setPower(1);\n+            claw2.setPower(-1);\n+            clamp = false;\n+        } */\n+       /* else if (!clamp){\n+            claw1.setPower(0);\n+            claw2.setPower(0);\n+        } */\n+       /* if (clamp){\n+            claw1.setPower(-1);\n+            claw2.setPower(1);\n+        } */\n+\n+\n+\n+        //claw1: 1=open, 0=closed\n+        //claw2: 0=open, 1=closed\n+\n+        //open\n+     /*   if (gamepad2.y){\n+            claw1.setPosition(0.6);\n+            claw2.setPosition(0.4);\n+        }\n+        //close\n+       else if (gamepad2.x){\n+            claw1.setPosition(0.4);\n+            claw2.setPosition(0.6);\n+        } */\n+\n+\n+\n+        //              ###ARM EXTENSION###\n+\n+      //  extendArm.setPower(-gamepad2.right_stick_y);\n+\n+        //              ###WRIST###\n+\n+     /*   if (gamepad2.right_bumper){\n+            wrist.setPower(0.5);\n+        } */\n+     /*   else if (gamepad2.left_bumper){\n+            wrist.setPower(-0.5);\n+        } */\n+      /*  else {\n+            wrist.setPower(0);\n+        } */\n+\n+\n+        //              ###ARM RAISING###\n+\n+        // Fast raise arm mode\n+       /* if (gamepad2.right_trigger>0){\n+            //If the driver is trying to move the arm up:\n+            if (rawRaiseValue > 0) {\n+                setRaiseArmPower(rawRaiseValue, 0.6);\n+            }\n+            //If the driver is trying to move the arm down:\n+            else if (rawRaiseValue < 0) {\n+                setRaiseArmPower(0.1f, 0.35);\n+            }\n+            //If the driver is not moving the arm\n+            else {\n+                setRaiseArmPower(0.23f, 1);\n+            }\n+        }*/\n+        // Slow raise arm mode\n+       /* else {\n+            //If the driver is trying to move the arm up:\n+            if (rawRaiseValue > 0) {\n+                setRaiseArmPower(rawRaiseValue, 0.35);\n+            }\n+            //If the driver is trying to move the arm down:\n+            else if (rawRaiseValue < 0) {\n+                setRaiseArmPower(0f, 1);\n+            }\n+            //If the driver is not moving the arm\n+            else {\n+                setRaiseArmPower(0.23f, 1);\n+            }\n+        }*/\n+        /*\n+        // Fast raise arm mode\n+        if (gamepad2.right_trigger>0){\n+            //If the driver is trying to move the arm up:\n+            if (rawRaiseValue > 0) {\n+                setRaiseArmPower(rawRaiseValue, 0.6);\n+            }\n+            //If the driver is trying to move the arm down:\n+            else if (rawRaiseValue < 0) {\n+                setRaiseArmPower(0.1f, 0.35);\n+            }\n+            //If the driver is not moving the arm\n+            /*else {\n+                setRaiseArmPower(0.23f, 1);\n+            }\n+        }\n+        // Slow raise arm mode\n+     /*   else {\n+            //If the driver is trying to move the arm up:\n+            if (rawRaiseValue > 0) {\n+                setRaiseArmPower(rawRaiseValue, 0.35);\n+            }\n+            //If the driver is trying to move the arm down:\n+            else if (rawRaiseValue < 0) {\n+                setRaiseArmPower(0f, 1);\n+            }\n+            //If the driver is not moving the arm\n+           /* else {\n+                setRaiseArmPower(0.23f, 1);\n+            }\n+        }*/\n+\n+\n+\n+\n+    }\n+\n+\n+\n+\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "6eae58ce2d1c0186049951420e8f3a526a9f9813",
    "filename": "TeleOpCurrentNew.java",
    "status": "added",
    "additions": 265,
    "deletions": 0,
    "changes": 265,
    "blob_url": "https://github.com/FTC7729/2020-FTC-UltimateGoal/blob/bd9469d7ba9a454a9c895468de88cacae7f05612/TeleOpCurrentNew.java",
    "raw_url": "https://github.com/FTC7729/2020-FTC-UltimateGoal/raw/bd9469d7ba9a454a9c895468de88cacae7f05612/TeleOpCurrentNew.java",
    "contents_url": "https://api.github.com/repos/FTC7729/2020-FTC-UltimateGoal/contents/TeleOpCurrentNew.java?ref=bd9469d7ba9a454a9c895468de88cacae7f05612",
    "patch": "@@ -0,0 +1,265 @@\n+// THIS IS THE NEW CODE CLAIRE MADE ON SUNDAY 3/7/21 THAT INCLUDES THE TWO MOTORS FOR THE ARM AND THE 3 SERVOS FOR THE WRIST\n+\n+package org.firstinspires.ftc.teamcode;\n+\n+        import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n+        import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+        import com.qualcomm.robotcore.hardware.CRServo;\n+        import com.qualcomm.robotcore.hardware.DcMotor;\n+        import com.qualcomm.robotcore.hardware.DcMotorSimple;\n+        import com.qualcomm.robotcore.util.Range;\n+\n+        import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n+        import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+        import com.qualcomm.robotcore.hardware.CRServo;\n+        import com.qualcomm.robotcore.hardware.DcMotor;\n+        import com.qualcomm.robotcore.hardware.DcMotorSimple;\n+        import com.qualcomm.robotcore.hardware.DigitalChannel;\n+        import com.qualcomm.robotcore.util.ElapsedTime;\n+        import com.qualcomm.robotcore.util.Range;\n+        import com.qualcomm.robotcore.hardware.Servo;\n+\n+@TeleOp(name =\"TeleOpCurrentNew\", group = \"TeleOP\")\n+public class TeleOpCurrentNew extends OpMode {\n+    DcMotor frontRight;\n+    DcMotor frontLeft;\n+    DcMotor backRight;\n+    DcMotor backLeft;\n+    DcMotor raiseArm1;\n+    DcMotor raiseArm2;\n+    DcMotor extendArm;\n+    CRServo claw1;\n+    CRServo claw2;\n+    CRServo wrist;\n+    boolean powerControl = false;\n+    double powerGiven =0;\n+    boolean clamp = false;\n+    int powerButton;\n+    CRServo drag1, drag2;\n+\n+    double armPowerMultiplier = 0.5;\n+\n+\n+    public void init() {\n+        //hardware map is for phone\n+\n+        //    touchSense = hardwareMap.get(DigitalChannel.class, \"sensor_digital\");\n+        frontRight = hardwareMap.dcMotor.get(\"front right\");\n+        frontLeft = hardwareMap.dcMotor.get(\"front left\");\n+        backRight = hardwareMap.dcMotor.get(\"back right\");\n+        backLeft = hardwareMap.dcMotor.get(\"back left\");\n+       raiseArm1 = hardwareMap.dcMotor.get(\"raise arm 1\");\n+        raiseArm2 = hardwareMap.dcMotor.get(\"raise arm 2\");\n+        extendArm = hardwareMap.dcMotor.get(\"extend arm\");\n+        claw1 = hardwareMap.crservo.get(\"claw 1\");\n+        claw2 = hardwareMap.crservo.get(\"claw 2\");\n+       // drag1 = hardwareMap.crservo.get(\"drag front\");\n+     //   drag2 = hardwareMap.crservo.get(\"drag back\");\n+        wrist = hardwareMap.crservo.get(\"wrist\");\n+    }\n+\n+    private void setRaiseArmPower(float armPower, double multiplier){\n+        raiseArm1.setPower(armPower*multiplier);\n+        raiseArm2.setPower(armPower*multiplier);\n+        return;\n+    }\n+\n+    public void loop() {\n+        //              -----STICK VARIABLES-----\n+        //For driving\n+        float move = -gamepad1.left_stick_y;\n+        float crabWalk = gamepad1.left_stick_x;\n+        float rotation = -gamepad1.right_stick_x;\n+\n+        //For arm raising\n+        float rawRaiseValue = -gamepad2.left_stick_y;\n+\n+\n+\n+\n+        //              -----WHEEL LOGIC-----\n+        //Wheels: Holonomic drive formula uses values of gamestick position to move\n+        double fLeftPower = Range.clip(move + rotation + crabWalk, -1.0, 1.0);\n+        double bLeftPower = Range.clip(move + rotation - crabWalk, -1.0, 1.0);\n+        double fRightPower = Range.clip(move - rotation - crabWalk, -1.0, 1.0);\n+        double bRightPower = Range.clip(move - rotation + crabWalk, -1.0, 1.0);\n+        //Assignment of motor power in relation to wheels\n+        frontLeft.setPower(fLeftPower/powerButton);\n+        frontLeft.setDirection(DcMotorSimple.Direction.REVERSE);\n+\n+        backLeft.setPower(bLeftPower/powerButton);\n+        backLeft.setDirection(DcMotorSimple.Direction.REVERSE);\n+\n+        frontRight.setPower(fRightPower/powerButton);\n+\n+        backRight.setPower(bRightPower/powerButton);\n+\n+        raiseArm1.setDirection(DcMotorSimple.Direction.FORWARD);\n+        raiseArm2.setDirection(DcMotorSimple.Direction.REVERSE);\n+\n+\n+\n+        //          -----GAME PAD 1-----\n+\n+        //              ###SPEED BOOST###\n+        if(gamepad1.right_trigger>0.1){\n+            powerButton=1;\n+        }else{\n+            powerButton =2;\n+        }\n+\n+        //              ###DRAG SERVOS###\n+      /* if(gamepad1.a){\n+            drag1.setPower(.5);\n+            drag2.setPower(-.5);\n+        } */\n+       /* else if(gamepad1.b){\n+            drag1.setPower(-.5);\n+            drag2.setPower(.5);\n+        } */\n+       /* else{\n+            drag1.setPower(0);\n+            drag2.setPower(0);\n+        } */\n+\n+        /* if(gamepad1.x){\n+            drag2.setPower(.5);\n+        }\n+        else if(gamepad1.y){\n+            drag2.setPower(-.5);\n+        }\n+        else{\n+            drag2.setPower(0);\n+        }*/\n+\n+\n+\n+\n+        //          -----GAME PAD 2-----\n+\n+        //              ###CLAMPS###\n+        if (gamepad2.x){\n+            clamp = true;\n+        } \n+        if (gamepad2.y){\n+            claw1.setPower(1);\n+            claw2.setPower(-1);\n+            clamp = false;\n+        } \n+        else if (!clamp){\n+            claw1.setPower(0);\n+            claw2.setPower(0);\n+        } \n+        if (clamp){\n+            claw1.setPower(-1);\n+            claw2.setPower(1);\n+        } \n+\n+\n+\n+        //claw1: 1=open, 0=closed\n+        //claw2: 0=open, 1=closed\n+\n+        //open\n+        if (gamepad2.y){\n+            claw1.setPosition(0.6);\n+            claw2.setPosition(0.4);\n+        }\n+        //close\n+       else if (gamepad2.x){\n+            claw1.setPosition(0.4);\n+            claw2.setPosition(0.6);\n+        } \n+\n+\n+\n+        //              ###ARM EXTENSION###\n+\n+       extendArm.setPower(-gamepad2.right_stick_y);\n+\n+        //              ###WRIST###\n+\n+       if (gamepad2.right_bumper){\n+            wrist.setPower(0.5);\n+        } \n+        else if (gamepad2.left_bumper){\n+            wrist.setPower(-0.5);\n+        } \n+       else {\n+            wrist.setPower(0);\n+        } \n+\n+\n+        //              ###ARM RAISING###\n+\n+        // Fast raise arm mode\n+        if (gamepad2.right_trigger>0){\n+            //If the driver is trying to move the arm up:\n+            if (rawRaiseValue > 0) {\n+                setRaiseArmPower(rawRaiseValue, 0.6);\n+            }\n+            //If the driver is trying to move the arm down:\n+            else if (rawRaiseValue < 0) {\n+                setRaiseArmPower(0.1f, 0.35);\n+            }\n+            //If the driver is not moving the arm\n+            else {\n+                setRaiseArmPower(0.23f, 1);\n+            }\n+        }\n+        // Slow raise arm mode\n+        else {\n+            //If the driver is trying to move the arm up:\n+            if (rawRaiseValue > 0) {\n+                setRaiseArmPower(rawRaiseValue, 0.35);\n+            }\n+            //If the driver is trying to move the arm down:\n+            else if (rawRaiseValue < 0) {\n+                setRaiseArmPower(0f, 1);\n+            }\n+            //If the driver is not moving the arm\n+            else {\n+                setRaiseArmPower(0.23f, 1);\n+            }\n+        }\n+        \n+        // Fast raise arm mode\n+        if (gamepad2.right_trigger>0){\n+            //If the driver is trying to move the arm up:\n+            if (rawRaiseValue > 0) {\n+                setRaiseArmPower(rawRaiseValue, 0.6);\n+            }\n+            //If the driver is trying to move the arm down:\n+            else if (rawRaiseValue < 0) {\n+                setRaiseArmPower(0.1f, 0.35);\n+            }\n+            //If the driver is not moving the arm\n+             {\n+                setRaiseArmPower(0.23f, 1);\n+            }\n+        }\n+        // Slow raise arm mode\n+        else {\n+            //If the driver is trying to move the arm up:\n+            if (rawRaiseValue > 0) {\n+                setRaiseArmPower(rawRaiseValue, 0.35);\n+            }\n+            //If the driver is trying to move the arm down:\n+            else if (rawRaiseValue < 0) {\n+                setRaiseArmPower(0f, 1);\n+            }\n+            //If the driver is not moving the arm\n+            else {\n+                setRaiseArmPower(0.23f, 1);\n+            }\n+        }\n+\n+\n+\n+\n+    }\n+\n+\n+\n+\n+}"
  },
  {
    "sha": "5cf36c17e3c7c2ddff78ff0afac707ab265f7fce",
    "filename": "TeleOpCurrentNew2.java",
    "status": "added",
    "additions": 252,
    "deletions": 0,
    "changes": 252,
    "blob_url": "https://github.com/FTC7729/2020-FTC-UltimateGoal/blob/bd9469d7ba9a454a9c895468de88cacae7f05612/TeleOpCurrentNew2.java",
    "raw_url": "https://github.com/FTC7729/2020-FTC-UltimateGoal/raw/bd9469d7ba9a454a9c895468de88cacae7f05612/TeleOpCurrentNew2.java",
    "contents_url": "https://api.github.com/repos/FTC7729/2020-FTC-UltimateGoal/contents/TeleOpCurrentNew2.java?ref=bd9469d7ba9a454a9c895468de88cacae7f05612",
    "patch": "@@ -0,0 +1,252 @@\n+// THIS IS THE NEW CODE CLAIRE MADE ON SUNDAY 3/7/21 THAT INCLUDES THE TWO MOTORS FOR THE ARM AND THE 3 SERVOS FOR THE WRIST\n+\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+import com.qualcomm.robotcore.hardware.CRServo;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.DcMotorSimple;\n+import com.qualcomm.robotcore.util.Range;\n+\n+import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+import com.qualcomm.robotcore.hardware.CRServo;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.DcMotorSimple;\n+import com.qualcomm.robotcore.hardware.DigitalChannel;\n+import com.qualcomm.robotcore.util.ElapsedTime;\n+import com.qualcomm.robotcore.util.Range;\n+import com.qualcomm.robotcore.hardware.Servo;\n+\n+@TeleOp(name =\"TeleOpCurrentNew\", group = \"TeleOP\")\n+public class TeleOpCurrentNew extends OpMode {\n+    DcMotor frontRight;\n+    DcMotor frontLeft;\n+    DcMotor backRight;\n+    DcMotor backLeft;\n+    DcMotor raiseArm1;\n+    DcMotor raiseArm2;\n+    DcMotor extendArm;\n+    CRServo claw1;\n+    CRServo claw2;\n+    CRServo wrist;\n+    boolean powerControl = false;\n+    double powerGiven =0;\n+    boolean clamp = false;\n+    int powerButton;\n+    CRServo drag1, drag2;\n+\n+    double armPowerMultiplier = 0.5;\n+\n+\n+    public void init() {\n+        //hardware map is for phone\n+\n+        //    touchSense = hardwareMap.get(DigitalChannel.class, \"sensor_digital\");\n+        frontRight = hardwareMap.dcMotor.get(\"front right\");\n+        frontLeft = hardwareMap.dcMotor.get(\"front left\");\n+        backRight = hardwareMap.dcMotor.get(\"back right\");\n+        backLeft = hardwareMap.dcMotor.get(\"back left\");\n+        raiseArm1 = hardwareMap.dcMotor.get(\"raise arm\");\n+        //raiseArm2 = hardwareMap.dcMotor.get(\"raise arm 2\");\n+        extendArm = hardwareMap.dcMotor.get(\"extend arm\");\n+        claw1 = hardwareMap.crservo.get(\"claw 1\");\n+        claw2 = hardwareMap.crservo.get(\"claw 2\");\n+        // drag1 = hardwareMap.crservo.get(\"drag front\");\n+        //   drag2 = hardwareMap.crservo.get(\"drag back\");\n+        wrist = hardwareMap.crservo.get(\"wrist\");\n+    }\n+\n+    private void setRaiseArmPower(double armPower, double multiplier){\n+        raiseArm1.setPower(armPower*multiplier);\n+      //  raiseArm2.setPower(armPower*multiplier);\n+        return;\n+    }\n+\n+    public void loop() {\n+        //              -----STICK VARIABLES-----\n+        //For driving\n+        float move = -gamepad1.left_stick_y;\n+        float crabWalk = gamepad1.left_stick_x;\n+        float rotation = -gamepad1.right_stick_x;\n+\n+        //For arm raising\n+        float rawRaiseValue = -gamepad2.left_stick_y;\n+\n+\n+\n+\n+        //              -----WHEEL LOGIC-----\n+        //Wheels: Holonomic drive formula uses values of gamestick position to move\n+        double fLeftPower = Range.clip(move + rotation + crabWalk, -1.0, 1.0);\n+        double bLeftPower = Range.clip(move + rotation - crabWalk, -1.0, 1.0);\n+        double fRightPower = Range.clip(move - rotation - crabWalk, -1.0, 1.0);\n+        double bRightPower = Range.clip(move - rotation + crabWalk, -1.0, 1.0);\n+        //Assignment of motor power in relation to wheels\n+        frontLeft.setPower(fLeftPower/powerButton);\n+        frontLeft.setDirection(DcMotorSimple.Direction.REVERSE);\n+\n+        backLeft.setPower(bLeftPower/powerButton);\n+        backLeft.setDirection(DcMotorSimple.Direction.REVERSE);\n+\n+        frontRight.setPower(fRightPower/powerButton);\n+\n+        backRight.setPower(bRightPower/powerButton);\n+\n+        raiseArm1.setDirection(DcMotorSimple.Direction.FORWARD);\n+     //\n+        //\n+        //\n+        //\n+        //\n+        //   raiseArm2.setDirection(DcMotorSimple.Direction.REVERSE);\n+\n+\n+\n+        //          -----GAME PAD 1-----\n+\n+        //              ###SPEED BOOST###\n+        if(gamepad1.right_trigger>0.1){\n+            powerButton=1;\n+        }else{\n+            powerButton =2;\n+        }\n+\n+        //              ###DRAG SERVOS###\n+      /* if(gamepad1.a){\n+            drag1.setPower(.5);\n+            drag2.setPower(-.5);\n+        } */\n+       /* else if(gamepad1.b){\n+            drag1.setPower(-.5);\n+            drag2.setPower(.5);\n+        } */\n+       /* else{\n+            drag1.setPower(0);\n+            drag2.setPower(0);\n+        } */\n+\n+        /* if(gamepad1.x){\n+            drag2.setPower(.5);\n+        }\n+        else if(gamepad1.y){\n+            drag2.setPower(-.5);\n+        }\n+        else{\n+            drag2.setPower(0);\n+        }*/\n+\n+\n+\n+\n+        //          -----GAME PAD 2-----\n+\n+        //              ###CLAMPS###\n+        if (gamepad2.x){\n+            clamp = true;\n+        }\n+        if (gamepad2.y){\n+            claw1.setPower(1);\n+            claw2.setPower(-1);\n+            clamp = false;\n+        }\n+        else if (!clamp){\n+            claw1.setPower(0);\n+            claw2.setPower(0);\n+        }\n+        if (clamp){\n+            claw1.setPower(-1);\n+            claw2.setPower(1);\n+        }\n+\n+\n+\n+        //claw1: 1=open, 0=closed\n+        //claw2: 0=open, 1=closed\n+\n+        //open\n+        if (gamepad2.y){\n+            claw1.setPower(0.6);\n+            claw2.setPower(0.4);\n+        }\n+        //close\n+        else if (gamepad2.x){\n+            claw1.setPower(0.4);\n+            claw2.setPower(0.6);\n+        }\n+\n+\n+\n+        //              ###ARM EXTENSION###\n+\n+        extendArm.setPower(-gamepad2.right_stick_y);\n+\n+        //              ###WRIST###\n+\n+        if (gamepad2.right_bumper){\n+            wrist.setPower(0.5);\n+        }\n+        else if (gamepad2.left_bumper){\n+            wrist.setPower(-0.5);\n+        }\n+        else {\n+            wrist.setPower(0);\n+        }\n+\n+\n+        //              ###ARM RAISING###\n+\n+        // Fast raise arm mode\n+        if (gamepad2.right_trigger>0){\n+            //If the driver is trying to move the arm up:\n+            setRaiseArmPower(rawRaiseValue, 0.6);\n+        }\n+        // Slow raise arm mode\n+\n+        //setRaiseArmPower(rawRaiseValue, 0.35);\n+        else {\n+            //If the driver is trying to move the arm up:\n+            setRaiseArmPower(rawRaiseValue, 0.35);\n+        }\n+\n+        // Fast raise arm mode\n+        if (gamepad2.right_trigger>0){\n+            //If the driver is trying to move the arm up:\n+            if (rawRaiseValue > 0) {\n+                setRaiseArmPower(rawRaiseValue, 0.6);\n+            }\n+            //If the driver is trying to move the arm down:\n+            else if (rawRaiseValue < 0) {\n+                setRaiseArmPower(0.1, 0.35);\n+            }\n+            //If the driver is not moving the arm\n+            else{\n+                setRaiseArmPower(0.0, 1);\n+            }\n+        }\n+        // Slow raise arm mode\n+        else {\n+            //If the driver is trying to move the arm up:\n+            if (rawRaiseValue > 0) {\n+                setRaiseArmPower(rawRaiseValue, 0.35);\n+            }\n+            //If the driver is trying to move the arm down:\n+            else if (rawRaiseValue < 0) {\n+                setRaiseArmPower(0, 1);\n+            }\n+            //If the driver is not moving the arm\n+            else {\n+                setRaiseArmPower(0.0, 1);\n+            }\n+        }\n+\n+\n+\n+\n+    }\n+\n+\n+\n+\n+}"
  }
]
