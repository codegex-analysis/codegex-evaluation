[
  {
    "sha": "3f795909fc6d60a821026af1893204db4fc60d12",
    "filename": "Baekjun16235.java",
    "status": "added",
    "additions": 147,
    "deletions": 0,
    "changes": 147,
    "blob_url": "https://github.com/ssafy10-5-algo/whynotworking/blob/f3a587b891b6202c436c191b87cf277490eaf9ef/Baekjun16235.java",
    "raw_url": "https://github.com/ssafy10-5-algo/whynotworking/raw/f3a587b891b6202c436c191b87cf277490eaf9ef/Baekjun16235.java",
    "contents_url": "https://api.github.com/repos/ssafy10-5-algo/whynotworking/contents/Baekjun16235.java?ref=f3a587b891b6202c436c191b87cf277490eaf9ef",
    "patch": "@@ -0,0 +1,147 @@\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.util.ArrayDeque;\r\n+import java.util.PriorityQueue;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class Baekjun16235 {\r\n+\tprivate static int[][] A;\r\n+\tprivate static int[][] G;\r\n+\tprivate static PriorityQueue<Tree> trees;\r\n+\tprivate static ArrayDeque<Tree> trees_alive = new ArrayDeque<>();\r\n+\tprivate static ArrayDeque<Tree> trees_dead = new ArrayDeque<>();\r\n+\tprivate static int N;\r\n+\r\n+\tpublic static void main(String[] args) throws Exception {\r\n+\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\tStringTokenizer st = new StringTokenizer(br.readLine());\r\n+\t\tN = Integer.parseInt(st.nextToken()); // 땅 넓이\r\n+\t\tint M = Integer.parseInt(st.nextToken()); // 나무 수\r\n+\t\tint K = Integer.parseInt(st.nextToken()); // 년\r\n+\t\tA = new int[N][N];\r\n+\t\tG = new int[N][N];\r\n+\t\tfor (int i = 0; i < N; i++) {\r\n+\t\t\tst = new StringTokenizer(br.readLine());\r\n+\t\t\tfor (int j = 0; j < N; j++) {\r\n+\t\t\t\tA[i][j]=Integer.parseInt(st.nextToken());\r\n+\t\t\t\tG[i][j]=5;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\ttrees = new PriorityQueue<Tree>(); // 어린 나무부터 양분을 먹기위한 우선순위 큐\r\n+\t\tfor (int i = 0; i < M; i++) {\r\n+\t\t\tst = new StringTokenizer(br.readLine());\r\n+\t\t\tint x = Integer.parseInt(st.nextToken())-1;\r\n+\t\t\tint y = Integer.parseInt(st.nextToken())-1;\r\n+\t\t\tint age = Integer.parseInt(st.nextToken());\r\n+\t\t\ttrees.add(new Tree(x,y,age));\r\n+\t\t}\r\n+\t\t\r\n+\t\t\r\n+\t\tfor (int i = 0; i < K; i++) { // K년이 지난다\r\n+\t\t\tone_year_later();\r\n+\t\t}\r\n+\t\t\r\n+\t\tSystem.out.println(trees.size());\r\n+\t}\r\n+\r\n+\tprivate static void one_year_later() { // 사계절이 지난다\r\n+\t\tSpring();\r\n+\t\tSummer();\r\n+\t\tFall();\r\n+\t\tWinter();\r\n+\t}\r\n+\r\n+\tprivate static void Spring() {\r\n+\t\twhile(!trees.isEmpty()) { // 모든 나무들이 (어린 나무부터)\r\n+\t\t\tTree tree = trees.poll();\r\n+\t\t\tif (G[tree.getX()][tree.getY()]<tree.getAge()) { // 양분이 부족하면 죽고\r\n+\t\t\t\ttrees_dead.add(tree);\r\n+\t\t\t}else { // 양분이 충분하면 양분을 소모하고 살아남아 한살을 먹는다\r\n+\t\t\t\tG[tree.getX()][tree.getY()] -= tree.getAge();\r\n+\t\t\t\ttree.setAge(tree.getAge()+1);\r\n+\t\t\t\ttrees_alive.add(tree);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tprivate static void Summer() {\r\n+\t\twhile(!trees_dead.isEmpty()) { // 죽은 나무는 양분이 된다\r\n+\t\t\tTree tree = trees_dead.poll();\r\n+\t\t\tG[tree.getX()][tree.getY()] += tree.getAge()/2;\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tprivate static void Fall() {\r\n+\t\twhile(!trees_alive.isEmpty()) {\r\n+\t\t\tTree tree = trees_alive.poll();\r\n+\t\t\tif (tree.getAge()%5==0) { // 나이가 5의 배수인 나무는 번식을 한다\r\n+\t\t\t\tint x = tree.getX();\r\n+\t\t\t\tint y = tree.getY();\r\n+\t\t\t\tfor (int i = -1; i <= 1; i++) {\r\n+\t\t\t\t\tfor (int j = -1; j <= 1; j++) {\r\n+\t\t\t\t\t\tif (i==0 && j==0) {\r\n+\t\t\t\t\t\t\tcontinue;\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tif (x+i>=0 && x+i<N && y+j>=0 && y+j<N) {\r\n+\t\t\t\t\t\t\tTree newtree = new Tree(x+i,y+j,1);\r\n+\t\t\t\t\t\t\ttrees.add(newtree);\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\ttrees.add(tree);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tprivate static void Winter() {\r\n+\t\tfor (int i = 0; i < N; i++) { // 양분을 공급한다\r\n+\t\t\tfor (int j = 0; j < N; j++) {\r\n+\t\t\t\tG[i][j] += A[i][j];\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+}\r\n+\r\n+class Tree implements Comparable<Tree>{ // 나무 객체, 우선순위 큐를 위한 comparable은 나이로 비교한다\r\n+\tprivate int x;\r\n+\tprivate int y;\r\n+\tprivate int age;\r\n+\t\r\n+\tpublic int getX() {\r\n+\t\treturn x;\r\n+\t}\r\n+\tpublic void setX(int x) {\r\n+\t\tthis.x = x;\r\n+\t}\r\n+\tpublic int getY() {\r\n+\t\treturn y;\r\n+\t}\r\n+\tpublic void setY(int y) {\r\n+\t\tthis.y = y;\r\n+\t}\r\n+\tpublic int getAge() {\r\n+\t\treturn age;\r\n+\t}\r\n+\tpublic void setAge(int age) {\r\n+\t\tthis.age = age;\r\n+\t}\r\n+\r\n+\tpublic Tree(int x, int y, int age) {\r\n+\t\tsuper();\r\n+\t\tthis.x = x;\r\n+\t\tthis.y = y;\r\n+\t\tthis.age = age;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic int compareTo(Tree tree) {\r\n+\t\tif (this.age > tree.age) {\r\n+\t\t\treturn 1;\r\n+\t\t} else if (this.age < tree.age) {\r\n+\t\t\treturn -1;\r\n+\t\t}\r\n+\t\treturn 0;\r\n+\t}\r\n+\t\r\n+\t\r\n+}\n\\ No newline at end of file"
  }
]
