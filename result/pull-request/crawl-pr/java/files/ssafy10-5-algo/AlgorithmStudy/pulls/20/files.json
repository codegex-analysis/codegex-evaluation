[
  {
    "sha": "4e78ff2d2adb9e99d0c2556b67d3441f917cfa82",
    "filename": "BOJ/BOJ_1238.java",
    "status": "added",
    "additions": 104,
    "deletions": 0,
    "changes": 104,
    "blob_url": "https://github.com/ssafy10-5-algo/AlgorithmStudy/blob/745fa437ab734fcc31fda52aff569c443cc5606d/BOJ/BOJ_1238.java",
    "raw_url": "https://github.com/ssafy10-5-algo/AlgorithmStudy/raw/745fa437ab734fcc31fda52aff569c443cc5606d/BOJ/BOJ_1238.java",
    "contents_url": "https://api.github.com/repos/ssafy10-5-algo/AlgorithmStudy/contents/BOJ/BOJ_1238.java?ref=745fa437ab734fcc31fda52aff569c443cc5606d",
    "patch": "@@ -0,0 +1,104 @@\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.StringTokenizer;\n+\n+// 파티\n+public class BOJ_1238 {\n+\tstatic int N, M, X;\n+\tstatic boolean[] visited;\n+\tstatic ArrayList<Node>[] cost;\n+\tstatic int INF = 100 * 10000 + 1;\t\t// N * M 보다 커야함\n+\n+\tpublic static void main(String[] args) throws Exception {\n+\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n+\t\t\n+\t\tN = Integer.parseInt(st.nextToken());\n+\t\tM = Integer.parseInt(st.nextToken());\n+\t\tX = Integer.parseInt(st.nextToken())-1;\n+\t\t\n+\t\tcost = new ArrayList[N];\n+\t\tfor (int i = 0; i < N; i++) {\n+\t\t\tcost[i] = new ArrayList<>();\n+\t\t}\n+\n+\t\tfor (int i = 0; i < M; i++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tint start = Integer.parseInt(st.nextToken())-1;\t\t// 마을은 인덱스로 표현하기 위해 -1 해주고 저장\n+\t\t\tint end = Integer.parseInt(st.nextToken())-1;\n+\t\t\tint time = Integer.parseInt(st.nextToken());\n+\t\t\tcost[start].add(new Node(end, time));\n+\t\t}\n+\t\t\n+\t\tint[] total = new int[N];\t\t\t// 왕복 시간 저장할 배열\n+\t\tfor (int i = 0; i < N; i++) {\t\t// 첫 마을부터 끝 마을까지 파티장 가는 시간 구하기\n+\t\t\tif (i == X) continue;\t\t\t// 파티 개최하는 마을은 구할필요 없음\n+\t\t\tvisited = new boolean[N];\n+\t\t\tdijstra(i);\n+\t\t\ttotal[i] += d[X];\n+\t\t}\n+\t\t\n+\t\tvisited = new boolean[N];\t\t\t// 파티장에서 각 마을로 돌아가는 시간 구하기\n+\t\tdijstra(X);\n+\t\tfor (int i = 0; i < N; i++) {\n+\t\t\ttotal[i] += d[i];\n+\t\t}\n+\t\t\t\n+\t\tint answer = 0;\n+\t\tfor (int i = 0; i < N; i++) {\t\t\t\t// 최대 왕복 시간 갱신\n+\t\t\tanswer = Math.max(answer, total[i]);\n+\t\t}\n+\t\t\n+\t\tSystem.out.println(answer);\n+\t}\n+\n+\tstatic int[] d;\n+\tprivate static void dijstra(int start) {\t\t\t// 다익스트라 알고리즘 이용\n+\t\td = new int[N];\t\t\t\t\t\t// 걸리는 시간 저장해줄 배열\n+\t\tArrays.fill(d, INF);\t\t\t\t// 무한대로 초기화\n+\t\tfor(Node node : cost[start]) {\t\t// 현재 마을에 연결된 모든 마을에 대해서\n+\t\t\td[node.n] = node.time;\t\t\t// 걸리는 시간 저장\n+\t\t}\n+\t\t\n+\t\tfor (int i = 0; i < N; i++) {\t\t// 출발 도착 같은 마을이면 걸리는 시간 0\n+\t\t\tif (i == start) {\n+\t\t\t\td[i] = 0;\n+\t\t\t}\n+\t\t}\n+\t\tint index = start;\t\t\t\t// 소요시간 제일 작은 노드의 인덱스 저정할 변수\n+\t\tvisited[start] = true;\t\t\t// 현재 마을은 방문체크 해주고\n+\t\t\n+\t\tfor (int count = 0; count < N-1; count++) {\t\t\t// 모든 마을 갯수 - 1(현재 마을) 만큼 반복\n+\t\t\tint minV = Integer.MAX_VALUE;\n+\t\t\tfor (int i = 0; i < N; i++) {\t\t\t// 소요시간 제일 작은 노드 찾기\n+\t\t\t\tif (!visited[i] && d[i] < minV) {\t// 방문한적 없고 소요시간 가장 작은 노드\n+\t\t\t\t\tminV = d[i];\n+\t\t\t\t\tindex = i;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\tvisited[index] = true;\t\t\t// 방문 체크\n+\t\t\tfor (int i = 0, size=cost[index].size(); i < size; i++) {\t\t// 해당 마을과 연결된 마을만큼 반복\n+\t\t\t\tNode node = cost[index].get(i);\t\t\t// 연결된 마을 가져오기\n+\t\t\t\tif (!visited[node.n]) {\t\t\t\t\t// 연결된 마을 방문한적 없으면\n+\t\t\t\t\t// 현재마을에서 해당마을까지 가는것 vs 현재마을에서 소요시간 최소인 마을 거쳐서 해당마을까지 가는것 중 작은값 갱신\n+\t\t\t\t\tif (d[index] + node.time < d[node.n]) {\n+\t\t\t\t\t\td[node.n] = d[index] + node.time;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tstatic class Node {\n+\t\tint n, time;\n+\t\t\n+\t\tNode(int n, int time) {\n+\t\t\tthis.n = n;\n+\t\t\tthis.time = time;\n+\t\t}\n+\t}\n+\n+}"
  }
]
