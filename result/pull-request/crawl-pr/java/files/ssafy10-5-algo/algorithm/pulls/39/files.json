[
  {
    "sha": "535cb4c13b97bffb49eede1e11b2f87f55d97770",
    "filename": "BOJ/[BOJ]1238_파티/BOJ1238.java",
    "status": "added",
    "additions": 81,
    "deletions": 0,
    "changes": 81,
    "blob_url": "https://github.com/ssafy10-5-algo/algorithm/blob/15766830e0c735012871742db1688466683f5640/BOJ/%5BBOJ%5D1238_%ED%8C%8C%ED%8B%B0/BOJ1238.java",
    "raw_url": "https://github.com/ssafy10-5-algo/algorithm/raw/15766830e0c735012871742db1688466683f5640/BOJ/%5BBOJ%5D1238_%ED%8C%8C%ED%8B%B0/BOJ1238.java",
    "contents_url": "https://api.github.com/repos/ssafy10-5-algo/algorithm/contents/BOJ/%5BBOJ%5D1238_%ED%8C%8C%ED%8B%B0/BOJ1238.java?ref=15766830e0c735012871742db1688466683f5640",
    "patch": "@@ -0,0 +1,81 @@\n+import java.util.*;\n+import java.io.*;\n+\n+public class BOJ1238 {\n+    static final int INF = Integer.MAX_VALUE;\n+    static int N, M, X;         // 학생 N명, 도로 M개, 파티 마을 X\n+    static List<Conn>[] cities; // 도시의 연결 상태\n+    static int[] ans;           // 각 도시별 X에 왔다 가는 소요 시간\n+\n+    public static void main(String[] args) throws Exception{\n+        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+        StringTokenizer st = new StringTokenizer(br.readLine());\n+        N = Integer.parseInt(st.nextToken());\n+        M = Integer.parseInt(st.nextToken());\n+        X = Integer.parseInt(st.nextToken());\n+        cities = new List[N+1];\n+        ans = new int[N+1];\n+        for (int i = 0; i <= N; i++) cities[i] = new ArrayList<Conn>();\n+        for (int i = 0; i < M; i++) {\n+            st = new StringTokenizer(br.readLine());\n+            int x = Integer.parseInt(st.nextToken());\n+            int y = Integer.parseInt(st.nextToken());\n+            int dist = Integer.parseInt(st.nextToken());\n+            cities[x].add(new Conn(y, dist));\n+        }\n+\n+        // 각 지역별 X 마을까지 가는 최단 거리를 구하기\n+        for (int i = 1; i <= N; i++) dijkstra(i);\n+        ans[0] = 0;\n+\n+        // 가장 오래 걸린 시간 구하기\n+        System.out.println(Arrays.stream(ans).max().getAsInt());\n+    }\n+\n+    static void dijkstra (int root) {\n+        int[] minDist = new int[N+1];           // root로부터 최단 거리\n+        boolean[] visited = new boolean[N+1];   // 최단 거리로 방문한 상태 체크\n+        Arrays.fill(minDist, INF);              // 최소 거리를 위한 배열 무한대값 초기화\n+        minDist[root] = 0;                      // root 최단 거리 0 초기화\n+\n+        for (int i = 1; i < N; i++) {\n+            int index = 0;      // 최소 거리를 가진 인덱스\n+            int min = INF;      // 최소 거리\n+            for (int j = 1; j <= N; j++) {\n+                // 아직 최소 거리의 값으로 확정되지 않은 것 중 가장 짧은 위치\n+                if (!visited[j] && min > minDist[j]) {\n+                    min = minDist[j];\n+                    index = j;\n+                }\n+            }\n+\n+            // 가장 짧은 거리를 가진 인덱스와 연결된 도시들의 값을 갱신해주는 작업\n+            for (int j = 0, size = cities[index].size(); j < size; j++) {\n+                Conn conn = cities[index].get(j);\n+                if (minDist[index] == INF || visited[conn.x]) continue;\n+                minDist[conn.x] = Math.min(minDist[conn.x], minDist[index] + conn.dist);\n+            }\n+            visited[index] = true;\n+\n+            // 파티하는 마을이 아니라면 root-X까지 가는 값만 구하면 되므로 X까지 가는 최소 값이 정해지면 break\n+            if (root != X && index == X) break;\n+        }\n+\n+        if (root == X) {\n+            // X에서 모든 마을까지의 돌아가는 최단 거리이므로 ans의 모든 값에 minDist를 더해준다.\n+            for (int i = 1; i <= N; i++) ans[i] += minDist[i];\n+        } else {\n+            // root-X까지 가는 최단 거리를 ans[root]에 더해준다.\n+            ans[root] += minDist[X];\n+        }\n+    }\n+\n+    static class Conn {\n+        int x, dist;\n+\n+        public Conn(int x, int dist) {\n+            this.x = x;\n+            this.dist = dist;\n+        }\n+    }\n+}"
  },
  {
    "sha": "96ddcafc98d050c82ed9b08d89552702c0ae4405",
    "filename": "BOJ/[BOJ]1238_파티/README.md",
    "status": "added",
    "additions": 58,
    "deletions": 0,
    "changes": 58,
    "blob_url": "https://github.com/ssafy10-5-algo/algorithm/blob/15766830e0c735012871742db1688466683f5640/BOJ/%5BBOJ%5D1238_%ED%8C%8C%ED%8B%B0/README.md",
    "raw_url": "https://github.com/ssafy10-5-algo/algorithm/raw/15766830e0c735012871742db1688466683f5640/BOJ/%5BBOJ%5D1238_%ED%8C%8C%ED%8B%B0/README.md",
    "contents_url": "https://api.github.com/repos/ssafy10-5-algo/algorithm/contents/BOJ/%5BBOJ%5D1238_%ED%8C%8C%ED%8B%B0/README.md?ref=15766830e0c735012871742db1688466683f5640",
    "patch": "@@ -0,0 +1,58 @@\n+# [백준: 1238 파티 🥳](https://www.acmicpc.net/problem/1238)\n+\n+### sudo ✍ \n+처음에는 이차원 배열로 visited[from][to] 이렇게해서 해야하나 했는데 생각해보니 최단 시간이면 그냥 다익스트라를 쓰면 되겠군? 이란 생각이 들었다. 처음에 푼 코드가 [시간초과](https://colorscripter.com/s/xyDgMk9)여서 다익스트라 알고리즘을 내가 잘못 알고 있군! 이란 생각이 들어 위키백과의 내용을 좀 참고 했다. ㅎㅎ.. 시간초과 코드보면 **당당하게 삼중 for문**을 쓰고 통과되길 바랬다... 몽총이 😎\n+\n+<br/>\n+\n+### [다익스트라 알고리즘](https://ko.wikipedia.org/w/index.php?title=%EB%8D%B0%EC%9D%B4%ED%81%AC%EC%8A%A4%ED%8A%B8%EB%9D%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98&action=edit&section=2)  \n+1. 모든 꼭짓점을 미방문 상태로 표시한다. \n+2. 초기점을 0으로, 다른 모든 꼭짓점을 무한대로 설정한다. \n+3. 미방문한 마을 중 최단 거리를 가진 마을과 연결된 도시들의 거리를  갱신\n+4. 미방문한 마을 중 최단 거리를 가진 마을을 방문한 마을로 변경\n+5. 도시 마을 N번 만큼 반복\n+\n+\n+<br/>\n+\n+### algorithm 💻\n+1. 모든 꼭짓점을 미방문 상태로 표시\n+2. 초기점은 0, 나머지 꼭짓점은 무한대로 설정\n+    ```java\n+    int[] minDist = new int[N+1];\n+    boolean[] visited = new boolean[N+1];체크\n+    Arrays.fill(minDist, INF);\n+    minDist[root] = 0;\n+    ```\n+\n+3. 미방문한 마을 중 최단 거리를 가진 마을과 연결된 도시들의 거리를  갱신\n+    * 3-1) 미방문한 꼭짓점 중 최단 거리를 가진 꼭짓점 찾기\n+        ```java\n+        for (int j = 1; j <= N; j++) {\n+            if (!visited[j] && min > minDist[j]) {\n+                min = minDist[j];\n+                index = j;\n+                }\n+        }\n+        ```\n+    * 3-2) 연결된 도시들 갱신  \n+        ```java\n+        for (int j = 0, size = cities[index].size(); j < size; j++) {\n+            Conn conn = cities[index].get(j);\n+            if (minDist[index] == INF || visited[conn.x]) continue;\n+            minDist[conn.x] = Math.min(minDist[conn.x], minDist[index] + conn.dist);\n+        }\n+        ```\n+\n+4. 미방문한 마을 중 최단 거리를 가진 마을을 방문한 마을로 변경\n+    ```java\n+    visited[index] = true;\n+    ```\n+\n+5. 도시 마을 N번 만큼 반복\n+6. 끝!\n+\n+<br/>\n+\n+### 배운 점 🌵  \n+다익스트라 알고리즘 문제를 오랜만에 풀었더니 좋았다! 잊어버렸던 알고리즘 하나를 다시 찾은 느낌? 다음 문제는 벨만포드 알고리즘으로 골라봐야겠다\n\\ No newline at end of file"
  }
]
