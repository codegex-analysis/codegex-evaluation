[
  {
    "sha": "18b442a3100d2f2c5173ffbb7fb8c3551defae73",
    "filename": "src/main/java/seedu/partyplanet/logic/parser/ParserUtil.java",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/AY2021S2-CS2103-W16-3/tp/blob/3caf37ffd40e611b279bee7a45741b4ea32b6f1e/src/main/java/seedu/partyplanet/logic/parser/ParserUtil.java",
    "raw_url": "https://github.com/AY2021S2-CS2103-W16-3/tp/raw/3caf37ffd40e611b279bee7a45741b4ea32b6f1e/src/main/java/seedu/partyplanet/logic/parser/ParserUtil.java",
    "contents_url": "https://api.github.com/repos/AY2021S2-CS2103-W16-3/tp/contents/src/main/java/seedu/partyplanet/logic/parser/ParserUtil.java?ref=3caf37ffd40e611b279bee7a45741b4ea32b6f1e",
    "patch": "@@ -135,15 +135,15 @@ public static Email parseEmail(String email) throws ParseException {\n     public static Birthday parseBirthday(String birthday) throws ParseException {\n         requireNonNull(birthday);\n         String trimmedBirthday = birthday.trim();\n-        if (birthday == Birthday.EMPTY_BIRTHDAY_STRING) {\n+        if (birthday.equals(Birthday.EMPTY_BIRTHDAY_STRING)) {\n             return Birthday.EMPTY_BIRTHDAY;\n         }\n         try {\n             return new Birthday(trimmedBirthday);\n         } catch (DateTimeException err) { // date in wrong format\n             throw new ParseException((Birthday.MESSAGE_CONSTRAINTS));\n-        } catch (IllegalArgumentException err) { // birthday year exceeds current year\n-            throw new ParseException(Birthday.MESSAGE_YEAR_CONSTRAINTS);\n+        } catch (IllegalArgumentException err) { // birthday is in the future\n+            throw new ParseException(Birthday.MESSAGE_DATE_CONSTRAINTS);\n         }\n     }\n "
  },
  {
    "sha": "b104fc57c11e16b05beb21291824ec6151e0bbce",
    "filename": "src/main/java/seedu/partyplanet/model/person/Birthday.java",
    "status": "modified",
    "additions": 160,
    "deletions": 20,
    "changes": 180,
    "blob_url": "https://github.com/AY2021S2-CS2103-W16-3/tp/blob/3caf37ffd40e611b279bee7a45741b4ea32b6f1e/src/main/java/seedu/partyplanet/model/person/Birthday.java",
    "raw_url": "https://github.com/AY2021S2-CS2103-W16-3/tp/raw/3caf37ffd40e611b279bee7a45741b4ea32b6f1e/src/main/java/seedu/partyplanet/model/person/Birthday.java",
    "contents_url": "https://api.github.com/repos/AY2021S2-CS2103-W16-3/tp/contents/src/main/java/seedu/partyplanet/model/person/Birthday.java?ref=3caf37ffd40e611b279bee7a45741b4ea32b6f1e",
    "patch": "@@ -5,42 +5,131 @@\n \n import java.time.DateTimeException;\n import java.time.LocalDate;\n+import java.time.MonthDay;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.TemporalAccessor;\n \n /** Represents a Person's birthday in PartyPlanet.\n  * Guarantees: immutable; is always valid.\n  */\n-public class Birthday {\n-\n-    public static final String MESSAGE_CONSTRAINTS = \"Birthday must be in the format yyyy-mm-dd\";\n-    public static final String MESSAGE_YEAR_CONSTRAINTS =\n-            String.format(\"Year should not exceed %d\", LocalDate.now().getYear());\n+public class Birthday implements Comparable<Birthday> {\n \n+    public static final String MESSAGE_CONSTRAINTS = \"Birthdays should be in one of the following formats:\\n\"\n+            + \"    - yyyy-mm-dd (ISO format)\\n\"\n+            + \"    - dd.mm.yyyy\\n\"\n+            + \"    - dd/mm/yyyy\\n\"\n+            + \"    - dd mmm yyyy\\n\"\n+            + \"    - mmm dd yyyy\";\n+    public static final String MESSAGE_DATE_CONSTRAINTS = \"Birthday should not be a date in the future\";\n     public static final String EMPTY_BIRTHDAY_STRING = \"\";\n     public static final Birthday EMPTY_BIRTHDAY = new Birthday();\n \n+    private static final DateTimeFormatter[] VALID_FORMATS = new DateTimeFormatter[] {\n+            DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"),\n+            DateTimeFormatter.ofPattern(\"d.M.yyyy\"),\n+            DateTimeFormatter.ofPattern(\"d/M/yyyy\"),\n+            DateTimeFormatter.ofPattern(\"d MMM yyyy\"),\n+            DateTimeFormatter.ofPattern(\"d MMMM yyyy\"),\n+            DateTimeFormatter.ofPattern(\"MMM d yyyy\"),\n+            DateTimeFormatter.ofPattern(\"MMMM d yyyy\"),\n+    };\n+    private static final DateTimeFormatter[] VALID_FORMATS_WITHOUT_YEAR = new DateTimeFormatter[] {\n+            DateTimeFormatter.ofPattern(\"--MM-dd\"),\n+            DateTimeFormatter.ofPattern(\"d/M\"),\n+            DateTimeFormatter.ofPattern(\"d MMM\"),\n+            DateTimeFormatter.ofPattern(\"d MMMM\"),\n+            DateTimeFormatter.ofPattern(\"MMM d\"),\n+            DateTimeFormatter.ofPattern(\"MMMM d\"),\n+    };\n+    private static final DateTimeFormatter ISO_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    private static final DateTimeFormatter ISO_FORMAT_WITHOUT_YEAR = DateTimeFormatter.ofPattern(\"--MM-dd\");\n+    private static final DateTimeFormatter READABLE_FORMAT = DateTimeFormatter.ofPattern(\"d MMM yyyy\");\n+    private static final DateTimeFormatter READABLE_FORMAT_WITHOUT_YEAR = DateTimeFormatter.ofPattern(\"d MMM\");\n+\n+    /** In \"dd mmm yyyy\" formatted string for human-readable display */\n+    public final String displayValue;\n+    /** In ISO-8601 format for easy comparison */\n     public final String value;\n+    private int month; // implemented for quick retrieval\n+    private boolean hasYear;\n     private boolean isEmpty = false;\n \n     /**\n      * Constructs a {@code Birthday}.\n+     * Birthdate should not be in the future, and can optionally contain a year.\n+     * Some invalid dates are mapped to the nearest valid date, e.g. 29 Feb 2021 -> 28 Feb 2021.\n      *\n      * @param birthdate A valid birthdate.\n      */\n     public Birthday(String birthdate) {\n         requireNonNull(birthdate);\n-        isValidBirthday(birthdate);\n-        checkArgument(isValidBirthdayYear(birthdate), MESSAGE_YEAR_CONSTRAINTS);\n-        value = birthdate;\n+        TemporalAccessor date = parseBirthday(toTitleCase(birthdate));\n+        hasYear = date instanceof LocalDate;\n+        if (hasYear) {\n+            value = ISO_FORMAT.format(date);\n+            displayValue = READABLE_FORMAT.format(date);\n+            month = ((LocalDate) date).getMonthValue();\n+        } else {\n+            value = ISO_FORMAT_WITHOUT_YEAR.format(date);\n+            displayValue = READABLE_FORMAT_WITHOUT_YEAR.format(date);\n+            month = ((MonthDay) date).getMonthValue();\n+        }\n+        checkArgument(isValidBirthdayDate(value), MESSAGE_DATE_CONSTRAINTS);\n     }\n \n     /**\n      * Constructs an empty birthday.\n      */\n     public Birthday() {\n         value = EMPTY_BIRTHDAY_STRING;\n+        displayValue = EMPTY_BIRTHDAY_STRING;\n         isEmpty = true;\n     }\n \n+    /**\n+     * Attempts to match {@code birthdate} to any parsing rule.\n+     * If valid, a LocalDate or MonthDay is returned depending on whether a year exists,\n+     * otherwise a DateTimeException will be thrown.\n+     */\n+    public static TemporalAccessor parseBirthday(String birthdate) throws DateTimeException {\n+        for (DateTimeFormatter dateFormat: VALID_FORMATS) {\n+            try {\n+                return LocalDate.parse(birthdate, dateFormat);\n+            } catch (DateTimeException e) {\n+                continue;\n+            }\n+        }\n+        for (DateTimeFormatter dateFormat: VALID_FORMATS_WITHOUT_YEAR) {\n+            try {\n+                return MonthDay.parse(birthdate, dateFormat);\n+            } catch (DateTimeException e) {\n+                continue;\n+            }\n+        }\n+        throw new DateTimeException(MESSAGE_CONSTRAINTS);\n+    }\n+\n+    /**\n+     * Returns title case for strings.\n+     * Required for user inputs in arbitrary case, which DateTimeFormatter does not support parsing for.\n+     */\n+    private static String toTitleCase(String date) {\n+        StringBuilder titleCase = new StringBuilder(date.length());\n+        boolean nextCapitalize = true;\n+        for (char c: date.toCharArray()) {\n+            if (!Character.isLetter(c)) {\n+                nextCapitalize = true;\n+            } else if (nextCapitalize) {\n+                c = Character.toUpperCase(c);\n+                nextCapitalize = false;\n+            } else {\n+                c = Character.toLowerCase(c);\n+            }\n+            titleCase.append(c);\n+        }\n+        return titleCase.toString();\n+    }\n+\n     /**\n      * Returns true if a given birthday is an empty birthday.\n      */\n@@ -49,37 +138,88 @@ public static boolean isEmptyBirthday(Birthday birthday) {\n     }\n \n     /**\n-     * Returns true if a given birthday string has a valid year.\n+     * Returns true if a given birthday string is a valid date not in the future.\n+     */\n+    public static boolean isValidBirthdayDate(String test) {\n+        return isValidBirthdayDate(test, LocalDate.now());\n+    }\n+\n+    /**\n+     * Returns true if a given birthday string is a valid date not after {@code reference}.\n+     * Exposes {@reference} date as a parameter for unit testing.\n+     * Note: Dates without years which are parsed successfully are always considered valid.\n      */\n-    public static boolean isValidBirthdayYear(String test) {\n-        return Integer.parseInt(test.split(\"-\")[0]) <= LocalDate.now().getYear();\n+    public static boolean isValidBirthdayDate(String test, LocalDate reference) {\n+        String referenceDate = ISO_FORMAT.format(reference);\n+        TemporalAccessor date = parseBirthday(test);\n+        String testDate = (date instanceof LocalDate ? ISO_FORMAT : ISO_FORMAT_WITHOUT_YEAR).format(date);\n+        return testDate.compareTo(referenceDate) <= 0;\n     }\n \n     /**\n-     * Throws an error if a given string is an invalid birthday.\n+     * Returns true if a given string is a valid birthday, otherwise false.\n+     * Implemented for unit testing.\n      */\n-    public static void isValidBirthday(String test) {\n+    public static boolean isValidBirthday(String test) {\n         try {\n-            LocalDate.parse(test);\n-        } catch (DateTimeException err) {\n-            throw new DateTimeException(MESSAGE_CONSTRAINTS);\n+            parseBirthday(test);\n+            return true;\n+        } catch (DateTimeException e) {\n+            return false;\n         }\n     }\n \n+    /**\n+     * Returns the month value of the birthday, in the range [1-12].\n+     * Required for feature to filter contact birthdays by month.\n+     */\n+    public int getMonth() {\n+        if (isEmpty) {\n+            throw new IllegalArgumentException(\"Birthday is empty\");\n+        }\n+        return month;\n+    }\n+\n+    @Override\n+    public int compareTo(Birthday other) {\n+        return getMonthDayString().compareTo(other.getMonthDayString());\n+    }\n+\n+    /**\n+     * Returns month and day as \"mm-dd\" in ISO format.\n+     * For easier comparison between Birthday objects.\n+     *\n+     * Note: Can consider refactoring this to rely on (month,day) integer pairs instead.\n+     */\n+    private String getMonthDayString() {\n+        if (isEmpty) {\n+            throw new IllegalArgumentException(\"Birthday is empty\");\n+        }\n+        return hasYear ? value.substring(5) : value.substring(2);\n+    }\n+\n     @Override\n     public String toString() {\n-        return value;\n+        return displayValue;\n     }\n \n     @Override\n     public boolean equals(Object other) {\n-        return other == this // short circuit if same object\n-                || (other instanceof Birthday // instanceof handles nulls\n-                && value.equals(((Birthday) other).value)); // state check\n+        if (other == this) {\n+            return true;\n+        }\n+        if (!(other instanceof Birthday)) {\n+            return false;\n+        }\n+        if (isEmpty == isEmptyBirthday((Birthday) other)) {\n+            return true;\n+        }\n+        return value.equals(((Birthday) other).value);\n     }\n \n     @Override\n     public int hashCode() {\n         return value.hashCode();\n     }\n+\n }"
  },
  {
    "sha": "2b21245cb81889878524a9ff9313979e9b314338",
    "filename": "src/main/java/seedu/partyplanet/storage/JsonAdaptedPerson.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/AY2021S2-CS2103-W16-3/tp/blob/3caf37ffd40e611b279bee7a45741b4ea32b6f1e/src/main/java/seedu/partyplanet/storage/JsonAdaptedPerson.java",
    "raw_url": "https://github.com/AY2021S2-CS2103-W16-3/tp/raw/3caf37ffd40e611b279bee7a45741b4ea32b6f1e/src/main/java/seedu/partyplanet/storage/JsonAdaptedPerson.java",
    "contents_url": "https://api.github.com/repos/AY2021S2-CS2103-W16-3/tp/contents/src/main/java/seedu/partyplanet/storage/JsonAdaptedPerson.java?ref=3caf37ffd40e611b279bee7a45741b4ea32b6f1e",
    "patch": "@@ -125,7 +125,7 @@ public Person toModelType() throws IllegalValueException {\n             } catch (DateTimeException err) { // date in wrong format\n                 throw new IllegalValueException(Birthday.MESSAGE_CONSTRAINTS);\n             } catch (IllegalArgumentException err) { // birthday year exceeds current year\n-                throw new IllegalValueException(Birthday.MESSAGE_YEAR_CONSTRAINTS);\n+                throw new IllegalValueException(Birthday.MESSAGE_DATE_CONSTRAINTS);\n             }\n         }\n "
  },
  {
    "sha": "b8f5b878d343c0bb1f59c964c680e64d6f741a79",
    "filename": "src/main/java/seedu/partyplanet/ui/PersonCard.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/AY2021S2-CS2103-W16-3/tp/blob/3caf37ffd40e611b279bee7a45741b4ea32b6f1e/src/main/java/seedu/partyplanet/ui/PersonCard.java",
    "raw_url": "https://github.com/AY2021S2-CS2103-W16-3/tp/raw/3caf37ffd40e611b279bee7a45741b4ea32b6f1e/src/main/java/seedu/partyplanet/ui/PersonCard.java",
    "contents_url": "https://api.github.com/repos/AY2021S2-CS2103-W16-3/tp/contents/src/main/java/seedu/partyplanet/ui/PersonCard.java?ref=3caf37ffd40e611b279bee7a45741b4ea32b6f1e",
    "patch": "@@ -69,7 +69,7 @@ public PersonCard(Person person, int displayedIndex) {\n             email.setText(person.getEmail().value);\n         }\n         if (!Birthday.isEmptyBirthday(person.getBirthday())) {\n-            birthday.setText(person.getBirthday().value);\n+            birthday.setText(person.getBirthday().displayValue);\n         }\n         if (!Remark.isEmptyRemark(person.getRemark())) {\n             remark.setText(person.getRemark().value);"
  },
  {
    "sha": "9dbe5a864d8062c2a21ad7149e1a5f1cae3ae297",
    "filename": "src/test/java/seedu/partyplanet/model/person/BirthdayTest.java",
    "status": "added",
    "additions": 121,
    "deletions": 0,
    "changes": 121,
    "blob_url": "https://github.com/AY2021S2-CS2103-W16-3/tp/blob/3caf37ffd40e611b279bee7a45741b4ea32b6f1e/src/test/java/seedu/partyplanet/model/person/BirthdayTest.java",
    "raw_url": "https://github.com/AY2021S2-CS2103-W16-3/tp/raw/3caf37ffd40e611b279bee7a45741b4ea32b6f1e/src/test/java/seedu/partyplanet/model/person/BirthdayTest.java",
    "contents_url": "https://api.github.com/repos/AY2021S2-CS2103-W16-3/tp/contents/src/test/java/seedu/partyplanet/model/person/BirthdayTest.java?ref=3caf37ffd40e611b279bee7a45741b4ea32b6f1e",
    "patch": "@@ -0,0 +1,121 @@\n+package seedu.partyplanet.model.person;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static seedu.partyplanet.testutil.Assert.assertThrows;\n+\n+import java.time.DateTimeException;\n+import java.time.LocalDate;\n+import java.time.MonthDay;\n+import java.util.Arrays;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class BirthdayTest {\n+\n+    @Test\n+    public void constructor_null_throwsNullPointerException() {\n+        assertThrows(NullPointerException.class, () -> new Birthday(null));\n+    }\n+\n+    @Test\n+    public void constructor_invalidBirthday_throwsDateTimeException() {\n+        String invalidBirthday = \"\";\n+        assertThrows(DateTimeException.class, () -> new Birthday(invalidBirthday));\n+    }\n+\n+    @Test\n+    public void isValidBirthday_invalidBirthdays() {\n+        // null birthdays\n+        assertThrows(NullPointerException.class, () -> Birthday.isValidBirthday(null));\n+\n+        // invalid birthdays\n+        assertFalse(Birthday.isValidBirthday(\"\")); // empty string\n+        assertFalse(Birthday.isValidBirthday(\" \")); // spaces only\n+        assertFalse(Birthday.isValidBirthday(\"91\")); // none match\n+        assertFalse(Birthday.isValidBirthday(\"2021 Feb 20\")); // unsupported format\n+        assertFalse(Birthday.isValidBirthday(\"20Feb2021\")); // unsupported format\n+    }\n+\n+    @Test\n+    public void isValidBirthday_validWithYears() {\n+        String[] validInputs = new String[]{\n+            \"2021-02-03\",\n+            \"3.2.2021\",\n+            \"3/2/2021\",\n+            \"3 Feb 2021\",\n+            \"3 February 2021\",\n+            \"Feb 3 2021\",\n+            \"February 3 2021\",\n+        };\n+        for (String validInput: validInputs) {\n+            assertTrue(Birthday.isValidBirthday(validInput));\n+        }\n+        assertEquals(1, Arrays.stream(validInputs)\n+                .map(Birthday::parseBirthday)\n+                .map(x -> (LocalDate) x)\n+                .distinct()\n+                .count());\n+    }\n+\n+    @Test\n+    public void isValidBirthday_validWithoutYears() {\n+        String[] validInputs = new String[]{\n+            \"--02-03\",\n+            \"3/2\",\n+            \"3 Feb\",\n+            \"3 February\",\n+            \"Feb 3\",\n+            \"February 3\",\n+        };\n+        for (String validInput: validInputs) {\n+            assertTrue(Birthday.isValidBirthday(validInput));\n+        }\n+        assertEquals(1, Arrays.stream(validInputs)\n+                .map(Birthday::parseBirthday)\n+                .map(x -> (MonthDay) x)\n+                .distinct()\n+                .count());\n+    }\n+\n+    @Test\n+    public void isValidBirthdayDate() {\n+        LocalDate referenceDate = LocalDate.of(2021, 6, 6);\n+\n+        // MonthDay is always valid\n+        assertTrue(Birthday.isValidBirthdayDate(\"--02-03\", referenceDate));\n+        assertTrue(Birthday.isValidBirthdayDate(\"--06-06\", referenceDate));\n+        assertTrue(Birthday.isValidBirthdayDate(\"--12-12\", referenceDate));\n+\n+        // LocalDate must be before reference\n+        assertTrue(Birthday.isValidBirthdayDate(\"2021-06-05\", referenceDate));\n+        assertTrue(Birthday.isValidBirthdayDate(\"2021-06-06\", referenceDate));\n+        assertFalse(Birthday.isValidBirthdayDate(\"2021-06-07\", referenceDate));\n+    }\n+\n+    @Test\n+    public void compareTo() {\n+        // Same year\n+        Birthday localDate0606 = new Birthday(\"2020-06-06\");\n+        Birthday monthDay0606 = new Birthday(\"--06-06\");\n+        Birthday monthDay0607 = new Birthday(\"--06-07\");\n+        Birthday localDate0608 = new Birthday(\"2020-06-08\");\n+\n+        // Different year\n+        Birthday localDatePrevYear = new Birthday(\"2019-08-13\");\n+\n+        // Same date\n+        assertEquals(0, localDate0606.compareTo(localDate0606));\n+        assertEquals(0, monthDay0606.compareTo(monthDay0606));\n+        assertEquals(0, localDate0606.compareTo(monthDay0606));\n+\n+        // Different date\n+        assertTrue(localDate0606.compareTo(monthDay0607) < 0);\n+        assertTrue(monthDay0606.compareTo(monthDay0607) < 0);\n+        assertTrue(localDate0606.compareTo(localDate0608) < 0);\n+        assertTrue(monthDay0607.compareTo(localDate0608) < 0);\n+        assertTrue(localDate0608.compareTo(localDatePrevYear) < 0);\n+        assertTrue(localDatePrevYear.compareTo(localDate0606) > 0);\n+    }\n+}"
  }
]
