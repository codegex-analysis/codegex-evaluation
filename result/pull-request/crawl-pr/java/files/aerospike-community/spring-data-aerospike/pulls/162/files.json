[
  {
    "sha": "a07d66ce184c5e95c59af89f4c49f2816143ed98",
    "filename": "src/main/java/org/springframework/data/aerospike/core/AerospikeOperations.java",
    "status": "modified",
    "additions": 3,
    "deletions": 0,
    "changes": 3,
    "blob_url": "https://github.com/aerospike-community/spring-data-aerospike/blob/373befdd85205fcebb8eb0b9904cc3aa12cb5a67/src/main/java/org/springframework/data/aerospike/core/AerospikeOperations.java",
    "raw_url": "https://github.com/aerospike-community/spring-data-aerospike/raw/373befdd85205fcebb8eb0b9904cc3aa12cb5a67/src/main/java/org/springframework/data/aerospike/core/AerospikeOperations.java",
    "contents_url": "https://api.github.com/repos/aerospike-community/spring-data-aerospike/contents/src/main/java/org/springframework/data/aerospike/core/AerospikeOperations.java?ref=373befdd85205fcebb8eb0b9904cc3aa12cb5a67",
    "patch": "@@ -26,6 +26,7 @@\n import org.springframework.data.domain.Sort;\n import org.springframework.data.mapping.context.MappingContext;\n \n+import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.function.Supplier;\n@@ -109,6 +110,8 @@\n \n \t<T> List<T> findByIds(Iterable<?> ids, Class<T> entityClass);\n \n+\tMap<Class<?>, Collection<?>> findByIds(Map<Class<?>, Collection<?>> keysMap);\n+\n \t<T> T add(T objectToAddTo, Map<String, Long> values);\n \t\n \t<T> T add(T objectToAddTo, String binName, long value);"
  },
  {
    "sha": "b0cf0a9bb70a99b8b6e455e61924f43bf02d00d7",
    "filename": "src/main/java/org/springframework/data/aerospike/core/AerospikeTemplate.java",
    "status": "modified",
    "additions": 72,
    "deletions": 3,
    "changes": 75,
    "blob_url": "https://github.com/aerospike-community/spring-data-aerospike/blob/373befdd85205fcebb8eb0b9904cc3aa12cb5a67/src/main/java/org/springframework/data/aerospike/core/AerospikeTemplate.java",
    "raw_url": "https://github.com/aerospike-community/spring-data-aerospike/raw/373befdd85205fcebb8eb0b9904cc3aa12cb5a67/src/main/java/org/springframework/data/aerospike/core/AerospikeTemplate.java",
    "contents_url": "https://api.github.com/repos/aerospike-community/spring-data-aerospike/contents/src/main/java/org/springframework/data/aerospike/core/AerospikeTemplate.java?ref=373befdd85205fcebb8eb0b9904cc3aa12cb5a67",
    "patch": "@@ -15,12 +15,24 @@\n  */\n package org.springframework.data.aerospike.core;\n \n+import com.aerospike.client.AerospikeClient;\n+import com.aerospike.client.AerospikeException;\n+import com.aerospike.client.Bin;\n+import com.aerospike.client.Info;\n+import com.aerospike.client.Key;\n+import com.aerospike.client.Operation;\n import com.aerospike.client.Record;\n-import com.aerospike.client.*;\n+import com.aerospike.client.ResultCode;\n+import com.aerospike.client.Value;\n import com.aerospike.client.cluster.Node;\n import com.aerospike.client.policy.RecordExistsAction;\n import com.aerospike.client.policy.WritePolicy;\n-import com.aerospike.client.query.*;\n+import com.aerospike.client.query.Filter;\n+import com.aerospike.client.query.IndexCollectionType;\n+import com.aerospike.client.query.IndexType;\n+import com.aerospike.client.query.KeyRecord;\n+import com.aerospike.client.query.ResultSet;\n+import com.aerospike.client.query.Statement;\n import com.aerospike.client.task.IndexTask;\n import lombok.extern.slf4j.Slf4j;\n import org.springframework.dao.InvalidDataAccessResourceUsageException;\n@@ -39,12 +51,22 @@\n import org.springframework.data.util.StreamUtils;\n import org.springframework.util.Assert;\n \n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n import java.util.function.Supplier;\n import java.util.stream.Collectors;\n import java.util.stream.IntStream;\n import java.util.stream.Stream;\n \n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.stream.Collectors.groupingBy;\n import static org.springframework.data.aerospike.core.OperationUtils.operations;\n \n \n@@ -334,6 +356,41 @@ private Record getAndTouch(Key key, int expiration) {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic Map<Class<?>, Collection<?>> findByIds(Map<Class<?>, Collection<?>> entitiesKeys) {\n+\t\tAssert.notNull(entitiesKeys, \"Map of entities ids must not be null!\");\n+\n+\t\tif (entitiesKeys.isEmpty()) {\n+\t\t\treturn emptyMap();\n+\t\t}\n+\n+\t\tMap<Class<?>, List<Key>> keyListMap = entitiesKeys.entrySet().stream()\n+\t\t\t\t.collect(Collectors.toMap(Map.Entry::getKey, entry -> toKeysList(entry.getKey(), entry.getValue())));\n+\n+\t\tMap<Class<?>, List<Object>> entitiesByIdsInternal = findEntitiesByIdsInternal(keyListMap);\n+\n+\t\treturn entitiesKeys.keySet().stream()\n+\t\t\t\t.collect(Collectors.toMap(key -> key, key -> entitiesByIdsInternal.getOrDefault(key, emptyList())));\n+\t}\n+\n+\tprivate Map<Class<?>, List<Object>> findEntitiesByIdsInternal(Map<Class<?>, List<Key>> entitiesKeys) {\n+\t\tClass<?>[] entityClasses = entitiesKeys.entrySet().stream()\n+\t\t\t\t.flatMap(entry -> entry.getValue().stream().map(item -> entry.getKey()))\n+\t\t\t\t.toArray(Class<?>[]::new);\n+\n+\t\tKey[] keys = entitiesKeys.entrySet().stream()\n+\t\t\t\t.flatMap(entry -> entry.getValue().stream())\n+\t\t\t\t.toArray(Key[]::new);\n+\n+\t\tRecord[] records = client.get(null, keys);\n+\n+\t\treturn IntStream.range(0, keys.length)\n+\t\t\t\t.filter(index -> records[index] != null)\n+\t\t\t\t.mapToObj(index -> mapToEntity(keys[index], entityClasses[index], records[index]))\n+\t\t\t\t.filter(Objects::nonNull)\n+\t\t\t\t.collect(groupingBy(this::getEntityClass));\n+\t}\n+\n \t@SuppressWarnings(\"unchecked\")\n \t@Override\n \tpublic <T> Iterable<T> aggregate(Filter filter, Class<T> entityClass,\n@@ -670,4 +727,16 @@ private Node getRandomNode(Node[] nodes) {\n \t\t}\n \t\tthrow new AerospikeException.InvalidNode(\"Command failed because no active nodes found.\");\n \t}\n+\n+\tprivate <T> List<Key> toKeysList(Class<T> entityClass, Collection<?> ids) {\n+\t\tAssert.notNull(entityClass, \"List of entities must not be null!\");\n+\t\tAssert.notNull(ids, \"List of ids must not be null!\");\n+\n+\t\tAerospikePersistentEntity<?> entity = mappingContext.getRequiredPersistentEntity(entityClass);\n+\t\tList<?> idsList = IterableConverter.toList(ids);\n+\n+\t\treturn idsList.stream()\n+\t\t\t\t.map(id -> getKey(id, entity))\n+\t\t\t\t.collect(Collectors.toList());\n+\t}\n }"
  },
  {
    "sha": "53d8bf7909cb937d1c362b3110bb3105f937d644",
    "filename": "src/test/java/org/springframework/data/aerospike/core/AerospikeTemplateFindByEntitiesTests.java",
    "status": "added",
    "additions": 219,
    "deletions": 0,
    "changes": 219,
    "blob_url": "https://github.com/aerospike-community/spring-data-aerospike/blob/373befdd85205fcebb8eb0b9904cc3aa12cb5a67/src/test/java/org/springframework/data/aerospike/core/AerospikeTemplateFindByEntitiesTests.java",
    "raw_url": "https://github.com/aerospike-community/spring-data-aerospike/raw/373befdd85205fcebb8eb0b9904cc3aa12cb5a67/src/test/java/org/springframework/data/aerospike/core/AerospikeTemplateFindByEntitiesTests.java",
    "contents_url": "https://api.github.com/repos/aerospike-community/spring-data-aerospike/contents/src/test/java/org/springframework/data/aerospike/core/AerospikeTemplateFindByEntitiesTests.java?ref=373befdd85205fcebb8eb0b9904cc3aa12cb5a67",
    "patch": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2019 the original author or authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.springframework.data.aerospike.core;\n+\n+import org.junit.jupiter.api.Test;\n+import org.springframework.core.convert.ConverterNotFoundException;\n+import org.springframework.data.aerospike.BaseBlockingIntegrationTests;\n+import org.springframework.data.aerospike.sample.Customer;\n+import org.springframework.data.aerospike.sample.Person;\n+import org.springframework.data.mapping.MappingException;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+public class AerospikeTemplateFindByEntitiesTests extends BaseBlockingIntegrationTests {\n+\n+    @Test\n+    public void shouldFindAllRequestedEntities() {\n+        List<Person> persons = generatePersons(5);\n+        List<Customer> customers = generateCustomers(3);\n+\n+        Map<Class<?>, Collection<?>> requestMap = getRequestMap(persons, customers);\n+\n+        Map<Class<?>, Collection<?>> entitiesByIds = template.findByIds(requestMap);\n+\n+        Map<Class<?>, Collection<?>> expectedResult = new HashMap<>();\n+        expectedResult.put(Person.class, persons);\n+        expectedResult.put(Customer.class, customers);\n+\n+        assertThat(entitiesByIds).usingRecursiveComparison()\n+                .ignoringCollectionOrder()\n+                .isEqualTo(expectedResult);\n+    }\n+\n+    @Test\n+    public void shouldFindSomeOfIdsOfRequestedEntities() {\n+        List<Person> persons = generatePersons(2);\n+        List<Customer> customers = generateCustomers(3);\n+\n+        Map<Class<?>, Collection<?>> requestMap = getRequestMapWithRandomExtraIds(persons, customers);\n+        Map<Class<?>, Collection<?>> entitiesByIds = template.findByIds(requestMap);\n+\n+        Map<Class<?>, Collection<?>> expectedResult = new HashMap<>();\n+        expectedResult.put(Person.class, persons);\n+        expectedResult.put(Customer.class, customers);\n+\n+        assertThat(entitiesByIds).usingRecursiveComparison()\n+                .ignoringCollectionOrder()\n+                .isEqualTo(expectedResult);\n+    }\n+\n+    @Test\n+    public void shouldFindResultsOfOneOfRequestedEntity() {\n+        List<Person> persons = generatePersons(3);\n+\n+        Map<Class<?>, Collection<?>> requestMap = getRequestMapWithRandomExtraIds(persons, emptyList());\n+        Map<Class<?>, Collection<?>> entitiesByIds = template.findByIds(requestMap);\n+\n+        Map<Class<?>, Collection<?>> expectedResult = new HashMap<>();\n+        expectedResult.put(Person.class, persons);\n+        expectedResult.put(Customer.class, emptyList());\n+\n+        assertThat(entitiesByIds).usingRecursiveComparison()\n+                .ignoringCollectionOrder()\n+                .isEqualTo(expectedResult);\n+    }\n+\n+    @Test\n+    public void shouldFindForOneEntityIfAnotherContainsEmptyRequestList() {\n+        List<Person> persons = generatePersons(3);\n+\n+        Map<Class<?>, Collection<?>> requestMap = getRequestMap(persons, emptyList());\n+        Map<Class<?>, Collection<?>> entitiesByIds = template.findByIds(requestMap);\n+\n+        Map<Class<?>, Collection<?>> expectedResult = new HashMap<>();\n+        expectedResult.put(Person.class, persons);\n+        expectedResult.put(Customer.class, emptyList());\n+\n+        assertThat(entitiesByIds).usingRecursiveComparison()\n+                .ignoringCollectionOrder()\n+                .isEqualTo(expectedResult);\n+    }\n+\n+    @Test\n+    public void shouldReturnMapWithEmptyResultsOnEmptyRequest() {\n+        Map<Class<?>, Collection<?>> requestedMap = new HashMap<>();\n+        requestedMap.put(Person.class, emptyList());\n+        requestedMap.put(Customer.class, emptyList());\n+\n+        Map<Class<?>, Collection<?>> entitiesByIds = template.findByIds(requestedMap);\n+\n+        Map<Class<?>, Collection<?>> expectedResult = new HashMap<>();\n+        expectedResult.put(Person.class, emptyList());\n+        expectedResult.put(Customer.class, emptyList());\n+\n+        assertThat(entitiesByIds).usingRecursiveComparison()\n+                .ignoringCollectionOrder()\n+                .isEqualTo(expectedResult);\n+    }\n+\n+    @Test\n+    public void shouldReturnMapWithEmptyResultsIfNoEntitiesWhereFound() {\n+        Map<Class<?>, Collection<?>> requestedMap = new HashMap<>();\n+        requestedMap.put(Person.class, singletonList(nextId()));\n+        requestedMap.put(Customer.class, singletonList(nextId()));\n+\n+        Map<Class<?>, Collection<?>> entitiesByIds = template.findByIds(requestedMap);\n+\n+        Map<Class<?>, Collection<?>> expectedResult = new HashMap<>();\n+        expectedResult.put(Person.class, emptyList());\n+        expectedResult.put(Customer.class, emptyList());\n+\n+        assertThat(entitiesByIds).usingRecursiveComparison()\n+                .ignoringCollectionOrder()\n+                .isEqualTo(expectedResult);\n+    }\n+\n+    @Test\n+    public void shouldThrowMappingExceptionOnNonAerospikeEntityClass() {\n+        List<Person> persons = generatePersons(2);\n+        Set<String> personIds = persons.stream()\n+                .map(Person::getId)\n+                .collect(Collectors.toSet());\n+\n+        Map<Class<?>, Collection<?>> requestMap = new HashMap<>();\n+        requestMap.put(Person.class, personIds);\n+        requestMap.put(String.class, singletonList(1L));\n+\n+        assertThatThrownBy(() -> template.findByIds(requestMap))\n+                .isInstanceOf(MappingException.class)\n+                .hasMessage(\"Couldn't find PersistentEntity for type class java.lang.String!\");\n+    }\n+\n+    @Test\n+    public void shouldReturnAnEmptyResultOnEmptyRequestMap() {\n+        Map<Class<?>, Collection<?>> byIds = template.findByIds(emptyMap());\n+        assertThat(byIds).isEmpty();\n+    }\n+\n+    @Test\n+    public void shouldThrowConverterNotFoundExceptionOnClassWithoutConverter() {\n+        Map<Class<?>, Collection<?>> requestMap = new HashMap<>();\n+        requestMap.put(Person.class, singletonList(Person.builder().id(\"id\").build()));\n+\n+        assertThatThrownBy(() -> template.findByIds(requestMap))\n+                .isInstanceOf(ConverterNotFoundException.class)\n+                .hasMessageContaining(\"No converter found capable of converting from type\");\n+    }\n+\n+    private Map<Class<?>, Collection<?>> getRequestMap(Collection<Person> persons, Collection<Customer> customers) {\n+        Set<String> requestedPersonsIds = persons.stream()\n+                .map(Person::getId)\n+                .collect(Collectors.toSet());\n+        Set<String> requestedCustomerIds = customers.stream().map(Customer::getId)\n+                .collect(Collectors.toSet());\n+\n+        return new HashMap<Class<?>, Collection<?>>() {{\n+            put(Person.class, requestedPersonsIds);\n+            put(Customer.class, requestedCustomerIds);\n+        }};\n+    }\n+\n+    private Map<Class<?>, Collection<?>> getRequestMapWithRandomExtraIds(Collection<Person> persons, Collection<Customer> customers) {\n+        Set<String> requestedPersonsIds = Stream.concat(persons.stream().map(Person::getId), Stream.of(nextId(), nextId()))\n+                .collect(Collectors.toSet());\n+        Set<String> requestedCustomerIds = Stream.concat(customers.stream().map(Customer::getId), Stream.of(nextId(), nextId()))\n+                .collect(Collectors.toSet());\n+\n+        return new HashMap<Class<?>, Collection<?>>() {{\n+            put(Person.class, requestedPersonsIds);\n+            put(Customer.class, requestedCustomerIds);\n+        }};\n+    }\n+\n+    private List<Customer> generateCustomers(int count) {\n+        return IntStream.range(0, count)\n+                .mapToObj(i -> Customer.builder().id(nextId())\n+                        .firstname(\"firstName\" + i)\n+                        .lastname(\"Smith\")\n+                        .build())\n+                .peek(template::save)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<Person> generatePersons(int count) {\n+        return IntStream.range(0, count)\n+                .mapToObj(i -> Person.builder().id(nextId())\n+                        .firstName(\"firstName\" + i)\n+                        .emailAddress(\"gmail.com\")\n+                        .build())\n+                .peek(template::save)\n+                .collect(Collectors.toList());\n+    }\n+}"
  }
]
