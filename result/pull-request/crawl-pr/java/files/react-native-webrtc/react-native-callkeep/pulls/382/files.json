[
  {
    "sha": "902d1e4ef5f3b390880bdec55f3e128c9009e496",
    "filename": "ios/RNCallKeep/RNCallKeep.h",
    "status": "modified",
    "additions": 42,
    "deletions": 26,
    "changes": 68,
    "blob_url": "https://github.com/react-native-webrtc/react-native-callkeep/blob/ee81cf1d8f08f85380ec73c3ad1dfe1f2afa9ef7/ios/RNCallKeep/RNCallKeep.h",
    "raw_url": "https://github.com/react-native-webrtc/react-native-callkeep/raw/ee81cf1d8f08f85380ec73c3ad1dfe1f2afa9ef7/ios/RNCallKeep/RNCallKeep.h",
    "contents_url": "https://api.github.com/repos/react-native-webrtc/react-native-callkeep/contents/ios/RNCallKeep/RNCallKeep.h?ref=ee81cf1d8f08f85380ec73c3ad1dfe1f2afa9ef7",
    "patch": "@@ -14,35 +14,51 @@\n \n #import <React/RCTEventEmitter.h>\n \n-@interface RNCallKeep : RCTEventEmitter <CXProviderDelegate>\n+@interface RNCallKeep: RCTEventEmitter <CXProviderDelegate>\n \n @property (nonatomic, strong) CXCallController *callKeepCallController;\n @property (nonatomic, strong) CXProvider *callKeepProvider;\n \n-+ (BOOL)application:(UIApplication *)application\n-            openURL:(NSURL *)url\n-            options:(NSDictionary<UIApplicationOpenURLOptionsKey, id> *)options NS_AVAILABLE_IOS(9_0);\n-\n-+ (BOOL)application:(UIApplication *)application\n-continueUserActivity:(NSUserActivity *)userActivity\n-  restorationHandler:(void(^)(NSArray * __nullable restorableObjects))restorationHandler;\n-\n-+ (void)reportNewIncomingCall:(NSString *)uuidString\n-                       handle:(NSString *)handle\n-                   handleType:(NSString *)handleType\n-                     hasVideo:(BOOL)hasVideo\n-          localizedCallerName:(NSString * _Nullable)localizedCallerName\n-              supportsHolding:(BOOL)supportsHolding\n-                 supportsDTMF:(BOOL)supportsDTMF\n-             supportsGrouping:(BOOL)supportsGrouping\n-           supportsUngrouping:(BOOL)supportsUngrouping\n-                  fromPushKit:(BOOL)fromPushKit\n-                      payload:(NSDictionary * _Nullable)payload\n-        withCompletionHandler:(void (^_Nullable)(void))completion;\n-\n-+ (void)endCallWithUUID:(NSString *)uuidString\n-                 reason:(int)reason;\n-\n-+ (BOOL)isCallActive:(NSString *)uuidString;\n+extern NSString * const RNCallKeepHandleStartCallNotification;\n+extern NSString * const RNCallKeepDidReceiveStartCallAction;\n+extern NSString * const RNCallKeepPerformAnswerCallAction;\n+extern NSString * const RNCallKeepPerformEndCallAction;\n+extern NSString * const RNCallKeepDidActivateAudioSession;\n+extern NSString * const RNCallKeepDidDeactivateAudioSession;\n+extern NSString * const RNCallKeepDidDisplayIncomingCall;\n+extern NSString * const RNCallKeepDidPerformSetMutedCallAction;\n+extern NSString * const RNCallKeepPerformPlayDTMFCallAction;\n+extern NSString * const RNCallKeepDidToggleHoldAction;\n+extern NSString * const RNCallKeepProviderReset;\n+extern NSString * const RNCallKeepCheckReachability;\n+extern NSString * const RNCallKeepDidLoadWithEvents;\n+\n++(BOOL) application: (UIApplication *) application\n+            openURL: (NSURL *) url\n+            options: (NSDictionary<UIApplicationOpenURLOptionsKey, id> *) options NS_AVAILABLE_IOS(9_0);\n+\n++(BOOL) application: (UIApplication *) application\n+continueUserActivity: (NSUserActivity *) userActivity\n+ restorationHandler: (void(^) (NSArray * __nullable restorableObjects)) restorationHandler;\n+\n++(void) reportNewIncomingCall: (NSString *) uuidString\n+                       handle: (NSString *) handle\n+                   handleType: (NSString *) handleType\n+                     hasVideo: (BOOL) hasVideo\n+          localizedCallerName: (NSString * _Nullable) localizedCallerName\n+              supportsHolding: (BOOL) supportsHolding\n+                 supportsDTMF: (BOOL) supportsDTMF\n+             supportsGrouping: (BOOL) supportsGrouping\n+           supportsUngrouping: (BOOL) supportsUngrouping\n+                  fromPushKit: (BOOL) fromPushKit\n+                      payload: (NSDictionary * _Nullable) payload\n+        withCompletionHandler: (void (^_Nullable)(void)) completion;\n+\n++(void) endCallWithUUID: (NSString *) uuidString\n+                 reason: (int) reason;\n+\n++(BOOL) isCallActive: (NSString *) uuidString;\n+\n+-(void) initCallKitProvider: (NSDictionary *) settings withEventHandler: (void (^) (NSString * eventName, id data)) onEvent;\n \n @end"
  },
  {
    "sha": "e302ff05790f68a577723330cb39d1a930a2a76b",
    "filename": "ios/RNCallKeep/RNCallKeep.m",
    "status": "modified",
    "additions": 612,
    "deletions": 588,
    "changes": 1200,
    "blob_url": "https://github.com/react-native-webrtc/react-native-callkeep/blob/ee81cf1d8f08f85380ec73c3ad1dfe1f2afa9ef7/ios/RNCallKeep/RNCallKeep.m",
    "raw_url": "https://github.com/react-native-webrtc/react-native-callkeep/raw/ee81cf1d8f08f85380ec73c3ad1dfe1f2afa9ef7/ios/RNCallKeep/RNCallKeep.m",
    "contents_url": "https://api.github.com/repos/react-native-webrtc/react-native-callkeep/contents/ios/RNCallKeep/RNCallKeep.m?ref=ee81cf1d8f08f85380ec73c3ad1dfe1f2afa9ef7",
    "patch": "@@ -21,799 +21,823 @@\n static int const OUTGOING_CALL_WAKEUP_DELAY = 5;\n #endif\n \n-static NSString *const RNCallKeepHandleStartCallNotification = @\"RNCallKeepHandleStartCallNotification\";\n-static NSString *const RNCallKeepDidReceiveStartCallAction = @\"RNCallKeepDidReceiveStartCallAction\";\n-static NSString *const RNCallKeepPerformAnswerCallAction = @\"RNCallKeepPerformAnswerCallAction\";\n-static NSString *const RNCallKeepPerformEndCallAction = @\"RNCallKeepPerformEndCallAction\";\n-static NSString *const RNCallKeepDidActivateAudioSession = @\"RNCallKeepDidActivateAudioSession\";\n-static NSString *const RNCallKeepDidDeactivateAudioSession = @\"RNCallKeepDidDeactivateAudioSession\";\n-static NSString *const RNCallKeepDidDisplayIncomingCall = @\"RNCallKeepDidDisplayIncomingCall\";\n-static NSString *const RNCallKeepDidPerformSetMutedCallAction = @\"RNCallKeepDidPerformSetMutedCallAction\";\n-static NSString *const RNCallKeepPerformPlayDTMFCallAction = @\"RNCallKeepDidPerformDTMFAction\";\n-static NSString *const RNCallKeepDidToggleHoldAction = @\"RNCallKeepDidToggleHoldAction\";\n-static NSString *const RNCallKeepProviderReset = @\"RNCallKeepProviderReset\";\n-static NSString *const RNCallKeepCheckReachability = @\"RNCallKeepCheckReachability\";\n-static NSString *const RNCallKeepDidLoadWithEvents = @\"RNCallKeepDidLoadWithEvents\";\n-\n-@implementation RNCallKeep\n-{\n-    NSOperatingSystemVersion _version;\n-    BOOL _isStartCallActionEventListenerAdded;\n-    bool _hasListeners;\n-    NSMutableArray *_delayedEvents;\n-}\n+@implementation RNCallKeep {\n+  NSOperatingSystemVersion _version;\n+  BOOL _isStartCallActionEventListenerAdded;\n+  bool _hasListeners;\n+  NSMutableArray *_delayedEvents;\n+\n+  void (^onEventHandler) (NSString * eventName, id data);\n+}\n+\n+NSString * const RNCallKeepHandleStartCallNotification = @\"RNCallKeepHandleStartCallNotification\";\n+NSString * const RNCallKeepDidReceiveStartCallAction = @\"RNCallKeepDidReceiveStartCallAction\";\n+NSString * const RNCallKeepPerformAnswerCallAction = @\"RNCallKeepPerformAnswerCallAction\";\n+NSString * const RNCallKeepPerformEndCallAction = @\"RNCallKeepPerformEndCallAction\";\n+NSString * const RNCallKeepDidActivateAudioSession = @\"RNCallKeepDidActivateAudioSession\";\n+NSString * const RNCallKeepDidDeactivateAudioSession = @\"RNCallKeepDidDeactivateAudioSession\";\n+NSString * const RNCallKeepDidDisplayIncomingCall = @\"RNCallKeepDidDisplayIncomingCall\";\n+NSString * const RNCallKeepDidPerformSetMutedCallAction = @\"RNCallKeepDidPerformSetMutedCallAction\";\n+NSString * const RNCallKeepPerformPlayDTMFCallAction = @\"RNCallKeepDidPerformDTMFAction\";\n+NSString * const RNCallKeepDidToggleHoldAction = @\"RNCallKeepDidToggleHoldAction\";\n+NSString * const RNCallKeepProviderReset = @\"RNCallKeepProviderReset\";\n+NSString * const RNCallKeepCheckReachability = @\"RNCallKeepCheckReachability\";\n+NSString * const RNCallKeepDidLoadWithEvents = @\"RNCallKeepDidLoadWithEvents\";\n \n static CXProvider* sharedProvider;\n \n // should initialise in AppDelegate.m\n RCT_EXPORT_MODULE()\n \n-- (instancetype)init\n-{\n+-(instancetype) init {\n+\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][init]\");\n+  NSLog (@\"[RNCallKeep][init]\");\n #endif\n-    if (self = [super init]) {\n-        _isStartCallActionEventListenerAdded = NO;\n-        _delayedEvents = [NSMutableArray array];\n+\n+  if (self = [super init]) {\n+    _isStartCallActionEventListenerAdded = NO;\n+    if (_delayedEvents == nil) {\n+      _delayedEvents = [NSMutableArray array];\n     }\n-    return self;\n+  }\n+\n+  return self;\n }\n \n-+ (id)allocWithZone:(NSZone *)zone {\n-    static RNCallKeep *sharedInstance = nil;\n-    static dispatch_once_t onceToken;\n-    dispatch_once(&onceToken, ^{\n-        sharedInstance = [super allocWithZone:zone];\n-    });\n-    return sharedInstance;\n++(instancetype) allocWithZone: (NSZone *) zone {\n+  static RNCallKeep *sharedInstance = nil;\n+  static dispatch_once_t onceToken;\n+\n+  dispatch_once(&onceToken, ^{\n+    sharedInstance = [super allocWithZone: zone];\n+  });\n+\n+  return sharedInstance;\n }\n \n-- (void)dealloc\n-{\n+-(void) dealloc {\n+\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][dealloc]\");\n+  NSLog (@\"[RNCallKeep][dealloc]\");\n #endif\n-    [[NSNotificationCenter defaultCenter] removeObserver:self];\n \n-    if (self.callKeepProvider != nil) {\n-        [self.callKeepProvider invalidate];\n-    }\n-    sharedProvider = nil;\n+  [[NSNotificationCenter defaultCenter] removeObserver:self];\n+\n+  if (self.callKeepProvider != nil) {\n+    [self.callKeepProvider invalidate];\n+  }\n+  sharedProvider = nil;\n }\n \n // Override method of RCTEventEmitter\n-- (NSArray<NSString *> *)supportedEvents\n-{\n-    return @[\n-        RNCallKeepDidReceiveStartCallAction,\n-        RNCallKeepPerformAnswerCallAction,\n-        RNCallKeepPerformEndCallAction,\n-        RNCallKeepDidActivateAudioSession,\n-        RNCallKeepDidDeactivateAudioSession,\n-        RNCallKeepDidDisplayIncomingCall,\n-        RNCallKeepDidPerformSetMutedCallAction,\n-        RNCallKeepPerformPlayDTMFCallAction,\n-        RNCallKeepDidToggleHoldAction,\n-        RNCallKeepProviderReset,\n-        RNCallKeepCheckReachability,\n-        RNCallKeepDidLoadWithEvents\n-    ];\n-}\n-\n-- (void)startObserving\n-{\n-    _hasListeners = YES;\n-    if ([_delayedEvents count] > 0) {\n-        [self sendEventWithName:RNCallKeepDidLoadWithEvents body:_delayedEvents];\n+-(NSArray<NSString *> *) supportedEvents {\n+  return @[\n+    RNCallKeepDidReceiveStartCallAction,\n+    RNCallKeepPerformAnswerCallAction,\n+    RNCallKeepPerformEndCallAction,\n+    RNCallKeepDidActivateAudioSession,\n+    RNCallKeepDidDeactivateAudioSession,\n+    RNCallKeepDidDisplayIncomingCall,\n+    RNCallKeepDidPerformSetMutedCallAction,\n+    RNCallKeepPerformPlayDTMFCallAction,\n+    RNCallKeepDidToggleHoldAction,\n+    RNCallKeepProviderReset,\n+    RNCallKeepCheckReachability,\n+    RNCallKeepDidLoadWithEvents\n+  ];\n+}\n+\n+-(void) startObserving {\n+  _hasListeners = YES;\n+  if ([_delayedEvents count] > 0) {\n+    [self sendEventWithName:RNCallKeepDidLoadWithEvents body: _delayedEvents];\n+  }\n+}\n+\n+-(void) stopObserving {\n+  _hasListeners = FALSE;\n+}\n+\n+-(void) sendEventWithNameWrapper: (NSString *) name body: (id) body {\n+  if (onEventHandler != nil) {\n+    onEventHandler(name, body);\n+  }\n+\n+  if (_hasListeners) {\n+    [self sendEventWithName: name body: body];\n+  } else {\n+    NSDictionary *dictionary = @{\n+      @\"name\": name,\n+      @\"data\": body ? body : @{}\n+    };\n+    if (_delayedEvents == nil) {\n+      _delayedEvents = [NSMutableArray array];\n     }\n+    [_delayedEvents addObject: dictionary];\n+  }\n }\n \n-- (void)stopObserving\n-{\n-    _hasListeners = FALSE;\n-}\n+-(void) initCallKitProvider: (NSDictionary *) settings withEventHandler: (void (^) (NSString *, id)) onEvent {\n+  _version = [[[NSProcessInfo alloc] init] operatingSystemVersion];\n \n-- (void)sendEventWithNameWrapper:(NSString *)name body:(id)body {\n-    if (_hasListeners) {\n-        [self sendEventWithName:name body:body];\n-    } else {\n-        NSDictionary *dictionary = @{\n-            @\"name\": name,\n-            @\"data\": body\n-        };\n-        [_delayedEvents addObject:dictionary];\n-    }\n-}\n+  if (self.callKeepCallController == nil) {\n+    self.callKeepCallController = [[CXCallController alloc] init];\n+  }\n \n-+ (void)initCallKitProvider {\n-    if (sharedProvider == nil) {\n-        NSDictionary *settings = [[NSUserDefaults standardUserDefaults] dictionaryForKey:@\"RNCallKeepSettings\"];\n-        sharedProvider = [[CXProvider alloc] initWithConfiguration:[RNCallKeep getProviderConfiguration:settings]];\n-    }\n-}\n+  BOOL renewConfiguration = true;\n \n-RCT_EXPORT_METHOD(setup:(NSDictionary *)options)\n-{\n-#ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][setup] options = %@\", options);\n-#endif\n-    _version = [[[NSProcessInfo alloc] init] operatingSystemVersion];\n-    self.callKeepCallController = [[CXCallController alloc] init];\n-    NSDictionary *settings = [[NSMutableDictionary alloc] initWithDictionary:options];\n+  if (settings == nil) {\n+    // fallback, get the previous saved settings\n+    settings = [[NSUserDefaults standardUserDefaults] dictionaryForKey: @\"RNCallKeepSettings\"];\n+    renewConfiguration = false;\n+  } else {\n     // Store settings in NSUserDefault\n-    [[NSUserDefaults standardUserDefaults] setObject:settings forKey:@\"RNCallKeepSettings\"];\n+    [[NSUserDefaults standardUserDefaults] setObject: settings forKey: @\"RNCallKeepSettings\"];\n     [[NSUserDefaults standardUserDefaults] synchronize];\n+  }\n \n-    [RNCallKeep initCallKitProvider];\n+  if (renewConfiguration == true || sharedProvider == nil) {\n+    sharedProvider = [[CXProvider alloc] initWithConfiguration: [RNCallKeep getProviderConfiguration: settings ]];\n+  }\n \n-    self.callKeepProvider = sharedProvider;\n-    [self.callKeepProvider setDelegate:self queue:nil];\n+  if (onEvent != nil) {\n+    onEventHandler = onEvent;\n+  }\n+  self.callKeepProvider = sharedProvider;\n+  [self.callKeepProvider setDelegate: self queue: nil];\n+}\n+\n+RCT_EXPORT_METHOD(setup: (NSDictionary *) options) {\n+#ifdef DEBUG\n+  NSLog (@\"[RNCallKeep][setup] options = %@\", options);\n+#endif\n+\n+  // NSDictionary *settings = [[NSMutableDictionary alloc] initWithDictionary: options];\n+  // [self initCallKitProvider: settings];\n+  [self initCallKitProvider: options withEventHandler: nil];\n }\n \n RCT_REMAP_METHOD(checkIfBusy,\n-                 checkIfBusyWithResolver:(RCTPromiseResolveBlock)resolve\n-                 rejecter:(RCTPromiseRejectBlock)reject)\n-{\n+                 checkIfBusyWithResolver: (RCTPromiseResolveBlock) resolve\n+                 rejecter: (RCTPromiseRejectBlock) reject) {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][checkIfBusy]\");\n+  NSLog (@\"[RNCallKeep][checkIfBusy]\");\n #endif\n-    resolve(@(self.callKeepCallController.callObserver.calls.count > 0));\n+\n+  resolve(@(self.callKeepCallController.callObserver.calls.count > 0));\n }\n \n RCT_REMAP_METHOD(checkSpeaker,\n                  checkSpeakerResolver:(RCTPromiseResolveBlock)resolve\n-                 rejecter:(RCTPromiseRejectBlock)reject)\n-{\n+                 rejecter:(RCTPromiseRejectBlock)reject) {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][checkSpeaker]\");\n+  NSLog (@\"[RNCallKeep][checkSpeaker]\");\n #endif\n-    NSString *output = [AVAudioSession sharedInstance].currentRoute.outputs.count > 0 ? [AVAudioSession sharedInstance].currentRoute.outputs[0].portType : nil;\n-    resolve(@([output isEqualToString:@\"Speaker\"]));\n+\n+  NSString *output = [AVAudioSession sharedInstance].currentRoute.outputs.count > 0 ? [AVAudioSession sharedInstance].currentRoute.outputs[0].portType : nil;\n+  resolve(@([output isEqualToString:@\"Speaker\"]));\n }\n \n #pragma mark - CXCallController call actions\n \n // Display the incoming call to the user\n-RCT_EXPORT_METHOD(displayIncomingCall:(NSString *)uuidString\n-                               handle:(NSString *)handle\n-                           handleType:(NSString *)handleType\n-                             hasVideo:(BOOL)hasVideo\n-                  localizedCallerName:(NSString * _Nullable)localizedCallerName\n-                      supportsHolding:(BOOL)supportsHolding\n-                         supportsDTMF:(BOOL)supportsDTMF\n-                     supportsGrouping:(BOOL)supportsGrouping\n-                   supportsUngrouping:(BOOL)supportsUngrouping)            \n-{\n-    [RNCallKeep reportNewIncomingCall: uuidString\n-                               handle: handle\n-                           handleType: handleType\n-                             hasVideo: hasVideo\n-                  localizedCallerName: localizedCallerName\n-                      supportsHolding: supportsHolding\n-                         supportsDTMF: supportsDTMF\n-                     supportsGrouping: supportsGrouping\n-                   supportsUngrouping: supportsUngrouping\n-                          fromPushKit: NO\n-                              payload: nil\n-                withCompletionHandler: nil];\n-}\n-\n-RCT_EXPORT_METHOD(startCall:(NSString *)uuidString\n-                     handle:(NSString *)handle\n-          contactIdentifier:(NSString * _Nullable)contactIdentifier\n-                 handleType:(NSString *)handleType\n-                      video:(BOOL)video)\n-{\n+RCT_EXPORT_METHOD(displayIncomingCall: (NSString *) uuidString\n+                  handle: (NSString *) handle\n+                  handleType: (NSString *) handleType\n+                  hasVideo: (BOOL) hasVideo\n+                  localizedCallerName: (NSString * _Nullable) localizedCallerName\n+                  supportsHolding: (BOOL) supportsHolding\n+                  supportsDTMF: (BOOL) supportsDTMF\n+                  supportsGrouping: (BOOL) supportsGrouping\n+                  supportsUngrouping: (BOOL) supportsUngrouping) {\n+  [RNCallKeep reportNewIncomingCall: uuidString\n+                             handle: handle\n+                         handleType: handleType\n+                           hasVideo: hasVideo\n+                localizedCallerName: localizedCallerName\n+                    supportsHolding: supportsHolding\n+                       supportsDTMF: supportsDTMF\n+                   supportsGrouping: supportsGrouping\n+                 supportsUngrouping: supportsUngrouping\n+                        fromPushKit: NO\n+                            payload: nil\n+              withCompletionHandler: nil];\n+}\n+\n+RCT_EXPORT_METHOD(startCall: (NSString *) uuidString\n+                  handle: (NSString *) handle\n+                  contactIdentifier: (NSString * _Nullable) contactIdentifier\n+                  handleType: (NSString *) handleType\n+                  video: (BOOL) video) {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][startCall] uuidString = %@\", uuidString);\n+  NSLog (@\"[RNCallKeep][startCall] uuidString = %@\", uuidString);\n #endif\n-    int _handleType = [RNCallKeep getHandleType:handleType];\n-    NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];\n-    CXHandle *callHandle = [[CXHandle alloc] initWithType:_handleType value:handle];\n-    CXStartCallAction *startCallAction = [[CXStartCallAction alloc] initWithCallUUID:uuid handle:callHandle];\n-    [startCallAction setVideo:video];\n-    [startCallAction setContactIdentifier:contactIdentifier];\n \n-    CXTransaction *transaction = [[CXTransaction alloc] initWithAction:startCallAction];\n+  int _handleType = [RNCallKeep getHandleType: handleType];\n+  NSUUID *uuid = [[NSUUID alloc] initWithUUIDString: uuidString];\n+  CXHandle *callHandle = [[CXHandle alloc] initWithType: _handleType value: handle];\n+  CXStartCallAction *startCallAction = [[CXStartCallAction alloc] initWithCallUUID: uuid handle: callHandle];\n+  [startCallAction setVideo: video];\n+  [startCallAction setContactIdentifier: contactIdentifier];\n \n-    [self requestTransaction:transaction];\n+  CXTransaction *transaction = [[CXTransaction alloc] initWithAction: startCallAction];\n+\n+  [self requestTransaction: transaction];\n }\n \n-RCT_EXPORT_METHOD(answerIncomingCall:(NSString *)uuidString)\n-{\n+RCT_EXPORT_METHOD(endCall: (NSString *) uuidString) {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][answerIncomingCall] uuidString = %@\", uuidString);\n+  NSLog (@\"[RNCallKeep][endCall] uuidString = %@\", uuidString);\n #endif\n-    NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];\n-    CXAnswerCallAction *answerCallAction = [[CXAnswerCallAction alloc] initWithCallUUID:uuid];\n-    CXTransaction *transaction = [[CXTransaction alloc] init];\n-    [transaction addAction:answerCallAction];\n \n-    [self requestTransaction:transaction];\n+  NSUUID *uuid = [[NSUUID alloc] initWithUUIDString: uuidString];\n+  CXEndCallAction *endCallAction = [[CXEndCallAction alloc] initWithCallUUID: uuid];\n+  CXTransaction *transaction = [[CXTransaction alloc] initWithAction: endCallAction];\n+\n+  [self requestTransaction: transaction];\n }\n \n-RCT_EXPORT_METHOD(endCall:(NSString *)uuidString)\n-{\n+RCT_EXPORT_METHOD(endAllCalls) {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][endCall] uuidString = %@\", uuidString);\n+  NSLog (@\"[RNCallKeep][endAllCalls] calls = %@\", self.callKeepCallController.callObserver.calls);\n #endif\n-    NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];\n-    CXEndCallAction *endCallAction = [[CXEndCallAction alloc] initWithCallUUID:uuid];\n-    CXTransaction *transaction = [[CXTransaction alloc] initWithAction:endCallAction];\n \n-    [self requestTransaction:transaction];\n+  for (CXCall *call in self.callKeepCallController.callObserver.calls) {\n+    CXEndCallAction *endCallAction = [[CXEndCallAction alloc] initWithCallUUID: call.UUID];\n+    CXTransaction *transaction = [[CXTransaction alloc] initWithAction: endCallAction];\n+    [self requestTransaction: transaction];\n+  }\n }\n \n-RCT_EXPORT_METHOD(endAllCalls)\n-{\n+RCT_EXPORT_METHOD(setOnHold: (NSString *) uuidString : (BOOL) shouldHold) {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][endAllCalls] calls = %@\", self.callKeepCallController.callObserver.calls);\n+  NSLog (@\"[RNCallKeep][setOnHold] uuidString = %@, shouldHold = %d\", uuidString, shouldHold);\n #endif\n-    for (CXCall *call in self.callKeepCallController.callObserver.calls) {\n-        CXEndCallAction *endCallAction = [[CXEndCallAction alloc] initWithCallUUID:call.UUID];\n-        CXTransaction *transaction = [[CXTransaction alloc] initWithAction:endCallAction];\n-        [self requestTransaction:transaction];\n-    }\n-}\n \n-RCT_EXPORT_METHOD(setOnHold:(NSString *)uuidString :(BOOL)shouldHold)\n-{\n-#ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][setOnHold] uuidString = %@, shouldHold = %d\", uuidString, shouldHold);\n-#endif\n-    NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];\n-    CXSetHeldCallAction *setHeldCallAction = [[CXSetHeldCallAction alloc] initWithCallUUID:uuid onHold:shouldHold];\n-    CXTransaction *transaction = [[CXTransaction alloc] init];\n-    [transaction addAction:setHeldCallAction];\n+  NSUUID *uuid = [[NSUUID alloc] initWithUUIDString: uuidString];\n+  CXSetHeldCallAction *setHeldCallAction = [[CXSetHeldCallAction alloc] initWithCallUUID: uuid onHold: shouldHold];\n+  CXTransaction *transaction = [[CXTransaction alloc] init];\n+  [transaction addAction: setHeldCallAction];\n \n-    [self requestTransaction:transaction];\n+  [self requestTransaction: transaction];\n }\n \n-RCT_EXPORT_METHOD(_startCallActionEventListenerAdded)\n-{\n-    _isStartCallActionEventListenerAdded = YES;\n+RCT_EXPORT_METHOD(_startCallActionEventListenerAdded) {\n+  _isStartCallActionEventListenerAdded = YES;\n }\n \n-RCT_EXPORT_METHOD(reportConnectingOutgoingCallWithUUID:(NSString *)uuidString)\n-{\n-    NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];\n-    [self.callKeepProvider reportOutgoingCallWithUUID:uuid startedConnectingAtDate:[NSDate date]];\n+RCT_EXPORT_METHOD(reportConnectingOutgoingCallWithUUID:(NSString *)uuidString) {\n+  NSUUID *uuid = [[NSUUID alloc] initWithUUIDString: uuidString];\n+  [self.callKeepProvider reportOutgoingCallWithUUID: uuid startedConnectingAtDate: [NSDate date]];\n }\n \n-RCT_EXPORT_METHOD(reportConnectedOutgoingCallWithUUID:(NSString *)uuidString)\n+RCT_EXPORT_METHOD(reportConnectedOutgoingCallWithUUID: (NSString *) uuidString)\n {\n-    NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];\n-    [self.callKeepProvider reportOutgoingCallWithUUID:uuid connectedAtDate:[NSDate date]];\n+  NSUUID *uuid = [[NSUUID alloc] initWithUUIDString: uuidString];\n+  [self.callKeepProvider reportOutgoingCallWithUUID: uuid connectedAtDate: [NSDate date]];\n }\n \n-RCT_EXPORT_METHOD(reportEndCallWithUUID:(NSString *)uuidString :(int)reason)\n+RCT_EXPORT_METHOD(reportEndCallWithUUID: (NSString *)uuidString : (int) reason)\n {\n-    [RNCallKeep endCallWithUUID: uuidString reason:reason];\n+  [RNCallKeep endCallWithUUID: uuidString reason: reason];\n }\n \n-RCT_EXPORT_METHOD(updateDisplay:(NSString *)uuidString :(NSString *)displayName :(NSString *)uri :(NSDictionary *)options)\n-{\n+RCT_EXPORT_METHOD(updateDisplay: (NSString *) uuidString : (NSString *) displayName : (NSString *) uri : (NSDictionary *) options) {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][updateDisplay] uuidString = %@ displayName = %@ uri = %@\", uuidString, displayName, uri);\n+  NSLog (@\"[RNCallKeep][updateDisplay] uuidString = %@ displayName = %@ uri = %@\", uuidString, displayName, uri);\n #endif\n-    NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];\n-    CXHandle *callHandle = [[CXHandle alloc] initWithType:CXHandleTypePhoneNumber value:uri];\n-    CXCallUpdate *callUpdate = [[CXCallUpdate alloc] init];\n-    callUpdate.localizedCallerName = displayName;\n-    callUpdate.remoteHandle = callHandle;\n \n-    if ([options valueForKey:@\"hasVideo\"] != nil) {\n-        callUpdate.hasVideo = [RCTConvert BOOL:options[@\"hasVideo\"]];\n-    }\n-    if ([options valueForKey:@\"supportsHolding\"] != nil) {\n-        callUpdate.supportsHolding = [RCTConvert BOOL:options[@\"supportsHolding\"]];\n-    }\n-    if ([options valueForKey:@\"supportsDTMF\"] != nil) {\n-        callUpdate.supportsDTMF = [RCTConvert BOOL:options[@\"supportsDTMF\"]];\n-    }\n-    if ([options valueForKey:@\"supportsGrouping\"] != nil) {\n-        callUpdate.supportsGrouping = [RCTConvert BOOL:options[@\"supportsGrouping\"]];\n-    }\n-    if ([options valueForKey:@\"supportsUngrouping\"] != nil) {\n-        callUpdate.supportsUngrouping = [RCTConvert BOOL:options[@\"supportsUngrouping\"]];\n-    }\n+  NSUUID *uuid = [[NSUUID alloc] initWithUUIDString: uuidString];\n+  CXHandle *callHandle = [[CXHandle alloc] initWithType: CXHandleTypePhoneNumber value: uri];\n+  CXCallUpdate *callUpdate = [[CXCallUpdate alloc] init];\n+  callUpdate.localizedCallerName = displayName;\n+  callUpdate.remoteHandle = callHandle;\n+\n+  if ([options valueForKey: @\"hasVideo\"] != nil) {\n+    callUpdate.hasVideo = [RCTConvert BOOL: options[@\"hasVideo\"]];\n+  }\n+  if ([options valueForKey: @\"supportsHolding\"] != nil) {\n+    callUpdate.supportsHolding = [RCTConvert BOOL: options[@\"supportsHolding\"]];\n+  }\n+  if ([options valueForKey: @\"supportsDTMF\"] != nil) {\n+    callUpdate.supportsDTMF = [RCTConvert BOOL: options[@\"supportsDTMF\"]];\n+  }\n+  if ([options valueForKey: @\"supportsGrouping\"] != nil) {\n+    callUpdate.supportsGrouping = [RCTConvert BOOL: options[@\"supportsGrouping\"]];\n+  }\n+  if ([options valueForKey: @\"supportsUngrouping\"] != nil) {\n+    callUpdate.supportsUngrouping = [RCTConvert BOOL: options[@\"supportsUngrouping\"]];\n+  }\n \n-    [self.callKeepProvider reportCallWithUUID:uuid updated:callUpdate];\n+  [self.callKeepProvider reportCallWithUUID: uuid updated: callUpdate];\n }\n \n-RCT_EXPORT_METHOD(setMutedCall:(NSString *)uuidString :(BOOL)muted)\n-{\n+RCT_EXPORT_METHOD(setMutedCall: (NSString *) uuidString : (BOOL) muted) {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][setMutedCall] muted = %i\", muted);\n+  NSLog (@\"[RNCallKeep][setMutedCall] muted = %i\", muted);\n #endif\n-    NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];\n-    CXSetMutedCallAction *setMutedAction = [[CXSetMutedCallAction alloc] initWithCallUUID:uuid muted:muted];\n-    CXTransaction *transaction = [[CXTransaction alloc] init];\n-    [transaction addAction:setMutedAction];\n \n-    [self requestTransaction:transaction];\n+  NSUUID *uuid = [[NSUUID alloc] initWithUUIDString: uuidString];\n+  CXSetMutedCallAction *setMutedAction = [[CXSetMutedCallAction alloc] initWithCallUUID: uuid muted: muted];\n+  CXTransaction *transaction = [[CXTransaction alloc] init];\n+  [transaction addAction: setMutedAction];\n+\n+  [self requestTransaction: transaction];\n }\n \n-RCT_EXPORT_METHOD(sendDTMF:(NSString *)uuidString dtmf:(NSString *)key)\n-{\n+RCT_EXPORT_METHOD(sendDTMF: (NSString *) uuidString dtmf: (NSString *)key)  {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][sendDTMF] key = %@\", key);\n+  NSLog (@\"[RNCallKeep][sendDTMF] key = %@\", key);\n #endif\n-    NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];\n-    CXPlayDTMFCallAction *dtmfAction = [[CXPlayDTMFCallAction alloc] initWithCallUUID:uuid digits:key type:CXPlayDTMFCallActionTypeHardPause];\n-    CXTransaction *transaction = [[CXTransaction alloc] init];\n-    [transaction addAction:dtmfAction];\n \n-    [self requestTransaction:transaction];\n+  NSUUID *uuid = [[NSUUID alloc] initWithUUIDString: uuidString];\n+  CXPlayDTMFCallAction *dtmfAction = [[CXPlayDTMFCallAction alloc] initWithCallUUID: uuid digits: key type:CXPlayDTMFCallActionTypeHardPause];\n+  CXTransaction *transaction = [[CXTransaction alloc] init];\n+  [transaction addAction: dtmfAction];\n+\n+  [self requestTransaction: transaction];\n }\n \n-RCT_EXPORT_METHOD(isCallActive:(NSString *)uuidString\n-                  isCallActiveResolver:(RCTPromiseResolveBlock)resolve\n-                  rejecter:(RCTPromiseRejectBlock)reject)\n-{\n+RCT_EXPORT_METHOD(isCallActive:(NSString *)uuidString) {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][isCallActive] uuid = %@\", uuidString);\n+  NSLog (@\"[RNCallKeep][isCallActive] uuid = %@\", uuidString);\n #endif\n-    BOOL isActive = [RNCallKeep isCallActive: uuidString];\n-    if (isActive) {\n-        resolve(@YES);\n-    } else {\n-        resolve(@NO);\n-    }\n+\n+  [RNCallKeep isCallActive: uuidString];\n }\n \n-RCT_EXPORT_METHOD(getCalls:(RCTPromiseResolveBlock)resolve\n-                  rejecter:(RCTPromiseRejectBlock)reject)\n-{\n+RCT_EXPORT_METHOD(getCalls: (RCTPromiseResolveBlock)resolve\n+                  rejecter: (RCTPromiseRejectBlock)reject) {\n #ifdef DEBUG\n     NSLog(@\"[RNCallKeep][getCalls]\");\n #endif\n     resolve([RNCallKeep getCalls]);\n }\n \n-- (void)requestTransaction:(CXTransaction *)transaction\n-{\n+-(void) requestTransaction: (CXTransaction *) transaction {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][requestTransaction] transaction = %@\", transaction);\n+  NSLog (@\"[RNCallKeep][requestTransaction] transaction = %@\", transaction);\n #endif\n-    if (self.callKeepCallController == nil) {\n-        self.callKeepCallController = [[CXCallController alloc] init];\n-    }\n-    [self.callKeepCallController requestTransaction:transaction completion:^(NSError * _Nullable error) {\n-        if (error != nil) {\n-            NSLog(@\"[RNCallKeep][requestTransaction] Error requesting transaction (%@): (%@)\", transaction.actions, error);\n-        } else {\n-            NSLog(@\"[RNCallKeep][requestTransaction] Requested transaction successfully\");\n-\n-            // CXStartCallAction\n-            if ([[transaction.actions firstObject] isKindOfClass:[CXStartCallAction class]]) {\n-                CXStartCallAction *startCallAction = [transaction.actions firstObject];\n-                CXCallUpdate *callUpdate = [[CXCallUpdate alloc] init];\n-                callUpdate.remoteHandle = startCallAction.handle;\n-                callUpdate.hasVideo = startCallAction.video;\n-                callUpdate.localizedCallerName = startCallAction.contactIdentifier;\n-                callUpdate.supportsDTMF = YES;\n-                callUpdate.supportsHolding = YES;\n-                callUpdate.supportsGrouping = YES;\n-                callUpdate.supportsUngrouping = YES;\n-                [self.callKeepProvider reportCallWithUUID:startCallAction.callUUID updated:callUpdate];\n-            }\n-        }\n-    }];\n-}\n \n-+ (BOOL)isCallActive:(NSString *)uuidString\n-{\n-    CXCallObserver *callObserver = [[CXCallObserver alloc] init];\n-    NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];\n-\n-    for(CXCall *call in callObserver.calls){\n-        NSLog(@\"[RNCallKeep] isCallActive %@ %d ?\", call.UUID, [call.UUID isEqual:uuid]);\n-        if([call.UUID isEqual:[[NSUUID alloc] initWithUUIDString:uuidString]]){\n-            return call.hasConnected;\n-        }\n+  if (self.callKeepCallController == nil) {\n+    self.callKeepCallController = [[CXCallController alloc] init];\n+  }\n+  [self.callKeepCallController requestTransaction: transaction completion: ^(NSError * _Nullable error) {\n+    if (error != nil) {\n+      NSLog (@\"[RNCallKeep][requestTransaction] Error requesting transaction (%@): (%@)\", transaction.actions, error);\n+    } else {\n+      NSLog (@\"[RNCallKeep][requestTransaction] Requested transaction successfully\");\n+\n+      // CXStartCallAction\n+      if ([[transaction.actions firstObject] isKindOfClass: [CXStartCallAction class]]) {\n+        CXStartCallAction *startCallAction = [transaction.actions firstObject];\n+        CXCallUpdate *callUpdate = [[CXCallUpdate alloc] init];\n+        callUpdate.remoteHandle = startCallAction.handle;\n+        callUpdate.hasVideo = startCallAction.video;\n+        callUpdate.localizedCallerName = startCallAction.contactIdentifier;\n+        callUpdate.supportsDTMF = YES;\n+        callUpdate.supportsHolding = YES;\n+        callUpdate.supportsGrouping = YES;\n+        callUpdate.supportsUngrouping = YES;\n+        [self.callKeepProvider reportCallWithUUID:startCallAction.callUUID updated:callUpdate];\n+      }\n     }\n-    return false;\n+  }];\n }\n \n-+ (NSMutableArray *) getCalls\n-{\n-#ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][getCalls]\");\n-#endif\n-    CXCallObserver *callObserver = [[CXCallObserver alloc] init];\n-    NSMutableArray *currentCalls = [NSMutableArray array];\n-    for(CXCall *call in callObserver.calls){\n-        NSString *uuidString = [call.UUID UUIDString];\n-        NSDictionary *requestedCall= @{\n-           @\"callUUID\": uuidString,\n-           @\"outgoing\": call.outgoing? @YES : @NO,\n-           @\"onHold\": call.onHold? @YES : @NO,\n-           @\"hasConnected\": call.hasConnected ? @YES : @NO,\n-           @\"hasEnded\": call.hasEnded ? @YES : @NO\n-        };\n-        [currentCalls addObject:requestedCall];\n-    }\n-    return currentCalls;\n-}\n++(BOOL) isCallActive: (NSString *) uuidString {\n+  CXCallObserver *callObserver = [[CXCallObserver alloc] init];\n+  NSUUID *uuid = [[NSUUID alloc] initWithUUIDString: uuidString];\n \n-+ (void)endCallWithUUID:(NSString *)uuidString\n-                 reason:(int)reason\n-{\n-#ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][reportEndCallWithUUID] uuidString = %@ reason = %d\", uuidString, reason);\n-#endif\n-    NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];\n-    switch (reason) {\n-        case 1:\n-            [sharedProvider reportCallWithUUID:uuid endedAtDate:[NSDate date] reason:CXCallEndedReasonFailed];\n-            break;\n-        case 2:\n-        case 6:\n-            [sharedProvider reportCallWithUUID:uuid endedAtDate:[NSDate date] reason:CXCallEndedReasonRemoteEnded];\n-            break;\n-        case 3:\n-            [sharedProvider reportCallWithUUID:uuid endedAtDate:[NSDate date] reason:CXCallEndedReasonUnanswered];\n-            break;\n-        case 4:\n-            [sharedProvider reportCallWithUUID:uuid endedAtDate:[NSDate date] reason:CXCallEndedReasonAnsweredElsewhere];\n-            break;\n-        case 5:\n-            [sharedProvider reportCallWithUUID:uuid endedAtDate:[NSDate date] reason:CXCallEndedReasonDeclinedElsewhere];\n-            break;\n-        default:\n-            break;\n+  for (CXCall *call in callObserver.calls) {\n+    NSLog (@\"[RNCallKeep] isCallActive %@ %d ?\", call.UUID, [call.UUID isEqual: uuid]);\n+\n+    if ([call.UUID isEqual: [[NSUUID alloc] initWithUUIDString: uuidString]] && !call.hasConnected){\n+      return true;\n     }\n+  }\n+  return false;\n }\n \n-+ (void)reportNewIncomingCall:(NSString *)uuidString\n-                       handle:(NSString *)handle\n-                   handleType:(NSString *)handleType\n-                     hasVideo:(BOOL)hasVideo\n-          localizedCallerName:(NSString * _Nullable)localizedCallerName\n-              supportsHolding:(BOOL)supportsHolding\n-                 supportsDTMF:(BOOL)supportsDTMF\n-             supportsGrouping:(BOOL)supportsGrouping\n-           supportsUngrouping:(BOOL)supportsUngrouping\n-                  fromPushKit:(BOOL)fromPushKit\n-                      payload:(NSDictionary * _Nullable)payload\n-        withCompletionHandler:(void (^_Nullable)(void))completion\n-{\n++(NSMutableArray *) getCalls {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][reportNewIncomingCall] uuidString = %@\", uuidString);\n-#endif\n-    int _handleType = [RNCallKeep getHandleType:handleType];\n-    NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];\n-    CXCallUpdate *callUpdate = [[CXCallUpdate alloc] init];\n-    callUpdate.remoteHandle = [[CXHandle alloc] initWithType:_handleType value:handle];\n-    callUpdate.supportsHolding = supportsHolding;\n-    callUpdate.supportsDTMF = supportsDTMF;\n-    callUpdate.supportsGrouping = supportsGrouping;\n-    callUpdate.supportsUngrouping = supportsUngrouping;\n-    callUpdate.hasVideo = hasVideo;\n-    callUpdate.localizedCallerName = localizedCallerName;\n-\n-    [RNCallKeep initCallKitProvider];\n-    [sharedProvider reportNewIncomingCallWithUUID:uuid update:callUpdate completion:^(NSError * _Nullable error) {\n-        RNCallKeep *callKeep = [RNCallKeep allocWithZone: nil];\n-        [callKeep sendEventWithNameWrapper:RNCallKeepDidDisplayIncomingCall body:@{\n-            @\"error\": error && error.localizedDescription ? error.localizedDescription : @\"\",\n-            @\"callUUID\": uuidString,\n-            @\"handle\": handle,\n-            @\"localizedCallerName\": localizedCallerName ? localizedCallerName : @\"\",\n-            @\"hasVideo\": hasVideo ? @\"1\" : @\"0\",\n-            @\"supportsHolding\": supportsHolding ? @\"1\" : @\"0\",\n-            @\"supportsDTMF\": supportsDTMF ? @\"1\" : @\"0\",\n-            @\"supportsGrouping\": supportsGrouping ? @\"1\" : @\"0\",\n-            @\"supportsUngrouping\": supportsUngrouping ? @\"1\" : @\"0\",\n-            @\"fromPushKit\": fromPushKit ? @\"1\" : @\"0\",\n-            @\"payload\": payload ? payload : @\"\",\n-        }];\n-        if (error == nil) {\n-            // Workaround per https://forums.developer.apple.com/message/169511\n-            if ([callKeep lessThanIos10_2]) {\n-                [callKeep configureAudioSession];\n-            }\n-        }\n-        if (completion != nil) {\n-            completion();\n-        }\n+  NSLog(@\"[RNCallKeep][getCalls]\");\n+#endif\n+  CXCallObserver *callObserver = [[CXCallObserver alloc] init];\n+  NSMutableArray *currentCalls = [NSMutableArray array];\n+  for (CXCall *call in callObserver.calls) {\n+    NSString *uuidString = [call.UUID UUIDString];\n+    NSDictionary *requestedCall= @{\n+      @\"callUUID\": uuidString,\n+      @\"outgoing\": call.outgoing? @YES : @NO,\n+      @\"onHold\": call.onHold? @YES : @NO,\n+      @\"hasConnected\": call.hasConnected ? @YES : @NO,\n+      @\"hasEnded\": call.hasEnded ? @YES : @NO\n+    };\n+    [currentCalls addObject: requestedCall];\n+  }\n+  return currentCalls;\n+}\n+\n++(void) endCallWithUUID: (NSString *) uuidString\n+                 reason: (int) reason {\n+#ifdef DEBUG\n+  NSLog (@\"[RNCallKeep][reportEndCallWithUUID] uuidString = %@ reason = %d\", uuidString, reason);\n+#endif\n+\n+  NSUUID *uuid = [[NSUUID alloc] initWithUUIDString: uuidString];\n+  switch (reason) {\n+    case 1:\n+      [sharedProvider reportCallWithUUID: uuid endedAtDate: [NSDate date] reason: CXCallEndedReasonFailed];\n+      break;\n+    case 2:\n+    case 6:\n+      [sharedProvider reportCallWithUUID: uuid endedAtDate: [NSDate date] reason: CXCallEndedReasonRemoteEnded];\n+      break;\n+    case 3:\n+      [sharedProvider reportCallWithUUID: uuid endedAtDate: [NSDate date] reason: CXCallEndedReasonUnanswered];\n+      break;\n+    case 4:\n+      [sharedProvider reportCallWithUUID: uuid endedAtDate: [NSDate date] reason: CXCallEndedReasonAnsweredElsewhere];\n+      break;\n+    case 5:\n+      [sharedProvider reportCallWithUUID: uuid endedAtDate: [NSDate date] reason: CXCallEndedReasonDeclinedElsewhere];\n+      break;\n+    default:\n+      break;\n+  }\n+}\n+\n++(void) reportNewIncomingCall: (NSString *) uuidString\n+                       handle: (NSString *) handle\n+                   handleType: (NSString *) handleType\n+                     hasVideo: (BOOL) hasVideo\n+          localizedCallerName: (NSString * _Nullable) localizedCallerName\n+              supportsHolding: (BOOL) supportsHolding\n+                 supportsDTMF: (BOOL) supportsDTMF\n+             supportsGrouping: (BOOL) supportsGrouping\n+           supportsUngrouping: (BOOL) supportsUngrouping\n+                  fromPushKit: (BOOL) fromPushKit\n+                      payload: (NSDictionary * _Nullable) payload\n+        withCompletionHandler: (void (^_Nullable) (void)) completion {\n+#ifdef DEBUG\n+  NSLog (@\"[RNCallKeep][reportNewIncomingCall] uuidString = %@\", uuidString);\n+#endif\n+\n+  int _handleType = [RNCallKeep getHandleType: handleType];\n+  NSUUID *uuid = [[NSUUID alloc] initWithUUIDString: uuidString];\n+  CXCallUpdate *callUpdate = [[CXCallUpdate alloc] init];\n+  callUpdate.remoteHandle = [[CXHandle alloc] initWithType: _handleType value: handle];\n+  callUpdate.supportsHolding = supportsHolding;\n+  callUpdate.supportsDTMF = supportsDTMF;\n+  callUpdate.supportsGrouping = supportsGrouping;\n+  callUpdate.supportsUngrouping = supportsUngrouping;\n+  callUpdate.hasVideo = hasVideo;\n+  callUpdate.localizedCallerName = localizedCallerName;\n+\n+  RNCallKeep *callKeep = [RNCallKeep allocWithZone: nil];\n+\n+  if (callKeep.callKeepProvider == nil) {\n+    [callKeep initCallKitProvider: nil withEventHandler: nil];\n+  }\n+\n+  [callKeep.callKeepProvider reportNewIncomingCallWithUUID: uuid update: callUpdate completion: ^(NSError * _Nullable error) {\n+    [callKeep sendEventWithNameWrapper: RNCallKeepDidDisplayIncomingCall body:@{\n+      @\"error\": error && error.localizedDescription ? error.localizedDescription : @\"\",\n+      @\"callUUID\": uuidString,\n+      @\"handle\": handle,\n+      @\"localizedCallerName\": localizedCallerName ? localizedCallerName : @\"\",\n+      @\"hasVideo\": hasVideo ? @\"1\" : @\"0\",\n+      @\"supportsHolding\": supportsHolding ? @\"1\" : @\"0\",\n+      @\"supportsDTMF\": supportsDTMF ? @\"1\" : @\"0\",\n+      @\"supportsGrouping\": supportsGrouping ? @\"1\" : @\"0\",\n+      @\"supportsUngrouping\": supportsUngrouping ? @\"1\" : @\"0\",\n+      @\"fromPushKit\": fromPushKit ? @\"1\" : @\"0\",\n+      @\"payload\": payload ? payload : @\"\",\n     }];\n-}\n \n-- (BOOL)lessThanIos10_2\n-{\n-    if (_version.majorVersion < 10) {\n-        return YES;\n-    } else if (_version.majorVersion > 10) {\n-        return NO;\n-    } else {\n-        return _version.minorVersion < 2;\n+    if (error == nil) {\n+      // Workaround per https://forums.developer.apple.com/message/169511\n+      if ([callKeep lessThanIos10_2]) {\n+        [callKeep configureAudioSession];\n+      }\n     }\n-}\n-\n-+ (int)getHandleType:(NSString *)handleType\n-{\n-    int _handleType;\n-    if ([handleType isEqualToString:@\"generic\"]) {\n-        _handleType = CXHandleTypeGeneric;\n-    } else if ([handleType isEqualToString:@\"number\"]) {\n-        _handleType = CXHandleTypePhoneNumber;\n-    } else if ([handleType isEqualToString:@\"email\"]) {\n-        _handleType = CXHandleTypeEmailAddress;\n-    } else {\n-        _handleType = CXHandleTypeGeneric;\n+    if (completion != nil) {\n+      completion();\n     }\n-    return _handleType;\n+  }];\n }\n \n-+ (CXProviderConfiguration *)getProviderConfiguration:(NSDictionary*)settings\n-{\n-#ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][getProviderConfiguration]\");\n-#endif\n-    CXProviderConfiguration *providerConfiguration = [[CXProviderConfiguration alloc] initWithLocalizedName:settings[@\"appName\"]];\n-    providerConfiguration.supportsVideo = YES;\n-    providerConfiguration.maximumCallGroups = 3;\n-    providerConfiguration.maximumCallsPerCallGroup = 1;\n-    if(settings[@\"handleType\"]){\n-        int _handleType = [RNCallKeep getHandleType:settings[@\"handleType\"]];\n-        providerConfiguration.supportedHandleTypes = [NSSet setWithObjects:[NSNumber numberWithInteger:_handleType], nil];\n-    }else{\n-        providerConfiguration.supportedHandleTypes = [NSSet setWithObjects:[NSNumber numberWithInteger:CXHandleTypePhoneNumber], nil];\n-    }\n-    if (settings[@\"supportsVideo\"]) {\n-        providerConfiguration.supportsVideo = [settings[@\"supportsVideo\"] boolValue];\n-    }\n-    if (settings[@\"maximumCallGroups\"]) {\n-        providerConfiguration.maximumCallGroups = [settings[@\"maximumCallGroups\"] integerValue];\n-    }\n-    if (settings[@\"maximumCallsPerCallGroup\"]) {\n-        providerConfiguration.maximumCallsPerCallGroup = [settings[@\"maximumCallsPerCallGroup\"] integerValue];\n-    }\n-    if (settings[@\"imageName\"]) {\n-        providerConfiguration.iconTemplateImageData = UIImagePNGRepresentation([UIImage imageNamed:settings[@\"imageName\"]]);\n-    }\n-    if (settings[@\"ringtoneSound\"]) {\n-        providerConfiguration.ringtoneSound = settings[@\"ringtoneSound\"];\n-    }\n-    if (@available(iOS 11.0, *)) {\n-        if (settings[@\"includesCallsInRecents\"]) {\n-            providerConfiguration.includesCallsInRecents = [settings[@\"includesCallsInRecents\"] boolValue];\n-        }\n+-(BOOL) lessThanIos10_2 {\n+  if (_version.majorVersion < 10) {\n+    return YES;\n+  }\n+\n+  if (_version.majorVersion > 10) {\n+    return NO;\n+  }\n+\n+  return _version.minorVersion < 2;\n+}\n+\n++(int) getHandleType: (NSString *) handleType {\n+  if ([handleType isEqualToString:@\"generic\"]) {\n+    return CXHandleTypeGeneric;\n+  }\n+\n+  if ([handleType isEqualToString:@\"number\"]) {\n+    return CXHandleTypePhoneNumber;\n+  }\n+\n+  if ([handleType isEqualToString:@\"email\"]) {\n+    return CXHandleTypeEmailAddress;\n+  }\n+\n+  return CXHandleTypeGeneric;\n+}\n+\n++(CXProviderConfiguration *) getProviderConfiguration: (NSDictionary*) settings {\n+#ifdef DEBUG\n+  NSLog (@\"[RNCallKeep][getProviderConfiguration]\");\n+#endif\n+\n+  NSString *localizedName = @\"unknown\";\n+  if (settings && settings[@\"appName\"]) {\n+    localizedName =settings[@\"appName\"];\n+  }\n+\n+  CXProviderConfiguration *providerConfiguration = [[CXProviderConfiguration alloc] initWithLocalizedName: localizedName];\n+  providerConfiguration.supportsVideo = YES;\n+  providerConfiguration.maximumCallGroups = 3;\n+  providerConfiguration.maximumCallsPerCallGroup = 1;\n+\n+  if(settings[@\"handleType\"]){\n+    int _handleType = [RNCallKeep getHandleType: settings[@\"handleType\"]];\n+    providerConfiguration.supportedHandleTypes = [NSSet setWithObjects: [NSNumber numberWithInteger: _handleType], nil];\n+  } else {\n+    providerConfiguration.supportedHandleTypes = [NSSet setWithObjects: [NSNumber numberWithInteger: CXHandleTypePhoneNumber], nil];\n+  }\n+  if (settings[@\"supportsVideo\"]) {\n+    providerConfiguration.supportsVideo = [settings[@\"supportsVideo\"] boolValue];\n+  }\n+  if (settings[@\"maximumCallGroups\"]) {\n+    providerConfiguration.maximumCallGroups = [settings[@\"maximumCallGroups\"] integerValue];\n+  }\n+  if (settings[@\"maximumCallsPerCallGroup\"]) {\n+    providerConfiguration.maximumCallsPerCallGroup = [settings[@\"maximumCallsPerCallGroup\"] integerValue];\n+  }\n+  if (settings[@\"imageName\"]) {\n+    providerConfiguration.iconTemplateImageData = UIImagePNGRepresentation([UIImage imageNamed: settings[@\"imageName\"]]);\n+  }\n+  if (settings[@\"ringtoneSound\"]) {\n+    providerConfiguration.ringtoneSound = settings[@\"ringtoneSound\"];\n+  }\n+  if (@available(iOS 11.0, *)) {\n+    if (settings[@\"includesCallsInRecents\"]) {\n+      providerConfiguration.includesCallsInRecents = [settings[@\"includesCallsInRecents\"] boolValue];\n     }\n-    return providerConfiguration;\n+  }\n+  return providerConfiguration;\n }\n \n-- (void)configureAudioSession\n-{\n+-(void) configureAudioSession {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][configureAudioSession] Activating audio session\");\n+  NSLog (@\"[RNCallKeep][configureAudioSession] Activating audio session\");\n #endif\n \n-    AVAudioSession* audioSession = [AVAudioSession sharedInstance];\n-    [audioSession setCategory:AVAudioSessionCategoryPlayAndRecord withOptions:AVAudioSessionCategoryOptionAllowBluetooth error:nil];\n+  AVAudioSession* audioSession = [AVAudioSession sharedInstance];\n+  [audioSession setCategory: AVAudioSessionCategoryPlayAndRecord withOptions: AVAudioSessionCategoryOptionAllowBluetooth error: nil];\n \n-    [audioSession setMode:AVAudioSessionModeVoiceChat error:nil];\n+  [audioSession setMode: AVAudioSessionModeVoiceChat error: nil];\n \n-    double sampleRate = 44100.0;\n-    [audioSession setPreferredSampleRate:sampleRate error:nil];\n+  double sampleRate = 44100.0;\n+  [audioSession setPreferredSampleRate: sampleRate error: nil];\n \n-    NSTimeInterval bufferDuration = .005;\n-    [audioSession setPreferredIOBufferDuration:bufferDuration error:nil];\n-    [audioSession setActive:TRUE error:nil];\n+  NSTimeInterval bufferDuration = .005;\n+  [audioSession setPreferredIOBufferDuration:bufferDuration error: nil];\n+  [audioSession setActive: TRUE error: nil];\n }\n \n-+ (BOOL)application:(UIApplication *)application\n-            openURL:(NSURL *)url\n-            options:(NSDictionary<UIApplicationOpenURLOptionsKey, id> *)options NS_AVAILABLE_IOS(9_0)\n-{\n++(BOOL) application: (UIApplication *) application\n+            openURL: (NSURL *) url\n+            options: (NSDictionary<UIApplicationOpenURLOptionsKey, id> *) options NS_AVAILABLE_IOS(9_0) {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][application:openURL]\");\n-#endif\n-    /*\n-    NSString *handle = [url startCallHandle];\n-    if (handle != nil && handle.length > 0 ){\n-        NSDictionary *userInfo = @{\n-            @\"handle\": handle,\n-            @\"video\": @NO\n-        };\n-        [[NSNotificationCenter defaultCenter] postNotificationName:RNCallKeepHandleStartCallNotification\n-                                                            object:self\n-                                                          userInfo:userInfo];\n-        return YES;\n-    }\n-    return NO;\n-    */\n-    return YES;\n+  NSLog (@\"[RNCallKeep][application:openURL]\");\n+#endif\n+\n+  /*\n+   NSString *handle = [url startCallHandle];\n+   if (handle != nil && handle.length > 0 ){\n+   NSDictionary *userInfo = @{\n+   @\"handle\": handle,\n+   @\"video\": @NO\n+   };\n+   [[NSNotificationCenter defaultCenter] postNotificationName:RNCallKeepHandleStartCallNotification\n+   object:self\n+   userInfo:userInfo];\n+   return YES;\n+   }\n+   return NO;\n+   */\n+  return YES;\n }\n \n-+ (BOOL)application:(UIApplication *)application\n-continueUserActivity:(NSUserActivity *)userActivity\n- restorationHandler:(void(^)(NSArray * __nullable restorableObjects))restorationHandler\n-{\n++(BOOL) application: (UIApplication *) application\n+continueUserActivity: (NSUserActivity *) userActivity\n+ restorationHandler: (void(^)(NSArray * __nullable restorableObjects)) restorationHandler {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][application:continueUserActivity]\");\n+  NSLog (@\"[RNCallKeep][application:continueUserActivity]\");\n #endif\n-    INInteraction *interaction = userActivity.interaction;\n-    INPerson *contact;\n-    NSString *handle;\n-    BOOL isAudioCall;\n-    BOOL isVideoCall;\n \n-//HACK TO AVOID XCODE 10 COMPILE CRASH\n-//REMOVE ON NEXT MAJOR RELEASE OF RNCALLKIT\n+  INInteraction *interaction = userActivity.interaction;\n+  INPerson *contact;\n+  NSString *handle;\n+  BOOL isAudioCall;\n+  BOOL isVideoCall;\n+\n+  //HACK TO AVOID XCODE 10 COMPILE CRASH\n+  //REMOVE ON NEXT MAJOR RELEASE OF RNCALLKIT\n #if __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000\n-    //XCode 11\n-    // iOS 13 returns an INStartCallIntent userActivity type\n-    if (@available(iOS 13, *)) {\n-        INStartCallIntent *intent = (INStartCallIntent*)interaction.intent;\n-        // callCapability is not available on iOS > 13.2, but it is in 13.1 weirdly...\n-        if ([intent respondsToSelector:@selector(callCapability)]) {\n-            isAudioCall = intent.callCapability == INCallCapabilityAudioCall;\n-            isVideoCall = intent.callCapability == INCallCapabilityVideoCall;\n-        } else {\n-            isAudioCall = [userActivity.activityType isEqualToString:INStartAudioCallIntentIdentifier];\n-            isVideoCall = [userActivity.activityType isEqualToString:INStartVideoCallIntentIdentifier];\n-        }\n+  //XCode 11\n+  // iOS 13 returns an INStartCallIntent userActivity type\n+  if (@available(iOS 13, *)) {\n+    INStartCallIntent *intent = (INStartCallIntent*) interaction.intent;\n+    // callCapability is not available on iOS > 13.2, but it is in 13.1 weirdly...\n+    if ([intent respondsToSelector: @selector(callCapability)]) {\n+      isAudioCall = intent.callCapability == INCallCapabilityAudioCall;\n+      isVideoCall = intent.callCapability == INCallCapabilityVideoCall;\n     } else {\n+      isAudioCall = [userActivity.activityType isEqualToString: INStartAudioCallIntentIdentifier];\n+      isVideoCall = [userActivity.activityType isEqualToString: INStartVideoCallIntentIdentifier];\n+    }\n+  } else {\n #endif\n-        //XCode 10 and below\n-        isAudioCall = [userActivity.activityType isEqualToString:INStartAudioCallIntentIdentifier];\n-        isVideoCall = [userActivity.activityType isEqualToString:INStartVideoCallIntentIdentifier];\n-//HACK TO AVOID XCODE 10 COMPILE CRASH\n-//REMOVE ON NEXT MAJOR RELEASE OF RNCALLKIT\n+    //XCode 10 and below\n+    isAudioCall = [userActivity.activityType isEqualToString: INStartAudioCallIntentIdentifier];\n+    isVideoCall = [userActivity.activityType isEqualToString: INStartVideoCallIntentIdentifier];\n+    //HACK TO AVOID XCODE 10 COMPILE CRASH\n+    //REMOVE ON NEXT MAJOR RELEASE OF RNCALLKIT\n #if __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000\n-    }\n+  }\n #endif\n \n-    if (isAudioCall) {\n-        INStartAudioCallIntent *startAudioCallIntent = (INStartAudioCallIntent *)interaction.intent;\n-        contact = [startAudioCallIntent.contacts firstObject];\n-    } else if (isVideoCall) {\n-        INStartVideoCallIntent *startVideoCallIntent = (INStartVideoCallIntent *)interaction.intent;\n-        contact = [startVideoCallIntent.contacts firstObject];\n-    }\n+  if (isAudioCall) {\n+    INStartAudioCallIntent *startAudioCallIntent = (INStartAudioCallIntent *) interaction.intent;\n+    contact = [startAudioCallIntent.contacts firstObject];\n+  } else if (isVideoCall) {\n+    INStartVideoCallIntent *startVideoCallIntent = (INStartVideoCallIntent *) interaction.intent;\n+    contact = [startVideoCallIntent.contacts firstObject];\n+  }\n \n-    if (contact != nil) {\n-        handle = contact.personHandle.value;\n-    }\n+  if (contact != nil) {\n+    handle = contact.personHandle.value;\n+  }\n \n-    if (handle != nil && handle.length > 0 ){\n-        NSDictionary *userInfo = @{\n-            @\"handle\": handle,\n-            @\"video\": @(isVideoCall)\n-        };\n+  if (handle != nil && handle.length > 0 ){\n+    NSDictionary *userInfo = @{\n+      @\"handle\": handle,\n+      @\"video\": @(isVideoCall)\n+    };\n \n-        RNCallKeep *callKeep = [RNCallKeep allocWithZone: nil];\n-        [callKeep sendEventWithNameWrapper:RNCallKeepDidReceiveStartCallAction body:userInfo];\n-        return YES;\n-    }\n-    return NO;\n+    RNCallKeep *callKeep = [RNCallKeep allocWithZone: nil];\n+    [callKeep sendEventWithNameWrapper: RNCallKeepDidReceiveStartCallAction body: userInfo];\n+    return YES;\n+  }\n+  return NO;\n }\n \n-+ (BOOL)requiresMainQueueSetup\n-{\n-    return YES;\n++(BOOL) requiresMainQueueSetup {\n+  return YES;\n }\n \n #pragma mark - CXProviderDelegate\n \n-- (void)providerDidReset:(CXProvider *)provider{\n+-(void) providerDidReset: (CXProvider *) provider {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][providerDidReset]\");\n+  NSLog (@\"[RNCallKeep][providerDidReset]\");\n #endif\n-    //this means something big changed, so tell the JS. The JS should\n-    //probably respond by hanging up all calls.\n-    [self sendEventWithNameWrapper:RNCallKeepProviderReset body:nil];\n+\n+  //this means something big changed, so tell the JS. The JS should\n+  //probably respond by hanging up all calls.\n+  [self sendEventWithNameWrapper:RNCallKeepProviderReset body: nil];\n }\n \n // Starting outgoing call\n-- (void)provider:(CXProvider *)provider performStartCallAction:(CXStartCallAction *)action\n-{\n+-(void) provider: (CXProvider *) provider performStartCallAction: (CXStartCallAction *) action {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][CXProviderDelegate][provider:performStartCallAction]\");\n+  NSLog (@\"[RNCallKeep][CXProviderDelegate][provider:performStartCallAction]\");\n #endif\n-    //do this first, audio sessions are flakey\n-    [self configureAudioSession];\n-    //tell the JS to actually make the call\n-    [self sendEventWithNameWrapper:RNCallKeepDidReceiveStartCallAction body:@{ @\"callUUID\": [action.callUUID.UUIDString lowercaseString], @\"handle\": action.handle.value }];\n-    [action fulfill];\n+\n+  //do this first, audio sessions are flakey\n+  [self configureAudioSession];\n+  //tell the JS to actually make the call\n+  [self sendEventWithNameWrapper: RNCallKeepDidReceiveStartCallAction body: @{\n+    @\"callUUID\": [action.callUUID.UUIDString lowercaseString],\n+    @\"handle\": action.handle.value\n+  }];\n+  [action fulfill];\n }\n \n // Update call contact info\n // @deprecated\n-RCT_EXPORT_METHOD(reportUpdatedCall:(NSString *)uuidString contactIdentifier:(NSString *)contactIdentifier)\n-{\n+RCT_EXPORT_METHOD(reportUpdatedCall: (NSString *) uuidString contactIdentifier: (NSString *)contactIdentifier) {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][reportUpdatedCall] contactIdentifier = %i\", contactIdentifier);\n+  NSLog (@\"[RNCallKeep][reportUpdatedCall] contactIdentifier = %i\", contactIdentifier);\n #endif\n-    NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];\n-    CXCallUpdate *callUpdate = [[CXCallUpdate alloc] init];\n-    callUpdate.localizedCallerName = contactIdentifier;\n \n-    [self.callKeepProvider reportCallWithUUID:uuid updated:callUpdate];\n+  NSUUID *uuid = [[NSUUID alloc] initWithUUIDString: uuidString];\n+  CXCallUpdate *callUpdate = [[CXCallUpdate alloc] init];\n+  callUpdate.localizedCallerName = contactIdentifier;\n+\n+  [self.callKeepProvider reportCallWithUUID: uuid updated: callUpdate];\n }\n \n // Answering incoming call\n-- (void)provider:(CXProvider *)provider performAnswerCallAction:(CXAnswerCallAction *)action\n+-(void) provider: (CXProvider *) provider performAnswerCallAction: (CXAnswerCallAction *) action\n {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][CXProviderDelegate][provider:performAnswerCallAction]\");\n+  NSLog (@\"[RNCallKeep][CXProviderDelegate][provider:performAnswerCallAction]\");\n #endif\n-    [self configureAudioSession];\n-    [self sendEventWithNameWrapper:RNCallKeepPerformAnswerCallAction body:@{ @\"callUUID\": [action.callUUID.UUIDString lowercaseString] }];\n-    [action fulfill];\n+  [self configureAudioSession];\n+  [self sendEventWithNameWrapper:RNCallKeepPerformAnswerCallAction body: @{\n+    @\"callUUID\": [action.callUUID.UUIDString lowercaseString]\n+  }];\n+  [action fulfill];\n }\n \n // Ending incoming call\n-- (void)provider:(CXProvider *)provider performEndCallAction:(CXEndCallAction *)action\n+-(void) provider: (CXProvider *) provider performEndCallAction: (CXEndCallAction *) action\n {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][CXProviderDelegate][provider:performEndCallAction]\");\n+  NSLog (@\"[RNCallKeep][CXProviderDelegate][provider:performEndCallAction]\");\n #endif\n-    [self sendEventWithNameWrapper:RNCallKeepPerformEndCallAction body:@{ @\"callUUID\": [action.callUUID.UUIDString lowercaseString] }];\n-    [action fulfill];\n+\n+  [self sendEventWithNameWrapper:RNCallKeepPerformEndCallAction body: @{\n+    @\"callUUID\": [action.callUUID.UUIDString lowercaseString]\n+  }];\n+  [action fulfill];\n }\n \n--(void)provider:(CXProvider *)provider performSetHeldCallAction:(CXSetHeldCallAction *)action\n-{\n+-(void) provider: (CXProvider *) provider performSetHeldCallAction: (CXSetHeldCallAction *) action {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][CXProviderDelegate][provider:performSetHeldCallAction]\");\n+  NSLog (@\"[RNCallKeep][CXProviderDelegate][provider:performSetHeldCallAction]\");\n #endif\n \n-    [self sendEventWithNameWrapper:RNCallKeepDidToggleHoldAction body:@{ @\"hold\": @(action.onHold), @\"callUUID\": [action.callUUID.UUIDString lowercaseString] }];\n-    [action fulfill];\n+  [self sendEventWithNameWrapper:RNCallKeepDidToggleHoldAction body: @{\n+    @\"hold\": @(action.onHold),\n+    @\"callUUID\": [action.callUUID.UUIDString lowercaseString]\n+  }];\n+  [action fulfill];\n }\n \n-- (void)provider:(CXProvider *)provider performPlayDTMFCallAction:(CXPlayDTMFCallAction *)action {\n+-(void) provider: (CXProvider *) provider performPlayDTMFCallAction: (CXPlayDTMFCallAction *) action {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][CXProviderDelegate][provider:performPlayDTMFCallAction]\");\n+  NSLog (@\"[RNCallKeep][CXProviderDelegate][provider:performPlayDTMFCallAction]\");\n #endif\n-    [self sendEventWithNameWrapper:RNCallKeepPerformPlayDTMFCallAction body:@{ @\"digits\": action.digits, @\"callUUID\": [action.callUUID.UUIDString lowercaseString] }];\n-    [action fulfill];\n+\n+  [self sendEventWithNameWrapper:RNCallKeepPerformPlayDTMFCallAction body: @{\n+    @\"digits\": action.digits,\n+    @\"callUUID\": [action.callUUID.UUIDString lowercaseString]\n+  }];\n+  [action fulfill];\n }\n \n--(void)provider:(CXProvider *)provider performSetMutedCallAction:(CXSetMutedCallAction *)action\n-{\n+-(void) provider: (CXProvider *) provider performSetMutedCallAction: (CXSetMutedCallAction *) action {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][CXProviderDelegate][provider:performSetMutedCallAction]\");\n+  NSLog (@\"[RNCallKeep][CXProviderDelegate][provider:performSetMutedCallAction]\");\n #endif\n \n-    [self sendEventWithNameWrapper:RNCallKeepDidPerformSetMutedCallAction body:@{ @\"muted\": @(action.muted), @\"callUUID\": [action.callUUID.UUIDString lowercaseString] }];\n-    [action fulfill];\n+  [self sendEventWithNameWrapper:RNCallKeepDidPerformSetMutedCallAction body:@{ @\"muted\": @(action.muted), @\"callUUID\": [action.callUUID.UUIDString lowercaseString] }];\n+  [action fulfill];\n }\n \n-- (void)provider:(CXProvider *)provider timedOutPerformingAction:(CXAction *)action\n-{\n+-(void) provider: (CXProvider *) provider timedOutPerformingAction: (CXAction *) action {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][CXProviderDelegate][provider:timedOutPerformingAction]\");\n+  NSLog (@\"[RNCallKeep][CXProviderDelegate][provider:timedOutPerformingAction]\");\n #endif\n }\n \n-- (void)provider:(CXProvider *)provider didActivateAudioSession:(AVAudioSession *)audioSession\n-{\n+-(void) provider: (CXProvider *) provider didActivateAudioSession: (AVAudioSession *) audioSession {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][CXProviderDelegate][provider:didActivateAudioSession]\");\n+  NSLog (@\"[RNCallKeep][CXProviderDelegate][provider:didActivateAudioSession]\");\n #endif\n-    NSDictionary *userInfo\n-    = @{\n-        AVAudioSessionInterruptionTypeKey: [NSNumber numberWithInt:AVAudioSessionInterruptionTypeEnded],\n-        AVAudioSessionInterruptionOptionKey: [NSNumber numberWithInt:AVAudioSessionInterruptionOptionShouldResume]\n-    };\n-    [[NSNotificationCenter defaultCenter] postNotificationName:AVAudioSessionInterruptionNotification object:nil userInfo:userInfo];\n+  NSDictionary *userInfo = @{\n+    AVAudioSessionInterruptionTypeKey: [NSNumber numberWithInt:AVAudioSessionInterruptionTypeEnded],\n+    AVAudioSessionInterruptionOptionKey: [NSNumber numberWithInt:AVAudioSessionInterruptionOptionShouldResume]\n+  };\n+  [[NSNotificationCenter defaultCenter] postNotificationName:AVAudioSessionInterruptionNotification object: nil userInfo: userInfo];\n \n-    [self configureAudioSession];\n-    [self sendEventWithNameWrapper:RNCallKeepDidActivateAudioSession body:nil];\n+  [self configureAudioSession];\n+  [self sendEventWithNameWrapper: RNCallKeepDidActivateAudioSession body: nil];\n }\n \n-- (void)provider:(CXProvider *)provider didDeactivateAudioSession:(AVAudioSession *)audioSession\n-{\n+- (void) provider: (CXProvider *) provider didDeactivateAudioSession: (AVAudioSession *) audioSession {\n #ifdef DEBUG\n-    NSLog(@\"[RNCallKeep][CXProviderDelegate][provider:didDeactivateAudioSession]\");\n+  NSLog (@\"[RNCallKeep][CXProviderDelegate][provider:didDeactivateAudioSession]\");\n #endif\n-    [self sendEventWithNameWrapper:RNCallKeepDidDeactivateAudioSession body:nil];\n+\n+  [self sendEventWithNameWrapper: RNCallKeepDidDeactivateAudioSession body: nil];\n }\n \n @end"
  }
]
