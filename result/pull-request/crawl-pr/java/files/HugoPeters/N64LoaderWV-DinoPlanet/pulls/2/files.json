[
  {
    "sha": "d29d99a84282080316773d56d417a1a7ea9b3e79",
    "filename": "src/main/java/n64loaderwv/DPDLL.java",
    "status": "modified",
    "additions": 141,
    "deletions": 149,
    "changes": 290,
    "blob_url": "https://github.com/HugoPeters/N64LoaderWV-DinoPlanet/blob/ee78c3b7c1f837a7748b9713ef3911fe66bf2e62/src/main/java/n64loaderwv/DPDLL.java",
    "raw_url": "https://github.com/HugoPeters/N64LoaderWV-DinoPlanet/raw/ee78c3b7c1f837a7748b9713ef3911fe66bf2e62/src/main/java/n64loaderwv/DPDLL.java",
    "contents_url": "https://api.github.com/repos/HugoPeters/N64LoaderWV-DinoPlanet/contents/src/main/java/n64loaderwv/DPDLL.java?ref=ee78c3b7c1f837a7748b9713ef3911fe66bf2e62",
    "patch": "@@ -1,10 +1,13 @@\n package n64loaderwv;\n \n+import java.io.ByteArrayInputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.math.BigInteger;\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.commons.io.output.ByteArrayOutputStream;\n import org.apache.commons.lang3.exception.ExceptionUtils;\n import org.python.jline.internal.Log;\n \n@@ -42,65 +45,53 @@\n import ghidra.util.exception.InvalidInputException;\n import ghidra.util.task.TaskMonitor;\n \n+import n64loaderwv.Utils;\n+\n public class DPDLL \n {\n \tprivate Program program;\n \tpublic int dll_id;\n \tpublic int dll_rom_offset;\n \tpublic int dll_tab_offset;\n+\tpublic int dll_bss;\n \tpublic int dll_size;\n \tpublic int hdr_size;\n-\tpublic int hdr_offset_data2;\n-\tpublic int hdr_offset_constants; // includes import/export function table\n-\tpublic short hdr_unk1;\n+\tpublic int hdr_offset_data;\n+\tpublic int hdr_offset_rodata; // begins with relocation table\n+\tpublic short hdr_export_count;\n \tpublic int code_offset;\n \tpublic int code_size;\n-\tpublic int constants_offset;\n-\tprivate long dll_address;\n+\tpublic int rodata_offset;\n+\tprivate long load_address;\n \tprivate long code_address;\n+\tprivate long rodata_address;\n+\tprivate long data_address;\n \tprivate AddressSpace address_space;\n-\tprivate long load_address;\n \tpublic String dll_identifier;\n \tpublic String dll_block_name;\n-\t\n-\tprivate long MakeRomAddress(int romOffset)\n-\t{\n-\t\treturn load_address + (romOffset - 0x1000);\n-\t}\n-\t\n-\tprivate int GetHeaderExportFuncOffset(int idx)\n+\n+\tprivate int GetHeaderInitFuncOffset()\n \t{\n-\t\treturn dll_rom_offset + 16 + 4 * idx;\n+\t\treturn 0x10;\n \t}\n-\t\n-\tprivate long GetFunctionAddress(int aOffset)\n+\n+\tprivate int GetHeaderFiniFuncOffset()\n \t{\n-\t\t// every(?) DLL function starts with some code that's patched by the game\n-\t\t// it sets up the gp register for the function\n-\t\t// atm we just set the register value, we could also patch the instructions\n-\t\tint addFuncOffset = 0;// aIsExport ? 0xC : 0;\n-\t\t\n-\t\tlong funcAddr = code_address + aOffset + addFuncOffset;\n-\t\t\n-\t\treturn funcAddr;\n+\t\treturn 0x14;\n \t}\n-\t\n-\t// move to some utility thing\n-\tprivate static void MakeConstantPtr(Program p, Address addr) throws CodeUnitInsertionException\n-\t{\n-\t\tData d = DataUtilities.createData(p, addr, PointerDataType.dataType, -1, false,\n-\t\t\t\tClearDataMode.CLEAR_ALL_UNDEFINED_CONFLICT_DATA);\n \n-\t\t// you have no idea how long it took me to find how to fucking set this property\n-\t\tMutabilitySettingsDefinition.DEF.setChoice(d, MutabilitySettingsDefinition.CONSTANT);\n+\tprivate int GetHeaderExportFuncOffset(int idx)\n+\t{\n+\t\treturn 0x1C + 4 * idx;\n \t}\n \t\n-\tpublic DPDLL(Program aProgram, int aId, int aRomStartOffset, int aTabOffset, int aSize) \n+\tpublic DPDLL(Program aProgram, int aId, int aRomStartOffset, int aTabOffset, int aBssSize, int aSize)\n \t{\n \t\tprogram = aProgram;\n \t\tdll_id = aId;\n \t\tdll_rom_offset = aRomStartOffset;\n \t\tdll_tab_offset = aTabOffset;\n+\t\tdll_bss = aBssSize;\n \t\tdll_size = aSize;\n \t\taddress_space = program.getAddressFactory().getDefaultAddressSpace();\n \t}\n@@ -113,23 +104,22 @@ public void Load(ByteArrayProvider s, long loadAddress, MessageLog log, TaskMoni\n \t\t\n \t\thandle.setPointerIndex(dll_rom_offset);\n \t\thdr_size = handle.readNextInt();\n-\t\thdr_offset_data2 = handle.readNextInt(); // can be -1\n-\t\thdr_offset_constants = handle.readNextInt();\n-\t\thdr_unk1 = handle.readNextShort();\n-\t\tcode_offset = dll_rom_offset + hdr_size;\n+\t\thdr_offset_data = handle.readNextInt();\n+\t\thdr_offset_rodata = handle.readNextInt();\n+\t\thdr_export_count = handle.readNextShort();\n+\t\tcode_offset = hdr_size;\n \t\tcode_size = dll_size - hdr_size;\n-\t\tconstants_offset = dll_rom_offset + hdr_offset_constants;\n-\t\t\n+\n \t\tLog.info(String.format(\"DP: DLL %d @ 0x%08X\", dll_id, dll_rom_offset));\n \n-\t\tdll_address = MakeRomAddress(dll_rom_offset);\n-\t\tcode_address = MakeRomAddress(code_offset);\n-\t\t//constants_address = MakeRomAddress(dll_rom_offset + hdr_offset_constants);\n-\t\t\n+\t\tcode_address = load_address + code_offset;\n+\t\trodata_address = load_address + hdr_offset_rodata;\n+\t\tdata_address = load_address + hdr_offset_data;\n+\n \t\tdll_identifier = String.format(\"dll_%03d\", dll_id);\n \t\tdll_block_name = dll_identifier;\n \t\tString usedObjectName = null;\n-\t\t\n+\n \t\tif (objects.dllidx_to_objname.containsKey(dll_id))\n \t\t{\n \t\t\tusedObjectName = objects.dllidx_to_objname.get(dll_id);\n@@ -150,35 +140,18 @@ public void Load(ByteArrayProvider s, long loadAddress, MessageLog log, TaskMoni\n \t\t\tString dllBlockDesc = String.format(\"DLL %d (used object=%s), ROM address 0x%08X, DLLS.BIN offset 0x%08X, DLLS.TAB offset 0x%08X\"\n \t\t\t\t\t\t\t\t\t\t\t, dll_id, usedObjectName != null ? usedObjectName : \"NONE\", dll_rom_offset, dll_tab_offset, 0x10 + dll_id * 8);\n \t\t\t\n-\t\t\tMemoryBlockUtils.createInitializedBlock(\n-\t\t\t\t\tprogram, false, \".\" + dll_block_name, address_space.getAddress(code_address), \n-\t\t\t\t\ts.getInputStream(code_offset), code_size, dllBlockDesc, \n-\t\t\t\t\tnull, true, true, true, log, monitor);\n-\t\t\t\n-\t\t\t// constants block\n-\t\t\t/*String constantsBlockName = String.format(\".%s_constants\", dllIdentifier);\n-\t\t\tAddress constantsStartAddr = address_space.getAddress(constants_address);\n-\t\t\tAddress constantsEndAddr = address_space.getAddress(constants_address + constants_size);\n-\n-\t\t\tMemoryBlockUtils.createInitializedBlock(\n-\t\t\t\t\tprogram, false, constantsBlockName, constantsStartAddr, \n-\t\t\t\t\ts.getInputStream(constants_offset), constants_size, null, \n-\t\t\t\t\tnull, true, false, false, log, monitor);*/\n-\t\t\t\n-\t\t\t// mark constant data as constant, helps ghidra show noice function calls\n-\t\t\t/*Address constantsStartAddr = address_space.getAddress(constants_address);\n-\t\t\tAddress constantsEndAddr = address_space.getAddress(constants_address + constants_size);\n+\t\t\tByteArrayOutputStream out_stream = new ByteArrayOutputStream();\n+\t\t\tout_stream.write(s.readBytes(dll_rom_offset, dll_size));\n+\t\t\tout_stream.write(new byte[dll_bss]);\n+\t\t\tbyte[] dll_data = out_stream.toByteArray();\n+\t\t\tInputStream in_stream = new ByteArrayInputStream(dll_data);\n \t\t\t\n-\t\t\tAddressSetView addrSetConstantData = new AddressSet(constantsStartAddr, constantsEndAddr);\n-\t\t\tDataIterator dataIt = program.getListing().getData(addrSetConstantData, true);\n+\t\t\tMemoryBlock block = MemoryBlockUtils.createInitializedBlock(\n+\t\t\t\t\tprogram, false, \".\" + dll_block_name, address_space.getAddress(load_address),\n+\t\t\t\t\tin_stream, dll_size + dll_bss, dllBlockDesc,\n+\t\t\t\t\tnull, true, true, true, log, monitor);\n \t\t\t\n-\t\t\twhile (dataIt.hasNext())\n-\t\t\t{\n-\t\t\t\tData data = dataIt.next();\n-\t\t\t\t\n-\t\t\t\t// this only works before the data is analyzed, we probably need to CreateData explicitly\n-\t\t\t\tMutabilitySettingsDefinition.DEF.setChoice(d, MutabilitySettingsDefinition.CONSTANT);\n-\t\t\t}*/\n+\t\t\taddress_space = block.getStart().getAddressSpace();\n \t\t}\n \t\tcatch (Exception e) \n \t\t{\n@@ -210,101 +183,117 @@ public void Relocate(ByteArrayProvider s) throws IOException, MemoryAccessExcept\n \t\tList<FuncInfo> functions = new ArrayList<FuncInfo>();\n \t\t\n \t\t// patch the export function offsets to address of the func in the rom\n-\t\tint num_exports = (hdr_size - 16) / 4;\n-\t\t\n-\t\tfor (int i = 0; i < num_exports; ++i)\n+\t\tfor (int i = 0; i < hdr_export_count + 2; ++i)\n \t\t{\n-\t\t\tint exportOffset = GetHeaderExportFuncOffset(i);\n-\t\t\tlong offsetAddr = MakeRomAddress(exportOffset);\n-\t\t\tint funcOffset = handle.readInt(exportOffset);\n-\t\t\tlong funcAddress = GetFunctionAddress(funcOffset);\n+\t\t\tint exportOffset = 0;\n+\t\t\tif (i == 0) exportOffset = GetHeaderInitFuncOffset();\n+\t\t\telse if (i == 1) exportOffset = GetHeaderFiniFuncOffset();\n+\t\t\telse exportOffset = GetHeaderExportFuncOffset(i - 2);\n+\n+\t\t\tlong offsetAddr = load_address + exportOffset;\n+\t\t\tint funcOffset = handle.readInt(dll_rom_offset + exportOffset);\n+\t\t\tlong funcAddress = code_address + funcOffset;\n \t\t\tAddress writeAddr = address_space.getAddress(offsetAddr);\n \t\t\tmem.setInt(writeAddr, (int)funcAddress);\n-\t\t\tMakeConstantPtr(program, writeAddr);\n-\t\t\t\n+\t\t\tUtils.MakeConstantPtr(program, writeAddr);\n+\n \t\t\tfunctions.add(new FuncInfo(true, false, funcOffset));\n \t\t}\n-\n-\t\tlong dataAddress = dll_address + hdr_offset_constants;\n-\t\tlong writeAddress = dataAddress - 4;\n-\t\t\n-\t\tRegister reg = program.getLanguage().getRegister(\"gp\");\n-\t\tAddress regAddrStart = address_space.getAddress(dll_address);\n-\t\tAddress regAddrEnd = address_space.getAddress(dll_address + dll_size);\n-\t\tctx.setValue(reg, regAddrStart, regAddrEnd, BigInteger.valueOf(dataAddress));\n-\t\t\n-\t\thandle.setPointerIndex(dll_rom_offset + hdr_offset_constants);\n \t\t\n-\t\tint rom_DLLSIMPORTTAB_offset = 0x3B064DC;\n-\t\t\n-\t\t// imports table\n-\t\twhile (true)\n+\t\t// relocation table\n+\t\tif (hdr_offset_rodata != -1)\n \t\t{\n-\t\t\twriteAddress += 4;\n-\t\t\tint val = handle.readNextInt();\n-\n-\t\t\tif (val == -2)\n-\t\t\t\tbreak;\n+\t\t\tRegister reg = program.getLanguage().getRegister(\"gp\");\n+\t\t\tAddress regAddrStart = address_space.getAddress(load_address);\n+\t\t\tAddress regAddrEnd = address_space.getAddress(load_address + dll_size + dll_bss - 1);\n+\t\t\tctx.setValue(reg, regAddrStart, regAddrEnd, BigInteger.valueOf(rodata_address));\n \t\t\t\n-\t\t\tlong writeValue = 0;\n+\t\t\thandle.setPointerIndex(dll_rom_offset + hdr_offset_rodata);\n \t\t\t\n-\t\t\tif ((val & 0x80000000) == 0)\n-\t\t\t{\n-\t\t\t\t// pointer to address within DLL, string table, etc.\n-\t\t\t\twriteValue = code_address + val;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\t// pointer to main executable function\n-\t\t\t\tint importTabOffset = (val & 0x7FFFFFFF) * 4 - 4;\n-\t\t\t\twriteValue = handle.readUnsignedInt(rom_DLLSIMPORTTAB_offset + importTabOffset); \n-\t\t\t}\n-\t\t\t\n-\t\t\tAddress targetAddr = address_space.getAddress(writeAddress);\n-\t\t\t\n-\t\t\tmem.setInt(targetAddr, (int)writeValue);\n-\t\t\tMakeConstantPtr(program, targetAddr);\n-\t\t}\n-\t\t\n-\t\t// function table\n-\t\twhile (true)\n-\t\t{\n-\t\t\tint val = handle.readNextInt();\n+\t\t\tint rom_DLLSIMPORTTAB_offset = DPFST.offsets.get(72);\n \t\t\t\n-\t\t\tif (val == -3)\n-\t\t\t\tbreak;\n+\t\t\tlong writeAddress = rodata_address - 4;\n \t\t\t\n-\t\t\tboolean hasFunc = false;\n-\t\t\tfor (int i = 0; i < functions.size() && !hasFunc; ++i)\n+\t\t\t// rodata table\n+\t\t\twhile (true)\n \t\t\t{\n-\t\t\t\tif (functions.get(i).dll_offset == val)\n+\t\t\t\twriteAddress += 4;\n+\t\t\t\tint val = handle.readNextInt();\n+\n+\t\t\t\tif (val == -2)\n+\t\t\t\t\tbreak;\n+\n+\t\t\t\tlong writeValue = 0;\n+\n+\t\t\t\tif ((val & 0x80000000) == 0)\n \t\t\t\t{\n-\t\t\t\t\thasFunc = true;\n-\t\t\t\t\tfunctions.get(i).is_local = true;\n+\t\t\t\t\t// pointer to address within DLL, string table, etc.\n+\t\t\t\t\twriteValue = code_address + val;\n \t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\t// pointer to main executable function\n+\t\t\t\t\tint importTabOffset = (val & 0x7FFFFFFF) * 4 - 4;\n+\t\t\t\t\twriteValue = handle.readUnsignedInt(rom_DLLSIMPORTTAB_offset + importTabOffset); \n+\t\t\t\t}\n+\n+\t\t\t\tAddress targetAddr = address_space.getAddress(writeAddress);\n+\n+\t\t\t\tmem.setInt(targetAddr, (int)writeValue);\n+\t\t\t\tUtils.MakeConstantPtr(program, targetAddr);\n \t\t\t}\n \t\t\t\n-\t\t\tif (!hasFunc)\n+\t\t\t// text table\n+\t\t\twhile (true)\n \t\t\t{\n-\t\t\t\tfunctions.add(new FuncInfo(false, true, val));\n+\t\t\t\tint val = handle.readNextInt();\n+\n+\t\t\t\tif (val == -3)\n+\t\t\t\t\tbreak;\n+\n+\t\t\t\tboolean hasFunc = false;\n+\t\t\t\tfor (int i = 0; i < functions.size() && !hasFunc; ++i)\n+\t\t\t\t{\n+\t\t\t\t\tif (functions.get(i).dll_offset == val)\n+\t\t\t\t\t{\n+\t\t\t\t\t\thasFunc = true;\n+\t\t\t\t\t\tfunctions.get(i).is_local = true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (!hasFunc)\n+\t\t\t\t{\n+\t\t\t\t\tfunctions.add(new FuncInfo(false, true, val));\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n+\n+\t\t\tif (hdr_offset_data != -1)\n+\t\t\t{\n+\t\t\t\t// data table\n+\t\t\t\twhile (true)\n+\t\t\t\t{\n+\t\t\t\t\tint val = handle.readNextInt();\n+\n+\t\t\t\t\tif (val == -1)\n+\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\twriteAddress = data_address + val;\n \t\t\n-\t\twhile (true)\n-\t\t{\n-\t\t\tint val = handle.readNextInt();\n-\t\t\t\n-\t\t\tif (val == -1)\n-\t\t\t\tbreak;\n-\t\t\t\n-\t\t\t// offsets into the DLL to tables of more values?\n-\t\t}\n+\t\t\t\t\tlong writeValue = handle.readUnsignedInt(dll_rom_offset + hdr_offset_data + val);\n+\t\t\t\t\twriteValue += data_address;\n \t\t\n+\t\t\t\t\tAddress targetAddr = address_space.getAddress(writeAddress);\n+\n+\t\t\t\t\tmem.setInt(targetAddr, (int)writeValue);\n+\t\t\t\t\tUtils.MakeNormalPtr(program, targetAddr);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\t// end of table\n \t\t\n \t\t// create functions\n-\t\tshort dataAddressHi = (short)((dataAddress >> 0x10) & 0xFFFF);\n-\t\tshort dataAddressLo = (short)(dataAddress & 0xFFFF);\n+\t\tshort rodataAddressHi = (short)((rodata_address >> 0x10) & 0xFFFF);\n+\t\tshort rodataAddressLo = (short)(rodata_address & 0xFFFF);\n \t\t\n \t\tfor (int i = 0; i < functions.size(); ++i)\n \t\t{\n@@ -316,23 +305,26 @@ public void Relocate(ByteArrayProvider s) throws IOException, MemoryAccessExcept\n \t\t\tif (info.is_export)\n \t\t\t\tfuncStrFlags += \"E\";\n \n-\t\t\tString funcName = String.format(\"%s_func_%04d\", dll_block_name, i);\n-\t\t\t\n+\t\t\tString funcName = null;\n+\t\t\tif (i == 0) funcName = String.format(\"%s_init\", dll_block_name);\n+\t\t\telse if (i == 1) funcName = String.format(\"%s_fini\", dll_block_name);\n+\t\t\telse funcName = String.format(\"%s_func_%04d\", dll_block_name, i - 2);\n+\n \t\t\tif (funcStrFlags.length() > 0)\n \t\t\t\tfuncName += \"_\" + funcStrFlags;\n \t\t\t\n-\t\t\tAddress addr = address_space.getAddress(GetFunctionAddress(info.dll_offset));\n+\t\t\tAddress addr = address_space.getAddress(code_address + info.dll_offset);\n \t\t    program.getSymbolTable().createLabel(addr, funcName, SourceType.ANALYSIS);\n \t\t\tprogram.getSymbolTable().addExternalEntryPoint(addr);\n \t\t    \n-\t\t    if (info.is_local)\n+\t\t    if (info.is_local && hdr_offset_rodata != -1)\n \t\t    {\n \t\t    \t// patch the GP register instructions at the start of the function\n \t\t    \t// the game does this as well at runtime\n \t\t    \tAddress loadInstrPatchAddr = addr.add(2);\n \t\t    \tAddress orInstrPatchAddr = addr.add(6);\n-\t\t    \tmem.setShort(loadInstrPatchAddr, dataAddressHi);\n-\t\t    \tmem.setShort(orInstrPatchAddr, dataAddressLo);\n+\t\t\tmem.setShort(loadInstrPatchAddr, rodataAddressHi);\n+\t\t\tmem.setShort(orInstrPatchAddr, rodataAddressLo);\n \t\t    }\n \t\t}\n \t}"
  },
  {
    "sha": "b4b070730cbb7af9a147d78648f0da0e9eb1c3ff",
    "filename": "src/main/java/n64loaderwv/DPDLLTab.java",
    "status": "modified",
    "additions": 22,
    "deletions": 11,
    "changes": 33,
    "blob_url": "https://github.com/HugoPeters/N64LoaderWV-DinoPlanet/blob/ee78c3b7c1f837a7748b9713ef3911fe66bf2e62/src/main/java/n64loaderwv/DPDLLTab.java",
    "raw_url": "https://github.com/HugoPeters/N64LoaderWV-DinoPlanet/raw/ee78c3b7c1f837a7748b9713ef3911fe66bf2e62/src/main/java/n64loaderwv/DPDLLTab.java",
    "contents_url": "https://api.github.com/repos/HugoPeters/N64LoaderWV-DinoPlanet/contents/src/main/java/n64loaderwv/DPDLLTab.java?ref=ee78c3b7c1f837a7748b9713ef3911fe66bf2e62",
    "patch": "@@ -36,12 +36,13 @@\n {\n \tpublic int[] dll_banks;\n \tpublic List<Integer> dll_offsets;\n-\t\n+\tpublic List<Integer> dll_bss_sizes;\n+\n \tpublic void Load(ByteArrayProvider s) throws IOException, InvalidInputException\n \t{\n \t\tBinaryReader handle = new BinaryReader(s, false);\n \t\t\n-\t\tint offset_DLLS_TAB = 0x3B04BDC;\n+\t\tint offset_DLLS_TAB = DPFST.offsets.get(71);\n \t\t\n \t\t// read tab\n \t\thandle.setPointerIndex(offset_DLLS_TAB);\n@@ -51,28 +52,38 @@ public void Load(ByteArrayProvider s) throws IOException, InvalidInputException\n \t\tdll_banks[1] = handle.readNextInt();\n \t\tdll_banks[2] = handle.readNextInt();\n \t\tdll_banks[3] = handle.readNextInt();\n-\t\t\n-\t\t// according to the game the first dll actually starts at 0x8 but this is bank data\n-\t\t// not sure why\n-\t\t// ignore this and just make correct offsets, we fix the ID later by just adding 1\n-\t\t\n+\n \t\tdll_offsets = new ArrayList<Integer>();\n-\t\t\n+\t\tdll_bss_sizes = new ArrayList<Integer>();\n+\n \t\twhile (true) \n \t\t{\n \t\t\tint dllOffset = handle.readNextInt();\n-\t\t\tint dllUnk = handle.readNextInt();\n+\t\t\tint dllBss = handle.readNextInt();\n \t\t\t\n-\t\t\tif (dllOffset == -1 && dllUnk == -1)\n+\t\t\tif (dllOffset == -1 && dllBss == -1)\n \t\t\t\tbreak;\n \t\t\t\n \t\t\tdll_offsets.add(dllOffset);\n+\t\t\tdll_bss_sizes.add(dllBss);\n \t\t}\n \t}\n+\n+\tpublic int GetDLLBssSizeFromIndex(int aIndex)\n+\t{\n+\t\tint dllBss = dll_bss_sizes.get(aIndex);\n+\t\treturn dllBss;\n+\t}\n+\n+\tpublic int GetDLLBssSizeFromEncodedId(int aId)\n+\t{\n+\t\tint index = DecodeDLLId(aId);\n+\t\treturn GetDLLBssSizeFromIndex(index - 1);\n+\t}\n \t\n \tpublic int GetDLLRomOffsetFromIndex(int aIndex)\n \t{\n-\t\tint offset_DLLS_BIN = 0x38317CC;\n+\t\tint offset_DLLS_BIN = DPFST.offsets.get(70);\n \t\tint tabOffset = dll_offsets.get(aIndex);\n \t\tint dllOffset = offset_DLLS_BIN + tabOffset;\n \t\treturn dllOffset;"
  },
  {
    "sha": "2147a5c203b7f240fd9c60626c26fd88a63393fc",
    "filename": "src/main/java/n64loaderwv/DPFST.java",
    "status": "added",
    "additions": 33,
    "deletions": 0,
    "changes": 33,
    "blob_url": "https://github.com/HugoPeters/N64LoaderWV-DinoPlanet/blob/ee78c3b7c1f837a7748b9713ef3911fe66bf2e62/src/main/java/n64loaderwv/DPFST.java",
    "raw_url": "https://github.com/HugoPeters/N64LoaderWV-DinoPlanet/raw/ee78c3b7c1f837a7748b9713ef3911fe66bf2e62/src/main/java/n64loaderwv/DPFST.java",
    "contents_url": "https://api.github.com/repos/HugoPeters/N64LoaderWV-DinoPlanet/contents/src/main/java/n64loaderwv/DPFST.java?ref=ee78c3b7c1f837a7748b9713ef3911fe66bf2e62",
    "patch": "@@ -0,0 +1,33 @@\n+package n64loaderwv;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import ghidra.app.util.bin.BinaryReader;\n+import ghidra.app.util.bin.ByteArrayProvider;\n+import ghidra.util.exception.InvalidInputException;\n+\n+public final class DPFST\n+{\n+\tpublic static List<Integer> offsets;\n+\n+\tpublic static void Load(ByteArrayProvider s, int offset_FST) throws IOException, InvalidInputException\n+\t{\n+\t\tBinaryReader handle = new BinaryReader(s, false);\n+\n+\t\thandle.setPointerIndex(offset_FST);\n+\n+\t\tint count = handle.readNextInt();\n+\t\tint offset_FAT = offset_FST + (count + 2) * 4;\n+\n+\t\toffsets = new ArrayList<Integer>();\n+\n+\t\tfor (int i = 0; i < count + 1; i++)\n+\t\t{\n+\t\t\tint offset = handle.readNextInt();\n+\n+\t\t\toffsets.add(offset_FAT + offset);\n+\t\t}\n+\t}\n+}"
  },
  {
    "sha": "8ad9c2fc9c5bf40681526c642e8ac9eaf14707b7",
    "filename": "src/main/java/n64loaderwv/DPGlobalDLLTable.java",
    "status": "modified",
    "additions": 53,
    "deletions": 27,
    "changes": 80,
    "blob_url": "https://github.com/HugoPeters/N64LoaderWV-DinoPlanet/blob/ee78c3b7c1f837a7748b9713ef3911fe66bf2e62/src/main/java/n64loaderwv/DPGlobalDLLTable.java",
    "raw_url": "https://github.com/HugoPeters/N64LoaderWV-DinoPlanet/raw/ee78c3b7c1f837a7748b9713ef3911fe66bf2e62/src/main/java/n64loaderwv/DPGlobalDLLTable.java",
    "contents_url": "https://api.github.com/repos/HugoPeters/N64LoaderWV-DinoPlanet/contents/src/main/java/n64loaderwv/DPGlobalDLLTable.java?ref=ee78c3b7c1f837a7748b9713ef3911fe66bf2e62",
    "patch": "@@ -1,11 +1,14 @@\n package n64loaderwv;\n \n+import java.io.ByteArrayInputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.math.BigInteger;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n \n+import org.apache.commons.io.output.ByteArrayOutputStream;\n import org.apache.commons.lang3.exception.ExceptionUtils;\n import org.python.jline.internal.Log;\n \n@@ -19,6 +22,7 @@\n import ghidra.program.database.code.CodeManager;\n import ghidra.program.model.address.Address;\n import ghidra.program.model.address.AddressOutOfBoundsException;\n+import ghidra.program.model.address.AddressOverflowException;\n import ghidra.program.model.address.AddressSet;\n import ghidra.program.model.address.AddressSetView;\n import ghidra.program.model.address.AddressSpace;\n@@ -43,6 +47,8 @@\n import ghidra.util.exception.InvalidInputException;\n import ghidra.util.task.TaskMonitor;\n \n+import n64loaderwv.Utils;\n+\n public class DPGlobalDLLTable \n {\n \tprivate static HashMap<Integer, String> dll_names;\n@@ -81,22 +87,37 @@ public static String GetGlobalDLLName(int aDllIndex)\n \t\treturn dll_names.get(aDllIndex);\n \t}\n \t\n-\tpublic static void Build(Program aProgram, DPDLLTab aTab, long loadAddress) throws MemoryAccessException, InvalidInputException, CodeUnitInsertionException\n+\tpublic static void Build(Program aProgram, DPDLLTab aTab, long loadAddress, MessageLog aLog, TaskMonitor aMonitor) throws MemoryAccessException, InvalidInputException, CodeUnitInsertionException, IOException, AddressOverflowException, AddressOutOfBoundsException\n \t{\n \t\tMemory mem = aProgram.getMemory();\n+\n+\t\tByteArrayOutputStream outStream = new ByteArrayOutputStream();\n+\t\toutStream.write(new byte[0x1000]);\n+\t\tbyte[] data = outStream.toByteArray();\n+\t\tInputStream inStream = new ByteArrayInputStream(data);\n+\n \t\tAddressSpace addrSpace = aProgram.getAddressFactory().getDefaultAddressSpace();\n \t\t\n+\t\tMemoryBlock block = MemoryBlockUtils.createInitializedBlock(\n+\t\t\t\taProgram, false, \".redir\", addrSpace.getAddress(0x80800000),\n+\t\t\t\tinStream, 0x1000, \"Redirection table\",\n+\t\t\t\tnull, true, true, true, aLog, aMonitor);\n+\n+\t\toutStream.close();\n+\n+\t\tAddressSpace redirSpace = block.getStart().getAddressSpace();\n+\n \t\tInfo infos[] = new Info[]\n \t\t\t\t{\n-\t\t\t\t\tnew Info(0x8008c994, 0x01),\n-\t\t\t\t\tnew Info(0x8008c978, 0x02),\n+\t\t\t\t\tnew Info(0x8008c994, 0x01, \"cmdmenu\"),\n+\t\t\t\t\tnew Info(0x8008c978, 0x02, \"camcontrol\"),\n \t\t\t\t\tnew Info(0x8008c97c, 0x03, \"ANIM\"),\n \t\t\t\t\tnew Info(0x8008c998, 0x04, \"Race\"),\n \t\t\t\t\tnew Info(0x8008c99c, 0x05, \"AMSEQ\"),\n \t\t\t\t\tnew Info(0x8008c9a0, 0x05, \"AMSEQ\"), // same as last\n \t\t\t\t\tnew Info(0x8008c9a4, 0x06, \"AMSFX\"),\n-\t\t\t\t\tnew Info(0x8008c980, 0x07, null),\n-\t\t\t\t\tnew Info(0x8008c984, 0x08, null),\n+\t\t\t\t\tnew Info(0x8008c980, 0x07, \"newday\"),\n+\t\t\t\t\tnew Info(0x8008c984, 0x08, \"newfog\"),\n \t\t\t\t\tnew Info(0x8008c988, 0x09, \"newclouds\"),\n \t\t\t\t\tnew Info(0x8008c98c, 0x0A, \"newstars\"),\n \t\t\t\t\tnew Info(0x8008c9a8, 0x0B, \"newlfx\"),\n@@ -105,55 +126,60 @@ public static void Build(Program aProgram, DPDLLTab aTab, long loadAddress) thro\n \t\t\t\t\tnew Info(0x8008c9b8, 0x0E, \"modgfx\"),\n \t\t\t\t\tnew Info(0x8008c9bc, 0x0F, \"projgfx\"),\n \t\t\t\t\tnew Info(0x8008c9c0, 0x10, null),\n-\t\t\t\t\tnew Info(0x8008c9c4, 0x11, null),\n-\t\t\t\t\tnew Info(0x8008c9c8, 0x12, null),\n+\t\t\t\t\tnew Info(0x8008c9c4, 0x11, \"partfx\"),\n+\t\t\t\t\tnew Info(0x8008c9c8, 0x12, \"objfsa\"),\n \t\t\t\t\t\n \t\t\t\t\tnew Info(0x8008c9cc, 0x14, \"SCREENS\"),\n \t\t\t\t\tnew Info(0x8008c9d0, 0x15, \"text\"),\n \t\t\t\t\tnew Info(0x8008c9d4, 0x16, \"subtitles\"),\n \t\t\t\t\tnew Info(0x8008c9d8, 0x17, null),\n \t\t\t\t\tnew Info(0x8008c9dc, 0x18, \"waterfx\"),\n-\t\t\t\t\tnew Info(0x8008c9e0, 0x19, null),\n+\t\t\t\t\tnew Info(0x8008c9e0, 0x19, \"paths\"),\n \t\t\t\t\tnew Info(0x8008c9e4, 0x1A, \"CURVES\"),\n \t\t\t\t\tnew Info(0x8008c9f0, 0x1B, null),\n-\t\t\t\t\tnew Info(0x8008c974, 0x1C, null),\n+\t\t\t\t\tnew Info(0x8008c974, 0x1C, \"clrscr\"),\n \t\t\t\t\tnew Info(0x8008c9f4, 0x1D, \"gplay\"),\n-\t\t\t\t\tnew Info(0x8008c9fc, 0x1E, null),\n+\t\t\t\t\tnew Info(0x8008c9fc, 0x1E, \"tasktext\"),\n \t\t\t\t\tnew Info(0x8008ca00, 0x1F, \"Save\"),\n \t\t\t\t\tnew Info(0x8008ca08, 0x20, null),\n \t\t\t\t\tnew Info(0x8008ca0c, 0x21, null),\n \t\t\t\t\t\n-\t\t\t\t\tnew Info(0x8008ca14, 0x36, null),\n+\t\t\t\t\tnew Info(0x8008ca14, 0x36, \"pickup\"),\n \t\t\t\t\t\n-\t\t\t\t\tnew Info(0x8008c9f8, 0x38, null),\n+\t\t\t\t\tnew Info(0x8008c9f8, 0x38, \"putdown\"),\n \t\t\t\t\tnew Info(0x8008c9ac, 0x39, null),\n \t\t\t\t\tnew Info(0x8008c9b0, 0x3A, null),\n \t\t\t\t\tnew Info(0x8008ca10, 0x3B, null),\n-\t\t\t\t\t\n-\t\t\t\t\tnew Info(0x8008c9e8, 0x4A, null),\n-\t\t\t\t\t\n-\t\t\t\t\tnew Info(0x8008c9e8, 0x4A, null),\n-\t\t\t\t\tnew Info(0x8008c9ec, 0x4B, null),\n+\n+\t\t\t\t\tnew Info(0x8008c9e8, 0x4A, \"picmenu\"),\n+\t\t\t\t\tnew Info(0x8008c9ec, 0x4B, \"frontend\"),\n \t\t\t\t\tnew Info(0x8008ca04, 0x4C, null),\n \t\t\t\t};\n \t\t\n \t\tdll_names = new HashMap<Integer, String>();\n-\t\t\n-\t\tint redirectionBlockOffset = 0x0219A11E; // use some memory from textures\n-\t\tlong redirectionBlockAddress = loadAddress + (redirectionBlockOffset - 0x1000);\n-\t\t\n+\n+\t\tlong redirectionBlockAddress = 0x80800000;\n+\n \t\tfor (int i = 0; i < infos.length; ++i)\n \t\t{\n \t\t\tInfo info = infos[i];\n-\t\t\t\t\t\t\n \t\t\tint dllId = aTab.DecodeDLLId(info.dll_id);\n-\t\t\tint dllOffset = aTab.GetDLLRomOffsetFromEncodedId(info.dll_id);\n-\t\t\tlong dllUserCodeAddress = loadAddress + (dllOffset + 0x18 - 0x1000);\n-\t\t\t\n-\t\t\tAddress addrDllEntry = addrSpace.getAddress(dllUserCodeAddress);\n \t\t\t\n+\t\t\tlong dllAddress = 0x81000000;\n+\t\t\tfor (int j = 1; j < dllId; j++)\n+\t\t\t{\n+\t\t\t\tint tabOffset = aTab.dll_offsets.get(j - 1);\n+\t\t\t\tint dllBss = aTab.dll_bss_sizes.get(j - 1);\n+\t\t\t\tint dllSize = aTab.dll_offsets.get(j) - tabOffset;\n+\n+\t\t\t\tdllAddress += dllSize + dllBss;\n+\t\t\t\tdllAddress = Utils.align(dllAddress, 0x1000);\n+\t\t\t}\n+\n+\t\t\tAddress addrDllEntry = addrSpace.getAddress(dllAddress + 0x18);\n+\n \t\t\t// write the redirection table entry\n-\t\t\tAddress addrRedirTableEntry = addrSpace.getAddress(redirectionBlockAddress + i * 4);\n+\t\t\tAddress addrRedirTableEntry = redirSpace.getAddress(redirectionBlockAddress + i * 4);\n \t\t\tmem.setInt(addrRedirTableEntry, (int)addrDllEntry.getOffset());\n \t\t\t\n \t\t\t// set the global to the redirection address"
  },
  {
    "sha": "b0ddde2d8fd0fc5f55341b508930135a0c040d3b",
    "filename": "src/main/java/n64loaderwv/DPObjects.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/HugoPeters/N64LoaderWV-DinoPlanet/blob/ee78c3b7c1f837a7748b9713ef3911fe66bf2e62/src/main/java/n64loaderwv/DPObjects.java",
    "raw_url": "https://github.com/HugoPeters/N64LoaderWV-DinoPlanet/raw/ee78c3b7c1f837a7748b9713ef3911fe66bf2e62/src/main/java/n64loaderwv/DPObjects.java",
    "contents_url": "https://api.github.com/repos/HugoPeters/N64LoaderWV-DinoPlanet/contents/src/main/java/n64loaderwv/DPObjects.java?ref=ee78c3b7c1f837a7748b9713ef3911fe66bf2e62",
    "patch": "@@ -41,8 +41,8 @@ public void Load(ByteArrayProvider s, DPDLLTab dlltab) throws IOException\n \t{\n \t\tBinaryReader handle = new BinaryReader(s, false);\n \t\t\n-\t\tint rom_OBJECTS_BIN_offset = 0x37EEB42; \n-\t\tint rom_OBJECTS_TAB_offset = 0X37ED766;\n+\t\tint rom_OBJECTS_BIN_offset = DPFST.offsets.get(66);\n+\t\tint rom_OBJECTS_TAB_offset = DPFST.offsets.get(65);\n \t\t\n \t\t// read tab\n \t\tList<Integer> offsets = new ArrayList<Integer>();"
  },
  {
    "sha": "1319b160f606d55a5f79de6965b1c3f66d6b0669",
    "filename": "src/main/java/n64loaderwv/N64LoaderWVLoader.java",
    "status": "modified",
    "additions": 44,
    "deletions": 14,
    "changes": 58,
    "blob_url": "https://github.com/HugoPeters/N64LoaderWV-DinoPlanet/blob/ee78c3b7c1f837a7748b9713ef3911fe66bf2e62/src/main/java/n64loaderwv/N64LoaderWVLoader.java",
    "raw_url": "https://github.com/HugoPeters/N64LoaderWV-DinoPlanet/raw/ee78c3b7c1f837a7748b9713ef3911fe66bf2e62/src/main/java/n64loaderwv/N64LoaderWVLoader.java",
    "contents_url": "https://api.github.com/repos/HugoPeters/N64LoaderWV-DinoPlanet/contents/src/main/java/n64loaderwv/N64LoaderWVLoader.java?ref=ee78c3b7c1f837a7748b9713ef3911fe66bf2e62",
    "patch": "@@ -15,12 +15,14 @@\n  */\n package n64loaderwv;\n \n+import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.nio.file.Files;\n import java.nio.file.Paths;\n import java.util.*;\n \n+import org.apache.commons.io.output.ByteArrayOutputStream;\n import org.apache.commons.lang3.exception.ExceptionUtils;\n import org.python.jline.internal.Log;\n \n@@ -35,6 +37,8 @@\n import ghidra.framework.model.DomainObject;\n import ghidra.program.model.address.Address;\n import ghidra.program.model.address.AddressOutOfBoundsException;\n+import ghidra.program.model.address.AddressOverflowException;\n+import ghidra.program.model.address.AddressSpace;\n import ghidra.program.model.data.DataUtilities;\n import ghidra.program.model.data.Structure;\n import ghidra.program.model.data.DataUtilities.ClearDataMode;\n@@ -51,6 +55,9 @@\n import ghidra.util.exception.InvalidInputException;\n import ghidra.util.task.TaskMonitor;\n \n+import n64loaderwv.DPFST;\n+import n64loaderwv.Utils;\n+\n public class N64LoaderWVLoader extends AbstractLibrarySupportLoader {\n \n \tclass BlockInfo\n@@ -93,7 +100,7 @@\n \t\n \t@Override\n \tpublic String getName() {\n-\t\treturn \"N64 Loader for DP by Warranty Voider and Hugo Peters\";\n+\t\treturn \"N64 Loader for DP by Warranty Voider, Hugo Peters and nuggs\";\n \t}\n \n \t@Override\n@@ -182,14 +189,30 @@ protected void load(ByteProvider provider, LoadSpec loadSpec, List<Option> optio\n \t\t\tLog.info(\"N64 Loader: Creating segment BOOT\");\n \t\t\tMakeBlock(program, \".boot\", \"ROM bootloader\", 0xA4000040, bapROM.getInputStream(0x40),  0xFC0, \"111\", null, log, monitor);\n \n+\t\t\tLog.info(\"N64-DP Loader: Loading FST\");\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tDPFST.Load(bapROM, (int) options.get(1).getValue());\n+\t\t\t}\n+\t\t\tcatch(Exception ex)\n+\t\t\t{\n+\t\t\t\tLog.error(\"N64-DP Loader: Failed to load FST\");\n+\t\t\t}\n+\n \t\t\tLog.info(\"N64 Loader: Creating segment RAM\");\n-\t\t\tMakeBlock(program, \".ram\", \"RAM content\", h.loadAddress, bapROM.getInputStream(0x1000),  buffROM.length - 0x1000, \"111\", null, log, monitor);\n \t\t\t\n-\t\t\tLog.info(\"N64-DP Loader: Loading DLL segments\");\n+\t\t\tByteArrayOutputStream outStream = new ByteArrayOutputStream();\n+\t\t\toutStream.write(bapROM.readBytes(0x1000, DPFST.offsets.get(0) - 0x1000));\n+\t\t\toutStream.write(new byte[0x7FFC00 - (DPFST.offsets.get(0) - 0x1000)]);\n+\t\t\tbyte[] data = outStream.toByteArray();\n+\t\t\tInputStream inStream = new ByteArrayInputStream(data);\n+\n+\t\t\tMakeBlock(program, \".ram\", \"RAM content\", h.loadAddress, inStream,  0x7FFC00, \"111\", null, log, monitor);\n \t\t\t\n+\t\t\tLog.info(\"N64-DP Loader: Loading DLL segments\");\n \t\t\ttry\n \t\t\t{\n-\t\t\t\tMakeDLLBlocks(program, h.loadAddress, bapROM, log, monitor);\n+\t\t\t\tMakeDLLBlocks(program, h.loadAddress, h.loadAddress + DPFST.offsets.get(0), bapROM, log, monitor);\n \t\t\t}\n \t\t\tcatch(Exception ex)\n \t\t\t{\n@@ -315,10 +338,9 @@ protected void load(ByteProvider provider, LoadSpec loadSpec, List<Option> optio\n \t\t\tLog.info(\"N64 Loader: Done Loading\");\n \t}\n \t\n-\tpublic void MakeDLLBlocks(Program program, long loadAddress, ByteArrayProvider s, MessageLog log, TaskMonitor monitor) throws IOException, InvalidInputException, MemoryAccessException, AddressOutOfBoundsException, CodeUnitInsertionException\n+\tpublic void MakeDLLBlocks(Program program, long loadAddress, long endAddress, ByteArrayProvider s, MessageLog log, TaskMonitor monitor) throws IOException, InvalidInputException, MemoryAccessException, AddressOutOfBoundsException, CodeUnitInsertionException, AddressOverflowException\n \t{\n-\t\t// TODO: use FST table\n-\t\tint size_DLLS_BIN = 0x2D3410;\n+\t\tint size_DLLS_BIN = DPFST.offsets.get(71) - DPFST.offsets.get(70);\n \t\t\n \t\tLog.info(\"DP: Loading DLL table data\");\n \t\tdll_tab = new DPDLLTab();\n@@ -329,34 +351,41 @@ public void MakeDLLBlocks(Program program, long loadAddress, ByteArrayProvider s\n \t\tobjects.Load(s, dll_tab);\n \t\t\n \t\tLog.info(\"DP: Creating global DLL redirection table\");\n-\t\tDPGlobalDLLTable.Build(program, dll_tab, loadAddress);\n+\t\tDPGlobalDLLTable.Build(program, dll_tab, loadAddress, log, monitor);\n \t\n-\t\tLog.info(String.format(\"DP: Found %d DLLs, %d object mappings\", dll_tab.dll_offsets.size(), objects.dllidx_to_objname.size()));\n-\t\t\n \t\tint numDllsToLoad = dll_tab.dll_offsets.size() - 1;\n+\t\tLog.info(String.format(\"DP: Found %d DLLs, %d object mappings\", numDllsToLoad, objects.dllidx_to_objname.size()));\n+\n \t\tmonitor.initialize(numDllsToLoad);\n \t\tmonitor.setMessage(\"Loading Dino DLLs (\" + numDllsToLoad + \")...\");\n+\n+\t\tlong dllAddress = 0x81000000;\n \t\t\n \t\tfor (int i = 0; i < numDllsToLoad; ++i)\n \t\t{\n \t\t\tmonitor.setProgress(i);\n \t\t\t\n \t\t\tint tabOffset = dll_tab.dll_offsets.get(i);\n+\t\t\tint dllBss = dll_tab.dll_bss_sizes.get(i);\n \t\t\tint dllOffset = dll_tab.GetDLLRomOffsetFromIndex(i);\n \t\t\tint dllSize = dll_tab.dll_offsets.get(i + 1) - tabOffset;\n-\t\t\tint dllId = i + 1; // see DPDLLTab for explanation\n+\t\t\tint dllId = i + 1; // DLLs begin at index 1 - otherwise half of the bank header is interpreted as a DLL entry\n \t\t\t\n-\t\t\tDPDLL dll = new DPDLL(program, dllId, dllOffset, tabOffset, dllSize);\n+\t\t\tDPDLL dll = new DPDLL(program, dllId, dllOffset, tabOffset, dllBss, dllSize);\n \t\t\t\n \t\t\ttry\n \t\t\t{\n-\t\t\t\tdll.Load(s, loadAddress, log, monitor, objects);\n+\t\t\t\tdll.Load(s, dllAddress, log, monitor, objects);\n \t\t\t\tdll.Relocate(s);\n \t\t\t}\n \t\t\tcatch (Exception ex)\n \t\t\t{\n-\t\t\t\tLog.error(\"Failed to log DLL %d: %s\", i, ex.getMessage());\n+\t\t\t\tLog.error(String.format(\"Failed to load DLL %d: %s\", i, ex.getMessage()));\n+\t\t\t\tLog.error(ExceptionUtils.getStackTrace(ex));\n \t\t\t}\n+\n+\t\t\tdllAddress += dllSize + dllBss;\n+\t\t\tdllAddress = Utils.align(dllAddress, 0x1000);\n \t\t}\n \t}\n \t\n@@ -467,6 +496,7 @@ public void ScanPatterns(byte[] rom, long loadAddress, String sigPath, Program p\n \t\t\tDomainObject domainObject, boolean isLoadIntoProgram) {\n \t\tList<Option> list = new ArrayList<Option>();\n \t\tlist.add(new Option(\"Signature file\", \"\"));\n+\t\tlist.add(new Option(\"FST offset\", 0xA4970));\n \t\treturn list;\n \t}\n "
  },
  {
    "sha": "9d9857e48ee74cef9306cba0ef673fc2ddf74b7d",
    "filename": "src/main/java/n64loaderwv/Utils.java",
    "status": "added",
    "additions": 34,
    "deletions": 0,
    "changes": 34,
    "blob_url": "https://github.com/HugoPeters/N64LoaderWV-DinoPlanet/blob/ee78c3b7c1f837a7748b9713ef3911fe66bf2e62/src/main/java/n64loaderwv/Utils.java",
    "raw_url": "https://github.com/HugoPeters/N64LoaderWV-DinoPlanet/raw/ee78c3b7c1f837a7748b9713ef3911fe66bf2e62/src/main/java/n64loaderwv/Utils.java",
    "contents_url": "https://api.github.com/repos/HugoPeters/N64LoaderWV-DinoPlanet/contents/src/main/java/n64loaderwv/Utils.java?ref=ee78c3b7c1f837a7748b9713ef3911fe66bf2e62",
    "patch": "@@ -0,0 +1,34 @@\n+package n64loaderwv;\n+\n+import ghidra.program.model.address.Address;\n+import ghidra.program.model.data.DataUtilities;\n+import ghidra.program.model.data.MutabilitySettingsDefinition;\n+import ghidra.program.model.data.PointerDataType;\n+import ghidra.program.model.data.DataUtilities.ClearDataMode;\n+import ghidra.program.model.listing.Data;\n+import ghidra.program.model.listing.Program;\n+import ghidra.program.model.util.CodeUnitInsertionException;\n+\n+public final class Utils\n+{\n+\tpublic static long align(long value, long alignment)\n+\t{\n+\t\treturn value >= 0 ? ((value + alignment - 1) / alignment) * alignment : (value / alignment) * alignment;\n+\t}\n+\n+\tpublic static void MakeConstantPtr(Program p, Address addr) throws CodeUnitInsertionException\n+\t{\n+\t\tData d = DataUtilities.createData(p, addr, PointerDataType.dataType, -1, false,\n+\t\t\t\tClearDataMode.CLEAR_ALL_UNDEFINED_CONFLICT_DATA);\n+\n+\t\t// you have no idea how long it took me to find how to fucking set this property\n+\t\tMutabilitySettingsDefinition.DEF.setChoice(d, MutabilitySettingsDefinition.CONSTANT);\n+\t}\n+\n+\tpublic static void MakeNormalPtr(Program p, Address addr) throws CodeUnitInsertionException\n+\t{\n+\t\tData d = DataUtilities.createData(p, addr, PointerDataType.dataType, -1, false,\n+\t\t\t\tClearDataMode.CLEAR_ALL_UNDEFINED_CONFLICT_DATA);\n+\n+\t}\n+}"
  }
]
