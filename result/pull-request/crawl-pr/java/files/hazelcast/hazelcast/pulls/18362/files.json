[
  {
    "sha": "efa596d30135ac03506d27c6b995d9f59dad918d",
    "filename": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/management/PollMCEventsMessageTask.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/hazelcast/hazelcast/blob/556d8c81a9fba648aa56cb8f0450b309a73f2c5d/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/management/PollMCEventsMessageTask.java",
    "raw_url": "https://github.com/hazelcast/hazelcast/raw/556d8c81a9fba648aa56cb8f0450b309a73f2c5d/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/management/PollMCEventsMessageTask.java",
    "contents_url": "https://api.github.com/repos/hazelcast/hazelcast/contents/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/management/PollMCEventsMessageTask.java?ref=556d8c81a9fba648aa56cb8f0450b309a73f2c5d",
    "patch": "@@ -45,7 +45,7 @@ protected Object call() throws Exception {\n         if (mcs == null) {\n             return Collections.<MCEventDTO>emptyList();\n         }\n-        List<Event> polledEvents = mcs.pollMCEvents();\n+        List<Event> polledEvents = mcs.pollMCEvents(connection.getRemoteAddress());\n         List<MCEventDTO> result = new ArrayList<>(polledEvents.size());\n         for (Event event : polledEvents) {\n             result.add(MCEventDTO.fromEvent(event));"
  },
  {
    "sha": "c72f0b86f001c91bad9e61e2f165ab400d571d3f",
    "filename": "hazelcast/src/main/java/com/hazelcast/internal/management/ManagementCenterService.java",
    "status": "modified",
    "additions": 146,
    "deletions": 24,
    "changes": 170,
    "blob_url": "https://github.com/hazelcast/hazelcast/blob/556d8c81a9fba648aa56cb8f0450b309a73f2c5d/hazelcast/src/main/java/com/hazelcast/internal/management/ManagementCenterService.java",
    "raw_url": "https://github.com/hazelcast/hazelcast/raw/556d8c81a9fba648aa56cb8f0450b309a73f2c5d/hazelcast/src/main/java/com/hazelcast/internal/management/ManagementCenterService.java",
    "contents_url": "https://api.github.com/repos/hazelcast/hazelcast/contents/hazelcast/src/main/java/com/hazelcast/internal/management/ManagementCenterService.java?ref=556d8c81a9fba648aa56cb8f0450b309a73f2c5d",
    "patch": "@@ -16,6 +16,7 @@\n \n package com.hazelcast.internal.management;\n \n+import com.hazelcast.cluster.Address;\n import com.hazelcast.console.ConsoleApp;\n import com.hazelcast.core.HazelcastException;\n import com.hazelcast.instance.impl.HazelcastInstanceImpl;\n@@ -31,13 +32,19 @@\n \n import javax.annotation.Nonnull;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.OptionalLong;\n import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.LongSupplier;\n \n import static com.hazelcast.instance.impl.OutOfMemoryErrorDispatcher.inspectOutOfMemoryError;\n \n@@ -46,36 +53,155 @@\n  */\n public class ManagementCenterService {\n \n+    static class MCEventStore {\n+        static final long MC_EVENTS_WINDOW_MILLIS = TimeUnit.SECONDS.toMillis(30);\n+        private final LongSupplier clock;\n+        private volatile long mostRecentAccessTimestamp;\n+        private final ConcurrentMap<Address, Long> lastAccessTimestamps = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Address, Integer> eventsReceivedInSameMillisec = new ConcurrentHashMap<>();\n+        private final BlockingQueue<Event> mcEvents;\n+\n+        MCEventStore(LongSupplier clock, BlockingQueue<Event> mcEvents) {\n+            this.clock = clock;\n+            this.mostRecentAccessTimestamp = clock.getAsLong();\n+            this.mcEvents = mcEvents;\n+        }\n+\n+        @SuppressFBWarnings(\"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+        void log(Event event) {\n+            if (clock.getAsLong() - mostRecentAccessTimestamp > MC_EVENTS_WINDOW_MILLIS) {\n+                // ignore event and clear the queue if the last poll happened a while ago\n+                onMCEventWindowExceeded();\n+            } else {\n+                mcEvents.offer(event);\n+            }\n+        }\n+\n+        void onMCEventWindowExceeded() {\n+            mcEvents.clear();\n+            lastAccessTimestamps.clear();\n+            eventsReceivedInSameMillisec.clear();\n+        }\n+\n+        /**\n+         * @param mcRemoteAddr the address of the calling MC instance.\n+         * @return the events which were added to the queue since this MC last polled, or all known events if the MC polls for the\n+         * first time.\n+         */\n+        public List<Event> pollMCEvents(Address mcRemoteAddr) {\n+            Long lastAccessObj = lastAccessTimestamps.get(mcRemoteAddr);\n+            mostRecentAccessTimestamp = clock.getAsLong();\n+            long pollStartedAt = mostRecentAccessTimestamp;\n+            List<Event> events;\n+            if (lastAccessObj == null) {\n+                System.out.println(\"null -> \");\n+                events = new ArrayList<>(mcEvents);\n+            } else {\n+                Integer receivedInSameMsWrapper = eventsReceivedInSameMillisec.get(mcRemoteAddr);\n+                int receivedInSameMs = receivedInSameMsWrapper == null ? 0 : receivedInSameMsWrapper;\n+                long lastAccess = lastAccessObj;\n+                events = new ArrayList<>(mcEvents.size());\n+                for (Event evt : mcEvents) {\n+                    System.out.println(\"check evt \" + evt.getTimestamp() + \" >= \" + lastAccess);\n+                    if (evt.getTimestamp() >= lastAccess) {\n+                        System.out.println(\"ts passed...\");\n+                        if (receivedInSameMs-- <= 0) {\n+                            System.out.println(\"recvMillis passed... \");\n+                            System.out.println(\"add: \" + evt);\n+                            events.add(evt);\n+                        }\n+                    }\n+                }\n+            }\n+            updateLatestAccessStats(mcRemoteAddr, pollStartedAt);\n+            int sameMilliEvents = 0;\n+            for (int i = events.size() - 1; i >= 0 && events.get(i).getTimestamp() >= mostRecentAccessTimestamp; --i) {\n+                ++sameMilliEvents;\n+            }\n+            eventsReceivedInSameMillisec.put(mcRemoteAddr, sameMilliEvents);\n+            return events;\n+        }\n+\n+        /**\n+         * Updates {@link #mostRecentAccessTimestamp} to the current time, removes old entries from {@link #lastAccessTimestamps}\n+         * and removes the entries of {@link #mcEvents} that are already read by all known MCs.\n+         *\n+         * @param mcRemoteAddr\n+         * @param pollStartedAt\n+         */\n+        private void updateLatestAccessStats(Address mcRemoteAddr, long pollStartedAt) {\n+            lastAccessTimestamps.put(mcRemoteAddr, pollStartedAt);\n+            if (mcEvents.isEmpty()) {\n+                return;\n+            }\n+            OptionalLong maybeOldestAccess = lastAccessTimestamps.values().stream().mapToLong(Long::longValue).min();\n+            if (maybeOldestAccess.isPresent()) {\n+                long oldestAccess = maybeOldestAccess.getAsLong();\n+                cleanUpLastAccessTimestamps(oldestAccess, pollStartedAt);\n+                Iterator<Event> it = mcEvents.iterator();\n+                while (it.hasNext()) {\n+                    Event evt = it.next();\n+                    if (evt.getTimestamp() >= oldestAccess) {\n+                        break;\n+                    }\n+                    it.remove();\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Removes the entries from {@link #lastAccessTimestamps} which record accesses older than\n+         * {@link #MC_EVENTS_WINDOW_MILLIS}. Also removes the entry from {@link #eventsReceivedInSameMillisec} with the same key.\n+         *\n+         * @param oldestAccess\n+         * @param pollStartedAt\n+         */\n+        private void cleanUpLastAccessTimestamps(long oldestAccess, long pollStartedAt) {\n+            if (pollStartedAt - oldestAccess > MC_EVENTS_WINDOW_MILLIS) {\n+                Iterator<Map.Entry<Address, Long>> it = lastAccessTimestamps.entrySet().iterator();\n+                while (it.hasNext()) {\n+                    Map.Entry<Address, Long> entry = it.next();\n+                    if (pollStartedAt - entry.getValue() > MC_EVENTS_WINDOW_MILLIS) {\n+                        it.remove();\n+                        eventsReceivedInSameMillisec.remove(entry.getKey());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     public static final String SERVICE_NAME = \"hz:core:managementCenterService\";\n \n     private static final int MIN_EVENT_QUEUE_CAPACITY = 1000;\n     private static final int EXECUTOR_QUEUE_CAPACITY_PER_THREAD = 1000;\n     private static final long TMS_CACHE_TIMEOUT_NANOS = TimeUnit.SECONDS.toNanos(1);\n-    private static final long MC_EVENTS_WINDOW_NANOS = TimeUnit.SECONDS.toNanos(30);\n \n     private final HazelcastInstanceImpl instance;\n     private final ILogger logger;\n \n     private final AtomicReference<String> tmsJson = new AtomicReference<>();\n     private final TimedMemberStateFactory tmsFactory;\n     private final AtomicBoolean tmsFactoryInitialized = new AtomicBoolean(false);\n-    private final BlockingQueue<Event> mcEvents;\n     private final ConsoleCommandHandler commandHandler;\n     private final ClientBwListConfigHandler bwListConfigHandler;\n+    private final MCEventStore eventStore;\n \n     private volatile ManagementCenterEventListener eventListener;\n     private volatile String lastMCConfigETag;\n     private volatile long lastTMSUpdateNanos;\n-    private volatile long lastMCEventsPollNanos = System.nanoTime();\n \n     public ManagementCenterService(HazelcastInstanceImpl instance) {\n+        this(instance, System::currentTimeMillis);\n+    }\n+\n+    public ManagementCenterService(HazelcastInstanceImpl instance, LongSupplier clock) {\n         this.instance = instance;\n         this.logger = instance.node.getLogger(ManagementCenterService.class);\n         this.tmsFactory = instance.node.getNodeExtension().createTimedMemberStateFactory(instance);\n         int partitionCount = instance.node.getPartitionService().getPartitionCount();\n-        this.mcEvents = new LinkedBlockingQueue<>(Math.max(MIN_EVENT_QUEUE_CAPACITY, partitionCount));\n         this.commandHandler = new ConsoleCommandHandler(instance);\n         this.bwListConfigHandler = new ClientBwListConfigHandler(instance.node.clientEngine);\n+        this.eventStore = new MCEventStore(clock, new LinkedBlockingQueue<>(Math.max(MIN_EVENT_QUEUE_CAPACITY, partitionCount)));\n         registerExecutor();\n     }\n \n@@ -130,23 +256,16 @@ private void registerExecutor() {\n      * <p>\n      * Events are used by Management Center to show the user what happens when on a cluster member.\n      */\n-    @SuppressFBWarnings(\"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n     public void log(Event event) {\n-        if (System.nanoTime() - lastMCEventsPollNanos > MC_EVENTS_WINDOW_NANOS) {\n-            // ignore event and clear the queue if the last poll happened a while ago\n-            onMCEventWindowExceeded();\n-        } else {\n-            mcEvents.offer(event);\n-        }\n-\n+        eventStore.log(event);\n         if (eventListener != null) {\n             eventListener.onEventLogged(event);\n         }\n     }\n \n     // visible for tests\n     void onMCEventWindowExceeded() {\n-        mcEvents.clear();\n+        eventStore.onMCEventWindowExceeded();\n     }\n \n     // used for tests\n@@ -161,27 +280,30 @@ public void setEventListener(ManagementCenterEventListener eventListener) {\n      * @return polled events\n      */\n     @Nonnull\n-    public List<Event> pollMCEvents() {\n-        List<Event> polled = new ArrayList<>();\n-        mcEvents.drainTo(polled);\n-        lastMCEventsPollNanos = System.nanoTime();\n-        return polled;\n+    public List<Event> pollMCEvents(Address mcRemoteAddr) {\n+        return eventStore.pollMCEvents(mcRemoteAddr);\n+    }\n+\n+    // visible for testing\n+    void clear() {\n+        eventStore.onMCEventWindowExceeded();\n     }\n \n     /**\n      * Run console command with internal {@link ConsoleCommandHandler}.\n      *\n-     * @param command   command string (see {@link ConsoleApp})\n-     * @return          command output\n+     * @param command command string (see {@link ConsoleApp})\n+     * @return command output\n      */\n-    public String runConsoleCommand(String command) throws InterruptedException {\n+    public String runConsoleCommand(String command)\n+            throws InterruptedException {\n         return commandHandler.handleCommand(command);\n     }\n \n     /**\n      * Returns ETag value of last applied MC config (client B/W list filtering).\n      *\n-     * @return  last or <code>null</code>\n+     * @return last or <code>null</code>\n      */\n     public String getLastMCConfigETag() {\n         return lastMCConfigETag;\n@@ -190,8 +312,8 @@ public String getLastMCConfigETag() {\n     /**\n      * Applies given MC config (client B/W list filtering).\n      *\n-     * @param eTag          ETag of new config\n-     * @param bwListConfig  new config\n+     * @param eTag         ETag of new config\n+     * @param bwListConfig new config\n      */\n     public void applyMCConfig(String eTag, ClientBwListDTO bwListConfig) {\n         if (eTag.equals(lastMCConfigETag)) {"
  },
  {
    "sha": "8aa73fc6c68a831c6b929d6261a8e2dc2f1b0ee2",
    "filename": "hazelcast/src/test/java/com/hazelcast/internal/management/MCEventStoreTest.java",
    "status": "added",
    "additions": 261,
    "deletions": 0,
    "changes": 261,
    "blob_url": "https://github.com/hazelcast/hazelcast/blob/556d8c81a9fba648aa56cb8f0450b309a73f2c5d/hazelcast/src/test/java/com/hazelcast/internal/management/MCEventStoreTest.java",
    "raw_url": "https://github.com/hazelcast/hazelcast/raw/556d8c81a9fba648aa56cb8f0450b309a73f2c5d/hazelcast/src/test/java/com/hazelcast/internal/management/MCEventStoreTest.java",
    "contents_url": "https://api.github.com/repos/hazelcast/hazelcast/contents/hazelcast/src/test/java/com/hazelcast/internal/management/MCEventStoreTest.java?ref=556d8c81a9fba648aa56cb8f0450b309a73f2c5d",
    "patch": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.management;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.internal.management.events.Event;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.NightlyTest;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.LongSupplier;\n+import java.util.stream.IntStream;\n+\n+import static com.hazelcast.internal.management.ManagementCenterService.MCEventStore.MC_EVENTS_WINDOW_MILLIS;\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class MCEventStoreTest {\n+\n+    private static class FakeClock\n+            implements LongSupplier {\n+\n+        long now = 42;\n+\n+        @Override\n+        public long getAsLong() {\n+            return now;\n+        }\n+    }\n+\n+    static final Address MC_1_REMOTE_ADDR;\n+\n+    static final Address MC_2_REMOTE_ADDR;\n+\n+    static final Address MC_3_REMOTE_ADDR;\n+\n+    static {\n+        try {\n+            MC_1_REMOTE_ADDR = new Address(\"localhost\", 5701);\n+            MC_2_REMOTE_ADDR = new Address(\"localhost\", 5702);\n+            MC_3_REMOTE_ADDR = new Address(\"localhost\", 5703);\n+        } catch (UnknownHostException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private LinkedBlockingQueue<Event> queue;\n+\n+    private ManagementCenterService.MCEventStore eventStore;\n+\n+    private FakeClock clock;\n+\n+    private void assertPolledEventCount(int expectedEventCount, Address mcRemoteAddress) {\n+        assertEquals(expectedEventCount, eventStore.pollMCEvents(mcRemoteAddress).size());\n+    }\n+\n+    void inNextMilli(Runnable r) {\n+        clock.now++;\n+        r.run();\n+    }\n+\n+    private void logEvent() {\n+        eventStore.log(new ManagementCenterServiceIntegrationTest.TestEvent(clock.now));\n+    }\n+\n+    @Before\n+    public void before() {\n+        clock = new FakeClock();\n+        queue = new LinkedBlockingQueue<>();\n+        eventStore = new ManagementCenterService.MCEventStore(clock, queue);\n+    }\n+\n+    @Test\n+    public void multipleMCs_canPollSeparately() {\n+        assertPolledEventCount(0, MC_2_REMOTE_ADDR);\n+        inNextMilli(() -> {\n+            logEvent();\n+            logEvent();\n+        });\n+        inNextMilli(() -> {\n+            assertPolledEventCount(2, MC_1_REMOTE_ADDR);\n+            assertPolledEventCount(2, MC_2_REMOTE_ADDR);\n+            assertPolledEventCount(0, MC_1_REMOTE_ADDR);\n+            assertPolledEventCount(0, MC_2_REMOTE_ADDR);\n+        });\n+        logEvent();\n+        inNextMilli(() -> {\n+            assertPolledEventCount(1, MC_1_REMOTE_ADDR);\n+        });\n+        inNextMilli(() -> {\n+            logEvent();\n+            assertPolledEventCount(1, MC_1_REMOTE_ADDR);\n+            assertPolledEventCount(2, MC_2_REMOTE_ADDR);\n+        });\n+        inNextMilli(() -> {\n+            logEvent();\n+            logEvent();\n+        });\n+        clock.now += MC_EVENTS_WINDOW_MILLIS;\n+        logEvent();\n+        inNextMilli(() -> {\n+            assertPolledEventCount(0, MC_1_REMOTE_ADDR);\n+            assertPolledEventCount(0, MC_2_REMOTE_ADDR);\n+        });\n+        inNextMilli(() -> {\n+            assertPolledEventCount(0, MC_1_REMOTE_ADDR);\n+        });\n+        inNextMilli(() -> {\n+            logEvent();\n+            assertPolledEventCount(1, MC_1_REMOTE_ADDR);\n+            assertPolledEventCount(1, MC_2_REMOTE_ADDR);\n+        });\n+    }\n+\n+    @Test\n+    public void elemsReadByAllMCsAreCleared() {\n+        eventStore.pollMCEvents(MC_2_REMOTE_ADDR);\n+        inNextMilli(() -> {\n+            logEvent();\n+            logEvent();\n+        });\n+        clock.now += MC_EVENTS_WINDOW_MILLIS;\n+        inNextMilli(() -> {\n+            assertPolledEventCount(2, MC_1_REMOTE_ADDR);\n+            assertPolledEventCount(2, MC_2_REMOTE_ADDR);\n+            assertEquals(0, queue.size());\n+        });\n+    }\n+\n+    @Test\n+    public void sameMilliEvent_reportedInNextPoll() {\n+        assertPolledEventCount(0, MC_1_REMOTE_ADDR);\n+        logEvent();\n+        logEvent();\n+        inNextMilli(() -> {\n+            logEvent();\n+            logEvent();\n+            assertPolledEventCount(4, MC_1_REMOTE_ADDR);\n+            logEvent();\n+            logEvent();\n+            logEvent();\n+        });\n+        inNextMilli(() -> {\n+            logEvent();\n+            logEvent();\n+        });\n+        inNextMilli(() -> {\n+            // 3 of these were reported in the same MS as the previous poll, 2 of them later\n+            assertPolledEventCount(5, MC_1_REMOTE_ADDR);\n+        });\n+    }\n+\n+    @Test\n+    public void disconnectRecognized_after30secInactivity() {\n+        inNextMilli(() -> {\n+            assertPolledEventCount(0, MC_1_REMOTE_ADDR);\n+            assertPolledEventCount(0, MC_2_REMOTE_ADDR);\n+            assertPolledEventCount(0, MC_3_REMOTE_ADDR);\n+        });\n+        logEvent();\n+        inNextMilli(() -> {\n+            assertPolledEventCount(1, MC_3_REMOTE_ADDR);\n+        });\n+        clock.now += TimeUnit.SECONDS.toMillis(15);\n+        inNextMilli(() -> {\n+            assertPolledEventCount(1, MC_1_REMOTE_ADDR);\n+        });\n+        inNextMilli(() -> {\n+            logEvent();\n+            logEvent();\n+        });\n+        clock.now += TimeUnit.SECONDS.toMillis(15);\n+        logEvent();\n+        logEvent();\n+        inNextMilli(() -> {\n+            assertPolledEventCount(4, MC_1_REMOTE_ADDR);\n+            // reads all 5 events, since its last-access TS is already cleared during previous read\n+            assertPolledEventCount(5, MC_3_REMOTE_ADDR);\n+        });\n+    }\n+\n+    /**\n+     * Runs 50 threads in parallel, each thread performs 1000 tasks. Each task is one of:\n+     * - logging 800 events\n+     * - or polling as MC_1\n+     * - or polling as MC_2\n+     * <p>\n+     * The test fails if any of the threads throws {@link java.util.ConcurrentModificationException} (or any other exception).\n+     */\n+    @Test\n+    @Category(NightlyTest.class)\n+    public void stressTest()\n+            throws InterruptedException {\n+        Runnable[] tasks = new Runnable[]{\n+                () -> {\n+                    for (int i = 0; i < 800; ++i) {\n+                        inNextMilli(this::logEvent);\n+                    }\n+                },\n+                () -> inNextMilli(() -> eventStore.pollMCEvents(MC_1_REMOTE_ADDR)),\n+                () -> inNextMilli(() -> eventStore.pollMCEvents(MC_2_REMOTE_ADDR))\n+        };\n+        Random random = new Random();\n+\n+        Set<Throwable> thrownByThreads = new ConcurrentSkipListSet<>();\n+\n+        ThreadFactory tf = new ThreadFactoryBuilder()\n+                .setUncaughtExceptionHandler((thread, exc) -> {\n+                    exc.printStackTrace();\n+                    thrownByThreads.add(exc);\n+                })\n+                .build();\n+\n+        int threadCount = 50;\n+        int taskCount = 1000;\n+        List<Thread> threads = IntStream.range(0, threadCount)\n+                .mapToObj(i -> IntStream.range(0, taskCount)\n+                        .mapToObj(j -> tasks[Math.abs(random.nextInt()) % tasks.length])\n+                        .collect(toList()))\n+                .map(tasksForThread -> tf.newThread(() -> tasksForThread.forEach(Runnable::run)))\n+                .collect(toList());\n+        threads.forEach(Thread::start);\n+        for (Thread thread : threads) {\n+            thread.join();\n+        }\n+        if (!thrownByThreads.isEmpty()) {\n+            thrownByThreads.forEach(Throwable::printStackTrace);\n+            throw new AssertionError(\"at least one thread threw an exception\");\n+        }\n+    }\n+}"
  },
  {
    "sha": "435ebc55fb892273b34c81e61cbc56080fcc820c",
    "filename": "hazelcast/src/test/java/com/hazelcast/internal/management/ManagementCenterServiceIntegrationTest.java",
    "status": "modified",
    "additions": 22,
    "deletions": 11,
    "changes": 33,
    "blob_url": "https://github.com/hazelcast/hazelcast/blob/556d8c81a9fba648aa56cb8f0450b309a73f2c5d/hazelcast/src/test/java/com/hazelcast/internal/management/ManagementCenterServiceIntegrationTest.java",
    "raw_url": "https://github.com/hazelcast/hazelcast/raw/556d8c81a9fba648aa56cb8f0450b309a73f2c5d/hazelcast/src/test/java/com/hazelcast/internal/management/ManagementCenterServiceIntegrationTest.java",
    "contents_url": "https://api.github.com/repos/hazelcast/hazelcast/contents/hazelcast/src/test/java/com/hazelcast/internal/management/ManagementCenterServiceIntegrationTest.java?ref=556d8c81a9fba648aa56cb8f0450b309a73f2c5d",
    "patch": "@@ -35,6 +35,7 @@\n \n import java.util.List;\n \n+import static com.hazelcast.internal.management.MCEventStoreTest.MC_1_REMOTE_ADDR;\n import static com.hazelcast.internal.util.StringUtil.isNullOrEmpty;\n import static com.hazelcast.test.Accessors.getNode;\n import static org.junit.Assert.assertEquals;\n@@ -45,7 +46,8 @@\n \n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class ManagementCenterServiceIntegrationTest extends HazelcastTestSupport {\n+public class ManagementCenterServiceIntegrationTest\n+        extends HazelcastTestSupport {\n \n     private static final String CLUSTER_NAME = \"mc-service-tests\";\n \n@@ -62,6 +64,7 @@ public void setUp() {\n             ManagementCenterService mcs = getNode(instance).getManagementCenterService();\n             assertNotNull(mcs);\n             this.mcs = mcs;\n+            mcs.clear();\n         });\n     }\n \n@@ -105,14 +108,12 @@ public void testTimedMemberState_ignoresCache_longTimeFrame() {\n \n     @Test\n     public void testMCEvents_storesEvents_recentPoll() {\n-        mcs.pollMCEvents();\n-\n         TestEvent expectedEvent = new TestEvent();\n         mcs.log(expectedEvent);\n         mcs.log(new TestEvent());\n         mcs.log(new TestEvent());\n \n-        List<Event> actualEvents = mcs.pollMCEvents();\n+        List<Event> actualEvents = mcs.pollMCEvents(MC_1_REMOTE_ADDR);\n         assertEquals(3, actualEvents.size());\n         assertEquals(expectedEvent, actualEvents.get(0));\n     }\n@@ -122,23 +123,33 @@ public void testMCEvents_storesEvents_noPollAtAll() {\n         mcs.log(new TestEvent());\n         mcs.log(new TestEvent());\n \n-        assertEquals(2, mcs.pollMCEvents().size());\n+        assertEquals(2, mcs.pollMCEvents(MC_1_REMOTE_ADDR).size());\n     }\n \n     @Test\n     public void testMCEvents_clearsEventQueue_noRecentPoll() {\n-        mcs.pollMCEvents();\n         mcs.log(new TestEvent());\n         mcs.log(new TestEvent());\n \n         mcs.onMCEventWindowExceeded();\n-        assertEquals(0, mcs.pollMCEvents().size());\n+        assertEquals(0, mcs.pollMCEvents(MC_1_REMOTE_ADDR).size());\n \n-        mcs.log(new TestEvent());\n-        assertEquals(1, mcs.pollMCEvents().size());\n+        mcs.log(new TestEvent(System.currentTimeMillis()));\n+        assertEquals(1, mcs.pollMCEvents(MC_1_REMOTE_ADDR).size());\n     }\n \n-    private static class TestEvent implements Event {\n+    static class TestEvent\n+            implements Event {\n+\n+        private final long timestamp;\n+\n+        TestEvent() {\n+            this(42);\n+        }\n+\n+        TestEvent(long timestamp) {\n+            this.timestamp = timestamp;\n+        }\n \n         @Override\n         public EventMetadata.EventType getType() {\n@@ -147,7 +158,7 @@ public void testMCEvents_clearsEventQueue_noRecentPoll() {\n \n         @Override\n         public long getTimestamp() {\n-            return 42;\n+            return timestamp;\n         }\n \n         @Override"
  }
]
