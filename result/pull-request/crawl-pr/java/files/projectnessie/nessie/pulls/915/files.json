[
  {
    "sha": "ea3abd2d71a8784df1be514f358715a8485db18a",
    "filename": "versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/HistoryRetriever.java",
    "status": "modified",
    "additions": 36,
    "deletions": 12,
    "changes": 48,
    "blob_url": "https://github.com/projectnessie/nessie/blob/c91f3a810a2679399485614ec04a42ec9dbe51b0/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/HistoryRetriever.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/c91f3a810a2679399485614ec04a42ec9dbe51b0/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/HistoryRetriever.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/HistoryRetriever.java?ref=c91f3a810a2679399485614ec04a42ec9dbe51b0",
    "patch": "@@ -21,6 +21,7 @@\n import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n import java.util.Spliterators;\n@@ -44,44 +45,62 @@\n   private final Store store;\n   private final InternalL1 start;\n   private final Id end;\n+  private final Map<Id, InternalL1> unsavedL1s;\n \n-  public HistoryRetriever(Store store, InternalL1 start, Id end, boolean retrieveL1, boolean retrieveCommit, boolean includeEndEmpty) {\n-    super();\n+  public HistoryRetriever(Store store, InternalL1 start, Id end, boolean retrieveL1, boolean retrieveCommit,\n+      boolean includeEndEmpty) {\n+    this(store, start, end, retrieveL1, retrieveCommit, includeEndEmpty, Collections.emptyMap());\n+  }\n+\n+  public HistoryRetriever(Store store, InternalL1 start, Id end, boolean retrieveL1, boolean retrieveCommit,\n+      boolean includeEndEmpty, Map<Id, InternalL1> unsavedL1s) {\n     this.store = store;\n     this.start = start;\n     this.end = end;\n     this.retrieveL1 = retrieveL1;\n     this.retrieveCommit = retrieveCommit;\n     this.includeEndEmpty = includeEndEmpty;\n+    this.unsavedL1s = unsavedL1s;\n   }\n \n-  class HistoryItem {\n+  static class HistoryItem {\n \n-    private Id id;\n+    private final Id id;\n     private InternalL1 l1;\n     private InternalCommitMetadata commitMetadata;\n \n-    public HistoryItem(Id id) {\n+    HistoryItem(Id id) {\n       this.id = id;\n     }\n \n-    public InternalL1 getL1() {\n+    InternalL1 getL1() {\n       return l1;\n     }\n \n-    public Id getId() {\n+    private void setL1(InternalL1 l1) {\n+      this.l1 = l1;\n+    }\n+\n+    private Id getL1MetadataId() {\n+      return l1.getMetadataId();\n+    }\n+\n+    Id getId() {\n       return id;\n     }\n \n-    public InternalCommitMetadata getMetadata() {\n+    InternalCommitMetadata getMetadata() {\n       return commitMetadata;\n     }\n \n+    private void setMetadata(InternalCommitMetadata commitMetadata) {\n+      this.commitMetadata = commitMetadata;\n+    }\n+\n     @Override\n     public String toString() {\n       return \"HistoryItem [id=\" + id + \", l1=\" + l1 + \", commitMetadata=\" + commitMetadata + \"]\";\n     }\n-\n   }\n \n   Stream<HistoryItem> getStream() {\n@@ -151,14 +170,19 @@ private void calculateNextList(ParentList list) throws ReferenceNotFoundExceptio\n         final HistoryItem item = new HistoryItem(parent);\n         items.add(item);\n         if (retrieveL1 || retrieveCommit || lastInList) {\n-          loadOps.load(EntityType.L1, InternalL1.class, parent, l1 -> item.l1 = l1);\n+          InternalL1 unsaved = unsavedL1s.get(parent);\n+          if (unsaved != null) {\n+            item.setL1(unsaved);\n+          } else {\n+            loadOps.load(EntityType.L1, InternalL1.class, parent, item::setL1);\n+          }\n         }\n \n         if (retrieveCommit && !parent.equals(InternalL1.EMPTY_ID)) {\n           secondOps.loadDeferred(EntityType.COMMIT_METADATA,\n               InternalCommitMetadata.class,\n-              () -> item.l1.getMetadataId(),\n-              cmd -> item.commitMetadata = cmd);\n+              item::getL1MetadataId,\n+              item::setMetadata);\n         }\n \n         if (parent.equals(end)) {"
  },
  {
    "sha": "1e62ab396f8dd53edd53a0c56b492a7d0d116663",
    "filename": "versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/InternalBranch.java",
    "status": "modified",
    "additions": 17,
    "deletions": 1,
    "changes": 18,
    "blob_url": "https://github.com/projectnessie/nessie/blob/c91f3a810a2679399485614ec04a42ec9dbe51b0/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/InternalBranch.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/c91f3a810a2679399485614ec04a42ec9dbe51b0/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/InternalBranch.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/InternalBranch.java?ref=c91f3a810a2679399485614ec04a42ec9dbe51b0",
    "patch": "@@ -17,6 +17,7 @@\n \n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n@@ -45,6 +46,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Throwables;\n@@ -263,12 +265,17 @@ public UpdateState getUpdateState(Store store)  {\n     Id lastId = null;\n     final List<SaveOp<?>> toSave = new ArrayList<>();\n \n+    Map<Id, InternalL1> unsavedL1s = new HashMap<>();\n     for (Commit c : unsavedCommits) {\n       for (UnsavedDelta delta : c.deltas) {\n         tree = delta.apply(tree);\n       }\n+\n+      unsavedL1s.put(lastL1.getId(), lastL1);\n+\n       lastL1 = lastL1.getChildWithTree(c.commit, tree, c.keyMutationList)\n-          .withCheckpointAsNecessary(store);\n+          .withCheckpointAsNecessary(store, unsavedL1s);\n+\n       toSave.add(EntityType.L1.createSaveOpForEntity(lastL1));\n       lastId = c.id;\n       if (lastUnsaved != c) {\n@@ -310,6 +317,11 @@ private UpdateState(\n       }\n     }\n \n+    @VisibleForTesting\n+    InternalL1 unsafeGetL1() {\n+      return finalL1;\n+    }\n+\n     /**\n      * Save any pending saves if they are not already saved.\n      *\n@@ -583,4 +595,8 @@ Ref applyToConsumer(Ref consumer) {\n         .backToRef();\n   }\n \n+  @VisibleForTesting\n+  List<Commit> getCommits() {\n+    return Collections.unmodifiableList(commits);\n+  }\n }"
  },
  {
    "sha": "238dbb67dd003176b9dd373faad8ed6a8eb551f7",
    "filename": "versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/InternalL1.java",
    "status": "modified",
    "additions": 3,
    "deletions": 2,
    "changes": 5,
    "blob_url": "https://github.com/projectnessie/nessie/blob/c91f3a810a2679399485614ec04a42ec9dbe51b0/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/InternalL1.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/c91f3a810a2679399485614ec04a42ec9dbe51b0/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/InternalL1.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/InternalL1.java?ref=c91f3a810a2679399485614ec04a42ec9dbe51b0",
    "patch": "@@ -17,6 +17,7 @@\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n@@ -63,8 +64,8 @@ InternalL1 getChildWithTree(Id metadataId, IdMap tree, KeyMutationList mutations\n     return new InternalL1(metadataId, tree, null, keyList, parents, DT.now());\n   }\n \n-  InternalL1 withCheckpointAsNecessary(Store store) {\n-    return keyList.createCheckpointIfNeeded(this, store)\n+  InternalL1 withCheckpointAsNecessary(Store store, Map<Id, InternalL1> unsavedL1s) {\n+    return keyList.createCheckpointIfNeeded(this, store, unsavedL1s)\n         .map(keylist -> new InternalL1(metadataId, tree, null, keylist, parentList, DT.now())).orElse(this);\n   }\n "
  },
  {
    "sha": "216de4a5ff62c372a24dc15f33d1aff4c1abd029",
    "filename": "versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/KeyList.java",
    "status": "modified",
    "additions": 10,
    "deletions": 9,
    "changes": 19,
    "blob_url": "https://github.com/projectnessie/nessie/blob/c91f3a810a2679399485614ec04a42ec9dbe51b0/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/KeyList.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/c91f3a810a2679399485614ec04a42ec9dbe51b0/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/KeyList.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/KeyList.java?ref=c91f3a810a2679399485614ec04a42ec9dbe51b0",
    "patch": "@@ -19,6 +19,7 @@\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n@@ -48,7 +49,7 @@\n \n   abstract KeyList plus(Id parent, List<KeyMutation> mutations);\n \n-  abstract Optional<KeyList> createCheckpointIfNeeded(InternalL1 startingPoint, Store store);\n+  abstract Optional<KeyList> createCheckpointIfNeeded(InternalL1 startingPoint, Store store, Map<Id, InternalL1> unsavedL1s);\n \n   abstract Type getType();\n \n@@ -97,29 +98,29 @@ public KeyList plus(Id parent, List<KeyMutation> mutations) {\n     }\n \n     @Override\n-    public Optional<KeyList> createCheckpointIfNeeded(InternalL1 startingPoint, Store store) {\n+    public Optional<KeyList> createCheckpointIfNeeded(InternalL1 startingPoint, Store store, Map<Id, InternalL1> unsavedL1s) {\n       if (getDistanceFromCheckpointCommits() < MAX_DELTAS) {\n         return Optional.empty();\n       }\n \n \n-      return Optional.of(generateNewCheckpoint(startingPoint, store));\n+      return Optional.of(generateNewCheckpoint(startingPoint, store, unsavedL1s));\n     }\n \n \n     @Override\n     Stream<InternalKey> getKeys(InternalL1 startingPoint, Store store) {\n-      IterResult keys = getKeysIter(startingPoint, store);\n+      IterResult keys = getKeysIter(startingPoint, store, Collections.emptyMap());\n       if (keys.isChanged()) {\n         return keys.keyList;\n       }\n \n       return keys.list.getKeys(startingPoint, store);\n     }\n \n-    private CompleteList generateNewCheckpoint(InternalL1 startingPoint, Store store) {\n+    private CompleteList generateNewCheckpoint(InternalL1 startingPoint, Store store, Map<Id, InternalL1> unsavedL1s) {\n \n-      IterResult result = getKeysIter(startingPoint, store);\n+      IterResult result = getKeysIter(startingPoint, store, unsavedL1s);\n       if (!result.isChanged()) {\n         return result.list;\n       }\n@@ -131,8 +132,8 @@ private CompleteList generateNewCheckpoint(InternalL1 startingPoint, Store store\n       return accum.getCompleteList(getMutations());\n     }\n \n-    private IterResult getKeysIter(InternalL1 startingPoint, Store store) {\n-      HistoryRetriever retriever = new HistoryRetriever(store, startingPoint, getPreviousCheckpoint(), true, false, true);\n+    private IterResult getKeysIter(InternalL1 startingPoint, Store store, Map<Id, InternalL1> unsavedL1s) {\n+      HistoryRetriever retriever = new HistoryRetriever(store, startingPoint, getPreviousCheckpoint(), true, false, true, unsavedL1s);\n       final CompleteList complete;\n       // incrementals, from oldest to newest.\n       final List<KeyList> incrementals;\n@@ -256,7 +257,7 @@ public Type getType() {\n     }\n \n     @Override\n-    public Optional<KeyList> createCheckpointIfNeeded(InternalL1 startingPoint, Store store) {\n+    public Optional<KeyList> createCheckpointIfNeeded(InternalL1 startingPoint, Store store, Map<Id, InternalL1> unsavedL1s) {\n       // checkpoint not needed, already a checkpoint.\n       return Optional.empty();\n     }"
  },
  {
    "sha": "238af4a6ac1792daa13c71c330bd3a8367a49cbe",
    "filename": "versioned/tiered/tiered-tests/src/main/java/org/projectnessie/versioned/impl/AbstractITTieredVersionStore.java",
    "status": "modified",
    "additions": 80,
    "deletions": 0,
    "changes": 80,
    "blob_url": "https://github.com/projectnessie/nessie/blob/c91f3a810a2679399485614ec04a42ec9dbe51b0/versioned/tiered/tiered-tests/src/main/java/org/projectnessie/versioned/impl/AbstractITTieredVersionStore.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/c91f3a810a2679399485614ec04a42ec9dbe51b0/versioned/tiered/tiered-tests/src/main/java/org/projectnessie/versioned/impl/AbstractITTieredVersionStore.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/tiered-tests/src/main/java/org/projectnessie/versioned/impl/AbstractITTieredVersionStore.java?ref=c91f3a810a2679399485614ec04a42ec9dbe51b0",
    "patch": "@@ -19,6 +19,7 @@\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n \n import java.util.Arrays;\n import java.util.Collections;\n@@ -43,18 +44,21 @@\n import org.projectnessie.versioned.ImmutableTagName;\n import org.projectnessie.versioned.Key;\n import org.projectnessie.versioned.NamedRef;\n+import org.projectnessie.versioned.Operation;\n import org.projectnessie.versioned.Put;\n import org.projectnessie.versioned.Ref;\n import org.projectnessie.versioned.ReferenceAlreadyExistsException;\n import org.projectnessie.versioned.ReferenceConflictException;\n import org.projectnessie.versioned.ReferenceNotFoundException;\n+import org.projectnessie.versioned.Serializer;\n import org.projectnessie.versioned.TagName;\n import org.projectnessie.versioned.Unchanged;\n import org.projectnessie.versioned.VersionStore;\n import org.projectnessie.versioned.WithHash;\n import org.projectnessie.versioned.impl.InconsistentValue.InconsistentValueException;\n import org.projectnessie.versioned.store.Id;\n import org.projectnessie.versioned.store.Store;\n+import org.projectnessie.versioned.store.ValueType;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n@@ -289,6 +293,82 @@ void createAndDeleteBranch() throws Exception {\n     assertThrows(ReferenceConflictException.class, () -> versionStore().delete(TagName.of(\"foo\"), Optional.empty()));\n   }\n \n+  @Test\n+  void checkpointWithUnsavedL1() throws Exception {\n+    // KeyList.IncrementalList.generateNewCheckpoint collects parent L1s for a branch\n+    // via HistoryRetriever to \"checkpoint\" the keylist. However, this only works if\n+    // HistoryRetriever has access to both saved AND unsaved L1s, so L1s that are persisted\n+    // and those that are still in the branch's REF. This test verifies that generateNewCheckpoint\n+    // does not fail in that case.\n+\n+    BranchName branch = BranchName.of(\"checkpointWithUnsavedL1\");\n+\n+    versionStore().create(branch, Optional.empty());\n+\n+    InternalRefId ref = InternalRefId.of(branch);\n+\n+    // generate MAX_DELTAS-1 keys in the key-list - just enough to *NOT*\n+    // trigger KeyList.IncrementalList.generateNewCheckpoint\n+    for (int i = 1; i < KeyList.IncrementalList.MAX_DELTAS; i++) {\n+      InternalBranch internalBranch = simulateCommit(ref, i);\n+\n+      // verify that the branch has an unsaved L1\n+      assertEquals(i, internalBranch.getCommits().stream().filter(c -> !c.isSaved()).count());\n+      KeyList keyList = internalBranch.getUpdateState(store()).unsafeGetL1().getKeyList();\n+      assertFalse(keyList.isFull());\n+      assertFalse(keyList.isEmptyIncremental());\n+      KeyList.IncrementalList incrementalList = (KeyList.IncrementalList) keyList;\n+      assertEquals(i, incrementalList.getDistanceFromCheckpointCommits());\n+    }\n+\n+    InternalBranch internalBranch = simulateCommit(ref, KeyList.IncrementalList.MAX_DELTAS);\n+    KeyList keyList = internalBranch.getUpdateState(store()).unsafeGetL1().getKeyList();\n+    assertTrue(keyList.isFull());\n+    assertFalse(keyList.isEmptyIncremental());\n+\n+  }\n+\n+  private InternalBranch simulateCommit(InternalRefId ref, int num) {\n+    List<Operation<String>> ops = Collections.singletonList(Put.of(Key.of(\"key\" + num), \"foo\" + num));\n+    List<InternalKey> keys = ops.stream().map(op -> new InternalKey(op.getKey())).collect(Collectors.toList());\n+\n+    Serializer<String> serializer = AbstractTieredStoreFixture.WORKER.getValueSerializer();\n+    Serializer<String> metadataSerializer = AbstractTieredStoreFixture.WORKER.getMetadataSerializer();\n+\n+    PartialTree<String> current = PartialTree.of(serializer, ref, keys);\n+\n+    String incomingCommit = \"metadata\";\n+    InternalCommitMetadata metadata = InternalCommitMetadata.of(metadataSerializer.toBytes(incomingCommit));\n+\n+    store().load(current.getLoadChain(b -> {\n+      InternalBranch.UpdateState updateState = b.getUpdateState(store());\n+      return updateState.unsafeGetL1();\n+    }, PartialTree.LoadType.NO_VALUES));\n+\n+    // do updates.\n+    ops.forEach(op ->\n+        current.setValueForKey(new InternalKey(op.getKey()), Optional.of(((Put<String>) op).getValue())));\n+\n+    // save all but l1 and branch.\n+    store().save(\n+        Stream.concat(\n+            current.getMostSaveOps(),\n+            Stream.of(EntityType.COMMIT_METADATA.createSaveOpForEntity(metadata))\n+        ).collect(Collectors.toList()));\n+\n+    PartialTree.CommitOp commitOp = current.getCommitOp(\n+        metadata.getId(),\n+        Collections.emptyList(),\n+        true,\n+        true);\n+\n+    InternalRef.Builder<?> builder = EntityType.REF.newEntityProducer();\n+    boolean updated = store().update(ValueType.REF, ref.getId(),\n+        commitOp.getUpdateWithCommit(), Optional.of(commitOp.getTreeCondition()), Optional.of(builder));\n+    assertTrue(updated);\n+    return builder.build().getBranch();\n+  }\n+\n   @Test\n   void conflictingCommit() throws Exception {\n     BranchName branch = BranchName.of(\"foo\");"
  }
]
