[
  {
    "sha": "80843ccc201980674676b467bfb85ae82857175e",
    "filename": "servers/quarkus-server/pom.xml",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/pom.xml",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/pom.xml",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/servers/quarkus-server/pom.xml?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -50,6 +50,11 @@\n       <artifactId>nessie-versioned-jgit</artifactId>\n       <version>${project.version}</version>\n     </dependency>\n+    <dependency>\n+      <groupId>org.projectnessie</groupId>\n+      <artifactId>nessie-versioned-tiered-inmem</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>\n     <dependency>\n       <groupId>org.projectnessie</groupId>\n       <artifactId>nessie-versioned-tiered-dynamodb</artifactId>"
  },
  {
    "sha": "27e73d730d5899196f8a8db3536512cbf205bdd2",
    "filename": "servers/quarkus-server/src/main/java/org/projectnessie/server/config/DynamoVersionStoreConfig.java",
    "status": "modified",
    "additions": 1,
    "deletions": 4,
    "changes": 5,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/java/org/projectnessie/server/config/DynamoVersionStoreConfig.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/java/org/projectnessie/server/config/DynamoVersionStoreConfig.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/servers/quarkus-server/src/main/java/org/projectnessie/server/config/DynamoVersionStoreConfig.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -24,14 +24,11 @@\n  * DynamoDB version store configuration.\n  */\n @ConfigProperties(prefix = \"nessie.version.store.dynamo\")\n-public interface DynamoVersionStoreConfig {\n+public interface DynamoVersionStoreConfig extends TieredVersionStoreConfig {\n \n   @ConfigProperty(name = \"initialize\", defaultValue = \"false\")\n   boolean isDynamoInitialize();\n \n   @ConfigProperty(defaultValue = DynamoStoreConfig.TABLE_PREFIX)\n   String getTablePrefix();\n-\n-  @ConfigProperty(name = \"tracing\", defaultValue = \"true\")\n-  boolean enableTracing();\n }"
  },
  {
    "sha": "7e6287de7a4e81b13601bdbfcdc6dbb66f5d793b",
    "filename": "servers/quarkus-server/src/main/java/org/projectnessie/server/config/TieredInMemVersionStoreConfig.java",
    "status": "added",
    "additions": 25,
    "deletions": 0,
    "changes": 25,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/java/org/projectnessie/server/config/TieredInMemVersionStoreConfig.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/java/org/projectnessie/server/config/TieredInMemVersionStoreConfig.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/servers/quarkus-server/src/main/java/org/projectnessie/server/config/TieredInMemVersionStoreConfig.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.server.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+\n+/**\n+ * Tiered-In-Memory version store configuration.\n+ */\n+@ConfigProperties(prefix = \"nessie.version.store.tiered-inmem\")\n+public interface TieredInMemVersionStoreConfig extends TieredVersionStoreConfig {\n+}"
  },
  {
    "sha": "9e41ec7152a7c896087cff33b063cd75cf25cfdf",
    "filename": "servers/quarkus-server/src/main/java/org/projectnessie/server/config/TieredVersionStoreConfig.java",
    "status": "added",
    "additions": 23,
    "deletions": 0,
    "changes": 23,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/java/org/projectnessie/server/config/TieredVersionStoreConfig.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/java/org/projectnessie/server/config/TieredVersionStoreConfig.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/servers/quarkus-server/src/main/java/org/projectnessie/server/config/TieredVersionStoreConfig.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.server.config;\n+\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+\n+public interface TieredVersionStoreConfig {\n+  @ConfigProperty(name = \"tracing\", defaultValue = \"true\")\n+  boolean enableTracing();\n+}"
  },
  {
    "sha": "15762d75de14d57771210f3dfa363a30c37a1c57",
    "filename": "servers/quarkus-server/src/main/java/org/projectnessie/server/config/VersionStoreConfig.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/java/org/projectnessie/server/config/VersionStoreConfig.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/java/org/projectnessie/server/config/VersionStoreConfig.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/servers/quarkus-server/src/main/java/org/projectnessie/server/config/VersionStoreConfig.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -30,7 +30,8 @@\n   public enum VersionStoreType {\n     DYNAMO,\n     INMEMORY,\n-    JGIT\n+    JGIT,\n+    TIERED_INMEMORY\n   }\n \n   @ConfigProperty(name = \"type\", defaultValue = \"INMEMORY\")"
  },
  {
    "sha": "b280985d66b6343d0ecf02d84622d95c6cfb6d02",
    "filename": "servers/quarkus-server/src/main/java/org/projectnessie/server/providers/DynamoVersionStoreFactory.java",
    "status": "modified",
    "additions": 5,
    "deletions": 16,
    "changes": 21,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/java/org/projectnessie/server/providers/DynamoVersionStoreFactory.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/java/org/projectnessie/server/providers/DynamoVersionStoreFactory.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/servers/quarkus-server/src/main/java/org/projectnessie/server/providers/DynamoVersionStoreFactory.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -17,7 +17,6 @@\n \n import static org.projectnessie.server.config.VersionStoreConfig.VersionStoreType.DYNAMO;\n \n-import java.io.IOException;\n import java.net.URI;\n import java.net.URISyntaxException;\n import java.util.Optional;\n@@ -27,11 +26,9 @@\n \n import org.eclipse.microprofile.config.inject.ConfigProperty;\n import org.projectnessie.server.config.DynamoVersionStoreConfig;\n-import org.projectnessie.versioned.StoreWorker;\n-import org.projectnessie.versioned.VersionStore;\n import org.projectnessie.versioned.dynamodb.DynamoStore;\n import org.projectnessie.versioned.dynamodb.DynamoStoreConfig;\n-import org.projectnessie.versioned.impl.TieredVersionStore;\n+import org.projectnessie.versioned.store.Store;\n \n import software.amazon.awssdk.regions.Region;\n \n@@ -40,7 +37,7 @@\n  */\n @StoreType(DYNAMO)\n @Dependent\n-public class DynamoVersionStoreFactory implements VersionStoreFactory {\n+public class DynamoVersionStoreFactory extends TieredVersionStoreFactory {\n   private final DynamoVersionStoreConfig config;\n \n   private final String region;\n@@ -53,21 +50,15 @@\n   public DynamoVersionStoreFactory(DynamoVersionStoreConfig config,\n       @ConfigProperty(name = \"quarkus.dynamodb.aws.region\") String region,\n       @ConfigProperty(name = \"quarkus.dynamodb.endpoint-override\") Optional<String> endpoint) {\n+    super(config);\n     this.config = config;\n     this.region = region;\n     this.endpoint = endpoint;\n   }\n \n   @Override\n-  public <VALUE, METADATA> VersionStore<VALUE, METADATA> newStore(StoreWorker<VALUE, METADATA> worker) throws IOException {\n-    return new TieredVersionStore<>(worker, newDynamoConnection(), false);\n-  }\n-\n-  /**\n-   * create a dynamo store based on config.\n-   */\n-  private DynamoStore newDynamoConnection() {\n-    DynamoStore dynamo = new DynamoStore(\n+  protected Store createStore() {\n+    return new DynamoStore(\n         DynamoStoreConfig.builder()\n           .endpoint(endpoint.map(e -> {\n             try {\n@@ -81,7 +72,5 @@ private DynamoStore newDynamoConnection() {\n           .tablePrefix(config.getTablePrefix())\n           .enableTracing(config.enableTracing())\n           .build());\n-    dynamo.start();\n-    return dynamo;\n   }\n }"
  },
  {
    "sha": "26546c263abaf0de2da003dae6784ac6c8de4b82",
    "filename": "servers/quarkus-server/src/main/java/org/projectnessie/server/providers/TieredInMemVersionStoreFactory.java",
    "status": "added",
    "additions": 40,
    "deletions": 0,
    "changes": 40,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/java/org/projectnessie/server/providers/TieredInMemVersionStoreFactory.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/java/org/projectnessie/server/providers/TieredInMemVersionStoreFactory.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/servers/quarkus-server/src/main/java/org/projectnessie/server/providers/TieredInMemVersionStoreFactory.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.server.providers;\n+\n+import static org.projectnessie.server.config.VersionStoreConfig.VersionStoreType.TIERED_INMEMORY;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+import org.projectnessie.server.config.TieredInMemVersionStoreConfig;\n+import org.projectnessie.versioned.inmem.InMemStore;\n+import org.projectnessie.versioned.store.Store;\n+\n+@StoreType(TIERED_INMEMORY)\n+@Dependent\n+public class TieredInMemVersionStoreFactory extends TieredVersionStoreFactory {\n+\n+  @Inject\n+  public TieredInMemVersionStoreFactory(TieredInMemVersionStoreConfig config) {\n+    super(config);\n+  }\n+\n+  @Override\n+  protected Store createStore() {\n+    return new InMemStore();\n+  }\n+}"
  },
  {
    "sha": "eb3d36469e150fea3c54f07d1ff14b34befdacfa",
    "filename": "servers/quarkus-server/src/main/java/org/projectnessie/server/providers/TieredVersionStoreFactory.java",
    "status": "added",
    "additions": 45,
    "deletions": 0,
    "changes": 45,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/java/org/projectnessie/server/providers/TieredVersionStoreFactory.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/java/org/projectnessie/server/providers/TieredVersionStoreFactory.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/servers/quarkus-server/src/main/java/org/projectnessie/server/providers/TieredVersionStoreFactory.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.server.providers;\n+\n+import java.io.IOException;\n+\n+import org.projectnessie.server.config.TieredVersionStoreConfig;\n+import org.projectnessie.versioned.StoreWorker;\n+import org.projectnessie.versioned.VersionStore;\n+import org.projectnessie.versioned.impl.TieredVersionStore;\n+import org.projectnessie.versioned.store.Store;\n+\n+abstract class TieredVersionStoreFactory implements VersionStoreFactory {\n+  private final TieredVersionStoreConfig config;\n+\n+  public TieredVersionStoreFactory(TieredVersionStoreConfig config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public <VALUE, METADATA> VersionStore<VALUE, METADATA> newStore(StoreWorker<VALUE, METADATA> worker) throws IOException {\n+    Store store = createStore();\n+\n+    // TODO a follow-up PR adds a `TracingStore` here, that delegates to the actual `Store` implementation\n+\n+    store.start();\n+\n+    return new TieredVersionStore<>(worker, store, false);\n+  }\n+\n+  protected abstract Store createStore();\n+}"
  },
  {
    "sha": "3f75dc92dfebc4f01083ed7d7fd706b34e5e601c",
    "filename": "servers/quarkus-server/src/main/resources/application.properties",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/resources/application.properties",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/servers/quarkus-server/src/main/resources/application.properties",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/servers/quarkus-server/src/main/resources/application.properties?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -19,7 +19,9 @@\n nessie.server.default-branch=main\n nessie.server.send-stacktrace-to-client=true\n \n-### which type of version store to use: JGIT, INMEMORY, DYNAMO. JGIT is best for local testing, DYNAMO preferred for production\n+### which type of version store to use: JGIT, INMEMORY, DYNAMO, TIERED_INMEMORY.\n+# JGIT is best for local testing, DYNAMO preferred for production.\n+# INMEMORY + TIERED_INMEMORY are good for ephemeral tests, do not persist anything - not suitable for production.\n nessie.version.store.type=INMEMORY\n \n ## JGit version store specific configuration"
  },
  {
    "sha": "74a3f2c9a18adf93325783cdfebdd53a750e8842",
    "filename": "versioned/tiered/inmem/pom.xml",
    "status": "added",
    "additions": 98,
    "deletions": 0,
    "changes": 98,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/pom.xml",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/pom.xml",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/pom.xml?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,98 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+\n+    Copyright (C) 2020 Dremio\n+\n+    Licensed under the Apache License, Version 2.0 (the \"License\");\n+    you may not use this file except in compliance with the License.\n+    You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n+\n+-->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.projectnessie</groupId>\n+    <artifactId>nessie-versioned-tiered</artifactId>\n+    <version>0.4.1-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>nessie-versioned-tiered-inmem</artifactId>\n+\n+  <name>Nessie - Versioned - Tiered - InMemory</name>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.projectnessie</groupId>\n+      <artifactId>nessie-versioned-tiered-impl</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.immutables</groupId>\n+      <artifactId>value</artifactId>\n+      <scope>provided</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.projectnessie</groupId>\n+      <artifactId>nessie-versioned-tests</artifactId>\n+      <version>${project.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.projectnessie</groupId>\n+      <artifactId>nessie-versioned-tiered-tests</artifactId>\n+      <version>${project.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.hamcrest</groupId>\n+      <artifactId>hamcrest</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter-api</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter-params</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>ch.qos.logback</groupId>\n+      <artifactId>logback-classic</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>ch.qos.logback</groupId>\n+      <artifactId>logback-core</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-failsafe-plugin</artifactId>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>integration-test</goal>\n+              <goal>verify</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>"
  },
  {
    "sha": "39f0abff7c6346f34306e6bd1d734d2f438e8dc2",
    "filename": "versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/BaseObj.java",
    "status": "added",
    "additions": 269,
    "deletions": 0,
    "changes": 269,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/BaseObj.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/BaseObj.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/BaseObj.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.stream.Collectors;\n+\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n+import org.projectnessie.versioned.impl.condition.RemoveClause;\n+import org.projectnessie.versioned.impl.condition.SetClause;\n+import org.projectnessie.versioned.impl.condition.UpdateClause;\n+import org.projectnessie.versioned.impl.condition.UpdateExpression;\n+import org.projectnessie.versioned.store.ConditionFailedException;\n+import org.projectnessie.versioned.store.Entity;\n+import org.projectnessie.versioned.store.Id;\n+import org.projectnessie.versioned.store.ValueType;\n+import org.projectnessie.versioned.tiered.BaseValue;\n+\n+/**\n+ * Base class of all value-types in of the in-memory {@link org.projectnessie.versioned.store.Store}\n+ * implementation.\n+ * <p>All subclasses <em>must</em> implement {@link Object#hashCode()} and\n+ * {@link Object#equals(Object)}, because the some functionality in the\n+ * {@link org.projectnessie.versioned.store.Store} implementation require this, for example\n+ * {@link InMemStore#delete(ValueType, Id, Optional)}.</p>\n+ * @param <C> value-type\n+ */\n+abstract class BaseObj<C extends BaseValue<C>> {\n+  static final String ID = \"id\";\n+\n+  private final Id id;\n+  private final long dt;\n+\n+  BaseObj(Id id, long dt) {\n+    this.id = id;\n+    this.dt = dt;\n+  }\n+\n+  Id getId() {\n+    return id;\n+  }\n+\n+  long getDt() {\n+    return dt;\n+  }\n+\n+  C consume(C consumer) {\n+    return consumer.id(id).dt(dt);\n+  }\n+\n+  void evaluate(List<Function> functions) throws ConditionFailedException {\n+    for (Function function: functions) {\n+      if (function.getPath().getRoot().isName()) {\n+        try {\n+          evaluate(function);\n+        } catch (IllegalStateException e) {\n+          // Catch exceptions raise due to incorrect Entity type in FunctionExpression being compared to the\n+          // target attribute.\n+          throw new ConditionFailedException(invalidValueMessage(function));\n+        }\n+      }\n+    }\n+  }\n+\n+  void evaluate(Function function) throws ConditionFailedException {\n+    throw new UnsupportedOperationException(\"Conditions not supported for \" + getClass().getSimpleName());\n+  }\n+\n+  boolean evaluate(Function function, List<Id> idList) {\n+    // EQUALS will either compare a specified position or the whole idList as a List.\n+    if (function.getOperator().equals(Function.Operator.EQUALS)) {\n+      final ExpressionPath.PathSegment pathSegment = function.getPath().getRoot().getChild().orElse(null);\n+      if (pathSegment == null) {\n+        return toEntity(idList).equals(function.getValue());\n+      } else if (pathSegment.isPosition()) { // compare individual element of list\n+        final int position = pathSegment.asPosition().getPosition();\n+        return toEntity(idList, position).equals(function.getValue());\n+      }\n+    } else if (function.getOperator().equals(Function.Operator.SIZE)) {\n+      return (idList.size() == function.getValue().getNumber());\n+    }\n+\n+    return false;\n+  }\n+\n+  static Entity toEntity(List<Id> idList) {\n+    return Entity.ofList(idList.stream().map(Id::toEntity).collect(Collectors.toList()));\n+  }\n+\n+  static Entity toEntity(List<Id> idList, int position) {\n+    return idList.stream().skip(position).findFirst().orElseThrow(NoSuchElementException::new).toEntity();\n+  }\n+\n+  void evaluatesId(Function function) throws ConditionFailedException {\n+    if (!function.isRootNameSegmentChildlessAndEquals()\n+        || !getId().toEntity().equals(function.getValue())) {\n+      throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+    }\n+  }\n+\n+  protected static String invalidOperatorSegmentMessage(Function function) {\n+    return String.format(\"Operator: %s is not applicable to segment %s\",\n+        function.getOperator(), function.getRootPathAsNameSegment().getName());\n+  }\n+\n+  protected static String invalidValueMessage(Function function) {\n+    return String.format(\"Not able to apply type: %s to segment: %s\", function.getValue().getType(),\n+        function.getRootPathAsNameSegment().getName());\n+  }\n+\n+  protected static String conditionNotMatchedMessage(Function function) {\n+    return String.format(\"Condition %s did not match the actual value for %s\", function.getValue().getType(),\n+        function.getRootPathAsNameSegment().getName());\n+  }\n+\n+  abstract BaseObj<C> copy();\n+\n+  static final class DeferredRemove implements Comparable<DeferredRemove> {\n+\n+    private final int position;\n+    private final IntConsumer removeOperation;\n+\n+    protected DeferredRemove(int position, IntConsumer removeOperation) {\n+      this.position = position;\n+      this.removeOperation = removeOperation;\n+    }\n+\n+    @Override\n+    public int compareTo(DeferredRemove o) {\n+      return Integer.compare(o.position, position);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+\n+      DeferredRemove that = (DeferredRemove) o;\n+\n+      if (position != that.position) {\n+        return false;\n+      }\n+      return removeOperation.equals(that.removeOperation);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      int result = position;\n+      result = 31 * result + removeOperation.hashCode();\n+      return result;\n+    }\n+\n+    void apply() {\n+      removeOperation.accept(position);\n+    }\n+  }\n+\n+  BaseObj<C> update(UpdateExpression update) {\n+    BaseObj<C> copy = copy();\n+    List<DeferredRemove> deferred = new ArrayList<>();\n+    update.getClauses().forEach(clause -> copy.apply(clause, deferred::add));\n+    deferred.stream().sorted().forEach(DeferredRemove::apply);\n+    return copy;\n+  }\n+\n+  private void apply(UpdateClause updateClause, Consumer<DeferredRemove> deferredRemoveConsumer) {\n+    switch (updateClause.getType()) {\n+      case DELETE:\n+        applyDelete(updateClause);\n+        break;\n+      case REMOVE:\n+        applyRemove((RemoveClause) updateClause, deferredRemoveConsumer);\n+        break;\n+      case SET:\n+        applySet((SetClause) updateClause);\n+        break;\n+      default:\n+        throw new UnsupportedOperationException(updateClause.toString());\n+    }\n+  }\n+\n+  void applyDelete(UpdateClause updateClause) {\n+    throw new UnsupportedOperationException(String.format(\"%s does not support UpdateClause/DELETE\", getClass().getSimpleName()));\n+  }\n+\n+  void applyRemove(RemoveClause removeClause,\n+      Consumer<DeferredRemove> deferredRemoveConsumer) {\n+    throw new UnsupportedOperationException(String.format(\"%s does not support RemoveClause\", getClass().getSimpleName()));\n+  }\n+\n+  void applySet(SetClause setClause) {\n+    throw new UnsupportedOperationException(String.format(\"%s does not support SetClause\", getClass().getSimpleName()));\n+  }\n+\n+  abstract static class BaseObjProducer<C extends BaseValue<C>> implements BaseValue<C> {\n+    private Id id;\n+    private long dt;\n+\n+    Id getId() {\n+      return id;\n+    }\n+\n+    long getDt() {\n+      return dt;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public C id(Id id) {\n+      this.id = id;\n+      return (C) this;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public C dt(long dt) {\n+      this.dt = dt;\n+      return (C) this;\n+    }\n+\n+    abstract BaseObj<C> build();\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    BaseObj<?> baseObj = (BaseObj<?>) o;\n+\n+    if (dt != baseObj.dt) {\n+      return false;\n+    }\n+    return id.equals(baseObj.id);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    int result = id.hashCode();\n+    result = 31 * result + (int) (dt ^ (dt >>> 32));\n+    return result;\n+  }\n+}"
  },
  {
    "sha": "3788049a667aa810c4e8f0bc6cc6afa17dfe13d9",
    "filename": "versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/CommitMetadataObj.java",
    "status": "added",
    "additions": 40,
    "deletions": 0,
    "changes": 40,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/CommitMetadataObj.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/CommitMetadataObj.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/CommitMetadataObj.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import org.projectnessie.versioned.store.Id;\n+import org.projectnessie.versioned.tiered.CommitMetadata;\n+\n+import com.google.protobuf.ByteString;\n+\n+final class CommitMetadataObj extends WrappedValueObj<CommitMetadata> {\n+\n+  CommitMetadataObj(Id id, long dt, ByteString value) {\n+    super(id, dt, value);\n+  }\n+\n+  @Override\n+  BaseObj<CommitMetadata> copy() {\n+    return new CommitMetadataObj(getId(), getDt(), getValue());\n+  }\n+\n+  static class CommitMetadataProducer extends BaseWrappedValueObjProducer<CommitMetadata> implements CommitMetadata {\n+    @Override\n+    BaseObj<CommitMetadata> build() {\n+      return new CommitMetadataObj(getId(), getDt(), getValue());\n+    }\n+  }\n+}"
  },
  {
    "sha": "3941830c192374bf01a3af463e5a47df9875848b",
    "filename": "versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/FragmentObj.java",
    "status": "added",
    "additions": 169,
    "deletions": 0,
    "changes": 169,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/FragmentObj.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/FragmentObj.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/FragmentObj.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.projectnessie.versioned.Key;\n+import org.projectnessie.versioned.impl.condition.ExpressionFunction;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath.NameSegment;\n+import org.projectnessie.versioned.impl.condition.RemoveClause;\n+import org.projectnessie.versioned.impl.condition.SetClause;\n+import org.projectnessie.versioned.store.ConditionFailedException;\n+import org.projectnessie.versioned.store.Entity;\n+import org.projectnessie.versioned.store.Id;\n+import org.projectnessie.versioned.tiered.Fragment;\n+\n+final class FragmentObj extends BaseObj<Fragment> {\n+  static final String KEY_LIST = \"keys\";\n+\n+  private final List<Key> keys;\n+\n+  FragmentObj(Id id, long dt, List<Key> keys) {\n+    super(id, dt);\n+    this.keys = keys;\n+  }\n+\n+  @Override\n+  Fragment consume(Fragment consumer) {\n+    return super.consume(consumer).keys(keys.stream());\n+  }\n+\n+  static class FragmentProducer extends BaseObjProducer<Fragment> implements Fragment {\n+    private List<Key> keys;\n+\n+    @Override\n+    public Fragment keys(Stream<Key> keys) {\n+      this.keys = keys.collect(Collectors.toList());\n+      return this;\n+    }\n+\n+    @Override\n+    BaseObj<Fragment> build() {\n+      return new FragmentObj(getId(), getDt(), keys);\n+    }\n+  }\n+\n+  @Override\n+  BaseObj<Fragment> copy() {\n+    return new FragmentObj(getId(), getDt(),\n+        keys != null ? new ArrayList<>(keys) : null);\n+  }\n+\n+  @Override\n+  void applyRemove(RemoveClause removeClause, Consumer<DeferredRemove> deferredRemoveConsumer) {\n+    NameSegment root = removeClause.getPath().getRoot();\n+    switch (root.getName()) {\n+      case KEY_LIST:\n+        int pos = root.getChild().orElseThrow(() -> new IllegalStateException(\"Position required\")).asPosition().getPosition();\n+        deferredRemoveConsumer.accept(new DeferredRemove(pos, keys::remove));\n+        break;\n+      default:\n+        throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  @Override\n+  void applySet(SetClause setClause) {\n+    NameSegment root = setClause.getPath().getRoot();\n+    switch (root.getName()) {\n+      case KEY_LIST:\n+        switch (setClause.getValue().getType()) {\n+          case FUNCTION:\n+            ExpressionFunction expressionFunction = (ExpressionFunction) setClause.getValue();\n+            switch (expressionFunction.getName()) {\n+              case LIST_APPEND:\n+                List<Entity> valueList = expressionFunction.getArguments().get(1).getValue().getList();\n+                valueList.forEach(value -> keys.add(Key.of(value.getList().stream().map(Entity::getString).toArray(String[]::new))));\n+                break;\n+              case EQUALS:\n+              case SIZE:\n+              case ATTRIBUTE_NOT_EXISTS:\n+              default:\n+                throw new UnsupportedOperationException();\n+            }\n+            break;\n+          case VALUE:\n+          case PATH:\n+          default:\n+            throw new UnsupportedOperationException();\n+        }\n+        break;\n+      default:\n+        throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  @Override\n+  public void evaluate(Function function) throws ConditionFailedException {\n+    final String segment = function.getRootPathAsNameSegment().getName();\n+    switch (segment) {\n+      case ID:\n+        evaluatesId(function);\n+        break;\n+      case KEY_LIST:\n+        if (function.getRootPathAsNameSegment().getChild().isPresent()) {\n+          throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n+        } else if (function.getOperator().equals(Function.Operator.EQUALS)) {\n+          if (!keysAsEntityList().equals(function.getValue())) {\n+            throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+          }\n+        } else if (function.getOperator().equals(Function.Operator.SIZE)) {\n+          if (keys.size() != function.getValue().getNumber()) {\n+            throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+          }\n+        } else {\n+          throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n+        }\n+        break;\n+      default:\n+        // NameSegment could not be applied to FunctionExpression.\n+        throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n+    }\n+  }\n+\n+  private Entity keysAsEntityList() {\n+    return Entity.ofList(keys.stream().map(k -> Entity.ofList(k.getElements().stream().map(Entity::ofString))));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    if (!super.equals(o)) {\n+      return false;\n+    }\n+\n+    FragmentObj that = (FragmentObj) o;\n+\n+    return keys.equals(that.keys);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    int result = super.hashCode();\n+    result = 31 * result + keys.hashCode();\n+    return result;\n+  }\n+}"
  },
  {
    "sha": "f051ae8b114436cbc4e2dd6970bd1cb60d52cb63",
    "filename": "versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/Function.java",
    "status": "added",
    "additions": 85,
    "deletions": 0,
    "changes": 85,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/Function.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/Function.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/Function.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import java.util.Objects;\n+\n+import org.immutables.value.Value.Immutable;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n+import org.projectnessie.versioned.store.Entity;\n+\n+/**\n+ * An expression that is asserted against an Entity.\n+ */\n+@Immutable\n+abstract class Function {\n+  /**\n+   * An enum encapsulating.\n+   */\n+  enum Operator {\n+    // An operator comparing the equality of entities.\n+    EQUALS,\n+\n+    // An operator comparing the size of entities.\n+    SIZE\n+  }\n+\n+  /**\n+   * Compares for equality with a provided Function object.\n+   * @param object  the object to compare\n+   * @return true if this is equal to provided object\n+   */\n+  @Override\n+  public boolean equals(Object object) {\n+    if (object == this) {\n+      return true;\n+    }\n+\n+    if (!(object instanceof Function)) {\n+      return false;\n+    }\n+\n+    final Function function = (Function) object;\n+    return (getOperator().equals(function.getOperator())\n+        && getPath().equals(function.getPath())\n+        && getValue().equals(function.getValue()));\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(getOperator(), getPath(), getValue());\n+  }\n+\n+  abstract Operator getOperator();\n+\n+  abstract ExpressionPath getPath();\n+\n+  abstract Entity getValue();\n+\n+  ExpressionPath.NameSegment getRootPathAsNameSegment() {\n+    return getPath().getRoot().asName();\n+  }\n+\n+  /**\n+   * A utility to aid evaluation of the Function in checking for equality on\n+   * a leaf {@link org.projectnessie.versioned.impl.condition.ExpressionPath.NameSegment}.\n+   * @return true if both root nameSegment is childless and function has an equality operator\n+   */\n+  boolean isRootNameSegmentChildlessAndEquals() {\n+    return !getRootPathAsNameSegment().getChild().isPresent()\n+        && getOperator().equals(Operator.EQUALS);\n+  }\n+}"
  },
  {
    "sha": "aa2e0d3057a40e3d74181468a4538da5e0ec26a1",
    "filename": "versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/InMemStore.java",
    "status": "added",
    "additions": 243,
    "deletions": 0,
    "changes": 243,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/InMemStore.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/InMemStore.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/InMemStore.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import java.util.ArrayList;\n+import java.util.ConcurrentModificationException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.projectnessie.versioned.impl.EntityStoreHelper;\n+import org.projectnessie.versioned.impl.condition.ConditionExpression;\n+import org.projectnessie.versioned.impl.condition.UpdateExpression;\n+import org.projectnessie.versioned.inmem.BaseObj.BaseObjProducer;\n+import org.projectnessie.versioned.store.ConditionFailedException;\n+import org.projectnessie.versioned.store.Id;\n+import org.projectnessie.versioned.store.LoadOp;\n+import org.projectnessie.versioned.store.LoadStep;\n+import org.projectnessie.versioned.store.NotFoundException;\n+import org.projectnessie.versioned.store.SaveOp;\n+import org.projectnessie.versioned.store.Store;\n+import org.projectnessie.versioned.store.ValueType;\n+import org.projectnessie.versioned.tiered.BaseValue;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+\n+/**\n+ * A <em>non-production</em> {@link Store} implementation for testing and benchmarking purposes.\n+ * <p>Based on one {@link ConcurrentMap} for each value-type.</p>\n+ */\n+public class InMemStore implements Store {\n+\n+  private static final InMemValueVisitor VALUE_VISITOR = new InMemValueVisitor();\n+\n+  private final Map<ValueType<?>, ConcurrentMap<Id, BaseObj<?>>> store;\n+\n+  private final Map<ValueType<?>, Supplier<? extends BaseObjProducer<?>>> typeSupplierMap;\n+\n+  /**\n+   * Construct the in-memory {@link Store} implementation.\n+   */\n+  public InMemStore() {\n+    Builder<ValueType<?>, ConcurrentMap<Id, BaseObj<?>>> storeBuilder = ImmutableMap.builder();\n+    Builder<ValueType<?>, Supplier<? extends BaseObjProducer<?>>> typeSupplierBuilder = ImmutableMap.builder();\n+\n+    for (ValueType<?> value : ValueType.values()) {\n+      storeBuilder.put(value, new ConcurrentHashMap<>());\n+    }\n+\n+    typeSupplierBuilder.put(ValueType.L1, L1Obj.L1Producer::new);\n+    typeSupplierBuilder.put(ValueType.L2, L2Obj.L2Producer::new);\n+    typeSupplierBuilder.put(ValueType.L3, L3Obj.L3Producer::new);\n+    typeSupplierBuilder.put(ValueType.COMMIT_METADATA, CommitMetadataObj.CommitMetadataProducer::new);\n+    typeSupplierBuilder.put(ValueType.KEY_FRAGMENT, FragmentObj.FragmentProducer::new);\n+    typeSupplierBuilder.put(ValueType.REF, RefObj.RefProducer::new);\n+    typeSupplierBuilder.put(ValueType.VALUE, ValueObj.ValueProducer::new);\n+\n+    this.store = storeBuilder.build();\n+    this.typeSupplierMap = typeSupplierBuilder.build();\n+  }\n+\n+  @Override\n+  public void start() {\n+    // make sure we have an empty l1 (ignore result, doesn't matter)\n+    EntityStoreHelper.storeMinimumEntities(this::putIfAbsent);\n+  }\n+\n+  @Override\n+  public void close() {\n+    store.values().forEach(Map::clear);\n+  }\n+\n+  @Override\n+  public void load(LoadStep loadstep) {\n+    while (true) {\n+      Map<ValueType<?>, List<Id>> missing = new HashMap<>();\n+      loadstep.getOps().forEach(op -> loadSingle(op, missing));\n+\n+      if (!missing.isEmpty()) {\n+        throw new NotFoundException(missing.toString());\n+      }\n+\n+      Optional<LoadStep> next = loadstep.getNext();\n+      if (!next.isPresent()) {\n+        break;\n+      }\n+      loadstep = next.get();\n+    }\n+  }\n+\n+  private <C extends BaseValue<C>> void loadSingle(LoadOp<C> op, Map<ValueType<?>, List<Id>> missing) {\n+    BaseObj<C> obj = store(op.getValueType()).get(op.getId());\n+    if (obj == null) {\n+      missing.computeIfAbsent(op.getValueType(), x -> new ArrayList<>()).add(op.getId());\n+    } else {\n+      obj.consume(op.getReceiver());\n+      op.done();\n+    }\n+  }\n+\n+  @Override\n+  public <C extends BaseValue<C>> void loadSingle(ValueType<C> type, Id id, C consumer) {\n+    BaseObj<C> obj = store(type).get(id);\n+    if (obj == null) {\n+      throw new NotFoundException(String.format(\"Unable to load item %s:%s.\", type, id));\n+    }\n+    obj.consume(consumer);\n+  }\n+\n+  @Override\n+  public <C extends BaseValue<C>> boolean putIfAbsent(SaveOp<C> saveOp) {\n+    return store(saveOp.getType()).putIfAbsent(saveOp.getId(), produce(saveOp)) == null;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <C extends BaseValue<C>> BaseObj<C> produce(SaveOp<C> saveOp) {\n+    BaseObjProducer<C> objProducer = newProducer(saveOp.getType());\n+    saveOp.serialize((C) objProducer);\n+    return objProducer.build();\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @VisibleForTesting\n+  <C extends BaseValue<C>> BaseObjProducer<C> newProducer(ValueType<C> type) {\n+    BaseObjProducer<C> objProducer = (BaseObjProducer<C>) typeSupplierMap.get(type).get();\n+    return objProducer;\n+  }\n+\n+  @Override\n+  public <C extends BaseValue<C>> void put(SaveOp<C> saveOp,\n+      Optional<ConditionExpression> condition) {\n+    ConcurrentMap<Id, BaseObj<C>> map = store(saveOp.getType());\n+    if (condition.isPresent()) {\n+      map.compute(saveOp.getId(), (id, v) -> {\n+        if (v != null) {\n+          v.evaluate(translate(condition.get()));\n+        } else {\n+          throw new ConditionFailedException(\"foo\");\n+        }\n+        return produce(saveOp);\n+      });\n+    } else {\n+      map.put(saveOp.getId(), produce(saveOp));\n+    }\n+  }\n+\n+  static List<Function> translate(ConditionExpression conditionExpression) {\n+    return conditionExpression.getFunctions().stream()\n+        .map(f -> f.accept(VALUE_VISITOR))\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public <C extends BaseValue<C>> boolean delete(ValueType<C> type, Id id,\n+      Optional<ConditionExpression> condition) {\n+    ConcurrentMap<Id, BaseObj<C>> map = store(type);\n+    if (condition.isPresent()) {\n+      BaseObj<C> value = map.get(id);\n+      if (value == null) {\n+        return false;\n+      }\n+      try {\n+        value.evaluate(translate(condition.get()));\n+      } catch (ConditionFailedException failed) {\n+        return false;\n+      }\n+      return map.remove(id, value);\n+    } else {\n+      return map.remove(id) != null;\n+    }\n+  }\n+\n+  @Override\n+  public void save(List<SaveOp<?>> ops) {\n+    ops.forEach(op -> store.get(op.getType()).put(op.getId(), produce(op)));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <C extends BaseValue<C>> boolean update(ValueType<C> type, Id id, UpdateExpression update,\n+      Optional<ConditionExpression> condition, Optional<BaseValue<C>> consumer)\n+      throws NotFoundException {\n+    ConcurrentMap<Id, BaseObj<C>> map = store(type);\n+    while (true) {\n+      BaseObj<C> value = map.get(id);\n+      if (value == null) {\n+        throw new NotFoundException(String.format(\"Not found: %s:%s\", type, id));\n+      }\n+      if (condition.isPresent()) {\n+        try {\n+          value.evaluate(translate(condition.get()));\n+        } catch (ConditionFailedException failed) {\n+          return false;\n+        }\n+      }\n+      try {\n+        BaseObj<C> updated = value.update(update);\n+        map.compute(id, (i, current) -> {\n+          if (current != value) {\n+            throw new ConcurrentModificationException();\n+          }\n+          return updated;\n+        });\n+        consumer.ifPresent(c -> updated.consume((C) c));\n+        return true;\n+      } catch (ConcurrentModificationException modified) {\n+        // ignore, just retry\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public <C extends BaseValue<C>> Stream<Acceptor<C>> getValues(ValueType<C> type) {\n+    return store(type).values().stream().map(obj -> obj::consume);\n+  }\n+\n+  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+  private <C extends BaseValue<C>> ConcurrentMap<Id, BaseObj<C>> store(ValueType<C> type) {\n+    ConcurrentMap m = store.get(type);\n+    return (ConcurrentMap<Id, BaseObj<C>>) m;\n+  }\n+}"
  },
  {
    "sha": "f746908595755124c269b7df431a7a8437bd2ec1",
    "filename": "versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/InMemValueVisitor.java",
    "status": "added",
    "additions": 92,
    "deletions": 0,
    "changes": 92,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/InMemValueVisitor.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/InMemValueVisitor.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/InMemValueVisitor.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import java.security.InvalidParameterException;\n+import java.util.List;\n+\n+import org.projectnessie.versioned.impl.condition.ExpressionFunction;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n+import org.projectnessie.versioned.impl.condition.Value;\n+import org.projectnessie.versioned.impl.condition.ValueVisitor;\n+import org.projectnessie.versioned.store.Entity;\n+\n+/**\n+ * This provides a separation of queries on @{ExpressionFunction} from the object itself.\n+ * This uses the Visitor design pattern to retrieve object attributes.\n+ */\n+class InMemValueVisitor implements ValueVisitor<Function> {\n+  private static class ExpressionPathVisitor implements ValueVisitor<ExpressionPath> {\n+    @Override\n+    public ExpressionPath visit(Entity entity) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public ExpressionPath visit(ExpressionFunction value) {\n+      final ExpressionFunction.FunctionName name = value.getName();\n+      throw new UnsupportedOperationException(String.format(\"%s is not a supported top-level RocksDB function.\", name));\n+    }\n+\n+    @Override\n+    public ExpressionPath visit(ExpressionPath value) {\n+      return value;\n+    }\n+  }\n+\n+  private static final ExpressionPathVisitor EXPRESSION_PATH_VALUE_VISITOR = new ExpressionPathVisitor();\n+\n+  @Override\n+  public Function visit(Entity entity) {\n+    throw new UnsupportedOperationException(String.format(\"%s is not supported as a RocksDB Function\", entity.toString()));\n+  }\n+\n+  @Override\n+  public Function visit(ExpressionFunction value) {\n+    final ExpressionFunction.FunctionName name = value.getName();\n+    final List<Value> arguments = value.getArguments();\n+    if (arguments.size() != name.getArgCount()) {\n+      throw new InvalidParameterException(\n+          String.format(\"Number of arguments provided [%d] does not match the number expected [%d] for %s.\",\n+              arguments.size(), name.getArgCount(), name));\n+    }\n+\n+    switch (name) {\n+      case EQUALS:\n+        // Special case SIZE, as the object representation is not contained in one level of ExpressionFunction.\n+        if (isSize(arguments.get(0))) {\n+          return ImmutableFunction.builder().operator(Function.Operator.SIZE)\n+              .path(arguments.get(0).getFunction().getArguments().get(0).accept(EXPRESSION_PATH_VALUE_VISITOR))\n+              .value(arguments.get(1).getValue()).build();\n+        }\n+\n+        return ImmutableFunction.builder().operator(Function.Operator.EQUALS)\n+            .path(arguments.get(0).accept(EXPRESSION_PATH_VALUE_VISITOR))\n+            .value(arguments.get(1).getValue()).build();\n+      default:\n+        throw new UnsupportedOperationException(String.format(\"%s is not a supported top-level RocksDB function.\", name));\n+    }\n+  }\n+\n+  @Override\n+  public Function visit(ExpressionPath value) {\n+    throw new UnsupportedOperationException(String.format(\"%s is not supported as a RocksDB Function\", value.toString()));\n+  }\n+\n+  private boolean isSize(Value value) {\n+    return (value.getType() == Value.Type.FUNCTION) && (((ExpressionFunction)value).getName() == ExpressionFunction.FunctionName.SIZE);\n+  }\n+}"
  },
  {
    "sha": "0e08b3fff3267375321073670ebe6cb0230b6dd9",
    "filename": "versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/L1Obj.java",
    "status": "added",
    "additions": 225,
    "deletions": 0,
    "changes": 225,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/L1Obj.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/L1Obj.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/L1Obj.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.projectnessie.versioned.Key.Mutation;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath;\n+import org.projectnessie.versioned.store.ConditionFailedException;\n+import org.projectnessie.versioned.store.Entity;\n+import org.projectnessie.versioned.store.Id;\n+import org.projectnessie.versioned.tiered.L1;\n+\n+final class L1Obj extends BaseObj<L1> {\n+  static final String COMMIT_METADATA = \"metadataId\";\n+  static final String ANCESTORS = \"ancestors\";\n+  static final String CHILDREN = \"children\";\n+  static final String KEY_LIST = \"keylist\";\n+  static final String INCREMENTAL_KEY_LIST = \"incrementalKeyList\";\n+  static final String COMPLETE_KEY_LIST = \"completeKeyList\";\n+  static final String CHECKPOINT_ID = \"checkpointId\";\n+  static final String DISTANCE_FROM_CHECKPOINT = \"distanceFromCheckpoint\";\n+\n+  private final Id commitMetadataId;\n+  private final List<Id> ancestors;\n+  private final List<Id> children;\n+  private final List<Mutation> keyMutations;\n+  private final int distanceFromCheckpoint;\n+  private final Id checkpointId;\n+  private final List<Id> completeKeyList;\n+\n+  L1Obj(Id id, long dt, Id commitMetadataId,\n+      List<Id> ancestors, List<Id> children,\n+      List<Mutation> keyMutations, int distanceFromCheckpoint,\n+      Id checkpointId, List<Id> completeKeyList) {\n+    super(id, dt);\n+    this.commitMetadataId = commitMetadataId;\n+    this.ancestors = ancestors;\n+    this.children = children;\n+    this.keyMutations = keyMutations;\n+    this.distanceFromCheckpoint = distanceFromCheckpoint;\n+    this.checkpointId = checkpointId;\n+    this.completeKeyList = completeKeyList;\n+  }\n+\n+  @Override\n+  L1 consume(L1 consumer) {\n+    super.consume(consumer)\n+        .commitMetadataId(commitMetadataId)\n+        .ancestors(ancestors.stream())\n+        .children(children.stream())\n+        .keyMutations(keyMutations.stream());\n+    if (completeKeyList != null) {\n+      return consumer.completeKeyList(completeKeyList.stream());\n+    } else {\n+      return consumer.incrementalKeyList(checkpointId, distanceFromCheckpoint);\n+    }\n+  }\n+\n+  static class L1Producer extends BaseObjProducer<L1> implements L1 {\n+\n+    private Id commitMetadataId;\n+    private List<Id> ancestors;\n+    private List<Id> children;\n+    private List<Mutation> keyMutations;\n+    private int distanceFromCheckpoint;\n+    private Id checkpointId;\n+    private List<Id> completeKeyList;\n+\n+    @Override\n+    public L1 commitMetadataId(Id id) {\n+      this.commitMetadataId = id;\n+      return this;\n+    }\n+\n+    @Override\n+    public L1 ancestors(Stream<Id> ids) {\n+      this.ancestors = ids.collect(Collectors.toList());\n+      return this;\n+    }\n+\n+    @Override\n+    public L1 children(Stream<Id> ids) {\n+      this.children = ids.collect(Collectors.toList());\n+      return this;\n+    }\n+\n+    @Override\n+    public L1 keyMutations(Stream<Mutation> keyMutations) {\n+      this.keyMutations = keyMutations.collect(Collectors.toList());\n+      return this;\n+    }\n+\n+    @Override\n+    public L1 incrementalKeyList(Id checkpointId, int distanceFromCheckpoint) {\n+      this.checkpointId = checkpointId;\n+      this.distanceFromCheckpoint = distanceFromCheckpoint;\n+      return this;\n+    }\n+\n+    @Override\n+    public L1 completeKeyList(Stream<Id> fragmentIds) {\n+      this.completeKeyList = fragmentIds.collect(Collectors.toList());\n+      return this;\n+    }\n+\n+    @Override\n+    BaseObj<L1> build() {\n+      return new L1Obj(getId(), getDt(),\n+          commitMetadataId, ancestors, children, keyMutations, distanceFromCheckpoint, checkpointId, completeKeyList);\n+    }\n+  }\n+\n+  @Override\n+  BaseObj<L1> copy() {\n+    return new L1Obj(getId(), getDt(), commitMetadataId,\n+        ancestors != null ? new ArrayList<>(ancestors) : null,\n+        children != null ? new ArrayList<>(children) : null,\n+        keyMutations != null ? new ArrayList<>(keyMutations) : null,\n+        distanceFromCheckpoint, checkpointId,\n+        completeKeyList != null ? new ArrayList<>(completeKeyList) : null);\n+  }\n+\n+  @Override\n+  public void evaluate(Function function) throws ConditionFailedException {\n+    final ExpressionPath.NameSegment nameSegment = function.getRootPathAsNameSegment();\n+    final String segment = nameSegment.getName();\n+    switch (segment) {\n+      case ID:\n+        evaluatesId(function);\n+        break;\n+      case COMMIT_METADATA:\n+        if (!function.isRootNameSegmentChildlessAndEquals()\n+            || !commitMetadataId.toEntity().equals(function.getValue())) {\n+          throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+        }\n+        break;\n+      case ANCESTORS:\n+        evaluate(function, ancestors);\n+        break;\n+      case CHILDREN:\n+        evaluate(function, children);\n+        break;\n+      case KEY_LIST:\n+        throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n+      case INCREMENTAL_KEY_LIST:\n+        if (!nameSegment.getChild().isPresent() || !function.getOperator().equals(Function.Operator.EQUALS)) {\n+          throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n+        }\n+        final String childName = nameSegment.getChild().get().asName().getName();\n+        if (childName.equals(CHECKPOINT_ID)) {\n+          if (!checkpointId.toEntity().equals(function.getValue())) {\n+            throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+          }\n+        } else if (childName.equals((DISTANCE_FROM_CHECKPOINT))) {\n+          if (!Entity.ofNumber(distanceFromCheckpoint).equals(function.getValue())) {\n+            throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+          }\n+        } else {\n+          // Invalid Condition Function.\n+          throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n+        }\n+        break;\n+      case COMPLETE_KEY_LIST:\n+        evaluate(function, completeKeyList);\n+        break;\n+      default:\n+        // Invalid Condition Function.\n+        throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n+    }\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    if (!super.equals(o)) {\n+      return false;\n+    }\n+\n+    L1Obj l1Obj = (L1Obj) o;\n+\n+    return (distanceFromCheckpoint == l1Obj.distanceFromCheckpoint)\n+        && Objects.equals(commitMetadataId, l1Obj.commitMetadataId)\n+        && Objects.equals(ancestors, l1Obj.ancestors)\n+        && Objects.equals(children, l1Obj.children)\n+        && Objects.equals(keyMutations, l1Obj.keyMutations)\n+        && Objects.equals(checkpointId, l1Obj.checkpointId)\n+        && Objects.equals(completeKeyList, l1Obj.completeKeyList);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    int result = super.hashCode();\n+    result = 31 * result + (commitMetadataId != null ? commitMetadataId.hashCode() : 0);\n+    result = 31 * result + (ancestors != null ? ancestors.hashCode() : 0);\n+    result = 31 * result + (children != null ? children.hashCode() : 0);\n+    result = 31 * result + (keyMutations != null ? keyMutations.hashCode() : 0);\n+    result = 31 * result + distanceFromCheckpoint;\n+    result = 31 * result + (checkpointId != null ? checkpointId.hashCode() : 0);\n+    result = 31 * result + (completeKeyList != null ? completeKeyList.hashCode() : 0);\n+    return result;\n+  }\n+}"
  },
  {
    "sha": "0f763fb6f32418d668120102829d78bf2f539f7f",
    "filename": "versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/L2Obj.java",
    "status": "added",
    "additions": 100,
    "deletions": 0,
    "changes": 100,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/L2Obj.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/L2Obj.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/L2Obj.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.projectnessie.versioned.store.ConditionFailedException;\n+import org.projectnessie.versioned.store.Id;\n+import org.projectnessie.versioned.tiered.L2;\n+\n+final class L2Obj extends BaseObj<L2> {\n+  private static final String CHILDREN = \"children\";\n+  private final List<Id> children;\n+\n+  L2Obj(Id id, long dt, List<Id> children) {\n+    super(id, dt);\n+    this.children = children;\n+  }\n+\n+  @Override\n+  L2 consume(L2 consumer) {\n+    return super.consume(consumer).children(children.stream());\n+  }\n+\n+  static class L2Producer extends BaseObjProducer<L2> implements L2 {\n+    private List<Id> children;\n+\n+    @Override\n+    public L2 children(Stream<Id> ids) {\n+      this.children = ids.collect(Collectors.toList());\n+      return this;\n+    }\n+\n+    @Override\n+    BaseObj<L2> build() {\n+      return new L2Obj(getId(), getDt(), children);\n+    }\n+  }\n+\n+  @Override\n+  BaseObj<L2> copy() {\n+    return new L2Obj(getId(), getDt(), new ArrayList<>(children));\n+  }\n+\n+  @Override\n+  public void evaluate(Function function) throws ConditionFailedException {\n+    final String segment = function.getRootPathAsNameSegment().getName();\n+    switch (segment) {\n+      case ID:\n+        evaluatesId(function);\n+        break;\n+      case CHILDREN:\n+        evaluate(function, children);\n+        break;\n+      default:\n+        // Invalid Condition Function.\n+        throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n+    }\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    if (!super.equals(o)) {\n+      return false;\n+    }\n+\n+    L2Obj that = (L2Obj) o;\n+\n+    return children.equals(that.children);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    int result = super.hashCode();\n+    result = 31 * result + children.hashCode();\n+    return result;\n+  }\n+}"
  },
  {
    "sha": "6ba1a755a19da14e41ac9ada4d3b55ffa6c88a58",
    "filename": "versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/L3Obj.java",
    "status": "added",
    "additions": 95,
    "deletions": 0,
    "changes": 95,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/L3Obj.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/L3Obj.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/L3Obj.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.projectnessie.versioned.store.ConditionFailedException;\n+import org.projectnessie.versioned.store.Id;\n+import org.projectnessie.versioned.store.KeyDelta;\n+import org.projectnessie.versioned.tiered.L3;\n+\n+final class L3Obj extends BaseObj<L3> {\n+  private final List<KeyDelta> keyDelta;\n+\n+  L3Obj(Id id, long dt, List<KeyDelta> keyDelta) {\n+    super(id, dt);\n+    this.keyDelta = keyDelta;\n+  }\n+\n+  @Override\n+  L3 consume(L3 consumer) {\n+    return super.consume(consumer).keyDelta(keyDelta.stream());\n+  }\n+\n+  static class L3Producer extends BaseObjProducer<L3> implements L3 {\n+    private List<KeyDelta> keyDelta;\n+\n+    @Override\n+    public L3 keyDelta(Stream<KeyDelta> keyDelta) {\n+      this.keyDelta = keyDelta.collect(Collectors.toList());\n+      return this;\n+    }\n+\n+    @Override\n+    BaseObj<L3> build() {\n+      return new L3Obj(getId(), getDt(), keyDelta);\n+    }\n+  }\n+\n+  @Override\n+  BaseObj<L3> copy() {\n+    return new L3Obj(getId(), getDt(),\n+        keyDelta != null ? new ArrayList<>(keyDelta) : null);\n+  }\n+\n+  @Override\n+  public void evaluate(Function function) throws ConditionFailedException {\n+    final String segment = function.getRootPathAsNameSegment().getName();\n+    if (segment.equals(ID)) {\n+      evaluatesId(function);\n+    } else {\n+      throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n+    }\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    if (!super.equals(o)) {\n+      return false;\n+    }\n+\n+    L3Obj that = (L3Obj) o;\n+\n+    return keyDelta.equals(that.keyDelta);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    int result = super.hashCode();\n+    result = 31 * result + keyDelta.hashCode();\n+    return result;\n+  }\n+}"
  },
  {
    "sha": "8d62c679fcafdc3b6b537d73a484e731ec16c119",
    "filename": "versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/RefObj.java",
    "status": "added",
    "additions": 646,
    "deletions": 0,
    "changes": 646,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/RefObj.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/RefObj.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/RefObj.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,646 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.projectnessie.versioned.Key;\n+import org.projectnessie.versioned.Key.Mutation;\n+import org.projectnessie.versioned.impl.condition.ExpressionFunction;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath.NameSegment;\n+import org.projectnessie.versioned.impl.condition.ExpressionPath.PathSegment;\n+import org.projectnessie.versioned.impl.condition.RemoveClause;\n+import org.projectnessie.versioned.impl.condition.SetClause;\n+import org.projectnessie.versioned.store.ConditionFailedException;\n+import org.projectnessie.versioned.store.Entity;\n+import org.projectnessie.versioned.store.Id;\n+import org.projectnessie.versioned.tiered.Ref;\n+import org.projectnessie.versioned.tiered.Ref.BranchCommit;\n+import org.projectnessie.versioned.tiered.Ref.UnsavedCommitDelta;\n+import org.projectnessie.versioned.tiered.Ref.UnsavedCommitMutations;\n+\n+import com.google.common.primitives.Ints;\n+\n+public class RefObj extends BaseObj<Ref> {\n+  static final String TYPE = \"type\";\n+  static final String NAME = \"name\";\n+  static final String METADATA = \"metadata\";\n+  static final String COMMITS = \"commits\";\n+  static final String COMMIT = \"commit\";\n+  static final String CHILDREN = \"children\";\n+  static final String TREE = \"tree\";\n+  static final String PARENT = \"parent\";\n+  static final String DELTAS = \"deltas\";\n+  static final String KEYS = \"keys\";\n+\n+  private String name;\n+  // tag\n+  private final Id commit;\n+  // branch\n+  private final Id metadata;\n+  private final List<Id> children;\n+  private final List<Commit> commits;\n+\n+  RefObj(Id id, long dt, String name, Id commit, Id metadata, List<Id> children, List<Commit> commits) {\n+    super(id, dt);\n+    this.name = name;\n+    this.commit = commit;\n+    this.metadata = metadata;\n+    this.children = children;\n+    this.commits = commits;\n+  }\n+\n+  @Override\n+  Ref consume(Ref consumer) {\n+    super.consume(consumer)\n+        .name(name);\n+    if (commit != null) {\n+      consumer.tag().commit(commit);\n+    } else {\n+      consumer.branch().metadata(metadata)\n+          .children(children.stream())\n+          .commits(bc -> commits.forEach(c -> c.consume(bc)));\n+    }\n+    return consumer;\n+  }\n+\n+  @Override\n+  BaseObj<Ref> copy() {\n+    return new RefObj(getId(), getDt(), name, commit, metadata,\n+        children != null ? new ArrayList<>(children) : null,\n+        commits != null ? commits.stream().map(Commit::copy).collect(Collectors.toList()) : null);\n+  }\n+\n+  @Override\n+  void applyRemove(RemoveClause removeClause, Consumer<DeferredRemove> deferredRemoveConsumer) {\n+    NameSegment root = removeClause.getPath().getRoot();\n+    switch (root.getName()) {\n+      case COMMITS:\n+        PathSegment position = root.getChild().orElseThrow(() -> new IllegalStateException(\"Position required\"));\n+        int pos = position.asPosition().getPosition();\n+        if (position.getChild().isPresent()) {\n+          commits.get(pos).applyRemove(position.getChild().get().asName().getName());\n+        } else {\n+          deferredRemoveConsumer.accept(new DeferredRemove(pos, commits::remove));\n+        }\n+        break;\n+      default:\n+        throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  @Override\n+  void applySet(SetClause setClause) {\n+    NameSegment root = setClause.getPath().getRoot();\n+    switch (root.getName()) {\n+      case NAME:\n+        switch (setClause.getValue().getType()) {\n+          case VALUE:\n+            this.name = setClause.getValue().getValue().getString();\n+            break;\n+          case FUNCTION:\n+          case PATH:\n+          default:\n+            throw new UnsupportedOperationException();\n+        }\n+        break;\n+      case TREE:\n+        switch (setClause.getValue().getType()) {\n+          case VALUE:\n+            int position = root.getChild().orElseThrow(() -> new IllegalStateException(\"Position required\")).asPosition().getPosition();\n+            children.set(position, Id.fromEntity(setClause.getValue().getValue()));\n+            break;\n+          case FUNCTION:\n+          case PATH:\n+          default:\n+            throw new UnsupportedOperationException();\n+        }\n+        break;\n+      case COMMITS:\n+        switch (setClause.getValue().getType()) {\n+          case FUNCTION:\n+            ExpressionFunction expressionFunction = (ExpressionFunction) setClause.getValue();\n+            switch (expressionFunction.getName()) {\n+              case LIST_APPEND:\n+                List<Entity> valueList = expressionFunction.getArguments().get(1).getValue().getList();\n+                valueList.stream().map(Commit::fromEntity).forEach(commits::add);\n+                break;\n+              case EQUALS:\n+              case SIZE:\n+              case ATTRIBUTE_NOT_EXISTS:\n+              default:\n+                throw new UnsupportedOperationException();\n+            }\n+            break;\n+          case VALUE:\n+            PathSegment position = root.getChild().orElseThrow(() -> new IllegalStateException(\"Position required\"));\n+            String valueName = position.getChild().orElseThrow(() -> new IllegalStateException(\"Name required\")).asName().getName();\n+            commits.get(position.asPosition().getPosition()).setValue(valueName, setClause.getValue().getValue());\n+            break;\n+          case PATH:\n+          default:\n+            throw new UnsupportedOperationException();\n+        }\n+        break;\n+      default:\n+        throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  @Override\n+  public void evaluate(Function function) throws ConditionFailedException {\n+    final String segment = function.getRootPathAsNameSegment().getName();\n+\n+    switch (segment) {\n+      case ID:\n+        evaluatesId(function);\n+        break;\n+      case TYPE:\n+        String typeFromFunction;\n+        if (function.getValue().getString().equals(\"b\")) {\n+          typeFromFunction = \"b\";\n+        } else if (function.getValue().getString().equals(\"t\")) {\n+          typeFromFunction = \"t\";\n+        } else {\n+          throw new IllegalArgumentException(String.format(\"Unknown type name [%s].\", function.getValue().getString()));\n+        }\n+\n+        String type = commit != null ? \"t\" : \"b\";\n+\n+        if (!function.isRootNameSegmentChildlessAndEquals() || !type.equals(typeFromFunction)) {\n+          throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+        }\n+        break;\n+      case NAME:\n+        if (!function.isRootNameSegmentChildlessAndEquals()\n+            || !name.equals(function.getValue().getString())) {\n+          throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+        }\n+        break;\n+      case TREE:\n+      case CHILDREN:\n+        if (commit != null) {\n+          throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+        }\n+        if (!evaluate(function, children)) {\n+          throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+        }\n+        break;\n+      case METADATA:\n+        if (!function.isRootNameSegmentChildlessAndEquals()\n+            || commit != null\n+            || !metadata.toEntity().equals(function.getValue())) {\n+          throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+        }\n+        break;\n+      case COMMIT:\n+        evaluateTagCommit(function);\n+        break;\n+      case COMMITS:\n+        evaluateBranchCommits(function);\n+        break;\n+      default:\n+        throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n+    }\n+  }\n+\n+  /**\n+   * Evaluates that this branch meets the condition.\n+   *\n+   * @param function the function that is tested against the nameSegment\n+   * @throws ConditionFailedException thrown if the condition expression is invalid or the condition is not met.\n+   */\n+  private void evaluateBranchCommits(Function function) {\n+    switch (function.getOperator()) {\n+      case EQUALS:\n+        if (function.getRootPathAsNameSegment().getChild().isPresent()\n+            || commit != null) {\n+          PathSegment position = function.getRootPathAsNameSegment().getChild().get();\n+          Commit c = commits.get(position.asPosition().getPosition());\n+          PathSegment name = position.getChild().orElseThrow(() -> new IllegalStateException(\"Name required\"));\n+          if (!c.evaluate(name.asName().getName(), function.getValue())) {\n+            throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+          }\n+        } else {\n+          throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+        }\n+        break;\n+      case SIZE:\n+        if (function.getRootPathAsNameSegment().getChild().isPresent()\n+            || commit != null\n+            || commits.size() != function.getValue().getNumber()) {\n+          throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+        }\n+        break;\n+      default:\n+        throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n+    }\n+  }\n+\n+  /**\n+   * Evaluates that this tag meets the condition.\n+   *\n+   * @param function the function that is tested against the nameSegment\n+   * @throws ConditionFailedException thrown if the condition expression is invalid or the condition is not met.\n+   */\n+  private void evaluateTagCommit(Function function) {\n+    if (!function.getOperator().equals(Function.Operator.EQUALS)\n+        || commit == null\n+        || !commit.toEntity().equals(function.getValue())) {\n+      throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+    }\n+  }\n+\n+  static class RefProducer extends BaseObjProducer<Ref> implements Ref {\n+\n+    private String name;\n+    private Id commit;\n+    private Id metadata;\n+    private List<Id> children;\n+    private final List<Commit> commits = new ArrayList<>();\n+\n+    @Override\n+    public Ref name(String name) {\n+      this.name = name;\n+      return this;\n+    }\n+\n+    @Override\n+    public Tag tag() {\n+      return new Tag() {\n+        @Override\n+        public Tag commit(Id commit) {\n+          RefProducer.this.commit = commit;\n+          return this;\n+        }\n+\n+        @Override\n+        public Ref backToRef() {\n+          return RefProducer.this;\n+        }\n+      };\n+    }\n+\n+    @Override\n+    public Branch branch() {\n+      return new Branch() {\n+        @Override\n+        public Branch metadata(Id metadata) {\n+          RefProducer.this.metadata = metadata;\n+          return this;\n+        }\n+\n+        @Override\n+        public Branch children(Stream<Id> children) {\n+          RefProducer.this.children = children.collect(Collectors.toList());\n+          return this;\n+        }\n+\n+        @Override\n+        public Branch commits(Consumer<BranchCommit> commits) {\n+          commits.accept(new BranchCommitObj());\n+          return this;\n+        }\n+\n+        @Override\n+        public Ref backToRef() {\n+          return RefProducer.this;\n+        }\n+      };\n+    }\n+\n+    private final class BranchCommitObj implements BranchCommit {\n+      private Id id;\n+      private Id commit;\n+\n+      @Override\n+      public BranchCommit id(Id id) {\n+        this.id = id;\n+        return this;\n+      }\n+\n+      @Override\n+      public BranchCommit commit(Id commit) {\n+        this.commit = commit;\n+        return this;\n+      }\n+\n+      @Override\n+      public SavedCommit saved() {\n+        return new SavedCommit() {\n+          private Id parent;\n+\n+          @Override\n+          public SavedCommit parent(Id parent) {\n+            this.parent = parent;\n+            return this;\n+          }\n+\n+          @Override\n+          public BranchCommit done() {\n+            commits.add(new Commit(id, commit, parent));\n+            return BranchCommitObj.this;\n+          }\n+        };\n+      }\n+\n+      @Override\n+      public UnsavedCommitDelta unsaved() {\n+        return new UnsavedCommitDelta() {\n+          private final List<UnsavedDelta> deltas = new ArrayList<>();\n+\n+          @Override\n+          public UnsavedCommitDelta delta(int position, Id oldId, Id newId) {\n+            this.deltas.add(new UnsavedDelta(position, oldId, newId));\n+            return this;\n+          }\n+\n+          @Override\n+          public UnsavedCommitMutations mutations() {\n+            return new UnsavedCommitMutations() {\n+              private final List<Mutation> keyMutations = new ArrayList<>();\n+\n+              @Override\n+              public UnsavedCommitMutations keyMutation(Mutation keyMutation) {\n+                this.keyMutations.add(keyMutation);\n+                return this;\n+              }\n+\n+              @Override\n+              public BranchCommit done() {\n+                commits.add(new Commit(id, commit, deltas, keyMutations));\n+                return BranchCommitObj.this;\n+              }\n+            };\n+          }\n+        };\n+      }\n+    }\n+\n+    @Override\n+    BaseObj<Ref> build() {\n+      return new RefObj(getId(), getDt(), name, commit, metadata, children, commits);\n+    }\n+  }\n+\n+  private static final class Commit {\n+    private Id id;\n+    private Id commit;\n+\n+    private Id parent;\n+\n+    private final List<UnsavedDelta> deltas;\n+    private final List<Mutation> keyMutations;\n+\n+    private Commit(Id id, Id commit, Id parent, List<UnsavedDelta> deltas, List<Mutation> keyMutations) {\n+      this.id = id;\n+      this.commit = commit;\n+\n+      this.parent = parent;\n+\n+      this.deltas = deltas;\n+      this.keyMutations = keyMutations;\n+    }\n+\n+    Commit(Id id, Id commit, Id parent) {\n+      this(id, commit, parent, new ArrayList<>(), new ArrayList<>());\n+    }\n+\n+    Commit(Id id, Id commit, List<UnsavedDelta> deltas, List<Mutation> keyMutations) {\n+      this(id, commit, null, deltas, keyMutations);\n+    }\n+\n+    Id getId() {\n+      return id;\n+    }\n+\n+    Id getCommit() {\n+      return commit;\n+    }\n+\n+    void consume(BranchCommit bc) {\n+      bc.id(id).commit(commit);\n+\n+      if (parent != null) {\n+        // saved\n+        bc.saved().parent(parent).done();\n+      } else {\n+        // unsaved\n+        UnsavedCommitDelta unsaved = bc.unsaved();\n+        deltas.forEach(d -> unsaved.delta(d.getPosition(), d.getOldId(), d.getNewId()));\n+        UnsavedCommitMutations mutations = unsaved.mutations();\n+        keyMutations.forEach(mutations::keyMutation);\n+        mutations.done();\n+      }\n+    }\n+\n+    Commit copy() {\n+      return new Commit(getId(), getCommit(), parent, new ArrayList<>(deltas), new ArrayList<>(keyMutations));\n+    }\n+\n+    static Commit fromEntity(Entity entity) {\n+      Map<String, Entity> map = entity.getMap();\n+      if (map.containsKey(PARENT)) {\n+        return new Commit(\n+            Id.fromEntity(map.get(ID)),\n+            Id.fromEntity(map.get(COMMIT)),\n+            Id.fromEntity(map.get(PARENT)));\n+      } else {\n+        return new Commit(\n+            Id.fromEntity(map.get(ID)),\n+            Id.fromEntity(map.get(COMMIT)),\n+            map.get(DELTAS).getList().stream().map(UnsavedDelta::fromEntity).collect(Collectors.toList()),\n+            map.get(KEYS).getList().stream().map(Commit::keyMutationFromEntity).collect(Collectors.toList())\n+        );\n+      }\n+    }\n+\n+    private static Mutation keyMutationFromEntity(Entity entity) {\n+      Map<String, Entity> map = entity.getMap();\n+      if (map.containsKey(\"a\")) {\n+        return Key.of(map.get(\"a\").getList().stream().map(Entity::getString).toArray(String[]::new)).asAddition();\n+      }\n+      if (map.containsKey(\"d\")) {\n+        return Key.of(map.get(\"d\").getList().stream().map(Entity::getString).toArray(String[]::new)).asRemoval();\n+      }\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    boolean evaluate(String name, Entity value) {\n+      switch (name) {\n+        case ID:\n+          return Id.fromEntity(value).equals(id);\n+        case COMMIT:\n+          return Id.fromEntity(value).equals(commit);\n+        case PARENT:\n+          return Id.fromEntity(value).equals(parent);\n+        default:\n+          return false;\n+      }\n+    }\n+\n+    void setValue(String name, Entity value) {\n+      switch (name) {\n+        case ID:\n+          this.id = Id.fromEntity(value);\n+          break;\n+        case COMMIT:\n+          this.commit = Id.fromEntity(value);\n+          break;\n+        case PARENT:\n+          this.parent = Id.fromEntity(value);\n+          break;\n+        default:\n+          throw new UnsupportedOperationException();\n+      }\n+    }\n+\n+    public void applyRemove(String name) {\n+      switch (name) {\n+        case DELTAS:\n+          deltas.clear();\n+          break;\n+        case KEYS:\n+          keyMutations.clear();\n+          break;\n+        case PARENT:\n+          parent = null;\n+          break;\n+        default:\n+          throw new UnsupportedOperationException();\n+      }\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+\n+      Commit commit1 = (Commit) o;\n+\n+      return Objects.equals(id, commit1.id)\n+          && Objects.equals(commit, commit1.commit)\n+          && Objects.equals(parent, commit1.parent)\n+          && Objects.equals(deltas, commit1.deltas)\n+          && Objects.equals(keyMutations, commit1.keyMutations);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      int result = id != null ? id.hashCode() : 0;\n+      result = 31 * result + (commit != null ? commit.hashCode() : 0);\n+      result = 31 * result + (parent != null ? parent.hashCode() : 0);\n+      result = 31 * result + (deltas != null ? deltas.hashCode() : 0);\n+      result = 31 * result + (keyMutations != null ? keyMutations.hashCode() : 0);\n+      return result;\n+    }\n+  }\n+\n+  private static final class UnsavedDelta {\n+    private static final String POSITION = \"position\";\n+    private static final String OLD = \"old\";\n+    private static final String NEW = \"new\";\n+\n+    private final int position;\n+    private final Id oldId;\n+    private final Id newId;\n+\n+    UnsavedDelta(int position, Id oldId, Id newId) {\n+      this.position = position;\n+      this.oldId = oldId;\n+      this.newId = newId;\n+    }\n+\n+    int getPosition() {\n+      return position;\n+    }\n+\n+    Id getOldId() {\n+      return oldId;\n+    }\n+\n+    Id getNewId() {\n+      return newId;\n+    }\n+\n+    static UnsavedDelta fromEntity(Entity entity) {\n+      Map<String, Entity> map = entity.getMap();\n+      return new UnsavedDelta(Ints.saturatedCast(map.get(POSITION).getNumber()),\n+        Id.fromEntity(map.get(OLD)),\n+        Id.fromEntity(map.get(NEW)));\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      UnsavedDelta that = (UnsavedDelta) o;\n+      return position == that.position && Objects.equals(oldId, that.oldId)\n+          && Objects.equals(newId, that.newId);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(position, oldId, newId);\n+    }\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    if (!super.equals(o)) {\n+      return false;\n+    }\n+\n+    RefObj refObj = (RefObj) o;\n+\n+    return Objects.equals(name, refObj.name)\n+        && Objects.equals(commit, refObj.commit)\n+        && Objects.equals(metadata, refObj.metadata)\n+        && Objects.equals(children, refObj.children)\n+        && Objects.equals(commits, refObj.commits);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    int result = super.hashCode();\n+    result = 31 * result + (name != null ? name.hashCode() : 0);\n+    result = 31 * result + (commit != null ? commit.hashCode() : 0);\n+    result = 31 * result + (metadata != null ? metadata.hashCode() : 0);\n+    result = 31 * result + (children != null ? children.hashCode() : 0);\n+    result = 31 * result + (commits != null ? commits.hashCode() : 0);\n+    return result;\n+  }\n+}"
  },
  {
    "sha": "61e73d2d60962b9ecae74ebfaba08ec5e27da6a1",
    "filename": "versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/ValueObj.java",
    "status": "added",
    "additions": 41,
    "deletions": 0,
    "changes": 41,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/ValueObj.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/ValueObj.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/ValueObj.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import org.projectnessie.versioned.store.Id;\n+import org.projectnessie.versioned.tiered.Value;\n+\n+import com.google.protobuf.ByteString;\n+\n+final class ValueObj extends WrappedValueObj<Value> {\n+\n+  ValueObj(Id id, long dt, ByteString value) {\n+    super(id, dt, value);\n+  }\n+\n+  @Override\n+  BaseObj<Value> copy() {\n+    return new ValueObj(getId(), getDt(), getValue());\n+  }\n+\n+  static class ValueProducer extends BaseWrappedValueObjProducer<Value> implements Value {\n+\n+    @Override\n+    BaseObj<Value> build() {\n+      return new ValueObj(getId(), getDt(), getValue());\n+    }\n+  }\n+}"
  },
  {
    "sha": "773005b7643fb62418a04466f3a20791ab8771b9",
    "filename": "versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/WrappedValueObj.java",
    "status": "added",
    "additions": 102,
    "deletions": 0,
    "changes": 102,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/WrappedValueObj.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/WrappedValueObj.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/main/java/org/projectnessie/versioned/inmem/WrappedValueObj.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.projectnessie.versioned.inmem;\n+\n+import org.projectnessie.versioned.store.ConditionFailedException;\n+import org.projectnessie.versioned.store.Id;\n+import org.projectnessie.versioned.tiered.BaseWrappedValue;\n+\n+import com.google.protobuf.ByteString;\n+\n+abstract class WrappedValueObj<C extends BaseWrappedValue<C>> extends BaseObj<C> {\n+  static final String VALUE = \"value\";\n+  private final ByteString value;\n+\n+  WrappedValueObj(Id id, long dt, ByteString value) {\n+    super(id, dt);\n+    this.value = value;\n+  }\n+\n+  ByteString getValue() {\n+    return value;\n+  }\n+\n+  @Override\n+  C consume(C consumer) {\n+    return super.consume(consumer).value(value);\n+  }\n+\n+  abstract static class BaseWrappedValueObjProducer<C extends BaseWrappedValue<C>>\n+      extends BaseObjProducer<C> implements BaseWrappedValue<C> {\n+\n+    private ByteString value;\n+\n+    ByteString getValue() {\n+      return value;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public C value(ByteString value) {\n+      this.value = value;\n+      return (C) this;\n+    }\n+  }\n+\n+  @Override\n+  public void evaluate(Function function) throws ConditionFailedException {\n+    final String segment = function.getRootPathAsNameSegment().getName();\n+    switch (segment) {\n+      case ID:\n+        evaluatesId(function);\n+        break;\n+      case VALUE:\n+        if (!function.isRootNameSegmentChildlessAndEquals()\n+            || !value.equals(function.getValue().getBinary())) {\n+          throw new ConditionFailedException(conditionNotMatchedMessage(function));\n+        }\n+        break;\n+      default:\n+        // Invalid Condition Function.\n+        throw new ConditionFailedException(invalidOperatorSegmentMessage(function));\n+    }\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    if (!super.equals(o)) {\n+      return false;\n+    }\n+\n+    WrappedValueObj<?> that = (WrappedValueObj<?>) o;\n+\n+    return value.equals(that.value);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    int result = super.hashCode();\n+    result = 31 * result + value.hashCode();\n+    return result;\n+  }\n+}"
  },
  {
    "sha": "4ae02eb5aa94c2dea0fc261bfb45f048dfa22773",
    "filename": "versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/ITInMemTestStore.java",
    "status": "added",
    "additions": 61,
    "deletions": 0,
    "changes": 61,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/ITInMemTestStore.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/ITInMemTestStore.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/ITInMemTestStore.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.projectnessie.versioned.impl.AbstractTestStore;\n+\n+/**\n+ * A test class that contains DynamoDB tests.\n+ */\n+class ITInMemTestStore extends AbstractTestStore<InMemStore> {\n+  private InMemStoreFixture fixture;\n+\n+  @AfterEach\n+  void deleteResources() {\n+    fixture.close();\n+  }\n+\n+  /**\n+   * Creates an instance of MongoDBStore on which tests are executed.\n+   * @return the store to test.\n+   */\n+  @Override\n+  protected InMemStore createStore() {\n+    fixture = new InMemStoreFixture();\n+    return fixture.getStore();\n+  }\n+\n+  @Override\n+  protected InMemStore createRawStore() {\n+    return fixture.createStoreImpl();\n+  }\n+\n+  @Override\n+  protected long getRandomSeed() {\n+    return 8612341233543L;\n+  }\n+\n+  @Override\n+  protected void resetStoreState() {\n+    super.store = null;\n+  }\n+\n+  @Override\n+  protected int loadSize() {\n+    return 100;\n+  }\n+}"
  },
  {
    "sha": "813885570bbda55c17b8c568f52968702993d7b1",
    "filename": "versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/ITInMemTieredVersionStore.java",
    "status": "added",
    "additions": 25,
    "deletions": 0,
    "changes": 25,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/ITInMemTieredVersionStore.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/ITInMemTieredVersionStore.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/ITInMemTieredVersionStore.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import org.projectnessie.versioned.impl.AbstractITTieredVersionStore;\n+\n+class ITInMemTieredVersionStore extends AbstractITTieredVersionStore {\n+  @Override\n+  protected InMemStoreFixture createNewFixture() {\n+    return new InMemStoreFixture();\n+  }\n+}"
  },
  {
    "sha": "3af92403b7f6e2079c583a2e37edcd020dfec305",
    "filename": "versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/ITInMemVersionStore.java",
    "status": "added",
    "additions": 65,
    "deletions": 0,
    "changes": 65,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/ITInMemVersionStore.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/ITInMemVersionStore.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/ITInMemVersionStore.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.projectnessie.versioned.ReferenceAlreadyExistsException;\n+import org.projectnessie.versioned.ReferenceConflictException;\n+import org.projectnessie.versioned.ReferenceNotFoundException;\n+import org.projectnessie.versioned.VersionStore;\n+import org.projectnessie.versioned.VersionStoreException;\n+import org.projectnessie.versioned.tests.AbstractITVersionStore;\n+\n+public class ITInMemVersionStore extends AbstractITVersionStore {\n+\n+  private InMemStoreFixture fixture;\n+\n+  @BeforeEach\n+  void setup() {\n+    fixture = new InMemStoreFixture();\n+  }\n+\n+  @AfterEach\n+  void deleteResources() {\n+    fixture.close();\n+  }\n+\n+  @Override\n+  protected VersionStore<String, String> store() {\n+    return fixture;\n+  }\n+\n+  @Disabled\n+  @Override\n+  public void commitWithInvalidReference() throws ReferenceNotFoundException,\n+      ReferenceConflictException, ReferenceAlreadyExistsException {\n+    super.commitWithInvalidReference();\n+  }\n+\n+  @Nested\n+  @DisplayName(\"when transplanting\")\n+  class WhenTransplanting extends AbstractITVersionStore.WhenTransplanting {\n+    @Disabled\n+    @Override\n+    protected void checkInvalidBranchHash() throws VersionStoreException {\n+      super.checkInvalidBranchHash();\n+    }\n+  }\n+}"
  },
  {
    "sha": "1cf981fe992860f243d5189e03717202aef13840",
    "filename": "versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/InMemStoreFixture.java",
    "status": "added",
    "additions": 39,
    "deletions": 0,
    "changes": 39,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/InMemStoreFixture.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/InMemStoreFixture.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/InMemStoreFixture.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import org.projectnessie.versioned.impl.AbstractTieredStoreFixture;\n+\n+/**\n+ * DynamoDB Store fixture.\n+ *\n+ * <p>Combine a local dynamodb server with a {@code VersionStore} instance to be used for tests.\n+ */\n+public class InMemStoreFixture extends AbstractTieredStoreFixture<InMemStore, String> {\n+  public InMemStoreFixture() {\n+    super(\"\");\n+  }\n+\n+  @Override\n+  public InMemStore createStoreImpl() {\n+    return new InMemStore();\n+  }\n+\n+  @Override\n+  public void close() {\n+    getStore().close();\n+  }\n+}"
  },
  {
    "sha": "cb192ccd9f0f8e7f490b48d4ba785a704305c6a7",
    "filename": "versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/TestInMemObject.java",
    "status": "added",
    "additions": 70,
    "deletions": 0,
    "changes": 70,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/TestInMemObject.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/TestInMemObject.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/test/java/org/projectnessie/versioned/inmem/TestInMemObject.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.inmem;\n+\n+import java.util.Random;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.projectnessie.versioned.impl.SampleEntities;\n+import org.projectnessie.versioned.inmem.BaseObj.BaseObjProducer;\n+import org.projectnessie.versioned.store.ValueType;\n+import org.projectnessie.versioned.tiered.BaseValue;\n+\n+public class TestInMemObject {\n+\n+  private final InMemStore store = new InMemStore();\n+\n+  private static Stream<ValueType<?>> allTypes() {\n+    return ValueType.values().stream()\n+        // repeat 20 times, cannot mix @ParameterizedTest + @RepeatedTest\n+        .flatMap(t -> IntStream.range(0, 20).mapToObj(x -> t));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"allTypes\")\n+  void testEqualsAndHashCode(ValueType<?> type) {\n+    Random r = new Random();\n+\n+    long seed = r.nextLong();\n+    BaseObj<?> inst1 = createInstance(type, new Random(seed));\n+    BaseObj<?> inst2 = createInstance(type, new Random(seed));\n+\n+    Assertions.assertEquals(inst1, inst2);\n+    Assertions.assertEquals(inst1.hashCode(), inst2.hashCode());\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"allTypes\")\n+  void testCopy(ValueType<?> type) {\n+    Random r = new Random();\n+\n+    BaseObj<?> inst = createInstance(type, r);\n+    BaseObj<?> copy = inst.copy();\n+\n+    Assertions.assertEquals(inst, copy);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <C extends BaseValue<C>, V extends BaseObj<C>> V createInstance(ValueType<C> type, Random r) {\n+    BaseObjProducer<C> producer = store.newProducer(type);\n+    SampleEntities.produceRandomTo(type, (C) producer, r);\n+    return (V) producer.build();\n+  }\n+}"
  },
  {
    "sha": "866ebc96d432ec701ba374a1cfdc51670b5c82e4",
    "filename": "versioned/tiered/inmem/src/test/resources/logback-test.xml",
    "status": "added",
    "additions": 30,
    "deletions": 0,
    "changes": 30,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/test/resources/logback-test.xml",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/inmem/src/test/resources/logback-test.xml",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/inmem/src/test/resources/logback-test.xml?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -0,0 +1,30 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n+<!--\n+\n+    Copyright (C) 2020 Dremio\n+\n+    Licensed under the Apache License, Version 2.0 (the \"License\");\n+    you may not use this file except in compliance with the License.\n+    You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n+\n+-->\n+<configuration debug=\"true\">\n+  <contextListener class=\"ch.qos.logback.classic.jul.LevelChangePropagator\"/>\n+  <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n+    <encoder>\n+      <pattern>%date{ISO8601} [%thread] %-5level %logger{36} - %msg%n</pattern>\n+    </encoder>\n+  </appender>\n+  <root>\n+    <level value=\"warn\"/>\n+    <appender-ref ref=\"console\"/>\n+  </root>\n+</configuration>"
  },
  {
    "sha": "e704f5701ca29972324d546c79c550ee3255390b",
    "filename": "versioned/tiered/pom.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/pom.xml",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/pom.xml",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/pom.xml?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -31,6 +31,7 @@\n   <name>Nessie - Versioned - Tiered - Parent</name>\n \n   <modules>\n+    <module>inmem</module>\n     <module>dynamodb</module>\n     <module>gc</module>\n     <module>mongodb</module>"
  },
  {
    "sha": "46233c04796d09abb5f675a0d7e381ac9cde5d1f",
    "filename": "versioned/tiered/tiered-tests/src/main/java/org/projectnessie/versioned/impl/SampleEntities.java",
    "status": "modified",
    "additions": 32,
    "deletions": 0,
    "changes": 32,
    "blob_url": "https://github.com/projectnessie/nessie/blob/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/tiered-tests/src/main/java/org/projectnessie/versioned/impl/SampleEntities.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/013a6994e0bed4b8cdf344296da6a4a539133fc0/versioned/tiered/tiered-tests/src/main/java/org/projectnessie/versioned/impl/SampleEntities.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/tiered-tests/src/main/java/org/projectnessie/versioned/impl/SampleEntities.java?ref=013a6994e0bed4b8cdf344296da6a4a539133fc0",
    "patch": "@@ -23,6 +23,8 @@\n import org.projectnessie.versioned.store.Entity;\n import org.projectnessie.versioned.store.Id;\n import org.projectnessie.versioned.store.KeyDelta;\n+import org.projectnessie.versioned.store.ValueType;\n+import org.projectnessie.versioned.tiered.BaseValue;\n \n import com.google.protobuf.ByteString;\n \n@@ -34,6 +36,36 @@\n  * objects, and should be moved once possible.\n  */\n public class SampleEntities {\n+  public static <C extends BaseValue<C>> void produceRandomTo(ValueType<C> type, C consumer, Random r) {\n+    PersistentBase<C> internalRandom = createRandom(type, r);\n+    internalRandom.applyToConsumer(consumer);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private static <C extends BaseValue<C>> PersistentBase<C> createRandom(ValueType<C> type, Random r) {\n+    if (type == ValueType.L1) {\n+      return (PersistentBase<C>) createL1(r);\n+    } else if (type == ValueType.L2) {\n+      return (PersistentBase<C>) createL2(r);\n+    } else if (type == ValueType.L3) {\n+      return (PersistentBase<C>) createL3(r);\n+    } else if (type == ValueType.VALUE) {\n+      return (PersistentBase<C>) createValue(r);\n+    } else if (type == ValueType.COMMIT_METADATA) {\n+      return (PersistentBase<C>) createCommitMetadata(r);\n+    } else if (type == ValueType.KEY_FRAGMENT) {\n+      return (PersistentBase<C>) createFragment(r);\n+    } else if (type == ValueType.REF) {\n+      if (r.nextBoolean()) {\n+        return (PersistentBase<C>) createBranch(r);\n+      } else {\n+        return (PersistentBase<C>) createTag(r);\n+      }\n+    } else {\n+      throw new IllegalArgumentException(\"Unknown type \" + type);\n+    }\n+  }\n+\n   /**\n    * Create a Sample L1 entity.\n    * @param random object to use for randomization of entity creation."
  }
]
