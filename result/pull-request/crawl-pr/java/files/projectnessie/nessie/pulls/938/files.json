[
  {
    "sha": "a5d1ac65f6e7489b3b666c50749c647c229e259f",
    "filename": "clients/client/src/main/java/org/projectnessie/client/rest/NessieBackendThrottledException.java",
    "status": "added",
    "additions": 29,
    "deletions": 0,
    "changes": 29,
    "blob_url": "https://github.com/projectnessie/nessie/blob/d6ab6b438b9d422a5d0762f0f7c983753a72817e/clients/client/src/main/java/org/projectnessie/client/rest/NessieBackendThrottledException.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/d6ab6b438b9d422a5d0762f0f7c983753a72817e/clients/client/src/main/java/org/projectnessie/client/rest/NessieBackendThrottledException.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/clients/client/src/main/java/org/projectnessie/client/rest/NessieBackendThrottledException.java?ref=d6ab6b438b9d422a5d0762f0f7c983753a72817e",
    "patch": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.client.rest;\n+\n+import org.projectnessie.error.NessieError;\n+\n+/**\n+ * If a backend store refuses to process a request, the condition is signalled to clients\n+ * via this exception.\n+ */\n+public class NessieBackendThrottledException extends NessieServiceException {\n+\n+  public NessieBackendThrottledException(NessieError serverError) {\n+    super(serverError);\n+  }\n+}"
  },
  {
    "sha": "91ef9aefbc6c1bb6fc33b6a68914d292ccc22162",
    "filename": "clients/client/src/main/java/org/projectnessie/client/rest/ResponseCheckFilter.java",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/projectnessie/nessie/blob/d6ab6b438b9d422a5d0762f0f7c983753a72817e/clients/client/src/main/java/org/projectnessie/client/rest/ResponseCheckFilter.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/d6ab6b438b9d422a5d0762f0f7c983753a72817e/clients/client/src/main/java/org/projectnessie/client/rest/ResponseCheckFilter.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/clients/client/src/main/java/org/projectnessie/client/rest/ResponseCheckFilter.java?ref=d6ab6b438b9d422a5d0762f0f7c983753a72817e",
    "patch": "@@ -60,6 +60,8 @@ public static void checkResponse(ResponseContext con, ObjectMapper mapper) throw\n         throw new NessieNotFoundException(error);\n       case CONFLICT:\n         throw new NessieConflictException(error);\n+      case TOO_MANY_REQUESTS:\n+        throw new NessieBackendThrottledException(error);\n       case INTERNAL_SERVER_ERROR:\n         throw new NessieInternalServerException(error);\n       default:"
  },
  {
    "sha": "01d9531b447b57f5ac52b146d7c49a5cdefbb1bc",
    "filename": "servers/quarkus-server/pom.xml",
    "status": "modified",
    "additions": 11,
    "deletions": 0,
    "changes": 11,
    "blob_url": "https://github.com/projectnessie/nessie/blob/d6ab6b438b9d422a5d0762f0f7c983753a72817e/servers/quarkus-server/pom.xml",
    "raw_url": "https://github.com/projectnessie/nessie/raw/d6ab6b438b9d422a5d0762f0f7c983753a72817e/servers/quarkus-server/pom.xml",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/servers/quarkus-server/pom.xml?ref=d6ab6b438b9d422a5d0762f0f7c983753a72817e",
    "patch": "@@ -180,6 +180,17 @@\n       <artifactId>quarkus-test-security</artifactId>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>org.projectnessie</groupId>\n+      <artifactId>nessie-versioned-tests</artifactId>\n+      <version>${project.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-core</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n   </dependencies>\n \n   <build>"
  },
  {
    "sha": "07647253228acbce5625abc9b09b8bee3661f953",
    "filename": "servers/quarkus-server/src/main/resources/application.properties",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/projectnessie/nessie/blob/d6ab6b438b9d422a5d0762f0f7c983753a72817e/servers/quarkus-server/src/main/resources/application.properties",
    "raw_url": "https://github.com/projectnessie/nessie/raw/d6ab6b438b9d422a5d0762f0f7c983753a72817e/servers/quarkus-server/src/main/resources/application.properties",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/servers/quarkus-server/src/main/resources/application.properties?ref=d6ab6b438b9d422a5d0762f0f7c983753a72817e",
    "patch": "@@ -17,7 +17,7 @@\n # Nessie settings\n ### default base branch name\n nessie.server.default-branch=main\n-nessie.server.send-stacktrace-to-client=true\n+nessie.server.send-stacktrace-to-client=false\n \n ### which type of version store to use: JGIT, INMEMORY, DYNAMO. JGIT is best for local testing, DYNAMO preferred for production\n nessie.version.store.type=INMEMORY"
  },
  {
    "sha": "9e1ee6d0d0520038b9d53458372419b2cac2e6ec",
    "filename": "servers/quarkus-server/src/test/java/org/projectnessie/server/error/ErrorTestService.java",
    "status": "modified",
    "additions": 40,
    "deletions": 0,
    "changes": 40,
    "blob_url": "https://github.com/projectnessie/nessie/blob/d6ab6b438b9d422a5d0762f0f7c983753a72817e/servers/quarkus-server/src/test/java/org/projectnessie/server/error/ErrorTestService.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/d6ab6b438b9d422a5d0762f0f7c983753a72817e/servers/quarkus-server/src/test/java/org/projectnessie/server/error/ErrorTestService.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/servers/quarkus-server/src/test/java/org/projectnessie/server/error/ErrorTestService.java?ref=d6ab6b438b9d422a5d0762f0f7c983753a72817e",
    "patch": "@@ -28,11 +28,19 @@\n import javax.ws.rs.POST;\n import javax.ws.rs.PUT;\n import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n import javax.ws.rs.Produces;\n import javax.ws.rs.QueryParam;\n import javax.ws.rs.core.MediaType;\n \n+import org.mockito.Mockito;\n import org.projectnessie.error.NessieNotFoundException;\n+import org.projectnessie.versioned.BackendLimitExceededException;\n+import org.projectnessie.versioned.StoreWorker;\n+import org.projectnessie.versioned.StringSerializer;\n+import org.projectnessie.versioned.impl.TieredVersionStore;\n+import org.projectnessie.versioned.store.Store;\n+import org.projectnessie.versioned.store.ValueType;\n \n /**\n  * REST service used to generate a bunch of violations for {@link TestNessieError}.\n@@ -103,4 +111,36 @@ public String constraintDeclarationException() {\n   public String groupDefinitionException() {\n     throw new GroupDefinitionException(\"meep\");\n   }\n+\n+  /**\n+   * Throws an exception depending on the parameter via {@link Store#getValues(ValueType)}.\n+   * @return nothing\n+   * @see TestNessieError#unhandledRuntimeExceptionInStore()\n+   * @see TestNessieError#backendThrottledExceptionInStore()\n+   */\n+  @Path(\"unhandledExceptionInTvsStore/{exception}\")\n+  @GET\n+  @Consumes(MediaType.APPLICATION_JSON)\n+  public String unhandledExceptionInTvsStore(@PathParam(\"exception\") String exception) {\n+    Exception ex;\n+    switch (exception) {\n+      case \"runtime\":\n+        ex = new RuntimeException(\"Store.getValues-throwing\");\n+        break;\n+      case \"throttle\":\n+        ex = new BackendLimitExceededException(\"Store.getValues-throttled\");\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"test code error\");\n+    }\n+\n+    Store store = Mockito.mock(Store.class);\n+    Mockito.when(store.getValues(ValueType.REF)).thenThrow(ex);\n+\n+    TieredVersionStore<String, String> tvs = new TieredVersionStore<>(\n+        StoreWorker.of(StringSerializer.getInstance(), StringSerializer.getInstance()), store,\n+        true);\n+    tvs.getNamedRefs().forEach(ref -> {});\n+    return \"we should not get here\";\n+  }\n }"
  },
  {
    "sha": "693078acef5e8471b4ea6c2c8d50025f54005f56",
    "filename": "servers/quarkus-server/src/test/java/org/projectnessie/server/error/TestNessieError.java",
    "status": "modified",
    "additions": 33,
    "deletions": 11,
    "changes": 44,
    "blob_url": "https://github.com/projectnessie/nessie/blob/d6ab6b438b9d422a5d0762f0f7c983753a72817e/servers/quarkus-server/src/test/java/org/projectnessie/server/error/TestNessieError.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/d6ab6b438b9d422a5d0762f0f7c983753a72817e/servers/quarkus-server/src/test/java/org/projectnessie/server/error/TestNessieError.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/servers/quarkus-server/src/test/java/org/projectnessie/server/error/TestNessieError.java?ref=d6ab6b438b9d422a5d0762f0f7c983753a72817e",
    "patch": "@@ -20,6 +20,7 @@\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.junit.jupiter.api.Assertions.assertAll;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n \n import java.net.URI;\n@@ -31,6 +32,7 @@\n import org.junit.jupiter.api.function.Executable;\n import org.projectnessie.client.http.HttpClient;\n import org.projectnessie.client.http.HttpClientException;\n+import org.projectnessie.client.rest.NessieBackendThrottledException;\n import org.projectnessie.client.rest.NessieBadRequestException;\n import org.projectnessie.client.rest.NessieHttpResponseFilter;\n import org.projectnessie.client.rest.NessieInternalServerException;\n@@ -186,8 +188,7 @@ void nessieNotFoundException() {\n     assertAll(\n         () -> assertEquals(\"not-there-message\",\n                            ex.getMessage()),\n-        () -> assertThat(ex.getServerStackTrace(),\n-                         startsWith(\"org.projectnessie.error.NessieNotFoundException: not-there-message\\n\")),\n+        () -> assertNull(ex.getServerStackTrace()),\n         () -> assertEquals(Response.Status.NOT_FOUND.getStatusCode(), ex.getStatus())\n     );\n   }\n@@ -196,30 +197,51 @@ void nessieNotFoundException() {\n   void nonConstraintValidationExceptions() {\n     // Exceptions that trigger the \"else-ish\" part in ResteasyExceptionMapper.toResponse()\n     assertAll(\n-        () -> assertThat(\n+        () -> assertEquals(\n+            \"Internal Server Error (HTTP/500): javax.validation.ConstraintDefinitionException: meep\",\n             assertThrows(NessieInternalServerException.class,\n                 () -> unwrap(() ->\n                     client.newRequest()\n                         .path(\"constraintDefinitionException\")\n-                        .get())).getMessage(),\n-            startsWith(\"Internal Server Error (HTTP/500): javax.validation.ConstraintDefinitionException: meep\\n\")),\n-        () -> assertThat(\n+                        .get())).getMessage()),\n+        () -> assertEquals(\n+            \"Internal Server Error (HTTP/500): javax.validation.ConstraintDeclarationException: meep\",\n             assertThrows(NessieInternalServerException.class,\n                 () -> unwrap(() ->\n                     client.newRequest()\n                         .path(\"constraintDeclarationException\")\n-                        .get())).getMessage(),\n-            startsWith(\"Internal Server Error (HTTP/500): javax.validation.ConstraintDeclarationException: meep\\n\")),\n-        () -> assertThat(\n+                        .get())).getMessage()),\n+        () -> assertEquals(\n+            \"Internal Server Error (HTTP/500): javax.validation.GroupDefinitionException: meep\",\n             assertThrows(NessieInternalServerException.class,\n                 () -> unwrap(() ->\n                     client.newRequest()\n                         .path(\"groupDefinitionException\")\n-                        .get())).getMessage(),\n-            startsWith(\"Internal Server Error (HTTP/500): javax.validation.GroupDefinitionException: meep\\n\"))\n+                        .get())).getMessage())\n     );\n   }\n \n+  @Test\n+  void unhandledRuntimeExceptionInStore() {\n+    // see org.projectnessie.server.error.ErrorTestService.unhandledExceptionInTvsStore\n+    assertEquals(\"Internal Server Error (HTTP/500): java.lang.RuntimeException: Store.getValues-throwing\",\n+        assertThrows(NessieInternalServerException.class,\n+            () -> client.newRequest()\n+                .path(\"unhandledExceptionInTvsStore/runtime\")\n+                .get()).getMessage());\n+  }\n+\n+  @Test\n+  void backendThrottledExceptionInStore() {\n+    // see org.projectnessie.server.error.ErrorTestService.unhandledExceptionInTvsStore\n+    assertEquals(\"Too Many Requests (HTTP/429): Backend store refused to process the request: \"\n+            + \"org.projectnessie.versioned.BackendLimitExceededException: Store.getValues-throttled\",\n+        assertThrows(NessieBackendThrottledException.class,\n+            () -> client.newRequest()\n+                .path(\"unhandledExceptionInTvsStore/throttle\")\n+                .get()).getMessage());\n+  }\n+\n   void unwrap(Executable exec) throws Throwable {\n     try {\n       exec.execute();"
  },
  {
    "sha": "5bfa627ec0ad9b211009a158d132f79a7cf5352f",
    "filename": "servers/services/src/main/java/org/projectnessie/services/rest/NessieExceptionMapper.java",
    "status": "modified",
    "additions": 17,
    "deletions": 1,
    "changes": 18,
    "blob_url": "https://github.com/projectnessie/nessie/blob/d6ab6b438b9d422a5d0762f0f7c983753a72817e/servers/services/src/main/java/org/projectnessie/services/rest/NessieExceptionMapper.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/d6ab6b438b9d422a5d0762f0f7c983753a72817e/servers/services/src/main/java/org/projectnessie/services/rest/NessieExceptionMapper.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/servers/services/src/main/java/org/projectnessie/services/rest/NessieExceptionMapper.java?ref=d6ab6b438b9d422a5d0762f0f7c983753a72817e",
    "patch": "@@ -15,6 +15,8 @@\n  */\n package org.projectnessie.services.rest;\n \n+import java.util.stream.Collectors;\n+\n import javax.inject.Inject;\n import javax.ws.rs.WebApplicationException;\n import javax.ws.rs.core.Response;\n@@ -24,11 +26,13 @@\n \n import org.projectnessie.error.BaseNessieClientServerException;\n import org.projectnessie.services.config.ServerConfig;\n+import org.projectnessie.versioned.BackendLimitExceededException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.fasterxml.jackson.core.JsonParseException;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.google.common.base.Throwables;\n \n /**\n  * \"Default\" exception mapper implementations, mostly used to serialize the\n@@ -58,27 +62,39 @@ public NessieExceptionMapper(ServerConfig config) {\n   public Response toResponse(Exception exception) {\n     int status;\n     String reason;\n+    String message;\n \n     if (exception instanceof WebApplicationException) {\n       WebApplicationException e = (WebApplicationException) exception;\n       Status st = Status.fromStatusCode(e.getResponse().getStatus());\n       status = st.getStatusCode();\n       reason = st.getReasonPhrase();\n+      message = exception.getMessage();\n     } else if (exception instanceof BaseNessieClientServerException) {\n       // log message at debug level so we can review stack traces if enabled.\n       LOGGER.debug(\"Exception on server with appropriate error sent to client.\", exception);\n       BaseNessieClientServerException e = (BaseNessieClientServerException) exception;\n       status = e.getStatus();\n       reason = e.getReason();\n+      message = exception.getMessage();\n     } else if (exception instanceof JsonParseException\n         || exception instanceof JsonMappingException) {\n+      LOGGER.debug(\"JSON parse/mapping exception\", exception);\n       status = Status.BAD_REQUEST.getStatusCode();\n       reason = Status.BAD_REQUEST.getReasonPhrase();\n+      message = exception.getMessage();\n+    } else if (exception instanceof BackendLimitExceededException) {\n+      LOGGER.warn(\"Backend throttled/refused the request: {}\", exception.toString());\n+      status = Status.TOO_MANY_REQUESTS.getStatusCode();\n+      reason = Status.TOO_MANY_REQUESTS.getReasonPhrase();\n+      message = \"Backend store refused to process the request: \" + exception.toString();\n     } else {\n+      LOGGER.warn(\"Unhandled exception returned as HTTP/500 to client\", exception);\n       status = Status.INTERNAL_SERVER_ERROR.getStatusCode();\n       reason = Status.INTERNAL_SERVER_ERROR.getReasonPhrase();\n+      message = Throwables.getCausalChain(exception).stream().map(Throwable::toString).collect(Collectors.joining(\", caused by\"));\n     }\n \n-    return buildExceptionResponse(status, reason, exception.getMessage(), exception);\n+    return buildExceptionResponse(status, reason, message, exception);\n   }\n }"
  },
  {
    "sha": "2a5e67e1fb101d658939967da9a1258da982c0ca",
    "filename": "versioned/spi/src/main/java/org/projectnessie/versioned/BackendLimitExceededException.java",
    "status": "added",
    "additions": 33,
    "deletions": 0,
    "changes": 33,
    "blob_url": "https://github.com/projectnessie/nessie/blob/d6ab6b438b9d422a5d0762f0f7c983753a72817e/versioned/spi/src/main/java/org/projectnessie/versioned/BackendLimitExceededException.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/d6ab6b438b9d422a5d0762f0f7c983753a72817e/versioned/spi/src/main/java/org/projectnessie/versioned/BackendLimitExceededException.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/spi/src/main/java/org/projectnessie/versioned/BackendLimitExceededException.java?ref=d6ab6b438b9d422a5d0762f0f7c983753a72817e",
    "patch": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned;\n+\n+/**\n+ * Thrown when some limit against the store's backend is exceeded and requests\n+ * against the store or a specific part of the store (e.g. a DynamoDB partition) have been\n+ * refused/throttled by the backend store.\n+ */\n+public class BackendLimitExceededException extends VersionStoreError {\n+\n+  public BackendLimitExceededException(String message, Throwable cause) {\n+    super(message, cause);\n+  }\n+\n+  public BackendLimitExceededException(String message) {\n+    super(message);\n+  }\n+\n+}"
  },
  {
    "sha": "1047da378c09e133153ced0a3e8d6c50a23d0720",
    "filename": "versioned/spi/src/main/java/org/projectnessie/versioned/VersionStoreError.java",
    "status": "added",
    "additions": 44,
    "deletions": 0,
    "changes": 44,
    "blob_url": "https://github.com/projectnessie/nessie/blob/d6ab6b438b9d422a5d0762f0f7c983753a72817e/versioned/spi/src/main/java/org/projectnessie/versioned/VersionStoreError.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/d6ab6b438b9d422a5d0762f0f7c983753a72817e/versioned/spi/src/main/java/org/projectnessie/versioned/VersionStoreError.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/spi/src/main/java/org/projectnessie/versioned/VersionStoreError.java?ref=d6ab6b438b9d422a5d0762f0f7c983753a72817e",
    "patch": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned;\n+\n+/**\n+ * Base unchecked exception for technical error conditions of a backend store.\n+ */\n+public class VersionStoreError extends RuntimeException {\n+  private static final long serialVersionUID = 1L;\n+\n+  public VersionStoreError() {\n+    super();\n+  }\n+\n+  public VersionStoreError(String message, Throwable cause, boolean enableSuppression,\n+      boolean writableStackTrace) {\n+    super(message, cause, enableSuppression, writableStackTrace);\n+  }\n+\n+  public VersionStoreError(String message, Throwable cause) {\n+    super(message, cause);\n+  }\n+\n+  public VersionStoreError(String message) {\n+    super(message);\n+  }\n+\n+  public VersionStoreError(Throwable cause) {\n+    super(cause);\n+  }\n+}"
  },
  {
    "sha": "e60ca87b30e798a65954a1d7469e3d4561000f01",
    "filename": "versioned/tiered/dynamodb/src/main/java/org/projectnessie/versioned/dynamodb/DynamoStore.java",
    "status": "modified",
    "additions": 107,
    "deletions": 72,
    "changes": 179,
    "blob_url": "https://github.com/projectnessie/nessie/blob/d6ab6b438b9d422a5d0762f0f7c983753a72817e/versioned/tiered/dynamodb/src/main/java/org/projectnessie/versioned/dynamodb/DynamoStore.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/d6ab6b438b9d422a5d0762f0f7c983753a72817e/versioned/tiered/dynamodb/src/main/java/org/projectnessie/versioned/dynamodb/DynamoStore.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/dynamodb/src/main/java/org/projectnessie/versioned/dynamodb/DynamoStore.java?ref=d6ab6b438b9d422a5d0762f0f7c983753a72817e",
    "patch": "@@ -36,6 +36,9 @@\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n+import javax.annotation.Nonnull;\n+\n+import org.projectnessie.versioned.BackendLimitExceededException;\n import org.projectnessie.versioned.dynamodb.metrics.DynamoMetricsPublisher;\n import org.projectnessie.versioned.dynamodb.metrics.TracingExecutionInterceptor;\n import org.projectnessie.versioned.impl.EntityStoreHelper;\n@@ -60,7 +63,6 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n-import com.google.common.base.Throwables;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ListMultimap;\n import com.google.common.collect.Multimaps;\n@@ -86,14 +88,16 @@\n import software.amazon.awssdk.services.dynamodb.model.DeleteTableRequest;\n import software.amazon.awssdk.services.dynamodb.model.DescribeTableRequest;\n import software.amazon.awssdk.services.dynamodb.model.DescribeTableResponse;\n-import software.amazon.awssdk.services.dynamodb.model.DynamoDbException;\n import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n import software.amazon.awssdk.services.dynamodb.model.GetItemResponse;\n import software.amazon.awssdk.services.dynamodb.model.KeySchemaElement;\n import software.amazon.awssdk.services.dynamodb.model.KeyType;\n import software.amazon.awssdk.services.dynamodb.model.KeysAndAttributes;\n+import software.amazon.awssdk.services.dynamodb.model.LimitExceededException;\n+import software.amazon.awssdk.services.dynamodb.model.ProvisionedThroughputExceededException;\n import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n import software.amazon.awssdk.services.dynamodb.model.PutRequest;\n+import software.amazon.awssdk.services.dynamodb.model.RequestLimitExceededException;\n import software.amazon.awssdk.services.dynamodb.model.ResourceNotFoundException;\n import software.amazon.awssdk.services.dynamodb.model.ReturnValue;\n import software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType;\n@@ -135,6 +139,20 @@ public DynamoStore(DynamoStoreConfig config) {\n     }\n   }\n \n+  @Nonnull\n+  @VisibleForTesting\n+  static RuntimeException unhandledException(String operation, RuntimeException e) {\n+    if (e instanceof RequestLimitExceededException) {\n+      return new BackendLimitExceededException(String.format(\"Dynamo request-limit exceeded during %s.\", operation), e);\n+    } else if (e instanceof LimitExceededException) {\n+      return new BackendLimitExceededException(String.format(\"Dynamo limit exceeded during %s.\", operation), e);\n+    } else if (e instanceof ProvisionedThroughputExceededException) {\n+      return new BackendLimitExceededException(String.format(\"Dynamo provisioned throughput exceeded during %s.\", operation), e);\n+    } else {\n+      return e;\n+    }\n+  }\n+\n   @Override\n   public void start() {\n     if (client != null && async != null) {\n@@ -201,59 +219,63 @@ public void close() {\n   @Override\n   public void load(LoadStep loadstep) throws NotFoundException {\n \n-    while (true) { // for each load step in the chain.\n-      List<ListMultimap<String, LoadOp<?>>> stepPages = paginateLoads(loadstep, paginationSize);\n-\n-      for (ListMultimap<String, LoadOp<?>> l : stepPages) {\n-        Map<String, KeysAndAttributes> loads = l.keySet().stream().collect(Collectors.toMap(Function.identity(), table -> {\n-          List<LoadOp<?>> loadList = l.get(table);\n-          List<Map<String, AttributeValue>> keys = loadList.stream()\n-              .map(load -> Collections.singletonMap(DynamoBaseValue.ID, idValue(load.getId())))\n-              .collect(Collectors.toList());\n-          return KeysAndAttributes.builder().keys(keys).consistentRead(true).build();\n-        }));\n-\n-        BatchGetItemResponse response = client.batchGetItem(BatchGetItemRequest.builder().requestItems(loads).build());\n-        Map<String, List<Map<String, AttributeValue>>> responses = response.responses();\n-        Sets.SetView<String> missingElements = Sets.difference(loads.keySet(), responses.keySet());\n-        Preconditions.checkArgument(missingElements.isEmpty(), \"Did not receive any objects for table(s) %s.\", missingElements);\n-\n-        for (String table : responses.keySet()) {\n-          List<LoadOp<?>> loadList = l.get(table);\n-          List<Map<String, AttributeValue>> values = responses.get(table);\n-          int missingResponses = loadList.size() - values.size();\n-          if (missingResponses != 0) {\n-            ValueType<?> loadType = loadList.get(0).getValueType();\n-            if (loadType == ValueType.REF || loadType == ValueType.L1) {\n-              throw new NotFoundException(\"Unable to find requested ref.\");\n+    try {\n+      while (true) { // for each load step in the chain.\n+        List<ListMultimap<String, LoadOp<?>>> stepPages = paginateLoads(loadstep, paginationSize);\n+\n+        for (ListMultimap<String, LoadOp<?>> l : stepPages) {\n+          Map<String, KeysAndAttributes> loads = l.keySet().stream().collect(Collectors.toMap(Function.identity(), table -> {\n+            List<LoadOp<?>> loadList = l.get(table);\n+            List<Map<String, AttributeValue>> keys = loadList.stream()\n+                .map(load -> Collections.singletonMap(DynamoBaseValue.ID, idValue(load.getId())))\n+                .collect(Collectors.toList());\n+            return KeysAndAttributes.builder().keys(keys).consistentRead(true).build();\n+          }));\n+\n+          BatchGetItemResponse response = client.batchGetItem(BatchGetItemRequest.builder().requestItems(loads).build());\n+          Map<String, List<Map<String, AttributeValue>>> responses = response.responses();\n+          Sets.SetView<String> missingElements = Sets.difference(loads.keySet(), responses.keySet());\n+          Preconditions.checkArgument(missingElements.isEmpty(), \"Did not receive any objects for table(s) %s.\", missingElements);\n+\n+          for (String table : responses.keySet()) {\n+            List<LoadOp<?>> loadList = l.get(table);\n+            List<Map<String, AttributeValue>> values = responses.get(table);\n+            int missingResponses = loadList.size() - values.size();\n+            if (missingResponses != 0) {\n+              ValueType<?> loadType = loadList.get(0).getValueType();\n+              if (loadType == ValueType.REF || loadType == ValueType.L1) {\n+                throw new NotFoundException(\"Unable to find requested ref.\");\n+              }\n+\n+              throw new NotFoundException(\n+                  String.format(\"[%d] object(s) missing in table read [%s]. \\n\\nObjects expected: %s\\n\\nObjects Received: %s\",\n+                  missingResponses, table, loadList, responses));\n             }\n \n-            throw new NotFoundException(\n-                String.format(\"[%d] object(s) missing in table read [%s]. \\n\\nObjects expected: %s\\n\\nObjects Received: %s\",\n-                missingResponses, table, loadList, responses));\n-          }\n-\n-          // unfortunately, responses don't come in the order of the requests so we need to map between ids.\n-          Map<Id, LoadOp<?>> opMap = loadList.stream().collect(Collectors.toMap(LoadOp::getId, Function.identity()));\n-          for (Map<String, AttributeValue> item : values) {\n-            @SuppressWarnings(\"rawtypes\") ValueType valueType = ValueType.byValueName(attributeValue(item, ValueType.SCHEMA_TYPE).s());\n-            Id id = deserializeId(item, ID);\n-            LoadOp<?> loadOp = opMap.get(id);\n-            if (loadOp == null) {\n-              throw new IllegalStateException(\"No load-op for loaded ID \" + id);\n+            // unfortunately, responses don't come in the order of the requests so we need to map between ids.\n+            Map<Id, LoadOp<?>> opMap = loadList.stream().collect(Collectors.toMap(LoadOp::getId, Function.identity()));\n+            for (Map<String, AttributeValue> item : values) {\n+              @SuppressWarnings(\"rawtypes\") ValueType valueType = ValueType.byValueName(attributeValue(item, ValueType.SCHEMA_TYPE).s());\n+              Id id = deserializeId(item, ID);\n+              LoadOp<?> loadOp = opMap.get(id);\n+              if (loadOp == null) {\n+                throw new IllegalStateException(\"No load-op for loaded ID \" + id);\n+              }\n+\n+              deserializeToConsumer(valueType, item, loadOp.getReceiver());\n+              loadOp.done();\n             }\n-\n-            deserializeToConsumer(valueType, item, loadOp.getReceiver());\n-            loadOp.done();\n           }\n         }\n-      }\n-      Optional<LoadStep> next = loadstep.getNext();\n+        Optional<LoadStep> next = loadstep.getNext();\n \n-      if (!next.isPresent()) {\n-        break;\n+        if (!next.isPresent()) {\n+          break;\n+        }\n+        loadstep = next.get();\n       }\n-      loadstep = next.get();\n+    } catch (RuntimeException e) {\n+      throw unhandledException(\"load\", e);\n     }\n   }\n \n@@ -291,6 +313,8 @@ public void deleteTables() {\n         client.deleteTable(DeleteTableRequest.builder().tableName(table).build());\n       } catch (ResourceNotFoundException ex) {\n         // ignore.\n+      } catch (RuntimeException e) {\n+        throw unhandledException(\"deleteTables\", e);\n       }\n     });\n \n@@ -313,8 +337,8 @@ public void deleteTables() {\n       client.putItem(builder.build());\n     } catch (ConditionalCheckFailedException ex) {\n       throw new ConditionFailedException(\"Condition failed during put operation.\", ex);\n-    } catch (DynamoDbException ex) {\n-      throw new StoreOperationException(\"Failure during put.\", ex);\n+    } catch (RuntimeException e) {\n+      throw unhandledException(\"put\", e);\n     }\n   }\n \n@@ -335,8 +359,8 @@ public void deleteTables() {\n     } catch (ConditionalCheckFailedException ex) {\n       LOGGER.debug(\"Failure during conditional check.\", ex);\n       return false;\n-    } catch (DynamoDbException ex) {\n-      throw new StoreOperationException(\"Failure during delete.\", ex);\n+    } catch (RuntimeException e) {\n+      throw unhandledException(\"delete\", e);\n     }\n   }\n \n@@ -433,26 +457,30 @@ public void save(List<SaveOp<?>> ops) {\n     } catch (InterruptedException e) {\n       throw new RuntimeException(e);\n     } catch (ExecutionException e) {\n-      if (e.getCause() instanceof DynamoDbException) {\n-        throw new StoreOperationException(\"Dynamo failure during save.\", e.getCause());\n+      Throwable cause = e.getCause();\n+      if (cause instanceof RuntimeException) {\n+        throw unhandledException(\"save\", (RuntimeException) cause);\n       } else {\n-        Throwables.throwIfUnchecked(e.getCause());\n-        throw new RuntimeException(e.getCause());\n+        throw unhandledException(\"save\", new RuntimeException(cause));\n       }\n     }\n   }\n \n   @Override\n   public <C extends BaseValue<C>> void loadSingle(ValueType<C> valueType, Id id, C consumer) {\n-    GetItemResponse response = client.getItem(GetItemRequest.builder()\n-        .tableName(tableNames.get(valueType))\n-        .key(Collections.singletonMap(DynamoBaseValue.ID, idValue(id)))\n-        .consistentRead(true)\n-        .build());\n-    if (!response.hasItem()) {\n-      throw new NotFoundException(String.format(\"Unable to load item %s:%s.\", valueType, id));\n+    try {\n+      GetItemResponse response = client.getItem(GetItemRequest.builder()\n+          .tableName(tableNames.get(valueType))\n+          .key(Collections.singletonMap(DynamoBaseValue.ID, idValue(id)))\n+          .consistentRead(true)\n+          .build());\n+      if (!response.hasItem()) {\n+        throw new NotFoundException(String.format(\"Unable to load item %s:%s.\", valueType, id));\n+      }\n+      deserializeToConsumer(valueType, response.item(), consumer);\n+    } catch (RuntimeException e) {\n+      throw unhandledException(\"loadSingle\", e);\n     }\n-    deserializeToConsumer(valueType, response.item(), consumer);\n   }\n \n   @Override\n@@ -477,27 +505,34 @@ public void save(List<SaveOp<?>> ops) {\n     } catch (ConditionalCheckFailedException checkFailed) {\n       LOGGER.debug(\"Conditional check failed.\", checkFailed);\n       return false;\n+    } catch (RuntimeException e) {\n+      throw unhandledException(\"update\", e);\n     }\n   }\n \n   private boolean tableExists(String name) {\n     try {\n-\n-      DescribeTableResponse refTable = client.describeTable(DescribeTableRequest.builder().tableName(name).build());\n-      verifyKeySchema(refTable.table());\n+      DescribeTableResponse table = client.describeTable(DescribeTableRequest.builder().tableName(name).build());\n+      verifyKeySchema(table.table());\n       return true;\n     } catch (ResourceNotFoundException e) {\n-      LOGGER.debug(\"Didn't find ref table, going to create one.\", e);\n+      LOGGER.debug(\"Didn't find table '{}', going to create one.\", name, e);\n       return false;\n+    } catch (RuntimeException e) {\n+      throw unhandledException(\"tableExists\", e);\n     }\n   }\n \n   @Override\n   public <C extends BaseValue<C>> Stream<Acceptor<C>> getValues(ValueType<C> type) {\n-    return client.scanPaginator(ScanRequest.builder().tableName(tableNames.get(type)).build())\n-        .stream()\n-        .flatMap(r -> r.items().stream())\n-        .map(i -> consumer -> deserializeToConsumer(type, i, consumer));\n+    try {\n+      return client.scanPaginator(ScanRequest.builder().tableName(tableNames.get(type)).build())\n+          .stream()\n+          .flatMap(r -> r.items().stream())\n+          .map(i -> consumer -> deserializeToConsumer(type, i, consumer));\n+    } catch (RuntimeException e) {\n+      throw unhandledException(\"getValues\", e);\n+    }\n   }\n \n   private void createIfMissing(String name) {"
  },
  {
    "sha": "6d0ab1292da0f7f0fdbc8f4d22b99d313e700261",
    "filename": "versioned/tiered/dynamodb/src/test/java/org/projectnessie/versioned/dynamodb/TestExceptionHandling.java",
    "status": "added",
    "additions": 74,
    "deletions": 0,
    "changes": 74,
    "blob_url": "https://github.com/projectnessie/nessie/blob/d6ab6b438b9d422a5d0762f0f7c983753a72817e/versioned/tiered/dynamodb/src/test/java/org/projectnessie/versioned/dynamodb/TestExceptionHandling.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/d6ab6b438b9d422a5d0762f0f7c983753a72817e/versioned/tiered/dynamodb/src/test/java/org/projectnessie/versioned/dynamodb/TestExceptionHandling.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/dynamodb/src/test/java/org/projectnessie/versioned/dynamodb/TestExceptionHandling.java?ref=d6ab6b438b9d422a5d0762f0f7c983753a72817e",
    "patch": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright (C) 2020 Dremio\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.projectnessie.versioned.dynamodb;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.projectnessie.versioned.BackendLimitExceededException;\n+import org.projectnessie.versioned.store.ConditionFailedException;\n+import org.projectnessie.versioned.store.NotFoundException;\n+import org.projectnessie.versioned.store.StoreException;\n+import org.projectnessie.versioned.store.StoreOperationException;\n+\n+import software.amazon.awssdk.services.dynamodb.model.LimitExceededException;\n+import software.amazon.awssdk.services.dynamodb.model.ProvisionedThroughputExceededException;\n+import software.amazon.awssdk.services.dynamodb.model.RequestLimitExceededException;\n+\n+public class TestExceptionHandling {\n+  @Test\n+  void testRequestLimitExceededException() {\n+    testException(\"testRequestLimitExceededException\", RequestLimitExceededException.builder().message(\"msg\").build(),\n+        BackendLimitExceededException.class, \"Dynamo request-limit exceeded during testRequestLimitExceededException.\");\n+  }\n+\n+  @Test\n+  void testLimitExceededException() {\n+    testException(\"testLimitExceededException\", LimitExceededException.builder().message(\"msg\").build(),\n+        BackendLimitExceededException.class, \"Dynamo limit exceeded during testLimitExceededException.\");\n+  }\n+\n+  @Test\n+  void testProvisionedThroughputExceededException() {\n+    testException(\"testProvisionedThroughputExceededException\", ProvisionedThroughputExceededException.builder().message(\"msg\").build(),\n+        BackendLimitExceededException.class, \"Dynamo provisioned throughput exceeded during testProvisionedThroughputExceededException.\");\n+  }\n+\n+  @Test\n+  void testStoreException() {\n+    testException(\"testStoreException\", new StoreOperationException(\"msg\"),\n+        StoreOperationException.class, \"msg\");\n+    testException(\"testStoreException\", new ConditionFailedException(\"msg\"),\n+        ConditionFailedException.class, \"msg\");\n+    testException(\"testStoreException\", new NotFoundException(\"msg\"),\n+        NotFoundException.class, \"msg\");\n+    testException(\"testStoreException\", new BackendLimitExceededException(\"msg\"),\n+        BackendLimitExceededException.class, \"msg\");\n+    testException(\"testStoreException\", new StoreException(\"msg\"),\n+        StoreException.class, \"msg\");\n+  }\n+\n+  @Test\n+  void testRuntimeException() {\n+    testException(\"testRuntimeException\", new RuntimeException(\"foo bar\"),\n+        RuntimeException.class, \"foo bar\");\n+  }\n+\n+  private void testException(String operation, RuntimeException e, Class<?> expectedExceptionClass, String expectedMessage) {\n+    RuntimeException result = DynamoStore.unhandledException(operation, e);\n+    Assertions.assertSame(expectedExceptionClass, result.getClass());\n+    Assertions.assertEquals(expectedMessage, result.getMessage());\n+  }\n+}"
  },
  {
    "sha": "74fe18edf2aaacc804d23c4db090ce61c614b37d",
    "filename": "versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/TieredVersionStore.java",
    "status": "modified",
    "additions": 7,
    "deletions": 3,
    "changes": 10,
    "blob_url": "https://github.com/projectnessie/nessie/blob/d6ab6b438b9d422a5d0762f0f7c983753a72817e/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/TieredVersionStore.java",
    "raw_url": "https://github.com/projectnessie/nessie/raw/d6ab6b438b9d422a5d0762f0f7c983753a72817e/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/TieredVersionStore.java",
    "contents_url": "https://api.github.com/repos/projectnessie/nessie/contents/versioned/tiered/tiered-impl/src/main/java/org/projectnessie/versioned/impl/TieredVersionStore.java?ref=d6ab6b438b9d422a5d0762f0f7c983753a72817e",
    "patch": "@@ -24,7 +24,7 @@\n import java.util.Set;\n import java.util.Spliterator;\n import java.util.Spliterators.AbstractSpliterator;\n-import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executor;\n import java.util.concurrent.Executors;\n import java.util.function.Consumer;\n import java.util.stream.Collectors;\n@@ -76,6 +76,7 @@\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Streams;\n+import com.google.common.util.concurrent.MoreExecutors;\n \n /**\n  * A version store that uses a tree of levels to store version information.\n@@ -88,7 +89,7 @@\n \n   private final Serializer<DATA> serializer;\n   private final Serializer<METADATA> metadataSerializer;\n-  private final ExecutorService executor;\n+  private final Executor executor;\n   private final Store store;\n   private final int commitRetryCount = 5;\n   private final int p2commitRetry = 5;\n@@ -105,7 +106,10 @@ public TieredVersionStore(StoreWorker<DATA,METADATA> storeWorker, Store store, b\n     this.serializer = storeWorker.getValueSerializer();\n     this.metadataSerializer = storeWorker.getMetadataSerializer();\n     this.store = store;\n-    this.executor = Executors.newCachedThreadPool();\n+    // We actually do not need an executor at all, when waitOnCollapse==true. Unit tests use\n+    // waitOnCollapse==true. It is not nice to instantiate an executor-service but never shut it\n+    // down, like unit tests did.\n+    this.executor =  waitOnCollapse ? MoreExecutors.directExecutor() : Executors.newCachedThreadPool();\n     this.waitOnCollapse = waitOnCollapse;\n   }\n "
  }
]
