[
  {
    "sha": "ad9e3db5dde28dafaa56b3a375f0e8175d24bf14",
    "filename": "modules/integration/tests-integration/tests-backend/src/test/java/org/wso2/identity/integration/test/oidc/OIDCFederatedIdpInitLogoutTest.java",
    "status": "added",
    "additions": 1053,
    "deletions": 0,
    "changes": 1053,
    "blob_url": "https://github.com/wso2/product-is/blob/3833d01760dc6a9c8e34f31cea471281bf939164/modules/integration/tests-integration/tests-backend/src/test/java/org/wso2/identity/integration/test/oidc/OIDCFederatedIdpInitLogoutTest.java",
    "raw_url": "https://github.com/wso2/product-is/raw/3833d01760dc6a9c8e34f31cea471281bf939164/modules/integration/tests-integration/tests-backend/src/test/java/org/wso2/identity/integration/test/oidc/OIDCFederatedIdpInitLogoutTest.java",
    "contents_url": "https://api.github.com/repos/wso2/product-is/contents/modules/integration/tests-integration/tests-backend/src/test/java/org/wso2/identity/integration/test/oidc/OIDCFederatedIdpInitLogoutTest.java?ref=3833d01760dc6a9c8e34f31cea471281bf939164",
    "patch": "@@ -0,0 +1,1053 @@\n+package org.wso2.identity.integration.test.oidc;\n+\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import com.nimbusds.jwt.SignedJWT;\n+import com.nimbusds.oauth2.sdk.AuthorizationCode;\n+import com.nimbusds.oauth2.sdk.AuthorizationCodeGrant;\n+import com.nimbusds.oauth2.sdk.TokenErrorResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.http.HTTPResponse;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.openid.connect.sdk.OIDCTokenResponse;\n+import com.nimbusds.openid.connect.sdk.OIDCTokenResponseParser;\n+import com.nimbusds.openid.connect.sdk.token.OIDCTokens;\n+import net.minidev.json.JSONObject;\n+import net.minidev.json.parser.JSONParser;\n+import org.apache.axis2.context.ConfigurationContext;\n+import org.apache.axis2.context.ConfigurationContextFactory;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.Header;\n+import org.apache.http.HttpHeaders;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.CookieStore;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.entity.UrlEncodedFormEntity;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.BasicCookieStore;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.message.BasicNameValuePair;\n+import org.apache.http.util.EntityUtils;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import org.wso2.carbon.automation.engine.context.AutomationContext;\n+import org.wso2.carbon.automation.engine.context.TestUserMode;\n+import org.wso2.carbon.identity.application.common.model.idp.xsd.IdentityProviderProperty;\n+import org.wso2.carbon.identity.application.common.model.idp.xsd.FederatedAuthenticatorConfig;\n+import org.wso2.carbon.identity.application.common.model.idp.xsd.IdentityProvider;\n+import org.wso2.carbon.identity.application.common.model.idp.xsd.JustInTimeProvisioningConfig;\n+import org.wso2.carbon.identity.application.common.model.idp.xsd.Property;\n+import org.wso2.carbon.identity.application.common.model.xsd.AuthenticationStep;\n+import org.wso2.carbon.identity.application.common.model.xsd.InboundAuthenticationRequestConfig;\n+import org.wso2.carbon.identity.application.common.model.xsd.ServiceProvider;\n+import org.wso2.carbon.identity.oauth.stub.dto.OAuthConsumerAppDTO;\n+import org.wso2.carbon.integration.common.admin.client.AuthenticatorClient;\n+import org.wso2.carbon.integration.common.utils.mgt.ServerConfigurationManager;\n+import org.wso2.identity.integration.common.clients.Idp.IdentityProviderMgtServiceClient;\n+import org.wso2.identity.integration.common.clients.TenantManagementServiceClient;\n+import org.wso2.identity.integration.common.clients.UserManagementClient;\n+import org.wso2.identity.integration.common.clients.application.mgt.ApplicationManagementServiceClient;\n+import org.wso2.identity.integration.common.clients.oauth.OauthAdminClient;\n+import org.wso2.identity.integration.common.utils.ISIntegrationTest;\n+import org.wso2.identity.integration.test.util.Utils;\n+import org.wso2.identity.integration.test.utils.DataExtractUtil;\n+import org.wso2.identity.integration.test.utils.IdentityConstants;\n+import org.wso2.identity.integration.test.utils.OAuth2Constant;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.rmi.RemoteException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.xpath.XPathExpressionException;\n+\n+public class OIDCFederatedIdpInitLogoutTest extends ISIntegrationTest {\n+\n+    protected Log log = LogFactory.getLog(OIDCFederatedIdpInitLogoutTest.class);\n+\n+    private static final String USER_AGENT = \"Apache-HttpClient/4.2.5 (java 1.5)\";\n+    // Tenant names and indexes.\n+    private static final String PRIMARY_TENANT_NAME = \"primary.com\";\n+    private static final String FEDERATED_TENANT_NAME = \"federated.com\";\n+    private static final int PRIMARY_TENANT = 0;\n+    private static final int FEDERATED_TENANT = 1;\n+    // Name of the primary Is configured in federated Is as a service provider.\n+    private static final String FEDERATED_IS_PRIMARY_SP_NAME = \"PrimaryIS\";\n+    // Primary idp related urls.\n+    private static final String PRIMARY_IS_AUTHORIZE_ENDPOINT = \"https://localhost:9853/t/primary\" +\n+            \".com/oauth2/authorize\";\n+    private static final String PRIMARY_IS_TOKEN_ENDPOINT = \"https://localhost:9853/t/primary.com/oauth2/token\";\n+    private static final String PRIMARY_IS_CALLBACK_URL = \"https://localhost:9853/t/primary.com/commonauth\";\n+    //TODO: Enable endpoint in framework.\n+    private static final String PRIMARY_IS_BACK_CHANNEL_LOGOUT_ENDPOINT = \"https://localhost:9853/t/primary\" +\n+            \".com/identity/oidc/slo\";\n+    private static final String PRIMARY_IS_SESSIONS_EXTENSION_ENDPOINT =\n+            \"https://localhost:9853/t/primary.com/identity/extend-session\";\n+    // Federated idp related urls.\n+    private static final String FEDERATED_IS_NAME = \"FederatedIS\";\n+    private static final String FEDERATED_IS_AUTHENTICATOR_NAME_OIDC = \"OpenIDConnectAuthenticator\";\n+    private static final String FEDERATED_IS_AUTHORIZE_ENDPOINT = \"https://localhost:9853/t/federated\" +\n+            \".com/oauth2/authorize\";\n+    private static final String FEDERATED_IS_CALLBACK_URL = \"https://localhost:9853/t/federated.com/commonauth\";\n+    private static final String FEDERATED_IS_TOKEN_ENDPOINT = \"https://localhost:9853/t/federated.com/oauth2/token\";\n+    private static final String FEDERATED_IS_LOGOUT_ENDPOINT = \"https://localhost:9853/t/federated.com/oidc/logout\";\n+    private static final String FEDERATED_IS_SERVICES_URI = \"https://localhost:9853/t/federated.com/services/\";\n+    private static final String FEDERATED_IS_JWKS_URI = \"https://localhost:9853/t/federated.com/oauth2/jwks\";\n+    private static final String FEDERATED_ME_SESSIONS_ENDPOINT =\n+            \"https://localhost:9853/t/federated.com/api/users/v1/me/sessions\";\n+    private static final String FEDERATED_IS_SESSIONS_EXTENSION_ENDPOINT =\n+            \"https://localhost:9853/t/federated.com/identity/extend-session\";\n+\n+    // Urls related to service provider configured in Primary IS.\n+    private static final String PRIMARY_IS_SP_NAME = \"application1\";\n+    private static final String PRIMARY_IS_SP_AUTHENTICATION_TYPE = \"federated\";\n+    private static final String PRIMARY_IS_SP_CALLBACK_URL = \"http://localhost/\";\n+    private static final String PRIMARY_IS_SP_BACK_CHANNEL_LOGOUT_URL = \"http://localhost/\";\n+\n+    // Urls related to service provider configured in Federated IS.\n+    private static final String FEDERATED_IS_SP_NAME = \"application2\";\n+    private static final String FEDERATED_IS_SP_CALLBACK_URL = \"http://localhost/\";\n+    private static final String FEDERATED_IS_SP_BACK_CHANNEL_LOGOUT_URL = \"http://localhost/\";\n+\n+    private static final String OIDC_APP_CLIENT_ID = \"ClientID\";\n+    private static final String OIDC_APP_CLIENT_SECRET = \"ClientSecret\";\n+\n+    // Username and password of the user in federated IS.\n+    private static final String FEDERATED_IS_TEST_USERNAME = \"testFederatedUser\";\n+    private static final String FEDERATED_IS_TEST_PASSWORD = \"testFederatePassword\";\n+    private static final String FEDERATED_IS_TEST_USER_ROLES = \"admin\";\n+\n+    private static final int SUCCESS_STATUS_CODE = 200;\n+    private static final int FAILURE_STATUS_CODE = 400;\n+\n+    private static final String ISK_CLAIM = \"isk\";\n+\n+    private Map<Integer, ApplicationManagementServiceClient> applicationManagementServiceClients;\n+    private Map<Integer, OauthAdminClient> oAuthAdminClients;\n+    private IdentityProviderMgtServiceClient identityProviderMgtServiceClient;\n+    private TenantManagementServiceClient tenantServiceClient;\n+    private UserManagementClient usrMgtClient;\n+    private ServerConfigurationManager serverConfigurationManager;\n+    private final AutomationContext context;\n+    // Usernames of the tenants.\n+    private String PrimaryTenantUsername = \"primaryAdmin@primary.com\";\n+    private String FederatedTenantUsername = \"federatedAdmin@federated.com\";\n+    // Client Id and Secret of primary Is service provider configured in federated idp.\n+    private String fedISClientID;\n+    private String fedISClientSecret;\n+    // Client Id and Secret of service provider configured in primary Is.\n+    private String primSPClientID;\n+    private String primSPClientSecret;\n+    // Client Id and Secret of service provider configured in federated Is.\n+    private String fedSP_ClientID;\n+    private String fedSP_ClientSecret;\n+    // Data related to the login flow.\n+    private String primaryIdToken;\n+    private String federatedIdToken;\n+    private String username;\n+    private String primaryIsk;\n+    private String federatedIsk;\n+    private String federatedSpSessionState;\n+    private CookieStore cookieStore;\n+    private CloseableHttpClient client;\n+    private HttpClient httpClientWithoutAutoRedirections;\n+    private JSONParser jsonParser;\n+\n+    @DataProvider(name = \"configProvider\")\n+    public static Object[][] configProvider() {\n+\n+        return new Object[][]{{TestUserMode.SUPER_TENANT_ADMIN}};\n+    }\n+\n+    @Factory(dataProvider = \"configProvider\")\n+    public OIDCFederatedIdpInitLogoutTest(TestUserMode userMode) throws Exception {\n+\n+        context = new AutomationContext(\"IDENTITY\", userMode);\n+    }\n+\n+    @BeforeClass(alwaysRun = true)\n+    public void initTest() throws Exception {\n+\n+        super.init();\n+        changeISConfiguration();\n+        super.init();\n+        applicationManagementServiceClients = new HashMap<>();\n+        oAuthAdminClients = new HashMap<>();\n+        serverConfigurationManager = new ServerConfigurationManager(isServer);\n+        tenantServiceClient = new TenantManagementServiceClient(isServer.getContextUrls().getBackEndUrl(),\n+                sessionCookie);\n+        createTenants();\n+        backendURL = context.getContextUrls().getBackEndUrl();\n+        AuthenticatorClient logManger = new AuthenticatorClient(backendURL);\n+        String primaryTenantCookie = logManger\n+                .login(PrimaryTenantUsername, \"password\", isServer.getInstance().getHosts().get(\"default\"));\n+        String federatedTenantCookie = logManger\n+                .login(FederatedTenantUsername, \"password\", isServer.getInstance().getHosts().get(\"default\"));\n+        createServiceClients(primaryTenantCookie, federatedTenantCookie);\n+        createPrimaryServiceProviderInSecondaryTenant();\n+        createIdentityProviderInPrimaryTenant();\n+        createServiceProviderInPrimaryIdp();\n+        createServiceProviderInSecondaryIdp();\n+        cookieStore = new BasicCookieStore();\n+        client = HttpClientBuilder.create().setDefaultCookieStore(cookieStore).build();\n+        httpClientWithoutAutoRedirections = HttpClientBuilder.create().disableRedirectHandling()\n+                .setDefaultCookieStore(cookieStore).build();\n+        Assert.assertTrue(addUserToSecondaryIS(), \"Adding user to federated idp failed.\");\n+        jsonParser = new JSONParser(JSONParser.MODE_JSON_SIMPLE);\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void endTest() throws Exception {\n+\n+        try {\n+            removeServiceProviders();\n+            tenantServiceClient.deleteTenant(PRIMARY_TENANT_NAME);\n+            tenantServiceClient.deleteTenant(FEDERATED_TENANT_NAME);\n+            client.close();\n+            resetISConfiguration();\n+        } catch (Exception e) {\n+            log.error(\"Failed to end test due to :\" + e.getMessage(), e);\n+            throw e;\n+        }\n+    }\n+\n+    @Test(alwaysRun = true, groups = \"wso2.is\", description = \"Testing federated idp login.\")\n+    private void testFederatedLogin() throws Exception {\n+\n+        // Make the authorize call to federated idp.\n+        String authCall = authorizeCallToIdp(client, FEDERATED_IS_SP_CALLBACK_URL, fedSP_ClientID,\n+                FEDERATED_IS_AUTHORIZE_ENDPOINT);\n+        Assert.assertTrue(authCall.contains(OAuth2Constant.SESSION_DATA_KEY),\n+                \"sessionDataKey not found in response.\");\n+        String sessionDataKey = DataExtractUtil.getParamFromURIString(authCall, OAuth2Constant.SESSION_DATA_KEY);\n+        Assert.assertNotNull(sessionDataKey, \"Session data key is null.\");\n+        // Get session data key consent from federated idp.\n+        String sessionDataKeyConsent = getSessionDataKeyConsent(client, sessionDataKey);\n+        Assert.assertNotNull(sessionDataKeyConsent, \"Invalid session key consent.\");\n+        // Get authorization code from federated idp.\n+        AuthorizationCode authorizationCode =\n+                getAuthCodeFromIdp(sessionDataKeyConsent, FEDERATED_IS_AUTHORIZE_ENDPOINT);\n+        Assert.assertNotNull(authorizationCode, \"Authorization code is null.\");\n+        // Get the id token from the federated idp.\n+        OIDCTokens tokens = getIdTokenFromIdp(authorizationCode, fedSP_ClientID, fedSP_ClientSecret,\n+                FEDERATED_IS_SP_CALLBACK_URL, FEDERATED_IS_TOKEN_ENDPOINT);\n+        federatedIdToken = tokens.getIDTokenString();\n+        String federatedAccessToken = tokens.getAccessToken().getValue();\n+        Assert.assertNotNull(federatedIdToken, \"ID token is null\");\n+        // Extract the claims from id token.\n+        SignedJWT signedJWT = SignedJWT.parse(federatedIdToken);\n+        JWTClaimsSet jwtClaimsSet = signedJWT.getJWTClaimsSet();\n+        username = jwtClaimsSet.getSubject();\n+        federatedIsk = (String) jwtClaimsSet.getClaim(ISK_CLAIM);\n+        HttpResponse response = sendGetRequest(client, FEDERATED_ME_SESSIONS_ENDPOINT, federatedAccessToken);\n+        JSONObject jsonObject = (JSONObject) jsonParser.parse(response.getEntity().getContent());\n+        Assert.assertNotNull(jsonObject.get(\"sessions\"), \"No sessions found in the federated idp for the user.\");\n+    }\n+\n+    @Test(alwaysRun = true, groups = \"wso2.is\", description = \"Testing primary idp login.\", dependsOnMethods = \"testFederatedLogin\")\n+    private void testPrimaryLogin() throws Exception {\n+\n+        // Make the authorize call to primary idp.\n+        String authorizeCall = authorizeCallToIdp(httpClientWithoutAutoRedirections,\n+                PRIMARY_IS_SP_CALLBACK_URL, primSPClientID, PRIMARY_IS_AUTHORIZE_ENDPOINT);\n+        Assert.assertNotNull(authorizeCall, \"Location value is null.\");\n+        String state = DataExtractUtil.getParamFromURIString(authorizeCall, \"state\");\n+        // Send authorize call from primary idp to federated idp.\n+        String commonAuthCall = authenticatePrimaryIsFromFed(state);\n+        String authCode = DataExtractUtil.getParamFromURIString(commonAuthCall, OAuth2Constant.AUTHORIZATION_CODE_NAME);\n+        String sessionState = DataExtractUtil.getParamFromURIString(commonAuthCall, \"session_state\");\n+        // Get the session data key consent from primary idp.\n+        String sessionDataKeyConsent = getSessionDataKeyConsentFromPrimaryIs(authCode, state, sessionState);\n+        // Get authorization code from idp.\n+        AuthorizationCode authorizationCode =\n+                getAuthCodeFromIdp(sessionDataKeyConsent, PRIMARY_IS_AUTHORIZE_ENDPOINT);\n+        // Get the id token from the primary is.\n+        OIDCTokens tokens = getIdTokenFromIdp(authorizationCode, primSPClientID, primSPClientSecret,\n+                PRIMARY_IS_SP_CALLBACK_URL, PRIMARY_IS_TOKEN_ENDPOINT);\n+        primaryIdToken = tokens.getIDTokenString();\n+        String primaryAccessToken = tokens.getAccessToken().getValue();\n+        Assert.assertNotNull(primaryIdToken, \"Primary sp Id token is null.\");\n+        // Extract claims from id token.\n+        SignedJWT signedJWT = SignedJWT.parse(primaryIdToken);\n+        JWTClaimsSet jwtClaimsSet = signedJWT.getJWTClaimsSet();\n+        primaryIsk = (String) jwtClaimsSet.getClaim(ISK_CLAIM);\n+        // Get the userId of the user.\n+        List<NameValuePair> sessionExtensionParams = new ArrayList<>();\n+        sessionExtensionParams.add(new BasicNameValuePair(\"idpSessionKey\", primaryIsk));\n+        HttpResponse response = sendGetRequestWithParameters(client,\n+                sessionExtensionParams, PRIMARY_IS_SESSIONS_EXTENSION_ENDPOINT);\n+        Assert.assertEquals(response.getStatusLine().getStatusCode(), SUCCESS_STATUS_CODE, \"Session doesn't exists \" +\n+                \"for the federated user in the primary idp.\");\n+    }\n+\n+    @Test(alwaysRun = true, groups = \"wso2.is\", description = \"Testing federated idp init logout.\", dependsOnMethods =\n+            \"testPrimaryLogin\")\n+    private void testFederatedIdpInitLogout() throws Exception {\n+\n+        // Do logout in federated idp.\n+        List<NameValuePair> urlParameters = new ArrayList<>();\n+        urlParameters.add(new BasicNameValuePair(\"post_logout_redirect_uri\", FEDERATED_IS_SP_CALLBACK_URL));\n+        urlParameters.add(new BasicNameValuePair(\"id_token_hint\", federatedIdToken));\n+        urlParameters.add(new BasicNameValuePair(\"session_state\", federatedSpSessionState));\n+        HttpResponse response;\n+        sendGetRequestWithParameters(httpClientWithoutAutoRedirections, urlParameters,\n+                FEDERATED_IS_LOGOUT_ENDPOINT);\n+        List<NameValuePair> logoutUrlParameters = new ArrayList<>();\n+        logoutUrlParameters.add(new BasicNameValuePair(\"consent\", \"approve\"));\n+        sendGetRequestWithParameters(httpClientWithoutAutoRedirections, logoutUrlParameters,\n+                FEDERATED_IS_LOGOUT_ENDPOINT);\n+        // Check for session existence in federated idp.\n+        List<NameValuePair> sessionExtensionParams = new ArrayList<>();\n+        sessionExtensionParams.add(new BasicNameValuePair(\"idpSessionKey\", federatedIsk));\n+        response = sendGetRequestWithParameters(client,\n+                sessionExtensionParams, FEDERATED_IS_SESSIONS_EXTENSION_ENDPOINT);\n+        Assert.assertEquals(response.getStatusLine().getStatusCode(), FAILURE_STATUS_CODE,\n+                \"Logout failure in federated idp.\");\n+        // Wait until back-channel logout is completed in primary idp.\n+        Thread.sleep(5 * 1000);\n+        // Check for session existence in primary idp.\n+        sessionExtensionParams = new ArrayList<>();\n+        sessionExtensionParams.add(new BasicNameValuePair(\"idpSessionKey\", primaryIsk));\n+        response = sendGetRequestWithParameters(client,\n+                sessionExtensionParams, PRIMARY_IS_SESSIONS_EXTENSION_ENDPOINT);\n+        Assert.assertEquals(response.getStatusLine().getStatusCode(), FAILURE_STATUS_CODE, \"OIDC federated idp \" +\n+                \"initiated back-channel logout failed for the federated user in primary idp.\");\n+    }\n+\n+    /**\n+     * First authorization call to the idp.\n+     *\n+     * @param client            - http client.\n+     * @param callbackUrl       - callback url of the service provider.\n+     * @param spClientId        - client id of the service provider.\n+     * @param authorizeEndpoint - authorization endpoint of the idp.\n+     * @return - location header value in the response.\n+     * @throws Exception - Exception.\n+     */\n+    public String authorizeCallToIdp(HttpClient client, String callbackUrl, String spClientId,\n+                                     String authorizeEndpoint)\n+            throws Exception {\n+\n+        List<NameValuePair> urlParameters = new ArrayList<>();\n+        urlParameters.add(new BasicNameValuePair(\"scope\", OAuth2Constant.OAUTH2_SCOPE_OPENID_WITH_INTERNAL_LOGIN));\n+        urlParameters.add(new BasicNameValuePair(\"response_type\", OAuth2Constant.OAUTH2_GRANT_TYPE_CODE));\n+        urlParameters.add(new BasicNameValuePair(\"redirect_uri\", callbackUrl));\n+        urlParameters.add(new BasicNameValuePair(\"client_id\", spClientId));\n+        HttpResponse response = sendPostRequestWithParameters(client, urlParameters, authorizeEndpoint);\n+        Assert.assertNotNull(response, \"Authorization request failed. Authorized response is null\");\n+        String locationValue = getLocationHeaderValue(response);\n+        EntityUtils.consume(response.getEntity());\n+        return locationValue;\n+    }\n+\n+    /**\n+     * Send authentication request to federated idp from primary is.\n+     *\n+     * @param state - state received during the authorization call.\n+     * @return - location value of the response containing authCode and sessionState.\n+     * @throws Exception - Exception.\n+     */\n+    public String authenticatePrimaryIsFromFed(String state)\n+            throws Exception {\n+\n+        List<NameValuePair> urlParameters = new ArrayList<>();\n+        urlParameters.add(new BasicNameValuePair(\"scope\", OAuth2Constant.OAUTH2_SCOPE_OPENID));\n+        urlParameters.add(new BasicNameValuePair(\"response_type\", OAuth2Constant.OAUTH2_GRANT_TYPE_CODE));\n+        urlParameters.add(new BasicNameValuePair(\"redirect_uri\", PRIMARY_IS_CALLBACK_URL));\n+        urlParameters.add(new BasicNameValuePair(\"client_id\", fedISClientID));\n+        urlParameters.add(new BasicNameValuePair(\"state\", state));\n+        HttpResponse response =\n+                sendPostRequestWithParameters(client, urlParameters,\n+                        FEDERATED_IS_AUTHORIZE_ENDPOINT);\n+        Assert.assertNotNull(response, \"Authorization request failed. Authorized response is null.\");\n+        String locationValue = getLocationHeaderValue(response);\n+        EntityUtils.consume(response.getEntity());\n+        return locationValue;\n+    }\n+\n+    /**\n+     * Sends a log in post to the IS instance and extract and return the sessionDataKeyConsent from the response.\n+     *\n+     * @param client         - CloseableHttpClient object to send the login post.\n+     * @param sessionDataKey - String sessionDataKey obtained.\n+     * @return - Extracted sessionDataKeyConsent.\n+     * @throws IOException        - IOException.\n+     * @throws URISyntaxException - URISyntaxException.\n+     */\n+    private String getSessionDataKeyConsent(CloseableHttpClient client, String sessionDataKey)\n+            throws IOException, URISyntaxException {\n+\n+        HttpResponse response = sendLoginPost(client, sessionDataKey);\n+        Assert.assertNotNull(response, \"Login request failed. response is null.\");\n+\n+        Header locationHeader =\n+                response.getFirstHeader(OAuth2Constant.HTTP_RESPONSE_HEADER_LOCATION);\n+        Assert.assertNotNull(locationHeader, \"Login response header is null.\");\n+        EntityUtils.consume(response.getEntity());\n+\n+        // Request will return with a 302 to the authorize end point. Doing a GET will give the sessionDataKeyConsent.\n+        HttpResponse response2 = sendGetRequest(httpClientWithoutAutoRedirections, locationHeader.getValue());\n+\n+        String locationValue = getLocationHeaderValue(response2);\n+        Assert.assertTrue(locationValue.contains(OAuth2Constant.SESSION_DATA_KEY_CONSENT),\n+                \"sessionDataKeyConsent not found in response.\");\n+        EntityUtils.consume(response2.getEntity());\n+        // Extract sessionDataKeyConsent from the location value.\n+        return DataExtractUtil.getParamFromURIString(locationValue, OAuth2Constant.SESSION_DATA_KEY_CONSENT);\n+    }\n+\n+    /**\n+     * Get the authorization code from the idp.\n+     *\n+     * @param sessionDataKeyConsent - sessionDataKeyConsent received after consent approval.\n+     * @param authorizeEndpoint     - authorization endpoint of the idp.\n+     * @return - AuthorizationCode object containing authCode.\n+     * @throws Exception - Exception.\n+     */\n+    public AuthorizationCode getAuthCodeFromIdp(String sessionDataKeyConsent, String authorizeEndpoint)\n+            throws Exception {\n+\n+        HttpResponse response = sendApprovalPost(client, sessionDataKeyConsent, authorizeEndpoint);\n+        Assert.assertNotNull(response, \"Approval request failed. response is invalid.\");\n+\n+        Header locationHeader =\n+                response.getFirstHeader(OAuth2Constant.HTTP_RESPONSE_HEADER_LOCATION);\n+        Assert.assertNotNull(locationHeader, \"Approval request failed. Location header is null.\");\n+\n+        String locationValue = getLocationHeaderValue(response);\n+        Assert.assertTrue(locationValue.contains(OAuth2Constant.AUTHORIZATION_CODE_NAME),\n+                \"Authorization code not found in the response.\");\n+        EntityUtils.consume(response.getEntity());\n+        federatedSpSessionState = DataExtractUtil.getParamFromURIString(locationValue,\n+                \"session_state\");\n+\n+        // Extract authorization code from the location value.\n+        return new AuthorizationCode(DataExtractUtil.getParamFromURIString(locationValue,\n+                OAuth2Constant.AUTHORIZATION_CODE_NAME));\n+    }\n+\n+    /**\n+     * Send approval post request.\n+     *\n+     * @param client                - http client.\n+     * @param sessionDataKeyConsent - session consent data.\n+     * @return - http response.\n+     * @throws ClientProtocolException - ClientProtocolException\n+     * @throws IOException             - IOException.\n+     */\n+    public HttpResponse sendApprovalPost(HttpClient client, String sessionDataKeyConsent, String authorizeEndpoint)\n+            throws ClientProtocolException,\n+            IOException {\n+\n+        List<NameValuePair> urlParameters = new ArrayList<>();\n+        urlParameters.add(new BasicNameValuePair(\"consent\", \"approve\"));\n+        urlParameters.add(new BasicNameValuePair(\"sessionDataKeyConsent\", sessionDataKeyConsent));\n+        return sendPostRequestWithParameters(client, urlParameters, authorizeEndpoint);\n+    }\n+\n+    /**\n+     * Get the sessionDataKeyConsent value from the primary idp.\n+     *\n+     * @param authCode     - authorization code received from federated idp.\n+     * @param state        - state received during authorization call.\n+     * @param sessionState - session state received from federated idp.\n+     * @return - sessionDataKeyConsent.\n+     * @throws URISyntaxException - URISyntaxException.\n+     * @throws IOException        - IOException.\n+     */\n+    private String getSessionDataKeyConsentFromPrimaryIs(String authCode, String state, String sessionState)\n+            throws URISyntaxException,\n+            IOException {\n+\n+        List<NameValuePair> urlParameters = new ArrayList<>();\n+        urlParameters.add(new BasicNameValuePair(\"code\", authCode));\n+        urlParameters.add(new BasicNameValuePair(\"state\", state));\n+        urlParameters.add(new BasicNameValuePair(\"session_state\", sessionState));\n+        HttpResponse response =\n+                sendPostRequestWithParameters(client, urlParameters,\n+                        PRIMARY_IS_CALLBACK_URL);\n+        Assert.assertNotNull(response, \"CommonAuth request to primary idp failed. CommonAuth response is null.\");\n+        String locationValue = getLocationHeaderValue(response);\n+        EntityUtils.consume(response.getEntity());\n+        response = sendGetRequest(httpClientWithoutAutoRedirections, locationValue);\n+        Header locationHeader =\n+                response.getFirstHeader(OAuth2Constant.HTTP_RESPONSE_HEADER_LOCATION);\n+        EntityUtils.consume(response.getEntity());\n+        Assert.assertTrue(locationHeader.getValue().contains(OAuth2Constant.SESSION_DATA_KEY_CONSENT),\n+                \"SessionDataKeyConsent not found in response of the primary idp.\");\n+        return DataExtractUtil.getParamFromURIString(locationHeader.getValue(),\n+                OAuth2Constant.SESSION_DATA_KEY_CONSENT);\n+    }\n+\n+    /**\n+     * Get the id token from the idp.\n+     *\n+     * @param authorizationCode - authorizationCode.\n+     * @param clientId          - clientId of the service provider.\n+     * @param clientSec         - clientSecret of the service provider.\n+     * @param spCallbackUrl     - callback url of the service provider.\n+     * @param tokenEndpoint     - token endpoint of the idp.\n+     * @return -  id token string.\n+     * @throws Exception - Exception.\n+     */\n+    public OIDCTokens getIdTokenFromIdp(AuthorizationCode authorizationCode, String clientId, String clientSec,\n+                                        String spCallbackUrl, String tokenEndpoint)\n+            throws Exception {\n+\n+        ClientID clientID = new ClientID(clientId);\n+        Secret clientSecret = new Secret(clientSec);\n+        ClientSecretBasic clientSecretBasic = new ClientSecretBasic(clientID, clientSecret);\n+\n+        URI callbackURI = new URI(spCallbackUrl);\n+        AuthorizationCodeGrant authorizationCodeGrant =\n+                new AuthorizationCodeGrant(authorizationCode, callbackURI);\n+\n+        TokenRequest tokenReq = new TokenRequest(new URI(tokenEndpoint), clientSecretBasic,\n+                authorizationCodeGrant);\n+\n+        HTTPResponse tokenHTTPResp = tokenReq.toHTTPRequest().send();\n+        Assert.assertNotNull(tokenHTTPResp, \"Access token http response is null.\");\n+\n+        TokenResponse tokenResponse = OIDCTokenResponseParser.parse(tokenHTTPResp);\n+        Assert.assertNotNull(tokenResponse, \"Access token response is null.\");\n+\n+        Assert.assertFalse(tokenResponse instanceof TokenErrorResponse,\n+                \"Access token response contains errors.\");\n+\n+        OIDCTokenResponse oidcTokenResponse = (OIDCTokenResponse) tokenResponse;\n+        OIDCTokens oidcTokens = oidcTokenResponse.getOIDCTokens();\n+        Assert.assertNotNull(oidcTokens, \"OIDC Tokens object is null.\");\n+        return oidcTokens;\n+    }\n+\n+    /**\n+     * Creates two tenants, primary.com and federated.com.\n+     *\n+     * @throws Exception - Exception if failed to create tenants.\n+     */\n+    private void createTenants() throws Exception {\n+\n+        tenantServiceClient.addTenant(PRIMARY_TENANT_NAME, \"primaryAdmin\", \"password\",\n+                \"primary@primary.com\", \"Primary\", \"Admin\");\n+        tenantServiceClient.addTenant(FEDERATED_TENANT_NAME, \"federatedAdmin\", \"password\", \"federated\" +\n+                \"@federated.com\", \"Federated\", \"Admin\");\n+        Assert.assertNotNull(tenantServiceClient.getTenant(\"primary.com\").getTenantDomain(),\n+                \"Failed to create Primary tenant.\");\n+        Assert.assertNotNull(tenantServiceClient.getTenant(\"federated.com\").getTenantDomain(),\n+                \"Failed to create federated tenant.\");\n+    }\n+\n+    /**\n+     * Create service clients for the tenants.\n+     *\n+     * @throws XPathExpressionException - Exception if failed.\n+     * @throws RemoteException          - Exception if failed.\n+     */\n+    private void createServiceClients(String primaryTenantCookie, String federatedTenantCookie)\n+            throws XPathExpressionException, RemoteException {\n+\n+        ConfigurationContext configContext = ConfigurationContextFactory.createConfigurationContextFromFileSystem\n+                (null, null);\n+        applicationManagementServiceClients\n+                .put(PRIMARY_TENANT, new ApplicationManagementServiceClient(primaryTenantCookie,\n+                        isServer.getContextUrls().getBackEndUrl(), configContext));\n+        applicationManagementServiceClients\n+                .put(FEDERATED_TENANT, new ApplicationManagementServiceClient(federatedTenantCookie,\n+                        isServer.getContextUrls().getBackEndUrl(), configContext));\n+        identityProviderMgtServiceClient =\n+                new IdentityProviderMgtServiceClient(primaryTenantCookie, isServer.getContextUrls().getBackEndUrl());\n+        oAuthAdminClients.put(PRIMARY_TENANT, new OauthAdminClient(isServer.getContextUrls().getBackEndUrl(),\n+                primaryTenantCookie));\n+        oAuthAdminClients.put(FEDERATED_TENANT, new OauthAdminClient(isServer.getContextUrls().getBackEndUrl(),\n+                federatedTenantCookie));\n+        usrMgtClient =\n+                new UserManagementClient(FEDERATED_IS_SERVICES_URI, \"federatedAdmin\" + \"@federated.com\", \"password\");\n+    }\n+\n+    /**\n+     * Creates a service provider for primary tenant IS in the federated tenant IS.\n+     *\n+     * @throws Exception - Exception if failed.\n+     */\n+    private void createPrimaryServiceProviderInSecondaryTenant()\n+            throws Exception {\n+\n+        addServiceProvider(FEDERATED_TENANT, FEDERATED_IS_PRIMARY_SP_NAME);\n+        ServiceProvider serviceProvider = getServiceProvider(FEDERATED_TENANT, FEDERATED_IS_PRIMARY_SP_NAME);\n+        HashMap<String, String> credentials =\n+                updateServiceProviderWithOIDCConfigs(FEDERATED_TENANT, FEDERATED_IS_PRIMARY_SP_NAME,\n+                        PRIMARY_IS_CALLBACK_URL, PRIMARY_IS_BACK_CHANNEL_LOGOUT_ENDPOINT, serviceProvider);\n+        fedISClientID = credentials.get(OIDC_APP_CLIENT_ID);\n+        fedISClientSecret = credentials.get(OIDC_APP_CLIENT_SECRET);\n+        updateServiceProvider(FEDERATED_TENANT, serviceProvider);\n+        serviceProvider = getServiceProvider(FEDERATED_TENANT, FEDERATED_IS_PRIMARY_SP_NAME);\n+        InboundAuthenticationRequestConfig[] configs = serviceProvider.getInboundAuthenticationConfig().\n+                getInboundAuthenticationRequestConfigs();\n+        boolean success = false;\n+        if (configs != null) {\n+            for (InboundAuthenticationRequestConfig config : configs) {\n+                if (fedISClientID.equals(config.getInboundAuthKey()) && OAuth2Constant.OAUTH_2.equals(\n+                        config.getInboundAuthType())) {\n+                    success = true;\n+                    break;\n+                }\n+            }\n+        }\n+        Assert.assertTrue(success, \"Failed to update PrimaryIS service provider with inbound OIDC configs in \" +\n+                \"secondary IS.\");\n+\n+    }\n+\n+    /**\n+     * Creates a identity provider in primary tenant IS.\n+     *\n+     * @throws Exception - Throw Exception if failed.\n+     */\n+    private void createIdentityProviderInPrimaryTenant() throws Exception {\n+\n+        IdentityProvider identityProvider = new IdentityProvider();\n+        identityProvider.setIdentityProviderName(FEDERATED_IS_NAME);\n+\n+        // Set JWKS Uri to identity provider.\n+        IdentityProviderProperty jwksUriProperty = new IdentityProviderProperty();\n+        jwksUriProperty.setName(\"jwksUri\");\n+        jwksUriProperty.setValue(FEDERATED_IS_JWKS_URI);\n+        IdentityProviderProperty issuerProperty = new IdentityProviderProperty();\n+        issuerProperty.setName(\"idpIssuerName\");\n+        issuerProperty.setValue(FEDERATED_IS_TOKEN_ENDPOINT);\n+        IdentityProviderProperty[] properties = {jwksUriProperty, issuerProperty};\n+        identityProvider.setIdpProperties(properties);\n+        // Set federated auth configs.\n+        FederatedAuthenticatorConfig oidcAuthnConfig = new FederatedAuthenticatorConfig();\n+        oidcAuthnConfig.setName(FEDERATED_IS_AUTHENTICATOR_NAME_OIDC);\n+        oidcAuthnConfig.setDisplayName(\"openidconnect\");\n+        oidcAuthnConfig.setEnabled(true);\n+        oidcAuthnConfig.setProperties(getOIDCAuthnConfigProperties());\n+        identityProvider.setDefaultAuthenticatorConfig(oidcAuthnConfig);\n+        identityProvider.setFederatedAuthenticatorConfigs(new FederatedAuthenticatorConfig[]{oidcAuthnConfig});\n+        JustInTimeProvisioningConfig jitConfig = new JustInTimeProvisioningConfig();\n+        jitConfig.setProvisioningEnabled(true);\n+        jitConfig.setProvisioningUserStore(\"PRIMARY\");\n+        identityProvider.setJustInTimeProvisioningConfig(jitConfig);\n+        identityProviderMgtServiceClient.addIdP(identityProvider);\n+        Assert.assertNotNull(identityProviderMgtServiceClient.getIdPByName(FEDERATED_IS_NAME), \"Failed to \" +\n+                \"create Identity Provider 'trustedIdP' in primary IS.\");\n+    }\n+\n+    /**\n+     * Creates 'application1' service provider in the primary idp.\n+     *\n+     * @throws Exception - Throw Exception if failed.\n+     */\n+    private void createServiceProviderInPrimaryIdp() throws Exception {\n+\n+        addServiceProvider(PRIMARY_TENANT, PRIMARY_IS_SP_NAME);\n+        ServiceProvider serviceProvider = getServiceProvider(PRIMARY_TENANT, PRIMARY_IS_SP_NAME);\n+        HashMap<String, String> credentials = updateServiceProviderWithOIDCConfigs(PRIMARY_TENANT, PRIMARY_IS_SP_NAME,\n+                PRIMARY_IS_SP_CALLBACK_URL, PRIMARY_IS_SP_BACK_CHANNEL_LOGOUT_URL, serviceProvider);\n+        primSPClientID = credentials.get(OIDC_APP_CLIENT_ID);\n+        primSPClientSecret = credentials.get(OIDC_APP_CLIENT_SECRET);\n+        AuthenticationStep authStep = new AuthenticationStep();\n+        org.wso2.carbon.identity.application.common.model.xsd.IdentityProvider idP = new org.wso2.carbon.identity.\n+                application.common.model.xsd.IdentityProvider();\n+        idP.setIdentityProviderName(FEDERATED_IS_NAME);\n+        org.wso2.carbon.identity.application.common.model.xsd.FederatedAuthenticatorConfig oidcAuthnConfig = new\n+                org.wso2.carbon.identity.application.common.model.xsd.FederatedAuthenticatorConfig();\n+        oidcAuthnConfig.setName(FEDERATED_IS_AUTHENTICATOR_NAME_OIDC);\n+        oidcAuthnConfig.setDisplayName(\"openidconnect\");\n+        idP.setFederatedAuthenticatorConfigs(new org.wso2.carbon.identity.application.common.model.xsd.\n+                FederatedAuthenticatorConfig[]{oidcAuthnConfig});\n+\n+        authStep.setFederatedIdentityProviders(new org.wso2.carbon.identity.application.common.model.xsd.\n+                IdentityProvider[]{idP});\n+\n+        serviceProvider.getLocalAndOutBoundAuthenticationConfig().setAuthenticationSteps(new AuthenticationStep[]{\n+                authStep});\n+        serviceProvider.getLocalAndOutBoundAuthenticationConfig()\n+                .setAuthenticationType(PRIMARY_IS_SP_AUTHENTICATION_TYPE);\n+\n+        updateServiceProvider(PRIMARY_TENANT, serviceProvider);\n+        serviceProvider = getServiceProvider(PRIMARY_TENANT, PRIMARY_IS_SP_NAME);\n+        InboundAuthenticationRequestConfig[] configs = serviceProvider.getInboundAuthenticationConfig().\n+                getInboundAuthenticationRequestConfigs();\n+        boolean success = false;\n+        if (configs != null) {\n+            for (InboundAuthenticationRequestConfig config : configs) {\n+                if (credentials.get(OIDC_APP_CLIENT_ID).equals(config.getInboundAuthKey()) &&\n+                        OAuth2Constant.OAUTH_2.equals(\n+                                config.getInboundAuthType())) {\n+                    success = true;\n+                    break;\n+                }\n+            }\n+        }\n+        Assert.assertTrue(success, \"Failed to update service provider in primaryIS with inbound OIDC \" +\n+                \"configs.\");\n+    }\n+\n+    /**\n+     * Create service provider, \"application2\" in the secondary idp.\n+     *\n+     * @throws Exception - Exception.\n+     */\n+    private void createServiceProviderInSecondaryIdp() throws Exception {\n+\n+        addServiceProvider(FEDERATED_TENANT, FEDERATED_IS_SP_NAME);\n+        ServiceProvider serviceProvider = getServiceProvider(FEDERATED_TENANT, FEDERATED_IS_SP_NAME);\n+        HashMap<String, String> credentials =\n+                updateServiceProviderWithOIDCConfigs(FEDERATED_TENANT, FEDERATED_IS_SP_NAME,\n+                        FEDERATED_IS_SP_CALLBACK_URL, FEDERATED_IS_SP_BACK_CHANNEL_LOGOUT_URL, serviceProvider);\n+        fedSP_ClientID = credentials.get(OIDC_APP_CLIENT_ID);\n+        fedSP_ClientSecret = credentials.get(OIDC_APP_CLIENT_SECRET);\n+        updateServiceProvider(FEDERATED_TENANT, serviceProvider);\n+        serviceProvider = getServiceProvider(FEDERATED_TENANT, FEDERATED_IS_SP_NAME);\n+        InboundAuthenticationRequestConfig[] configs = serviceProvider.getInboundAuthenticationConfig().\n+                getInboundAuthenticationRequestConfigs();\n+        boolean success = false;\n+        if (configs != null) {\n+            for (InboundAuthenticationRequestConfig config : configs) {\n+                if (credentials.get(OIDC_APP_CLIENT_ID).equals(config.getInboundAuthKey()) &&\n+                        OAuth2Constant.OAUTH_2.equals(\n+                                config.getInboundAuthType())) {\n+                    success = true;\n+                    break;\n+                }\n+            }\n+        }\n+        Assert.assertTrue(success, \"Failed to update service provider in FederatedIS with inbound OIDC \" +\n+                \"configs in \");\n+    }\n+\n+    /**\n+     * Add a user to federated idp.\n+     *\n+     * @return - boolean value indicating success.\n+     * @throws Exception - Exception.\n+     */\n+    private boolean addUserToSecondaryIS() throws Exception {\n+\n+        if (usrMgtClient == null) {\n+            return false;\n+        } else {\n+            String[] roles = {FEDERATED_IS_TEST_USER_ROLES};\n+            usrMgtClient.addUser(FEDERATED_IS_TEST_USERNAME, FEDERATED_IS_TEST_PASSWORD, roles, null);\n+            return usrMgtClient.userNameExists(FEDERATED_IS_TEST_USER_ROLES, FEDERATED_IS_TEST_USERNAME);\n+        }\n+    }\n+\n+    /**\n+     * Create a service provider in ApplicationManagementServiceClient for the given tenant.\n+     *\n+     * @param tenant          - Tenant to which the service provider needs to be added.\n+     * @param applicationName - Name of the application.\n+     * @throws Exception - Throw Exception if failed.\n+     */\n+    public void addServiceProvider(int tenant, String applicationName) throws Exception {\n+\n+        ServiceProvider serviceProvider = new ServiceProvider();\n+        serviceProvider.setApplicationName(applicationName);\n+        serviceProvider.setDescription(\"This is a test Service Provider\");\n+        applicationManagementServiceClients.get(tenant).createApplication(serviceProvider);\n+    }\n+\n+    /**\n+     * Retrieve the a service provider from ApplicationManagementServiceClient for the given tenant.\n+     *\n+     * @param tenant          - Tenant from where the service provider needs to be fetched.\n+     * @param applicationName - Name of the application.\n+     * @return - Return the service provider.\n+     * @throws Exception - Throw Exception if failed.\n+     */\n+    public ServiceProvider getServiceProvider(int tenant, String applicationName)\n+            throws Exception {\n+\n+        return applicationManagementServiceClients.get(tenant).getApplication(applicationName);\n+    }\n+\n+    /**\n+     * Update a service provider in ApplicationManagementServiceClient for the given tenant.\n+     *\n+     * @param tenant          - Tenant where the service provider needs to be updated.\n+     * @param serviceProvider - Service provider which needs to be updated.\n+     * @throws Exception - Throw Exception if failed.\n+     */\n+    public void updateServiceProvider(int tenant, ServiceProvider serviceProvider)\n+            throws Exception {\n+\n+        applicationManagementServiceClients.get(tenant).updateApplicationData(serviceProvider);\n+    }\n+\n+    /**\n+     * Update the given service provider with OIDC configurations.\n+     *\n+     * @param tenant               - Tenant where the service provider needs to be updated.\n+     * @param applicationName      - Name of the application.\n+     * @param callbackUrl          - Call back url.\n+     * @param backChannelLogoutUrl - Back channel logout url.\n+     * @param serviceProvider      - Service provider.\n+     * @return - Returns hashmap containing app credentials.\n+     * @throws Exception - Throw Exception if failed.\n+     */\n+    private HashMap<String, String> updateServiceProviderWithOIDCConfigs(int tenant,\n+                                                                         String applicationName,\n+                                                                         String callbackUrl,\n+                                                                         String backChannelLogoutUrl,\n+                                                                         ServiceProvider serviceProvider)\n+            throws Exception {\n+\n+        String oidcAppClientId = null;\n+        String oidcAppClientSecret = null;\n+        OAuthConsumerAppDTO appDTO = new OAuthConsumerAppDTO();\n+        appDTO.setApplicationName(applicationName);\n+        appDTO.setCallbackUrl(callbackUrl);\n+        appDTO.setOAuthVersion(OAuth2Constant.OAUTH_VERSION_2);\n+        appDTO.setGrantTypes(OAuth2Constant.OAUTH2_GRANT_TYPE_AUTHORIZATION_CODE);\n+        appDTO.setBackChannelLogoutUrl(backChannelLogoutUrl);\n+\n+        oAuthAdminClients.get(tenant).registerOAuthApplicationData(appDTO);\n+        OAuthConsumerAppDTO createdApp = oAuthAdminClients.get(tenant).getOAuthAppByName(applicationName);\n+        Assert.assertNotNull(createdApp, \"Adding OIDC app failed.\");\n+\n+        InboundAuthenticationRequestConfig inboundAuthenticationRequestConfig = new\n+                InboundAuthenticationRequestConfig();\n+        inboundAuthenticationRequestConfig.setInboundAuthType(OAuth2Constant.OAUTH_2);\n+\n+        if (StringUtils.isNotBlank(createdApp.getOauthConsumerKey())) {\n+            inboundAuthenticationRequestConfig.setInboundAuthKey(createdApp.getOauthConsumerKey());\n+            oidcAppClientId = createdApp.getOauthConsumerKey();\n+        }\n+\n+        if (StringUtils.isNotBlank(createdApp.getOauthConsumerSecret())) {\n+            org.wso2.carbon.identity.application.common.model.xsd.Property property = new org.wso2.carbon.identity.\n+                    application.common.model.xsd.Property();\n+            property.setName(OAuth2Constant.OAUTH_CONSUMER_SECRET);\n+            property.setValue(createdApp.getOauthConsumerSecret());\n+            oidcAppClientSecret = createdApp.getOauthConsumerSecret();\n+            org.wso2.carbon.identity.application.common.model.xsd.Property[] properties = {property};\n+            inboundAuthenticationRequestConfig.setProperties(properties);\n+        }\n+        serviceProvider.getInboundAuthenticationConfig().setInboundAuthenticationRequestConfigs(new\n+                InboundAuthenticationRequestConfig[]{inboundAuthenticationRequestConfig});\n+\n+        HashMap<String, String> credentials = new HashMap<>();\n+        credentials.put(OIDC_APP_CLIENT_ID, oidcAppClientId);\n+        credentials.put(OIDC_APP_CLIENT_SECRET, oidcAppClientSecret);\n+        return credentials;\n+    }\n+\n+    /**\n+     * Get the OIDC authentication configuration properties for the Idp.\n+     *\n+     * @return - Returns OIDC Auth Config Properties.\n+     */\n+    private Property[] getOIDCAuthnConfigProperties() {\n+\n+        Property[] properties = new Property[8];\n+        Property property = new Property();\n+        property.setName(IdentityConstants.Authenticator.OIDC.IDP_NAME);\n+        property.setValue(\"oidcFedIdP\");\n+        properties[0] = property;\n+\n+        property = new Property();\n+        property.setName(IdentityConstants.Authenticator.OIDC.CLIENT_ID);\n+        property.setValue(fedISClientID);\n+        properties[1] = property;\n+\n+        property = new Property();\n+        property.setName(IdentityConstants.Authenticator.OIDC.CLIENT_SECRET);\n+        property.setValue(fedISClientSecret);\n+        properties[2] = property;\n+\n+        property = new Property();\n+        property.setName(IdentityConstants.Authenticator.OIDC.OAUTH2_AUTHZ_URL);\n+        property.setValue(FEDERATED_IS_AUTHORIZE_ENDPOINT);\n+        properties[3] = property;\n+\n+        property = new Property();\n+        property.setName(IdentityConstants.Authenticator.OIDC.OAUTH2_TOKEN_URL);\n+        property.setValue(FEDERATED_IS_TOKEN_ENDPOINT);\n+        properties[4] = property;\n+\n+        property = new Property();\n+        property.setName(IdentityConstants.Authenticator.OIDC.CALLBACK_URL);\n+        property.setValue(PRIMARY_IS_CALLBACK_URL);\n+        properties[5] = property;\n+\n+        property = new Property();\n+        property.setName(IdentityConstants.Authenticator.OIDC.OIDC_LOGOUT_URL);\n+        property.setValue(FEDERATED_IS_LOGOUT_ENDPOINT);\n+        properties[6] = property;\n+\n+        property = new Property();\n+        property.setName(\"commonAuthQueryParams\");\n+        property.setValue(\"scope=\" + OAuth2Constant.OAUTH2_SCOPE_OPENID_WITH_INTERNAL_LOGIN);\n+        properties[7] = property;\n+        return properties;\n+    }\n+\n+    /**\n+     * Send login credentials to federated idp.\n+     *\n+     * @param client         - http client.\n+     * @param sessionDataKey - sessionDataKey.\n+     * @return - http response of the login request.\n+     * @throws IOException - IOException.\n+     */\n+    private HttpResponse sendLoginPost(HttpClient client, String sessionDataKey) throws IOException {\n+\n+        List<NameValuePair> urlParameters = new ArrayList<>();\n+        urlParameters.add(new BasicNameValuePair(\"username\", FEDERATED_IS_TEST_USERNAME));\n+        urlParameters.add(new BasicNameValuePair(\"password\", FEDERATED_IS_TEST_PASSWORD));\n+        urlParameters.add(new BasicNameValuePair(\"sessionDataKey\", sessionDataKey));\n+\n+        return sendPostRequestWithParameters(client, urlParameters, FEDERATED_IS_CALLBACK_URL);\n+    }\n+\n+    /**\n+     * Make a get request to the given url.\n+     *\n+     * @param client      - http client.\n+     * @param locationURL - url to make the request.\n+     * @return - http response of the request.\n+     * @throws IOException - IOException.\n+     */\n+    private HttpResponse sendGetRequest(HttpClient client, String locationURL) throws IOException {\n+\n+        HttpGet getRequest = new HttpGet(locationURL);\n+        getRequest.addHeader(\"User-Agent\", OAuth2Constant.USER_AGENT);\n+\n+        return client.execute(getRequest);\n+    }\n+\n+    /**\n+     * Make a get request to the given url.\n+     *\n+     * @param client      - http client.\n+     * @param locationURL - url to make the request.\n+     * @return - http response of the request.\n+     * @throws IOException - IOException.\n+     */\n+    private HttpResponse sendGetRequest(HttpClient client, String locationURL, String token) throws IOException {\n+\n+        HttpGet getRequest = new HttpGet(locationURL);\n+        getRequest.addHeader(\"User-Agent\", OAuth2Constant.USER_AGENT);\n+        getRequest.setHeader(HttpHeaders.CONTENT_TYPE, \"application/json\");\n+        getRequest.setHeader(HttpHeaders.AUTHORIZATION, \"Bearer \" + token);\n+        return client.execute(getRequest);\n+    }\n+\n+    /**\n+     * Send a GET request with url parameters.\n+     *\n+     * @param client        - http client.\n+     * @param urlParameters - url parameters list.\n+     * @param url           - url to send the POST request.\n+     * @return - http response of the request.\n+     * @throws IOException - IOException.\n+     */\n+    private HttpResponse sendGetRequestWithParameters(HttpClient client, List<NameValuePair> urlParameters, String url)\n+            throws IOException, URISyntaxException {\n+\n+        HttpGet request = new HttpGet(url);\n+        request.setHeader(\"User-Agent\", OAuth2Constant.USER_AGENT);\n+        URI uri = new URIBuilder(request.getURI())\n+                .addParameters(urlParameters)\n+                .build();\n+        request.setURI(uri);\n+        return client.execute(request);\n+    }\n+\n+    /**\n+     * Send a POST request with url parameters.\n+     *\n+     * @param client        - http client.\n+     * @param urlParameters - url parameters list.\n+     * @param url           - url to send the POST request.\n+     * @return - http response of the request.\n+     * @throws IOException - IOException.\n+     */\n+    private HttpResponse sendPostRequestWithParameters(HttpClient client, List<NameValuePair> urlParameters, String url)\n+            throws IOException {\n+\n+        HttpPost request = new HttpPost(url);\n+        request.setHeader(\"User-Agent\", OAuth2Constant.USER_AGENT);\n+        request.setEntity(new UrlEncodedFormEntity(urlParameters));\n+\n+        return client.execute(request);\n+    }\n+\n+    /**\n+     * Replace existing deployment.toml file with a file containing the configs to enable the tenant qualified urls\n+     * session.\n+     *\n+     * @throws Exception - Exception.\n+     */\n+    private void changeISConfiguration() throws Exception {\n+\n+        log.info(\"Replacing deployment.toml to enable tenant qualified url.\");\n+        String carbonHome = Utils.getResidentCarbonHome();\n+        File defaultTomlFile = getDeploymentTomlFile(carbonHome);\n+        File configuredTomlFile = new File(getISResourceLocation() + File.separator + \"oidc\" +\n+                File.separator + \"tenant_qualified_paths_enabled.toml\");\n+        serverConfigurationManager.applyConfigurationWithoutRestart(configuredTomlFile, defaultTomlFile, true);\n+        serverConfigurationManager.restartGracefully();\n+    }\n+\n+    /**\n+     * Reset IS Configuration.\n+     *\n+     * @throws Exception\n+     */\n+    private void resetISConfiguration() throws Exception {\n+\n+        serverConfigurationManager.restoreToLastConfiguration(false);\n+    }\n+\n+    /**\n+     * Create service clients for the tenants.\n+     *\n+     * @throws XPathExpressionException - Exception if failed.\n+     * @throws RemoteException          - Exception if failed.\n+     */\n+    private void removeServiceProviders()\n+            throws Exception {\n+\n+        applicationManagementServiceClients.get(PRIMARY_TENANT).deleteApplication(PRIMARY_IS_SP_NAME);\n+        applicationManagementServiceClients.get(FEDERATED_TENANT).deleteApplication(FEDERATED_IS_SP_NAME);\n+        identityProviderMgtServiceClient.deleteIdP(FEDERATED_IS_NAME);\n+        oAuthAdminClients.get(PRIMARY_TENANT).removeOAuthApplicationData(primSPClientID);\n+        oAuthAdminClients.get(FEDERATED_TENANT).removeOAuthApplicationData(fedSP_ClientID);\n+        usrMgtClient.deleteUser(FEDERATED_IS_TEST_USERNAME);\n+    }\n+\n+    /**\n+     * Extract the location header value from a HttpResponse.\n+     *\n+     * @param response HttpResponse object that needs the header extracted.\n+     * @return String value of the location header.\n+     */\n+    private String getLocationHeaderValue(HttpResponse response) {\n+\n+        Header location = response.getFirstHeader(OAuth2Constant.HTTP_RESPONSE_HEADER_LOCATION);\n+        Assert.assertNotNull(location);\n+        return location.getValue();\n+    }\n+}"
  },
  {
    "sha": "c33fabb8405b4579c2d27094b0c87ff6832c7b37",
    "filename": "modules/integration/tests-integration/tests-backend/src/test/resources/artifacts/IS/oidc/tenant_qualified_paths_enabled.toml",
    "status": "added",
    "additions": 47,
    "deletions": 0,
    "changes": 47,
    "blob_url": "https://github.com/wso2/product-is/blob/3833d01760dc6a9c8e34f31cea471281bf939164/modules/integration/tests-integration/tests-backend/src/test/resources/artifacts/IS/oidc/tenant_qualified_paths_enabled.toml",
    "raw_url": "https://github.com/wso2/product-is/raw/3833d01760dc6a9c8e34f31cea471281bf939164/modules/integration/tests-integration/tests-backend/src/test/resources/artifacts/IS/oidc/tenant_qualified_paths_enabled.toml",
    "contents_url": "https://api.github.com/repos/wso2/product-is/contents/modules/integration/tests-integration/tests-backend/src/test/resources/artifacts/IS/oidc/tenant_qualified_paths_enabled.toml?ref=3833d01760dc6a9c8e34f31cea471281bf939164",
    "patch": "@@ -0,0 +1,47 @@\n+[server]\n+hostname = \"localhost\"\n+node_ip = \"127.0.0.1\"\n+base_path = \"https://$ref{server.hostname}:${carbon.management.port}\"\n+\n+[super_admin]\n+username = \"admin\"\n+password = \"admin\"\n+create_admin_account = true\n+\n+[user_store]\n+type = \"read_write_ldap_unique_id\"\n+connection_url = \"ldap://localhost:${Ports.EmbeddedLDAP.LDAPServerPort}\"\n+connection_name = \"uid=admin,ou=system\"\n+connection_password = \"admin\"\n+base_dn = \"dc=wso2,dc=org\"      #refers the base dn on which the user and group search bases will be generated\n+\n+[database.identity_db]\n+type = \"h2\"\n+url = \"jdbc:h2:./repository/database/WSO2IDENTITY_DB;DB_CLOSE_ON_EXIT=FALSE;LOCK_TIMEOUT=60000\"\n+username = \"wso2carbon\"\n+password = \"wso2carbon\"\n+\n+[database.shared_db]\n+type = \"h2\"\n+url = \"jdbc:h2:./repository/database/WSO2SHARED_DB;DB_CLOSE_ON_EXIT=FALSE;LOCK_TIMEOUT=60000\"\n+username = \"wso2carbon\"\n+password = \"wso2carbon\"\n+\n+[keystore.primary]\n+file_name = \"wso2carbon.jks\"\n+password = \"wso2carbon\"\n+\n+[truststore]\n+file_name=\"client-truststore.jks\"\n+password=\"wso2carbon\"\n+type=\"JKS\"\n+\n+[account_recovery.endpoint.auth]\n+hash= \"66cd9688a2ae068244ea01e70f0e230f5623b7fa4cdecb65070a09ec06452262\"\n+\n+[identity.auth_framework.endpoint]\n+app_password= \"dashboard\"\n+\n+[tenant_context]\n+enable_tenant_qualified_urls = true\n+enable_tenanted_sessions = true"
  },
  {
    "sha": "8ab1f4afc7da750dcff3d4d9f5f6fc2b28e65413",
    "filename": "modules/integration/tests-integration/tests-backend/src/test/resources/testng.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/wso2/product-is/blob/3833d01760dc6a9c8e34f31cea471281bf939164/modules/integration/tests-integration/tests-backend/src/test/resources/testng.xml",
    "raw_url": "https://github.com/wso2/product-is/raw/3833d01760dc6a9c8e34f31cea471281bf939164/modules/integration/tests-integration/tests-backend/src/test/resources/testng.xml",
    "contents_url": "https://api.github.com/repos/wso2/product-is/contents/modules/integration/tests-integration/tests-backend/src/test/resources/testng.xml?ref=3833d01760dc6a9c8e34f31cea471281bf939164",
    "patch": "@@ -229,6 +229,7 @@\n             <class name=\"org.wso2.identity.integration.test.workflow.mgt.WorkflowManagementTestCase\"/>\n             <class name=\"org.wso2.identity.integration.test.oidc.OIDCIdentityFederationTestCase\"/>\n             <class name=\"org.wso2.identity.integration.test.provisioning.JustInTimeProvisioningTestCase\"/>\n+            <class name=\"org.wso2.identity.integration.test.oidc.OIDCFederatedIdpInitLogoutTest\"/>\n         </classes>\n     </test>\n "
  }
]
