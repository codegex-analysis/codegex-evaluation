[
  {
    "sha": "bad0bef3154576aa9484001172fc0711ddab9b80",
    "filename": "src/main/java/com/qiniu/common/QiniuException.java",
    "status": "modified",
    "additions": 19,
    "deletions": 1,
    "changes": 20,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/common/QiniuException.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/common/QiniuException.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/common/QiniuException.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -9,8 +9,10 @@\n  * 七牛SDK异常封装类，封装了http响应数据\n  */\n public final class QiniuException extends IOException {\n+\n     public final Response response;\n     private String error;\n+    private boolean isUnrecoverable = false;\n \n \n     public QiniuException(Response response) {\n@@ -21,6 +23,18 @@ public QiniuException(Response response) {\n         }\n     }\n \n+    public static QiniuException unrecoverable(Exception e) {\n+        QiniuException exception = new QiniuException(e);\n+        exception.isUnrecoverable = true;\n+        return exception;\n+    }\n+\n+    public static QiniuException unrecoverable(String msg) {\n+        QiniuException exception = new QiniuException(null, msg);\n+        exception.isUnrecoverable = true;\n+        return exception;\n+    }\n+\n     public QiniuException(Exception e) {\n         this(e, null);\n     }\n@@ -36,7 +50,11 @@ public String url() {\n     }\n \n     public int code() {\n-        return response != null ? response.statusCode : -1;\n+        return response != null ? response.statusCode : Response.NetworkError;\n+    }\n+\n+    public boolean isUnrecoverable() {\n+        return isUnrecoverable;\n     }\n \n     public String error() {"
  },
  {
    "sha": "24272ce11617439e4e264549000005e4a63a9598",
    "filename": "src/main/java/com/qiniu/http/Response.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/http/Response.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/http/Response.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/http/Response.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -136,6 +136,11 @@ public static Response createError(okhttp3.Response response, String address, do\n                 address, duration, error, body);\n     }\n \n+    public static Response createSuccessResponse() {\n+        return new Response(null, 200, \"inter:reqId\", null, \"inter:via\",\n+                null, 0, null, new byte[0]);\n+    }\n+\n \n     private static String via(okhttp3.Response response) {\n         String via;"
  },
  {
    "sha": "9fc83e31fe23fbfd6d9e6911b469bad3bd4e571b",
    "filename": "src/main/java/com/qiniu/storage/ConcurrentResumeUploader.java",
    "status": "added",
    "additions": 183,
    "deletions": 0,
    "changes": 183,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ConcurrentResumeUploader.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ConcurrentResumeUploader.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/storage/ConcurrentResumeUploader.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -0,0 +1,183 @@\n+package com.qiniu.storage;\n+\n+import com.qiniu.common.QiniuException;\n+import com.qiniu.http.Client;\n+import com.qiniu.http.Response;\n+import com.qiniu.util.StringMap;\n+\n+import java.io.File;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * 并发分片上传\n+ * <p>\n+ * 分片上传 v1\n+ * 参考文档：<a href=\"https://developer.qiniu.com/kodo/7443/shard-to-upload\">分片上传</a>\n+ * <p/>\n+ * 上传通过将一个文件分割为固定大小的块(4M)，每次上传一个块的内容（服务端只分块，没有分片）。\n+ * 等待所有块都上传完成之后，再将这些块拼接起来，构成一个完整的文件。\n+ * <p/>\n+ * <p>\n+ * 分片上传 v2\n+ * 参考文档：<a href=\"https://developer.qiniu.com/kodo/6364/multipartupload-interface\">分片上传</a>\n+ * <p/>\n+ * 上传通过将一个文件分割为固定大小的块(大小可配置，通过 Configuration.resumeV2BlockSize)，每次上传一个块的内容。\n+ * 等待所有块都上传完成之后，再将这些块拼接起来，构成一个完整的文件。\n+ * <p/>\n+ * <p>\n+ * 另外分片上传还支持纪录上传进度，如果本次上传被暂停，那么下次还可以从上次\n+ * 上次完成的文件偏移位置，继续开始上传，这样就实现了断点续传功能。\n+ * <p>\n+ * 服务端网络较稳定，较大文件（如500M以上）才需要将块记录保存下来。\n+ * 小文件没有必要，可以有效地实现大文件的上传。\n+ */\n+public class ConcurrentResumeUploader extends ResumeUploader {\n+\n+    /**\n+     * 构建分片上传文件的对象【兼容老版本】\n+     * 分片上传时，每个上传操作会占用 blockSize 大小内存，blockSize 也即分片大小，\n+     * 在分片 v1 中 blockSize 为 4M；\n+     * 分片 v2 可自定义 blockSize，定义方式为：Configuration.resumeV2BlockSize，范围为：1M ~ 1GB，分片 v2 需要注意每个文件最大分片数量为 10000；\n+     * 当采用并发分片时，占用内存大小和当时启用并发任务数量有关，即：blockSize * 并发数量，\n+     * 并发任务数量配置方式：Configuration.resumeMaxConcurrentTaskCount\n+     * <p>\n+     * 支持分片上传 v1/v2，支持断点续传，支持并发\n+     *\n+     * @param client        上传 client【必须】\n+     * @param upToken       上传凭证【必须】\n+     * @param key           文件保存名称【可选】\n+     * @param file          文件【必须】\n+     * @param params        自定义参数【可选】\n+     *                      自定义文件 metadata 信息，key 需要增加前缀 x-qn-meta- ：如 params.put(\"x-qn-meta-key\", \"foo\")\n+     *                      用户自定义变量，key 需要增加前缀 x: ：如 params.put(\"x:foo\", \"foo\")\n+     * @param mime          文件 mime type【可选】\n+     * @param recorder      断点续传信息记录对象【可选】\n+     * @param configuration 上传配置信息【必须】\n+     */\n+    public ConcurrentResumeUploader(Client client, String upToken, String key, File file, StringMap params, String mime,\n+                                    Recorder recorder, Configuration configuration) {\n+        super(client, upToken, key, file, params, mime, recorder, configuration);\n+    }\n+\n+    /**\n+     * 构建分片上传文件流的对象【兼容老版本】\n+     * 分片上传时，每个上传操作会占用 blockSize 大小内存，blockSize 也即分片大小，\n+     * 在分片 v1 中 blockSize 为 4M；\n+     * 分片 v2 可自定义 blockSize，定义方式为：Configuration.resumeV2BlockSize，范围为：1M ~ 1GB，分片 v2 需要注意每个文件最大分片数量为 10000；\n+     * 当采用并发分片时，占用内存大小和当时启用并发任务数量有关，即：blockSize * 并发数量，\n+     * 并发任务数量配置方式：Configuration.resumeMaxConcurrentTaskCount\n+     * <p>\n+     * 支持分片上传 v1/v2，支持并发\n+     * 不支持断点续传，不支持定义file name\n+     *\n+     * @param client        上传 client 【必须】\n+     * @param upToken       上传凭证 【必须】\n+     * @param key           文件保存名称 【可选】\n+     * @param stream        文件流 【必须】\n+     * @param params        自定义参数【可选】\n+     *                      自定义文件 metadata 信息，key 需要增加前缀 x-qn-meta- ：如 params.put(\"x-qn-meta-key\", \"foo\")\n+     *                      用户自定义变量，key 需要增加前缀 x: ：如 params.put(\"x:foo\", \"foo\")\n+     * @param mime          文件 mime type【可选】\n+     * @param configuration 上传配置信息 【必须】\n+     */\n+    public ConcurrentResumeUploader(Client client, String upToken, String key, InputStream stream,\n+                                    StringMap params, String mime, Configuration configuration) {\n+        super(client, upToken, key, stream, null, params, mime, configuration);\n+    }\n+\n+    /**\n+     * 构建分片上传文件流的对象\n+     * 分片上传时，每个上传操作会占用 blockSize 大小内存，blockSize 也即分片大小，\n+     * 在分片 v1 中 blockSize 为 4M；\n+     * 分片 v2 可自定义 blockSize，定义方式为：Configuration.resumeV2BlockSize，范围为：1M ~ 1GB，分片 v2 需要注意每个文件最大分片数量为 10000；\n+     * 当采用并发分片时，占用内存大小和当时启用并发任务数量有关，即：blockSize * 并发数量，\n+     * 并发任务数量配置方式：Configuration.resumeMaxConcurrentTaskCount\n+     * <p>\n+     * 支持分片上传 v1/v2，支持并发，支持定义file name\n+     * 不支持断点续传\n+     *\n+     * @param client        上传 client 【必须】\n+     * @param upToken       上传凭证 【必须】\n+     * @param key           文件保存名称 【可选】\n+     * @param stream        文件流 【必须】\n+     * @param fileName      文件名 【可选】\n+     * @param params        自定义参数【可选】\n+     *                      自定义文件 metadata 信息，key 需要增加前缀 x-qn-meta- ：如 params.put(\"x-qn-meta-key\", \"foo\")\n+     *                      用户自定义变量，key 需要增加前缀 x: ：如 params.put(\"x:foo\", \"foo\")\n+     * @param mime          文件 mime type 【可选】\n+     * @param configuration 上传配置信息 【必须】\n+     */\n+    public ConcurrentResumeUploader(Client client, String upToken, String key, InputStream stream,\n+                                    String fileName, StringMap params, String mime, Configuration configuration) {\n+        super(client, upToken, key, stream, fileName, params, mime, configuration);\n+    }\n+\n+    @Override\n+    Response uploadData() throws QiniuException {\n+\n+        // 处理参数\n+        int maxConcurrentTaskCount = config.resumeMaxConcurrentTaskCount;\n+        ExecutorService pool = config.resumeConcurrentTaskExecutorService;\n+\n+        if (maxConcurrentTaskCount < 1) {\n+            maxConcurrentTaskCount = 1;\n+        }\n+        if (pool == null) {\n+            pool = Executors.newFixedThreadPool(maxConcurrentTaskCount);\n+        }\n+\n+        // 开启并发任务\n+        System.out.println(\"并发上传 task count:\" + maxConcurrentTaskCount);\n+        List<Future<Response>> futures = new ArrayList<>();\n+        for (int i = 0; i < maxConcurrentTaskCount; i++) {\n+            Future<Response> future = pool.submit(new Callable<Response>() {\n+                @Override\n+                public Response call() throws Exception {\n+                    return ConcurrentResumeUploader.super.uploadData();\n+                }\n+            });\n+            futures.add(future);\n+        }\n+\n+        // 等待所有并发任务完成\n+        Response response = null;\n+        QiniuException exception = null;\n+        for (Future<Response> future : futures) {\n+            while (!future.isDone()) {\n+                try {\n+                    Thread.sleep(500);\n+                } catch (InterruptedException ignored) {\n+                }\n+            }\n+\n+            try {\n+                Response responseP = future.get();\n+                if (response == null || (responseP != null && responseP.isOK())) {\n+                    response = responseP;\n+                }\n+            } catch (Exception e) {\n+                exception = new QiniuException(e);\n+            }\n+\n+            System.out.println(\"并发上传 task complete, index:\" + futures.indexOf(future));\n+        }\n+\n+        // 所有块上传完成说明上传成功\n+        if (uploadPerformer.isAllBlocksUploaded()) {\n+            return response;\n+        }\n+\n+        // 未完成 如果有异常则有异常，理论上未完成必定有异常\n+        if (exception != null) {\n+            throw exception;\n+        }\n+\n+        return response;\n+    }\n+}"
  },
  {
    "sha": "80bb55a2b10c0618bddd6b106843f3c8f28968dc",
    "filename": "src/main/java/com/qiniu/storage/Configuration.java",
    "status": "modified",
    "additions": 36,
    "deletions": 0,
    "changes": 36,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/Configuration.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/Configuration.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/storage/Configuration.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -7,6 +7,8 @@\n import com.qiniu.http.Dns;\n import com.qiniu.http.ProxyConfiguration;\n \n+import java.util.concurrent.ExecutorService;\n+\n /**\n  * 该类封装了SDK相关配置参数\n  */\n@@ -41,6 +43,35 @@\n      * upload-na0.qiniup.com, upload-as0.qiniup.com\n      */\n     public boolean useDefaultUpHostIfNone = true;\n+    /**\n+     * 使用分片 V2 上传时的分片大小\n+     * 范围为：1M ~ 1GB，\n+     * 注：每个文件最大分片数量为 10000\n+     */\n+    public int resumeV2BlockSize = Constants.BLOCK_SIZE;\n+    /**\n+     * 分片上传每个文件传时的最大并发任务数，并发数量会影响内存使用，请合理配置\n+     * 当 resumeMaxConcurrentTaskCount 小于或等于 1 时，使用同步上传，resumeConcurrentTaskExecutorService 不被使用\n+     * 当 resumeMaxConcurrentTaskCount 大于 1 时，使用并发上传\n+     * <p>\n+     * 分片上传，每个上传操作会占用 blockSize 大小内存，blockSize 也即分片大小，\n+     * 在分片 v1 中 blockSize 为 4M；\n+     * 分片 v2 可自定义，定义方式为：Configuration.resumeV2BlockSize，范围为：1M ~ 1GB，分片 v2 需要注意每个文件最大分片数量为 10000；\n+     * 当采用并发分片时，占用内存大小和当时启用并发任务数量有关，即：blockSize * 并发数量，\n+     * 并发任务数量配置方式：Configuration.resumeMaxConcurrentTaskCount\n+     */\n+    public int resumeMaxConcurrentTaskCount = 1;\n+    /**\n+     * 分片上传并发任务的 ExecutorService\n+     * 当 resumeMaxConcurrentTaskCount 小于或等于 1，此设置无效；\n+     * 当 resumeMaxConcurrentTaskCount 大于 1 且 resumeConcurrentTaskExecutorService 为空，则会创建 Executors.newFixedThreadPool(maxConcurrentTaskCount)\n+     * 当 resumeMaxConcurrentTaskCount 大于 1 且 resumeConcurrentTaskExecutorService 不为空，则直接使用 resumeConcurrentTaskExecutorService\n+     */\n+    public ExecutorService resumeConcurrentTaskExecutorService = null;\n+    /**\n+     * 分片上传的版本\n+     */\n+    public ResumeVersion resumeVersion = ResumeVersion.V1;\n     /**\n      * 如果文件大小大于此值则使用断点上传, 否则使用Form上传\n      */\n@@ -179,4 +210,9 @@ public String ucHost() {\n         return configHelper.ucHost();\n     }\n \n+\n+    public enum ResumeVersion {\n+        V1, V2\n+    }\n+\n }"
  },
  {
    "sha": "0cfb9ef421dad385bd07fb98b660c80225f0ff9a",
    "filename": "src/main/java/com/qiniu/storage/FixBlockUploader.java",
    "status": "modified",
    "additions": 11,
    "deletions": 1,
    "changes": 12,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/FixBlockUploader.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/FixBlockUploader.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/storage/FixBlockUploader.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -165,6 +165,7 @@ Record initUpload(BlockData blockData, UploadRecordHelper recordHelper,\n             String uploadId = init(bucket, base64Key, token.getUpToken());\n             List<EtagIdx> etagIdxes = new ArrayList<>();\n             record = initRecord(uploadId, etagIdxes);\n+            record.blockSize = blockData.blockDataSize;\n         }\n         return record;\n     }\n@@ -880,7 +881,12 @@ public String toString() {\n         long createdTime;\n         String uploadId;\n         long size;\n+        long blockSize;\n         List<EtagIdx> etagIdxes;\n+        // 用于区分记录是 V1 还是 V2\n+        boolean isValid() {\n+            return uploadId != null && etagIdxes != null && etagIdxes.size() > 0;\n+        }\n     }\n \n     class UploadRecordHelper {\n@@ -902,6 +908,9 @@ public Record reloadRecord() {\n                 try {\n                     byte[] data = recorder.get(recordFileKey);\n                     record = new Gson().fromJson(new String(data, Charset.forName(\"UTF-8\")), Record.class);\n+                    if (!record.isValid()) {\n+                        record = null;\n+                    }\n                 } catch (Exception e) {\n                     // do nothing\n                 }\n@@ -929,7 +938,8 @@ public boolean isActiveRecord(Record record, BlockData blockData) {\n                     && record.createdTime > System.currentTimeMillis() - 1000 * 3600 * 24 * 5\n                     && !StringUtils.isNullOrEmpty(record.uploadId)\n                     && record.etagIdxes != null && record.etagIdxes.size() > 0\n-                    && record.size > 0 && record.size <= blockData.size();\n+                    && record.size > 0 && record.size <= blockData.size()\n+                    && record.blockSize == blockData.blockDataSize;\n             if (isOk) {\n                 int p = 0;\n                 // PartNumber start with 1 and increase by 1 //"
  },
  {
    "sha": "4cbdca0a5f63ebcc4332e967e66dc78af2899cf3",
    "filename": "src/main/java/com/qiniu/storage/ResumeUploadPerformer.java",
    "status": "added",
    "additions": 210,
    "deletions": 0,
    "changes": 210,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ResumeUploadPerformer.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ResumeUploadPerformer.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/storage/ResumeUploadPerformer.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -0,0 +1,210 @@\n+package com.qiniu.storage;\n+\n+import com.google.gson.Gson;\n+import com.qiniu.common.Constants;\n+import com.qiniu.common.QiniuException;\n+import com.qiniu.http.Client;\n+import com.qiniu.http.Response;\n+import com.qiniu.util.StringMap;\n+import com.qiniu.util.StringUtils;\n+\n+import java.io.IOException;\n+\n+abstract class ResumeUploadPerformer {\n+\n+    private final Client client;\n+    private final Recorder recorder;\n+    private final Configuration config;\n+    private final ConfigHelper configHelper;\n+\n+    final String key;\n+    final UploadToken token;\n+    final ResumeUploadSource uploadSource;\n+    final UploadOptions options;\n+\n+    ResumeUploadPerformer(Client client, String key, UploadToken token, ResumeUploadSource source,\n+                          Recorder recorder, UploadOptions options, Configuration config) {\n+        this.client = client;\n+        this.key = key;\n+        this.token = token;\n+        this.uploadSource = source;\n+        this.options = options == null ? UploadOptions.defaultOptions() : options;\n+        this.recorder = recorder;\n+        this.config = config;\n+        this.configHelper = new ConfigHelper(config);\n+    }\n+\n+    boolean isAllBlocksUploadingOrUploaded() {\n+        return uploadSource.isAllBlocksUploadingOrUploaded();\n+    }\n+\n+    boolean isAllBlocksUploaded() {\n+        return uploadSource.isAllBlocksUploaded();\n+    }\n+\n+\n+    abstract boolean shouldInit();\n+\n+    abstract Response uploadInit() throws QiniuException;\n+\n+    Response uploadNextData() throws QiniuException {\n+        ResumeUploadSource.Block block = null;\n+        synchronized (this) {\n+            block = getNextUploadingBlock();\n+            if (block != null) {\n+                block.isUploading = true;\n+            }\n+        }\n+\n+        if (block == null) {\n+            return Response.createSuccessResponse();\n+        }\n+\n+        System.out.printf(\"上传块开始：index:%d offset:%d size:%d \\r\\n\", block.index, block.offset, block.size);\n+\n+        Response response = null;\n+        try {\n+            response = uploadBlock(block);\n+            block.isUploading = false;\n+\n+        } catch (QiniuException e) {\n+            block.isUploading = false;\n+            throw e;\n+        } finally {\n+            System.out.printf(\"上传块结束：index:%d offset:%d size:%d \\r\\n\", block.index, block.offset, block.size);\n+        }\n+        return response;\n+    }\n+\n+    abstract Response uploadBlock(ResumeUploadSource.Block block) throws QiniuException;\n+\n+    abstract Response completeUpload() throws QiniuException;\n+\n+    private ResumeUploadSource.Block getNextUploadingBlock() throws QiniuException {\n+\n+        ResumeUploadSource.Block block = null;\n+        try {\n+            block = uploadSource.getNextUploadingBlock();\n+        } catch (IOException e) {\n+            throw new QiniuException(e);\n+        }\n+        return block;\n+    }\n+\n+    void recoverUploadProgressFromLocal() {\n+        if (recorder == null || StringUtils.isNullOrEmpty(uploadSource.recordKey)) {\n+            return;\n+        }\n+\n+        byte[] data = recorder.get(uploadSource.recordKey);\n+        if (data == null) {\n+            return;\n+        }\n+        String jsonString = new String(data, Constants.UTF_8);\n+        ResumeUploadSource source = null;\n+        try {\n+            source = new Gson().fromJson(jsonString, uploadSource.getClass());\n+        } catch (Exception ignored) {\n+        }\n+        if (source == null) {\n+            return;\n+        }\n+\n+        boolean isCopy = uploadSource.recoverFromRecordInfo(source);\n+        if (!isCopy) {\n+            removeUploadProgressFromLocal();\n+        }\n+    }\n+\n+    void saveUploadProgressToLocal() {\n+        if (recorder == null || StringUtils.isNullOrEmpty(uploadSource.recordKey)) {\n+            return;\n+        }\n+        String dataString = new Gson().toJson(uploadSource);\n+        recorder.set(uploadSource.recordKey, dataString.getBytes(Constants.UTF_8));\n+    }\n+\n+    void removeUploadProgressFromLocal() {\n+        if (recorder == null || StringUtils.isNullOrEmpty(uploadSource.recordKey)) {\n+            return;\n+        }\n+        recorder.del(uploadSource.recordKey);\n+    }\n+\n+    private String getUploadHost() throws QiniuException {\n+        return configHelper.upHost(token.getToken());\n+    }\n+\n+    private void changeHost(String host) {\n+        try {\n+            configHelper.tryChangeUpHost(token.getToken(), host);\n+        } catch (Exception ignored) {\n+        }\n+    }\n+\n+    Response post(String url, byte[] data, int offset, int size) throws QiniuException {\n+        StringMap header = new StringMap();\n+        header.put(\"Authorization\", \"UpToken \" + token.getToken());\n+        return client.post(url, data, offset, size, header, options.mimeType);\n+    }\n+\n+    Response put(String url, byte[] data, int offset, int size) throws QiniuException {\n+        StringMap header = new StringMap();\n+        header.put(\"Authorization\", \"UpToken \" + token.getToken());\n+        return client.put(url, data, offset, size, header, options.mimeType);\n+    }\n+\n+    Response retryUploadAction(UploadAction action) throws QiniuException {\n+        Response response = null;\n+        int retryCount = 0;\n+\n+\n+        do {\n+            boolean shouldRetry = false;\n+            String host = getUploadHost();\n+            System.out.println(\"== action index:\" + retryCount);\n+            try {\n+                response = action.uploadAction(host);\n+                System.out.println(\"== response:\" + response);\n+            } catch (QiniuException e) {\n+                System.out.println(\"== Exception:\" + e);\n+\n+                // 切换 Host\n+                if (e.code() < 0 || e.response != null && e.response.needSwitchServer()) {\n+                    System.out.println(\"== change host\");\n+                    changeHost(host);\n+                }\n+\n+                // 判断是否需要重试\n+                if (!e.isUnrecoverable() || (e.response != null && e.response.needRetry())) {\n+                    shouldRetry = true;\n+                } else {\n+                    throw e;\n+                }\n+            }\n+\n+            // 判断是否需要重试\n+            if (!shouldRetry && (response == null || response.needRetry())) {\n+                System.out.println(\"== Exception response data:\" + (response != null ? response.bodyString() : \"\"));\n+                shouldRetry = true;\n+            }\n+\n+            retryCount++;\n+\n+            if (!shouldRetry) {\n+                break;\n+            }\n+\n+            if (retryCount >= config.retryMax) {\n+                throw QiniuException.unrecoverable(\"failed after retry times\");\n+            }\n+        } while (true);\n+\n+        return response;\n+    }\n+\n+    interface UploadAction {\n+        Response uploadAction(String host) throws QiniuException;\n+    }\n+\n+}"
  },
  {
    "sha": "48816a6cb56169403cc4dc2d734f562c3c548be8",
    "filename": "src/main/java/com/qiniu/storage/ResumeUploadPerformerV1.java",
    "status": "added",
    "additions": 130,
    "deletions": 0,
    "changes": 130,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ResumeUploadPerformerV1.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ResumeUploadPerformerV1.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/storage/ResumeUploadPerformerV1.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -0,0 +1,130 @@\n+package com.qiniu.storage;\n+\n+import com.qiniu.common.QiniuException;\n+import com.qiniu.http.Client;\n+import com.qiniu.http.Response;\n+import com.qiniu.util.Crc32;\n+import com.qiniu.util.StringMap;\n+import com.qiniu.util.StringUtils;\n+import com.qiniu.util.UrlSafeBase64;\n+\n+class ResumeUploadPerformerV1 extends ResumeUploadPerformer {\n+\n+\n+    ResumeUploadPerformerV1(Client client, String key, UploadToken token, ResumeUploadSource source, Recorder recorder,\n+                            UploadOptions options, Configuration config) {\n+        super(client, key, token, source, recorder, options, config);\n+    }\n+\n+    @Override\n+    boolean shouldInit() {\n+        return false;\n+    }\n+\n+    @Override\n+    Response uploadInit() throws QiniuException {\n+        return null;\n+    }\n+\n+    @Override\n+    Response uploadBlock(final ResumeUploadSource.Block block) throws QiniuException {\n+        return retryUploadAction(new UploadAction() {\n+            @Override\n+            public Response uploadAction(String host) throws QiniuException {\n+                return makeBlock(host, block);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    Response completeUpload() throws QiniuException {\n+        return retryUploadAction(new UploadAction() {\n+            @Override\n+            public Response uploadAction(String host) throws QiniuException {\n+                return makeFile(host, uploadSource.getFileName());\n+            }\n+        });\n+    }\n+\n+    private Response makeBlock(String host, ResumeUploadSource.Block block) throws QiniuException {\n+        String action = String.format(\"/mkblk/%d\", block.size);\n+        String url = host + action;\n+\n+        Response response = post(url, block.data, 0, block.size);\n+\n+        System.out.printf(\"== make block:%d upload :%s \\n\", block.index, response);\n+\n+        if (response.isOK()) {\n+\n+            StringMap jsonMap = response.jsonToMap();\n+            if (jsonMap == null) {\n+                throw new QiniuException(new Exception(\"block's info is empty\"));\n+            }\n+\n+            if (options.checkCrc) {\n+                if (jsonMap.get(\"crc\") == null) {\n+                    throw new QiniuException(new Exception(\"block's crc32 is empty\"));\n+                }\n+\n+                long crc = Crc32.bytes(block.data, 0, block.size);\n+                long serverCrc = new Long(jsonMap.get(\"crc\").toString());\n+                if ((long) serverCrc != crc) {\n+                    throw new QiniuException(new Exception(\"block's crc32 is not match\"));\n+                }\n+            }\n+\n+            if (jsonMap.get(\"ctx\") == null) {\n+                throw new QiniuException(new Exception(\"block's ctx is empty\"));\n+            }\n+            block.context = jsonMap.get(\"ctx\").toString();\n+            block.data = null;\n+        }\n+        return response;\n+    }\n+\n+    private Response makeFile(String host, String fileName) throws QiniuException {\n+        String[] contexts = uploadSource.getAllBlockContextList();\n+        String action = String.format(\"/mkfile/%s/mimeType/%s\", uploadSource.getSize(),\n+                UrlSafeBase64.encodeToString(options.mimeType));\n+        if (!StringUtils.isNullOrEmpty(fileName)) {\n+            action = String.format(\"%s/fname/%s\", action, UrlSafeBase64.encodeToString(fileName));\n+        }\n+\n+        String url = host + action;\n+\n+        final StringBuilder b = new StringBuilder(url);\n+        if (key != null) {\n+            b.append(\"/key/\");\n+            b.append(UrlSafeBase64.encodeToString(key));\n+        }\n+\n+        if (options.params != null) {\n+            options.params.forEach(new StringMap.Consumer() {\n+                @Override\n+                public void accept(String key, Object value) {\n+                    b.append(\"/\");\n+                    b.append(key);\n+                    b.append(\"/\");\n+                    b.append(UrlSafeBase64.encodeToString(\"\" + value));\n+                }\n+            });\n+        }\n+\n+        if (options.metaDataParam != null) {\n+            options.metaDataParam.forEach(new StringMap.Consumer() {\n+                @Override\n+                public void accept(String key, Object value) {\n+                    b.append(\"/\");\n+                    b.append(key);\n+                    b.append(\"/\");\n+                    b.append(UrlSafeBase64.encodeToString(\"\" + value));\n+                }\n+            });\n+        }\n+\n+        url = b.toString();\n+        String s = StringUtils.join(contexts, \",\");\n+        byte[] data = StringUtils.utf8Bytes(s);\n+        return post(url, StringUtils.utf8Bytes(s), (int) 0, data.length);\n+    }\n+}"
  },
  {
    "sha": "18a3df5a41474b1859ccb31e644a96c63a69fe58",
    "filename": "src/main/java/com/qiniu/storage/ResumeUploadPerformerV2.java",
    "status": "added",
    "additions": 168,
    "deletions": 0,
    "changes": 168,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ResumeUploadPerformerV2.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ResumeUploadPerformerV2.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/storage/ResumeUploadPerformerV2.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -0,0 +1,168 @@\n+package com.qiniu.storage;\n+\n+import com.qiniu.common.QiniuException;\n+import com.qiniu.http.Client;\n+import com.qiniu.http.Response;\n+import com.qiniu.util.*;\n+\n+import java.util.*;\n+\n+\n+class ResumeUploadPerformerV2 extends ResumeUploadPerformer {\n+\n+    ResumeUploadPerformerV2(Client client, String key, UploadToken token, ResumeUploadSource source, Recorder recorder,\n+                            UploadOptions options, Configuration config) {\n+        super(client, key, token, source, recorder, options, config);\n+    }\n+\n+    @Override\n+    boolean shouldInit() {\n+        // 包含 uploadId 且有效\n+        if (StringUtils.isNullOrEmpty(uploadSource.uploadId)) {\n+            return true;\n+        }\n+\n+        // 服务端是 7 天，此处有效期少 3 天，为 4 天\n+        long currentTimestamp = new Date().getTime() / 1000;\n+        long expireAtTimestamp = uploadSource.expireAt - 24 * 3600 * 3;\n+        return expireAtTimestamp < currentTimestamp;\n+    }\n+\n+    @Override\n+    Response uploadInit() throws QiniuException {\n+        return retryUploadAction(new UploadAction() {\n+            @Override\n+            public Response uploadAction(String host) throws QiniuException {\n+                return initPart(host);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    Response uploadBlock(final ResumeUploadSource.Block block) throws QiniuException {\n+        return retryUploadAction(new UploadAction() {\n+            @Override\n+            public Response uploadAction(String host) throws QiniuException {\n+                return uploadPart(host, block);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    Response completeUpload() throws QiniuException {\n+        return retryUploadAction(new UploadAction() {\n+            @Override\n+            public Response uploadAction(String host) throws QiniuException {\n+                return completeParts(host);\n+            }\n+        });\n+    }\n+\n+    private Response initPart(String host) throws QiniuException {\n+        String action = String.format(Locale.ENGLISH, \"/buckets/%s/objects/%s/uploads\", this.token.getBucket(), resumeV2EncodeKey(key));\n+        String url = host + action;\n+        Response response = post(url, new byte[0], 0, 0);\n+        if (response != null && response.isOK()) {\n+\n+            StringMap jsonMap = response.jsonToMap();\n+            if (jsonMap == null) {\n+                throw new QiniuException(new Exception(\"upload's info is empty\"));\n+            }\n+\n+            String uploadId = jsonMap.get(\"uploadId\").toString();\n+            Object expireAt = jsonMap.get(\"expireAt\");\n+            if (uploadId == null || expireAt == null) {\n+                throw new QiniuException(new Exception(\"uploadId or expireAt is empty\"));\n+            }\n+            uploadSource.uploadId = uploadId;\n+            if (expireAt instanceof Double) {\n+                uploadSource.expireAt = ((Double) expireAt).longValue();\n+            } else if (expireAt instanceof Integer) {\n+                uploadSource.expireAt = ((Integer) expireAt).longValue();\n+            } else if (expireAt instanceof Long) {\n+                uploadSource.expireAt = (Long) expireAt;\n+            } else {\n+                uploadSource.expireAt = new Date().getTime() / 1000;\n+            }\n+        }\n+        return response;\n+    }\n+\n+    private Response uploadPart(String host, ResumeUploadSource.Block block) throws QiniuException {\n+        String uploadId = uploadSource.uploadId;\n+        int partIndex = block.index + 1;\n+        String action = String.format(\"/buckets/%s/objects/%s/uploads/%s/%d\", token.getBucket(), resumeV2EncodeKey(key), uploadId, partIndex);\n+        String url = host + action;\n+        Response response = put(url, block.data, 0, block.size);\n+\n+        if (response != null && response.isOK()) {\n+\n+            StringMap jsonMap = response.jsonToMap();\n+            if (jsonMap == null) {\n+                throw new QiniuException(new Exception(\"block's info is empty\"));\n+            }\n+\n+            if (options.checkCrc) {\n+                if (jsonMap.get(\"md5\") == null) {\n+                    throw new QiniuException(new Exception(\"block's md5 is empty\"));\n+                }\n+\n+                String md5 = Md5.md5(block.data);\n+                String serverMd5 = jsonMap.get(\"md5\").toString();\n+                if (!serverMd5.equals(md5)) {\n+                    throw new QiniuException(new Exception(\"block's md5 is not match\"));\n+                }\n+            }\n+\n+            if (jsonMap.get(\"etag\") == null) {\n+                throw new QiniuException(new Exception(\"block's etag is empty\"));\n+            }\n+            block.etag = jsonMap.get(\"etag\").toString();\n+            block.data = null;\n+        }\n+\n+        return response;\n+    }\n+\n+    private Response completeParts(String host) throws QiniuException {\n+\n+        List<Map<String, Object>> partInfoArray = uploadSource.getPartInfo();\n+        String uploadId = uploadSource.uploadId;\n+\n+        String action = String.format(\"/buckets/%s/objects/%s/uploads/%s\", token.getBucket(), resumeV2EncodeKey(key), uploadId);\n+        String url = host + action;\n+\n+        HashMap<String, Object> bodyMap = new HashMap<>();\n+        if (partInfoArray != null) {\n+            bodyMap.put(\"parts\", partInfoArray);\n+        }\n+        if (uploadSource.getFileName() != null) {\n+            bodyMap.put(\"fname\", uploadSource.getFileName());\n+        }\n+        if (options.mimeType != null) {\n+            bodyMap.put(\"mimeType\", options.mimeType);\n+        }\n+        if (options.params != null) {\n+            bodyMap.put(\"customVars\", options.params.map());\n+        }\n+        if (options.metaDataParam != null) {\n+            bodyMap.put(\"metaData\", options.metaDataParam.map());\n+        }\n+\n+        String bodyString = Json.encode(bodyMap);\n+        byte[] body = bodyString.getBytes();\n+        return post(url, body, 0, body.length);\n+    }\n+\n+    private String resumeV2EncodeKey(String key) {\n+        String encodeKey = null;\n+        if (key == null) {\n+            encodeKey = \"~\";\n+        } else if (key.equals(\"\")) {\n+            encodeKey = \"\";\n+        } else {\n+            encodeKey = UrlSafeBase64.encodeToString(key);\n+        }\n+        return encodeKey;\n+    }\n+}"
  },
  {
    "sha": "1ff5d9da34ab58a417eca5bcb971f1f9cbf76121",
    "filename": "src/main/java/com/qiniu/storage/ResumeUploadSource.java",
    "status": "added",
    "additions": 187,
    "deletions": 0,
    "changes": 187,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ResumeUploadSource.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ResumeUploadSource.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/storage/ResumeUploadSource.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -0,0 +1,187 @@\n+package com.qiniu.storage;\n+\n+import com.qiniu.common.Constants;\n+import com.qiniu.util.StringUtils;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+abstract class ResumeUploadSource {\n+\n+    final String recordKey;\n+    final int blockSize;\n+    final String targetRegionId;\n+    final Configuration.ResumeVersion resumeVersion;\n+\n+    transient Configuration config;\n+\n+    List<Block> blockList;\n+    // uploadId: 此次文件上传唯一标识 【resume v2 特有】\n+    String uploadId;\n+    // expireAt: uploadId 有效期， 单位：秒 【resume v2 特有】\n+    Long expireAt;\n+\n+    ResumeUploadSource() {\n+        this.targetRegionId = null;\n+        this.blockSize = 0;\n+        this.recordKey = null;\n+        this.resumeVersion = Configuration.ResumeVersion.V1;\n+    }\n+\n+    ResumeUploadSource(Configuration config, String recordKey, String targetRegionId) {\n+        this.config = config;\n+        this.blockSize = getBlockSize(config);\n+        this.recordKey = recordKey;\n+        this.targetRegionId = targetRegionId;\n+        this.resumeVersion = config.resumeVersion;\n+    }\n+\n+    // 所有块数据是否 正在上传 或者 已上传，为 true 则说明没有需要上传的数据块\n+    boolean isAllBlocksUploadingOrUploaded() {\n+        if (blockList == null || blockList.size() == 0) {\n+            return true;\n+        }\n+\n+        boolean isAllBlockUploadingOrUploaded = true;\n+        for (ResumeUploadSource.Block block : blockList) {\n+            if (!block.isUploading && !block.isUploaded()) {\n+                isAllBlockUploadingOrUploaded = false;\n+                break;\n+            }\n+        }\n+        return isAllBlockUploadingOrUploaded;\n+    }\n+\n+    boolean isAllBlocksUploaded() {\n+        if (blockList == null || blockList.size() == 0) {\n+            return true;\n+        }\n+\n+        boolean isAllBlockUploaded = true;\n+        for (ResumeUploadSource.Block block : blockList) {\n+            if (!block.isUploaded()) {\n+                isAllBlockUploaded = false;\n+                break;\n+            }\n+        }\n+        return isAllBlockUploaded;\n+    }\n+\n+    // 获取下一个需要上传的块\n+    ResumeUploadSource.Block getNextUploadingBlock() throws IOException {\n+        ResumeUploadSource.Block block = null;\n+        for (ResumeUploadSource.Block blockP : blockList) {\n+            if (!blockP.isUploading && !blockP.isUploaded()) {\n+                block = blockP;\n+                break;\n+            }\n+        }\n+        return block;\n+    }\n+\n+    // 关闭数据流\n+    abstract void close() throws IOException;\n+\n+    // 是否为有效源文件\n+    abstract boolean isValid();\n+\n+    // 获取资源大小\n+    abstract long getSize();\n+\n+    // 获取文件名\n+    abstract String getFileName();\n+\n+    boolean recoverFromRecordInfo(ResumeUploadSource source) {\n+        return false;\n+    }\n+\n+    int getBlockSize(Configuration config) {\n+        if (resumeVersion == Configuration.ResumeVersion.V2) {\n+            return config.resumeV2BlockSize;\n+        } else {\n+            return Constants.BLOCK_SIZE;\n+        }\n+    }\n+\n+    // 分片 V1 make file 使用\n+    String[] getAllBlockContextList() {\n+        String[] contextList = new String[blockList.size()];\n+        for (int i = 0; i < blockList.size(); i++) {\n+            Block block = blockList.get(i);\n+            if (block.context != null) {\n+                contextList[i] = block.context;\n+            }\n+        }\n+        return contextList;\n+    }\n+\n+    // 分片 V2 complete upload 使用\n+    List<Map<String, Object>> getPartInfo() {\n+\n+        // 排序\n+        Collections.sort(blockList, new Comparator<Block>() {\n+            @Override\n+            public int compare(Block o1, Block o2) {\n+                return o1.index - o2.index; // small enough and both greater than 0 //\n+            }\n+        });\n+\n+        List<Map<String, Object>> partInfo = new ArrayList<>();\n+        for (int i = 0; i < blockList.size(); i++) {\n+            Block block = blockList.get(i);\n+            Map<String, Object> part = new HashMap<>();\n+            if (block.etag != null) {\n+                part.put(\"partNumber\", block.index + 1);\n+                part.put(\"etag\", block.etag);\n+            }\n+            partInfo.add(part);\n+        }\n+        return partInfo;\n+    }\n+\n+    static class Block {\n+        final int index;\n+        final long offset;\n+        final Configuration.ResumeVersion resumeVersion;\n+\n+        int size;\n+\n+        transient byte[] data;\n+        transient boolean isUploading;\n+\n+        // context: 块上传上下文信息 【resume v1 特有】\n+        String context;\n+        // etag: 块etag【resume v2 特有】\n+        String etag;\n+\n+        Block() {\n+            this.offset = 0;\n+            this.index = 0;\n+            this.resumeVersion = Configuration.ResumeVersion.V1;\n+        }\n+\n+        Block(Configuration config, long offset, int blockSize, int index) {\n+            this.resumeVersion = config.resumeVersion;\n+            this.offset = offset;\n+            this.size = blockSize;\n+            this.index = index;\n+            this.isUploading = false;\n+            this.etag = null;\n+            this.context = null;\n+        }\n+\n+        boolean isUploaded() {\n+            boolean isUploaded = false;\n+            if (resumeVersion == Configuration.ResumeVersion.V1) {\n+                if (!StringUtils.isNullOrEmpty(context)) {\n+                    isUploaded = true;\n+                }\n+            } else {\n+                if (!StringUtils.isNullOrEmpty(etag)) {\n+                    isUploaded = true;\n+                }\n+            }\n+            return isUploaded;\n+        }\n+    }\n+}"
  },
  {
    "sha": "ecb55870c93c5dfc40e4f152c48895e9a96c5a4f",
    "filename": "src/main/java/com/qiniu/storage/ResumeUploadSourceFile.java",
    "status": "added",
    "additions": 122,
    "deletions": 0,
    "changes": 122,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ResumeUploadSourceFile.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ResumeUploadSourceFile.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/storage/ResumeUploadSourceFile.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -0,0 +1,122 @@\n+package com.qiniu.storage;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.ArrayList;\n+\n+class ResumeUploadSourceFile extends ResumeUploadSource {\n+\n+    private final long size;\n+    private final String fileName;\n+    private transient final File file;\n+    private transient RandomAccessFile randomAccessFile;\n+\n+    ResumeUploadSourceFile(File file, Configuration config, String recordKey, String targetRegionId) {\n+        super(config, recordKey, targetRegionId);\n+        this.file = file;\n+        this.fileName = file.getName();\n+        this.size = file.length();\n+        createBlockList(config, size, blockSize);\n+    }\n+\n+    private void createBlockList(Configuration config, long fileSize, int blockSize) {\n+        blockList = new ArrayList<>();\n+        long offset = 0;\n+        int blockIndex = 0;\n+        while (offset < fileSize) {\n+            int lastSize = (int) (fileSize - offset);\n+            int blockSizeP = Math.min(lastSize, blockSize);\n+            Block block = new Block(config, offset, blockSizeP, blockIndex);\n+            blockList.add(block);\n+            offset += blockSizeP;\n+            blockIndex += 1;\n+        }\n+    }\n+\n+    @Override\n+    boolean isValid() {\n+        return file != null && file.canRead();\n+    }\n+\n+    @Override\n+    public long getSize() {\n+        return size;\n+    }\n+\n+    @Override\n+    String getFileName() {\n+        return fileName;\n+    }\n+\n+    @Override\n+    ResumeUploadSource.Block getNextUploadingBlock() throws IOException {\n+        ResumeUploadSource.Block block = super.getNextUploadingBlock();\n+        if (block != null && block.data == null) {\n+            setBlockData(block);\n+        }\n+        return block;\n+    }\n+\n+    private void setBlockData(ResumeUploadSource.Block block) throws IOException {\n+\n+        int readSize = 0;\n+        byte[] buffer = new byte[block.size];\n+\n+        RandomAccessFile randomAccessFile = getRandomAccessFile();\n+        randomAccessFile.seek(block.offset);\n+\n+        while (readSize != block.size) {\n+            int ret = randomAccessFile.read(buffer, 0, block.size);\n+            if (ret < 0) {\n+                break;\n+            }\n+            readSize += ret;\n+        }\n+\n+        if (readSize < block.size) {\n+            throw new IOException(\"read file data error\");\n+        }\n+\n+        block.data = buffer;\n+    }\n+\n+    private RandomAccessFile getRandomAccessFile() throws IOException {\n+        if (randomAccessFile == null && file != null) {\n+            randomAccessFile = new RandomAccessFile(file, \"r\");\n+        }\n+        return randomAccessFile;\n+    }\n+\n+    @Override\n+    boolean recoverFromRecordInfo(ResumeUploadSource source) {\n+        if (!isSameResource(source)) {\n+            return false;\n+        }\n+        uploadId = source.uploadId;\n+        expireAt = source.expireAt;\n+        blockList = source.blockList;\n+        return true;\n+    }\n+\n+    private boolean isSameResource(ResumeUploadSource source) {\n+        if (!(source instanceof ResumeUploadSourceFile)) {\n+            return false;\n+        }\n+\n+        ResumeUploadSourceFile sourceFile = (ResumeUploadSourceFile) source;\n+        return sourceFile.recordKey != null && sourceFile.recordKey.equals(recordKey) &&\n+                sourceFile.size == size && sourceFile.blockSize == blockSize &&\n+                sourceFile.blockList != null && sourceFile.blockList.size() > 0 &&\n+                sourceFile.getFileName() != null && sourceFile.getFileName().equals(getFileName()) &&\n+                sourceFile.targetRegionId != null && sourceFile.targetRegionId.equals(targetRegionId) &&\n+                sourceFile.resumeVersion == resumeVersion;\n+    }\n+\n+    @Override\n+    void close() throws IOException {\n+        if (randomAccessFile != null) {\n+            randomAccessFile.close();\n+        }\n+    }\n+}"
  },
  {
    "sha": "aad7dbb6ca9d8d8d3cb3aafaa5573a9f8159a3ed",
    "filename": "src/main/java/com/qiniu/storage/ResumeUploadSourceStream.java",
    "status": "added",
    "additions": 116,
    "deletions": 0,
    "changes": 116,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ResumeUploadSourceStream.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ResumeUploadSourceStream.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/storage/ResumeUploadSourceStream.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -0,0 +1,116 @@\n+package com.qiniu.storage;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.LinkedList;\n+\n+public class ResumeUploadSourceStream extends ResumeUploadSource {\n+\n+    private long readOffset = 0;\n+    private boolean isAllDataRead;\n+    private final InputStream inputStream;\n+    private final String fileName;\n+\n+    ResumeUploadSourceStream(InputStream inputStream, Configuration config, String recordKey, String targetRegionId, String fileName) {\n+        super(config, recordKey, targetRegionId);\n+        this.inputStream = inputStream;\n+        this.fileName = fileName;\n+        this.blockList = new LinkedList<>();\n+    }\n+\n+    @Override\n+    boolean isAllBlocksUploadingOrUploaded() {\n+        if (!isAllDataRead) {\n+            return false;\n+        }\n+        return super.isAllBlocksUploadingOrUploaded();\n+    }\n+\n+    @Override\n+    boolean isAllBlocksUploaded() {\n+        if (!isAllDataRead) {\n+            return false;\n+        }\n+        return super.isAllBlocksUploaded();\n+    }\n+\n+    @Override\n+    Block getNextUploadingBlock() throws IOException {\n+        ResumeUploadSource.Block block = super.getNextUploadingBlock();\n+        if (block != null) {\n+            return block;\n+        }\n+\n+        block = new Block(config, readOffset, getBlockSize(config), blockList.size());\n+        block.data = getBlockData(block);\n+        if (block.size == 0) {\n+            return null;\n+        }\n+\n+        blockList.add(block);\n+        return block;\n+    }\n+\n+    @Override\n+    void close() throws IOException {\n+        if (inputStream != null) {\n+            inputStream.close();\n+        }\n+    }\n+\n+    @Override\n+    boolean isValid() {\n+        return inputStream != null;\n+    }\n+\n+    /// 只有数据流读取结束才有效，即 isAllBlocksUploaded() 为 true 时值有效\n+    @Override\n+    long getSize() {\n+        return readOffset;\n+    }\n+\n+    @Override\n+    String getFileName() {\n+        return fileName;\n+    }\n+\n+    private byte[] getBlockData(ResumeUploadSource.Block block) throws IOException {\n+        if (block.data != null) {\n+            return block.data;\n+        }\n+\n+        byte[] buffer = null;\n+        synchronized (this) {\n+            while (true) {\n+                if (readOffset == block.offset) {\n+                    int readSize = 0;\n+                    buffer = new byte[block.size];\n+                    while (readSize < block.size) {\n+                        int ret = inputStream.read(buffer, readSize, block.size - readSize);\n+\n+                        if (ret < 0) {\n+                            isAllDataRead = true;\n+                            break;\n+                        }\n+\n+                        readSize += ret;\n+\n+                        try {\n+                            Thread.sleep(50);\n+                        } catch (InterruptedException ignored) {\n+                        }\n+                    }\n+                    block.data = buffer;\n+                    block.size = readSize;\n+                    readOffset += readSize;\n+                    break;\n+                } else if (readOffset < block.offset) {\n+                    readOffset += inputStream.skip(block.offset - readOffset);\n+                } else {\n+                    throw new IOException(\"read block data error\");\n+                }\n+            }\n+        }\n+        return buffer;\n+    }\n+}"
  },
  {
    "sha": "e832a1aace9c1c09183541c7b5940163d417a393",
    "filename": "src/main/java/com/qiniu/storage/ResumeUploader.java",
    "status": "modified",
    "additions": 184,
    "deletions": 256,
    "changes": 440,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ResumeUploader.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/ResumeUploader.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/storage/ResumeUploader.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -1,331 +1,259 @@\n package com.qiniu.storage;\n \n-import com.google.gson.Gson;\n-import com.qiniu.common.Constants;\n import com.qiniu.common.QiniuException;\n import com.qiniu.http.Client;\n import com.qiniu.http.Response;\n-import com.qiniu.storage.model.ResumeBlockInfo;\n-import com.qiniu.util.Crc32;\n import com.qiniu.util.StringMap;\n-import com.qiniu.util.StringUtils;\n-import com.qiniu.util.UrlSafeBase64;\n \n import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-\n+import java.io.InputStream;\n \n /**\n- * 分片上传\n- * 参考文档：<a href=\"http://developer.qiniu.com/docs/v6/api/overview/up/chunked-upload.html\">分片上传</a>\n+ * 同步分片上传\n+ * <p>\n+ * 分片上传 v1\n+ * 参考文档：<a href=\"https://developer.qiniu.com/kodo/7443/shard-to-upload\">分片上传</a>\n  * <p/>\n- * 分片上传通过将一个文件分割为固定大小的块(4M)，每次上传一个块的内容（服务端只分块，没有分片）。\n+ * 上传通过将一个文件分割为固定大小的块(4M)，每次上传一个块的内容（服务端只分块，没有分片）。\n  * 等待所有块都上传完成之后，再将这些块拼接起来，构成一个完整的文件。\n+ * <p/>\n+ * <p>\n+ * 分片上传 v2\n+ * 参考文档：<a href=\"https://developer.qiniu.com/kodo/6364/multipartupload-interface\">分片上传</a>\n+ * <p/>\n+ * 上传通过将一个文件分割为固定大小的块(大小可配置，通过 Configuration.resumeV2BlockSize)，每次上传一个块的内容。\n+ * 等待所有块都上传完成之后，再将这些块拼接起来，构成一个完整的文件。\n+ * <p/>\n+ * <p>\n  * 另外分片上传还支持纪录上传进度，如果本次上传被暂停，那么下次还可以从上次\n  * 上次完成的文件偏移位置，继续开始上传，这样就实现了断点续传功能。\n- * <p/>\n+ * <p>\n  * 服务端网络较稳定，较大文件（如500M以上）才需要将块记录保存下来。\n  * 小文件没有必要，可以有效地实现大文件的上传。\n  */\n-public final class ResumeUploader {\n-    private final String upToken;\n-    private final String key;\n-    private final File f;\n-    private final long size;\n-    private final StringMap params;\n-    private final String mime;\n-    private final String[] contexts;\n-    private final ConfigHelper configHelper;\n+public class ResumeUploader {\n     private final Client client;\n-    private final byte[] blockBuffer;\n+    private final String key;\n+    private final String upToken;\n+    private final ResumeUploadSource source;\n     private final Recorder recorder;\n-    private final long modifyTime;\n-    private final RecordHelper helper;\n-    private FileInputStream file;\n-    private String host = null;\n-    private int retryMax;\n+    private final UploadOptions options;\n+\n+    final Configuration config;\n+\n+    ResumeUploadPerformer uploadPerformer;\n \n     /**\n-     * 构建分片上传文件的对象\n+     * 构建分片上传文件的对象【兼容老版本】\n+     * 分片上传时，每个上传操作会占用 blockSize 大小内存，blockSize 也即分片大小，\n+     * 在分片 v1 中 blockSize 为 4M；\n+     * 分片 v2 可自定义 blockSize，定义方式为：Configuration.resumeV2BlockSize，范围为：1M ~ 1GB，分片 v2 需要注意每个文件最大分片数量为 10000；\n+     * <p>\n+     * 支持分片上传 v1/v2，支持断点续传\n+     * 不支持并发【并发使用 ConcurrentResumeUploader】\n+     *\n+     * @param client        上传 client【必须】\n+     * @param upToken       上传凭证【必须】\n+     * @param key           文件保存名称【可选】\n+     * @param file          文件【必须】\n+     * @param params        自定义参数【可选】\n+     *                      自定义文件 metadata 信息，key 需要增加前缀 x-qn-meta- ：如 params.put(\"x-qn-meta-key\", \"foo\")\n+     *                      用户自定义变量，key 需要增加前缀 x: ：如 params.put(\"x:foo\", \"foo\")\n+     * @param mime          文件 mime type【可选】\n+     * @param recorder      断点续传信息记录对象【可选】\n+     * @param configuration 上传配置信息【必须】\n      */\n     public ResumeUploader(Client client, String upToken, String key, File file,\n                           StringMap params, String mime, Recorder recorder, Configuration configuration) {\n-        this.configHelper = new ConfigHelper(configuration);\n+        this(client, key, upToken,\n+                new ResumeUploadSourceFile(file, configuration, getRecorderKey(key, file, recorder), getRegionTargetId(upToken, configuration)),\n+                recorder, new UploadOptions.Builder().params(params).metaData(params).mimeType(mime).build(), configuration);\n+    }\n+\n+    /**\n+     * 构建分片上传文件流的对象【兼容老版本】\n+     * 分片上传时，每个上传操作会占用 blockSize 大小内存，blockSize 也即分片大小，\n+     * 在分片 v1 中 blockSize 为 4M；\n+     * 分片 v2 可自定义 blockSize，定义方式为：Configuration.resumeV2BlockSize，范围为：1M ~ 1GB，分片 v2 需要注意每个文件最大分片数量为 10000；\n+     * <p>\n+     * 支持分片上传 v1/v2，支持并发\n+     * 不支持断点续传，不支持定义file name，不支持并发【并发使用 ConcurrentResumeUploader】\n+     *\n+     * @param client        上传 client 【必须】\n+     * @param upToken       上传凭证 【必须】\n+     * @param key           文件保存名称 【可选】\n+     * @param stream        文件流 【必须】\n+     * @param params        自定义参数【可选】\n+     *                      自定义文件 metadata 信息，key 需要增加前缀 x-qn-meta- ：如 params.put(\"x-qn-meta-key\", \"foo\")\n+     *                      用户自定义变量，key 需要增加前缀 x: ：如 params.put(\"x:foo\", \"foo\")\n+     * @param mime          文件 mime type【可选】\n+     * @param configuration 上传配置信息 【必须】\n+     */\n+    public ResumeUploader(Client client, String upToken, String key, InputStream stream,\n+                          StringMap params, String mime, Configuration configuration) {\n+        this(client, upToken, key, stream, null, params, mime, configuration);\n+    }\n+\n+    /**\n+     * 构建分片上传文件流的对象\n+     * 分片上传时，每个上传操作会占用 blockSize 大小内存，blockSize 也即分片大小，\n+     * 在分片 v1 中 blockSize 为 4M；\n+     * 分片 v2 可自定义 blockSize，定义方式为：Configuration.resumeV2BlockSize，范围为：1M ~ 1GB，分片 v2 需要注意每个文件最大分片数量为 10000；\n+     * <p>\n+     * 支持分片上传 v1/v2，支持并发，支持定义file name\n+     * 不支持断点续传，不支持并发【并发使用 ConcurrentResumeUploader】\n+     *\n+     * @param client        上传 client 【必须】\n+     * @param upToken       上传凭证 【必须】\n+     * @param key           文件保存名称 【可选】\n+     * @param stream        文件流 【必须】\n+     * @param fileName      文件名 【可选】\n+     * @param params        自定义参数【可选】\n+     *                      自定义文件 metadata 信息，key 需要增加前缀 x-qn-meta- ：如 params.put(\"x-qn-meta-key\", \"foo\")\n+     *                      用户自定义变量，key 需要增加前缀 x: ：如 params.put(\"x:foo\", \"foo\")\n+     * @param mime          文件 mime type 【可选】\n+     * @param configuration 上传配置信息 【必须】\n+     */\n+    public ResumeUploader(Client client, String upToken, String key, InputStream stream,\n+                          String fileName, StringMap params, String mime, Configuration configuration) {\n+        this(client, key, upToken,\n+                new ResumeUploadSourceStream(stream, configuration, null, getRegionTargetId(upToken, configuration), fileName),\n+                null, new UploadOptions.Builder().params(params).metaData(params).mimeType(mime).build(), configuration);\n+    }\n+\n+    private ResumeUploader(Client client, String key, String upToken, ResumeUploadSource source, Recorder recorder,\n+                           UploadOptions options, Configuration configuration) {\n+\n         this.client = client;\n-        this.upToken = upToken;\n         this.key = key;\n-        this.f = file;\n-        this.size = file.length();\n-        this.params = params;\n-        this.mime = mime == null ? Client.DefaultMime : mime;\n-        long count = (size + Constants.BLOCK_SIZE - 1) / Constants.BLOCK_SIZE;\n-        this.contexts = new String[(int) count];\n-        this.blockBuffer = new byte[Constants.BLOCK_SIZE];\n+        this.upToken = upToken;\n+        this.source = source;\n         this.recorder = recorder;\n-        this.modifyTime = f.lastModified();\n-        helper = new RecordHelper();\n-        retryMax = configuration.retryMax;\n+        this.options = options == null ? UploadOptions.defaultOptions() : options;\n+        this.config = configuration;\n     }\n \n     /**\n-     * 同步上传文件\n+     * 上传文件\n      */\n     public Response upload() throws QiniuException {\n         try {\n-            return upload0();\n+            return _upload();\n         } finally {\n             close();\n         }\n     }\n \n-    private Response upload0() throws QiniuException {\n-        if (host == null) {\n-            this.host = configHelper.upHost(upToken);\n-        }\n-        long uploaded = helper.recoveryFromRecord();\n-        try {\n-            this.file = new FileInputStream(f);\n-        } catch (FileNotFoundException e) {\n-            throw new QiniuException(e);\n-        }\n-        boolean retry = false;\n-        int contextIndex = blockIdx(uploaded);\n-        try {\n-            file.skip(uploaded);\n-        } catch (IOException e) {\n-            close();\n-            throw new QiniuException(e);\n-        }\n-        while (uploaded < size) {\n-            int blockSize = nextBlockSize(uploaded);\n-            try {\n-                file.read(blockBuffer, 0, blockSize);\n-            } catch (IOException e) {\n-                close();\n-                throw new QiniuException(e);\n-            }\n-\n-            long crc = Crc32.bytes(blockBuffer, 0, blockSize);\n-            Response response = null;\n-            QiniuException temp = null;\n-            try {\n-                response = makeBlock(blockBuffer, blockSize);\n-            } catch (QiniuException e) {\n-                if (e.code() < 0 || (e.response != null && e.response.needSwitchServer())) {\n-                    changeHost(upToken, host);\n-                }\n-                if (e.response == null || e.response.needRetry()) {\n-                    retry = true;\n-                    temp = e;\n-                } else {\n-                    close();\n-                    throw e;\n-                }\n-            }\n+    private Response _upload() throws QiniuException {\n+        // 检查参数\n+        checkParam();\n \n-            if (!retry) {\n-                ResumeBlockInfo blockInfo0 = response.jsonToObject(ResumeBlockInfo.class);\n-                if (blockInfo0.crc32 != crc) {\n-                    retry = true;\n-                    temp = new QiniuException(new Exception(\"block's crc32 is not match\"));\n-                }\n-            }\n+        // 选择上传策略\n+        UploadToken token = new UploadToken(upToken);\n+        if (config.resumeVersion == Configuration.ResumeVersion.V2) {\n+            uploadPerformer = new ResumeUploadPerformerV2(client, key, token, source, recorder, options, config);\n+        } else {\n+            uploadPerformer = new ResumeUploadPerformerV1(client, key, token, source, recorder, options, config);\n+        }\n \n-            if (retry) {\n-                if (retryMax > 0) {\n-                    retryMax--;\n-                    try {\n-                        response = makeBlock(blockBuffer, blockSize);\n-                        retry = false;\n-                    } catch (QiniuException e) {\n-                        close();\n-                        throw e;\n-                    }\n-                } else {\n-                    close();\n-                    throw temp;\n-                }\n-            }\n+        // 恢复本地断点续传数据\n+        uploadPerformer.recoverUploadProgressFromLocal();\n \n-            ResumeBlockInfo blockInfo = response.jsonToObject(ResumeBlockInfo.class);\n-            if (blockInfo.crc32 != crc) {\n-                throw new QiniuException(new Exception(\"block's crc32 is not match\"));\n+        // 上传数据至服务 - 步骤1\n+        System.out.println(\"上传步骤 1: 开始\");\n+        Response response = null;\n+        if (uploadPerformer.shouldInit()) {\n+            response = uploadPerformer.uploadInit();\n+            if (!response.isOK()) {\n+                return response;\n             }\n-            contexts[contextIndex++] = blockInfo.ctx;\n-            uploaded += blockSize;\n-            helper.record(uploaded);\n         }\n-        close();\n-\n-        try {\n-            return makeFile();\n-        } catch (QiniuException e) {\n-            try {\n-                return makeFile();\n-            } catch (QiniuException e1) {\n-                throw e1;\n+        System.out.printf(\"上传步骤 1: 结束 %s \\n\", response);\n+\n+        // 上传数据至服务 - 步骤2\n+        System.out.println(\"上传步骤 2: 开始\");\n+        if (!uploadPerformer.isAllBlocksUploaded()) {\n+            response = uploadData();\n+            if (!response.isOK()) {\n+                return response;\n             }\n-        } finally {\n-            helper.removeRecord();\n         }\n-    }\n+        System.out.printf(\"上传步骤 2: 结束 %s \\n\", response);\n \n-    private void changeHost(String upToken, String host) {\n-        try {\n-            this.host = configHelper.tryChangeUpHost(upToken, host);\n-        } catch (Exception e) {\n-            // ignore\n-            // use the old up host //\n+        // 上传数据至服务 - 步骤3\n+        System.out.println(\"上传步骤 3: 开始\");\n+        response = uploadPerformer.completeUpload();\n+        if (response.isOK()) {\n+            uploadPerformer.removeUploadProgressFromLocal();\n         }\n+        System.out.printf(\"上传步骤 3: 结束 %s \\n\", response);\n+\n+        return response;\n     }\n \n-    private Response makeBlock(byte[] block, int blockSize) throws QiniuException {\n-        String url = host + \"/mkblk/\" + blockSize;\n-        return post(url, block, 0, blockSize);\n+    Response uploadData() throws QiniuException {\n+        Response response = null;\n+        do {\n+            response = uploadPerformer.uploadNextData();\n+            if (response != null && response.isOK()) {\n+                uploadPerformer.saveUploadProgressToLocal();\n+            }\n+        } while (!uploadPerformer.isAllBlocksUploadingOrUploaded());\n+        return response;\n     }\n \n     private void close() {\n         try {\n-            file.close();\n+            source.close();\n         } catch (Exception e) {\n             e.printStackTrace();\n         }\n     }\n \n-    private String fileUrl() {\n-        String url = host + \"/mkfile/\" + size + \"/mimeType/\" + UrlSafeBase64.encodeToString(mime)\n-                + \"/fname/\" + UrlSafeBase64.encodeToString(f.getName());\n-        final StringBuilder b = new StringBuilder(url);\n-        if (key != null) {\n-            b.append(\"/key/\");\n-            b.append(UrlSafeBase64.encodeToString(key));\n-        }\n-        if (params != null) {\n-            params.forEach(new StringMap.Consumer() {\n-                @Override\n-                public void accept(String key, Object value) {\n-                    b.append(\"/\");\n-                    b.append(key);\n-                    b.append(\"/\");\n-                    b.append(UrlSafeBase64.encodeToString(\"\" + value));\n-                }\n-            });\n+    private void checkParam() throws QiniuException {\n+        if (client == null) {\n+            throw QiniuException.unrecoverable(new Exception(\"client can't be empty\"));\n         }\n-        return b.toString();\n-    }\n-\n-    private Response makeFile() throws QiniuException {\n-        String url = fileUrl();\n-        String s = StringUtils.join(contexts, \",\");\n-        return post(url, StringUtils.utf8Bytes(s));\n-    }\n-\n-    private Response post(String url, byte[] data) throws QiniuException {\n-        return client.post(url, data, new StringMap().put(\"Authorization\", \"UpToken \" + upToken));\n-    }\n \n-    private Response post(String url, byte[] data, int offset, int size) throws QiniuException {\n-        return client.post(url, data, offset, size, new StringMap().put(\"Authorization\", \"UpToken \" + upToken),\n-                Client.DefaultMime);\n-    }\n-\n-    private int nextBlockSize(long uploaded) {\n-        if (size < uploaded + Constants.BLOCK_SIZE) {\n-            return (int) (size - uploaded);\n+        if (config == null) {\n+            throw QiniuException.unrecoverable(new Exception(\"Configuration can't be empty\"));\n         }\n-        return Constants.BLOCK_SIZE;\n-    }\n-\n-    private int blockIdx(long offset) {\n-        return (int) (offset / Constants.BLOCK_SIZE);\n-    }\n-\n-    private class RecordHelper {\n-\n-        long recoveryFromRecord() {\n-            try {\n-                return recoveryFromRecord0();\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-                // ignore\n \n-                return 0;\n-            }\n+        if (config.zone == null && config.region == null) {\n+            throw QiniuException.unrecoverable(new Exception(\"Configuration.region can't be empty\"));\n         }\n \n-        long recoveryFromRecord0() {\n-            if (recorder == null) {\n-                return 0;\n-            }\n-\n-            String recorderKey = recorder.recorderKeyGenerate(key, f);\n-\n-            byte[] data = recorder.get(recorderKey);\n-            if (data == null) {\n-                return 0;\n-            }\n-            String jsonStr = new String(data);\n-            Record r = new Gson().fromJson(jsonStr, Record.class);\n-            if (r.offset == 0 || r.modify_time != modifyTime || r.size != size\n-                    || r.contexts == null || r.contexts.length == 0) {\n-                return 0;\n-            }\n-            for (int i = 0; i < r.contexts.length; i++) {\n-                contexts[i] = r.contexts[i];\n-            }\n+        if (!source.isValid()) {\n+            throw QiniuException.unrecoverable(new Exception(\"InputStream or File is invalid\"));\n+        }\n \n-            return r.offset;\n+        UploadToken token = new UploadToken(upToken);\n+        if (!token.isValid()) {\n+            throw QiniuException.unrecoverable(new Exception(\"token is invalid\"));\n         }\n+    }\n \n-        void removeRecord() {\n-            try {\n-                if (recorder != null) {\n-                    String recorderKey = recorder.recorderKeyGenerate(key, f);\n-                    recorder.del(recorderKey);\n-                }\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-                // ignore\n-            }\n+    private static String getRecorderKey(String key, File file, Recorder recorder) {\n+        if (recorder == null) {\n+            return null;\n         }\n+        return recorder.recorderKeyGenerate(key, file);\n+    }\n \n-        // save json value\n-        //{\n-        //    \"size\":filesize,\n-        //    \"offset\":lastSuccessOffset,\n-        //    \"modify_time\": lastFileModifyTime,\n-        //    \"contexts\": contexts\n-        //}\n-        void record(long offset) {\n-            try {\n-                if (recorder == null || offset == 0) {\n-                    return;\n-                }\n-                String recorderKey = recorder.recorderKeyGenerate(key, f);\n-                String data = new Gson().toJson(new Record(size, offset, modifyTime, contexts));\n-                recorder.set(recorderKey, data.getBytes());\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-                // ignore\n-            }\n+    private static String getRegionTargetId(String upToken, Configuration config) {\n+        if (config == null || upToken == null) {\n+            return null;\n         }\n \n-        private class Record {\n-            long size;\n-            long offset;\n-            // CHECKSTYLE:OFF\n-            long modify_time;\n-            // CHECKSTYLE:ON\n-            String[] contexts;\n+        UploadToken token = null;\n+        try {\n+            token = new UploadToken(upToken);\n+        } catch (QiniuException ignored) {\n+        }\n \n-            Record(long size, long offset, long modify_time, String[] contexts) {\n-                this.size = size;\n-                this.offset = offset;\n-                this.modify_time = modify_time;\n-                this.contexts = contexts;\n-            }\n+        if (token == null || !token.isValid()) {\n+            return null;\n         }\n+        return config.region.getRegion(token);\n     }\n }"
  },
  {
    "sha": "347a13576a2ad6c24b5bd7c539c54a48006fe1b8",
    "filename": "src/main/java/com/qiniu/storage/UploadManager.java",
    "status": "modified",
    "additions": 159,
    "deletions": 60,
    "changes": 219,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/UploadManager.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/UploadManager.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/storage/UploadManager.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -24,7 +24,7 @@\n     /**\n      * 构建一个非断点续传的上传对象\n      *\n-     * @param config 配置类对象\n+     * @param config 配置类对象【必须】\n      */\n     public UploadManager(Configuration config) {\n         this(config, null);\n@@ -35,15 +35,23 @@ public UploadManager(Configuration config) {\n      * 分块上传中，将每一块上传的记录保存下来。上传中断后可在上一次断点记录基础上上传剩余部分。\n      * 对于不同的文件上传需要支持断点续传的情况，请定义不同的UploadManager对象，而不要共享。\n      *\n-     * @param config   配置类对象\n-     * @param recorder 断点记录对象\n+     * @param config   配置类对象【必须】\n+     * @param recorder 断点记录对象【可选】\n      */\n     public UploadManager(Configuration config, Recorder recorder) {\n         configuration = config.clone();\n         client = new Client(configuration);\n         this.recorder = recorder;\n     }\n \n+    /**\n+     * 构建一个支持断点续传的上传对象。只在文件采用分片上传时才会有效。\n+     * 分块上传中，将每一块上传的记录保存下来。上传中断后可在上一次断点记录基础上上传剩余部分。\n+     * 对于不同的文件上传需要支持断点续传的情况，请定义不同的UploadManager对象，而不要共享。\n+     *\n+     * @param client   上传 client【必须】\n+     * @param recorder 断点记录对象【可选】\n+     */\n     public UploadManager(Client client, Recorder recorder) {\n         this.client = client;\n         this.recorder = recorder;\n@@ -90,17 +98,29 @@ public void accept(String key, Object value) {\n \n     /**\n      * 上传字节流，小文件走表单，大文件走分片\n+     * <p>\n+     * inputStream size 大于 configuration.putThreshold 时采用分片上传\n+     * 分片上传时，每个上传操作会占用 blockSize 大小内存，blockSize 也即分片大小，\n+     * 在分片 v1 中 blockSize 为 4M；\n+     * 分片 v2 可自定义 blockSize，定义方式为：Configuration.resumeV2BlockSize，范围为：1M ~ 1GB，分片 v2 需要注意每个文件最大分片数量为 10000；\n+     * 当采用并发分片时，占用内存大小和当时启用并发任务数量有关，即：blockSize * 并发数量，\n+     * 并发任务数量配置方式：Configuration.resumeMaxConcurrentTaskCount\n+     * 流式分片上传：支持分片上传 v1/v2，支持并发，不支持断点续传\n+     * <p>\n+     * inputStream size 小于 configuration.putThreshold 时采用表单上传\n+     * 表单上传会占用 inputStream size 大小内存\n      *\n-     * @param inputStream\n-     * @param size\n-     * @param key\n-     * @param token\n-     * @param params\n-     * @param mime\n-     * @param checkCrc\n+     * @param inputStream 文件流【必须】\n+     * @param size        文件大小【必须】\n+     * @param key         保存文件名【可选】\n+     * @param token       上传凭证【必须】\n+     * @param params      自定义参数【可选】\n+     *                    自定义文件 metadata 信息，key 需要增加前缀 x-qn-meta- ：如 params.put(\"x-qn-meta-key\", \"foo\")\n+     *                    用户自定义变量，key 需要增加前缀 x: ：如 params.put(\"x:foo\", \"foo\")\n+     * @param mime        文件 mime type【可选】\n+     * @param checkCrc    是否检测 crc【可选】\n      * @return\n-     * @throws QiniuException\n-     * @throws IOException\n+     * @throws QiniuException 上传失败异常\n      */\n     public Response put(InputStream inputStream, long size, String key, String token, StringMap params,\n                         String mime, boolean checkCrc) throws QiniuException {\n@@ -117,27 +137,33 @@ public Response put(InputStream inputStream, long size, String key, String token\n     }\n \n     /**\n-     * 上传字节数组\n+     * 上传字节数组，表单上传\n+     * 表单上传：不支持分片上传 v1/v2，不支持并发，不支持断点续传\n      *\n-     * @param data  上传的数据\n-     * @param key   上传数据保存的文件名\n-     * @param token 上传凭证\n+     * @param data  上传的数据【必须】\n+     * @param key   上传数据保存的文件名【可选】\n+     * @param token 上传凭证【必须】\n+     * @return\n+     * @throws QiniuException 上传失败异常\n      */\n     public Response put(final byte[] data, final String key, final String token) throws QiniuException {\n         return put(data, key, token, null, null, false);\n     }\n \n     /**\n-     * 上传字节数组\n+     * 上传字节数组，表单上传\n+     * 表单上传：不支持分片上传 v1/v2，不支持并发，不支持断点续传\n      *\n-     * @param data     上传的数据\n-     * @param key      上传数据保存的文件名\n-     * @param token    上传凭证\n-     * @param params   自定义参数，如 params.put(\"x:foo\", \"foo\")\n-     * @param mime     指定文件mimetype\n-     * @param checkCrc 是否验证crc32\n+     * @param data     上传的数据【必须】\n+     * @param key      上传数据保存的文件名【可选】\n+     * @param token    上传凭证【必须】\n+     * @param params   自定义参数【可选】\n+     *                 自定义文件 metadata 信息，key 需要增加前缀 x-qn-meta- ：如 params.put(\"x-qn-meta-key\", \"foo\")\n+     *                 用户自定义变量，key 需要增加前缀 x: ：如 params.put(\"x:foo\", \"foo\")\n+     * @param mime     指定文件mimetype【可选】\n+     * @param checkCrc 是否验证crc32【可选】\n      * @return\n-     * @throws QiniuException\n+     * @throws QiniuException 上传失败异常\n      */\n     public Response put(final byte[] data, final String key, final String token, StringMap params,\n                         String mime, boolean checkCrc) throws QiniuException {\n@@ -152,23 +178,37 @@ public Response put(final byte[] data, final String key, final String token, Str\n     /**\n      * 上传文件\n      *\n-     * @param filePath 上传的文件路径\n-     * @param key      上传文件保存的文件名\n-     * @param token    上传凭证\n+     * @param filePath 上传的文件路径【必须】\n+     * @param key      上传文件保存的文件名【可选】\n+     * @param token    上传凭证【必须】\n      */\n     public Response put(String filePath, String key, String token) throws QiniuException {\n         return put(filePath, key, token, null, null, false);\n     }\n \n     /**\n      * 上传文件\n+     * <p>\n+     * file size 大于 configuration.putThreshold 时采用分片上传\n+     * 分片上传时，每个上传操作会占用 blockSize 大小内存，blockSize 也即分片大小，\n+     * 在分片 v1 中 blockSize 为 4M；\n+     * 分片 v2 可自定义 blockSize，定义方式为：Configuration.resumeV2BlockSize，范围为：1M ~ 1GB，分片 v2 需要注意每个文件最大分片数量为 10000；\n+     * 当采用并发分片时，占用内存大小和当时启用并发任务数量有关，即：blockSize * 并发数量，\n+     * 并发任务数量配置方式：Configuration.resumeMaxConcurrentTaskCount\n+     * 分片上传：支持分片上传 v1/v2，支持并发，支持断点续传\n+     * <p>\n+     * file size 小于 configuration.putThreshold 时采用表单上传\n+     * 表单上传会占用 inputStream size 大小内存\n+     * 表单上传：不支持分片上传 v1/v2，不支持并发，不支持断点续传\n      *\n-     * @param filePath 上传的文件路径\n-     * @param key      上传文件保存的文件名\n-     * @param token    上传凭证\n-     * @param params   自定义参数，如 params.put(\"x:foo\", \"foo\")\n-     * @param mime     指定文件mimetype\n-     * @param checkCrc 是否验证crc32\n+     * @param filePath 上传的文件路径【必须】\n+     * @param key      上传文件保存的文件名【可选】\n+     * @param token    上传凭证【必须】\n+     * @param params   自定义参数【可选】\n+     *                 自定义文件 metadata 信息，key 需要增加前缀 x-qn-meta- ：如 params.put(\"x-qn-meta-key\", \"foo\")\n+     *                 用户自定义变量，key 需要增加前缀 x: ：如 params.put(\"x:foo\", \"foo\")\n+     * @param mime     指定文件mimetype【可选】\n+     * @param checkCrc 是否验证crc32【可选】\n      */\n     public Response put(String filePath, String key, String token, StringMap params,\n                         String mime, boolean checkCrc) throws QiniuException {\n@@ -177,23 +217,47 @@ public Response put(String filePath, String key, String token, StringMap params,\n \n     /**\n      * 上传文件\n+     * <p>\n+     * file size 大于 configuration.putThreshold 时采用分片上传\n+     * 分片上传时，每个上传操作会占用 blockSize 大小内存，blockSize 也即分片大小，\n+     * 在分片 v1 中 blockSize 为 4M；\n+     * 分片 v2 可自定义 blockSize，定义方式为：Configuration.resumeV2BlockSize，范围为：1M ~ 1GB，分片 v2 需要注意每个文件最大分片数量为 10000；\n+     * 当采用并发分片时，占用内存大小和当时启用并发任务数量有关，即：blockSize * 并发数量，\n+     * 并发任务数量配置方式：Configuration.resumeMaxConcurrentTaskCount\n+     * 分片上传：支持分片上传 v1/v2，支持并发，支持断点续传\n+     * <p>\n+     * file size 小于 configuration.putThreshold 时采用表单上传\n+     * 表单上传会占用 inputStream size 大小内存\n+     * 表单上传：不支持分片上传 v1/v2，不支持并发，不支持断点续传\n      *\n-     * @param file  上传的文件对象\n-     * @param key   上传文件保存的文件名\n-     * @param token 上传凭证\n+     * @param file  上传的文件对象【必须】\n+     * @param key   上传文件保存的文件名【可选】\n+     * @param token 上传凭证【必须】\n      */\n     public Response put(File file, String key, String token) throws QiniuException {\n         return put(file, key, token, null, null, false);\n     }\n \n     /**\n      * 上传文件\n+     * *\n+     * file size 大于 configuration.putThreshold 时采用分片上传\n+     * 分片上传时，每个上传操作会占用 blockSize 大小内存，blockSize 也即分片大小，\n+     * 在分片 v1 中 blockSize 为 4M；\n+     * 分片 v2 可自定义 blockSize，定义方式为：Configuration.resumeV2BlockSize，范围为：1M ~ 1GB，分片 v2 需要注意每个文件最大分片数量为 10000；\n+     * 当采用并发分片时，占用内存大小和当时启用并发任务数量有关，即：blockSize * 并发数量，\n+     * 并发任务数量配置方式：Configuration.resumeMaxConcurrentTaskCount\n+     * 分片上传：支持分片上传 v1/v2，支持并发，支持断点续传\n+     * <p>\n+     * file size 小于 configuration.putThreshold 时采用表单上传\n+     * 表单上传会占用 inputStream size 大小内存\n+     * 表单上传：不支持分片上传 v1/v2，不支持并发，不支持断点续传\n      *\n-     * @param file     上传的文件对象\n-     * @param key      上传文件保存的文件名\n-     * @param token    上传凭证\n-     * @param mime     指定文件mimetype\n-     * @param checkCrc 是否验证crc32\n+     * @param file     上传的文件对象【必须】\n+     * @param key      上传文件保存的文件名【可选】\n+     * @param token    上传凭证【必须】\n+     * @param mime     指定文件mimetype【可选】\n+     * @param checkCrc 是否验证crc32【可选】\n      */\n     public Response put(File file, String key, String token, StringMap params,\n                         String mime, boolean checkCrc) throws QiniuException {\n@@ -207,21 +271,32 @@ public Response put(File file, String key, String token, StringMap params,\n             return new FormUploader(client, token, key, file, params, mime, checkCrc, configuration).upload();\n         }\n \n-        ResumeUploader uploader = new ResumeUploader(client, token, key, file,\n-                params, mime, recorder, configuration);\n-        return uploader.upload();\n+        if (configuration.resumeMaxConcurrentTaskCount > 1) {\n+            ResumeUploader uploader = new ConcurrentResumeUploader(client, token, key, file,\n+                    params, mime, recorder, configuration);\n+            return uploader.upload();\n+        } else {\n+            ResumeUploader uploader = new ResumeUploader(client, token, key, file,\n+                    params, mime, recorder, configuration);\n+            return uploader.upload();\n+        }\n     }\n \n     /**\n-     * 异步上传数据\n+     * 异步上传数据，表单上传\n+     * <p>\n+     * 不支持分片上传 v1/v2，不支持并发，不支持断点续传\n      *\n-     * @param data     上传的数据\n+     * @param data     上传的数据【必须】\n      * @param key      上传数据保存的文件名\n-     * @param token    上传凭证\n-     * @param params   自定义参数，如 params.put(\"x:foo\", \"foo\")\n-     * @param mime     指定文件mimetype\n-     * @param checkCrc 是否验证crc32\n-     * @param handler  上传完成的回调函数\n+     * @param token    上传凭证【必须】\n+     * @param params   自定义参数【可选】\n+     *                 自定义文件 metadata 信息，key 需要增加前缀 x-qn-meta- ：如 params.put(\"x-qn-meta-key\", \"foo\")\n+     *                 用户自定义变量，key 需要增加前缀 x: ：如 params.put(\"x:foo\", \"foo\")\n+     * @param mime     指定文件mimetype【可选】\n+     * @param checkCrc 是否验证crc32【可选】\n+     * @param handler  上传完成的回调函数【必须】\n+     * @throws IOException 上传异常\n      */\n     public void asyncPut(final byte[] data, final String key, final String token, StringMap params,\n                          String mime, boolean checkCrc, UpCompletionHandler handler) throws IOException {\n@@ -234,13 +309,30 @@ public void asyncPut(final byte[] data, final String key, final String token, St\n     }\n \n     /**\n-     * 流式上传，通常情况建议文件上传，可以使用持久化的断点记录。\n+     * 流式上传，通常情况建议文件上传，文件上传可以使用持久化的断点记录。\n+     * <p>\n+     * 支持分片上传 v1/v2，支持并发\n+     * 不支持断点续传\n+     * <p>\n+     * inputStream size 大于 configuration.putThreshold 时采用分片上传\n+     * 分片上传时，每个上传操作会占用 blockSize 大小内存，blockSize 也即分片大小，\n+     * 在分片 v1 中 blockSize 为 4M；\n+     * 分片 v2 可自定义 blockSize，定义方式为：Configuration.resumeV2BlockSize，范围为：1M ~ 1GB，分片 v2 需要注意每个文件最大分片数量为 10000；\n+     * 当采用并发分片时，占用内存大小和当时启用并发任务数量有关，即：blockSize * 并发数量，\n+     * 并发任务数量配置方式：Configuration.resumeMaxConcurrentTaskCount\n+     * 流式分片上传：支持分片上传 v1/v2，支持并发，不支持断点续传\n+     * <p>\n+     * inputStream size 小于 configuration.putThreshold 时采用表单上传\n+     * 表单上传会占用 inputStream size 大小内存\n+     * 表单上传：不支持分片上传 v1/v2，不支持并发，不支持断点续传\n      *\n-     * @param stream sha\n-     * @param key    上传文件保存的文件名\n-     * @param token  上传凭证\n-     * @param params 自定义参数，如 params.put(\"x:foo\", \"foo\")\n-     * @param mime   指定文件mimetype\n+     * @param stream 文件流【必须】\n+     * @param key    上传文件保存的文件名【可选】\n+     * @param token  上传凭证【必须】\n+     * @param params 自定义参数【可选】\n+     *               自定义文件 metadata 信息，key 需要增加前缀 x-qn-meta- ：如 params.put(\"x-qn-meta-key\", \"foo\")\n+     *               用户自定义变量，key 需要增加前缀 x: ：如 params.put(\"x:foo\", \"foo\")\n+     * @param mime   指定文件mimetype【可选】\n      */\n     public Response put(InputStream stream, String key, String token, StringMap params,\n                         String mime) throws QiniuException {\n@@ -253,8 +345,15 @@ public Response put(InputStream stream, String key, String token, StringMap para\n         if (message != null) {\n             throw new IllegalArgumentException(message);\n         }\n-        StreamUploader uploader = new StreamUploader(client, token, key, stream,\n-                params, mime, configuration);\n-        return uploader.upload();\n+\n+        if (configuration.resumeMaxConcurrentTaskCount > 1) {\n+            ResumeUploader uploader = new ConcurrentResumeUploader(client, token, key, stream,\n+                    params, mime, configuration);\n+            return uploader.upload();\n+        } else {\n+            ResumeUploader uploader = new ResumeUploader(client, token, key, stream,\n+                    params, mime, configuration);\n+            return uploader.upload();\n+        }\n     }\n }"
  },
  {
    "sha": "6ad4340532348c427669bdfd98594cba07d25cef",
    "filename": "src/main/java/com/qiniu/storage/UploadOptions.java",
    "status": "added",
    "additions": 137,
    "deletions": 0,
    "changes": 137,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/UploadOptions.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/UploadOptions.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/storage/UploadOptions.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -0,0 +1,137 @@\n+package com.qiniu.storage;\n+\n+import com.qiniu.util.StringMap;\n+\n+public final class UploadOptions {\n+\n+    /**\n+     * 用于服务器上传回调通知的自定义参数，参数的key必须以x: 开头  eg: x:foo\n+     */\n+    public final StringMap params;\n+\n+    /**\n+     * 用于设置meta数据，参数的key必须以x-qn-meta- 开头  eg: x-qn-meta-key\n+     */\n+    public final StringMap metaDataParam;\n+\n+    /**\n+     * 指定上传文件的MimeType\n+     */\n+    public final String mimeType;\n+\n+    /**\n+     * 启用上传内容crc32校验\n+     */\n+    public final boolean checkCrc;\n+\n+    public static UploadOptions defaultOptions() {\n+        return new UploadOptions.Builder().build();\n+    }\n+\n+    private UploadOptions(StringMap params,\n+                          StringMap metaDataParam,\n+                          String mimeType,\n+                          boolean checkCrc) {\n+        this.params = params;\n+        this.metaDataParam = metaDataParam;\n+        this.mimeType = mimeType;\n+        this.checkCrc = checkCrc;\n+    }\n+\n+\n+    public static class Builder {\n+\n+        private StringMap params;\n+        private StringMap metaDataParam;\n+        private String mimeType;\n+        private boolean checkCrc;\n+\n+        /**\n+         * 用于服务器上传回调通知的自定义参数，参数的key必须以x: 开头  eg: x:foo\n+         */\n+        public Builder params(StringMap params) {\n+            this.params = params;\n+            return this;\n+        }\n+\n+        /**\n+         * 用于设置meta数据，参数的key必须以x-qn-meta- 开头  eg: x-qn-meta-key\n+         */\n+        public Builder metaData(StringMap params) {\n+            this.metaDataParam = params;\n+            return this;\n+        }\n+\n+        /**\n+         * 指定上传文件的MimeType\n+         */\n+        public Builder mimeType(String mimeType) {\n+            this.mimeType = mimeType;\n+            return this;\n+        }\n+\n+        /**\n+         * 启用上传内容crc32校验\n+         */\n+        public Builder checkCrc(boolean checkCrc) {\n+            this.checkCrc = checkCrc;\n+            return this;\n+        }\n+\n+        public UploadOptions build() {\n+            mimeType = mime(mimeType);\n+            params = filterParam(params);\n+            metaDataParam = filterMetaData(params);\n+            return new UploadOptions(params, metaDataParam, mimeType, checkCrc);\n+        }\n+\n+        private String mime(String mimeType) {\n+            if (mimeType == null || mimeType.equals(\"\")) {\n+                return \"application/octet-stream\";\n+            }\n+            return mimeType;\n+        }\n+\n+        /**\n+         * 过滤用户自定义参数，只有参数名以<code>x:</code>开头的参数才会被使用\n+         *\n+         * @param params 待过滤的用户自定义参数\n+         * @return 过滤后的用户自定义参数\n+         */\n+        private StringMap filterParam(StringMap params) {\n+            final StringMap ret = new StringMap();\n+            if (params == null) {\n+                return ret;\n+            }\n+\n+            params.forEach(new StringMap.Consumer() {\n+                @Override\n+                public void accept(String key, Object value) {\n+                    ret.putWhen(key, value, key != null && key.startsWith(\"x:\") && value != null && !value.equals(\"\"));\n+                }\n+            });\n+            return ret;\n+        }\n+\n+        /**\n+         * 过滤meta data参数，只有参数名以<code>x-qn-meta-</code>开头的参数才会被使用\n+         *\n+         * @param params 待过滤的用户自定义参数\n+         * @return 过滤后的参数\n+         */\n+        private StringMap filterMetaData(StringMap params) {\n+            final StringMap ret = new StringMap();\n+            if (params == null) {\n+                return ret;\n+            }\n+\n+            params.forEach(new StringMap.Consumer() {\n+                @Override\n+                public void accept(String key, Object value) {\n+                    ret.putWhen(key, value, key != null && key.startsWith(\"x-qn-meta-\") && value != null && !value.equals(\"\"));\n+                }\n+            });\n+            return ret;\n+        }\n+    }\n+}"
  },
  {
    "sha": "9f13fa95cd424fc331aeefcfb31a4088c5507074",
    "filename": "src/main/java/com/qiniu/storage/UploadToken.java",
    "status": "added",
    "additions": 24,
    "deletions": 0,
    "changes": 24,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/UploadToken.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/main/java/com/qiniu/storage/UploadToken.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/main/java/com/qiniu/storage/UploadToken.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -0,0 +1,24 @@\n+package com.qiniu.storage;\n+\n+import com.qiniu.common.QiniuException;\n+import com.qiniu.util.StringUtils;\n+\n+class UploadToken extends RegionReqInfo {\n+\n+    private final String token;\n+\n+    UploadToken(String token) throws QiniuException {\n+        super(token);\n+        this.token = token;\n+    }\n+\n+    String getToken() {\n+        return token;\n+    }\n+\n+    boolean isValid() {\n+        return !StringUtils.isNullOrEmpty(token) &&\n+                !StringUtils.isNullOrEmpty(getBucket()) &&\n+                !StringUtils.isNullOrEmpty(getAccessKey());\n+    }\n+}"
  },
  {
    "sha": "6a7d50440c40e1472e6e430571ae735a0b823ba6",
    "filename": "src/test/java/test/com/qiniu/storage/RecordUploadTest.java",
    "status": "modified",
    "additions": 96,
    "deletions": 15,
    "changes": 111,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/test/java/test/com/qiniu/storage/RecordUploadTest.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/test/java/test/com/qiniu/storage/RecordUploadTest.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/test/java/test/com/qiniu/storage/RecordUploadTest.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -4,6 +4,7 @@\n import com.qiniu.common.Zone;\n import com.qiniu.http.Client;\n import com.qiniu.http.Response;\n+import com.qiniu.storage.ConcurrentResumeUploader;\n import com.qiniu.storage.Configuration;\n import com.qiniu.storage.ResumeUploader;\n import com.qiniu.storage.persistent.FileRecorder;\n@@ -33,30 +34,52 @@\n     FileRecorder recorder = null;\n     private Response response = null;\n \n+    private static boolean[][] TestConfigList = {\n+            // isResumeV2, isConcurrent\n+            {true, false},\n+            {true, true},\n+            {false, false},\n+            {false, true}\n+    };\n \n     /**\n      * 断点续传\n      *\n-     * @param size\n+     * @param size         文件大小\n+     * @param isResumeV2   是否使用分片上传 api v2, 反之为 v1\n+     * @param isConcurrent 是否采用并发方式上传\n      * @throws IOException\n      */\n-    private void template(final int size) throws IOException {\n+    private void template(final int size, boolean isResumeV2, boolean isConcurrent) throws IOException {\n+\n         Map<String, Zone> bucketKeyMap = new HashMap<String, Zone>();\n         bucketKeyMap.put(TestConfig.testBucket_z0, Zone.zone0());\n         bucketKeyMap.put(TestConfig.testBucket_na0, Zone.zoneNa0());\n         for (Map.Entry<String, Zone> entry : bucketKeyMap.entrySet()) {\n+\n             String bucket = entry.getKey();\n             final Zone zone = entry.getValue();\n+\n+            System.out.println(\"\\n\\n\");\n+            System.out.printf(\"bucket:%s zone:%s \\n\", bucket, zone.getRegion());\n+\n             response = null;\n-            final String expectKey = \"\\r\\n?&r=\" + size + \"k\";\n+            String key = \"\";\n+            key += isResumeV2 ? \"_resumeV2\" : \"_resumeV1\";\n+            key += isConcurrent ? \"_concurrent\" : \"_serial\";\n+            final String expectKey = \"\\r\\n?&r=\" + size + \"k\" + key;\n             final File f = TempFile.createFile(size);\n             recorder = new FileRecorder(f.getParentFile());\n+\n+            System.out.printf(\"key:%s \\n\", expectKey);\n+\n+            final Complete complete = new Complete();\n             try {\n                 final String token = TestConfig.testAuth.uploadToken(bucket, expectKey);\n                 final String recordKey = recorder.recorderKeyGenerate(expectKey, f);\n \n                 // 开始第一部分上传\n-                final Up up = new Up(f, expectKey, token);\n+                final Up up = new Up(f, expectKey, token, isResumeV2, isConcurrent);\n                 new Thread() {\n                     @Override\n                     public void run() {\n@@ -69,6 +92,7 @@ public void run() {\n                             System.out.println(\"UP:  \" + i + \", exception run\");\n                             e.printStackTrace();\n                         }\n+                        complete.isComplete = true;\n                     }\n                 }.start();\n \n@@ -90,8 +114,8 @@ public void run() {\n                     for (int i = 150; i > 0; --i) {\n                         byte[] data = getRecord(recorder, recordKey);\n                         if (data != null) {\n+                            doSleep(1000);\n                             up.close();\n-                            doSleep(100);\n                             break;\n                         }\n                         doSleep(200);\n@@ -101,11 +125,15 @@ public void run() {\n                 }\n \n                 System.out.println(\"response is \" + response);\n+                while (!complete.isComplete) {\n+                    doSleep(200);\n+                }\n \n+                System.out.println(\"\\r\\n断点续传:\");\n                 // 若第一部分上传部分未全部成功,再次上传\n                 if (response == null) {\n                     try {\n-                        response = new Up(f, expectKey, token).up(zone);\n+                        response = new Up(f, expectKey, token, isResumeV2, isConcurrent).up(zone);\n                     } catch (Exception e) {\n                         e.printStackTrace();\n                     }\n@@ -163,44 +191,76 @@ private void doSleep(int m) {\n \n     @Test\n     public void test1K() throws Throwable {\n-        template(1);\n+        for (boolean[] config : TestConfigList) {\n+            template(1, config[0], config[1]);\n+        }\n     }\n \n     @Test\n     public void test600k() throws Throwable {\n-        template(600);\n+        for (boolean[] config : TestConfigList) {\n+            template(600, config[0], config[1]);\n+        }\n     }\n \n     @Test\n     public void test4M() throws Throwable {\n         if (TestConfig.isTravis()) {\n             return;\n         }\n-        template(1024 * 4);\n+        for (boolean[] config : TestConfigList) {\n+            template(1024 * 4, config[0], config[1]);\n+        }\n     }\n \n     @Test\n     public void test4M1K() throws Throwable {\n         if (TestConfig.isTravis()) {\n             return;\n         }\n-        template(1024 * 4 + 1);\n+        for (boolean[] config : TestConfigList) {\n+            template(1024 * 4 + 1, config[0], config[1]);\n+        }\n     }\n \n     @Test\n     public void test8M1k() throws Throwable {\n         if (TestConfig.isTravis()) {\n             return;\n         }\n-        template(1024 * 8 + 1);\n+        for (boolean[] config : TestConfigList) {\n+            template(1024 * 8 + 1, config[0], config[1]);\n+        }\n     }\n \n     @Test\n     public void test25M1k() throws Throwable {\n         if (TestConfig.isTravis()) {\n             return;\n         }\n-        template(1024 * 25 + 1);\n+        for (boolean[] config : TestConfigList) {\n+            template(1024 * 25 + 1, config[0], config[1]);\n+        }\n+    }\n+\n+    @Test\n+    public void test50M1k() throws Throwable {\n+        if (TestConfig.isTravis()) {\n+            return;\n+        }\n+        for (boolean[] config : TestConfigList) {\n+            template(1024 * 50 + 1, config[0], config[1]);\n+        }\n+    }\n+\n+    @Test\n+    public void test100M1k() throws Throwable {\n+        if (TestConfig.isTravis()) {\n+            return;\n+        }\n+        for (boolean[] config : TestConfigList) {\n+            template(1024 * 100 + 1, config[0], config[1]);\n+        }\n     }\n \n     @Test\n@@ -253,12 +313,16 @@ public void testLastModify() throws IOException {\n         private final File file;\n         private final String key;\n         private final String token;\n+        private final boolean isResumeV2;\n+        private final boolean isConcurrent;\n         ResumeUploader uploader = null;\n \n-        Up(File file, String key, String token) {\n+        Up(File file, String key, String token, boolean isResumeV2, boolean isConcurrent) {\n             this.file = file;\n             this.key = key;\n             this.token = token;\n+            this.isResumeV2 = isResumeV2;\n+            this.isConcurrent = isConcurrent;\n         }\n \n         public void close() {\n@@ -286,8 +350,21 @@ public Response up(Zone zone) throws Exception {\n                     recorder = new FileRecorder(file.getParentFile());\n                 }\n \n-                uploader = new ResumeUploader(client, token, key, file,\n-                        null, Client.DefaultMime, recorder, new Configuration(zone));\n+                Configuration config = new Configuration(zone);\n+\n+                if (isResumeV2) {\n+                    config.resumeVersion = Configuration.ResumeVersion.V2;\n+                }\n+\n+                if (isConcurrent) {\n+                    config.resumeMaxConcurrentTaskCount = 3;\n+                    uploader = new ConcurrentResumeUploader(client, token, key, file,\n+                            null, Client.DefaultMime, recorder, config);\n+                } else {\n+                    uploader = new ResumeUploader(client, token, key, file,\n+                            null, Client.DefaultMime, recorder, config);\n+                }\n+\n                 Response res = uploader.upload();\n                 System.out.println(\"UP:  \" + i + \", left up\");\n                 return res;\n@@ -297,4 +374,8 @@ public Response up(Zone zone) throws Exception {\n             }\n         }\n     }\n+\n+    static class Complete {\n+        boolean isComplete = false;\n+    }\n }"
  },
  {
    "sha": "840864901e1b6b1f02679182daa09c6e4ae831d2",
    "filename": "src/test/java/test/com/qiniu/storage/ResumeUploadTest.java",
    "status": "modified",
    "additions": 112,
    "deletions": 19,
    "changes": 131,
    "blob_url": "https://github.com/qiniu/java-sdk/blob/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/test/java/test/com/qiniu/storage/ResumeUploadTest.java",
    "raw_url": "https://github.com/qiniu/java-sdk/raw/0a1086612aa530013a5bef8cf993f9f92a73da8a/src/test/java/test/com/qiniu/storage/ResumeUploadTest.java",
    "contents_url": "https://api.github.com/repos/qiniu/java-sdk/contents/src/test/java/test/com/qiniu/storage/ResumeUploadTest.java?ref=0a1086612aa530013a5bef8cf993f9f92a73da8a",
    "patch": "@@ -4,6 +4,7 @@\n import com.qiniu.common.Zone;\n import com.qiniu.http.Client;\n import com.qiniu.http.Response;\n+import com.qiniu.storage.ConcurrentResumeUploader;\n import com.qiniu.storage.Configuration;\n import com.qiniu.storage.ResumeUploader;\n import com.qiniu.storage.UploadManager;\n@@ -14,6 +15,7 @@\n import test.com.qiniu.TestConfig;\n \n import java.io.File;\n+import java.io.FileInputStream;\n import java.io.IOException;\n import java.util.HashMap;\n import java.util.Map;\n@@ -23,6 +25,31 @@\n \n public class ResumeUploadTest {\n \n+//    private static boolean[][] TestConfigList = {\n+//            // isHttps, isResumeV2, isStream, isConcurrent\n+//            {false, true, true, true},\n+//    };\n+\n+    private static boolean[][] TestConfigList = {\n+            // isHttps, isResumeV2, isStream, isConcurrent\n+            {false, true, false, false},\n+            {false, false, false, true},\n+            {false, false, true, false},\n+            {false, false, true, true},\n+            {false, true, false, false},\n+            {false, true, false, true},\n+            {false, true, true, false},\n+            {false, true, true, true},\n+            {true, false, false, false},\n+            {true, false, false, true},\n+            {true, false, true, false},\n+            {true, false, true, true},\n+            {true, true, false, false},\n+            {true, true, false, true},\n+            {true, true, true, false},\n+            {true, true, true, true}\n+    };\n+\n     /**\n      * 检测自定义变量foo是否生效\n      *\n@@ -69,38 +96,68 @@ public void testXVar() throws IOException {\n      * 分片上传\n      * 检测key、hash、fszie、fname是否符合预期\n      *\n-     * @param size\n-     * @param https\n+     * @param size         文件大小\n+     * @param isHttps      是否采用 https 方式, 反之为 http\n+     * @param isResumeV2   是否使用分片上传 api v2, 反之为 v1\n+     * @param isStream     是否上传 stream, 反之为 file\n+     * @param isConcurrent 是否采用并发方式上传\n      * @throws IOException\n      */\n-    private void template(int size, boolean https) throws IOException {\n+    private void template(int size, boolean isHttps, boolean isResumeV2, boolean isStream, boolean isConcurrent) throws IOException {\n         Map<String, Zone> bucketKeyMap = new HashMap<String, Zone>();\n         bucketKeyMap.put(TestConfig.testBucket_z0, Zone.zone0());\n         bucketKeyMap.put(TestConfig.testBucket_na0, Zone.zoneNa0());\n         for (Map.Entry<String, Zone> entry : bucketKeyMap.entrySet()) {\n             String bucket = entry.getKey();\n             Zone zone = entry.getValue();\n-            Configuration c = new Configuration(zone);\n-            c.useHttpsDomains = https;\n-            final String expectKey = \"\\r\\n?&r=\" + size + \"k\";\n+            Configuration config = new Configuration(zone);\n+            if (isResumeV2) {\n+                config.resumeVersion = Configuration.ResumeVersion.V2;\n+            }\n+\n+            config.useHttpsDomains = isHttps;\n+            String key = \"\";\n+            key += isHttps ? \"_https\" : \"_http\";\n+            key += isResumeV2 ? \"_resumeV2\" : \"_resumeV1\";\n+            key += isStream ? \"_stream\" : \"_file\";\n+            key += isConcurrent ? \"_concurrent\" : \"_serial\";\n+            final String expectKey = \"\\r\\n?&r=\" + size + \"k\" + key;\n             final File f = TempFile.createFile(size);\n             final String etag = Etag.file(f);\n             final String returnBody = \"{\\\"key\\\":\\\"$(key)\\\",\\\"hash\\\":\\\"$(etag)\\\",\\\"fsize\\\":\\\"$(fsize)\\\"\"\n                     + \",\\\"fname\\\":\\\"$(fname)\\\",\\\"mimeType\\\":\\\"$(mimeType)\\\"}\";\n             String token = TestConfig.testAuth.uploadToken(bucket, expectKey, 3600,\n                     new StringMap().put(\"returnBody\", returnBody));\n \n+            System.out.printf(\"\\r\\nkey:%s zone:%s\\n\", expectKey, zone.getRegion());\n+\n             try {\n-                ResumeUploader up = new ResumeUploader(new Client(), token, expectKey, f, null, null, null,\n-                        new Configuration(zone));\n+                ResumeUploader up = null;\n+                if (!isConcurrent) {\n+                    if (isStream) {\n+                        up = new ResumeUploader(new Client(), token, expectKey, new FileInputStream(f), null, null, config);\n+                    } else {\n+                        up = new ResumeUploader(new Client(), token, expectKey, f, null, null, null, config);\n+                    }\n+                } else {\n+                    config.resumeMaxConcurrentTaskCount = 3;\n+                    if (isStream) {\n+                        up = new ConcurrentResumeUploader(new Client(), token, expectKey, new FileInputStream(f), null, null, config);\n+                    } else {\n+                        up = new ConcurrentResumeUploader(new Client(), token, expectKey, f, null, null, null, config);\n+                    }\n+                }\n+\n                 Response r = up.upload();\n                 MyRet ret = r.jsonToObject(MyRet.class);\n                 assertEquals(expectKey, ret.key);\n-                assertEquals(f.getName(), ret.fname);\n+                if (!isStream) {\n+                    assertEquals(f.getName(), ret.fname);\n+                }\n                 assertEquals(String.valueOf(f.length()), ret.fsize);\n                 assertEquals(etag, ret.hash);\n             } catch (QiniuException e) {\n-                assertEquals(\"\", e.response == null ? \"e.response is null\" : e.response.bodyString());\n+                assertEquals(\"\", e.response == null ? e + \"e.response is null\" : e.response.bodyString());\n                 fail();\n             }\n             TempFile.remove(f);\n@@ -109,43 +166,79 @@ private void template(int size, boolean https) throws IOException {\n \n     @Test\n     public void test1K() throws Throwable {\n-        template(1, false);\n+        for (boolean[] config : TestConfigList) {\n+            template(1, config[0], config[1], config[2], config[3]);\n+        }\n     }\n \n     @Test\n     public void test600k() throws Throwable {\n-        template(600, true);\n+        for (boolean[] config : TestConfigList) {\n+            template(600, config[0], config[1], config[2], config[3]);\n+        }\n     }\n \n     @Test\n-    public void test600k2() throws IOException {\n-        template(600, false);\n+    public void test4M() throws Throwable {\n+        if (TestConfig.isTravis()) {\n+            return;\n+        }\n+        for (boolean[] config : TestConfigList) {\n+            template(1024 * 4, config[0], config[1], config[2], config[3]);\n+        }\n     }\n \n     @Test\n-    public void test4M() throws Throwable {\n+    public void test8M() throws Throwable {\n         if (TestConfig.isTravis()) {\n             return;\n         }\n-        template(1024 * 4, false);\n+        for (boolean[] config : TestConfigList) {\n+            template(1024 * 8, config[0], config[1], config[2], config[3]);\n+        }\n     }\n \n     @Test\n     public void test8M1k() throws Throwable {\n         if (TestConfig.isTravis()) {\n             return;\n         }\n-        template(1024 * 8 + 1, false);\n+        for (boolean[] config : TestConfigList) {\n+            template(1024 * 8 + 1, config[0], config[1], config[2], config[3]);\n+        }\n+    }\n+\n+    @Test\n+    public void test10M() throws Throwable {\n+        if (TestConfig.isTravis()) {\n+            return;\n+        }\n+        for (boolean[] config : TestConfigList) {\n+            template(1024 * 10, config[0], config[1], config[2], config[3]);\n+        }\n+    }\n+\n+    @Test\n+    public void test20M() throws Throwable {\n+        if (TestConfig.isTravis()) {\n+            return;\n+        }\n+        for (boolean[] config : TestConfigList) {\n+            template(1024 * 20, config[0], config[1], config[2], config[3]);\n+        }\n     }\n \n     @Test\n-    public void test8M1k2() throws Throwable {\n+    public void test20M1K() throws Throwable {\n         if (TestConfig.isTravis()) {\n             return;\n         }\n-        template(1024 * 8 + 1, true);\n+        for (boolean[] config : TestConfigList) {\n+            template(1024 * 20 + 1, config[0], config[1], config[2], config[3]);\n+        }\n     }\n \n+\n     class MyRet {\n         public String hash;\n         public String key;"
  }
]
