[
  {
    "sha": "0e64650595cb5eaa986c413e57b3962505cd50d2",
    "filename": "stream/src/main/java/com/annimon/stream/DoubleStream.java",
    "status": "modified",
    "additions": 43,
    "deletions": 0,
    "changes": 43,
    "blob_url": "https://github.com/aNNiMON/Lightweight-Stream-API/blob/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/main/java/com/annimon/stream/DoubleStream.java",
    "raw_url": "https://github.com/aNNiMON/Lightweight-Stream-API/raw/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/main/java/com/annimon/stream/DoubleStream.java",
    "contents_url": "https://api.github.com/repos/aNNiMON/Lightweight-Stream-API/contents/stream/src/main/java/com/annimon/stream/DoubleStream.java?ref=a9f959be57a872d0f5354dff9218ed5acedd9869",
    "patch": "@@ -4,6 +4,7 @@\n import com.annimon.stream.internal.Compose;\n import com.annimon.stream.internal.Operators;\n import com.annimon.stream.internal.Params;\n+import com.annimon.stream.internal.SpinedBuffer;\n import com.annimon.stream.iterator.PrimitiveIndexedIterator;\n import com.annimon.stream.iterator.PrimitiveIterator;\n import com.annimon.stream.operator.*;\n@@ -619,6 +620,48 @@ public DoubleStream flatMap(@NotNull final DoubleFunction<? extends DoubleStream\n         return new DoubleStream(params, new DoubleFlatMap(iterator, mapper));\n     }\n \n+    /**\n+     * Returns a stream consisting of the results of replacing each element of\n+     * this stream with the contents of a mapped stream produced by applying\n+     * the provided mapping function to each element.\n+     *\n+     * <p>This is an intermediate operation.\n+     *\n+     * @param mapper  the mapper function used to apply to each element for producing replacing elements\n+     * @return the new stream\n+     * @since 1.2.2\n+     * @see Stream#mapMulti(com.annimon.stream.function.BiConsumer)\n+     * @see DoubleStream#flatMap(com.annimon.stream.function.DoubleFunction)\n+     */\n+    @NotNull\n+    public DoubleStream mapMulti(@NotNull final DoubleMapMultiConsumer mapper) {\n+        return flatMap(new DoubleFunction<DoubleStream>() {\n+            @Override\n+            public DoubleStream apply(double value) {\n+                SpinedBuffer.OfDouble buffer = new SpinedBuffer.OfDouble();\n+                mapper.accept(value, buffer);\n+                return DoubleStream.of(buffer.iterator());\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Represents an operation on two input arguments.\n+     *\n+     * @since 1.2.2\n+     * @see #mapMulti(com.annimon.stream.DoubleStream.DoubleMapMultiConsumer)\n+     */\n+    public interface DoubleMapMultiConsumer {\n+        /**\n+         * Replaces the given {@code value} with zero or more values\n+         * by feeding the mapped values to the {@code consumer} consumer.\n+         *\n+         * @param value  the double value coming from upstream\n+         * @param consumer  a {@code DoubleConsumer} accepting the mapped values\n+         */\n+        void accept(double value, DoubleConsumer consumer);\n+    }\n+\n     /**\n      * Returns a stream consisting of the distinct elements of this stream.\n      *"
  },
  {
    "sha": "6df349f09e5540a3a671019550d4c0e61fa3b40e",
    "filename": "stream/src/main/java/com/annimon/stream/IntStream.java",
    "status": "modified",
    "additions": 43,
    "deletions": 0,
    "changes": 43,
    "blob_url": "https://github.com/aNNiMON/Lightweight-Stream-API/blob/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/main/java/com/annimon/stream/IntStream.java",
    "raw_url": "https://github.com/aNNiMON/Lightweight-Stream-API/raw/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/main/java/com/annimon/stream/IntStream.java",
    "contents_url": "https://api.github.com/repos/aNNiMON/Lightweight-Stream-API/contents/stream/src/main/java/com/annimon/stream/IntStream.java?ref=a9f959be57a872d0f5354dff9218ed5acedd9869",
    "patch": "@@ -4,6 +4,7 @@\n import com.annimon.stream.internal.Compose;\n import com.annimon.stream.internal.Operators;\n import com.annimon.stream.internal.Params;\n+import com.annimon.stream.internal.SpinedBuffer;\n import com.annimon.stream.iterator.PrimitiveIndexedIterator;\n import com.annimon.stream.iterator.PrimitiveIterator;\n import com.annimon.stream.operator.*;\n@@ -675,6 +676,48 @@ public IntStream flatMap(@NotNull final IntFunction<? extends IntStream> mapper)\n         return new IntStream(params, new IntFlatMap(iterator, mapper));\n     }\n \n+    /**\n+     * Returns a stream consisting of the results of replacing each element of\n+     * this stream with the contents of a mapped stream produced by applying\n+     * the provided mapping function to each element.\n+     *\n+     * <p>This is an intermediate operation.\n+     *\n+     * @param mapper  the mapper function used to apply to each element for producing replacing elements\n+     * @return the new stream\n+     * @since 1.2.2\n+     * @see Stream#mapMulti(com.annimon.stream.function.BiConsumer)\n+     * @see IntStream#flatMap(com.annimon.stream.function.IntFunction)\n+     */\n+    @NotNull\n+    public IntStream mapMulti(@NotNull final IntStream.IntMapMultiConsumer mapper) {\n+        return flatMap(new IntFunction<IntStream>() {\n+            @Override\n+            public IntStream apply(int value) {\n+                SpinedBuffer.OfInt buffer = new SpinedBuffer.OfInt();\n+                mapper.accept(value, buffer);\n+                return IntStream.of(buffer.iterator());\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Represents an operation on two input arguments.\n+     *\n+     * @since 1.2.2\n+     * @see #mapMulti(com.annimon.stream.IntStream.IntMapMultiConsumer)\n+     */\n+    public interface IntMapMultiConsumer {\n+        /**\n+         * Replaces the given {@code value} with zero or more values\n+         * by feeding the mapped values to the {@code consumer} consumer.\n+         *\n+         * @param value  the int value coming from upstream\n+         * @param consumer  an {@code IntConsumer} accepting the mapped values\n+         */\n+        void accept(int value, IntConsumer consumer);\n+    }\n+\n     /**\n      * Returns a stream consisting of the distinct elements of this stream.\n      *"
  },
  {
    "sha": "2276af17920f51004d57051ee2afc8c6e7aac8cc",
    "filename": "stream/src/main/java/com/annimon/stream/LongStream.java",
    "status": "modified",
    "additions": 43,
    "deletions": 0,
    "changes": 43,
    "blob_url": "https://github.com/aNNiMON/Lightweight-Stream-API/blob/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/main/java/com/annimon/stream/LongStream.java",
    "raw_url": "https://github.com/aNNiMON/Lightweight-Stream-API/raw/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/main/java/com/annimon/stream/LongStream.java",
    "contents_url": "https://api.github.com/repos/aNNiMON/Lightweight-Stream-API/contents/stream/src/main/java/com/annimon/stream/LongStream.java?ref=a9f959be57a872d0f5354dff9218ed5acedd9869",
    "patch": "@@ -4,6 +4,7 @@\n import com.annimon.stream.internal.Compose;\n import com.annimon.stream.internal.Operators;\n import com.annimon.stream.internal.Params;\n+import com.annimon.stream.internal.SpinedBuffer;\n import com.annimon.stream.iterator.PrimitiveIndexedIterator;\n import com.annimon.stream.iterator.PrimitiveIterator;\n import com.annimon.stream.operator.*;\n@@ -655,6 +656,48 @@ public LongStream flatMap(@NotNull final LongFunction<? extends LongStream> mapp\n         return new LongStream(params, new LongFlatMap(iterator, mapper));\n     }\n \n+    /**\n+     * Returns a stream consisting of the results of replacing each element of\n+     * this stream with the contents of a mapped stream produced by applying\n+     * the provided mapping function to each element.\n+     *\n+     * <p>This is an intermediate operation.\n+     *\n+     * @param mapper  the mapper function used to apply to each element for producing replacing elements\n+     * @return the new stream\n+     * @since 1.2.2\n+     * @see Stream#mapMulti(com.annimon.stream.function.BiConsumer)\n+     * @see LongStream#flatMap(com.annimon.stream.function.LongFunction)\n+     */\n+    @NotNull\n+    public LongStream mapMulti(@NotNull final LongStream.LongMapMultiConsumer mapper) {\n+        return flatMap(new LongFunction<LongStream>() {\n+            @Override\n+            public LongStream apply(long value) {\n+                SpinedBuffer.OfLong buffer = new SpinedBuffer.OfLong();\n+                mapper.accept(value, buffer);\n+                return LongStream.of(buffer.iterator());\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Represents an operation on two input arguments.\n+     *\n+     * @since 1.2.2\n+     * @see #mapMulti(com.annimon.stream.LongStream.LongMapMultiConsumer)\n+     */\n+    public interface LongMapMultiConsumer {\n+        /**\n+         * Replaces the given {@code value} with zero or more values\n+         * by feeding the mapped values to the {@code consumer} consumer.\n+         *\n+         * @param value  the long value coming from upstream\n+         * @param consumer  a {@code LongConsumer} accepting the mapped values\n+         */\n+        void accept(long value, LongConsumer consumer);\n+    }\n+\n     /**\n      * Returns a stream consisting of the distinct elements of this stream.\n      *"
  },
  {
    "sha": "c787d7bb85510e3cdfe5257adc002ca2824f542e",
    "filename": "stream/src/main/java/com/annimon/stream/Stream.java",
    "status": "modified",
    "additions": 118,
    "deletions": 0,
    "changes": 118,
    "blob_url": "https://github.com/aNNiMON/Lightweight-Stream-API/blob/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/main/java/com/annimon/stream/Stream.java",
    "raw_url": "https://github.com/aNNiMON/Lightweight-Stream-API/raw/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/main/java/com/annimon/stream/Stream.java",
    "contents_url": "https://api.github.com/repos/aNNiMON/Lightweight-Stream-API/contents/stream/src/main/java/com/annimon/stream/Stream.java?ref=a9f959be57a872d0f5354dff9218ed5acedd9869",
    "patch": "@@ -4,6 +4,7 @@\n import com.annimon.stream.internal.Compose;\n import com.annimon.stream.internal.Operators;\n import com.annimon.stream.internal.Params;\n+import com.annimon.stream.internal.SpinedBuffer;\n import com.annimon.stream.iterator.IndexedIterator;\n import com.annimon.stream.iterator.LazyIterator;\n import com.annimon.stream.operator.*;\n@@ -1034,6 +1035,123 @@ public DoubleStream flatMapToDouble(@NotNull final Function<? super T, ? extends\n         return new DoubleStream(params, new ObjFlatMapToDouble<T>(iterator, mapper));\n     }\n \n+    /**\n+     * Returns a stream consisting of the results of replacing each element of\n+     * this stream with zero or more elements,\n+     * that passed to the provided consumer function.\n+     *\n+     * <p>This is an intermediate operation.\n+     *\n+     * <p>Example:\n+     * <pre>\n+     * stream: [1, 2, 3, 4]\n+     * mapper: (a, consumer) -&gt; {\n+     *   consumer.accept(a);\n+     *   consumer.accept(-a);\n+     * }\n+     * result: [1, -1, 2, -2, 3, -3, 4, -4]\n+     *\n+     * stream: [1, 2, 3, 4]\n+     * mapper: (a, consumer) -&gt; {\n+     *   if (a % 2 == 0)\n+     *     consumer.accept(a * 2);\n+     * }\n+     * result: [4, 8]\n+     * </pre>\n+     *\n+     * @param <R> the type of elements in resulting stream\n+     * @param mapper  the mapper function used to apply to each element for producing replacing elements\n+     * @return the new stream\n+     * @since 1.2.2\n+     * @see #flatMap(com.annimon.stream.function.Function)\n+     */\n+    @NotNull\n+    public <R> Stream<R> mapMulti(@NotNull final BiConsumer<? super T, ? super Consumer<R>> mapper) {\n+        return flatMap(new Function<T, Stream<? extends R>>() {\n+            @Override\n+            public Stream<? extends R> apply(T t) {\n+                SpinedBuffer.Of<R> buffer = new SpinedBuffer.Of<R>();\n+                mapper.accept(t, buffer);\n+                return of(buffer.iterator());\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Returns a stream consisting of the results of replacing each element of\n+     * this stream with zero or more elements,\n+     * that passed to the provided consumer function.\n+     *\n+     * <p>This is an intermediate operation.\n+     *\n+     * @param mapper  the mapper function used to apply to each element for producing replacing elements\n+     * @return the new stream\n+     * @since 1.2.2\n+     * @see #mapMulti(com.annimon.stream.function.BiConsumer)\n+     * @see #flatMapToInt(com.annimon.stream.function.Function)\n+     */\n+    @NotNull\n+    public IntStream mapMultiToInt(@NotNull final BiConsumer<? super T, ? super IntConsumer> mapper) {\n+        return flatMapToInt(new Function<T, IntStream>() {\n+            @Override\n+            public IntStream apply(T t) {\n+                SpinedBuffer.OfInt buffer = new SpinedBuffer.OfInt();\n+                mapper.accept(t, buffer);\n+                return IntStream.of(buffer.iterator());\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Returns a stream consisting of the results of replacing each element of\n+     * this stream with zero or more elements,\n+     * that passed to the provided consumer function.\n+     *\n+     * <p>This is an intermediate operation.\n+     *\n+     * @param mapper  the mapper function used to apply to each element for producing replacing elements\n+     * @return the new stream\n+     * @since 1.2.2\n+     * @see #mapMulti(com.annimon.stream.function.BiConsumer)\n+     * @see #flatMapToLong(com.annimon.stream.function.Function)\n+     */\n+    @NotNull\n+    public LongStream mapMultiToLong(@NotNull final BiConsumer<? super T, ? super LongConsumer> mapper) {\n+        return flatMapToLong(new Function<T, LongStream>() {\n+            @Override\n+            public LongStream apply(T t) {\n+                SpinedBuffer.OfLong buffer = new SpinedBuffer.OfLong();\n+                mapper.accept(t, buffer);\n+                return LongStream.of(buffer.iterator());\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Returns a stream consisting of the results of replacing each element of\n+     * this stream with zero or more elements,\n+     * that passed to the provided consumer function.\n+     *\n+     * <p>This is an intermediate operation.\n+     *\n+     * @param mapper  the mapper function used to apply to each element for producing replacing elements\n+     * @return the new stream\n+     * @since 1.2.2\n+     * @see #mapMulti(com.annimon.stream.function.BiConsumer)\n+     * @see #flatMapToDouble(com.annimon.stream.function.Function)\n+     */\n+    @NotNull\n+    public DoubleStream mapMultiToDouble(@NotNull final BiConsumer<? super T, ? super DoubleConsumer> mapper) {\n+        return flatMapToDouble(new Function<T, DoubleStream>() {\n+            @Override\n+            public DoubleStream apply(T t) {\n+                SpinedBuffer.OfDouble buffer = new SpinedBuffer.OfDouble();\n+                mapper.accept(t, buffer);\n+                return DoubleStream.of(buffer.iterator());\n+            }\n+        });\n+    }\n+\n     /**\n      * Returns {@code Stream} with indexed elements.\n      * Indexing starts from 0 with step 1."
  },
  {
    "sha": "1b9a723fd938b78aeb80c4b762eed0de4823d864",
    "filename": "stream/src/main/java/com/annimon/stream/internal/SpinedBuffer.java",
    "status": "modified",
    "additions": 239,
    "deletions": 163,
    "changes": 402,
    "blob_url": "https://github.com/aNNiMON/Lightweight-Stream-API/blob/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/main/java/com/annimon/stream/internal/SpinedBuffer.java",
    "raw_url": "https://github.com/aNNiMON/Lightweight-Stream-API/raw/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/main/java/com/annimon/stream/internal/SpinedBuffer.java",
    "contents_url": "https://api.github.com/repos/aNNiMON/Lightweight-Stream-API/contents/stream/src/main/java/com/annimon/stream/internal/SpinedBuffer.java?ref=a9f959be57a872d0f5354dff9218ed5acedd9869",
    "patch": "@@ -1,14 +1,21 @@\n package com.annimon.stream.internal;\n \n+import com.annimon.stream.function.Consumer;\n import com.annimon.stream.function.DoubleConsumer;\n import com.annimon.stream.function.IntConsumer;\n+import com.annimon.stream.function.IntFunction;\n import com.annimon.stream.function.LongConsumer;\n import com.annimon.stream.iterator.PrimitiveIterator;\n import java.util.Arrays;\n import java.util.Iterator;\n \n+/**\n+ * Base class for a data structure for gathering elements into a buffer and then\n+ * iterating them. Maintains an array of increasingly sized arrays, so there is\n+ * no copying cost associated with growing the data structure.\n+ */\n @SuppressWarnings({\"WeakerAccess\", \"SameParameterValue\"})\n-final class SpinedBuffer {\n+public abstract class SpinedBuffer<E, T_ARR> implements Iterable<E> {\n \n     /**\n      * Minimum power-of-two for the first chunk.\n@@ -30,210 +37,279 @@\n      */\n     private static final int MIN_SPINE_SIZE = 8;\n \n-    private SpinedBuffer() {\n+    /**\n+     * log2 of the size of the first chunk.\n+     */\n+    final int initialChunkPower;\n+\n+    /**\n+     * Index of the *next* element to write; may point into, or just outside of,\n+     * the current chunk.\n+     */\n+    int elementIndex;\n+\n+    /**\n+     * Index of the *current* chunk in the spine array, if the spine array is\n+     * non-null.\n+     */\n+    int spineIndex;\n+\n+    /**\n+     * Count of elements in all prior chunks.\n+     */\n+    long[] priorElementCount;\n+\n+    T_ARR curChunk;\n+\n+    T_ARR[] spine;\n+\n+    SpinedBuffer() {\n+        this.initialChunkPower = MIN_CHUNK_POWER;\n+        curChunk = newArray(1 << initialChunkPower);\n     }\n \n     /**\n-     * Base class for a data structure for gathering elements into a buffer and then\n-     * iterating them. Maintains an array of increasingly sized arrays, so there is\n-     * no copying cost associated with growing the data structure.\n+     * Construct with a specified initial capacity.\n+     *\n+     * @param initialCapacity The minimum expected number of elements\n      */\n-    abstract static class OfPrimitive<E, T_ARR, T_CONS> implements Iterable<E> {\n-\n-        /**\n-         * log2 of the size of the first chunk.\n-         */\n-        final int initialChunkPower;\n-\n-        /**\n-         * Index of the *next* element to write; may point into, or just outside of,\n-         * the current chunk.\n-         */\n-        int elementIndex;\n-\n-        /**\n-         * Index of the *current* chunk in the spine array, if the spine array is\n-         * non-null.\n-         */\n-        int spineIndex;\n-\n-        /**\n-         * Count of elements in all prior chunks.\n-         */\n-        long[] priorElementCount;\n-\n-        T_ARR curChunk;\n-\n-        T_ARR[] spine;\n-\n-        /**\n-         * Construct with a specified initial capacity.\n-         *\n-         * @param initialCapacity The minimum expected number of elements\n-         */\n-        OfPrimitive(int initialCapacity) {\n-            if (initialCapacity < 0)\n-                throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity);\n+    SpinedBuffer(int initialCapacity) {\n+        if (initialCapacity < 0)\n+            throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity);\n \n-            this.initialChunkPower = Math.max(MIN_CHUNK_POWER,\n-                    Integer.SIZE - Integer.numberOfLeadingZeros(initialCapacity - 1));\n-            curChunk = newArray(1 << initialChunkPower);\n-        }\n+        this.initialChunkPower = Math.max(MIN_CHUNK_POWER,\n+                Integer.SIZE - Integer.numberOfLeadingZeros(initialCapacity - 1));\n+        curChunk = newArray(1 << initialChunkPower);\n+    }\n \n-        OfPrimitive() {\n-            this.initialChunkPower = MIN_CHUNK_POWER;\n-            curChunk = newArray(1 << initialChunkPower);\n-        }\n+    @Override\n+    public abstract Iterator<E> iterator();\n \n-        @Override\n-        public abstract Iterator<E> iterator();\n+    protected abstract T_ARR[] newArrayArray(int size);\n \n-        protected abstract T_ARR[] newArrayArray(int size);\n+    protected abstract T_ARR newArray(int size);\n \n-        protected abstract T_ARR newArray(int size);\n+    protected abstract int arrayLength(T_ARR array);\n+\n+    /**\n+     * Is the buffer currently empty?\n+     */\n+    public boolean isEmpty() {\n+        return (spineIndex == 0) && (elementIndex == 0);\n+    }\n \n-        protected abstract int arrayLength(T_ARR array);\n+    /**\n+     * How many elements are currently in the buffer?\n+     */\n+    public long count() {\n+        return (spineIndex == 0)\n+                ? elementIndex\n+                : priorElementCount[spineIndex] + elementIndex;\n+    }\n \n-        /**\n-         * Is the buffer currently empty?\n-         */\n-        public boolean isEmpty() {\n-            return (spineIndex == 0) && (elementIndex == 0);\n+    /**\n+     * How big should the nth chunk be?\n+     */\n+    int chunkSize(int n) {\n+        int power = (n == 0 || n == 1)\n+                ? initialChunkPower\n+                : Math.min(initialChunkPower + n - 1, MAX_CHUNK_POWER);\n+        return 1 << power;\n+    }\n+\n+    long capacity() {\n+        return (spineIndex == 0)\n+                ? arrayLength(curChunk)\n+                : priorElementCount[spineIndex] + arrayLength(spine[spineIndex]);\n+    }\n+\n+    private void inflateSpine() {\n+        if (spine == null) {\n+            spine = newArrayArray(MIN_SPINE_SIZE);\n+            priorElementCount = new long[MIN_SPINE_SIZE];\n+            spine[0] = curChunk;\n         }\n+    }\n \n-        /**\n-         * How many elements are currently in the buffer?\n-         */\n-        public long count() {\n-            return (spineIndex == 0)\n-                    ? elementIndex\n-                    : priorElementCount[spineIndex] + elementIndex;\n+    final void ensureCapacity(long targetSize) {\n+        long capacity = capacity();\n+        if (targetSize > capacity) {\n+            inflateSpine();\n+            for (int i=spineIndex+1; targetSize > capacity; i++) {\n+                if (i >= spine.length) {\n+                    int newSpineSize = spine.length * 2;\n+                    spine = Arrays.copyOf(spine, newSpineSize);\n+                    priorElementCount = Arrays.copyOf(priorElementCount, newSpineSize);\n+                }\n+                int nextChunkSize = chunkSize(i);\n+                spine[i] = newArray(nextChunkSize);\n+                priorElementCount[i] = priorElementCount[i-1] + arrayLength(spine[i - 1]);\n+                capacity += nextChunkSize;\n+            }\n         }\n+    }\n \n-        /**\n-         * How big should the nth chunk be?\n-         */\n-        int chunkSize(int n) {\n-            int power = (n == 0 || n == 1)\n-                    ? initialChunkPower\n-                    : Math.min(initialChunkPower + n - 1, MAX_CHUNK_POWER);\n-            return 1 << power;\n+    void increaseCapacity() {\n+        ensureCapacity(capacity() + 1);\n+    }\n+\n+    int chunkFor(long index) {\n+        if (spineIndex == 0) {\n+            if (index < elementIndex)\n+                return 0;\n+            else\n+                throw new IndexOutOfBoundsException(Long.toString(index));\n         }\n \n-        long capacity() {\n-            return (spineIndex == 0)\n-                    ? arrayLength(curChunk)\n-                    : priorElementCount[spineIndex] + arrayLength(spine[spineIndex]);\n+        if (index >= count())\n+            throw new IndexOutOfBoundsException(Long.toString(index));\n+\n+        for (int j=0; j <= spineIndex; j++)\n+            if (index < priorElementCount[j] + arrayLength(spine[j]))\n+                return j;\n+\n+        throw new IndexOutOfBoundsException(Long.toString(index));\n+    }\n+\n+    @SuppressWarnings(\"SuspiciousSystemArraycopy\")\n+    void copyInto(T_ARR array, int offset) {\n+        long finalOffset = offset + count();\n+        if (finalOffset > arrayLength(array) || finalOffset < offset) {\n+            throw new IndexOutOfBoundsException(\"does not fit\");\n         }\n \n-        private void inflateSpine() {\n-            if (spine == null) {\n-                spine = newArrayArray(MIN_SPINE_SIZE);\n-                priorElementCount = new long[MIN_SPINE_SIZE];\n-                spine[0] = curChunk;\n+        if (spineIndex == 0)\n+            System.arraycopy(curChunk, 0, array, offset, elementIndex);\n+        else {\n+            // full chunks\n+            for (int i=0; i < spineIndex; i++) {\n+                System.arraycopy(spine[i], 0, array, offset, arrayLength(spine[i]));\n+                offset += arrayLength(spine[i]);\n             }\n+            if (elementIndex > 0)\n+                System.arraycopy(curChunk, 0, array, offset, elementIndex);\n         }\n+    }\n \n-        final void ensureCapacity(long targetSize) {\n-            long capacity = capacity();\n-            if (targetSize > capacity) {\n-                inflateSpine();\n-                for (int i=spineIndex+1; targetSize > capacity; i++) {\n-                    if (i >= spine.length) {\n-                        int newSpineSize = spine.length * 2;\n-                        spine = Arrays.copyOf(spine, newSpineSize);\n-                        priorElementCount = Arrays.copyOf(priorElementCount, newSpineSize);\n-                    }\n-                    int nextChunkSize = chunkSize(i);\n-                    spine[i] = newArray(nextChunkSize);\n-                    priorElementCount[i] = priorElementCount[i-1] + arrayLength(spine[i - 1]);\n-                    capacity += nextChunkSize;\n-                }\n-            }\n+    void preAccept() {\n+        if (elementIndex == arrayLength(curChunk)) {\n+            inflateSpine();\n+            if (spineIndex+1 >= spine.length || spine[spineIndex+1] == null)\n+                increaseCapacity();\n+            elementIndex = 0;\n+            ++spineIndex;\n+            curChunk = spine[spineIndex];\n         }\n+    }\n+\n+    /**\n+     * Remove all data from the buffer\n+     */\n+    public void clear() {\n+        if (spine != null) {\n+            curChunk = spine[0];\n+            spine = null;\n+            priorElementCount = null;\n+        }\n+        elementIndex = 0;\n+        spineIndex = 0;\n+    }\n+\n+    public static class Of<E> extends SpinedBuffer<E, E[]>\n+            implements Consumer<E> {\n+\n+        public Of() { }\n \n-        void increaseCapacity() {\n-            ensureCapacity(capacity() + 1);\n+        public Of(int initialCapacity) {\n+            super(initialCapacity);\n         }\n \n-        int chunkFor(long index) {\n-            if (spineIndex == 0) {\n-                if (index < elementIndex)\n-                    return 0;\n-                else\n-                    throw new IndexOutOfBoundsException(Long.toString(index));\n-            }\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        protected E[][] newArrayArray(int size) {\n+            return (E[][]) new Object[size][];\n+        }\n \n-            if (index >= count())\n-                throw new IndexOutOfBoundsException(Long.toString(index));\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        protected E[] newArray(int size) {\n+            return (E[]) new Object[size];\n+        }\n \n-            for (int j=0; j <= spineIndex; j++)\n-                if (index < priorElementCount[j] + arrayLength(spine[j]))\n-                    return j;\n+        @Override\n+        protected int arrayLength(E[] array) {\n+            return array.length;\n+        }\n \n-            throw new IndexOutOfBoundsException(Long.toString(index));\n+        @Override\n+        public void accept(E e) {\n+            preAccept();\n+            curChunk[elementIndex++] = e;\n         }\n \n-        @SuppressWarnings(\"SuspiciousSystemArraycopy\")\n-        void copyInto(T_ARR array, int offset) {\n-            long finalOffset = offset + count();\n-            if (finalOffset > arrayLength(array) || finalOffset < offset) {\n-                throw new IndexOutOfBoundsException(\"does not fit\");\n-            }\n+        public E get(long index) {\n+            int ch = chunkFor(index);\n+            if (spineIndex == 0 && ch == 0)\n+                return curChunk[(int) index];\n+            else\n+                return spine[ch][(int) (index - priorElementCount[ch])];\n+        }\n \n-            if (spineIndex == 0)\n-                System.arraycopy(curChunk, 0, array, offset, elementIndex);\n-            else {\n-                // full chunks\n-                for (int i=0; i < spineIndex; i++) {\n-                    System.arraycopy(spine[i], 0, array, offset, arrayLength(spine[i]));\n-                    offset += arrayLength(spine[i]);\n+\n+        @Override\n+        public Iterator<E> iterator() {\n+            return new Iterator<E>() {\n+                long index = 0;\n+\n+                @Override\n+                public E next() {\n+                    return get(index++);\n                 }\n-                if (elementIndex > 0)\n-                    System.arraycopy(curChunk, 0, array, offset, elementIndex);\n-            }\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return index < count();\n+                }\n+\n+                @Override\n+                public void remove() {\n+                    throw new UnsupportedOperationException(\"remove\");\n+                }\n+            };\n         }\n \n-        public T_ARR asPrimitiveArray() {\n+        public E[] asArray(IntFunction<E[]> arrayFactory) {\n             long size = count();\n-\n             Compat.checkMaxArraySize(size);\n-\n-            T_ARR result = newArray((int) size);\n+            E[] result = arrayFactory.apply((int) size);\n             copyInto(result, 0);\n             return result;\n         }\n+    }\n \n-        void preAccept() {\n-            if (elementIndex == arrayLength(curChunk)) {\n-                inflateSpine();\n-                if (spineIndex+1 >= spine.length || spine[spineIndex+1] == null)\n-                    increaseCapacity();\n-                elementIndex = 0;\n-                ++spineIndex;\n-                curChunk = spine[spineIndex];\n-            }\n+\n+    abstract static class OfPrimitive<E, T_ARR> extends SpinedBuffer<E, T_ARR> {\n+\n+        OfPrimitive() { }\n+\n+        OfPrimitive(int initialCapacity) {\n+            super(initialCapacity);\n         }\n \n-        /**\n-         * Remove all data from the buffer\n-         */\n-        public void clear() {\n-            if (spine != null) {\n-                curChunk = spine[0];\n-                spine = null;\n-                priorElementCount = null;\n-            }\n-            elementIndex = 0;\n-            spineIndex = 0;\n+        public T_ARR asPrimitiveArray() {\n+            long size = count();\n+            Compat.checkMaxArraySize(size);\n+            T_ARR result = newArray((int) size);\n+            copyInto(result, 0);\n+            return result;\n         }\n     }\n \n-    static class OfInt extends SpinedBuffer.OfPrimitive<Integer, int[], IntConsumer>\n+    public static class OfInt extends SpinedBuffer.OfPrimitive<Integer, int[]>\n             implements IntConsumer {\n-        OfInt() { }\n+        public OfInt() { }\n \n-        OfInt(int initialCapacity) {\n+        public OfInt(int initialCapacity) {\n             super(initialCapacity);\n         }\n \n@@ -287,11 +363,11 @@ public boolean hasNext() {\n         }\n     }\n \n-    static class OfLong extends SpinedBuffer.OfPrimitive<Long, long[], LongConsumer>\n+    public static class OfLong extends SpinedBuffer.OfPrimitive<Long, long[]>\n             implements LongConsumer {\n-        OfLong() { }\n+        public OfLong() { }\n \n-        OfLong(int initialCapacity) {\n+        public OfLong(int initialCapacity) {\n             super(initialCapacity);\n         }\n \n@@ -343,11 +419,11 @@ public boolean hasNext() {\n         }\n     }\n \n-    static class OfDouble extends SpinedBuffer.OfPrimitive<Double, double[], DoubleConsumer>\n+    public static class OfDouble extends SpinedBuffer.OfPrimitive<Double, double[]>\n             implements DoubleConsumer {\n-        OfDouble() { }\n+        public OfDouble() { }\n \n-        OfDouble(int initialCapacity) {\n+        public OfDouble(int initialCapacity) {\n             super(initialCapacity);\n         }\n "
  },
  {
    "sha": "536c400274d6056473adf50dc993344cc2e33b4b",
    "filename": "stream/src/test/java/com/annimon/stream/doublestreamtests/MapMultiTest.java",
    "status": "added",
    "additions": 59,
    "deletions": 0,
    "changes": 59,
    "blob_url": "https://github.com/aNNiMON/Lightweight-Stream-API/blob/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/doublestreamtests/MapMultiTest.java",
    "raw_url": "https://github.com/aNNiMON/Lightweight-Stream-API/raw/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/doublestreamtests/MapMultiTest.java",
    "contents_url": "https://api.github.com/repos/aNNiMON/Lightweight-Stream-API/contents/stream/src/test/java/com/annimon/stream/doublestreamtests/MapMultiTest.java?ref=a9f959be57a872d0f5354dff9218ed5acedd9869",
    "patch": "@@ -0,0 +1,59 @@\n+package com.annimon.stream.doublestreamtests;\n+\n+import com.annimon.stream.DoubleStream;\n+import com.annimon.stream.function.DoubleConsumer;\n+import java.util.NoSuchElementException;\n+import org.junit.Test;\n+import static com.annimon.stream.test.hamcrest.DoubleStreamMatcher.assertElements;\n+import static com.annimon.stream.test.hamcrest.DoubleStreamMatcher.assertIsEmpty;\n+import static org.hamcrest.Matchers.arrayContaining;\n+\n+public final class MapMultiTest {\n+\n+    @Test\n+    public void testMapMulti() {\n+        DoubleStream.of(0.012, -3.039, 100d)\n+                .mapMulti(new DoubleStream.DoubleMapMultiConsumer() {\n+                    @Override\n+                    public void accept(double value, DoubleConsumer consumer) {\n+                        consumer.accept(value);\n+                        consumer.accept(-value);\n+                    }\n+                })\n+                .custom(assertElements(arrayContaining(\n+                        0.012, -0.012, -3.039, 3.039, 100d, -100d\n+                )));\n+\n+        DoubleStream.of(0.012, -3.039, 100d)\n+                .mapMulti(new DoubleStream.DoubleMapMultiConsumer() {\n+                    @Override\n+                    public void accept(double value, DoubleConsumer consumer) {\n+                        if (value < 0) {\n+                            consumer.accept(value);\n+                        }\n+                    }\n+                })\n+                .custom(assertElements(arrayContaining(\n+                        -3.039\n+                )));\n+    }\n+\n+    @Test(expected = NoSuchElementException.class)\n+    public void testMapMultiIterator() {\n+        DoubleStream.empty().mapMulti(new DoubleStream.DoubleMapMultiConsumer() {\n+            @Override\n+            public void accept(double value, DoubleConsumer consumer) {\n+                consumer.accept(value);\n+            }\n+        }).iterator().nextDouble();\n+    }\n+\n+    @Test\n+    public void testMapMultiEmpty() {\n+        DoubleStream.of(1, 2).mapMulti(new DoubleStream.DoubleMapMultiConsumer() {\n+            @Override\n+            public void accept(double value, DoubleConsumer consumer) {\n+            }\n+        }).custom(assertIsEmpty());\n+    }\n+}"
  },
  {
    "sha": "7c9ae08b1ee987c190f70386ed30e2491b8bb83a",
    "filename": "stream/src/test/java/com/annimon/stream/internal/SpinedBufferTest.java",
    "status": "modified",
    "additions": 279,
    "deletions": 169,
    "changes": 448,
    "blob_url": "https://github.com/aNNiMON/Lightweight-Stream-API/blob/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/internal/SpinedBufferTest.java",
    "raw_url": "https://github.com/aNNiMON/Lightweight-Stream-API/raw/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/internal/SpinedBufferTest.java",
    "contents_url": "https://api.github.com/repos/aNNiMON/Lightweight-Stream-API/contents/stream/src/test/java/com/annimon/stream/internal/SpinedBufferTest.java?ref=a9f959be57a872d0f5354dff9218ed5acedd9869",
    "patch": "@@ -1,8 +1,10 @@\n package com.annimon.stream.internal;\n \n+import com.annimon.stream.function.IntFunction;\n import com.annimon.stream.iterator.PrimitiveIterator;\n+import java.util.Iterator;\n import org.junit.Test;\n-import static com.annimon.stream.test.hamcrest.CommonMatcher.hasOnlyPrivateConstructors;\n+import static com.annimon.stream.Functions.arrayGenerator;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.closeTo;\n import static org.junit.Assert.assertEquals;\n@@ -15,6 +17,12 @@\n */\n public class SpinedBufferTest {\n \n+    @Test\n+    public void testEmptyConstructor() {\n+        SpinedBuffer.Of<String> b = new SpinedBuffer.Of<String>();\n+        assertEquals(SpinedBuffer.MIN_CHUNK_SIZE, b.capacity());\n+    }\n+\n     @Test\n     public void testOfIntEmptyConstructor() {\n         SpinedBuffer.OfInt b = new SpinedBuffer.OfInt();\n@@ -34,6 +42,17 @@ public void testOfDoubleEmptyConstructor() {\n     }\n \n \n+    @Test\n+    public void testConstructorCapacity() {\n+        SpinedBuffer.Of<String> b = new SpinedBuffer.Of<String>(1);\n+        assertEquals(SpinedBuffer.MIN_CHUNK_SIZE, b.capacity());\n+        SpinedBuffer.Of<String> b2 = new SpinedBuffer.Of<String>(33);\n+        assertEquals(64, b2.capacity());\n+\n+        SpinedBuffer.Of<String> b3 = new SpinedBuffer.Of<String>(1735);\n+        assertEquals(0, b3.capacity() % SpinedBuffer.MIN_CHUNK_SIZE);\n+    }\n+\n     @Test\n     public void testOfIntConstructorCapacity() {\n         SpinedBuffer.OfInt b = new SpinedBuffer.OfInt(1);\n@@ -68,6 +87,11 @@ public void testOfDoubleConstructorCapacity() {\n     }\n \n \n+    @Test(expected = IllegalArgumentException.class)\n+    public void testConstructorInvalidCapacity() {\n+        new SpinedBuffer.Of<String>(-5);\n+    }\n+\n     @Test(expected = IllegalArgumentException.class)\n     public void testOfIntConstructorInvalidCapacity() {\n         new SpinedBuffer.OfInt(-5);\n@@ -84,6 +108,18 @@ public void testOfDoubleConstructorInvalidCapacity() {\n     }\n \n \n+    @Test\n+    public void testEmpty() {\n+        SpinedBuffer.Of<String> b = new SpinedBuffer.Of<String>();\n+        assertTrue(b.isEmpty());\n+\n+        SpinedBuffer.Of<String> b2 = new SpinedBuffer.Of<String>(32);\n+        assertTrue(b.isEmpty());\n+\n+        b2.accept(\"a\");\n+        assertFalse(b2.isEmpty());\n+    }\n+ \n     @Test\n     public void testIntEmpty() {\n         SpinedBuffer.OfInt b = new SpinedBuffer.OfInt();\n@@ -121,6 +157,27 @@ public void testDoubleEmpty() {\n     }\n \n \n+    @Test\n+    public void testCount() {\n+        SpinedBuffer.Of<String> b = new SpinedBuffer.Of<String>();\n+        assertEquals(0, b.count());\n+\n+        b.accept(\"a\");\n+        b.accept(\"b\");\n+        b.accept(\"c\");\n+\n+        assertEquals(3, b.count());\n+        for(char ch = 'd'; ch < 'q'; ch++) {\n+            b.accept(String.valueOf(ch));\n+        }\n+\n+        assertEquals(16, b.count());\n+\n+        b.accept(\"q\");\n+\n+        assertEquals(17, b.count());\n+    }\n+\n     @Test\n     public void testIntCount() {\n         SpinedBuffer.OfInt b = new SpinedBuffer.OfInt();\n@@ -188,6 +245,26 @@ public void testDoubleCount() {\n     }\n \n \n+    @Test\n+    public void testAccept() {\n+        SpinedBuffer.Of<String> b = new SpinedBuffer.Of<String>();\n+\n+        for(int i = 0; i < 1000; i++)\n+            b.accept(Integer.toString(i));\n+\n+        assertEquals(b.count(), 1000);\n+        assertEquals(b.capacity(), 1024);\n+\n+        for(int i = 0; i < 1000; i++) {\n+            String s = Integer.toString(i);\n+            assertEquals(s, b.get(i));\n+        }\n+\n+        SpinedBuffer.Of<String> b2 = new SpinedBuffer.Of<String>();\n+        b2.accept(\"abc\");\n+        assertEquals(b2.get(0), \"abc\");\n+    }\n+\n     @Test\n     public void testIntAccept() {\n         SpinedBuffer.OfInt b = new SpinedBuffer.OfInt();\n@@ -243,85 +320,100 @@ public void testDoubleAccept() {\n     }\n \n \n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testGetOutOfBounds() {\n+        SpinedBuffer.Of<String> b = new SpinedBuffer.Of<String>();\n+        for (int i = 0; i < 5; i++)\n+            b.accept(\"a\");\n+        // test when special case - one chunk(<16 elements) present\n+        b.get(10);\n+    }\n+\n     @Test(expected = IndexOutOfBoundsException.class)\n     public void testIntGetOutOfBounds() {\n         SpinedBuffer.OfInt b = new SpinedBuffer.OfInt();\n-\n-        for(int i = 0; i < 5; i++)\n+        for (int i = 0; i < 5; i++)\n             b.accept(i);\n-\n         // test when special case - one chunk(<16 elements) present\n         b.get(10);\n     }\n \n     @Test(expected = IndexOutOfBoundsException.class)\n     public void testLongGetOutOfBounds() {\n         SpinedBuffer.OfLong b = new SpinedBuffer.OfLong();\n-\n-        for(long i = 0; i < 5; i++)\n+        for (long i = 0; i < 5; i++)\n             b.accept(i);\n-\n         // test when special case - one chunk(<16 elements) present\n         b.get(10);\n     }\n \n     @Test(expected = IndexOutOfBoundsException.class)\n     public void testDoubleGetOutOfBounds() {\n         SpinedBuffer.OfDouble b = new SpinedBuffer.OfDouble();\n-\n-        for(int i = 0; i < 5; i++)\n+        for (int i = 0; i < 5; i++)\n             b.accept(i);\n-\n         // test when special case - one chunk(<16 elements) present\n         b.get(10);\n     }\n \n \n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testGetOutOfBounds2() {\n+        SpinedBuffer.Of<String> b = new SpinedBuffer.Of<String>();\n+        for (int i = 0; i < 32; i++)\n+            b.accept(\"a\");\n+        // test when spine(several chunks, >16 elements)\n+        b.get(40);\n+    }\n+\n     @Test(expected = IndexOutOfBoundsException.class)\n     public void testIntGetOutOfBounds2() {\n         SpinedBuffer.OfInt b = new SpinedBuffer.OfInt();\n-\n-        for(int i = 0; i < 32; i++)\n+        for (int i = 0; i < 32; i++)\n             b.accept(i);\n-\n         // test when spine(several chunks, >16 elements)\n         b.get(40);\n     }\n \n     @Test(expected = IndexOutOfBoundsException.class)\n     public void testLongGetOutOfBounds2() {\n         SpinedBuffer.OfLong b = new SpinedBuffer.OfLong();\n-\n-        for(long i = 0; i < 32; i++)\n+        for (long i = 0; i < 32; i++)\n             b.accept(i);\n-\n         // test when spine(several chunks, >16 elements)\n         b.get(40);\n     }\n \n     @Test(expected = IndexOutOfBoundsException.class)\n     public void testDoubleGetOutOfBounds2() {\n         SpinedBuffer.OfDouble b = new SpinedBuffer.OfDouble();\n-\n-        for(int i = 0; i < 32; i++)\n+        for (int i = 0; i < 32; i++)\n             b.accept(i);\n-\n         // test when spine(several chunks, >16 elements)\n         b.get(40);\n     }\n \n \n+    @SuppressWarnings(\"RedundantCast\")\n     @Test\n-    public void testIntEnsureCapacity() {\n-        SpinedBuffer.OfInt b = new SpinedBuffer.OfInt();\n-\n+    public void testEnsureCapacity() {\n+        SpinedBuffer.Of<String> b = new SpinedBuffer.Of<String>();\n         int m = SpinedBuffer.MIN_CHUNK_POWER;\n+        int count = (1<<m) + (1<<m) + (1<<m+1) + (1<<m+2) + (1<<m + 3) + (1<<m+4) + (1<<m+5) + (1<<m+6);\n+        for (int i = 0; i < count; i++)\n+            b.accept(\"a\");\n+        b.accept(\"b\");\n \n-        int count = (1<<m)+ (1<<m) + (1<<m+1) + (1<<m+2) + (1<<m + 3) + (1<<m+4) + (1<<m+5) + (1<<m+6);\n+        assertEquals(16, ((Object[][])b.spine).length);\n+    }\n \n-        for(int i = 0; i < count; i++)\n+    @Test\n+    public void testIntEnsureCapacity() {\n+        SpinedBuffer.OfInt b = new SpinedBuffer.OfInt();\n+        int m = SpinedBuffer.MIN_CHUNK_POWER;\n+        int count = (1<<m) + (1<<m) + (1<<m+1) + (1<<m+2) + (1<<m + 3) + (1<<m+4) + (1<<m+5) + (1<<m+6);\n+        for (int i = 0; i < count; i++)\n             b.accept(i);\n-\n         b.accept(42);\n \n         assertEquals(16, b.spine.length);\n@@ -330,14 +422,10 @@ public void testIntEnsureCapacity() {\n     @Test\n     public void testLongEnsureCapacity() {\n         SpinedBuffer.OfLong b = new SpinedBuffer.OfLong();\n-\n         long m = SpinedBuffer.MIN_CHUNK_POWER;\n-\n-        long count = (1<<m)+ (1<<m) + (1<<m+1) + (1<<m+2) + (1<<m + 3) + (1<<m+4) + (1<<m+5) + (1<<m+6);\n-\n-        for(long i = 0; i < count; i++)\n+        long count = (1<<m) + (1<<m) + (1<<m+1) + (1<<m+2) + (1<<m + 3) + (1<<m+4) + (1<<m+5) + (1<<m+6);\n+        for (long i = 0; i < count; i++)\n             b.accept(i);\n-\n         b.accept(42);\n \n         assertEquals(16, b.spine.length);\n@@ -346,38 +434,49 @@ public void testLongEnsureCapacity() {\n     @Test\n     public void testDoubleEnsureCapacity() {\n         SpinedBuffer.OfDouble b = new SpinedBuffer.OfDouble();\n-\n         int m = SpinedBuffer.MIN_CHUNK_POWER;\n-\n-        int count = (1<<m)+ (1<<m) + (1<<m+1) + (1<<m+2) + (1<<m + 3) + (1<<m+4) + (1<<m+5) + (1<<m+6);\n-\n-        for(int i = 0; i < count; i++)\n+        int count = (1<<m) + (1<<m) + (1<<m+1) + (1<<m+2) + (1<<m + 3) + (1<<m+4) + (1<<m+5) + (1<<m+6);\n+        for (int i = 0; i < count; i++)\n             b.accept(i);\n-\n         b.accept(42);\n \n         assertEquals(16, b.spine.length);\n     }\n \n \n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testChunkForUnreachableEndException() {\n+        SpinedBuffer.Of<String> b = new SpinedBuffer.Of<String>() {\n+            @Override\n+            public long count() {\n+                long superCount = super.count();\n+                if (superCount == 200)\n+                    return 1024;\n+                return superCount;\n+            }\n+        };\n+\n+        // fill some data to fill first chunk and a bit more\n+        for (int i = 0; i < 200; i++)\n+            b.accept(\"a\");\n+        b.chunkFor(300);\n+    }\n+\n     @Test(expected = IndexOutOfBoundsException.class)\n     public void testIntChunkForUnreachableEndException() {\n         SpinedBuffer.OfInt b = new SpinedBuffer.OfInt() {\n             @Override\n             public long count() {\n                 long superCount = super.count();\n-\n-                if(superCount == 200)\n+                if (superCount == 200)\n                     return 1024;\n-\n                 return superCount;\n             }\n         };\n \n         // fill some data to fill first chunk and a bit more\n-        for(int i = 0; i < 200; i++)\n+        for (int i = 0; i < 200; i++)\n             b.accept(i);\n-\n         b.chunkFor(300);\n     }\n \n@@ -387,18 +486,15 @@ public void testLongChunkForUnreachableEndException() {\n             @Override\n             public long count() {\n                 long superCount = super.count();\n-\n-                if(superCount == 200)\n+                if (superCount == 200)\n                     return 1024;\n-\n                 return superCount;\n             }\n         };\n \n         // fill some data to fill first chunk and a bit more\n-        for(long i = 0; i < 200; i++)\n+        for (long i = 0; i < 200; i++)\n             b.accept(i);\n-\n         b.chunkFor(300);\n     }\n \n@@ -408,44 +504,57 @@ public void testDoubleChunkForUnreachableEndException() {\n             @Override\n             public long count() {\n                 long superCount = super.count();\n-\n-                if(superCount == 200)\n+                if (superCount == 200)\n                     return 1024;\n-\n                 return superCount;\n             }\n         };\n \n         // fill some data to fill first chunk and a bit more\n-        for(int i = 0; i < 200; i++)\n+        for (int i = 0; i < 200; i++)\n             b.accept(i);\n-\n         b.chunkFor(300);\n     }\n \n \n+    @Test\n+    public void testToArray() {\n+        SpinedBuffer.Of<String> e = new SpinedBuffer.Of<String>();\n+        IntFunction<String[]> arrayFactory = arrayGenerator(String[].class);\n+\n+        String[] empty = e.asArray(arrayFactory);\n+        assertEquals(empty.length, 0);\n+\n+        e.accept(\"a\");\n+        String[] single = e.asArray(arrayFactory);\n+        assertEquals(single.length, 1);\n+\n+        SpinedBuffer.Of<String> b = new SpinedBuffer.Of<String>();\n+        for (int i = 0; i < 52; i++)\n+            b.accept(Integer.toString(i*2));\n+        String[] strings = b.asArray(arrayFactory);\n+        for (int i = 0; i < 52; i++) {\n+            String s = Integer.toString(i*2);\n+            assertEquals(s, strings[i]);\n+        }\n+    }\n+\n     @Test\n     public void testIntToArray() {\n         SpinedBuffer.OfInt e = new SpinedBuffer.OfInt();\n \n         int[] empty = e.asPrimitiveArray();\n-\n         assertEquals(empty.length, 0);\n \n         e.accept(42);\n-\n         int[] single = e.asPrimitiveArray();\n-\n         assertEquals(single.length, 1);\n \n         SpinedBuffer.OfInt b = new SpinedBuffer.OfInt();\n-\n-        for(int i = 0; i < 52; i++)\n+        for (int i = 0; i < 52; i++)\n             b.accept(i*2);\n-\n         int[] ints = b.asPrimitiveArray();\n-\n-        for(int i = 0; i < 52; i++)\n+        for (int i = 0; i < 52; i++)\n             assertEquals(i*2, ints[i]);\n     }\n \n@@ -454,23 +563,17 @@ public void testLongToArray() {\n         SpinedBuffer.OfLong e = new SpinedBuffer.OfLong();\n \n         long[] empty = e.asPrimitiveArray();\n-\n         assertEquals(empty.length, 0);\n \n         e.accept(42);\n-\n         long[] single = e.asPrimitiveArray();\n-\n         assertEquals(single.length, 1);\n \n         SpinedBuffer.OfLong b = new SpinedBuffer.OfLong();\n-\n-        for(long i = 0; i < 52; i++)\n+        for (long i = 0; i < 52; i++)\n             b.accept(i*2);\n-\n         long[] longs = b.asPrimitiveArray();\n-\n-        for(int i = 0; i < 52; i++)\n+        for (int i = 0; i < 52; i++)\n             assertEquals(i*2, longs[i]);\n     }\n \n@@ -479,27 +582,32 @@ public void testDoubleToArray() {\n         SpinedBuffer.OfDouble e = new SpinedBuffer.OfDouble();\n \n         double[] empty = e.asPrimitiveArray();\n-\n         assertEquals(empty.length, 0);\n \n         e.accept(42);\n-\n         double[] single = e.asPrimitiveArray();\n-\n         assertEquals(single.length, 1);\n \n         SpinedBuffer.OfDouble b = new SpinedBuffer.OfDouble();\n-\n-        for(int i = 0; i < 52; i++)\n+        for (int i = 0; i < 52; i++)\n             b.accept(i*2);\n-\n         double[] doubles = b.asPrimitiveArray();\n-\n-        for(int i = 0; i < 52; i++)\n+        for (int i = 0; i < 52; i++)\n             assertThat(doubles[i], closeTo(i * 2, 0.0001));\n     }\n \n \n+    @Test(expected = IllegalArgumentException.class)\n+    public void testToArrayTooBig() {\n+        SpinedBuffer.Of<String> b = new SpinedBuffer.Of<String>() {\n+            @Override\n+            public long count() {\n+                return Compat.MAX_ARRAY_SIZE;\n+            }\n+        };\n+        b.asArray(arrayGenerator(String[].class));\n+    }\n+\n     @Test(expected = IllegalArgumentException.class)\n     public void testIntToArrayTooBig() {\n         SpinedBuffer.OfInt b = new SpinedBuffer.OfInt() {\n@@ -508,7 +616,6 @@ public long count() {\n                 return Compat.MAX_ARRAY_SIZE;\n             }\n         };\n-\n         b.asPrimitiveArray();\n     }\n \n@@ -520,7 +627,6 @@ public long count() {\n                 return Compat.MAX_ARRAY_SIZE;\n             }\n         };\n-\n         b.asPrimitiveArray();\n     }\n \n@@ -532,145 +638,147 @@ public long count() {\n                 return Compat.MAX_ARRAY_SIZE;\n             }\n         };\n-\n         b.asPrimitiveArray();\n     }\n \n \n+    @Test\n+    public void testClear() {\n+        SpinedBuffer.Of<String> b = new SpinedBuffer.Of<String>();\n+        for (int i = 0; i < 1024; i++)\n+            b.accept(\"a\");\n+        b.clear();\n+        assertNull(b.spine);\n+        assertEquals(0, b.elementIndex);\n+        assertEquals(0, b.spineIndex);\n+\n+        SpinedBuffer.Of<String> b2 = new SpinedBuffer.Of<String>();\n+        b2.accept(\"a\");\n+        b2.clear();\n+        assertEquals(0, b2.elementIndex);\n+        assertEquals(0, b2.spineIndex);\n+\n+        SpinedBuffer.Of<String> b3 = new SpinedBuffer.Of<String>();\n+        b3.clear();\n+        assertEquals(0, b3.count());\n+        assertEquals(0, b3.elementIndex);\n+    }\n+\n     @Test\n     public void testIntClear() {\n         SpinedBuffer.OfInt b = new SpinedBuffer.OfInt();\n-\n-        for(int i = 0; i < 1024; i++)\n+        for (int i = 0; i < 1024; i++)\n             b.accept(i);\n-\n         b.clear();\n-\n         assertNull(b.spine);\n         assertEquals(0, b.elementIndex);\n         assertEquals(0, b.spineIndex);\n \n         SpinedBuffer.OfInt b2 = new SpinedBuffer.OfInt();\n-\n         b2.accept(42);\n-\n         b2.clear();\n-\n         assertEquals(0, b2.elementIndex);\n         assertEquals(0, b2.spineIndex);\n \n         SpinedBuffer.OfInt b3 = new SpinedBuffer.OfInt();\n-\n         b3.clear();\n-\n         assertEquals(0, b3.count());\n         assertEquals(0, b3.elementIndex);\n     }\n \n     @Test\n     public void testLongClear() {\n         SpinedBuffer.OfLong b = new SpinedBuffer.OfLong();\n-\n-        for(long i = 0; i < 1024; i++)\n+        for (long i = 0; i < 1024; i++)\n             b.accept(i);\n-\n         b.clear();\n-\n         assertNull(b.spine);\n         assertEquals(0, b.elementIndex);\n         assertEquals(0, b.spineIndex);\n \n         SpinedBuffer.OfLong b2 = new SpinedBuffer.OfLong();\n-\n         b2.accept(42);\n-\n         b2.clear();\n-\n         assertEquals(0, b2.elementIndex);\n         assertEquals(0, b2.spineIndex);\n \n         SpinedBuffer.OfLong b3 = new SpinedBuffer.OfLong();\n-\n         b3.clear();\n-\n         assertEquals(0, b3.count());\n         assertEquals(0, b3.elementIndex);\n     }\n \n     @Test\n     public void testDoubleClear() {\n         SpinedBuffer.OfDouble b = new SpinedBuffer.OfDouble();\n-\n-        for(int i = 0; i < 1024; i++)\n+        for (int i = 0; i < 1024; i++)\n             b.accept(i);\n-\n         b.clear();\n-\n         assertNull(b.spine);\n         assertEquals(0, b.elementIndex);\n         assertEquals(0, b.spineIndex);\n \n         SpinedBuffer.OfDouble b2 = new SpinedBuffer.OfDouble();\n-\n         b2.accept(42);\n-\n         b2.clear();\n-\n         assertEquals(0, b2.elementIndex);\n         assertEquals(0, b2.spineIndex);\n \n         SpinedBuffer.OfDouble b3 = new SpinedBuffer.OfDouble();\n-\n         b3.clear();\n-\n         assertEquals(0, b3.count());\n         assertEquals(0, b3.elementIndex);\n     }\n \n \n+    @Test\n+    public void testCopyInto() {\n+        SpinedBuffer.Of<String> b = new SpinedBuffer.Of<String>();\n+        String[] array = { \"\", \"\", \"\", \"\" };\n+\n+        b.copyInto(array, 0);\n+        assertEquals(\"\", array[0]);\n+\n+        b.accept(\"a\");\n+        b.copyInto(array, 0);\n+        assertEquals(\"a\", array[0]);\n+\n+        b.accept(\"b\");\n+        b.copyInto(array, 1);\n+        assertEquals(\"b\", array[2]);\n+    }\n+\n     @Test\n     public void testIntCopyInto() {\n         SpinedBuffer.OfInt b = new SpinedBuffer.OfInt();\n-\n         int[] array = new int[4];\n \n         b.copyInto(array, 0);\n-\n         assertEquals(0, array[0]);\n \n         b.accept(7);\n-\n         b.copyInto(array, 0);\n-\n         assertEquals(7, array[0]);\n \n         b.accept(9);\n-\n         b.copyInto(array, 1);\n-\n         assertEquals(9, array[2]);\n     }\n \n     @Test\n-    public void testLongCopyLongo() {\n+    public void testLongCopyInto() {\n         SpinedBuffer.OfLong b = new SpinedBuffer.OfLong();\n-\n         long[] array = new long[4];\n \n         b.copyInto(array, 0);\n-\n         assertEquals(0, array[0]);\n \n         b.accept(7);\n-\n         b.copyInto(array, 0);\n-\n         assertEquals(7, array[0]);\n \n         b.accept(9);\n-\n         b.copyInto(array, 1);\n-\n         assertEquals(9, array[2]);\n     }\n \n@@ -692,113 +800,121 @@ public void testDoubleCopyInto() {\n     }\n \n \n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testCopyIntoNotFit() {\n+        SpinedBuffer.Of<String> b = new SpinedBuffer.Of<String>();\n+        for (int i = 0; i < 64; i++)\n+            b.accept(\"a\");\n+        String[] array = new String[10];\n+        b.copyInto(array, 0);\n+    }\n+\n     @Test(expected = IndexOutOfBoundsException.class)\n     public void testIntCopyIntoNotFit() {\n         SpinedBuffer.OfInt b = new SpinedBuffer.OfInt();\n-\n-        for(int i = 0; i < 64; i++)\n+        for (int i = 0; i < 64; i++)\n             b.accept(i);\n-\n         int[] array = new int[10];\n-\n         b.copyInto(array, 0);\n     }\n \n     @Test(expected = IndexOutOfBoundsException.class)\n-    public void testLongCopyLongoNotFit() {\n+    public void testLongCopyIntoNotFit() {\n         SpinedBuffer.OfLong b = new SpinedBuffer.OfLong();\n-\n-        for(long i = 0; i < 64; i++)\n+        for (long i = 0; i < 64; i++)\n             b.accept(i);\n-\n         long[] array = new long[10];\n-\n         b.copyInto(array, 0);\n     }\n \n     @Test(expected = IndexOutOfBoundsException.class)\n     public void testDoubleCopyIntoNotFit() {\n         SpinedBuffer.OfDouble b = new SpinedBuffer.OfDouble();\n-\n-        for(int i = 0; i < 64; i++)\n+        for (int i = 0; i < 64; i++)\n             b.accept(i);\n-\n         double[] array = new double[10];\n-\n         b.copyInto(array, 0);\n     }\n \n \n+    @Test\n+    public void testIterator() {\n+        SpinedBuffer.Of<Integer> b = new SpinedBuffer.Of<Integer>();\n+        for (int i = 0; i < 255; i++)\n+            b.accept(i);\n+        for (Integer i : b) {\n+            assertTrue(i >= 0);\n+            assertTrue(i < 255);\n+        }\n+\n+        Iterator<Integer> iterator = b.iterator();\n+        int sum = 0;\n+        while (iterator.hasNext()) {\n+            sum += iterator.next();\n+        }\n+        assertEquals(32385, sum);\n+    }\n+\n     @Test\n     public void testIntIterator() {\n         SpinedBuffer.OfInt b = new SpinedBuffer.OfInt();\n-\n-        for(int i = 0; i < 255; i++)\n+        for (int i = 0; i < 255; i++)\n             b.accept(i);\n-\n-        for(Integer i: b) {\n+        for (Integer i : b) {\n             assertTrue(i >= 0);\n             assertTrue(i < 255);\n         }\n \n         PrimitiveIterator.OfInt iterator = b.iterator();\n-\n-        int sum2 = 0;\n-\n-        while(iterator.hasNext()) {\n-            sum2 += iterator.nextInt();\n+        int sum = 0;\n+        while (iterator.hasNext()) {\n+            sum += iterator.nextInt();\n         }\n-\n-        assertEquals(32385, sum2);\n+        assertEquals(32385, sum);\n     }\n \n     @Test\n     public void testLongIterator() {\n         SpinedBuffer.OfLong b = new SpinedBuffer.OfLong();\n-\n-        for(long i = 0; i < 255; i++)\n+        for (long i = 0; i < 255; i++)\n             b.accept(i);\n-\n-        for(Long i : b) {\n+        for (Long i : b) {\n             assertTrue(i >= 0);\n             assertTrue(i < 255);\n         }\n \n         PrimitiveIterator.OfLong iterator = b.iterator();\n-\n-        long sum2 = 0;\n-\n+        long sum = 0;\n         while(iterator.hasNext()) {\n-            sum2 += iterator.nextLong();\n+            sum += iterator.nextLong();\n         }\n-\n-        assertEquals(32385, sum2);\n+        assertEquals(32385, sum);\n     }\n \n     @Test\n     public void testDoubleIterator() {\n         SpinedBuffer.OfDouble b = new SpinedBuffer.OfDouble();\n-\n-        for(int i = 0; i < 255; i++)\n+        for (int i = 0; i < 255; i++)\n             b.accept(i);\n-\n-        for(Double i : b) {\n+        for (Double i : b) {\n             assertTrue(i >= 0);\n             assertTrue(i < 255);\n         }\n \n         PrimitiveIterator.OfDouble iterator = b.iterator();\n-\n-        int sum2 = 0;\n-\n+        int sum = 0;\n         while(iterator.hasNext()) {\n-            sum2 += iterator.nextDouble();\n+            sum += iterator.nextDouble();\n         }\n-\n-        assertEquals(32385, sum2);\n+        assertEquals(32385, sum);\n     }\n \n \n+    @Test(expected = UnsupportedOperationException.class)\n+    public void testIteratorRemove() {\n+        new SpinedBuffer.Of<String>().iterator().remove();\n+    }\n+\n     @Test(expected = UnsupportedOperationException.class)\n     public void testIntIteratorRemove() {\n         new SpinedBuffer.OfInt().iterator().remove();\n@@ -813,10 +929,4 @@ public void testLongIteratorRemove() {\n     public void testDoubleIteratorRemove() {\n         new SpinedBuffer.OfDouble().iterator().remove();\n     }\n-\n-\n-    @Test\n-    public void testPrivateConstructor() {\n-        assertThat(SpinedBuffer.class, hasOnlyPrivateConstructors());\n-    }\n }"
  },
  {
    "sha": "e9cde02074638b6ef5e18cdc17835988980ed1c3",
    "filename": "stream/src/test/java/com/annimon/stream/intstreamtests/MapMultiTest.java",
    "status": "added",
    "additions": 61,
    "deletions": 0,
    "changes": 61,
    "blob_url": "https://github.com/aNNiMON/Lightweight-Stream-API/blob/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/intstreamtests/MapMultiTest.java",
    "raw_url": "https://github.com/aNNiMON/Lightweight-Stream-API/raw/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/intstreamtests/MapMultiTest.java",
    "contents_url": "https://api.github.com/repos/aNNiMON/Lightweight-Stream-API/contents/stream/src/test/java/com/annimon/stream/intstreamtests/MapMultiTest.java?ref=a9f959be57a872d0f5354dff9218ed5acedd9869",
    "patch": "@@ -0,0 +1,61 @@\n+package com.annimon.stream.intstreamtests;\n+\n+import com.annimon.stream.IntStream;\n+import com.annimon.stream.function.IntConsumer;\n+import java.util.NoSuchElementException;\n+import org.junit.Test;\n+import static com.annimon.stream.test.hamcrest.IntStreamMatcher.assertElements;\n+import static com.annimon.stream.test.hamcrest.IntStreamMatcher.assertIsEmpty;\n+import static org.hamcrest.Matchers.arrayContaining;\n+\n+public final class MapMultiTest {\n+\n+    @Test\n+    public void testMapMulti() {\n+        IntStream.of(10, 20, 30)\n+                .mapMulti(new IntStream.IntMapMultiConsumer() {\n+                    @Override\n+                    public void accept(int value, IntConsumer consumer) {\n+                        consumer.accept(value);\n+                        consumer.accept(-value);\n+                    }\n+                })\n+                .custom(assertElements(arrayContaining(\n+                        10, -10,\n+                        20, -20,\n+                        30, -30\n+                )));\n+\n+        IntStream.of(10, 20, -30)\n+                .mapMulti(new IntStream.IntMapMultiConsumer() {\n+                    @Override\n+                    public void accept(int value, IntConsumer consumer) {\n+                        if (value < 0) {\n+                            consumer.accept(value);\n+                        }\n+                    }\n+                })\n+                .custom(assertElements(arrayContaining(\n+                        -30\n+                )));\n+    }\n+\n+    @Test(expected = NoSuchElementException.class)\n+    public void testMapMultiIterator() {\n+        IntStream.empty().mapMulti(new IntStream.IntMapMultiConsumer() {\n+            @Override\n+            public void accept(int value, IntConsumer consumer) {\n+                consumer.accept(value);\n+            }\n+        }).iterator().nextInt();\n+    }\n+\n+    @Test\n+    public void testMapMultiEmpty() {\n+        IntStream.of(1, 2).mapMulti(new IntStream.IntMapMultiConsumer() {\n+            @Override\n+            public void accept(int value, IntConsumer consumer) {\n+            }\n+        }).custom(assertIsEmpty());\n+    }\n+}"
  },
  {
    "sha": "afe01dcc1ce87fea0638a8007aab3ef86a747e22",
    "filename": "stream/src/test/java/com/annimon/stream/longstreamtests/MapMultiTest.java",
    "status": "added",
    "additions": 61,
    "deletions": 0,
    "changes": 61,
    "blob_url": "https://github.com/aNNiMON/Lightweight-Stream-API/blob/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/longstreamtests/MapMultiTest.java",
    "raw_url": "https://github.com/aNNiMON/Lightweight-Stream-API/raw/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/longstreamtests/MapMultiTest.java",
    "contents_url": "https://api.github.com/repos/aNNiMON/Lightweight-Stream-API/contents/stream/src/test/java/com/annimon/stream/longstreamtests/MapMultiTest.java?ref=a9f959be57a872d0f5354dff9218ed5acedd9869",
    "patch": "@@ -0,0 +1,61 @@\n+package com.annimon.stream.longstreamtests;\n+\n+import com.annimon.stream.LongStream;\n+import com.annimon.stream.function.LongConsumer;\n+import java.util.NoSuchElementException;\n+import org.junit.Test;\n+import static com.annimon.stream.test.hamcrest.LongStreamMatcher.assertElements;\n+import static com.annimon.stream.test.hamcrest.LongStreamMatcher.assertIsEmpty;\n+import static org.hamcrest.Matchers.arrayContaining;\n+\n+public final class MapMultiTest {\n+\n+    @Test\n+    public void testMapMulti() {\n+        LongStream.of(10L, 20L, 30L)\n+                .mapMulti(new LongStream.LongMapMultiConsumer() {\n+                    @Override\n+                    public void accept(long value, LongConsumer consumer) {\n+                        consumer.accept(value);\n+                        consumer.accept(-value);\n+                    }\n+                })\n+                .custom(assertElements(arrayContaining(\n+                        10L, -10L,\n+                        20L, -20L,\n+                        30L, -30L\n+                )));\n+\n+        LongStream.of(10L, 20L, -30L)\n+                .mapMulti(new LongStream.LongMapMultiConsumer() {\n+                    @Override\n+                    public void accept(long value, LongConsumer consumer) {\n+                        if (value < 0) {\n+                            consumer.accept(value);\n+                        }\n+                    }\n+                })\n+                .custom(assertElements(arrayContaining(\n+                        -30L\n+                )));\n+    }\n+\n+    @Test(expected = NoSuchElementException.class)\n+    public void testMapMultiIterator() {\n+        LongStream.empty().mapMulti(new LongStream.LongMapMultiConsumer() {\n+            @Override\n+            public void accept(long value, LongConsumer consumer) {\n+                consumer.accept(value);\n+            }\n+        }).iterator().nextLong();\n+    }\n+\n+    @Test\n+    public void testMapMultiEmpty() {\n+        LongStream.of(1, 2).mapMulti(new LongStream.LongMapMultiConsumer() {\n+            @Override\n+            public void accept(long value, LongConsumer consumer) {\n+            }\n+        }).custom(assertIsEmpty());\n+    }\n+}"
  },
  {
    "sha": "5c52ba8dd790c367c2f60ca511639d4818108903",
    "filename": "stream/src/test/java/com/annimon/stream/streamtests/MapMultiTest.java",
    "status": "added",
    "additions": 43,
    "deletions": 0,
    "changes": 43,
    "blob_url": "https://github.com/aNNiMON/Lightweight-Stream-API/blob/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/streamtests/MapMultiTest.java",
    "raw_url": "https://github.com/aNNiMON/Lightweight-Stream-API/raw/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/streamtests/MapMultiTest.java",
    "contents_url": "https://api.github.com/repos/aNNiMON/Lightweight-Stream-API/contents/stream/src/test/java/com/annimon/stream/streamtests/MapMultiTest.java?ref=a9f959be57a872d0f5354dff9218ed5acedd9869",
    "patch": "@@ -0,0 +1,43 @@\n+package com.annimon.stream.streamtests;\n+\n+import com.annimon.stream.Stream;\n+import com.annimon.stream.function.BiConsumer;\n+import com.annimon.stream.function.Consumer;\n+import com.annimon.stream.test.hamcrest.StreamMatcher;\n+import org.junit.Test;\n+import static com.annimon.stream.test.hamcrest.StreamMatcher.assertElements;\n+import static org.hamcrest.Matchers.contains;\n+\n+public final class MapMultiTest {\n+\n+    @Test\n+    public void testMapMulti() {\n+        Stream.rangeClosed(2, 4)\n+                .mapMulti(new BiConsumer<Integer, Consumer<String>>() {\n+                    @Override\n+                    public void accept(Integer i, Consumer<String> consumer) {\n+                        consumer.accept(String.format(\"%d * 2 = %d\", i, (i*2)));\n+                        consumer.accept(String.format(\"%d * 4 = %d\", i, (i*4)));\n+                    }\n+                })\n+                .custom(assertElements(contains(\n+                        \"2 * 2 = 4\",\n+                        \"2 * 4 = 8\",\n+                        \"3 * 2 = 6\",\n+                        \"3 * 4 = 12\",\n+                        \"4 * 2 = 8\",\n+                        \"4 * 4 = 16\"\n+                )));\n+    }\n+\n+    @Test\n+    public void testMapMultiEmpty() {\n+        Stream.rangeClosed(2, 4)\n+                .mapMulti(new BiConsumer<Integer, Consumer<String>>() {\n+                    @Override\n+                    public void accept(Integer i, Consumer<String> consumer) {\n+                    }\n+                })\n+                .custom(StreamMatcher.<String>assertIsEmpty());\n+    }\n+}"
  },
  {
    "sha": "16c26b6c8e88d676c660e2a0faf45612208dc52b",
    "filename": "stream/src/test/java/com/annimon/stream/streamtests/MapMultiToDoubleTest.java",
    "status": "added",
    "additions": 43,
    "deletions": 0,
    "changes": 43,
    "blob_url": "https://github.com/aNNiMON/Lightweight-Stream-API/blob/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/streamtests/MapMultiToDoubleTest.java",
    "raw_url": "https://github.com/aNNiMON/Lightweight-Stream-API/raw/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/streamtests/MapMultiToDoubleTest.java",
    "contents_url": "https://api.github.com/repos/aNNiMON/Lightweight-Stream-API/contents/stream/src/test/java/com/annimon/stream/streamtests/MapMultiToDoubleTest.java?ref=a9f959be57a872d0f5354dff9218ed5acedd9869",
    "patch": "@@ -0,0 +1,43 @@\n+package com.annimon.stream.streamtests;\n+\n+import com.annimon.stream.Stream;\n+import com.annimon.stream.function.BiConsumer;\n+import com.annimon.stream.function.DoubleConsumer;\n+import org.junit.Test;\n+import static com.annimon.stream.test.hamcrest.DoubleStreamMatcher.assertElements;\n+import static com.annimon.stream.test.hamcrest.DoubleStreamMatcher.assertIsEmpty;\n+import static org.hamcrest.Matchers.array;\n+import static org.hamcrest.Matchers.closeTo;\n+\n+public final class MapMultiToDoubleTest {\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void testMapMultiToDouble() {\n+        Stream.of(2, 4)\n+                .mapMultiToDouble(new BiConsumer<Integer, DoubleConsumer>() {\n+                    @Override\n+                    public void accept(Integer value, DoubleConsumer consumer) {\n+                        consumer.accept(value / 10d);\n+                        consumer.accept(value / 20d);\n+                    }\n+                })\n+                .custom(assertElements(array(\n+                        closeTo(0.2, 0.0001),\n+                        closeTo(0.1, 0.0001),\n+                        closeTo(0.4, 0.0001),\n+                        closeTo(0.2, 0.0001)\n+                )));\n+    }\n+\n+    @Test\n+    public void testMapMultiToDoubleEmpty() {\n+        Stream.rangeClosed(2, 4)\n+                .mapMultiToDouble(new BiConsumer<Integer, DoubleConsumer>() {\n+                    @Override\n+                    public void accept(Integer value, DoubleConsumer consumer) {\n+                    }\n+                })\n+                .custom(assertIsEmpty());\n+    }\n+}"
  },
  {
    "sha": "58caa43cc25f2d577cc91ea83a0d378f2775d2b5",
    "filename": "stream/src/test/java/com/annimon/stream/streamtests/MapMultiToIntTest.java",
    "status": "added",
    "additions": 41,
    "deletions": 0,
    "changes": 41,
    "blob_url": "https://github.com/aNNiMON/Lightweight-Stream-API/blob/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/streamtests/MapMultiToIntTest.java",
    "raw_url": "https://github.com/aNNiMON/Lightweight-Stream-API/raw/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/streamtests/MapMultiToIntTest.java",
    "contents_url": "https://api.github.com/repos/aNNiMON/Lightweight-Stream-API/contents/stream/src/test/java/com/annimon/stream/streamtests/MapMultiToIntTest.java?ref=a9f959be57a872d0f5354dff9218ed5acedd9869",
    "patch": "@@ -0,0 +1,41 @@\n+package com.annimon.stream.streamtests;\n+\n+import com.annimon.stream.Stream;\n+import com.annimon.stream.function.BiConsumer;\n+import com.annimon.stream.function.IntConsumer;\n+import org.junit.Test;\n+import static com.annimon.stream.test.hamcrest.IntStreamMatcher.assertElements;\n+import static com.annimon.stream.test.hamcrest.IntStreamMatcher.assertIsEmpty;\n+import static org.hamcrest.Matchers.arrayContaining;\n+\n+public final class MapMultiToIntTest {\n+\n+    @Test\n+    public void testMapMultiToInt() {\n+        Stream.rangeClosed(2, 4)\n+                .mapMultiToInt(new BiConsumer<Integer, IntConsumer>() {\n+                    @Override\n+                    public void accept(Integer value, IntConsumer consumer) {\n+                        for (int i = 0; i < value; i++) {\n+                            consumer.accept(value);\n+                        }\n+                    }\n+                })\n+                .custom(assertElements(arrayContaining(\n+                        2, 2,\n+                        3, 3, 3,\n+                        4, 4, 4, 4\n+                )));\n+    }\n+\n+    @Test\n+    public void testMapMultiToIntEmpty() {\n+        Stream.rangeClosed(2, 4)\n+                .mapMultiToInt(new BiConsumer<Integer, IntConsumer>() {\n+                    @Override\n+                    public void accept(Integer value, IntConsumer consumer) {\n+                    }\n+                })\n+                .custom(assertIsEmpty());\n+    }\n+}"
  },
  {
    "sha": "bcc59a0673ca42ed9dfbe1b44310e93ea9edd2b7",
    "filename": "stream/src/test/java/com/annimon/stream/streamtests/MapMultiToLongTest.java",
    "status": "added",
    "additions": 41,
    "deletions": 0,
    "changes": 41,
    "blob_url": "https://github.com/aNNiMON/Lightweight-Stream-API/blob/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/streamtests/MapMultiToLongTest.java",
    "raw_url": "https://github.com/aNNiMON/Lightweight-Stream-API/raw/a9f959be57a872d0f5354dff9218ed5acedd9869/stream/src/test/java/com/annimon/stream/streamtests/MapMultiToLongTest.java",
    "contents_url": "https://api.github.com/repos/aNNiMON/Lightweight-Stream-API/contents/stream/src/test/java/com/annimon/stream/streamtests/MapMultiToLongTest.java?ref=a9f959be57a872d0f5354dff9218ed5acedd9869",
    "patch": "@@ -0,0 +1,41 @@\n+package com.annimon.stream.streamtests;\n+\n+import com.annimon.stream.Stream;\n+import com.annimon.stream.function.BiConsumer;\n+import com.annimon.stream.function.LongConsumer;\n+import org.junit.Test;\n+import static com.annimon.stream.test.hamcrest.LongStreamMatcher.assertElements;\n+import static com.annimon.stream.test.hamcrest.LongStreamMatcher.assertIsEmpty;\n+import static org.hamcrest.Matchers.arrayContaining;\n+\n+public final class MapMultiToLongTest {\n+\n+    @Test\n+    public void testMapMultiToLong() {\n+        Stream.rangeClosed(2L, 4L)\n+                .mapMultiToLong(new BiConsumer<Long, LongConsumer>() {\n+                    @Override\n+                    public void accept(Long value, LongConsumer consumer) {\n+                        for (long i = 0; i < value; i++) {\n+                            consumer.accept(value);\n+                        }\n+                    }\n+                })\n+                .custom(assertElements(arrayContaining(\n+                        2L, 2L,\n+                        3L, 3L, 3L,\n+                        4L, 4L, 4L, 4L\n+                )));\n+    }\n+\n+    @Test\n+    public void testMapMultiToLongEmpty() {\n+        Stream.rangeClosed(2L, 4L)\n+                .mapMultiToLong(new BiConsumer<Long, LongConsumer>() {\n+                    @Override\n+                    public void accept(Long value, LongConsumer consumer) {\n+                    }\n+                })\n+                .custom(assertIsEmpty());\n+    }\n+}"
  }
]
