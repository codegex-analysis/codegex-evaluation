[
  {
    "sha": "2dda49b11edf6258ef079d6477cb2c0aa871bd5a",
    "filename": "core/pom.xml",
    "status": "modified",
    "additions": 112,
    "deletions": 36,
    "changes": 148,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/pom.xml",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/pom.xml",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/pom.xml?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -25,12 +25,12 @@\n     <parent>\n         <groupId>io.undertow</groupId>\n         <artifactId>undertow-parent</artifactId>\n-        <version>1.4.0.Beta1-SNAPSHOT</version>\n+        <version>1.4.29.Final-SNAPSHOT</version>\n     </parent>\n \n     <groupId>io.undertow</groupId>\n     <artifactId>undertow-core</artifactId>\n-    <version>1.4.0.Beta1-SNAPSHOT</version>\n+    <version>1.4.29.Final-SNAPSHOT</version>\n \n     <name>Undertow Core</name>\n \n@@ -40,8 +40,12 @@\n         <proxy>false</proxy>\n         <dump>false</dump>\n         <https>false</https>\n+        <openssl>false</openssl>\n         <test.ipv6>false</test.ipv6>\n         <bufferSize>8192</bufferSize>\n+        <libraryPath></libraryPath>\n+        <java.library.path></java.library.path>\n+        <org.wildfly.openssl.path></org.wildfly.openssl.path>\n     </properties>\n \n     <dependencies>\n@@ -135,6 +139,13 @@\n             <artifactId>h2</artifactId>\n             <scope>test</scope>\n         </dependency>\n+\n+        <dependency>\n+            <groupId>org.wildfly.openssl</groupId>\n+            <artifactId>wildfly-openssl</artifactId>\n+            <version>${version.org.wildfly.openssl}</version>\n+            <scope>test</scope>\n+        </dependency>\n     </dependencies>\n \n \n@@ -158,17 +169,48 @@\n         </testResources>\n \n         <plugins>\n+            <plugin>\n+                <groupId>org.apache.felix</groupId>\n+                <artifactId>maven-bundle-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <id>generate-manifest</id>\n+                        <goals>\n+                            <goal>manifest</goal>\n+                        </goals>\n+                        <configuration>\n+                            <instructions>\n+                                <Export-Package>\n+                                    io.undertow.*;version=${project.version};-noimport:=true\n+                                </Export-Package>\n+                                <Import-Package>\n+                                    org.eclipse.jetty.*;resolution:=optional;version=\"[1,2)\",\n+                                    !., !sun.*, !org.xnio._private, *\n+                                </Import-Package>\n+                            </instructions>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n             <plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-jar-plugin</artifactId>\n                 <executions>\n                     <execution>\n+                        <id>test-jar</id>\n                         <goals>\n-                            <goal>jar</goal>\n                             <goal>test-jar</goal>\n                         </goals>\n+                        <configuration>\n+                            <classifier>tests</classifier>\n+                        </configuration>\n                     </execution>\n                 </executions>\n+                <configuration>\n+                    <archive>\n+                        <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>\n+                    </archive>\n+                </configuration>\n             </plugin>\n             <plugin>\n                 <groupId>org.bitstrings.maven.plugins</groupId>\n@@ -194,22 +236,87 @@\n                         <test.proxy>${proxy}</test.proxy>\n                         <test.dump>${dump}</test.dump>\n                         <test.https>${https}</test.https>\n+                        <test.openssl>${openssl}</test.openssl>\n                         <test.bufferSize>${bufferSize}</test.bufferSize>\n                         <default.server.address>localhost</default.server.address>\n                         <default.server.port>7777</default.server.port>\n                         <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n                         <test.level>${test.level}</test.level>\n                         <java.net.preferIPv6Addresses>${test.ipv6}</java.net.preferIPv6Addresses>\n-                        <alpn-boot-string>${alpn-boot-string}</alpn-boot-string>\n                         <sun.net.useExclusiveBind>false</sun.net.useExclusiveBind>\n+                        <org.wildfly.openssl.path>${org.wildfly.openssl.path}</org.wildfly.openssl.path>\n                     </systemPropertyVariables>\n-                    <argLine>${alpn-boot-string} ${jacoco.agent.argLine} ${surefire.system.args}</argLine>\n+                    <argLine>${jacoco.agent.argLine} ${surefire.system.args} ${libraryPath}</argLine>\n                 </configuration>\n             </plugin>\n         </plugins>\n     </build>\n \n     <profiles>\n+\n+        <profile>\n+            <id>mac</id>\n+            <activation>\n+                <os>\n+                    <family>mac</family>\n+                </os>\n+            </activation>\n+            <properties>\n+                <org.wildfly.openssl.path>/usr/local/opt/openssl/lib</org.wildfly.openssl.path>\n+            </properties>\n+        </profile>\n+\n+        <profile>\n+            <id>openssl</id>\n+            <activation>\n+                <property><name>test.openssl</name></property>\n+            </activation>\n+            <properties>\n+                <libraryPath>-Djava.library.path=${java.library.path}</libraryPath>\n+            </properties>\n+        </profile>\n+\n+        <profile>\n+            <id>jetty-alpn</id>\n+            <activation>\n+                <property><name>jetty-alpn</name></property>\n+            </activation>\n+            <dependencies>\n+                <dependency>\n+                    <groupId>org.mortbay.jetty.alpn</groupId>\n+                    <artifactId>alpn-boot</artifactId>\n+                    <version>${version.org.mortbay.jetty.alpn}</version>\n+                    <scope>test</scope>\n+                </dependency>\n+            </dependencies>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins</groupId>\n+                        <artifactId>maven-surefire-plugin</artifactId>\n+                        <configuration>\n+                            <enableAssertions>true</enableAssertions>\n+                            <runOrder>reversealphabetical</runOrder>\n+                            <systemPropertyVariables>\n+                                <io.undertow.disable-jdk8-alpn>true</io.undertow.disable-jdk8-alpn>\n+                                <test.proxy>true</test.proxy>\n+                                <test.dump>${dump}</test.dump>\n+                                <test.bufferSize>${bufferSize}</test.bufferSize>\n+                                <default.server.address>localhost</default.server.address>\n+                                <default.server.port>7777</default.server.port>\n+                                <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+                                <test.level>${test.level}</test.level>\n+                                <java.net.preferIPv6Addresses>${test.ipv6}</java.net.preferIPv6Addresses>\n+                                <sun.net.useExclusiveBind>false</sun.net.useExclusiveBind>\n+                                <alpn-boot-string>true</alpn-boot-string>\n+                            </systemPropertyVariables>\n+                            <reportsDirectory>${project.build.directory}/surefire-proxy-reports</reportsDirectory>\n+                        </configuration>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+\n         <profile>\n             <id>proxy</id>\n             <build>\n@@ -236,7 +343,6 @@\n                                         <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n                                         <test.level>${test.level}</test.level>\n                                         <java.net.preferIPv6Addresses>${test.ipv6}</java.net.preferIPv6Addresses>\n-                                        <alpn-boot-string>${alpn-boot-string}</alpn-boot-string>\n                                         <sun.net.useExclusiveBind>false</sun.net.useExclusiveBind>\n                                     </systemPropertyVariables>\n                                     <reportsDirectory>${project.build.directory}/surefire-proxy-reports</reportsDirectory>\n@@ -261,37 +367,11 @@\n                                         </java.util.logging.manager>\n                                         <test.level>${test.level}</test.level>\n                                         <java.net.preferIPv6Addresses>${test.ipv6}</java.net.preferIPv6Addresses>\n-                                        <alpn-boot-string>${alpn-boot-string}</alpn-boot-string>\n                                         <sun.net.useExclusiveBind>false</sun.net.useExclusiveBind>\n                                     </systemPropertyVariables>\n                                     <reportsDirectory>${project.build.directory}/surefire-ajp-reports</reportsDirectory>\n                                 </configuration>\n                             </execution>\n-                            <execution>\n-                                <id>proxy-spdy</id>\n-                                <phase>test</phase>\n-                                <goals>\n-                                    <goal>test</goal>\n-                                </goals>\n-                                <configuration>\n-                                    <enableAssertions>true</enableAssertions>\n-                                    <runOrder>reversealphabetical</runOrder>\n-                                    <systemPropertyVariables>\n-                                        <test.spdy>true</test.spdy>\n-                                        <test.dump>${dump}</test.dump>\n-                                        <test.bufferSize>${bufferSize}</test.bufferSize>\n-                                        <default.server.address>localhost</default.server.address>\n-                                        <default.server.port>7777</default.server.port>\n-                                        <java.util.logging.manager>org.jboss.logmanager.LogManager\n-                                        </java.util.logging.manager>\n-                                        <test.level>${test.level}</test.level>\n-                                        <java.net.preferIPv6Addresses>${test.ipv6}</java.net.preferIPv6Addresses>\n-                                        <alpn-boot-string>${alpn-boot-string}</alpn-boot-string>\n-                                        <sun.net.useExclusiveBind>false</sun.net.useExclusiveBind>\n-                                    </systemPropertyVariables>\n-                                    <reportsDirectory>${project.build.directory}/surefire-spdy-reports</reportsDirectory>\n-                                </configuration>\n-                            </execution>\n                             <execution>\n                                 <id>proxy-https</id>\n                                 <phase>test</phase>\n@@ -311,7 +391,6 @@\n                                         </java.util.logging.manager>\n                                         <test.level>${test.level}</test.level>\n                                         <java.net.preferIPv6Addresses>${test.ipv6}</java.net.preferIPv6Addresses>\n-                                        <alpn-boot-string>${alpn-boot-string}</alpn-boot-string>\n                                         <sun.net.useExclusiveBind>false</sun.net.useExclusiveBind>\n                                     </systemPropertyVariables>\n                                     <reportsDirectory>${project.build.directory}/surefire-https-reports</reportsDirectory>\n@@ -336,7 +415,6 @@\n                                         </java.util.logging.manager>\n                                         <test.level>${test.level}</test.level>\n                                         <java.net.preferIPv6Addresses>${test.ipv6}</java.net.preferIPv6Addresses>\n-                                        <alpn-boot-string>${alpn-boot-string}</alpn-boot-string>\n                                         <sun.net.useExclusiveBind>false</sun.net.useExclusiveBind>\n                                     </systemPropertyVariables>\n                                     <reportsDirectory>${project.build.directory}/surefire-h2-reports</reportsDirectory>\n@@ -361,7 +439,6 @@\n                                         </java.util.logging.manager>\n                                         <test.level>${test.level}</test.level>\n                                         <java.net.preferIPv6Addresses>${test.ipv6}</java.net.preferIPv6Addresses>\n-                                        <alpn-boot-string>${alpn-boot-string}</alpn-boot-string>\n                                         <sun.net.useExclusiveBind>false</sun.net.useExclusiveBind>\n                                     </systemPropertyVariables>\n                                     <reportsDirectory>${project.build.directory}/surefire-h2c-reports</reportsDirectory>\n@@ -387,7 +464,6 @@\n                                         </java.util.logging.manager>\n                                         <test.level>${test.level}</test.level>\n                                         <java.net.preferIPv6Addresses>${test.ipv6}</java.net.preferIPv6Addresses>\n-                                        <alpn-boot-string>${alpn-boot-string}</alpn-boot-string>\n                                         <sun.net.useExclusiveBind>false</sun.net.useExclusiveBind>\n                                     </systemPropertyVariables>\n                                     <reportsDirectory>${project.build.directory}/surefire-h2c-upgrade-reports</reportsDirectory>"
  },
  {
    "sha": "dd93d51f932602569e958ed53e75118799b19769",
    "filename": "core/src/main/java/io/undertow/Handlers.java",
    "status": "modified",
    "additions": 3,
    "deletions": 4,
    "changes": 7,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/Handlers.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/Handlers.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/Handlers.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -45,7 +45,6 @@\n import io.undertow.server.handlers.RequestDumpingHandler;\n import io.undertow.server.handlers.RequestLimit;\n import io.undertow.server.handlers.RequestLimitingHandler;\n-import io.undertow.server.handlers.ResponseCodeHandler;\n import io.undertow.server.handlers.ResponseRateLimitingHandler;\n import io.undertow.server.handlers.SetAttributeHandler;\n import io.undertow.server.handlers.SetHeaderHandler;\n@@ -487,7 +486,7 @@ public static RequestLimitingHandler requestLimitingHandler(final RequestLimit r\n      * @return The proxy handler\n      */\n     public static ProxyHandler proxyHandler(ProxyClient proxyClient, int maxRequestTime, HttpHandler next) {\n-        return new ProxyHandler(proxyClient, maxRequestTime, next);\n+        return ProxyHandler.builder().setProxyClient(proxyClient).setNext(next).setMaxRequestTime(maxRequestTime).build();\n     }\n     /**\n      * Returns a handler that can act as a load balancing reverse proxy.\n@@ -497,7 +496,7 @@ public static ProxyHandler proxyHandler(ProxyClient proxyClient, int maxRequestT\n      * @return The proxy handler\n      */\n     public static ProxyHandler proxyHandler(ProxyClient proxyClient, HttpHandler next) {\n-        return new ProxyHandler(proxyClient, next);\n+        return ProxyHandler.builder().setProxyClient(proxyClient).setNext(next).build();\n     }\n \n     /**\n@@ -507,7 +506,7 @@ public static ProxyHandler proxyHandler(ProxyClient proxyClient, HttpHandler nex\n      * @return The proxy handler\n      */\n     public static ProxyHandler proxyHandler(ProxyClient proxyClient) {\n-        return new ProxyHandler(proxyClient, ResponseCodeHandler.HANDLE_404);\n+        return ProxyHandler.builder().setProxyClient(proxyClient).build();\n     }\n \n     /**"
  },
  {
    "sha": "3223526e2ee522c9148de20fe876d3a4812bab0b",
    "filename": "core/src/main/java/io/undertow/Undertow.java",
    "status": "modified",
    "additions": 275,
    "deletions": 40,
    "changes": 315,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/Undertow.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/Undertow.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/Undertow.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -18,35 +18,42 @@\n \n package io.undertow;\n \n+import io.undertow.connector.ByteBufferPool;\n import io.undertow.protocols.ssl.UndertowXnioSsl;\n+import io.undertow.server.ConnectorStatistics;\n import io.undertow.server.DefaultByteBufferPool;\n import io.undertow.server.HttpHandler;\n+import io.undertow.server.OpenListener;\n import io.undertow.server.protocol.ajp.AjpOpenListener;\n import io.undertow.server.protocol.http.AlpnOpenListener;\n import io.undertow.server.protocol.http.HttpOpenListener;\n import io.undertow.server.protocol.http2.Http2OpenListener;\n-import io.undertow.server.protocol.spdy.SpdyOpenListener;\n+import io.undertow.server.protocol.http2.Http2UpgradeHandler;\n+import io.undertow.server.protocol.proxy.ProxyProtocolOpenListener;\n import org.xnio.ChannelListener;\n import org.xnio.ChannelListeners;\n import org.xnio.IoUtils;\n import org.xnio.Option;\n import org.xnio.OptionMap;\n import org.xnio.Options;\n-import io.undertow.connector.ByteBufferPool;\n import org.xnio.StreamConnection;\n import org.xnio.Xnio;\n import org.xnio.XnioWorker;\n import org.xnio.channels.AcceptingChannel;\n-import org.xnio.ssl.SslConnection;\n-import org.xnio.ssl.XnioSsl;\n+import org.xnio.ssl.JsseSslUtils;\n \n import javax.net.ssl.KeyManager;\n import javax.net.ssl.SSLContext;\n import javax.net.ssl.TrustManager;\n+import java.io.IOException;\n import java.net.Inet4Address;\n import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.security.SecureRandom;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * Convenience class used to build an Undertow server.\n@@ -61,6 +68,7 @@\n     private final int workerThreads;\n     private final boolean directBuffers;\n     private final List<ListenerConfig> listeners = new ArrayList<>();\n+    private volatile List<ListenerInfo> listenerInfo;\n     private final HttpHandler rootHandler;\n     private final OptionMap workerOptions;\n     private final OptionMap socketOptions;\n@@ -70,22 +78,24 @@\n      * Will be true when a {@link XnioWorker} instance was NOT provided to the {@link Builder}.\n      * When true, a new worker will be created during {@link Undertow#start()},\n      * and shutdown when {@link Undertow#stop()} is called.\n-     *\n+     * <p>\n      * Will be false when a {@link XnioWorker} instance was provided to the {@link Builder}.\n      * When false, the provided {@link #worker} will be used instead of creating a new one in {@link Undertow#start()}.\n      * Also, when false, the {@link #worker} will NOT be shutdown when {@link Undertow#stop()} is called.\n      */\n     private final boolean internalWorker;\n \n+    private ByteBufferPool byteBufferPool;\n     private XnioWorker worker;\n     private List<AcceptingChannel<? extends StreamConnection>> channels;\n     private Xnio xnio;\n \n     private Undertow(Builder builder) {\n-        this.bufferSize = builder.bufferSize;\n+        this.byteBufferPool = builder.byteBufferPool;\n+        this.bufferSize = byteBufferPool != null ? byteBufferPool.getBufferSize() : builder.bufferSize;\n+        this.directBuffers = byteBufferPool != null ? byteBufferPool.isDirect() : builder.directBuffers;\n         this.ioThreads = builder.ioThreads;\n         this.workerThreads = builder.workerThreads;\n-        this.directBuffers = builder.directBuffers;\n         this.listeners.addAll(builder.listeners);\n         this.rootHandler = builder.handler;\n         this.worker = builder.worker;\n@@ -103,6 +113,7 @@ public static Builder builder() {\n     }\n \n     public synchronized void start() {\n+        UndertowLogger.ROOT_LOGGER.debugf(\"starting undertow server %s\", this);\n         xnio = Xnio.getInstance(Undertow.class.getClassLoader());\n         channels = new ArrayList<>();\n         try {\n@@ -129,103 +140,181 @@ public synchronized void start() {\n                     .addAll(this.socketOptions)\n                     .getMap();\n \n+            OptionMap serverOptions = OptionMap.builder()\n+                    .set(UndertowOptions.NO_REQUEST_TIMEOUT, 60 * 1000)\n+                    .addAll(this.serverOptions)\n+                    .getMap();\n \n-            ByteBufferPool buffers = new DefaultByteBufferPool(directBuffers, bufferSize, -1, 4);\n \n+            ByteBufferPool buffers = this.byteBufferPool;\n+            if (buffers == null) {\n+                buffers = new DefaultByteBufferPool(directBuffers, bufferSize, -1, 4);\n+            }\n+\n+            listenerInfo = new ArrayList<>();\n             for (ListenerConfig listener : listeners) {\n+                UndertowLogger.ROOT_LOGGER.debugf(\"Configuring listener with protocol %s for interface %s and port %s\", listener.type, listener.host, listener.port);\n                 final HttpHandler rootHandler = listener.rootHandler != null ? listener.rootHandler : this.rootHandler;\n                 if (listener.type == ListenerType.AJP) {\n                     AjpOpenListener openListener = new AjpOpenListener(buffers, serverOptions);\n                     openListener.setRootHandler(rootHandler);\n-                    ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(openListener);\n-                    AcceptingChannel<? extends StreamConnection> server = worker.createStreamConnectionServer(new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), acceptListener, socketOptions);\n+\n+                    final ChannelListener<StreamConnection> finalListener;\n+                    if (listener.useProxyProtocol) {\n+                        finalListener = new ProxyProtocolOpenListener(openListener, null, buffers, OptionMap.EMPTY);\n+                    } else {\n+                        finalListener = openListener;\n+                    }\n+                    ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(finalListener);\n+                    OptionMap socketOptionsWithOverrides = OptionMap.builder().addAll(socketOptions).addAll(listener.overrideSocketOptions).getMap();\n+                    AcceptingChannel<? extends StreamConnection> server = worker.createStreamConnectionServer(new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), acceptListener, socketOptionsWithOverrides);\n                     server.resumeAccepts();\n                     channels.add(server);\n+                    listenerInfo.add(new ListenerInfo(\"ajp\", server.getLocalAddress(), openListener, null, server));\n                 } else {\n                     OptionMap undertowOptions = OptionMap.builder().set(UndertowOptions.BUFFER_PIPELINED_DATA, true).addAll(serverOptions).getMap();\n+                    boolean http2 = serverOptions.get(UndertowOptions.ENABLE_HTTP2, false);\n                     if (listener.type == ListenerType.HTTP) {\n                         HttpOpenListener openListener = new HttpOpenListener(buffers, undertowOptions);\n-                        openListener.setRootHandler(rootHandler);\n-                        ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(openListener);\n-                        AcceptingChannel<? extends StreamConnection> server = worker.createStreamConnectionServer(new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), acceptListener, socketOptions);\n+                        HttpHandler handler = rootHandler;\n+                        if (http2) {\n+                            handler = new Http2UpgradeHandler(handler);\n+                        }\n+                        openListener.setRootHandler(handler);\n+                        final ChannelListener<StreamConnection> finalListener;\n+                        if (listener.useProxyProtocol) {\n+                            finalListener = new ProxyProtocolOpenListener(openListener, null, buffers, OptionMap.EMPTY);\n+                        } else {\n+                            finalListener = openListener;\n+                        }\n+\n+                        ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(finalListener);\n+                        OptionMap socketOptionsWithOverrides = OptionMap.builder().addAll(socketOptions).addAll(listener.overrideSocketOptions).getMap();\n+                        AcceptingChannel<? extends StreamConnection> server = worker.createStreamConnectionServer(new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), acceptListener, socketOptionsWithOverrides);\n                         server.resumeAccepts();\n                         channels.add(server);\n+                        listenerInfo.add(new ListenerInfo(\"http\", server.getLocalAddress(), openListener, null, server));\n                     } else if (listener.type == ListenerType.HTTPS) {\n-                        ChannelListener<StreamConnection> openListener;\n+                        OpenListener openListener;\n \n                         HttpOpenListener httpOpenListener = new HttpOpenListener(buffers, undertowOptions);\n                         httpOpenListener.setRootHandler(rootHandler);\n \n-                        boolean spdy = serverOptions.get(UndertowOptions.ENABLE_SPDY, false);\n-                        boolean http2 = serverOptions.get(UndertowOptions.ENABLE_HTTP2, false);\n-                        if(spdy || http2) {\n+                        if (http2) {\n                             AlpnOpenListener alpn = new AlpnOpenListener(buffers, undertowOptions, httpOpenListener);\n-                            if(spdy) {\n-                                SpdyOpenListener spdyListener = new SpdyOpenListener(buffers, new DefaultByteBufferPool(false, 1024, -1, 2, 0), undertowOptions);\n-                                spdyListener.setRootHandler(rootHandler);\n-                                alpn.addProtocol(SpdyOpenListener.SPDY_3_1, spdyListener, 5);\n-                            }\n-                            if(http2) {\n-                                Http2OpenListener http2Listener = new Http2OpenListener(buffers, undertowOptions);\n-                                http2Listener.setRootHandler(rootHandler);\n-                                alpn.addProtocol(Http2OpenListener.HTTP2, http2Listener, 10);\n-                                alpn.addProtocol(Http2OpenListener.HTTP2_14, http2Listener, 7);\n-                            }\n+                            Http2OpenListener http2Listener = new Http2OpenListener(buffers, undertowOptions);\n+                            http2Listener.setRootHandler(rootHandler);\n+                            alpn.addProtocol(Http2OpenListener.HTTP2, http2Listener, 10);\n+                            alpn.addProtocol(Http2OpenListener.HTTP2_14, http2Listener, 7);\n                             openListener = alpn;\n                         } else {\n                             openListener = httpOpenListener;\n                         }\n-                        ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(openListener);\n-                        XnioSsl xnioSsl;\n+\n+                        UndertowXnioSsl xnioSsl;\n                         if (listener.sslContext != null) {\n                             xnioSsl = new UndertowXnioSsl(xnio, OptionMap.create(Options.USE_DIRECT_BUFFERS, true), listener.sslContext);\n                         } else {\n-                            xnioSsl = xnio.getSslProvider(listener.keyManagers, listener.trustManagers, OptionMap.create(Options.USE_DIRECT_BUFFERS, true));\n+                            OptionMap.Builder builder = OptionMap.builder();\n+                            builder.addAll(listener.overrideSocketOptions);\n+                            if (!listener.overrideSocketOptions.contains(Options.SSL_PROTOCOL)) {\n+                                builder.set(Options.SSL_PROTOCOL, \"TLSv1.2\");\n+                            }\n+                            xnioSsl = new UndertowXnioSsl(xnio, OptionMap.create(Options.USE_DIRECT_BUFFERS, true), JsseSslUtils.createSSLContext(listener.keyManagers, listener.trustManagers, new SecureRandom(), builder.getMap()));\n                         }\n-                        AcceptingChannel<SslConnection> sslServer = xnioSsl.createSslConnectionServer(worker, new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), (ChannelListener) acceptListener, socketOptions);\n+\n+                        OptionMap socketOptionsWithOverrides = OptionMap.builder().addAll(socketOptions).addAll(listener.overrideSocketOptions).getMap();\n+                        AcceptingChannel<? extends StreamConnection> sslServer;\n+                        if (listener.useProxyProtocol) {\n+                            ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(new ProxyProtocolOpenListener(openListener, xnioSsl, buffers, socketOptionsWithOverrides));\n+                            sslServer = worker.createStreamConnectionServer(new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), (ChannelListener) acceptListener, socketOptionsWithOverrides);\n+                        } else {\n+                            ChannelListener<AcceptingChannel<StreamConnection>> acceptListener = ChannelListeners.openListenerAdapter(openListener);\n+                            sslServer = xnioSsl.createSslConnectionServer(worker, new InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), (ChannelListener) acceptListener, socketOptionsWithOverrides);\n+                        }\n+\n                         sslServer.resumeAccepts();\n                         channels.add(sslServer);\n+                        listenerInfo.add(new ListenerInfo(\"https\", sslServer.getLocalAddress(), openListener, xnioSsl, sslServer));\n                     }\n                 }\n \n             }\n \n         } catch (Exception e) {\n+            if(internalWorker && worker != null) {\n+                worker.shutdownNow();\n+            }\n             throw new RuntimeException(e);\n         }\n     }\n \n     public synchronized void stop() {\n-        for (AcceptingChannel<? extends StreamConnection> channel : channels) {\n-            IoUtils.safeClose(channel);\n+        UndertowLogger.ROOT_LOGGER.debugf(\"stopping undertow server %s\", this);\n+        if (channels != null) {\n+            for (AcceptingChannel<? extends StreamConnection> channel : channels) {\n+                IoUtils.safeClose(channel);\n+            }\n+            channels = null;\n         }\n-        channels = null;\n \n         /*\n          * Only shutdown the worker if it was created during start()\n          */\n-        if (internalWorker) {\n-            worker.shutdownNow();\n+        if (internalWorker && worker != null) {\n+            Integer shutdownTimeoutMillis = serverOptions.get(UndertowOptions.SHUTDOWN_TIMEOUT);\n+            worker.shutdown();\n+            try {\n+                if (shutdownTimeoutMillis == null) {\n+                    worker.awaitTermination();\n+                } else {\n+                    if (!worker.awaitTermination(shutdownTimeoutMillis, TimeUnit.MILLISECONDS)) {\n+                        worker.shutdownNow();\n+                    }\n+                }\n+            } catch (InterruptedException e) {\n+                worker.shutdownNow();\n+                throw new RuntimeException(e);\n+            }\n             worker = null;\n         }\n         xnio = null;\n+        listenerInfo = null;\n     }\n \n+    public Xnio getXnio() {\n+        return xnio;\n+    }\n \n-    public static enum ListenerType {\n+    public XnioWorker getWorker() {\n+        return worker;\n+    }\n+\n+    public List<ListenerInfo> getListenerInfo() {\n+        if (listenerInfo == null) {\n+            throw UndertowMessages.MESSAGES.serverNotStarted();\n+        }\n+        return Collections.unmodifiableList(listenerInfo);\n+    }\n+\n+\n+    public enum ListenerType {\n         HTTP,\n         HTTPS,\n         AJP\n     }\n \n     private static class ListenerConfig {\n+\n         final ListenerType type;\n         final int port;\n         final String host;\n         final KeyManager[] keyManagers;\n         final TrustManager[] trustManagers;\n         final SSLContext sslContext;\n         final HttpHandler rootHandler;\n+        final OptionMap overrideSocketOptions;\n+        final boolean useProxyProtocol;\n \n         private ListenerConfig(final ListenerType type, final int port, final String host, KeyManager[] keyManagers, TrustManager[] trustManagers, HttpHandler rootHandler) {\n             this.type = type;\n@@ -235,6 +324,8 @@ private ListenerConfig(final ListenerType type, final int port, final String hos\n             this.trustManagers = trustManagers;\n             this.rootHandler = rootHandler;\n             this.sslContext = null;\n+            this.overrideSocketOptions = OptionMap.EMPTY;\n+            this.useProxyProtocol = false;\n         }\n \n         private ListenerConfig(final ListenerType type, final int port, final String host, SSLContext sslContext, HttpHandler rootHandler) {\n@@ -245,6 +336,78 @@ private ListenerConfig(final ListenerType type, final int port, final String hos\n             this.keyManagers = null;\n             this.trustManagers = null;\n             this.sslContext = sslContext;\n+            this.overrideSocketOptions = OptionMap.EMPTY;\n+            this.useProxyProtocol = false;\n+        }\n+\n+        private ListenerConfig(final ListenerBuilder listenerBuilder) {\n+            this.type = listenerBuilder.type;\n+            this.port = listenerBuilder.port;\n+            this.host = listenerBuilder.host;\n+            this.rootHandler = listenerBuilder.rootHandler;\n+            this.keyManagers = listenerBuilder.keyManagers;\n+            this.trustManagers = listenerBuilder.trustManagers;\n+            this.sslContext = listenerBuilder.sslContext;\n+            this.overrideSocketOptions = listenerBuilder.overrideSocketOptions;\n+            this.useProxyProtocol = listenerBuilder.useProxyProtocol;\n+        }\n+    }\n+\n+    public static final class ListenerBuilder {\n+\n+        ListenerType type;\n+        int port;\n+        String host;\n+        KeyManager[] keyManagers;\n+        TrustManager[] trustManagers;\n+        SSLContext sslContext;\n+        HttpHandler rootHandler;\n+        OptionMap overrideSocketOptions = OptionMap.EMPTY;\n+        boolean useProxyProtocol;\n+\n+        public ListenerBuilder setType(ListenerType type) {\n+            this.type = type;\n+            return this;\n+        }\n+\n+        public ListenerBuilder setPort(int port) {\n+            this.port = port;\n+            return this;\n+        }\n+\n+        public ListenerBuilder setHost(String host) {\n+            this.host = host;\n+            return this;\n+        }\n+\n+        public ListenerBuilder setKeyManagers(KeyManager[] keyManagers) {\n+            this.keyManagers = keyManagers;\n+            return this;\n+        }\n+\n+        public ListenerBuilder setTrustManagers(TrustManager[] trustManagers) {\n+            this.trustManagers = trustManagers;\n+            return this;\n+        }\n+\n+        public ListenerBuilder setSslContext(SSLContext sslContext) {\n+            this.sslContext = sslContext;\n+            return this;\n+        }\n+\n+        public ListenerBuilder setRootHandler(HttpHandler rootHandler) {\n+            this.rootHandler = rootHandler;\n+            return this;\n+        }\n+\n+        public ListenerBuilder setOverrideSocketOptions(OptionMap overrideSocketOptions) {\n+            this.overrideSocketOptions = overrideSocketOptions;\n+            return this;\n+        }\n+\n+        public ListenerBuilder setUseProxyProtocol(boolean useProxyProtocol) {\n+            this.useProxyProtocol = useProxyProtocol;\n+            return this;\n         }\n     }\n \n@@ -257,6 +420,7 @@ private ListenerConfig(final ListenerType type, final int port, final String hos\n         private final List<ListenerConfig> listeners = new ArrayList<>();\n         private HttpHandler handler;\n         private XnioWorker worker;\n+        private ByteBufferPool byteBufferPool;\n \n         private final OptionMap.Builder workerOptions = OptionMap.builder();\n         private final OptionMap.Builder socketOptions = OptionMap.builder();\n@@ -279,7 +443,7 @@ private Builder() {\n                 //use 16k buffers for best performance\n                 //as 16k is generally the max amount of data that can be sent in a single write() call\n                 directBuffers = true;\n-                bufferSize = 1024 * 16;\n+                bufferSize = 1024 * 16 - 20; //the 20 is to allow some space for protocol headers, see UNDERTOW-1209\n             }\n \n         }\n@@ -300,6 +464,11 @@ public Builder addListener(int port, String host, ListenerType listenerType) {\n             return this;\n         }\n \n+        public Builder addListener(ListenerBuilder listenerBuilder) {\n+            listeners.add(new ListenerConfig(listenerBuilder));\n+            return this;\n+        }\n+\n         public Builder addHttpListener(int port, String host) {\n             listeners.add(new ListenerConfig(ListenerType.HTTP, port, host, null, null, null));\n             return this;\n@@ -339,6 +508,7 @@ public Builder addAjpListener(int port, String host, HttpHandler rootHandler) {\n             listeners.add(new ListenerConfig(ListenerType.AJP, port, host, null, null, rootHandler));\n             return this;\n         }\n+\n         public Builder setBufferSize(final int bufferSize) {\n             this.bufferSize = bufferSize;\n             return this;\n@@ -390,7 +560,7 @@ public Builder setHandler(final HttpHandler handler) {\n          * when {@link Undertow#start()} is called.\n          * Additionally, this newly created worker will be shutdown when {@link Undertow#stop()} is called.\n          * <br/>\n-         *\n+         * <p>\n          * When non-null, the provided {@link XnioWorker} will be reused instead of creating a new {@link XnioWorker}\n          * when {@link Undertow#start()} is called.\n          * Additionally, the provided {@link XnioWorker} will NOT be shutdown when {@link Undertow#stop()} is called.\n@@ -400,6 +570,71 @@ public Builder setHandler(final HttpHandler handler) {\n             this.worker = worker;\n             return this;\n         }\n+\n+        public <T> Builder setByteBufferPool(ByteBufferPool byteBufferPool) {\n+            this.byteBufferPool = byteBufferPool;\n+            return this;\n+        }\n+    }\n+\n+    public static class ListenerInfo {\n+\n+        private final String protcol;\n+        private final SocketAddress address;\n+        private final OpenListener openListener;\n+        private final UndertowXnioSsl ssl;\n+        private final AcceptingChannel<? extends StreamConnection> channel;\n+\n+        public ListenerInfo(String protcol, SocketAddress address, OpenListener openListener, UndertowXnioSsl ssl, AcceptingChannel<? extends StreamConnection> channel) {\n+            this.protcol = protcol;\n+            this.address = address;\n+            this.openListener = openListener;\n+            this.ssl = ssl;\n+            this.channel = channel;\n+        }\n+\n+        public String getProtcol() {\n+            return protcol;\n+        }\n+\n+        public SocketAddress getAddress() {\n+            return address;\n+        }\n+\n+        public SSLContext getSslContext() {\n+            if(ssl == null) {\n+                return null;\n+            }\n+            return ssl.getSslContext();\n+        }\n+\n+        public void setSslContext(SSLContext sslContext) {\n+            if(ssl != null) {\n+                //just ignore it if this is not a SSL listener\n+                ssl.updateSSLContext(sslContext);\n+            }\n+        }\n+\n+        public ConnectorStatistics getConnectorStatistics() {\n+            return openListener.getConnectorStatistics();\n+        }\n+\n+        public <T> void setSocketOption(Option<T>option, T value) throws IOException {\n+            channel.setOption(option, value);\n+        }\n+\n+        public void setServerOptions(OptionMap options) {\n+            openListener.setUndertowOptions(options);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"ListenerInfo{\" +\n+                    \"protcol='\" + protcol + '\\'' +\n+                    \", address=\" + address +\n+                    \", sslContext=\" + getSslContext() +\n+                    '}';\n+        }\n     }\n \n }"
  },
  {
    "sha": "eb6fbb09544555a7ccba22acfdbd2eabf8c99f26",
    "filename": "core/src/main/java/io/undertow/UndertowLogger.java",
    "status": "modified",
    "additions": 126,
    "deletions": 52,
    "changes": 178,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/UndertowLogger.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/UndertowLogger.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/UndertowLogger.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -19,8 +19,10 @@\n package io.undertow;\n \n import io.undertow.client.ClientConnection;\n+import io.undertow.protocols.ssl.SslConduit;\n import io.undertow.server.HttpServerExchange;\n import io.undertow.server.ServerConnection;\n+import io.undertow.server.handlers.sse.ServerSentEventConnection;\n import io.undertow.util.HeaderMap;\n import io.undertow.util.HttpString;\n import org.jboss.logging.BasicLogger;\n@@ -29,14 +31,14 @@\n import org.jboss.logging.annotations.LogMessage;\n import org.jboss.logging.annotations.Message;\n import org.jboss.logging.annotations.MessageLogger;\n+import org.xnio.ssl.SslConnection;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n import java.net.URI;\n import java.nio.file.Path;\n-import java.sql.SQLException;\n import java.util.Date;\n import java.util.List;\n \n@@ -57,6 +59,8 @@\n     UndertowLogger CLIENT_LOGGER = Logger.getMessageLogger(UndertowLogger.class, ClientConnection.class.getPackage().getName());\n \n     UndertowLogger REQUEST_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + \".request\");\n+    UndertowLogger SESSION_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + \".session\");\n+    UndertowLogger SECURITY_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + \".request.security\");\n     UndertowLogger PROXY_REQUEST_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + \".proxy\");\n     UndertowLogger REQUEST_DUMPER_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + \".request.dump\");\n     /**\n@@ -65,23 +69,23 @@\n      */\n     UndertowLogger REQUEST_IO_LOGGER = Logger.getMessageLogger(UndertowLogger.class, UndertowLogger.class.getPackage().getName() + \".request.io\");\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5001, value = \"An exception occurred processing the request\")\n     void exceptionProcessingRequest(@Cause Throwable cause);\n \n-    @LogMessage(level = INFO)\n-    @Message(id = 5002, value = \"Exception reading file %s: %s\")\n-    void exceptionReadingFile(final Path file, final IOException e);\n+//    @LogMessage(level = INFO)\n+//    @Message(id = 5002, value = \"Exception reading file %s: %s\")\n+//    void exceptionReadingFile(final Path file, final IOException e);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5003, value = \"IOException reading from channel\")\n     void ioExceptionReadingFromChannel(@Cause IOException e);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5005, value = \"Cannot remove uploaded file %s\")\n     void cannotRemoveUploadedFile(Path file);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = DEBUG)\n     @Message(id = 5006, value = \"Connection from %s terminated as request header was larger than %s\")\n     void requestHeaderWasTooLarge(SocketAddress address, int size);\n \n@@ -101,7 +105,7 @@\n     @Message(id = 5010, value = \"Verification of authentication tokens for user '%s' has failed using mechanism '%s'.\")\n     void authenticationFailed(final String userName, final String mechanism);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5011, value = \"Ignoring AJP request with prefix %s\")\n     void ignoringAjpRequestWithPrefixCode(byte prefix);\n \n@@ -110,90 +114,90 @@\n     void ioException(@Cause IOException e);\n \n     @LogMessage(level = DEBUG)\n-    @Message(id = 5014, value = \"Failed to parse HTTP request\")\n-    void failedToParseRequest(@Cause Exception e);\n+    @Message(id = 5014, value = \"Failed to parse request\")\n+    void failedToParseRequest(@Cause Throwable e);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5015, value = \"Error rotating access log\")\n     void errorRotatingAccessLog(@Cause IOException e);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5016, value = \"Error writing access log\")\n     void errorWritingAccessLog(@Cause IOException e);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n-    @Message(id = 5017, value = \"Unknown variable %s\")\n+    @LogMessage(level = ERROR)\n+    @Message(id = 5017, value = \"Unknown variable %s. For the literal percent character use two percent characters: '%%'\")\n     void unknownVariable(String token);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5018, value = \"Exception invoking close listener %s\")\n     void exceptionInvokingCloseListener(ServerConnection.CloseListener l, @Cause Throwable e);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n-    @Message(id = 5019, value = \"Cannot upgrade connection\")\n-    void cannotUpgradeConnection(@Cause Exception e);\n+//    @LogMessage(level = Logger.Level.ERROR)\n+//    @Message(id = 5019, value = \"Cannot upgrade connection\")\n+//    void cannotUpgradeConnection(@Cause Exception e);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5020, value = \"Error writing JDBC log\")\n-    void errorWritingJDBCLog(@Cause SQLException e);\n+    void errorWritingJDBCLog(@Cause Exception e);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n-    @Message(id = 5021, value = \"Proxy request to %s timed out\")\n-    void proxyRequestTimedOut(String requestURI);\n+//    @LogMessage(level = Logger.Level.ERROR)\n+//    @Message(id = 5021, value = \"Proxy request to %s timed out\")\n+//    void proxyRequestTimedOut(String requestURI);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5022, value = \"Exception generating error page %s\")\n     void exceptionGeneratingErrorPage(@Cause Exception e, String location);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5023, value = \"Exception handling request to %s\")\n     void exceptionHandlingRequest(@Cause Throwable t, String requestURI);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5024, value = \"Could not register resource change listener for caching resource manager, automatic invalidation of cached resource will not work\")\n     void couldNotRegisterChangeListener(@Cause Exception e);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n-    @Message(id = 5025, value = \"Could not initiate SPDY connection and no HTTP fallback defined\")\n-    void couldNotInitiateSpdyConnection();\n-\n-    @LogMessage(level = Logger.Level.ERROR)\n-    @Message(id = 5026, value = \"Jetty ALPN support not found on boot class path, %s client will not be available.\")\n-    void jettyALPNNotFound(String protocol);\n+//    @LogMessage(level = Logger.Level.ERROR)\n+//    @Message(id = 5025, value = \"Could not initiate SPDY connection and no HTTP fallback defined\")\n+//    void couldNotInitiateSpdyConnection();\n+//\n+//    @LogMessage(level = INFO)\n+//    @Message(id = 5026, value = \"Jetty ALPN support not found on boot class path, %s client will not be available.\")\n+//    void jettyALPNNotFound(String protocol);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5027, value = \"Timing out request to %s\")\n     void timingOutRequest(String requestURI);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5028, value = \"Proxy request to %s failed\")\n     void proxyRequestFailed(String requestURI, @Cause Exception e);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n-    @Message(id = 5030, value = \"Proxy request to %s could not resolve a backend server\")\n-    void proxyRequestFailedToResolveBackend(String requestURI);\n+//    @LogMessage(level = Logger.Level.ERROR)\n+//    @Message(id = 5030, value = \"Proxy request to %s could not resolve a backend server\")\n+//    void proxyRequestFailedToResolveBackend(String requestURI);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5031, value = \"Proxy request to %s could not connect to backend server %s\")\n     void proxyFailedToConnectToBackend(String requestURI, URI uri);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5032, value = \"Listener not making progress on framed channel, closing channel to prevent infinite loop\")\n     void listenerNotProgressing();\n \n-    @LogMessage(level = Logger.Level.ERROR)\n-    @Message(id = 5033, value = \"Failed to initiate HTTP2 connection\")\n-    void couldNotInitiateHttp2Connection();\n+//    @LogMessage(level = Logger.Level.ERROR)\n+//    @Message(id = 5033, value = \"Failed to initiate HTTP2 connection\")\n+//    void couldNotInitiateHttp2Connection();\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5034, value = \"Remote endpoint failed to send initial settings frame in HTTP2 connection, frame type %s\")\n     void remoteEndpointFailedToSendInitialSettings(int type);\n \n     @LogMessage(level = DEBUG)\n     @Message(id = 5035, value = \"Closing channel because of parse timeout for remote address %s\")\n     void parseRequestTimedOut(java.net.SocketAddress remoteAddress);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5036, value = \"ALPN negotiation failed for %s and no fallback defined, closing connection\")\n     void noALPNFallback(SocketAddress address);\n \n@@ -217,15 +221,15 @@ void balancerCreated(int id, String name, boolean stickySession, String stickySe\n     @Message(id = 5040, value = \"Gonna send payload:\\n%s\")\n     void proxyAdvertiseMessagePayload(String payload);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5041, value = \"Cannot send advertise message. Address: %s\")\n     void proxyAdvertiseCannotSendMessage(@Cause Exception e, InetSocketAddress address);\n \n     @LogMessage(level = DEBUG)\n     @Message(id = 5042, value = \"Undertow mod_cluster proxy MCMPHandler created\")\n     void mcmpHandlerCreated();\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5043, value = \"Error in processing MCMP commands: Type:%s, Mess: %s\")\n     void mcmpProcessingError(String type, String errString);\n \n@@ -257,11 +261,11 @@ void balancerCreated(int id, String name, boolean stickySession, String stickySe\n     void nodeConfigCreated(URI connectionURI, String balancer, String domain, String jvmRoute, boolean flushPackets, int flushwait, int ping, long ttl,\n                            int timeout, int maxConnections, int cacheConnections, int requestQueueSize, boolean queueNewRequests);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5050, value = \"Failed to process management request\")\n     void failedToProcessManagementReq(@Cause Exception e);\n \n-    @LogMessage(level = Logger.Level.ERROR)\n+    @LogMessage(level = ERROR)\n     @Message(id = 5051, value = \"Failed to send ping response\")\n     void failedToSendPingResponse(@Cause Exception e);\n \n@@ -293,7 +297,7 @@ void nodeConfigCreated(URI connectionURI, String balancer, String domain, String\n     @Message(id = 5058, value = \"Could not bind multicast socket to %s (%s address): %s; make sure your multicast address is of the same type as the IP stack (IPv4 or IPv6). Multicast socket will not be bound to an address, but this may lead to cross talking (see http://www.jboss.org/community/docs/DOC-9469 for details).\")\n     void potentialCrossTalking(InetAddress group, String s, String localizedMessage);\n \n-    @LogMessage(level = org.jboss.logging.Logger.Level.WARN)\n+    @LogMessage(level = WARN)\n     @Message(id = 5060, value = \"Predicate %s uses old style square braces to define predicates, which will be removed in a future release. predicate[value] should be changed to predicate(value)\")\n     void oldStylePredicateSyntax(String string);\n \n@@ -330,7 +334,7 @@ void nodeConfigCreated(URI connectionURI, String balancer, String domain, String\n \n     @LogMessage(level = ERROR)\n     @Message(id = 5069, value = \"Failed to write JDBC access log\")\n-    void failedToWriteJdbcAccessLog(@Cause SQLException e);\n+    void failedToWriteJdbcAccessLog(@Cause Exception e);\n \n     @LogMessage(level = ERROR)\n     @Message(id = 5070, value = \"Failed to write pre-cached file\")\n@@ -348,4 +352,74 @@ void nodeConfigCreated(URI connectionURI, String balancer, String domain, String\n     @Message(id = 5073, value = \"Thread %s (id=%s) was previously reported to be stuck but has completed. It was active for approximately %s milliseconds. There is/are still %s thread(s) that are monitored by this Valve and may be stuck.\")\n     void stuckThreadCompleted(String threadName, long threadId, long active, int stuckCount);\n \n+    @LogMessage(level = ERROR)\n+    @Message(id = 5074, value = \"Failed to invoke error callback %s for SSE task\")\n+    void failedToInvokeFailedCallback(ServerSentEventConnection.EventCallback callback, @Cause Exception e);\n+\n+    @Message(id = 5075, value = \"Unable to resolve mod_cluster management host's address for '%s'\")\n+    IllegalStateException unableToResolveModClusterManagementHost(String providedHost);\n+\n+    @LogMessage(level = ERROR)\n+    @Message(id = 5076, value = \"SSL read loop detected. This should not happen, please report this to the Undertow developers. Current state %s\")\n+    void sslReadLoopDetected(SslConduit sslConduit);\n+\n+    @LogMessage(level = ERROR)\n+    @Message(id = 5077, value = \"SSL unwrap buffer overflow detected. This should not happen, please report this to the Undertow developers. Current state %s\")\n+    void sslBufferOverflow(SslConduit sslConduit);\n+\n+//    @LogMessage(level = ERROR)\n+//    @Message(id = 5078, value = \"ALPN connection failed\")\n+//    void alpnConnectionFailed(@Cause Exception e);\n+\n+    @LogMessage(level = ERROR)\n+    @Message(id = 5079, value = \"ALPN negotiation on %s failed\")\n+    void alpnConnectionFailed(SslConnection connection);\n+\n+    @LogMessage(level = ERROR)\n+    @Message(id = 5080, value = \"HttpServerExchange cannot have both async IO resumed and dispatch() called in the same cycle\")\n+    void resumedAndDispatched();\n+\n+    @LogMessage(level = ERROR)\n+    @Message(id = 5081, value = \"Response has already been started, cannot proxy request %s\")\n+    void cannotProxyStartedRequest(HttpServerExchange exchange);\n+\n+    @Message(id = 5082, value = \"Configured mod_cluster management host address cannot be a wildcard address (%s)!\")\n+    IllegalArgumentException cannotUseWildcardAddressAsModClusterManagementHost(String providedAddress);\n+\n+    @Message(id = 5083, value = \"Unexpected end of compressed input\")\n+    IOException unexpectedEndOfCompressedInput();\n+\n+    @Message(id = 5084, value = \"Attempted to write %s bytes however content-length has been set to %s\")\n+    IOException dataLargerThanContentLength(long totalToWrite, long responseContentLength);\n+\n+    @LogMessage(level = ERROR)\n+    @Message(id = 5085, value = \"Connection %s for exchange %s was not closed cleanly, forcibly closing connection\")\n+    void responseWasNotTerminated(ServerConnection connection, HttpServerExchange exchange);\n+\n+    @LogMessage(level = ERROR)\n+    @Message(id = 5086, value = \"Failed to accept SSL request\")\n+    void failedToAcceptSSLRequest(@Cause Exception e);\n+\n+    @LogMessage(level = ERROR)\n+    @Message(id = 5087, value = \"Failed to use the server order\")\n+    void failedToUseServerOrder(@Cause ReflectiveOperationException e);\n+\n+    @LogMessage(level = ERROR)\n+    @Message(id = 5088, value = \"Failed to execute ServletOutputStream.closeAsync() on IO thread\")\n+    void closeAsyncFailed(@Cause IOException e);\n+\n+    @Message(id = 5089, value = \"Method parameter '%s' cannot be null\")\n+    IllegalArgumentException nullParameter(String name);\n+\n+    @LogMessage(level = ERROR)\n+    @Message(id = 5090, value = \"Unexpected failure\")\n+    void handleUnexpectedFailure(@Cause Throwable t);\n+\n+    @LogMessage(level = ERROR)\n+    @Message(id = 5091, value = \"Failed to initialize DirectByteBufferDeallocator\")\n+    void directBufferDeallocatorInitializationFailed(@Cause Throwable t);\n+\n+    @LogMessage(level = DEBUG)\n+    @Message(id = 5092, value = \"Failed to free direct buffer\")\n+    void directBufferDeallocationFailed(@Cause Throwable t);\n }"
  },
  {
    "sha": "3d15f29461f2901ba0bccd0ed7870ebd118b0c8c",
    "filename": "core/src/main/java/io/undertow/UndertowMessages.java",
    "status": "modified",
    "additions": 208,
    "deletions": 71,
    "changes": 279,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/UndertowMessages.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/UndertowMessages.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/UndertowMessages.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -19,18 +19,23 @@\n package io.undertow;\n \n import java.io.IOException;\n-import java.net.SocketAddress;\n import java.nio.channels.ClosedChannelException;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLPeerUnverifiedException;\n \n-import io.undertow.predicate.PredicateBuilder;\n-import io.undertow.protocols.http2.HpackException;\n-import io.undertow.server.handlers.builder.HandlerBuilder;\n+import io.undertow.server.RequestTooBigException;\n+import io.undertow.server.handlers.form.MultiPartParserDefinition;\n import org.jboss.logging.Messages;\n import org.jboss.logging.annotations.Cause;\n import org.jboss.logging.annotations.Message;\n import org.jboss.logging.annotations.MessageBundle;\n-\n-import javax.net.ssl.SSLPeerUnverifiedException;\n+import io.undertow.predicate.PredicateBuilder;\n+import io.undertow.protocols.http2.HpackException;\n+import io.undertow.security.api.AuthenticationMechanism;\n+import io.undertow.server.handlers.builder.HandlerBuilder;\n+import io.undertow.util.HttpString;\n+import io.undertow.util.ParameterLimitException;\n+import io.undertow.util.BadRequestException;\n \n /**\n  * @author Stuart Douglas\n@@ -64,8 +69,8 @@\n     @Message(id = 9, value = \"Path must be specified\")\n     IllegalArgumentException pathMustBeSpecified();\n \n-    @Message(id = 10, value = \"Session not found %s\")\n-    IllegalStateException sessionNotFound(final String session);\n+    @Message(id = 10, value = \"Session is invalid %s\")\n+    IllegalStateException sessionIsInvalid(String sessionId);\n \n     @Message(id = 11, value = \"Session manager must not be null\")\n     IllegalStateException sessionManagerMustNotBeNull();\n@@ -76,23 +81,23 @@\n     @Message(id = 13, value = \"Argument %s cannot be null\")\n     IllegalArgumentException argumentCannotBeNull(final String argument);\n \n-    @Message(id = 14, value = \"close() called with data still to be flushed. Please call shutdownWrites() and then call flush() until it returns true before calling close()\")\n-    IOException closeCalledWithDataStillToBeFlushed();\n+//    @Message(id = 14, value = \"close() called with data still to be flushed. Please call shutdownWrites() and then call flush() until it returns true before calling close()\")\n+//    IOException closeCalledWithDataStillToBeFlushed();\n+//\n+//    @Message(id = 16, value = \"Could not add cookie as cookie handler was not present in the handler chain\")\n+//    IllegalStateException cookieHandlerNotPresent();\n \n-    @Message(id = 16, value = \"Could not add cookie as cookie handler was not present in the handler chain\")\n-    IllegalStateException cookieHandlerNotPresent();\n-\n-    @Message(id = 17, value = \"Form value is a file, use getFile() instead\")\n+    @Message(id = 17, value = \"Form value is a file, use getFileItem() instead\")\n     IllegalStateException formValueIsAFile();\n \n     @Message(id = 18, value = \"Form value is a String, use getValue() instead\")\n     IllegalStateException formValueIsAString();\n-\n-    @Message(id = 19, value = \"Connection from %s terminated as request entity was larger than %s\")\n-    IOException requestEntityWasTooLarge(SocketAddress address, long size);\n+//\n+//    @Message(id = 19, value = \"Connection from %s terminated as request entity was larger than %s\")\n+//    IOException requestEntityWasTooLarge(SocketAddress address, long size);\n \n     @Message(id = 20, value = \"Connection terminated as request was larger than %s\")\n-    IOException requestEntityWasTooLarge(long size);\n+    RequestTooBigException requestEntityWasTooLarge(long size);\n \n     @Message(id = 21, value = \"Session already invalidated\")\n     IllegalStateException sessionAlreadyInvalidated();\n@@ -114,9 +119,9 @@\n \n     @Message(id = 27, value = \"Could not find session cookie config in the request\")\n     IllegalStateException couldNotFindSessionCookieConfig();\n-\n-    @Message(id = 28, value = \"Session %s already exists\")\n-    IllegalStateException sessionAlreadyExists(final String id);\n+//\n+//    @Message(id = 28, value = \"Session %s already exists\")\n+//    IllegalStateException sessionAlreadyExists(final String id);\n \n     @Message(id = 29, value = \"Channel was closed mid chunk, if you have attempted to write chunked data you cannot shutdown the channel until after it has all been written.\")\n     IOException chunkedChannelClosedMidChunk();\n@@ -126,9 +131,9 @@\n \n     @Message(id = 31, value = \"User %s has logged out.\")\n     String userLoggedOut(final String userName);\n-\n-    @Message(id = 33, value = \"Authentication type %s cannot be combined with %s\")\n-    IllegalStateException authTypeCannotBeCombined(String type, String existing);\n+//\n+//    @Message(id = 33, value = \"Authentication type %s cannot be combined with %s\")\n+//    IllegalStateException authTypeCannotBeCombined(String type, String existing);\n \n     @Message(id = 34, value = \"Stream is closed\")\n     IOException streamIsClosed();\n@@ -145,11 +150,11 @@\n     @Message(id = 38, value = \"Authentication failed, requested user name '%s'\")\n     String authenticationFailed(final String userName);\n \n-    @Message(id = 39, value = \"To many query parameters, cannot have more than %s query parameters\")\n-    RuntimeException tooManyQueryParameters(int noParams);\n+    @Message(id = 39, value = \"Too many query parameters, cannot have more than %s query parameters\")\n+    BadRequestException tooManyQueryParameters(int noParams);\n \n-    @Message(id = 40, value = \"To many headers, cannot have more than %s header\")\n-    RuntimeException tooManyHeaders(int noParams);\n+    @Message(id = 40, value = \"Too many headers, cannot have more than %s header\")\n+    String tooManyHeaders(int noParams);\n \n     @Message(id = 41, value = \"Channel is closed\")\n     ClosedChannelException channelIsClosed();\n@@ -170,7 +175,7 @@\n     IllegalStateException tooManyCookies(int maxCookies);\n \n     @Message(id = 47, value = \"The number of parameters exceeded the maximum of %s\")\n-    IllegalStateException tooManyParameters(int maxValues);\n+    ParameterLimitException tooManyParameters(int maxValues);\n \n     @Message(id = 48, value = \"No request is currently active\")\n     IllegalStateException noRequestActive();\n@@ -188,7 +193,7 @@\n     IllegalArgumentException listenerAlreadyRegistered(String name);\n \n     @Message(id = 54, value = \"The maximum size %s for an individual file in a multipart request was exceeded\")\n-    IOException maxFileSizeExceeded(long maxIndividualFileSize);\n+    MultiPartParserDefinition.FileTooLargeException maxFileSizeExceeded(long maxIndividualFileSize);\n \n     @Message(id = 55, value = \"Could not set attribute %s to %s as it is read only\")\n     String couldNotSetAttribute(String attributeName, String newValue);\n@@ -201,24 +206,24 @@\n \n     @Message(id = 58, value = \"More than one handler with name %s. Builder class %s and %s\")\n     IllegalStateException moreThanOneHandlerWithName(String name, Class<? extends HandlerBuilder> aClass, Class<? extends HandlerBuilder> existing);\n-\n-    @Message(id = 59, value = \"Invalid syntax %s\")\n-    IllegalArgumentException invalidSyntax(String line);\n-\n-    @Message(id = 60, value = \"Error parsing handler string %s:%n%s\")\n-    IllegalArgumentException errorParsingHandlerString(String reason, String s);\n+//\n+//    @Message(id = 59, value = \"Invalid syntax %s\")\n+//    IllegalArgumentException invalidSyntax(String line);\n+//\n+//    @Message(id = 60, value = \"Error parsing handler string %s:%n%s\")\n+//    IllegalArgumentException errorParsingHandlerString(String reason, String s);\n \n     @Message(id = 61, value = \"Out of band responses only allowed for 100-continue requests\")\n     IllegalArgumentException outOfBandResponseOnlyAllowedFor100Continue();\n-\n-    @Message(id = 62, value = \"AJP does not support HTTP upgrade\")\n-    IllegalStateException ajpDoesNotSupportHTTPUpgrade();\n-\n-    @Message(id = 63, value = \"File system watcher already started\")\n-    IllegalStateException fileSystemWatcherAlreadyStarted();\n-\n-    @Message(id = 64, value = \"File system watcher not started\")\n-    IllegalStateException fileSystemWatcherNotStarted();\n+//\n+//    @Message(id = 62, value = \"AJP does not support HTTP upgrade\")\n+//    IllegalStateException ajpDoesNotSupportHTTPUpgrade();\n+//\n+//    @Message(id = 63, value = \"File system watcher already started\")\n+//    IllegalStateException fileSystemWatcherAlreadyStarted();\n+//\n+//    @Message(id = 64, value = \"File system watcher not started\")\n+//    IllegalStateException fileSystemWatcherNotStarted();\n \n     @Message(id = 65, value = \"SSL must be specified to connect to a https URL\")\n     IOException sslWasNull();\n@@ -247,9 +252,9 @@\n \n     @Message(id = 73, value = \"Resource change listeners are not supported\")\n     IllegalArgumentException resourceChangeListenerNotSupported();\n-\n-    @Message(id = 74, value = \"Could not renegotiate SSL connection to require client certificate, as client had sent more data\")\n-    IllegalStateException couldNotRenegotiate();\n+//\n+//    @Message(id = 74, value = \"Could not renegotiate SSL connection to require client certificate, as client had sent more data\")\n+//    IllegalStateException couldNotRenegotiate();\n \n     @Message(id = 75, value = \"Object was freed\")\n     IllegalStateException objectWasFreed();\n@@ -262,15 +267,15 @@\n \n     @Message(id = 78, value = \"Renegotiation not supported\")\n     IOException renegotiationNotSupported();\n-\n-    @Message(id = 79, value = \"Not a valid user agent pattern %s\")\n-    IllegalArgumentException notAValidUserAgentPattern(String userAgent);\n+//\n+//    @Message(id = 79, value = \"Not a valid user agent pattern %s\")\n+//    IllegalArgumentException notAValidUserAgentPattern(String userAgent);\n \n     @Message(id = 80, value = \"Not a valid regular expression pattern %s\")\n     IllegalArgumentException notAValidRegularExpressionPattern(String pattern);\n \n     @Message(id = 81, value = \"Bad request\")\n-    RuntimeException badRequest();\n+    BadRequestException badRequest();\n \n     @Message(id = 82, value = \"Host %s already registered\")\n     RuntimeException hostAlreadyRegistered(Object host);\n@@ -283,30 +288,30 @@\n \n     @Message(id = 85, value = \"Could not generate unique session id\")\n     RuntimeException couldNotGenerateUniqueSessionId();\n-\n-    @Message(id = 86, value = \"SPDY needs to be provided with a heap buffer pool, for use in compressing and decompressing headers.\")\n-    IllegalArgumentException mustProvideHeapBuffer();\n-\n-    @Message(id = 87, value = \"Unexpected SPDY frame type %s\")\n-    IOException unexpectedFrameType(int type);\n+//\n+//    @Message(id = 86, value = \"SPDY needs to be provided with a heap buffer pool, for use in compressing and decompressing headers.\")\n+//    IllegalArgumentException mustProvideHeapBuffer();\n+//\n+//    @Message(id = 87, value = \"Unexpected SPDY frame type %s\")\n+//    IOException unexpectedFrameType(int type);\n \n     @Message(id = 88, value = \"SPDY control frames cannot have body content\")\n     IOException controlFrameCannotHaveBodyContent();\n \n-    @Message(id = 89, value = \"SPDY not supported\")\n-    IOException spdyNotSupported();\n-\n-    @Message(id = 90, value = \"Jetty NPN not available\")\n-    IOException jettyNPNNotAvailable();\n+//    @Message(id = 89, value = \"SPDY not supported\")\n+////    IOException spdyNotSupported();\n+//\n+//    @Message(id = 90, value = \"No ALPN implementation available (tried Jetty ALPN and JDK9)\")\n+//    IOException alpnNotAvailable();\n \n     @Message(id = 91, value = \"Buffer has already been freed\")\n     IllegalStateException bufferAlreadyFreed();\n+//\n+//    @Message(id = 92, value = \"A SPDY header was too large to fit in a response buffer, if you want to support larger headers please increase the buffer size\")\n+//    IllegalStateException headersTooLargeToFitInHeapBuffer();\n \n-    @Message(id = 92, value = \"A SPDY header was too large to fit in a response buffer, if you want to support larger headers please increase the buffer size\")\n-    IllegalStateException headersTooLargeToFitInHeapBuffer();\n-\n-    @Message(id = 93, value = \"A SPDY stream was reset by the remote endpoint\")\n-    IOException spdyStreamWasReset();\n+//    @Message(id = 93, value = \"A SPDY stream was reset by the remote endpoint\")\n+//    IOException spdyStreamWasReset();\n \n     @Message(id = 94, value = \"Blocking await method called from IO thread. Blocking IO must be dispatched to a worker thread or deadlocks will result.\")\n     IOException awaitCalledFromIoThread();\n@@ -331,9 +336,9 @@\n \n     @Message(id = 101, value = \"stream id must not be zero for frame type %s\")\n     String streamIdMustNotBeZeroForFrameType(int frameType);\n-\n-    @Message(id = 102, value = \"RST_STREAM received for idle stream\")\n-    String rstStreamReceivedForIdleStream();\n+//\n+//    @Message(id = 102, value = \"RST_STREAM received for idle stream\")\n+//    String rstStreamReceivedForIdleStream();\n \n     @Message(id = 103, value = \"Http2 stream was reset\")\n     IOException http2StreamWasReset();\n@@ -431,4 +436,136 @@\n \n     @Message(id = 134, value = \"Authentication mechanism %s requires property %s to be set\")\n     IllegalStateException authenticationPropertyNotSet(String name, String header);\n+\n+    @Message(id = 135, value = \"renegotiation failed\")\n+    IllegalStateException rengotiationFailed();\n+\n+    @Message(id = 136, value = \"User agent charset string must have an even number of items, in the form pattern,charset,pattern,charset,... Instead got: %s\")\n+    IllegalArgumentException userAgentCharsetMustHaveEvenNumberOfItems(String supplied);\n+\n+    @Message(id = 137, value = \"Could not find the datasource called %s\")\n+    IllegalArgumentException datasourceNotFound(String ds);\n+\n+    @Message(id = 138, value = \"Server not started\")\n+    IllegalStateException serverNotStarted();\n+\n+    @Message(id = 139, value = \"Exchange already complete\")\n+    IllegalStateException exchangeAlreadyComplete();\n+\n+    @Message(id = 140, value = \"Initial SSL/TLS data is not a handshake record\")\n+    SSLHandshakeException notHandshakeRecord();\n+\n+    @Message(id = 141, value = \"Initial SSL/TLS handshake record is invalid\")\n+    SSLHandshakeException invalidHandshakeRecord();\n+\n+    @Message(id = 142, value = \"Initial SSL/TLS handshake spans multiple records\")\n+    SSLHandshakeException multiRecordSSLHandshake();\n+\n+    @Message(id = 143, value = \"Expected \\\"client hello\\\" record\")\n+    SSLHandshakeException expectedClientHello();\n+\n+    @Message(id = 144, value = \"Expected server hello\")\n+    SSLHandshakeException expectedServerHello();\n+\n+    @Message(id = 145, value = \"Too many redirects\")\n+    IOException tooManyRedirects(@Cause IOException exception);\n+\n+    @Message(id = 146, value = \"HttpServerExchange cannot have both async IO resumed and dispatch() called in the same cycle\")\n+    IllegalStateException resumedAndDispatched();\n+\n+    @Message(id = 147, value = \"No host header in a HTTP/1.1 request\")\n+    IOException noHostInHttp11Request();\n+\n+    @Message(id = 148, value = \"Invalid HPack encoding. First byte: %s\")\n+    HpackException invalidHpackEncoding(byte b);\n+\n+    @Message(id = 149, value = \"HttpString is not allowed to contain newlines. value: %s\")\n+    IllegalArgumentException newlineNotSupportedInHttpString(String value);\n+\n+    @Message(id = 150, value = \"Pseudo header %s received after receiving normal headers. Pseudo headers must be the first headers in a HTTP/2 header block.\")\n+    String pseudoHeaderInWrongOrder(HttpString header);\n+\n+    @Message(id = 151, value = \"Expected to receive a continuation frame\")\n+    String expectedContinuationFrame();\n+\n+    @Message(id = 152, value = \"Incorrect frame size\")\n+    String incorrectFrameSize();\n+\n+    @Message(id = 153, value = \"Stream id not registered\")\n+    IllegalStateException streamNotRegistered();\n+\n+    @Message(id = 154, value = \"Mechanism %s returned a null result from sendChallenge()\")\n+    NullPointerException sendChallengeReturnedNull(AuthenticationMechanism mechanism);\n+\n+    @Message(id = 155, value = \"Framed channel body was set when it was not ready for flush\")\n+    IllegalStateException bodyIsSetAndNotReadyForFlush();\n+\n+    @Message(id = 156, value = \"Invalid GZIP header\")\n+    IOException invalidGzipHeader();\n+\n+    @Message(id = 157, value = \"Invalid GZIP footer\")\n+    IOException invalidGZIPFooter();\n+\n+    @Message(id = 158, value = \"Response of length %s is too large to buffer\")\n+    IllegalStateException responseTooLargeToBuffer(Long length);\n+//\n+//    @Message(id = 159, value = \"Max size must be larger than one\")\n+//    IllegalArgumentException maxSizeMustBeLargerThanOne();\n+\n+    @Message(id = 161, value = \"HTTP/2 header block is too large\")\n+    String headerBlockTooLarge();\n+\n+    @Message(id = 162, value = \"Same-site attribute %s is invalid. It must be Strict or Lax\")\n+    IllegalArgumentException invalidSameSiteMode(String mode);\n+\n+    @Message(id = 163, value = \"Invalid token %s\")\n+    IllegalArgumentException invalidToken(byte c);\n+\n+    @Message(id = 164, value = \"Request contained invalid headers\")\n+    IllegalArgumentException invalidHeaders();\n+\n+    @Message(id = 165, value = \"Invalid character %s in request-target\")\n+    String invalidCharacterInRequestTarget(char next);\n+\n+    @Message(id = 167, value = \"More than one host header in request\")\n+    IOException moreThanOneHostHeader();\n+\n+    @Message(id = 168, value = \"An invalid character [ASCII code: %s] was present in the cookie value\")\n+    IllegalArgumentException invalidCookieValue(String value);\n+\n+    @Message(id = 169, value = \"An invalid domain [%s] was specified for this cookie\")\n+    IllegalArgumentException invalidCookieDomain(String value);\n+\n+    @Message(id = 170, value = \"An invalid path [%s] was specified for this cookie\")\n+    IllegalArgumentException invalidCookiePath(String value);\n+\n+    @Message(id = 173, value = \"An invalid control character [%s] was present in the cookie value or attribute\")\n+    IllegalArgumentException invalidControlCharacter(String value);\n+\n+    @Message(id = 174, value = \"An invalid escape character in cookie value\")\n+    IllegalArgumentException invalidEscapeCharacter();\n+\n+    @Message(id = 175, value = \"Invalid Hpack index %s\")\n+    HpackException invalidHpackIndex(int index);\n+\n+    @Message(id = 178, value = \"Buffer pool is too small, min size is %s\")\n+    IllegalArgumentException bufferPoolTooSmall(int minSize);\n+\n+    @Message(id = 179, value = \"Invalid PROXY protocol header\")\n+    IOException invalidProxyHeader();\n+\n+    @Message(id = 180, value = \"PROXY protocol header exceeded max size of 107 bytes\")\n+    IOException headerSizeToLarge();\n+\n+    @Message(id = 181, value = \"HTTP/2 trailers too large for single buffer\")\n+    RuntimeException http2TrailerToLargeForSingleBuffer();\n+\n+    @Message(id = 184, value = \"Stream limit exceeded\")\n+    IOException streamLimitExceeded();\n+\n+    @Message(id = 185, value = \"Invalid IP address %s\")\n+    IOException invalidIpAddress(String addressString);\n+\n+    @Message(id = 192, value = \"Form value is a in-memory file, use getFileItem() instead\")\n+    IllegalStateException formValueIsInMemoryFile();\n }"
  },
  {
    "sha": "a05ca1ddd7e4f75bacc084e25fe18a3c03842af0",
    "filename": "core/src/main/java/io/undertow/UndertowOptions.java",
    "status": "modified",
    "additions": 72,
    "deletions": 2,
    "changes": 74,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/UndertowOptions.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/UndertowOptions.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/UndertowOptions.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -77,6 +77,8 @@\n      */\n     public static final Option<Integer> NO_REQUEST_TIMEOUT = Option.simple(UndertowOptions.class, \"NO_REQUEST_TIMEOUT\", Integer.class);\n \n+    public static final int DEFAULT_MAX_PARAMETERS = 1000;\n+\n     /**\n      * The maximum number of parameters that will be parsed. This is used to protect against hash vulnerabilities.\n      * <p>\n@@ -87,6 +89,8 @@\n      */\n     public static final Option<Integer> MAX_PARAMETERS = Option.simple(UndertowOptions.class, \"MAX_PARAMETERS\", Integer.class);\n \n+    public static final int DEFAULT_MAX_HEADERS = 200;\n+\n     /**\n      * The maximum number of headers that will be parsed. This is used to protect against hash vulnerabilities.\n      * <p>\n@@ -157,6 +161,8 @@\n      */\n     public static final Option<Integer> MAX_BUFFERED_REQUEST_SIZE = Option.simple(UndertowOptions.class, \"MAX_BUFFERED_REQUEST_SIZE\", Integer.class);\n \n+    public static final int DEFAULT_MAX_BUFFERED_REQUEST_SIZE = 16384;\n+\n     /**\n      * If this is true then Undertow will record the request start time, to allow for request time to be logged\n      *\n@@ -175,9 +181,21 @@\n      */\n     public static final Option<Boolean> ALLOW_EQUALS_IN_COOKIE_VALUE = Option.simple(UndertowOptions.class, \"ALLOW_EQUALS_IN_COOKIE_VALUE\", Boolean.class);\n \n+    /**\n+     * If this is true then Undertow will enable RFC6265 compliant cookie validation for Set-Cookie header instead of legacy backward compatible behavior.\n+     *\n+     * default is false\n+     */\n+    public static final Option<Boolean> ENABLE_RFC6265_COOKIE_VALIDATION = Option.simple(UndertowOptions.class, \"ENABLE_RFC6265_COOKIE_VALIDATION\", Boolean.class);\n+\n+    public static final boolean DEFAULT_ENABLE_RFC6265_COOKIE_VALIDATION = false;\n+\n     /**\n      * If we should attempt to use SPDY for HTTPS connections.\n+     *\n+     * SPDY is no longer supported, use HTTP/2 instead\n      */\n+    @Deprecated\n     public static final Option<Boolean> ENABLE_SPDY = Option.simple(UndertowOptions.class, \"ENABLE_SPDY\", Boolean.class);\n \n     /**\n@@ -235,8 +253,20 @@\n \n     public static final Option<Integer> HTTP2_SETTINGS_INITIAL_WINDOW_SIZE = Option.simple(UndertowOptions.class, \"HTTP2_SETTINGS_INITIAL_WINDOW_SIZE\", Integer.class);\n     public static final Option<Integer> HTTP2_SETTINGS_MAX_FRAME_SIZE = Option.simple(UndertowOptions.class, \"HTTP2_SETTINGS_MAX_FRAME_SIZE\", Integer.class);\n+\n+    /**\n+     * Deprecated, as it is effectively a duplicate of MAX_HEADER_SIZE\n+     *\n+     * @see #MAX_HEADER_SIZE\n+     */\n+    @Deprecated\n     public static final Option<Integer> HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE = Option.simple(UndertowOptions.class, \"HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE\", Integer.class);\n \n+    /**\n+     * The maximum amount of padding to send in a HTTP/2 frame. Actual amount will be randomly determined, defaults to Zero.\n+     */\n+    public static final Option<Integer> HTTP2_PADDING_SIZE = Option.simple(UndertowOptions.class, \"HTTP2_PADDING_SIZE\", Integer.class);\n+\n     /**\n      * Undertow keeps a LRU cache of common huffman encodings. This sets the maximum size, setting this to 0 will disable the caching.\n      *\n@@ -246,12 +276,12 @@\n     /**\n      * The maximum number of concurrent requests that will be processed at a time. This differs from max concurrent streams in that it is not sent to the remote client.\n      *\n-     * If the number of pending requests exceeds this number then requests will be queued, the difference between this and max concurrent streams determins\n+     * If the number of pending requests exceeds this number then requests will be queued, the difference between this and max concurrent streams determines\n      * the maximum number of requests that will be queued.\n      *\n      * Queued requests are processed by a priority queue, rather than a FIFO based queue, using HTTP2 stream priority.\n      *\n-     * If this number is smaller than or equal to zero then max concurrent streams determins the maximum number of streams that can be run.\n+     * If this number is smaller than or equal to zero then max concurrent streams determines the maximum number of streams that can be run.\n      *\n      *\n      */\n@@ -262,6 +292,46 @@\n      */\n     public static final Option<Integer> MAX_QUEUED_READ_BUFFERS = Option.simple(UndertowOptions.class, \"MAX_QUEUED_READ_BUFFERS\", Integer.class);\n \n+    /**\n+     * The maximum AJP packet size, default is 8192\n+     */\n+    public static final Option<Integer> MAX_AJP_PACKET_SIZE = Option.simple(UndertowOptions.class, \"MAX_AJP_PACKET_SIZE\", Integer.class);\n+\n+    /**\n+     * If this is true then HTTP/1.1 requests will be failed if no host header is present.\n+     */\n+    public static final Option<Boolean> REQUIRE_HOST_HTTP11 = Option.simple(UndertowOptions.class, \"REQUIRE_HOST_HTTP11\", Boolean.class);\n+\n+    public static final int DEFAULT_MAX_CACHED_HEADER_SIZE = 150;\n+\n+    /**\n+     * The maximum size of a header name+value combo that is cached in the per connection cache. Defaults to 150\n+     */\n+    public static final Option<Integer> MAX_CACHED_HEADER_SIZE = Option.simple(UndertowOptions.class, \"MAX_CACHED_HEADER_SIZE\", Integer.class);\n+\n+    public static final int DEFAULT_HTTP_HEADERS_CACHE_SIZE = 15;\n+\n+    /**\n+     * The maximum number of headers that are cached per connection. Defaults to 15. If this is set to zero the cache is disabled.\n+     */\n+    public static final Option<Integer> HTTP_HEADERS_CACHE_SIZE = Option.simple(UndertowOptions.class, \"HTTP_HEADERS_CACHE_SIZE\", Integer.class);\n+\n+    /**\n+     * If the SSLEngine should prefer the servers cipher version. Only applicable on JDK8+.\n+     */\n+    public static final Option<Boolean> SSL_USER_CIPHER_SUITES_ORDER = Option.simple(UndertowOptions.class, \"SSL_USER_CIPHER_SUITES_ORDER\", Boolean.class);\n+\n+\n+    public static final Option<Boolean> ALLOW_UNESCAPED_CHARACTERS_IN_URL = Option.simple(UndertowOptions.class,\"ALLOW_UNESCAPED_CHARACTERS_IN_URL\", Boolean.class);\n+\n+    /**\n+     * The server shutdown timeout in milliseconds after which the executor will be forcefully shut down interrupting\n+     * tasks which are still executing.\n+     *\n+     * There is no timeout by default.\n+     */\n+    public static final Option<Integer> SHUTDOWN_TIMEOUT = Option.simple(UndertowOptions.class, \"SHUTDOWN_TIMEOUT\", Integer.class);\n+\n     private UndertowOptions() {\n \n     }"
  },
  {
    "sha": "56fa0ab1f986ad4f1dda4bb672a81de887ad3835",
    "filename": "core/src/main/java/io/undertow/Version.java",
    "status": "modified",
    "additions": 3,
    "deletions": 2,
    "changes": 5,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/Version.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/Version.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/Version.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -18,6 +18,7 @@\n \n package io.undertow;\n \n+import java.io.InputStream;\n import java.util.Properties;\n \n /**\n@@ -30,9 +31,9 @@\n \n     static {\n         String version = \"Unknown\";\n-        try {\n+        try (InputStream versionPropsStream = Version.class.getResourceAsStream(\"version.properties\")){\n             Properties props = new Properties();\n-            props.load(Version.class.getResourceAsStream(\"version.properties\"));\n+            props.load(versionPropsStream);\n             version = props.getProperty(\"undertow.version\");\n         } catch (Exception e) {\n             e.printStackTrace();"
  },
  {
    "sha": "e493bf32e0a34d63e6affc4d17ea9ba9622102e6",
    "filename": "core/src/main/java/io/undertow/attribute/ExchangeAttributeParser.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/ExchangeAttributeParser.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/ExchangeAttributeParser.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/ExchangeAttributeParser.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -118,7 +118,14 @@ public ExchangeAttribute parse(final String valueString) {\n                 case 3: {\n                     if (c == '{') {\n                         state = 4;\n+                    } else if (c == '$') {\n+                        //literal dollars\n+                        attributes.add(wrap(new ConstantExchangeAttribute(\"$\")));\n+                        pos = i + 1;\n+                        state = 0;\n                     } else {\n+                        attributes.add(wrap(parseSingleToken(valueString.substring(pos, i + 1))));\n+                        pos = i + 1;\n                         state = 0;\n                     }\n                     break;"
  },
  {
    "sha": "43727ee86580665f97375e3d86e9a30cdd3e5a4d",
    "filename": "core/src/main/java/io/undertow/attribute/ExchangeAttributes.java",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/ExchangeAttributes.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/ExchangeAttributes.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/ExchangeAttributes.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -103,6 +103,10 @@ public static ExchangeAttribute responseCode() {\n         return ResponseCodeAttribute.INSTANCE;\n     }\n \n+    public static ExchangeAttribute responseReasonPhrase() {\n+        return ResponseReasonPhraseAttribute.INSTANCE;\n+    }\n+\n     public static ExchangeAttribute responseHeader(final HttpString header) {\n         return new ResponseHeaderAttribute(header);\n     }"
  },
  {
    "sha": "776569f2d7afb427e16cb90aac26af468f34294b",
    "filename": "core/src/main/java/io/undertow/attribute/LocalServerNameAttribute.java",
    "status": "modified",
    "additions": 1,
    "deletions": 2,
    "changes": 3,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/LocalServerNameAttribute.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/LocalServerNameAttribute.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/LocalServerNameAttribute.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -19,7 +19,6 @@\n package io.undertow.attribute;\n \n import io.undertow.server.HttpServerExchange;\n-import io.undertow.util.Headers;\n \n /**\n  * The local server name\n@@ -39,7 +38,7 @@ private LocalServerNameAttribute() {\n \n     @Override\n     public String readAttribute(final HttpServerExchange exchange) {\n-        return exchange.getRequestHeaders().getFirst(Headers.HOST);\n+        return exchange.getHostName();\n     }\n \n     @Override"
  },
  {
    "sha": "195764c72667329b6232ac964c80769c31b9508c",
    "filename": "core/src/main/java/io/undertow/attribute/NullAttribute.java",
    "status": "added",
    "additions": 69,
    "deletions": 0,
    "changes": 69,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/NullAttribute.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/NullAttribute.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/NullAttribute.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -0,0 +1,69 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2014 Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package io.undertow.attribute;\n+\n+import io.undertow.server.HttpServerExchange;\n+\n+/**\n+ * A cookie\n+ *\n+ * @author Stuart Douglas\n+ */\n+public class NullAttribute implements ExchangeAttribute {\n+\n+    public static final String NAME = \"%{NULL}\";\n+\n+    public static final NullAttribute INSTANCE = new NullAttribute();\n+\n+\n+    private NullAttribute() {\n+\n+    }\n+\n+    @Override\n+    public String readAttribute(final HttpServerExchange exchange) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void writeAttribute(final HttpServerExchange exchange, final String newValue) throws ReadOnlyAttributeException {\n+        throw new ReadOnlyAttributeException(NAME, newValue);\n+    }\n+\n+    public static final class Builder implements ExchangeAttributeBuilder {\n+\n+        @Override\n+        public String name() {\n+            return \"null\";\n+        }\n+\n+        @Override\n+        public ExchangeAttribute build(final String token) {\n+            if (token.equals(NAME)) {\n+                return INSTANCE;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public int priority() {\n+            return 0;\n+        }\n+    }\n+}"
  },
  {
    "sha": "4fffe63fe4484c579d681d891ca7197739d73799",
    "filename": "core/src/main/java/io/undertow/attribute/QueryStringAttribute.java",
    "status": "modified",
    "additions": 9,
    "deletions": 3,
    "changes": 12,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/QueryStringAttribute.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/QueryStringAttribute.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/QueryStringAttribute.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -29,17 +29,21 @@\n \n     public static final String QUERY_STRING_SHORT = \"%q\";\n     public static final String QUERY_STRING = \"%{QUERY_STRING}\";\n+    public static final String BARE_QUERY_STRING = \"%{BARE_QUERY_STRING}\";\n \n-    public static final ExchangeAttribute INSTANCE = new QueryStringAttribute();\n+    public static final ExchangeAttribute INSTANCE = new QueryStringAttribute(true);\n+    public static final ExchangeAttribute BARE_INSTANCE = new QueryStringAttribute(false);\n \n-    private QueryStringAttribute() {\n+    private final boolean includeQuestionMark;\n \n+    private QueryStringAttribute(boolean includeQuestionMark) {\n+        this.includeQuestionMark = includeQuestionMark;\n     }\n \n     @Override\n     public String readAttribute(final HttpServerExchange exchange) {\n         String qs = exchange.getQueryString();\n-        if(qs.isEmpty()) {\n+        if(qs.isEmpty() || !includeQuestionMark) {\n             return qs;\n         }\n         return '?' + qs;\n@@ -61,6 +65,8 @@ public String name() {\n         public ExchangeAttribute build(final String token) {\n             if (token.equals(QUERY_STRING) || token.equals(QUERY_STRING_SHORT)) {\n                 return QueryStringAttribute.INSTANCE;\n+            } else if(token.equals(BARE_QUERY_STRING)) {\n+                return QueryStringAttribute.BARE_INSTANCE;\n             }\n             return null;\n         }"
  },
  {
    "sha": "869e73185bd7a05aaa1408e741bdc5f1c6b593e6",
    "filename": "core/src/main/java/io/undertow/attribute/RelativePathAttribute.java",
    "status": "modified",
    "additions": 18,
    "deletions": 4,
    "changes": 22,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/RelativePathAttribute.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/RelativePathAttribute.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/RelativePathAttribute.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -47,13 +47,27 @@ public void writeAttribute(final HttpServerExchange exchange, final String newVa\n         int pos = newValue.indexOf('?');\n         if (pos == -1) {\n             exchange.setRelativePath(newValue);\n-            exchange.setRequestURI(exchange.getResolvedPath() + newValue);\n-            exchange.setRequestPath(exchange.getResolvedPath() + newValue);\n+            String requestURI = exchange.getResolvedPath() + newValue;\n+            if(requestURI.contains(\"%\")) {\n+                //as the request URI is supposed to be encoded we need to replace\n+                //percent characters with their encoded form, otherwise we can run into issues\n+                //where the percent will be taked to be a encoded character\n+                //TODO: should we fully encode this? It seems like it also has the potential to cause issues, and encoding the percent character is probably enough\n+                exchange.setRequestURI(requestURI.replaceAll(\"%\", \"%25\"));\n+            } else {\n+                exchange.setRequestURI(requestURI);\n+            }\n+            exchange.setRequestPath(requestURI);\n         } else {\n             final String path = newValue.substring(0, pos);\n             exchange.setRelativePath(path);\n-            exchange.setRequestURI(exchange.getResolvedPath() + newValue);\n-            exchange.setRequestPath(exchange.getResolvedPath() + newValue);\n+            String requestURI = exchange.getResolvedPath() + path;\n+            if(requestURI.contains(\"%\")) {\n+                exchange.setRequestURI(requestURI.replaceAll(\"%\", \"%25\"));\n+            } else {\n+                exchange.setRequestURI(requestURI);\n+            }\n+            exchange.setRequestPath(requestURI);\n \n             final String newQueryString = newValue.substring(pos);\n             exchange.setQueryString(newQueryString);"
  },
  {
    "sha": "afc528698447b1caab53f41c340c5c3310f0f7fd",
    "filename": "core/src/main/java/io/undertow/attribute/RemoteHostAttribute.java",
    "status": "modified",
    "additions": 4,
    "deletions": 4,
    "changes": 8,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/RemoteHostAttribute.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/RemoteHostAttribute.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/RemoteHostAttribute.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -40,20 +40,20 @@ private RemoteHostAttribute() {\n \n     @Override\n     public String readAttribute(final HttpServerExchange exchange) {\n-        final InetSocketAddress peerAddress = (InetSocketAddress) exchange.getConnection().getPeerAddress();\n-        return peerAddress.getHostString();\n+        final InetSocketAddress sourceAddress = (InetSocketAddress) exchange.getSourceAddress();\n+        return sourceAddress.getHostString();\n     }\n \n     @Override\n     public void writeAttribute(final HttpServerExchange exchange, final String newValue) throws ReadOnlyAttributeException {\n-        throw new ReadOnlyAttributeException(\"Remote IP\", newValue);\n+        throw new ReadOnlyAttributeException(\"Remote host\", newValue);\n     }\n \n     public static final class Builder implements ExchangeAttributeBuilder {\n \n         @Override\n         public String name() {\n-            return \"Remote IP\";\n+            return \"Remote host\";\n         }\n \n         @Override"
  },
  {
    "sha": "ce03af9b1eed5f8b9d5671a91611ba196649552e",
    "filename": "core/src/main/java/io/undertow/attribute/RemoteIPAttribute.java",
    "status": "modified",
    "additions": 12,
    "deletions": 2,
    "changes": 14,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/RemoteIPAttribute.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/RemoteIPAttribute.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/RemoteIPAttribute.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -18,6 +18,7 @@\n \n package io.undertow.attribute;\n \n+import java.net.InetAddress;\n import java.net.InetSocketAddress;\n \n import io.undertow.server.HttpServerExchange;\n@@ -40,8 +41,17 @@ private RemoteIPAttribute() {\n \n     @Override\n     public String readAttribute(final HttpServerExchange exchange) {\n-        final InetSocketAddress peerAddress = (InetSocketAddress) exchange.getConnection().getPeerAddress();\n-        return peerAddress.getAddress().getHostAddress();\n+        final InetSocketAddress sourceAddress = exchange.getSourceAddress();\n+        InetAddress address = sourceAddress.getAddress();\n+        if (address == null) {\n+            //this can happen when we have an unresolved X-forwarded-for address\n+            //in this case we just return the IP of the balancer\n+            address = ((InetSocketAddress) exchange.getConnection().getPeerAddress()).getAddress();\n+        }\n+        if(address == null) {\n+            return null;\n+        }\n+        return address.getHostAddress();\n     }\n \n     @Override"
  },
  {
    "sha": "b49da5b5b6e0f3ba20747761aad18e32344a5f5a",
    "filename": "core/src/main/java/io/undertow/attribute/RequestHeaderAttribute.java",
    "status": "modified",
    "additions": 17,
    "deletions": 1,
    "changes": 18,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/RequestHeaderAttribute.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/RequestHeaderAttribute.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/RequestHeaderAttribute.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -19,6 +19,7 @@\n package io.undertow.attribute;\n \n import io.undertow.server.HttpServerExchange;\n+import io.undertow.util.HeaderValues;\n import io.undertow.util.HttpString;\n \n /**\n@@ -37,7 +38,22 @@ public RequestHeaderAttribute(final HttpString requestHeader) {\n \n     @Override\n     public String readAttribute(final HttpServerExchange exchange) {\n-        return exchange.getRequestHeaders().getFirst(requestHeader);\n+        HeaderValues header = exchange.getRequestHeaders().get(requestHeader);\n+        if (header == null) {\n+            return null;\n+        } else if(header.size() == 1) {\n+            return header.getFirst();\n+        }\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[\");\n+        for (int i = 0; i < header.size(); ++i) {\n+            if (i != 0) {\n+                sb.append(\", \");\n+            }\n+            sb.append(header.get(i));\n+        }\n+        sb.append(\"]\");\n+        return sb.toString();\n     }\n \n     @Override"
  },
  {
    "sha": "c41b55d6beb66b52e9cddccde19e998a77f1cb92",
    "filename": "core/src/main/java/io/undertow/attribute/RequestSchemeAttribute.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/RequestSchemeAttribute.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/RequestSchemeAttribute.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/RequestSchemeAttribute.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -42,7 +42,7 @@ public String readAttribute(final HttpServerExchange exchange) {\n \n     @Override\n     public void writeAttribute(final HttpServerExchange exchange, final String newValue) throws ReadOnlyAttributeException {\n-        throw new ReadOnlyAttributeException(\"Request scheme\", newValue);\n+        exchange.setRequestScheme(newValue);\n     }\n \n     public static final class Builder implements ExchangeAttributeBuilder {"
  },
  {
    "sha": "90d1a87f829c1a8467fbc73704dd3b39a84542bd",
    "filename": "core/src/main/java/io/undertow/attribute/ResponseHeaderAttribute.java",
    "status": "modified",
    "additions": 17,
    "deletions": 1,
    "changes": 18,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/ResponseHeaderAttribute.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/ResponseHeaderAttribute.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/ResponseHeaderAttribute.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -19,6 +19,7 @@\n package io.undertow.attribute;\n \n import io.undertow.server.HttpServerExchange;\n+import io.undertow.util.HeaderValues;\n import io.undertow.util.HttpString;\n \n /**\n@@ -37,7 +38,22 @@ public ResponseHeaderAttribute(final HttpString responseHeader) {\n \n     @Override\n     public String readAttribute(final HttpServerExchange exchange) {\n-        return exchange.getResponseHeaders().getFirst(responseHeader);\n+        HeaderValues header = exchange.getResponseHeaders().get(responseHeader);\n+        if (header == null) {\n+            return null;\n+        } else if(header.size() == 1) {\n+            return header.getFirst();\n+        }\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[\");\n+        for (int i = 0; i < header.size(); ++i) {\n+            if (i != 0) {\n+                sb.append(\", \");\n+            }\n+            sb.append(header.get(i));\n+        }\n+        sb.append(\"]\");\n+        return sb.toString();\n     }\n \n     @Override"
  },
  {
    "sha": "3e7c13ad89647911d63583866151a6be81d82602",
    "filename": "core/src/main/java/io/undertow/attribute/ResponseReasonPhraseAttribute.java",
    "status": "added",
    "additions": 70,
    "deletions": 0,
    "changes": 70,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/ResponseReasonPhraseAttribute.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/ResponseReasonPhraseAttribute.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/ResponseReasonPhraseAttribute.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -0,0 +1,70 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2014 Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package io.undertow.attribute;\n+\n+import io.undertow.server.HttpServerExchange;\n+import io.undertow.util.StatusCodes;\n+\n+\n+/**\n+ * The request status code\n+ *\n+ * @author Stuart Douglas\n+ */\n+public class ResponseReasonPhraseAttribute implements ExchangeAttribute {\n+\n+    public static final String RESPONSE_REASON_PHRASE = \"%{RESPONSE_REASON_PHRASE}\";\n+\n+    public static final ExchangeAttribute INSTANCE = new ResponseReasonPhraseAttribute();\n+\n+    private ResponseReasonPhraseAttribute() {\n+\n+    }\n+\n+    @Override\n+    public String readAttribute(final HttpServerExchange exchange) {\n+        return StatusCodes.getReason(exchange.getStatusCode());\n+    }\n+\n+    @Override\n+    public void writeAttribute(final HttpServerExchange exchange, final String newValue) throws ReadOnlyAttributeException {\n+        exchange.setReasonPhrase(newValue);\n+    }\n+\n+    public static final class Builder implements ExchangeAttributeBuilder {\n+\n+        @Override\n+        public String name() {\n+            return \"Response reason phrase\";\n+        }\n+\n+        @Override\n+        public ExchangeAttribute build(final String token) {\n+            if (token.equals(RESPONSE_REASON_PHRASE)) {\n+                return ResponseReasonPhraseAttribute.INSTANCE;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public int priority() {\n+            return 0;\n+        }\n+    }\n+}"
  },
  {
    "sha": "9bf6603712f6748823d510b5a63d2d00fa574cea",
    "filename": "core/src/main/java/io/undertow/attribute/ResponseTimeAttribute.java",
    "status": "modified",
    "additions": 19,
    "deletions": 2,
    "changes": 21,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/ResponseTimeAttribute.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/ResponseTimeAttribute.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/ResponseTimeAttribute.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -19,6 +19,7 @@\n package io.undertow.attribute;\n \n import io.undertow.server.HttpServerExchange;\n+import io.undertow.util.AttachmentKey;\n \n import java.util.concurrent.TimeUnit;\n \n@@ -29,9 +30,12 @@\n  */\n public class ResponseTimeAttribute implements ExchangeAttribute {\n \n+    private static final AttachmentKey<Long> FIRST_RESPONSE_TIME_NANOS = AttachmentKey.create(Long.class);\n+\n     public static final String RESPONSE_TIME_MILLIS_SHORT = \"%D\";\n     public static final String RESPONSE_TIME_SECONDS_SHORT = \"%T\";\n     public static final String RESPONSE_TIME_MILLIS = \"%{RESPONSE_TIME}\";\n+    public static final String RESPONSE_TIME_MICROS = \"%{RESPONSE_TIME_MICROS}\";\n     public static final String RESPONSE_TIME_NANOS = \"%{RESPONSE_TIME_NANOS}\";\n \n     private final TimeUnit timeUnit;\n@@ -46,10 +50,20 @@ public String readAttribute(HttpServerExchange exchange) {\n         if(requestStartTime == -1) {\n             return null;\n         }\n-        final long nanos = System.nanoTime() - requestStartTime;\n+        final long nanos;\n+        Long first = exchange.getAttachment(FIRST_RESPONSE_TIME_NANOS);\n+        if(first != null) {\n+            nanos = first;\n+        } else {\n+            nanos = System.nanoTime() - requestStartTime;\n+            if(exchange.isResponseComplete()) {\n+                //save the response time so it is consistent\n+                exchange.putAttachment(FIRST_RESPONSE_TIME_NANOS, nanos);\n+            }\n+        }\n         if(timeUnit == TimeUnit.SECONDS) {\n             StringBuilder buf = new StringBuilder();\n-            long milis = timeUnit.convert(nanos, TimeUnit.NANOSECONDS);\n+            long milis = TimeUnit.MILLISECONDS.convert(nanos, TimeUnit.NANOSECONDS);\n             buf.append(Long.toString(milis / 1000));\n             buf.append('.');\n             int remains = (int) (milis % 1000);\n@@ -83,6 +97,9 @@ public ExchangeAttribute build(String token) {\n             if (token.equals(RESPONSE_TIME_SECONDS_SHORT)) {\n                 return new ResponseTimeAttribute(TimeUnit.SECONDS);\n             }\n+            if(token.equals(RESPONSE_TIME_MICROS)) {\n+                return new ResponseTimeAttribute(TimeUnit.MICROSECONDS);\n+            }\n             if(token.equals(RESPONSE_TIME_NANOS)) {\n                 return new ResponseTimeAttribute(TimeUnit.NANOSECONDS);\n             }"
  },
  {
    "sha": "e0dcf6dfba9e6ee1e587d3e8d79b627ee95fea54",
    "filename": "core/src/main/java/io/undertow/attribute/SecureExchangeAttribute.java",
    "status": "modified",
    "additions": 6,
    "deletions": 4,
    "changes": 10,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/SecureExchangeAttribute.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/SecureExchangeAttribute.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/SecureExchangeAttribute.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -25,17 +25,19 @@\n  */\n public class SecureExchangeAttribute implements ExchangeAttribute {\n \n-    public static final String TOKEN = \"${SECURE}\";\n+    public static final String TOKEN = \"%{SECURE}\";\n+\n+    public static final String LEGACY_INCORRECT_TOKEN = \"${SECURE}\"; //this was a bug, but we still support it for compat\n     public static final ExchangeAttribute INSTANCE = new SecureExchangeAttribute();\n \n     @Override\n     public String readAttribute(HttpServerExchange exchange) {\n-        return Boolean.toString(exchange.getProtocol().equals(\"https\"));\n+        return Boolean.toString(exchange.isSecure());\n     }\n \n     @Override\n     public void writeAttribute(HttpServerExchange exchange, String newValue) throws ReadOnlyAttributeException {\n-        throw new ReadOnlyAttributeException(\"secure\", newValue);\n+        exchange.putAttachment(HttpServerExchange.SECURE_REQUEST, Boolean.parseBoolean(newValue));\n     }\n \n     public static class Builder implements ExchangeAttributeBuilder {\n@@ -47,7 +49,7 @@ public String name() {\n \n         @Override\n         public ExchangeAttribute build(String token) {\n-            if(token.equals(TOKEN)) {\n+            if(token.equals(TOKEN) || token.equals(LEGACY_INCORRECT_TOKEN)) {\n                 return INSTANCE;\n             }\n             return null;"
  },
  {
    "sha": "5765604342ffbcab2e1bc56c19bd717ce7ee5f75",
    "filename": "core/src/main/java/io/undertow/attribute/StoredResponse.java",
    "status": "added",
    "additions": 99,
    "deletions": 0,
    "changes": 99,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/StoredResponse.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/attribute/StoredResponse.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/attribute/StoredResponse.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -0,0 +1,99 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2014 Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package io.undertow.attribute;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.undertow.UndertowLogger;\n+import io.undertow.conduits.StoredResponseStreamSinkConduit;\n+import io.undertow.server.HttpServerExchange;\n+import io.undertow.util.HeaderMap;\n+import io.undertow.util.Headers;\n+\n+/**\n+ * @author Stuart Douglas\n+ */\n+public class StoredResponse implements ExchangeAttribute {\n+\n+    public static final ExchangeAttribute INSTANCE = new StoredResponse();\n+\n+    private StoredResponse() {\n+\n+    }\n+\n+    @Override\n+    public String readAttribute(HttpServerExchange exchange) {\n+        byte[] data = exchange.getAttachment(StoredResponseStreamSinkConduit.RESPONSE);\n+        if(data == null) {\n+            return null;\n+        }\n+        String charset = extractCharset(exchange.getResponseHeaders());\n+        if(charset == null) {\n+            return null;\n+        }\n+        try {\n+            return new String(data, charset);\n+        } catch (UnsupportedEncodingException e) {\n+            UndertowLogger.ROOT_LOGGER.debugf(e,\"Could not decode response body using charset %s\", charset);\n+            return null;\n+        }\n+    }\n+    private String extractCharset(HeaderMap headers) {\n+        String contentType = headers.getFirst(Headers.CONTENT_TYPE);\n+        if (contentType != null) {\n+            String value = Headers.extractQuotedValueFromHeader(contentType, \"charset\");\n+            if (value != null) {\n+                return value;\n+            }\n+            //if it is text we default to ISO_8859_1\n+            if(contentType.startsWith(\"text/\")) {\n+                return StandardCharsets.ISO_8859_1.displayName();\n+            }\n+            return null;\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void writeAttribute(HttpServerExchange exchange, String newValue) throws ReadOnlyAttributeException {\n+        throw new ReadOnlyAttributeException(\"Stored Response\", newValue);\n+    }\n+\n+    public static class Builder implements ExchangeAttributeBuilder {\n+\n+        @Override\n+        public String name() {\n+            return \"Stored Response\";\n+        }\n+\n+        @Override\n+        public ExchangeAttribute build(final String token) {\n+            if (token.equals(\"%{STORED_RESPONSE}\")) {\n+                return INSTANCE;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public int priority() {\n+            return 0;\n+        }\n+    }\n+}"
  },
  {
    "sha": "81b637aeef9de713bcfd0446a6c9898049cbb811",
    "filename": "core/src/main/java/io/undertow/channels/DelegatingStreamSinkChannel.java",
    "status": "removed",
    "additions": 0,
    "deletions": 157,
    "changes": 157,
    "blob_url": "https://github.com/ptrepag/undertow/blob/15a2924e3408959e01d0418aa1a952212ee5e45a/core/src/main/java/io/undertow/channels/DelegatingStreamSinkChannel.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/15a2924e3408959e01d0418aa1a952212ee5e45a/core/src/main/java/io/undertow/channels/DelegatingStreamSinkChannel.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/channels/DelegatingStreamSinkChannel.java?ref=15a2924e3408959e01d0418aa1a952212ee5e45a",
    "patch": "@@ -1,157 +0,0 @@\n-/*\n- * JBoss, Home of Professional Open Source.\n- * Copyright 2014 Red Hat, Inc., and individual contributors\n- * as indicated by the @author tags.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-\n-package io.undertow.channels;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.xnio.ChannelListener;\n-import org.xnio.ChannelListeners;\n-import org.xnio.Option;\n-import org.xnio.XnioExecutor;\n-import org.xnio.XnioIoThread;\n-import org.xnio.XnioWorker;\n-import org.xnio.channels.StreamSinkChannel;\n-import org.xnio.channels.StreamSourceChannel;\n-\n-/**\n- * @author Stuart Douglas\n- */\n-public abstract class DelegatingStreamSinkChannel<T extends DelegatingStreamSinkChannel> implements StreamSinkChannel {\n-\n-    protected final StreamSinkChannel delegate;\n-    protected final ChannelListener.SimpleSetter<T> writeSetter = new ChannelListener.SimpleSetter<>();\n-    protected final ChannelListener.SimpleSetter<T> closeSetter = new ChannelListener.SimpleSetter<>();\n-\n-    public DelegatingStreamSinkChannel(final StreamSinkChannel delegate) {\n-        this.delegate = delegate;\n-        delegate.getWriteSetter().set(ChannelListeners.delegatingChannelListener((T) this, writeSetter));\n-        delegate.getCloseSetter().set(ChannelListeners.delegatingChannelListener((T) this, closeSetter));\n-    }\n-\n-    public long transferFrom(final FileChannel src, final long position, final long count) throws IOException {\n-        return delegate.transferFrom(src, position, count);\n-    }\n-\n-    public XnioWorker getWorker() {\n-        return delegate.getWorker();\n-    }\n-\n-    public boolean isWriteResumed() {\n-        return delegate.isWriteResumed();\n-    }\n-\n-    public boolean flush() throws IOException {\n-        return delegate.flush();\n-    }\n-\n-    public void awaitWritable(final long time, final TimeUnit timeUnit) throws IOException {\n-        delegate.awaitWritable(time, timeUnit);\n-    }\n-\n-    public int write(final ByteBuffer src) throws IOException {\n-        return delegate.write(src);\n-    }\n-\n-    public long write(final ByteBuffer[] srcs, final int offset, final int length) throws IOException {\n-        return delegate.write(srcs, offset, length);\n-    }\n-\n-    public void awaitWritable() throws IOException {\n-        delegate.awaitWritable();\n-    }\n-\n-    public <T> T setOption(final Option<T> option, final T value) throws IllegalArgumentException, IOException {\n-        return delegate.setOption(option, value);\n-    }\n-\n-    public ChannelListener.Setter<? extends StreamSinkChannel> getCloseSetter() {\n-        return closeSetter;\n-    }\n-\n-    public ChannelListener.Setter<? extends StreamSinkChannel> getWriteSetter() {\n-        return writeSetter;\n-    }\n-\n-    public boolean supportsOption(final Option<?> option) {\n-        return delegate.supportsOption(option);\n-    }\n-\n-    public final long write(final ByteBuffer[] srcs) throws IOException {\n-        return write(srcs, 0, srcs.length);\n-    }\n-\n-    public void resumeWrites() {\n-        delegate.resumeWrites();\n-    }\n-\n-    public boolean isOpen() {\n-        return delegate.isOpen();\n-    }\n-\n-    public void shutdownWrites() throws IOException {\n-        delegate.shutdownWrites();\n-    }\n-\n-    public long transferFrom(final StreamSourceChannel source, final long count, final ByteBuffer throughBuffer) throws IOException {\n-        return delegate.transferFrom(source, count, throughBuffer);\n-    }\n-\n-    public XnioExecutor getWriteThread() {\n-        return delegate.getWriteThread();\n-    }\n-\n-    public void wakeupWrites() {\n-        delegate.wakeupWrites();\n-    }\n-\n-    public void close() throws IOException {\n-        delegate.close();\n-    }\n-\n-    public <T> T getOption(final Option<T> option) throws IOException {\n-        return delegate.getOption(option);\n-    }\n-\n-    public void suspendWrites() {\n-        delegate.suspendWrites();\n-    }\n-\n-    @Override\n-    public XnioIoThread getIoThread() {\n-        return delegate.getIoThread();\n-    }\n-\n-    @Override\n-    public int writeFinal(ByteBuffer src) throws IOException {\n-        return delegate.writeFinal(src);\n-    }\n-\n-    @Override\n-    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n-        return delegate.writeFinal(srcs, offset, length);\n-    }\n-\n-    @Override\n-    public long writeFinal(ByteBuffer[] srcs) throws IOException {\n-        return delegate.writeFinal(srcs);\n-    }\n-}"
  },
  {
    "sha": "a8353e1aca4406229821c35c2f2730205469d6e4",
    "filename": "core/src/main/java/io/undertow/channels/DelegatingStreamSourceChannel.java",
    "status": "removed",
    "additions": 0,
    "deletions": 138,
    "changes": 138,
    "blob_url": "https://github.com/ptrepag/undertow/blob/15a2924e3408959e01d0418aa1a952212ee5e45a/core/src/main/java/io/undertow/channels/DelegatingStreamSourceChannel.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/15a2924e3408959e01d0418aa1a952212ee5e45a/core/src/main/java/io/undertow/channels/DelegatingStreamSourceChannel.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/channels/DelegatingStreamSourceChannel.java?ref=15a2924e3408959e01d0418aa1a952212ee5e45a",
    "patch": "@@ -1,138 +0,0 @@\n-/*\n- * JBoss, Home of Professional Open Source.\n- * Copyright 2014 Red Hat, Inc., and individual contributors\n- * as indicated by the @author tags.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-\n-package io.undertow.channels;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.xnio.ChannelListener;\n-import org.xnio.ChannelListeners;\n-import org.xnio.Option;\n-import org.xnio.XnioExecutor;\n-import org.xnio.XnioIoThread;\n-import org.xnio.XnioWorker;\n-import org.xnio.channels.StreamSinkChannel;\n-import org.xnio.channels.StreamSourceChannel;\n-\n-/**\n- * @author Stuart Douglas\n- */\n-public abstract class DelegatingStreamSourceChannel<T extends DelegatingStreamSourceChannel> implements StreamSourceChannel {\n-\n-    protected final ChannelListener.SimpleSetter<T> readSetter = new ChannelListener.SimpleSetter<>();\n-    protected final ChannelListener.SimpleSetter<T> closeSetter = new ChannelListener.SimpleSetter<>();\n-    protected final StreamSourceChannel delegate;\n-\n-    public DelegatingStreamSourceChannel(final StreamSourceChannel delegate) {\n-        this.delegate = delegate;\n-        delegate.getReadSetter().set(ChannelListeners.delegatingChannelListener((T) this, readSetter));\n-        delegate.getCloseSetter().set(ChannelListeners.delegatingChannelListener((T) this, closeSetter));\n-    }\n-\n-    public long transferTo(final long position, final long count, final FileChannel target) throws IOException {\n-        return delegate.transferTo(position, count, target);\n-    }\n-\n-    public void awaitReadable() throws IOException {\n-        delegate.awaitReadable();\n-    }\n-\n-    public void suspendReads() {\n-        delegate.suspendReads();\n-    }\n-\n-    public long transferTo(final long count, final ByteBuffer throughBuffer, final StreamSinkChannel target) throws IOException {\n-        return delegate.transferTo(count, throughBuffer, target);\n-    }\n-\n-    public XnioWorker getWorker() {\n-        return delegate.getWorker();\n-    }\n-\n-    public boolean isReadResumed() {\n-        return delegate.isReadResumed();\n-    }\n-\n-    public <T> T setOption(final Option<T> option, final T value) throws IllegalArgumentException, IOException {\n-        return delegate.setOption(option, value);\n-    }\n-\n-    public boolean supportsOption(final Option<?> option) {\n-        return delegate.supportsOption(option);\n-    }\n-\n-    public void shutdownReads() throws IOException {\n-        delegate.shutdownReads();\n-    }\n-\n-    public ChannelListener.Setter<? extends StreamSourceChannel> getReadSetter() {\n-        return readSetter;\n-    }\n-\n-    public boolean isOpen() {\n-        return delegate.isOpen();\n-    }\n-\n-    public long read(final ByteBuffer[] dsts) throws IOException {\n-        return delegate.read(dsts);\n-    }\n-\n-    public long read(final ByteBuffer[] dsts, final int offset, final int length) throws IOException {\n-        return delegate.read(dsts, offset, length);\n-    }\n-\n-    public void wakeupReads() {\n-        delegate.wakeupReads();\n-    }\n-\n-    public XnioExecutor getReadThread() {\n-        return delegate.getReadThread();\n-    }\n-\n-    public void awaitReadable(final long time, final TimeUnit timeUnit) throws IOException {\n-        delegate.awaitReadable(time, timeUnit);\n-    }\n-\n-    public ChannelListener.Setter<? extends StreamSourceChannel> getCloseSetter() {\n-        return closeSetter;\n-    }\n-\n-    public void close() throws IOException {\n-        delegate.close();\n-    }\n-\n-    public <T> T getOption(final Option<T> option) throws IOException {\n-        return delegate.getOption(option);\n-    }\n-\n-    public void resumeReads() {\n-        delegate.resumeReads();\n-    }\n-\n-    public int read(final ByteBuffer dst) throws IOException {\n-        return delegate.read(dst);\n-    }\n-\n-    @Override\n-    public XnioIoThread getIoThread() {\n-        return delegate.getIoThread();\n-    }\n-}"
  },
  {
    "sha": "1f41ed30404f97ab1964c552acf87c703472118e",
    "filename": "core/src/main/java/io/undertow/channels/DetachableStreamSinkChannel.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/channels/DetachableStreamSinkChannel.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/channels/DetachableStreamSinkChannel.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/channels/DetachableStreamSinkChannel.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -274,7 +274,7 @@ public void responseDone() {\n         private final SimpleSetter<StreamSinkChannel> setter;\n         private final StreamSinkChannel channel;\n \n-        public SetterDelegatingListener(final SimpleSetter<StreamSinkChannel> setter, final StreamSinkChannel channel) {\n+        SetterDelegatingListener(final SimpleSetter<StreamSinkChannel> setter, final StreamSinkChannel channel) {\n             this.setter = setter;\n             this.channel = channel;\n         }"
  },
  {
    "sha": "5ed992402151773e7d80b3a41faa37dadfa53e78",
    "filename": "core/src/main/java/io/undertow/channels/DetachableStreamSourceChannel.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/ptrepag/undertow/blob/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/channels/DetachableStreamSourceChannel.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/0ae3a3319f25f1778c1f9fc0817870bff571d973/core/src/main/java/io/undertow/channels/DetachableStreamSourceChannel.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/channels/DetachableStreamSourceChannel.java?ref=0ae3a3319f25f1778c1f9fc0817870bff571d973",
    "patch": "@@ -220,7 +220,7 @@ public XnioIoThread getIoThread() {\n         private final SimpleSetter<StreamSourceChannel> setter;\n         private final StreamSourceChannel channel;\n \n-        public SetterDelegatingListener(final SimpleSetter<StreamSourceChannel> setter, final StreamSourceChannel channel) {\n+        SetterDelegatingListener(final SimpleSetter<StreamSourceChannel> setter, final StreamSourceChannel channel) {\n             this.setter = setter;\n             this.channel = channel;\n         }"
  },
  {
    "sha": "451eec3754d28dcd3e9794c6ae9249a9bd199d1b",
    "filename": "core/src/main/java/io/undertow/channels/GatedStreamSinkChannel.java",
    "status": "removed",
    "additions": 0,
    "deletions": 297,
    "changes": 297,
    "blob_url": "https://github.com/ptrepag/undertow/blob/15a2924e3408959e01d0418aa1a952212ee5e45a/core/src/main/java/io/undertow/channels/GatedStreamSinkChannel.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/15a2924e3408959e01d0418aa1a952212ee5e45a/core/src/main/java/io/undertow/channels/GatedStreamSinkChannel.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/channels/GatedStreamSinkChannel.java?ref=15a2924e3408959e01d0418aa1a952212ee5e45a",
    "patch": "@@ -1,297 +0,0 @@\n-/*\n- * JBoss, Home of Professional Open Source.\n- * Copyright 2014 Red Hat, Inc., and individual contributors\n- * as indicated by the @author tags.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-\n-package io.undertow.channels;\n-\n-import org.xnio.ChannelListener;\n-import org.xnio.ChannelListeners;\n-import org.xnio.Option;\n-import org.xnio.XnioExecutor;\n-import org.xnio.XnioIoThread;\n-import org.xnio.XnioWorker;\n-import org.xnio.channels.StreamSinkChannel;\n-import org.xnio.channels.StreamSourceChannel;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.ClosedChannelException;\n-import java.nio.channels.FileChannel;\n-import java.util.concurrent.TimeUnit;\n-\n-import static org.xnio.Bits.allAreClear;\n-import static org.xnio.Bits.allAreSet;\n-import static org.xnio.Bits.anyAreClear;\n-import static org.xnio.Bits.anyAreSet;\n-\n-/**\n- * A 'gated' stream sink channel.\n- * <p>\n- * This channel has a gate which starts of closed. When the gate is closed writes will return 0. When the gate is opened\n- * writes will resume as normal.\n- *\n- * @author <a href=\"mailto:david.lloyd@redhat.com\">David M. Lloyd</a>\n- */\n-public final class GatedStreamSinkChannel implements StreamSinkChannel {\n-    private final StreamSinkChannel delegate;\n-    private final ChannelListener.SimpleSetter<GatedStreamSinkChannel> writeSetter = new ChannelListener.SimpleSetter<>();\n-    private final ChannelListener.SimpleSetter<GatedStreamSinkChannel> closeSetter = new ChannelListener.SimpleSetter<>();\n-\n-    /**\n-     * Construct a new instance.\n-     *\n-     * @param delegate the channel to wrap\n-     */\n-    public GatedStreamSinkChannel(final StreamSinkChannel delegate) {\n-        this.delegate = delegate;\n-    }\n-\n-    @SuppressWarnings(\"unused\")\n-    private int state;\n-\n-    private static final int FLAG_GATE_OPEN = 1 << 0;\n-    private static final int FLAG_WRITES_RESUMED = 1 << 1;\n-    private static final int FLAG_CLOSE_REQUESTED = 1 << 2;\n-    private static final int FLAG_CLOSED = 1 << 3;\n-\n-    /**\n-     * Open the gate and allow data to flow.  Once opened, the gate cannot be closed other than closing the channel.\n-     * <p>\n-     * If the shutdownWrites() or close() method has already been called this will result it in being invoked on the\n-     * delegate.\n-     */\n-    public void openGate() throws IOException {\n-        int val = state;\n-        if (allAreSet(val, FLAG_GATE_OPEN)) {\n-            return;\n-        }\n-        state |= FLAG_GATE_OPEN;\n-        if (allAreSet(val, FLAG_CLOSED)) {\n-            delegate.close();\n-        } else {\n-            if (allAreSet(val, FLAG_CLOSE_REQUESTED)) {\n-                delegate.shutdownWrites();\n-            }\n-            if (allAreSet(val, FLAG_WRITES_RESUMED)) {\n-                delegate.wakeupWrites();\n-            }\n-        }\n-    }\n-\n-    public boolean isGateOpen() {\n-        return allAreSet(state, FLAG_GATE_OPEN);\n-    }\n-\n-    public XnioWorker getWorker() {\n-        return delegate.getWorker();\n-    }\n-\n-    @Override\n-    public XnioIoThread getIoThread() {\n-        return delegate.getIoThread();\n-    }\n-\n-    public XnioExecutor getWriteThread() {\n-        return delegate.getWriteThread();\n-    }\n-\n-    public ChannelListener.Setter<? extends StreamSinkChannel> getWriteSetter() {\n-        return writeSetter;\n-    }\n-\n-    public ChannelListener.Setter<? extends StreamSinkChannel> getCloseSetter() {\n-        return closeSetter;\n-    }\n-\n-    @Override\n-    public int writeFinal(ByteBuffer src) throws IOException {\n-        if (handleGate()) {\n-            return 0;\n-        }\n-        return delegate.writeFinal(src);\n-    }\n-\n-    @Override\n-    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n-        if (handleGate()) {\n-            return 0;\n-        }\n-        return delegate.writeFinal(srcs, offset, length);\n-    }\n-\n-    @Override\n-    public long writeFinal(ByteBuffer[] srcs) throws IOException {\n-        if (handleGate()) {\n-            return 0;\n-        }\n-        return delegate.writeFinal(srcs);\n-    }\n-\n-    public int write(final ByteBuffer src) throws IOException {\n-        if (handleGate()) {\n-            return 0;\n-        }\n-        return delegate.write(src);\n-    }\n-\n-    public long write(final ByteBuffer[] srcs) throws IOException {\n-        return write(srcs, 0, srcs.length);\n-    }\n-\n-    public long write(final ByteBuffer[] srcs, final int offset, final int length) throws IOException {\n-        if (handleGate()) {\n-            return 0;\n-        }\n-        return delegate.write(srcs, offset, length);\n-    }\n-\n-    private boolean handleGate() throws ClosedChannelException {\n-        int val = state;\n-        if (anyAreSet(val, FLAG_CLOSE_REQUESTED)) {\n-            throw new ClosedChannelException();\n-        }\n-        if (anyAreClear(val, FLAG_GATE_OPEN)) {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    public long transferFrom(final FileChannel src, final long position, final long count) throws IOException {\n-        if (handleGate()) {\n-            return 0;\n-        }\n-        return delegate.transferFrom(src, position, count);\n-    }\n-\n-    public long transferFrom(final StreamSourceChannel source, final long count, final ByteBuffer throughBuffer) throws IOException {\n-        if (handleGate()) {\n-            return 0;\n-        }\n-        return delegate.transferFrom(source, count, throughBuffer);\n-    }\n-\n-    public boolean flush() throws IOException {\n-        if (anyAreClear(state, FLAG_GATE_OPEN)) {\n-            return false;\n-        }\n-        if (anyAreSet(state, FLAG_CLOSED)) {\n-            throw new ClosedChannelException();\n-        }\n-        if (anyAreSet(state, FLAG_CLOSE_REQUESTED)) {\n-            boolean result = delegate.flush();\n-            if (result) {\n-                state |= FLAG_CLOSED;\n-            }\n-            return result;\n-        }\n-        return delegate.flush();\n-    }\n-\n-    public void suspendWrites() {\n-        if (anyAreSet(state, FLAG_GATE_OPEN)) {\n-            delegate.suspendWrites();\n-        } else {\n-            state &= ~FLAG_WRITES_RESUMED;\n-        }\n-    }\n-\n-    public void resumeWrites() {\n-        if (anyAreSet(state, FLAG_GATE_OPEN)) {\n-            delegate.resumeWrites();\n-        } else {\n-            state |= FLAG_WRITES_RESUMED;\n-        }\n-    }\n-\n-    public boolean isWriteResumed() {\n-        if (anyAreSet(state, FLAG_GATE_OPEN)) {\n-            return delegate.isWriteResumed();\n-        } else {\n-            return anyAreSet(state, FLAG_WRITES_RESUMED);\n-        }\n-    }\n-\n-    public void wakeupWrites() {\n-        if (anyAreSet(state, FLAG_GATE_OPEN)) {\n-            delegate.wakeupWrites();\n-        } else {\n-            state |= FLAG_WRITES_RESUMED;\n-            getIoThread().execute(new Runnable() {\n-                @Override\n-                public void run() {\n-                    ChannelListeners.invokeChannelListener(GatedStreamSinkChannel.this, writeSetter.get());\n-                }\n-            });\n-        }\n-    }\n-\n-    public void shutdownWrites() throws IOException {\n-        state |= FLAG_CLOSE_REQUESTED;\n-        if (anyAreSet(state, FLAG_GATE_OPEN)) {\n-            delegate.shutdownWrites();\n-        }\n-    }\n-\n-    public void close() throws IOException {\n-        if (allAreSet(state, FLAG_CLOSED)) {\n-            return;\n-        }\n-        state |= FLAG_CLOSED;\n-        if (anyAreSet(state, FLAG_GATE_OPEN)) {\n-            delegate.close();\n-        }\n-    }\n-\n-    public void awaitWritable() throws IOException {\n-        if (allAreClear(state, FLAG_GATE_OPEN)) {\n-            throw new IllegalStateException();//we don't allow this, as it results in thread safety issues\n-        }\n-        delegate.awaitWritable();\n-    }\n-\n-    public void awaitWritable(final long time, final TimeUnit timeUnit) throws IOException {\n-        if (allAreClear(state, FLAG_GATE_OPEN)) {\n-            throw new IllegalStateException();//we don't allow this, as it results in thread safety issues\n-        }\n-        delegate.awaitWritable(time, timeUnit);\n-    }\n-\n-    public boolean isOpen() {\n-        return allAreClear(state, FLAG_CLOSED);\n-    }\n-\n-    public boolean supportsOption(final Option<?> option) {\n-        return false;\n-    }\n-\n-    public <T> T getOption(final Option<T> option) throws IOException {\n-        return null;\n-    }\n-\n-    public <T> T setOption(final Option<T> option, final T value) throws IllegalArgumentException, IOException {\n-        return null;\n-    }\n-\n-    /**\n-     * Get the underlying channel if the gate is open, else return this channel.\n-     *\n-     * @return the underlying channel, or this channel if the gate is not open\n-     */\n-    public StreamSinkChannel getChannel() {\n-        return allAreSet(state, FLAG_GATE_OPEN) ? delegate : this;\n-    }\n-}"
  },
  {
    "sha": "ee72b1062bc33d419ed77273f6ea38ac5ebab59c",
    "filename": "core/src/main/java/io/undertow/channels/GatedStreamSourceChannel.java",
    "status": "removed",
    "additions": 0,
    "deletions": 284,
    "changes": 284,
    "blob_url": "https://github.com/ptrepag/undertow/blob/15a2924e3408959e01d0418aa1a952212ee5e45a/core/src/main/java/io/undertow/channels/GatedStreamSourceChannel.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/15a2924e3408959e01d0418aa1a952212ee5e45a/core/src/main/java/io/undertow/channels/GatedStreamSourceChannel.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/channels/GatedStreamSourceChannel.java?ref=15a2924e3408959e01d0418aa1a952212ee5e45a",
    "patch": "@@ -1,284 +0,0 @@\n-/*\n- * JBoss, Home of Professional Open Source.\n- * Copyright 2014 Red Hat, Inc., and individual contributors\n- * as indicated by the @author tags.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-\n-package io.undertow.channels;\n-\n-import org.xnio.ChannelListener;\n-import org.xnio.ChannelListeners;\n-import org.xnio.Option;\n-import org.xnio.XnioExecutor;\n-import org.xnio.XnioIoThread;\n-import org.xnio.XnioWorker;\n-import org.xnio.channels.StreamSinkChannel;\n-import org.xnio.channels.StreamSourceChannel;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.concurrent.TimeUnit;\n-\n-import static org.xnio.Bits.allAreClear;\n-import static org.xnio.Bits.allAreSet;\n-import static org.xnio.Bits.anyAreClear;\n-import static org.xnio.Bits.anyAreSet;\n-\n-/**\n- * A 'gated' stream source channel.\n- * <p>\n- * This channel has a gate which starts of closed. When the gate is closed reads will return 0. When the gate is opened\n- * reads will resume as normal.\n- *\n- * @author <a href=\"mailto:david.lloyd@redhat.com\">David M. Lloyd</a>\n- */\n-public final class GatedStreamSourceChannel implements StreamSourceChannel {\n-    private final StreamSourceChannel delegate;\n-    private final ChannelListener.SimpleSetter<GatedStreamSourceChannel> readSetter = new ChannelListener.SimpleSetter<>();\n-    private final ChannelListener.SimpleSetter<GatedStreamSourceChannel> closeSetter = new ChannelListener.SimpleSetter<>();\n-\n-    /**\n-     * Construct a new instance.\n-     *\n-     * @param delegate the channel to wrap\n-     */\n-    public GatedStreamSourceChannel(final StreamSourceChannel delegate) {\n-        this.delegate = delegate;\n-    }\n-\n-    @SuppressWarnings(\"unused\")\n-    private int state;\n-\n-    private static final int FLAG_GATE_OPEN = 1 << 0;\n-    private static final int FLAG_READS_RESUMED = 1 << 1;\n-    private static final int FLAG_CLOSE_REQUESTED = 1 << 2;\n-    private static final int FLAG_CLOSED = 1 << 3;\n-\n-    /**\n-     * Open the gate and allow data to flow.  Once opened, the gate cannot be closed other than closing the channel.\n-     * <p>\n-     * If the shutdownReads() or close() method has already been called this will result it in being invoked on the\n-     * delegate.\n-     */\n-    public void openGate() throws IOException {\n-        int val = state;\n-        if (allAreSet(val, FLAG_GATE_OPEN)) {\n-            return;\n-        }\n-        state |= FLAG_GATE_OPEN;\n-        if (allAreSet(val, FLAG_CLOSED)) {\n-            delegate.close();\n-        } else {\n-            if (allAreSet(val, FLAG_CLOSE_REQUESTED)) {\n-                delegate.shutdownReads();\n-            }\n-            if (allAreSet(val, FLAG_READS_RESUMED)) {\n-                delegate.wakeupReads();\n-            }\n-        }\n-    }\n-\n-    public boolean isGateOpen() {\n-        return allAreSet(state, FLAG_GATE_OPEN);\n-    }\n-\n-    public XnioWorker getWorker() {\n-        return delegate.getWorker();\n-    }\n-\n-    @Override\n-    public XnioIoThread getIoThread() {\n-        return delegate.getIoThread();\n-    }\n-\n-    @Override\n-    public long transferTo(long position, long count, FileChannel target) throws IOException {\n-        int val = state;\n-        if (anyAreSet(val, FLAG_CLOSE_REQUESTED)) {\n-            return -1;\n-        }\n-        if (anyAreClear(val, FLAG_GATE_OPEN)) {\n-            return 0;\n-        }\n-        return delegate.transferTo(position, count, target);\n-    }\n-\n-    @Override\n-    public long transferTo(long count, ByteBuffer throughBuffer, StreamSinkChannel target) throws IOException {\n-        int val = state;\n-        if (anyAreSet(val, FLAG_CLOSE_REQUESTED)) {\n-            return -1;\n-        }\n-        if (anyAreClear(val, FLAG_GATE_OPEN)) {\n-            return 0;\n-        }\n-        return delegate.transferTo(count, throughBuffer, target);\n-    }\n-\n-    @Override\n-    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n-        int val = state;\n-        if (anyAreSet(val, FLAG_CLOSE_REQUESTED)) {\n-            return -1;\n-        }\n-        if (anyAreClear(val, FLAG_GATE_OPEN)) {\n-            return 0;\n-        }\n-        return delegate.read(dsts, offset, length);\n-    }\n-\n-    @Override\n-    public long read(ByteBuffer[] dsts) throws IOException {\n-        int val = state;\n-        if (anyAreSet(val, FLAG_CLOSE_REQUESTED)) {\n-            return -1;\n-        }\n-        if (anyAreClear(val, FLAG_GATE_OPEN)) {\n-            return 0;\n-        }\n-        return delegate.read(dsts);\n-    }\n-\n-    @Override\n-    public int read(ByteBuffer dst) throws IOException {\n-        int val = state;\n-        if (anyAreSet(val, FLAG_CLOSE_REQUESTED)) {\n-            return -1;\n-        }\n-        if (anyAreClear(val, FLAG_GATE_OPEN)) {\n-            return 0;\n-        }\n-        return delegate.read(dst);\n-    }\n-    @Override\n-    public void suspendReads() {\n-        if (anyAreSet(state, FLAG_GATE_OPEN)) {\n-            delegate.suspendReads();\n-        } else {\n-            state &= ~FLAG_READS_RESUMED;\n-        }\n-    }\n-\n-    @Override\n-    public void resumeReads() {\n-        if (anyAreSet(state, FLAG_GATE_OPEN)) {\n-            delegate.resumeReads();\n-        } else {\n-            state |= FLAG_READS_RESUMED;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isReadResumed() {\n-        if (anyAreSet(state, FLAG_GATE_OPEN)) {\n-            return delegate.isReadResumed();\n-        } else {\n-            return anyAreSet(state, FLAG_READS_RESUMED);\n-        }\n-    }\n-\n-    @Override\n-    public void wakeupReads() {\n-        if (anyAreSet(state, FLAG_GATE_OPEN)) {\n-            delegate.resumeReads();\n-        } else {\n-            state |= FLAG_READS_RESUMED;\n-            getIoThread().execute(new Runnable() {\n-                @Override\n-                public void run() {\n-                    ChannelListeners.invokeChannelListener(GatedStreamSourceChannel.this, readSetter.get());\n-                }\n-            });\n-        }\n-    }\n-\n-    @Override\n-    public void shutdownReads() throws IOException {\n-        if (anyAreSet(state, FLAG_GATE_OPEN)) {\n-            delegate.shutdownReads();\n-        } else {\n-            state |= FLAG_CLOSE_REQUESTED;\n-        }\n-    }\n-\n-    @Override\n-    public void awaitReadable() throws IOException {\n-        if (anyAreSet(state, FLAG_GATE_OPEN)) {\n-            delegate.awaitReadable();\n-        } else {\n-            throw new IllegalStateException();\n-        }\n-    }\n-\n-    @Override\n-    public void awaitReadable(long time, TimeUnit timeUnit) throws IOException {\n-        if (anyAreSet(state, FLAG_GATE_OPEN)) {\n-            delegate.awaitReadable(time, timeUnit);\n-        } else {\n-            throw new IllegalStateException();\n-        }\n-    }\n-\n-    @Override\n-    public XnioExecutor getReadThread() {\n-        return delegate.getIoThread();\n-    }\n-\n-    @Override\n-    public ChannelListener.Setter<? extends StreamSourceChannel> getReadSetter() {\n-        return readSetter;\n-    }\n-\n-    public ChannelListener.Setter<? extends StreamSourceChannel> getCloseSetter() {\n-        return closeSetter;\n-    }\n-\n-    public void close() throws IOException {\n-        if (allAreSet(state, FLAG_CLOSED)) {\n-            return;\n-        }\n-        state |= FLAG_CLOSED;\n-        if (anyAreSet(state, FLAG_GATE_OPEN)) {\n-            delegate.close();\n-        }\n-    }\n-\n-    public boolean isOpen() {\n-        return allAreClear(state, FLAG_CLOSED);\n-    }\n-\n-    public boolean supportsOption(final Option<?> option) {\n-        return false;\n-    }\n-\n-    public <T> T getOption(final Option<T> option) throws IOException {\n-        return null;\n-    }\n-\n-    public <T> T setOption(final Option<T> option, final T value) throws IllegalArgumentException, IOException {\n-        return null;\n-    }\n-\n-    /**\n-     * Get the underlying channel if the gate is open, else return this channel.\n-     *\n-     * @return the underlying channel, or this channel if the gate is not open\n-     */\n-    public StreamSourceChannel getChannel() {\n-        return allAreSet(state, FLAG_GATE_OPEN) ? delegate : this;\n-    }\n-\n-}"
  },
  {
    "sha": "d69ac4f1c9d72d79d0435dd1aa9080a7b8825841",
    "filename": "core/src/main/java/io/undertow/channels/ReadTimeoutStreamSourceChannel.java",
    "status": "removed",
    "additions": 0,
    "deletions": 159,
    "changes": 159,
    "blob_url": "https://github.com/ptrepag/undertow/blob/15a2924e3408959e01d0418aa1a952212ee5e45a/core/src/main/java/io/undertow/channels/ReadTimeoutStreamSourceChannel.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/15a2924e3408959e01d0418aa1a952212ee5e45a/core/src/main/java/io/undertow/channels/ReadTimeoutStreamSourceChannel.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/channels/ReadTimeoutStreamSourceChannel.java?ref=15a2924e3408959e01d0418aa1a952212ee5e45a",
    "patch": "@@ -1,159 +0,0 @@\n-/*\n- * JBoss, Home of Professional Open Source.\n- * Copyright 2014 Red Hat, Inc., and individual contributors\n- * as indicated by the @author tags.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-\n-package io.undertow.channels;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.concurrent.TimeUnit;\n-\n-import io.undertow.UndertowLogger;\n-import org.xnio.ChannelListeners;\n-import org.xnio.IoUtils;\n-import org.xnio.Option;\n-import org.xnio.Options;\n-import org.xnio.XnioExecutor;\n-import org.xnio.channels.StreamSinkChannel;\n-import org.xnio.channels.StreamSourceChannel;\n-\n-/**\n- * Wrapper for read timeout. This should always be the first wrapper applied to the underlying channel.\n- *\n- * @author Stuart Douglas\n- * @see org.xnio.Options#READ_TIMEOUT\n- */\n-public final class ReadTimeoutStreamSourceChannel extends DelegatingStreamSourceChannel<ReadTimeoutStreamSourceChannel> {\n-\n-    private int readTimeout;\n-    private XnioExecutor.Key handle;\n-\n-    private final Runnable timeoutCommand = new Runnable() {\n-        @Override\n-        public void run() {\n-            UndertowLogger.REQUEST_LOGGER.tracef(\"Timing out channel %s due to inactivity\");\n-            try {\n-                if (delegate.isReadResumed()) {\n-                    ChannelListeners.invokeChannelListener(ReadTimeoutStreamSourceChannel.this, readSetter.get());\n-                }\n-            } finally {\n-                IoUtils.safeClose(delegate);\n-            }\n-        }\n-    };\n-\n-    /**\n-     * @param delegate    The underlying channel\n-     */\n-    public ReadTimeoutStreamSourceChannel(final StreamSourceChannel delegate) {\n-        super(delegate);\n-        try {\n-            Integer timeout = delegate.getOption(Options.READ_TIMEOUT);\n-            if (timeout != null) {\n-                this.readTimeout = timeout;\n-            } else {\n-                this.readTimeout = 0;\n-            }\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    private void handleReadTimeout(final long ret) {\n-        if(ret == -1) {\n-            if(handle != null) {\n-                handle.remove();\n-                handle = null;\n-            }\n-        } else if (readTimeout > 0) {\n-            if (ret == 0 && handle == null) {\n-                handle = delegate.getIoThread().executeAfter(timeoutCommand, readTimeout, TimeUnit.MILLISECONDS);\n-            } else if (ret > 0 && handle != null) {\n-                handle.remove();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public long transferTo(final long position, final long count, final FileChannel target) throws IOException {\n-        long ret = delegate.transferTo(position, count, target);\n-        handleReadTimeout(ret);\n-        return ret;\n-    }\n-\n-    @Override\n-    public long transferTo(final long count, final ByteBuffer throughBuffer, final StreamSinkChannel target) throws IOException {\n-        long ret = delegate.transferTo(count, throughBuffer, target);\n-        handleReadTimeout(ret);\n-        return ret;\n-    }\n-\n-    @Override\n-    public long read(final ByteBuffer[] dsts, final int offset, final int length) throws IOException {\n-        long ret = delegate.read(dsts, offset, length);\n-        handleReadTimeout(ret);\n-        return ret;\n-    }\n-\n-    @Override\n-    public long read(final ByteBuffer[] dsts) throws IOException {\n-        long ret = delegate.read(dsts);\n-        handleReadTimeout(ret);\n-        return ret;\n-    }\n-\n-    @Override\n-    public int read(final ByteBuffer dst) throws IOException {\n-        int ret = delegate.read(dst);\n-        handleReadTimeout(ret);\n-        return ret;\n-    }\n-\n-    @Override\n-    public <T> T setOption(final Option<T> option, final T value) throws IllegalArgumentException, IOException {\n-        T ret = super.setOption(option, value);\n-        if (option == Options.READ_TIMEOUT) {\n-            readTimeout = (Integer) value;\n-            if (handle != null) {\n-                handle.remove();\n-                if (readTimeout > 0) {\n-                    getReadThread().executeAfter(timeoutCommand, readTimeout, TimeUnit.MILLISECONDS);\n-                }\n-            }\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    public void shutdownReads() throws IOException {\n-        super.shutdownReads();\n-        if(handle != null) {\n-            handle.remove();\n-            handle = null;\n-        }\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-        super.close();\n-        if(handle != null) {\n-            handle.remove();\n-            handle = null;\n-        }\n-    }\n-}"
  },
  {
    "sha": "cac1089bdae2bf1bda6a2b76401b37262a62a7ea",
    "filename": "core/src/main/java/io/undertow/channels/WriteTimeoutStreamSinkChannel.java",
    "status": "removed",
    "additions": 0,
    "deletions": 188,
    "changes": 188,
    "blob_url": "https://github.com/ptrepag/undertow/blob/15a2924e3408959e01d0418aa1a952212ee5e45a/core/src/main/java/io/undertow/channels/WriteTimeoutStreamSinkChannel.java",
    "raw_url": "https://github.com/ptrepag/undertow/raw/15a2924e3408959e01d0418aa1a952212ee5e45a/core/src/main/java/io/undertow/channels/WriteTimeoutStreamSinkChannel.java",
    "contents_url": "https://api.github.com/repos/ptrepag/undertow/contents/core/src/main/java/io/undertow/channels/WriteTimeoutStreamSinkChannel.java?ref=15a2924e3408959e01d0418aa1a952212ee5e45a",
    "patch": "@@ -1,188 +0,0 @@\n-/*\n- * JBoss, Home of Professional Open Source.\n- * Copyright 2014 Red Hat, Inc., and individual contributors\n- * as indicated by the @author tags.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-\n-package io.undertow.channels;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.util.concurrent.TimeUnit;\n-\n-import io.undertow.UndertowLogger;\n-import org.xnio.Buffers;\n-import org.xnio.ChannelListeners;\n-import org.xnio.IoUtils;\n-import org.xnio.Option;\n-import org.xnio.Options;\n-import org.xnio.XnioExecutor;\n-import org.xnio.channels.StreamSinkChannel;\n-import org.xnio.channels.StreamSourceChannel;\n-\n-/**\n- * Wrapper for write timeout. This should always be the first wrapper applied to the underlying channel.\n- * <p>\n- *\n- * @author Stuart Douglas\n- * @see org.xnio.Options#WRITE_TIMEOUT\n- */\n-public final class WriteTimeoutStreamSinkChannel extends DelegatingStreamSinkChannel<WriteTimeoutStreamSinkChannel> {\n-\n-    private int writeTimeout;\n-    private XnioExecutor.Key handle;\n-\n-    private final Runnable timeoutCommand = new Runnable() {\n-        @Override\n-        public void run() {\n-            UndertowLogger.REQUEST_LOGGER.tracef(\"Timing out channel %s due to inactivity\");\n-            try {\n-                if (delegate.isWriteResumed()) {\n-                    ChannelListeners.invokeChannelListener(WriteTimeoutStreamSinkChannel.this, writeSetter.get());\n-                }\n-            } finally {\n-                IoUtils.safeClose(delegate);\n-            }\n-        }\n-    };\n-\n-    /**\n-     * @param delegate    The underlying channel\n-     */\n-    public WriteTimeoutStreamSinkChannel(final StreamSinkChannel delegate) {\n-        super(delegate);\n-        try {\n-            Integer timeout = delegate.getOption(Options.WRITE_TIMEOUT);\n-            if (timeout != null) {\n-                this.writeTimeout = timeout;\n-            } else {\n-                this.writeTimeout = 0;\n-            }\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    private void handleWriteTimeout(final long ret) {\n-        if (writeTimeout > 0) {\n-            if (ret == 0 && handle == null) {\n-                handle = delegate.getWriteThread().executeAfter(timeoutCommand, writeTimeout, TimeUnit.MILLISECONDS);\n-            } else if (ret > 0 && handle != null) {\n-                handle.remove();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public int write(final ByteBuffer src) throws IOException {\n-        int ret = delegate.write(src);\n-        handleWriteTimeout(ret);\n-        return ret;\n-    }\n-\n-    @Override\n-    public long write(final ByteBuffer[] srcs, final int offset, final int length) throws IOException {\n-        long ret = delegate.write(srcs, offset, length);\n-        handleWriteTimeout(ret);\n-        return ret;\n-    }\n-\n-    @Override\n-    public int writeFinal(ByteBuffer src) throws IOException {\n-        int ret = delegate.writeFinal(src);\n-        handleWriteTimeout(ret);\n-        if(!src.hasRemaining()) {\n-            if(handle != null) {\n-                handle.remove();\n-                handle = null;\n-            }\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n-        long ret = delegate.writeFinal(srcs, offset, length);\n-        handleWriteTimeout(ret);\n-        if(!Buffers.hasRemaining(srcs, offset, length)) {\n-            if(handle != null) {\n-                handle.remove();\n-                handle = null;\n-            }\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    public long writeFinal(ByteBuffer[] srcs) throws IOException {\n-        long ret = delegate.writeFinal(srcs);\n-        handleWriteTimeout(ret);\n-        if(!Buffers.hasRemaining(srcs)) {\n-            if(handle != null) {\n-                handle.remove();\n-                handle = null;\n-            }\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    public long transferFrom(final FileChannel src, final long position, final long count) throws IOException {\n-        long ret = delegate.transferFrom(src, position, count);\n-        handleWriteTimeout(ret);\n-        return ret;\n-    }\n-\n-    @Override\n-    public long transferFrom(final StreamSourceChannel source, final long count, final ByteBuffer throughBuffer) throws IOException {\n-        long ret = delegate.transferFrom(source, count, throughBuffer);\n-        handleWriteTimeout(ret);\n-        return ret;\n-    }\n-\n-    @Override\n-    public <T> T setOption(final Option<T> option, final T value) throws IllegalArgumentException, IOException {\n-        T ret = super.setOption(option, value);\n-        if (option == Options.WRITE_TIMEOUT) {\n-            writeTimeout = (Integer) value;\n-            if (handle != null) {\n-                handle.remove();\n-                if(writeTimeout > 0) {\n-                    getWriteThread().executeAfter(timeoutCommand, writeTimeout, TimeUnit.MILLISECONDS);\n-                }\n-            }\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    public void shutdownWrites() throws IOException {\n-        super.shutdownWrites();\n-        if(handle != null) {\n-            handle.remove();\n-            handle = null;\n-        }\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-        super.close();\n-        if(handle != null) {\n-            handle.remove();\n-            handle = null;\n-        }\n-    }\n-}"
  }
]
