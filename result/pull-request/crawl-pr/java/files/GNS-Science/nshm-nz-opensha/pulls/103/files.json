[
  {
    "sha": "f0b835ab9987dd20618bbbc5e54354a3aa6b9aff",
    "filename": "README.md",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/GNS-Science/nshm-nz-opensha/blob/07df109021a63e45b9b272f86a7c1722e4285792/README.md",
    "raw_url": "https://github.com/GNS-Science/nshm-nz-opensha/raw/07df109021a63e45b9b272f86a7c1722e4285792/README.md",
    "contents_url": "https://api.github.com/repos/GNS-Science/nshm-nz-opensha/contents/README.md?ref=07df109021a63e45b9b272f86a7c1722e4285792",
    "patch": "@@ -46,3 +46,4 @@ Test reports are found at  `./build/reports/tests/localTests/index.html`\n \n \n \n+"
  },
  {
    "sha": "cf8717beea574400c284c3226c294e4cd0ea99fe",
    "filename": "src/main/java/nz/cri/gns/NSHM/opensha/analysis/NSHM_FaultSystemRupSetCalc.java",
    "status": "modified",
    "additions": 8,
    "deletions": 3,
    "changes": 11,
    "blob_url": "https://github.com/GNS-Science/nshm-nz-opensha/blob/07df109021a63e45b9b272f86a7c1722e4285792/src/main/java/nz/cri/gns/NSHM/opensha/analysis/NSHM_FaultSystemRupSetCalc.java",
    "raw_url": "https://github.com/GNS-Science/nshm-nz-opensha/raw/07df109021a63e45b9b272f86a7c1722e4285792/src/main/java/nz/cri/gns/NSHM/opensha/analysis/NSHM_FaultSystemRupSetCalc.java",
    "contents_url": "https://api.github.com/repos/GNS-Science/nshm-nz-opensha/contents/src/main/java/nz/cri/gns/NSHM/opensha/analysis/NSHM_FaultSystemRupSetCalc.java?ref=07df109021a63e45b9b272f86a7c1722e4285792",
    "patch": "@@ -1,10 +1,14 @@\n package nz.cri.gns.NSHM.opensha.analysis;\n \n+import java.io.FileWriter;\n import java.util.HashMap;\n import java.util.List;\n+\n+import org.opensha.commons.data.function.HistogramFunction;\n import org.opensha.sha.faultSurface.FaultSection;\n import scratch.UCERF3.FaultSystemRupSet;\n import scratch.UCERF3.analysis.FaultSystemRupSetCalc;\n+import scratch.UCERF3.inversion.InversionFaultSystemRupSet;\n \n public class NSHM_FaultSystemRupSetCalc extends FaultSystemRupSetCalc {\n \n@@ -49,11 +53,12 @@\n \t\t// do the last one:\n \t\tmagForParSectMap.put(prevParSectName, maxMinSeismoMag);\n \n-//\t\tfor(String parName:magForParSectMap.keySet())\n-//\t\t\tSystem.out.println(parName+\"\\t\"+magForParSectMap.get(parName));\n+\t\t// for(String parName:magForParSectMap.keySet())\n+\t\t// System.out.println(parName+\"\\t\"+magForParSectMap.get(parName));\n \n \t\t// now set the value for each section in the array, giving a value of\n-\t\t// systemWideMinMinSeismoMag if the parent section value falls below this\n+\t\t// systemWideMinMinSeismoMag\n+\t\t// if the parent section value falls below this\n \t\tfor (int s = 0; s < sectDataList.size(); s++) {\n \t\t\tdouble minMag = magForParSectMap.get(sectDataList.get(s).getParentSectionName());\n \t\t\tif (minMag > systemWideMinSeismoMag)"
  },
  {
    "sha": "09a2d0de9a4c8681a42d94e5152d85db8d45fd89",
    "filename": "src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHMInversionRunner.java",
    "status": "modified",
    "additions": 17,
    "deletions": 22,
    "changes": 39,
    "blob_url": "https://github.com/GNS-Science/nshm-nz-opensha/blob/07df109021a63e45b9b272f86a7c1722e4285792/src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHMInversionRunner.java",
    "raw_url": "https://github.com/GNS-Science/nshm-nz-opensha/raw/07df109021a63e45b9b272f86a7c1722e4285792/src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHMInversionRunner.java",
    "contents_url": "https://api.github.com/repos/GNS-Science/nshm-nz-opensha/contents/src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHMInversionRunner.java?ref=07df109021a63e45b9b272f86a7c1722e4285792",
    "patch": "@@ -34,6 +34,7 @@\n import scratch.UCERF3.simulatedAnnealing.completion.*;\n import scratch.UCERF3.utils.FaultSystemIO;\n import scratch.UCERF3.utils.MFD_InversionConstraint;\n+import scratch.UCERF3.utils.aveSlip.AveSlipConstraint;\n \n import java.io.File;\n import java.io.IOException;\n@@ -258,6 +259,7 @@ public NSHMInversionRunner configure() {\n \tprotected FaultSystemRupSet loadRupSet(File file) throws IOException, DocumentException {\n \t\tFaultSystemRupSet fsRupSet = FaultSystemIO.loadRupSet(file);\n \t\treturn fsRupSet;\n+\n \t}\n \n \t/**\n@@ -270,35 +272,23 @@ protected FaultSystemRupSet loadRupSet(File file) throws IOException, DocumentEx\n \t */\n \tpublic FaultSystemSolution runInversion() throws IOException, DocumentException {\n \n-\t\t///////\n-\t\t// This is now in NSHM_InversionGenerator with parameters defined in\n-\t\t/////// NSHM_InversionConfiguration...\n-\t\t// /*\n-\t\t// * Slip rate constraints\n-\t\t// */\n-\t\t// constraints.add(new\n-\t\t/////// SlipRateInversionConstraint(this.slipRateConstraintWt_normalized,\n-\t\t// this.slipRateConstraintWt_unnormalized,\n-\t\t// this.slipRateWeighting, rupSet, rupSet.getSlipRateForAllSections()));\n-\t\t//\n-\t\t// /* MFD constraints are now built here\n-\t\t// *\n-\t\t// */\n-\t\t// inversionMFDs = new NSHM_InversionTargetMFDs(this.rupSet);\n-\t\t// for (InversionConstraint constraint : inversionMFDs.getMFDConstraints()) {\n-\t\t// constraints.add(constraint);\n-\t\t// }\n-\t\t//\n-\t\t/////////////////////////////\n-\n \t\t// weight of entropy-maximization constraint (not used in UCERF3)\n \t\tdouble smoothnessWt = 0;\n \n \t\t/*\n \t\t * Build inversion inputs\n \t\t */\n+\t\tList<AveSlipConstraint> aveSlipConstraints = null;\n+\t\t// try {\n+\t\t// aveSlipConstraints =\n+\t\t// AveSlipConstraint.load(rupSet.getFaultSectionDataList());\n+\t\t// } catch (IOException e) {\n+\t\t// e.printStackTrace();\n+\t\t// System.exit(1);\n+\t\t// }\n+\n \t\tNSHM_InversionInputGenerator inputGen = new NSHM_InversionInputGenerator(rupSet, inversionConfiguration, null,\n-\t\t\t\tnull, null, null);\n+\t\t\t\taveSlipConstraints, null, null);\n \n \t\tinputGen.generateInputs(true);\n \t\t// column compress it for fast annealing\n@@ -310,6 +300,11 @@ public FaultSystemSolution runInversion() throws IOException, DocumentException\n \t\t\tthis.completionCriterias.add(this.energyChangeCompletionCriteria);\n \n \t\tcompletionCriteria = new CompoundCompletionCriteria(this.completionCriterias);\n+\n+\t\t// Bring up window to track progress\n+\t\t// criteria = new ProgressTrackingCompletionCriteria(criteria, progressReport,\n+\t\t// 0.1d);\n+\t\t// ....\n \t\tcompletionCriteria = new ProgressTrackingCompletionCriteria(completionCriteria);\n \n \t\t// this is the \"sub completion criteria\" - the amount of time (or iterations)"
  },
  {
    "sha": "572538847a3a2abdbb86656cb5f89edc966cdca8",
    "filename": "src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHM_InversionConfiguration.java",
    "status": "modified",
    "additions": 44,
    "deletions": 32,
    "changes": 76,
    "blob_url": "https://github.com/GNS-Science/nshm-nz-opensha/blob/07df109021a63e45b9b272f86a7c1722e4285792/src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHM_InversionConfiguration.java",
    "raw_url": "https://github.com/GNS-Science/nshm-nz-opensha/raw/07df109021a63e45b9b272f86a7c1722e4285792/src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHM_InversionConfiguration.java",
    "contents_url": "https://api.github.com/repos/GNS-Science/nshm-nz-opensha/contents/src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHM_InversionConfiguration.java?ref=07df109021a63e45b9b272f86a7c1722e4285792",
    "patch": "@@ -8,11 +8,13 @@\n import org.opensha.commons.metadata.XMLSaveable;\r\n import org.opensha.commons.util.XMLUtils;\r\n import org.opensha.sha.magdist.IncrementalMagFreqDist;\r\n+import org.opensha.sha.magdist.SummedMagFreqDist;\r\n \r\n import com.google.common.collect.Lists;\r\n \r\n import scratch.UCERF3.FaultSystemRupSet;\r\n import scratch.UCERF3.enumTreeBranches.InversionModels;\r\n+import scratch.UCERF3.inversion.UCERF3InversionConfiguration;\r\n import scratch.UCERF3.inversion.UCERF3InversionConfiguration.SlipRateConstraintWeightingType;\r\n import scratch.UCERF3.utils.MFD_InversionConstraint;\r\n \r\n@@ -40,11 +42,11 @@\n //\tprivate double rupRateConstraintWt;\r\n //\tprivate double participationSmoothnessConstraintWt;\r\n //\tprivate double participationConstraintMagBinSize;\r\n-//\tprivate double nucleationMFDConstraintWt;\r\n+\tprivate double nucleationMFDConstraintWt;\r\n //\tprivate double mfdSmoothnessConstraintWt;\r\n //\tprivate double mfdSmoothnessConstraintWtForPaleoParents;\r\n //\tprivate double rupRateSmoothingConstraintWt;\r\n-//\tprivate double minimizationConstraintWt;\r\n+\tprivate double minimizationConstraintWt;\r\n //\tprivate double momentConstraintWt;\r\n //\tprivate double parkfieldConstraintWt;\r\n //\tprivate double[] aPrioriRupConstraint;\r\n@@ -288,7 +290,7 @@ public static NSHM_InversionConfiguration forModel(InversionModels model, NSHM_I\n //\t\tdouble participationSmoothnessConstraintWt;\r\n //\t\t\r\n //\t\t// weight of nucleation MFD constraint - applied on subsection basis\r\n-//\t\tdouble nucleationMFDConstraintWt;\r\n+\t\tdouble nucleationMFDConstraintWt;\r\n //\t\t\r\n //\t\t// weight of spatial MFD smoothness constraint (recommended:  1000)\r\n //\t\tdouble mfdSmoothnessConstraintWt;\r\n@@ -298,36 +300,39 @@ public static NSHM_InversionConfiguration forModel(InversionModels model, NSHM_I\n //\t\tdouble eventRateSmoothnessWt;\r\n //\t\t\r\n //\t\t// fraction of the minimum rupture rate basis to be used as initial rates\r\n-//\t\tdouble minimumRuptureRateFraction;\r\n+\t\tdouble minimumRuptureRateFraction = 0;\r\n //\t\t\r\n //\t\tdouble[] aPrioriRupConstraint;\r\n-//\t\tdouble[] initialRupModel;\r\n-//\t\tdouble[] minimumRuptureRateBasis;\r\n+\t\tdouble[] initialRupModel = null;\r\n+\t\tdouble[] minimumRuptureRateBasis = null;\r\n //\t\t\r\n-//\t\tSummedMagFreqDist targetOnFaultMFD =  rupSet.getInversionTargetMFDs().getOnFaultSupraSeisMFD();\r\n+\t\tSummedMagFreqDist targetOnFaultMFD = rupSet.getInversionTargetMFDs().getOnFaultSupraSeisMFD();\r\n ////\t\tSystem.out.println(\"SUPRA SEIS MFD = \");\r\n ////\t\tSystem.out.println(rupSet.getInversionMFDs().getTargetOnFaultSupraSeisMFD());\r\n-//\t\t\r\n \r\n \t\tif (model.isConstrained()) {\r\n \t\t\t// CONSTRAINED BRANCHES\r\n \t\t\tif (model == InversionModels.CHAR_CONSTRAINED) {\r\n //\t\t\t\tparticipationSmoothnessConstraintWt = 0;\r\n-//\t\t\t\tnucleationMFDConstraintWt = 0.01;\r\n+\t\t\t\tnucleationMFDConstraintWt = 0.01;\r\n //\t\t\t\tmfdSmoothnessConstraintWt = 0;\r\n //\t\t\t\tmfdSmoothnessConstraintWtForPaleoParents = 1000;\r\n //\t\t\t\teventRateSmoothnessWt = 0;\r\n //\t\t\t\trupRateConstraintWt = 0;\r\n //\t\t\t\taPrioriRupConstraint = getUCERF2Solution(rupSet);\r\n //\t\t\t\tinitialRupModel = Arrays.copyOf(aPrioriRupConstraint, aPrioriRupConstraint.length); \r\n-//\t\t\t\tminimumRuptureRateFraction = 0.01;\r\n-//\t\t\t\tminimumRuptureRateBasis = adjustStartingModel(getSmoothStartingSolution(rupSet,targetOnFaultMFD), mfdConstraints, rupSet, true);\r\n+\r\n+\t\t\t\t// For water level\r\n+\t\t\t\tminimumRuptureRateFraction = 0.01;\r\n+\t\t\t\tminimumRuptureRateBasis = UCERF3InversionConfiguration.adjustStartingModel(\r\n+\t\t\t\t\t\tUCERF3InversionConfiguration.getSmoothStartingSolution(rupSet, targetOnFaultMFD),\r\n+\t\t\t\t\t\tmfdConstraints, rupSet, true);\r\n \r\n //\t\t\t\tinitialRupModel = adjustIsolatedSections(rupSet, initialRupModel);\r\n //\t\t\t\tif (mfdInequalityConstraintWt>0.0 || mfdEqualityConstraintWt>0.0) initialRupModel = adjustStartingModel(initialRupModel, mfdConstraints, rupSet, true);\r\n //\t\t\t\tinitialRupModel = adjustParkfield(rupSet, initialRupModel);\r\n //\t\t\t\tinitialRupModel = removeRupsBelowMinMag(rupSet, initialRupModel);\r\n-//\t\t\t\tinitialRupModel = new double[initialRupModel.length];\r\n+\t\t\t\tinitialRupModel = new double[rupSet.getNumRuptures()];\r\n \t\t\t} else if (model == InversionModels.GR_CONSTRAINED) {\r\n //\t\t\t\tparticipationSmoothnessConstraintWt = 1000;\r\n //\t\t\t\tnucleationMFDConstraintWt = 0;\r\n@@ -381,15 +386,20 @@ public static NSHM_InversionConfiguration forModel(InversionModels model, NSHM_I\n \r\n \t\t// NSHM-style config using setter methods...\r\n \t\tNSHM_InversionConfiguration newConfig = new NSHM_InversionConfiguration()\r\n+\t\t\t\t// MFD config\r\n \t\t\t\t.setMagnitudeEqualityConstraintWt(mfdEqualityConstraintWt)\r\n \t\t\t\t.setMagnitudeInequalityConstraintWt(mfdInequalityConstraintWt)\r\n \t\t\t\t.setMfdEqualityConstraints(mfdEqualityConstraints).setMfdInequalityConstraints(mfdInequalityConstraints)\r\n+\t\t\t\t// Slip Rate config\r\n \t\t\t\t.setSlipRateConstraintWt_normalized(slipRateConstraintWt_normalized)\r\n \t\t\t\t.setSlipRateConstraintWt_unnormalized(slipRateConstraintWt_unnormalized)\r\n-\t\t\t\t.setSlipRateWeightingType(slipRateWeighting);\r\n+\t\t\t\t.setSlipRateWeightingType(slipRateWeighting)\r\n+\t\t\t\t// Rate Minimization config\r\n+\t\t\t\t.setMinimizationConstraintWt(minimizationConstraintWt)\r\n+\t\t\t\t.setMinimumRuptureRateFraction(minimumRuptureRateFraction)\r\n+\t\t\t\t.setMinimumRuptureRateBasis(minimumRuptureRateBasis).setInitialRupModel(initialRupModel);\r\n \r\n \t\treturn newConfig;\r\n-\r\n \t}\r\n \r\n \t/**\r\n@@ -514,16 +524,16 @@ public NSHM_InversionConfiguration setMagnitudeInequalityConstraintWt(\n //\t\tthis.participationConstraintMagBinSize = participationConstraintMagBinSize;\r\n //\t}\r\n \r\n-//\tpublic double getMinimizationConstraintWt() {\r\n-//\t\treturn minimizationConstraintWt;\r\n-//\t}\r\n-//\r\n-//\tpublic void setMinimizationConstraintWt(\r\n-//\t\t\tdouble relativeMinimizationConstraintWt) {\r\n-//\t\tthis.minimizationConstraintWt = relativeMinimizationConstraintWt;\r\n-//\t}\r\n+\tpublic double getMinimizationConstraintWt() {\r\n+\t\treturn minimizationConstraintWt;\r\n+\t}\r\n \r\n-//\tpublic double getMomentConstraintWt() {\r\n+\tpublic NSHM_InversionConfiguration setMinimizationConstraintWt(double relativeMinimizationConstraintWt) {\r\n+\t\tthis.minimizationConstraintWt = relativeMinimizationConstraintWt;\r\n+\t\treturn this;\r\n+\t}\r\n+\r\n+\t// public double getMomentConstraintWt() {\r\n //\t\treturn momentConstraintWt;\r\n //\t}\r\n //\r\n@@ -557,6 +567,7 @@ public NSHM_InversionConfiguration setMinimumRuptureRateBasis(double[] minimumRu\n \t\tthis.minimumRuptureRateBasis = minimumRuptureRateBasis;\r\n \t\treturn this;\r\n \t}\r\n+\r\n //\r\n //\tpublic double getSmoothnessWt() {\r\n //\t\treturn smoothnessWt;\r\n@@ -566,13 +577,14 @@ public NSHM_InversionConfiguration setMinimumRuptureRateBasis(double[] minimumRu\n //\t\tthis.smoothnessWt = relativeSmoothnessWt;\r\n //\t}\r\n //\r\n-//\tpublic double getNucleationMFDConstraintWt() {\r\n-//\t\treturn nucleationMFDConstraintWt;\r\n-//\t}\r\n-//\r\n-//\tpublic void setNucleationMFDConstraintWt(double relativeNucleationMFDConstraintWt) {\r\n-//\t\tthis.nucleationMFDConstraintWt = relativeNucleationMFDConstraintWt;\r\n-//\t}\r\n+\tpublic double getNucleationMFDConstraintWt() {\r\n+\t\treturn nucleationMFDConstraintWt;\r\n+\t}\r\n+\r\n+\tpublic NSHM_InversionConfiguration setNucleationMFDConstraintWt(double relativeNucleationMFDConstraintWt) {\r\n+\t\tthis.nucleationMFDConstraintWt = relativeNucleationMFDConstraintWt;\r\n+\t\treturn this;\r\n+\t}\r\n //\t\r\n //\tpublic double getMFDSmoothnessConstraintWt() {\r\n //\t\treturn mfdSmoothnessConstraintWt;\r\n@@ -634,15 +646,15 @@ public void updateRupSetInfoString(FaultSystemRupSet rupSet) {\n //\t\treturn eventRateSmoothnessWt;\r\n //\t}\r\n //\r\n-//\tpublic void setEventRateSmoothnessWt(double eventRateSmoothnessWt) {\r\n+//\tpublic NSHM_InversionConfiguration setEventRateSmoothnessWt(double eventRateSmoothnessWt) {\r\n //\t\tthis.eventRateSmoothnessWt = eventRateSmoothnessWt;\r\n //\t}\r\n //\t\r\n //\tpublic double getRupRateSmoothingConstraintWt() {\r\n //\t\treturn rupRateSmoothingConstraintWt;\r\n //\t}\r\n //\r\n-//\tpublic void setRupRateSmoothingConstraintWt(double rupRateSmoothingConstraintWt) {\r\n+//\tpublic NSHM_InversionConfiguration setRupRateSmoothingConstraintWt(double rupRateSmoothingConstraintWt) {\r\n //\t\tthis.rupRateSmoothingConstraintWt = rupRateSmoothingConstraintWt;\r\n //\t}\r\n \r"
  },
  {
    "sha": "f8c8b0ffc38f33ccb908485f00aea4ad2503c8c4",
    "filename": "src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHM_InversionInputGenerator.java",
    "status": "modified",
    "additions": 24,
    "deletions": 18,
    "changes": 42,
    "blob_url": "https://github.com/GNS-Science/nshm-nz-opensha/blob/07df109021a63e45b9b272f86a7c1722e4285792/src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHM_InversionInputGenerator.java",
    "raw_url": "https://github.com/GNS-Science/nshm-nz-opensha/raw/07df109021a63e45b9b272f86a7c1722e4285792/src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHM_InversionInputGenerator.java",
    "contents_url": "https://api.github.com/repos/GNS-Science/nshm-nz-opensha/contents/src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHM_InversionInputGenerator.java?ref=07df109021a63e45b9b272f86a7c1722e4285792",
    "patch": "@@ -14,6 +14,8 @@\n //import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.APrioriInversionConstraint;\r\n import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.MFDEqualityInversionConstraint;\r\n import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.MFDInequalityInversionConstraint;\r\n+import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.MFDSubSectNuclInversionConstraint;\r\n+import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.RupRateMinimizationConstraint;\r\n //import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.MFDLaplacianSmoothingInversionConstraint;\r\n //import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.MFDParticipationSmoothnessInversionConstraint;\r\n //import org.opensha.sha.earthquake.faultSysSolution.inversion.constraints.impl.MFDSubSectNuclInversionConstraint;\r\n@@ -33,12 +35,14 @@\n //import com.google.common.collect.Lists;\r\n //import com.google.common.collect.Maps;\r\n \r\n+import nz.cri.gns.NSHM.opensha.analysis.NSHM_FaultSystemRupSetCalc;\r\n //import cern.colt.function.tdouble.IntIntDoubleFunction;\r\n //import cern.colt.list.tdouble.DoubleArrayList;\r\n //import cern.colt.list.tint.IntArrayList;\r\n //import cern.colt.matrix.tdouble.DoubleMatrix2D;\r\n import scratch.UCERF3.FaultSystemRupSet;\r\n import scratch.UCERF3.SlipEnabledRupSet;\r\n+import scratch.UCERF3.utils.SectionMFD_constraint;\r\n //import scratch.UCERF3.analysis.FaultSystemRupSetCalc;\r\n //import scratch.UCERF3.enumTreeBranches.InversionModels;\r\n //\r\n@@ -106,7 +110,7 @@ public static PaleoProbabilityModel loadDefaultPaleoProbabilityModel() throws IO\n \t\treturn defaultProbModel;\r\n \t}\r\n \r\n-\tprivate static List<InversionConstraint> buildConstraints(SlipEnabledRupSet rupSet,\r\n+\tprivate static List<InversionConstraint> buildConstraints(NSHM_InversionFaultSystemRuptSet rupSet,\r\n \t\t\tNSHM_InversionConfiguration config, List<PaleoRateConstraint> paleoRateConstraints,\r\n \t\t\tList<AveSlipConstraint> aveSlipConstraints, PaleoProbabilityModel paleoProbabilityModel) {\r\n \r\n@@ -140,17 +144,18 @@ public static PaleoProbabilityModel loadDefaultPaleoProbabilityModel() throws IO\n //\t\t// This constrains rates of ruptures that differ by only 1 subsection\r\n //\t\tif (config.getRupRateSmoothingConstraintWt() > 0)\r\n //\t\t\tconstraints.add(new RupRateSmoothingInversionConstraint(config.getRupRateSmoothingConstraintWt(), rupSet));\r\n-//\r\n-\t\t\r\n-//\t\t// Rupture rate minimization constraint\r\n-//\t\t// Minimize the rates of ruptures below SectMinMag (strongly so that they have zero rates)\r\n-//\t\tif (config.getMinimizationConstraintWt() > 0.0) {\r\n-//\t\t\tList<Integer> belowMinIndexes = new ArrayList<>();\r\n-//\t\t\tfor (int r=0; r<rupSet.getNumRuptures(); r++)\r\n-//\t\t\t\tif (rupSet.isRuptureBelowSectMinMag(r))\r\n-//\t\t\t\t\tbelowMinIndexes.add(r);\r\n-//\t\t\tconstraints.add(new RupRateMinimizationConstraint(config.getMinimizationConstraintWt(), belowMinIndexes));\r\n-//\t\t}\r\n+//\t\t\r\n+\r\n+\t\t// Rupture rate minimization constraint\r\n+\t\t// Minimize the rates of ruptures below SectMinMag (strongly so that they have\r\n+\t\t// zero rates)\r\n+\t\tif (config.getMinimizationConstraintWt() > 0.0) {\r\n+\t\t\tList<Integer> belowMinIndexes = new ArrayList<>();\r\n+\t\t\tfor (int r = 0; r < rupSet.getNumRuptures(); r++)\r\n+\t\t\t\tif (rupSet.isRuptureBelowSectMinMag(r))\r\n+\t\t\t\t\tbelowMinIndexes.add(r);\r\n+\t\t\tconstraints.add(new RupRateMinimizationConstraint(config.getMinimizationConstraintWt(), belowMinIndexes));\r\n+\t\t}\r\n \r\n \t\t// Constrain Solution MFD to equal the Target MFD\r\n \t\t// This is for equality constraints only -- inequality constraints must be\r\n@@ -172,12 +177,13 @@ public static PaleoProbabilityModel loadDefaultPaleoProbabilityModel() throws IO\n //\t\t\tconstraints.add(new MFDParticipationSmoothnessInversionConstraint(rupSet,\r\n //\t\t\t\t\tconfig.getParticipationSmoothnessConstraintWt(), config.getParticipationConstraintMagBinSize()));\r\n \r\n-//\t\t// MFD Subsection nucleation MFD constraint\r\n-//\t\tArrayList<SectionMFD_constraint> MFDConstraints = null;\r\n-//\t\tif (config.getNucleationMFDConstraintWt() > 0.0) {\r\n-//\t\t\tMFDConstraints = FaultSystemRupSetCalc.getCharInversionSectMFD_Constraints(rupSet);\r\n-//\t\t\tconstraints.add(new MFDSubSectNuclInversionConstraint(rupSet, config.getNucleationMFDConstraintWt(), MFDConstraints));\r\n-//\t\t}\r\n+\t\t// MFD Subsection nucleation MFD constraint\r\n+\t\tArrayList<SectionMFD_constraint> MFDConstraints = null;\r\n+\t\tif (config.getNucleationMFDConstraintWt() > 0.0) {\r\n+\t\t\tMFDConstraints = NSHM_FaultSystemRupSetCalc.getCharInversionSectMFD_Constraints(rupSet);\r\n+\t\t\tconstraints.add(new MFDSubSectNuclInversionConstraint(rupSet, config.getNucleationMFDConstraintWt(),\r\n+\t\t\t\t\tMFDConstraints));\r\n+\t\t}\r\n \r\n //\t\t// MFD Smoothing constraint - MFDs spatially smooth along adjacent subsections on a parent section (Laplacian smoothing)\r\n //\t\tif (config.getMFDSmoothnessConstraintWt() > 0.0 || config.getMFDSmoothnessConstraintWtForPaleoParents() > 0.0) {  \r"
  },
  {
    "sha": "cbec80c5f5c2a3110b2bc13cb685d189d13f621b",
    "filename": "src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHM_InversionTargetMFDs.java",
    "status": "modified",
    "additions": 143,
    "deletions": 88,
    "changes": 231,
    "blob_url": "https://github.com/GNS-Science/nshm-nz-opensha/blob/07df109021a63e45b9b272f86a7c1722e4285792/src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHM_InversionTargetMFDs.java",
    "raw_url": "https://github.com/GNS-Science/nshm-nz-opensha/raw/07df109021a63e45b9b272f86a7c1722e4285792/src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHM_InversionTargetMFDs.java",
    "contents_url": "https://api.github.com/repos/GNS-Science/nshm-nz-opensha/contents/src/main/java/nz/cri/gns/NSHM/opensha/inversion/NSHM_InversionTargetMFDs.java?ref=07df109021a63e45b9b272f86a7c1722e4285792",
    "patch": "@@ -3,6 +3,7 @@\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.opensha.commons.data.function.HistogramFunction;\n import org.opensha.commons.geo.GriddedRegion;\n import org.opensha.commons.geo.Location;\n import org.opensha.commons.geo.Region;\n@@ -23,14 +24,15 @@\n import nz.cri.gns.NSHM.opensha.ruptures.NSHMSlipEnabledRuptureSet;\n import scratch.UCERF3.SlipEnabledRupSet;\n import scratch.UCERF3.analysis.DeformationModelsCalc;\n-import scratch.UCERF3.analysis.FaultSystemRupSetCalc;\n+\n import scratch.UCERF3.enumTreeBranches.DeformationModels;\n import scratch.UCERF3.enumTreeBranches.InversionModels;\n import scratch.UCERF3.enumTreeBranches.MaxMagOffFault;\n import scratch.UCERF3.enumTreeBranches.MomentRateFixes;\n import scratch.UCERF3.enumTreeBranches.SpatialSeisPDF;\n import scratch.UCERF3.enumTreeBranches.TotalMag5Rate;\n import scratch.UCERF3.griddedSeismicity.GriddedSeisUtils;\n+import scratch.UCERF3.inversion.InversionFaultSystemRupSet;\n import scratch.UCERF3.inversion.InversionTargetMFDs;\n import scratch.UCERF3.logicTree.LogicTreeBranch;\n import scratch.UCERF3.utils.MFD_InversionConstraint;\n@@ -63,6 +65,8 @@\n \tNSHM_SpatialSeisPDF spatialSeisPDF;\n \tNSHM_SpatialSeisPDF spatialSeisPDFforOnFaultRates;\n \n+\tboolean MFD_STATS = true; //print some curves for analytics\n+\t\n //\t// discretization parameters for MFDs\n //\tpublic final static double MIN_MAG = 0.05;\n //\tpublic final static double MAX_MAG = 8.95;\n@@ -87,47 +91,44 @@\n \tprotected List<MFD_InversionConstraint> mfdConstraints = new ArrayList<>();\n //    private ArrayList<MFD_InversionConstraint> mfdConstraints;\n \n-\tpublic List<MFD_InversionConstraint> getMFDConstraints() {\n-\t\treturn mfdConstraints;\n-\t}\n-\n-\t/**\n-\t * Sets GutenbergRichterMFD arguments\n-\t * \n-\t * @param totalRateM5      the number of M>=5's per year. TODO: ref David\n-\t *                         Rhodes/Chris Roland? [KKS, CBC]\n-\t * @param bValue\n-\t * @param mfdTransitionMag magnitude to switch from MFD equality to MFD\n-\t *                         inequality TODO: how to validate this number for NZ?\n-\t *                         (ref Morgan Page in USGS/UCERF3) [KKS, CBC]\n-\t * @param mfdNum\n-\t * @param mfdMin\n-\t * @param mfdMax\n-\t * @return\n-\t */\n-\tpublic NSHM_InversionTargetMFDs setGutenbergRichterMFD(double totalRateM5, double bValue, double mfdTransitionMag,\n-\t\t\tint mfdNum, double mfdMin, double mfdMax) {\n-\t\tthis.totalRateM5 = totalRateM5;\n-\t\tthis.bValue = bValue;\n-\t\tthis.mfdTransitionMag = mfdTransitionMag;\n-\t\tthis.mfdNum = mfdNum;\n-\t\tthis.mfdMin = mfdMin;\n-\t\tthis.mfdMax = mfdMax;\n-\t\treturn this;\n-\t}\n-\n-\t/**\n-\t * @param mfdEqualityConstraintWt\n-\t * @param mfdInequalityConstraintWt\n-\t * @return\n-\t */\n-\tpublic NSHM_InversionTargetMFDs setGutenbergRichterMFDWeights(double mfdEqualityConstraintWt,\n-\t\t\tdouble mfdInequalityConstraintWt) {\n-\t\tthis.mfdEqualityConstraintWt = mfdEqualityConstraintWt;\n-\t\tthis.mfdInequalityConstraintWt = mfdInequalityConstraintWt;\n-\t\treturn this;\n-\t}\n-\n+    public List<MFD_InversionConstraint> getMFDConstraints() {\n+    \treturn mfdConstraints;\n+    }\n+    \n+    /**\n+     * Sets GutenbergRichterMFD arguments\n+     * @param totalRateM5 the number of  M>=5's per year. TODO: ref David Rhodes/Chris Roland? [KKS, CBC]\n+     * @param bValue\n+     * @param mfdTransitionMag magnitude to switch from MFD equality to MFD inequality TODO: how to validate this number for NZ? (ref Morgan Page in USGS/UCERF3) [KKS, CBC]\n+     * @param mfdNum\n+     * @param mfdMin\n+     * @param mfdMax\n+     * @return\n+     */\n+    public NSHM_InversionTargetMFDs setGutenbergRichterMFD(double totalRateM5, double bValue, \n+    \t\tdouble mfdTransitionMag, int mfdNum, double mfdMin, double mfdMax ) {\n+        this.totalRateM5 = totalRateM5; \n+        this.bValue = bValue;\n+        this.mfdTransitionMag = mfdTransitionMag;      \n+        this.mfdNum = mfdNum;\n+        this.mfdMin = mfdMin;\n+        this.mfdMax = mfdMax;\n+        return this;\n+    }    \n+\n+    /**\n+     * @param mfdEqualityConstraintWt\n+     * @param mfdInequalityConstraintWt\n+     * @return\n+     */\n+    public NSHM_InversionTargetMFDs setGutenbergRichterMFDWeights(double mfdEqualityConstraintWt, \n+    \t\tdouble mfdInequalityConstraintWt) {\n+    \tthis.mfdEqualityConstraintWt = mfdEqualityConstraintWt;\n+    \tthis.mfdInequalityConstraintWt = mfdInequalityConstraintWt;\n+    \treturn this;\n+    }       \n+    \n+\t@SuppressWarnings(\"unused\")\n \tpublic NSHM_InversionTargetMFDs(NSHM_InversionFaultSystemRuptSet invRupSet) {\n \t\tthis.invRupSet = invRupSet;\n \n@@ -139,13 +140,9 @@ public NSHM_InversionTargetMFDs(NSHM_InversionFaultSystemRuptSet invRupSet) {\n \t\t// logicTreeBranch.getValue(TotalMag5Rate.class).getRateMag5();\n \n \t\tthis.totalRegionRateMgt5 = this.totalRateM5;\n-\t\tthis.mMaxOffFault = logicTreeBranch.getValue(MaxMagOffFault.class).getMaxMagOffFault();\n-\t\tthis.applyImpliedCouplingCoeff = logicTreeBranch.getValue(MomentRateFixes.class).isApplyCC(); // true if\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// MomentRateFixes\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// =\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// APPLY_IMPLIED_CC\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// or\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// APPLY_CC_AND_RELAX_MFD\n+\t\tthis.mMaxOffFault = logicTreeBranch.getValue(MaxMagOffFault.class).getMaxMagOffFault(); //TODO: set this to 8.05 (more NZ ish)\n+\t\tthis.mMaxOffFault = 8.05d;\n+\t\tthis.applyImpliedCouplingCoeff = logicTreeBranch.getValue(MomentRateFixes.class).isApplyCC();\t// true if MomentRateFixes = APPLY_IMPLIED_CC or APPLY_CC_AND_RELAX_MFD\n //\t\tthis.spatialSeisPDF = logicTreeBranch.getValue(SpatialSeisPDF.class);\n \t\tthis.spatialSeisPDF = NSHM_SpatialSeisPDF.NZSHM22_1246;\n \n@@ -157,42 +154,84 @@ public NSHM_InversionTargetMFDs(NSHM_InversionFaultSystemRuptSet invRupSet) {\n \t\tList<? extends FaultSection> faultSectionData = invRupSet.getFaultSectionDataList();\n \n \t\tGriddedRegion regionNzGridded = new NewZealandRegions.NZ_TEST_GRIDDED();\n-\t\tGriddedRegion regionSansTVZGridded = new NewZealandRegions.NZ_RECTANGLE_SANS_TVZ_GRIDDED();\n-\t\tGriddedRegion regionTVZGridded = new NewZealandRegions.NZ_TVZ_GRIDDED();\n-\n-\t\tgridSeisUtils = new GriddedSeisUtils(faultSectionData, spatialSeisPDF.getPDF(), FAULT_BUFFER, regionNzGridded);\n-\t\tfractionSeisOnFault = gridSeisUtils.pdfInPolys();\n-\t\tdouble fractSeisInSansTVZ = this.spatialSeisPDF.getFractionInRegion(regionSansTVZGridded);\n-\n-\t\tonFaultRegionRateMgt5 = totalRegionRateMgt5 * fractionSeisOnFault;\n-\t\toffFaultRegionRateMgt5 = totalRegionRateMgt5 - onFaultRegionRateMgt5;\n-\t\torigOnFltDefModMoRate = DeformationModelsCalc.calculateTotalMomentRate(faultSectionData, true);\n-\t\toffFltDefModMoRate = DeformationModelsCalc.calcMoRateOffFaultsForDefModel(invRupSet.getFaultModel(),\n-\t\t\t\tinvRupSet.getDeformationModel());\n-\n+\t\t///GriddedRegion regionSansTVZGridded = new NewZealandRegions.NZ_RECTANGLE_SANS_TVZ_GRIDDED();\n+\t\t///GriddedRegion regionTVZGridded = new NewZealandRegions.NZ_TVZ_GRIDDED();\n+\t\t\n+\t\tgridSeisUtils = new GriddedSeisUtils(faultSectionData, \n+\t\t\t\tspatialSeisPDF.getPDF(), FAULT_BUFFER, regionNzGridded);\t\n+\t\tfractionSeisOnFault = gridSeisUtils.pdfInPolys(); //TODO: check this uses grid weights\n+\t\t/// double fractSeisInSansTVZ = this.spatialSeisPDF.getFractionInRegion(regionSansTVZGridded);\n+\t\t\n+\t\tonFaultRegionRateMgt5 = totalRegionRateMgt5*fractionSeisOnFault;\n+\t\toffFaultRegionRateMgt5 = totalRegionRateMgt5-onFaultRegionRateMgt5;\n+\t\torigOnFltDefModMoRate = DeformationModelsCalc.calculateTotalMomentRate(faultSectionData,true);\n+\t\toffFltDefModMoRate = DeformationModelsCalc.calcMoRateOffFaultsForDefModel(invRupSet.getFaultModel(), invRupSet.getDeformationModel());\n+\t\t\n \t\t// make the total target GR MFD\n+\t\t// TODO: why MIN_MAG = 0 ??\n \t\ttotalTargetGR = new GutenbergRichterMagFreqDist(MIN_MAG, NUM_MAG, DELTA_MAG);\n+\t\tif (MFD_STATS) {\n+\t\t\tSystem.out.println(\"totalTargetGR\");\n+\t\t\tSystem.out.println(totalTargetGR.toString());\n+\t\t\tSystem.out.println(\"\");\t\n+\t\t}\n \t\troundedMmaxOnFault = totalTargetGR.getX(totalTargetGR.getClosestXIndex(invRupSet.getMaxMag()));\n-\t\ttotalTargetGR.setAllButTotMoRate(MIN_MAG, roundedMmaxOnFault, totalRegionRateMgt5 * 1e5, 1.0);\n-\n-\t\tGutenbergRichterMagFreqDist totalTargetGR_SansTVZ = new GutenbergRichterMagFreqDist(MIN_MAG, NUM_MAG,\n-\t\t\t\tDELTA_MAG);\n-\t\ttotalTargetGR_SansTVZ.setAllButTotMoRate(MIN_MAG, roundedMmaxOnFault,\n-\t\t\t\ttotalRegionRateMgt5 * fractSeisInSansTVZ * 1e5, 1.0);\n-\n-\t\tGutenbergRichterMagFreqDist totalTargetGR_TVZ = new GutenbergRichterMagFreqDist(MIN_MAG, NUM_MAG, DELTA_MAG);\n-\t\ttotalTargetGR_TVZ.setAllButTotMoRate(MIN_MAG, roundedMmaxOnFault,\n-\t\t\t\ttotalRegionRateMgt5 * (1 - fractSeisInSansTVZ) * 1e5, 1.0);\n+\t\ttotalTargetGR.setAllButTotMoRate(MIN_MAG, roundedMmaxOnFault, totalRegionRateMgt5*1e5, 1.0); //TODO: revisit\n+\t\t\n+\t\tif (MFD_STATS) {\n+\t\t\tSystem.out.println(\"totalTargetGR after setAllButTotMoRate\");\n+\t\t\tSystem.out.println(totalTargetGR.toString());\n+\t\t\tSystem.out.println(\"\");\t\t\n+\t\t}\n \n+\t\t/*\n+\t\t * \n+\t\t *\n+\t\tGutenbergRichterMagFreqDist totalTargetGR_SansTVZ = new GutenbergRichterMagFreqDist(MIN_MAG, NUM_MAG, DELTA_MAG);\t\n+\t\ttotalTargetGR_SansTVZ.setAllButTotMoRate(MIN_MAG, \n+\t\t\t\troundedMmaxOnFault, totalRegionRateMgt5 * fractSeisInSansTVZ * 1e5, 1.0);\t\t\t\t\t\n+\t\tGutenbergRichterMagFreqDist totalTargetGR_TVZ = new GutenbergRichterMagFreqDist(MIN_MAG, NUM_MAG, DELTA_MAG);\t\n+\t\ttotalTargetGR_TVZ.setAllButTotMoRate(MIN_MAG, roundedMmaxOnFault, totalRegionRateMgt5 * (1-fractSeisInSansTVZ) * 1e5, 1.0);\n+\t\t*/\n+\t\t\n \t\t// get ave min seismo mag for region\n-\t\tdouble tempMag = FaultSystemRupSetCalc.getMeanMinMag(invRupSet, true);\n-\t\taveMinSeismoMag = totalTargetGR.getX(totalTargetGR.getClosestXIndex(tempMag)); // round to nearest MFD value\n-\n-\t\ttrulyOffFaultMFD = FaultSystemRupSetCalc.getTriLinearCharOffFaultTargetMFD(totalTargetGR, onFaultRegionRateMgt5,\n-\t\t\t\taveMinSeismoMag, mMaxOffFault);\n-\t\tsubSeismoOnFaultMFD_List = FaultSystemRupSetCalc.getCharSubSeismoOnFaultMFD_forEachSection(invRupSet,\n-\t\t\t\tgridSeisUtils, totalTargetGR);\n-\n+\t\t// TODO: this is weighted by moment, so exponentially biased to larger ruptures (WHY?)\n+\t\tdouble tempMag = NSHM_FaultSystemRupSetCalc.getMeanMinMag(invRupSet, true);\n+\t\t\n+\t\t//TODO: why derive this from the rupt set and not use mMaxOffFault??\n+\t\taveMinSeismoMag = totalTargetGR.getX(totalTargetGR.getClosestXIndex(tempMag));\t// round to nearest MFD value\n+\t\t\n+\t\t//TODO: why aveMinSeismoMag (Ned??)\n+\t\t// seems to calculate our corner magnitude for tapered GR\n+\t\ttrulyOffFaultMFD = NSHM_FaultSystemRupSetCalc.getTriLinearCharOffFaultTargetMFD(totalTargetGR, onFaultRegionRateMgt5, aveMinSeismoMag, mMaxOffFault);\n+\t\tsubSeismoOnFaultMFD_List = NSHM_FaultSystemRupSetCalc.getCharSubSeismoOnFaultMFD_forEachSection(invRupSet, gridSeisUtils, totalTargetGR);\n+\n+\t\t//What are the min magnitude per section\n+\t\tif (MFD_STATS) {\n+\t\t\tSystem.out.println(\"trulyOffFaultMFD (TriLinearCharOffFaultTargetMFD)\");\n+\t\t\tSystem.out.println(trulyOffFaultMFD.toString());\n+\t\t\tSystem.out.println(\"\");\t\t\n+\t\t}\n+\t\t\n+\t\t//MATT debug\n+\t\tif (MFD_STATS && false) {\t\t\n+\t\t\t//\tHistogramFunction hist = NSHM_FaultSystemRupSetCalc.getMagHistogram(invRupSet, MIN_MAG, NUM_MAG+10, DELTA_MAG);\n+\t\t\t//\n+\t\t\t// Build our own historgram\n+\t\t\t// using systemWideMinMag of 0.0 here, to get actual values\n+\t\t\tdouble [] sect_mins =  NSHM_FaultSystemRupSetCalc.computeMinSeismoMagForSections(invRupSet, 0.0d);\n+\t\t\tHistogramFunction hist = new HistogramFunction(0.0d, 90, 0.1d);\n+\t\t\tfor (int r=0;r<invRupSet.getNumRuptures(); r++) {\n+\t\t\t\thist.add(invRupSet.getMagForRup(r), 1.0);\n+\t\t\t}\n+\t\t\tSystem.out.println(\"getMagHistogram\");\n+\t\t\tSystem.out.println(hist.toString());\n+\t\t\tSystem.out.println(\"\");\t\t\n+\t\t}\n+\t\t\n+\t\t\n+\t\t// TODO: use computeMinSeismoMagForSections to find NZ values and explain 7.4\n+\t\t// histogram to look for min values > 7.X\n \t\ttotalSubSeismoOnFaultMFD = new SummedMagFreqDist(MIN_MAG, NUM_MAG, DELTA_MAG);\n \t\tfor (int m = 0; m < subSeismoOnFaultMFD_List.size(); m++) {\n \t\t\tGutenbergRichterMagFreqDist mfd = subSeismoOnFaultMFD_List.get(m);\n@@ -203,19 +242,34 @@ public NSHM_InversionTargetMFDs(NSHM_InversionFaultSystemRuptSet invRupSet) {\n \t\t\ttotalSubSeismoOnFaultMFD.addIncrementalMagFreqDist(mfd);\n \t\t}\n \n-\t\ttargetOnFaultSupraSeisMFD = new SummedMagFreqDist(MIN_MAG, NUM_MAG, DELTA_MAG);\n+\t\tif (MFD_STATS) {\n+\t\t\tSystem.out.println(\"totalSubSeismoOnFaultMFD (SummedMagFreqDist)\");\n+\t\t\tSystem.out.println(totalSubSeismoOnFaultMFD.toString());\n+\t\t\tSystem.out.println(\"\");\t\t\n+\t\t}\n+\t\t\n+\t\ttargetOnFaultSupraSeisMFD = new SummedMagFreqDist(MIN_MAG, NUM_MAG, DELTA_MAG);\t\t\n \t\ttargetOnFaultSupraSeisMFD.addIncrementalMagFreqDist(totalTargetGR);\n \t\ttargetOnFaultSupraSeisMFD.subtractIncrementalMagFreqDist(trulyOffFaultMFD);\n \t\ttargetOnFaultSupraSeisMFD.subtractIncrementalMagFreqDist(totalSubSeismoOnFaultMFD);\n \n+\t\tif (MFD_STATS) {\n+\t\t\tSystem.out.println(\"targetOnFaultSupraSeisMFD (SummedMagFreqDist)\");\n+\t\t\tSystem.out.println(targetOnFaultSupraSeisMFD.toString());\n+\t\t\tSystem.out.println(\"\");\t\t\n+\t\t}\t\t\n+\t\t\n+\t\t/*\n+\t\t * \n \t\t// split the above between Regions\n \t\tIncrementalMagFreqDist targetSupraSeisMFD_sansTVZ = new IncrementalMagFreqDist(MIN_MAG, NUM_MAG, DELTA_MAG);\n \t\tIncrementalMagFreqDist targetSupraSeisMFD_TVZ = new IncrementalMagFreqDist(MIN_MAG, NUM_MAG, DELTA_MAG);\n \t\tfor (int i = 0; i < NUM_MAG; i++) {\n \t\t\ttargetSupraSeisMFD_sansTVZ.set(i, targetOnFaultSupraSeisMFD.getY(i) * (fractSeisInSansTVZ));\n \t\t\ttargetSupraSeisMFD_TVZ.set(i, targetOnFaultSupraSeisMFD.getY(i) * (1 - fractSeisInSansTVZ));\n \t\t}\n-\n+        */\n+\t\t\n \t\t// compute coupling coefficients\n \t\timpliedOnFaultCouplingCoeff = (targetOnFaultSupraSeisMFD.getTotalMomentRate()\n \t\t\t\t+ totalSubSeismoOnFaultMFD.getTotalMomentRate()) / origOnFltDefModMoRate;\n@@ -224,19 +278,20 @@ public NSHM_InversionTargetMFDs(NSHM_InversionFaultSystemRuptSet invRupSet) {\n \n \t\t// set the names\n \t\ttotalTargetGR.setName(\"InversionTargetMFDs.totalTargetGR\");\n-\t\ttotalTargetGR_SansTVZ.setName(\"InversionTargetMFDs.totalTargetGR_SansTVZ\");\n-\t\ttotalTargetGR_TVZ.setName(\"InversionTargetMFDs.totalTargetGR_TVZ\");\n+\t\t///totalTargetGR_SansTVZ.setName(\"InversionTargetMFDs.totalTargetGR_SansTVZ\");\n+\t\t///totalTargetGR_TVZ.setName(\"InversionTargetMFDs.totalTargetGR_TVZ\");\n \t\ttargetOnFaultSupraSeisMFD.setName(\"InversionTargetMFDs.targetOnFaultSupraSeisMFD\");\n \t\ttrulyOffFaultMFD.setName(\"InversionTargetMFDs.trulyOffFaultMFD\");\n \t\ttotalSubSeismoOnFaultMFD.setName(\"InversionTargetMFDs.totalSubSeismoOnFaultMFD\");\n-\t\ttargetSupraSeisMFD_sansTVZ.setName(\"InversionTargetMFDs.targetSupraSeisMFD_sansTVZ\");\n-\t\ttargetSupraSeisMFD_TVZ.setName(\"InversionTargetMFDs.targetSupraSeisMFD_TVZ\");\n+\t\t///targetSupraSeisMFD_sansTVZ.setName(\"InversionTargetMFDs.targetSupraSeisMFD_sansTVZ\");\n+\t\t///targetSupraSeisMFD_TVZ.setName(\"InversionTargetMFDs.targetSupraSeisMFD_TVZ\");\n \n \t\t// Build the MFD Constraints for regions\n \t\tmfdConstraints = new ArrayList<MFD_InversionConstraint>();\n-\t\tmfdConstraints.add(new MFD_InversionConstraint(targetSupraSeisMFD_sansTVZ, regionSansTVZGridded));\n-\t\tmfdConstraints.add(new MFD_InversionConstraint(targetSupraSeisMFD_TVZ, regionTVZGridded));\n \n+\t\t///mfdConstraints.add(new MFD_InversionConstraint(targetSupraSeisMFD_sansTVZ, regionSansTVZGridded));\n+\t\t///mfdConstraints.add(new MFD_InversionConstraint(targetSupraSeisMFD_TVZ, regionTVZGridded));\n+\t\tmfdConstraints.add(new MFD_InversionConstraint(targetOnFaultSupraSeisMFD, regionNzGridded));\t\n \t}\n \n //\tprivate void buildConstraints() {"
  },
  {
    "sha": "72782c9dd71fda73c537445477137018f64f20d8",
    "filename": "src/main/java/nz/cri/gns/NSHM/opensha/ruptures/NSHMSlipEnabledRuptureSet.java",
    "status": "modified",
    "additions": 4,
    "deletions": 4,
    "changes": 8,
    "blob_url": "https://github.com/GNS-Science/nshm-nz-opensha/blob/07df109021a63e45b9b272f86a7c1722e4285792/src/main/java/nz/cri/gns/NSHM/opensha/ruptures/NSHMSlipEnabledRuptureSet.java",
    "raw_url": "https://github.com/GNS-Science/nshm-nz-opensha/raw/07df109021a63e45b9b272f86a7c1722e4285792/src/main/java/nz/cri/gns/NSHM/opensha/ruptures/NSHMSlipEnabledRuptureSet.java",
    "contents_url": "https://api.github.com/repos/GNS-Science/nshm-nz-opensha/contents/src/main/java/nz/cri/gns/NSHM/opensha/ruptures/NSHMSlipEnabledRuptureSet.java?ref=07df109021a63e45b9b272f86a7c1722e4285792",
    "patch": "@@ -53,7 +53,7 @@ public NSHMSlipEnabledRuptureSet(List<ClusterRupture> ruptures, List<FaultSectio\n \t\t/*\n \t\t * build a map of downdip ruptures with length\n \t\t */\n-\t\tMap<Integer, Double> ruptureLengths = new HashMap<>();\n+\t\tMap<ClusterRupture, Double> ruptureLengths = new HashMap<>();\n \t\tInteger currentMin; // , currentMax;\n \n \t\tfor (int r = 0; r < ruptures.size(); r++) {\n@@ -83,7 +83,7 @@ public NSHMSlipEnabledRuptureSet(List<ClusterRupture> ruptures, List<FaultSectio\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (length > 0)\n-\t\t\t\truptureLengths.put(rup.hashCode(), length);\n+\t\t\t\truptureLengths.put(rup, length);\n \t\t}\n \n \t\tfor (int r = 0; r < ruptures.size(); r++) {\n@@ -109,8 +109,8 @@ public NSHMSlipEnabledRuptureSet(List<ClusterRupture> ruptures, List<FaultSectio\n \t\t\t}\n \n \t\t\t// extend length for downdip ruptures\n-\t\t\tif (ruptureLengths.get(rup.hashCode()) != null)\n-\t\t\t\ttotLength += ruptureLengths.get(rup.hashCode());\n+\t\t\tif (ruptureLengths.get(rup) != null)\n+\t\t\t\ttotLength += ruptureLengths.get(rup);\n \n \t\t\trupAreas[r] = totArea;\n \t\t\trupLengths[r] = totLength;"
  },
  {
    "sha": "3e9e5f4a1de82e03d49896b49365f13cc1a16659",
    "filename": "src/python/automation/run_inversion_hazard.py",
    "status": "modified",
    "additions": 20,
    "deletions": 19,
    "changes": 39,
    "blob_url": "https://github.com/GNS-Science/nshm-nz-opensha/blob/07df109021a63e45b9b272f86a7c1722e4285792/src/python/automation/run_inversion_hazard.py",
    "raw_url": "https://github.com/GNS-Science/nshm-nz-opensha/raw/07df109021a63e45b9b272f86a7c1722e4285792/src/python/automation/run_inversion_hazard.py",
    "contents_url": "https://api.github.com/repos/GNS-Science/nshm-nz-opensha/contents/src/python/automation/run_inversion_hazard.py?ref=07df109021a63e45b9b272f86a7c1722e4285792",
    "patch": "@@ -36,9 +36,9 @@\n     inputfile = \"/home/chrisbc/DEV/GNS/opensha/tmp/2021-03-02T08-04-59.066119/ruptset_ddw0.5_jump5.0_SANS_TVZ2_580.0_2_UCERF3_thin0.zip\"\n \n     t0 = dt.datetime.utcnow()\n-    INVERSION_MINS =100\n+    INVERSION_MINS =10*60+1\n     SOLUTION_FILE = \"/home/chrisbc/DEV/GNS/opensha/tmp/reports/TestSolution_%sm_CRUSTAL_SANS_TVZ2_BGSEIS.zip\" % INVERSION_MINS\n-\n+    \"\"\"\n     mfd = SimpleNamespace(**dict(\n         total_rate_m5 = 8.8,\n         b_value = 1.0,\n@@ -57,9 +57,9 @@\n     inversion_runner\\\n         .setInversionMinutes(INVERSION_MINS)\\\n         .setEnergyChangeCompletionCriteria(float(0), float(0.001), float(1))\\\n+        .setNumThreads(12)\\\n         .setSyncInterval(30)\\\n         .setRuptureSetFile(inputfile)\\\n-        .setNumThreads(12)\\\n         .configure()\\\n         .runInversion()\n \n@@ -84,23 +84,24 @@\n \n     info = inversion_runner.parentFaultMomentRates()\n     print(info)\n+    \"\"\"\n \n-    # print(\"Setting up hazard\")\n-    # print(\"=================\")\n-    # calc = hazard_calc\\\n-    #     .setForecastTimespan(50.0)\\\n-    #     .setSolutionFile(SOLUTION_FILE)\\\n-    #     .setMaxDistance(250.0)\\\n-    #     .build()\n+    print(\"Setting up hazard\")\n+    print(\"=================\")\n+    calc = hazard_calc\\\n+        .setForecastTimespan(50.0)\\\n+        .setSolutionFile(SOLUTION_FILE)\\\n+        .setMaxDistance(250.0)\\\n+        .build()\n \n     # t2 = dt.datetime.utcnow()\n     # print(\"took %s secs\" % (t2-t1).total_seconds())\n \n-    # print(\"Hazard in Site...\")\n-    # print(\"==========================\")\n-    # masterton = dict(lat=-40.95972, lon=175.6575)\n-    # wellington = dict(lat=-41.289, lon=174.777)\n-    # result = calc.calc(wellington['lat'], wellington['lon'])\n+    print(\"Hazard in Site...\")\n+    print(\"==========================\")\n+    masterton = dict(lat=-40.95972, lon=175.6575)\n+    wellington = dict(lat=-41.289, lon=174.777)\n+    result = calc.calc(wellington['lat'], wellington['lon'])\n \n     # # print(dir(result))\n     # \"\"\"\n@@ -118,10 +119,10 @@\n     # 'toString', 'toXMLMetadata', 'wait', 'writeSimpleFuncFile', 'xValues', 'yValues']\n     # \"\"\"\n \n-    # fout = open(\"wgtn_50yr_250km_PGA_inversion_for_%sm_COMBINED_330K.\" % INVERSION_MINS, 'w')\n-    # fout.write(result.getInfo())\n-    # fout.write('\\n\\n')\n-    # fout.write(result.toString())\n+    fout = open(\"wgtn_50yr_250km_PGA_inversion_for_%sm_\" % INVERSION_MINS, 'w')\n+    fout.write(result.getInfo())\n+    fout.write('\\n\\n')\n+    fout.write(result.toString())\n \n     # t3 = dt.datetime.utcnow()\n     # print(\"took %s secs\" % (t3-t2).total_seconds())"
  },
  {
    "sha": "8313017a94e52cd9cdef20df54f3fcdd53d8ff3e",
    "filename": "test/java/nz/cri/gns/NSHM/opensha/ruptures/FaultIdFilterTest.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/GNS-Science/nshm-nz-opensha/blob/07df109021a63e45b9b272f86a7c1722e4285792/test/java/nz/cri/gns/NSHM/opensha/ruptures/FaultIdFilterTest.java",
    "raw_url": "https://github.com/GNS-Science/nshm-nz-opensha/raw/07df109021a63e45b9b272f86a7c1722e4285792/test/java/nz/cri/gns/NSHM/opensha/ruptures/FaultIdFilterTest.java",
    "contents_url": "https://api.github.com/repos/GNS-Science/nshm-nz-opensha/contents/test/java/nz/cri/gns/NSHM/opensha/ruptures/FaultIdFilterTest.java?ref=07df109021a63e45b9b272f86a7c1722e4285792",
    "patch": "@@ -113,9 +113,9 @@ public ClusterRupture mockClusterRupture(int... parentIds) throws NoSuchMethodEx\n         UniqueRupture u2 = mock(UniqueRupture.class);\n         when(u2.size()).thenReturn(parentIds.length - 1);\n \n-\n-         Constructor<ClusterRupture> con = ClusterRupture.class.getDeclaredConstructor(\n+        Constructor<ClusterRupture> con = ClusterRupture.class.getDeclaredConstructor(\n                 FaultSubsectionCluster[].class, ImmutableSet.class, ImmutableMap.class, UniqueRupture.class, UniqueRupture.class, Boolean.TYPE);\n+\n         con.setAccessible(true);\n         return con.newInstance(clusters, ImmutableSet.copyOf(jumps), ImmutableMap.of(), u1, u2, true);\n     }"
  }
]
