[
  {
    "sha": "1116a31355e7f47ebfd19e7ce0be12ff1e6e588a",
    "filename": "src/by/it/group873601/karpeychik/lesson03/A_Huffman.java",
    "status": "added",
    "additions": 160,
    "deletions": 0,
    "changes": 160,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson03/A_Huffman.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson03/A_Huffman.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson03/A_Huffman.java?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,160 @@\n+package by.it.group873601.karpeychik.lesson03;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.util.*;\n+\n+//Lesson 3. A_Huffman.\n+//Разработайте метод encode(File file) для кодирования строки (код Хаффмана)\n+\n+// По данным файла (непустой строке ss длины не более 104104),\n+// состоящей из строчных букв латинского алфавита,\n+// постройте оптимальный по суммарной длине беспрефиксный код.\n+\n+// Используйте Алгоритм Хаффмана — жадный алгоритм оптимального\n+// безпрефиксного кодирования алфавита с минимальной избыточностью.\n+\n+// В первой строке выведите количество различных букв kk,\n+// встречающихся в строке, и размер получившейся закодированной строки.\n+// В следующих kk строках запишите коды букв в формате \"letter: code\".\n+// В последней строке выведите закодированную строку. Примеры ниже\n+\n+//        Sample Input 1:\n+//        a\n+//\n+//        Sample Output 1:\n+//        1 1\n+//        a: 0\n+//        0\n+\n+//        Sample Input 2:\n+//        abacabad\n+//\n+//        Sample Output 2:\n+//        4 14\n+//        a: 0\n+//        b: 10\n+//        c: 110\n+//        d: 111\n+//        01001100100111\n+\n+public class A_Huffman {\n+\n+    //Изучите классы Node InternalNode LeafNode\n+    abstract class Node implements Comparable<Node> {\n+        //абстрактный класс элемент дерева\n+        //(сделан abstract, чтобы нельзя было использовать его напрямую)\n+        //а только через его версии InternalNode и LeafNode\n+        private final int frequence; //частота символов\n+\n+        //генерация кодов (вызывается на корневом узле\n+        //один раз в конце, т.е. после построения дерева)\n+        abstract void fillCodes(String code);\n+\n+        //конструктор по умолчанию\n+        private Node(int frequence) {\n+            this.frequence = frequence;\n+        }\n+\n+        //метод нужен для корректной работы узла в приоритетной очереди\n+        //или для сортировок\n+        @Override\n+        public int compareTo(Node o) {\n+            return Integer.compare(frequence, o.frequence);\n+        }\n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////////////////\n+    //расширение базового класса до внутреннего узла дерева\n+    private class InternalNode extends Node {\n+        //внутренный узел дерева\n+        Node left;  //левый ребенок бинарного дерева\n+        Node right; //правый ребенок бинарного дерева\n+\n+        //для этого дерева не существует внутренних узлов без обоих детей\n+        //поэтому вот такого конструктора будет достаточно\n+        InternalNode(Node left, Node right) {\n+            super(left.frequence + right.frequence);\n+            this.left = left;\n+            this.right = right;\n+        }\n+\n+        @Override\n+        void fillCodes(String code) {\n+            left.fillCodes(code + \"0\");\n+            right.fillCodes(code + \"1\");\n+        }\n+\n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////////////////\n+    //расширение базового класса до листа дерева\n+    private class LeafNode extends Node {\n+        //лист\n+        char symbol; //символы хранятся только в листах\n+\n+        LeafNode(int frequence, char symbol) {\n+            super(frequence);\n+            this.symbol = symbol;\n+        }\n+\n+        @Override\n+        void fillCodes(String code) {\n+            //добрались до листа, значит рекурсия закончена, код уже готов\n+            //и можно запомнить его в индексе для поиска кода по символу.\n+            codes.put(this.symbol, code);\n+        }\n+    }\n+\n+    //индекс данных из листьев\n+    static private Map<Character, String> codes = new TreeMap<>();\n+\n+\n+    //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+    String encode(File file) throws FileNotFoundException {\n+        //прочитаем строку для кодирования из тестового файла\n+        Scanner scanner = new Scanner(file);\n+        String s = scanner.next();\n+\n+        //все комментарии от тестового решения были оставлены т.к. это задание A.\n+        //если они вам мешают их можно удалить\n+\n+        Map<Character, Integer> count = new HashMap<>();\n+        //1. переберем все символы по очереди и рассчитаем их частоту в Map count\n+            //для каждого символа добавим 1 если его в карте еще нет или инкремент если есть.\n+\n+        //2. перенесем все символы в приоритетную очередь в виде листьев\n+        PriorityQueue<Node> priorityQueue = new PriorityQueue<>();\n+\n+        //3. вынимая по два узла из очереди (для сборки родителя)\n+        //и возвращая этого родителя обратно в очередь\n+        //построим дерево кодирования Хаффмана.\n+        //У родителя частоты детей складываются.\n+\n+        //4. последний из родителей будет корнем этого дерева\n+        //это будет последний и единственный элемент оставшийся в очереди priorityQueue.\n+        StringBuilder sb = new StringBuilder();\n+        //.....\n+\n+        return sb.toString();\n+        //01001100100111\n+        //01001100100111\n+    }\n+    //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        File f = new File(root + \"by/it/a_khmelev/lesson03/dataHuffman.txt\");\n+        A_Huffman instance = new A_Huffman();\n+        long startTime = System.currentTimeMillis();\n+        String result = instance.encode(f);\n+        long finishTime = System.currentTimeMillis();\n+        System.out.printf(\"%d %d\\n\", codes.size(), result.length());\n+        for (Map.Entry<Character, String> entry : codes.entrySet()) {\n+            System.out.printf(\"%s: %s\\n\", entry.getKey(), entry.getValue());\n+        }\n+        System.out.println(result);\n+    }\n+\n+}"
  },
  {
    "sha": "7eb51da654deb2d3234548f6e0d7e3c8581fa479",
    "filename": "src/by/it/group873601/karpeychik/lesson03/B_Huffman.java",
    "status": "added",
    "additions": 70,
    "deletions": 0,
    "changes": 70,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson03/B_Huffman.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson03/B_Huffman.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson03/B_Huffman.java?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,70 @@\n+package by.it.group873601.karpeychik.lesson03;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.util.Scanner;\n+\n+// Lesson 3. B_Huffman.\n+// Восстановите строку по её коду и беспрефиксному коду символов.\n+\n+// В первой строке входного файла заданы два целых числа\n+// kk и ll через пробел — количество различных букв, встречающихся в строке,\n+// и размер получившейся закодированной строки, соответственно.\n+//\n+// В следующих kk строках записаны коды букв в формате \"letter: code\".\n+// Ни один код не является префиксом другого.\n+// Буквы могут быть перечислены в любом порядке.\n+// В качестве букв могут встречаться лишь строчные буквы латинского алфавита;\n+// каждая из этих букв встречается в строке хотя бы один раз.\n+// Наконец, в последней строке записана закодированная строка.\n+// Исходная строка и коды всех букв непусты.\n+// Заданный код таков, что закодированная строка имеет минимальный возможный размер.\n+//\n+//        Sample Input 1:\n+//        1 1\n+//        a: 0\n+//        0\n+\n+//        Sample Output 1:\n+//        a\n+\n+\n+//        Sample Input 2:\n+//        4 14\n+//        a: 0\n+//        b: 10\n+//        c: 110\n+//        d: 111\n+//        01001100100111\n+\n+//        Sample Output 2:\n+//        abacabad\n+\n+public class B_Huffman {\n+\n+    String decode(File file) throws FileNotFoundException {\n+        StringBuilder result=new StringBuilder();\n+        //прочитаем строку для кодирования из тестового файла\n+        Scanner scanner = new Scanner(file);\n+        Integer count = scanner.nextInt();\n+        Integer length = scanner.nextInt();\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! НАЧАЛО ЗАДАЧИ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1\n+        //тут запишите ваше решение\n+\n+\n+\n+\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! КОНЕЦ ЗАДАЧИ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1\n+        return result.toString(); //01001100100111\n+    }\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        File f = new File(root + \"by/it/a_khmelev/lesson03/encodeHuffman.txt\");\n+        B_Huffman instance = new B_Huffman();\n+        String result = instance.decode(f);\n+        System.out.println(result);\n+    }\n+\n+\n+}"
  },
  {
    "sha": "37c6ea5150a20664c7b85f6200106a01db19cf7f",
    "filename": "src/by/it/group873601/karpeychik/lesson03/C_HeapMax.java",
    "status": "added",
    "additions": 104,
    "deletions": 0,
    "changes": 104,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson03/C_HeapMax.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson03/C_HeapMax.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson03/C_HeapMax.java?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,104 @@\n+package by.it.group873601.karpeychik.lesson03;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Scanner;\n+\n+// Lesson 3. C_Heap.\n+// Задача: построить max-кучу = пирамиду = бинарное сбалансированное дерево на массиве.\n+// ВАЖНО! НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ НИКАКИЕ КОЛЛЕКЦИИ, КРОМЕ ARRAYLIST (его можно, но только для массива)\n+\n+//      Проверка проводится по данным файла\n+//      Первая строка входа содержит число операций 1 ≤ n ≤ 100000.\n+//      Каждая из последующих nn строк задают операцию одного из следующих двух типов:\n+\n+//      Insert x, где 0 ≤ x ≤ 1000000000 — целое число;\n+//      ExtractMax.\n+\n+//      Первая операция добавляет число x в очередь с приоритетами,\n+//      вторая — извлекает максимальное число и выводит его.\n+\n+//      Sample Input:\n+//      6\n+//      Insert 200\n+//      Insert 10\n+//      ExtractMax\n+//      Insert 5\n+//      Insert 500\n+//      ExtractMax\n+//\n+//      Sample Output:\n+//      200\n+//      500\n+\n+\n+public class C_HeapMax {\n+\n+    private class MaxHeap {\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! НАЧАЛО ЗАДАЧИ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1\n+        //тут запишите ваше решение.\n+        //Будет мало? Ну тогда можете его собрать как Generic и/или использовать в варианте B\n+        private List<Long> heap = new ArrayList<>();\n+\n+        int siftDown(int i) { //просеивание вверх\n+\n+            return i;\n+        }\n+\n+        int siftUp(int i) { //просеивание вниз\n+\n+            return i;\n+        }\n+\n+        void insert(Long value) { //вставка\n+        }\n+\n+        Long extractMax() { //извлечение и удаление максимума\n+            Long result = null;\n+\n+            return result;\n+        }\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! КОНЕЦ ЗАДАЧИ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1\n+    }\n+\n+    //эта процедура читает данные из файла, ее можно не менять.\n+    Long findMaxValue(InputStream stream) {\n+        Long maxValue=0L;\n+        MaxHeap heap = new MaxHeap();\n+        //прочитаем строку для кодирования из тестового файла\n+        Scanner scanner = new Scanner(stream);\n+        Integer count = scanner.nextInt();\n+        for (int i = 0; i < count; ) {\n+            String s = scanner.nextLine();\n+            if (s.equalsIgnoreCase(\"extractMax\")) {\n+                Long res=heap.extractMax();\n+                if (res!=null && res>maxValue) maxValue=res;\n+                System.out.println();\n+                i++;\n+            }\n+            if (s.contains(\" \")) {\n+                String[] p = s.split(\" \");\n+                if (p[0].equalsIgnoreCase(\"insert\"))\n+                    heap.insert(Long.parseLong(p[1]));\n+                i++;\n+            //System.out.println(heap); //debug\n+            }\n+        }\n+        return maxValue;\n+    }\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson03/heapData.txt\");\n+        C_HeapMax instance = new C_HeapMax();\n+        System.out.println(\"MAX=\"+instance.findMaxValue(stream));\n+    }\n+\n+    // РЕМАРКА. Это задание исключительно учебное.\n+    // Свои собственные кучи нужны довольно редко.\n+    // \"В реальном бою\" все существенно иначе. Изучите и используйте коллекции\n+    // TreeSet, TreeMap, PriorityQueue и т.д. с нужным CompareTo() для объекта внутри.\n+}"
  },
  {
    "sha": "9156f6986d77dcf5fed73972282d4a3d33676ece",
    "filename": "src/by/it/group873601/karpeychik/lesson03/Lesson3Test.java",
    "status": "added",
    "additions": 51,
    "deletions": 0,
    "changes": 51,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson03/Lesson3Test.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson03/Lesson3Test.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson03/Lesson3Test.java?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,51 @@\n+package by.it.group873601.karpeychik.lesson03;\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+public class Lesson3Test {\n+    /*\n+    для прохождения тестов создайте JUnit-конфигурацию на свой пакет:\n+    Поля:\n+    Name:               Test a_khmelev (тут ваша фамилия)\n+    Test kind:          All in package\n+    Package:            by.it.a_khmelev (тут ваша фамилия)\n+    Search for test:    In whole project\n+    */\n+\n+\n+    @Test\n+    public void A() throws Exception {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        File f = new File(root + \"by/it/a_khmelev/lesson03/dataHuffman.txt\");\n+        A_Huffman instance = new A_Huffman();\n+        String result = instance.encode(f);\n+        boolean ok=result.equals(\"01001100100111\");\n+        assertTrue(\"A failed\", ok);\n+    }\n+\n+    @Test\n+    public void B() throws Exception {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        File f = new File(root + \"by/it/a_khmelev/lesson03/encodeHuffman.txt\");\n+        B_Huffman instance = new B_Huffman();\n+        String result = instance.decode(f);\n+        boolean ok=result.equals(\"abacabad\");\n+        assertTrue(\"B failed\", ok);\n+    }\n+    @Test\n+    public void C() throws Exception {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson03/heapData.txt\");\n+        C_HeapMax instance = new C_HeapMax();\n+        Long res=instance.findMaxValue(stream);\n+        boolean ok=(res==500);\n+        assertTrue(\"C failed\", ok);\n+    }\n+\n+}"
  },
  {
    "sha": "e62bf5bf4f805b156d94506a32439fa6b4bd7e9b",
    "filename": "src/by/it/group873601/karpeychik/lesson03/dataHuffman.txt",
    "status": "added",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson03/dataHuffman.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson03/dataHuffman.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson03/dataHuffman.txt?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1 @@\n+abacabad\n\\ No newline at end of file"
  },
  {
    "sha": "ac8d8e8e9a631bf7c42365d25276edd28f87640a",
    "filename": "src/by/it/group873601/karpeychik/lesson03/encodeHuffman.txt",
    "status": "added",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson03/encodeHuffman.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson03/encodeHuffman.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson03/encodeHuffman.txt?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,6 @@\n+4 14\n+a: 0\n+b: 10\n+c: 110\n+d: 111\n+01001100100111\n\\ No newline at end of file"
  },
  {
    "sha": "3189ed64e8e6b5c9c8b65dc0d73cf4c3256fd256",
    "filename": "src/by/it/group873601/karpeychik/lesson03/heapData.txt",
    "status": "added",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson03/heapData.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson03/heapData.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson03/heapData.txt?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,7 @@\n+6\n+Insert 200\n+Insert 10\n+ExtractMax\n+Insert 5\n+Insert 500\n+ExtractMax"
  },
  {
    "sha": "ad460ead0cf8488fab74e0580676b4daa56c7af2",
    "filename": "src/by/it/group873601/karpeychik/lesson04/A_BinaryFind.java",
    "status": "added",
    "additions": 72,
    "deletions": 0,
    "changes": 72,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson04/A_BinaryFind.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson04/A_BinaryFind.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson04/A_BinaryFind.java?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,72 @@\n+package by.it.group873601.karpeychik.lesson04;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Scanner;\n+\n+/*\n+В первой строке источника данных даны:\n+        - целое число 1<=n<=100000 (размер массива)\n+        - сам массив A[1...n] из n различных натуральных чисел,\n+          не превышающих 10E9, в порядке возрастания,\n+Во второй строке\n+        - целое число 1<=k<=10000 (сколько чисел нужно найти)\n+        - k натуральных чисел b1,...,bk не превышающих 10E9 (сами числа)\n+Для каждого i от 1 до kk необходимо вывести индекс 1<=j<=n,\n+для которого A[j]=bi, или -1, если такого j нет.\n+\n+        Sample Input:\n+        5 1 5 8 12 13\n+        5 8 1 23 1 11\n+\n+        Sample Output:\n+        3 1 -1 1 -1\n+\n+(!) Обратите внимание на смещение начала индекса массивов JAVA относительно условий задачи\n+*/\n+\n+public class A_BinaryFind {\n+    int[] findIndex(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+\n+        //размер отсортированного массива\n+        int n = scanner.nextInt();\n+        //сам отсортированный массива\n+        int[] a=new int[n];\n+        for (int i = 1; i <= n; i++) {\n+            a[i-1] = scanner.nextInt();\n+        }\n+\n+        //размер массива индексов\n+        int k = scanner.nextInt();\n+        int[] result=new int[k];\n+        for (int i = 0; i < k; i++) {\n+            int value = scanner.nextInt();\n+            //тут реализуйте бинарный поиск индекса\n+\n+\n+\n+\n+            result[i]=0;\n+        }\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return result;\n+    }\n+\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson04/dataA.txt\");\n+        A_BinaryFind instance = new A_BinaryFind();\n+        //long startTime = System.currentTimeMillis();\n+        int[] result=instance.findIndex(stream);\n+        //long finishTime = System.currentTimeMillis();\n+        for (int index:result){\n+            System.out.print(index+\" \");\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "41db7c53d5ec662966eea865024cf5e8cda43638",
    "filename": "src/by/it/group873601/karpeychik/lesson04/B_MergeSort.java",
    "status": "added",
    "additions": 96,
    "deletions": 0,
    "changes": 96,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson04/B_MergeSort.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson04/B_MergeSort.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson04/B_MergeSort.java?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,96 @@\n+package by.it.group873601.karpeychik.lesson04;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Scanner;\n+\n+/*\n+Реализуйте сортировку слиянием для одномерного массива.\n+Сложность алгоритма должна быть не хуже, чем O(n log n)\n+\n+Первая строка содержит число 1<=n<=10000,\n+вторая - массив A[1…n], содержащий натуральные числа, не превосходящие 10E9.\n+Необходимо отсортировать полученный массив.\n+\n+Sample Input:\n+5\n+2 3 9 2 9\n+Sample Output:\n+2 2 3 9 9\n+*/\n+public class B_MergeSort {\n+\n+    int[] merge(int[] ar_1, int[] ar_2){\n+        int max = ar_1.length + ar_2.length;\n+        int[] result = new int[max];\n+        int m = 0, n = 0;\n+        for (int i = 0; i < max; i++){\n+            if (m >= ar_1.length & n < ar_2.length){\n+                result[i] = ar_2[n];\n+                n++;\n+            }else if(n >= ar_2.length & m < ar_1.length){\n+                result[i] = ar_1[m];\n+                m++;\n+            }else if (ar_1[m] <= ar_2[n] & m < ar_1.length){\n+                result[i] = ar_1[m];\n+                m++;\n+            }else {\n+                result[i] = ar_2[n];\n+                n++;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    int[] mergeSort(int[] arr, int l, int r){\n+        int[] result = new int[1];\n+        int index = (int)(l + r) / 2;\n+        if (l < r){\n+           return merge(mergeSort(arr, l, index), mergeSort(arr, index + 1, r));\n+        }else {\n+            result[0] = arr[l];\n+            return result;\n+        }\n+    }\n+\n+    int[] getMergeSort(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+\n+        //размер массива\n+        int n = scanner.nextInt();\n+        //сам массива\n+        int[] a=new int[n];\n+        for (int i = 0; i < n; i++) {\n+            a[i] = scanner.nextInt();\n+            System.out.println(a[i]);\n+\n+        }\n+\n+        // тут ваше решение (реализуйте сортировку слиянием)\n+        // https://ru.wikipedia.org/wiki/Сортировка_слиянием\n+\n+        a = mergeSort(a, 0, a.length - 1);\n+\n+\n+\n+\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return a;\n+    }\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson04/dataB.txt\");\n+        B_MergeSort instance = new B_MergeSort();\n+        //long startTime = System.currentTimeMillis();\n+        int[] result=instance.getMergeSort(stream);\n+        //long finishTime = System.currentTimeMillis();\n+        for (int index:result){\n+            System.out.print(index+\" \");\n+        }\n+    }\n+\n+\n+}"
  },
  {
    "sha": "57f95e0d5244df7c7d624303d4bdd1c42b264dc4",
    "filename": "src/by/it/group873601/karpeychik/lesson04/C_GetInversions.java",
    "status": "added",
    "additions": 74,
    "deletions": 0,
    "changes": 74,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson04/C_GetInversions.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson04/C_GetInversions.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson04/C_GetInversions.java?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,74 @@\n+package by.it.group873601.karpeychik.lesson04;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Scanner;\n+\n+/*\n+Рассчитать число инверсий одномерного массива.\n+Сложность алгоритма должна быть не хуже, чем O(n log n)\n+\n+Первая строка содержит число 1<=n<=10000,\n+вторая - массив A[1…n], содержащий натуральные числа, не превосходящие 10E9.\n+Необходимо посчитать число пар индексов 1<=i<j<n, для которых A[i]>A[j].\n+\n+    (Такая пара элементов называется инверсией массива.\n+    Количество инверсий в массиве является в некотором смысле\n+    его мерой неупорядоченности: например, в упорядоченном по неубыванию\n+    массиве инверсий нет вообще, а в массиве, упорядоченном по убыванию,\n+    инверсию образуют каждые (т.е. любые) два элемента.\n+    )\n+\n+Sample Input:\n+5\n+2 3 9 2 9\n+Sample Output:\n+2\n+\n+Головоломка (т.е. не обязательно).\n+Попробуйте обеспечить скорость лучше, чем O(n log n) за счет многопоточности.\n+Докажите рост производительности замерами времени.\n+Большой тестовый массив можно прочитать свой или сгенерировать его программно.\n+*/\n+\n+\n+public class C_GetInversions {\n+\n+    int calc(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!\n+        //размер массива\n+        int n = scanner.nextInt();\n+        //сам массив\n+        int[] a = new int[n];\n+        for (int i = 0; i < n; i++) {\n+            a[i] = scanner.nextInt();\n+        }\n+        int result = 0;\n+        //!!!!!!!!!!!!!!!!!!!!!!!!     тут ваше решение   !!!!!!!!!!!!!!!!!!!!!!!!\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return result;\n+    }\n+\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson04/dataC.txt\");\n+        C_GetInversions instance = new C_GetInversions();\n+        //long startTime = System.currentTimeMillis();\n+        int result = instance.calc(stream);\n+        //long finishTime = System.currentTimeMillis();\n+        System.out.print(result);\n+    }\n+}"
  },
  {
    "sha": "54fdc796c7f6b287f9ba0094e865c9a6ae8a50f6",
    "filename": "src/by/it/group873601/karpeychik/lesson04/dataA.txt",
    "status": "added",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson04/dataA.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson04/dataA.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson04/dataA.txt?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,2 @@\n+5 1 5 8 12 13\n+5 8 1 23 1 11\n\\ No newline at end of file"
  },
  {
    "sha": "d55c9cc43bafba5b7ceff7092ad66f3035e2604d",
    "filename": "src/by/it/group873601/karpeychik/lesson04/dataB.txt",
    "status": "added",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson04/dataB.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson04/dataB.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson04/dataB.txt?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,2 @@\n+5\n+2 3 9 2 9\n\\ No newline at end of file"
  },
  {
    "sha": "d55c9cc43bafba5b7ceff7092ad66f3035e2604d",
    "filename": "src/by/it/group873601/karpeychik/lesson04/dataC.txt",
    "status": "added",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson04/dataC.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson04/dataC.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson04/dataC.txt?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,2 @@\n+5\n+2 3 9 2 9\n\\ No newline at end of file"
  },
  {
    "sha": "8e2639a9919578814f926300616d5c420087b296",
    "filename": "src/by/it/group873601/karpeychik/lesson05/A_QSort.java",
    "status": "added",
    "additions": 102,
    "deletions": 0,
    "changes": 102,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson05/A_QSort.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson05/A_QSort.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson05/A_QSort.java?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,102 @@\n+package by.it.group873601.karpeychik.lesson05;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Scanner;\n+\n+/*\n+Видеорегистраторы и площадь.\n+На площади установлена одна или несколько камер.\n+Известны данные о том, когда каждая из них включалась и выключалась (отрезки работы)\n+Известен список событий на площади (время начала каждого события).\n+Вам необходимо определить для каждого события сколько камер его записали.\n+\n+В первой строке задано два целых числа:\n+    число включений камер (отрезки) 1<=n<=50000\n+    число событий (точки) 1<=m<=50000.\n+\n+Следующие n строк содержат по два целых числа ai и bi (ai<=bi) -\n+координаты концов отрезков (время работы одной какой-то камеры).\n+Последняя строка содержит m целых чисел - координаты точек.\n+Все координаты не превышают 10E8 по модулю (!).\n+\n+Точка считается принадлежащей отрезку, если она находится внутри него или на границе.\n+\n+Для каждой точки в порядке их появления во вводе выведите,\n+скольким отрезкам она принадлежит.\n+    Sample Input:\n+    2 3\n+    0 5\n+    7 10\n+    1 6 11\n+    Sample Output:\n+    1 0 0\n+\n+*/\n+\n+public class A_QSort {\n+\n+    //отрезок\n+    private class Segment  implements Comparable{\n+        int start;\n+        int stop;\n+\n+        Segment(int start, int stop){\n+            this.start = start;\n+            this.stop = stop;\n+            //тут вообще-то лучше доделать конструктор на случай если\n+            //концы отрезков придут в обратном порядке\n+        }\n+\n+        @Override\n+        public int compareTo(Object o) {\n+            //подумайте, что должен возвращать компаратор отрезков\n+            return 0;\n+        }\n+    }\n+\n+\n+    int[] getAccessory(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        //число отрезков отсортированного массива\n+        int n = scanner.nextInt();\n+        Segment[] segments=new Segment[n];\n+        //число точек\n+        int m = scanner.nextInt();\n+        int[] points=new int[m];\n+        int[] result=new int[m];\n+\n+        //читаем сами отрезки\n+        for (int i = 0; i < n; i++) {\n+            //читаем начало и конец каждого отрезка\n+            segments[i]=new Segment(scanner.nextInt(),scanner.nextInt());\n+        }\n+        //читаем точки\n+        for (int i = 0; i < m; i++) {\n+            points[i]=scanner.nextInt();\n+        }\n+        //тут реализуйте логику задачи с применением быстрой сортировки\n+        //в классе отрезка Segment реализуйте нужный для этой задачи компаратор\n+\n+\n+\n+\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return result;\n+    }\n+\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson05/dataA.txt\");\n+        A_QSort instance = new A_QSort();\n+        int[] result=instance.getAccessory(stream);\n+        for (int index:result){\n+            System.out.print(index+\" \");\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "c55989df733e75ed4bd7c4990d399e33f697c4ef",
    "filename": "src/by/it/group873601/karpeychik/lesson05/B_CountSort.java",
    "status": "added",
    "additions": 54,
    "deletions": 0,
    "changes": 54,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson05/B_CountSort.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson05/B_CountSort.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson05/B_CountSort.java?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,54 @@\n+package by.it.group873601.karpeychik.lesson05;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Scanner;\n+\n+/*\n+Первая строка содержит число 1<=n<=10000, вторая - n натуральных чисел, не превышающих 10.\n+Выведите упорядоченную по неубыванию последовательность этих чисел.\n+\n+При сортировке реализуйте метод со сложностью O(n)\n+\n+Пример: https://karussell.wordpress.com/2010/03/01/fast-integer-sorting-algorithm-on/\n+Вольный перевод: http://programador.ru/sorting-positive-int-linear-time/\n+*/\n+\n+public class B_CountSort {\n+\n+\n+    int[] countSort(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        //размер массива\n+        int n = scanner.nextInt();\n+        int[] points=new int[n];\n+\n+        //читаем точки\n+        for (int i = 0; i < n; i++) {\n+            points[i]=scanner.nextInt();\n+        }\n+        //тут реализуйте логику задачи с применением сортировки подсчетом\n+\n+\n+\n+\n+\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return points;\n+    }\n+\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson05/dataB.txt\");\n+        B_CountSort instance = new B_CountSort();\n+        int[] result=instance.countSort(stream);\n+        for (int index:result){\n+            System.out.print(index+\" \");\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "8bce2baa112fab1ea06dd9d2494973d5835e94d7",
    "filename": "src/by/it/group873601/karpeychik/lesson05/C_QSortOptimized.java",
    "status": "added",
    "additions": 93,
    "deletions": 0,
    "changes": 93,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson05/C_QSortOptimized.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson05/C_QSortOptimized.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson05/C_QSortOptimized.java?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,93 @@\n+package by.it.group873601.karpeychik.lesson05;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Scanner;\n+\n+/*\n+Видеорегистраторы и площадь 2.\n+Условие то же что и в задаче А.\n+\n+        По сравнению с задачей A доработайте алгоритм так, чтобы\n+        1) он оптимально использовал время и память:\n+            - за стек отвечает элиминация хвостовой рекурсии,\n+            - за сам массив отрезков - сортировка на месте\n+            - рекурсионные вызовы должны проводится на основе 3-разбиения\n+\n+        2) при поиске подходящих отрезков для точки реализуйте метод бинарного поиска,\n+        помните при реализации, что поиск множественный\n+        (т.е. отрезков, подходящих для точки, может быть много)\n+\n+    Sample Input:\n+    2 3\n+    0 5\n+    7 10\n+    1 6 11\n+    Sample Output:\n+    1 0 0\n+\n+*/\n+\n+\n+public class C_QSortOptimized {\n+\n+    //отрезок\n+    private class Segment  implements Comparable{\n+        int start;\n+        int stop;\n+\n+        Segment(int start, int stop){\n+            this.start = start;\n+            this.stop = stop;\n+        }\n+\n+        @Override\n+        public int compareTo(Object o) {\n+            //подумайте, что должен возвращать компаратор отрезков\n+            return 0;\n+        }\n+    }\n+\n+\n+    int[] getAccessory2(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        //число отрезков отсортированного массива\n+        int n = scanner.nextInt();\n+        Segment[] segments=new Segment[n];\n+        //число точек\n+        int m = scanner.nextInt();\n+        int[] points=new int[m];\n+        int[] result=new int[m];\n+\n+        //читаем сами отрезки\n+        for (int i = 0; i < n; i++) {\n+            //читаем начало и конец каждого отрезка\n+            segments[i]=new Segment(scanner.nextInt(),scanner.nextInt());\n+        }\n+        //читаем точки\n+        for (int i = 0; i < n; i++) {\n+            points[i]=scanner.nextInt();\n+        }\n+        //тут реализуйте логику задачи с применением быстрой сортировки\n+        //в классе отрезка Segment реализуйте нужный для этой задачи компаратор\n+\n+\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return result;\n+    }\n+\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson05/dataC.txt\");\n+        C_QSortOptimized instance = new C_QSortOptimized();\n+        int[] result=instance.getAccessory2(stream);\n+        for (int index:result){\n+            System.out.print(index+\" \");\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "899fa0a398c4e557b8c4b3b645a3e851a6e83d43",
    "filename": "src/by/it/group873601/karpeychik/lesson05/Lesson5Test.java",
    "status": "added",
    "additions": 44,
    "deletions": 0,
    "changes": 44,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson05/Lesson5Test.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson05/Lesson5Test.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson05/Lesson5Test.java?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,44 @@\n+package by.it.group873601.karpeychik.lesson05;\n+\n+import org.junit.Test;\n+\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+public class Lesson5Test {\n+    @Test\n+    public void A() throws Exception {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson05/dataA.txt\");\n+        A_QSort instance = new A_QSort();\n+        int[] result=instance.getAccessory(stream);\n+        boolean ok=Arrays.equals(result,new int[]{1,0,0});\n+        assertTrue(\"A failed\", ok);\n+    }\n+\n+\n+    @Test\n+    public void B() throws Exception {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson05/dataB.txt\");\n+        B_CountSort instance = new B_CountSort();\n+        int[] result=instance.countSort(stream);\n+        boolean ok=Arrays.equals(result,new int[]{2,2,3,9,9});\n+        assertTrue(\"B failed\", ok);\n+    }\n+\n+\n+    @Test\n+    public void C() throws Exception {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson05/dataC.txt\");\n+        C_QSortOptimized instance = new C_QSortOptimized();\n+        int[] result=instance.getAccessory2(stream);\n+        boolean ok=Arrays.equals(result,new int[]{1,0,0});\n+        assertTrue(\"C failed\", ok);\n+    }\n+\n+}"
  },
  {
    "sha": "e5667e7bc8cfab2696d4d88b39c907ad94fc044f",
    "filename": "src/by/it/group873601/karpeychik/lesson05/dataA.txt",
    "status": "added",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson05/dataA.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson05/dataA.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson05/dataA.txt?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,4 @@\n+2 3\n+0 5\n+7 10\n+1 6 11\n\\ No newline at end of file"
  },
  {
    "sha": "d55c9cc43bafba5b7ceff7092ad66f3035e2604d",
    "filename": "src/by/it/group873601/karpeychik/lesson05/dataB.txt",
    "status": "added",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson05/dataB.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson05/dataB.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson05/dataB.txt?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,2 @@\n+5\n+2 3 9 2 9\n\\ No newline at end of file"
  },
  {
    "sha": "e5667e7bc8cfab2696d4d88b39c907ad94fc044f",
    "filename": "src/by/it/group873601/karpeychik/lesson05/dataC.txt",
    "status": "added",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson05/dataC.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/e355b925ad90dc67e064bb078fb94ada6deb02a0/src/by/it/group873601/karpeychik/lesson05/dataC.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/karpeychik/lesson05/dataC.txt?ref=e355b925ad90dc67e064bb078fb94ada6deb02a0",
    "patch": "@@ -0,0 +1,4 @@\n+2 3\n+0 5\n+7 10\n+1 6 11\n\\ No newline at end of file"
  }
]
