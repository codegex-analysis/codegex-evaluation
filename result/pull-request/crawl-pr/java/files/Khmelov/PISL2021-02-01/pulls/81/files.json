[
  {
    "sha": "cdaa7327ea04081d9f9a652df00e8bd0cd7838b6",
    "filename": "src/by/it/group873602/martirosov/lesson01/FiboA.java",
    "status": "added",
    "additions": 55,
    "deletions": 0,
    "changes": 55,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson01/FiboA.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson01/FiboA.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson01/FiboA.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,55 @@\n+package by.it.group873602.martirosov.lesson01;\n+\n+import java.math.BigInteger;\n+\n+/*\n+ * Вам необходимо выполнить рекурсивный способ вычисления чисел Фибоначчи\n+ */\n+\n+public class FiboA {\n+\n+    private long startTime = System.currentTimeMillis();\n+\n+    private long time() {\n+        return System.currentTimeMillis() - startTime;\n+    }\n+\n+    public static void main(String[] args) {\n+        FiboA fibo = new FiboA();\n+        int n = 33;\n+        System.out.printf(\"calc(%d)=%d \\n\\t time=%d \\n\\n\", n, fibo.calc(n), fibo.time());\n+\n+        //вычисление чисел фибоначчи медленным методом (рекурсией)\n+        fibo = new FiboA();\n+        n = 33;\n+        System.out.printf(\"slowA(%d)=%d \\n\\t time=%d \\n\\n\", n, fibo.slowA(n), fibo.time());\n+    }\n+\n+\n+    private static int calc(int n) {\n+        //здесь простейший вариант, в котором код совпадает с мат.определением чисел Фибоначчи\n+        //время O(2^n)\n+        if (n < 2) {\n+            return n;\n+        }\n+        return calc(n - 1) + calc(n - 2);\n+    }\n+\n+\n+    BigInteger slowA(Integer n) {\n+        //рекурсия\n+        //здесь нужно реализовать вариант без ограничения на размер числа,\n+        //в котором код совпадает с мат.определением чисел Фибоначчи\n+        //время O(2^n)\n+        if (n == 0) {\n+            return BigInteger.ZERO;\n+        }\n+        if (n == 1) {\n+            return BigInteger.ONE;\n+        }\n+        return slowA(n - 1).add(slowA(n - 2));\n+    }\n+\n+\n+}\n+"
  },
  {
    "sha": "169310b638cc54947a5b481f42bdd340336f17ce",
    "filename": "src/by/it/group873602/martirosov/lesson01/FiboB.java",
    "status": "added",
    "additions": 40,
    "deletions": 0,
    "changes": 40,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson01/FiboB.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson01/FiboB.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson01/FiboB.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,40 @@\n+package by.it.group873602.martirosov.lesson01;\n+\n+import java.math.BigInteger;\n+\n+/*\n+ * Вам необходимо выполнить способ вычисления чисел Фибоначчи с вспомогательным массивом\n+ * без ограничений на размер результата (BigInteger)\n+ */\n+\n+public class FiboB {\n+\n+    private long startTime = System.currentTimeMillis();\n+\n+    private long time() {\n+        return System.currentTimeMillis() - startTime;\n+    }\n+\n+    public static void main(String[] args) {\n+        //вычисление чисел простым быстрым методом\n+        FiboB fibo = new FiboB();\n+        int n = 55555;\n+        System.out.printf(\"fastB(%d)=%d \\n\\t time=%d \\n\\n\", n, fibo.fastB(n), fibo.time());\n+    }\n+\n+    BigInteger fastB(Integer n) {\n+        //здесь нужно реализовать вариант с временем O(n) и памятью O(n)\n+        if (n < 2) {\n+            return BigInteger.valueOf(n);\n+        }\n+        BigInteger[] fibonacci = new BigInteger[n + 1];\n+        fibonacci[0] = BigInteger.ZERO;\n+        fibonacci[1] = BigInteger.ONE;\n+        for (int i = 2; i <= n; i++) {\n+            fibonacci[i] = fibonacci[i - 1].add(fibonacci[i - 2]);\n+        }\n+        return fibonacci[n];\n+    }\n+\n+}\n+"
  },
  {
    "sha": "82a9fa5533d35883e7acefcbd2737d32b970549f",
    "filename": "src/by/it/group873602/martirosov/lesson01/FiboC.java",
    "status": "added",
    "additions": 65,
    "deletions": 0,
    "changes": 65,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson01/FiboC.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson01/FiboC.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson01/FiboC.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,65 @@\n+package by.it.group873602.martirosov.lesson01;\n+\n+/*\n+ * Даны целые числа 1<=n<=1E18 и 2<=m<=1E5,\n+ * необходимо найти остаток от деления n-го числа Фибоначчи на m.\n+ * время расчета должно быть не более 2 секунд\n+ */\n+\n+\n+public class FiboC {\n+\n+    private long startTime = System.currentTimeMillis();\n+\n+    private long time() {\n+        return System.currentTimeMillis() - startTime;\n+    }\n+\n+    public static void main(String[] args) {\n+        FiboC fibo = new FiboC();\n+        int n = 10;\n+        int m = 2;\n+        System.out.printf(\"fasterC(%d)=%d \\n\\t time=%d \\n\\n\", n, fibo.fasterC(n, m), fibo.time());\n+    }\n+\n+    long fasterC(long n, int m) {\n+        //решение практически невозможно найти интуитивно\n+        //вам потребуется дополнительный поиск информации\n+        //см. период Пизано\n+\n+        long period = pisanoPeriod(m);\n+        n = n % period;\n+\n+        long prev = 0;\n+        long curr = 1;\n+\n+        if (n == 0)\n+            return 0;\n+        else if (n == 1)\n+            return 1;\n+\n+        for (int i = 0; i < n - 1; i++) {\n+            long temp = curr;\n+            curr = (prev + curr) % m;\n+            prev = temp;\n+        }\n+        return curr % m;\n+    }\n+\n+    long pisanoPeriod(int m) {\n+        long prev = 0;\n+        long curr = 1;\n+        long res = 0;\n+\n+        for (int i = 0; i < m * m; i++) {\n+            long temp = curr;\n+            curr = (prev + curr) % m;\n+            prev = temp;\n+            if (prev == 0 && curr == 1)\n+                res = i + 1L;\n+        }\n+        return res;\n+    }\n+\n+}\n+"
  },
  {
    "sha": "e0d018dd0aa9e3d185f08be5064a5d74861c234d",
    "filename": "src/by/it/group873602/martirosov/lesson01/FiboTest.java",
    "status": "added",
    "additions": 44,
    "deletions": 0,
    "changes": 44,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson01/FiboTest.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson01/FiboTest.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson01/FiboTest.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,44 @@\n+package by.it.group873602.martirosov.lesson01;\n+\n+import org.junit.Test;\n+\n+import java.math.BigInteger;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+@SuppressWarnings(\"all\")\n+public class FiboTest {\n+    /*\n+    для прохождения тестов создайте JUnit-конфигурацию на свой пакет:\n+    Поля:\n+    Name:               Test a_khmelev (тут ваша фамилия)\n+    Test kind:          All in package\n+    Package:            by.it.группа.a_khmelev (тут ваша фамилия)\n+    Search for test:    In whole project\n+    */\n+\n+    @Test(timeout = 2000)\n+    public void slowA() throws Exception {\n+        FiboA fibo=new FiboA();\n+        BigInteger res=fibo.slowA(33);\n+        boolean ok=res.toString().equals(\"3524578\");\n+        assertTrue(\"slowA failed\", ok);\n+    }\n+\n+    @Test(timeout = 2000)\n+    public void fastB() throws Exception {\n+        FiboB fibo=new FiboB();\n+        BigInteger res=fibo.fastB(55555);\n+        boolean ok=res.toString().equals(\"909639027887347144342941161985282559355604430178183350584743748717027366542263454115774180457764119361178818065700599781605301031045912765958497937280143381078273858129564496371971635030388750211987018878594019122081608369859944055268290173661554656988657518473325524758272795937728604044464542075109647906732003650134988406067095491300374765088995480882968323512392912312617101227083974431097843457164074034436313773650841482061774891287543184545319371770727639363930224382008732215830209082100766659544448480462507899357524202479150382770774225865911940587951107025348123733528069313663520384501512487053755021582416432850008389098306703752469001379572433690896114640467636745086253877163269201080071042494668988577461564455432769254924713162146595798906578795216402666025860799868329860419563359713651103025221898184983333267778823082367482711242103128392639556863537102898301584759995002143070624597894698442040541110354780977822565822171878905836685636670318316609386609202981350416675502168926283222103319258798073524908331967335663739592708768575160693887587735383269058895502334974804209475257196644182183401092327147491379059823962903951993250290841961188457640918400772385828052455203308446497850522876608528180685531168473225828714565131444729283223699444503340482790428257563981286491892991033660246616024417941332506656689310748059549811484339433261117033259300500652902600115830724750452473301964550639144809470925781705205968970158308389657887649940883753804405196006995646957204750059695355436194123493457393941168645210746811798866778101896550299432514806643837980851710824081612727110722903372833776910411007619235864817126801702604065158334293916156858599848629086275942621396162424197955746781438271034399002200063411918796452136003564078905058991463355510592166377559715763614721727528762174985396734474738268089578234506515167275375031138709799221183193411830728781110315375410911538679192274012094572237862077799468940063396469472599562545280819613024692324290422417839590915081207851260450836509701986374443916520141544165383083153839035877261659612382394632908007237421298532631111604945472400580867112299736836453942883040919301426094366040263165816911324753683371254510146219312091798708493014082923046997229461410584400431963646196252695714577178308225591412910064716932858200159965282243561088622912391823483428553478212367172161995145427807648571543023538682011236247367500274357118969986946537681049847626833132626372331564775657970641545523598392909167955481457119817830082623455816062894209540469687455385575569476674039940711008474204307994961300581065435298861539733935163376567922721517142143870693595730772685170607264169021390358395399881188502427638248182477340230104522058037488718549609599732273262380107970103277852454079585014822446529907617554793888590318212831222877218400569978891912384375052727128718524934694661093439843049535858173127778867554834009090803582310094817387989046072275124327174453547387528618636253514292557730838237832283956847317251403978580909937787351429711078779176486954188835695627800987961493008146727150524700479682194654092491230343705472375989711563194519597413676122218700696331903370014042611855683236265661719277254818697403919130430082970613330085512630581993711275159086521623909671751050921361703343681699299208222210483191228642778043551720776161308201536353678451006349284573330815487139659744321673584559584535627067439581010081475569270508585650460599634412977833754040474620298291660929317207989213615847996337996513194412889319901026696279249614618048263112515523015028139115642407637494547067374364469154787640932535093313030524973284071847837684736975960823366826524971915596117141751173539262729086663116346365870365304961139616265531459119026052533301468820910319585978974579222551497319612280250272156600439579462572938175236818419213102577039797603964012311447121482962605776496764124907797045802761239464920829449200700588088226581890821754119528698448992492281777980743978405757962977498730099652422271747491916518058732412727393295412382217561015709276476265222622439458716140712781458897230945546868329928230421054584160200580399770646730181726541248601424838093255137542059863632032681191155464626810329003052450414902087133451713656344971266301306286598384154530437443195904584793667201486293909822730384866567403589855617148472976331377475537071340992696406582003033494858455633469855189854940169584255295881044283926177924571700029807536243414753698785712283199281467324771044558885623524634519934706960773040035641679891564766888028735640301056231364309188747975235305086820099619101194834477655410300908530799568056341467135959865163012148879799637372073120238334002164083141825552383359986157349055506671454613969971250993197318896380371736044700678686839058532742550672100148762502462567690393928229862990414662283465195719969681192925317147860433332662900777435695885742702980153579468077090503778385793045257952950939571400815755338835778252681311651211593423223271033820090662697446363417460923662250393808376533067948734141461696784826857742355326481531786608713950657208084344938550518227245946447950939511777299612416771729542414142576982603181588548594463903119620377875737240585329354450191149476257004704220396218896372972566563146603173395844213465455964339975758771738916022135628159697749562375309032256886577396168475827194326636777935421248710464612589191850097913011941826600916151746153573160932425356307913018103818572231771494548545466579668290240407141870360876562951856602444500777026852071846553257362419622464288697450580933026516503035014339009765843791821196411312165393747945504793993299751422908151987854767765817269975642144761884958625379183412350880981868626565168326052339532680197197858200204765140560748809378804767059034896306912874114267381150013577312431115293222274051955700161995353499107308739432654491665121139862651022220977402790694292313265157926210586554304669753789549742695475816403068323026643883659608102895106663954928507274638709413715276973722234800924968628551339593194656950666233178329230171300171790896760977977600703054490908033779919061417430767972754011226620011447787770040516989025818170004928836489506904080580895410790729678817790554829402807415722829064048804325214048768867868973205447913321185017203366768134124893876478106169409068166845256345603614755952200995450506503253096322589741111272573860520318560975126951189832398691354790155624215487306220430798632050226044082813297278674533852360615715272471146505997831814294373508289575689863926936157018562847403666957893046474794231832245767915764950463063819418934599036046132748550708580576092027307732454889200961677384186109536709266079853985476523531346415464941229194954505563092687327971602994597871986901655705546866430975791120173653270445491788176467125447014593030142811426624156667284237606937924697282519593068350824281461162360460317917445333603270404304171598255866616988625308545480547154998052222643657711174682277414701792789234550398444243563783350442559055541908269576447978400898556078854184975313420863644992336418260123115661138641838759121980922980182746613943486465087534850232586744133841747636710046314846745831670994098779580524422809535845883196541125925818027934524935795767942477297350167199511158722375729298143275562777989210939237729459500581200151961622610294719193912857664983695747089418077848341842747479353605964240934175117419680043821686563473525770356986897633945931996114027441293993666079903771862622785438928626113923911063936627869681173024996982573602392657779169262900509896269475824282258512914113759956518014684249546781380028633024426568315690423091176078448062494938618353795856287157761500396653963545510376826468285937461198717614785486284331624856379761950342941444039902439629145470393835639847926115014167679471960937462655579715056840092791540700933617938096273282334596764346928341223024309869218051536398537753802101110929837955769236103813869055495099703262883409012041761848724021333195454659951646980359421677064210706863660168861016236559537365045396235129819997695240203563639949785452598555874284145741040777257331880614743732438162252284147764148035005741554344546279394472438931324820288026274519808242693869080414444386675028918373153401490768380843351848427113619478744126210371863122440093613655447577113249000267942356307385248399435895311440865406541769774462963106844269995751111165312365889148985270030844877174359429336511675454861607078483687194200066090642719223093576427110150588110262193847157421102306411197089273574347086542400800528633585357786827095878525421498709518886724470954005978197906964718477002198987643283664577833752291238017460379354661683518044119258658196403688119863911001969457493498416088591539522805271419678746763581838734245715754721462086955985058439722368277588862050210922965588458008390805204826682386085423655836350934031315253436248696684634375070218291996645101785894679972053232999268463391792491397202598698532549209306038407089389170814042190047516687465343718894057618663112796109731136276137806006584813314845139426531979308355804915578565990413773376631453799855137038090741773508055133822860525243513283527061589059172286453679441998352714513650394795295105354986943863982582202530167265532500296148726539153598148766840870641239364617379750315388889503569004926351420656298789603645728951021324352143042614674039251422115798697547713631123807698993164925645374669805460077809276103954476896034509625394385947204050185217855524099622360537052794654126314130181596293144127267509390351018246614606419621608169991253167324318111584118384187873077324332235101472978837059697059900874239444989224012834638657187726461799190254373145224070507453490923444230916867959017257447376941662132028194306992196255147173779906789871155483492726999503177894814033511619479083908698457989598370495012644118329516819853330226633565412918634998283088126395380398793476716953835254592257031565790616613525000495203746662094756817245475391242659231997308097443779983219354573130426611778478692593591583617546914799296804525789713206912214531267052339211190112282721627175290941677106804596492543428294900573560468271465025689687105084668468189619639767716888486300937738962512530217833483251969414978948838418010674059964119031192844349921473189890333562644298871733567268178369507713139770414787297439886671772253317004726358040061068277570898528015355478563278532031290793232443681316564577939942167329056757668531416126638187915973262788310855346242953743907089052889700419942324397362425606941409727506690635964020154837089838696081484461121904400568295520716383595963400635719347742258457380004078279995058218236192428143853631277927475108860128155160872714269943851277340373266639438556500597050794352027301766865935883146777193359759064506577499692945142961399847185363846035489411916728005190125133620051680304062592494005371056113711295667563242745476125963220775394209187567930808056120453037041093082967574251679712066113534102230967327013521657561065451643719451653530724205229681371200152912780481428209508316270189500076121582841081399695808147375164707080761193903187755870846758109462933355019372529492513155055378096677369110652175673711075578590299120574710961154283757840850882013305753689311953733654090859881700093223315641073455810767834119285376879100652544381617590818383118661851414962612809756947753199125171502545556831799322789170241148215338109963325425668997935546328658765991089842850466571454347611327119513293519489362335958179174105025034828099588669105077499597365168880387075676110356654357331280261235167283832661443727354497944795910894953884419939619445\");\n+        assertTrue(\"fastB failed\", ok);\n+    }\n+\n+\n+    @Test(timeout = 2000)\n+    public void fasterC() throws Exception {\n+        FiboC fibo=new FiboC();\n+        assertTrue(\"fasterC failed 1\", fibo.fasterC(10,2)==1L);\n+        assertTrue(\"fasterC failed 2\", fibo.fasterC(1,2)==1L);\n+        assertTrue(\"fasterC failed 3\", fibo.fasterC(999999999,321)==34L);\n+    }\n+}"
  },
  {
    "sha": "d6605308ad432ab324e48c1cfe734ceb8cdc094e",
    "filename": "src/by/it/group873602/martirosov/lesson02/A_VideoRegistrator.java",
    "status": "added",
    "additions": 49,
    "deletions": 0,
    "changes": 49,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson02/A_VideoRegistrator.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson02/A_VideoRegistrator.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson02/A_VideoRegistrator.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,49 @@\n+package by.it.group873602.martirosov.lesson02;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+/*\n+даны события events\n+реализуйте метод calcStartTimes, так, чтобы число включений регистратора на\n+заданный период времени (1) было минимальным, а все события events\n+были зарегистрированы.\n+Алгоритм жадный. Для реализации обдумайте надежный шаг.\n+*/\n+\n+public class A_VideoRegistrator {\n+\n+    public static void main(String[] args) {\n+        A_VideoRegistrator instance = new A_VideoRegistrator();\n+        double[] events = new double[]{1, 1.1, 1.6, 2.2, 2.4, 2.7, 3.9, 8.1, 9.1, 5.5, 3.7};\n+        List<Double> starts = instance.calcStartTimes(events, 1); //рассчитаем моменты старта, с длинной сеанса 1\n+        System.out.println(starts);                            //покажем моменты старта\n+    }\n+\n+    //модификаторы доступа опущены для возможности тестирования\n+    List<Double> calcStartTimes(double[] events, double workDuration) {\n+        //events - события которые нужно зарегистрировать\n+        //timeWorkDuration время работы видеокамеры после старта\n+        List<Double> result;\n+        result = new ArrayList<>();\n+        int i = 0;                              //i - это индекс события events[i]\n+        //комментарии от проверочного решения сохранены для подсказки, но вы можете их удалить.\n+        //подготовка к жадному поглощению массива событий\n+        //hint: сортировка Arrays.sort обеспечит скорость алгоритма\n+        //C*(n log n) + C1*n = O(n log n)\n+\n+        Arrays.sort(events);\n+        while (i < events.length) {//пока есть незарегистрированные события\n+            result.add(events[i]);          //получим одно событие по левому краю\n+            double startTime = events[i];   //и запомним время старта видеокамеры\n+            double endTime = startTime + workDuration;      //вычислим момент окончания работы видеокамеры\n+            i++;\n+            //и теперь пропустим все покрываемые события\n+            //за время до конца работы, увеличивая индекс\n+            while (i < events.length && events[i] <= endTime) {\n+                i++;\n+            }\n+        }\n+        return result;     //вернем итог\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "816a1490080272e5d64fc3b759d1740432ff9f41",
    "filename": "src/by/it/group873602/martirosov/lesson02/B_Sheduler.java",
    "status": "added",
    "additions": 77,
    "deletions": 0,
    "changes": 77,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson02/B_Sheduler.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson02/B_Sheduler.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson02/B_Sheduler.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,77 @@\n+package by.it.group873602.martirosov.lesson02;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+/*\n+даны интервальные события events\n+реализуйте метод calcStartTimes, так, чтобы число принятых к выполнению\n+непересекающихся событий было максимально.\n+Алгоритм жадный. Для реализации обдумайте надежный шаг.\n+*/\n+\n+public class B_Sheduler {\n+    //событие у аудитории(два поля: начало и конец)\n+    static class Event {\n+        int start;\n+        int stop;\n+\n+        Event(int start, int stop) {\n+            this.start = start;\n+            this.stop = stop;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"(\"+ start +\":\" + stop + \")\";\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        B_Sheduler instance = new B_Sheduler();\n+        Event[] events = {  new Event(0, 3),  new Event(0, 1), new Event(1, 2), new Event(3, 5),\n+                new Event(1, 3),  new Event(1, 3), new Event(1, 3), new Event(3, 6),\n+                new Event(2, 7),  new Event(2, 3), new Event(2, 7), new Event(7, 9),\n+                new Event(3, 5),  new Event(2, 4), new Event(2, 3), new Event(3, 7),\n+                new Event(4, 5),  new Event(6, 7), new Event(6, 9), new Event(7, 9),\n+                new Event(8, 9),  new Event(4, 6), new Event(8, 10), new Event(7, 10)\n+        };\n+\n+        List<Event> starts = instance.calcStartTimes(events,0,10);  //рассчитаем оптимальное заполнение аудитории\n+        System.out.println(starts);                                 //покажем рассчитанный график занятий\n+    }\n+\n+    List<Event> calcStartTimes(Event[] events, int from, int to) {\n+        //events - события которые нужно распределить в аудитории\n+        //в период [from, int] (включительно).\n+        //оптимизация проводится по наибольшему числу непересекающихся событий.\n+        //начало и конец событий могут совпадать.\n+        List<Event> result;\n+        result = new ArrayList<>();\n+        //ваше решение.\n+\n+        Arrays.sort(events, (event1, event2) -> {\n+            if (event1.start == event2.start)\n+                return Integer.compare(event1.stop, event2.stop);\n+            return Integer.compare(event1.start, event2.start);\n+        });\n+\n+        int i = 0;\n+        while (events[i].start < from) {\n+            i++;\n+        }\n+        int d;\n+        while (i < events.length && events[i].stop <= to) {\n+            result.add(events[i]);\n+            d = events[i].stop;\n+            i++;\n+            while (events[i].start < d) {\n+                i++;\n+                if (i == events.length)\n+                    break;\n+            }\n+        }\n+\n+        return result;                        //вернем итог\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "8292d37513a2fdd9c34dfb141bd8a5cbbf3d411b",
    "filename": "src/by/it/group873602/martirosov/lesson02/C_GreedyKnapsack.java",
    "status": "added",
    "additions": 99,
    "deletions": 0,
    "changes": 99,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson02/C_GreedyKnapsack.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson02/C_GreedyKnapsack.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson02/C_GreedyKnapsack.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,99 @@\n+package by.it.group873602.martirosov.lesson02;\n+/*\n+Даны\n+1) объем рюкзака 4\n+2) число возможных предметов 60\n+3) сам набор предметов\n+    100 50\n+    120 30\n+    100 50\n+Все это указано в файле (by/it/a_khmelev/lesson02/greedyKnapsack.txt)\n+\n+Необходимо собрать наиболее дорогой вариант рюкзака для этого объема\n+Предметы можно резать на кусочки (т.е. алгоритм будет жадным)\n+ */\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Scanner;\n+\n+public class C_GreedyKnapsack {\n+    private class Item implements Comparable<Item> {\n+        int cost;\n+        int weight;\n+\n+        Item(int cost, int weight) {\n+            this.cost = cost;\n+            this.weight = weight;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Item{\" +\n+                    \"cost=\" + cost +\n+                    \", weight=\" + weight +\n+                    '}';\n+        }\n+\n+        @Override\n+        public int compareTo(Item o) {\n+            //тут может быть ваш компаратор\n+            return Double.compare((double) this.cost / this.weight, (double) o.cost / o.weight);\n+        }\n+    }\n+\n+    double calc(File source) throws FileNotFoundException {\n+        Scanner input = new Scanner(source);\n+        int n = input.nextInt();      //сколько предметов в файле\n+        int W = input.nextInt();      //какой вес у рюкзака\n+        Item[] items = new Item[n];   //получим список предметов\n+        for (int i = 0; i < n; i++) { //создавая каждый конструктором\n+            items[i] = new Item(input.nextInt(), input.nextInt());\n+        }\n+        //покажем предметы\n+        for (Item item:items) {\n+            System.out.println(item);\n+        }\n+        System.out.printf(\"Всего предметов: %d. Рюкзак вмещает %d кг.\\n\",n,W);\n+\n+        //тут необходимо реализовать решение задачи\n+        //итогом является максимально воможная стоимость вещей в рюкзаке\n+        //вещи можно резать на кусочки (непрерывный рюкзак)\n+        double result = 0;\n+        //тут реализуйте алгоритм сбора рюкзака\n+        //будет особенно хорошо, если с собственной сортировкой\n+        //кроме того, можете описать свой компаратор в классе Item\n+        //ваше решение.\n+\n+        Arrays.sort(items, Comparator.reverseOrder());\n+        int currentWeight = 0;\n+        for (int i = 0; i < n - 1 && currentWeight + items[i].weight <= W; i++) {\n+            result += items[i].cost;\n+            currentWeight += items[i].weight;\n+\n+            if (currentWeight + items[i + 1].weight > W) {\n+                int difference = W - currentWeight;\n+\n+                if (difference > 0) {\n+                    int unitCost = items[i + 1].cost / items[i + 1].weight;\n+\n+                    result += difference * unitCost;\n+                    currentWeight += difference;\n+                }\n+            }\n+        }\n+\n+        System.out.printf(\"Удалось собрать рюкзак на сумму %f\\n\",result);\n+        return result;\n+    }\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        long startTime = System.currentTimeMillis();\n+        String root=System.getProperty(\"user.dir\")+\"/src/\";\n+        File f=new File(root+\"by/it/a_khmelev/lesson02/greedyKnapsack.txt\");\n+        double costFinal=new C_GreedyKnapsack().calc(f);\n+        long finishTime = System.currentTimeMillis();\n+        System.out.printf(\"Общая стоимость %f (время %d)\",costFinal,finishTime - startTime);\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "fcbcae9b8f6c461d1f9c088bfd547f8c1e64b30b",
    "filename": "src/by/it/group873602/martirosov/lesson02/Lesson2Test.java",
    "status": "added",
    "additions": 55,
    "deletions": 0,
    "changes": 55,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson02/Lesson2Test.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson02/Lesson2Test.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson02/Lesson2Test.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,55 @@\n+package by.it.group873602.martirosov.lesson02;\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+public class Lesson2Test {\n+    /*\n+    для прохождения тестов создайте JUnit-конфигурацию на свой пакет:\n+    Поля:\n+    Name:               Test a_khmelev (тут ваша фамилия)\n+    Test kind:          All in package\n+    Package:            by.it.a_khmelev (тут ваша фамилия)\n+    Search for test:    In whole project\n+    */\n+\n+\n+    @Test\n+    public void A_VideoRegistrator() {\n+        A_VideoRegistrator instance = new A_VideoRegistrator();\n+        double[] events = new double[]{1, 1.1, 1.6, 2.2, 2.4, 2.7, 3.9, 8.1, 9.1, 5.5, 3.7};\n+        List<Double> starts = instance.calcStartTimes(events, 1); //рассчитаем моменты старта, с длинной сеанса 1\n+        boolean ok = starts.toString().equals(\"[1.0, 2.2, 3.7, 5.5, 8.1]\");\n+        assertTrue(\"slowA failed\", ok);\n+    }\n+\n+    @Test\n+    public void B_Sheduler() {\n+        B_Sheduler instance = new B_Sheduler();\n+        B_Sheduler.Event[] events = {new B_Sheduler.Event(0, 3), new B_Sheduler.Event(0, 1), new B_Sheduler.Event(1, 2), new B_Sheduler.Event(3, 5),\n+                new B_Sheduler.Event(1, 3), new B_Sheduler.Event(1, 3), new B_Sheduler.Event(1, 3), new B_Sheduler.Event(3, 6),\n+                new B_Sheduler.Event(2, 7), new B_Sheduler.Event(2, 3), new B_Sheduler.Event(2, 7), new B_Sheduler.Event(7, 9),\n+                new B_Sheduler.Event(3, 5), new B_Sheduler.Event(2, 4), new B_Sheduler.Event(2, 3), new B_Sheduler.Event(3, 7),\n+                new B_Sheduler.Event(4, 5), new B_Sheduler.Event(6, 7), new B_Sheduler.Event(6, 9), new B_Sheduler.Event(7, 9),\n+                new B_Sheduler.Event(8, 9), new B_Sheduler.Event(4, 6), new B_Sheduler.Event(8, 10), new B_Sheduler.Event(7, 10)\n+        };\n+\n+        List<B_Sheduler.Event> starts = instance.calcStartTimes(events, 0, 10);  //рассчитаем оптимальное заполнение аудитории\n+        boolean ok = starts.toString().equals(\"[(0:1), (1:2), (2:3), (3:5), (6:7), (7:9)]\");\n+        assertTrue(\"B_Sheduler failed\", ok);\n+    }\n+\n+    @Test\n+    public void C_GreedyKnapsack() throws Exception {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        File f = new File(root + \"by/it/a_khmelev/lesson02/greedyKnapsack.txt\");\n+        double costFinal = new C_GreedyKnapsack().calc(f);\n+        boolean ok = costFinal == 200;\n+        assertTrue(\"B_Sheduler failed\", ok);\n+    }\n+\n+}"
  },
  {
    "sha": "60f162d0b8801ed4f620cefbea33eed7d45eb350",
    "filename": "src/by/it/group873602/martirosov/lesson02/greedyKnapsack.txt",
    "status": "added",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson02/greedyKnapsack.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson02/greedyKnapsack.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson02/greedyKnapsack.txt?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,5 @@\n+4 60\n+60 20\n+100 50\n+120 30\n+100 50"
  },
  {
    "sha": "dd0f906b7d0f1919c5aabcc4a0afe3fa8a582faf",
    "filename": "src/by/it/group873602/martirosov/lesson03/A_Huffman.java",
    "status": "added",
    "additions": 181,
    "deletions": 0,
    "changes": 181,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson03/A_Huffman.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson03/A_Huffman.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson03/A_Huffman.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,181 @@\n+package by.it.group873602.martirosov.lesson03;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.util.*;\n+\n+//Lesson 3. A_Huffman.\n+//Разработайте метод encode(File file) для кодирования строки (код Хаффмана)\n+\n+// По данным файла (непустой строке ss длины не более 104104),\n+// состоящей из строчных букв латинского алфавита,\n+// постройте оптимальный по суммарной длине беспрефиксный код.\n+\n+// Используйте Алгоритм Хаффмана — жадный алгоритм оптимального\n+// безпрефиксного кодирования алфавита с минимальной избыточностью.\n+\n+// В первой строке выведите количество различных букв kk,\n+// встречающихся в строке, и размер получившейся закодированной строки.\n+// В следующих kk строках запишите коды букв в формате \"letter: code\".\n+// В последней строке выведите закодированную строку. Примеры ниже\n+\n+//        Sample Input 1:\n+//        a\n+//\n+//        Sample Output 1:\n+//        1 1\n+//        a: 0\n+//        0\n+\n+//        Sample Input 2:\n+//        abacabad\n+//\n+//        Sample Output 2:\n+//        4 14\n+//        a: 0\n+//        b: 10\n+//        c: 110\n+//        d: 111\n+//        01001100100111\n+\n+public class A_Huffman {\n+\n+    //Изучите классы Node InternalNode LeafNode\n+    abstract class Node implements Comparable<Node> {\n+        //абстрактный класс элемент дерева\n+        //(сделан abstract, чтобы нельзя было использовать его напрямую)\n+        //а только через его версии InternalNode и LeafNode\n+        private final int frequence; //частота символов\n+\n+        //генерация кодов (вызывается на корневом узле\n+        //один раз в конце, т.е. после построения дерева)\n+        abstract void fillCodes(String code);\n+\n+        //конструктор по умолчанию\n+        private Node(int frequence) {\n+            this.frequence = frequence;\n+        }\n+\n+        //метод нужен для корректной работы узла в приоритетной очереди\n+        //или для сортировок\n+        @Override\n+        public int compareTo(Node o) {\n+            return Integer.compare(frequence, o.frequence);\n+        }\n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////////////////\n+    //расширение базового класса до внутреннего узла дерева\n+    private class InternalNode extends Node {\n+        //внутренный узел дерева\n+        Node left;  //левый ребенок бинарного дерева\n+        Node right; //правый ребенок бинарного дерева\n+\n+        //для этого дерева не существует внутренних узлов без обоих детей\n+        //поэтому вот такого конструктора будет достаточно\n+        InternalNode(Node left, Node right) {\n+            super(left.frequence + right.frequence);\n+            this.left = left;\n+            this.right = right;\n+        }\n+\n+        @Override\n+        void fillCodes(String code) {\n+            left.fillCodes(code + \"0\");\n+            right.fillCodes(code + \"1\");\n+        }\n+\n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////////////////\n+    //расширение базового класса до листа дерева\n+    private class LeafNode extends Node {\n+        //лист\n+        char symbol; //символы хранятся только в листах\n+\n+        LeafNode(int frequence, char symbol) {\n+            super(frequence);\n+            this.symbol = symbol;\n+        }\n+\n+        @Override\n+        void fillCodes(String code) {\n+            //добрались до листа, значит рекурсия закончена, код уже готов\n+            //и можно запомнить его в индексе для поиска кода по символу.\n+            codes.put(this.symbol, code);\n+        }\n+    }\n+\n+    //индекс данных из листьев\n+    static private Map<Character, String> codes = new TreeMap<>();\n+\n+\n+    //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+    String encode(File file) throws FileNotFoundException {\n+        //прочитаем строку для кодирования из тестового файла\n+        Scanner scanner = new Scanner(file);\n+        String s = scanner.next();\n+\n+        //все комментарии от тестового решения были оставлены т.к. это задание A.\n+        //если они вам мешают их можно удалить\n+\n+        //1. переберем все символы по очереди и рассчитаем их частоту в Map count\n+        //для каждого символа добавим 1 если его в карте еще нет или инкремент если есть.\n+        Map<Character, Integer> count = new HashMap<>();\n+        for(char symbol : s.toCharArray()) {\n+            if(count.containsKey(symbol)) {\n+                count.replace(symbol, count.get(symbol) + 1);\n+            } else {\n+                count.put(symbol, 1);\n+            }\n+        }\n+\n+        //2. перенесем все символы в приоритетную очередь в виде листьев\n+        PriorityQueue<Node> priorityQueue = new PriorityQueue<>();\n+        for (Map.Entry<Character, Integer> entry : count.entrySet()) {\n+            priorityQueue.add(new LeafNode(entry.getValue(), entry.getKey()));\n+        }\n+\n+        //3. вынимая по два узла из очереди (для сборки родителя)\n+        //и возвращая этого родителя обратно в очередь\n+        //построим дерево кодирования Хаффмана.\n+        //У родителя частоты детей складываются.\n+        while(priorityQueue.size() > 1) {\n+            Node child1 = priorityQueue.poll();\n+            Node child2 = priorityQueue.poll();\n+            Node parent = new InternalNode(child1, child2);\n+            priorityQueue.add(parent);\n+        }\n+\n+        //4. последний из родителей будет корнем этого дерева\n+        //это будет последний и единственный элемент оставшийся в очереди priorityQueue.\n+        StringBuilder sb = new StringBuilder();\n+        if (priorityQueue.peek() != null) {\n+            priorityQueue.peek().fillCodes(\"\");\n+            for(char symbol : s.toCharArray()) {\n+                sb.append(codes.get(symbol));\n+            }\n+        }\n+\n+        return sb.toString();\n+        //01001100100111\n+        //01001100100111\n+    }\n+    //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        File f = new File(root + \"by/it/a_khmelev/lesson03/dataHuffman.txt\");\n+        A_Huffman instance = new A_Huffman();\n+        long startTime = System.currentTimeMillis();\n+        String result = instance.encode(f);\n+        long finishTime = System.currentTimeMillis();\n+        System.out.printf(\"%d %d\\n\", codes.size(), result.length());\n+        for (Map.Entry<Character, String> entry : codes.entrySet()) {\n+            System.out.printf(\"%s: %s\\n\", entry.getKey(), entry.getValue());\n+        }\n+        System.out.println(result);\n+    }\n+\n+}"
  },
  {
    "sha": "f41fd3c1373a17bc2111f57cc2554c96d1636be1",
    "filename": "src/by/it/group873602/martirosov/lesson03/B_Huffman.java",
    "status": "added",
    "additions": 88,
    "deletions": 0,
    "changes": 88,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson03/B_Huffman.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson03/B_Huffman.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson03/B_Huffman.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,88 @@\n+package by.it.group873602.martirosov.lesson03;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Scanner;\n+\n+// Lesson 3. B_Huffman.\n+// Восстановите строку по её коду и беспрефиксному коду символов.\n+\n+// В первой строке входного файла заданы два целых числа\n+// kk и ll через пробел — количество различных букв, встречающихся в строке,\n+// и размер получившейся закодированной строки, соответственно.\n+//\n+// В следующих kk строках записаны коды букв в формате \"letter: code\".\n+// Ни один код не является префиксом другого.\n+// Буквы могут быть перечислены в любом порядке.\n+// В качестве букв могут встречаться лишь строчные буквы латинского алфавита;\n+// каждая из этих букв встречается в строке хотя бы один раз.\n+// Наконец, в последней строке записана закодированная строка.\n+// Исходная строка и коды всех букв непусты.\n+// Заданный код таков, что закодированная строка имеет минимальный возможный размер.\n+//\n+//        Sample Input 1:\n+//        1 1\n+//        a: 0\n+//        0\n+\n+//        Sample Output 1:\n+//        a\n+\n+\n+//        Sample Input 2:\n+//        4 14\n+//        a: 0\n+//        b: 10\n+//        c: 110\n+//        d: 111\n+//        01001100100111\n+\n+//        Sample Output 2:\n+//        abacabad\n+\n+public class B_Huffman {\n+\n+    String decode(File file) throws FileNotFoundException {\n+        StringBuilder result=new StringBuilder();\n+        //прочитаем строку для кодирования из тестового файла\n+        Scanner scanner = new Scanner(file);\n+        Integer count = scanner.nextInt();\n+        Integer length = scanner.nextInt();\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! НАЧАЛО ЗАДАЧИ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1\n+        //тут запишите ваше решение\n+\n+        Map<Character, String> codes = new HashMap<>();\n+\n+        for(int i = 0; i < count; i++) {\n+            Character symbol = scanner.next().charAt(0);\n+            String code = scanner.next();\n+            codes.put(symbol, code);\n+        }\n+\n+        String encoded = scanner.next();\n+        while(encoded.length() > 0) {\n+            for (Map.Entry<Character, String> entry : codes.entrySet()) {\n+                if (encoded.startsWith(entry.getValue())) {\n+                    result.append(entry.getKey());\n+                    encoded = encoded.substring(entry.getValue().length());\n+                    break;\n+                }\n+            }\n+        }\n+\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! КОНЕЦ ЗАДАЧИ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1\n+        return result.toString(); //01001100100111\n+    }\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        File f = new File(root + \"by/it/a_khmelev/lesson03/encodeHuffman.txt\");\n+        B_Huffman instance = new B_Huffman();\n+        String result = instance.decode(f);\n+        System.out.println(result);\n+    }\n+\n+\n+}"
  },
  {
    "sha": "7e01633819d7f7bd882cdf6267d517c816f4795a",
    "filename": "src/by/it/group873602/martirosov/lesson03/C_HeapMax.java",
    "status": "added",
    "additions": 122,
    "deletions": 0,
    "changes": 122,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson03/C_HeapMax.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson03/C_HeapMax.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson03/C_HeapMax.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,122 @@\n+package by.it.group873602.martirosov.lesson03;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Scanner;\n+\n+// Lesson 3. C_Heap.\n+// Задача: построить max-кучу = пирамиду = бинарное сбалансированное дерево на массиве.\n+// ВАЖНО! НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ НИКАКИЕ КОЛЛЕКЦИИ, КРОМЕ ARRAYLIST (его можно, но только для массива)\n+\n+//      Проверка проводится по данным файла\n+//      Первая строка входа содержит число операций 1 ≤ n ≤ 100000.\n+//      Каждая из последующих nn строк задают операцию одного из следующих двух типов:\n+\n+//      Insert x, где 0 ≤ x ≤ 1000000000 — целое число;\n+//      ExtractMax.\n+\n+//      Первая операция добавляет число x в очередь с приоритетами,\n+//      вторая — извлекает максимальное число и выводит его.\n+\n+//      Sample Input:\n+//      6\n+//      Insert 200\n+//      Insert 10\n+//      ExtractMax\n+//      Insert 5\n+//      Insert 500\n+//      ExtractMax\n+//\n+//      Sample Output:\n+//      200\n+//      500\n+\n+\n+public class C_HeapMax {\n+\n+    private class MaxHeap {\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! НАЧАЛО ЗАДАЧИ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1\n+        //тут запишите ваше решение.\n+        //Будет мало? Ну тогда можете его собрать как Generic и/или использовать в варианте B\n+        private List<Long> heap = new ArrayList<>();\n+\n+        int siftDown(int i) { //просеивание вверх\n+            while (heap.size() > 2 * i + 1) {\n+                int j = 2 * i + 1;\n+                if (heap.size() > j + 1 && heap.get(j + 1).compareTo(heap.get(j)) > 0) {\n+                    j++;\n+                }\n+                if (heap.get(i).compareTo(heap.get(j)) >= 0) {\n+                    break;\n+                }\n+                Collections.swap(heap, i, j);\n+                i = j;\n+            }\n+            return i;\n+        }\n+\n+        int siftUp(int i) { //просеивание вниз\n+            while (heap.get(i).compareTo(heap.get((i - 1) / 2)) > 0) {\n+                Collections.swap(heap, i, (i - 1) / 2);\n+                i = (i - 1) / 2;\n+            }\n+            return i;\n+        }\n+\n+        void insert(Long value) { //вставка\n+            heap.add(value);\n+            siftUp(heap.size() - 1);\n+        }\n+\n+        Long extractMax() { //извлечение и удаление максимума\n+            Long result = null;\n+            result = heap.remove(0);\n+            heap.add(0, heap.remove(heap.size() - 1));\n+            siftDown(0);\n+            return result;\n+        }\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! КОНЕЦ ЗАДАЧИ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1\n+    }\n+\n+    //эта процедура читает данные из файла, ее можно не менять.\n+    Long findMaxValue(InputStream stream) {\n+        Long maxValue = 0L;\n+        MaxHeap heap = new MaxHeap();\n+        //прочитаем строку для кодирования из тестового файла\n+        Scanner scanner = new Scanner(stream);\n+        Integer count = scanner.nextInt();\n+        for (int i = 0; i < count; ) {\n+            String s = scanner.nextLine();\n+            if (s.equalsIgnoreCase(\"extractMax\")) {\n+                Long res = heap.extractMax();\n+                if (res != null && res > maxValue) maxValue = res;\n+                System.out.println();\n+                i++;\n+            }\n+            if (s.contains(\" \")) {\n+                String[] p = s.split(\" \");\n+                if (p[0].equalsIgnoreCase(\"insert\"))\n+                    heap.insert(Long.parseLong(p[1]));\n+                i++;\n+                //System.out.println(heap); //debug\n+            }\n+        }\n+        return maxValue;\n+    }\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson03/heapData.txt\");\n+        C_HeapMax instance = new C_HeapMax();\n+        System.out.println(\"MAX=\" + instance.findMaxValue(stream));\n+    }\n+\n+    // РЕМАРКА. Это задание исключительно учебное.\n+    // Свои собственные кучи нужны довольно редко.\n+    // \"В реальном бою\" все существенно иначе. Изучите и используйте коллекции\n+    // TreeSet, TreeMap, PriorityQueue и т.д. с нужным CompareTo() для объекта внутри.\n+}"
  },
  {
    "sha": "7f18968909f97e2f96ec55c370ee23939f48099f",
    "filename": "src/by/it/group873602/martirosov/lesson03/Lesson3Test.java",
    "status": "added",
    "additions": 51,
    "deletions": 0,
    "changes": 51,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson03/Lesson3Test.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson03/Lesson3Test.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson03/Lesson3Test.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,51 @@\n+package by.it.group873602.martirosov.lesson03;\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+public class Lesson3Test {\n+    /*\n+    для прохождения тестов создайте JUnit-конфигурацию на свой пакет:\n+    Поля:\n+    Name:               Test a_khmelev (тут ваша фамилия)\n+    Test kind:          All in package\n+    Package:            by.it.a_khmelev (тут ваша фамилия)\n+    Search for test:    In whole project\n+    */\n+\n+\n+    @Test\n+    public void A() throws Exception {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        File f = new File(root + \"by/it/a_khmelev/lesson03/dataHuffman.txt\");\n+        A_Huffman instance = new A_Huffman();\n+        String result = instance.encode(f);\n+        boolean ok=result.equals(\"01001100100111\");\n+        assertTrue(\"A failed\", ok);\n+    }\n+\n+    @Test\n+    public void B() throws Exception {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        File f = new File(root + \"by/it/a_khmelev/lesson03/encodeHuffman.txt\");\n+        B_Huffman instance = new B_Huffman();\n+        String result = instance.decode(f);\n+        boolean ok=result.equals(\"abacabad\");\n+        assertTrue(\"B failed\", ok);\n+    }\n+    @Test\n+    public void C() throws Exception {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson03/heapData.txt\");\n+        C_HeapMax instance = new C_HeapMax();\n+        Long res=instance.findMaxValue(stream);\n+        boolean ok=(res==500);\n+        assertTrue(\"C failed\", ok);\n+    }\n+\n+}"
  },
  {
    "sha": "e62bf5bf4f805b156d94506a32439fa6b4bd7e9b",
    "filename": "src/by/it/group873602/martirosov/lesson03/dataHuffman.txt",
    "status": "added",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson03/dataHuffman.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson03/dataHuffman.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson03/dataHuffman.txt?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1 @@\n+abacabad\n\\ No newline at end of file"
  },
  {
    "sha": "ac8d8e8e9a631bf7c42365d25276edd28f87640a",
    "filename": "src/by/it/group873602/martirosov/lesson03/encodeHuffman.txt",
    "status": "added",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson03/encodeHuffman.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson03/encodeHuffman.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson03/encodeHuffman.txt?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,6 @@\n+4 14\n+a: 0\n+b: 10\n+c: 110\n+d: 111\n+01001100100111\n\\ No newline at end of file"
  },
  {
    "sha": "3189ed64e8e6b5c9c8b65dc0d73cf4c3256fd256",
    "filename": "src/by/it/group873602/martirosov/lesson03/heapData.txt",
    "status": "added",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson03/heapData.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson03/heapData.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson03/heapData.txt?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,7 @@\n+6\n+Insert 200\n+Insert 10\n+ExtractMax\n+Insert 5\n+Insert 500\n+ExtractMax"
  },
  {
    "sha": "d92b3c40f37bf1222fc52a22ddedae280a6cd396",
    "filename": "src/by/it/group873602/martirosov/lesson04/A_BinaryFind.java",
    "status": "added",
    "additions": 82,
    "deletions": 0,
    "changes": 82,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson04/A_BinaryFind.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson04/A_BinaryFind.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson04/A_BinaryFind.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,82 @@\n+package by.it.group873602.martirosov.lesson04;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Scanner;\n+\n+/*\n+В первой строке источника данных даны:\n+        - целое число 1<=n<=100000 (размер массива)\n+        - сам массив A[1...n] из n различных натуральных чисел,\n+          не превышающих 10E9, в порядке возрастания,\n+Во второй строке\n+        - целое число 1<=k<=10000 (сколько чисел нужно найти)\n+        - k натуральных чисел b1,...,bk не превышающих 10E9 (сами числа)\n+Для каждого i от 1 до kk необходимо вывести индекс 1<=j<=n,\n+для которого A[j]=bi, или -1, если такого j нет.\n+\n+        Sample Input:\n+        5 1 5 8 12 13\n+        5 8 1 23 1 11\n+\n+        Sample Output:\n+        3 1 -1 1 -1\n+\n+(!) Обратите внимание на смещение начала индекса массивов JAVA относительно условий задачи\n+*/\n+\n+public class A_BinaryFind {\n+    int[] findIndex(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+\n+        //размер отсортированного массива\n+        int n = scanner.nextInt();\n+        //сам отсортированный массива\n+        int[] a = new int[n];\n+        for (int i = 1; i <= n; i++) {\n+            a[i - 1] = scanner.nextInt();\n+        }\n+\n+        //размер массива индексов\n+        int k = scanner.nextInt();\n+        int[] result = new int[k];\n+        for (int i = 0; i < k; i++) {\n+            int value = scanner.nextInt();\n+            int left = 0;\n+            int right = n-1;\n+            result[i] = -1;\n+            //тут реализуйте бинарный поиск индекса\n+\n+            while(left <= right) {\n+                int middle = (left + right) / 2;\n+                if(a[middle] == value) {\n+                    result[i] = middle + 1;\n+                    break;\n+                } else if(a[middle] > value) {\n+                    right = middle - 1;\n+                } else {\n+                    left = middle + 1;\n+                }\n+            }\n+        }\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return result;\n+    }\n+\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson04/dataA.txt\");\n+        A_BinaryFind instance = new A_BinaryFind();\n+        //long startTime = System.currentTimeMillis();\n+        int[] result = instance.findIndex(stream);\n+        //long finishTime = System.currentTimeMillis();\n+        for (int index : result) {\n+            System.out.print(index + \" \");\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "dc0317faae580d6e9f2209a09af20eacbcfe61cf",
    "filename": "src/by/it/group873602/martirosov/lesson04/B_MergeSort.java",
    "status": "added",
    "additions": 95,
    "deletions": 0,
    "changes": 95,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson04/B_MergeSort.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson04/B_MergeSort.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson04/B_MergeSort.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,95 @@\n+package by.it.group873602.martirosov.lesson04;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Scanner;\n+\n+/*\n+Реализуйте сортировку слиянием для одномерного массива.\n+Сложность алгоритма должна быть не хуже, чем O(n log n)\n+\n+Первая строка содержит число 1<=n<=10000,\n+вторая - массив A[1…n], содержащий натуральные числа, не превосходящие 10E9.\n+Необходимо отсортировать полученный массив.\n+\n+Sample Input:\n+5\n+2 3 9 2 9\n+Sample Output:\n+2 2 3 9 9\n+*/\n+public class B_MergeSort {\n+\n+    int[] merge(int[] ar_1, int[] ar_2) {\n+        int max = ar_1.length + ar_2.length;\n+        int[] result = new int[max];\n+        int m = 0, n = 0;\n+        for (int i = 0; i < max; i++) {\n+            if (m >= ar_1.length & n < ar_2.length) {\n+                result[i] = ar_2[n];\n+                n++;\n+            } else if (n >= ar_2.length & m < ar_1.length) {\n+                result[i] = ar_1[m];\n+                m++;\n+            } else if (ar_1[m] <= ar_2[n] & m < ar_1.length) {\n+                result[i] = ar_1[m];\n+                m++;\n+            } else {\n+                result[i] = ar_2[n];\n+                n++;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    int[] mergeSort(int[] arr, int l, int r) {\n+        int[] result = new int[1];\n+        int index = (l + r) / 2;\n+        if (l < r) {\n+            return merge(mergeSort(arr, l, index), mergeSort(arr, index + 1, r));\n+        } else {\n+            result[0] = arr[l];\n+            return result;\n+        }\n+    }\n+\n+    int[] getMergeSort(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+\n+        //размер массива\n+        int n = scanner.nextInt();\n+        //сам массива\n+        int[] a = new int[n];\n+        for (int i = 0; i < n; i++) {\n+            a[i] = scanner.nextInt();\n+            System.out.println(a[i]);\n+\n+        }\n+\n+        // тут ваше решение (реализуйте сортировку слиянием)\n+        // https://ru.wikipedia.org/wiki/Сортировка_слиянием\n+\n+        a = mergeSort(a, 0, a.length - 1);\n+\n+\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return a;\n+    }\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson04/dataB.txt\");\n+        B_MergeSort instance = new B_MergeSort();\n+        //long startTime = System.currentTimeMillis();\n+        int[] result = instance.getMergeSort(stream);\n+        //long finishTime = System.currentTimeMillis();\n+        for (int index : result) {\n+            System.out.print(index + \" \");\n+        }\n+    }\n+\n+\n+}"
  },
  {
    "sha": "8e812205131cffa28822116cc0bd255c7344ad8f",
    "filename": "src/by/it/group873602/martirosov/lesson04/C_GetInversions.java",
    "status": "added",
    "additions": 103,
    "deletions": 0,
    "changes": 103,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson04/C_GetInversions.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson04/C_GetInversions.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson04/C_GetInversions.java?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,103 @@\n+package by.it.group873602.martirosov.lesson04;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.Scanner;\n+\n+/*\n+Рассчитать число инверсий одномерного массива.\n+Сложность алгоритма должна быть не хуже, чем O(n log n)\n+\n+Первая строка содержит число 1<=n<=10000,\n+вторая - массив A[1…n], содержащий натуральные числа, не превосходящие 10E9.\n+Необходимо посчитать число пар индексов 1<=i<j<n, для которых A[i]>A[j].\n+\n+    (Такая пара элементов называется инверсией массива.\n+    Количество инверсий в массиве является в некотором смысле\n+    его мерой неупорядоченности: например, в упорядоченном по неубыванию\n+    массиве инверсий нет вообще, а в массиве, упорядоченном по убыванию,\n+    инверсию образуют каждые (т.е. любые) два элемента.\n+    )\n+\n+Sample Input:\n+5\n+2 3 9 2 9\n+Sample Output:\n+2\n+\n+Головоломка (т.е. не обязательно).\n+Попробуйте обеспечить скорость лучше, чем O(n log n) за счет многопоточности.\n+Докажите рост производительности замерами времени.\n+Большой тестовый массив можно прочитать свой или сгенерировать его программно.\n+*/\n+\n+\n+public class C_GetInversions {\n+\n+    int calc(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!\n+        //размер массива\n+        int n = scanner.nextInt();\n+        //сам массив\n+        int[] a = new int[n];\n+        for (int i = 0; i < n; i++) {\n+            a[i] = scanner.nextInt();\n+        }\n+        int result = 0;\n+        //!!!!!!!!!!!!!!!!!!!!!!!!     тут ваше решение   !!!!!!!!!!!!!!!!!!!!!!!!\n+\n+        result = mergeSortAndCount(a, 0, n - 1);\n+\n+\n+\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return result;\n+    }\n+\n+\n+    private int mergeAndCount(int[] arr, int l, int m, int r)\n+    {\n+        int[] left = Arrays.copyOfRange(arr, l, m + 1);\n+        int[] right = Arrays.copyOfRange(arr, m + 1, r + 1);\n+\n+        int i = 0, j = 0, k = l, swaps = 0;\n+        while (i < left.length && j < right.length) {\n+            if (left[i] <= right[j])\n+                arr[k++] = left[i++];\n+            else {\n+                arr[k++] = right[j++];\n+                swaps += (m + 1) - (l + i);\n+            }\n+        }\n+        while (i < left.length)\n+            arr[k++] = left[i++];\n+        while (j < right.length)\n+            arr[k++] = right[j++];\n+        return swaps;\n+    }\n+\n+    private int mergeSortAndCount(int[] arr, int l, int r) {\n+        int count = 0;\n+        if (l < r) {\n+            int m = (l + r) / 2;\n+            count += mergeSortAndCount(arr, l, m);\n+            count += mergeSortAndCount(arr, m + 1, r);\n+            count += mergeAndCount(arr, l, m, r);\n+        }\n+        return count;\n+    }\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson04/dataC.txt\");\n+        C_GetInversions instance = new C_GetInversions();\n+        //long startTime = System.currentTimeMillis();\n+        int result = instance.calc(stream);\n+        //long finishTime = System.currentTimeMillis();\n+        System.out.print(result);\n+    }\n+}"
  },
  {
    "sha": "54fdc796c7f6b287f9ba0094e865c9a6ae8a50f6",
    "filename": "src/by/it/group873602/martirosov/lesson04/dataA.txt",
    "status": "added",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson04/dataA.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson04/dataA.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson04/dataA.txt?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,2 @@\n+5 1 5 8 12 13\n+5 8 1 23 1 11\n\\ No newline at end of file"
  },
  {
    "sha": "d55c9cc43bafba5b7ceff7092ad66f3035e2604d",
    "filename": "src/by/it/group873602/martirosov/lesson04/dataB.txt",
    "status": "added",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson04/dataB.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson04/dataB.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson04/dataB.txt?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,2 @@\n+5\n+2 3 9 2 9\n\\ No newline at end of file"
  },
  {
    "sha": "d55c9cc43bafba5b7ceff7092ad66f3035e2604d",
    "filename": "src/by/it/group873602/martirosov/lesson04/dataC.txt",
    "status": "added",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson04/dataC.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/2c85cdf7d84fa8a0c22049a8c795760967763e49/src/by/it/group873602/martirosov/lesson04/dataC.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873602/martirosov/lesson04/dataC.txt?ref=2c85cdf7d84fa8a0c22049a8c795760967763e49",
    "patch": "@@ -0,0 +1,2 @@\n+5\n+2 3 9 2 9\n\\ No newline at end of file"
  }
]
