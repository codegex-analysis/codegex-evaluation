[
  {
    "sha": "8cfbb23cbf9cc1ea16517b5ac4224cb1bc8fdf14",
    "filename": "src/by/it/group873601/vlasova/lesson04/A_BinaryFind.java",
    "status": "added",
    "additions": 84,
    "deletions": 0,
    "changes": 84,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson04/A_BinaryFind.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson04/A_BinaryFind.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/vlasova/lesson04/A_BinaryFind.java?ref=1d31ff69a0109d12480794f2207522383f9027bb",
    "patch": "@@ -0,0 +1,84 @@\n+package by.it.group873601.vlasova.lesson04;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.Scanner;\n+\n+/*\n+В первой строке источника данных даны:\n+        - целое число 1<=n<=100000 (размер массива)\n+        - сам массив A[1...n] из n различных натуральных чисел,\n+          не превышающих 10E9, в порядке возрастания,\n+Во второй строке\n+        - целое число 1<=k<=10000 (сколько чисел нужно найти)\n+        - k натуральных чисел b1,...,bk не превышающих 10E9 (сами числа)\n+Для каждого i от 1 до kk необходимо вывести индекс 1<=j<=n,\n+для которого A[j]=bi, или -1, если такого j нет.\n+\n+        Sample Input:\n+        5 1 5 8 12 13\n+        5 8 1 23 1 11\n+\n+        Sample Output:\n+        3 1 -1 1 -1\n+\n+(!) Обратите внимание на смещение начала индекса массивов JAVA относительно условий задачи\n+*/\n+\n+public class A_BinaryFind {\n+    int[] findIndex(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+\n+        //размер отсортированного массива\n+        int n = scanner.nextInt();\n+        //сам отсортированный массива\n+        int[] a=new int[n];\n+        for (int i = 1; i <= n; i++) {\n+            a[i-1] = scanner.nextInt();\n+        }\n+        Arrays.sort(a);\n+\n+        //размер массива индексов\n+        int k = scanner.nextInt();\n+        int[] result=new int[k];\n+        for (int i = 0; i < k; i++) {\n+            int value = scanner.nextInt();\n+            //тут реализуйте бинарный поиск индекса\n+            int l = 0;\n+            int r = n - 1;\n+            int res = -1;\n+            while (l <= r) {\n+                int m = (l + r) / 2;\n+                if(value == a[m]) {\n+                    res = m + 1;\n+                    break;\n+                }\n+                if(value < a[m])\n+                    r = m - 1;\n+                else\n+                    l = m + 1;\n+            }\n+            result[i] = res;\n+        }\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return result;\n+    }\n+\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson04/dataA.txt\");\n+        A_BinaryFind instance = new A_BinaryFind();\n+        //long startTime = System.currentTimeMillis();\n+        int[] result=instance.findIndex(stream);\n+        //long finishTime = System.currentTimeMillis();\n+        for (int index:result){\n+            System.out.print(index+\" \");\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "e24e3d69498efd965161a5321e80d224066b0ec8",
    "filename": "src/by/it/group873601/vlasova/lesson04/B_MergeSort.java",
    "status": "added",
    "additions": 93,
    "deletions": 0,
    "changes": 93,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson04/B_MergeSort.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson04/B_MergeSort.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/vlasova/lesson04/B_MergeSort.java?ref=1d31ff69a0109d12480794f2207522383f9027bb",
    "patch": "@@ -0,0 +1,93 @@\n+package by.it.group873601.vlasova.lesson04;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.Scanner;\n+\n+/*\n+Реализуйте сортировку слиянием для одномерного массива.\n+Сложность алгоритма должна быть не хуже, чем O(n log n)\n+\n+Первая строка содержит число 1<=n<=10000,\n+вторая - массив A[1…n], содержащий натуральные числа, не превосходящие 10E9.\n+Необходимо отсортировать полученный массив.\n+\n+Sample Input:\n+5\n+2 3 9 2 9\n+Sample Output:\n+2 2 3 9 9\n+*/\n+public class B_MergeSort {\n+\n+    int[] mergeSort(int[] a) {\n+        if (a.length < 2)\n+            return a;\n+\n+        return merge(\n+                mergeSort(Arrays.copyOfRange(a, 0, a.length / 2)),\n+                mergeSort(Arrays.copyOfRange(a, a.length / 2, a.length)));\n+    }\n+\n+    int [] merge(int [] left, int [] right) {\n+\n+        int[] result = new int[left.length + right.length];\n+        int i = 0, j = 0, k = 0;\n+\n+        while (i < left.length && j < right.length) {\n+            if (left[i] <= right[j])\n+                result[k++] = left[i++];\n+            else\n+                result[k++] = right[j++];\n+        }\n+\n+        while (i < left.length)\n+            result[k++] = left[i++];\n+        while (j < right.length)\n+            result[k++] = right[j++];\n+\n+        return result;\n+    }\n+\n+    int[] getMergeSort(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+\n+        //размер массива\n+        int n = scanner.nextInt();\n+        //сам массива\n+        int[] a=new int[n];\n+        for (int i = 0; i < n; i++) {\n+            a[i] = scanner.nextInt();\n+            System.out.println(a[i]);\n+\n+        }\n+\n+        // тут ваше решение (реализуйте сортировку слиянием)\n+        // https://ru.wikipedia.org/wiki/Сортировка_слиянием\n+\n+        a = mergeSort(a);\n+\n+\n+\n+\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return a;\n+    }\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson04/dataB.txt\");\n+        B_MergeSort instance = new B_MergeSort();\n+        //long startTime = System.currentTimeMillis();\n+        int[] result=instance.getMergeSort(stream);\n+        //long finishTime = System.currentTimeMillis();\n+        for (int index:result){\n+            System.out.print(index+\" \");\n+        }\n+    }\n+\n+\n+}"
  },
  {
    "sha": "e3a47f5ada7c24234f36ec678fc402482072ac2a",
    "filename": "src/by/it/group873601/vlasova/lesson04/C_GetInversions.java",
    "status": "added",
    "additions": 98,
    "deletions": 0,
    "changes": 98,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson04/C_GetInversions.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson04/C_GetInversions.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/vlasova/lesson04/C_GetInversions.java?ref=1d31ff69a0109d12480794f2207522383f9027bb",
    "patch": "@@ -0,0 +1,98 @@\n+package by.it.group873601.vlasova.lesson04;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.Scanner;\n+\n+/*\n+Рассчитать число инверсий одномерного массива.\n+Сложность алгоритма должна быть не хуже, чем O(n log n)\n+\n+Первая строка содержит число 1<=n<=10000,\n+вторая - массив A[1…n], содержащий натуральные числа, не превосходящие 10E9.\n+Необходимо посчитать число пар индексов 1<=i<j<n, для которых A[i]>A[j].\n+\n+    (Такая пара элементов называется инверсией массива.\n+    Количество инверсий в массиве является в некотором смысле\n+    его мерой неупорядоченности: например, в упорядоченном по неубыванию\n+    массиве инверсий нет вообще, а в массиве, упорядоченном по убыванию,\n+    инверсию образуют каждые (т.е. любые) два элемента.\n+    )\n+\n+Sample Input:\n+5\n+2 3 9 2 9\n+Sample Output:\n+2\n+\n+Головоломка (т.е. не обязательно).\n+Попробуйте обеспечить скорость лучше, чем O(n log n) за счет многопоточности.\n+Докажите рост производительности замерами времени.\n+Большой тестовый массив можно прочитать свой или сгенерировать его программно.\n+*/\n+\n+\n+public class C_GetInversions {\n+\n+    int calc(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!\n+        //размер массива\n+        int n = scanner.nextInt();\n+        //сам массив\n+        int[] a = new int[n];\n+        for (int i = 0; i < n; i++) {\n+            a[i] = scanner.nextInt();\n+        }\n+        int result = 0;\n+        //!!!!!!!!!!!!!!!!!!!!!!!!     тут ваше решение   !!!!!!!!!!!!!!!!!!!!!!!!\n+\n+        result = mergeSort(a);\n+\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return result;\n+    }\n+    int mergeSort(int[] arr) {\n+        if (arr.length < 2)\n+            return 0;\n+\n+        int[] left = Arrays.copyOfRange(arr, 0, arr.length / 2);\n+        int[] right = Arrays.copyOfRange(arr, arr.length / 2, arr.length);\n+\n+        return mergeSort(left) + mergeSort(right) + merge(arr, left, right);\n+    }\n+\n+    int merge(int[] result, int[] left, int[] right) {\n+        int i = 0, j = 0, k = 0;\n+        int count = 0;\n+\n+        while (i < left.length && j < right.length) {\n+            if (left[i] <= right[j])\n+                result[k++] = left[i++];\n+            else {\n+                result[k++] = right[j++];\n+                count += left.length - i;\n+            }\n+        }\n+\n+        while (i < left.length)\n+            result[k++] = left[i++];\n+        while (j < right.length)\n+            result[k++] = right[j++];\n+\n+        return count;\n+    }\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson04/dataC.txt\");\n+        C_GetInversions instance = new C_GetInversions();\n+        //long startTime = System.currentTimeMillis();\n+        int result = instance.calc(stream);\n+        //long finishTime = System.currentTimeMillis();\n+        System.out.print(result);\n+    }\n+}"
  },
  {
    "sha": "54fdc796c7f6b287f9ba0094e865c9a6ae8a50f6",
    "filename": "src/by/it/group873601/vlasova/lesson04/dataA.txt",
    "status": "added",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson04/dataA.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson04/dataA.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/vlasova/lesson04/dataA.txt?ref=1d31ff69a0109d12480794f2207522383f9027bb",
    "patch": "@@ -0,0 +1,2 @@\n+5 1 5 8 12 13\n+5 8 1 23 1 11\n\\ No newline at end of file"
  },
  {
    "sha": "d55c9cc43bafba5b7ceff7092ad66f3035e2604d",
    "filename": "src/by/it/group873601/vlasova/lesson04/dataB.txt",
    "status": "added",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson04/dataB.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson04/dataB.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/vlasova/lesson04/dataB.txt?ref=1d31ff69a0109d12480794f2207522383f9027bb",
    "patch": "@@ -0,0 +1,2 @@\n+5\n+2 3 9 2 9\n\\ No newline at end of file"
  },
  {
    "sha": "d55c9cc43bafba5b7ceff7092ad66f3035e2604d",
    "filename": "src/by/it/group873601/vlasova/lesson04/dataC.txt",
    "status": "added",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson04/dataC.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson04/dataC.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/vlasova/lesson04/dataC.txt?ref=1d31ff69a0109d12480794f2207522383f9027bb",
    "patch": "@@ -0,0 +1,2 @@\n+5\n+2 3 9 2 9\n\\ No newline at end of file"
  },
  {
    "sha": "47c5861afb94d46ceaf80517c90759d871861097",
    "filename": "src/by/it/group873601/vlasova/lesson05/A_QSort.java",
    "status": "added",
    "additions": 131,
    "deletions": 0,
    "changes": 131,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson05/A_QSort.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson05/A_QSort.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/vlasova/lesson05/A_QSort.java?ref=1d31ff69a0109d12480794f2207522383f9027bb",
    "patch": "@@ -0,0 +1,131 @@\n+package by.it.group873601.vlasova.lesson05;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Scanner;\n+\n+/*\n+Видеорегистраторы и площадь.\n+На площади установлена одна или несколько камер.\n+Известны данные о том, когда каждая из них включалась и выключалась (отрезки работы)\n+Известен список событий на площади (время начала каждого события).\n+Вам необходимо определить для каждого события сколько камер его записали.\n+\n+В первой строке задано два целых числа:\n+    число включений камер (отрезки) 1<=n<=50000\n+    число событий (точки) 1<=m<=50000.\n+\n+Следующие n строк содержат по два целых числа ai и bi (ai<=bi) -\n+координаты концов отрезков (время работы одной какой-то камеры).\n+Последняя строка содержит m целых чисел - координаты точек.\n+Все координаты не превышают 10E8 по модулю (!).\n+\n+Точка считается принадлежащей отрезку, если она находится внутри него или на границе.\n+\n+Для каждой точки в порядке их появления во вводе выведите,\n+скольким отрезкам она принадлежит.\n+    Sample Input:\n+    2 3\n+    0 5\n+    7 10\n+    1 6 11\n+    Sample Output:\n+    1 0 0\n+\n+*/\n+\n+public class A_QSort {\n+\n+    //отрезок\n+    private class Segment  implements Comparable<Segment>{\n+        int start;\n+        int stop;\n+\n+        Segment(int start, int stop){\n+            this.start = start;\n+            this.stop = stop;\n+            //тут вообще-то лучше доделать конструктор на случай если\n+            //концы отрезков придут в обратном порядке\n+        }\n+\n+        @Override\n+        public int compareTo(Segment o) {\n+            if (this.start == o.start)\n+                return Integer.compare(this.stop, o.stop);\n+            return Integer.compare(this.start, o.start);\n+        }\n+    }\n+\n+\n+    int[] getAccessory(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        //число отрезков отсортированного массива\n+        int n = scanner.nextInt();\n+        Segment[] segments=new Segment[n];\n+        //число точек\n+        int m = scanner.nextInt();\n+        int[] points=new int[m];\n+        int[] result=new int[m];\n+\n+        //читаем сами отрезки\n+        for (int i = 0; i < n; i++) {\n+            //читаем начало и конец каждого отрезка\n+            segments[i]=new Segment(scanner.nextInt(),scanner.nextInt());\n+        }\n+        //читаем точки\n+        for (int i = 0; i < m; i++) {\n+            points[i]=scanner.nextInt();\n+        }\n+        //тут реализуйте логику задачи с применением быстрой сортировки\n+        //в классе отрезка Segment реализуйте нужный для этой задачи компаратор\n+\n+        qsort(segments, 0, n - 1);\n+\n+        for (int i = 0; i < m; i++) {\n+            int j = 0;\n+            while(j < segments.length && points[i] < segments[j].start)\n+                j++;\n+            while(j < segments.length && points[i] >= segments[j].start && points[i] <= segments[j].stop) {\n+                j++;\n+                result[i]++;\n+            }\n+        }\n+\n+\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return result;\n+    }\n+    public void qsort(Segment[] segments, int b, int e) {\n+        if(segments.length == 0 || b >= e)\n+            return;\n+        int m = (b + e) / 2;\n+        int l = b, r = e;\n+        while(l <= r) {\n+            while(segments[l].compareTo(segments[m]) < 0) l++;\n+            while(segments[r].compareTo(segments[m]) > 0) r--;\n+            if(l <= r) {\n+                Segment temp = segments[l];\n+                segments[l++] = segments[r];\n+                segments[r--] = temp;\n+            }\n+        }\n+        if(b < r)\n+            qsort(segments, b, r);\n+        if(e > l)\n+            qsort(segments, l, e);\n+    }\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson05/dataA.txt\");\n+        A_QSort instance = new A_QSort();\n+        int[] result=instance.getAccessory(stream);\n+        for (int index:result){\n+            System.out.print(index+\" \");\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "69ee83a4454cbaeb75ff0b74a3ccb9be8cb316c4",
    "filename": "src/by/it/group873601/vlasova/lesson05/B_CountSort.java",
    "status": "added",
    "additions": 73,
    "deletions": 0,
    "changes": 73,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson05/B_CountSort.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson05/B_CountSort.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/vlasova/lesson05/B_CountSort.java?ref=1d31ff69a0109d12480794f2207522383f9027bb",
    "patch": "@@ -0,0 +1,73 @@\n+package by.it.group873601.vlasova.lesson05;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.Scanner;\n+\n+/*\n+Первая строка содержит число 1<=n<=10000, вторая - n натуральных чисел, не превышающих 10.\n+Выведите упорядоченную по неубыванию последовательность этих чисел.\n+\n+При сортировке реализуйте метод со сложностью O(n)\n+\n+Пример: https://karussell.wordpress.com/2010/03/01/fast-integer-sorting-algorithm-on/\n+Вольный перевод: http://programador.ru/sorting-positive-int-linear-time/\n+*/\n+\n+public class B_CountSort {\n+\n+\n+    int[] countSort(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        //размер массива\n+        int n = scanner.nextInt();\n+        int[] points=new int[n];\n+\n+        //читаем точки\n+        for (int i = 0; i < n; i++) {\n+            points[i]=scanner.nextInt();\n+        }\n+        //тут реализуйте логику задачи с применением сортировки подсчетом\n+\n+        sort(points);\n+\n+\n+\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return points;\n+    }\n+\n+    int[] sort(int[] array) {\n+        int min = Arrays.stream(array).summaryStatistics().getMin();\n+        int max = Arrays.stream(array).summaryStatistics().getMax();\n+\n+        int[] countIntegers = new int[max - min + 1];\n+\n+        for (int k : array) {\n+            countIntegers[k - min]++;\n+        }\n+\n+        int pos = 0;\n+        for (int i = min; i <= max; i++) {\n+            for (int j = 0; j < countIntegers[i - min]; j++) {\n+                array[pos++] = i;\n+            }\n+        }\n+        return array;\n+    }\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson05/dataB.txt\");\n+        B_CountSort instance = new B_CountSort();\n+        int[] result=instance.countSort(stream);\n+        for (int index:result){\n+            System.out.print(index+\" \");\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "2b7ba36c61c8cfcfd18756db4a7fe2e935b2e6c6",
    "filename": "src/by/it/group873601/vlasova/lesson05/C_QSortOptimized.java",
    "status": "added",
    "additions": 177,
    "deletions": 0,
    "changes": 177,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson05/C_QSortOptimized.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson05/C_QSortOptimized.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/vlasova/lesson05/C_QSortOptimized.java?ref=1d31ff69a0109d12480794f2207522383f9027bb",
    "patch": "@@ -0,0 +1,177 @@\n+package by.it.group873601.vlasova.lesson05;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.util.Scanner;\n+\n+\n+/*\n+Видеорегистраторы и площадь 2.\n+Условие то же что и в задаче А.\n+\n+        По сравнению с задачей A доработайте алгоритм так, чтобы\n+        1) он оптимально использовал время и память:\n+            - за стек отвечает элиминация хвостовой рекурсии,\n+            - за сам массив отрезков - сортировка на месте\n+            - рекурсионные вызовы должны проводится на основе 3-разбиения\n+\n+        2) при поиске подходящих отрезков для точки реализуйте метод бинарного поиска,\n+        помните при реализации, что поиск множественный\n+        (т.е. отрезков, подходящих для точки, может быть много)\n+\n+    Sample Input:\n+    2 3\n+    0 5\n+    7 10\n+    1 6 11\n+    Sample Output:\n+    1 0 0\n+\n+*/\n+\n+\n+public class C_QSortOptimized {\n+\n+    //отрезок\n+    private class Segment  implements Comparable<Segment>{\n+        int start;\n+        int stop;\n+\n+        Segment(int start, int stop){\n+            this.start = start;\n+            this.stop = stop;\n+        }\n+\n+        @Override\n+        public int compareTo(Segment o) {\n+            if (this.start == o.start)\n+                return Integer.compare(this.stop, o.stop);\n+            return Integer.compare(this.start, o.start);\n+        }\n+    }\n+\n+\n+    int[] getAccessory2(InputStream stream) throws FileNotFoundException {\n+        //подготовка к чтению данных\n+        Scanner scanner = new Scanner(stream);\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        //число отрезков отсортированного массива\n+        int n = scanner.nextInt();\n+        Segment[] segments=new Segment[n];\n+        //число точек\n+        int m = scanner.nextInt();\n+        int[] points=new int[m];\n+        int[] result=new int[m];\n+\n+        //читаем сами отрезки\n+        for (int i = 0; i < n; i++) {\n+            //читаем начало и конец каждого отрезка\n+            segments[i]=new Segment(scanner.nextInt(),scanner.nextInt());\n+        }\n+        //читаем точки\n+        for (int i = 0; i < m; i++) {\n+            points[i]=scanner.nextInt();\n+        }\n+        //тут реализуйте логику задачи с применением быстрой сортировки\n+        //в классе отрезка Segment реализуйте нужный для этой задачи компаратор\n+        quicksort(segments, 0, n - 1);\n+\n+        for (int i = 0; i < m; i++) {\n+            int l = 0;\n+            int r = n - 1;\n+            int res1 = 0;\n+            int res2 = 0;\n+            while (l <= r) {\n+                int mid = (l + r) / 2;\n+                while(mid + res1 <= r && segments[mid + res1].start <= points[i] && points[i] <= segments[mid + res1].stop) {\n+                    res1++;\n+                }\n+                while(mid - res2 - 1 >= l && segments[mid - res2  - 1].start <= points[i] && points[i] <= segments[mid - res2  - 1].stop) {\n+                    res2++;\n+                }\n+                if(res1 + res2 != 0)\n+                    break;\n+                if(segments[mid].start >= points[i])\n+                    r = mid - 1;\n+                else\n+                    l = mid + 1;\n+            }\n+            result[i] = res1 + res2;\n+        }\n+\n+        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!\n+        return result;\n+    }\n+\n+    void quicksort(Segment[] segments, int b, int e) {\n+        while (b < e) {\n+            int[] lr = partition(segments, b, e);\n+\n+            if (lr[1] - b < e - lr[0]) {\n+                quicksort(segments, b, lr[1]);\n+                b = lr[0];\n+            } else {\n+                quicksort(segments, lr[0], e);\n+                e = lr[1];\n+            }\n+        }\n+    }\n+\n+    int[] partition(Segment segments[], int b, int e) {\n+        int l = b - 1;\n+        int r = e;\n+        int p = b - 1;\n+        int q = e;\n+\n+        Segment v = segments[e];\n+\n+        while (true) {\n+            while (segments[++l].compareTo(v) < 0);\n+            while (segments[--r].compareTo(v) > 0)\n+                if (r == b)\n+                    break;\n+            if (l >= r)\n+                break;\n+\n+            swap(segments, l, r);\n+\n+            if (segments[l].compareTo(v) == 0)\n+                swap(segments, l, ++p);\n+\n+            if (segments[r].compareTo(v) == 0)\n+                swap(segments, --q, r);\n+        }\n+\n+        swap(segments, l, e);\n+\n+        r = l - 1;\n+        for (int k = b; k <= p; k++, r--)\n+            swap(segments, k, r);\n+\n+\n+        l = l + 1;\n+        for (int k = e - 1; k >= q; k--, l++)\n+            swap(segments, l, k);\n+\n+        return new int[]{l, r};\n+    }\n+\n+    void swap(Segment[] arr, int i, int j) {\n+        Segment t = arr[i];\n+        arr[i] = arr[j];\n+        arr[j] = t;\n+    }\n+\n+\n+    public static void main(String[] args) throws FileNotFoundException {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson05/dataC.txt\");\n+        C_QSortOptimized instance = new C_QSortOptimized();\n+        int[] result=instance.getAccessory2(stream);\n+        for (int index:result){\n+            System.out.print(index+\" \");\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "7a43109c5d9ab988d2867a7979ca15031b45ba0a",
    "filename": "src/by/it/group873601/vlasova/lesson05/Lesson5Test.java",
    "status": "added",
    "additions": 44,
    "deletions": 0,
    "changes": 44,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson05/Lesson5Test.java",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson05/Lesson5Test.java",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/vlasova/lesson05/Lesson5Test.java?ref=1d31ff69a0109d12480794f2207522383f9027bb",
    "patch": "@@ -0,0 +1,44 @@\n+package by.it.group873601.vlasova.lesson05;\n+\n+import org.junit.Test;\n+\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+public class Lesson5Test {\n+    @Test\n+    public void A() throws Exception {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson05/dataA.txt\");\n+        A_QSort instance = new A_QSort();\n+        int[] result=instance.getAccessory(stream);\n+        boolean ok=Arrays.equals(result,new int[]{1,0,0});\n+        assertTrue(\"A failed\", ok);\n+    }\n+\n+\n+    @Test\n+    public void B() throws Exception {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson05/dataB.txt\");\n+        B_CountSort instance = new B_CountSort();\n+        int[] result=instance.countSort(stream);\n+        boolean ok=Arrays.equals(result,new int[]{2,2,3,9,9});\n+        assertTrue(\"B failed\", ok);\n+    }\n+\n+\n+    @Test\n+    public void C() throws Exception {\n+        String root = System.getProperty(\"user.dir\") + \"/src/\";\n+        InputStream stream = new FileInputStream(root + \"by/it/a_khmelev/lesson05/dataC.txt\");\n+        C_QSortOptimized instance = new C_QSortOptimized();\n+        int[] result=instance.getAccessory2(stream);\n+        boolean ok=Arrays.equals(result,new int[]{1,0,0});\n+        assertTrue(\"C failed\", ok);\n+    }\n+\n+}"
  },
  {
    "sha": "e5667e7bc8cfab2696d4d88b39c907ad94fc044f",
    "filename": "src/by/it/group873601/vlasova/lesson05/dataA.txt",
    "status": "added",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson05/dataA.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson05/dataA.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/vlasova/lesson05/dataA.txt?ref=1d31ff69a0109d12480794f2207522383f9027bb",
    "patch": "@@ -0,0 +1,4 @@\n+2 3\n+0 5\n+7 10\n+1 6 11\n\\ No newline at end of file"
  },
  {
    "sha": "d55c9cc43bafba5b7ceff7092ad66f3035e2604d",
    "filename": "src/by/it/group873601/vlasova/lesson05/dataB.txt",
    "status": "added",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson05/dataB.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson05/dataB.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/vlasova/lesson05/dataB.txt?ref=1d31ff69a0109d12480794f2207522383f9027bb",
    "patch": "@@ -0,0 +1,2 @@\n+5\n+2 3 9 2 9\n\\ No newline at end of file"
  },
  {
    "sha": "e5667e7bc8cfab2696d4d88b39c907ad94fc044f",
    "filename": "src/by/it/group873601/vlasova/lesson05/dataC.txt",
    "status": "added",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/Khmelov/PISL2021-02-01/blob/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson05/dataC.txt",
    "raw_url": "https://github.com/Khmelov/PISL2021-02-01/raw/1d31ff69a0109d12480794f2207522383f9027bb/src/by/it/group873601/vlasova/lesson05/dataC.txt",
    "contents_url": "https://api.github.com/repos/Khmelov/PISL2021-02-01/contents/src/by/it/group873601/vlasova/lesson05/dataC.txt?ref=1d31ff69a0109d12480794f2207522383f9027bb",
    "patch": "@@ -0,0 +1,4 @@\n+2 3\n+0 5\n+7 10\n+1 6 11\n\\ No newline at end of file"
  }
]
