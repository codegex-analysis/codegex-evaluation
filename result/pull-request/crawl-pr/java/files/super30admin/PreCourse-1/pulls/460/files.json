[
  {
    "sha": "acdea708ea76e2c5a8d87682731f43ee1b81c16f",
    "filename": "Exercise_1.java",
    "status": "modified",
    "additions": 29,
    "deletions": 1,
    "changes": 30,
    "blob_url": "https://github.com/super30admin/PreCourse-1/blob/49a50c174fde30a3a51dcf41d2a92fdfa3a2f449/Exercise_1.java",
    "raw_url": "https://github.com/super30admin/PreCourse-1/raw/49a50c174fde30a3a51dcf41d2a92fdfa3a2f449/Exercise_1.java",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-1/contents/Exercise_1.java?ref=49a50c174fde30a3a51dcf41d2a92fdfa3a2f449",
    "patch": "@@ -1,3 +1,5 @@\n+import java.lang.*;\r\n+import java.util.*;\r\n class Stack { \r\n     static final int MAX = 1000; \r\n     int top; \r\n@@ -6,39 +8,65 @@\n     boolean isEmpty() \r\n     { \r\n         //Write your code here \r\n+        if(this.top==0) return true;\r\n+        return false;\r\n     } \r\n \r\n     Stack() \r\n     { \r\n         //Initialize your constructor \r\n+        this.top=0;\r\n+\r\n     } \r\n   \r\n     boolean push(int x) \r\n     { \r\n         //Check for stack Overflow\r\n         //Write your code here\r\n+        if(this.top==MAX-1) return false;\r\n+        a[this.top]=x;\r\n+        ++this.top;\r\n+        return true;\r\n     } \r\n   \r\n     int pop() \r\n     { \r\n         //If empty return 0 and print \" Stack Underflow\"\r\n         //Write your code here\r\n+        if(this.isEmpty()){\r\n+            System.out.println(\"Stack Underflow\");\r\n+            return 0;\r\n+        } \r\n+        --top;\r\n+        return a[top];\r\n     } \r\n   \r\n     int peek() \r\n     { \r\n         //Write your code here\r\n+        if(this.isEmpty()) return 0;\r\n+        return a[top-1];\r\n     } \r\n } \r\n   \r\n // Driver code \r\n class Main { \r\n     public static void main(String args[]) \r\n     { \r\n-        Stack s = new Stack(); \r\n+        Stack s = new Stack();      \r\n         s.push(10); \r\n         s.push(20); \r\n         s.push(30); \r\n         System.out.println(s.pop() + \" Popped from stack\"); \r\n     } \r\n }\r\n+\r\n+/*\r\n+ *  Time Complexity: O(1) to push pop and peek for the stack as we keep the pointer to the top element. Here N is the number of elements.\r\n+ *  Space Complexity: O(N) to store all the element in the array.\r\n+ * \r\n+ *  Did this code successfully run on Leetcode : Yes\r\n+ *  Any problem you faced while coding this : None\r\n+ * \r\n+ *  Hold the pointer to the top element in the array with a variable and using that variable perform the basic operations like push pop and peek.\r\n+ */\r"
  },
  {
    "sha": "d34b2923445bd67b8130048ce0492a3d5eb2b34e",
    "filename": "Exercise_2.java",
    "status": "modified",
    "additions": 90,
    "deletions": 50,
    "changes": 140,
    "blob_url": "https://github.com/super30admin/PreCourse-1/blob/49a50c174fde30a3a51dcf41d2a92fdfa3a2f449/Exercise_2.java",
    "raw_url": "https://github.com/super30admin/PreCourse-1/raw/49a50c174fde30a3a51dcf41d2a92fdfa3a2f449/Exercise_2.java",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-1/contents/Exercise_2.java?ref=49a50c174fde30a3a51dcf41d2a92fdfa3a2f449",
    "patch": "@@ -1,52 +1,92 @@\n-public class StackAsLinkedList { \r\n-  \r\n-    StackNode root; \r\n-  \r\n-    static class StackNode { \r\n-        int data; \r\n-        StackNode next; \r\n-  \r\n-        StackNode(int data) \r\n-        { \r\n-            //Constructor here \r\n-        } \r\n-    } \r\n-    \r\n-\t\r\n-    public boolean isEmpty() \r\n-    { \r\n-        //Write your code here for the condition if stack is empty. \r\n-    } \r\n-  \r\n-    public void push(int data) \r\n-    { \r\n-        //Write code to push data to the stack. \r\n-    } \r\n-  \r\n-    public int pop() \r\n-    { \t\r\n-\t//If Stack Empty Return 0 and print \"Stack Underflow\"\r\n+import java.lang.*;\r\n+import java.util.*;\r\n+public class Exercise_2 {\r\n+\r\n+    StackNode root;\r\n+\r\n+    static class StackNode {\r\n+        int data;\r\n+        StackNode next;\r\n+\r\n+        StackNode(int data)\r\n+        {\r\n+            //Constructor here\r\n+            this.data=data;\r\n+            this.next=null;\r\n+        }\r\n+    }\r\n+\r\n+    Exercise_2(){\r\n+        this.root=null;\r\n+    }\r\n+\r\n+    public boolean isEmpty()\r\n+    {\r\n+        //Write your code here for the condition if stack is empty.\r\n+        if(root==null){\r\n+            return true;\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    public void push(int data)\r\n+    {\r\n+        //Write code to push data to the stack.\r\n+        StackNode node = new StackNode(data);\r\n+        if(isEmpty()) root=node;\r\n+        else{\r\n+            node.next = root;\r\n+            root = node;\r\n+        }\r\n+    }\r\n+\r\n+    public int pop()\r\n+    {\r\n+        //If Stack Empty Return 0 and print \"Stack Underflow\"\r\n         //Write code to pop the topmost element of stack.\r\n-\t//Also return the popped element \r\n-    } \r\n-  \r\n-    public int peek() \r\n-    { \r\n+        //Also return the popped element\r\n+        if(isEmpty()){\r\n+            System.out.println(\"Stack Underflow\");\r\n+            return 0;\r\n+        }\r\n+        int value = root.data;\r\n+        root=root.next;\r\n+        return value;\r\n+    }\r\n+\r\n+    public int peek()\r\n+    {\r\n         //Write code to just return the topmost element without removing it.\r\n-    } \r\n-  \r\n-\t//Driver code\r\n-    public static void main(String[] args) \r\n-    { \r\n-  \r\n-        StackAsLinkedList sll = new StackAsLinkedList(); \r\n-  \r\n-        sll.push(10); \r\n-        sll.push(20); \r\n-        sll.push(30); \r\n-  \r\n-        System.out.println(sll.pop() + \" popped from stack\"); \r\n-  \r\n-        System.out.println(\"Top element is \" + sll.peek()); \r\n-    } \r\n-} \r\n+        if(this.isEmpty()) {\r\n+            System.out.println(\"Stack Underflow\");\r\n+            return 0;\r\n+        }\r\n+        return root.data;\r\n+    }\r\n+\r\n+    //Driver code\r\n+    public static void main(String[] args)\r\n+    {\r\n+\r\n+        Exercise_2 sll = new Exercise_2();\r\n+\r\n+        sll.push(10);\r\n+        sll.push(20);\r\n+        sll.push(30);\r\n+\r\n+        System.out.println(sll.pop() + \" popped from stack\");\r\n+        System.out.println(\"Top element is \" + sll.peek());\r\n+    }\r\n+}\r\n+\r\n+/*\r\n+ *  Time Complexity: O(1) to push pop and peek for the stack as we keep the pointer to the top element. Here N is the number of elements.\r\n+ *  Space Complexity: O(N) to store all the element in the array.\r\n+ * \r\n+ *  Did this code successfully run on Leetcode : Yes\r\n+ *  Any problem you faced while coding this : None\r\n+ * \r\n+ *  Hold the pointer to the top element in the array with a variable and using that variable perform the basic operations like push pop and peek.\r\n+ */\r\n+\r\n+\r"
  },
  {
    "sha": "f22eb025482eb923e92e27c584c77aa4605adf82",
    "filename": "Exercise_3.java",
    "status": "modified",
    "additions": 78,
    "deletions": 49,
    "changes": 127,
    "blob_url": "https://github.com/super30admin/PreCourse-1/blob/49a50c174fde30a3a51dcf41d2a92fdfa3a2f449/Exercise_3.java",
    "raw_url": "https://github.com/super30admin/PreCourse-1/raw/49a50c174fde30a3a51dcf41d2a92fdfa3a2f449/Exercise_3.java",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-1/contents/Exercise_3.java?ref=49a50c174fde30a3a51dcf41d2a92fdfa3a2f449",
    "patch": "@@ -1,70 +1,99 @@\n-import java.io.*; \r\n-  \r\n+import java.io.*;\r\n+\r\n // Java program to implement \r\n // a Singly Linked List \r\n-public class LinkedList { \r\n-  \r\n+public class LinkedList {\r\n+\r\n     Node head; // head of list \r\n-  \r\n+\r\n     // Linked list Node. \r\n     // This inner class is made static \r\n     // so that main() can access it \r\n-    static class Node { \r\n-  \r\n-        int data; \r\n-        Node next; \r\n-  \r\n+    static class Node {\r\n+\r\n+        int data;\r\n+        Node next;\r\n+\r\n         // Constructor \r\n-        Node(int d) \r\n-        { \r\n-            //Write your code here \r\n-        } \r\n-    } \r\n-  \r\n+        Node(int d)\r\n+        {\r\n+            //Write your code here\r\n+            this.data = d;\r\n+        }\r\n+    }\r\n+\r\n     // Method to insert a new node \r\n-    public static LinkedList insert(LinkedList list, int data) \r\n-    { \r\n-        // Create a new node with given data \r\n-   \r\n+    public static LinkedList insert(LinkedList list, int data)\r\n+    {\r\n+        // Create a new node with given data\r\n+        Node newNode = new Node(data);\r\n+\r\n+        if(list.head==null){\r\n+            list.head = newNode;\r\n+            return list;\r\n+        }\r\n+        Node currNode = list.head;\r\n+        while(currNode.next!=null){\r\n+            currNode = currNode.next;\r\n+        }\r\n+        currNode.next = newNode;\r\n+\r\n+        return list;\r\n         // If the Linked List is empty, \r\n         // then make the new node as head \r\n-        \r\n-            // Else traverse till the last node \r\n-            // and insert the new_node there \r\n \r\n-            // Insert the new_node at last node \r\n+        // Else traverse till the last node\r\n+        // and insert the new_node there\r\n+\r\n+        // Insert the new_node at last node\r\n         // Return the list by head \r\n-        \r\n-    } \r\n-  \r\n+\r\n+    }\r\n+\r\n     // Method to print the LinkedList. \r\n-    public static void printList(LinkedList list) \r\n-    {  \r\n+    public static void printList(LinkedList list)\r\n+    {\r\n         // Traverse through the LinkedList \r\n-   \r\n-            // Print the data at current node \r\n-       \r\n-            // Go to next node \r\n-    } \r\n-   \r\n+        Node currNode = list.head;\r\n+        if(currNode==null) return;\r\n+        // Print the data at current node\r\n+        while(currNode!=null){\r\n+            System.out.println(currNode.data);\r\n+            currNode=currNode.next;\r\n+        }\r\n+        // Go to next node\r\n+    }\r\n+\r\n     // Driver code \r\n-    public static void main(String[] args) \r\n-    { \r\n+    public static void main(String[] args)\r\n+    {\r\n         /* Start with the empty list. */\r\n-        LinkedList list = new LinkedList(); \r\n-  \r\n+        LinkedList list = new LinkedList();\r\n+\r\n         // \r\n         // ******INSERTION****** \r\n         // \r\n-  \r\n+\r\n         // Insert the values \r\n-        list = insert(list, 1); \r\n-        list = insert(list, 2); \r\n-        list = insert(list, 3); \r\n-        list = insert(list, 4); \r\n-        list = insert(list, 5); \r\n-  \r\n+        list = insert(list, 1);\r\n+        list = insert(list, 2);\r\n+        list = insert(list, 3);\r\n+        list = insert(list, 4);\r\n+        list = insert(list, 5);\r\n+\r\n         // Print the LinkedList \r\n-        printList(list); \r\n-    } \r\n-}\n\\ No newline at end of file\n+        printList(list);\r\n+    }\r\n+}\r\n+\r\n+/*\r\n+ *  Time Complexity: O(N) for insertion as we need to traverse through the entire list to add a new element\r\n+ *  Space Complexity: O(N) to store all the node information.\r\n+ * \r\n+ *  Did this code successfully run on Leetcode : Yes\r\n+ *  Any problem you faced while coding this : None\r\n+ * \r\n+ *  Simply traverse through all the node from the head to the last and append the next element.\r\n+ */\r\n+\r\n+\r"
  },
  {
    "sha": "c3fbbd72e07f969e0df76eef7de18a3cc7eedeab",
    "filename": "Exercise_4.java",
    "status": "modified",
    "additions": 71,
    "deletions": 51,
    "changes": 122,
    "blob_url": "https://github.com/super30admin/PreCourse-1/blob/49a50c174fde30a3a51dcf41d2a92fdfa3a2f449/Exercise_4.java",
    "raw_url": "https://github.com/super30admin/PreCourse-1/raw/49a50c174fde30a3a51dcf41d2a92fdfa3a2f449/Exercise_4.java",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-1/contents/Exercise_4.java?ref=49a50c174fde30a3a51dcf41d2a92fdfa3a2f449",
    "patch": "@@ -1,59 +1,79 @@\n-import java.util.LinkedList; \r\n-import java.util.Queue; \r\n-public class GFG { \r\n-       \r\n+import java.util.LinkedList;\r\n+import java.util.Queue;\r\n+public class GFG {\r\n+\r\n     /* A binary tree node has key, pointer to  \r\n     left child and a pointer to right child */\r\n-    static class Node { \r\n-        int key; \r\n-        Node left, right; \r\n-          \r\n+    static class Node {\r\n+        int key;\r\n+        Node left, right;\r\n+\r\n         // constructor \r\n-        Node(int key){ \r\n-            this.key = key; \r\n-            left = null; \r\n-            right = null; \r\n-        } \r\n-    } \r\n-    static Node root; \r\n-    static Node temp = root; \r\n-      \r\n+        Node(int key){\r\n+            this.key = key;\r\n+            left = null;\r\n+            right = null;\r\n+        }\r\n+    }\r\n+    static Node root;\r\n+    static Node temp = root;\r\n+\r\n     /* Inorder traversal of a binary tree*/\r\n-    static void inorder(Node temp) \r\n-    { \r\n-        if (temp == null) \r\n-            return; \r\n-       \r\n-        inorder(temp.left); \r\n-        System.out.print(temp.key+\" \"); \r\n-        inorder(temp.right); \r\n-    } \r\n-       \r\n-    /*function to insert element in binary tree */\r\n-    static void insert(Node temp, int key) \r\n-    { \r\n+    static void inorder(Node temp)\r\n+    {\r\n+        if (temp == null)\r\n+            return;\r\n+\r\n+        inorder(temp.left);\r\n+        System.out.print(temp.key+\" \");\r\n+        inorder(temp.right);\r\n+    }\r\n \r\n+    /*function to insert element in binary tree */\r\n+    static void insert(Node temp, int key)\r\n+    {\r\n+        Queue<Node> queue = new LinkedList<>();\r\n+        queue.add(temp);\r\n+        Node newNode = new Node(key);\r\n+        while(!queue.isEmpty()){\r\n+            Node currNode = queue.poll();\r\n+            if(currNode.left==null) currNode.left=newNode;\r\n+            else queue.offer(temp.left);\r\n+            if(currNode.right==null) currNode.right=newNode;\r\n+            else queue.offer(temp.right);\r\n+        }\r\n         // Do level order traversal until we find \r\n         // an empty place and add the node.  \r\n-    } \r\n-       \r\n+    }\r\n+\r\n     // Driver code \r\n-    public static void main(String args[]) \r\n-    { \r\n-        root = new Node(10); \r\n-        root.left = new Node(11); \r\n-        root.left.left = new Node(7); \r\n-        root.right = new Node(9); \r\n-        root.right.left = new Node(15); \r\n-        root.right.right = new Node(8); \r\n-       \r\n-        System.out.print( \"Inorder traversal before insertion:\"); \r\n-        inorder(root); \r\n-       \r\n-        int key = 12; \r\n-        insert(root, key); \r\n-       \r\n-        System.out.print(\"\\nInorder traversal after insertion:\"); \r\n-        inorder(root); \r\n-    } \r\n-}\n\\ No newline at end of file\n+    public static void main(String args[])\r\n+    {\r\n+        root = new Node(10);\r\n+        root.left = new Node(11);\r\n+        root.left.left = new Node(7);\r\n+        root.right = new Node(9);\r\n+        root.right.left = new Node(15);\r\n+        root.right.right = new Node(8);\r\n+\r\n+        System.out.print( \"Inorder traversal before insertion:\");\r\n+        inorder(root);\r\n+\r\n+        int key = 12;\r\n+        insert(root, key);\r\n+\r\n+        System.out.print(\"\\nInorder traversal after insertion:\");\r\n+        inorder(root);\r\n+    }\r\n+}\r\n+\r\n+\r\n+/*\r\n+ *  Time Complexity: O(N) for insertion as we need to traverse through the entire list to add a new element\r\n+ *  Space Complexity: O(N) to store all the node information.\r\n+ * \r\n+ *  Did this code successfully run on Leetcode : Yes\r\n+ *  Any problem you faced while coding this : None\r\n+ * \r\n+ *  Simply traverse through all the node from the head to the last and append the next element.\r\n+ */\r"
  }
]
