[
  {
    "sha": "43d08f4813667c4f4b9e07fc1ec33f0de725944b",
    "filename": "Sample.java",
    "status": "modified",
    "additions": 133,
    "deletions": 5,
    "changes": 138,
    "blob_url": "https://github.com/super30admin/Two-Pointers-1/blob/9b71416f19ae1ea4b14feb70fcd3bec18871647b/Sample.java",
    "raw_url": "https://github.com/super30admin/Two-Pointers-1/raw/9b71416f19ae1ea4b14feb70fcd3bec18871647b/Sample.java",
    "contents_url": "https://api.github.com/repos/super30admin/Two-Pointers-1/contents/Sample.java?ref=9b71416f19ae1ea4b14feb70fcd3bec18871647b",
    "patch": "@@ -1,7 +1,135 @@\n-// Time Complexity :\r\n-// Space Complexity :\r\n-// Did this code successfully run on Leetcode :\r\n-// Any problem you faced while coding this :\r\n+// Time Complexity :O(n)\r\n+// Space Complexity :O(1)\r\n+// Did this code successfully run on Leetcode : yes\r\n+// Any problem you faced while coding this :no\r\n \r\n \r\n-// Your code here along with comments explaining your approach\n\\ No newline at end of file\n+// Your code here along with comments explaining your approach\r\n+/*\r\n+ * Keep 3 pointers -> Low(0's) High(2's) Mid(1's). Make moves based on mid values\r\n+ * when '0' it means we need to swap the mid with low, also mid can be moved -> all possible 2's will be moved to the high.\r\n+ */\r\n+\r\n+    public void sortColors(int[] nums) {\r\n+        \r\n+        if(nums==null || nums.length==0)\r\n+            return;\r\n+        \r\n+        int low = 0;\r\n+        int mid = 0;\r\n+        int high = nums.length-1;\r\n+        \r\n+        while(mid<=high){\r\n+            if(nums[mid]==0){\r\n+                swap(nums,low,mid);\r\n+                low++;\r\n+                mid++;\r\n+            }\r\n+            else if(nums[mid]==2){\r\n+                swap(nums,high,mid);\r\n+                high--;\r\n+            }\r\n+            else if(nums[mid]==1){\r\n+                mid++;\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    private void swap(int[] nums,int a, int b){\r\n+        int temp = nums[a];\r\n+        nums[a] = nums[b];\r\n+        nums[b] = temp;\r\n+    }\r\n+\r\n+ // Time Complexity :O(n^2)\r\n+ // Space Complexity :O(1) -> discarding the result list which is sent back\r\n+ // Did this code successfully run on Leetcode : yes\r\n+ // Any problem you faced while coding this :no\r\n+\r\n+\r\n+ // Your code here along with comments explaining your approach\r\n+ /*\r\n+  * A two pointer approach on each element. Considering a left and right pointer to the right of each element.\r\n+  * A current Sum is calculated by considering the current number, left number and right number.\r\n+  * A condition to handle duplicates is identified at both initial level and at the nested level.\r\n+  */\r\n+    \r\n+    public List<List<Integer>> threeSum(int[] nums) {\r\n+        List<List<Integer>> result = new ArrayList<>();\r\n+        if(nums==null || nums.length==0)\r\n+            return result;\r\n+        \r\n+\t\tArrays.sort(nums);\r\n+\t\t\r\n+\t\t\r\n+\t\t\r\n+\t\tint left = 0;\r\n+\t\tint right = 0;\r\n+        int targetSum = 0;\r\n+\t\t\r\n+\t\tfor(int cN=0;cN<nums.length-2;cN++){\r\n+            \r\n+\t\t\tleft = cN+1;\r\n+\t\t\tright = nums.length-1;\r\n+\t\t\t\r\n+            if(cN==0 || nums[cN]!=nums[cN-1]){\r\n+                while(left<right){\r\n+\t\t\t\tint cS = nums[cN]+nums[left]+nums[right];\r\n+\t\t\t\tif(cS==targetSum){\r\n+                    List<Integer> triplet = Arrays.asList(nums[cN],nums[left],nums[right]);\r\n+\t\t\t\t\tresult.add(triplet);\r\n+\t\t\t\t\tleft++;\r\n+\t\t\t\t\tright--;\r\n+                    while(left<right && nums[left]==nums[left-1])\r\n+                        left++;\r\n+                    while(left<right && nums[right]==nums[right+1])\r\n+                        right--;\r\n+\t\t\t\t}\r\n+\t\t\t\telse if(cS>targetSum)\r\n+\t\t\t\t\tright--;\r\n+\t\t\t\telse\r\n+\t\t\t\t\tleft++;\r\n+\t\t\t    }\r\n+            }\r\n+\t\t\t\r\n+\t\t}\r\n+\t\t\r\n+        return result;\r\n+    }\r\n+    \r\n+    \r\n+    // Time Complexity :O(n)\r\n+    // Space Complexity :O(1)\r\n+    // Did this code successfully run on Leetcode : yes\r\n+    // Any problem you faced while coding this :no\r\n+\r\n+\r\n+    // Your code here along with comments explaining your approach\r\n+    /*\r\n+     * A two pointer approach, calculate the area of each of the heights. Multiply height by width.\r\n+     * calculate the max area, by moving the low pointer when height of low is less than height of high.\r\n+     * Similarly reduce the high pointer when height of high is less than height of low.\r\n+     */\r\n+    \r\n+    public int maxArea(int[] height) {\r\n+        if(height==null || height.length==0)\r\n+            return 0;\r\n+        \r\n+        int low = 0;\r\n+        int high = height.length-1;\r\n+        \r\n+        int max = Integer.MIN_VALUE;\r\n+        \r\n+        while(low<high){\r\n+            max = Math.max(max,Math.min(height[low],height[high])*(high-low));\r\n+            \r\n+            if(height[low]<height[high])\r\n+                low++;\r\n+            else\r\n+                high--;\r\n+        }\r\n+        \r\n+        return max;\r\n+        \r\n+    }\r\n+ \n\\ No newline at end of file"
  }
]
