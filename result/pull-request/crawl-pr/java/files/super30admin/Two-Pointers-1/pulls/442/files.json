[
  {
    "sha": "3446d30e147a59898040efcdaafb8113050670dc",
    "filename": "3sum.java",
    "status": "added",
    "additions": 89,
    "deletions": 0,
    "changes": 89,
    "blob_url": "https://github.com/super30admin/Two-Pointers-1/blob/3e0925593eb7be81b4c0a44d2c50393f4c7d806d/3sum.java",
    "raw_url": "https://github.com/super30admin/Two-Pointers-1/raw/3e0925593eb7be81b4c0a44d2c50393f4c7d806d/3sum.java",
    "contents_url": "https://api.github.com/repos/super30admin/Two-Pointers-1/contents/3sum.java?ref=3e0925593eb7be81b4c0a44d2c50393f4c7d806d",
    "patch": "@@ -0,0 +1,89 @@\n+// Time Complexity : O(n^2*logn) for both approaches\n+// Space Complexity : O(1) for both approaches\n+// Did this code successfully run on Leetcode : Yes\n+// Any problem you faced while coding this : No\n+\n+\n+// Your code here along with comments explaining your approach\n+-------------------------------------------------------------------- Approach 1 -------------------------------------------------------------------------------\n+ class Solution {\n+    //Binary Search approach\n+    //In order to find X+Y+Z=0 , we can find Y+Z=-X;\n+    public List<List<Integer>> threeSum(int[] nums) {\n+        //{-4,-1,-1,0,0,0,1,1,2}\n+        Arrays.sort(nums);//sort the array\n+        List<List<Integer>> triplets = new ArrayList<>();\n+        \n+        for(int i=0;i<nums.length;i++){\n+            if(i>0 && nums[i]==nums[i-1]){\n+                //base condition - for not repeating elements - for outer loop\n+                continue;\n+            }\n+            searchTriplets(-nums[i],nums,i+1,triplets);\n+        }\n+        return triplets;\n+    }\n+    \n+    public static void searchTriplets(int target, int[] arr, int left, List<List<Integer>> triplets){\n+        int right = arr.length-1;\n+        while(left<right){\n+            if(arr[left]+arr[right]==target){\n+                triplets.add(Arrays.asList(-target,arr[left],arr[right]));\n+            \n+            left++;\n+            right--;\n+            while(left<right && arr[left]==arr[left-1]){\n+                //There may be case for duplicate triplet, example {0,0,1,1} -> we end up going to                      zero again - so we increment again\n+                left++;\n+            }\n+            while(left<right && arr[right]==arr[right+1]){\n+                //There may be case for duplicate triplet, example {0,0,1,1} -> we end up going to                      one again - so we decrement again\n+                right--;\n+            }\n+            }\n+            else if(arr[left]+arr[right]>target){\n+                right--;//Decrement right if sum is greater than target\n+            }\n+            else{\n+                left++; //Increment left if sum is lesser than target\n+            }\n+            \n+        }\n+    }\n+}\n+\n+-------------------------------------------------------------------- Approach 2 -----------------------------------------------------------------------------\n+  class Solution {\n+    public List<List<Integer>> threeSum(int[] nums) {\n+        //Two Pointers Approach\n+        Arrays.sort(nums);//sort the array\n+        List<List<Integer>> triplets = new ArrayList<>();\n+        \n+        for(int i=0;i<nums.length;i++){\n+            //base condition - for not repeating elements - for outer loop\n+            if(i>0 && nums[i]==nums[i-1]){\n+                continue;\n+            }\n+            int low=i+1;int high=nums.length-1;\n+            while(low<high){\n+                int sum = nums[i]+nums[low]+nums[high];\n+                if(sum==0){\n+                    triplets.add(Arrays.asList(nums[i],nums[low],nums[high]));\n+                    low++;\n+                    high--;\n+                    //There may be case for duplicate triplet, example {0,0,1,1} -> we                      end up going to zero again - so we increment again\n+                    while(low<high && nums[low]==nums[low-1]) low++;\n+                    //There may be case for duplicate triplet, example {0,0,1,1} -> we                     end up going to one again - so we decrement again\n+                    while(low<high && nums[high]==nums[high+1]) high--;\n+                }\n+                else if(sum<0){\n+                    low++;//Increment low if sum is less than target\n+                }\n+                else{\n+                    high--;//Decrement high if sum is greater than target\n+                }\n+            }\n+        }\n+        return triplets;\n+    }\n+}"
  },
  {
    "sha": "1ec755127dbcf120a8111ce586dc73c84f2d31c7",
    "filename": "container_with_most_water.java",
    "status": "added",
    "additions": 46,
    "deletions": 0,
    "changes": 46,
    "blob_url": "https://github.com/super30admin/Two-Pointers-1/blob/3e0925593eb7be81b4c0a44d2c50393f4c7d806d/container_with_most_water.java",
    "raw_url": "https://github.com/super30admin/Two-Pointers-1/raw/3e0925593eb7be81b4c0a44d2c50393f4c7d806d/container_with_most_water.java",
    "contents_url": "https://api.github.com/repos/super30admin/Two-Pointers-1/contents/container_with_most_water.java?ref=3e0925593eb7be81b4c0a44d2c50393f4c7d806d",
    "patch": "@@ -0,0 +1,46 @@\n+// Time Complexity : O(n^2) for first approach, O(n) for second approach\n+// Space Complexity : O(1) for both approaches\n+// Did this code successfully run on Leetcode : Approach 1 didn't run. Time limit exceeded. Approach 2 ran successfully\n+// Any problem you faced while coding this : No\n+\n+\n+// Your code here along with comments explaining your approach\n+---------------------------------------------------------------- Approach 1 -----------------------------------------------------------\n+  //Brute-Force\n+class Solution {\n+    public int maxArea(int[] height) {\n+        if(height==null || height.length==0) return 0;\n+        int max=0;\n+        for(int i=0;i<height.length-1;i++){\n+            for(int j=i+1;j<height.length;j++){\n+                max = Math.max(max,Math.min(height[i],height[j])*(j-i));\n+            }\n+        }\n+        return max;\n+    }\n+}\n+\n+------------------------------------------------------------- Approach 2 -----------------------------------------------------------------\n+ class Solution {\n+    public int maxArea(int[] height) {\n+        //Basic checking\n+        if(height==null || height.length==0) return 0;\n+        \n+        int low=0; int high = height.length-1;\n+        int max=0;\n+        //Binary search approach\n+        //At every point we move away from the lower height to increase our chances of                  maximizing the area\n+        while(low<=high){\n+           //Area should be calculated as prouduct of min between two heights and diff b/w indices\n+           max = Math.max(max,Math.min(height[low],height[high])*(high-low));\n+           //If high is less, move away from high;\n+           if(height[low]>height[high]){\n+               high--;\n+           }\n+           else{\n+               low++;\n+           }\n+        }\n+        return max;\n+    }\n+}"
  },
  {
    "sha": "bc71d9d2b12e4fd92e8087348b5fd5125ae5a197",
    "filename": "sort-colors.java",
    "status": "added",
    "additions": 35,
    "deletions": 0,
    "changes": 35,
    "blob_url": "https://github.com/super30admin/Two-Pointers-1/blob/3e0925593eb7be81b4c0a44d2c50393f4c7d806d/sort-colors.java",
    "raw_url": "https://github.com/super30admin/Two-Pointers-1/raw/3e0925593eb7be81b4c0a44d2c50393f4c7d806d/sort-colors.java",
    "contents_url": "https://api.github.com/repos/super30admin/Two-Pointers-1/contents/sort-colors.java?ref=3e0925593eb7be81b4c0a44d2c50393f4c7d806d",
    "patch": "@@ -0,0 +1,35 @@\n+class Solution {\n+    \n+  //swapping technique\n+    public static void swap(int[] nums,int i, int j){\n+        int temp=nums[i];\n+        nums[i]=nums[j];\n+        nums[j]=temp;\n+    }\n+    public void sortColors(int[] nums) {\n+        \n+        //Dutch Flag algorithm - Three pointers approach\n+        int low = 0;\n+        int high=nums.length-1;\n+        int mid=0;//third-pointer\n+        \n+        //Traverse until mid is less than or equal to high\n+        while(mid<=high){\n+            //if 2 is at any place of mid, we sap it to end\n+            if(nums[mid]==2){\n+                swap(nums,mid,high);\n+                high--;\n+            }\n+          //for 1 , we just move the mid pointer\n+            else if(nums[mid]==1){\n+                mid++;\n+            }\n+          //for 0, we swap mid with low pointer such that o's are always at starting\n+            else{\n+                swap(nums,mid,low);\n+                low++;\n+                mid++;\n+            }\n+        }\n+    }\n+}"
  }
]
