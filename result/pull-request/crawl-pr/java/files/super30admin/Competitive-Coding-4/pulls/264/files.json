[
  {
    "sha": "e568208f7a3f017521ecf1349671512c5dd4b29b",
    "filename": "balanced_binary_tree.java",
    "status": "added",
    "additions": 36,
    "deletions": 0,
    "changes": 36,
    "blob_url": "https://github.com/super30admin/Competitive-Coding-4/blob/7c025310e6f0cdf160570ed5ca72d2f3d33cf5eb/balanced_binary_tree.java",
    "raw_url": "https://github.com/super30admin/Competitive-Coding-4/raw/7c025310e6f0cdf160570ed5ca72d2f3d33cf5eb/balanced_binary_tree.java",
    "contents_url": "https://api.github.com/repos/super30admin/Competitive-Coding-4/contents/balanced_binary_tree.java?ref=7c025310e6f0cdf160570ed5ca72d2f3d33cf5eb",
    "patch": "@@ -0,0 +1,36 @@\n+// Time Complexity : O(n) where n is number of nodes in tree\n+// Space Complexity : O(n) , space occupied by recursion stack\n+// Did this code successfully run on Leetcode : Yes\n+// Any problem you faced while coding this : No\n+\n+\n+// Your code here along with comments explaining your approach\n+\n+//-> Recursive Approach  - Top down approach\n+class Solution {\n+    public boolean isBalanced(TreeNode root) {\n+        if(root==null) return true;\n+        \n+        //check for height of left and right subtree at each node and proceed further down if condition of difference not greater than 1 satisfies.\n+        return (Math.abs(height(root.left) - height(root.right))<=1) && isBalanced(root.left) && isBalanced(root.right);\n+        \n+    }\n+    \n+  //code for checking height of a node\n+    private int height(TreeNode root){\n+        if(root==null) return -1;\n+        \n+        int left=0;\n+        int right=0;\n+        \n+        if(root.left!=null){\n+            left=1+height(root.left);//height of left subtree\n+        }\n+        \n+        if(root.right!=null){\n+            right=1+height(root.right);//height of right subtree\n+        }\n+        \n+        return Math.max(left,right);//maximum height of a node \n+    }\n+}"
  },
  {
    "sha": "3c9a211969a4ce4f9815f6ef55874ef5e01f13e1",
    "filename": "palindrome_linked_list.java",
    "status": "added",
    "additions": 94,
    "deletions": 0,
    "changes": 94,
    "blob_url": "https://github.com/super30admin/Competitive-Coding-4/blob/7c025310e6f0cdf160570ed5ca72d2f3d33cf5eb/palindrome_linked_list.java",
    "raw_url": "https://github.com/super30admin/Competitive-Coding-4/raw/7c025310e6f0cdf160570ed5ca72d2f3d33cf5eb/palindrome_linked_list.java",
    "contents_url": "https://api.github.com/repos/super30admin/Competitive-Coding-4/contents/palindrome_linked_list.java?ref=7c025310e6f0cdf160570ed5ca72d2f3d33cf5eb",
    "patch": "@@ -0,0 +1,94 @@\n+// Time Complexity : ~O(n) for both approaches\n+// Space Complexity : O(n) for 1st approach, O(1) for second approach\n+// Did this code successfully run on Leetcode : Yes\n+// Any problem you faced while coding this : No\n+\n+\n+// Your code here along with comments explaining your approach\n+---------------------------------------------------------------------------Approach 1 ---------------------------------------------------------------------------\n+class Solution {\n+    public boolean isPalindrome(ListNode head) {\n+    //Taking two pointers pointing to head\n+    ListNode curr = head;\n+    ListNode curr2 = head;\n+    \n+    //We will be using stack for both inserting elements and comparing while popping from the stack.\n+    Stack<Integer> stack = new Stack<>();\n+    \n+    //Pushing into the stack\n+    while(curr!=null){\n+        stack.push(curr.val);\n+        curr = curr.next;\n+    }\n+    \n+      //At any point, if value popped is not equal to element from start/head of linked list, we return false\n+    while(curr2!=null){\n+        if(curr2.val!=stack.pop()){\n+            return false;\n+            //break;\n+        }\n+        curr2 = curr2.next;\n+    }\n+    \n+    return true;\n+  }\n+}\n+\n+---------------------------------------------------------------- Approach 2----------------------------------------------------------------\n+  // This involves finding the mid point first and then reveresing the second part after mid. Finally we compare reversed second half with first half.\n+  class Solution {\n+    public boolean isPalindrome(ListNode head) {\n+        //Using mid and reverse approach\n+        if(head==null || head.next==null) return true;\n+        ListNode mid = mid(head);//store mid of linked list in mid\n+        ListNode newHead = mid.next;\n+        mid.next=null;//removing the connection from first half and second half\n+        \n+        ListNode first = head;\n+        ListNode second = reverse(newHead);//reversing the second part, code below\n+        \n+        //At any point, if element from second half of linked list is not equal to first part, we return false\n+        while(second!=null){\n+            if(first.val!=second.val){\n+                return false;\n+                //break;\n+            }\n+            first = first.next;\n+            second = second.next;\n+        }\n+        return true;\n+    }\n+    \n+    //Code for reversing the second half of linked list\n+    public ListNode reverse(ListNode head){\n+        if(head==null || head.next==null) return head;\n+        \n+        ListNode prev = null;\n+        ListNode next;\n+        ListNode curr = head;\n+        \n+        while(curr!=null){\n+            next = curr.next;\n+            curr.next = prev;\n+            prev = curr;\n+            curr = next;\n+        }\n+        \n+        return prev;\n+    }\n+    \n+    //Code for finding the mid of linkedlist - two pointers approach\n+    public ListNode mid(ListNode head){\n+        if(head==null || head.next==null) return head;\n+        \n+        ListNode fast = head;\n+        ListNode slow = head;\n+        \n+        while(fast.next!=null && fast.next.next!=null){\n+            fast = fast.next.next;\n+            slow = slow.next;\n+        }\n+        \n+        return slow;\n+    }\n+}"
  }
]
