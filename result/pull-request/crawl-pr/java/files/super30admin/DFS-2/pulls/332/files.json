[
  {
    "sha": "0f2b0109be041ba752ab30569bb54b9ed398b92e",
    "filename": "DecodeStrings.py",
    "status": "added",
    "additions": 62,
    "deletions": 0,
    "changes": 62,
    "blob_url": "https://github.com/super30admin/DFS-2/blob/b555f27c2f584af4c8a8ad449434469af3019b26/DecodeStrings.py",
    "raw_url": "https://github.com/super30admin/DFS-2/raw/b555f27c2f584af4c8a8ad449434469af3019b26/DecodeStrings.py",
    "contents_url": "https://api.github.com/repos/super30admin/DFS-2/contents/DecodeStrings.py?ref=b555f27c2f584af4c8a8ad449434469af3019b26",
    "patch": "@@ -0,0 +1,62 @@\n+# TC: O(n * maxk)\n+# SC: O(n)\n+# LeetCode: Y(https://leetcode.com/problems/decode-string/)\n+# Approach: Use two stack to push numbers and current string\n+#           Decode only when ] is seen\n+#           Continue building the number till [ is seen\n+#           [ => push number and current string\n+#           character -> append to current string\n+class Solution:\n+    def decodeString(self, s: str) -> str:\n+        \n+        # base case\n+        if ((not s) or (len(s) == 0)):\n+            return s\n+        \n+        # track current string\n+        currentString = \"\"\n+        \n+        # numbersStack\n+        numStack = []\n+        \n+        # stringsStack\n+        stringStack = []\n+        \n+        # num\n+        num = 0\n+        \n+        # lopp through the string\n+        for c in s:\n+            \n+            # if current character is digit then continue building num\n+            if c.isdigit():\n+                num = num * 10 + int(c)\n+            \n+            # if '[' => push num, current string and reset them\n+            elif c == '[':\n+                numStack.append(num)\n+                stringStack.append(currentString)\n+                num = 0\n+                currentString = \"\"\n+            \n+            # if ']' => start decoding\n+            elif c == ']':\n+                # get the number to multiply with current string\n+                multiplier = numStack.pop()\n+                \n+                # concatenate the current string with itself multiplier times\n+                newString = currentString * multiplier\n+                \n+                # append the newly built string to previously built string and store it as current string \n+                currentString = stringStack.pop() + newString\n+            \n+            # append current character to current string\n+            else:\n+                currentString += c\n+          \n+        # return the computed current string at end\n+        return currentString\n+                \n+                \n+                \n+        "
  },
  {
    "sha": "fd783fa250ee7ddd11999cb7ca0755f6d368ad1b",
    "filename": "NumberOfIslandsI.java",
    "status": "added",
    "additions": 68,
    "deletions": 0,
    "changes": 68,
    "blob_url": "https://github.com/super30admin/DFS-2/blob/b555f27c2f584af4c8a8ad449434469af3019b26/NumberOfIslandsI.java",
    "raw_url": "https://github.com/super30admin/DFS-2/raw/b555f27c2f584af4c8a8ad449434469af3019b26/NumberOfIslandsI.java",
    "contents_url": "https://api.github.com/repos/super30admin/DFS-2/contents/NumberOfIslandsI.java?ref=b555f27c2f584af4c8a8ad449434469af3019b26",
    "patch": "@@ -0,0 +1,68 @@\n+/**\n+ * Time Complexity = O(M x N)\n+ * Space Complexity = O(M x N)\n+ * LeetCode: Y(https://leetcode.com/problems/number-of-islands)\n+ * Approach: \n+ *    Do the DFS to mark all pieces of land of an island as visited as they are part of the same island\n+ *    Traverse the grid, perform a DFS when you see a piece of land,\n+ *    When you see a piece of land mark the land as visited\n+ *    Do this for all the islands\n+ */\n+\n+class Solution {\n+    public int numIslands(char[][] grid) {\n+        // variable to track number of islands\n+        int numberOfIslands = 0;\n+        \n+        // 2d matrix to track the land pieces already considered as a part of some island\n+        boolean[][] visited = new boolean[grid.length][grid[0].length];\n+        \n+        // Loop through the grid\n+        for(int i = 0 ; i < grid.length ; i++) {\n+            for(int j = 0 ; j < grid[0].length ; j++) {\n+                // if there is a piece of land that is not visited then increment numberOfIslands and perform DFS on its neighboring cells\n+                if(grid[i][j] == '1' && !visited[i][j]) {\n+                    // increment numberOfIslands\n+                    numberOfIslands++;\n+                    \n+                    // perform DFS on its neighboring cells\n+                    doDFSUtil(grid, i, j, visited);\n+                }\n+            }\n+        }\n+        \n+        return numberOfIslands;\n+    }\n+    \n+    /* Helper function to perform DFS */\n+    private void doDFSUtil(char[][] grid, int row, int col, boolean[][] visited) {\n+        \n+        // if the grid position is not valid or the grid position is water or the grid position is land already seen\n+        if(!isGridPositionValid(row, col, grid.length, grid[0].length) || grid[row][col] == '0' || visited[row][col]) {\n+            return;\n+        }\n+        \n+        // mark the current piece of land as visited\n+        visited[row][col] = true;\n+        \n+        // / dirs array to look in the 4 neighboring grid positions\n+        int[] dirs = {-1, 0, 1, 0, -1};\n+\n+        // Look in all 4 directions\n+        for(int i = 0 ; i < 4 ; i++) {\n+            // get row number of neighboring cell position\n+            int neighborRow = row + dirs[i];\n+            \n+            // get col number of neighboring cell position\n+            int neighborCol = col + dirs[i + 1];\n+            \n+            // Explore neighboring grid position with DFS\n+            doDFSUtil(grid, neighborRow, neighborCol, visited);\n+        }\n+    }\n+    \n+     /* Helper function to check if the current pixel is within the dimensions of the matrix */\n+    private boolean isGridPositionValid(int row, int col, int rows, int cols) {\n+        return (row >= 0 && row < rows && col >= 0 && col < cols);\n+    }\n+}"
  },
  {
    "sha": "b903152a573249190a60e4766d57a3e5898df82e",
    "filename": "NumberOfIslandsQ.java",
    "status": "added",
    "additions": 88,
    "deletions": 0,
    "changes": 88,
    "blob_url": "https://github.com/super30admin/DFS-2/blob/b555f27c2f584af4c8a8ad449434469af3019b26/NumberOfIslandsQ.java",
    "raw_url": "https://github.com/super30admin/DFS-2/raw/b555f27c2f584af4c8a8ad449434469af3019b26/NumberOfIslandsQ.java",
    "contents_url": "https://api.github.com/repos/super30admin/DFS-2/contents/NumberOfIslandsQ.java?ref=b555f27c2f584af4c8a8ad449434469af3019b26",
    "patch": "@@ -0,0 +1,88 @@\n+/**\n+ * Time Complexity = O(M x N)\n+ * Space Complexity = O(min(M,N))\n+ * LeetCode: Y(https://leetcode.com/problems/number-of-islands)\n+ * Approach: \n+ *    Do the BFS to mark all pieces of land of an island as visited as they are part of the same island\n+ *    Traverse the grid, perform a BFS when you see a piece of land,\n+ *    When you see a piece of land mark the land as visited\n+ *    Do this for all the islands\n+ */\n+\n+class Solution {\n+    public int numIslands(char[][] grid) {\n+        // variable to track number of islands\n+        int numberOfIslands = 0;\n+        \n+        // 2d matrix to track the land pieces already considered as a part of some island\n+        boolean[][] visited = new boolean[grid.length][grid[0].length];\n+        \n+        // Loop through the grid\n+        for(int i = 0 ; i < grid.length ; i++) {\n+            for(int j = 0 ; j < grid[0].length ; j++) {\n+                // if there is a piece of land that is not visited then increment numberOfIslands and perform BFS on its neighboring cells\n+                if(grid[i][j] == '1' && !visited[i][j]) {\n+                    // increment numberOfIslands\n+                    numberOfIslands++;\n+                    \n+                    // perform BFS on its neighboring cells\n+                    doBFSUtil(grid, i, j, visited);\n+                }\n+            }\n+        }\n+        return numberOfIslands;\n+    }\n+    \n+    /* Helper function to perform BFS */\n+    private void doBFSUtil(char[][] grid, int row, int col, boolean[][] visited) {\n+        \n+        // initialize queue to perform BFS from grid[row][col]\n+        Queue<Integer> q = new LinkedList<Integer>();\n+        \n+        // get total number of columns in the grid\n+        int numOfCols = grid[0].length;\n+        \n+        // mark the current piece of land as visited\n+        visited[row][col] = true;\n+        \n+        // enqueue source grid position\n+        q.add(row * numOfCols + col);\n+        \n+        // loop until all the adjacent land pieces are visited\n+        while(!q.isEmpty()) {\n+            // get the current cell from front of queue\n+            int currentCell = q.poll();\n+            \n+            // extract row number of current cell\n+            int currentRow = currentCell / numOfCols;\n+            \n+            // extract col number of current cell\n+            int currentCol = currentCell % numOfCols;\n+            \n+            // dirs array to look in the 4 neighboring grid positions\n+            int[] dirs = {-1, 0, 1, 0, -1};\n+\n+            // Look in all 4 directions\n+            for(int i = 0 ; i < 4 ; i++) {\n+                // get row number of neighboring cell position\n+                int neighborRow = currentRow + dirs[i];\n+\n+                // get col number of neighboring cell position\n+                int neighborCol = currentCol + dirs[i + 1];\n+\n+                // check if the neighboring grid position is valid and neighboring grid position is land not visited \n+                if(isGridPositionValid(neighborRow, neighborCol, grid.length, grid[0].length) && grid[neighborRow][neighborCol] == '1' && !visited[neighborRow][neighborCol]) {\n+                    // mark the land piece as visited\n+                    visited[neighborRow][neighborCol] = true;\n+                    // enqueue the grid position\n+                    q.add(neighborRow * numOfCols + neighborCol);\n+                }\n+            }\n+        }\n+    }\n+    \n+     /* Helper function to check if the current pixel is within the dimensions of the matrix */\n+    private boolean isGridPositionValid(int row, int col, int rows, int cols) {\n+        return (row >= 0 && row < rows && col >= 0 && col < cols);\n+    }\n+}"
  }
]
