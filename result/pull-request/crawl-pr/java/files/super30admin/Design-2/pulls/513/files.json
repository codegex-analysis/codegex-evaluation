[
  {
    "sha": "5a9599424fd80dd74cece63c7836ed884d2bf136",
    "filename": "MyHashSet.java",
    "status": "added",
    "additions": 63,
    "deletions": 0,
    "changes": 63,
    "blob_url": "https://github.com/super30admin/Design-2/blob/0eb58f01faeb570ac086b2429f5b98963d65de0a/MyHashSet.java",
    "raw_url": "https://github.com/super30admin/Design-2/raw/0eb58f01faeb570ac086b2429f5b98963d65de0a/MyHashSet.java",
    "contents_url": "https://api.github.com/repos/super30admin/Design-2/contents/MyHashSet.java?ref=0eb58f01faeb570ac086b2429f5b98963d65de0a",
    "patch": "@@ -0,0 +1,63 @@\n+/*\n+ *  Time Complexity: O(1) for add, remove and contains operation since we are storing that info in the 2d array, we just need to calculate the hashKeys which takes constant time.\n+ *  Space Complexity: O(N) to store all the element in the 2d array.\n+ * \n+ *  Did this code successfully run on Leetcode : Yes\n+ *  Any problem you faced while coding this : None\n+ * \n+ *  Identify the bucket using the modulo function, then identify the bucket item index with the divide function, then mark that element in the 2d array with true. In order to remove the element we can remove mark the element as false. \n+ */\n+\n+class MyHashSet {\n+\n+    /** Initialize your data structure here. */\n+    int buckets;\n+    int bucketItems;\n+    boolean[][] hashSet;\n+    public MyHashSet() {\n+        this.buckets=1000;\n+        this.bucketItems=1001;\n+        hashSet = new boolean[buckets][];\n+    }\n+    \n+    private int getBucket(int key){\n+        return key%this.buckets;\n+    }\n+    \n+    private int getBucketItem(int key){\n+        return key/this.bucketItems;\n+    }\n+    \n+    public void add(int key) {\n+        int bucketIndex = getBucket(key);\n+        int bucketItemIndex = getBucketItem(key);\n+        if(hashSet[bucketIndex]==null) hashSet[bucketIndex] = new boolean[bucketItems];\n+        \n+        hashSet[bucketIndex][bucketItemIndex] = true;\n+    }\n+    \n+    public void remove(int key) {\n+        int bucketIndex = getBucket(key);\n+        int bucketItemIndex = getBucketItem(key);\n+        if(hashSet[bucketIndex]==null) \n+            return;\n+        hashSet[bucketIndex][bucketItemIndex] = false;\n+    }\n+    \n+    /** Returns true if this set contains the specified element */\n+    public boolean contains(int key) {\n+        int bucketIndex = getBucket(key);\n+        int bucketItemIndex = getBucketItem(key);\n+        if(hashSet[bucketIndex]==null) \n+            return false;\n+        return hashSet[bucketIndex][bucketItemIndex]; \n+    }\n+}\n+\n+/**\n+ * Your MyHashSet object will be instantiated and called as such:\n+ * MyHashSet obj = new MyHashSet();\n+ * obj.add(key);\n+ * obj.remove(key);\n+ * boolean param_3 = obj.contains(key);\n+ */"
  },
  {
    "sha": "f7a0cdbeea8f12eac4115b8463187f58be94e69d",
    "filename": "MyQueue.java",
    "status": "added",
    "additions": 57,
    "deletions": 0,
    "changes": 57,
    "blob_url": "https://github.com/super30admin/Design-2/blob/0eb58f01faeb570ac086b2429f5b98963d65de0a/MyQueue.java",
    "raw_url": "https://github.com/super30admin/Design-2/raw/0eb58f01faeb570ac086b2429f5b98963d65de0a/MyQueue.java",
    "contents_url": "https://api.github.com/repos/super30admin/Design-2/contents/MyQueue.java?ref=0eb58f01faeb570ac086b2429f5b98963d65de0a",
    "patch": "@@ -0,0 +1,57 @@\n+/*\n+ *  Time Complexity: O(1) for push and O(N) for pop and peek operation since we have to move all the elements from in stack to out stack.\n+ *  Space Complexity: O(N) to store all the element in the stack.\n+ * \n+ *  Did this code successfully run on Leetcode : Yes\n+ *  Any problem you faced while coding this : None\n+ * \n+ *  Push all the elements in an in stack always. If there is a pop or peek operation we move all the elements in in stack to out stack and pop or peek the top elements. We then carry out all the pop operation in the out stacks untill we run out of elements, if we run out of elements we then push all the elements from in to out stack and continue.\n+ */\n+\n+class MyQueue {\n+\n+    /** Initialize your data structure here. */\n+    Stack<Integer> inStack;\n+    Stack<Integer> outStack;\n+    public MyQueue() {\n+        inStack = new Stack();\n+        outStack = new Stack();\n+    }\n+    \n+    /** Push element x to the back of queue. */\n+    public void push(int x) {\n+        inStack.push(x);\n+    }\n+    \n+    /** Removes the element from in front of queue and returns that element. */\n+    public int pop() {\n+        if(this.empty()) return -1;\n+        peek();\n+        return outStack.pop();\n+    }\n+    \n+    /** Get the front element. */\n+    public int peek() {\n+        if(this.empty()) return -1;\n+        if(outStack.isEmpty()){\n+            while(!inStack.isEmpty()){\n+                outStack.push(inStack.pop());\n+            }    \n+        }\n+        return outStack.peek();\n+    }\n+    \n+    /** Returns whether the queue is empty. */\n+    public boolean empty() {\n+        return inStack.isEmpty() && outStack.isEmpty();\n+    }\n+}\n+\n+/**\n+ * Your MyQueue object will be instantiated and called as such:\n+ * MyQueue obj = new MyQueue();\n+ * obj.push(x);\n+ * int param_2 = obj.pop();\n+ * int param_3 = obj.peek();\n+ * boolean param_4 = obj.empty();\n+ */"
  }
]
