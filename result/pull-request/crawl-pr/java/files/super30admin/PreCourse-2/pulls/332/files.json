[
  {
    "sha": "a6dc14ccab2fca9f0a707786de3af47e3451a166",
    "filename": "Exercise_1.cpp",
    "status": "removed",
    "additions": 0,
    "deletions": 21,
    "changes": 21,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_1.cpp",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_1.cpp",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_1.cpp?ref=40d045818153d3ae141c5612ae6feb348acfe4c4",
    "patch": "@@ -1,21 +0,0 @@\n-#include <stdio.h> \r\n-  \r\n-// A recursive binary search function. It returns \r\n-// location of x in given array arr[l..r] is present, \r\n-// otherwise -1 \r\n-int binarySearch(int arr[], int l, int r, int x) \r\n-{   \r\n-    //Your Code here \r\n-} \r\n-  \r\n-int main(void) \r\n-{ \r\n-    int arr[] = { 2, 3, 4, 10, 40 }; \r\n-    int n = sizeof(arr) / sizeof(arr[0]); \r\n-    int x = 10; \r\n-    int result = binarySearch(arr, 0, n - 1, x); \r\n-    (result == -1) ? printf(\"Element is not present in array\") \r\n-                   : printf(\"Element is present at index %d\", \r\n-                            result); \r\n-    return 0; \r\n-} \n\\ No newline at end of file"
  },
  {
    "sha": "584cdd57a472bb4f755c855ad54ccf1190b13f5e",
    "filename": "Exercise_1.java",
    "status": "modified",
    "additions": 37,
    "deletions": 17,
    "changes": 54,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/005fecd6b326c665858df81df8f1c1ea9408ac0f/Exercise_1.java",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/005fecd6b326c665858df81df8f1c1ea9408ac0f/Exercise_1.java",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_1.java?ref=005fecd6b326c665858df81df8f1c1ea9408ac0f",
    "patch": "@@ -1,21 +1,41 @@\n-class BinarySearch { \r\n+// Time Complexity : O(log n) as the given array is divided into two parts at each step of execution.\r\n+// Space Complexity : O(1) as no extra space is used.\r\n+// Did this code successfully run on Leetcode : yes\r\n+// Any problem you faced while coding this : No\r\n+// Your code here along with comments explaining your approach\r\n+class BinarySearch {\r\n     // Returns index of x if it is present in arr[l.. r], else return -1 \r\n-    int binarySearch(int arr[], int l, int r, int x) \r\n-    { \r\n+    int binarySearch(int arr[], int l, int r, int x)\r\n+    {\r\n         //Write your code here\r\n-    } \r\n-  \r\n-    // Driver method to test above \r\n-    public static void main(String args[]) \r\n-    { \r\n-        BinarySearch ob = new BinarySearch(); \r\n-        int arr[] = { 2, 3, 4, 10, 40 }; \r\n-        int n = arr.length; \r\n-        int x = 10; \r\n-        int result = ob.binarySearch(arr, 0, n - 1, x); \r\n-        if (result == -1) \r\n-            System.out.println(\"Element not present\"); \r\n+        if(l <= r) {\r\n+            int mid = (l + r) - l / 2;\r\n+            if (arr[mid] == x) {\r\n+                return mid;\r\n+            }\r\n+            if (x < arr[mid]) {\r\n+                return binarySearch(arr, l, mid - 1, x);\r\n+            }\r\n+            else{\r\n+                return binarySearch(arr, mid + 1, r, x);\r\n+            }\r\n+        }\r\n+\r\n+        return -1;\r\n+\r\n+    }\r\n+\r\n+    // Driver method to test above\r\n+    public static void main(String args[])\r\n+    {\r\n+        BinarySearch ob = new BinarySearch();\r\n+        int arr[] = { 2, 3, 4, 10, 40 };\r\n+        int n = arr.length;\r\n+        int x = 10;\r\n+        int result = ob.binarySearch(arr, 0, n - 1, x);\r\n+        if (result == -1)\r\n+            System.out.println(\"Element not present\");\r\n         else\r\n-            System.out.println(\"Element found at index \" + result); \r\n-    } \r\n+            System.out.println(\"Element found at index \" + result);\r\n+    }\r\n } \r"
  },
  {
    "sha": "3e6adcf443e2b8b54475554e6f1b74741879fbe1",
    "filename": "Exercise_1.py",
    "status": "removed",
    "additions": 0,
    "deletions": 22,
    "changes": 22,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_1.py",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_1.py",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_1.py?ref=40d045818153d3ae141c5612ae6feb348acfe4c4",
    "patch": "@@ -1,22 +0,0 @@\n-# Python code to implement iterative Binary  \n-# Search. \n-  \n-# It returns location of x in given array arr  \n-# if present, else returns -1 \n-def binarySearch(arr, l, r, x): \n-  \n-  #write your code here\n-  \n-    \n-  \n-# Test array \n-arr = [ 2, 3, 4, 10, 40 ] \n-x = 10\n-  \n-# Function call \n-result = binarySearch(arr, 0, len(arr)-1, x) \n-  \n-if result != -1: \n-    print \"Element is present at index % d\" % result \n-else: \n-    print \"Element is not present in array\""
  },
  {
    "sha": "c90e577e4a03ac9dbbba0683b8d8cd18fb6bbf38",
    "filename": "Exercise_2.cpp",
    "status": "removed",
    "additions": 0,
    "deletions": 47,
    "changes": 47,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_2.cpp",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_2.cpp",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_2.cpp?ref=40d045818153d3ae141c5612ae6feb348acfe4c4",
    "patch": "@@ -1,47 +0,0 @@\n-#include <bits/stdc++.h> \r\n-using namespace std;  \r\n-  \r\n-// A utility function to swap two elements  \r\n-void swap(int* a, int* b)  \r\n-{  \r\n-    //Your Code here \r\n-}  \r\n-  \r\n-/* This function takes last element as pivot, places  \r\n-the pivot element at its correct position in sorted  \r\n-array, and places all smaller (smaller than pivot)  \r\n-to left of pivot and all greater elements to right  \r\n-of pivot */\r\n-int partition (int arr[], int low, int high)  \r\n-{  \r\n-    //Your Code here \r\n-}  \r\n-  \r\n-/* The main function that implements QuickSort  \r\n-arr[] --> Array to be sorted,  \r\n-low --> Starting index,  \r\n-high --> Ending index */\r\n-void quickSort(int arr[], int low, int high)  \r\n-{  \r\n-    //Your Code here \r\n-}  \r\n-  \r\n-/* Function to print an array */\r\n-void printArray(int arr[], int size)  \r\n-{  \r\n-    int i;  \r\n-    for (i = 0; i < size; i++)  \r\n-        cout << arr[i] << \" \";  \r\n-    cout << endl;  \r\n-}  \r\n-  \r\n-// Driver Code \r\n-int main()  \r\n-{  \r\n-    int arr[] = {10, 7, 8, 9, 1, 5};  \r\n-    int n = sizeof(arr) / sizeof(arr[0]);  \r\n-    quickSort(arr, 0, n - 1);  \r\n-    cout << \"Sorted array: \\n\";  \r\n-    printArray(arr, n);  \r\n-    return 0;  \r\n-}  \n\\ No newline at end of file"
  },
  {
    "sha": "51fe04942764c4f17ca271170a3fa5ba4555b48a",
    "filename": "Exercise_2.java",
    "status": "modified",
    "additions": 67,
    "deletions": 43,
    "changes": 110,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/005fecd6b326c665858df81df8f1c1ea9408ac0f/Exercise_2.java",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/005fecd6b326c665858df81df8f1c1ea9408ac0f/Exercise_2.java",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_2.java?ref=005fecd6b326c665858df81df8f1c1ea9408ac0f",
    "patch": "@@ -1,48 +1,72 @@\n-class QuickSort \r\n-{ \r\n-    /* This function takes last element as pivot, \r\n-       places the pivot element at its correct \r\n-       position in sorted array, and places all \r\n-       smaller (smaller than pivot) to left of \r\n-       pivot and all greater elements to right \r\n+// Time Complexity : O(n^2)\r\n+// Space Complexity : O(1) as no extra space is used.\r\n+// Did this code successfully run on Leetcode : No couldn't find in LeetCode, but executed successfully in IDE\r\n+// Any problem you faced while coding this : No\r\n+// Your code here along with comments explaining your approach\r\n+class QuickSort\r\n+{\r\n+    /* This function takes last element as pivot,\r\n+       places the pivot element at its correct\r\n+       position in sorted array, and places all\r\n+       smaller (smaller than pivot) to left of\r\n+       pivot and all greater elements to right\r\n        of pivot */\r\n     void swap(int arr[],int i,int j){\r\n-        //Your code here   \r\n+        //Your code here\r\n+        int temp;\r\n+        temp = arr[i];\r\n+        arr[i] = arr[j];\r\n+        arr[j] = temp;\r\n     }\r\n-    \r\n-    int partition(int arr[], int low, int high) \r\n-    { \r\n-   \t//Write code here for Partition and Swap \r\n-    } \r\n-    /* The main function that implements QuickSort() \r\n-      arr[] --> Array to be sorted, \r\n-      low  --> Starting index, \r\n+\r\n+    int partition(int arr[], int low, int high)\r\n+    {\r\n+        //Write code here for Partition and Swap\r\n+        int pivot = arr[high];\r\n+        int ptr1 = low-1;\r\n+        for(int ptr2=low; ptr2<high; ptr2++){\r\n+            if(arr[ptr2] <= pivot){\r\n+                ptr1++;\r\n+                swap(arr,ptr1,ptr2);\r\n+            }\r\n+        }\r\n+        swap(arr,ptr1+1,high);\r\n+        return ptr1+1;\r\n+    }\r\n+    /* The main function that implements QuickSort()\r\n+      arr[] --> Array to be sorted,\r\n+      low  --> Starting index,\r\n       high  --> Ending index */\r\n-    void sort(int arr[], int low, int high) \r\n-    {  \r\n-            // Recursively sort elements before \r\n-            // partition and after partition \r\n-    } \r\n-  \r\n+    void sort(int arr[], int low, int high)\r\n+    {\r\n+        // Recursively sort elements before\r\n+        // partition and after partition\r\n+        if(low < high){\r\n+            int piv = partition(arr,low,high);\r\n+            sort(arr,low,piv-1);\r\n+            sort(arr,piv+1,high);\r\n+        }\r\n+    }\r\n+\r\n     /* A utility function to print array of size n */\r\n-    static void printArray(int arr[]) \r\n-    { \r\n-        int n = arr.length; \r\n-        for (int i=0; i<n; ++i) \r\n-            System.out.print(arr[i]+\" \"); \r\n-        System.out.println(); \r\n-    } \r\n-  \r\n-    // Driver program \r\n-    public static void main(String args[]) \r\n-    { \r\n-        int arr[] = {10, 7, 8, 9, 1, 5}; \r\n-        int n = arr.length; \r\n-  \r\n-        QuickSort ob = new QuickSort(); \r\n-        ob.sort(arr, 0, n-1); \r\n-  \r\n-        System.out.println(\"sorted array\"); \r\n-        printArray(arr); \r\n-    } \r\n-} \r\n+    static void printArray(int arr[])\r\n+    {\r\n+        int n = arr.length;\r\n+        for (int i=0; i<n; ++i)\r\n+            System.out.print(arr[i]+\" \");\r\n+        System.out.println();\r\n+    }\r\n+\r\n+    // Driver program\r\n+    public static void main(String args[])\r\n+    {\r\n+        int arr[] = {10, 7, 8, 9, 1, 5};\r\n+        int n = arr.length;\r\n+        QuickSort ob = new QuickSort();\r\n+        ob.sort(arr, 0, n-1);\r\n+\r\n+        System.out.println(\"sorted array\");\r\n+        printArray(arr);\r\n+    }\r\n+}\r\n+\r"
  },
  {
    "sha": "35abf0dd311c3e1f2f6bb3df188fe5eb76d902f4",
    "filename": "Exercise_2.py",
    "status": "removed",
    "additions": 0,
    "deletions": 23,
    "changes": 23,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_2.py",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_2.py",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_2.py?ref=40d045818153d3ae141c5612ae6feb348acfe4c4",
    "patch": "@@ -1,23 +0,0 @@\n-# Python program for implementation of Quicksort Sort \n-  \n-# give you explanation for the approach\n-def partition(arr,low,high):\n-  \n-  \n-    #write your code here\n-  \n-\n-# Function to do Quick sort \n-def quickSort(arr,low,high): \n-    \n-    #write your code here\n-  \n-# Driver code to test above \n-arr = [10, 7, 8, 9, 1, 5] \n-n = len(arr) \n-quickSort(arr,0,n-1) \n-print (\"Sorted array is:\") \n-for i in range(n): \n-    print (\"%d\" %arr[i]), \n-  \n- "
  },
  {
    "sha": "209ce0feec02227066bfb01bf896b77daef77b7a",
    "filename": "Exercise_3.cpp",
    "status": "removed",
    "additions": 0,
    "deletions": 50,
    "changes": 50,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_3.cpp",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_3.cpp",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_3.cpp?ref=40d045818153d3ae141c5612ae6feb348acfe4c4",
    "patch": "@@ -1,50 +0,0 @@\n-#include<bits/stdc++.h>  \r\n-using namespace std;  \r\n-  \r\n-// Struct  \r\n-struct Node  \r\n-{  \r\n-    int data;  \r\n-    struct Node* next;  \r\n-};  \r\n-  \r\n-/* Function to get the middle of the linked list*/\r\n-void printMiddle(struct Node *head)  \r\n-{  \r\n-  //YourCode here\r\n-  //Use fast and slow pointer technique\r\n-}  \r\n-  \r\n-// Function to add a new node  \r\n-void push(struct Node** head_ref, int new_data)  \r\n-{  \r\n-    struct Node* new_node = new Node;  \r\n-    new_node->data = new_data;  \r\n-    new_node->next = (*head_ref);  \r\n-    (*head_ref) = new_node;  \r\n-}  \r\n-  \r\n-// A utility function to print a given linked list  \r\n-void printList(struct Node *ptr)  \r\n-{  \r\n-    while (ptr != NULL)  \r\n-    {  \r\n-        printf(\"%d->\", ptr->data);  \r\n-        ptr = ptr->next;  \r\n-    }  \r\n-    printf(\"NULL\\n\");  \r\n-}  \r\n-  \r\n-// Driver Code \r\n-int main()  \r\n-{    \r\n-    struct Node* head = NULL;    \r\n-    for (int i=15; i>0; i--)  \r\n-    {  \r\n-        push(&head, i);  \r\n-        printList(head);  \r\n-        printMiddle(head);  \r\n-    }  \r\n-  \r\n-    return 0;  \r\n-}  \n\\ No newline at end of file"
  },
  {
    "sha": "3581e2b4ac87ca90256c074f8c949f0ab22e157a",
    "filename": "Exercise_3.java",
    "status": "modified",
    "additions": 15,
    "deletions": 1,
    "changes": 16,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/005fecd6b326c665858df81df8f1c1ea9408ac0f/Exercise_3.java",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/005fecd6b326c665858df81df8f1c1ea9408ac0f/Exercise_3.java",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_3.java?ref=005fecd6b326c665858df81df8f1c1ea9408ac0f",
    "patch": "@@ -1,4 +1,11 @@\n-class LinkedList \r\n+/* Time Complexity :O(n).\r\n+push() and printList() operations takes O(n) time as all the elements are processes. printMiddle() takes O(n/2)~ O(n). Hence, 3O(n) ~ O(n)\r\n+Space Complexity : O(1) as no extra space is used.\r\n+ */\r\n+// Did this code successfully run on Leetcode : yes\r\n+// Any problem you faced while coding this : Initially I could'nt figureout how to use the slow and fast pointers\r\n+// Your code here along with comments explaining your approach\r\n+class LinkedList\r\n { \r\n     Node head; // head of linked list \r\n   \r\n@@ -20,6 +27,13 @@ void printMiddle()\n     { \r\n         //Write your code here\r\n \t//Implement using Fast and slow pointers\r\n+        Node slow = head;\r\n+        Node fast = head;\r\n+        while(fast!=null && fast.next!=null){\r\n+            slow = slow.next;\r\n+            fast = fast.next.next;\r\n+        }\r\n+        System.out.print(\"The middle node is : \"+ slow.data);\r\n     } \r\n   \r\n     public void push(int new_data) \r"
  },
  {
    "sha": "a26a69b8e53cf457c643a8e32ccac48ea267c996",
    "filename": "Exercise_3.py",
    "status": "removed",
    "additions": 0,
    "deletions": 26,
    "changes": 26,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_3.py",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_3.py",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_3.py?ref=40d045818153d3ae141c5612ae6feb348acfe4c4",
    "patch": "@@ -1,26 +0,0 @@\n-# Node class  \n-class Node:  \n-  \n-    # Function to initialise the node object  \n-    def __init__(self, data):  \n-        \n-class LinkedList: \n-  \n-    def __init__(self): \n-        \n-  \n-    def push(self, new_data): \n-        \n-  \n-    # Function to get the middle of  \n-    # the linked list \n-    def printMiddle(self): \n-\n-# Driver code \n-list1 = LinkedList() \n-list1.push(5) \n-list1.push(4) \n-list1.push(2) \n-list1.push(3) \n-list1.push(1) \n-list1.printMiddle() "
  },
  {
    "sha": "1a528ee64034531f045081b141b93e0995d856ec",
    "filename": "Exercise_4.cpp",
    "status": "removed",
    "additions": 0,
    "deletions": 43,
    "changes": 43,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_4.cpp",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_4.cpp",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_4.cpp?ref=40d045818153d3ae141c5612ae6feb348acfe4c4",
    "patch": "@@ -1,43 +0,0 @@\n-#include<stdlib.h> \r\n-#include<stdio.h> \r\n-  \r\n-// Merges two subarrays of arr[]. \r\n-// First subarray is arr[l..m] \r\n-// Second subarray is arr[m+1..r] \r\n-void merge(int arr[], int l, int m, int r) \r\n-{ \r\n-    //Your code here\r\n-} \r\n-  \r\n-/* l is for left index and r is right index of the \r\n-   sub-array of arr to be sorted */\r\n-void mergeSort(int arr[], int l, int r) \r\n-{ \r\n-    //Your code here\r\n-} \r\n-  \r\n-/* UTILITY FUNCTIONS */\r\n-/* Function to print an array */\r\n-void printArray(int A[], int size) \r\n-{ \r\n-    int i; \r\n-    for (i=0; i < size; i++) \r\n-        printf(\"%d \", A[i]); \r\n-    printf(\"\\n\"); \r\n-} \r\n-  \r\n-/* Driver program to test above functions */\r\n-int main() \r\n-{ \r\n-    int arr[] = {12, 11, 13, 5, 6, 7}; \r\n-    int arr_size = sizeof(arr)/sizeof(arr[0]); \r\n-  \r\n-    printf(\"Given array is \\n\"); \r\n-    printArray(arr, arr_size); \r\n-  \r\n-    mergeSort(arr, 0, arr_size - 1); \r\n-  \r\n-    printf(\"\\nSorted array is \\n\"); \r\n-    printArray(arr, arr_size); \r\n-    return 0; \r\n-}\n\\ No newline at end of file"
  },
  {
    "sha": "d4de4f646165610d8cae36b0a2c4d97e29f7dccb",
    "filename": "Exercise_4.java",
    "status": "modified",
    "additions": 48,
    "deletions": 3,
    "changes": 51,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/005fecd6b326c665858df81df8f1c1ea9408ac0f/Exercise_4.java",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/005fecd6b326c665858df81df8f1c1ea9408ac0f/Exercise_4.java",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_4.java?ref=005fecd6b326c665858df81df8f1c1ea9408ac0f",
    "patch": "@@ -1,19 +1,64 @@\n-class MergeSort \r\n+// Time Complexity : O(nlog n) as the input list is divided n times before mergeing the sorted list.\r\n+// Space Complexity : O(n) as extra array is used to store the sub elements from the input lists. Hence not an in place operation.\r\n+// Did this code successfully run on Leetcode : yes\r\n+// Any problem you faced while coding this : no\r\n+// Your code here along with comments explaining your approach\r\n+class MergeSort\r\n { \r\n     // Merges two subarrays of arr[]. \r\n     // First subarray is arr[l..m] \r\n     // Second subarray is arr[m+1..r] \r\n     void merge(int arr[], int l, int m, int r) \r\n     {  \r\n-       //Your code here  \r\n+       //Your code here\r\n+        int ptr = l;\r\n+        int left_size = m-l+1;\r\n+        int right_size = r-m;\r\n+        int[] left_arr = new int[left_size];\r\n+        int[] right_arr = new int[right_size];\r\n+        for(int i=0;i<left_size;i++){\r\n+            left_arr[i] = arr[l+i];\r\n+        }\r\n+        for(int j=0;j<right_size;j++){\r\n+            right_arr[j] = arr[m+j+1];\r\n+        }\r\n+        int i=0,j=0;\r\n+        while(i<left_size && j<right_size){\r\n+            if(left_arr[i] <= right_arr[j]){\r\n+                arr[ptr] = left_arr[i];\r\n+                ptr++;\r\n+                i++;\r\n+            }\r\n+            else{\r\n+                arr[ptr] = right_arr[j];\r\n+                ptr++;\r\n+                j++;\r\n+            }\r\n+        }\r\n+        while(i<left_size){\r\n+            arr[ptr] = left_arr[i];\r\n+            ptr++;\r\n+            i++;\r\n+        }\r\n+        while(j<right_size){\r\n+            arr[ptr] = right_arr[j];\r\n+            ptr++;\r\n+            j++;\r\n+        }\r\n     } \r\n   \r\n     // Main function that sorts arr[l..r] using \r\n     // merge() \r\n     void sort(int arr[], int l, int r) \r\n     { \r\n \t//Write your code here\r\n-        //Call mergeSort from here \r\n+        //Call mergeSort from here\r\n+       if(l<r){\r\n+           int mid = (r+l)/ 2;\r\n+           sort(arr,l,mid);\r\n+           sort(arr,mid+1,r);\r\n+           merge(arr,l,mid,r);\r\n+       }\r\n     } \r\n   \r\n     /* A utility function to print array of size n */\r"
  },
  {
    "sha": "9bc25d3dcff2abc4740639976d639f85123fd780",
    "filename": "Exercise_4.py",
    "status": "removed",
    "additions": 0,
    "deletions": 18,
    "changes": 18,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_4.py",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_4.py",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_4.py?ref=40d045818153d3ae141c5612ae6feb348acfe4c4",
    "patch": "@@ -1,18 +0,0 @@\n-# Python program for implementation of MergeSort \n-def mergeSort(arr):\n-  \n-  #write your code here\n-  \n-# Code to print the list \n-def printList(arr): \n-    \n-    #write your code here\n-  \n-# driver code to test the above code \n-if __name__ == '__main__': \n-    arr = [12, 11, 13, 5, 6, 7]  \n-    print (\"Given array is\", end=\"\\n\")  \n-    printList(arr) \n-    mergeSort(arr) \n-    print(\"Sorted array is: \", end=\"\\n\") \n-    printList(arr) "
  },
  {
    "sha": "a07c2bf60bd28187ed50e310a348576657a3ea3f",
    "filename": "Exercise_5.cpp",
    "status": "removed",
    "additions": 0,
    "deletions": 42,
    "changes": 42,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_5.cpp",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_5.cpp",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_5.cpp?ref=40d045818153d3ae141c5612ae6feb348acfe4c4",
    "patch": "@@ -1,42 +0,0 @@\n-#include <bits/stdc++.h> \r\n-using namespace std; \r\n-  \r\n-// A utility function to swap two elements \r\n-void swap(int* a, int* b) \r\n-{ \r\n-    int t = *a; \r\n-    *a = *b; \r\n-    *b = t; \r\n-} \r\n-  \r\n-/* This function is same in both iterative and recursive*/\r\n-int partition(int arr[], int l, int h) \r\n-{ \r\n-    //Do the comparison and swapping here \r\n-} \r\n-  \r\n-/* A[] --> Array to be sorted,  \r\n-l --> Starting index,  \r\n-h --> Ending index */\r\n-void quickSortIterative(int arr[], int l, int h) \r\n-{ \r\n-    //Try to think that how you can use stack here to remove recursion.\r\n-} \r\n-  \r\n-// A utility function to print contents of arr \r\n-void printArr(int arr[], int n) \r\n-{ \r\n-    int i; \r\n-    for (i = 0; i < n; ++i) \r\n-        cout << arr[i] << \" \"; \r\n-} \r\n-  \r\n-// Driver code \r\n-int main() \r\n-{ \r\n-    int arr[] = { 4, 3, 5, 2, 1, 3, 2, 3 }; \r\n-    int n = sizeof(arr) / sizeof(*arr); \r\n-    quickSortIterative(arr, 0, n - 1); \r\n-    printArr(arr, n); \r\n-    return 0; \r\n-} \n\\ No newline at end of file"
  },
  {
    "sha": "7b9324018ca5c8dbf81df0c0b5537918a8bb660f",
    "filename": "Exercise_5.java",
    "status": "modified",
    "additions": 38,
    "deletions": 2,
    "changes": 40,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/005fecd6b326c665858df81df8f1c1ea9408ac0f/Exercise_5.java",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/005fecd6b326c665858df81df8f1c1ea9408ac0f/Exercise_5.java",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_5.java?ref=005fecd6b326c665858df81df8f1c1ea9408ac0f",
    "patch": "@@ -1,20 +1,56 @@\n-class IterativeQuickSort { \r\n+// Time Complexity : O(n^2)\r\n+// Space Complexity : O(n) extra array is use dto represent stack\r\n+// Did this code successfully run on Leetcode :  No couldn't find in LeetCode, but executed successfully in IDE\r\n+// Any problem you faced while coding this : I could not fiqure out how to swap without using extra variable\r\n+// Your code here along with comments explaining your approach\r\n+class IterativeQuickSort {\r\n     void swap(int arr[], int i, int j) \r\n     { \r\n-\t//Try swapping without extra variable \r\n+\t//Try swapping without extra variable\r\n+        int temp;\r\n+        temp = arr[i];\r\n+        arr[i] = arr[j];\r\n+        arr[j] = temp;\r\n     } \r\n   \r\n     /* This function is same in both iterative and \r\n        recursive*/\r\n     int partition(int arr[], int l, int h) \r\n     { \r\n         //Compare elements and swap.\r\n+        int pivot = arr[high];\r\n+        int ptr1 = low-1;\r\n+        for(int ptr2=low; ptr2<high; ptr2++){\r\n+            if(arr[ptr2] <= pivot){\r\n+                ptr1++;\r\n+                swap(arr,ptr1,ptr2);\r\n+            }\r\n+        }\r\n+        swap(arr,ptr1+1,high);\r\n+        return ptr1+1;\r\n     } \r\n   \r\n     // Sorts arr[l..h] using iterative QuickSort \r\n     void QuickSort(int arr[], int l, int h) \r\n     { \r\n         //Try using Stack Data Structure to remove recursion.\r\n+        int[] stack = new int[h - l + 1];\r\n+        int top = -1;\r\n+        stack[++top] = l;\r\n+        stack[++top] = h;\r\n+        while (top >= 0) {\r\n+            h = stack[top--];\r\n+            l = stack[top--];\r\n+            int p = partition(arr, l, h);\r\n+            if (p - 1 > l) {\r\n+                stack[++top] = l;\r\n+                stack[++top] = p - 1;\r\n+            }\r\n+            if (p + 1 < h) {\r\n+                stack[++top] = p + 1;\r\n+                stack[++top] = h;\r\n+            }\r\n+        }\r\n     } \r\n   \r\n     // A utility function to print contents of arr \r"
  },
  {
    "sha": "1da24ffbd5875ba8261867d4c1ba149096b79f14",
    "filename": "Exercise_5.py",
    "status": "removed",
    "additions": 0,
    "deletions": 10,
    "changes": 10,
    "blob_url": "https://github.com/super30admin/PreCourse-2/blob/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_5.py",
    "raw_url": "https://github.com/super30admin/PreCourse-2/raw/40d045818153d3ae141c5612ae6feb348acfe4c4/Exercise_5.py",
    "contents_url": "https://api.github.com/repos/super30admin/PreCourse-2/contents/Exercise_5.py?ref=40d045818153d3ae141c5612ae6feb348acfe4c4",
    "patch": "@@ -1,10 +0,0 @@\n-# Python program for implementation of Quicksort\n-\n-# This function is same in both iterative and recursive\n-def partition(arr, l, h):\n-  #write your code here\n-\n-\n-def quickSortIterative(arr, l, h):\n-  #write your code here\n-"
  }
]
