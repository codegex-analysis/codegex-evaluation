[
  {
    "sha": "e4dd5fc108ecaa747d423e5c5f0b80f08e69eb5f",
    "filename": "Problem1.java",
    "status": "added",
    "additions": 87,
    "deletions": 0,
    "changes": 87,
    "blob_url": "https://github.com/super30admin/Competitive-Coding-9/blob/0da74e3408395e1f58638b793de7dd6b69a44f77/Problem1.java",
    "raw_url": "https://github.com/super30admin/Competitive-Coding-9/raw/0da74e3408395e1f58638b793de7dd6b69a44f77/Problem1.java",
    "contents_url": "https://api.github.com/repos/super30admin/Competitive-Coding-9/contents/Problem1.java?ref=0da74e3408395e1f58638b793de7dd6b69a44f77",
    "patch": "@@ -0,0 +1,87 @@\n+/*\n+construct a adjacency list which consits of all the possible combinations of the words\n+in the wordlist. \n+ex: *it, h*t, etc\n+Start the bfs from begin word by adding it to queue\n+and for each possible combination of the word, fetch the adjacency list from map and chck if its the endword, return the count. Else continue by adding node to the queue.\n+time complexity: O(n^2) + O(m^2)\n+space complexity: O(m^2 n)\n+*/\n+class pair{\n+    String word;\n+    int level;\n+    pair(String word,int level){\n+        this.word = word;\n+        this.level = level;\n+    }\n+}\n+\n+\n+class Solution {\n+    HashMap<String,List<String>> dictionary;\n+        \n+    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n+        \n+        int n = beginWord.length();\n+        \n+        this.dictionary = new HashMap<>();\n+        \n+        populateDictionary(wordList,n);\n+        \n+        Queue<pair>queue = new LinkedList<>();\n+        queue.add(new pair(beginWord,1));\n+        \n+        HashMap<String,Boolean> visited = new HashMap<>();\n+        visited.put(beginWord,true);\n+        \n+        while(!queue.isEmpty()){\n+            \n+            pair p = queue.poll();\n+            String word =p.word;\n+            int level = p.level;\n+            \n+            \n+            for(int i = 0; i< n;i++)\n+            {\n+                String newWord = word.substring(0,i)+\"*\"+word.substring(i+1,n);\n+                \n+                for(String neigh : dictionary.getOrDefault(newWord,new ArrayList<>())){\n+                    \n+                    if(neigh.equals(endWord)){\n+                        return level+1;\n+                    }\n+                    \n+                    if(!visited.containsKey(neigh)){\n+                         visited.put(neigh,true);\n+                        \n+                        queue.add(new pair(neigh,level+1));\n+                    }\n+              }\n+        }\n+            \n+        }\n+        return 0;\n+    }\n+    \n+    \n+    private void populateDictionary(List<String> wordList,int n){\n+         for(String word : wordList){\n+            for(int i =0;i < n ; i++){\n+                String newWord = word.substring(0,i)+\"*\"+word.substring(i+1,n);\n+                if(dictionary.containsKey(newWord)){\n+                    List<String>adjlist = dictionary.get(newWord);\n+                    adjlist.add(word);\n+                    dictionary.put(newWord,adjlist);\n+                }else{\n+                    List<String>adjlist = new ArrayList<>();\n+                    adjlist.add(word);\n+                    dictionary.put(newWord,adjlist);\n+                                   \n+                }\n+            }\n+        }\n+        \n+    }\n+    \n+    \n+}"
  }
]
