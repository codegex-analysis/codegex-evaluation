[
  {
    "sha": "8e5a8e30bc8a58686f0075d407f0d1e9f4e1ba6d",
    "filename": "solution143.py",
    "status": "added",
    "additions": 41,
    "deletions": 0,
    "changes": 41,
    "blob_url": "https://github.com/super30admin/BFS-3/blob/0f60a455a82b967c901810c3b2e308fc68bc1aaa/solution143.py",
    "raw_url": "https://github.com/super30admin/BFS-3/raw/0f60a455a82b967c901810c3b2e308fc68bc1aaa/solution143.py",
    "contents_url": "https://api.github.com/repos/super30admin/BFS-3/contents/solution143.py?ref=0f60a455a82b967c901810c3b2e308fc68bc1aaa",
    "patch": "@@ -0,0 +1,41 @@\n+#Time Complexity:O(2^n)\n+#Space Complexity:O(n*2^n)\n+class Solution:\n+    def removeInvalidParentheses(self, s: str) -> List[str]:\n+        result=[]                                               #use an output array that stores valid strings\n+        if not s:\n+            result.append(\"\")\n+            return result                                       #if s is empty return output array with empty string\n+        hset=[]\n+        q=deque()                                               #use a queue and a hashset to store the possible string combinations\n+        q.append(s)\n+        hset.append(s)\n+        flag=False                                              #flag is used to store the occurance of a valid string\n+        while q:                                                #while the queue is populated\n+            size=len(q)                                         #parse through elemnts of queue at this point\n+            for i in range(size):\n+                curr=q.popleft()\n+                if self.isValid(curr):                          #if the current string is valid, st flag to true and append it to output array\n+                    flag=True\n+                    result.append(curr)\n+                if not flag:                                    #if the flag is not set, parse through the current string, if a character is alphabet continue\n+                    for j in range(len(curr)):\n+                        if curr[j].isalpha():\n+                            continue\n+                        child=curr[:j]+curr[j+1:]               #else try possible combinations of current string and append it to the queue as well as the hashset\n+                        if child not in hset:\n+                            q.append(child)\n+                            hset.append(child)\n+        return result                                           #return the output array once all possibilities are parsed\n+    \n+    def isValid(self,s:str)->bool:                              #to check if a string is valid or not , use count to see of the number of braces match\n+        count=0\n+        for i in range(len(s)):\n+            c=s[i]\n+            if c=='(':                                          #if opening brace is encountered increment count\n+                count+=1\n+            elif c==')':                                        #if closing brace is matched  and count is not zero, decrement count\n+                if count==0:\n+                    return False\n+                count-=1\n+        return count==0                                         #return boolean of count equals zero\n\\ No newline at end of file"
  },
  {
    "sha": "e148100c9b2be5990ae91a0851ddcb39e0dfcb7a",
    "filename": "solution144.py",
    "status": "added",
    "additions": 28,
    "deletions": 0,
    "changes": 28,
    "blob_url": "https://github.com/super30admin/BFS-3/blob/0f60a455a82b967c901810c3b2e308fc68bc1aaa/solution144.py",
    "raw_url": "https://github.com/super30admin/BFS-3/raw/0f60a455a82b967c901810c3b2e308fc68bc1aaa/solution144.py",
    "contents_url": "https://api.github.com/repos/super30admin/BFS-3/contents/solution144.py?ref=0f60a455a82b967c901810c3b2e308fc68bc1aaa",
    "patch": "@@ -0,0 +1,28 @@\n+#Time Complexity:O(V+E)\n+#Space Complexity:O(V)\n+\n+\"\"\"\n+# Definition for a Node.\n+class Node:\n+    def __init__(self, val = 0, neighbors = None):\n+        self.val = val\n+        self.neighbors = neighbors if neighbors is not None else []\n+\"\"\"\n+class Solution:\n+    def cloneGraph(self, node: 'Node') -> 'Node':\n+        if not node:\n+            return None\n+        dict={}                                         #a hashmap is declared to map every node to its copy\n+        copyNode=Node(node.val)                         #copy of the first node is created and added to the hashmap\n+        dict[node]=copyNode\n+        q=deque()                                       #a queue is created and the first original node is added to the queue\n+        q.append(node)\n+        while q:                                        #while is q has elements in it, obtain the first element\n+            curr=q.pop()\n+            for n in curr.neighbors:                    #access the neigbors of the node\n+                if n not in dict:                       #if its copy does not exist, create a copy and map it in the hashmap\n+                    copy=Node(n.val)\n+                    dict[n]=copy\n+                    q.append(n)                         #push the original of the neighbor nodes to the queue\n+                dict[curr].neighbors.append(dict[n])    #access the copy of current node and to its neigbors list append the copy of the original neighbors\n+        return copyNode                                 #return the copyNode\n\\ No newline at end of file"
  }
]
