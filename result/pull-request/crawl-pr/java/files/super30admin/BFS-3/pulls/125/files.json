[
  {
    "sha": "4a513b588f48a63b378b954a44a730c72f89224d",
    "filename": "CloneGraph.java",
    "status": "added",
    "additions": 60,
    "deletions": 0,
    "changes": 60,
    "blob_url": "https://github.com/super30admin/BFS-3/blob/b7c7f9c1ef0bb180d9e79ed0060b8c743750c1d9/CloneGraph.java",
    "raw_url": "https://github.com/super30admin/BFS-3/raw/b7c7f9c1ef0bb180d9e79ed0060b8c743750c1d9/CloneGraph.java",
    "contents_url": "https://api.github.com/repos/super30admin/BFS-3/contents/CloneGraph.java?ref=b7c7f9c1ef0bb180d9e79ed0060b8c743750c1d9",
    "patch": "@@ -0,0 +1,60 @@\n+import java.util.*;\r\n+// Time Complexity :(n+m)\r\n+// Space Complexity :O(n)\r\n+// Did this code successfully run on Leetcode : yes\r\n+// Any problem you faced while coding this : getting started\r\n+\r\n+// Your code here along with comments explaining your approach\r\n+public class CloneGraph {\r\n+    /*\r\n+// Definition for a Node.*/\r\n+    class Node {\r\n+        public int val;\r\n+        public List<Node> neighbors;\r\n+        public Node() {\r\n+            val = 0;\r\n+            neighbors = new ArrayList<Node>();\r\n+        }\r\n+        public Node(int _val) {\r\n+            val = _val;\r\n+            neighbors = new ArrayList<Node>();\r\n+        }\r\n+        public Node(int _val, ArrayList<Node> _neighbors) {\r\n+            val = _val;\r\n+            neighbors = _neighbors;\r\n+        }\r\n+    }\r\n+\r\n+    class Solution {\r\n+        public Node cloneGraph(Node node) {\r\n+            if (node == null) return node;//base case\r\n+\r\n+            //hashmap to store visited nodes\r\n+            HashMap<Node, Node> visited = new HashMap();\r\n+\r\n+            // add first node to queue\r\n+            Queue<Node> queue = new LinkedList<Node>();\r\n+            queue.add(node);\r\n+\r\n+            // Clone the node and add to visited\r\n+            visited.put(node, new Node(node.val, new ArrayList()));\r\n+\r\n+            // Begin bfs\r\n+            while (!queue.isEmpty()) {\r\n+                // Pop node from front of queue and iterate through all neighbours\r\n+                Node n = queue.remove();\r\n+                for (Node neighbor: n.neighbors) {\r\n+                    if (!visited.containsKey(neighbor)) {\r\n+                        //add to hashmap if not present and to queue\r\n+                        visited.put(neighbor, new Node(neighbor.val, new ArrayList()));\r\n+                        queue.add(neighbor);\r\n+                    }\r\n+                    //add node to neighbors\r\n+                    visited.get(n).neighbors.add(visited.get(neighbor));\r\n+                }\r\n+            }\r\n+            return visited.get(node);//return cloned nodes\r\n+        }\r\n+    }\r\n+\r\n+}\r"
  },
  {
    "sha": "62049c3586d4d4735a27ea400a80a2a94bfd2d7f",
    "filename": "RemoveInvalidParentheses.java",
    "status": "added",
    "additions": 47,
    "deletions": 0,
    "changes": 47,
    "blob_url": "https://github.com/super30admin/BFS-3/blob/b7c7f9c1ef0bb180d9e79ed0060b8c743750c1d9/RemoveInvalidParentheses.java",
    "raw_url": "https://github.com/super30admin/BFS-3/raw/b7c7f9c1ef0bb180d9e79ed0060b8c743750c1d9/RemoveInvalidParentheses.java",
    "contents_url": "https://api.github.com/repos/super30admin/BFS-3/contents/RemoveInvalidParentheses.java?ref=b7c7f9c1ef0bb180d9e79ed0060b8c743750c1d9",
    "patch": "@@ -0,0 +1,47 @@\n+import java.util.ArrayList;\r\n+import java.util.List;\r\n+// Time Complexity :O(2^n)\r\n+// Space Complexity :O(n)\r\n+// Did this code successfully run on Leetcode : yes\r\n+// Any problem you faced while coding this : getting started\r\n+\r\n+// Your code here along with comments explaining your approach\r\n+public class RemoveInvalidParentheses {\r\n+\r\n+    class Solution {\r\n+        public List<String> removeInvalidParentheses(String s) {\r\n+            List<String> res = new ArrayList<>();\r\n+            helper(s, 0, 0, res, new char[]{'(', ')'});\r\n+            return res;\r\n+        }\r\n+\r\n+        //helper method to remove invalid parenthesis\r\n+        private void helper(String s, int left, int right, List<String> res, char[] parenthesis){\r\n+            int stack=0;\r\n+            int n = s.length();\r\n+            for(;right<n; right++){\r\n+                char c = s.charAt(right);\r\n+                if(c==parenthesis[0]){\r\n+                    stack++;\r\n+                }else if(c==parenthesis[1]){\r\n+                    stack--;\r\n+                }\r\n+                if(stack<0) break;\r\n+            }\r\n+\r\n+            if(stack < 0){\r\n+                for(;left<=right; left++){\r\n+                    char c = s.charAt(left);\r\n+                    if(c!=parenthesis[1]) continue;\r\n+                    if(left > 1 && s.charAt(left) == s.charAt(left-1)) continue;\r\n+                    helper(s.substring(0, left) + s.substring(left+1), left, right, res, parenthesis);\r\n+                }\r\n+            }else if(stack > 0){\r\n+                helper(new StringBuilder(s).reverse().toString(), 0, 0, res, new char[]{')', '('});\r\n+            }else{\r\n+                res.add(parenthesis[0]== '(' ? s: new StringBuilder(s).reverse().toString() );\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+}\r"
  }
]
