[
  {
    "sha": "b6ada6a5f0859adf47d0d276ca974d394d9a92f2",
    "filename": "CloneGraph.java",
    "status": "added",
    "additions": 83,
    "deletions": 0,
    "changes": 83,
    "blob_url": "https://github.com/super30admin/BFS-3/blob/de2c36b6d9cfea8573c572f0b59c3f7b43e01d02/CloneGraph.java",
    "raw_url": "https://github.com/super30admin/BFS-3/raw/de2c36b6d9cfea8573c572f0b59c3f7b43e01d02/CloneGraph.java",
    "contents_url": "https://api.github.com/repos/super30admin/BFS-3/contents/CloneGraph.java?ref=de2c36b6d9cfea8573c572f0b59c3f7b43e01d02",
    "patch": "@@ -0,0 +1,83 @@\n+/*\n+// Definition for a Node.\n+class Node {\n+    public int val;\n+    public List<Node> neighbors;\n+    public Node() {\n+        val = 0;\n+        neighbors = new ArrayList<Node>();\n+    }\n+    public Node(int _val) {\n+        val = _val;\n+        neighbors = new ArrayList<Node>();\n+    }\n+    public Node(int _val, ArrayList<Node> _neighbors) {\n+        val = _val;\n+        neighbors = _neighbors;\n+    }\n+}\n+*/\n+/*\n+method 1: using BFS approach \n+Maintain a hashmap of original node as key and value as copy node. \n+use queue to traverse the graph. \n+Add the first node to queue and add it to visited hashmap. Get its neighbors and check if visited or not.\n+if not, add to hashmap and to the queue. \n+TC : O(v+e)\n+SC :O(v)\n+\n+method 2: DFS approach\n+similar to bfs i.e. maintianing of hashmap\n+TC:O O(v+e)\n+SC: O(v)\n+*/\n+\n+class Solution {\n+    HashMap<Node,Node> visited;\n+    public Node cloneGraph(Node node) {\n+        if(node == null)return node;\n+        \n+        this.visited = new HashMap<>();\n+        \n+        ///method 1\n+//         Queue<Node> queue = new LinkedList<>();\n+//         queue.add(node);\n+//         Node firstCopy = new Node(node.val);\n+//         visited.put(node, firstCopy);\n+        \n+//         while(!queue.isEmpty()){\n+//             Node curr = queue.poll();\n+            \n+//             if(curr.neighbors != null){\n+//                 for(Node n : curr.neighbors){\n+//                     if(!visited.containsKey(n)){\n+//                      Node copy = new Node (n.val);\n+//                      visited.put(n,copy);\n+//                      queue.add(n);\n+//                    }\n+            \n+//                     //get the copied node from hashmap\n+//             //add the original nodes adjcency list to the copy node also\n+//             Node clonnedNeighbor = visited.get(n);\n+//             visited.get(curr).neighbors.add(clonnedNeighbor);\n+//              }\n+//             }\n+           \n+//         }\n+        dfs(node);\n+        return this.visited.get(node);\n+        \n+    }\n+    \n+    private void dfs(Node node){\n+        if(this.visited.containsKey(node)){\n+            return;\n+        }\n+        Node copyNode = new Node(node.val);\n+        this.visited.put(node,copyNode);\n+        for(Node n : node.neighbors){\n+            dfs(n);\n+            this.visited.get(node).neighbors.add(this.visited.get(n));\n+        }\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "080191621aeb243485b96861f026f3747347050c",
    "filename": "RemoveInvalidPranthesis.java",
    "status": "added",
    "additions": 58,
    "deletions": 0,
    "changes": 58,
    "blob_url": "https://github.com/super30admin/BFS-3/blob/de2c36b6d9cfea8573c572f0b59c3f7b43e01d02/RemoveInvalidPranthesis.java",
    "raw_url": "https://github.com/super30admin/BFS-3/raw/de2c36b6d9cfea8573c572f0b59c3f7b43e01d02/RemoveInvalidPranthesis.java",
    "contents_url": "https://api.github.com/repos/super30admin/BFS-3/contents/RemoveInvalidPranthesis.java?ref=de2c36b6d9cfea8573c572f0b59c3f7b43e01d02",
    "patch": "@@ -0,0 +1,58 @@\n+/*\n+here we have to try all possible combinatoins of brackets by doing a BFS approach.\n+if you find that at any level if the string is valid then no need to proceed to deeper level. \n+If not, then remove on char at time and from string and add it queue if not seen before and process it.\n+TC: O(2^n)\n+SC :O(2^n), in worst case might end up adding all to visited\n+\n+*/\n+class Solution {\n+    public List<String> removeInvalidParentheses(String s) {\n+        \n+        List<String> result = new ArrayList<>();\n+        \n+        if(s == null)return result;\n+        \n+        HashSet<String> visited = new HashSet<>();\n+        Queue<String> queue = new LinkedList<>();\n+        queue.add(s);\n+        visited.add(s);\n+        \n+        boolean flag = false;\n+        \n+        while(!queue.isEmpty()){\n+            String curr = queue.poll();\n+            if(isValidString(curr)){\n+                flag = true;\n+                result.add(curr);\n+            }\n+            \n+            if(!flag){\n+                for(int i = 0; i < curr.length();i++){\n+                    if(Character.isLetter(curr.charAt(i)))continue;\n+                    String nextStr = curr.substring(0,i) + curr.substring(i+1);\n+                    \n+                    if(!visited.contains(nextStr)){\n+                        queue.add(nextStr);\n+                        visited.add(nextStr);\n+                    }\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+    \n+    private boolean isValidString(String s){\n+        int count= 0;\n+        for(int i = 0;i < s.length();i++){\n+            char ch = s.charAt(i);\n+            if(ch == '(')count++;\n+            else if(ch == ')'){\n+                if(count == 0)return false;\n+                count--;\n+            }\n+                \n+        }\n+        return count == 0;\n+    }\n+}\n\\ No newline at end of file"
  }
]
