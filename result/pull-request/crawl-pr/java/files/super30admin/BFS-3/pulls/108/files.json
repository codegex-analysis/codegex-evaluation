[
  {
    "sha": "e47e40296bb213036af1ab187f6b8c7e18aceb94",
    "filename": "Clone Graph.java",
    "status": "added",
    "additions": 100,
    "deletions": 0,
    "changes": 100,
    "blob_url": "https://github.com/super30admin/BFS-3/blob/9fde2db0d54b8472a1781ec7da0990acec2c94e0/Clone%20Graph.java",
    "raw_url": "https://github.com/super30admin/BFS-3/raw/9fde2db0d54b8472a1781ec7da0990acec2c94e0/Clone%20Graph.java",
    "contents_url": "https://api.github.com/repos/super30admin/BFS-3/contents/Clone%20Graph.java?ref=9fde2db0d54b8472a1781ec7da0990acec2c94e0",
    "patch": "@@ -0,0 +1,100 @@\n+/*\n+class Solution:\n+    def cloneGraph(self, node: 'Node') -> 'Node':\n+        if node is None:\n+            return node\n+        \n+        copy = Node(node.val)\n+        queue = collections.deque()\n+        queue.append(node)\n+        mapping = dict()\n+        mapping[node] = copy\n+        \n+        while len(queue) > 0:\n+            cur = queue.popleft()\n+            for nei in cur.neighbors:\n+                if nei not in mapping:\n+                    copynode = Node(nei.val)\n+                    mapping[nei] = copynode\n+                    queue.append(nei)\n+                mapping[cur].neighbors.append(mapping[nei])\n+        return copy\n+        #return mapping[node]\n+\n+class Solution:\n+    def cloneGraph(self, node: 'Node') -> 'Node':\n+        if node is None:\n+            return node\n+        \n+        self.mapping = dict()\n+        self.dfs(node)\n+        \n+        return self.mapping[node]\n+    \n+    def dfs(self, node):\n+        if node in self.mapping:\n+            return\n+        \n+        copy = Node(node.val)\n+        self.mapping[node] = copy\n+        for nei in node.neighbors:\n+            self.dfs(nei)\n+            self.mapping[node].neighbors.append(self.mapping[nei])\n+*/\n+/*\n+class Solution {\n+    HashMap<Node, Node> map;\n+    public Node cloneGraph(Node node) {\n+        if (node == null)\n+            return null;\n+        \n+        map = new HashMap<>();\n+        dfs(node);\n+        return map.get(node);\n+    }\n+    private void dfs(Node node){\n+        if (map.containsKey(node))\n+            return;\n+        \n+        Node copy = new Node(node.val);\n+        map.put(node, copy);\n+        \n+        for (Node nei:node.neighbors){\n+            Node nei_copy = new Node(nei.val);\n+            dfs(nei);\n+            map.get(node).neighbors.add(map.get(nei));\n+        }\n+    }\n+}\n+*/\n+\n+// time - O(V+E)\n+// space - O(V+E)\n+// logic - started with bfs on given node\n+class Solution {\n+    public Node cloneGraph(Node node) {\n+        if (node == null)\n+            return null;\n+        \n+        Queue<Node> q = new LinkedList<>();\n+        HashMap<Node, Node> mapping = new HashMap<>();\n+        Node copy = new Node(node.val);\n+        mapping.put(node, copy);\n+        q.add(node);\n+        \n+        while (!q.isEmpty()){\n+            Node cur = q.poll();\n+            for (Node nei:cur.neighbors){\n+                if (!mapping.containsKey(nei)){\n+                    Node copynode = new Node(nei.val);\n+                    q.add(nei);\n+                    mapping.put(nei, copynode);\n+                }\n+                mapping.get(cur).neighbors.add(mapping.get(nei));\n+                \n+            }\n+        }\n+        return copy;\n+        //return mapping.get(node);\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "a30035a82fccc297eeb342faa487f84f2ce41bf5",
    "filename": "Remove Invalid Parentheses.java",
    "status": "added",
    "additions": 188,
    "deletions": 0,
    "changes": 188,
    "blob_url": "https://github.com/super30admin/BFS-3/blob/9fde2db0d54b8472a1781ec7da0990acec2c94e0/Remove%20Invalid%20Parentheses.java",
    "raw_url": "https://github.com/super30admin/BFS-3/raw/9fde2db0d54b8472a1781ec7da0990acec2c94e0/Remove%20Invalid%20Parentheses.java",
    "contents_url": "https://api.github.com/repos/super30admin/BFS-3/contents/Remove%20Invalid%20Parentheses.java?ref=9fde2db0d54b8472a1781ec7da0990acec2c94e0",
    "patch": "@@ -0,0 +1,188 @@\n+/*\n+class Solution:\n+\n+    def removeInvalidParentheses(self, s: str) -> List[str]:\n+        if s is None:\n+            return []\n+        \n+        result = []\n+        queue = collections.deque()\n+        queue.append(s)\n+        hashset = set()\n+        hashset.add(s)\n+        finished = False\n+        \n+        while len(queue)>0 and not finished:\n+            size = len(queue)\n+            for i in range(size):\n+                popped = queue.popleft()\n+                if self.isvalid(popped):\n+                    finished = True\n+                    result.append(popped)\n+                \n+                if not finished:\n+                    for j in range(len(popped)):\n+                        substring = popped[0:j] + popped[j+1:]\n+                        if substring not in hashset:\n+                            hashset.add(substring)\n+                            queue.append(substring)\n+        return result\n+    def isvalid(self, string):\n+        cnt = 0\n+        for k in range(len(string)):\n+            if string[k] == \"(\":\n+                cnt += 1\n+            elif string[k] == \")\" and cnt == 0:\n+                return False\n+            \n+            elif string[k] == \")\":\n+                cnt -= 1\n+        return cnt == 0\n+\n+\n+class Solution:\n+    def removeInvalidParentheses(self, s: str) -> List[str]:\n+        if s is None:\n+            return []\n+        \n+        result = []\n+        queue = collections.deque()\n+        queue.append(s)\n+        hashset = set()\n+        hashset.add(s)\n+        finished = False\n+        \n+        while len(queue)>0:\n+            # size = len(queue)                 when we remove bfs size and travel levelwise we have to remove finished from while condition but this condition made sure alphabets are allowed in final result so when we remove this we have add if condition to skip alphabet\n+            # for i in range(size):\n+            popped = queue.popleft()\n+            if self.isvalid(popped):\n+                finished = True\n+                result.append(popped)\n+\n+            if not finished:\n+                for j in range(len(popped)):\n+                    if popped[j].isalpha():  # added this condition because finished was removed from while condition\n+                        continue\n+                    substring = popped[0:j] + popped[j+1:]\n+                    \n+                    if substring not in hashset:\n+                        hashset.add(substring)\n+                        queue.append(substring)\n+        return result\n+    def isvalid(self, string):\n+        cnt = 0\n+        for k in range(len(string)):\n+            if string[k] == \"(\":\n+                cnt += 1\n+            elif string[k] == \")\" and cnt == 0:\n+                return False\n+            \n+            elif string[k] == \")\":\n+                cnt -= 1\n+        return cnt == 0\n+*/\n+/*\n+class Solution {\n+    public List<String> removeInvalidParentheses(String s) {\n+        List<String> result = new ArrayList<>();\n+        if (s == null)\n+            return result;\n+        \n+        HashSet<String> set = new HashSet<>();\n+        Queue<String> q = new LinkedList<>();\n+        q.add(s);\n+        set.add(s);\n+        \n+        boolean finished = false;\n+        \n+        while (!q.isEmpty()){\n+            // int size = q.size();\n+            // for (int i=0; i<size; i++){\n+                String popped = q.poll();\n+                if (isValid(popped)){\n+                    result.add(popped);\n+                    finished = true;\n+                }\n+                if (!finished){\n+                    for (int j=0; j<popped.length(); j++){\n+                        if (Character.isLetter(popped.charAt(j)))\n+                            continue;\n+                        String substr = popped.substring(0,j) + popped.substring(j+1);\n+                        if (!set.contains(substr)){\n+                            set.add(substr);\n+                            q.add(substr);\n+                        }\n+                    }\n+                }\n+            //}\n+        }\n+        return result;\n+    }\n+    public boolean isValid(String g){\n+        int cnt = 0;\n+        for (int k=0; k<g.length(); k++){\n+            char c = g.charAt(k);\n+            if (c == '(')\n+                cnt ++;\n+            else if (c == ')' && cnt == 0)\n+                return false;\n+            else if (c == ')')\n+                cnt -= 1;\n+        }\n+        return cnt == 0;\n+    }\n+}\n+*/\n+\n+// time - O(2^n)\n+// space - O(n)\n+// logic - we remove one by one parenthesis to check whether it is valid \n+class Solution {\n+    public List<String> removeInvalidParentheses(String s) {\n+        List<String> result = new ArrayList<>();\n+        if (s == null)\n+            return result;\n+        \n+        HashSet<String> set = new HashSet<>();\n+        Queue<String> q = new LinkedList<>();\n+        q.add(s);\n+        set.add(s);\n+        \n+        boolean finished = false;\n+        \n+        while (!q.isEmpty() && !finished){\n+            int size = q.size();\n+            for (int i=0; i<size; i++){\n+                String popped = q.poll();\n+                if (isValid(popped)){\n+                    result.add(popped);\n+                    finished = true;\n+                }\n+                if (!finished){\n+                    for (int j=0; j<popped.length(); j++){\n+                        String substr = popped.substring(0,j) + popped.substring(j+1);\n+                        if (!set.contains(substr)){\n+                            set.add(substr);\n+                            q.add(substr);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+    public boolean isValid(String g){\n+        int cnt = 0;\n+        for (int k=0; k<g.length(); k++){\n+            char c = g.charAt(k);\n+            if (c == '(')\n+                cnt ++;\n+            else if (c == ')' && cnt == 0)\n+                return false;\n+            else if (c == ')')\n+                cnt -= 1;\n+        }\n+        return cnt == 0;\n+    }\n+}\n\\ No newline at end of file"
  }
]
