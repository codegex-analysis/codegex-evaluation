[
  {
    "sha": "f7c7b6ffcf014a8bf4e6aedd1bd60d1d0f91f7c5",
    "filename": "README.md",
    "status": "modified",
    "additions": 80,
    "deletions": 0,
    "changes": 80,
    "blob_url": "https://github.com/super30admin/Design-1/blob/20d04004e3b6dafe820f80b590b14e130f035466/README.md",
    "raw_url": "https://github.com/super30admin/Design-1/raw/20d04004e3b6dafe820f80b590b14e130f035466/README.md",
    "contents_url": "https://api.github.com/repos/super30admin/Design-1/contents/README.md?ref=20d04004e3b6dafe820f80b590b14e130f035466",
    "patch": "@@ -3,10 +3,90 @@\n ## Problem 1:\n Design Hashmap (https://leetcode.com/problems/design-hashmap/)\n \n+class MyHashMap:\n+\n+    def __init__(self):\n+        \"\"\"\n+        Initialize your data structure here.\n+        \"\"\"\n+        self.dict = {}\n+\n+    def put(self, key: int, value: int) -> None:\n+        \"\"\"\n+        value will always be non-negative.\n+        \"\"\"\n+        self.dict[key] = value\n+        # print(key)\n+        # print(value)\n+\n+    def get(self, key: int) -> int:\n+        \"\"\"\n+        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key\n+        \"\"\"\n+        if key in self.dict:\n+            return self.dict[key]\n+        else:\n+            return -1\n+\n+    def remove(self, key: int) -> None:\n+        \"\"\"\n+        Removes the mapping of the specified value key if this map contains a mapping for the key\n+        \"\"\"\n+        self.dict.pop(key,None)\n+        self.dict[key] = -1\n+\n+\n+# Your MyHashMap object will be instantiated and called as such:\n+# obj = MyHashMap()\n+# obj.put(key,value)\n+# param_2 = obj.get(key)\n+# obj.remove(key)\n+\n \n \n ## Problem 2:\n Design MinStack (https://leetcode.com/problems/min-stack/)\n \n+import math\n+class MinStack:\n+\n+    def __init__(self):\n+        \"\"\"\n+        initialize your data structure here.\n+        \"\"\"\n+        self.stack = []\n+        self.checkmin = math.inf\n+        \n+    def push(self, x: int) -> None:\n+        if x <= self.checkmin:\n+            self.stack.append(self.checkmin)\n+            self.checkmin = x\n+        self.stack.append(x)\n+        \n+        \n+    def pop(self) -> None:\n+        # s = self.stack.pop()\n+        # if self.stack[-1] == self.checkmin:\n+        #     self.checkmin = self.stack.pop()\n+        \n+        if self.stack[-1] == self.checkmin:\n+            self.stack.pop()\n+            self.checkmin = self.stack[-1]\n+        self.stack.pop()\n+        \n+    def top(self) -> int:\n+        return self.stack[-1]\n+\n+    def getMin(self) -> int:\n+        return self.checkmin\n+\n+\n+# Your MinStack object will be instantiated and called as such:\n+# obj = MinStack()\n+# obj.push(x)\n+# obj.pop()\n+# param_3 = obj.top()\n+# param_4 = obj.getMin()\n+\n \n "
  }
]
