[
  {
    "sha": "a921045e229f85dd55992e5739a8c3665088a683",
    "filename": "DesignHashMap.py",
    "status": "added",
    "additions": 108,
    "deletions": 0,
    "changes": 108,
    "blob_url": "https://github.com/super30admin/Design-1/blob/a181c9dad0517b2553f1f6b787438e80968beda5/DesignHashMap.py",
    "raw_url": "https://github.com/super30admin/Design-1/raw/a181c9dad0517b2553f1f6b787438e80968beda5/DesignHashMap.py",
    "contents_url": "https://api.github.com/repos/super30admin/Design-1/contents/DesignHashMap.py?ref=a181c9dad0517b2553f1f6b787438e80968beda5",
    "patch": "@@ -0,0 +1,108 @@\n+'''\n+Time Complexity - O(N) \n+Space Complexity - O(N) \n+\n+Algorithm - We are suing separate chaining to handle collision issue. Worst case when after hashing we are getting the same value and new key is being appended to it\n+'''\n+\n+# ListNode to store key and value\n+class ListNode:\n+    def __init__(self,key,value):\n+        self.key = key\n+        self.value=value\n+        self.next = None\n+        \n+class MyHashMap:\n+\n+    def __init__(self):\n+        \"\"\"\n+        Initialize your data structure here.\n+        \"\"\"\n+        self.size = 10000\n+        self.nodes = [None]*self.size\n+        \n+    # Hashing funtion\n+    def getHash(self,key):\n+        return key%self.size\n+    \n+    # this function returns the prev ListNode of the key. If it does not exist, then returns the last key\n+    # TC - O(N)\n+    def findElement(self,key,head):\n+        prev=None\n+        cur = head\n+        \n+        while(cur != None and cur.key!=key):\n+            prev=cur\n+            cur=cur.next\n+            \n+        return prev\n+        \n+\n+    def put(self, key: int, value: int) -> None:\n+        \"\"\"\n+        value will always be non-negative.\n+        \"\"\"\n+        hash_value = self.getHash(key)\n+        if self.nodes[hash_value]==None:\n+            self.nodes[hash_value]=ListNode(-1,-1) # Creating a dummy node at the beginning\n+        prev = self.findElement(key,self.nodes[hash_value])\n+        \n+        # If key does not exist, then create a new ListNode with given key and value as next of prev node\n+        if prev.next==None:\n+            prev.next = ListNode(key,value)\n+            \n+        else:\n+            # else update the value of the key if key found Ask interviewer if he wants to update or return -1\n+            prev.next.value = value\n+        \n+\n+    def get(self, key: int) -> int:\n+        \"\"\"\n+        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key\n+        \"\"\"\n+        hash_value = self.getHash(key)\n+        \n+        # base case \n+        if self.nodes[hash_value] == None:\n+            return -1\n+        prev = self.findElement(key,self.nodes[hash_value])\n+        \n+        if prev.next == None:\n+            return -1\n+        \n+        return prev.next.value\n+        \n+\n+    def remove(self, key: int) -> None:\n+        \"\"\"\n+        Removes the mapping of the specified value key if this map contains a mapping for the key\n+        \"\"\"\n+        hash_value = self.getHash(key)\n+        if self.nodes[hash_value] == None:\n+            return\n+        prev = self.findElement(key,self.nodes[hash_value])\n+        \n+        if prev.next==None:\n+            return\n+        \n+        prev.next=prev.next.next\n+        \n+        \n+\n+\n+# Your MyHashMap object will be instantiated and called as such:\n+# obj = MyHashMap()\n+# obj.put(key,value)\n+# param_2 = obj.get(key)\n+# obj.remove(key)\n+        \n+# Driver code\n+hashmap = MyHashMap()\n+hashmap.put(1, 2)\n+hashmap.put(2, 3)\n+hashmap.get(1)            # returns 2\n+hashmap.get(3)            # returns -1 (not found)\n+hashmap.put(2, 4)         # update the existing value\n+hashmap.get(2)            # returns 4\n+hashmap.remove(2)         # remove the mapping for 2\n+hashmap.get(2)            # returns -1 (not found)\n\\ No newline at end of file"
  },
  {
    "sha": "ea2d0838e70ff5ab7976b0195743596820966d3b",
    "filename": "MinStack.py",
    "status": "added",
    "additions": 48,
    "deletions": 0,
    "changes": 48,
    "blob_url": "https://github.com/super30admin/Design-1/blob/a181c9dad0517b2553f1f6b787438e80968beda5/MinStack.py",
    "raw_url": "https://github.com/super30admin/Design-1/raw/a181c9dad0517b2553f1f6b787438e80968beda5/MinStack.py",
    "contents_url": "https://api.github.com/repos/super30admin/Design-1/contents/MinStack.py?ref=a181c9dad0517b2553f1f6b787438e80968beda5",
    "patch": "@@ -0,0 +1,48 @@\n+'''\n+Time Complexity - O(1)\n+Space Complexity - O(N)\n+'''\n+class MinStack:\n+\n+    def __init__(self):\n+        \"\"\"\n+        initialize your data structure here.\n+        \"\"\"\n+        self.stack = []\n+        self.minimum = float(\"inf\") # For keeping the hold of minimum value\n+\n+    def push(self, x: int) -> None:\n+        \n+        if x<=self.minimum:\n+            self.stack.append(self.minimum) # We are appending minimum so that when our current minimum is popped, then we have the hold of next minimum\n+            self.minimum=x\n+        self.stack.append(x)\n+        \n+        \n+\n+    def pop(self) -> None:\n+        \n+        if self.stack.pop()==self.minimum:\n+            self.minimum=self.stack.pop() # Updating by next minimum\n+\n+    def top(self) -> int:\n+        \n+        if len(self.stack)>0:\n+            return self.stack[-1]\n+        \n+        return -1\n+        \n+\n+    def getMin(self) -> int:\n+        \n+        return self.minimum # Returning the minimum value\n+        \n+        \n+\n+\n+# Your MinStack object will be instantiated and called as such:\n+# obj = MinStack()\n+# obj.push(x)\n+# obj.pop()\n+# param_3 = obj.top()\n+# param_4 = obj.getMin()\n\\ No newline at end of file"
  }
]
