[
  {
    "sha": "5a06c387b2e24bd046265784beef8344b3f8b41b",
    "filename": "Sample.java",
    "status": "modified",
    "additions": 70,
    "deletions": 4,
    "changes": 74,
    "blob_url": "https://github.com/super30admin/DP-1/blob/06e6683271f6e15aa48ca20148e5b4e3831770a0/Sample.java",
    "raw_url": "https://github.com/super30admin/DP-1/raw/06e6683271f6e15aa48ca20148e5b4e3831770a0/Sample.java",
    "contents_url": "https://api.github.com/repos/super30admin/DP-1/contents/Sample.java?ref=06e6683271f6e15aa48ca20148e5b4e3831770a0",
    "patch": "@@ -1,7 +1,73 @@\n-// Time Complexity :\n-// Space Complexity :\n-// Did this code successfully run on Leetcode :\n-// Any problem you faced while coding this :\n+// Time Complexity : O(n^2) where n is the number of decisions made at each level\n+// Space Complexity : O(m*n), for making use of dp[][] matrix to store the optimal sub-structures and eventually the final result.\n+// Did this code successfully run on Leetcode : yes\n+// Any problem you faced while coding this : I was able solve the problem on paper, while writing the code I initially found it difficult to come up with the conditions. With few errors & with the help of video lecture, I was able to figure out the way.\n \n \n // Your code here along with comments explaining your approach\n+\n+/*\n+ * Coin change problem is basically trying to find out the least number of ways to reach the final target. Initially I started with the approach of selecting each coin and seeing if I reached the target, again making a decision not to select and repeat the procedure of Choose/not choose at every level.\n+ * Came across scenarios where the overlapping subproblems were present, and optimal substructure at each interval helped in finding the result.\n+ * Made use of a 2D matrix to store the results at each index.\n+ * Every element represents the minimum number of ways to reach the amount.\n+ * Main conditions that were kept in mind was: \n+ * 1. when the given coin denomination is greater than the amount. (copy the value on the previous row, same column)\n+ * 2. find the minimum of making a choice to 1. keep the coin, 2. not keep the coin. \n+ * */\n+\n+class Solution{\n+\t\n+\tpublic static int coinChange(int[] coins,int amount) {\n+\t\t\n+\t\t//define row\n+\t\tint row = coins.length+1;\n+\t\t\n+\t\t//define column\n+\t\tint col = amount+1;\n+\t\t\n+\t\tint[][] dp = new int[row][col];\n+\t\t\n+\t\t//The first row, all the columns from 1 are made infinite as we keep adding '0' and we wont be able to reach the total number of coins.\n+\t\tfor(int j=1;j<col;j++)\n+\t\t\tdp[0][j] = 10001;\n+\t\t\n+\t\t//1.Choose -> choosing one denomination 1+current amount - denomination at that index 2.Don't choose -> option when we dont select the coin denomination. We just use the value which is in the above row.\n+\t\tfor(int i=1;i<row;i++) {\n+\t\t\tfor(int j=1;j<col;j++) {\n+\t\t\t\tif(coins[i-1]>j)\n+\t\t\t\t\tdp[i][j] = dp[i-1][j];\n+\t\t\t\telse {\n+\t\t\t\t\tdp[i][j] = Math.min(1+dp[i][j-coins[i-1]], dp[i-1][j]);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn dp[row-1][col-1] == 10001 ? -1:dp[row-1][col-1];\n+\t\t\n+\t}\n+\t\n+\t\n+\t// Time Complexity : O(n)\n+\t// Space Complexity : O(1)\n+\t// Did this code successfully run on Leetcode : yes\n+\t// Any problem you faced while coding this : no\n+\t\n+\t/*\n+\t * Adjacent houses wont be robbed, So at every house I had an option either to choose the house or not. If the house is Chosen, I can consider the path sum of previously not chosen value. Similarly, If I am not choosing a house I can select the Max of previously chosen or not chosen house.\n+\t * */\n+\tpublic static int houseRobber(int[] nums) {\n+\t\tif(nums==null || nums.length ==0)\n+\t\t\treturn 0;\n+\t\t\n+\t\tint C = 0, DC = 0;\n+\t\t\n+\t\tfor(int x:nums) {\n+\t\t\tint temp = DC;\n+\t\t\tDC = Math.max(C, DC);\n+\t\t\tC = x + temp;\n+\t\t}\n+\t\t\n+\t\treturn Math.max(C, DC);\n+\t}\n+}"
  }
]
