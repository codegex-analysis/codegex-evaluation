[
  {
    "sha": "1302cb9daf1858f716b4a3f9914009090619f005",
    "filename": "Exclusive Time of Functions.java",
    "status": "added",
    "additions": 56,
    "deletions": 0,
    "changes": 56,
    "blob_url": "https://github.com/super30admin/Stack-2/blob/370225d5f914cfc301dd4c7965c512274bf88bcf/Exclusive%20Time%20of%20Functions.java",
    "raw_url": "https://github.com/super30admin/Stack-2/raw/370225d5f914cfc301dd4c7965c512274bf88bcf/Exclusive%20Time%20of%20Functions.java",
    "contents_url": "https://api.github.com/repos/super30admin/Stack-2/contents/Exclusive%20Time%20of%20Functions.java?ref=370225d5f914cfc301dd4c7965c512274bf88bcf",
    "patch": "@@ -0,0 +1,56 @@\n+/*\n+class Solution:\n+    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\n+        if logs is None or len(logs) == 0:\n+            return []\n+        \n+        result = [0]*n\n+        stack = []\n+        cur = 0\n+        prev = 0\n+        for i in range(len(logs)):\n+            string = logs[i].split(\":\")\n+            cur = int(string[2])\n+            if string[1] == \"start\":\n+                if len(stack) > 0:\n+                    result[stack[-1]] += cur - prev\n+                    prev = cur\n+                stack.append(int(string[0]))\n+                \n+            else:\n+                result[stack.pop()] += cur - prev + 1\n+                prev = cur + 1\n+                \n+        return result\n+*/\n+// time - O(n)\n+// space - O(n)\n+// logic - whenever there is start I push onto stack and calculate for how much units the previous process ran by taking index from stack\n+// whenever there is end i pop from stack and calculate the unit for the process\n+class Solution {\n+    public int[] exclusiveTime(int n, List<String> logs) {\n+        if (logs == null || logs.size() == 0)\n+            return new int[]{};\n+        \n+        int[] result = new int[n];\n+        Stack<Integer> stack = new Stack<>();\n+        int cur = 0, prev = 0;\n+        for (int i=0; i<logs.size(); i++){\n+            String[] s = logs.get(i).split(\":\");\n+            cur = Integer.parseInt(s[2]);\n+            \n+            if (s[1].equals(\"start\")){\n+                if (!stack.isEmpty()){\n+                    result[stack.peek()] += cur - prev;\n+                    prev = cur;\n+                }\n+                stack.push(Integer.parseInt(s[0]));\n+            }\n+            else{\n+                result[stack.pop()] += cur - prev + 1;\n+                prev = cur + 1;\n+            }\n+        }\n+        return result;\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "7aa385d7c4de958e7cb96e9ae248dedbb1d6467d",
    "filename": "Valid Parentheses.java",
    "status": "added",
    "additions": 81,
    "deletions": 0,
    "changes": 81,
    "blob_url": "https://github.com/super30admin/Stack-2/blob/370225d5f914cfc301dd4c7965c512274bf88bcf/Valid%20Parentheses.java",
    "raw_url": "https://github.com/super30admin/Stack-2/raw/370225d5f914cfc301dd4c7965c512274bf88bcf/Valid%20Parentheses.java",
    "contents_url": "https://api.github.com/repos/super30admin/Stack-2/contents/Valid%20Parentheses.java?ref=370225d5f914cfc301dd4c7965c512274bf88bcf",
    "patch": "@@ -0,0 +1,81 @@\n+/* for a single type of bracket like just { or [ or ( this below code should pass\n+class Solution:\n+    def isValid(self, s: str) -> bool:\n+        if len(s) % 2 != 0:\n+            return False\n+        \n+        count = 0\n+        for i in range(len(s)):\n+            \n+            if s[i] == \"(\":\n+                count += 1\n+            \n+            else:\n+                count -= 1\n+                \n+            if i == 0:\n+                if count < 0:\n+                    return False\n+                \n+            \n+        if count != 0:\n+            return False\n+        \n+        return True\n+\n+\n+class Solution:\n+    def isValid(self, s: str) -> bool:\n+        if s is None or len(s) == 0 or len(s) % 2 != 0:\n+            return False\n+        \n+        stack = []\n+        for c in s:\n+            if c == \"(\":\n+                stack.append(\")\")\n+                \n+            elif c == \"{\":\n+                stack.append(\"}\")\n+                \n+            elif c == \"[\":\n+                stack.append(\"]\")\n+            \n+            elif len(stack) == 0 or stack.pop() != c:\n+                return False\n+            \n+        if len(stack) != 0:\n+            return False\n+        \n+        return True\n+*/\n+// time - O(n)\n+// space - O(n)\n+// logic - pushed the bracket onto stack if it was opening and popped out from stack if it is closing\n+class Solution {\n+    public boolean isValid(String s) {\n+        if (s == null || s.length() == 0 || s.length() % 2 != 0)\n+            return false;\n+        \n+        Stack<Character> stack = new Stack<>();\n+        for (int i=0; i<s.length(); i++){\n+            char c = s.charAt(i);\n+            \n+            if (c == '(')\n+                stack.push(')');\n+            \n+            else if (c == '[')\n+                stack.push(']');\n+            \n+            else if (c == '{')\n+                stack.push('}');\n+            \n+            else if (stack.isEmpty() || stack.pop() != c)\n+                return false;\n+        }\n+        \n+        if (!stack.isEmpty())\n+            return false;\n+        \n+        return true;\n+    }\n+}"
  }
]
