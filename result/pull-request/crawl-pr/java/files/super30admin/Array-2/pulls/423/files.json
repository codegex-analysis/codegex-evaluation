[
  {
    "sha": "4f63471e5cb02223991194717447b4985afeeb26",
    "filename": "FindAllNumbersDisappearedInArray.java",
    "status": "added",
    "additions": 76,
    "deletions": 0,
    "changes": 76,
    "blob_url": "https://github.com/super30admin/Array-2/blob/b43833f14db1f8753c370815a227e50d0b4dce6e/FindAllNumbersDisappearedInArray.java",
    "raw_url": "https://github.com/super30admin/Array-2/raw/b43833f14db1f8753c370815a227e50d0b4dce6e/FindAllNumbersDisappearedInArray.java",
    "contents_url": "https://api.github.com/repos/super30admin/Array-2/contents/FindAllNumbersDisappearedInArray.java?ref=b43833f14db1f8753c370815a227e50d0b4dce6e",
    "patch": "@@ -0,0 +1,76 @@\n+// TC - O(n), SC - O(1)\n+\n+// Constant space and O(n) approach\n+class Solution {\n+    public List<Integer> findDisappearedNumbers(int[] nums) {\n+        // Sanity check, if nums is null or length is 0, return empty arraylist\n+        if(nums == null || nums.length == 0){\n+            return new ArrayList<>();\n+        }\n+        // Initialize a result ArrayList\n+        List<Integer> result = new ArrayList<>();\n+        int n = nums.length;\n+        // Itearate over nums array, if number at ith index is x, we update xth index to negative value, as we can make sure if there is negative value, we encountered that value in array and if it is positive we can say that index value is missing in array and add it to arraylist\n+        for(int i=0; i<n; i++){\n+            int idx = Math.abs(nums[i]) - 1;\n+            if(nums[idx] > 0){\n+                nums[idx] *= -1;\n+            }\n+        }\n+        \n+        for(int i=0; i<nums.length; i++){\n+            if(nums[i] > 0){\n+                result.add(i+1);\n+            }\n+        }\n+        return result;\n+    }\n+}\n+\n+\n+// Using HashMap TC - O(n), SC - O(n)\n+// class Solution {\n+//     public List<Integer> findDisappearedNumbers(int[] nums) {\n+//         if(nums == null || nums.length == 0){\n+//             return new ArrayList<>();\n+//         }\n+//         List<Integer> result = new ArrayList<>();\n+//         Map<Integer, Boolean> map = new HashMap<>();\n+        \n+//         for(int i=0; i<nums.length; i++){\n+//             map.put(nums[i], true);\n+//         }\n+        \n+//         for(int i=1; i<=nums.length; i++){\n+//             if(!map.containsKey(i)){\n+//                 result.add(i);\n+//             }\n+//         }\n+//         return result;\n+//     }\n+// }\n+\n+\n+// BruteForce - Time Limit Exceeded\n+// class Solution {\n+//     public List<Integer> findDisappearedNumbers(int[] nums) {\n+//         if(nums == null || nums.length == 0){\n+//             return new ArrayList<>();\n+//         }\n+//         List<Integer> result = new ArrayList<>();\n+//         boolean numFound = false;\n+//         for(int i=0; i<nums.length; i++){\n+//             numFound = false;\n+//             for(int j=0; j<nums.length; j++){\n+//                 if(nums[j] == i+1){\n+//                     numFound = true;\n+//                     break;\n+//                 }\n+//             }\n+//             if(numFound == false){\n+//                 result.add(i+1);\n+//             }\n+//         }\n+//         return result;\n+//     }\n+// }\n\\ No newline at end of file"
  },
  {
    "sha": "7d2c035eed4b5b2f343a9f0c01c4a36010cd8da5",
    "filename": "FindMinAndMaxInArray.java",
    "status": "added",
    "additions": 40,
    "deletions": 0,
    "changes": 40,
    "blob_url": "https://github.com/super30admin/Array-2/blob/b43833f14db1f8753c370815a227e50d0b4dce6e/FindMinAndMaxInArray.java",
    "raw_url": "https://github.com/super30admin/Array-2/raw/b43833f14db1f8753c370815a227e50d0b4dce6e/FindMinAndMaxInArray.java",
    "contents_url": "https://api.github.com/repos/super30admin/Array-2/contents/FindMinAndMaxInArray.java?ref=b43833f14db1f8753c370815a227e50d0b4dce6e",
    "patch": "@@ -0,0 +1,40 @@\n+// TC - O(log n), SC - O(1)\n+\n+// Find min and max in array in less than 2*(n-1) comparisons, n is length of array\n+public class FindMinAndMaxInArray {\n+\tpublic static void main(String[] args) {\n+\t\tint[] nums = {4, 2, 7, 1, 9, 8, 10};\n+\t\t// Initializing min and max values\n+\t\tint min = Integer.MAX_VALUE;\n+\t\tint max = Integer.MIN_VALUE;\n+\t\t\n+\t\t// i is used to keep track of first element and second element in pair and j for number of iterations\n+\t\t// Instead of comparing every value with min and max, in the array we take pairs and compare between them, element which is higher will be compared with max value and element with lower value will be compared to min value\n+\t\t// In this way, we reduce 1 comparison for every 2 elements and update min and max value accordingly\n+\t\tint i=0;\n+\t\tint j=0;\n+\t\t\n+\t\twhile(j < nums.length/2) {\n+\t\t\tint firstEle = i;\n+\t\t\tint secEle = i+1;\n+\t\t\ti+=2;\n+\t\t\tif(nums[firstEle] < nums[secEle]) {\n+\t\t\t\tmin = Math.min(nums[firstEle], min);\n+\t\t\t\tmax = Math.max(nums[secEle], max);\n+\t\t\t}else {\n+\t\t\t\tmin = Math.min(nums[secEle], min);\n+\t\t\t\tmax = Math.max(nums[firstEle], max);\n+\t\t\t}\n+\t\t\tj++;\n+\t\t}\n+\t\t\n+\t\t// Above logic will work when array length is even as pairs will sum up to even, when length is odd, an element will be left at back. Compare that value with min and max and update accordingly.\n+\t\tif(nums.length % 2 == 1) {\n+\t\t\tmin = Math.min(nums[nums.length - 1], min);\n+\t\t\tmax = Math.max(nums[nums.length - 1], max);\n+\t\t}\n+\t\t\n+\t\tSystem.out.println(\"Minimum element is: \"+min+\", Maximum element is: \"+max);\n+\t\t\n+\t}\n+}"
  },
  {
    "sha": "08d7f1894ff517cc02ceddda1ce4a3674c085fdf",
    "filename": "GameOfLife.java",
    "status": "added",
    "additions": 183,
    "deletions": 0,
    "changes": 183,
    "blob_url": "https://github.com/super30admin/Array-2/blob/b43833f14db1f8753c370815a227e50d0b4dce6e/GameOfLife.java",
    "raw_url": "https://github.com/super30admin/Array-2/raw/b43833f14db1f8753c370815a227e50d0b4dce6e/GameOfLife.java",
    "contents_url": "https://api.github.com/repos/super30admin/Array-2/contents/GameOfLife.java?ref=b43833f14db1f8753c370815a227e50d0b4dce6e",
    "patch": "@@ -0,0 +1,183 @@\n+// TC - O(m X n), SC - O(1)\n+\n+// Using constant space and dirs[][] array\n+class Solution {\n+    public void gameOfLife(int[][] board) {\n+        // Sanity check when board is null or length of board is 0\n+        if(board == null || board.length == 0){\n+            return;\n+        }\n+        int m = board.length;\n+        int n = board[0].length;\n+        // Iterate over each element in matrix and call findLiveOrDead method\n+        for(int i=0; i<m; i++){\n+            for(int j=0; j<n; j++){\n+                board[i][j] = findLiveOrDead(board, i, j);\n+            }\n+        }\n+        \n+        \n+        /// Iterate over board matrix and if we encounter 3, change it to 0 and if we encounter 2, change it to 2\n+        for(int i=0; i<m; i++){\n+             for(int j=0; j<n; j++){\n+                 if(board[i][j] == 3){\n+                     board[i][j] = 0;\n+                 }else if(board[i][j] == 2){\n+                     board[i][j] = 1;\n+                 }\n+             }\n+        }\n+    }\n+    \n+    private static int findLiveOrDead(int[][] board, int i, int j){\n+        // Initalize ct variable to 0, this stores number of alive cells around current cell\n+        int ct = 0;\n+        int m = board.length - 1;\n+        int n = board[0].length - 1;\n+        // Initializing dirs array, these are 8 directions from current cell in matrix\n+        int[][] dirs = {{0, -1}, {-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}};\n+        \n+        // Iterating over dirs array \n+        for(int x=0; x<dirs.length; x++){\n+            // r is row and c is column of particular direction, we add up current i value to current dirs row or column value\n+            int r = i+dirs[x][0];\n+            int c = j+dirs[x][1];\n+            // Check if r and c is in boundary of matrix\n+            if(r >= 0 && r <= m && c >= 0 && c <= n){\n+                // if rth row and cth column is 1 or 3, increment ct, we use 3 because when state changed from 1 to 0, we store in 0 as 3 as we need constant space\n+                if(board[r][c] == 1 || board[r][c] == 3){\n+                    ct++;\n+                }\n+            }\n+        }\n+        \n+        // Rules check\n+        if(board[i][j] == 1 && ct < 2){\n+            return 3;\n+        }else if(board[i][j] == 1 && ct > 3){\n+            return 3;\n+        }else if(board[i][j] == 0 && ct == 3){\n+            return 2;\n+        }\n+        return board[i][j]; \n+    }\n+}\n+\n+\n+// Using dirs[][] array and O(m X n) extra space\n+// class Solution {\n+//     public void gameOfLife(int[][] board) {\n+//         int m = board.length;\n+//         int n = board[0].length;\n+//         int[][] result = new int[m][n];\n+//         for(int i=0; i<m; i++){\n+//             for(int j=0; j<n; j++){\n+//                 result[i][j] = findLiveOrDead(board, i, j);\n+//             }\n+//         }\n+//         for(int i=0; i<m; i++){\n+//             for(int j=0; j<n; j++){\n+//                 board[i][j] = result[i][j];       \n+//             }\n+//         }\n+//     }\n+    \n+//     private static int findLiveOrDead(int[][] board, int i, int j){\n+//         int ct = 0;\n+//         int m = board.length - 1;\n+//         int n = board[0].length - 1;\n+//         int[][] dirs = {{0, -1}, {-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}};\n+        \n+//         for(int x=0; x<dirs.length; x++){\n+//             int r = i+dirs[x][0];\n+//             int c = j+dirs[x][1];\n+//             if(r >= 0 && r <= m && c >= 0 && c <= n){\n+//                 if(board[r][c] == 1){\n+//                     ct++;\n+//                 }\n+//             }\n+//         }\n+//         if(board[i][j] == 1 && ct < 2){\n+//             return 0;\n+//         }else if(board[i][j] == 1 && ct > 3){\n+//             return 0;\n+//         }else if(board[i][j] == 0 && ct == 3){\n+//             return 1;\n+//         }\n+//         return board[i][j]; \n+//     }\n+// }\n+\n+\n+// Using O(m X n) extra space\n+// class Solution {\n+//     public void gameOfLife(int[][] board) {\n+//         int m = board.length;\n+//         int n = board[0].length;\n+//         int[][] result = new int[m][n];\n+//         for(int i=0; i<m; i++){\n+//             for(int j=0; j<n; j++){\n+//                 result[i][j] = findLiveOrDead(board, i, j);\n+//             }\n+//         }\n+//         for(int i=0; i<m; i++){\n+//             for(int j=0; j<n; j++){\n+//                 board[i][j] = result[i][j];       \n+//             }\n+//         }\n+//     }\n+    \n+//     private static int findLiveOrDead(int[][] board, int i, int j){\n+//         int ct = 0;\n+//         int m = board.length - 1;\n+//         int n = board[0].length - 1;\n+//         if(j-1 >= 0){\n+//             if(board[i][j-1] == 1){  \n+//                 ct++;\n+//             }\n+//         }\n+//         if(j-1 >= 0 && i-1 >= 0){\n+//             if(board[i-1][j-1] == 1){  \n+//                 ct++;\n+//             }\n+//         }\n+//         if(i-1 >= 0){\n+//             if(board[i-1][j] == 1){  \n+//                 ct++;\n+//             }\n+//         }\n+//         if(i-1 >= 0 && j+1 <= n){\n+//             if(board[i-1][j+1] == 1){  \n+//                 ct++;\n+//             }\n+//         }\n+//         if(j+1 <= n){\n+//             if(board[i][j+1] == 1){  \n+//                 ct++;\n+//             }\n+//         }\n+//         if(i+1 <= m && j+1 <= n){\n+//             if(board[i+1][j+1] == 1){  \n+//                 ct++;\n+//             }\n+//         }\n+//         if(i+1 <= m ){\n+//             if(board[i+1][j] == 1){  \n+//                 ct++;\n+//             }\n+//         }\n+//         if(i+1 <= m && j-1 >= 0){\n+//             if(board[i+1][j-1] == 1){  \n+//                 ct++;\n+//             }\n+//         }\n+//         if(board[i][j] == 1 && ct < 2){\n+//             return 0;\n+//         }else if(board[i][j] == 1 && ct > 3){\n+//             return 0;\n+//         }else if(board[i][j] == 0 && ct == 3){\n+//             return 1;\n+//         }\n+//         return board[i][j];\n+//     }\n+// }\n\\ No newline at end of file"
  },
  {
    "sha": "d9163f022497d43baf2bb239cb2dd3d0bc0f144d",
    "filename": "README.md",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/super30admin/Array-2/blob/b43833f14db1f8753c370815a227e50d0b4dce6e/README.md",
    "raw_url": "https://github.com/super30admin/Array-2/raw/b43833f14db1f8753c370815a227e50d0b4dce6e/README.md",
    "contents_url": "https://api.github.com/repos/super30admin/Array-2/contents/README.md?ref=b43833f14db1f8753c370815a227e50d0b4dce6e",
    "patch": "@@ -1,10 +1,12 @@\n # Array-2\n \n+Leetcode 448\n ## Problem1 (https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/)\n \n \n ## Problem2\n Given an array of numbers of length N, find both the minimum and maximum. Follow up : Can you do it using less than 2 * (N - 2) comparison\n \n+Leetcode 289\n ## Problem3 (https://leetcode.com/problems/game-of-life/)\n "
  },
  {
    "sha": "f5c45b5fea98d036342c0c758d3e9f09966f8f3a",
    "filename": "Sample.java",
    "status": "removed",
    "additions": 0,
    "deletions": 7,
    "changes": 7,
    "blob_url": "https://github.com/super30admin/Array-2/blob/febece769198fd9409b02e1f999074172dea5d3f/Sample.java",
    "raw_url": "https://github.com/super30admin/Array-2/raw/febece769198fd9409b02e1f999074172dea5d3f/Sample.java",
    "contents_url": "https://api.github.com/repos/super30admin/Array-2/contents/Sample.java?ref=febece769198fd9409b02e1f999074172dea5d3f",
    "patch": "@@ -1,7 +0,0 @@\n-// Time Complexity :\r\n-// Space Complexity :\r\n-// Did this code successfully run on Leetcode :\r\n-// Any problem you faced while coding this :\r\n-\r\n-\r\n-// Your code here along with comments explaining your approach\n\\ No newline at end of file"
  }
]
