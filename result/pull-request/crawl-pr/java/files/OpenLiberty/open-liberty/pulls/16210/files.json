[
  {
    "sha": "91fce934a010f3c5d4b22ffc3f5f3b0cc9d4f421",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/build.gradle",
    "status": "modified",
    "additions": 5,
    "deletions": 2,
    "changes": 7,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/build.gradle",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/build.gradle",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/build.gradle?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -1,17 +1,20 @@\n /**\n  * Copy the OSGi bundle into the osgiEmbedManager test application.\n  */\n+\n task prebuild(type: Sync) {\n     mkdir(\"test-applications/osgiEmbedManager/resources/WEB-INF/lib\")\n     into \"test-applications/osgiEmbedManager/resources/WEB-INF/lib\" \n     from(\"../org.eclipse.osgi/build/libs\") {\n         include \"org.eclipse.osgi.jar\"\n     }\n }\n-build.dependsOn prebuild\n+build.dependsOn 'prebuild'\n+build.dependsOn ':wlp.lib.extract:assemble'\n \n task postrunfat(type: Delete) {\n   dependsOn prebuild\n   delete new File(\"test-applications/osgiEmbedManager/resources/WEB-INF/lib\", \"org.eclipse.osgi.jar\")\n }\n-runfat.finalizedBy postrunfat\n\\ No newline at end of file\n+runfat.finalizedBy postrunfat\n+"
  },
  {
    "sha": "2c69eb5f81feea82519d873df86ee87d42b408f3",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/FATSuite.java",
    "status": "modified",
    "additions": 8,
    "deletions": 7,
    "changes": 15,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/FATSuite.java",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/FATSuite.java",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/FATSuite.java?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2012 IBM Corporation and others.\n+ * Copyright (c) 2012, 2021 IBM Corporation and others.\n  * All rights reserved. This program and the accompanying materials\n  * are made available under the terms of the Eclipse Public License v1.0\n  * which accompanies this distribution, and is available at\n@@ -21,9 +21,9 @@\n import com.ibm.ws.kernel.boot.commandport.ServerCommandPortTest;\n import com.ibm.ws.kernel.boot.internal.commands.LogLevelPropertyTest;\n import com.ibm.ws.kernel.boot.internal.commands.PackageCommandTest;\n-import com.ibm.ws.kernel.boot.internal.commands.PackageLooseConfigTest;\n-import com.ibm.ws.kernel.boot.internal.commands.PackageLooseConfigDropinsTest;\n-import com.ibm.ws.kernel.boot.internal.commands.PackageLooseConfigParameterizedTest;\n+import com.ibm.ws.kernel.boot.internal.commands.PackageLooseRunnableTest;\n+import com.ibm.ws.kernel.boot.internal.commands.PackageLooseContentsTest;\n+import com.ibm.ws.kernel.boot.internal.commands.PackageLooseFilterTest;\n import com.ibm.ws.kernel.osgi.OSGiEmbedManagerTest;\n import com.ibm.ws.kernel.provisioning.KernelChangeTest;\n import com.ibm.ws.kernel.provisioning.ProvisioningTest;\n@@ -54,9 +54,9 @@\n                 ServerCommandPortTest.class,\n                 DumpCommandTest.class,\n                 PackageCommandTest.class,\n-                PackageLooseConfigTest.class,\n-                PackageLooseConfigDropinsTest.class,\n-                PackageLooseConfigParameterizedTest.class,\n+                PackageLooseRunnableTest.class,\n+                PackageLooseContentsTest.class,\n+//                PackageLooseFilterTest.class, // Recreates issue 15724; disabled until that is fixed.\n                 LogLevelPropertyTest.class,\n                 CreateCommandTest.class,\n                 StartCommandTest.class,\n@@ -69,4 +69,5 @@\n                 OSGiEmbedManagerTest.class\n })\n public class FATSuite {\n+    // Empty\n }"
  },
  {
    "sha": "28d45878a2dfcdbc2447fe40551cf7729d25bbb1",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/AbstractLooseConfigTest.java",
    "status": "modified",
    "additions": 715,
    "deletions": 62,
    "changes": 777,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/AbstractLooseConfigTest.java",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/AbstractLooseConfigTest.java",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/AbstractLooseConfigTest.java?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2018 IBM Corporation and others.\n+ * Copyright (c) 2018, 2021 IBM Corporation and others.\n  * All rights reserved. This program and the accompanying materials\n  * are made available under the terms of the Eclipse Public License v1.0\n  * which accompanies this distribution, and is available at\n@@ -10,93 +10,746 @@\n  *******************************************************************************/\n package com.ibm.ws.kernel.boot.internal.commands;\n \n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n-import java.util.Arrays;\n+import java.io.BufferedReader;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n import java.util.Collection;\n+import java.util.Enumeration;\n import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.regex.Pattern;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipInputStream;\n+\n+import com.ibm.websphere.simplicity.ProgramOutput;\n \n import componenttest.topology.impl.LibertyServer;\n \n-/**\n- *\n- */\n public abstract class AbstractLooseConfigTest {\n-    protected static final String SERVER_NAME = \"com.ibm.ws.kernel.boot.loose.config.fat\";\n-    protected static final String SERVER_ROOT = \"MyRoot\";\n-    // For Usr and server-root, there should be no /usr in the structure\n-    protected static final String SERVER_PATH = SERVER_ROOT + \"/servers/\" + SERVER_NAME;\n-    protected static final String ARCHIVE_PACKAGE = \"MyPackage.zip\";\n+    protected static final long MS_IN_SEC = 1000;\n+    protected static final long NS_IN_SEC = 1000000000;\n+\n+    // Local folders ...\n+    \n+    protected static final String BUILD_DIR = \"build\";\n     protected static final String PUBLISH_RESOURCES = \"publish/resources/\";\n     protected static final String CONFIG_SOURCE = PUBLISH_RESOURCES + \"configs/\";\n     protected static final String TMP_SOURCE = PUBLISH_RESOURCES + \"tmp/\";\n+\n+    // Liberty image folders ...\n+\n     protected static final String APPS_DIR = \"apps\";\n     protected static final String DROPINS_DIR = \"dropins\";\n-    private static final String[] CONFIGS = new String[] {\n-                                                           \"DefaultArchive.war.xml\",\n-                                                           \"SimpleElements.war.xml\",\n-                                                           \"ArchivedElements.war.xml\",\n-                                                           \"SkipInvalidEntries.war.xml\",\n-                                                           \"EarArchive.ear.xml\",\n-    };\n-\n-    protected static Collection<Object[]> getConfigsAsParameters() {\n-        Object[][] params = new Object[CONFIGS.length][1];\n-        for (int i = 0; i < CONFIGS.length; i++) {\n-            params[i][0] = CONFIGS[i];\n-        }\n-        return Arrays.asList(params);\n-    }\n+\n+    public abstract String getAppsTargetDir();\n+    \n+    // The liberty server used by these tests ...\n+    // Also, a liberty image folder.\n+\n+    protected static final String SERVER_NAME = \"com.ibm.ws.kernel.boot.loose.config.fat\";\n+    protected static final String SERVER_NAME_JAR = SERVER_NAME + \".jar\";\n+    protected static final String SERVER_NAME_ZIP = SERVER_NAME + \".zip\";\n+\n+    // Packaging values ...\n+  \n+    protected static final String ARCHIVE_NAME_ZIP = \"MyPackage.zip\";\n+    protected static final String ARCHIVE_NAME_1_JAR = \"MyPackage1.jar\";\n+    protected static final String ARCHIVE_NAME_2_JAR = \"MyPackage2.jar\";\n+\n+    protected static final String SERVER_ROOT_DEFAULT = \"wlp\";\n+    protected static final String SERVER_ROOT = \"MyRoot\";\n \n     /**\n-     * Add the given value to the value found in checkMatch at the given key if one\n-     * exists, otherwise make a new entry\n-     *\n-     * @param checkMatch\n-     * @param key\n-     * @param value\n+     * Environment variable used to specify where the liberty image\n+     * is extracted when launching a liberty runnable jar.\n      */\n-    protected void putMatch(HashMap<String, Integer> checkMatch, String key, int value) {\n-        int match = checkMatch.get(key) == null ? 0 : checkMatch.get(key);\n-        checkMatch.put(key, match + value);\n+    protected static final String WLP_EXTRACT_PROPERTY_NAME = \"WLP_JAR_EXTRACT_ROOT\";\n+\n+    /**\n+     * Value to assign to the wlp-extract property.\n+     */\n+    protected static final String WLP_EXTRACT = \"wlpExtract\";\n+\n+    //\n+    \n+    private LibertyServer server;\n+\n+    protected LibertyServer getServer() {\n+        return server;\n     }\n \n-    public void packageWithConfig(LibertyServer server, String[] cmd) throws Exception {\n-        packageWithConfig(server, \"DefaultArchive.war.xml\", cmd);\n+    protected void setServer(LibertyServer server) {\n+        this.server = server;\n     }\n \n-    public void packageWithConfig(LibertyServer server, String config) throws Exception {\n-        String[] cmd = new String[] { \"--archive=\" + ARCHIVE_PACKAGE, \"--include=usr\", \"--server-root=\" + SERVER_ROOT };\n-        packageWithConfig(server, config, cmd);\n+    //\n+\n+    protected String packageRunnable(\n+        String moduleName, String packageName, String serverRoot)\n+        throws Exception {\n+\n+        String[] packageCmd;\n+\n+        if ( !serverRoot.equals(SERVER_ROOT_DEFAULT) ) {\n+            // The server root parameter is ignored!\n+            // stdout will display the following,\n+            // and 'wlp' will be used as the server root.\n+            //\n+            // Packaging server com.ibm.ws.kernel.boot.loose.config.fat.\n+            // CWWKE0948W: A --server-root option with --include=runnable\n+            //   is not an allowed combination. The default argument of wlp\n+            //   is used for the server root.\n+            // Server com.ibm.ws.kernel.boot.loose.config.fat package complete\n+            //   in C:\\\\dev\\\\repos-pub\\\\open-liberty\\\\dev\\\\build.image\\\\wlp\\\\usr\\\\servers\\\\com.ibm.ws.kernel.boot.loose.config.fat\\\\MyPackage2.jar.\n+\n+            packageCmd = new String[] {\n+                \"--archive=\" + packageName,\n+                \"--include=runnable\",\n+                \"--server-root=\" + serverRoot\n+                };\n+\n+        } else {\n+            packageCmd = new String[] {\n+                \"--archive=\" + packageName,\n+                \"--include=runnable\"\n+            };            \n+        }\n+\n+        packageServer(moduleName, packageName, packageCmd);\n+\n+        return getServer().getServerRoot() + '/' + packageName;\n     }\n \n-    /**\n-     * Copy the loose config file into the given server, with the given loose config file,\n-     * then run the package command with the given args.\n-     *\n-     * @param server\n-     * @param config\n-     * @param cmd\n-     * @throws Exception\n-     */\n-    public void packageWithConfig(LibertyServer server, String config, String[] cmd) throws Exception {\n-        System.out.printf(\"%2s-config: %s%n\", \"\", config);\n+    public String packageServer(\n+        String looseConfig, String archiveName,\n+        String[] packageCmd) throws Exception {\n+\n+        String methodName = \"packageServer\";\n+\n+        String looseConfigPath = getAppsTargetDir() + '/' + looseConfig;\n+        String archivePath = server.getServerRoot() + '/' + archiveName;        \n+\n+        System.out.println(methodName + \": Server: \" + server.getServerName());\n+        System.out.println(methodName + \": Loose config: \" + looseConfig);\n+        System.out.println(methodName + \": Loose config path: \" + looseConfigPath);\n+        System.out.println(methodName + \": Archive: \" + archiveName);\n+        System.out.println(methodName + \": Archive path: \" + archivePath);\n+\n+        for ( String cmdArg : packageCmd ) {\n+            System.out.println(methodName + \": Package arg: \" + cmdArg);\n+        }\n \n         server.getFileFromLibertyInstallRoot(\"lib/extract\");\n \n-        // Find the config in PUBLISH_RESOURCES and move it to APPS_DIR in the server\n-        server.copyFileToLibertyServerRoot(CONFIG_SOURCE, getAppsTargetDir(), config);\n+        server.copyFileToLibertyServerRoot(CONFIG_SOURCE, getAppsTargetDir(), looseConfig);\n \n-        // Package the server and ensure it completes\n-        String stdout = server.executeServerScript(\"package\", cmd).getStdout();\n-        assertTrue(\"The package command did not complete as expected. STDOUT = \" + stdout,\n-                   stdout.contains(\"package complete\"));\n+        ProgramOutput output = server.executeServerScript(\"package\", packageCmd);\n+        String stdout = output.getStdout();\n+        String stderr = output.getStderr();\n+        if ( !stdout.isEmpty() ) {\n+            System.out.print(\"stdout:\");\n+            System.out.println(stdout);\n+        }\n+        if ( !stderr.isEmpty() ) {\n+            System.out.println(\"stderr:\");        \n+            System.out.print(stderr);\n+        }\n+        if ( !stdout.contains(\"package complete\") ) {\n+            fail(\"Package of [ \" + server.getInstallRoot() + \" ] into [ \" + archiveName + \" ] command did not complete. STDOUT = \" + stdout);\n+        }\n+\n+        return archivePath;\n     }\n \n-    /**\n-     * @return\n-     */\n-    public String getAppsTargetDir() {\n-        return APPS_DIR;\n+    protected static final boolean INCLUDE_USR = true;\n+    protected static final boolean VERIFY_APP = true;\n+\n+    protected void verifyContents(\n+            String archivePath,\n+            String installRoot, boolean includeUsr, \n+            String serverName, String appName) throws IOException {\n+    }\n+        \n+    protected void verifyContents(\n+            String archivePath,\n+            String installRoot, boolean includeUsr, \n+            String serverName, String appName, boolean verifyApp) throws IOException {\n+\n+        String methodName = \"verifyContents\";\n+\n+        System.out.println(methodName + \": Verifying [ \" + archivePath + \" ]\");\n+        System.out.println(methodName + \":   Install root [ \" + installRoot + \" ]\");\n+        System.out.println(methodName + \":   Server [ \" + serverName + \" ]\");\n+        System.out.println(methodName + \":   Module [ \" + appName + \" ]\");\n+\n+        String appsDir = getAppsTargetDir();\n+\n+        String serverPath;\n+        if ( includeUsr ) {\n+            serverPath = installRoot + \"/usr/servers/\" + serverName;\n+        } else {\n+            serverPath = installRoot + \"/servers/\" + serverName;\n+        }\n+        String appPath = serverPath + '/' + appsDir + '/' + appName;\n+        // The expanded application is always placed under 'apps', even if the\n+        // un-expanded application is under 'dropins'.\n+        String expandedAppPath = serverPath + \"/apps/expanded/\" + appName + '/';\n+\n+        System.out.println(methodName + \":   Server path [ \" + serverPath + \" ]\");\n+        \n+        if ( verifyApp ) {\n+            System.out.println(methodName + \":   App path [ \" + appPath + \" ]\");\n+            System.out.println(methodName + \":   Expanded app path [ \" + expandedAppPath + \" ]\");\n+        }\n+\n+        try ( ZipFile zipFile = new ZipFile(archivePath) ) {\n+            boolean foundAll = false;\n+            boolean foundServerEntry = false;\n+            boolean foundAppEntry = !verifyApp; // Short circuit these if app validation is off.\n+            boolean foundExpandedAppEntry = !verifyApp;\n+\n+            String lastEntry = null;\n+            int lastSlash = -1;\n+\n+            Enumeration<? extends ZipEntry> en = zipFile.entries();\n+            while ( !foundAll && en.hasMoreElements() ) {\n+                ZipEntry entry = en.nextElement();\n+                String entryName = entry.getName();\n+                int slash = entryName.lastIndexOf('/');\n+                boolean doLog = (\n+                    (lastEntry == null) ||\n+                    (slash != lastSlash) ||\n+                    !entryName.regionMatches(0, lastEntry, 0, lastSlash) );\n+                if ( doLog ) {\n+                    lastEntry = entryName;\n+                    lastSlash = slash;\n+                    System.out.println(\"Entry [ \" + entryName + \" ]\");\n+                }                    \n+\n+                if ( !foundServerEntry ) {\n+                    foundServerEntry = entryName.startsWith(serverPath);\n+                }\n+                if ( !foundAppEntry ) {\n+                    foundAppEntry = entryName.startsWith(appPath);\n+                }\n+                if ( !foundExpandedAppEntry ) {\n+                    foundExpandedAppEntry = entryName.startsWith(expandedAppPath);\n+                }\n+                foundAll = ( foundServerEntry && foundAppEntry && foundExpandedAppEntry );                                                \n+            }\n+\n+            if ( !foundServerEntry ) {\n+                fail(\"Package [ \" + archivePath + \" ] missing [ \" + serverPath + \" ]\");\n+            }\n+            if ( !foundAppEntry ) {\n+                fail(\"Package [ \" + archivePath + \" ] missing [ \" + appPath + \" ]\");\n+            }\n+            if ( !foundExpandedAppEntry ) {\n+                fail(\"Package [ \" + archivePath + \" ] missing [ \" + expandedAppPath + \" ]\");\n+            }\n+        }\n+    }\n+\n+    protected void verifyExpandedContents(\n+        String archivePath,\n+        String serverRoot, boolean includeUsr, String serverName,\n+        String moduleName) throws IOException {\n+        \n+        String methodName = \"verifyExpandedContents\";\n+\n+        String packedPath = serverRoot;\n+        if ( includeUsr ) {\n+            packedPath += \"/usr\";\n+        }\n+        packedPath +=\n+            \"/servers/\" + serverName + '/' +\n+            getAppsTargetDir() + '/' +\n+            moduleName;\n+\n+        String unpackedPrefix = serverRoot;\n+        if ( includeUsr ) {\n+            unpackedPrefix += \"/usr\";\n+        }\n+        unpackedPrefix +=\n+            \"/servers/\" + serverName + '/' +\n+            getAppsTargetDir() + \"/expanded/\" +\n+            moduleName + '/';\n+        int unpackedPrefixLen = unpackedPrefix.length();\n+\n+        System.out.println(methodName + \":  Packed archive [ \" + packedPath + \" ]\");\n+        System.out.println(methodName + \":  Unpacked archive [ \" + unpackedPrefix + \" ]\");\n+\n+        Map<String, Integer> packedMapping = null;\n+        Map<String, Integer> unpackedMapping = null;\n+\n+        try ( ZipFile packageZip = new ZipFile(archivePath) ) {\n+            int unpackedOffset = 0;\n+\n+            String lastEntry = null;\n+            int lastSlash = -1;\n+            \n+            Enumeration<? extends ZipEntry> entries = packageZip.entries();\n+            while ( entries.hasMoreElements() ) {\n+                ZipEntry entry = entries.nextElement();\n+                String entryName = entry.getName();\n+                int slash = entryName.lastIndexOf('/');\n+                boolean doLog = (\n+                    (lastEntry == null) ||\n+                    (slash != lastSlash) ||\n+                    !entryName.regionMatches(0, lastEntry, 0, lastSlash) );\n+                if ( doLog ) {\n+                    lastEntry = entryName;\n+                    lastSlash = slash;\n+                    System.out.println(\"Entry [ \" + entryName + \" ]\");\n+                }                \n+\n+                if ( entryName.equals(packedPath) ) {\n+                    if ( packedMapping != null ) {\n+                        fail(\"Archive [ \" + archivePath + \" ] has duplicates of entry [ \" + packedPath + \" ]\");\n+                        return;\n+                        // Never used; added to avoid a compiler null value warning:\n+                        // The compiler doesn't know that 'fail' never returns.                        \n+                    }\n+                    packedMapping = new HashMap<String, Integer>();\n+\n+                    try ( InputStream nestedStream = packageZip.getInputStream(entry);\n+                          ZipInputStream nestedZipStream = new ZipInputStream(nestedStream); ) {\n+\n+                        ZipEntry nestedEntry;\n+                        for ( int offset = 0;\n+                              (nestedEntry = nestedZipStream.getNextEntry()) != null;\n+                              offset++ ) { \n+                            packedMapping.put( nestedEntry.getName(), Integer.valueOf(offset) ); \n+                        }\n+                    }\n+\n+                } else {\n+                    // '<=' is deliberate: We don't want the entry for\n+                    // the directory of the unpacked archive.\n+                    if ( entryName.length() <= unpackedPrefixLen ) {\n+                        // ignore this entry\n+                    } else  if ( entryName.startsWith(unpackedPrefix) ) {\n+                        if ( unpackedMapping == null ) {\n+                            unpackedMapping = new HashMap<String, Integer>();\n+                        }\n+                        String suffix = entryName.substring(unpackedPrefix.length());\n+                        unpackedMapping.put(suffix, Integer.valueOf(unpackedOffset++));\n+                    } else {\n+                        // ignore this entry ...\n+                    }\n+                }\n+            }\n+        }\n+        \n+        if ( unpackedMapping == null ) {\n+            fail(\"Archive [ \" + archivePath + \" ] has no unpacked module entries [ \" + unpackedPrefix + \" ]\");\n+            return;\n+            // Never used; added to avoid a compiler null value warning:\n+            // The compiler doesn't know that 'fail' never returns.\n+        }\n+\n+        if ( packedMapping == null ) {\n+            fail(\"Archive [ \" + archivePath + \" ] has no packed module [ \" + packedPath + \" ]\");\n+            return;\n+            // Never used; added to avoid a compiler null value warning:\n+            // The compiler doesn't know that 'fail' never returns.\n+        }\n+\n+        int failures = 0;\n+\n+        for ( Map.Entry<String, Integer> packedEntry : packedMapping.entrySet() ) {\n+            String packedName = packedEntry.getKey();\n+            Integer packedOffset = packedEntry.getValue();\n+            \n+            Integer unpackedOffset = unpackedMapping.get(packedName);\n+            \n+            if ( unpackedOffset == null ) {\n+                System.out.println(\"Extra packed entry [ \" + packedName + \" ]\");\n+                failures++;\n+            } else {\n+                if ( packedOffset.intValue() != unpackedOffset.intValue() ) {\n+                    System.out.println(\"Packed entry [ \" + packedName + \" ] changed offset from [ \" + packedOffset.intValue() + \" ] to [ \" + unpackedOffset.intValue() + \" ]\");\n+                    failures++;\n+                }\n+            }\n+        }\n+        \n+        for ( String unpackedName : unpackedMapping.keySet() ) {\n+            if ( !packedMapping.containsKey(unpackedName) ) {\n+                System.out.println(\"Extra unpacked entry [ \" + unpackedName + \" ]\");\n+                failures++;\n+            } else {\n+                // The offsets were already verified\n+            }\n+        }\n+            \n+        if ( failures != 0 ) {\n+            fail(\"Archive [ \" + archivePath + \" ] packed archive [ \" + packedPath + \" ] has [ \" + failures + \" ] content errors\"); \n+        }\n     }\n+    \n+    \n+    protected void verifyFilteredContents(\n+        String archivePath,\n+        String serverRoot, boolean includeUsr, String serverName,\n+        String moduleName,\n+        Collection<String> requiredEntries,\n+        Collection<String> forbiddenEntries) throws IOException {\n+\n+        String methodName = \"verifyFilteredContents\";\n+\n+        String packedPath = serverRoot;\n+        if ( includeUsr ) {\n+            packedPath += \"/usr\";\n+        }\n+        packedPath +=\n+            \"/servers/\" + serverName + '/' +\n+            getAppsTargetDir() + '/' +\n+            moduleName;\n+\n+        String unpackedPrefix = serverRoot;\n+        if ( includeUsr ) {\n+            unpackedPrefix += \"/usr\";\n+        }\n+        unpackedPrefix +=\n+            \"/servers/\" + serverName + '/' +\n+            getAppsTargetDir() + \"/expanded/\" +\n+            moduleName + '/';\n+        int unpackedPrefixLen = unpackedPrefix.length();\n+\n+        System.out.println(methodName + \":  Packed archive [ \" + packedPath + \" ]\");\n+        System.out.println(methodName + \":  Unpacked archive [ \" + unpackedPrefix + \" ]\");\n+\n+        System.out.println(methodName + \":  Forbidden entries: \" + forbiddenEntries);\n+        System.out.println(methodName + \":  Required entries: \" + requiredEntries);\n+\n+        Set<String> forbidden = new HashSet<String>(forbiddenEntries);\n+        Set<String> forbiddenButPresentPacked = null;\n+        Set<String> forbiddenButPresentUnpacked = null;\n+\n+        Set<String> requiredButAbsentPacked = new HashSet<String>(requiredEntries);\n+        Set<String> requiredButAbsentUnpacked = new HashSet<String>(requiredEntries);\n+\n+        try ( ZipFile packageZip = new ZipFile(archivePath) ) {\n+            String lastEntry = null;\n+            int lastSlash = -1;\n+                \n+            Enumeration<? extends ZipEntry> entries = packageZip.entries();\n+            while ( entries.hasMoreElements() ) {\n+                ZipEntry entry = entries.nextElement();\n+                String entryName = entry.getName();\n+                int slash = entryName.lastIndexOf('/');\n+                boolean doLog = (\n+                    (lastEntry == null) ||\n+                    (slash != lastSlash) ||\n+                    !entryName.regionMatches(0, lastEntry, 0, lastSlash) );\n+                if ( doLog ) {\n+                    lastEntry = entryName;\n+                    lastSlash = slash;\n+                    System.out.println(\"Entry [ \" + entryName + \" ]\");\n+                }                \n+\n+                if ( entryName.equals(packedPath) ) {\n+                    try ( InputStream nestedStream = packageZip.getInputStream(entry);\n+                          ZipInputStream nestedZipStream = new ZipInputStream(nestedStream); ) {\n+\n+                        ZipEntry nestedEntry;\n+                        while ( (nestedEntry = nestedZipStream.getNextEntry()) != null ) {\n+                            String nestedEntryName = nestedEntry.getName();\n+                            if ( forbidden.contains(nestedEntryName) ) {\n+                                if ( forbiddenButPresentPacked == null ) {\n+                                    forbiddenButPresentPacked = new HashSet<String>(1);\n+                                }\n+                                forbiddenButPresentPacked.add(nestedEntryName);\n+                            }\n+                            requiredButAbsentPacked.remove(nestedEntryName);\n+                        }\n+                    }\n+                } else {\n+                    // '<=' is deliberate: We don't want the entry for\n+                    // the directory of the unpacked archive.\n+                    if ( entryName.length() <= unpackedPrefixLen ) {\n+                        // ignore this entry\n+                    } else  if ( entryName.startsWith(unpackedPrefix) ) {\n+                        String suffix = entryName.substring(unpackedPrefix.length());\n+                        if ( forbidden.contains(suffix) ) {\n+                            if ( forbiddenButPresentUnpacked == null ) {\n+                                forbiddenButPresentUnpacked = new HashSet<String>(1);\n+                            }                            \n+                            forbiddenButPresentUnpacked.add(suffix);\n+                        }\n+                        requiredButAbsentUnpacked.remove(suffix);\n+\n+                    } else {\n+                        // ignore this entry ...\n+                    }\n+                }\n+            }\n+\n+            String error1 = null;\n+            if ( forbiddenButPresentPacked != null ) {\n+                error1 = \"Archive has extra packed module entries [ \" + packedPath + \" ]: \" + forbiddenButPresentPacked;\n+                System.out.println(error1);\n+            }\n+            String error2 = null;\n+            if ( !requiredButAbsentPacked.isEmpty() ) {\n+                error2 = \"Archive has missing packed module entries [ \" + packedPath + \" ]: \" + requiredButAbsentPacked;\n+                System.out.println(error2);                \n+            }\n+            String error3 = null;\n+            if ( forbiddenButPresentUnpacked != null ) {\n+                error3 = \"Archive has extra unpacked module entries [ \" + unpackedPrefix + \" ]: \" + forbiddenButPresentUnpacked;\n+                System.out.println(error3);\n+            }\n+            String error4 = null;\n+            if ( !requiredButAbsentUnpacked.isEmpty() ) {\n+                error4 = \"Archive has missing unpacked module entries [ \" + unpackedPrefix + \" ]: \" + requiredButAbsentUnpacked;\n+                System.out.println(error4);\n+            }            \n+            \n+            if ( error1 != null ) {\n+                fail(error1);\n+            }\n+            if ( error2 != null ) {\n+                fail(error2);\n+            }\n+            \n+            if ( error3 != null ) {\n+                fail(error3);\n+            }            \n+            if ( error4 != null ) {\n+                fail(error4);\n+            }\n+        }    \n+    }\n+\n+    //\n+\n+    protected static class UnblockedReader implements Closeable {\n+        @SuppressWarnings(\"unused\")\n+        private final InputStream inputStream;\n+        private final BufferedReader inputReader;\n+\n+        private final BlockingQueue<String> inputQueue;\n+        private final Thread inputThread;\n+\n+        public UnblockedReader(InputStream inputStream) {\n+            this.inputStream = inputStream;\n+            this.inputReader =  new BufferedReader( new InputStreamReader(inputStream) );\n+\n+            this.inputQueue = new LinkedBlockingDeque<>();\n+            this.inputThread = new Thread(this::postAll);\n+\n+            this.inputThread.start();\n+        }\n+\n+        public void close() {\n+            stop();\n+        }\n+\n+        @SuppressWarnings(\"deprecation\")\n+        public void stop() {\n+            inputThread.stop();\n+        }\n+\n+        private void postAll() {\n+            try {\n+                for (String line; (line = inputReader.readLine()) != null;) {\n+                    inputQueue.put(line);\n+                }\n+            } catch ( Exception e ) {\n+                System.out.println(\"Unexpected read exception: \" + e.getLocalizedMessage());\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        public String poll() {\n+            String line = inputQueue.poll();\n+            if ( line == null ) {\n+                Thread.yield();\n+                line = inputQueue.poll();\n+            }\n+            return line;\n+        }\n+    }\n+\n+    protected static class SafeProcess implements Closeable {\n+        public SafeProcess(String[] cmd, String[] envp) throws IOException {\n+            this.process = Runtime.getRuntime().exec(cmd, envp, null);\n+        }        \n+        \n+        public SafeProcess(String[] cmd) throws IOException {\n+            this.process = Runtime.getRuntime().exec(cmd);\n+        }\n+\n+        private final Process process;\n+\n+        public InputStream getStdoutStream() {\n+            // Note: This is correct; the names are just messed up.\n+            return process.getInputStream();\n+        }\n+\n+        public UnblockedReader createStdoutReader() {\n+            return new UnblockedReader( getStdoutStream() );\n+        }\n+\n+        public InputStream getStderrStream() {\n+            return process.getErrorStream();\n+        }\n+\n+        public UnblockedReader createStderrReader() {\n+            return new UnblockedReader( getStderrStream() );\n+        }\n+\n+        public void close() {\n+            process.destroy();\n+        }\n+    }\n+\n+    // Expected output:\n+    //\n+    // java -jar runnablePackage.jar\n+    // Extracting files to C:\\\\Users\\\\...\\\\wlpExtract\\\\runnablePackage_260686838796000\\\\wlp\n+    // Successfully extracted all product files.\n+    // A Java runtime environment installation is being used. The server will run in a separate Java virtual machine.\n+    // C:\\\\Users\\\\ThomasBitonti\\\\wlpExtract\\\\runnablePackage_260686838796000\\\\wlp\\\\bin\\\\server run com.ibm.ws.kernel.boot.loose.config.fat\n+    // Launching com.ibm.ws.kernel.boot.loose.config.fat (Open Liberty 21.0.0.3/wlp-1.0.50.202102222233) on IBM J9 VM, version 8.0.5.10 - pwa6480sr5fp10-20180214_01(SR5 FP10) (en_US)\n+    // [AUDIT   ] CWWKE0001I: The server com.ibm.ws.kernel.boot.loose.config.fat has been launched.\n+    // [WARNING ] CWWKF0009W: The server has not been configured to install any features.\n+    // [AUDIT   ] CWWKF0011I: The com.ibm.ws.kernel.boot.loose.config.fat server is ready to run a smarter planet. The com.ibm.ws.kernel.boot.loose.config.fat server started in 58.478 seconds.\n+\n+    private static final Pattern launchPattern =\n+        Pattern.compile(\"^.* CWWKE0001I: .* \" + SERVER_NAME + \" .*$\");\n+    private static final Pattern readyPattern =\n+        Pattern.compile(\".* CWWKF0011I: .* \" + SERVER_NAME + \" .*$\");\n+    \n+    // The windows defender will slow down the runnable server,\n+    // increasing the time taken for the the server to start from\n+    // just a few seconds to nearly a minute.  To avoid this\n+    // slowdown, and as a generally better build practice, the\n+    // extraction is redirected to the local build folder.\n+    //\n+    // From: \n+    // https://www.ibm.com/support/knowledgecenter/SSEQTP_liberty/com.ibm.websphere.wlp.doc/ae/rwlp_setup_jarserver.html\n+    //\n+    // When the JAR file runs, it gets extracted to a temporary location and then\n+    // the server runs in the foreground, started by the Liberty server run command.\n+    // All output is written to stdout or stderr. By default, files are extracted to\n+    // temporary locations:\n+    //\n+    // For Windows: %HOMEPATH%/wlpExtract/<jar file name>_nnnnnnnnnnnnnnnnnnn\n+    // For all other platforms: $HOME/wlpExtract/<jar file name>_nnnnnnnnnnnnnnnnnnn\n+    //\n+    // You can control the output location by using the WLP_JAR_EXTRACT_ROOT or\n+    // WLP_JAR_EXTRACT_DIR environment variable.\n+\n+    // When running on windows using Java11, for example:\n+    //\n+    // openjdk version \"11.0.4\" 2019-07-16\n+    // OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.4+11)\n+    // Eclipse OpenJ9 VM AdoptOpenJDK (build openj9-0.15.1, JRE 11 Windows 10 amd64-64-Bit 20190717_36 (JIT enabled, AOT enabled)\n+    // OpenJ9   - 0f66c6431\n+    // OMR      - ec782f26\n+    // JCL      - fa49279450 based on jdk-11.0.4+11)\n+    //\n+    // The extraction code generates illegal access warnings:\n+    //\n+    // WARNING: An illegal reflective access operation has occurred\n+    // WARNING: Illegal reflective access by org.eclipse.osgi.storage.FrameworkExtensionInstaller\n+    //   (file:/C:/Users/ThomasBitonti/wlpExtract/runnablePackage_258869724879800/wlp/lib/org.eclipse.osgi_3.15.0.jar)\n+    //   to method java.net.URLClassLoader.addURL(java.net.URL)\n+    // WARNING: Please consider reporting this to the maintainers of org.eclipse.osgi.storage.FrameworkExtensionInstaller\n+    // WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations\n+    // WARNING: All illegal access operations will be denied in a future release\n+    //\n+    // For now, the messages are warnings.  Later, they may be errors,\n+    // in which case a switch will be necessary to turn them back into\n+    // being warnings:\n+    // \"--illegal-access=warn\"\n+    \n+    protected void launchRunnable(String archivePath) throws Exception {        \n+        String[] launchCmd = {\n+            \"java\",\n+            \"-jar\", archivePath,\n+        };\n+\n+        String[] launchEnv = {\n+            WLP_EXTRACT_PROPERTY_NAME + \"=\" + BUILD_DIR + '/' + WLP_EXTRACT\n+        };\n+\n+        try ( SafeProcess proc = new SafeProcess(launchCmd, launchEnv);\n+              UnblockedReader stdoutReader = proc.createStdoutReader();\n+              UnblockedReader stderrReader = proc.createStderrReader(); ) {\n+\n+            boolean serverDidLaunch = false;\n+            boolean serverIsReady = false;\n+\n+            long timeStart = System.nanoTime();\n+            System.out.println(\"Start time: \" + timeStart);\n+\n+            for (;;) {\n+                System.out.println(\"Polling for errors ...\");\n+                String error;\n+                while ( (error = stderrReader.poll()) != null ) {\n+                    if ( !isReflectiveAccessWarning(error) ) {\n+                        System.out.println(\"Launch error: \" + error);\n+                        fail(\"Server launch error: \" + error);\n+                    } else {\n+                        System.out.println(\"Ignoring launch error: \" + error);\n+                    }\n+                }\n+\n+                System.out.println(\"Polling for output ...\");                    \n+                String line;\n+                while ( (line = stdoutReader.poll()) != null ) {\n+                    System.out.println(\"Launch output: \" + line);\n+                    if ( !serverDidLaunch ) {\n+                        serverDidLaunch = launchPattern.matcher(line).matches();\n+                        if ( serverDidLaunch ) {\n+                            System.out.println(\"Server did launch\");\n+                        }\n+                    }\n+                    if ( !serverIsReady ) {\n+                        serverIsReady = readyPattern.matcher(line).matches();\n+                        if ( serverIsReady ) {\n+                            System.out.println(\"Server is ready\");\n+                        }\n+                    }\n+                }\n+\n+                if ( serverDidLaunch && serverIsReady ) {\n+                    break;\n+                }\n+\n+                long timeNext = System.nanoTime();\n+                long timeElapsed = timeNext - timeStart;\n+                System.out.println(\"Poll time: \" + timeNext + \": Elapsed: \" + timeElapsed);\n+                if ( timeElapsed > NS_IN_SEC * 20 ) {\n+                    if ( !serverDidLaunch ) {\n+                        fail(\"Server package \" + archivePath + \" did not launch in time.\");\n+                    }\n+                    if ( !serverIsReady ) {\n+                        fail(\"Server package \" + archivePath + \" was not ready in time.\");\n+                    }\n+                }\n+\n+                Thread.sleep(MS_IN_SEC);\n+            }\n+        }\n+    }\n+\n+    private boolean isReflectiveAccessWarning(String line) {\n+        return ( line.contains(\"reflective access\") ||\n+                 line.contains(\"consider reporting\") ||\n+                 line.contains(\"illegal access\") );\n+    }    \n }"
  },
  {
    "sha": "aac26058fc05de3661d3fc04f67ded959a5daf77",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageCommandTest.java",
    "status": "modified",
    "additions": 547,
    "deletions": 487,
    "changes": 1034,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageCommandTest.java",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageCommandTest.java",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageCommandTest.java?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2014 IBM Corporation and others.\n+ * Copyright (c) 2014, 2021 IBM Corporation and others.\n  * All rights reserved. This program and the accompanying materials\n  * are made available under the terms of the Eclipse Public License v1.0\n  * which accompanies this distribution, and is available at\n@@ -12,17 +12,19 @@\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n import static org.junit.Assume.assumeTrue;\n \n+import java.io.Closeable;\n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n-import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Enumeration;\n-import java.util.HashSet;\n+import java.util.List;\n import java.util.Set;\n import java.util.jar.JarEntry;\n import java.util.jar.JarFile;\n@@ -36,371 +38,386 @@\n \n import com.ibm.websphere.simplicity.config.ServerConfiguration;\n \n+import componenttest.annotation.SkipIfSysProp;\n import componenttest.custom.junit.runner.FATRunner;\n import componenttest.topology.impl.LibertyServer;\n import componenttest.topology.impl.LibertyServerFactory;\n \n-/**\n- *\n- */\n @RunWith(FATRunner.class)\n public class PackageCommandTest {\n-    private static final Class<?> c = PackageCommandTest.class;\n+    private static final String rootFatServerName = \"com.ibm.ws.kernel.boot.root.fat\";\n+    private static final String bootstrapFatServerName = \"com.ibm.ws.kernel.bootstrap.fat\";\n+\n+    private static final String archiveName = \"MyPackage\";\n+    private static final String archiveNameJar = \"MyPackage.jar\";\n+    private static final String archiveNameZip = \"MyPackage.zip\";\n+    private static final String archiveNameTarGz = \"MyPackage.tar.gz\";\n+\n+    private static final String[] ARCHIVE_NAMES = {\n+        archiveNameJar,\n+        archiveNameZip,\n+        archiveNameTarGz\n+    };\n \n-    private static String serverName = \"com.ibm.ws.kernel.boot.root.fat\";\n-    private static String archivePackage = \"MyPackage.zip\";\n-    private static String archivePackageNoExtension = \"MyPackage\";\n-    private static String archivePackageTarGzExtension = \"MyPackage.tar.gz\";\n-    private static String archivePackageJarExtension = \"MyPackage.jar\";\n+    private LibertyServer rootFatServer;\n+    @SuppressWarnings(\"unused\")\n+    private String rootFatInstallPath;\n+    private String rootFatServerPath;\n+\n+    private LibertyServer bootstrapFatServer;\n+    private String bootstrapFatInstallPath;\n+    private String bootstrapFatServerPath;\n \n     @Before\n     public void before() throws Exception {\n+        rootFatServer = LibertyServerFactory.getLibertyServer(rootFatServerName);\n+        rootFatInstallPath = rootFatServer.getInstallRoot();\n+        rootFatServerPath = rootFatServer.getServerRoot();       \n+        System.out.println(\"Root FAT server: \" + rootFatServerName);\n+        System.out.println(\"Root FAT server path: \" + rootFatServerPath);\n+\n+        for ( String archiveName : ARCHIVE_NAMES ) {\n+            delete(rootFatServerPath, archiveName);\n+        }\n+\n+        bootstrapFatServer = LibertyServerFactory.getLibertyServer(bootstrapFatServerName);\n+        bootstrapFatInstallPath = bootstrapFatServer.getInstallRoot();        \n+        bootstrapFatServerPath = bootstrapFatServer.getServerRoot();\n+        System.out.println(\"Bootstrap FAT server: \" + bootstrapFatServerName);\n+        System.out.println(\"Bootstrap FAT server path: \" + bootstrapFatServerPath);        \n+        for ( String archiveName : ARCHIVE_NAMES ) {\n+            delete(bootstrapFatServerPath, archiveName);\n+        }\n+    }\n \n-        // Delete previous archive file if it exists\n-        LibertyServer server = LibertyServerFactory.getLibertyServer(serverName);\n-        server.deleteFileFromLibertyServerRoot(archivePackage);\n+    private void delete(String rootPath, String childPath) {\n+        (new File(rootPath + '/' + childPath)).delete();\n     }\n \n+    //\n+\n     /**\n-     * The package command requires that the lib/extract directory exists, as this directory\n-     * contains a required manifest, self extractable classes, etc. If this directory does\n-     * not exist, then the command should print this message:\n-     * <br/>\n-     * <em>CWWKE0922E: The package command cannot complete because the installation is missing the lib/extract directory.</em>\n-     * <br/>\n-     * This test verifies that this error message is printed.\n-     * <br/>\n-     * <b>Note:</b> This test assumes that the lib/extract directory is already missing. As of today, the\n-     * FAT environment's installation of WLP does not include this directory. If we end up creating that\n-     * directory in the FAT environment, then we'll need to find another way to run this test - as we\n-     * probably don't want to delete a directory in the FAT environment's installation.\n+     * The package command requires that the lib/extract directory exists,\n+     * as this directory contains a required manifest, self extractable\n+     * classes, etc. If this directory does not exist, then the command\n+     * should print this message:\n+     * \n+     * <em>CWWKE0922E: The package command cannot complete because the\n+     * installation is missing the lib/extract directory.</em>\n      *\n-     * @throws Exception\n+     * This test requires that the lib/extract directory be already missing,\n+     * and does not run.\n      */\n     @Test\n     public void testCorrectErrorMessageWhenLibExtractDirIsMissing() throws Exception {\n-        // Pick any server, doesn't matter.\n-        LibertyServer server = LibertyServerFactory.getLibertyServer(\"com.ibm.ws.kernel.bootstrap.fat\");\n-        // Only run the test if the lib/extract directory does not exist\n-        try {\n-            server.getFileFromLibertyInstallRoot(\"lib/extract\");\n-            assumeTrue(false); // the directory exists, so we skip this test.\n-        } catch (FileNotFoundException ex) {\n-            //expected - the directory does not exist - so proceed.\n-        }\n+        LibertyServer server = bootstrapFatServer;\n \n-        String stdout = server.executeServerScript(\"package\", new String[] { \"--include=minify\" }).getStdout();\n+        String extractPath = bootstrapFatInstallPath + \"/lib/extract\";\n+        assumeTrue( !(new File(extractPath).exists()) );\n \n-        assertTrue(\"Did not find expected failure message, CWWKE0922E\", stdout.contains(\"CWWKE0922E\"));\n+        String[] packageCmd = { \"--include=minify\" };\n+        verifyPackageError(server, packageCmd, \"CWWKE0922E\"); \n     }\n \n+    private static final String SELF_EXTRACT_CLASS_NAME =\n+        \"wlp.lib.extract.SelfExtractRun\";\n+    private static final String SELF_EXTRACT_RESOURCE_NAME =\n+        \"wlp/lib/extract/SelfExtractRun.class\"; \n+\n     /**\n      * Packages --include=minify,runnable jar and verifies correct content.\n-     * This test is not run if:\n-     * 1) platform is z/OS (jar archive not supported)\n-     * 2) wlp/lib/extract directory does not exist\n-     *\n-     * @throws Exception\n      */\n     @Test\n+    @SkipIfSysProp(\"os.name=z/OS\") // Jar not supported on Z/OS\n     public void testCreateRunnableJar() throws Exception {\n-        // Pick any server, doesn't matter.\n-        String serverName = \"com.ibm.ws.kernel.bootstrap.fat\";\n-        String jarFileName = serverName + \".jar\";\n-        String mainClass = \"wlp.lib.extract.SelfExtractRun\";\n+        String serverName = bootstrapFatServerName;\n+        LibertyServer server = bootstrapFatServer;\n \n-        // Doesn't work on z/OS (because you can't package into a jar on z/OS)\n-        assumeTrue(!System.getProperty(\"os.name\").equals(\"z/OS\"));\n+        String packageName = serverName + \".jar\";\n+        String packagePath = bootstrapFatServerPath + '/' + packageName;\n+        String[] packageCmd = {\n+            \"--archive=\" + packageName,\n+            \"--include=runnable\"\n+        };\n+        verifyPackage(server, packageCmd, packageName, packagePath);\n \n-        LibertyServer server = LibertyServerFactory.getLibertyServer(serverName);\n-\n-        // Only run the test if the lib/extract directory exists\n-        try {\n-            server.getFileFromLibertyInstallRoot(\"lib/extract\");\n-\n-            String stdout = server.executeServerScript(\"package\", new String[] { \"--archive=\" + jarFileName, \"--include=runnable\" }).getStdout();\n-\n-            assertTrue(\"Could not package server \" + serverName, stdout.contains(\"Server \" + serverName + \" package complete\"));\n-\n-            JarFile jarFile = new JarFile(server.getFileFromLibertyServerRoot(jarFileName).getAbsolutePath());\n-\n-            // Check the manifest for headers that should be in there.\n+        // Check the manifest for headers that should be in there.\n+        // make sure it'a a runnable jar\n+        // Check that the self-extract and the server's entries are in the jar\n+        \n+        try ( JarFile jarFile = new JarFile(packagePath) ) {\n             Manifest mf = jarFile.getManifest();\n-            assertNotNull(\"There should be a manifest in the jar file\", mf);\n-\n-            // make sure it'a a runnable jar\n-            assertEquals(mainClass, mf.getMainAttributes().getValue(\"Main-Class\"));\n+            assertNotNull(\"Package [ \" + packagePath + \" ] is missing its manifest\", mf);\n \n-            // Check that the self-extract and the server's entries are in the jar\n-            Enumeration<JarEntry> entries = jarFile.entries();\n-            assertTrue(entries.hasMoreElements());\n+            String mainClass = SELF_EXTRACT_CLASS_NAME;\n+            assertEquals(\"Package [ \" + packagePath + \" ] has incorrect main class\",\n+                mainClass, mf.getMainAttributes().getValue(\"Main-Class\"));\n \n-            boolean foundSelfExtractRun = false;\n-            while (entries.hasMoreElements()) {\n-                JarEntry entry = entries.nextElement();\n-                foundSelfExtractRun |= entry.getName().startsWith(\"wlp/lib/extract/SelfExtractRun.class\");\n+            boolean foundSelfExtractRun =\n+                ( jarFile.getEntry(SELF_EXTRACT_RESOURCE_NAME) != null );\n+            if ( !foundSelfExtractRun ) {\n+                fail(\"Package [ \" + packagePath + \" ] missing self-extract class [ \" + SELF_EXTRACT_RESOURCE_NAME + \" ]\");\n             }\n-\n-            assertTrue(foundSelfExtractRun);\n-\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n         }\n     }\n \n-    /**\n-     * Make sure that when packaging a jar archive using --include=usr,\n-     * the resulting jar files does NOT contain the self-extract files.\n-     */\n-    @Test\n-    public void testPackageJarArchiveWithIncludeEqualsUsr() throws Exception {\n-\n-        // NOTE: This test won't work cuz the necessary MANIFEST files and\n-        // self-extract files (wlp/lib/extract/*) aren't present in our test environment.\n-        assumeTrue(false);\n-\n-        // Doesn't work on z/OS (cuz you can't package into a jar on z/OS)\n-        assumeTrue(!System.getProperty(\"os.name\").equals(\"z/OS\"));\n-\n-        // Pick any server, doesn't matter.\n-        LibertyServer server = LibertyServerFactory.getLibertyServer(\"com.ibm.ws.kernel.bootstrap.fat\");\n-\n-        String jarFileName = \"package.usr.jar\";\n-\n-        String stdout = server.executeServerScript(\"package\",\n-                                                   new String[] { \"--archive=\" + jarFileName,\n-                                                                  \"--include=usr\" }).getStdout();\n-\n-        JarFile jarFile = new JarFile(server.getFileFromLibertyServerRoot(jarFileName).getAbsolutePath());\n-\n-        // Check the manifest for headers that should be in there.\n-        Manifest mf = jarFile.getManifest();\n-        assertNotNull(\"There should be a manifest in the jar file\", mf);\n-\n-        assertTrue(mf.getMainAttributes().containsKey(\"Applies-To\"));\n-        assertEquals(\"com.ibm.websphere.appserver\", mf.getMainAttributes().getValue(\"Applies-To\"));\n-        assertEquals(\"false\", mf.getMainAttributes().getValue(\"Extract-Installer\"));\n-\n-        // Check that the self-extract and the server's entries are in the jar\n-        Enumeration<JarEntry> entries = jarFile.entries();\n-        assertTrue(entries.hasMoreElements());\n-\n-        boolean foundServerEntry = false;\n-        boolean foundSelfExtractEntry = false;\n-        while (entries.hasMoreElements()) {\n-            JarEntry entry = entries.nextElement();\n-            foundServerEntry |= entry.getName().startsWith(\"wlp/usr/servers/com.ibm.ws.kernel.bootstrap.fat\");\n-            foundSelfExtractEntry |= entry.getName().startsWith(\"wlp/lib/extract\");\n-        }\n-\n-        assertTrue(foundServerEntry);\n-        assertTrue(foundSelfExtractEntry);\n-    }\n+    // This test has been removed.  The intent of the test is not\n+    // valid.  'include=usr' is not allowed with extension '.jar'.\n+    //\n+    // See 'testCorrectErrorMessageWhenUsrandJARArchiveSpecified',\n+    // which performs the same test, and which correctly verifies\n+    // that an error occurs.\n+\n+//    /**\n+//     * Make sure that when packaging a jar archive using --include=usr,\n+//     * the resulting jar files does NOT contain the self-extract files.\n+//     */\n+//    @Test\n+//    @SkipIfSysProp(\"os.name=z/OS\") // Jar not supported on Z/OS    \n+//    public void testPackageJarArchiveWithIncludeEqualsUsr() throws Exception {\n+//        LibertyServer server = bootstrapFatServer;\n+//\n+//        String packageName = \"packageUsr.jar\";\n+//        String packagePath = bootstrapFatServerPath + '/' + packageName;\n+//        String[] packageCmd = {\n+//            \"--archive=\" + packageName,\n+//            \"--include=usr\" };\n+//        verifyPackage(server, packageCmd, packageName, packagePath);\n+//\n+//        try ( JarFile jarFile = new JarFile(packagePath) ) {\n+//            Manifest mf = jarFile.getManifest();\n+//            assertNotNull(\"Package [ \" + packagePath + \" ] is missing its manifest\", mf);\n+//\n+//            assertTrue(mf.getMainAttributes().containsKey(\"Applies-To\"));\n+//            assertEquals(\"Package [ \" + packagePath + \" has incorrect 'Applies-To'\",            \n+//                \"com.ibm.websphere.appserver\", mf.getMainAttributes().getValue(\"Applies-To\"));\n+//            assertEquals(\"Package [ \" + packagePath + \" has incorrect 'Extract-Installer'\",\n+//                \"false\", mf.getMainAttributes().getValue(\"Extract-Installer\"));\n+//\n+//            // Check that the self-extract and the server's entries are in the jar\n+//            Enumeration<JarEntry> entries = jarFile.entries();\n+//            assertTrue(\"Package [ \" + packagePath + \" ] is empty\", entries.hasMoreElements());\n+//\n+//            boolean foundServerEntry = false;\n+//            boolean foundSelfExtractEntry = false;\n+//            while ( (!foundServerEntry || !foundSelfExtractEntry) && entries.hasMoreElements()) {\n+//                JarEntry entry = entries.nextElement();\n+//                String entryName = entry.getName();\n+//                if ( !foundServerEntry ) {\n+//                    foundServerEntry = entryName.startsWith(\"wlp/usr/servers/com.ibm.ws.kernel.bootstrap.fat\");\n+//                }\n+//                if ( !foundSelfExtractEntry ) {\n+//                    foundSelfExtractEntry = entryName.startsWith(\"wlp/lib/extract\");\n+//                }\n+//            }\n+//            if ( !foundServerEntry ) {\n+//                fail(\"Package [ \" + packagePath + \" ] is missing entries [ wlp/usr/servers/com.ibm.ws.kernel.bootstrap.fat ]\");\n+//            }\n+//            if ( !foundSelfExtractEntry ) {\n+//                fail(\"Package [ \" + packagePath + \" ] is missing entries [ wlp/lib/extract ]\");\n+//            }\n+//        }\n+//    }\n \n     @Test\n     public void testCorrectErrorMessageWhenProductExtensionsInstalledAndServerRootSpecified() throws Exception {\n+        LibertyServer server = rootFatServer;\n \n-        LibertyServer server = LibertyServerFactory.getLibertyServer(serverName);\n-\n-        try {\n-            server.getFileFromLibertyInstallRoot(\"lib/extract\");\n-\n-            // Make sure we have the /wlp/etc/extension directory which indicates Product Extensions are installed\n-            File prodExtensionDir = null;\n-            try {\n-                server.getFileFromLibertyInstallRoot(\"etc/extension/\");\n-            } catch (FileNotFoundException ex) {\n-                // The /etc/extension directory does not exist - so create it for this test.\n-                String pathToProdExt = server.getInstallRoot() + \"/etc\" + \"/extension/\";\n-                prodExtensionDir = new File(pathToProdExt);\n-                prodExtensionDir.mkdirs();\n-            }\n-\n-            String[] cmd = new String[] { \"--archive=\" + archivePackage,\n-                                          \"--include=minify\",\n-                                          \"--server-root= \" };\n-            String stdout = server.executeServerScript(\"package\", cmd).getStdout();\n-\n-            assertTrue(\"Did not find expected failure message, CWWKE0947W.  STDOUT = \" + stdout, stdout.contains(\"CWWKE0947W\"));\n+        ensureProductExt(server);\n \n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n-        }\n+        String[] packageCmd = {\n+            \"--archive=\" + archiveNameZip,\n+            \"--include=minify\",\n+            \"--server-root=\"\n+        };\n+        verifyPackageError(server, packageCmd, \"CWWKE0947W\");\n     }\n \n     /**\n      * This tests that --include=usr outputs the correct information in\n-     * the archive file\n-     *\n+     * the archive file.\n      */\n     @Test\n     public void testMinifyInclude() throws Exception {\n-        LibertyServer server = LibertyServerFactory.getLibertyServer(serverName);\n-        try {\n-\n-            server.getFileFromLibertyInstallRoot(\"lib/extract\");\n-\n-            String[] cmd = new String[] { \"--archive=\" + archivePackage,\n-                                          \"--include=minify\" };\n-            // Ensure package completes\n-            String stdout = server.executeServerScript(\"package\", cmd).getStdout();\n-            assertTrue(\"The package command did not complete as expected. STDOUT = \" + stdout, stdout.contains(\"package complete\"));\n-\n-            // Ensure root is correct in the .zip\n-            ZipFile zipFile = new ZipFile(server.getServerRoot() + \"/\" + archivePackage);\n-            try {\n-                boolean foundDefaultRootEntry = false;\n-                boolean foundUsrEntry = false;\n-                boolean foundBinEntry = false;\n-                boolean foundLibEntry = false;\n-                boolean foundDevEntry = false;\n-\n-                for (Enumeration<? extends ZipEntry> en = zipFile.entries(); en.hasMoreElements();) {\n-                    ZipEntry entry = en.nextElement();\n-                    foundDefaultRootEntry |= entry.getName().startsWith(\"wlp\");\n-                    foundUsrEntry |= entry.getName().contains(\"/usr\");\n-                    foundBinEntry |= entry.getName().contains(\"/bin\");\n-                    foundLibEntry |= entry.getName().contains(\"/lib\");\n-                    foundDevEntry |= entry.getName().contains(\"/dev\");\n+        LibertyServer server = rootFatServer;\n+\n+        String packageName = archiveNameZip;\n+        String packagePath = rootFatServerPath + '/' + packageName;\n+        String[] packageCmd = {\n+            \"--archive=\" + packageName,\n+            \"--include=minify\"\n+        };\n+        verifyPackage(server, packageCmd, packageName, packagePath);\n+\n+        try (  ZipFile zipFile = new ZipFile(packagePath) ) {\n+            boolean foundDefaultRootEntry = false;\n+            boolean foundUsrEntry = false;\n+            boolean foundBinEntry = false;\n+            boolean foundLibEntry = false;\n+            boolean foundDevEntry = false;\n+            boolean foundAll = false;\n+\n+            Enumeration<? extends ZipEntry> en = zipFile.entries();\n+            while ( !foundAll && en.hasMoreElements() ) {\n+                ZipEntry entry = en.nextElement();\n+                String entryName = entry.getName();\n+\n+                if ( !foundDefaultRootEntry ) {\n+                    foundDefaultRootEntry = entryName.startsWith(\"wlp/\");\n                 }\n-                assertTrue(\"The package did not contain /wlp root structure as expected.\", foundDefaultRootEntry);\n-                assertTrue(\"The package did not contain /usr/ as expected.\", foundUsrEntry);\n-                assertTrue(\"The package did not contain /bin/ as expected.\", foundBinEntry);\n-                assertTrue(\"The package did not contain /lib/ as expected.\", foundLibEntry);\n-                assertTrue(\"The package did not contain /dev/ as expected.\", foundDevEntry);\n-\n-            } finally {\n-                try {\n-                    zipFile.close();\n-                } catch (IOException ex) {\n+                if ( !foundUsrEntry ) {\n+                    foundUsrEntry = entryName.contains(\"/usr/\");\n                 }\n+                if ( !foundBinEntry ) {\n+                    foundBinEntry = entryName.contains(\"/bin/\");\n+                }\n+                if ( !foundLibEntry ) {\n+                    foundLibEntry = entryName.contains(\"/lib/\");\n+                }\n+                if ( !foundDevEntry ) {\n+                    foundDevEntry = entryName.contains(\"/dev/\");\n+                }\n+\n+                foundAll = ( foundDefaultRootEntry && foundUsrEntry &&\n+                             foundBinEntry && foundLibEntry && foundDevEntry);\n+            }\n+\n+            if ( !foundDefaultRootEntry ) {\n+                System.out.println(\"Package [ \" + packagePath + \" ] is missing default root entry [ /wlp ]\");\n+            }\n+            if ( !foundUsrEntry ) {\n+                System.out.println(\"Package [ \" + packagePath + \" ] is missing user entry [ /usr ]\");\n+            }                \n+            if ( !foundBinEntry ) {\n+                System.out.println(\"Package [ \" + packagePath + \" ] is missing bin entry [ /bin ]\");\n+            }                                \n+            if ( !foundLibEntry ) {\n+                System.out.println(\"Package [ \" + packagePath + \" ] is missing lib entry [ /lib ]\");\n+            }                                                \n+            if ( !foundLibEntry ) {\n+                System.out.println(\"Package [ \" + packagePath + \" ] is missing dev entry [ /dev ]\");\n+            }                                                                \n+\n+            if ( !foundDefaultRootEntry ) {\n+                fail(\"Package [ \" + packagePath + \" ] did not contain /wlp/.\");\n+            }\n+            if ( !foundUsrEntry ) {\n+                fail(\"Package [ \" + packagePath + \" ] did not contain /usr/.\");\n+            }\n+            if ( !foundBinEntry ) {\n+                fail(\"Package [ \" + packagePath + \" ] did not contain /bin/.\");\n+            }\n+            if ( !foundLibEntry ) {\n+                fail(\"Package [ \" + packagePath + \" ] did not contain /lib/.\");\n+            }\n+            if ( !foundDevEntry ) {\n+                fail(\"Package [ \" + packagePath + \" ] did not contain /dev/.\");\n             }\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n         }\n     }\n \n-    /**\n-     * This tests that --include=usr outputs the correct information in\n-     * the archive file\n-     *\n-     */\n     @Test\n     public void testUsrInclude() throws Exception {\n-        LibertyServer server = LibertyServerFactory.getLibertyServer(serverName);\n-        try {\n-\n-            server.getFileFromLibertyInstallRoot(\"lib/extract\");\n-\n-            String[] cmd = new String[] { \"--archive=\" + archivePackage,\n-                                          \"--include=usr\" };\n-            // Ensure package completes\n-            String stdout = server.executeServerScript(\"package\", cmd).getStdout();\n-            assertTrue(\"The package command did not complete as expected. STDOUT = \" + stdout, stdout.contains(\"package complete\"));\n-\n-            // Ensure root is correct in the .zip\n-            ZipFile zipFile = new ZipFile(server.getServerRoot() + \"/\" + archivePackage);\n-            try {\n-                boolean foundDefaultRootEntry = false;\n-                boolean foundUsrEntry = true;\n-                for (Enumeration<? extends ZipEntry> en = zipFile.entries(); en.hasMoreElements();) {\n-                    ZipEntry entry = en.nextElement();\n-                    foundDefaultRootEntry |= entry.getName().startsWith(\"wlp\");\n-                    foundUsrEntry |= entry.getName().contains(\"/usr/\");\n+        LibertyServer server = rootFatServer;\n+\n+        String packageName = archiveNameZip;\n+        String packagePath = rootFatServerPath + '/' + packageName;        \n+        String[] packageCmd = {\n+            \"--archive=\" + packageName,\n+            \"--include=usr\"\n+        };\n+        verifyPackage(server, packageCmd, packageName, packagePath);\n+\n+        try ( ZipFile zipFile = new ZipFile(packagePath) ) {\n+            boolean foundDefaultRootEntry = false;\n+            boolean foundUsrEntry = false;\n+            Enumeration<? extends ZipEntry> en = zipFile.entries();\n+            while ( (!foundDefaultRootEntry || !foundUsrEntry) && en.hasMoreElements() ) {\n+                ZipEntry entry = en.nextElement();\n+                String entryName = entry.getName();\n+                if ( !foundDefaultRootEntry ) {\n+                    foundDefaultRootEntry = entryName.startsWith(\"wlp\");\n                 }\n-                assertTrue(\"The package did not contain /wlp root structure as expected.\", foundDefaultRootEntry);\n-                assertTrue(\"The package did not contain /usr/ as expected.\", foundUsrEntry);\n-            } finally {\n-                try {\n-                    zipFile.close();\n-                } catch (IOException ex) {\n+                if ( !foundUsrEntry ) {\n+                    foundUsrEntry = entryName.contains(\"/usr/\");\n                 }\n             }\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n+            if ( !foundDefaultRootEntry ) {\n+                fail(\"Package [ \" + packagePath + \" ] missing root entries [ wlp ]\");\n+            }\n+            if ( !foundUsrEntry ) {\n+                fail(\"Package [ \" + packagePath + \" ] missing user entries [ /usr/ ]\");\n+            }\n         }\n     }\n \n     /**\n      * This tests that when --server-root is supplied, that the value supplied\n      * shows up as the root of the archive\n-     *\n      */\n     @Test\n     public void testServerRootSpecified() throws Exception {\n-        LibertyServer server = LibertyServerFactory.getLibertyServer(serverName);\n-        try {\n-\n-            server.getFileFromLibertyInstallRoot(\"lib/extract\");\n-\n-            String[] cmd = new String[] { \"--archive=\" + archivePackage,\n-                                          \"--include=minify\",\n-                                          \"--server-root=MyRoot\" };\n-            // Ensure package completes\n-            String stdout = server.executeServerScript(\"package\", cmd).getStdout();\n-            assertTrue(\"The package command did not complete as expected. STDOUT = \" + stdout, stdout.contains(\"package complete\"));\n-\n-            // Ensure root is correct in the .zip\n-            ZipFile zipFile = new ZipFile(server.getServerRoot() + \"/\" + archivePackage);\n-            try {\n-                boolean foundMyRootEntry = false;\n-                for (Enumeration<? extends ZipEntry> en = zipFile.entries(); en.hasMoreElements();) {\n-                    ZipEntry entry = en.nextElement();\n-                    foundMyRootEntry |= entry.getName().startsWith(\"MyRoot\");\n-                }\n-                assertTrue(\"The package did not contain /MyRoot as expected.\", foundMyRootEntry);\n-            } finally {\n-                try {\n-                    zipFile.close();\n-                } catch (IOException ex) {\n-                }\n+        LibertyServer server = rootFatServer;\n+\n+        String packageName = archiveNameZip;\n+        String packagePath = rootFatServerPath + '/' + packageName;        \n+        String[] packageCmd = {\n+            \"--archive=\" + packageName,\n+            \"--include=minify\",\n+            \"--server-root=MyRoot\"\n+        };\n+        verifyPackage(server, packageCmd, packageName, packagePath);\n+\n+        try ( ZipFile zipFile = new ZipFile(packagePath) ) {\n+            boolean foundMyRootEntry = false;\n+            for (Enumeration<? extends ZipEntry> en = zipFile.entries(); en.hasMoreElements();) {\n+                ZipEntry entry = en.nextElement();\n+                foundMyRootEntry |= entry.getName().startsWith(\"MyRoot\");\n+            }\n+            if ( !foundMyRootEntry ) {\n+                fail(\"Package [ \" + packagePath + \" ] missing root entries [ /MyRoot ]\");\n             }\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n         }\n     }\n \n     /**\n      * This tests that when --server-root is supplied, and --include=usr that the\n      * /shared folder is also placed at the root of the archive.\n-     *\n      */\n     @Test\n     public void testSharedFolderWithServerRootandUsrSpecified() throws Exception {\n+        LibertyServer server = rootFatServer;\n+        \n+        Path sharedPath = Paths.get(server.getServerSharedPath());\n+        File sharedFile = sharedPath.toFile();\n+        sharedFile.mkdirs();\n+        if ( !sharedFile.exists() ) {\n+            fail(\"Shared location [ \" + sharedFile.getAbsolutePath() + \" ] does not exists\");\n+        }\n+        if ( !sharedFile.isDirectory() ) {\n+            fail(\"Shared location [ \" + sharedFile.getAbsolutePath() + \" ] is not a directory\");\n+        }\n \n-        LibertyServer server = LibertyServerFactory.getLibertyServer(serverName);\n-        try {\n-\n-            server.getFileFromLibertyInstallRoot(\"lib/extract\");\n-\n-            // Ensure the usr/shared dir exists\n-            Path sharedPath = Paths.get(server.getServerSharedPath());\n-            sharedPath.toFile().mkdirs();\n-\n-            String[] cmd = new String[] { \"--archive=\" + archivePackage,\n-                                          \"--include=usr\",\n-                                          \"--server-root=MyRoot\" };\n-            // Ensure package completes\n-            String stdout = server.executeServerScript(\"package\", cmd).getStdout();\n-            assertTrue(\"The package command did not complete as expected. STDOUT = \" + stdout, stdout.contains(\"package complete\"));\n-\n-            // Ensure root is correct in the .zip\n-            ZipFile zipFile = new ZipFile(server.getServerRoot() + \"/\" + archivePackage);\n-            try {\n-                boolean foundMyRootSharedEntry = false;\n-                for (Enumeration<? extends ZipEntry> en = zipFile.entries(); en.hasMoreElements();) {\n-                    ZipEntry entry = en.nextElement();\n-                    foundMyRootSharedEntry |= entry.getName().contains(\"MyRoot/shared\");\n-                }\n-                assertTrue(\"The package did not contain MyRoot/shared/ as expected.\", foundMyRootSharedEntry);\n-            } finally {\n-                try {\n-                    zipFile.close();\n-                } catch (IOException ex) {\n-                }\n+        String packageName = archiveNameZip;\n+        String packagePath = rootFatServerPath + '/' + packageName;        \n+        String[] packageCmd = {\n+            \"--archive=\" + packageName,\n+            \"--include=usr\",\n+            \"--server-root=MyRoot\"\n+        };\n+        verifyPackage(server, packageCmd, packageName, packagePath);\n+\n+        // Ensure root is correct in the .zip\n+        try ( ZipFile zipFile = new ZipFile(packagePath) ) {\n+            boolean foundMyRootSharedEntry = false;\n+            Enumeration<? extends ZipEntry> en = zipFile.entries();\n+            while ( !foundMyRootSharedEntry && en.hasMoreElements() ) {\n+                ZipEntry entry = en.nextElement();\n+                foundMyRootSharedEntry = entry.getName().contains(\"MyRoot/shared\");\n+            }\n+            if ( !foundMyRootSharedEntry ) {\n+                fail(\"Package [ \" + packagePath + \" ] missing shared entries [ MyRoot/shared/ ]\");\n             }\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n         }\n     }\n \n@@ -410,111 +427,80 @@ public void testSharedFolderWithServerRootandUsrSpecified() throws Exception {\n      */\n     @Test\n     public void testServerFoundWithServerRootSpecified() throws Exception {\n-\n-        LibertyServer server = LibertyServerFactory.getLibertyServer(serverName);\n-        try {\n-\n-            server.getFileFromLibertyInstallRoot(\"lib/extract\");\n-\n-            String[] cmd = new String[] { \"--archive=\" + archivePackage,\n-                                          \"--include=minify\",\n-                                          \"--server-root=MyRoot\" };\n-            // Ensure package completes\n-            String stdout = server.executeServerScript(\"package\", cmd).getStdout();\n-            assertTrue(\"The package command did not complete as expected. STDOUT = \" + stdout, stdout.contains(\"package complete\"));\n-\n-            // Ensure root is correct in the .zip\n-            ZipFile zipFile = new ZipFile(server.getServerRoot() + \"/\" + archivePackage);\n-            try {\n-                boolean foundServerEntry = false;\n-                boolean foundWarFileEntry = false;\n-                for (Enumeration<? extends ZipEntry> en = zipFile.entries(); en.hasMoreElements();) {\n-                    ZipEntry entry = en.nextElement();\n-                    // For Minify, there should be /usr in the structure with server-root option\n-                    foundServerEntry |= entry.getName().contains(\"MyRoot/usr/servers/com.ibm.ws.kernel.boot.root.fat\");\n-                    foundWarFileEntry |= entry.getName().contains(\"MyRoot/usr/servers/com.ibm.ws.kernel.boot.root.fat/apps/AppsLooseWeb.war\");\n+        LibertyServer server = rootFatServer;\n+\n+        String packageName = archiveNameZip;\n+        String packagePath = rootFatServerPath + '/' + packageName;        \n+        String[] packageCmd = {\n+            \"--archive=\" + packageName,\n+            \"--include=minify\",\n+            \"--server-root=MyRoot\"\n+        };\n+        verifyPackage(server, packageCmd, packageName, packagePath); \n+\n+        // For minify, there should be /usr in the structure with server-root option\n+\n+        try ( ZipFile zipFile = new ZipFile(packagePath) ) {\n+            boolean foundServerEntry = false;\n+            boolean foundWarFileEntry = false;\n+\n+            Enumeration<? extends ZipEntry> en = zipFile.entries();\n+            while ( (!foundServerEntry || !foundWarFileEntry) && en.hasMoreElements()) {\n+                ZipEntry entry = en.nextElement();\n+                String entryName = entry.getName();\n+\n+                if ( !foundServerEntry ) {\n+                    foundServerEntry = entryName.contains(\"MyRoot/usr/servers/com.ibm.ws.kernel.boot.root.fat\");\n                 }\n-                assertTrue(\"The package did not contain MyRoot/usr/servers/com.ibm.ws.kernel.boot.root.fat as expected.\", foundServerEntry);\n-                assertTrue(\"The package did not contain MyRoot/usr/servers/com.ibm.ws.kernel.boot.root.fat/apps/AppsLooseWeb.war as expected.\", foundWarFileEntry);\n-            } finally {\n-                try {\n-                    zipFile.close();\n-                } catch (IOException ex) {\n+                if ( !foundWarFileEntry ) {\n+                    foundWarFileEntry = entryName.contains(\"MyRoot/usr/servers/com.ibm.ws.kernel.boot.root.fat/apps/AppsLooseWeb.war\");\n                 }\n             }\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n+\n+            if ( !foundServerEntry ) {\n+                fail(\"Package [ \" + packagePath + \" ] missing [ MyRoot/usr/servers/com.ibm.ws.kernel.boot.root.fat ]\");\n+            }\n+            if ( !foundWarFileEntry ) {\n+                fail(\"Package [ \" + packagePath + \" ] missing [ MyRoot/usr/servers/com.ibm.ws.kernel.boot.root.fat/apps/AppsLooseWeb.war ]\");\n+            }\n         }\n     }\n \n     /**\n      * This tests that when --include=runnable is supplied, and --archive is supplied with\n      * a file extension not ending with .jar that an error is returned.\n-     *\n      */\n     @Test\n     public void testCorrectErrorMessageWhenRunnableAndNonJARArchiveSpecified() throws Exception {\n+        LibertyServer server = rootFatServer;\n \n-        LibertyServer server = LibertyServerFactory.getLibertyServer(serverName);\n-\n-        try {\n-            server.getFileFromLibertyInstallRoot(\"lib/extract\");\n+        ensureProductExt(server);\n \n-            // Make sure we have the /wlp/etc/extension directory which indicates Product Extensions are installed\n-            File prodExtensionDir = null;\n-            try {\n-                server.getFileFromLibertyInstallRoot(\"etc/extension/\");\n-            } catch (FileNotFoundException ex) {\n-                // The /etc/extension directory does not exist - so create it for this test.\n-                String pathToProdExt = server.getInstallRoot() + \"/etc\" + \"/extension/\";\n-                prodExtensionDir = new File(pathToProdExt);\n-                prodExtensionDir.mkdirs();\n-            }\n-\n-            String[] cmd = new String[] { \"--archive=\" + archivePackage,\n-                                          \"--include=runnable\" };\n-            String stdout = server.executeServerScript(\"package\", cmd).getStdout();\n-\n-            assertTrue(\"Did not find expected failure message, CWWKE0950E.  STDOUT = \" + stdout, stdout.contains(\"CWWKE0950E\"));\n-\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n-        }\n+        String[] packageCmd = {\n+            \"--archive=\" + archiveNameZip,\n+            \"--include=runnable\"\n+        };\n+        verifyPackageError(server, packageCmd, \"CWWKE0950E\"); \n     }\n \n     /**\n      * This tests that when the --archive value has no extension, and --include=runnable\n      * that a .jar archive is created by default.\n      */\n     @Test\n+    @SkipIfSysProp(\"os.name=z/OS\") // Jar not supported on Z/OS    \n     public void testDefaultingToJar() throws Exception {\n+        LibertyServer server = rootFatServer;\n \n-        LibertyServer server = LibertyServerFactory.getLibertyServer(serverName);\n-\n-        try {\n-            server.getFileFromLibertyInstallRoot(\"lib/extract\");\n-\n-            // Make sure we have the /wlp/etc/extension directory which indicates Product Extensions are installed\n-            File prodExtensionDir = null;\n-            try {\n-                server.getFileFromLibertyInstallRoot(\"etc/extension/\");\n-            } catch (FileNotFoundException ex) {\n-                // The /etc/extension directory does not exist - so create it for this test.\n-                String pathToProdExt = server.getInstallRoot() + \"/etc\" + \"/extension/\";\n-                prodExtensionDir = new File(pathToProdExt);\n-                prodExtensionDir.mkdirs();\n-            }\n-\n-            String[] cmd = new String[] { \"--archive=\" + archivePackageNoExtension,\n-                                          \"--include=runnable\" };\n-            String stdout = server.executeServerScript(\"package\", cmd).getStdout();\n-\n-            assertTrue(\"Did not find expected 'package complete' success message.  STDOUT = \" + stdout, stdout.contains(\"package complete\"));\n-            assertTrue(\"Did not find expected .jar archive.  STDOUT = \" + stdout, stdout.contains(archivePackageNoExtension + \".jar\"));\n+        ensureProductExt(server);\n \n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n-        }\n+        String packageName = archiveNameJar;\n+        String packagePath = rootFatServerPath + '/' + packageName;\n+        String[] packageCmd = {\n+            \"--archive=\" + archiveName, // Use of 'archiveName' is correct\n+            \"--include=runnable\"\n+        };\n+        verifyPackage(server, packageCmd, packageName, packagePath);\n     }\n \n     /**\n@@ -523,158 +509,232 @@ public void testDefaultingToJar() throws Exception {\n      */\n     @Test\n     public void testDefaultingToZip() throws Exception {\n+        LibertyServer server = rootFatServer;\n \n-        LibertyServer server = LibertyServerFactory.getLibertyServer(serverName);\n-\n-        try {\n-            server.getFileFromLibertyInstallRoot(\"lib/extract\");\n-\n-            // Make sure we have the /wlp/etc/extension directory which indicates Product Extensions are installed\n-            File prodExtensionDir = null;\n-            try {\n-                server.getFileFromLibertyInstallRoot(\"etc/extension/\");\n-            } catch (FileNotFoundException ex) {\n-                // The /etc/extension directory does not exist - so create it for this test.\n-                String pathToProdExt = server.getInstallRoot() + \"/etc\" + \"/extension/\";\n-                prodExtensionDir = new File(pathToProdExt);\n-                prodExtensionDir.mkdirs();\n-            }\n-\n-            String[] cmd = new String[] { \"--archive=\" + archivePackageNoExtension,\n-                                          \"--include=usr\" };\n-            String stdout = server.executeServerScript(\"package\", cmd).getStdout();\n+        ensureProductExt(server);\n \n-            assertTrue(\"Did not find expected 'package complete' success message.  STDOUT = \" + stdout, stdout.contains(\"package complete\"));\n-            assertTrue(\"Did not find expected .zip archive.  STDOUT = \" + stdout, stdout.contains(archivePackageNoExtension + \".zip\"));\n-\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n-        }\n+        String packageName = archiveNameZip;\n+        String packagePath = rootFatServerPath + '/' + packageName;        \n+        String[] packageCmd = {\n+            \"--archive=\" + archiveName, // Use of 'archiveName' is correct.\n+            \"--include=usr\"\n+        };\n+        verifyPackage(server, packageCmd, packageName, packagePath);\n     }\n-\n+    \n     /**\n      * This tests that a .tar.gz file type is created when specified by --archive.\n      */\n     @Test\n     public void testTarGz() throws Exception {\n+        LibertyServer server = rootFatServer;\n \n-        LibertyServer server = LibertyServerFactory.getLibertyServer(serverName);\n-\n-        try {\n-            server.getFileFromLibertyInstallRoot(\"lib/extract\");\n-\n-            // Make sure we have the /wlp/etc/extension directory which indicates Product Extensions are installed\n-            File prodExtensionDir = null;\n-            try {\n-                server.getFileFromLibertyInstallRoot(\"etc/extension/\");\n-            } catch (FileNotFoundException ex) {\n-                // The /etc/extension directory does not exist - so create it for this test.\n-                String pathToProdExt = server.getInstallRoot() + \"/etc\" + \"/extension/\";\n-                prodExtensionDir = new File(pathToProdExt);\n-                prodExtensionDir.mkdirs();\n-            }\n-\n-            String[] cmd = new String[] { \"--archive=\" + archivePackageTarGzExtension,\n-                                          \"--include=usr\" };\n-            String stdout = server.executeServerScript(\"package\", cmd).getStdout();\n+        ensureProductExt(server);\n \n-            assertTrue(\"Did not find expected 'package complete' success message.  STDOUT = \" + stdout, stdout.contains(\"package complete\"));\n-            assertTrue(\"Did not find expected .tar.gz archive.  STDOUT = \" + stdout, stdout.contains(archivePackageTarGzExtension));\n-\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n-        }\n+        String packageName = archiveNameTarGz;\n+        String packagePath = rootFatServerPath + '/' + packageName;\n+        String[] packageCmd = {\n+            \"--archive=\" + packageName,\n+            \"--include=usr\"\n+        };\n+        verifyPackage(server, packageCmd, packageName, packagePath);\n     }\n \n     /**\n-     * This tests that when --include=usr is supplied, and --archive is supplied with\n-     * a file extension ending with .jar that an error is returned.\n-     *\n+     * This tests that when --include=usr is supplied, and --archive\n+     * is supplied with a file extension ending with .jar that an\n+     * error is returned.\n      */\n     @Test\n+    @SkipIfSysProp(\"os.name=z/OS\") // Jar not supported on Z/OS    \n     public void testCorrectErrorMessageWhenUsrandJARArchiveSpecified() throws Exception {\n+        LibertyServer server = rootFatServer;\n \n-        LibertyServer server = LibertyServerFactory.getLibertyServer(serverName);\n+        ensureProductExt(server);\n \n-        try {\n-            server.getFileFromLibertyInstallRoot(\"lib/extract\");\n+        String[] packageCmd = {\n+            \"--archive=\" + archiveNameJar,\n+            \"--include=usr\"\n+        };\n+        verifyPackageError(server, packageCmd, \"CWWKE0951E\"); \n \n-            // Make sure we have the /wlp/etc/extension directory which indicates Product Extensions are installed\n-            File prodExtensionDir = null;\n-            try {\n-                server.getFileFromLibertyInstallRoot(\"etc/extension/\");\n-            } catch (FileNotFoundException ex) {\n-                // The /etc/extension directory does not exist - so create it for this test.\n-                String pathToProdExt = server.getInstallRoot() + \"/etc\" + \"/extension/\";\n-                prodExtensionDir = new File(pathToProdExt);\n-                prodExtensionDir.mkdirs();\n-            }\n+    }\n \n-            String[] cmd = new String[] { \"--archive=\" + archivePackageJarExtension,\n-                                          \"--include=usr\" };\n-            String stdout = server.executeServerScript(\"package\", cmd).getStdout();\n+    /**\n+     * Verify the embedded server instance launched by the package command does\n+     * not corrupt the feature cache of the packaged (target) server.\n+     */\n+    \n+    private static final List<String> cacheFeatures;\n+    static {\n+        cacheFeatures = new ArrayList<String>(3);\n+        cacheFeatures.add(\"mpFaultTolerance-1.1\");\n+        cacheFeatures.add(\"mpMetrics-1.1\");\n+        cacheFeatures.add(\"jsp-2.3\");\n+    }\n \n-            assertTrue(\"Did not find expected failure message, CWWKE0951E.  STDOUT = \" + stdout, stdout.contains(\"CWWKE0951E\"));\n+    // Expected: \"CWWKF0012I: The server installed the following features:\n+    // [cdi-1.2, concurrent-1.0, distributedMap-1.0, el-3.0, jndi-1.0,\n+    //  json-1.0, jsp-2.3, mpConfig-1.3, mpFaultTolerance-1.1, mpMetrics-1.1,\n+    //  servlet-3.1, ssl-1.0, timedExit-1.0]\";\n \n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n+    private String collectFeatures(LibertyServer server, String tag) throws Exception {\n+        List<String> matches;\n+        try ( CloseableServer closeableServer = new CloseableServer(server) ) {\n+            matches = server.findStringsInLogs(\"CWWKF0012I:.*\");\n+        }\n+        if ( matches.isEmpty() ) {\n+            fail(\"Missing features [ CWWKF0012I ] in server [ \" + server.getInstallRoot() + \" ]\");\n+        }\n+       \n+        String rawFeatures = matches.get(0);;\n+        System.out.println(\"Raw \" + tag + \" features: \" + rawFeatures);\n+        int offset = rawFeatures.indexOf(\"CWWKF0012I:\");\n+        if ( offset == -1 ) {\n+            fail(\"Missing \" + tag + \" features [ CWWKF0012I ]: \" + rawFeatures);\n         }\n+        return rawFeatures.substring(offset);\n     }\n \n-    /**\n-     * Verify the embedded server instance launched by the package command does not corrupt\n-     * the feature cache of the packaged (target) server.\n-     */\n     @Test\n     public void testMinifyDoesNotCorruptServerFeatureCache() throws Exception {\n+        LibertyServer server = bootstrapFatServer;\n+        String serverPath = bootstrapFatServerPath;\n \n-        LibertyServer server = LibertyServerFactory.getLibertyServer(\"com.ibm.ws.kernel.bootstrap.fat\");\n-        String jarFileName = server.getServerName() + \".jar\";\n-        ServerConfiguration config = null;\n-        Set<String> features = null;\n-        try {\n-            config = server.getServerConfiguration();\n-            features = config.getFeatureManager().getFeatures();\n-            features.addAll(new HashSet<>(Arrays.asList(\"mpFaultTolerance-1.1\", \"mpMetrics-1.1\", \"jsp-2.3\")));\n-            server.updateServerConfiguration(config);\n+        try ( ServerFeatures serverFeatures = new ServerFeatures(server, cacheFeatures) ) {\n+            String initialFeatures = collectFeatures(server, \"initial\");\n+\n+            String packageName = server.getServerName() + \".jar\";\n+            String packagePath = bootstrapFatServerPath + '/' + packageName;            \n+            String[] packageCmd = {\n+                \"--archive=\" + packageName,\n+                \"--include=minify\"\n+            };\n+            verifyPackage(server, packageCmd, packageName, packagePath);\n+\n+            String finalFeatures = collectFeatures(server, \"final\");\n+\n+            assertEquals(\"Server [ \" + serverPath + \" ] cached features were changed\", initialFeatures, finalFeatures);\n+        }\n+    }\n+\n+    private static class CloseableServer implements Closeable {\n+        private final LibertyServer server;\n+        \n+        public CloseableServer(LibertyServer server) throws Exception {\n+            this.server = server;\n+            server.startServer(true);\n+        }\n+        \n+        private void stopServer() throws Exception {\n+            if (!server.isStarted()) {\n+                return;\n+            }\n \n-            server.startServer(true); // --clean\n-            String installedFeaturesBefore = server.findStringsInLogs(\"CWWKF0012I:.*\").get(0);\n-            System.out.println(\"installedFeaturesBefore: \" + installedFeaturesBefore);\n             server.stopServer();\n+        }\n \n-            String stdout = server.executeServerScript(\"package\", new String[] { \"--archive=\" + jarFileName, \"--include=minify\" }).getStdout();\n-            System.out.println(\"Server package command output: \" + stdout);\n-            assertTrue(\"Server package command launched an embedded server that computed a feature set : \", stdout.contains(\"CWWKF0012I:\"));\n-\n-            server.startServer(); // Not --clean\n-            String installedFeaturesAfter = server.findStringsInLogs(\"CWWKF0012I:.*\").get(0);\n-            System.out.println(\"installedFeaturesAfter: \" + installedFeaturesAfter);\n-\n-            int i = installedFeaturesBefore.indexOf(\"CWWKF0012I:\"); // Ignore the timestamp\n-            int j = installedFeaturesAfter.indexOf(\"CWWKF0012I:\");\n-            assertTrue(\"Server package command did not change the packaged server's feature cache: \",\n-                       i > 0 && j > 0 && installedFeaturesBefore.substring(i).equals(installedFeaturesAfter.substring(j)));\n-            //Expected: \"CWWKF0012I: The server installed the following features: [cdi-1.2, concurrent-1.0, distributedMap-1.0, el-3.0, jndi-1.0, json-1.0, jsp-2.3, mpConfig-1.3, mpFaultTolerance-1.1, mpMetrics-1.1, servlet-3.1, ssl-1.0, timedExit-1.0]\";\n-        } finally {\n-            if (server.isStarted()) {\n-                try {\n-                    server.stopServer();\n-                } catch (Exception e1) {\n-                    e1.printStackTrace(System.out);\n-                }\n+        public void close() throws IOException {\n+            try {\n+                stopServer();\n+            } catch ( IOException e ) {\n+                throw e;\n+            } catch ( Exception e ) {\n+                throw new IOException(e); \n+            }            \n+        }\n+    }\n+\n+    private static class ServerFeatures implements Closeable {\n+        private final LibertyServer server;\n+        private final Collection<String> features;\n+        \n+        public ServerFeatures(LibertyServer server, Collection<String> features) throws Exception {\n+            this.server = server;\n+            this.features = features;\n+            \n+            setFeatures();\n+        }\n+        \n+        private void setFeatures() throws Exception {\n+            ServerConfiguration config = server.getServerConfiguration();\n+            Set<String> serverFeatures = config.getFeatureManager().getFeatures();\n+            serverFeatures.addAll(features);\n+            server.updateServerConfiguration(config);\n+        }\n+\n+        private void unsetFeatures() throws Exception {\n+            ServerConfiguration config = server.getServerConfiguration();\n+            Set<String> serverFeatures = config.getFeatureManager().getFeatures();\n+            serverFeatures.removeAll(features);\n+            server.updateServerConfiguration(config);            \n+        }\n+\n+        public void close() throws IOException {\n+            try {\n+                unsetFeatures();\n+            } catch ( IOException e ) {\n+                throw e;\n+            } catch ( Exception e ) {\n+                throw new IOException(e); \n             }\n-            // Help tidy up, but likely redundant as getLibertyServer() will reset the server configuration.\n-            if (!features.isEmpty() && features.contains(\"mpFaultTolerance-1.1\")) {\n-                features.removeAll(new HashSet<>(Arrays.asList(\"mpFaultTolerance-1.1\", \"mpMetrics-1.1\", \"jsp-2.3\")));\n-                try {\n-                    server.updateServerConfiguration(config);\n-                } catch (Exception e2) {\n-                    e2.printStackTrace(System.out);\n-                }\n+        }\n+    }\n+\n+    // Make sure we have the /wlp/etc/extension directory which\n+    // indicates Product Extensions are installed.\n+\n+    private void ensureProductExt(LibertyServer server) throws Exception {\n+        String prodExtPath = server.getInstallRoot() + \"/etc/extension/\";\n+        File prodExt = new File(prodExtPath);\n+\n+        if ( !prodExt.exists() ) {\n+            prodExt.mkdirs();\n+            if ( !prodExt.exists() ) {\n+                throw new FileNotFoundException(prodExtPath);\n             }\n+        }\n \n+        if ( !prodExt.isDirectory() ) {\n+            throw new IOException(\"Product extension location is not a directory [ \" + prodExtPath + \" ]\");\n         }\n     }\n \n+    private String packageServer(LibertyServer server, String[] packageCmd) throws Exception {\n+        return server.executeServerScript(\"package\", packageCmd).getStdout();\n+    }\n+    \n+    private void verifyPackage(\n+        LibertyServer server,\n+        String[] packageCmd, String packageName, String packagePath)\n+        throws Exception {\n+\n+        System.out.println(\"Packaging server [ \" + server.getInstallRoot() + \" ]\");\n+        System.out.println(\"Package [ \" + packagePath + \" ]\");\n+\n+        String stdout = packageServer(server, packageCmd);\n+\n+        if ( !stdout.contains(\"package complete\") ) {\n+            fail(\"Packaging did not complete. STDOUT = \" + stdout);\n+        } else {\n+            System.out.println(\"Packaging completed; found [ package complete ]\");\n+        }\n+        if ( !stdout.contains(packageName) ) {\n+            fail(\"Packaging did not show archive [ \" + packageName + \" ].  STDOUT = \" + stdout);\n+        } else {\n+            System.out.println(\"Packaging displays archive [ \" + packageName + \" ]\");\n+        }\n+        if ( !(new File(packagePath)).exists() ) {\n+            fail(\"Package [ \" + packagePath + \" ] does not exist.  STDOUT = \" + stdout);\n+        } else {\n+            System.out.println(\"Package file was created [ \" + packagePath + \" ]\");\n+        }\n+    }\n+\n+    private void verifyPackageError(LibertyServer server, String[] packageCmd, String errorText) throws Exception {\n+        String stdout = packageServer(server, packageCmd);\n+        if ( !stdout.contains(errorText) ) {\n+            fail(\"Packaging output missing error \" + errorText + \". STDOUT = \" + stdout);\n+        }\n+    }\n }"
  },
  {
    "sha": "db85c7fcd2d05c921f7b0eed091aedf1c55951d3",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseConfigDropinsTest.java",
    "status": "removed",
    "additions": 0,
    "deletions": 194,
    "changes": 194,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/e9dec03eccb8e68797e6af1fb804c075ff50ce7c/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseConfigDropinsTest.java",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/e9dec03eccb8e68797e6af1fb804c075ff50ce7c/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseConfigDropinsTest.java",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseConfigDropinsTest.java?ref=e9dec03eccb8e68797e6af1fb804c075ff50ce7c",
    "patch": "@@ -1,194 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2014 IBM Corporation and others.\n- * All rights reserved. This program and the accompanying materials\n- * are made available under the terms of the Eclipse Public License v1.0\n- * which accompanies this distribution, and is available at\n- * http://www.eclipse.org/legal/epl-v10.html\n- *\n- * Contributors:\n- *     IBM Corporation - initial API and implementation\n- *******************************************************************************/\n-package com.ibm.ws.kernel.boot.internal.commands;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.junit.Assume.assumeTrue;\n-\n-import java.io.BufferedReader;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.util.Enumeration;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarFile;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipFile;\n-\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.TestName;\n-\n-import componenttest.topology.impl.LibertyServer;\n-import componenttest.topology.impl.LibertyServerFactory;\n-\n-/**\n- *\n- */\n-public class PackageLooseConfigDropinsTest extends AbstractLooseConfigTest {\n-\n-    LibertyServer server;\n-    private static String ARCHIVE = \"DefaultArchive.war\";\n-\n-    @Rule\n-    public TestName testName = new TestName();\n-\n-    @Before\n-    public void before() throws Exception {\n-\n-        // Delete previous archive file if it exists\n-        server = LibertyServerFactory.getLibertyServer(SERVER_NAME);\n-        server.deleteFileFromLibertyServerRoot(ARCHIVE_PACKAGE);\n-\n-        System.out.printf(\"%n%s%n\", testName.getMethodName());\n-    }\n-\n-    @After\n-    public void clean() throws Exception {\n-        server.deleteFileFromLibertyServerRoot(DROPINS_DIR + \"/DefaultArchive.war.xml\");\n-    }\n-\n-    /**\n-     * Packages a loose application with '--include=all' and verifies that the\n-     * resulting package contains the expected entries\n-     */\n-    @Test\n-    public void testIncludeAll() throws Exception {\n-        try {\n-            String[] cmd = new String[] { \"--archive=\" + ARCHIVE_PACKAGE, \"--include=all\",\n-                                          \"--server-root=\" + SERVER_ROOT };\n-            packageWithConfig(server, cmd);\n-            ZipFile zipFile = new ZipFile(server.getServerRoot() + \"/\" + ARCHIVE_PACKAGE);\n-            try {\n-                String serverPath = SERVER_ROOT + \"/usr/servers/\" + SERVER_NAME;\n-                boolean foundServerEntry = false;\n-                boolean foundWarFileEntry = false;\n-                boolean foundExpandedEntry = false;\n-                for (Enumeration<? extends ZipEntry> en = zipFile.entries(); en.hasMoreElements();) {\n-                    ZipEntry entry = en.nextElement();\n-\n-                    foundServerEntry |= entry.getName().matches(\"^\" + serverPath + \"/$\");\n-                    foundWarFileEntry |= entry.getName().matches(\"^\" + serverPath + \"/dropins/\" + ARCHIVE + \"$\");\n-                    foundExpandedEntry |= entry.getName().matches(\"^\" + serverPath + \"/apps/expanded/\" + ARCHIVE + \"/.*$\");\n-                }\n-                assertTrue(\"The package did not contain \" + serverPath + \"/ as expected.\", foundServerEntry);\n-                assertTrue(\"The package did not contain \" + serverPath + \"/dropins/\" + ARCHIVE + \" as expected.\",\n-                           foundWarFileEntry);\n-                assertTrue(\"The package did not contain \" + serverPath + \"/apps/expanded/\" + ARCHIVE + \"/ as expected.\",\n-                           foundExpandedEntry);\n-            } finally {\n-                try {\n-                    zipFile.close();\n-                } catch (IOException ex) {\n-                }\n-            }\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n-        }\n-    }\n-\n-    /**\n-     * Packages a loose application with '--include=runnable' and verifies that the\n-     * resulting package contains the expected entries\n-     */\n-    @Test\n-    public void testIncludeRunnable() throws Exception {\n-\n-        try {\n-            String archivePackage = \"MyPackage.jar\";\n-            String[] cmd = new String[] { \"--archive=\" + archivePackage, \"--include=runnable\" };\n-            packageWithConfig(server, cmd);\n-            JarFile jarFile = new JarFile(server.getServerRoot() + \"/\" + archivePackage);\n-            try {\n-                String serverPath = \"wlp/usr/servers/\" + SERVER_NAME;\n-                boolean foundServerEntry = false;\n-                boolean foundWarFileEntry = false;\n-                boolean foundExpandedEntry = false;\n-                for (Enumeration<? extends JarEntry> en = jarFile.entries(); en.hasMoreElements();) {\n-                    JarEntry entry = en.nextElement();\n-                    // Uses String.matches() to ensure exact path is found\n-                    foundServerEntry |= entry.getName().matches(\"^\" + serverPath + \"/$\");\n-                    foundWarFileEntry |= entry.getName().matches(\"^\" + serverPath + \"/dropins/\" + ARCHIVE + \"$\");\n-                    foundExpandedEntry |= entry.getName().matches(\"^\" + serverPath + \"/apps/expanded/\" + ARCHIVE + \"/.*$\");\n-                }\n-                assertTrue(\"The package did not contain \" + serverPath + \"/ as expected.\", foundServerEntry);\n-                assertTrue(\"The package did not contain \" + serverPath + \"/dropins/\" + ARCHIVE + \" as expected.\",\n-                           foundWarFileEntry);\n-                assertTrue(\"The package did not contain \" + serverPath + \"/apps/expanded/\" + ARCHIVE + \"/ as expected.\",\n-                           foundExpandedEntry);\n-            } finally {\n-                try {\n-                    jarFile.close();\n-                } catch (IOException ex) {\n-                }\n-            }\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n-        }\n-    }\n-\n-    /**\n-     * Packages a loose application into a .jar with 'include=runnable' and verifies\n-     * that it starts up properly after being run with 'java -jar packageName.jar'\n-     */\n-    @Test\n-    public void testCreateAndStartRunnableJar() throws Exception {\n-        try {\n-            String archivePackage = \"runnablePackage.jar\";\n-            String[] cmd = new String[] { \"--archive=\" + archivePackage, \"--include=runnable\" };\n-            packageWithConfig(server, cmd);\n-\n-            // Start a separate process to run the jar\n-            Process proc = Runtime.getRuntime().exec(new String[] { \"java\", \"-jar\", server.getServerRoot() + \"/\" + archivePackage });\n-            try {\n-                BufferedReader brOutput = new BufferedReader(new InputStreamReader(proc.getInputStream()));\n-                BufferedReader brError = new BufferedReader(new InputStreamReader(proc.getErrorStream()));\n-\n-                // Timeout after 20 seconds if the server still hasn't started\n-                long timeStart = System.nanoTime();\n-                long timeLimit = 20 * (long) Math.pow(10, 9);\n-\n-                boolean serverDidLaunch = false;\n-                boolean serverIsReady = false;\n-                while (!(serverDidLaunch && serverIsReady) && timeLimit - (System.nanoTime() - timeStart) > 0) {\n-\n-                    // If an error is read fail the test\n-                    if (brError.ready()) {\n-                        fail(\"The server package \" + archivePackage + \" encountered the following error(s):\\n\\t\"\n-                             + brError.readLine());\n-                    }\n-\n-                    if (brOutput.ready()) {\n-                        String line = brOutput.readLine();\n-                        serverDidLaunch |= line.matches(\"^.* CWWKE0001I: .* \" + SERVER_NAME + \" .*$\");\n-                        serverIsReady |= line.matches(\".* CWWKF0011I: .* \" + SERVER_NAME + \" .*$\");\n-                    }\n-                }\n-\n-                assertTrue(\"The server package \" + archivePackage + \" did not launch successfully\", serverDidLaunch);\n-                assertTrue(\"The server package \" + archivePackage + \" was not ready to run in time\", serverIsReady);\n-            } finally {\n-                proc.destroy();\n-            }\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n-        }\n-    }\n-\n-    @Override\n-    public String getAppsTargetDir() {\n-\n-        return DROPINS_DIR;\n-    }\n-}\n\\ No newline at end of file"
  },
  {
    "sha": "7fa77e42e8419f0a4118f1ab2ad9be8a6d6c7a24",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseConfigParameterizedTest.java",
    "status": "removed",
    "additions": 0,
    "deletions": 186,
    "changes": 186,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/e9dec03eccb8e68797e6af1fb804c075ff50ce7c/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseConfigParameterizedTest.java",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/e9dec03eccb8e68797e6af1fb804c075ff50ce7c/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseConfigParameterizedTest.java",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseConfigParameterizedTest.java?ref=e9dec03eccb8e68797e6af1fb804c075ff50ce7c",
    "patch": "@@ -1,186 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2014 IBM Corporation and others.\n- * All rights reserved. This program and the accompanying materials\n- * are made available under the terms of the Eclipse Public License v1.0\n- * which accompanies this distribution, and is available at\n- * http://www.eclipse.org/legal/epl-v10.html\n- *\n- * Contributors:\n- *     IBM Corporation - initial API and implementation\n- *******************************************************************************/\n-package com.ibm.ws.kernel.boot.internal.commands;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assume.assumeTrue;\n-\n-import java.io.BufferedInputStream;\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipFile;\n-\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.TestName;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameters;\n-\n-import componenttest.topology.impl.LibertyServer;\n-import componenttest.topology.impl.LibertyServerFactory;\n-\n-/**\n- *\n- */\n-@RunWith(Parameterized.class)\n-public class PackageLooseConfigParameterizedTest extends AbstractLooseConfigTest {\n-\n-    private LibertyServer server;\n-    private final String config;\n-    private final String archive;\n-\n-    public PackageLooseConfigParameterizedTest(String config) {\n-        this.config = config;\n-        // Remove .xml from config file name to get loose config archive name\n-        this.archive = config.substring(0, config.lastIndexOf('.'));\n-    }\n-\n-    @Rule\n-    public TestName testName = new TestName();\n-\n-    @Before\n-    public void before() throws Exception {\n-\n-        // Delete previous archive file if it exists\n-        server = LibertyServerFactory.getLibertyServer(SERVER_NAME);\n-        server.deleteFileFromLibertyServerRoot(ARCHIVE_PACKAGE);\n-\n-        System.out.printf(\"%n%s%n\", testName.getMethodName());\n-    }\n-\n-    @After\n-    public void clean() throws Exception {\n-        server.deleteFileFromLibertyServerRoot(APPS_DIR + \"/\" + config);\n-    }\n-\n-    @Parameters\n-    public static Collection<Object[]> data() {\n-        return getConfigsAsParameters();\n-    }\n-\n-    /**\n-     * Packages a loose application with '--include=usr' and verifies that the\n-     * resulting package contains the expected entries.\n-     */\n-    @Test\n-    public void testIncludeUsr() throws Exception {\n-        try {\n-            packageWithConfig(server, config);\n-            ZipFile zipFile = new ZipFile(server.getServerRoot() + \"/\" + ARCHIVE_PACKAGE);\n-            try {\n-                boolean foundServerEntry = false;\n-                boolean foundWarFileEntry = false;\n-                boolean foundExpandedEntry = false;\n-                for (Enumeration<? extends ZipEntry> en = zipFile.entries(); en.hasMoreElements();) {\n-                    ZipEntry entry = en.nextElement();\n-                    // Uses String.matches() to ensure exact path is found\n-                    foundServerEntry |= entry.getName().matches(\"^\" + SERVER_PATH + \"/$\");\n-                    foundWarFileEntry |= entry.getName().matches(\"^\" + SERVER_PATH + \"/apps/\" + archive + \"$\");\n-                    foundExpandedEntry |= entry.getName().matches(\"^\" + SERVER_PATH + \"/apps/expanded/\" + archive + \"/.*$\");\n-                }\n-                assertTrue(\"The package did not contain \" + SERVER_PATH + \"/ as expected.\", foundServerEntry);\n-                assertTrue(\"The package did not contain \" + SERVER_PATH + \"/apps/\" + archive + \" as expected.\",\n-                           foundWarFileEntry);\n-                assertTrue(\n-                           \"The package did not contain \" + SERVER_PATH + \"/apps/expanded/\" + archive + \"/ as expected.\",\n-                           foundExpandedEntry);\n-            } finally {\n-                try {\n-                    zipFile.close();\n-                } catch (IOException ex) {\n-                }\n-            }\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n-        }\n-    }\n-\n-    /**\n-     * Compares the contents of the .war archive and the expanded folder found in a\n-     * packaged loose application to ensure they have the same files in the same order.\n-     */\n-    @Test\n-    public void testArchiveContentsMatchExpandedFolder() throws Exception {\n-        try {\n-            packageWithConfig(server, config);\n-            // Map every entry found in both the .war and the expanded folder to\n-            // the relative order they were found. Add the values from the archive and\n-            // subtract the values from the expanded folder.\n-            // Resulting values should all be 0.\n-            HashMap<String, Integer> checkMatch = new HashMap<>();\n-            int expandedOrder = -1;\n-            ZipFile packageZip = new ZipFile(server.getServerRoot() + \"/\" + ARCHIVE_PACKAGE);\n-            try {\n-                for (Enumeration<? extends ZipEntry> packageEn = packageZip.entries(); packageEn.hasMoreElements();) {\n-                    ZipEntry packageEntry = packageEn.nextElement();\n-\n-                    // Found the entry for the .war in the .zip\n-                    if (packageEntry.getName().matches(\"^\" + SERVER_PATH + \"/apps/\" + archive + \"$\")) {\n-                        // Read the contents of the compressed .war into warFile\n-                        BufferedInputStream bis = new BufferedInputStream(packageZip.getInputStream(packageEntry));\n-                        File warFile = new File(server.getServerRoot() + \"/packagedWar\");\n-                        FileOutputStream warOutput = new FileOutputStream(warFile);\n-                        while (bis.available() > 0) {\n-                            warOutput.write(bis.read());\n-                        }\n-                        warOutput.close();\n-\n-                        // Add the index of each extracted entry from the .war into the hashmap using\n-                        // their name as the key\n-                        ZipFile warZip = new ZipFile(warFile);\n-                        int warOrder = 1;\n-                        for (Enumeration<? extends ZipEntry> warEn = warZip.entries(); warEn.hasMoreElements();) {\n-                            String warEntry = warEn.nextElement().getName();\n-                            putMatch(checkMatch, warEntry, warOrder++);\n-\n-                        }\n-                        warZip.close();\n-                    }\n-\n-                    // Subtract the index of each entry in the expanded folder from the hashmap\n-                    // using their name as the key\n-                    if (packageEntry.getName().matches(\"^\" + SERVER_PATH + \"/apps/expanded/\" + archive + \"/.+$\")) {\n-                        String expandedEntry = packageEntry.getName().replaceFirst(SERVER_PATH + \"/apps/expanded/\" + archive + \"/\", \"\");\n-\n-                        putMatch(checkMatch, expandedEntry, expandedOrder--);\n-                    }\n-                }\n-\n-                // If the archive and the expanded folder contain the same files in the same\n-                // order then every entry will have a value of 0\n-                Iterator<Map.Entry<String, Integer>> matchSet = checkMatch.entrySet().iterator();\n-                while (matchSet.hasNext()) {\n-                    Map.Entry<String, Integer> match = matchSet.next();\n-                    assertTrue(\"The archive does not match the expanded folder at file: \" + match.getKey(),\n-                               match.getValue() == 0);\n-                }\n-            } finally {\n-                try {\n-                    packageZip.close();\n-                } catch (IOException ex) {\n-                }\n-            }\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n-        }\n-    }\n-}\n\\ No newline at end of file"
  },
  {
    "sha": "63658cd69c55d2e347ed3ee0b451ba1e9c8b2526",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseConfigTest.java",
    "status": "removed",
    "additions": 0,
    "deletions": 188,
    "changes": 188,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/e9dec03eccb8e68797e6af1fb804c075ff50ce7c/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseConfigTest.java",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/e9dec03eccb8e68797e6af1fb804c075ff50ce7c/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseConfigTest.java",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseConfigTest.java?ref=e9dec03eccb8e68797e6af1fb804c075ff50ce7c",
    "patch": "@@ -1,188 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2014 IBM Corporation and others.\n- * All rights reserved. This program and the accompanying materials\n- * are made available under the terms of the Eclipse Public License v1.0\n- * which accompanies this distribution, and is available at\n- * http://www.eclipse.org/legal/epl-v10.html\n- *\n- * Contributors:\n- *     IBM Corporation - initial API and implementation\n- *******************************************************************************/\n-package com.ibm.ws.kernel.boot.internal.commands;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.junit.Assume.assumeTrue;\n-\n-import java.io.BufferedReader;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.util.Enumeration;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarFile;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipFile;\n-\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.TestName;\n-\n-import componenttest.topology.impl.LibertyServer;\n-import componenttest.topology.impl.LibertyServerFactory;\n-\n-/**\n- *\n- */\n-public class PackageLooseConfigTest extends AbstractLooseConfigTest {\n-\n-    LibertyServer server;\n-    private static String ARCHIVE = \"DefaultArchive.war\";\n-\n-    @Rule\n-    public TestName testName = new TestName();\n-\n-    @Before\n-    public void before() throws Exception {\n-\n-        // Delete previous archive file if it exists\n-        server = LibertyServerFactory.getLibertyServer(SERVER_NAME);\n-        server.deleteFileFromLibertyServerRoot(ARCHIVE_PACKAGE);\n-\n-        System.out.printf(\"%n%s%n\", testName.getMethodName());\n-    }\n-\n-    @After\n-    public void clean() throws Exception {\n-        server.deleteFileFromLibertyServerRoot(APPS_DIR + \"/DefaultArchive.war.xml\");\n-    }\n-\n-    /**\n-     * Packages a loose application with '--include=all' and verifies that the\n-     * resulting package contains the expected entries\n-     */\n-    @Test\n-    public void testIncludeAll() throws Exception {\n-        try {\n-            String[] cmd = new String[] { \"--archive=\" + ARCHIVE_PACKAGE, \"--include=all\",\n-                                          \"--server-root=\" + SERVER_ROOT };\n-            packageWithConfig(server, cmd);\n-            ZipFile zipFile = new ZipFile(server.getServerRoot() + \"/\" + ARCHIVE_PACKAGE);\n-            try {\n-                String serverPath = SERVER_ROOT + \"/usr/servers/\" + SERVER_NAME;\n-                boolean foundServerEntry = false;\n-                boolean foundWarFileEntry = false;\n-                boolean foundExpandedEntry = false;\n-                for (Enumeration<? extends ZipEntry> en = zipFile.entries(); en.hasMoreElements();) {\n-                    ZipEntry entry = en.nextElement();\n-\n-                    foundServerEntry |= entry.getName().matches(\"^\" + serverPath + \"/$\");\n-                    foundWarFileEntry |= entry.getName().matches(\"^\" + serverPath + \"/apps/\" + ARCHIVE + \"$\");\n-                    foundExpandedEntry |= entry.getName().matches(\"^\" + serverPath + \"/apps/expanded/\" + ARCHIVE + \"/.*$\");\n-                }\n-                assertTrue(\"The package did not contain \" + serverPath + \"/ as expected.\", foundServerEntry);\n-                assertTrue(\"The package did not contain \" + serverPath + \"/apps/\" + ARCHIVE + \" as expected.\",\n-                           foundWarFileEntry);\n-                assertTrue(\"The package did not contain \" + serverPath + \"/apps/expanded/\" + ARCHIVE + \"/ as expected.\",\n-                           foundExpandedEntry);\n-            } finally {\n-                try {\n-                    zipFile.close();\n-                } catch (IOException ex) {\n-                }\n-            }\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n-        }\n-    }\n-\n-    /**\n-     * Packages a loose application with '--include=runnable' and verifies that the\n-     * resulting package contains the expected entries\n-     */\n-    @Test\n-    public void testIncludeRunnable() throws Exception {\n-\n-        try {\n-            String archivePackage = \"MyPackage.jar\";\n-            String[] cmd = new String[] { \"--archive=\" + archivePackage, \"--include=runnable\" };\n-            packageWithConfig(server, cmd);\n-            JarFile jarFile = new JarFile(server.getServerRoot() + \"/\" + archivePackage);\n-            try {\n-                String serverPath = \"wlp/usr/servers/\" + SERVER_NAME;\n-                boolean foundServerEntry = false;\n-                boolean foundWarFileEntry = false;\n-                boolean foundExpandedEntry = false;\n-                for (Enumeration<? extends JarEntry> en = jarFile.entries(); en.hasMoreElements();) {\n-                    JarEntry entry = en.nextElement();\n-                    // Uses String.matches() to ensure exact path is found\n-                    foundServerEntry |= entry.getName().matches(\"^\" + serverPath + \"/$\");\n-                    foundWarFileEntry |= entry.getName().matches(\"^\" + serverPath + \"/apps/\" + ARCHIVE + \"$\");\n-                    foundExpandedEntry |= entry.getName().matches(\"^\" + serverPath + \"/apps/expanded/\" + ARCHIVE + \"/.*$\");\n-                }\n-                assertTrue(\"The package did not contain \" + serverPath + \"/ as expected.\", foundServerEntry);\n-                assertTrue(\"The package did not contain \" + serverPath + \"/apps/\" + ARCHIVE + \" as expected.\",\n-                           foundWarFileEntry);\n-                assertTrue(\"The package did not contain \" + serverPath + \"/apps/expanded/\" + ARCHIVE + \"/ as expected.\",\n-                           foundExpandedEntry);\n-            } finally {\n-                try {\n-                    jarFile.close();\n-                } catch (IOException ex) {\n-                }\n-            }\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n-        }\n-    }\n-\n-    /**\n-     * Packages a loose application into a .jar with 'include=runnable' and verifies\n-     * that it starts up properly after being run with 'java -jar packageName.jar'\n-     */\n-    @Test\n-    public void testCreateAndStartRunnableJar() throws Exception {\n-        try {\n-            String archivePackage = \"runnablePackage.jar\";\n-            String[] cmd = new String[] { \"--archive=\" + archivePackage, \"--include=runnable\" };\n-            packageWithConfig(server, cmd);\n-\n-            // Start a separate process to run the jar\n-            Process proc = Runtime.getRuntime().exec(new String[] { \"java\", \"-jar\", server.getServerRoot() + \"/\" + archivePackage });\n-            try {\n-                BufferedReader brOutput = new BufferedReader(new InputStreamReader(proc.getInputStream()));\n-                BufferedReader brError = new BufferedReader(new InputStreamReader(proc.getErrorStream()));\n-\n-                // Timeout after 20 seconds if the server still hasn't started\n-                long timeStart = System.nanoTime();\n-                long timeLimit = 20 * (long) Math.pow(10, 9);\n-\n-                boolean serverDidLaunch = false;\n-                boolean serverIsReady = false;\n-                while (!(serverDidLaunch && serverIsReady) && timeLimit - (System.nanoTime() - timeStart) > 0) {\n-\n-                    // If an error is read fail the test\n-                    if (brError.ready()) {\n-                        fail(\"The server package \" + archivePackage + \" encountered the following error(s):\\n\\t\"\n-                             + brError.readLine());\n-                    }\n-\n-                    if (brOutput.ready()) {\n-                        String line = brOutput.readLine();\n-                        serverDidLaunch |= line.matches(\"^.* CWWKE0001I: .* \" + SERVER_NAME + \" .*$\");\n-                        serverIsReady |= line.matches(\".* CWWKF0011I: .* \" + SERVER_NAME + \" .*$\");\n-                    }\n-                }\n-\n-                assertTrue(\"The server package \" + archivePackage + \" did not launch successfully\", serverDidLaunch);\n-                assertTrue(\"The server package \" + archivePackage + \" was not ready to run in time\", serverIsReady);\n-            } finally {\n-                proc.destroy();\n-            }\n-        } catch (FileNotFoundException ex) {\n-            assumeTrue(false); // the directory does not exist, so we skip this test.\n-        }\n-    }\n-}\n\\ No newline at end of file"
  },
  {
    "sha": "2a55381bb7d8f5d3c5c643b9db1c40eccdca0fa6",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseContentsTest.java",
    "status": "added",
    "additions": 280,
    "deletions": 0,
    "changes": 280,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseContentsTest.java",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseContentsTest.java",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseContentsTest.java?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -0,0 +1,280 @@\n+/*******************************************************************************\n+ * Copyright (c) 2014, 2021 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.kernel.boot.internal.commands;\n+\n+import static org.junit.Assert.fail;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipInputStream;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import componenttest.topology.impl.LibertyServerFactory;\n+\n+@RunWith(Parameterized.class)\n+public class PackageLooseContentsTest extends AbstractLooseConfigTest {\n+\n+    // The full list of available configurations is:\n+    //   DefaultArchive.war.xml\n+    //   SimpleElements.war.xml\n+    //   ArchivedElements.war.xml\n+    //   EarArchive.ear.xml\n+    // Plus:\n+    //   SkipInvalidEntries.war.xml\n+    //   EmptyArchive.war.xml\n+    \n+    private static final List<Object[]> CONFIGS = new ArrayList<>(5);\n+    static {\n+        CONFIGS.add(new Object[] { \"DefaultArchive.war.xml\", \"true\" });\n+        CONFIGS.add(new Object[] { \"SimpleElements.war.xml\", \"true\" });\n+        CONFIGS.add(new Object[] { \"ArchivedElements.war.xml\", \"true\" });\n+        CONFIGS.add(new Object[] { \"EarArchive.ear.xml\", \"true\" });\n+\n+        CONFIGS.add(new Object[] { \"SkipInvalidEntries.war.xml\", \"false\" });\n+        CONFIGS.add(new Object[] { \"EmptyArchive.war.xml\", \"false\" });\n+    };\n+\n+    @Parameters\n+    public static Collection<Object[]> data() {\n+        return CONFIGS;\n+    }\n+\n+    private final String moduleLooseConfig;\n+    private String moduleLooseConfigPath;\n+    private final String moduleArchiveName;\n+    private String moduleExpandedPath;\n+    private final boolean verifyApp;\n+\n+    public PackageLooseContentsTest(String config, String verifyApp) {\n+        this.moduleLooseConfig = config;\n+        this.moduleLooseConfigPath = null;\n+        this.moduleArchiveName = config.substring(0, config.lastIndexOf('.'));\n+        this.moduleExpandedPath = null;\n+        \n+        this.verifyApp = Boolean.valueOf(verifyApp);\n+    }\n+\n+    //\n+\n+    @Override\n+    public String getAppsTargetDir() {\n+        return APPS_DIR;\n+    }\n+\n+    //\n+\n+    @Rule\n+    public TestName testName = new TestName();\n+\n+    @Before\n+    public void before() throws Exception {\n+        System.out.println(testName.getMethodName());\n+\n+        setServer( LibertyServerFactory.getLibertyServer(SERVER_NAME) );\n+\n+        String appsPath = getServer().getServerRoot() + '/' + getAppsTargetDir() + '/'; \n+        moduleLooseConfigPath = appsPath + moduleLooseConfig;\n+        moduleExpandedPath = appsPath + \"expanded/\" + moduleArchiveName;\n+\n+        System.out.println(\"  Module loose config: \" + moduleLooseConfig);\n+        System.out.println(\"  Module loose config path: \" + moduleLooseConfigPath);\n+        System.out.println(\"  Module archive: \" + moduleArchiveName);\n+        System.out.println(\"  Module expanded path: \" + moduleExpandedPath);\n+\n+        getServer().deleteFileFromLibertyServerRoot(moduleArchiveName);\n+    }\n+\n+    @After\n+    public void clean() throws Exception {\n+        new File(moduleLooseConfigPath).delete();\n+    }\n+\n+    //\n+\n+    @Test\n+    public void testIncludeUsr_Contents() throws Exception {\n+        String[] packageCmd = new String[] {\n+            \"--archive=\" + SERVER_NAME,\n+            \"--include=usr\",\n+            \"--server-root=\" + SERVER_ROOT };\n+        String archivePath = packageServer(moduleLooseConfig, SERVER_NAME_ZIP, packageCmd);\n+        // Because server-root and include=usr are specified,\n+        // packaging shifts the server folder up one directory.  The\n+        // 'usr' directory is excised from the path.\n+        verifyContents(archivePath,\n+            SERVER_ROOT, !INCLUDE_USR, SERVER_NAME,\n+            moduleArchiveName, verifyApp);\n+    }\n+\n+    @Override\n+    protected void verifyContents(\n+        String archivePath,\n+        String serverRoot, boolean includeUsr, String serverName,\n+        String moduleName, boolean verifyApp) throws IOException {\n+\n+        String methodName = \"verifyContents\";\n+\n+        super.verifyContents(archivePath,\n+            serverRoot, includeUsr, serverName,\n+            moduleName, verifyApp);\n+\n+        if ( !verifyApp ) {\n+            return;\n+        }\n+\n+        String packedPath = serverRoot;\n+        if ( includeUsr ) {\n+            packedPath += \"/usr\";\n+        }\n+        packedPath +=\n+            \"/servers/\" + serverName + '/' +\n+            getAppsTargetDir() + '/' +\n+            moduleName;\n+\n+        String unpackedPrefix = serverRoot;\n+        if ( includeUsr ) {\n+            unpackedPrefix += \"/usr\";\n+        }\n+        unpackedPrefix +=\n+            \"/servers/\" + serverName + '/' +\n+            getAppsTargetDir() + \"/expanded/\" +\n+            moduleName + '/';\n+        int unpackedPrefixLen = unpackedPrefix.length();\n+\n+        System.out.println(methodName + \":  Packed archive [ \" + packedPath + \" ]\");\n+        System.out.println(methodName + \":  Unpacked archive [ \" + unpackedPrefix + \" ]\");\n+\n+        Map<String, Integer> packedMapping = null;\n+        Map<String, Integer> unpackedMapping = null;\n+\n+        try ( ZipFile packageZip = new ZipFile(archivePath) ) {\n+            int unpackedOffset = 0;\n+\n+            String lastEntry = null;\n+            int lastSlash = -1;\n+            \n+            Enumeration<? extends ZipEntry> entries = packageZip.entries();\n+            while ( entries.hasMoreElements() ) {\n+                ZipEntry entry = entries.nextElement();\n+                String entryName = entry.getName();\n+                int slash = entryName.lastIndexOf('/');\n+                boolean doLog = (\n+                    (lastEntry == null) ||\n+                    (slash != lastSlash) ||\n+                    !entryName.regionMatches(0, lastEntry, 0, lastSlash) );\n+                if ( doLog ) {\n+                    lastEntry = entryName;\n+                    lastSlash = slash;\n+                    System.out.println(\"Entry [ \" + entryName + \" ]\");\n+                }                \n+\n+                if ( entryName.equals(packedPath) ) {\n+                    if ( packedMapping != null ) {\n+                        fail(\"Archive [ \" + archivePath + \" ] has duplicates of entry [ \" + packedPath + \" ]\");\n+                        return;\n+                        // Never used; added to avoid a compiler null value warning:\n+                        // The compiler doesn't know that 'fail' never returns.                        \n+                    }\n+                    packedMapping = new HashMap<String, Integer>();\n+\n+                    try ( InputStream nestedStream = packageZip.getInputStream(entry);\n+                          ZipInputStream nestedZipStream = new ZipInputStream(nestedStream); ) {\n+\n+                        ZipEntry nestedEntry;\n+                        for ( int offset = 0;\n+                              (nestedEntry = nestedZipStream.getNextEntry()) != null;\n+                              offset++ ) { \n+                            packedMapping.put( nestedEntry.getName(), Integer.valueOf(offset) ); \n+                        }\n+                    }\n+\n+                } else {\n+                    // '<=' is deliberate: We don't want the entry for\n+                    // the directory of the unpacked archive.\n+                    if ( entryName.length() <= unpackedPrefixLen ) {\n+                        // ignore this entry\n+                    } else  if ( entryName.startsWith(unpackedPrefix) ) {\n+                        if ( unpackedMapping == null ) {\n+                            unpackedMapping = new HashMap<String, Integer>();\n+                        }\n+                        String suffix = entryName.substring(unpackedPrefix.length());\n+                        unpackedMapping.put(suffix, Integer.valueOf(unpackedOffset++));\n+                    } else {\n+                        // ignore this entry ...\n+                    }\n+                }\n+            }\n+        }\n+        \n+        if ( unpackedMapping == null ) {\n+            fail(\"Archive [ \" + archivePath + \" ] has no unpacked module entries [ \" + unpackedPrefix + \" ]\");\n+            return;\n+            // Never used; added to avoid a compiler null value warning:\n+            // The compiler doesn't know that 'fail' never returns.\n+        }\n+\n+        if ( packedMapping == null ) {\n+            fail(\"Archive [ \" + archivePath + \" ] has no packed module [ \" + packedPath + \" ]\");\n+            return;\n+            // Never used; added to avoid a compiler null value warning:\n+            // The compiler doesn't know that 'fail' never returns.\n+        }\n+\n+        int failures = 0;\n+\n+        for ( Map.Entry<String, Integer> packedEntry : packedMapping.entrySet() ) {\n+            String packedName = packedEntry.getKey();\n+            Integer packedOffset = packedEntry.getValue();\n+            \n+            Integer unpackedOffset = unpackedMapping.get(packedName);\n+            \n+            if ( unpackedOffset == null ) {\n+                System.out.println(\"Extra packed entry [ \" + packedName + \" ]\");\n+                failures++;\n+            } else {\n+                if ( packedOffset.intValue() != unpackedOffset.intValue() ) {\n+                    System.out.println(\"Packed entry [ \" + packedName + \" ] changed offset from [ \" + packedOffset.intValue() + \" ] to [ \" + unpackedOffset.intValue() + \" ]\");\n+                    failures++;\n+                }\n+            }\n+        }\n+        \n+        for ( String unpackedName : unpackedMapping.keySet() ) {\n+            if ( !packedMapping.containsKey(unpackedName) ) {\n+                System.out.println(\"Extra unpacked entry [ \" + unpackedName + \" ]\");\n+                failures++;\n+            } else {\n+                // The offsets were already verified\n+            }\n+        }\n+            \n+        if ( failures != 0 ) {\n+            fail(\"Archive [ \" + archivePath + \" ] packed archive [ \" + packedPath + \" ] has [ \" + failures + \" ] content errors\"); \n+        }\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "8760a9b4d3186745f0a1b3e636a8dce7ae17d81e",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseFilterTest.java",
    "status": "added",
    "additions": 161,
    "deletions": 0,
    "changes": 161,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseFilterTest.java",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseFilterTest.java",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseFilterTest.java?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -0,0 +1,161 @@\n+/*******************************************************************************\n+ * Copyright (c) 2021 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.kernel.boot.internal.commands;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServerFactory;\n+\n+/**\n+ * Test loose archive filtering.\n+ *\n+ * This is per issue #15724: \"Loose application in runtime is different from server package\".\n+ *\n+ * The problem is how the filtering used by packaging handles slashes.\n+ *\n+ * Previously, the filtering did not normalize loose entry paths to use consistent slashes.  That causes problems when packaging on windows: Filtering used forward slashes, but loose configuration provided paths with forward or reverse slashes depending on the platform.\n+ *\n+ * This test verifies that exclude and include processing is performed correctly\n+ * during packaging.  The test uses a loose configuration with:\n+ *\n+ * dir sourceOnDisk=\"${server.config.dir}\\looseConfig\\filterContent\"\n+ *     targetInArchive=\"filterTxt\"\n+ *     excludes=\"(**\\/*.xml)\"\n+ * \n+ * dir sourceOnDisk=\"${server.config.dir}\\looseConfig\\filterContent\"\n+ *     targetInArchive=\"filterXml\"\n+ *     excludes=\"(**\\/*.txt)\"\n+ * \n+ * dir sourceOnDisk=\"${server.config.dir}\\looseConfig\\filterContent\"\n+ *     targetInArchive=\"filterSample1Txt\"\n+ *     exclude=\"(**\\/*.xml)|(**\\/sample0.*)\"\n+ *\n+ * With the \"filterContent\" containing:\n+ *   sample0.txt\n+ *   sample0.xml\n+ *   sample1.txt\n+ *   sample1.xml\n+ */\n+@RunWith(FATRunner.class)\n+public class PackageLooseFilterTest extends AbstractLooseConfigTest {\n+\n+    private static final String MODULE_NAME_LOOSE = \"Filter.war.xml\";\n+    private static final String MODULE_NAME = \"Filter.war\";\n+\n+    private static final List<String> FILTER_REQUIRED_ENTRIES;\n+    private static final List<String> FILTER_FORBIDDEN_ENTRIES;\n+\n+    static {\n+        FILTER_REQUIRED_ENTRIES = new ArrayList<String>(2);\n+        FILTER_FORBIDDEN_ENTRIES = new ArrayList<String>(2);\n+\n+        FILTER_FORBIDDEN_ENTRIES.add(\"filterTxt/sample0.xml\");\n+        FILTER_REQUIRED_ENTRIES .add(\"filterTxt/sample0.txt\");\n+        FILTER_FORBIDDEN_ENTRIES.add(\"filterTxt/sample1.xml\");        \n+        FILTER_REQUIRED_ENTRIES .add(\"filterTxt/sample1.txt\");\n+        \n+        FILTER_REQUIRED_ENTRIES .add(\"filterXml/sample0.xml\");\n+        FILTER_FORBIDDEN_ENTRIES.add(\"filterXml/sample0.txt\");\n+        FILTER_REQUIRED_ENTRIES .add(\"filterXml/sample1.xml\");\n+        FILTER_FORBIDDEN_ENTRIES.add(\"filterXml/sample1.txt\");\n+\n+        FILTER_FORBIDDEN_ENTRIES.add(\"filterSample1Txt/sample0.xml\");\n+        FILTER_FORBIDDEN_ENTRIES.add(\"filterSample1Txt/sample1.xml\");\n+        FILTER_FORBIDDEN_ENTRIES.add(\"filterSample1Txt/sample0.txt\");\n+        FILTER_REQUIRED_ENTRIES .add(\"filterSample1Txt/sample1.txt\");\n+    }\n+    \n+    private String moduleLoosePath;\n+    private String moduleExpandedPath;\n+\n+    //\n+\n+    @Override\n+    public String getAppsTargetDir() {\n+        return APPS_DIR;\n+    }\n+\n+    //\n+\n+    @Rule\n+    public TestName testName = new TestName();\n+\n+    @Before\n+    public void before() throws Exception {\n+        System.out.println(testName.getMethodName());\n+\n+        setServer( LibertyServerFactory.getLibertyServer(SERVER_NAME) );\n+\n+        String appsPath = getServer().getServerRoot() + '/' + getAppsTargetDir() + '/'; \n+        moduleLoosePath = appsPath + MODULE_NAME_LOOSE;\n+        moduleExpandedPath = appsPath + \"expanded/\" + MODULE_NAME;\n+\n+        System.out.println(\"  Module loose config: \" + MODULE_NAME_LOOSE);\n+        System.out.println(\"  Module loose config path: \" + moduleLoosePath);\n+        System.out.println(\"  Module archive: \" + MODULE_NAME);\n+        System.out.println(\"  Module expanded path: \" + moduleExpandedPath);\n+\n+        getServer().deleteFileFromLibertyServerRoot(MODULE_NAME);\n+    }\n+\n+    @After\n+    public void clean() throws Exception {\n+        new File(moduleLoosePath).delete();\n+    }\n+\n+    //\n+\n+    @Test\n+    public void testIncludeUsr_Filter() throws Exception {\n+        String[] packageCmd = new String[] {\n+            \"--archive=\" + SERVER_NAME,\n+            \"--include=usr\",\n+            \"--server-root=\" + SERVER_ROOT };\n+        String archivePath = packageServer(MODULE_NAME_LOOSE, SERVER_NAME_ZIP, packageCmd);\n+        // Because server-root and include=usr are specified,\n+        // packaging shifts the server folder up one directory.  The\n+        // 'usr' directory is excised from the path.\n+        verifyContents(archivePath,\n+            SERVER_ROOT, !INCLUDE_USR, SERVER_NAME,\n+            MODULE_NAME);\n+    }\n+\n+    @Override\n+    protected void verifyContents(\n+        String archivePath,\n+        String serverRoot, boolean includeUsr, String serverName,\n+        String moduleName) throws IOException {\n+\n+        super.verifyContents(archivePath,\n+            serverRoot, includeUsr, serverName,\n+            moduleName, VERIFY_APP);\n+\n+        verifyExpandedContents(archivePath,\n+            serverRoot, includeUsr, serverName,\n+            moduleName);\n+        \n+        verifyFilteredContents(archivePath,\n+            serverRoot, includeUsr, serverName,\n+            moduleName,\n+            FILTER_REQUIRED_ENTRIES, FILTER_FORBIDDEN_ENTRIES);\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "ee120b8fe3d9b0ea5354b7c817894a56d440d2b5",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseRunnableTest.java",
    "status": "added",
    "additions": 126,
    "deletions": 0,
    "changes": 126,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseRunnableTest.java",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseRunnableTest.java",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/fat/src/com/ibm/ws/kernel/boot/internal/commands/PackageLooseRunnableTest.java?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -0,0 +1,126 @@\n+/*******************************************************************************\n+ * Copyright (c) 2014, 2021 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.kernel.boot.internal.commands;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import componenttest.annotation.SkipIfSysProp;\n+import componenttest.topology.impl.LibertyServerFactory;\n+import componenttest.topology.utils.FileUtils;\n+\n+@RunWith(Parameterized.class)\n+@SkipIfSysProp(\"os.name=z/OS\") // Jar not supported on Z/OS\n+public class PackageLooseRunnableTest extends AbstractLooseConfigTest {\n+    private static final String MODULE_NAME = \"DefaultArchive.war\";\n+    private static final String MODULE_NAME_LOOSE = \"DefaultArchive.war.xml\";\n+\n+    //\n+\n+    private static final List<Object[]> CONFIGS = new ArrayList<Object[]>(2);\n+    static {\n+        CONFIGS.add(new Object[] { APPS_DIR });\n+        CONFIGS.add(new Object[] { DROPINS_DIR });\n+    };\n+\n+    @Parameters\n+    public static Collection<Object[]> data() {\n+        return CONFIGS;\n+    }\n+\n+    public PackageLooseRunnableTest(String targetDir) {\n+        this.targetDir = targetDir;\n+    }\n+\n+    private final String targetDir;\n+\n+    @Override\n+    public String getAppsTargetDir() {\n+        return targetDir;\n+    }\n+    \n+    //\n+\n+    @Rule\n+    public TestName testName = new TestName();\n+\n+    @Before\n+    public void before() throws Exception {\n+        System.out.println(testName.getMethodName());\n+        System.out.println(\"Target: \" + getAppsTargetDir() );\n+\n+        setServer( LibertyServerFactory.getLibertyServer(SERVER_NAME) );\n+        getServer().deleteFileFromLibertyServerRoot(ARCHIVE_NAME_ZIP);\n+    }\n+\n+    @After\n+    public void clean() throws Exception {\n+        try {\n+            getServer().deleteFileFromLibertyServerRoot( getAppsTargetDir() + '/' + MODULE_NAME_LOOSE);\n+        } finally {\n+            FileUtils.recursiveDelete( new File(BUILD_DIR + '/' + WLP_EXTRACT) );\n+        }\n+    }\n+\n+    //\n+\n+    @Test\n+    public void testIncludeAll() throws Exception {\n+        String prepackedModuleName = MODULE_NAME_LOOSE;\n+        String packedModuleName = MODULE_NAME;\n+        String archiveName = ARCHIVE_NAME_ZIP;\n+        String[] packageCmd = {\n+            \"--archive=\" + archiveName,\n+            \"--include=all\",\n+            \"--server-root=\" + SERVER_ROOT                \n+        };\n+        String archivePath = packageServer(prepackedModuleName, archiveName, packageCmd);\n+\n+        verifyContents(archivePath,\n+            SERVER_ROOT, INCLUDE_USR, SERVER_NAME,\n+            packedModuleName, VERIFY_APP);\n+    }\n+\n+    @Test\n+    public void testRunnableDefaultRoot() throws Exception {\n+        String prepackedModuleName = MODULE_NAME_LOOSE;\n+        String packedModuleName = MODULE_NAME;\n+        String archivePath = packageRunnable(prepackedModuleName, ARCHIVE_NAME_1_JAR, SERVER_ROOT_DEFAULT);\n+        verifyContents(archivePath,\n+            SERVER_ROOT_DEFAULT, INCLUDE_USR, SERVER_NAME,\n+            packedModuleName, VERIFY_APP);        \n+        launchRunnable(archivePath);\n+    }\n+\n+    @Test\n+    public void testRunnable() throws Exception {\n+        String prepackedModuleName = MODULE_NAME_LOOSE;\n+        String packedModuleName = MODULE_NAME;\n+        String archivePath = packageRunnable(prepackedModuleName, ARCHIVE_NAME_2_JAR, SERVER_ROOT);\n+        // Note the change from 'SERVER_ROOT' to 'SERVER_ROOT_DEFAULT';\n+        // The server root parameter is ignored when packaging a runnable server.\n+        verifyContents(archivePath,\n+            SERVER_ROOT_DEFAULT, INCLUDE_USR, SERVER_NAME,\n+            packedModuleName, VERIFY_APP);\n+        launchRunnable(archivePath);\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "ecf7d16aceb7e760664287da23ffe83f94b93087",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/publish/resources/configs/Filter.war.xml",
    "status": "added",
    "additions": 35,
    "deletions": 0,
    "changes": 35,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/resources/configs/Filter.war.xml",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/resources/configs/Filter.war.xml",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/publish/resources/configs/Filter.war.xml?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -0,0 +1,35 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+    Copyright (c) 2017, 2021 IBM Corporation and others.\n+    All rights reserved. This program and the accompanying materials\n+    are made available under the terms of the Eclipse Public License v1.0\n+    which accompanies this distribution, and is available at\n+    http://www.eclipse.org/legal/epl-v10.html\n+   \n+    Contributors:\n+        IBM Corporation - initial API and implementation\n+ -->\n+\n+<archive>\n+  <archive targetInArchive=\"Utils.jar\">\n+    <dir sourceOnDisk=\"${server.config.dir}\\looseConfig\\utils\\classes\"\n+         targetInArchive=\"/\"/>\n+  </archive>\n+\n+  <dir sourceOnDisk=\"${server.config.dir}\\looseConfig\\testWeb0\\WebContent\"\n+       targetInArchive=\"/\"/>\n+\n+  <dir sourceOnDisk=\"${server.config.dir}\\looseConfig\\filterContent\"\n+       targetInArchive=\"filterTxt\"\n+       excludes=\"(**/*.xml)\"/>\n+\n+  <dir sourceOnDisk=\"${server.config.dir}\\looseConfig\\filterContent\"\n+       targetInArchive=\"filterXml\"\n+       excludes=\"(**/*.txt)\"/>\n+\n+  <dir sourceOnDisk=\"${server.config.dir}\\looseConfig\\filterContent\"\n+       targetInArchive=\"filterSample1Txt\"\n+       excludes=\"(**/*.xml)|(**/sample0.*)\"/>\n+\n+</archive>"
  },
  {
    "sha": "fb6fcc1f1744f5e01d3ec4529109ccdc2f020ed7",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample0.txt",
    "status": "added",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample0.txt",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample0.txt",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample0.txt?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -0,0 +1 @@\n+sample0"
  },
  {
    "sha": "c6e186982bbbbd40949d0eb6a9aeb905af4e39b9",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample0.xml",
    "status": "added",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample0.xml",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample0.xml",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample0.xml?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -0,0 +1 @@\n+<sample0/>"
  },
  {
    "sha": "724ae58948df9ac79d77719f3ec1c9f622feadb1",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample1.txt",
    "status": "added",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample1.txt",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample1.txt",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample1.txt?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -0,0 +1 @@\n+sample1"
  },
  {
    "sha": "f657ccbe3b906e1c6657af4a959c95006632e8d5",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample1.xml",
    "status": "added",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample1.xml",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample1.xml",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/publish/resources/looseConfig/filterContent/sample1.xml?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -0,0 +1 @@\n+<sample1/>"
  },
  {
    "sha": "fb6fcc1f1744f5e01d3ec4529109ccdc2f020ed7",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample0.txt",
    "status": "added",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample0.txt",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample0.txt",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample0.txt?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -0,0 +1 @@\n+sample0"
  },
  {
    "sha": "c6e186982bbbbd40949d0eb6a9aeb905af4e39b9",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample0.xml",
    "status": "added",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample0.xml",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample0.xml",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample0.xml?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -0,0 +1 @@\n+<sample0/>"
  },
  {
    "sha": "724ae58948df9ac79d77719f3ec1c9f622feadb1",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample1.txt",
    "status": "added",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample1.txt",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample1.txt",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample1.txt?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -0,0 +1 @@\n+sample1"
  },
  {
    "sha": "f657ccbe3b906e1c6657af4a959c95006632e8d5",
    "filename": "dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample1.xml",
    "status": "added",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/OpenLiberty/open-liberty/blob/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample1.xml",
    "raw_url": "https://github.com/OpenLiberty/open-liberty/raw/eae4e28a2edafb59fc3e667c33d2cb1c3c6effea/dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample1.xml",
    "contents_url": "https://api.github.com/repos/OpenLiberty/open-liberty/contents/dev/com.ibm.ws.kernel.boot_fat/publish/servers/com.ibm.ws.kernel.boot.loose.config.fat/looseConfig/filterContent/sample1.xml?ref=eae4e28a2edafb59fc3e667c33d2cb1c3c6effea",
    "patch": "@@ -0,0 +1 @@\n+<sample1/>"
  }
]
