[
  {
    "sha": "af6987a78cb99698c928fe89d3bd5a6ca845c195",
    "filename": "build.gradle",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/build.gradle",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/build.gradle",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/build.gradle?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -20,6 +20,12 @@ subprojects { Project subproject ->\n             }\n         }\n         maven { url \"https://oss.sonatype.org/content/groups/staging\" }\n+        mavenLocal {\n+            metadataSources {\n+                mavenPom()\n+                artifact()\n+            }\n+        }\n     }\n \n     if (subproject.name.endsWith('-bom')) {"
  },
  {
    "sha": "627e0327849c98da60c1ed4b158e8dee1a10a6fc",
    "filename": "coherence-data/build.gradle",
    "status": "modified",
    "additions": 0,
    "deletions": 1,
    "changes": 1,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/build.gradle",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/build.gradle",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence-data/build.gradle?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -35,6 +35,5 @@ tasks.withType(Test) {\n \n test {\n     systemProperty(\"java.net.preferIPv4Stack\", \"true\")\n-    systemProperty(\"coherence.data.query.log\", \"true\")\n     forkEvery 1\n }"
  },
  {
    "sha": "26c1b22ecb52a94c9d54dfdb499c94f120187ddf",
    "filename": "coherence-data/src/main/java/io/micronaut/coherence/data/AbstractCoherenceAsyncRepository.java",
    "status": "added",
    "additions": 104,
    "deletions": 0,
    "changes": 104,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/main/java/io/micronaut/coherence/data/AbstractCoherenceAsyncRepository.java",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/main/java/io/micronaut/coherence/data/AbstractCoherenceAsyncRepository.java",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence-data/src/main/java/io/micronaut/coherence/data/AbstractCoherenceAsyncRepository.java?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2017-2021 original authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.micronaut.coherence.data;\n+\n+import com.oracle.coherence.repository.AbstractAsyncRepository;\n+import com.tangosol.net.AsyncNamedMap;\n+import io.micronaut.coherence.data.interceptors.GetAsyncMapInterceptor;\n+import io.micronaut.coherence.data.interceptors.GetEntityTypeInterceptor;\n+import io.micronaut.coherence.data.interceptors.GetIdInterceptor;\n+import io.micronaut.data.intercept.annotation.DataMethod;\n+import io.micronaut.data.repository.GenericRepository;\n+\n+/**\n+ * While it's possible to annotate a simple {@link io.micronaut.data.repository.async.AsyncCrudRepository} with\n+ * {@link io.micronaut.coherence.data.annotation.CoherenceRepository} and use Coherence as a backend cache.  However,\n+ * to take full advantage of the feature set Coherence has to offer, it is recommended extending this class.  This\n+ * will give you all of the features as documented in {@link AbstractAsyncRepository}.\n+ *\n+ * Any class extending this class <em>must</em> be declared abstract and <em>cannot</em> implement any of\n+ * the Micronaut repository types due to overlap in methods between those interface methods and those provided\n+ * by {@link AbstractAsyncRepository}.\n+ *\n+ * @param <ID> the ID type\n+ * @param <T> the entity type\n+ */\n+public abstract class AbstractCoherenceAsyncRepository<T, ID>\n+        extends AbstractAsyncRepository<ID, T>\n+        implements GenericRepository<T, ID> {\n+\n+    // ----- AbstractAsyncRepository ----------------------------------------\n+\n+    @Override\n+    protected AsyncNamedMap<ID, T> getMap() {\n+        return getMapInternal();\n+    }\n+\n+    @Override\n+    protected ID getId(final T t) {\n+        return getIdInternal(t);\n+    }\n+\n+    @Override\n+    protected Class<? extends T> getEntityType() {\n+        return getEntityTypeInternal(null);\n+    }\n+\n+    // ----- Helpers --------------------------------------------------------\n+\n+    /**\n+     * This is in place to prevent Micronaut from scanning further up the inheritance tree and trying\n+     * to map {@link AbstractAsyncRepository#getId(Object)} and failing.\n+     *\n+     * Called only by {@link #getId(Object)}.\n+     *\n+     * @param entity the entity\n+     *\n+     * @return the ID of the provided entity\n+     */\n+    @DataMethod(interceptor = GetIdInterceptor.class)\n+    protected abstract ID getIdInternal(T entity);\n+\n+    /**\n+     * This is in place to prevent Micronaut from scanning further up the inheritance tree and trying\n+     * to map {@link AbstractAsyncRepository#getMap()} and failing.\n+     *\n+     * Called only by {@link #getId(Object)}.\n+     *\n+     * @return the {@link AsyncNamedMap} for this {@code repository}\n+     */\n+    @DataMethod(interceptor = GetAsyncMapInterceptor.class)\n+    protected abstract AsyncNamedMap<ID, T> getMapInternal();\n+\n+    /**\n+     * This is in place to prevent Micronaut from scanning further up the inheritance tree and trying\n+     * to map {@link AbstractAsyncRepository#getEntityType()} and failing.\n+     *\n+     * Note: the value passed to this may always be {@code null}.  We don't care about the value\n+     * as due to how the Coherence API is defined, there can never be a value.  However, we can rely\n+     * on the compile type information generated by Micronaut for this intercepted method and use that metadata\n+     * to return the entity type.\n+     *\n+     * Called only by {@link #getEntityType()}.\n+     *\n+     * @param entity the entity\n+     *\n+     * @return the {@link Class} representing the entity type handled by this {@code repository}.\n+     */\n+    @SuppressWarnings(\"SameParameterValue\")\n+    @DataMethod(interceptor = GetEntityTypeInterceptor.class)\n+    protected abstract Class<? extends T> getEntityTypeInternal(T entity);\n+}"
  },
  {
    "sha": "dba66d96ef3661bb623e0e197943657fc982e1c7",
    "filename": "coherence-data/src/main/java/io/micronaut/coherence/data/DefaultCoherenceRepositoryOperations.java",
    "status": "modified",
    "additions": 216,
    "deletions": 7,
    "changes": 223,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/main/java/io/micronaut/coherence/data/DefaultCoherenceRepositoryOperations.java",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/main/java/io/micronaut/coherence/data/DefaultCoherenceRepositoryOperations.java",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence-data/src/main/java/io/micronaut/coherence/data/DefaultCoherenceRepositoryOperations.java?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -18,6 +18,8 @@\n import com.oracle.coherence.common.base.Logger;\n import com.tangosol.coherence.dslquery.ExecutionContext;\n import com.tangosol.coherence.dslquery.Statement;\n+import com.tangosol.coherence.dslquery.StatementResult;\n+import com.tangosol.net.AsyncNamedMap;\n import com.tangosol.net.Coherence;\n import com.tangosol.net.NamedMap;\n import com.tangosol.net.Session;\n@@ -31,15 +33,16 @@\n import io.micronaut.core.beans.BeanProperty;\n import io.micronaut.core.util.ArgumentUtils;\n import io.micronaut.data.model.Page;\n+import io.micronaut.data.model.runtime.DeleteBatchOperation;\n+import io.micronaut.data.model.runtime.DeleteOperation;\n import io.micronaut.data.model.runtime.InsertBatchOperation;\n import io.micronaut.data.model.runtime.InsertOperation;\n import io.micronaut.data.model.runtime.PagedQuery;\n import io.micronaut.data.model.runtime.PreparedQuery;\n import io.micronaut.data.model.runtime.RuntimePersistentEntity;\n import io.micronaut.data.model.runtime.RuntimePersistentProperty;\n import io.micronaut.data.model.runtime.UpdateOperation;\n-import io.micronaut.data.model.runtime.DeleteBatchOperation;\n-import io.micronaut.data.model.runtime.DeleteOperation;\n+import io.micronaut.data.operations.async.AsyncRepositoryOperations;\n \n import java.io.IOException;\n import java.io.PrintWriter;\n@@ -51,8 +54,10 @@\n import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.Executor;\n import java.util.stream.Collectors;\n import java.util.stream.IntStream;\n import java.util.stream.Stream;\n@@ -112,6 +117,11 @@\n      */\n     private ExecutionContext cohQLContext;\n \n+    /**\n+     * {@link AsyncRepositoryOperations}.\n+     */\n+    private CoherenceAsyncRepositoryOperations asyncOperations;\n+\n     // ----- constructors ---------------------------------------------------\n \n     /**\n@@ -161,6 +171,14 @@ protected void setSession(final String sessionName) {\n         this.sessionName = sessionName;\n     }\n \n+    // ----- AsyncCapableRepository interface -------------------------------\n+\n+    @NonNull\n+    @Override\n+    public AsyncRepositoryOperations async() {\n+        return ensureAsyncOperations();\n+    }\n+\n     // ----- RepositoryOperations interface ---------------------------------\n \n     @Nullable\n@@ -300,7 +318,7 @@ protected void setSession(final String sessionName) {\n      *\n      * @return a CohQL statement ready for execution\n      */\n-    protected Statement createStatement(ExecutionContext context, PreparedQuery preparedQuery) {\n+    private Statement createStatement(ExecutionContext context, PreparedQuery preparedQuery) {\n         Map bindings = createBindingMap(preparedQuery);\n \n         String query = replaceTarget(preparedQuery.getQuery(), preparedQuery.getRootEntity());\n@@ -319,7 +337,7 @@ protected Statement createStatement(ExecutionContext context, PreparedQuery prep\n      *\n      * @return the result of query execution\n      */\n-    protected Object execute(PreparedQuery preparedQuery) {\n+    private Object execute(PreparedQuery preparedQuery) {\n         ExecutionContext ctx = ensureExecutionContext();\n         Statement statement = createStatement(ctx, preparedQuery);\n         return statement.execute(ctx).getResult();\n@@ -333,7 +351,7 @@ protected Object execute(PreparedQuery preparedQuery) {\n      *\n      * @return the {@link RuntimePersistentEntity} for the given type\n      */\n-    protected RuntimePersistentEntity ensureMeta(Class entityType) {\n+    private RuntimePersistentEntity ensureMeta(Class entityType) {\n         return entities.computeIfAbsent(entityType, RuntimePersistentEntity::new);\n     }\n \n@@ -342,7 +360,7 @@ protected RuntimePersistentEntity ensureMeta(Class entityType) {\n      *\n      * @return the {@link ExecutionContext}\n      */\n-    protected ExecutionContext ensureExecutionContext() {\n+    private ExecutionContext ensureExecutionContext() {\n         ExecutionContext ctx = cohQLContext;\n         if (ctx == null) {\n             ctx = QueryHelper.createExecutionContext(ensureSession());\n@@ -357,7 +375,7 @@ protected ExecutionContext ensureExecutionContext() {\n      *\n      * @return return the {@link NamedMap} that should be used by this {@code repository}\n      */\n-    protected NamedMap ensureNamedMap() {\n+    private NamedMap ensureNamedMap() {\n         if (namedMap == null) {\n             namedMap = ensureSession().getMap(mapName);\n         }\n@@ -376,6 +394,18 @@ protected Session ensureSession() {\n         return session;\n     }\n \n+    /**\n+     * Return the {@link AsyncRepositoryOperations}.\n+     *\n+     * @return the {@link AsyncRepositoryOperations}\n+     */\n+    protected AsyncRepositoryOperations ensureAsyncOperations() {\n+        if (asyncOperations == null) {\n+            asyncOperations = new DefaultCoherenceAsyncRepositoryOperations();\n+        }\n+        return asyncOperations;\n+    }\n+\n     /**\n      * Replaces the generated target of the statement with the name {@link NamedMap} associated\n      * with this {@link io.micronaut.data.operations.RepositoryOperations} instance.\n@@ -432,4 +462,183 @@ protected void logQuery(ExecutionContext ctx, Statement statement, String query,\n             Logger.info(trace.execute(ctx).getResult().toString());\n         }\n     }\n+\n+    // ----- inner class: DefaultCoherenceAsyncRepositoryOperations ---------\n+\n+    private final class DefaultCoherenceAsyncRepositoryOperations\n+        implements CoherenceAsyncRepositoryOperations {\n+\n+        private AsyncNamedMap asyncNamedMap;\n+\n+        // ----- constructors -----------------------------------------------\n+\n+        private DefaultCoherenceAsyncRepositoryOperations() {\n+        }\n+\n+        // ----- CoherenceAsyncRepositoryOperations -------------------------\n+\n+        @Override\n+        public <ID, T> AsyncNamedMap<ID, T> getAsyncNamedMap() {\n+            return ensureAsyncMap();\n+        }\n+\n+        @Override\n+        public <ID, T> ID getId(final T entity) {\n+            return DefaultCoherenceRepositoryOperations.this.getId(entity);\n+        }\n+\n+        // ----- AsyncRepositoryOperations ----------------------------------\n+\n+        @NonNull\n+        @Override\n+        public Executor getExecutor() {\n+            return null;\n+        }\n+\n+        @NonNull\n+        @Override\n+        public <T> CompletionStage<T> findOne(@NonNull final Class<T> type, @NonNull final Serializable id) {\n+            return (CompletionStage<T>) getAsyncNamedMap().get(id);\n+        }\n+\n+        @Override\n+        public <T> CompletionStage<Boolean> exists(@NonNull final PreparedQuery<T, Boolean> preparedQuery) {\n+            return executeAsync(preparedQuery)\n+                    .thenApply(o -> !((Map) o).isEmpty());\n+        }\n+\n+        @NonNull\n+        @Override\n+        public <T, R> CompletionStage<R> findOne(@NonNull final PreparedQuery<T, R> preparedQuery) {\n+            CompletionStage stage = executeAsync(preparedQuery);\n+            return stage.thenApply(o -> {\n+                if (o instanceof Map) {\n+                    Map m = (Map) o;\n+                    if (m.isEmpty()) {\n+                        return null;\n+                    }\n+                    return m.values().stream().findFirst().get();\n+                } else if (o instanceof Number) {\n+                    return o;\n+                } else {\n+                    throw new IllegalStateException(\"Unhandled type: \" + o.getClass().getName());\n+                }\n+            });\n+        }\n+\n+        @NonNull\n+        @Override\n+        public <T> CompletionStage<T> findOptional(@NonNull final Class<T> type, @NonNull final Serializable id) {\n+            return null;\n+        }\n+\n+        @NonNull\n+        @Override\n+        public <T, R> CompletionStage<R> findOptional(@NonNull final PreparedQuery<T, R> preparedQuery) {\n+            return null;\n+        }\n+\n+        @NonNull\n+        @Override\n+        public <T> CompletionStage<Iterable<T>> findAll(final PagedQuery<T> pagedQuery) {\n+            throw new UnsupportedOperationException(\"paging queries are not supported\");\n+        }\n+\n+        @NonNull\n+        @Override\n+        public <T> CompletionStage<Long> count(final PagedQuery<T> pagedQuery) {\n+            throw new UnsupportedOperationException(\"paging queries are not supported\");\n+        }\n+\n+        @NonNull\n+        @Override\n+        public <T, R> CompletionStage<Iterable<R>> findAll(@NonNull final PreparedQuery<T, R> preparedQuery) {\n+            CompletionStage stage = executeAsync(preparedQuery);\n+            return stage.thenApply(o -> {\n+                if (o instanceof Map) {\n+                    Map m = (Map) o;\n+                    return m.values();\n+                } else if (o instanceof Number) {\n+                    return Collections.singletonList(((Number) o).longValue());\n+                } else if (o instanceof Iterable) {\n+                    return o;\n+                } else {\n+                    throw new IllegalStateException(\"Unhandled type: \" + o.getClass().getName());\n+                }\n+            });\n+        }\n+\n+        @NonNull\n+        @Override\n+        public <T> CompletionStage<T> persist(@NonNull final InsertOperation<T> operation) {\n+            T entity = operation.getEntity();\n+            return getAsyncNamedMap().put(getId(entity), entity).thenApply(unused -> entity);\n+        }\n+\n+        @NonNull\n+        @Override\n+        public <T> CompletionStage<T> update(@NonNull final UpdateOperation<T> operation) {\n+            T entity = operation.getEntity();\n+            return getAsyncNamedMap().put(getId(entity), entity).thenApply(unused -> entity);\n+        }\n+\n+        @NonNull\n+        @Override\n+        public <T> CompletionStage<Number> delete(@NonNull final DeleteOperation<T> operation) {\n+            T entity = operation.getEntity();\n+            return getAsyncNamedMap().remove(getId(entity), entity).thenApply(aBoolean -> aBoolean ? 1 : 0);\n+        }\n+\n+        @NonNull\n+        @Override\n+        public <T> CompletionStage<Iterable<T>> persistAll(@NonNull final InsertBatchOperation<T> operation) {\n+            Map<?, T> entitiesToSave = new HashMap<>();\n+            operation.forEach(t -> entitiesToSave.put(getId(t), t));\n+            return getAsyncNamedMap().putAll(entitiesToSave).thenApply(unused -> entitiesToSave.values());\n+        }\n+\n+        @NonNull\n+        @Override\n+        public CompletionStage<Number> executeUpdate(@NonNull final PreparedQuery<?, Number> preparedQuery) {\n+            CompletionStage stage = executeAsync(preparedQuery);\n+            return stage.thenApply(o -> {\n+                if (o instanceof Map) {\n+                    return ((Map) o).size();\n+                } else if (o instanceof Set) {\n+                    return ((Set) o).size();\n+                } else {\n+                    throw new IllegalStateException(\"unhandled return type\");\n+                }\n+            });\n+        }\n+\n+        @NonNull\n+        @Override\n+        public <T> CompletionStage<Number> deleteAll(@NonNull final DeleteBatchOperation<T> operation) {\n+            Map<?, T> entitiesToDelete = new LinkedHashMap<>();\n+            operation.forEach(t -> entitiesToDelete.put(getId(t), t));\n+            return getAsyncNamedMap().invokeAll(entitiesToDelete.keySet(), Processors.remove()).thenApply(Map::size);\n+        }\n+\n+        @NonNull\n+        @Override\n+        public <R> CompletionStage<Page<R>> findPage(@NonNull final PagedQuery<R> pagedQuery) {\n+            throw new UnsupportedOperationException(\"paging queries are not supported\");\n+        }\n+\n+        // ----- helper methods ---------------------------------------------\n+\n+        private AsyncNamedMap ensureAsyncMap() {\n+            if (asyncNamedMap == null) {\n+                asyncNamedMap = ensureNamedMap().async();\n+            }\n+            return asyncNamedMap;\n+        }\n+\n+        private CompletionStage<?> executeAsync(PreparedQuery preparedQuery) {\n+            ExecutionContext ctx = ensureExecutionContext();\n+            Statement statement = createStatement(ctx, preparedQuery);\n+            return statement.executeAsync(ctx).thenApply(StatementResult::getResult);\n+        }\n+    }\n }"
  },
  {
    "sha": "3fa16fb9884f21c0bf505dd4d4eea39c87582d13",
    "filename": "coherence-data/src/main/java/io/micronaut/coherence/data/interceptors/GetAsyncMapInterceptor.java",
    "status": "added",
    "additions": 60,
    "deletions": 0,
    "changes": 60,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/main/java/io/micronaut/coherence/data/interceptors/GetAsyncMapInterceptor.java",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/main/java/io/micronaut/coherence/data/interceptors/GetAsyncMapInterceptor.java",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence-data/src/main/java/io/micronaut/coherence/data/interceptors/GetAsyncMapInterceptor.java?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2017-2021 original authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.micronaut.coherence.data.interceptors;\n+\n+import com.tangosol.net.AsyncNamedMap;\n+import edu.umd.cs.findbugs.annotations.NonNull;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.coherence.data.CoherenceAsyncRepositoryOperations;\n+import io.micronaut.coherence.data.CoherenceRepositoryOperations;\n+import io.micronaut.data.intercept.DataInterceptor;\n+import io.micronaut.data.intercept.RepositoryMethodKey;\n+import io.micronaut.data.operations.RepositoryOperations;\n+import io.micronaut.data.runtime.intercept.AbstractQueryInterceptor;\n+\n+/**\n+ * A {@link DataInterceptor} allowing {@link io.micronaut.coherence.data.AbstractCoherenceRepository} instances\n+ * to obtain the {@link AsyncNamedMap} associated with the\n+ * {@link io.micronaut.coherence.data.AbstractCoherenceAsyncRepository}.\n+ *\n+ * @param <D> the declaring type\n+ * @param <T> the entity type\n+ * @param <ID> the ID type of the entity\n+ */\n+public final class GetAsyncMapInterceptor<ID, T, D>\n+        extends AbstractQueryInterceptor<D, AsyncNamedMap<ID, T>>\n+        implements DataInterceptor<D, AsyncNamedMap<ID, T>> {\n+\n+    // ----- constructors -----------------------------------------------\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param operations the {@link RepositoryOperations}\n+     */\n+    protected GetAsyncMapInterceptor(@NonNull RepositoryOperations operations) {\n+        super(operations);\n+    }\n+\n+    // ----- DataInterceptor --------------------------------------------\n+\n+    @Override\n+    public AsyncNamedMap<ID, T> intercept(final RepositoryMethodKey methodKey,\n+                                          final MethodInvocationContext<D, AsyncNamedMap<ID, T>> context) {\n+        return ((CoherenceAsyncRepositoryOperations)\n+                   ((CoherenceRepositoryOperations) operations).async()).getAsyncNamedMap();\n+    }\n+}"
  },
  {
    "sha": "e81d9696ad54f8b484fefe410d6f2a7093cf3ca2",
    "filename": "coherence-data/src/test/java/io/micronaut/coherence/data/AbstractDataTest.java",
    "status": "renamed",
    "additions": 8,
    "deletions": 11,
    "changes": 19,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/AbstractDataTest.java",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/AbstractDataTest.java",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence-data/src/test/java/io/micronaut/coherence/data/AbstractDataTest.java?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -21,7 +21,6 @@\n import io.micronaut.coherence.data.model.Book;\n import org.junit.jupiter.api.BeforeEach;\n \n-import javax.inject.Inject;\n import java.util.Calendar;\n import java.util.GregorianCalendar;\n import java.util.LinkedHashSet;\n@@ -31,7 +30,7 @@\n /**\n  * Base test class using {@link Book}s for functional validation.\n  */\n-public class AbstractDataTests {\n+public abstract class AbstractDataTest {\n     /**\n      * Author: Frank Herbert\n      */\n@@ -75,29 +74,27 @@\n     protected static final Book HOBBIT = new Book(\"The Hobbit\", 355, JOHN_TOLKIEN, new GregorianCalendar(1937,\n             Calendar.SEPTEMBER, 21, 0, 0));\n \n-    /**\n-     * The {@link NamedMap} the {@code Repository} should be using.\n-     */\n-    @Inject\n-    protected NamedMap<UUID, Book> book;\n-\n     /**\n      * A {@link Set} of {@link Book books} for validating test results.\n      */\n-    protected Set<Book> books = new LinkedHashSet<>();\n+    protected Set<Book> books;\n+\n+    public abstract NamedMap<UUID, Book> getNamedMap();\n \n     /**\n      * Initializes/resets the {@link NamedMap} before each test.\n      */\n     @BeforeEach\n     public void _before() {\n-        book.clear(); // cache\n+        NamedMap<UUID, Book> namedMap = getNamedMap();\n+        namedMap.clear(); // cache\n \n+        books = new LinkedHashSet<>(4);\n         books.add(DUNE);\n         books.add(DUNE_MESSIAH);\n         books.add(NAME_OF_THE_WIND);\n         books.add(HOBBIT);\n \n-        book.putAll(books.stream().collect(Collectors.toMap(Book::getUuid, b -> b)));\n+        namedMap.putAll(books.stream().collect(Collectors.toMap(Book::getUuid, b -> b)));\n     }\n }",
    "previous_filename": "coherence-data/src/test/java/io/micronaut/coherence/data/AbstractDataTests.java"
  },
  {
    "sha": "66bf56058d8287b2181e55fbca807a21253a0665",
    "filename": "coherence-data/src/test/java/io/micronaut/coherence/data/AsyncRepositoryTest.java",
    "status": "added",
    "additions": 99,
    "deletions": 0,
    "changes": 99,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/AsyncRepositoryTest.java",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/AsyncRepositoryTest.java",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence-data/src/test/java/io/micronaut/coherence/data/AsyncRepositoryTest.java?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2017-2021 original authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.micronaut.coherence.data;\n+\n+import com.tangosol.net.AsyncNamedMap;\n+import com.tangosol.net.NamedMap;\n+import com.tangosol.util.UUID;\n+import io.micronaut.coherence.data.model.Book;\n+import io.micronaut.coherence.data.repositories.CoherenceAsyncBookRepository;\n+import io.micronaut.test.extensions.junit5.annotation.MicronautTest;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+\n+import javax.inject.Inject;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.core.Is.is;\n+import static org.hamcrest.core.IsInstanceOf.instanceOf;\n+import static org.hamcrest.core.IsNull.notNullValue;\n+\n+/**\n+ * Validation of {@link AbstractCoherenceAsyncRepository}.\n+ */\n+@MicronautTest(propertySources = {\"classpath:sessions.yaml\"})\n+@TestInstance(TestInstance.Lifecycle.PER_METHOD)\n+public class AsyncRepositoryTest extends AbstractDataTest {\n+\n+    /**\n+     * The concrete {@link AbstractCoherenceAsyncRepository} implementation under test.\n+     */\n+    @Inject\n+    protected CoherenceAsyncBookRepository repo;\n+\n+    // ----- AbstractDataTest -----------------------------------------------\n+\n+    @Override\n+    public NamedMap<UUID, Book> getNamedMap() {\n+        return repo.getMap().getNamedMap();\n+    }\n+\n+    // ----- test methods ---------------------------------------------------\n+\n+    /**\n+     * Ensure the {@link io.micronaut.coherence.data.interceptors.GetMapInterceptor} interceptor fires when\n+     * {@link AbstractCoherenceAsyncRepository#getMap()} is invoked.\n+     */\n+    @Test\n+    public void shouldReturnNamedMap() {\n+        assertThat(repo, notNullValue());\n+        assertThat(repo.getMap(), instanceOf(AsyncNamedMap.class));\n+        assertThat(repo.count().join(), is(4L));\n+    }\n+\n+    /**\n+     * Ensure the {@link io.micronaut.coherence.data.interceptors.GetIdInterceptor} interceptor fires when\n+     * {@link AbstractCoherenceAsyncRepository#getId(Object)} is invoked.\n+     */\n+    @Test\n+    public void shouldReturnId() {\n+        assertThat(repo, notNullValue());\n+        assertThat(repo.getId(DUNE), is(DUNE.getUuid()));\n+    }\n+\n+    /**\n+     * Ensure the {@link io.micronaut.coherence.data.interceptors.GetEntityTypeInterceptor} interceptor fires when\n+     * {@link AbstractCoherenceAsyncRepository#getEntityType()} is invoked.\n+     */\n+    @Test\n+    public void shouldReturnEntityType() {\n+        assertThat(repo, notNullValue());\n+        assertThat(repo.getEntityType(), Matchers.typeCompatibleWith(Book.class));\n+    }\n+\n+    /**\n+     * Ensure generated queries continue to work when extending {@code AbstractCoherenceAsyncRepository}.\n+     */\n+    @Test\n+    public void shouldAllowGeneratedQueries() {\n+        repo.findByTitleStartingWith(\"Du\")\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getTitle().startsWith(\"Du\")).toArray())))\n+                .join();\n+    }\n+}"
  },
  {
    "sha": "0754ea1a4a3aaed53d82961a84c70d04a71d8035",
    "filename": "coherence-data/src/test/java/io/micronaut/coherence/data/GeneratedAsyncStatementsTest.java",
    "status": "added",
    "additions": 424,
    "deletions": 0,
    "changes": 424,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/GeneratedAsyncStatementsTest.java",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/GeneratedAsyncStatementsTest.java",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence-data/src/test/java/io/micronaut/coherence/data/GeneratedAsyncStatementsTest.java?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -0,0 +1,424 @@\n+/*\n+ * Copyright 2017-2021 original authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.micronaut.coherence.data;\n+\n+import com.tangosol.net.AsyncNamedMap;\n+import com.tangosol.net.NamedMap;\n+import com.tangosol.util.UUID;\n+import io.micronaut.coherence.data.model.Author;\n+import io.micronaut.coherence.data.model.Book;\n+import io.micronaut.coherence.data.repositories.AsyncBookRepository;\n+import io.micronaut.test.extensions.junit5.annotation.MicronautTest;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Comparator;\n+import java.util.GregorianCalendar;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.core.Is.is;\n+\n+@MicronautTest(propertySources = {\"classpath:sessions.yaml\"})\n+@TestInstance(TestInstance.Lifecycle.PER_METHOD)\n+public class GeneratedAsyncStatementsTest extends AbstractDataTest {\n+\n+    /**\n+     * The {@link NamedMap} the {@code Repository} should be using.\n+     */\n+    @Inject\n+    protected AsyncNamedMap<UUID, Book> book;\n+\n+    /**\n+     * A {@code repository} for validating generated queries.\n+     */\n+    @Inject\n+    protected AsyncBookRepository repo;\n+\n+    // ----- AbstractDataTest -----------------------------------------------\n+\n+    @Override\n+    public NamedMap<UUID, Book> getNamedMap() {\n+        return book.getNamedMap();\n+    }\n+\n+    // ----- test methods ---------------------------------------------------\n+\n+    /**\n+     * Validate it is possible to query books by id.\n+     */\n+    @Test\n+    public void shouldGetBooksById() {\n+        for (Book b : books) {\n+            repo.findById(b.getUuid())\n+                    .thenAccept(book1 -> assertThat(book1, is(b))).join();\n+        }\n+    }\n+\n+    /**\n+     * Validate it is possible to obtain all books associated with a specific {@link Author author}.\n+     */\n+    @Test\n+    public void shouldGetBooksByAuthor() {\n+        repo.findByAuthor(FRANK_HERBERT)\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getAuthor().equals(FRANK_HERBERT)).toArray()))).join();\n+    }\n+\n+    /**\n+     * Validate it is possible to find books with pages greater or equal to some value.\n+     */\n+    @Test\n+    public void shouldGetBooksWithPagesGreaterOrEqualTo() {\n+        repo.findByPagesGreaterThanEquals(468)\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getPages() >= 468).toArray())))\n+                .join();\n+\n+    }\n+\n+    /**\n+     * Validate it is possible to find books with pages less or equal to some value.\n+     */\n+    @Test\n+    public void shouldGetBooksWithPagesLessOrEqualTo() {\n+        repo.findByPagesLessThanEquals(677)\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getPages() <= 677).toArray())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate it is possible to find books using {@code like}.\n+     */\n+    @Test\n+    public void shouldGetBooksWithTitleLike() {\n+        repo.findByTitleLike(\"%Dune%\")\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getTitle().contains(\"Dune\")).toArray())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate returns {@code true} for {@link Book books} were authored by a known {@link Author author}.\n+     */\n+    @Test\n+    public void shouldReturnTrueForValidAuthor() {\n+        repo.existsByAuthor(FRANK_HERBERT).thenAccept(aBoolean -> assertThat(aBoolean, is(true))).join();\n+    }\n+\n+    /**\n+     * Validate returns {@code false} for an {@link Author author}.\n+     */\n+    @Test\n+    public void shouldReturnFalseForInvalidAuthor() {\n+        repo.existsByAuthor(new Author(\"Stephen\", \"King\"))\n+                .thenAccept(aBoolean -> assertThat(aBoolean, is(false)))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected result is returned when querying for {@link Book books} {@code before} a specific year.\n+     */\n+    @Test\n+    public void shouldReturnExpectedResultsUsingBefore() {\n+        repo.findByPublicationYearBefore(1980)\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getPublicationYear() < 1980).toArray())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected result is returned when querying for {@link Book books} {@code after} a specific year.\n+     */\n+    @Test\n+    public void shouldReturnExpectedResultsUsingAfter() {\n+        repo.findByPublicationYearAfter(1980)\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getPublicationYear() > 1980).toArray())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected result is returned when searching by a title containing the given string.\n+     */\n+    @Test\n+    public void shouldFindBooksUsingContains() {\n+        repo.findByTitleContains(\"Dune\")\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getTitle().contains(\"Dune\")).toArray())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected result is returned when searching for books with pages numbered greater than a\n+     * given value.\n+     */\n+    @Test\n+    void shouldFindBooksWithPagesGreaterThan() {\n+        repo.findByPagesGreaterThan(468)\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getPages() > 468).toArray())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected result is returned when searching for books with pages numbered less than a\n+     * given value.\n+     */\n+    @Test\n+    void shouldFindBooksWithPagesLessThan() {\n+        repo.findByPagesLessThan(677)\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getPages() < 677).toArray())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected results are returned when searching for titles starting with a given string.\n+     */\n+    @Test\n+    void shouldFindByTitleStartingWith() {\n+        repo.findByTitleStartingWith(\"Du\")\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getTitle().startsWith(\"Du\")).toArray())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected results are returned when searching for titles ending with a given string.\n+     */\n+    @Test\n+    void shouldFindByTitleEndingWith() {\n+        repo.findByTitleEndingWith(\"Wind\")\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getTitle().endsWith(\"Wind\")).toArray())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected results are returned when searching for a list of titles.\n+     */\n+    @Test\n+    void shouldFindByTitleIn() {\n+        List<String> titles = new ArrayList<>();\n+        titles.add(\"Dune\");\n+        titles.add(\"The Name of the Wind\");\n+\n+        repo.findByTitleIn(titles)\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getTitle().equals(\"Dune\")\n+                                || book.getTitle().equals(\"The Name of the Wind\")).toArray())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected results are returned when searching for books published between a given range.\n+     */\n+    @Test\n+    void shouldFindBetweenPublicationYears() {\n+        repo.findByPublicationYearBetween(1960, 2000)\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getPublicationYear() > 1960\n+                                && book.getPublicationYear() < 2000).toArray())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected results when searching for null authors.\n+     */\n+    @Test\n+    void shouldReturnEmptyListForNullAuthors() {\n+        repo.findByAuthorIsNull()\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getAuthor() == null).toArray())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected results when searching for non-null authors.\n+     */\n+    @Test\n+    void shouldReturnListForNonNullAuthors() {\n+        repo.findByAuthorIsNotNull()\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream().filter(book -> book.getAuthor() != null).toArray())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected number of titles with pages greater than input value.\n+     */\n+    @Test\n+    void shouldReturnCountOfTitlesWithPagesGreaterThan() {\n+        repo.countTitleByPagesGreaterThan(400)\n+                .thenAccept(aLong -> assertThat(aLong,\n+                        is(books.stream().filter(book -> book.getPages() > 400).count())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected of number of distinct titles with pages greater than input value.\n+     */\n+    @Test\n+    void shouldReturnCountDistinctOfTitlesWithPagesGreaterThan() {\n+        repo.countDistinctTitleByPagesGreaterThan(400)\n+                .thenAccept(aLong -> assertThat(aLong,\n+                        is(books.stream().filter(book -> book.getPages() > 400).count())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected results are returned when searching for a list of titles\n+     * with pages greater than input value.\n+     */\n+    @Test\n+    void shouldReturnListOfDistinctTitlesWithPagesGreaterThan() {\n+        repo.findDistinctTitleByPagesGreaterThan(400)\n+                .thenAccept(books1 -> assertThat(books1, containsInAnyOrder(\n+                        books.stream()\n+                                .filter(book -> book.getPages() > 400)\n+                                .map(Book::getTitle)\n+                                .distinct().toArray())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected value is returned when getting max pages by author.\n+     */\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+    @Test\n+    void shouldReturnMaxPagesByAuthor() {\n+        repo.findMaxPagesByAuthor(FRANK_HERBERT)\n+                .thenAccept(aLong -> assertThat(aLong, is(\n+                        books.stream()\n+                                .filter(book -> book.getAuthor().equals(FRANK_HERBERT))\n+                                .map(Book::getPages)\n+                                .max(Comparator.comparing(Long::valueOf)).get().longValue())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected value is returned when getting min pages by author.\n+     */\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+    @Test\n+    void shouldReturnMinPagesByAuthor() {\n+        repo.findMinPagesByAuthor(FRANK_HERBERT)\n+                .thenAccept(aLong -> assertThat(aLong, is(\n+                        books.stream()\n+                                .filter(book -> book.getAuthor().equals(FRANK_HERBERT))\n+                                .map(Book::getPages)\n+                                .min(Comparator.comparing(Long::valueOf)).get().longValue())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected value is returned when getting sum pages by author.\n+     */\n+    @Test\n+    void shouldReturnSumPagesByAuthor() {\n+        repo.findSumPagesByAuthor(FRANK_HERBERT)\n+                .thenAccept(aLong -> assertThat(aLong, is(\n+                        books.stream()\n+                                .filter(book -> book.getAuthor().equals(FRANK_HERBERT))\n+                                .map(Book::getPages)\n+                                .reduce(0, Integer::sum).longValue())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate the expected value is returned when getting avg pages by author.\n+     */\n+    @Test\n+    void shouldReturnAvgPagesByAuthor() {\n+        repo.findAvgPagesByAuthor(FRANK_HERBERT)\n+                .thenAccept(aLong -> assertThat(aLong, is(\n+                        books.stream()\n+                                .filter(book -> book.getAuthor().equals(FRANK_HERBERT))\n+                                .collect(Collectors.averagingInt(Book::getPages)).longValue())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate batch updates work as expected.\n+     */\n+    @Test\n+    void shouldSupportBatchUpdates() {\n+        repo.updateByTitleStartingWith(\"Du\", 700)\n+                .thenAcceptAsync(unused -> assertThat(repo.findById(DUNE.getUuid()).join().getPages(), is(700)))\n+                .thenAcceptAsync(unused -> assertThat(repo.findById(DUNE_MESSIAH.getUuid()).join().getPages(), is(700)))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate single update with existing value returns the expected value and updates\n+     * the book.\n+     */\n+    @Test\n+    void shouldSupportSingleUpdates() {\n+        repo.update(DUNE.getUuid(), 999)\n+                .thenAccept(integer -> assertThat(integer, is(1)))\n+                .thenAcceptAsync(unused -> assertThat(repo.findById(DUNE.getUuid()).join().getPages(), is(999)))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate expected return value when the no entity matches.\n+     */\n+    @Test\n+    void shouldSupportSingleUpdatesNoMatch() {\n+        repo.update(new UUID(), 999)\n+                .thenAccept(integer -> assertThat(integer, is(0)))\n+                .thenAcceptAsync(unused -> assertThat(repo.findById(DUNE.getUuid()).join().getPages(), is(DUNE.getPages())))\n+                .join();\n+    }\n+\n+    /**\n+     * Validate batch deletes work as expected.\n+     */\n+    @Test\n+    void shouldSupportBatchDeletes() {\n+        repo.deleteByTitleStartingWith(\"Du\")\n+                .thenAcceptAsync(unused -> assertThat(repo.count().join(), is(2L)))\n+                .thenAcceptAsync(unused -> assertThat(repo.existsById(DUNE.getUuid()).join(), is(false)))\n+                .thenAcceptAsync(unused -> assertThat(repo.existsById(DUNE_MESSIAH.getUuid()).join(), is(false)));\n+    }\n+\n+    /**\n+     * Validate bulk saves work as expected.\n+     */\n+    @Test\n+    void shouldSupportBulksSaves() {\n+        Set<Book> setNewBooks = new HashSet<>();\n+        setNewBooks.add(new Book(\"Children of Dune\", 444, FRANK_HERBERT, new GregorianCalendar(1976,\n+                Calendar.APRIL, 6, 0, 0)));\n+        setNewBooks.add(new Book(\"God Emperor of Dune\", 496, FRANK_HERBERT, new GregorianCalendar(1981,\n+                Calendar.FEBRUARY, 6, 0, 0)));\n+        repo.saveBooks(setNewBooks)\n+                .thenAcceptAsync(unused -> assertThat(repo.findByTitleIn(\n+                        Arrays.asList(\"Children of Dune\", \"God Emperor of Dune\")).join(),\n+                        containsInAnyOrder(setNewBooks.toArray()))).join();\n+    }\n+}"
  },
  {
    "sha": "f5c0e01ebf48fac4d157178fd8057d55d5d731de",
    "filename": "coherence-data/src/test/java/io/micronaut/coherence/data/GeneratedStatementsTest.java",
    "status": "renamed",
    "additions": 15,
    "deletions": 1,
    "changes": 16,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/GeneratedStatementsTest.java",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/GeneratedStatementsTest.java",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence-data/src/test/java/io/micronaut/coherence/data/GeneratedStatementsTest.java?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -15,6 +15,7 @@\n  */\n package io.micronaut.coherence.data;\n \n+import com.tangosol.net.NamedMap;\n import com.tangosol.util.UUID;\n import io.micronaut.coherence.data.model.Author;\n import io.micronaut.coherence.data.model.Book;\n@@ -33,14 +34,27 @@\n \n @MicronautTest(propertySources = {\"classpath:sessions.yaml\"})\n @TestInstance(TestInstance.Lifecycle.PER_METHOD)\n-public class GeneratedStatementTests extends AbstractDataTests {\n+public class GeneratedStatementsTest extends AbstractDataTest {\n+\n+    /**\n+     * The {@link NamedMap} the {@code Repository} should be using.\n+     */\n+    @Inject\n+    protected NamedMap<UUID, Book> book;\n \n     /**\n      * A {@code repository} for validating generated queries.\n      */\n     @Inject\n     protected BookRepository repo;\n \n+    // ----- AbstractDataTest -----------------------------------------------\n+\n+    @Override\n+    public NamedMap<UUID, Book> getNamedMap() {\n+        return book;\n+    }\n+\n     // ----- test methods ---------------------------------------------------\n \n     /**",
    "previous_filename": "coherence-data/src/test/java/io/micronaut/coherence/data/GeneratedStatementTests.java"
  },
  {
    "sha": "986010a0e57fc37b7ed00145f6a4d559643b2bf1",
    "filename": "coherence-data/src/test/java/io/micronaut/coherence/data/RepositoryTest.java",
    "status": "renamed",
    "additions": 12,
    "deletions": 2,
    "changes": 14,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/RepositoryTest.java",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/RepositoryTest.java",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence-data/src/test/java/io/micronaut/coherence/data/RepositoryTest.java?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -15,6 +15,8 @@\n  */\n package io.micronaut.coherence.data;\n \n+import com.tangosol.net.NamedMap;\n+import com.tangosol.util.UUID;\n import io.micronaut.coherence.data.model.Book;\n import io.micronaut.coherence.data.repositories.CoherenceBookRepository;\n import io.micronaut.test.extensions.junit5.annotation.MicronautTest;\n@@ -27,21 +29,29 @@\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.core.Is.is;\n+import static org.hamcrest.core.IsInstanceOf.instanceOf;\n import static org.hamcrest.core.IsNull.notNullValue;\n \n /**\n  * Validation of {@link AbstractCoherenceRepository}.\n  */\n @MicronautTest(propertySources = {\"classpath:sessions.yaml\"})\n @TestInstance(TestInstance.Lifecycle.PER_METHOD)\n-public class RepositoryTests extends AbstractDataTests {\n+public class RepositoryTest extends AbstractDataTest {\n \n     /**\n      * The concrete {@link AbstractCoherenceRepository} implementation under test.\n      */\n     @Inject\n     protected CoherenceBookRepository repo;\n \n+    // ----- AbstractDataTest -----------------------------------------------\n+\n+    @Override\n+    public NamedMap<UUID, Book> getNamedMap() {\n+        return repo.getMap();\n+    }\n+\n     // ----- test methods ---------------------------------------------------\n \n     /**\n@@ -51,7 +61,7 @@\n     @Test\n     public void shouldReturnNamedMap() {\n         assertThat(repo, notNullValue());\n-        assertThat(repo.getMap(), notNullValue());\n+        assertThat(repo.getMap(), instanceOf(NamedMap.class));\n         assertThat(repo.count(), is(4L));\n     }\n ",
    "previous_filename": "coherence-data/src/test/java/io/micronaut/coherence/data/RepositoryTests.java"
  },
  {
    "sha": "280ab152f646db5a92fe08df521e5e52ae2b10a6",
    "filename": "coherence-data/src/test/java/io/micronaut/coherence/data/repositories/AsyncBookRepository.java",
    "status": "added",
    "additions": 91,
    "deletions": 0,
    "changes": 91,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/repositories/AsyncBookRepository.java",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/repositories/AsyncBookRepository.java",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence-data/src/test/java/io/micronaut/coherence/data/repositories/AsyncBookRepository.java?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2017-2021 original authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.micronaut.coherence.data.repositories;\n+\n+import com.tangosol.util.UUID;\n+import io.micronaut.coherence.data.annotation.CoherenceRepository;\n+import io.micronaut.coherence.data.model.Author;\n+import io.micronaut.coherence.data.model.Book;\n+import io.micronaut.data.annotation.Id;\n+import io.micronaut.data.repository.async.AsyncCrudRepository;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * A {@link Book} {@code Repository} to test queries generated by Micronaut.\n+ */\n+@CoherenceRepository(\"book\")\n+public interface AsyncBookRepository extends AsyncCrudRepository<Book, UUID> {\n+\n+    CompletableFuture<Boolean> existsByAuthor(Author author);\n+\n+    CompletableFuture<List<Book>> findByAuthor(Author author);\n+\n+    CompletableFuture<List<Book>> findByPagesGreaterThanEquals(int pages);\n+\n+    CompletableFuture<List<Book>> findByPagesLessThanEquals(int pageCount);\n+\n+    CompletableFuture<List<Book>> findByTitleLike(String like);\n+\n+    CompletableFuture<List<Book>> findByPagesGreaterThan(int pageCount);\n+\n+    CompletableFuture<List<Book>> findByPagesLessThan(int pageCount);\n+\n+    CompletableFuture<List<Book>> findByPublicationYearAfter(int year);\n+\n+    CompletableFuture<List<Book>> findByPublicationYearBefore(int year);\n+\n+    CompletableFuture<List<Book>> findByTitleContains(String keyword);\n+\n+    CompletableFuture<List<Book>> findByTitleStartingWith(String keyword);\n+\n+    CompletableFuture<List<Book>> findByTitleEndingWith(String keyword);\n+\n+    CompletableFuture<List<Book>> findByTitleIn(Collection<String> titles);\n+\n+    CompletableFuture<List<Book>> findByPublicationYearBetween(int startYear, int endYear);\n+\n+    CompletableFuture<List<Book>> findByAuthorIsNull();\n+\n+    CompletableFuture<List<Book>> findByAuthorIsNotNull();\n+\n+    // projections\n+    CompletableFuture<Long> countTitleByPagesGreaterThan(int pageCount);\n+\n+    CompletableFuture<Long> countDistinctTitleByPagesGreaterThan(int pageCount);\n+\n+    CompletableFuture<List<String>> findDistinctTitleByPagesGreaterThan(int pageCount);\n+\n+    CompletableFuture<Long> findMaxPagesByAuthor(Author author);\n+\n+    CompletableFuture<Long> findMinPagesByAuthor(Author author);\n+\n+    CompletableFuture<Long> findSumPagesByAuthor(Author author);\n+\n+    CompletableFuture<Long> findAvgPagesByAuthor(Author author);\n+\n+    // updates\n+    CompletableFuture<Integer> update(@Id UUID id, int pages);\n+\n+    CompletableFuture<Void> updateByTitleStartingWith(String title, int pages);\n+\n+    // deletes\n+    CompletableFuture<Integer> deleteByTitleStartingWith(String title);\n+\n+    CompletableFuture<Collection<Book>> saveBooks(Collection<Book> books);\n+}"
  },
  {
    "sha": "830d755dcfb7fc803d4f44205c0c219db4728111",
    "filename": "coherence-data/src/test/java/io/micronaut/coherence/data/repositories/CoherenceAsyncBookRepository.java",
    "status": "added",
    "additions": 35,
    "deletions": 0,
    "changes": 35,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/repositories/CoherenceAsyncBookRepository.java",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/repositories/CoherenceAsyncBookRepository.java",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence-data/src/test/java/io/micronaut/coherence/data/repositories/CoherenceAsyncBookRepository.java?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2017-2021 original authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.micronaut.coherence.data.repositories;\n+\n+import com.tangosol.util.UUID;\n+import io.micronaut.coherence.data.AbstractCoherenceAsyncRepository;\n+import io.micronaut.coherence.data.AbstractCoherenceRepository;\n+import io.micronaut.coherence.data.annotation.CoherenceRepository;\n+import io.micronaut.coherence.data.model.Book;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * A {@code Repository} extending {@link AbstractCoherenceAsyncRepository} to ensure this integration point\n+ * is functional.\n+ */\n+@CoherenceRepository(\"book\")\n+public abstract class CoherenceAsyncBookRepository extends AbstractCoherenceAsyncRepository<Book, UUID> {\n+    public abstract CompletableFuture<List<Book>> findByTitleStartingWith(String keyword);\n+}\n+"
  },
  {
    "sha": "a871e1f58195e51c94403d0d006a9f5f83e22fdb",
    "filename": "coherence-data/src/test/java/io/micronaut/coherence/data/repositories/CoherenceBookRepository.java",
    "status": "modified",
    "additions": 1,
    "deletions": 2,
    "changes": 3,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/repositories/CoherenceBookRepository.java",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-data/src/test/java/io/micronaut/coherence/data/repositories/CoherenceBookRepository.java",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence-data/src/test/java/io/micronaut/coherence/data/repositories/CoherenceBookRepository.java?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -23,8 +23,7 @@\n import java.util.List;\n \n /**\n- * A {@code Repository} extending {@link com.oracle.coherence.repository.AbstractRepository} to ensure\n- * this integration point is functional.\n+ * A {@code Repository} extending {@link AbstractCoherenceRepository} to ensure this integration point is functional.\n  */\n @CoherenceRepository(\"book\")\n public abstract class CoherenceBookRepository extends AbstractCoherenceRepository<Book, UUID> {"
  },
  {
    "sha": "601b117904a6188d400226af305e555e8334c523",
    "filename": "coherence-processor/src/main/java/io/micronaut/coherence/data/CoherenceAsyncRepositoryOperations.java",
    "status": "added",
    "additions": 47,
    "deletions": 0,
    "changes": 47,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-processor/src/main/java/io/micronaut/coherence/data/CoherenceAsyncRepositoryOperations.java",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-processor/src/main/java/io/micronaut/coherence/data/CoherenceAsyncRepositoryOperations.java",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence-processor/src/main/java/io/micronaut/coherence/data/CoherenceAsyncRepositoryOperations.java?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2017-2021 original authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.micronaut.coherence.data;\n+\n+import com.tangosol.net.AsyncNamedMap;\n+import io.micronaut.data.operations.async.AsyncRepositoryOperations;\n+\n+/**\n+ * Exposes {@code async repository} operations specific to Coherence.\n+ */\n+public interface CoherenceAsyncRepositoryOperations extends AsyncRepositoryOperations {\n+    /**\n+     * Obtain the {@link AsyncNamedMap} associated this this {@code repository}.\n+     *\n+     * @param <ID> the type of the entity id\n+     * @param <T> the entity type\n+     *\n+     * @return the {@link AsyncNamedMap} associated this this {@code repository}\n+     */\n+    <ID, T> AsyncNamedMap<ID, T> getAsyncNamedMap();\n+\n+\n+    /**\n+     * Return the id associated with the specified entity.\n+     *\n+     * @param entity the entity to interrogate\n+     *\n+     * @param <ID> the type of the entity id\n+     * @param <T> the entity type\n+     *\n+     * @return the id associated with the specified entity\n+     */\n+    <ID, T> ID getId(T entity);\n+}"
  },
  {
    "sha": "0027799f7fcdc3c202df021e08eda8b3cc135c44",
    "filename": "coherence-processor/src/main/java/io/micronaut/coherence/data/CoherenceRepositoryOperations.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-processor/src/main/java/io/micronaut/coherence/data/CoherenceRepositoryOperations.java",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence-processor/src/main/java/io/micronaut/coherence/data/CoherenceRepositoryOperations.java",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence-processor/src/main/java/io/micronaut/coherence/data/CoherenceRepositoryOperations.java?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -16,12 +16,12 @@\n package io.micronaut.coherence.data;\n \n import com.tangosol.net.NamedMap;\n-import io.micronaut.data.operations.RepositoryOperations;\n+import io.micronaut.data.operations.async.AsyncCapableRepository;\n \n /**\n  * Exposes {@code repository} operations specific to Coherence.\n  */\n-public interface CoherenceRepositoryOperations extends RepositoryOperations {\n+public interface CoherenceRepositoryOperations extends AsyncCapableRepository {\n \n     /**\n      * Obtain the {@link NamedMap} associated this this {@code repository}."
  },
  {
    "sha": "806d501661db6faec56405fd8393ddd3a27b149a",
    "filename": "coherence/src/main/java/io/micronaut/coherence/CoherenceFactory.java",
    "status": "modified",
    "additions": 29,
    "deletions": 6,
    "changes": 35,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence/src/main/java/io/micronaut/coherence/CoherenceFactory.java",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/coherence/src/main/java/io/micronaut/coherence/CoherenceFactory.java",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/coherence/src/main/java/io/micronaut/coherence/CoherenceFactory.java?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -31,9 +31,11 @@\n import io.micronaut.context.ApplicationContext;\n import io.micronaut.context.BeanContext;\n import io.micronaut.context.annotation.*;\n+import io.micronaut.context.event.StartupEvent;\n import io.micronaut.core.util.StringUtils;\n import io.micronaut.inject.InjectionPoint;\n import io.micronaut.inject.qualifiers.Qualifiers;\n+import io.micronaut.runtime.event.annotation.EventListener;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -62,6 +64,16 @@ public CoherenceFactory(BeanContext beanContext) {\n         this.beanContext = beanContext;\n     }\n \n+    /**\n+     * Initialise the Coherence instance on start-up.\n+     *\n+     * @param event  the {@link StartupEvent}\n+     */\n+    @EventListener\n+    void onStartupEvent(StartupEvent event) {\n+        beanContext.getBean(Coherence.class, Qualifiers.byName(Coherence.DEFAULT_NAME));\n+    }\n+\n     /**\n      * Creates the default {@link com.tangosol.net.Coherence} instance used by the Micronaut\n      * Coherence server.\n@@ -89,13 +101,24 @@ Coherence getCoherence(SessionConfiguration[] configurations,\n \n         LOG.info(\"Creating default Coherence instance.\");\n \n-        CoherenceConfiguration cfg = CoherenceConfiguration.builder()\n-                .withSessions(CoherenceFactory.collectConfigurations(configurations, providers))\n-                .withEventInterceptors(lifecycleListeners)\n-                .withEventInterceptors(listenerProcessor.getInterceptors())\n-                .build();\n+        // We need to check for an existing instance of Coherence.\n+        // Even thought his method is annotated as @Singleton it \"could\" get called more than once\n+        Coherence coherence = Coherence.getInstance(Coherence.DEFAULT_NAME);\n+        if (coherence == null) {\n+            synchronized (this) {\n+                coherence = Coherence.getInstance(Coherence.DEFAULT_NAME);\n+                if (coherence == null) {\n+                    CoherenceConfiguration cfg = CoherenceConfiguration.builder()\n+                            .withSessions(CoherenceFactory.collectConfigurations(configurations, providers))\n+                            .withEventInterceptors(lifecycleListeners)\n+                            .withEventInterceptors(listenerProcessor.getInterceptors())\n+                            .build();\n+\n+                    coherence = Coherence.clusterMember(cfg);\n+                }\n+            }\n+        }\n \n-        Coherence coherence = Coherence.clusterMember(cfg);\n         // start Coherence and wait for it to be started\n         coherence.start().join();\n         return coherence;"
  },
  {
    "sha": "245cef83b106b94603215d16c7c3673a74f17895",
    "filename": "gradle.properties",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/rlubke/micronaut-coherence/blob/c42d0081579c8a8e825a94caeb89390fe7454ec4/gradle.properties",
    "raw_url": "https://github.com/rlubke/micronaut-coherence/raw/c42d0081579c8a8e825a94caeb89390fe7454ec4/gradle.properties",
    "contents_url": "https://api.github.com/repos/rlubke/micronaut-coherence/contents/gradle.properties?ref=c42d0081579c8a8e825a94caeb89390fe7454ec4",
    "patch": "@@ -11,7 +11,7 @@ spockVersion=2.0-M3-groovy-3.0\n #groovyVersion=2.5.11\n #spockVersion=1.3-groovy-2.5\n \n-coherenceVersion=21.06-M1\n+coherenceVersion=21.06-SNAPSHOT\n hamcrestVersion=2.2\n bedrockVersion=5.0.20\n testContainersVersion=1.15.2"
  }
]
