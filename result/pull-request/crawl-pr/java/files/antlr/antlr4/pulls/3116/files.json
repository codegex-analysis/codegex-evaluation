[
  {
    "sha": "067e73e79264e37c7d396c892de12089cb481721",
    "filename": ".appveyor/workflow.yml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/.appveyor/workflow.yml",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/.appveyor/workflow.yml",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/.appveyor/workflow.yml?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -58,7 +58,7 @@ for:\n       only:\n         - job_name: dart-runtime\n     install:\n-      - cinst -y dart-sdk --version=2.8.4\n+      - cinst -y dart-sdk --version=2.12.1\n     build_script:\n       - mvn -q -DskipTests install --batch-mode\n     test_script:"
  },
  {
    "sha": "25e857606bc32d0fbb4f123aba3c80af393cf4b2",
    "filename": ".circleci/scripts/install-linux-dart.sh",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/.circleci/scripts/install-linux-dart.sh",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/.circleci/scripts/install-linux-dart.sh",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/.circleci/scripts/install-linux-dart.sh?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -8,7 +8,7 @@ sudo apt-get install apt-transport-https\n sudo sh -c 'wget -qO- https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add -'\n sudo sh -c 'wget -qO- https://storage.googleapis.com/download.dartlang.org/linux/debian/dart_stable.list > /etc/apt/sources.list.d/dart_stable.list'\n sudo apt-get update\n-sudo apt-get install dart=2.8.4-1\n+sudo apt-get install dart=2.12.1-1\n export PATH=\"$PATH:/usr/lib/dart/bin\"\n echo \"done installing dart SDK\"\n sudo apt-get install -f"
  },
  {
    "sha": "9b471196c46ccbe854c246fc56a87da073589c4c",
    "filename": ".travis/before-install-linux-dart.sh",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/.travis/before-install-linux-dart.sh",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/.travis/before-install-linux-dart.sh",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/.travis/before-install-linux-dart.sh?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -1,7 +1,7 @@\n #!/bin/bash\n \n set -euo pipefail\n-wget https://storage.googleapis.com/dart-archive/channels/stable/release/2.8.4/linux_packages/dart_2.8.4-1_amd64.deb\n-sudo dpkg -i ./dart_2.8.4-1_amd64.deb\n-sudo rm ./dart_2.8.4-1_amd64.deb\n+wget https://storage.googleapis.com/dart-archive/channels/stable/release/2.12.1/linux_packages/dart_2.12.1-1_amd64.deb\n+sudo dpkg -i ./dart_2.12.1-1_amd64.deb\n+sudo rm ./dart_2.12.1-1_amd64.deb\n sudo apt-get install -f"
  },
  {
    "sha": "29e3e9a41f1718c6fbdb445fccbd4d5a00b780c6",
    "filename": "contributors.txt",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/contributors.txt",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/contributors.txt",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/contributors.txt?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -290,3 +290,5 @@ YYYY/MM/DD, github id, Full name, email\n 2021/02/27, khmarbaise, Karl Heinz Marbaise, github@soebes.com\n 2021/03/02, hackeris\n 2021/03/03, xTachyon, Damian Andrei, xTachyon@users.noreply.github.com\n+2021/03/10, renancaraujo, Renan C. Ara√∫jo, renancaraujo@users.noreply.github.com\n+2021/03/13, canastro, Ricardo Canastro, ricardocanastro@users.noreply.github.com"
  },
  {
    "sha": "2b85e81f692c9ba772148b481c33a92b08e0f4b0",
    "filename": "doc/dart-target.md",
    "status": "modified",
    "additions": 0,
    "deletions": 2,
    "changes": 2,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/doc/dart-target.md",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/doc/dart-target.md",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/doc/dart-target.md?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -1,7 +1,5 @@\n # ANTLR4 Runtime for Dart\n \n-Notice: Dart target may generate code incompatible with Dart 2.9 sound null safety. Please set the minimum SDK constraint to 2.8.4 or lower if such violation is found. Contributions are welcomed.\n-\n ### First steps\n \n #### 1. Install ANTLR4"
  },
  {
    "sha": "60eeac8be6fdb70754fe82d688d649c3f372e997",
    "filename": "runtime-testsuite/resources/org/antlr/v4/test/runtime/templates/Dart.test.stg",
    "status": "modified",
    "additions": 16,
    "deletions": 16,
    "changes": 32,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime-testsuite/resources/org/antlr/v4/test/runtime/templates/Dart.test.stg",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime-testsuite/resources/org/antlr/v4/test/runtime/templates/Dart.test.stg",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime-testsuite/resources/org/antlr/v4/test/runtime/templates/Dart.test.stg?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -68,7 +68,7 @@ PlusText(a) ::= <%\"<a>\" + this.text%>\n \n InputText() ::= \"tokenStream.text\"\n \n-LTEquals(i, v) ::= <%tokenStream.LT(<i>).text == <v>%>\n+LTEquals(i, v) ::= <%tokenStream.LT(<i>)!.text == <v>%>\n \n LANotEquals(i, v) ::= <%tokenStream.LA(<i>)!=<v>%>\n \n@@ -80,7 +80,7 @@ GetExpectedTokenNames() ::= \"this.expectedTokens.toString(vocabulary: this.vocab\n \n RuleInvocationStack() ::= \"ruleInvocationStack\"\n \n-LL_EXACT_AMBIG_DETECTION() ::= <<interpreter.predictionMode = PredictionMode.LL_EXACT_AMBIG_DETECTION;>>\n+LL_EXACT_AMBIG_DETECTION() ::= <<interpreter!.predictionMode = PredictionMode.LL_EXACT_AMBIG_DETECTION;>>\n \n ParserToken(parser, token) ::= <%<parser>.TOKEN_<token>%>\n \n@@ -221,9 +221,9 @@ walker.walk(new LeafListener(), <s>);\n TreeNodeWithAltNumField(X) ::= <<\n @parser::definitions {\n class MyRuleNode extends ParserRuleContext {\n-  int altNum;\n+  late int altNum;\n \n-  MyRuleNode(ParserRuleContext parent, int invokingStateNumber)\n+  MyRuleNode(ParserRuleContext? parent, int? invokingStateNumber)\n       : super(parent, invokingStateNumber);\n \n   @override int get altNumber {\n@@ -242,9 +242,9 @@ TokenGetterListener(X) ::= <<\n class LeafListener extends TBaseListener {\n   void exitA(AContext ctx) {\n     if (ctx.childCount==2)\n-      stdout.write(\"${ctx.INT(0).symbol.text} ${ctx.INT(1).symbol.text} ${ctx.INTs()}\");\n+      stdout.write(\"${ctx.INT(0)?.symbol.text} ${ctx.INT(1)?.symbol.text} ${ctx.INTs()}\");\n     else\n-      print(ctx.ID().symbol);\n+      print(ctx.ID()?.symbol);\n   }\n }\n }\n@@ -255,9 +255,9 @@ RuleGetterListener(X) ::= <<\n class LeafListener extends TBaseListener {\n   void exitA(AContext ctx) {\n     if (ctx.childCount==2) {\n-      stdout.write(\"${ctx.b(0).start.text} ${ctx.b(1).start.text} ${ctx.bs()[0].start.text}\");\n+      stdout.write(\"${ctx.b(0)?.start?.text} ${ctx.b(1)?.start?.text} ${ctx.bs()[0].start?.text}\");\n     } else\n-      print(ctx.b(0).start.text);\n+      print(ctx.b(0)?.start?.text);\n   }\n }\n }\n@@ -269,9 +269,9 @@ LRListener(X) ::= <<\n class LeafListener extends TBaseListener {\n   void exitE(EContext ctx) {\n     if (ctx.childCount==3) {\n-      stdout.write(\"${ctx.e(0).start.text} ${ctx.e(1).start.text} ${ctx.es()[0].start.text}\\n\");\n+      stdout.write(\"${ctx.e(0)?.start?.text} ${ctx.e(1)?.start?.text} ${ctx.es()[0].start?.text}\\n\");\n     } else\n-      print(ctx.INT().symbol.text);\n+      print(ctx.INT()?.symbol.text);\n   }\n }\n }\n@@ -281,20 +281,20 @@ LRWithLabelsListener(X) ::= <<\n @parser::definitions {\n class LeafListener extends TBaseListener {\n   void exitCall(CallContext ctx) {\n-    stdout.write(\"${ctx.e().start.text} ${ctx.eList()}\");\n+    stdout.write(\"${ctx.e()?.start?.text} ${ctx.eList()}\");\n   }\n   void exitInt(IntContext ctx) {\n-    print(ctx.INT().symbol.text);\n+    print(ctx.INT()?.symbol.text);\n   }\n }\n }\n >>\n \n DeclareContextListGettersFunction() ::= <<\n void foo() {\n-  SContext s = null;\n-  List\\<AContext> a = s.as();\n-  List\\<BContext> b = s.bs();\n+  SContext? s = null;\n+  List\\<AContext>? a = s?.as();\n+  List\\<BContext>? b = s?.bs();\n }\n >>\n \n@@ -315,4 +315,4 @@ Invoke_pred(v) ::= <<this.pred(<v>)>>\n ParserTokenType(t) ::= \"Parser.<t>\"\n ContextRuleFunction(ctx, rule) ::= \"<ctx>.<rule>\"\n StringType() ::= \"String\"\n-ContextMember(ctx, subctx, member) ::= \"<ctx>.<subctx>.<member>\"\n+ContextMember(ctx, subctx, member) ::= \"<ctx>.<subctx>!.<member>!\""
  },
  {
    "sha": "1fcce39d532e3551b9c6505903bdb62f47b074ab",
    "filename": "runtime-testsuite/test/org/antlr/v4/test/runtime/dart/BaseDartTest.java",
    "status": "modified",
    "additions": 13,
    "deletions": 5,
    "changes": 18,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime-testsuite/test/org/antlr/v4/test/runtime/dart/BaseDartTest.java",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime-testsuite/test/org/antlr/v4/test/runtime/dart/BaseDartTest.java",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime-testsuite/test/org/antlr/v4/test/runtime/dart/BaseDartTest.java?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -30,6 +30,7 @@\n \t);\n \n \tprivate static String cacheDartPackages;\n+\tprivate static String cacheDartPackageConfig;\n \n \tpublic String getPropertyPrefix() {\n \t\treturn \"antlr-dart\";\n@@ -140,7 +141,10 @@ protected boolean rawGenerateAndBuildRecognizer(String grammarFileName,\n \t\t\t\"name: \\\"test\\\"\\n\" +\n \t\t\t\t\"dependencies:\\n\" +\n \t\t\t\t\"  antlr4:\\n\" +\n-\t\t\t\t\"    path: \" + runtime + \"\\n\");\n+\t\t\t\t\"    path: \" + runtime + \"\\n\" +\n+\t\t\t\t\"environment:\\n\" +\n+  \t\t\t\t\"  sdk: \\\">=2.12.0 <3.0.0\\\"\\n\");\n+\t\tfinal File dartToolDir = new File(getTempDirPath(), \".dart_tool\");\n \t\tif (cacheDartPackages == null) {\n \t\t\ttry {\n \t\t\t\tfinal Process process = Runtime.getRuntime().exec(new String[]{locatePub(), \"get\"}, null, getTempTestDir());\n@@ -169,8 +173,12 @@ public void run() {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t\tcacheDartPackages = readFile(getTempDirPath(), \".packages\");\n+\t\t\tcacheDartPackageConfig = readFile(dartToolDir.getAbsolutePath(), \"package_config.json\");\n \t\t} else {\n \t\t\twriteFile(getTempDirPath(), \".packages\", cacheDartPackages);\n+\t\t\t//noinspection ResultOfMethodCallIgnored\n+\t\t\tdartToolDir.mkdir();\n+\t\t\twriteFile(dartToolDir.getAbsolutePath(), \"package_config.json\", cacheDartPackageConfig);\n \t\t}\n \t\treturn true; // allIsWell: no compile\n \t}\n@@ -293,7 +301,7 @@ private String locateTool(String tool) {\n \n \t\tfinal String[] roots = isWindows()\n \t\t\t\t? new String[]{\"C:\\\\tools\\\\dart-sdk\\\\bin\\\\\"}\n-\t\t\t\t: new String[]{\"/usr/local/bin/\", \"/opt/local/bin/\", \"/usr/bin/\", \"/usr/lib/dart/bin/\"};\n+\t\t\t\t: new String[]{\"/usr/local/bin/\", \"/opt/local/bin/\", \"/usr/bin/\", \"/usr/lib/dart/bin/\", \"/usr/local/opt/dart/libexec\"};\n \n \t\tfor (String root : roots) {\n \t\t\tfor (String t : tools) {\n@@ -402,7 +410,7 @@ protected void writeTestFile(String parserName,\n \t\t\t\t\"  @override\\n\" +\n \t\t\t\t\"  void enterEveryRule(ParserRuleContext ctx) {\\n\" +\n \t\t\t\t\"    for (var i = 0; i \\\\< ctx.childCount; i++) {\\n\" +\n-\t\t\t\t\"      final parent = ctx.getChild(i).parent;\\n\" +\n+\t\t\t\t\"      final parent = ctx.getChild(i)?.parent;\\n\" +\n \t\t\t\t\"      if (!(parent is RuleNode) || (parent as RuleNode).ruleContext != ctx) {\\n\" +\n \t\t\t\t\"        throw StateError('Invalid parse tree shape detected.');\\n\" +\n \t\t\t\t\"      }\\n\" +\n@@ -444,10 +452,10 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {\n \t\t\t\t\"  <lexerName> lex = <lexerName>(input);\\n\" +\n \t\t\t\t\"  CommonTokenStream tokens = CommonTokenStream(lex);\\n\" +\n \t\t\t\t\"  tokens.fill();\\n\" +\n-\t\t\t\t\"  for (Object t in tokens.getTokens())\\n\" +\n+\t\t\t\t\"  for (Object t in tokens.getTokens()!)\\n\" +\n \t\t\t\t\"    print(t);\\n\" +\n \t\t\t\t\"\\n\" +\n-\t\t\t\t(showDFA ? \"stdout.write(lex.interpreter.getDFA(Lexer.DEFAULT_MODE).toLexerString());\\n\" : \"\") +\n+\t\t\t\t(showDFA ? \"stdout.write(lex.interpreter!.getDFA(Lexer.DEFAULT_MODE).toLexerString());\\n\" : \"\") +\n \t\t\t\t\"}\\n\"\n \t\t);\n "
  },
  {
    "sha": "c3890c1cdb820a5d47adfcb0baa03293249c1aba",
    "filename": "runtime/Dart/lib/antlr4.dart",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/antlr4.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/antlr4.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/antlr4.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -19,3 +19,4 @@ export 'src/parser_rule_context.dart';\n export 'src/vocabulary.dart';\n export 'src/runtime_meta_data.dart';\n export 'src/token.dart';\n+export 'src/prediction_context.dart';\n\\ No newline at end of file"
  },
  {
    "sha": "6d13de580893b551aacd0e5fbe93b63f415acfe6",
    "filename": "runtime/Dart/lib/src/atn/src/atn.dart",
    "status": "modified",
    "additions": 18,
    "deletions": 17,
    "changes": 35,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/atn.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/atn.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/atn/src/atn.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -16,18 +16,18 @@ import 'transition.dart';\n class ATN {\n   static final INVALID_ALT_NUMBER = 0;\n \n-  List<ATNState> states = [];\n+  List<ATNState?> states = [];\n \n   /// Each subrule/rule is a decision point and we must track them so we\n   ///  can go back later and build DFA predictors for them.  This includes\n   ///  all the rules, subrules, optional blocks, ()+, ()* etc...\n   List<DecisionState> decisionToState = [];\n \n   /// Maps from rule index to starting state number.\n-  List<RuleStartState> ruleToStartState;\n+  List<RuleStartState> ruleToStartState = <RuleStartState>[];\n \n   /// Maps from rule index to stop state number.\n-  List<RuleStopState> ruleToStopState;\n+  late List<RuleStopState> ruleToStopState;\n \n   Map<String, TokensStartState> modeNameToStartState = {};\n \n@@ -42,11 +42,11 @@ class ATN {\n   /// type if the\n   /// {@link ATNDeserializationOptions#isGenerateRuleBypassTransitions}\n   /// deserialization option was specified; otherwise, this is null.\n-  List<int> ruleToTokenType;\n+  List<int>? ruleToTokenType;\n \n   /// For lexer ATNs, this is an array of [LexerAction] objects which may\n   /// be referenced by action transitions in the ATN.\n-  List<LexerAction> lexerActions;\n+  List<LexerAction>? lexerActions;\n \n   List<TokensStartState> modeToStartState = [];\n \n@@ -62,17 +62,17 @@ class ATN {\n   ///  Compute the set of valid tokens that can occur starting in [s] and\n   ///  staying in same rule. {@link Token#EPSILON} is in set if we reach end of\n   ///  rule.\n-  IntervalSet nextTokens(ATNState s, [RuleContext ctx]) {\n+  IntervalSet nextTokens(ATNState s, [RuleContext? ctx]) {\n     if (ctx != null) {\n       return LL1Analyzer(this).LOOK(s, ctx);\n     }\n-    if (s.nextTokenWithinRule != null) return s.nextTokenWithinRule;\n+    if (s.nextTokenWithinRule != null) return s.nextTokenWithinRule!;\n     s.nextTokenWithinRule = LL1Analyzer(this).LOOK(s, null);\n-    s.nextTokenWithinRule.setReadonly(true);\n-    return s.nextTokenWithinRule;\n+    s.nextTokenWithinRule!.setReadonly(true);\n+    return s.nextTokenWithinRule!;\n   }\n \n-  void addState(ATNState state) {\n+  void addState(ATNState? state) {\n     if (state != null) {\n       state.atn = this;\n       state.stateNumber = states.length;\n@@ -92,9 +92,9 @@ class ATN {\n     return s.decision;\n   }\n \n-  DecisionState getDecisionState(int decision) {\n-    if (decisionToState.isNotEmpty) {\n-      return decisionToState[decision];\n+  DecisionState? getDecisionState(int? decision) {\n+    if (decisionToState.isNotEmpty || decision != null) {\n+      return decisionToState[decision!];\n     }\n     return null;\n   }\n@@ -135,13 +135,13 @@ class ATN {\n   /// specified state in the specified context.\n   /// @throws IllegalArgumentException if the ATN does not contain a state with\n   /// number [stateNumber]\n-  IntervalSet getExpectedTokens(int stateNumber, RuleContext context) {\n+  IntervalSet getExpectedTokens(int stateNumber, RuleContext? context) {\n     if (stateNumber < 0 || stateNumber >= states.length) {\n       throw RangeError.index(stateNumber, states, 'stateNumber');\n     }\n \n     var ctx = context;\n-    final s = states[stateNumber];\n+    final s = states[stateNumber]!;\n     var following = nextTokens(s);\n     if (!following.contains(Token.EPSILON)) {\n       return following;\n@@ -153,8 +153,9 @@ class ATN {\n     while (ctx != null &&\n         ctx.invokingState >= 0 &&\n         following.contains(Token.EPSILON)) {\n-      final invokingState = states[ctx.invokingState];\n-      RuleTransition rt = invokingState.transition(0);\n+      final invokingState = states[ctx.invokingState]!;\n+\n+      final rt = invokingState.transition(0) as RuleTransition;\n       following = nextTokens(rt.followState);\n       expected.addAll(following);\n       expected.remove(Token.EPSILON);"
  },
  {
    "sha": "2b414fa9a1cc6ef1f69dfd84d3989f76d3ba1a02",
    "filename": "runtime/Dart/lib/src/atn/src/atn_config.dart",
    "status": "modified",
    "additions": 36,
    "deletions": 25,
    "changes": 61,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/atn_config.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/atn_config.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/atn/src/atn_config.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -5,7 +5,6 @@\n  */\n \n import '../../prediction_context.dart';\n-import '../../recognizer.dart';\n import '../../util/murmur_hash.dart';\n import 'atn_state.dart';\n import 'lexer_action_executor.dart';\n@@ -59,7 +58,7 @@ class ATNConfig {\n   /// The stack of invoking states leading to the rule/states associated\n   ///  with this config.  We track only those contexts pushed during\n   ///  execution of the ATN simulator.\n-  PredictionContext context;\n+  PredictionContext? context;\n \n   /// We cannot execute predicates dependent upon local context unless\n   /// we know for sure we are in the correct context. Because there is\n@@ -82,22 +81,28 @@ class ATNConfig {\n   /// constructors as well as certain operations like\n   /// {@link ATNConfigSet#add(ATNConfig, DoubleKeyMap)} method are\n   /// <em>completely</em> unaffected by the change.</p>\n-  int reachesIntoOuterContext = 0;\n+  int reachesIntoOuterContext;\n \n   SemanticContext semanticContext;\n \n-  ATNConfig(this.state, this.alt, this.context,\n-      [this.semanticContext = SemanticContext.NONE]);\n-\n-  ATNConfig.dup(ATNConfig c,\n-      {this.state, this.alt, this.context, this.semanticContext}) {\n-    state = state ?? c.state;\n-    alt = alt ?? c.alt;\n-    context = context ?? c.context;\n-    semanticContext = semanticContext ?? c.semanticContext;\n-    reachesIntoOuterContext =\n-        c.reachesIntoOuterContext ?? reachesIntoOuterContext;\n-  }\n+  ATNConfig(\n+    this.state,\n+    this.alt,\n+    this.context, [\n+    this.semanticContext = SemanticContext.NONE,\n+  ]) : reachesIntoOuterContext = 0;\n+\n+  ATNConfig.dup(\n+    ATNConfig c, {\n+    ATNState? state,\n+    int? alt,\n+    PredictionContext? context,\n+    SemanticContext? semanticContext,\n+  })  : state = state ?? c.state,\n+        alt = alt ?? c.alt,\n+        context = context ?? c.context,\n+        semanticContext = semanticContext ?? c.semanticContext,\n+        reachesIntoOuterContext = c.reachesIntoOuterContext;\n \n   /// This method gets the value of the {@link #reachesIntoOuterContext} field\n   /// as it existed prior to the introduction of the\n@@ -123,7 +128,7 @@ class ATNConfig {\n   ///  syntactic/semantic contexts are the same.\n   @override\n   bool operator ==(Object other) {\n-    if (other is ATNConfig && other != null) {\n+    if (other is ATNConfig) {\n       return state.stateNumber == other.state.stateNumber &&\n           alt == other.alt &&\n           (context == other.context ||\n@@ -147,7 +152,7 @@ class ATNConfig {\n   }\n \n   @override\n-  String toString([Recognizer recog, bool showAlt = true]) {\n+  String toString([_, bool showAlt = true]) {\n     final buf = StringBuffer();\n     // if ( state.ruleIndex>=0 ) {\n     //  if ( recog!=null ) buf.write(recog.ruleNames[state.ruleIndex]+\":\");\n@@ -164,7 +169,7 @@ class ATNConfig {\n       buf.write(context.toString());\n       buf.write(']');\n     }\n-    if (semanticContext != null && semanticContext != SemanticContext.NONE) {\n+    if (semanticContext != SemanticContext.NONE) {\n       buf.write(',');\n       buf.write(semanticContext);\n     }\n@@ -180,19 +185,25 @@ class ATNConfig {\n class LexerATNConfig extends ATNConfig {\n   /// Gets the [LexerActionExecutor] capable of executing the embedded\n   /// action(s) for the current configuration.\n-  LexerActionExecutor lexerActionExecutor;\n+  LexerActionExecutor? lexerActionExecutor;\n \n   bool passedThroughNonGreedyDecision = false;\n \n-  LexerATNConfig(ATNState state, int alt, PredictionContext context,\n-      [this.lexerActionExecutor])\n-      : super(state, alt, context, SemanticContext.NONE) {\n+  LexerATNConfig(\n+    ATNState state,\n+    int alt,\n+    PredictionContext context, [\n+    this.lexerActionExecutor,\n+  ]) : super(state, alt, context, SemanticContext.NONE) {\n     passedThroughNonGreedyDecision = false;\n   }\n \n-  LexerATNConfig.dup(LexerATNConfig c, ATNState state,\n-      {this.lexerActionExecutor, PredictionContext context})\n-      : super.dup(c, state: state, context: context) {\n+  LexerATNConfig.dup(\n+    LexerATNConfig c,\n+    ATNState state, {\n+    this.lexerActionExecutor,\n+    PredictionContext? context,\n+  }) : super.dup(c, state: state, context: context) {\n     lexerActionExecutor = lexerActionExecutor ?? c.lexerActionExecutor;\n     passedThroughNonGreedyDecision = checkNonGreedyDecision(c, state);\n   }"
  },
  {
    "sha": "78f3d1593d152af72ae38880f50472de35676f5e",
    "filename": "runtime/Dart/lib/src/atn/src/atn_config_set.dart",
    "status": "modified",
    "additions": 41,
    "deletions": 33,
    "changes": 74,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/atn_config_set.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/atn_config_set.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/atn/src/atn_config_set.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -18,6 +18,18 @@ import 'atn_config.dart';\n import 'atn_state.dart';\n import 'semantic_context.dart';\n \n+final defaultConfigLookup = () => HashSet<ATNConfig>(equals: (a, b) {\n+      return a.state.stateNumber == b.state.stateNumber &&\n+          a.alt == b.alt &&\n+          a.semanticContext == b.semanticContext;\n+    }, hashCode: (ATNConfig o) {\n+      var hashCode = 7;\n+      hashCode = 31 * hashCode + o.state.stateNumber;\n+      hashCode = 31 * hashCode + o.alt;\n+      hashCode = 31 * hashCode + o.semanticContext.hashCode;\n+      return hashCode;\n+    });\n+\n class ATNConfigSet extends Iterable<ATNConfig> {\n   /// Indicates that the set of configurations is read-only. Do not\n   ///  allow any code to manipulate the set; DFA states will point at\n@@ -32,6 +44,8 @@ class ATNConfigSet extends Iterable<ATNConfig> {\n     _readOnly = readOnly;\n     if (readOnly) {\n       configLookup = null; // can't mod, no need for lookup cache\n+    } else {\n+      configLookup = defaultConfigLookup();\n     }\n   }\n \n@@ -43,18 +57,7 @@ class ATNConfigSet extends Iterable<ATNConfig> {\n   ///\n   /// All configs but hashed by (s, i, _, pi) not including context. Wiped out\n   /// when we go readonly as this set becomes a DFA state.\n-  Set<ATNConfig> configLookup = HashSet<ATNConfig>(equals: (a, b) {\n-    if (a == null || b == null) return false;\n-    return a.state.stateNumber == b.state.stateNumber &&\n-        a.alt == b.alt &&\n-        a.semanticContext == b.semanticContext;\n-  }, hashCode: (ATNConfig o) {\n-    var hashCode = 7;\n-    hashCode = 31 * hashCode + o.state.stateNumber;\n-    hashCode = 31 * hashCode + o.alt;\n-    hashCode = 31 * hashCode + o.semanticContext.hashCode;\n-    return hashCode;\n-  });\n+  Set<ATNConfig>? configLookup = defaultConfigLookup();\n \n   /// Track the elements as they are added to the set; supports get(i) */\n   final List<ATNConfig> configs = [];\n@@ -67,7 +70,7 @@ class ATNConfigSet extends Iterable<ATNConfig> {\n   ///  not necessarily represent the ambiguous alternatives. In fact,\n   ///  I should also point out that this seems to include predicated alternatives\n   ///  that have predicates that evaluate to false. Computed in computeTargetState().\n-  BitSet conflictingAlts;\n+  BitSet? conflictingAlts;\n \n   // Used in parser and lexer. In lexer, it indicates we hit a pred\n   // while computing a closure operation.  Don't make a DFA state from this.\n@@ -83,13 +86,13 @@ class ATNConfigSet extends Iterable<ATNConfig> {\n \n   ATNConfigSet([this.fullCtx = true]);\n \n-  ATNConfigSet.dup(ATNConfigSet old) {\n-    fullCtx = old.fullCtx;\n+  ATNConfigSet.dup(ATNConfigSet old)\n+      : fullCtx = old.fullCtx,\n+        uniqueAlt = old.uniqueAlt,\n+        conflictingAlts = old.conflictingAlts,\n+        hasSemanticContext = old.hasSemanticContext,\n+        dipsIntoOuterContext = old.dipsIntoOuterContext {\n     addAll(old);\n-    uniqueAlt = old.uniqueAlt;\n-    conflictingAlts = old.conflictingAlts;\n-    hasSemanticContext = old.hasSemanticContext;\n-    dipsIntoOuterContext = old.dipsIntoOuterContext;\n   }\n \n   /// Adding a new config means merging contexts with existing configs for\n@@ -100,28 +103,34 @@ class ATNConfigSet extends Iterable<ATNConfig> {\n   ///\n   /// <p>This method updates {@link #dipsIntoOuterContext} and\n   /// {@link #hasSemanticContext} when necessary.</p>\n-  bool add(ATNConfig config,\n-      [Map<Pair<PredictionContext, PredictionContext>, PredictionContext>\n-          mergeCache]) {\n+  bool add(\n+    ATNConfig config, [\n+    Map<Pair<PredictionContext, PredictionContext>, PredictionContext>?\n+        mergeCache,\n+  ]) {\n     if (readOnly) throw StateError('This set is readonly');\n     if (config.semanticContext != SemanticContext.NONE) {\n       hasSemanticContext = true;\n     }\n     if (config.outerContextDepth > 0) {\n       dipsIntoOuterContext = true;\n     }\n-    final existing = configLookup.lookup(config) ?? config;\n+    final existing = configLookup!.lookup(config) ?? config;\n     if (identical(existing, config)) {\n       // we added this new one\n       cachedHashCode = -1;\n-      configLookup.add(config);\n+      configLookup!.add(config);\n       configs.add(config); // track order here\n       return true;\n     }\n     // a previous (s,i,pi,_), merge with it and save result\n     final rootIsWildcard = !fullCtx;\n     final merged = PredictionContext.merge(\n-        existing.context, config.context, rootIsWildcard, mergeCache);\n+      existing.context!,\n+      config.context!,\n+      rootIsWildcard,\n+      mergeCache,\n+    );\n     // no need to check for existing.context, config.context in cache\n     // since only way to create new graphs is \"call rule\" and here. We\n     // cache at both places.\n@@ -164,8 +173,8 @@ class ATNConfigSet extends Iterable<ATNConfig> {\n     return alts;\n   }\n \n-  List<SemanticContext> get predicates {\n-    final preds = <SemanticContext>[];\n+  List<SemanticContext?> get predicates {\n+    final preds = <SemanticContext?>[];\n     for (var c in configs) {\n       if (c.semanticContext != SemanticContext.NONE) {\n         preds.add(c.semanticContext);\n@@ -181,11 +190,11 @@ class ATNConfigSet extends Iterable<ATNConfig> {\n   void optimizeConfigs(interpreter) {\n     if (readOnly) throw StateError('This set is readonly');\n \n-    if (configLookup.isEmpty) return;\n+    if (configLookup!.isEmpty) return;\n \n     for (var config in configs) {\n //\t\t\tint before = PredictionContext.getAllContextNodes(config.context).length;\n-      config.context = interpreter.getCachedContext(config.context);\n+      config.context = interpreter!.getCachedContext(config.context);\n //\t\t\tint after = PredictionContext.getAllContextNodes(config.context).length;\n //\t\t\tSystem.out.println(\"configs \"+before+\"->\"+after);\n     }\n@@ -202,7 +211,6 @@ class ATNConfigSet extends Iterable<ATNConfig> {\n   bool operator ==(other) {\n     return identical(this, other) ||\n         (other is ATNConfigSet &&\n-            other != null &&\n             ListEquality().equals(configs, other.configs) &&\n             fullCtx == other.fullCtx &&\n             uniqueAlt == other.uniqueAlt &&\n@@ -244,13 +252,13 @@ class ATNConfigSet extends Iterable<ATNConfig> {\n   }\n \n   @override\n-  bool contains(Object o) {\n+  bool contains(Object? o) {\n     if (configLookup == null) {\n       throw UnsupportedError(\n           'This method is not implemented for readonly sets.');\n     }\n \n-    return configLookup.contains(o);\n+    return configLookup!.contains(o);\n   }\n \n   @override\n@@ -260,7 +268,7 @@ class ATNConfigSet extends Iterable<ATNConfig> {\n     if (readOnly) throw StateError('This set is readonly');\n     configs.clear();\n     cachedHashCode = -1;\n-    configLookup.clear();\n+    configLookup!.clear();\n   }\n \n   @override"
  },
  {
    "sha": "643e9f0b666d3d6fd99bd57f8052d9cdaca4287f",
    "filename": "runtime/Dart/lib/src/atn/src/atn_deserializer.dart",
    "status": "modified",
    "additions": 124,
    "deletions": 92,
    "changes": 216,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/atn_deserializer.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/atn_deserializer.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/atn/src/atn_deserializer.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -14,21 +14,21 @@ import 'lexer_action.dart';\n import 'transition.dart';\n \n class ATNDeserializationOptions {\n-  static final ATNDeserializationOptions defaultOptions =\n-      ATNDeserializationOptions()..makeReadOnly();\n+  static late final ATNDeserializationOptions defaultOptions =\n+      ATNDeserializationOptions(true);\n \n   bool readOnly;\n-  bool verifyATN;\n-  bool generateRuleBypassTransitions;\n+  late bool verifyATN;\n+  late bool generateRuleBypassTransitions;\n \n-  ATNDeserializationOptions([ATNDeserializationOptions options]) {\n+  ATNDeserializationOptions(this.readOnly,\n+      [ATNDeserializationOptions? options]) {\n     if (options == null) {\n       verifyATN = true;\n       generateRuleBypassTransitions = false;\n     } else {\n       verifyATN = options.verifyATN;\n-      generateRuleBypassTransitions =\n-          options.generateRuleBypassTransitions;\n+      generateRuleBypassTransitions = options.generateRuleBypassTransitions;\n     }\n   }\n \n@@ -73,6 +73,7 @@ class ATNDeserializer {\n   /** WARNING: DO NOT MERGE THESE LINES. If UUIDs differ during a merge,\n    * resolve the conflict by generating a new ID!\n    */\n+\n   /// This is the earliest supported serialized UUID.\n   static final BASE_SERIALIZED_UUID = '33761B2D-78BB-4A43-8B0B-4F5BEE8AACF3';\n \n@@ -103,12 +104,12 @@ class ATNDeserializer {\n   /// This is the current serialized UUID.\n   static final SERIALIZED_UUID = ADDED_UNICODE_SMP;\n \n-  ATNDeserializationOptions deserializationOptions;\n-  List<int> data;\n-  var pos;\n-  String uuid;\n+  late final ATNDeserializationOptions deserializationOptions;\n+  late List<int> data;\n+  int pos = 0;\n+  late String uuid;\n \n-  ATNDeserializer([options]) {\n+  ATNDeserializer([ATNDeserializationOptions? options]) {\n     deserializationOptions =\n         options ?? ATNDeserializationOptions.defaultOptions;\n   }\n@@ -266,39 +267,39 @@ class ATNDeserializer {\n   void readRules(ATN atn) {\n     final nrules = readInt();\n     if (atn.grammarType == ATNType.LEXER) {\n-      atn.ruleToTokenType = List<int>(nrules);\n+      atn.ruleToTokenType =\n+          List<int>.filled(nrules, 0); //Todo: keep an eye on this zero\n     }\n \n-    atn.ruleToStartState = List<RuleStartState>(nrules);\n     for (var i = 0; i < nrules; i++) {\n       final s = readInt();\n-      RuleStartState startState = atn.states[s];\n-      atn.ruleToStartState[i] = startState;\n+      final startState = atn.states[s] as RuleStartState;\n+      atn.ruleToStartState.add(startState);\n       if (atn.grammarType == ATNType.LEXER) {\n         var tokenType = readInt();\n         if (tokenType == 0xFFFF) {\n           tokenType = Token.EOF;\n         }\n \n-        atn.ruleToTokenType[i] = tokenType;\n+        atn.ruleToTokenType![i] = tokenType;\n \n         if (!isFeatureSupported(ADDED_LEXER_ACTIONS, uuid)) {\n           // this piece of unused metadata was serialized prior to the\n           // addition of LexerAction\n-          final actionIndexIgnored = readInt();\n+          readInt();\n         }\n       }\n     }\n \n-    atn.ruleToStopState = List<RuleStopState>(nrules);\n+    atn.ruleToStopState = List<RuleStopState>.generate(\n+        nrules, (int index) => RuleStopState(index));\n+\n     for (var state in atn.states) {\n-      if (!(state is RuleStopState)) {\n+      if (state is! RuleStopState) {\n         continue;\n       }\n-\n-      RuleStopState stopState = state;\n-      atn.ruleToStopState[state.ruleIndex] = stopState;\n-      atn.ruleToStartState[state.ruleIndex].stopState = stopState;\n+      atn.ruleToStopState[state.ruleIndex] = state;\n+      atn.ruleToStartState[state.ruleIndex].stopState = state;\n     }\n   }\n \n@@ -339,18 +340,20 @@ class ATNDeserializer {\n       final arg1 = readInt();\n       final arg2 = readInt();\n       final arg3 = readInt();\n-      final trans =\n-          edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\n+      final trans = edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\n //\t\t\tSystem.out.println(\"EDGE \"+trans.getClass().getSimpleName()+\" \"+\n //\t\t\t\t\t\t\t   src+\"->\"+trg+\n //\t\t\t\t\t   \" \"+Transition.serializationNames[ttype]+\n //\t\t\t\t\t   \" \"+arg1+\",\"+arg2+\",\"+arg3);\n-      final srcState = atn.states[src];\n+      final srcState = atn.states[src]!;\n       srcState.addTransition(trans);\n     }\n \n     // edges for rule stop states can be derived, so they aren't serialized\n     for (var state in atn.states) {\n+      if (state == null) {\n+        continue;\n+      }\n       for (var i = 0; i < state.numberOfTransitions; i++) {\n         final t = state.transition(i);\n         if (t is RuleTransition) {\n@@ -379,11 +382,11 @@ class ATNDeserializer {\n         }\n \n         // block end states can only be associated to a single block start state\n-        if (state.endState.startState != null) {\n+        if (state.endState!.startState != null) {\n           throw StateError('');\n         }\n \n-        state.endState.startState = state;\n+        state.endState!.startState = state;\n       }\n \n       if (state is PlusLoopbackState) {\n@@ -410,7 +413,7 @@ class ATNDeserializer {\n     final ndecisions = readInt();\n     for (var i = 1; i <= ndecisions; i++) {\n       final s = readInt();\n-      DecisionState decState = atn.states[s];\n+      final decState = atn.states[s] as DecisionState;\n       atn.decisionToState.add(decState);\n       decState.decision = i - 1;\n     }\n@@ -419,8 +422,7 @@ class ATNDeserializer {\n   void readLexerActions(ATN atn) {\n     if (atn.grammarType == ATNType.LEXER) {\n       if (isFeatureSupported(ADDED_LEXER_ACTIONS, uuid)) {\n-        atn.lexerActions = List<LexerAction>(readInt());\n-        for (var i = 0; i < atn.lexerActions.length; i++) {\n+        atn.lexerActions = List<LexerAction>.generate(readInt(), (index) {\n           final actionType = LexerActionType.values[readInt()];\n           var data1 = readInt();\n           if (data1 == 0xFFFF) {\n@@ -431,24 +433,25 @@ class ATNDeserializer {\n           if (data2 == 0xFFFF) {\n             data2 = -1;\n           }\n-          final lexerAction =\n-              lexerActionFactory(actionType, data1, data2);\n+          final lexerAction = lexerActionFactory(actionType, data1, data2);\n \n-          atn.lexerActions[i] = lexerAction;\n-        }\n+          return lexerAction;\n+        });\n       } else {\n         // for compatibility with older serialized ATNs, convert the old\n         // serialized action index for action transitions to the new\n         // form, which is the index of a LexerCustomAction\n         final legacyLexerActions = <LexerAction>[];\n         for (var state in atn.states) {\n+          if (state == null) {\n+            continue;\n+          }\n           for (var i = 0; i < state.numberOfTransitions; i++) {\n             final transition = state.transition(i);\n             if (transition is ActionTransition) {\n               final ruleIndex = transition.ruleIndex;\n               final actionIndex = transition.actionIndex;\n-              final lexerAction =\n-                  LexerCustomAction(ruleIndex, actionIndex);\n+              final lexerAction = LexerCustomAction(ruleIndex, actionIndex);\n               state.setTransition(\n                   i,\n                   ActionTransition(transition.target, ruleIndex,\n@@ -465,44 +468,46 @@ class ATNDeserializer {\n \n   void generateRuleBypassTransitions(ATN atn) {\n     for (var i = 0; i < atn.ruleToStartState.length; i++) {\n-      atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\n+      //Todo: I didnt get why ruleToTokenType is called here since it can be null if we are in a PARSER\n+      atn.ruleToTokenType![i] = atn.maxTokenType + i + 1;\n     }\n     for (var i = 0; i < atn.ruleToStartState.length; i++) {\n       generateRuleBypassTransition(atn, i);\n     }\n   }\n \n   void generateRuleBypassTransition(ATN atn, int idx) {\n-    final bypassStart = BasicBlockStartState();\n-    bypassStart.ruleIndex = idx;\n+    final bypassStart = BasicBlockStartState(idx);\n     atn.addState(bypassStart);\n \n-    final bypassStop = BlockEndState();\n-    bypassStop.ruleIndex = idx;\n+    final bypassStop = BlockEndState(idx);\n     atn.addState(bypassStop);\n \n     bypassStart.endState = bypassStop;\n     atn.defineDecisionState(bypassStart);\n \n     bypassStop.startState = bypassStart;\n \n-    ATNState endState;\n-    Transition excludeTransition;\n+    ATNState? endState;\n+    Transition? excludeTransition;\n     if (atn.ruleToStartState[idx].isLeftRecursiveRule) {\n       // wrap from the beginning of the rule to the StarLoopEntryState\n       endState = null;\n       for (var state in atn.states) {\n+        if (state == null) {\n+          continue;\n+        }\n         if (state.ruleIndex != idx) {\n           continue;\n         }\n \n-        if (!(state is StarLoopEntryState)) {\n+        if (state is! StarLoopEntryState) {\n           continue;\n         }\n \n         final maybeLoopEndState =\n             state.transition(state.numberOfTransitions - 1).target;\n-        if (!(maybeLoopEndState is LoopEndState)) {\n+        if (maybeLoopEndState is! LoopEndState) {\n           continue;\n         }\n \n@@ -515,17 +520,21 @@ class ATNDeserializer {\n \n       if (endState == null) {\n         throw UnsupportedError(\n-            \"Couldn't identify final state of the precedence rule prefix section.\");\n+          \"Couldn't identify final state of the precedence rule prefix section.\",\n+        );\n       }\n \n       excludeTransition =\n-          (endState as StarLoopEntryState).loopBackState.transition(0);\n+          (endState as StarLoopEntryState).loopBackState!.transition(0);\n     } else {\n       endState = atn.ruleToStopState[idx];\n     }\n \n     // all non-excluded transitions that currently target end state need to target blockEnd instead\n     for (var state in atn.states) {\n+      if (state == null) {\n+        continue;\n+      }\n       for (var transition in state.transitions) {\n         if (transition == excludeTransition) {\n           continue;\n@@ -539,19 +548,24 @@ class ATNDeserializer {\n \n     // all transitions leaving the rule start state need to leave blockStart instead\n     while (atn.ruleToStartState[idx].numberOfTransitions > 0) {\n-      final transition = atn.ruleToStartState[idx].removeTransition(\n-          atn.ruleToStartState[idx].numberOfTransitions - 1);\n+      final transition = atn.ruleToStartState[idx]\n+          .removeTransition(atn.ruleToStartState[idx].numberOfTransitions - 1);\n       bypassStart.addTransition(transition);\n     }\n \n     // link the new states\n     atn.ruleToStartState[idx].addTransition(EpsilonTransition(bypassStart));\n     bypassStop.addTransition(EpsilonTransition(endState));\n \n-    ATNState matchState = BasicState();\n+    // Todo: review this idx passed to this rule\n+    ATNState matchState = BasicState(idx);\n     atn.addState(matchState);\n-    matchState.addTransition(\n-        AtomTransition(bypassStop, atn.ruleToTokenType[idx]));\n+\n+    //Todo: I didnt get why ruleToTokenType is called here since it can be null if we are in a PARSER\n+    matchState.addTransition(AtomTransition(\n+      bypassStop,\n+      atn.ruleToTokenType![idx],\n+    ));\n     bypassStart.addTransition(EpsilonTransition(matchState));\n   }\n \n@@ -588,8 +602,8 @@ class ATNDeserializer {\n         continue;\n       }\n \n-      checkCondition(state.onlyHasEpsilonTransitions() ||\n-          state.numberOfTransitions <= 1);\n+      checkCondition(\n+          state.onlyHasEpsilonTransitions() || state.numberOfTransitions <= 1);\n \n       if (state is PlusBlockStartState) {\n         checkCondition(state.loopBackState != null);\n@@ -667,29 +681,50 @@ class ATNDeserializer {\n     return (low & 0x00000000FFFFFFFF) | (high << 32);\n   }\n \n-  static final byteToHex  = List.generate(256, (i) => i.toRadixString(16).padLeft(2, '0').toUpperCase());\n+  static final byteToHex = List.generate(\n+      256, (i) => i.toRadixString(16).padLeft(2, '0').toUpperCase());\n \n   String readUUID() {\n-    final bb = List<int>(16);\n+    final bb = List<int>.filled(16, 0); // Todo: keep an eye on this zero\n+\n     for (var i = 7; i >= 0; i--) {\n       final int = readInt();\n-      /* jshint bitwise: false */\n       bb[(2 * i) + 1] = int & 0xFF;\n       bb[2 * i] = (int >> 8) & 0xFF;\n     }\n-    return byteToHex[bb[0]] + byteToHex[bb[1]] +\n-        byteToHex[bb[2]] + byteToHex[bb[3]] + '-' +\n-        byteToHex[bb[4]] + byteToHex[bb[5]] + '-' +\n-        byteToHex[bb[6]] + byteToHex[bb[7]] + '-' +\n-        byteToHex[bb[8]] + byteToHex[bb[9]] + '-' +\n-        byteToHex[bb[10]] + byteToHex[bb[11]] +\n-        byteToHex[bb[12]] + byteToHex[bb[13]] +\n-        byteToHex[bb[14]] + byteToHex[bb[15]];\n-  }\n-\n-  Transition edgeFactory(ATN atn, TransitionType type, int src, int trg,\n-      int arg1, int arg2, int arg3, List<IntervalSet> sets) {\n-    final target = atn.states[trg];\n+    return byteToHex[bb[0]] +\n+        byteToHex[bb[1]] +\n+        byteToHex[bb[2]] +\n+        byteToHex[bb[3]] +\n+        '-' +\n+        byteToHex[bb[4]] +\n+        byteToHex[bb[5]] +\n+        '-' +\n+        byteToHex[bb[6]] +\n+        byteToHex[bb[7]] +\n+        '-' +\n+        byteToHex[bb[8]] +\n+        byteToHex[bb[9]] +\n+        '-' +\n+        byteToHex[bb[10]] +\n+        byteToHex[bb[11]] +\n+        byteToHex[bb[12]] +\n+        byteToHex[bb[13]] +\n+        byteToHex[bb[14]] +\n+        byteToHex[bb[15]];\n+  }\n+\n+  Transition edgeFactory(\n+    ATN atn,\n+    TransitionType type,\n+    int src,\n+    int trg,\n+    int arg1,\n+    int arg2,\n+    int arg3,\n+    List<IntervalSet> sets,\n+  ) {\n+    final target = atn.states[trg]!;\n     switch (type) {\n       case TransitionType.EPSILON:\n         return EpsilonTransition(target);\n@@ -698,12 +733,11 @@ class ATNDeserializer {\n             ? RangeTransition(target, Token.EOF, arg2)\n             : RangeTransition(target, arg1, arg2);\n       case TransitionType.RULE:\n-        final rt =\n-            RuleTransition(atn.states[arg1], arg2, arg3, target);\n+        final rt = RuleTransition(\n+            atn.states[arg1] as RuleStartState, arg2, arg3, target);\n         return rt;\n       case TransitionType.PREDICATE:\n-        final pt =\n-            PredicateTransition(target, arg1, arg2, arg3 != 0);\n+        final pt = PredicateTransition(target, arg1, arg2, arg3 != 0);\n         return pt;\n       case TransitionType.PRECEDENCE:\n         return PrecedencePredicateTransition(target, arg1);\n@@ -712,8 +746,7 @@ class ATNDeserializer {\n             ? AtomTransition(target, Token.EOF)\n             : AtomTransition(target, arg1);\n       case TransitionType.ACTION:\n-        final a =\n-            ActionTransition(target, arg1, arg2, arg3 != 0);\n+        final a = ActionTransition(target, arg1, arg2, arg3 != 0);\n         return a;\n       case TransitionType.SET:\n         return SetTransition(target, sets[arg1]);\n@@ -728,52 +761,51 @@ class ATNDeserializer {\n     }\n   }\n \n-  ATNState stateFactory(StateType type, int ruleIndex) {\n+  ATNState? stateFactory(StateType type, int ruleIndex) {\n     ATNState s;\n     switch (type) {\n       case StateType.INVALID_TYPE:\n         return null;\n       case StateType.BASIC:\n-        s = BasicState();\n+        s = BasicState(ruleIndex);\n         break;\n       case StateType.RULE_START:\n-        s = RuleStartState();\n+        s = RuleStartState(ruleIndex);\n         break;\n       case StateType.BLOCK_START:\n-        s = BasicBlockStartState();\n+        s = BasicBlockStartState(ruleIndex);\n         break;\n       case StateType.PLUS_BLOCK_START:\n-        s = PlusBlockStartState();\n+        s = PlusBlockStartState(ruleIndex);\n         break;\n       case StateType.STAR_BLOCK_START:\n-        s = StarBlockStartState();\n+        s = StarBlockStartState(ruleIndex);\n         break;\n       case StateType.TOKEN_START:\n-        s = TokensStartState();\n+        s = TokensStartState(ruleIndex);\n         break;\n       case StateType.RULE_STOP:\n-        s = RuleStopState();\n+        s = RuleStopState(ruleIndex);\n         break;\n       case StateType.BLOCK_END:\n-        s = BlockEndState();\n+        s = BlockEndState(ruleIndex);\n         break;\n       case StateType.STAR_LOOP_BACK:\n-        s = StarLoopbackState();\n+        s = StarLoopbackState(ruleIndex);\n         break;\n       case StateType.STAR_LOOP_ENTRY:\n-        s = StarLoopEntryState();\n+        s = StarLoopEntryState(ruleIndex);\n         break;\n       case StateType.PLUS_LOOP_BACK:\n-        s = PlusLoopbackState();\n+        s = PlusLoopbackState(ruleIndex);\n         break;\n       case StateType.LOOP_END:\n-        s = LoopEndState();\n+        s = LoopEndState(ruleIndex);\n         break;\n       default:\n         throw ArgumentError.value(type, 'state type', 'not valid.');\n     }\n \n-    s.ruleIndex = ruleIndex;\n     return s;\n   }\n "
  },
  {
    "sha": "4497d23f60c6efa3b00216730f6452b21b4a1e30",
    "filename": "runtime/Dart/lib/src/atn/src/atn_simulator.dart",
    "status": "modified",
    "additions": 7,
    "deletions": 6,
    "changes": 13,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/atn_simulator.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/atn_simulator.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/atn/src/atn_simulator.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -12,8 +12,10 @@ import 'atn_config_set.dart';\n abstract class ATNSimulator {\n   /// Must distinguish between missing edge and edge we know leads nowhere */\n \n-  static final DFAState ERROR =\n-      DFAState(stateNumber: 0x7FFFFFFF, configs: ATNConfigSet());\n+  static final DFAState ERROR = DFAState(\n+    stateNumber: 0x7FFFFFFF,\n+    configs: ATNConfigSet(),\n+  );\n \n   final ATN atn;\n \n@@ -36,7 +38,7 @@ abstract class ATNSimulator {\n   ///  whacked after each adaptivePredict(). It cost a little bit\n   ///  more time I think and doesn't save on the overall footprint\n   ///  so it's not worth the complexity.</p>\n-  final PredictionContextCache sharedContextCache;\n+  final PredictionContextCache? sharedContextCache;\n \n   ATNSimulator(this.atn, this.sharedContextCache);\n \n@@ -60,8 +62,7 @@ abstract class ATNSimulator {\n     if (sharedContextCache == null) return context;\n \n     final visited = <PredictionContext, PredictionContext>{};\n-    return PredictionContext.getCachedContext(\n-        context, sharedContextCache, visited);\n+    return PredictionContext.getCachedContext(context, sharedContextCache!, visited);\n   }\n }\n \n@@ -85,7 +86,7 @@ class PredictionContextCache {\n     return ctx;\n   }\n \n-  PredictionContext operator [](PredictionContext ctx) {\n+  PredictionContext? operator [](PredictionContext ctx) {\n     return cache[ctx];\n   }\n "
  },
  {
    "sha": "4d2a40611a41cafeed63e260a3b6e1ba570d18dd",
    "filename": "runtime/Dart/lib/src/atn/src/atn_state.dart",
    "status": "modified",
    "additions": 38,
    "deletions": 8,
    "changes": 46,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/atn_state.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/atn_state.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/atn/src/atn_state.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -94,7 +94,7 @@ abstract class ATNState {\n   static final int INVALID_STATE_NUMBER = -1;\n \n   /// Which ATN are we in? */\n-  ATN atn;\n+  late ATN atn;\n \n   int stateNumber = INVALID_STATE_NUMBER;\n \n@@ -106,7 +106,9 @@ abstract class ATNState {\n   List<Transition> transitions = [];\n \n   /// Used to cache lookahead during parsing, not used during construction */\n-  IntervalSet nextTokenWithinRule;\n+  IntervalSet? nextTokenWithinRule;\n+\n+  ATNState(this.ruleIndex);\n \n   @override\n   int get hashCode {\n@@ -187,6 +189,8 @@ abstract class ATNState {\n }\n \n class BasicState extends ATNState {\n+  BasicState(int ruleIndex) : super(ruleIndex);\n+\n   @override\n   StateType get stateType => StateType.BASIC;\n }\n@@ -195,21 +199,29 @@ class RuleStartState extends ATNState {\n   var stopState;\n   var isLeftRecursiveRule = false;\n \n+  RuleStartState(int ruleIndex) : super(ruleIndex);\n+\n   @override\n   StateType get stateType => StateType.RULE_START;\n }\n \n abstract class DecisionState extends ATNState {\n   int decision = 0;\n   bool nonGreedy = false;\n+\n+  DecisionState(int ruleIndex) : super(ruleIndex);\n }\n \n //  The start of a regular {@code (...)} block.\n abstract class BlockStartState extends DecisionState {\n-  BlockEndState endState;\n+  BlockEndState? endState;\n+\n+  BlockStartState(int ruleIndex) : super(ruleIndex);\n }\n \n class BasicBlockStartState extends BlockStartState {\n+  BasicBlockStartState(int ruleIndex) : super(ruleIndex);\n+\n   @override\n   StateType get stateType => StateType.BLOCK_START;\n }\n@@ -219,20 +231,26 @@ class BasicBlockStartState extends BlockStartState {\n ///  it for completeness. In reality, the [PlusLoopbackState] node is the\n ///  real decision-making note for {@code A+}.\n class PlusBlockStartState extends BlockStartState {\n-  PlusLoopbackState loopBackState;\n+  PlusLoopbackState? loopBackState;\n+\n+  PlusBlockStartState(int ruleIndex) : super(ruleIndex);\n \n   @override\n   StateType get stateType => StateType.PLUS_BLOCK_START;\n }\n \n /// The block that begins a closure loop.\n class StarBlockStartState extends BlockStartState {\n+  StarBlockStartState(int ruleIndex) : super(ruleIndex);\n+\n   @override\n   StateType get stateType => StateType.STAR_BLOCK_START;\n }\n \n /// The Tokens rule start state linking to each lexer rule start state */\n class TokensStartState extends DecisionState {\n+  TokensStartState(int ruleIndex) : super(ruleIndex);\n+\n   @override\n   StateType get stateType => StateType.TOKEN_START;\n }\n@@ -242,29 +260,35 @@ class TokensStartState extends DecisionState {\n ///  references to all calls to this rule to compute FOLLOW sets for\n ///  error handling.\n class RuleStopState extends ATNState {\n+  RuleStopState(int ruleIndex) : super(ruleIndex);\n+\n   @override\n   StateType get stateType => StateType.RULE_STOP;\n }\n \n /// Terminal node of a simple {@code (a|b|c)} block.\n class BlockEndState extends ATNState {\n-  BlockStartState startState;\n+  BlockStartState? startState;\n+\n+  BlockEndState(int ruleIndex) : super(ruleIndex);\n \n   @override\n   StateType get stateType => StateType.BLOCK_END;\n }\n \n class StarLoopbackState extends ATNState {\n+  StarLoopbackState(int ruleIndex) : super(ruleIndex);\n+\n   StarLoopEntryState get loopEntryState {\n-    return transition(0).target;\n+    return transition(0).target as StarLoopEntryState;\n   }\n \n   @override\n   StateType get stateType => StateType.STAR_LOOP_BACK;\n }\n \n class StarLoopEntryState extends DecisionState {\n-  StarLoopbackState loopBackState;\n+  StarLoopbackState? loopBackState;\n \n   /// Indicates whether this state can benefit from a precedence DFA during SLL\n   /// decision making.\n@@ -276,20 +300,26 @@ class StarLoopEntryState extends DecisionState {\n   /// @see DFA#isPrecedenceDfa()\n   bool isPrecedenceDecision = false;\n \n+  StarLoopEntryState(int ruleIndex) : super(ruleIndex);\n+\n   @override\n   StateType get stateType => StateType.STAR_LOOP_ENTRY;\n }\n \n /// Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:\n ///  one to the loop back to start of the block and one to exit.\n class PlusLoopbackState extends DecisionState {\n+  PlusLoopbackState(int ruleIndex) : super(ruleIndex);\n+\n   @override\n   StateType get stateType => StateType.PLUS_LOOP_BACK;\n }\n \n /// Mark the end of a * or + loop.\n class LoopEndState extends ATNState {\n-  ATNState loopBackState;\n+  ATNState? loopBackState;\n+\n+  LoopEndState(int ruleIndex) : super(ruleIndex);\n \n   @override\n   StateType get stateType => StateType.LOOP_END;"
  },
  {
    "sha": "f188fb684a15400b718a26b1d6bd10072a37183e",
    "filename": "runtime/Dart/lib/src/atn/src/info.dart",
    "status": "modified",
    "additions": 55,
    "deletions": 30,
    "changes": 85,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/info.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/info.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/atn/src/info.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -64,7 +64,7 @@ class DecisionEventInfo {\n   /// The configuration set containing additional information relevant to the\n   /// prediction state when the current event occurred, or null if no\n   /// additional information is relevant or available.\n-  final ATNConfigSet configs;\n+  final ATNConfigSet? configs;\n \n   /// The input token stream which is being parsed.\n   final TokenStream input;\n@@ -80,8 +80,14 @@ class DecisionEventInfo {\n   /// otherwise, [false] if the input occurred during SLL prediction.\n   final bool fullCtx;\n \n-  DecisionEventInfo(this.decision, this.configs, this.input, this.startIndex,\n-      this.stopIndex, this.fullCtx);\n+  DecisionEventInfo(\n+    this.decision,\n+    this.configs,\n+    this.input,\n+    this.startIndex,\n+    this.stopIndex,\n+    this.fullCtx,\n+  );\n }\n \n /// This class contains profiling gathered for a particular decision.\n@@ -96,12 +102,16 @@ class DecisionEventInfo {\n ///\n /// @since 4.3\n class DecisionInfo {\n+\n+  //  Todo: this class is full of int fields that are never initialized and somehow it call ++ on them in some places\n+  // I had to figure out some asumptions here\n+\n   /// The decision number, which is an index into {@link ATN#decisionToState}.\n   final int decision;\n \n   /// The total number of times {@link ParserATNSimulator#adaptivePredict} was\n   /// invoked for this decision.\n-  int invocations;\n+  int invocations = 0;\n \n   /// The total time spent in {@link ParserATNSimulator#adaptivePredict} for\n   /// this decision, in nanoseconds.\n@@ -115,50 +125,50 @@ class DecisionInfo {\n   /// which is warmed up by parsing the input prior to profiling. If desired,\n   /// call {@link ATNSimulator#clearDFA} to reset the DFA cache to its initial\n   /// state before starting the profiling measurement pass.</p>\n-  int timeInPrediction;\n+  int timeInPrediction = 0;\n \n   /// The sum of the lookahead required for SLL prediction for this decision.\n   /// Note that SLL prediction is used before LL prediction for performance\n   /// reasons even when {@link PredictionMode#LL} or\n   /// {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} is used.\n-  int SLL_TotalLook;\n+  int SLL_TotalLook = 0;\n \n   /// Gets the minimum lookahead required for any single SLL prediction to\n   /// complete for this decision, by reaching a unique prediction, reaching an\n   /// SLL conflict state, or encountering a syntax error.\n-  int SLL_MinLook;\n+  int SLL_MinLook = 0;\n \n   /// Gets the maximum lookahead required for any single SLL prediction to\n   /// complete for this decision, by reaching a unique prediction, reaching an\n   /// SLL conflict state, or encountering a syntax error.\n-  int SLL_MaxLook;\n+  int SLL_MaxLook = 0;\n \n   /// Gets the [LookaheadEventInfo] associated with the event where the\n   /// {@link #SLL_MaxLook} value was set.\n-  LookaheadEventInfo SLL_MaxLookEvent;\n+  LookaheadEventInfo? SLL_MaxLookEvent;\n \n   /// The sum of the lookahead required for LL prediction for this decision.\n   /// Note that LL prediction is only used when SLL prediction reaches a\n   /// conflict state.\n-  int LL_TotalLook;\n+  int LL_TotalLook = 0;\n \n   /// Gets the minimum lookahead required for any single LL prediction to\n   /// complete for this decision. An LL prediction completes when the algorithm\n   /// reaches a unique prediction, a conflict state (for\n   /// {@link PredictionMode#LL}, an ambiguity state (for\n   /// {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.\n-  int LL_MinLook;\n+  int LL_MinLook = 0;\n \n   /// Gets the maximum lookahead required for any single LL prediction to\n   /// complete for this decision. An LL prediction completes when the algorithm\n   /// reaches a unique prediction, a conflict state (for\n   /// {@link PredictionMode#LL}, an ambiguity state (for\n   /// {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.\n-  int LL_MaxLook;\n+  int LL_MaxLook = 0;\n \n   /// Gets the [LookaheadEventInfo] associated with the event where the\n   /// {@link #LL_MaxLook} value was set.\n-  LookaheadEventInfo LL_MaxLookEvent;\n+  LookaheadEventInfo? LL_MaxLookEvent;\n \n   /// A collection of [ContextSensitivityInfo] instances describing the\n   /// context sensitivities encountered during LL prediction for this decision.\n@@ -200,7 +210,7 @@ class DecisionInfo {\n   /// @see #SLL_ATNTransitions\n   /// @see ParserATNSimulator#computeTargetState\n   /// @see LexerATNSimulator#computeTargetState\n-  int SLL_ATNTransitions;\n+  int? SLL_ATNTransitions;\n \n   /// The total number of DFA transitions required during SLL prediction for\n   /// this decision.\n@@ -210,7 +220,7 @@ class DecisionInfo {\n   ///\n   /// @see ParserATNSimulator#getExistingTargetState\n   /// @see LexerATNSimulator#getExistingTargetState\n-  int SLL_DFATransitions;\n+  int? SLL_DFATransitions;\n \n   /// Gets the total number of times SLL prediction completed in a conflict\n   /// state, resulting in fallback to LL prediction.\n@@ -221,7 +231,7 @@ class DecisionInfo {\n   /// conflicts for this decision produce the same result as LL prediction for\n   /// this decision, {@link PredictionMode#SLL} would produce the same overall\n   /// parsing result as {@link PredictionMode#LL}.</p>\n-  int LL_Fallback;\n+  int? LL_Fallback;\n \n   /// The total number of ATN transitions required during LL prediction for\n   /// this decision. An ATN transition is determined by the number of times the\n@@ -237,7 +247,7 @@ class DecisionInfo {\n   /// @see #LL_DFATransitions\n   /// @see ParserATNSimulator#computeTargetState\n   /// @see LexerATNSimulator#computeTargetState\n-  int LL_ATNTransitions;\n+  int? LL_ATNTransitions;\n \n   /// The total number of DFA transitions required during LL prediction for\n   /// this decision.\n@@ -247,7 +257,7 @@ class DecisionInfo {\n   ///\n   /// @see ParserATNSimulator#getExistingTargetState\n   /// @see LexerATNSimulator#getExistingTargetState\n-  int LL_DFATransitions;\n+  int? LL_DFATransitions;\n \n   /// Constructs a new instance of the [DecisionInfo] class to contain\n   /// statistics for a particular decision.\n@@ -296,7 +306,7 @@ class DecisionInfo {\n /// @since 4.3\n class AmbiguityInfo extends DecisionEventInfo {\n   /// The set of alternative numbers for this decision event that lead to a valid parse. */\n-  BitSet ambigAlts;\n+  BitSet? ambigAlts;\n \n   /// Constructs a new instance of the [AmbiguityInfo] class with the\n   /// specified detailed ambiguity information.\n@@ -340,9 +350,14 @@ class ErrorInfo extends DecisionEventInfo {\n   /// @param fullCtx [true] if the syntax error was identified during LL\n   /// prediction; otherwise, [false] if the syntax error was identified\n   /// during SLL prediction\n-  ErrorInfo(int decision, ATNConfigSet configs, TokenStream input,\n-      int startIndex, int stopIndex, bool fullCtx)\n-      : super(decision, configs, input, startIndex, stopIndex, fullCtx);\n+  ErrorInfo(\n+    int decision,\n+    ATNConfigSet? configs,\n+    TokenStream input,\n+    int startIndex,\n+    int stopIndex,\n+    bool fullCtx,\n+  ) : super(decision, configs, input, startIndex, stopIndex, fullCtx);\n }\n \n /// This class represents profiling event information for tracking the lookahead\n@@ -369,9 +384,15 @@ class LookaheadEventInfo extends DecisionEventInfo {\n   /// @param fullCtx [true] if the current lookahead is part of an LL\n   /// prediction; otherwise, [false] if the current lookahead is part of\n   /// an SLL prediction\n-  LookaheadEventInfo(int decision, ATNConfigSet configs, this.predictedAlt,\n-      TokenStream input, int startIndex, int stopIndex, bool fullCtx)\n-      : super(decision, configs, input, startIndex, stopIndex, fullCtx);\n+  LookaheadEventInfo(\n+    int decision,\n+    ATNConfigSet? configs,\n+    this.predictedAlt,\n+    TokenStream input,\n+    int startIndex,\n+    int stopIndex,\n+    bool fullCtx,\n+  ) : super(decision, configs, input, startIndex, stopIndex, fullCtx);\n }\n \n /// This class represents profiling event information for semantic predicate\n@@ -453,7 +474,8 @@ class ParseInfo {\n     final decisions = atnSimulator.decisionInfo;\n     final LL = <int>[];\n     for (var i = 0; i < decisions.length; i++) {\n-      final fallBack = decisions[i].LL_Fallback;\n+      //Todo: i assumed if it is null we should not add it\n+      final fallBack = decisions[i].LL_Fallback ?? 0;\n       if (fallBack > 0) LL.add(i);\n     }\n     return LL;\n@@ -501,7 +523,8 @@ class ParseInfo {\n     final decisions = atnSimulator.decisionInfo;\n     var k = 0;\n     for (var i = 0; i < decisions.length; i++) {\n-      k += decisions[i].SLL_ATNTransitions;\n+      //Todo: I assumed if it is null we should not add it, this value is never initialized\n+      k += decisions[i].SLL_ATNTransitions ?? 0;\n     }\n     return k;\n   }\n@@ -512,7 +535,8 @@ class ParseInfo {\n     final decisions = atnSimulator.decisionInfo;\n     var k = 0;\n     for (var i = 0; i < decisions.length; i++) {\n-      k += decisions[i].LL_ATNTransitions;\n+      //Todo: I assumed if it is null we should not add it, this value is never initialized\n+      k += decisions[i].LL_ATNTransitions ?? 0;\n     }\n     return k;\n   }\n@@ -527,8 +551,9 @@ class ParseInfo {\n     final decisions = atnSimulator.decisionInfo;\n     var k = 0;\n     for (var i = 0; i < decisions.length; i++) {\n-      k += decisions[i].SLL_ATNTransitions;\n-      k += decisions[i].LL_ATNTransitions;\n+      //Todo: I assumed if it is null we should not add it, this value is never initialized\n+      k += decisions[i].SLL_ATNTransitions ?? 0;\n+      k += decisions[i].LL_ATNTransitions ?? 0;\n     }\n     return k;\n   }"
  },
  {
    "sha": "8fe02a09026bea38946dd31b029a5fbf3d2e8ffb",
    "filename": "runtime/Dart/lib/src/atn/src/lexer_action_executor.dart",
    "status": "modified",
    "additions": 14,
    "deletions": 10,
    "changes": 24,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/lexer_action_executor.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/lexer_action_executor.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/atn/src/lexer_action_executor.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -54,7 +54,9 @@ class LexerActionExecutor {\n   /// @return A [LexerActionExecutor] for executing the combine actions\n   /// of [lexerActionExecutor] and [lexerAction].\n   static LexerActionExecutor append(\n-      LexerActionExecutor lexerActionExecutor, LexerAction lexerAction) {\n+    LexerActionExecutor? lexerActionExecutor,\n+    LexerAction lexerAction,\n+  ) {\n     if (lexerActionExecutor == null) {\n       return LexerActionExecutor([lexerAction]);\n     }\n@@ -93,10 +95,10 @@ class LexerActionExecutor {\n   /// @return A [LexerActionExecutor] which stores input stream offsets\n   /// for all position-dependent lexer actions.\n   LexerActionExecutor fixOffsetBeforeMatch(int offset) {\n-    List<LexerAction> updatedLexerActions;\n+    List<LexerAction>? updatedLexerActions;\n     for (var i = 0; i < lexerActions.length; i++) {\n       if (lexerActions[i].isPositionDependent &&\n-          !(lexerActions[i] is LexerIndexedCustomAction)) {\n+          lexerActions[i] is! LexerIndexedCustomAction) {\n         updatedLexerActions ??= List.from(lexerActions);\n \n         updatedLexerActions[i] =\n@@ -134,9 +136,9 @@ class LexerActionExecutor {\n     try {\n       for (var lexerAction in lexerActions) {\n         if (lexerAction is LexerIndexedCustomAction) {\n-          final offset = (lexerAction as LexerIndexedCustomAction).offset;\n+          final offset = lexerAction.offset;\n           input.seek(startIndex + offset);\n-          lexerAction = (lexerAction as LexerIndexedCustomAction).action;\n+          lexerAction = lexerAction.action;\n           requiresSeek = (startIndex + offset) != stopIndex;\n         } else if (lexerAction.isPositionDependent) {\n           input.seek(stopIndex);\n@@ -153,15 +155,17 @@ class LexerActionExecutor {\n   }\n \n   @override\n-  bool operator ==(Object obj) {\n-    if (identical(obj, this)) {\n+  bool operator ==(Object other) {\n+    if (identical(other, this)) {\n       return true;\n-    } else if (!(obj is LexerActionExecutor)) {\n+    } else if (other is! LexerActionExecutor) {\n       return false;\n     }\n \n-    LexerActionExecutor other = obj;\n     return hashCode == other.hashCode &&\n-        ListEquality().equals(lexerActions, other.lexerActions);\n+        ListEquality().equals(\n+          lexerActions,\n+          other.lexerActions,\n+        );\n   }\n }"
  },
  {
    "sha": "87472b3f76410710a07e0113e522721c583c5d77",
    "filename": "runtime/Dart/lib/src/atn/src/lexer_atn_simulator.dart",
    "status": "modified",
    "additions": 106,
    "deletions": 72,
    "changes": 178,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/lexer_atn_simulator.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/lexer_atn_simulator.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/atn/src/lexer_atn_simulator.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -42,7 +42,7 @@ class SimState {\n   int line = 0;\n   int charPos = -1;\n \n-  DFAState dfaState;\n+  DFAState? dfaState;\n \n   void reset() {\n     index = -1;\n@@ -81,10 +81,12 @@ class LexerATNSimulator extends ATNSimulator {\n \n   final SimState prevAccept = SimState();\n \n-  LexerATNSimulator(ATN atn, this.decisionToDFA,\n-      PredictionContextCache sharedContextCache,\n-      {this.recog})\n-      : super(atn, sharedContextCache);\n+  LexerATNSimulator(\n+    ATN atn,\n+    this.decisionToDFA,\n+    PredictionContextCache sharedContextCache, {\n+    required this.recog,\n+  }) : super(atn, sharedContextCache);\n \n   void copyState(LexerATNSimulator simulator) {\n     charPositionInLine = simulator.charPositionInLine;\n@@ -103,7 +105,7 @@ class LexerATNSimulator extends ATNSimulator {\n       if (dfa.s0 == null) {\n         return matchATN(input);\n       } else {\n-        return execATN(input, dfa.s0);\n+        return execATN(input, dfa.s0!);\n       }\n     } finally {\n       input.release(mark);\n@@ -122,7 +124,7 @@ class LexerATNSimulator extends ATNSimulator {\n   @override\n   void clearDFA() {\n     for (var d = 0; d < decisionToDFA.length; d++) {\n-      decisionToDFA[d] = DFA(atn.getDecisionState(d), d);\n+      decisionToDFA[d] = DFA(atn.getDecisionState(d)!, d);\n     }\n   }\n \n@@ -165,7 +167,7 @@ class LexerATNSimulator extends ATNSimulator {\n       captureSimState(prevAccept, input, ds0);\n     }\n \n-    var t = input.LA(1);\n+    var t = input.LA(1)!;\n \n     var s = ds0; // s is current/from DFA state\n \n@@ -215,7 +217,7 @@ class LexerATNSimulator extends ATNSimulator {\n         }\n       }\n \n-      t = input.LA(1);\n+      t = input.LA(1)!;\n       s = target; // flip; current DFA target becomes new src/from state\n     }\n \n@@ -232,12 +234,12 @@ class LexerATNSimulator extends ATNSimulator {\n   /// [t], or null if the target state for this edge is not\n   /// already cached\n \n-  DFAState getExistingTargetState(DFAState s, int t) {\n+  DFAState? getExistingTargetState(DFAState s, int t) {\n     if (s.edges == null || t < MIN_DFA_EDGE || t > MAX_DFA_EDGE) {\n       return null;\n     }\n \n-    final target = s.edges[t - MIN_DFA_EDGE];\n+    final target = s.edges![t - MIN_DFA_EDGE];\n     if (debug && target != null) {\n       log('reuse state ${s.stateNumber} edge to ${target.stateNumber}',\n           level: Level.FINE.value);\n@@ -281,13 +283,22 @@ class LexerATNSimulator extends ATNSimulator {\n   }\n \n   int failOrAccept(\n-      SimState prevAccept, CharStream input, ATNConfigSet reach, int t) {\n+    SimState prevAccept,\n+    CharStream input,\n+    ATNConfigSet reach,\n+    int t,\n+  ) {\n     if (prevAccept.dfaState != null) {\n-      final lexerActionExecutor =\n-          prevAccept.dfaState.lexerActionExecutor;\n-      accept(input, lexerActionExecutor, startIndex, prevAccept.index,\n-          prevAccept.line, prevAccept.charPos);\n-      return prevAccept.dfaState.prediction;\n+      final lexerActionExecutor = prevAccept.dfaState!.lexerActionExecutor;\n+      accept(\n+        input,\n+        lexerActionExecutor,\n+        startIndex,\n+        prevAccept.index,\n+        prevAccept.line,\n+        prevAccept.charPos,\n+      );\n+      return prevAccept.dfaState!.prediction;\n     } else {\n       // if no accept and EOF is first char, return EOF\n       if (t == IntStream.EOF && input.index == startIndex) {\n@@ -302,7 +313,11 @@ class LexerATNSimulator extends ATNSimulator {\n   ///  we can reach upon input [t]. Parameter [reach] is a return\n   ///  parameter.\n   void getReachableConfigSet(\n-      CharStream input, ATNConfigSet configs, ATNConfigSet reach, int t) {\n+    CharStream input,\n+    ATNConfigSet configs,\n+    ATNConfigSet reach,\n+    int t,\n+  ) {\n     // this is used to skip processing for configs which have a lower priority\n     // than a config that already reached an accept state for the same rule\n     var skipAlt = ATN.INVALID_ALT_NUMBER;\n@@ -324,8 +339,7 @@ class LexerATNSimulator extends ATNSimulator {\n         final trans = c.state.transition(ti);\n         final target = getReachableTarget(trans, t);\n         if (target != null) {\n-          var lexerActionExecutor =\n-              (c as LexerATNConfig).lexerActionExecutor;\n+          var lexerActionExecutor = (c as LexerATNConfig).lexerActionExecutor;\n           if (lexerActionExecutor != null) {\n             lexerActionExecutor = lexerActionExecutor\n                 .fixOffsetBeforeMatch(input.index - startIndex);\n@@ -350,8 +364,14 @@ class LexerATNSimulator extends ATNSimulator {\n     }\n   }\n \n-  void accept(CharStream input, LexerActionExecutor lexerActionExecutor,\n-      int startIndex, int index, int line, int charPos) {\n+  void accept(\n+    CharStream input,\n+    LexerActionExecutor? lexerActionExecutor,\n+    int startIndex,\n+    int index,\n+    int line,\n+    int charPos,\n+  ) {\n     if (debug) {\n       log('ACTION $lexerActionExecutor\\n', level: Level.FINE.value);\n     }\n@@ -361,12 +381,12 @@ class LexerATNSimulator extends ATNSimulator {\n     this.line = line;\n     charPositionInLine = charPos;\n \n-    if (lexerActionExecutor != null && recog != null) {\n+    if (lexerActionExecutor != null) {\n       lexerActionExecutor.execute(recog, input, startIndex);\n     }\n   }\n \n-  ATNState getReachableTarget(Transition trans, int t) {\n+  ATNState? getReachableTarget(Transition trans, int t) {\n     if (trans.matches(t, Lexer.MIN_CHAR_VALUE, Lexer.MAX_CHAR_VALUE)) {\n       return trans.target;\n     }\n@@ -407,36 +427,41 @@ class LexerATNSimulator extends ATNSimulator {\n \n     if (config.state is RuleStopState) {\n       if (debug) {\n-        if (recog != null) {\n-          log('closure at ${recog.ruleNames[config.state.ruleIndex]} rule stop $config\\n',\n-              level: Level.FINE.value);\n-        } else {\n-          log('closure at rule stop $config\\n', level: Level.FINE.value);\n-        }\n+        log('closure at ${recog.ruleNames[config.state.ruleIndex]} rule stop $config\\n',\n+            level: Level.FINE.value);\n       }\n \n-      if (config.context == null || config.context.hasEmptyPath()) {\n-        if (config.context == null || config.context.isEmpty) {\n+      if (config.context == null || config.context!.hasEmptyPath()) {\n+        if (config.context == null || config.context!.isEmpty) {\n           configs.add(config);\n           return true;\n         } else {\n-          configs.add(LexerATNConfig.dup(config, config.state,\n-              context: PredictionContext.EMPTY));\n+          configs.add(LexerATNConfig.dup(\n+            config,\n+            config.state,\n+            context: PredictionContext.EMPTY,\n+          ));\n           currentAltReachedAcceptState = true;\n         }\n       }\n \n-      if (config.context != null && !config.context.isEmpty) {\n-        for (var i = 0; i < config.context.length; i++) {\n-          if (config.context.getReturnState(i) !=\n+      if (config.context != null && !config.context!.isEmpty) {\n+        for (var i = 0; i < config.context!.length; i++) {\n+          if (config.context!.getReturnState(i) !=\n               PredictionContext.EMPTY_RETURN_STATE) {\n             final newContext =\n-                config.context.getParent(i); // \"pop\" return state\n-            final returnState = atn.states[config.context.getReturnState(i)];\n-            final c = LexerATNConfig.dup(config, returnState,\n-                context: newContext);\n-            currentAltReachedAcceptState = closure(input, c, configs,\n-                currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n+                config.context!.getParent(i); // \"pop\" return state\n+            final returnState = atn.states[config.context!.getReturnState(i)]!;\n+            final c =\n+                LexerATNConfig.dup(config, returnState, context: newContext);\n+            currentAltReachedAcceptState = closure(\n+              input,\n+              c,\n+              configs,\n+              currentAltReachedAcceptState,\n+              speculative,\n+              treatEofAsEpsilon,\n+            );\n           }\n         }\n       }\n@@ -456,7 +481,13 @@ class LexerATNSimulator extends ATNSimulator {\n     for (var i = 0; i < p.numberOfTransitions; i++) {\n       final t = p.transition(i);\n       final c = getEpsilonTarget(\n-          input, config, t, configs, speculative, treatEofAsEpsilon);\n+        input,\n+        config,\n+        t,\n+        configs,\n+        speculative,\n+        treatEofAsEpsilon,\n+      );\n       if (c != null) {\n         currentAltReachedAcceptState = closure(input, c, configs,\n             currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n@@ -468,19 +499,22 @@ class LexerATNSimulator extends ATNSimulator {\n \n   // side-effect: can alter configs.hasSemanticContext\n \n-  LexerATNConfig getEpsilonTarget(\n-      CharStream input,\n-      LexerATNConfig config,\n-      Transition t,\n-      ATNConfigSet configs,\n-      bool speculative,\n-      bool treatEofAsEpsilon) {\n-    LexerATNConfig c;\n+  LexerATNConfig? getEpsilonTarget(\n+    CharStream input,\n+    LexerATNConfig config,\n+    Transition t,\n+    ATNConfigSet configs,\n+    bool speculative,\n+    bool treatEofAsEpsilon,\n+  ) {\n+    LexerATNConfig? c;\n     switch (t.type) {\n       case TransitionType.RULE:\n-        RuleTransition ruleTransition = t;\n+        final ruleTransition = t as RuleTransition;\n         PredictionContext newContext = SingletonPredictionContext.create(\n-            config.context, ruleTransition.followState.stateNumber);\n+          config.context!,\n+          ruleTransition.followState.stateNumber,\n+        );\n         c = LexerATNConfig.dup(config, t.target, context: newContext);\n         break;\n \n@@ -506,7 +540,7 @@ class LexerATNSimulator extends ATNSimulator {\n \t\t\t\t states reached by traversing predicates. Since this is when we\n \t\t\t\t test them, we cannot cash the DFA state target of ID.\n \t\t\t */\n-        PredicateTransition pt = t;\n+        final pt = t as PredicateTransition;\n         if (debug) {\n           log('EVAL rule ${pt.ruleIndex}:${pt.predIndex}',\n               level: Level.FINE.value);\n@@ -517,7 +551,7 @@ class LexerATNSimulator extends ATNSimulator {\n         }\n         break;\n       case TransitionType.ACTION:\n-        if (config.context == null || config.context.hasEmptyPath()) {\n+        if (config.context == null || config.context!.hasEmptyPath()) {\n           // execute actions anywhere in the start rule for a token.\n           //\n           // TODO: if the entry rule is invoked recursively, some\n@@ -531,8 +565,9 @@ class LexerATNSimulator extends ATNSimulator {\n           // additional modifications are needed before we can support\n           // the split operation.\n           final lexerActionExecutor = LexerActionExecutor.append(\n-              config.lexerActionExecutor,\n-              atn.lexerActions[(t as ActionTransition).actionIndex]);\n+            config.lexerActionExecutor,\n+            atn.lexerActions![(t as ActionTransition).actionIndex],\n+          );\n           c = LexerATNConfig.dup(config, t.target,\n               lexerActionExecutor: lexerActionExecutor);\n         } else {\n@@ -562,7 +597,6 @@ class LexerATNSimulator extends ATNSimulator {\n         break;\n       case TransitionType.INVALID:\n         throw ArgumentError.value(t.type, 'TransitionType');\n-        break;\n     }\n \n     return c;\n@@ -588,12 +622,11 @@ class LexerATNSimulator extends ATNSimulator {\n   /// @return [true] if the specified predicate evaluates to\n   /// [true].\n   bool evaluatePredicate(\n-      CharStream input, int ruleIndex, int predIndex, bool speculative) {\n-    // assume true if no recognizer was provided\n-    if (recog == null) {\n-      return true;\n-    }\n-\n+    CharStream input,\n+    int ruleIndex,\n+    int predIndex,\n+    bool speculative,\n+  ) {\n     if (!speculative) {\n       return recog.sempred(null, ruleIndex, predIndex);\n     }\n@@ -656,8 +689,8 @@ class LexerATNSimulator extends ATNSimulator {\n           level: Level.FINE.value);\n     }\n \n-    p.edges ??= List<DFAState>(MAX_DFA_EDGE - MIN_DFA_EDGE + 1);\n-    p.edges[t - MIN_DFA_EDGE] = q; // connect\n+    p.edges ??= List<DFAState?>.filled(MAX_DFA_EDGE - MIN_DFA_EDGE + 1, null);\n+    p.edges![t - MIN_DFA_EDGE] = q; // connect\n   }\n \n   /// Add a new DFA state if there isn't one with this set of\n@@ -671,7 +704,7 @@ class LexerATNSimulator extends ATNSimulator {\n     assert(!configs.hasSemanticContext);\n \n     final proposed = DFAState(configs: configs);\n-    ATNConfig firstConfigWithRuleStopState;\n+    ATNConfig? firstConfigWithRuleStopState;\n     for (var c in configs) {\n       if (c.state is RuleStopState) {\n         firstConfigWithRuleStopState = c;\n@@ -682,10 +715,10 @@ class LexerATNSimulator extends ATNSimulator {\n     if (firstConfigWithRuleStopState != null) {\n       proposed.isAcceptState = true;\n       proposed.lexerActionExecutor =\n-          (firstConfigWithRuleStopState as LexerATNConfig)\n-              .lexerActionExecutor;\n+          (firstConfigWithRuleStopState as LexerATNConfig).lexerActionExecutor;\n+      //Todo: I didnt get why ruleToTokenType is called here since it can be null if we are in a PARSER\n       proposed.prediction =\n-          atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\n+          atn.ruleToTokenType![firstConfigWithRuleStopState.state.ruleIndex];\n     }\n \n     final dfa = decisionToDFA[mode];\n@@ -714,7 +747,8 @@ class LexerATNSimulator extends ATNSimulator {\n \n   void consume(CharStream input) {\n     final curChar = input.LA(1);\n-    if (curChar == 10) { // Is new line\n+    if (curChar == 10) {\n+      // Is new line\n       line++;\n       charPositionInLine = 0;\n     } else {"
  },
  {
    "sha": "56b7dd396749b27e80dd0a94e0363253a423ffc4",
    "filename": "runtime/Dart/lib/src/atn/src/parser_atn_simulator.dart",
    "status": "modified",
    "additions": 345,
    "deletions": 197,
    "changes": 542,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/parser_atn_simulator.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/parser_atn_simulator.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/atn/src/parser_atn_simulator.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -22,7 +22,6 @@ import '../../token.dart';\n import '../../token_stream.dart';\n import '../../util/bit_set.dart';\n import '../../util/murmur_hash.dart';\n-import '../../vocabulary.dart';\n import 'atn.dart';\n import 'atn_config.dart';\n import 'atn_config_set.dart';\n@@ -281,21 +280,21 @@ class ParserATNSimulator extends ATNSimulator {\n   ///  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid\n   ///  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should\n   ///  also be examined during cache lookup.\n-  Map<Pair<PredictionContext, PredictionContext>, PredictionContext> mergeCache;\n+  Map<Pair<PredictionContext, PredictionContext>, PredictionContext>?\n+      mergeCache; // Todo: this is null and nothing can change it\n \n   // LAME globals to avoid parameters!!!!! I need these down deep in predTransition\n-  TokenStream input;\n+  late TokenStream input;\n   int startIndex = 0;\n-  ParserRuleContext _outerContext;\n-  DFA _dfa;\n-\n-  ParserATNSimulator(this.parser, ATN atn, this.decisionToDFA,\n-      PredictionContextCache sharedContextCache)\n-      : super(atn, sharedContextCache) {\n-    //\t\tDOTGenerator dot = new DOTGenerator(null);\n-    //\t\tlog(dot.getDOT(atn.rules.get(0), parser.getRuleNames()));\n-    //\t\tlog(dot.getDOT(atn.rules.get(1), parser.getRuleNames()));\n-  }\n+  ParserRuleContext? _outerContext;\n+  DFA? _dfa;\n+\n+  ParserATNSimulator(\n+    this.parser,\n+    ATN atn,\n+    this.decisionToDFA,\n+    PredictionContextCache? sharedContextCache,\n+  ) : super(atn, sharedContextCache);\n \n   @override\n   void reset() {}\n@@ -308,11 +307,14 @@ class ParserATNSimulator extends ATNSimulator {\n   }\n \n   int adaptivePredict(\n-      TokenStream input_, int decision, ParserRuleContext outerContext) {\n+    TokenStream input_,\n+    int decision,\n+    ParserRuleContext? outerContext,\n+  ) {\n     if (debug || debug_list_atn_decisions) {\n       log('adaptivePredict decision $decision' ' exec LA(1)==' +\n           getLookaheadName(input_) +\n-          ' line ${input_.LT(1).line}:${input_.LT(1).charPositionInLine}');\n+          ' line ${input_.LT(1)!.line}:${input_.LT(1)!.charPositionInLine}');\n     }\n \n     input = input_;\n@@ -327,7 +329,7 @@ class ParserATNSimulator extends ATNSimulator {\n     // Now we are certain to have a specific decision's DFA\n     // But, do we still need an initial state?\n     try {\n-      DFAState s0;\n+      DFAState? s0;\n       if (dfa.isPrecedenceDfa()) {\n         // the start state for a precedence DFA depends on the current\n         // parser precedence, and is provided by a DFA method.\n@@ -348,7 +350,10 @@ class ParserATNSimulator extends ATNSimulator {\n \n         final fullCtx = false;\n         var s0_closure = computeStartState(\n-            dfa.atnStartState, ParserRuleContext.EMPTY, fullCtx);\n+          dfa.atnStartState!,\n+          ParserRuleContext.EMPTY,\n+          fullCtx,\n+        );\n \n         if (dfa.isPrecedenceDfa()) {\n           /* If this is a precedence DFA, we use applyPrecedenceFilter\n@@ -357,8 +362,8 @@ class ParserATNSimulator extends ATNSimulator {\n \t\t\t\t\t * appropriate start state for the precedence level rather\n \t\t\t\t\t * than simply setting DFA.s0.\n \t\t\t\t\t */\n-          dfa.s0.configs =\n-              s0_closure; // not used for prediction but useful to know start configs anyway\n+          // not used for prediction but useful to know start configs anyway\n+          dfa.s0!.configs = s0_closure;\n           s0_closure = applyPrecedenceFilter(s0_closure);\n           s0 = addDFAState(dfa, DFAState(configs: s0_closure));\n           dfa.setPrecedenceStartState(parser.precedence, s0);\n@@ -368,7 +373,7 @@ class ParserATNSimulator extends ATNSimulator {\n         }\n       }\n \n-      final alt = execATN(dfa, s0, input_, index, outerContext);\n+      final alt = execATN(dfa, s0, input_, index, outerContext!);\n       if (debug) {\n         log('DFA after predictATN: ' + dfa.toString(parser.vocabulary));\n       }\n@@ -416,21 +421,21 @@ class ParserATNSimulator extends ATNSimulator {\n     if (debug || debug_list_atn_decisions) {\n       log('execATN decision ${dfa.decision}' ' exec LA(1)==' +\n           getLookaheadName(input) +\n-          ' line ${input.LT(1).line}' +\n-          ':${input.LT(1).charPositionInLine}');\n+          ' line ${input.LT(1)!.line}' +\n+          ':${input.LT(1)!.charPositionInLine}');\n     }\n \n     var previousD = s0;\n \n     if (debug) log('s0 = $s0');\n \n-    var t = input.LA(1);\n+    var t = input.LA(1)!;\n \n     while (true) {\n       // while more work\n       var D = getExistingTargetState(previousD, t);\n       D ??= computeTargetState(dfa, previousD, t);\n-\n+      D = D as DFAState;\n       if (D == ATNSimulator.ERROR) {\n         // if any configs in previous dipped into outer context, that\n         // means that input up to t actually finished entry rule\n@@ -441,8 +446,12 @@ class ParserATNSimulator extends ATNSimulator {\n         // ATN states in SLL implies LL will also get nowhere.\n         // If conflict in states that dip out, choose min since we\n         // will get error no matter what.\n-        final e =\n-            noViableAlt(input, outerContext, previousD.configs, startIndex);\n+        final e = noViableAlt(\n+          input,\n+          outerContext,\n+          previousD.configs,\n+          startIndex,\n+        );\n         input.seek(startIndex);\n         final alt = getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(\n             previousD.configs, outerContext);\n@@ -463,7 +472,7 @@ class ParserATNSimulator extends ATNSimulator {\n           }\n \n           conflictingAlts =\n-              evalSemanticContext(D.predicates, outerContext, true);\n+              evalSemanticContext(D.predicates!, outerContext, true);\n           if (conflictingAlts.cardinality == 1) {\n             if (debug) log('Full LL avoided');\n             return conflictingAlts.nextset(0);\n@@ -476,14 +485,28 @@ class ParserATNSimulator extends ATNSimulator {\n           }\n         }\n \n-        if (dfa_debug) log('ctx sensitive state ${outerContext} in $D');\n+        if (dfa_debug) log('ctx sensitive state $outerContext in $D');\n         final fullCtx = true;\n-        final s0_closure =\n-            computeStartState(dfa.atnStartState, outerContext, fullCtx);\n+        final s0_closure = computeStartState(\n+          dfa.atnStartState!,\n+          outerContext,\n+          fullCtx,\n+        );\n         reportAttemptingFullContext(\n-            dfa, conflictingAlts, D.configs, startIndex, input.index);\n+          dfa,\n+          conflictingAlts,\n+          D.configs,\n+          startIndex,\n+          input.index,\n+        );\n         final alt = execATNWithFullContext(\n-            dfa, D, s0_closure, input, startIndex, outerContext);\n+          dfa,\n+          D,\n+          s0_closure,\n+          input,\n+          startIndex,\n+          outerContext,\n+        );\n         return alt;\n       }\n \n@@ -494,7 +517,7 @@ class ParserATNSimulator extends ATNSimulator {\n \n         final stopIndex = input.index;\n         input.seek(startIndex);\n-        final alts = evalSemanticContext(D.predicates, outerContext, true);\n+        final alts = evalSemanticContext(D.predicates!, outerContext, true);\n         switch (alts.cardinality) {\n           case 0:\n             throw noViableAlt(input, outerContext, D.configs, startIndex);\n@@ -506,7 +529,14 @@ class ParserATNSimulator extends ATNSimulator {\n             // report ambiguity after predicate evaluation to make sure the correct\n             // set of ambig alts is reported.\n             reportAmbiguity(\n-                dfa, D, startIndex, stopIndex, false, alts, D.configs);\n+              dfa,\n+              D,\n+              startIndex,\n+              stopIndex,\n+              false,\n+              alts,\n+              D.configs,\n+            );\n             return alts.nextset(0);\n         }\n       }\n@@ -515,7 +545,7 @@ class ParserATNSimulator extends ATNSimulator {\n \n       if (t != IntStream.EOF) {\n         input.consume();\n-        t = input.LA(1);\n+        t = input.LA(1)!;\n       }\n     }\n   }\n@@ -529,7 +559,7 @@ class ParserATNSimulator extends ATNSimulator {\n   /// @return The existing target DFA state for the given input symbol\n   /// [t], or null if the target state for this edge is not\n   /// already cached\n-  DFAState getExistingTargetState(DFAState previousD, int t) {\n+  DFAState? getExistingTargetState(DFAState previousD, int t) {\n     final edges = previousD.edges;\n     if (edges == null || t + 1 < 0 || t + 1 >= edges.length) {\n       return null;\n@@ -548,25 +578,24 @@ class ParserATNSimulator extends ATNSimulator {\n   /// @return The computed target DFA state for the given input symbol\n   /// [t]. If [t] does not lead to a valid DFA state, this method\n   /// returns {@link #ERROR}.\n-  DFAState computeTargetState(DFA dfa, DFAState previousD, int t) {\n+  DFAState? computeTargetState(DFA dfa, DFAState previousD, int t) {\n     final reach = computeReachSet(previousD.configs, t, false);\n     if (reach == null) {\n       addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);\n       return ATNSimulator.ERROR;\n     }\n \n     // create new target state; we'll add to DFA after it's complete\n-    var D = DFAState(configs: reach);\n+    DFAState? D = DFAState(configs: reach);\n \n     final predictedAlt = getUniqueAlt(reach);\n \n     if (debug) {\n       final altSubSets =\n-      PredictionModeExtension.getConflictingAltSubsets(reach);\n-      log(\n-          'SLL altSubSets=$altSubSets' ', configs=$reach' ', predict=$predictedAlt, allSubsetsConflict=${PredictionModeExtension\n-              .allSubsetsConflict(\n-              altSubSets)}, conflictingAlts=${getConflictingAlts(reach)}');\n+          PredictionModeExtension.getConflictingAltSubsets(reach);\n+      log('SLL altSubSets=$altSubSets'\n+          ', configs=$reach'\n+          ', predict=$predictedAlt, allSubsetsConflict=${PredictionModeExtension.allSubsetsConflict(altSubSets)}, conflictingAlts=${getConflictingAlts(reach)}');\n     }\n \n     if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\n@@ -581,7 +610,7 @@ class ParserATNSimulator extends ATNSimulator {\n       D.requiresFullContext = true;\n       // in SLL-only mode, we will stop at this state and return the minimum alt\n       D.isAcceptState = true;\n-      D.prediction = D.configs.conflictingAlts.nextset(0);\n+      D.prediction = D.configs.conflictingAlts!.nextset(0);\n     }\n \n     if (D.isAcceptState && D.configs.hasSemanticContext) {\n@@ -596,16 +625,23 @@ class ParserATNSimulator extends ATNSimulator {\n     return D;\n   }\n \n-  void predicateDFAState(DFAState dfaState, DecisionState decisionState) {\n+  void predicateDFAState(DFAState dfaState, DecisionState? decisionState) {\n+    // Todo: this if was added due to a possuble null pointer error\n+    if (decisionState == null) return;\n+\n     // We need to test all predicates, even in DFA states that\n     // uniquely predict alternative.\n     final nalts = decisionState.numberOfTransitions;\n     // Update DFA so reach becomes accept state with (predicate,alt)\n     // pairs if preds found for conflicting alts\n-    final altsToCollectPredsFrom =\n-        getConflictingAltsOrUniqueAlt(dfaState.configs);\n-    final altToPred =\n-        getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);\n+    final altsToCollectPredsFrom = getConflictingAltsOrUniqueAlt(\n+      dfaState.configs,\n+    );\n+    final altToPred = getPredsForAmbigAlts(\n+      altsToCollectPredsFrom,\n+      dfaState.configs,\n+      nalts,\n+    );\n     if (altToPred != null) {\n       dfaState.predicates =\n           getPredicatePredictions(altsToCollectPredsFrom, altToPred);\n@@ -631,10 +667,10 @@ class ParserATNSimulator extends ATNSimulator {\n     }\n     final fullCtx = true;\n     var foundExactAmbig = false;\n-    ATNConfigSet reach;\n+    ATNConfigSet? reach;\n     var previous = s0;\n     input.seek(startIndex);\n-    var t = input.LA(1);\n+    var t = input.LA(1)!;\n     int predictedAlt;\n     while (true) {\n       // while more work\n@@ -652,11 +688,12 @@ class ParserATNSimulator extends ATNSimulator {\n         // ATN states in SLL implies LL will also get nowhere.\n         // If conflict in states that dip out, choose min since we\n         // will get error no matter what.\n-        final e =\n-            noViableAlt(input, outerContext, previous, startIndex);\n+        final e = noViableAlt(input, outerContext, previous, startIndex);\n         input.seek(startIndex);\n         final alt = getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(\n-            previous, outerContext);\n+          previous,\n+          outerContext,\n+        );\n         if (alt != ATN.INVALID_ALT_NUMBER) {\n           return alt;\n         }\n@@ -666,7 +703,9 @@ class ParserATNSimulator extends ATNSimulator {\n       final altSubSets =\n           PredictionModeExtension.getConflictingAltSubsets(reach);\n       if (debug) {\n-        log('LL altSubSets=$altSubSets' ', predict=${PredictionModeExtension.getUniqueAlt(altSubSets)}' ', resolvesToJustOneViableAlt=${PredictionModeExtension.resolvesToJustOneViableAlt(altSubSets)}');\n+        log('LL altSubSets=$altSubSets'\n+            ', predict=${PredictionModeExtension.getUniqueAlt(altSubSets)}'\n+            ', resolvesToJustOneViableAlt=${PredictionModeExtension.resolvesToJustOneViableAlt(altSubSets)}');\n       }\n \n //\t\t\tlog(\"altSubSets: \"+altSubSets);\n@@ -700,7 +739,7 @@ class ParserATNSimulator extends ATNSimulator {\n       previous = reach;\n       if (t != IntStream.EOF) {\n         input.consume();\n-        t = input.LA(1);\n+        t = input.LA(1)!;\n       }\n     }\n \n@@ -740,13 +779,13 @@ class ParserATNSimulator extends ATNSimulator {\n \t\tthe fact that we should predict alternative 1.  We just can't say for\n \t\tsure that there is an ambiguity without looking further.\n \t\t*/\n-    reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig,\n-        reach.alts, reach);\n+    reportAmbiguity(\n+        dfa, D, startIndex, input.index, foundExactAmbig, reach.alts, reach);\n \n     return predictedAlt;\n   }\n \n-  ATNConfigSet computeReachSet(ATNConfigSet config, int t, bool fullCtx) {\n+  ATNConfigSet? computeReachSet(ATNConfigSet config, int t, bool fullCtx) {\n     if (debug) log('in computeReachSet, starting closure: $config');\n \n     mergeCache ??= {};\n@@ -763,14 +802,14 @@ class ParserATNSimulator extends ATNSimulator {\n \t\t * ensure that the alternative matching the longest overall sequence is\n \t\t * chosen when multiple such configurations can match the input.\n \t\t */\n-    List<ATNConfig> skippedStopStates;\n+    List<ATNConfig>? skippedStopStates;\n \n     // First figure out where we can reach on input t\n     for (var c in config) {\n       if (debug) log('testing ' + getTokenName(t) + ' at ' + c.toString());\n \n       if (c.state is RuleStopState) {\n-        assert(c.context.isEmpty);\n+        assert(c.context!.isEmpty);\n         if (fullCtx || t == IntStream.EOF) {\n           skippedStopStates ??= [];\n \n@@ -793,7 +832,7 @@ class ParserATNSimulator extends ATNSimulator {\n \n     // Now figure out where the reach operation can take us...\n \n-    ATNConfigSet reach;\n+    ATNConfigSet? reach;\n \n     /* This block optimizes the reach operation for intermediate sets which\n \t\t * trivially indicate a termination state for the overall\n@@ -907,8 +946,7 @@ class ParserATNSimulator extends ATNSimulator {\n         final nextTokens = atn.nextTokens(config.state);\n         if (nextTokens.contains(Token.EPSILON)) {\n           ATNState endOfRuleState = atn.ruleToStopState[config.state.ruleIndex];\n-          result.add(\n-              ATNConfig.dup(config, state: endOfRuleState), mergeCache);\n+          result.add(ATNConfig.dup(config, state: endOfRuleState), mergeCache);\n         }\n       }\n     }\n@@ -918,8 +956,7 @@ class ParserATNSimulator extends ATNSimulator {\n \n   ATNConfigSet computeStartState(ATNState p, RuleContext ctx, bool fullCtx) {\n     // always at least the implicit call to start rule\n-    final initialContext =\n-        PredictionContext.fromRuleContext(atn, ctx);\n+    final initialContext = PredictionContext.fromRuleContext(atn, ctx);\n     final configs = ATNConfigSet(fullCtx);\n \n     for (var i = 0; i < p.numberOfTransitions; i++) {\n@@ -1102,18 +1139,21 @@ class ParserATNSimulator extends ATNSimulator {\n         continue;\n       }\n \n-      final updatedContext =\n-          config.semanticContext.evalPrecedence(parser, _outerContext);\n+      final updatedContext = config.semanticContext.evalPrecedence(\n+        parser,\n+        _outerContext,\n+      );\n       if (updatedContext == null) {\n         // the configuration was eliminated\n         continue;\n       }\n+      assert(config.context != null);\n+      final configContext = config.context!;\n \n-      statesFromAlt1[config.state.stateNumber] = config.context;\n+      statesFromAlt1[config.state.stateNumber] = configContext;\n       if (updatedContext != config.semanticContext) {\n         configSet.add(\n-            ATNConfig.dup(config, semanticContext: updatedContext),\n-            mergeCache);\n+            ATNConfig.dup(config, semanticContext: updatedContext), mergeCache);\n       } else {\n         configSet.add(config, mergeCache);\n       }\n@@ -1130,8 +1170,10 @@ class ParserATNSimulator extends ATNSimulator {\n \t\t\t\t * filter the prediction context for alternatives predicting alt>1\n \t\t\t\t * (basically a graph subtraction algorithm).\n \t\t\t\t */\n+        assert(config.context != null);\n+        final configContext = config.context!;\n         final context = statesFromAlt1[config.state.stateNumber];\n-        if (context != null && context == config.context) {\n+        if (context != null && context == configContext) {\n           // eliminated\n           continue;\n         }\n@@ -1143,16 +1185,19 @@ class ParserATNSimulator extends ATNSimulator {\n     return configSet;\n   }\n \n-  ATNState getReachableTarget(Transition trans, int ttype) {\n+  ATNState? getReachableTarget(Transition trans, int ttype) {\n     if (trans.matches(ttype, 0, atn.maxTokenType)) {\n       return trans.target;\n     }\n \n     return null;\n   }\n \n-  List<SemanticContext> getPredsForAmbigAlts(\n-      BitSet ambigAlts, ATNConfigSet configs, int nalts) {\n+  List<SemanticContext?>? getPredsForAmbigAlts(\n+    BitSet ambigAlts,\n+    ATNConfigSet configs,\n+    int nalts,\n+  ) {\n     // REACH=[1|1|[]|0:0, 1|2|[]|0:1]\n     /* altToPred starts as an array of all null contexts. The entry at index i\n \t\t * corresponds to alternative i. altToPred[i] may have one of three values:\n@@ -1165,7 +1210,8 @@ class ParserATNSimulator extends ATNSimulator {\n \t\t *\n \t\t * From this, it is clear that NONE||anything==NONE.\n \t\t */\n-    var altToPred = List<SemanticContext>(nalts + 1);\n+    final altToPred = List<SemanticContext?>.filled(nalts + 1, null);\n+\n     for (var c in configs) {\n       if (ambigAlts[c.alt]) {\n         altToPred[c.alt] =\n@@ -1187,14 +1233,16 @@ class ParserATNSimulator extends ATNSimulator {\n //\t\t\taltToPred[i] = altToPred[i].optimize();\n //\t\t}\n \n-    // nonambig alts are null in altToPred\n-    if (nPredAlts == 0) altToPred = null;\n     if (debug) log('getPredsForAmbigAlts result $altToPred');\n+    // nonambig alts are null in altToPred\n+    if (nPredAlts == 0) return null;\n     return altToPred;\n   }\n \n-  List<PredPrediction> getPredicatePredictions(\n-      BitSet ambigAlts, List<SemanticContext> altToPred) {\n+  List<PredPrediction>? getPredicatePredictions(\n+    BitSet? ambigAlts,\n+    List<SemanticContext?> altToPred,\n+  ) {\n     final pairs = <PredPrediction>[];\n     var containsPredicate = false;\n     for (var i = 1; i < altToPred.length; i++) {\n@@ -1263,8 +1311,7 @@ class ParserATNSimulator extends ATNSimulator {\n   /// identified and {@link #adaptivePredict} should report an error instead.\n   int getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(\n       ATNConfigSet configs, ParserRuleContext outerContext) {\n-    final sets =\n-        splitAccordingToSemanticValidity(configs, outerContext);\n+    final sets = splitAccordingToSemanticValidity(configs, outerContext);\n     final semValidConfigs = sets.a;\n     final semInvalidConfigs = sets.b;\n     var alt = getAltThatFinishedDecisionEntryRule(semValidConfigs);\n@@ -1286,8 +1333,9 @@ class ParserATNSimulator extends ATNSimulator {\n   int getAltThatFinishedDecisionEntryRule(ATNConfigSet configs) {\n     final alts = IntervalSet();\n     for (var c in configs) {\n+      assert(c.context != null);\n       if (c.outerContextDepth > 0 ||\n-          (c.state is RuleStopState && c.context.hasEmptyPath())) {\n+          (c.state is RuleStopState && c.context!.hasEmptyPath())) {\n         alts.addOne(c.alt);\n       }\n     }\n@@ -1304,13 +1352,19 @@ class ParserATNSimulator extends ATNSimulator {\n   ///  Assumption: the input stream has been restored to the starting point\n   ///  prediction, which is where predicates need to evaluate.\n   Pair<ATNConfigSet, ATNConfigSet> splitAccordingToSemanticValidity(\n-      ATNConfigSet configs, ParserRuleContext outerContext) {\n+    ATNConfigSet configs,\n+    ParserRuleContext outerContext,\n+  ) {\n     final succeeded = ATNConfigSet(configs.fullCtx);\n     final failed = ATNConfigSet(configs.fullCtx);\n     for (var c in configs) {\n       if (c.semanticContext != SemanticContext.NONE) {\n         final predicateEvaluationResult = evalSemanticContextOne(\n-            c.semanticContext, outerContext, c.alt, configs.fullCtx);\n+          c.semanticContext,\n+          outerContext,\n+          c.alt,\n+          configs.fullCtx,\n+        );\n         if (predicateEvaluationResult) {\n           succeeded.add(c);\n         } else {\n@@ -1328,8 +1382,11 @@ class ParserATNSimulator extends ATNSimulator {\n   ///  unpredicated config which behaves as \"always true.\" If !complete\n   ///  then we stop at the first predicate that evaluates to true. This\n   ///  includes pairs with null predicates.\n-  BitSet evalSemanticContext(List<PredPrediction> predPredictions,\n-      ParserRuleContext outerContext, bool complete) {\n+  BitSet evalSemanticContext(\n+    List<PredPrediction> predPredictions,\n+    ParserRuleContext outerContext,\n+    bool complete,\n+  ) {\n     final predictions = BitSet();\n     for (var pair in predPredictions) {\n       if (pair.pred == SemanticContext.NONE) {\n@@ -1387,8 +1444,12 @@ class ParserATNSimulator extends ATNSimulator {\n   /// during SLL prediction\n   ///\n   /// @since 4.3\n-  bool evalSemanticContextOne(SemanticContext pred,\n-      ParserRuleContext parserCallStack, int alt, bool fullCtx) {\n+  bool evalSemanticContextOne(\n+    SemanticContext pred,\n+    ParserRuleContext? parserCallStack,\n+    int alt,\n+    bool fullCtx,\n+  ) {\n     return pred.eval(parser, parserCallStack);\n   }\n \n@@ -1422,34 +1483,51 @@ class ParserATNSimulator extends ATNSimulator {\n       bool treatEofAsEpsilon) {\n     if (debug) log('closure(' + config.toString(parser, true) + ')');\n \n+    assert(config.context != null);\n+\n+    final configContext = config.context!;\n+\n     if (config.state is RuleStopState) {\n       // We hit rule end. If we have context info, use it\n       // run thru all possible stack tops in ctx\n-      if (!config.context.isEmpty) {\n-        for (var i = 0; i < config.context.length; i++) {\n-          if (config.context.getReturnState(i) ==\n+      if (!configContext.isEmpty) {\n+        for (var i = 0; i < configContext.length; i++) {\n+          if (configContext.getReturnState(i) ==\n               PredictionContext.EMPTY_RETURN_STATE) {\n             if (fullCtx) {\n               configs.add(\n-                  ATNConfig.dup(config,\n-                      state: config.state, context: PredictionContext.EMPTY),\n+                  ATNConfig.dup(\n+                    config,\n+                    state: config.state,\n+                    context: PredictionContext.EMPTY,\n+                  ),\n                   mergeCache);\n               continue;\n             } else {\n               // we have no context info, just chase follow links (if greedy)\n               if (debug) {\n                 log('FALLING off rule ' + getRuleName(config.state.ruleIndex));\n               }\n-              closure_(config, configs, closureBusy, collectPredicates, fullCtx,\n-                  depth, treatEofAsEpsilon);\n+              closure_(\n+                config,\n+                configs,\n+                closureBusy,\n+                collectPredicates,\n+                fullCtx,\n+                depth,\n+                treatEofAsEpsilon,\n+              );\n             }\n             continue;\n           }\n-          final returnState = atn.states[config.context.getReturnState(i)];\n-          final newContext =\n-              config.context.getParent(i); // \"pop\" return state\n+          final returnState = atn.states[configContext.getReturnState(i)]!;\n+          final newContext = configContext.getParent(i); // \"pop\" return state\n           final c = ATNConfig(\n-              returnState, config.alt, newContext, config.semanticContext);\n+            returnState,\n+            config.alt,\n+            newContext,\n+            config.semanticContext,\n+          );\n           // While we have context to pop back from, we may have\n           // gotten that context AFTER having falling off a rule.\n           // Make sure we track that we are now out of context.\n@@ -1475,8 +1553,15 @@ class ParserATNSimulator extends ATNSimulator {\n       }\n     }\n \n-    closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth,\n-        treatEofAsEpsilon);\n+    closure_(\n+      config,\n+      configs,\n+      closureBusy,\n+      collectPredicates,\n+      fullCtx,\n+      depth,\n+      treatEofAsEpsilon,\n+    );\n   }\n \n   /// Do the actual work of walking epsilon edges */\n@@ -1501,7 +1586,7 @@ class ParserATNSimulator extends ATNSimulator {\n       if (i == 0 && canDropLoopEntryEdgeInLeftRecursiveRule(config)) continue;\n \n       final t = p.transition(i);\n-      final continueCollecting = !(t is ActionTransition) && collectPredicates;\n+      final continueCollecting = (t is! ActionTransition) && collectPredicates;\n       final c = getEpsilonTarget(config, t, continueCollecting, depth == 0,\n           fullCtx, treatEofAsEpsilon);\n       if (c != null) {\n@@ -1514,10 +1599,10 @@ class ParserATNSimulator extends ATNSimulator {\n           // come in handy and we avoid evaluating context dependent\n           // preds if this is > 0.\n \n-          if (_dfa != null && _dfa.isPrecedenceDfa()) {\n+          if (_dfa != null && _dfa!.isPrecedenceDfa()) {\n             final outermostPrecedenceReturn =\n                 (t as EpsilonTransition).outermostPrecedenceReturn;\n-            if (outermostPrecedenceReturn == _dfa.atnStartState.ruleIndex) {\n+            if (outermostPrecedenceReturn == _dfa!.atnStartState!.ruleIndex) {\n               c.setPrecedenceFilterSuppressed(true);\n             }\n           }\n@@ -1548,8 +1633,15 @@ class ParserATNSimulator extends ATNSimulator {\n           }\n         }\n \n-        closureCheckingStopState(c, configs, closureBusy, continueCollecting,\n-            fullCtx, newDepth, treatEofAsEpsilon);\n+        closureCheckingStopState(\n+          c,\n+          configs,\n+          closureBusy,\n+          continueCollecting,\n+          fullCtx,\n+          newDepth,\n+          treatEofAsEpsilon,\n+        );\n       }\n     }\n   }\n@@ -1644,37 +1736,41 @@ class ParserATNSimulator extends ATNSimulator {\n   bool canDropLoopEntryEdgeInLeftRecursiveRule(ATNConfig config) {\n     if (TURN_OFF_LR_LOOP_ENTRY_BRANCH_OPT) return false;\n     final p = config.state;\n+\n+    assert(config.context != null);\n     // First check to see if we are in StarLoopEntryState generated during\n     // left-recursion elimination. For efficiency, also check if\n     // the context has an empty stack case. If so, it would mean\n     // global FOLLOW so we can't perform optimization\n     if (p.stateType != StateType.STAR_LOOP_ENTRY ||\n         !(p as StarLoopEntryState)\n             .isPrecedenceDecision || // Are we the special loop entry/exit state?\n-        config.context.isEmpty || // If SLL wildcard\n-        config.context.hasEmptyPath()) {\n+        config.context!.isEmpty || // If SLL wildcard\n+        config.context!.hasEmptyPath()) {\n       return false;\n     }\n \n+    final configContext = config.context!;\n+\n     // Require all return states to return back to the same rule\n     // that p is in.\n-    final numCtxs = config.context.length;\n+    final numCtxs = configContext.length;\n     for (var i = 0; i < numCtxs; i++) {\n       // for each stack context\n-      final returnState = atn.states[config.context.getReturnState(i)];\n+      final returnState = atn.states[configContext.getReturnState(i)]!;\n       if (returnState.ruleIndex != p.ruleIndex) return false;\n     }\n \n-    BlockStartState decisionStartState = p.transition(0).target;\n-    final blockEndStateNum = decisionStartState.endState.stateNumber;\n-    BlockEndState blockEndState = atn.states[blockEndStateNum];\n+    final decisionStartState = p.transition(0).target as BlockStartState;\n+    final blockEndStateNum = decisionStartState.endState!.stateNumber;\n+    final blockEndState = atn.states[blockEndStateNum] as BlockEndState;\n \n     // Verify that the top of each stack context leads to loop entry/exit\n     // state through epsilon edges and w/o leaving rule.\n     for (var i = 0; i < numCtxs; i++) {\n       // for each stack context\n-      final returnStateNumber = config.context.getReturnState(i);\n-      final returnState = atn.states[returnStateNumber];\n+      final returnStateNumber = configContext.getReturnState(i);\n+      final returnState = atn.states[returnStateNumber]!;\n       // all states must have single outgoing epsilon edge\n       if (returnState.numberOfTransitions != 1 ||\n           !returnState.transition(0).isEpsilon) {\n@@ -1714,11 +1810,11 @@ class ParserATNSimulator extends ATNSimulator {\n   }\n \n   String getRuleName(int index) {\n-    if (parser != null && index >= 0) return parser.ruleNames[index];\n+    if (index >= 0) return parser.ruleNames[index];\n     return '<rule $index>';\n   }\n \n-  ATNConfig getEpsilonTarget(\n+  ATNConfig? getEpsilonTarget(\n       ATNConfig config,\n       Transition t,\n       bool collectPredicates,\n@@ -1727,16 +1823,27 @@ class ParserATNSimulator extends ATNSimulator {\n       bool treatEofAsEpsilon) {\n     switch (t.type) {\n       case TransitionType.RULE:\n-        return ruleTransition(config, t);\n+        return ruleTransition(config, t as RuleTransition);\n \n       case TransitionType.PRECEDENCE:\n         return precedenceTransition(\n-            config, t, collectPredicates, inContext, fullCtx);\n+          config,\n+          t as PrecedencePredicateTransition,\n+          collectPredicates,\n+          inContext,\n+          fullCtx,\n+        );\n \n       case TransitionType.PREDICATE:\n-        return predTransition(config, t, collectPredicates, inContext, fullCtx);\n+        return predTransition(\n+          config,\n+          t as PredicateTransition,\n+          collectPredicates,\n+          inContext,\n+          fullCtx,\n+        );\n       case TransitionType.ACTION:\n-        return actionTransition(config, t);\n+        return actionTransition(config, t as ActionTransition);\n \n       case TransitionType.EPSILON:\n         return ATNConfig.dup(config, state: t.target);\n@@ -1764,20 +1871,19 @@ class ParserATNSimulator extends ATNSimulator {\n     return ATNConfig.dup(config, state: t.target);\n   }\n \n-  ATNConfig precedenceTransition(\n+  ATNConfig? precedenceTransition(\n       ATNConfig config,\n       PrecedencePredicateTransition pt,\n       bool collectPredicates,\n       bool inContext,\n       bool fullCtx) {\n     if (debug) {\n       log('PRED (collectPredicates=$collectPredicates) ${pt.precedence}>=_p, ctx dependent=true');\n-      if (parser != null) {\n-        log('context surrounding pred is ${parser.getRuleInvocationStack()}');\n-      }\n+\n+      log('context surrounding pred is ${parser.getRuleInvocationStack()}');\n     }\n \n-    ATNConfig c;\n+    ATNConfig? c;\n     if (collectPredicates && inContext) {\n       if (fullCtx) {\n         // In full context mode, we can evaluate predicates on-the-fly\n@@ -1793,10 +1899,11 @@ class ParserATNSimulator extends ATNSimulator {\n           c = ATNConfig.dup(config, state: pt.target); // no pred context\n         }\n       } else {\n-        final newSemCtx =\n-            SemanticContext.and(config.semanticContext, pt.predicate);\n-        c = ATNConfig.dup(config,\n-            state: pt.target, semanticContext: newSemCtx);\n+        final newSemCtx = SemanticContext.and(\n+          config.semanticContext,\n+          pt.predicate,\n+        );\n+        c = ATNConfig.dup(config, state: pt.target, semanticContext: newSemCtx);\n       }\n     } else {\n       c = ATNConfig.dup(config, state: pt.target);\n@@ -1806,16 +1913,22 @@ class ParserATNSimulator extends ATNSimulator {\n     return c;\n   }\n \n-  ATNConfig predTransition(ATNConfig config, PredicateTransition pt,\n-      bool collectPredicates, bool inContext, bool fullCtx) {\n+  ATNConfig? predTransition(\n+    ATNConfig config,\n+    PredicateTransition pt,\n+    bool collectPredicates,\n+    bool inContext,\n+    bool fullCtx,\n+  ) {\n     if (debug) {\n-      log('PRED (collectPredicates=$collectPredicates) ' '${pt.ruleIndex}:${pt.predIndex}' ', ctx dependent=${pt.isCtxDependent}');\n-      if (parser != null) {\n-        log('context surrounding pred is ${parser.getRuleInvocationStack()}');\n-      }\n+      log('PRED (collectPredicates=$collectPredicates) '\n+          '${pt.ruleIndex}:${pt.predIndex}'\n+          ', ctx dependent=${pt.isCtxDependent}');\n+\n+      log('context surrounding pred is ${parser.getRuleInvocationStack()}');\n     }\n \n-    ATNConfig c;\n+    ATNConfig? c;\n     if (collectPredicates &&\n         (!pt.isCtxDependent || (pt.isCtxDependent && inContext))) {\n       if (fullCtx) {\n@@ -1826,16 +1939,19 @@ class ParserATNSimulator extends ATNSimulator {\n         final currentPosition = input.index;\n         input.seek(startIndex);\n         final predSucceeds = evalSemanticContextOne(\n-            pt.predicate, _outerContext, config.alt, fullCtx);\n+          pt.predicate,\n+          _outerContext,\n+          config.alt,\n+          fullCtx,\n+        );\n         input.seek(currentPosition);\n         if (predSucceeds) {\n           c = ATNConfig.dup(config, state: pt.target); // no pred context\n         }\n       } else {\n         final newSemCtx =\n             SemanticContext.and(config.semanticContext, pt.predicate);\n-        c = ATNConfig.dup(config,\n-            state: pt.target, semanticContext: newSemCtx);\n+        c = ATNConfig.dup(config, state: pt.target, semanticContext: newSemCtx);\n       }\n     } else {\n       c = ATNConfig.dup(config, state: pt.target);\n@@ -1866,8 +1982,7 @@ class ParserATNSimulator extends ATNSimulator {\n   /// conflicting alternative subsets. If [configs] does not contain any\n   /// conflicting subsets, this method returns an empty [BitSet].\n   BitSet getConflictingAlts(ATNConfigSet configs) {\n-    final altsets =\n-        PredictionModeExtension.getConflictingAltSubsets(configs);\n+    final altsets = PredictionModeExtension.getConflictingAltSubsets(configs);\n     return PredictionModeExtension.getAlts(altsets);\n   }\n \n@@ -1906,24 +2021,22 @@ class ParserATNSimulator extends ATNSimulator {\n   /// ignore a set of conflicting alts when we have an alternative\n   /// that we still need to pursue.\n   BitSet getConflictingAltsOrUniqueAlt(ATNConfigSet configs) {\n-    BitSet conflictingAlts;\n+    BitSet? conflictingAlts;\n     if (configs.uniqueAlt != ATN.INVALID_ALT_NUMBER) {\n       conflictingAlts = BitSet();\n       conflictingAlts.set(configs.uniqueAlt);\n     } else {\n       conflictingAlts = configs.conflictingAlts;\n     }\n-    return conflictingAlts;\n+    return conflictingAlts!;\n   }\n \n   String getTokenName(int t) {\n     if (t == Token.EOF) {\n       return 'EOF';\n     }\n \n-    final vocabulary = parser != null\n-        ? parser.vocabulary\n-        : VocabularyImpl.EMPTY_VOCABULARY;\n+    final vocabulary = parser.vocabulary;\n     final displayName = vocabulary.getDisplayName(t);\n     if (displayName == t.toString()) {\n       return displayName;\n@@ -1933,15 +2046,15 @@ class ParserATNSimulator extends ATNSimulator {\n   }\n \n   String getLookaheadName(TokenStream input) {\n-    return getTokenName(input.LA(1));\n+    return getTokenName(input.LA(1)!);\n   }\n \n   /// Used for debugging in adaptivePredict around execATN but I cut\n   ///  it out for clarity now that alg. works well. We can leave this\n   ///  \"dead\" code for a bit.\n   void dumpDeadEndConfigs(NoViableAltException nvae) {\n     log('dead end configs: ', level: Level.SEVERE.value);\n-    for (var c in nvae.deadEndConfigs) {\n+    for (var c in nvae.deadEndConfigs!) {\n       var trans = 'no edges';\n       if (c.state.numberOfTransitions > 0) {\n         final t = c.state.transition(0);\n@@ -1958,10 +2071,20 @@ class ParserATNSimulator extends ATNSimulator {\n     }\n   }\n \n-  NoViableAltException noViableAlt(TokenStream input,\n-      ParserRuleContext outerContext, ATNConfigSet configs, int startIndex) {\n-    return NoViableAltException(parser, input, input.get(startIndex),\n-        input.LT(1), configs, outerContext);\n+  NoViableAltException noViableAlt(\n+    TokenStream input,\n+    ParserRuleContext outerContext,\n+    ATNConfigSet configs,\n+    int startIndex,\n+  ) {\n+    return NoViableAltException(\n+      parser,\n+      input,\n+      input.get(startIndex),\n+      input.LT(1),\n+      configs,\n+      outerContext,\n+    );\n   }\n \n   static int getUniqueAlt(ATNConfigSet configs) {\n@@ -1994,29 +2117,22 @@ class ParserATNSimulator extends ATNSimulator {\n   /// @return If [to] is null, this method returns null;\n   /// otherwise this method returns the result of calling {@link #addDFAState}\n   /// on [to]\n-  DFAState addDFAEdge(DFA dfa, DFAState from, int t, DFAState to) {\n+  DFAState? addDFAEdge(DFA dfa, DFAState? from, int t, DFAState to) {\n     if (debug) {\n       log('EDGE $from -> $to upon ' + getTokenName(t));\n     }\n \n-    if (to == null) {\n-      return null;\n-    }\n-\n     to = addDFAState(dfa, to); // used existing if possible not incoming\n     if (from == null || t < -1 || t > atn.maxTokenType) {\n       return to;\n     }\n \n-    from.edges ??= List(atn.maxTokenType + 1 + 1);\n+    from.edges ??= List.filled(atn.maxTokenType + 1 + 1, null);\n \n-    from.edges[t + 1] = to; // connect\n+    from.edges![t + 1] = to; // connect\n \n     if (debug) {\n-      log('DFA=\\n' +\n-          dfa.toString(parser != null\n-              ? parser.vocabulary\n-              : VocabularyImpl.EMPTY_VOCABULARY));\n+      log('DFA=\\n' + dfa.toString(parser.vocabulary));\n     }\n \n     return to;\n@@ -2053,51 +2169,81 @@ class ParserATNSimulator extends ATNSimulator {\n     return D;\n   }\n \n-  void reportAttemptingFullContext(DFA dfa, BitSet conflictingAlts,\n-      ATNConfigSet configs, int startIndex, int stopIndex) {\n+  void reportAttemptingFullContext(\n+    DFA dfa,\n+    BitSet? conflictingAlts,\n+    ATNConfigSet configs,\n+    int startIndex,\n+    int stopIndex,\n+  ) {\n     if (debug || retry_debug) {\n       final interval = Interval.of(startIndex, stopIndex);\n-      log('reportAttemptingFullContext decision=${dfa.decision}:$configs' ', input=' +\n-          parser.tokenStream.getText(interval));\n-    }\n-    if (parser != null) {\n-      parser.errorListenerDispatch.reportAttemptingFullContext(\n-          parser, dfa, startIndex, stopIndex, conflictingAlts, configs);\n-    }\n+      log(\n+        'reportAttemptingFullContext decision=${dfa.decision}:$configs'\n+                ', input=' +\n+            parser.tokenStream.getText(interval),\n+      );\n+    }\n+\n+    parser.errorListenerDispatch.reportAttemptingFullContext(\n+      parser,\n+      dfa,\n+      startIndex,\n+      stopIndex,\n+      conflictingAlts,\n+      configs,\n+    );\n   }\n \n   void reportContextSensitivity(DFA dfa, int prediction, ATNConfigSet configs,\n       int startIndex, int stopIndex) {\n     if (debug || retry_debug) {\n       final interval = Interval.of(startIndex, stopIndex);\n-      log('reportContextSensitivity decision=${dfa.decision}:$configs' ', input=' +\n-          parser.tokenStream.getText(interval));\n-    }\n-    if (parser != null) {\n-      parser.errorListenerDispatch.reportContextSensitivity(\n-          parser, dfa, startIndex, stopIndex, prediction, configs);\n-    }\n+      log(\n+        'reportContextSensitivity decision=${dfa.decision}:$configs'\n+                ', input=' +\n+            parser.tokenStream.getText(interval),\n+      );\n+    }\n+\n+    parser.errorListenerDispatch.reportContextSensitivity(\n+      parser,\n+      dfa,\n+      startIndex,\n+      stopIndex,\n+      prediction,\n+      configs,\n+    );\n   }\n \n   /// If context sensitive parsing, we know it's ambiguity not conflict */\n   void reportAmbiguity(\n-      DFA dfa,\n-      DFAState D, // the DFA state from execATN() that had SLL conflicts\n-      int startIndex,\n-      int stopIndex,\n-      bool exact,\n-      BitSet ambigAlts,\n-      ATNConfigSet configs) // configs that LL not SLL considered conflicting\n+    DFA dfa,\n+    DFAState D, // the DFA state from execATN() that had SLL conflicts\n+    int startIndex,\n+    int stopIndex,\n+    bool exact,\n+    BitSet? ambigAlts,\n+    ATNConfigSet configs,\n+  ) // configs that LL not SLL considered conflicting\n   {\n     if (debug || retry_debug) {\n       final interval = Interval.of(startIndex, stopIndex);\n-      log('reportAmbiguity $ambigAlts:$configs' ', input=' +\n-          parser.tokenStream.getText(interval));\n-    }\n-    if (parser != null) {\n-      parser.errorListenerDispatch.reportAmbiguity(\n-          parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n-    }\n+      log(\n+        'reportAmbiguity $ambigAlts:$configs' ', input=' +\n+            parser.tokenStream.getText(interval),\n+      );\n+    }\n+\n+    parser.errorListenerDispatch.reportAmbiguity(\n+      parser,\n+      dfa,\n+      startIndex,\n+      stopIndex,\n+      exact,\n+      ambigAlts,\n+      configs,\n+    );\n   }\n }\n \n@@ -2125,6 +2271,7 @@ enum PredictionMode {\n   /// This prediction mode does not provide any guarantees for prediction\n   /// behavior for syntactically-incorrect inputs.</p>\n   SLL,\n+\n   /// The LL(*) prediction mode. This prediction mode allows the current parser\n   /// context to be used for resolving SLL conflicts that occur during\n   /// prediction. This is the fastest prediction mode that guarantees correct\n@@ -2142,6 +2289,7 @@ enum PredictionMode {\n   /// This prediction mode does not provide any guarantees for prediction\n   /// behavior for syntactically-incorrect inputs.</p>\n   LL,\n+\n   /// The LL(*) prediction mode with exact ambiguity detection. In addition to\n   /// the correctness guarantees provided by the {@link #LL} prediction mode,\n   /// this prediction mode instructs the prediction algorithm to determine the\n@@ -2315,7 +2463,7 @@ extension PredictionModeExtension on PredictionMode {\n   /// [RuleStopState], otherwise [false]\n   static bool allConfigsInRuleStopStates(ATNConfigSet configs) {\n     for (var config in configs) {\n-      if (!(config.state is RuleStopState)) {\n+      if (config.state is! RuleStopState) {\n         return false;\n       }\n     }\n@@ -2561,7 +2709,7 @@ extension PredictionModeExtension on PredictionMode {\n   /// </pre>\n   static List<BitSet> getConflictingAltSubsets(ATNConfigSet configs) {\n     final configToAlts =\n-    HashMap<ATNConfig, BitSet>(equals: (ATNConfig a, ATNConfig b) {\n+        HashMap<ATNConfig, BitSet>(equals: (ATNConfig? a, ATNConfig? b) {\n       if (identical(a, b)) return true;\n       if (a == null || b == null) return false;\n       return a.state.stateNumber == b.state.stateNumber &&"
  },
  {
    "sha": "7b3a0b9466b15e1b9d4a24f4674b8d9197665010",
    "filename": "runtime/Dart/lib/src/atn/src/profiling_atn_simulator.dart",
    "status": "modified",
    "additions": 136,
    "deletions": 42,
    "changes": 178,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/profiling_atn_simulator.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/profiling_atn_simulator.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/atn/src/profiling_atn_simulator.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -18,14 +18,14 @@ import 'parser_atn_simulator.dart';\n import 'semantic_context.dart';\n \n class ProfilingATNSimulator extends ParserATNSimulator {\n-  List<DecisionInfo> decisions;\n-  int numDecisions;\n+  late List<DecisionInfo> decisions;\n+  late int numDecisions;\n \n-  int _sllStopIndex;\n-  int _llStopIndex;\n+  late int _sllStopIndex;\n+  late int _llStopIndex;\n \n-  int currentDecision;\n-  DFAState currentState;\n+  late int currentDecision;\n+  DFAState? currentState;\n \n   /// At the point of LL failover, we record how SLL would resolve the conflict so that\n   ///  we can determine whether or not a decision / input pair is context-sensitive.\n@@ -37,21 +37,28 @@ class ProfilingATNSimulator extends ParserATNSimulator {\n   ///  was not required in order to produce a correct prediction for this decision and input sequence.\n   ///  It may in fact still be a context sensitivity but we don't know by looking at the\n   ///  minimum alternatives for the current input.\n-  int conflictingAltResolvedBySLL;\n+  int? conflictingAltResolvedBySLL;\n \n   ProfilingATNSimulator(Parser parser)\n-      : super(parser, parser.interpreter.atn, parser.interpreter.decisionToDFA,\n-            parser.interpreter.sharedContextCache) {\n+      : super(\n+          parser,\n+          parser.interpreter!.atn,\n+          parser.interpreter!.decisionToDFA,\n+          parser.interpreter!.sharedContextCache,\n+        ) {\n     numDecisions = atn.decisionToState.length;\n-    decisions = List<DecisionInfo>(numDecisions);\n-    for (var i = 0; i < numDecisions; i++) {\n-      decisions[i] = DecisionInfo(i);\n-    }\n+    decisions = List<DecisionInfo>.generate(\n+      numDecisions,\n+      (index) => DecisionInfo(index),\n+    );\n   }\n \n   @override\n   int adaptivePredict(\n-      TokenStream input, int decision, ParserRuleContext outerContext) {\n+    TokenStream input,\n+    int decision,\n+    ParserRuleContext? outerContext,\n+  ) {\n     try {\n       _sllStopIndex = -1;\n       _llStopIndex = -1;\n@@ -73,7 +80,14 @@ class ProfilingATNSimulator extends ParserATNSimulator {\n       if (SLL_k > decisions[decision].SLL_MaxLook) {\n         decisions[decision].SLL_MaxLook = SLL_k;\n         decisions[decision].SLL_MaxLookEvent = LookaheadEventInfo(\n-            decision, null, alt, input, startIndex, _sllStopIndex, false);\n+          decision,\n+          null,\n+          alt,\n+          input,\n+          startIndex,\n+          _sllStopIndex,\n+          false,\n+        );\n       }\n \n       if (_llStopIndex >= 0) {\n@@ -96,18 +110,29 @@ class ProfilingATNSimulator extends ParserATNSimulator {\n   }\n \n   @override\n-  DFAState getExistingTargetState(DFAState previousD, int t) {\n+  DFAState? getExistingTargetState(DFAState previousD, int t) {\n     // this method is called after each time the input position advances\n     // during SLL prediction\n     _sllStopIndex = input.index;\n \n     final existingTargetState = super.getExistingTargetState(previousD, t);\n     if (existingTargetState != null) {\n-      decisions[currentDecision]\n-          .SLL_DFATransitions++; // count only if we transition over a DFA state\n+      //Todo: I assumed if it is null we should consider it zero\n+      final SLL_DFATransitions =\n+          decisions[currentDecision].SLL_DFATransitions ?? 0;\n+      // count only if we transition over a DFA state\n+      decisions[currentDecision].SLL_DFATransitions = SLL_DFATransitions + 1;\n       if (existingTargetState == ATNSimulator.ERROR) {\n-        decisions[currentDecision].errors.add(ErrorInfo(currentDecision,\n-            previousD.configs, input, startIndex, _sllStopIndex, false));\n+        decisions[currentDecision].errors.add(\n+              ErrorInfo(\n+                currentDecision,\n+                previousD.configs,\n+                input,\n+                startIndex,\n+                _sllStopIndex,\n+                false,\n+              ),\n+            );\n       }\n     }\n \n@@ -116,14 +141,14 @@ class ProfilingATNSimulator extends ParserATNSimulator {\n   }\n \n   @override\n-  DFAState computeTargetState(DFA dfa, DFAState previousD, int t) {\n+  DFAState? computeTargetState(DFA dfa, DFAState previousD, int t) {\n     final state = super.computeTargetState(dfa, previousD, t);\n     currentState = state;\n     return state;\n   }\n \n   @override\n-  ATNConfigSet computeReachSet(ATNConfigSet closure, int t, bool fullCtx) {\n+  ATNConfigSet? computeReachSet(ATNConfigSet closure, int t, bool fullCtx) {\n     if (fullCtx) {\n       // this method is called after each time the input position advances\n       // during full context prediction\n@@ -132,17 +157,32 @@ class ProfilingATNSimulator extends ParserATNSimulator {\n \n     final reachConfigs = super.computeReachSet(closure, t, fullCtx);\n     if (fullCtx) {\n-      decisions[currentDecision]\n-          .LL_ATNTransitions++; // count computation even if error\n+      //Todo: I assumed if it is null we should consider it zero\n+      final LL_ATNTransitions =\n+          decisions[currentDecision].LL_ATNTransitions ?? 0;\n+\n+      // count computation even if error\n+      decisions[currentDecision].LL_ATNTransitions = LL_ATNTransitions + 1;\n       if (reachConfigs != null) {\n       } else {\n         // no reach on current lookahead symbol. ERROR.\n         // TODO: does not handle delayed errors per getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule()\n-        decisions[currentDecision].errors.add(ErrorInfo(\n-            currentDecision, closure, input, startIndex, _llStopIndex, true));\n+        decisions[currentDecision].errors.add(\n+              ErrorInfo(\n+                currentDecision,\n+                closure,\n+                input,\n+                startIndex,\n+                _llStopIndex,\n+                true,\n+              ),\n+            );\n       }\n     } else {\n-      decisions[currentDecision].SLL_ATNTransitions++;\n+      //Todo: I assumed if it is null we should consider it zero\n+      final SLL_ATNTransitions =\n+          decisions[currentDecision].SLL_ATNTransitions ?? 0;\n+      decisions[currentDecision].SLL_ATNTransitions = SLL_ATNTransitions + 1;\n       if (reachConfigs != null) {\n       } else {\n         // no reach on current lookahead symbol. ERROR.\n@@ -154,10 +194,18 @@ class ProfilingATNSimulator extends ParserATNSimulator {\n   }\n \n   @override\n-  bool evalSemanticContextOne(SemanticContext pred,\n-      ParserRuleContext parserCallStack, int alt, bool fullCtx) {\n-    final result =\n-        super.evalSemanticContextOne(pred, parserCallStack, alt, fullCtx);\n+  bool evalSemanticContextOne(\n+    SemanticContext pred,\n+    ParserRuleContext? parserCallStack,\n+    int alt,\n+    bool fullCtx,\n+  ) {\n+    final result = super.evalSemanticContextOne(\n+      pred,\n+      parserCallStack,\n+      alt,\n+      fullCtx,\n+    );\n     if (!(pred is PrecedencePredicate)) {\n       final fullContext = _llStopIndex >= 0;\n       final stopIndex = fullContext ? _llStopIndex : _sllStopIndex;\n@@ -176,16 +224,33 @@ class ProfilingATNSimulator extends ParserATNSimulator {\n   }\n \n   @override\n-  void reportAttemptingFullContext(DFA dfa, BitSet conflictingAlts,\n-      ATNConfigSet configs, int startIndex, int stopIndex) {\n+  void reportAttemptingFullContext(\n+    DFA dfa,\n+    BitSet? conflictingAlts,\n+    ATNConfigSet configs,\n+    int startIndex,\n+    int stopIndex,\n+  ) {\n     if (conflictingAlts != null) {\n       conflictingAltResolvedBySLL = conflictingAlts.nextset(0);\n     } else {\n       conflictingAltResolvedBySLL = configs.alts.nextset(0);\n     }\n-    decisions[currentDecision].LL_Fallback++;\n+    //Todo: I assumed if it is null it should be zero\n+    if (decisions[currentDecision].LL_Fallback == null) {\n+      decisions[currentDecision].LL_Fallback = 1;\n+    } else {\n+      decisions[currentDecision].LL_Fallback =\n+          decisions[currentDecision].LL_Fallback! + 1;\n+    }\n+\n     super.reportAttemptingFullContext(\n-        dfa, conflictingAlts, configs, startIndex, stopIndex);\n+      dfa,\n+      conflictingAlts,\n+      configs,\n+      startIndex,\n+      stopIndex,\n+    );\n   }\n \n   @override\n@@ -201,8 +266,15 @@ class ProfilingATNSimulator extends ParserATNSimulator {\n   }\n \n   @override\n-  void reportAmbiguity(DFA dfa, DFAState D, int startIndex, int stopIndex,\n-      bool exact, BitSet ambigAlts, ATNConfigSet configs) {\n+  void reportAmbiguity(\n+    DFA dfa,\n+    DFAState D,\n+    int startIndex,\n+    int stopIndex,\n+    bool exact,\n+    BitSet? ambigAlts,\n+    ATNConfigSet configs,\n+  ) {\n     final prediction =\n         ambigAlts != null ? ambigAlts.nextset(0) : configs.alts.nextset(0);\n     if (configs.fullCtx && prediction != conflictingAltResolvedBySLL) {\n@@ -212,13 +284,35 @@ class ProfilingATNSimulator extends ParserATNSimulator {\n       // to different minimum alternatives we have also identified a\n       // context sensitivity.\n       decisions[currentDecision].contextSensitivities.add(\n-          ContextSensitivityInfo(\n-              currentDecision, configs, input, startIndex, stopIndex));\n+            ContextSensitivityInfo(\n+              currentDecision,\n+              configs,\n+              input,\n+              startIndex,\n+              stopIndex,\n+            ),\n+          );\n     }\n-    decisions[currentDecision].ambiguities.add(AmbiguityInfo(currentDecision,\n-        configs, ambigAlts, input, startIndex, stopIndex, configs.fullCtx));\n+    decisions[currentDecision].ambiguities.add(\n+          AmbiguityInfo(\n+            currentDecision,\n+            configs,\n+            ambigAlts,\n+            input,\n+            startIndex,\n+            stopIndex,\n+            configs.fullCtx,\n+          ),\n+        );\n     super.reportAmbiguity(\n-        dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);\n+      dfa,\n+      D,\n+      startIndex,\n+      stopIndex,\n+      exact,\n+      ambigAlts,\n+      configs,\n+    );\n   }\n \n   // ---------------------------------------------------------------------"
  },
  {
    "sha": "a78e1f6573f461fb1aa7c678509626b55167426a",
    "filename": "runtime/Dart/lib/src/atn/src/semantic_context.dart",
    "status": "modified",
    "additions": 40,
    "deletions": 37,
    "changes": 77,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/semantic_context.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/semantic_context.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/atn/src/semantic_context.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -34,7 +34,7 @@ abstract class SemanticContext {\n   /// capture context dependent predicates in the context in which we begin\n   /// prediction, so we passed in the outer context here in case of context\n   /// dependent predicate evaluation.</p>\n-  bool eval(Recognizer parser, RuleContext parserCallStack);\n+  bool eval(Recognizer parser, RuleContext? parserCallStack);\n \n   /// Evaluate the precedence predicates for the context and reduce the result.\n   ///\n@@ -52,12 +52,14 @@ abstract class SemanticContext {\n   /// <li>A non-null [SemanticContext]in the new simplified\n   /// semantic context after precedence predicates are evaluated.</li>\n   /// </ul>\n-  SemanticContext evalPrecedence(Recognizer parser,\n-      RuleContext parserCallStack) {\n+  SemanticContext? evalPrecedence(\n+    Recognizer parser,\n+    RuleContext? parserCallStack,\n+  ) {\n     return this;\n   }\n \n-  static SemanticContext and(SemanticContext a, SemanticContext b) {\n+  static SemanticContext? and(SemanticContext? a, SemanticContext? b) {\n     if (a == null || a == NONE) return b;\n     if (b == null || b == NONE) return a;\n     final result = AND(a, b);\n@@ -70,7 +72,7 @@ abstract class SemanticContext {\n \n   ///\n   ///  @see ParserATNSimulator#getPredsForAmbigAlts\n-  static SemanticContext or(SemanticContext a, SemanticContext b) {\n+  static SemanticContext? or(SemanticContext? a, SemanticContext? b) {\n     if (a == null) return b;\n     if (b == null) return a;\n     if (a == NONE || b == NONE) return NONE;\n@@ -89,7 +91,7 @@ abstract class SemanticContext {\n \n   static Iterable<SemanticContext> filterNonPrecedencePredicates(\n       Iterable<SemanticContext> collection) {\n-    return collection.where((e) => !(e is PrecedencePredicate));\n+    return collection.where((e) => e is! PrecedencePredicate);\n   }\n }\n \n@@ -102,7 +104,7 @@ class Predicate extends SemanticContext {\n       [this.ruleIndex = -1, this.predIndex = -1, this.isCtxDependent = false]);\n \n   @override\n-  bool eval(Recognizer parser, RuleContext parserCallStack) {\n+  bool eval(Recognizer parser, RuleContext? parserCallStack) {\n     final localctx = isCtxDependent ? parserCallStack : null;\n     return parser.sempred(localctx, ruleIndex, predIndex);\n   }\n@@ -138,13 +140,15 @@ class PrecedencePredicate extends SemanticContext\n   PrecedencePredicate([this.precedence = 0]);\n \n   @override\n-  bool eval(Recognizer parser, RuleContext parserCallStack) {\n+  bool eval(Recognizer parser, RuleContext? parserCallStack) {\n     return parser.precpred(parserCallStack, precedence);\n   }\n \n   @override\n-  SemanticContext evalPrecedence(Recognizer parser,\n-      RuleContext parserCallStack) {\n+  SemanticContext? evalPrecedence(\n+    Recognizer parser,\n+    RuleContext? parserCallStack,\n+  ) {\n     if (parser.precpred(parserCallStack, precedence)) {\n       return SemanticContext.NONE;\n     } else {\n@@ -165,11 +169,10 @@ class PrecedencePredicate extends SemanticContext\n   }\n \n   @override\n-  bool operator ==(Object obj) {\n-    if (!(obj is PrecedencePredicate)) {\n+  bool operator ==(Object other) {\n+    if (other is! PrecedencePredicate) {\n       return false;\n     }\n-    PrecedencePredicate other = obj;\n     return precedence == other.precedence;\n   }\n \n@@ -198,7 +201,7 @@ abstract class Operator extends SemanticContext {\n /// is false.\n \n class AND extends Operator {\n-  List<SemanticContext> opnds;\n+  late final List<SemanticContext> opnds;\n \n   AND(SemanticContext a, SemanticContext b) {\n     var operands = <SemanticContext>{};\n@@ -214,13 +217,13 @@ class AND extends Operator {\n     }\n \n     final precedencePredicates =\n-    SemanticContext.filterPrecedencePredicates(operands);\n+        SemanticContext.filterPrecedencePredicates(operands);\n \n     operands = SemanticContext.filterNonPrecedencePredicates(operands).toSet();\n     if (precedencePredicates.isNotEmpty) {\n       // interested in the transition with the lowest precedence\n       final reduced =\n-      precedencePredicates.reduce((a, b) => a.compareTo(b) <= 0 ? a : b);\n+          precedencePredicates.reduce((a, b) => a.compareTo(b) <= 0 ? a : b);\n       operands.add(reduced);\n     }\n \n@@ -233,9 +236,8 @@ class AND extends Operator {\n   }\n \n   @override\n-  bool operator ==(Object obj) {\n-    if (!(obj is AND)) return false;\n-    AND other = obj;\n+  bool operator ==(Object other) {\n+    if (other is! AND) return false;\n     return ListEquality().equals(opnds, other.opnds);\n   }\n \n@@ -251,21 +253,22 @@ class AND extends Operator {\n   /// unordered.</p>\n \n   @override\n-  bool eval(Recognizer parser, RuleContext parserCallStack) {\n+  bool eval(Recognizer parser, RuleContext? parserCallStack) {\n     for (var opnd in opnds) {\n       if (!opnd.eval(parser, parserCallStack)) return false;\n     }\n     return true;\n   }\n \n   @override\n-  SemanticContext evalPrecedence(Recognizer parser,\n-      RuleContext parserCallStack) {\n+  SemanticContext? evalPrecedence(\n+    Recognizer parser,\n+    RuleContext? parserCallStack,\n+  ) {\n     var differs = false;\n     final operands = <SemanticContext>[];\n     for (var context in opnds) {\n-      final evaluated =\n-      context.evalPrecedence(parser, parserCallStack);\n+      final evaluated = context.evalPrecedence(parser, parserCallStack);\n       differs |= (evaluated != context);\n       if (evaluated == null) {\n         // The AND context is false if any element is false\n@@ -285,7 +288,7 @@ class AND extends Operator {\n       return SemanticContext.NONE;\n     }\n \n-    var result = operands[0];\n+    SemanticContext? result = operands[0];\n     for (var i = 1; i < operands.length; i++) {\n       result = SemanticContext.and(result, operands[i]);\n     }\n@@ -302,7 +305,7 @@ class AND extends Operator {\n /// A semantic context which is true whenever at least one of the contained\n /// contexts is true.\n class OR extends Operator {\n-  List<SemanticContext> opnds;\n+  late final List<SemanticContext> opnds;\n \n   OR(SemanticContext a, SemanticContext b) {\n     var operands = <SemanticContext>{};\n@@ -318,13 +321,13 @@ class OR extends Operator {\n     }\n \n     final precedencePredicates =\n-    SemanticContext.filterPrecedencePredicates(operands);\n+        SemanticContext.filterPrecedencePredicates(operands);\n \n     operands = SemanticContext.filterNonPrecedencePredicates(operands).toSet();\n     if (precedencePredicates.isNotEmpty) {\n       // interested in the transition with the highest precedence\n       final reduced =\n-      precedencePredicates.reduce((a, b) => a.compareTo(b) >= 0 ? a : b);\n+          precedencePredicates.reduce((a, b) => a.compareTo(b) >= 0 ? a : b);\n       operands.add(reduced);\n     }\n \n@@ -337,9 +340,8 @@ class OR extends Operator {\n   }\n \n   @override\n-  bool operator ==(Object obj) {\n-    if (!(obj is OR)) return false;\n-    OR other = obj;\n+  bool operator ==(Object other) {\n+    if (other is! OR) return false;\n     return ListEquality().equals(opnds, other.opnds);\n   }\n \n@@ -355,21 +357,22 @@ class OR extends Operator {\n   /// unordered.</p>\n \n   @override\n-  bool eval(Recognizer parser, RuleContext parserCallStack) {\n+  bool eval(Recognizer parser, RuleContext? parserCallStack) {\n     for (var opnd in opnds) {\n       if (opnd.eval(parser, parserCallStack)) return true;\n     }\n     return false;\n   }\n \n   @override\n-  SemanticContext evalPrecedence(Recognizer parser,\n-      RuleContext parserCallStack) {\n+  SemanticContext? evalPrecedence(\n+    Recognizer parser,\n+    RuleContext? parserCallStack,\n+  ) {\n     var differs = false;\n     final operands = <SemanticContext>[];\n     for (var context in opnds) {\n-      final evaluated =\n-      context.evalPrecedence(parser, parserCallStack);\n+      final evaluated = context.evalPrecedence(parser, parserCallStack);\n       differs |= (evaluated != context);\n       if (evaluated == SemanticContext.NONE) {\n         // The OR context is true if any element is true\n@@ -389,7 +392,7 @@ class OR extends Operator {\n       return null;\n     }\n \n-    var result = operands[0];\n+    SemanticContext? result = operands[0];\n     for (var i = 1; i < operands.length; i++) {\n       result = SemanticContext.or(result, operands[i]);\n     }"
  },
  {
    "sha": "d123256d3327c54a4074d5790ae55cdaa020c664",
    "filename": "runtime/Dart/lib/src/atn/src/transition.dart",
    "status": "modified",
    "additions": 11,
    "deletions": 13,
    "changes": 24,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/transition.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/atn/src/transition.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/atn/src/transition.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -36,13 +36,9 @@ enum TransitionType {\n ///  ATN transitions.</p>\n abstract class Transition {\n   /// The target of this transition. */\n-  ATNState target;\n+  ATNState target; // Todo: never make it null\n \n-  Transition(this.target) {\n-    if (target == null) {\n-      throw ArgumentError.notNull('target cannot be null.');\n-    }\n-  }\n+  Transition(this.target);\n \n   TransitionType get type;\n \n@@ -55,7 +51,7 @@ abstract class Transition {\n   /// transition consumes (matches) an input symbol.\n   bool get isEpsilon => false;\n \n-  IntervalSet get label => null;\n+  IntervalSet? get label => null;\n \n   bool matches(int symbol, int minVocabSymbol, int maxVocabSymbol);\n }\n@@ -123,9 +119,12 @@ class RuleTransition extends Transition {\n   /// What node to begin computations following ref to rule */\n   ATNState followState;\n \n-  RuleTransition(RuleStartState ruleStart, this.ruleIndex, this.precedence,\n-      this.followState)\n-      : super(ruleStart);\n+  RuleTransition(\n+    RuleStartState ruleStart,\n+    this.ruleIndex,\n+    this.precedence,\n+    this.followState,\n+  ) : super(ruleStart);\n \n   @override\n   bool get isEpsilon => true;\n@@ -162,7 +161,6 @@ class PredicateTransition extends AbstractPredicateTransition {\n \n   Predicate get predicate => Predicate(ruleIndex, predIndex, isCtxDependent);\n \n-\n   @override\n   String toString() {\n     return 'pred_$ruleIndex:$predIndex';\n@@ -226,9 +224,9 @@ class ActionTransition extends Transition {\n // A transition containing a set of values.\n class SetTransition extends Transition {\n   @override\n-  IntervalSet label;\n+  late IntervalSet label;\n \n-  SetTransition(ATNState target, [IntervalSet st]) : super(target) {\n+  SetTransition(ATNState target, [IntervalSet? st]) : super(target) {\n     label = st ?? IntervalSet.ofOne(Token.INVALID_TYPE);\n   }\n "
  },
  {
    "sha": "7ee14406d81ff82aa3ee3997f033a6501cad6950",
    "filename": "runtime/Dart/lib/src/dfa/src/dfa.dart",
    "status": "modified",
    "additions": 16,
    "deletions": 16,
    "changes": 32,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/dfa/src/dfa.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/dfa/src/dfa.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/dfa/src/dfa.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -15,17 +15,17 @@ class DFA {\n \n   Map<DFAState, DFAState> states = {};\n \n-  DFAState s0;\n+  DFAState? s0;\n \n-  final int decision;\n+  final int? decision;\n \n   /// From which ATN state did we create this DFA? */\n \n-  DecisionState atnStartState;\n+  DecisionState? atnStartState;\n \n   /// [true] if this DFA is for a precedence decision; otherwise,\n-  /// [false]. This is the backing field for {@link #isPrecedenceDfa}.\n-  bool precedenceDfa;\n+  /// [false]. This is the backing field for [isPrecedenceDfa].\n+  late bool precedenceDfa;\n \n   DFA(this.atnStartState, [this.decision]) {\n     var precedenceDfa = false;\n@@ -44,8 +44,8 @@ class DFA {\n   }\n \n   /// Gets whether this DFA is a precedence DFA. Precedence DFAs use a special\n-  /// start state {@link #s0} which is not stored in {@link #states}. The\n-  /// {@link DFAState#edges} array for this start state contains outgoing edges\n+  /// start state {@link #s0} which is not stored in [states]. The\n+  /// [DFAState.edges] array for this start state contains outgoing edges\n   /// supplying individual start states corresponding to specific precedence\n   /// values.\n   ///\n@@ -64,18 +64,18 @@ class DFA {\n   ///\n   /// @throws IllegalStateException if this is not a precedence DFA.\n   /// @see #isPrecedenceDfa()\n-  DFAState getPrecedenceStartState(int precedence) {\n+  DFAState? getPrecedenceStartState(int precedence) {\n     if (!isPrecedenceDfa()) {\n       throw StateError(\n           'Only precedence DFAs may contain a precedence start state.');\n     }\n \n     // s0.edges is never null for a precedence DFA\n-    if (precedence < 0 || precedence >= s0.edges.length) {\n+    if (precedence < 0 || precedence >= s0!.edges!.length) {\n       return null;\n     }\n \n-    return s0.edges[precedence];\n+    return s0!.edges![precedence];\n   }\n \n   /// Set the start state for a specific precedence value.\n@@ -99,13 +99,13 @@ class DFA {\n     // synchronization on s0 here is ok. when the DFA is turned into a\n     // precedence DFA, s0 will be initialized once and not updated again\n     // s0.edges is never null for a precedence DFA\n-    if (precedence >= s0.edges.length) {\n-      final original = s0.edges;\n-      s0.edges = List(precedence + 1);\n-      List.copyRange(s0.edges, 0, original);\n+    if (precedence >= s0!.edges!.length) {\n+      final original = s0!.edges!;\n+      s0!.edges = List.filled(precedence + 1, null);\n+      List.copyRange(s0!.edges!, 0, original);\n     }\n \n-    s0.edges[precedence] = startState;\n+    s0!.edges![precedence] = startState;\n   }\n \n   /// Return a list of all states in this DFA, ordered by state number.\n@@ -120,7 +120,7 @@ class DFA {\n   }\n \n   @override\n-  String toString([Vocabulary vocabulary]) {\n+  String toString([Vocabulary? vocabulary]) {\n     vocabulary = vocabulary ?? VocabularyImpl.EMPTY_VOCABULARY;\n     if (s0 == null) {\n       return '';"
  },
  {
    "sha": "36698f52c7cd885e74bf9552d7644bfb11b0ed36",
    "filename": "runtime/Dart/lib/src/dfa/src/dfa_serializer.dart",
    "status": "modified",
    "additions": 4,
    "deletions": 4,
    "changes": 8,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/dfa/src/dfa_serializer.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/dfa/src/dfa_serializer.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/dfa/src/dfa_serializer.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -19,14 +19,14 @@ class DFASerializer {\n \n   @override\n   String toString() {\n-    if (dfa.s0 == null) return null;\n+    if (dfa.s0 == null) return 'null';\n     final buf = StringBuffer();\n     final states = dfa.getStates();\n     for (var s in states) {\n       var n = 0;\n-      if (s.edges != null) n = s.edges.length;\n+      if (s.edges != null) n = s.edges!.length;\n       for (var i = 0; i < n; i++) {\n-        final t = s.edges[i];\n+        final t = s.edges![i];\n         if (t != null && t.stateNumber != 0x7FFFFFFF) {\n           buf.write(getStateString(s));\n           final label = getEdgeLabel(i);\n@@ -40,7 +40,7 @@ class DFASerializer {\n     }\n \n     final output = buf.toString();\n-    if (output.isEmpty) return null;\n+    if (output.isEmpty) return 'null';\n     //return Utils.sortLinesInString(output);\n     return output;\n   }"
  },
  {
    "sha": "6628c8faa4a773ee03dcb7aa4890965f4e299e78",
    "filename": "runtime/Dart/lib/src/dfa/src/dfa_state.dart",
    "status": "modified",
    "additions": 14,
    "deletions": 18,
    "changes": 32,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/dfa/src/dfa_state.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/dfa/src/dfa_state.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/dfa/src/dfa_state.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -45,14 +45,14 @@ class PredPrediction {\n ///  but with different ATN contexts (with same or different alts)\n ///  meaning that state was reached via a different set of rule invocations.</p>\n class DFAState {\n-  int stateNumber = -1;\n+  int stateNumber;\n \n   ATNConfigSet configs = ATNConfigSet();\n \n   /// {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)\n   ///  {@link Token#EOF} maps to {@code edges[0]}.\n \n-  List<DFAState> edges;\n+  List<DFAState?>? edges;\n \n   bool isAcceptState = false;\n \n@@ -61,7 +61,7 @@ class DFAState {\n   ///  {@link #requiresFullContext}.\n   int prediction = 0;\n \n-  LexerActionExecutor lexerActionExecutor;\n+  LexerActionExecutor? lexerActionExecutor;\n \n   /// Indicates that this state was created during SLL prediction that\n   /// discovered a conflict between the configurations in the state. Future\n@@ -81,19 +81,19 @@ class DFAState {\n   ///\n   ///  <p>This list is computed by {@link ParserATNSimulator#predicateDFAState}.</p>\n \n-  List<PredPrediction> predicates;\n+  List<PredPrediction>? predicates;\n \n-  DFAState({this.stateNumber, this.configs});\n+  DFAState({this.stateNumber = -1, required this.configs});\n \n   /// Get the set of all alts mentioned by all ATN configurations in this\n   ///  DFA state.\n-  Set<int> get altSet {\n+  Set<int>? get altSet {\n     final alts = <int>{};\n-    if (configs != null) {\n-      for (var c in configs) {\n-        alts.add(c.alt);\n-      }\n+\n+    for (var c in configs) {\n+      alts.add(c.alt);\n     }\n+\n     if (alts.isEmpty) return null;\n     return alts;\n   }\n@@ -119,19 +119,15 @@ class DFAState {\n   /// {@link #stateNumber} is irrelevant.</p>\n \n   @override\n-  bool operator ==(Object o) {\n+  bool operator ==(Object other) {\n     // compare set of ATN configurations in this set with other\n-    if (identical(this, o)) return true;\n+    if (identical(this, other)) return true;\n \n-    if (!(o is DFAState)) {\n+    if (other is! DFAState) {\n       return false;\n     }\n \n-    DFAState other = o;\n-    // TODO (sam): what to do when configs==null?\n-    final sameSet = configs == other.configs;\n-//\t\tSystem.out.println(\"DFAState.equals: \"+configs+(sameSet?\"==\":\"!=\")+other.configs);\n-    return sameSet;\n+    return configs == other.configs;\n   }\n \n   @override"
  },
  {
    "sha": "ee576fdbc0c10da53a2ad45b3e776971f6f80335",
    "filename": "runtime/Dart/lib/src/error/src/diagnostic_error_listener.dart",
    "status": "modified",
    "additions": 16,
    "deletions": 9,
    "changes": 25,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/error/src/diagnostic_error_listener.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/error/src/diagnostic_error_listener.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/error/src/diagnostic_error_listener.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -41,7 +41,7 @@ class DiagnosticErrorListener extends BaseErrorListener {\n \n   @override\n   void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex,\n-      int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs) {\n+      int stopIndex, bool exact, BitSet? ambigAlts, ATNConfigSet configs) {\n     if (exactOnly && !exact) {\n       return;\n     }\n@@ -56,11 +56,18 @@ class DiagnosticErrorListener extends BaseErrorListener {\n   }\n \n   @override\n-  void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex,\n-      int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) {\n+  void reportAttemptingFullContext(\n+    Parser recognizer,\n+    DFA dfa,\n+    int startIndex,\n+    int stopIndex,\n+    BitSet? conflictingAlts,\n+    ATNConfigSet configs,\n+  ) {\n     final decision = getDecisionDescription(recognizer, dfa);\n-    final text =\n-        recognizer.tokenStream.getText(Interval.of(startIndex, stopIndex));\n+    final text = recognizer.tokenStream.getText(\n+      Interval.of(startIndex, stopIndex),\n+    );\n     final message = \"reportAttemptingFullContext d=$decision, input='$text'\";\n     recognizer.notifyErrorListeners(message);\n   }\n@@ -77,15 +84,15 @@ class DiagnosticErrorListener extends BaseErrorListener {\n \n   String getDecisionDescription(Parser recognizer, DFA dfa) {\n     final decision = dfa.decision;\n-    final ruleIndex = dfa.atnStartState.ruleIndex;\n+    final ruleIndex = dfa.atnStartState?.ruleIndex;\n \n     final ruleNames = recognizer.ruleNames;\n-    if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n+    if (ruleIndex == null || ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n       return decision.toString();\n     }\n \n     final ruleName = ruleNames[ruleIndex];\n-    if (ruleName == null || ruleName.isEmpty) {\n+    if (ruleName.isEmpty) {\n       return decision.toString();\n     }\n \n@@ -101,7 +108,7 @@ class DiagnosticErrorListener extends BaseErrorListener {\n   /// @param configs The conflicting or ambiguous configuration set.\n   /// @return Returns [reportedAlts] if it is not null, otherwise\n   /// returns the set of alternatives represented in [configs].\n-  BitSet getConflictingAlts(BitSet reportedAlts, ATNConfigSet configs) {\n+  BitSet getConflictingAlts(BitSet? reportedAlts, ATNConfigSet configs) {\n     if (reportedAlts != null) {\n       return reportedAlts;\n     }"
  },
  {
    "sha": "c157db38727334c38946e9715b70e44811ac12c6",
    "filename": "runtime/Dart/lib/src/error/src/error_listener.dart",
    "status": "modified",
    "additions": 122,
    "deletions": 28,
    "changes": 150,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/error/src/error_listener.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/error/src/error_listener.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/error/src/error_listener.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -45,8 +45,14 @@ abstract class ErrorListener {\n   ///        the reporting of an error. It is null in the case where\n   ///        the parser was able to recover in line without exiting the\n   ///        surrounding rule.\n-  void syntaxError(Recognizer recognizer, Object offendingSymbol, int line,\n-      int charPositionInLine, String msg, RecognitionException e);\n+  void syntaxError(\n+    Recognizer recognizer,\n+    Object? offendingSymbol,\n+    int? line,\n+    int charPositionInLine,\n+    String msg,\n+    RecognitionException? e,\n+  );\n \n   /// This method is called by the parser when a full-context prediction\n   /// results in an ambiguity.\n@@ -86,8 +92,15 @@ abstract class ErrorListener {\n   /// set of represented alternatives in [configs]\n   /// @param configs the ATN configuration set where the ambiguity was\n   /// identified\n-  void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex,\n-      int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);\n+  void reportAmbiguity(\n+    Parser recognizer,\n+    DFA dfa,\n+    int startIndex,\n+    int stopIndex,\n+    bool exact,\n+    BitSet? ambigAlts,\n+    ATNConfigSet configs,\n+  );\n \n   /// This method is called when an SLL conflict occurs and the parser is about\n   /// to use the full context information to make an LL decision.\n@@ -110,8 +123,14 @@ abstract class ErrorListener {\n   /// as null).\n   /// @param configs the ATN configuration set where the SLL conflict was\n   /// detected\n-  void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex,\n-      int stopIndex, BitSet conflictingAlts, ATNConfigSet configs);\n+  void reportAttemptingFullContext(\n+    Parser recognizer,\n+    DFA dfa,\n+    int startIndex,\n+    int stopIndex,\n+    BitSet? conflictingAlts,\n+    ATNConfigSet configs,\n+  );\n \n   /// This method is called by the parser when a full-context prediction has a\n   /// unique result.\n@@ -149,26 +168,57 @@ abstract class ErrorListener {\n   /// @param prediction the unambiguous result of the full-context prediction\n   /// @param configs the ATN configuration set where the unambiguous prediction\n   /// was determined\n-  void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex,\n-      int stopIndex, int prediction, ATNConfigSet configs);\n+  void reportContextSensitivity(\n+    Parser recognizer,\n+    DFA dfa,\n+    int startIndex,\n+    int stopIndex,\n+    int prediction,\n+    ATNConfigSet configs,\n+  );\n }\n \n class BaseErrorListener extends ErrorListener {\n   @override\n-  void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex,\n-      int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs) {}\n+  void reportAmbiguity(\n+    Parser recognizer,\n+    DFA dfa,\n+    int startIndex,\n+    int stopIndex,\n+    bool exact,\n+    BitSet? ambigAlts,\n+    ATNConfigSet configs,\n+  ) {}\n \n   @override\n-  void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex,\n-      int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) {}\n+  void reportAttemptingFullContext(\n+    Parser recognizer,\n+    DFA dfa,\n+    int startIndex,\n+    int stopIndex,\n+    BitSet? conflictingAlts,\n+    ATNConfigSet configs,\n+  ) {}\n \n   @override\n-  void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex,\n-      int stopIndex, int prediction, ATNConfigSet configs) {}\n+  void reportContextSensitivity(\n+    Parser recognizer,\n+    DFA dfa,\n+    int startIndex,\n+    int stopIndex,\n+    int prediction,\n+    ATNConfigSet configs,\n+  ) {}\n \n   @override\n-  void syntaxError(Recognizer<ATNSimulator> recognizer, Object offendingSymbol,\n-      int line, int charPositionInLine, String msg, RecognitionException e) {}\n+  void syntaxError(\n+    Recognizer<ATNSimulator> recognizer,\n+    Object? offendingSymbol,\n+    int? line,\n+    int charPositionInLine,\n+    String msg,\n+    RecognitionException? e,\n+  ) {}\n }\n \n class ConsoleErrorListener extends BaseErrorListener {\n@@ -195,47 +245,91 @@ class ConsoleErrorListener extends BaseErrorListener {\n /// collection of delegate listeners. This reduces the effort required to support multiple\n /// listeners.\n class ProxyErrorListener implements ErrorListener {\n-  final List<ErrorListener> delegates;\n+  final List<ErrorListener> delegates; //Todo: never make it null;\n \n   ProxyErrorListener(this.delegates) {\n+    // ignore: unnecessary_null_comparison\n     if (delegates == null) {\n       throw ArgumentError.notNull('delegates');\n     }\n   }\n \n   @override\n-  void syntaxError(Recognizer recognizer, Object offendingSymbol, int line,\n-      int charPositionInLine, String msg, RecognitionException e) {\n+  void syntaxError(\n+    Recognizer recognizer,\n+    Object? offendingSymbol,\n+    int? line,\n+    int charPositionInLine,\n+    String msg,\n+    RecognitionException? e,\n+  ) {\n     for (final listener in delegates) {\n       listener.syntaxError(\n-          recognizer, offendingSymbol, line, charPositionInLine, msg, e);\n+        recognizer,\n+        offendingSymbol,\n+        line,\n+        charPositionInLine,\n+        msg,\n+        e,\n+      );\n     }\n   }\n \n   @override\n-  void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex,\n-      int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs) {\n+  void reportAmbiguity(\n+    Parser recognizer,\n+    DFA dfa,\n+    int startIndex,\n+    int stopIndex,\n+    bool exact,\n+    BitSet? ambigAlts,\n+    ATNConfigSet configs,\n+  ) {\n     for (final listener in delegates) {\n       listener.reportAmbiguity(\n           recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n     }\n   }\n \n   @override\n-  void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex,\n-      int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) {\n+  void reportAttemptingFullContext(\n+    Parser recognizer,\n+    DFA dfa,\n+    int startIndex,\n+    int stopIndex,\n+    BitSet? conflictingAlts,\n+    ATNConfigSet configs,\n+  ) {\n     for (final listener in delegates) {\n       listener.reportAttemptingFullContext(\n-          recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs);\n+        recognizer,\n+        dfa,\n+        startIndex,\n+        stopIndex,\n+        conflictingAlts,\n+        configs,\n+      );\n     }\n   }\n \n   @override\n-  void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex,\n-      int stopIndex, int prediction, ATNConfigSet configs) {\n+  void reportContextSensitivity(\n+    Parser recognizer,\n+    DFA dfa,\n+    int startIndex,\n+    int stopIndex,\n+    int prediction,\n+    ATNConfigSet configs,\n+  ) {\n     for (final listener in delegates) {\n       listener.reportContextSensitivity(\n-          recognizer, dfa, startIndex, stopIndex, prediction, configs);\n+        recognizer,\n+        dfa,\n+        startIndex,\n+        stopIndex,\n+        prediction,\n+        configs,\n+      );\n     }\n   }\n }"
  },
  {
    "sha": "a7fb8a9f629cdb1f17b4eabab5e095f1ffc4c7e7",
    "filename": "runtime/Dart/lib/src/error/src/error_strategy.dart",
    "status": "modified",
    "additions": 42,
    "deletions": 41,
    "changes": 83,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/error/src/error_strategy.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/error/src/error_strategy.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/error/src/error_strategy.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -130,18 +130,18 @@ class DefaultErrorStrategy implements ErrorStrategy {\n   ///  one token/tree node is consumed for two errors.\n   int lastErrorIndex = -1;\n \n-  IntervalSet lastErrorStates;\n+  IntervalSet? lastErrorStates; // Todo: this is null and nothing can change it\n \n   /// This field is used to propagate information about the lookahead following\n   /// the previous match. Since prediction prefers completing the current rule\n   /// to error recovery efforts, error reporting may occur later than the\n   /// original point where it was discoverable. The original context is used to\n   /// compute the true expected sets as though the reporting occurred as early\n   /// as possible.\n-  ParserRuleContext nextTokensContext;\n+  ParserRuleContext? nextTokensContext;\n \n   /// @see #nextTokensContext\n-  int nextTokensState;\n+  int? nextTokensState;\n \n   /// {@inheritDoc}\n   ///\n@@ -242,7 +242,7 @@ class DefaultErrorStrategy implements ErrorStrategy {\n //\t\t\t\t\t\t   \", states=\"+lastErrorStates);\n     if (lastErrorIndex == recognizer.inputStream.index &&\n         lastErrorStates != null &&\n-        lastErrorStates.contains(recognizer.state)) {\n+        lastErrorStates!.contains(recognizer.state)) {\n       // uh oh, another error at same token index and previously-visited\n       // state in ATN; must be a case where LT(1) is in the recovery\n       // token set so nothing got consumed. Consume a single token\n@@ -253,7 +253,8 @@ class DefaultErrorStrategy implements ErrorStrategy {\n       recognizer.consume();\n     }\n     lastErrorIndex = recognizer.inputStream.index;\n-    lastErrorStates ??= IntervalSet(); lastErrorStates.addOne(recognizer.state);\n+    lastErrorStates ??= IntervalSet();\n+    lastErrorStates!.addOne(recognizer.state);\n     final followSet = getErrorRecoverySet(recognizer);\n     consumeUntil(recognizer, followSet);\n   }\n@@ -305,15 +306,15 @@ class DefaultErrorStrategy implements ErrorStrategy {\n \n   @override\n   void sync(Parser recognizer) {\n-    final s = recognizer.interpreter.atn.states[recognizer.state];\n+    final s = recognizer.interpreter!.atn.states[recognizer.state]!;\n //\t\tlog(\"sync @ \"+s.stateNumber+\"=\"+s.getClass().getSimpleName(), level: Level.SEVERE.value);\n     // If already recovering, don't try to sync\n     if (inErrorRecoveryMode(recognizer)) {\n       return;\n     }\n \n     final tokens = recognizer.inputStream;\n-    final la = tokens.LA(1);\n+    final la = tokens.LA(1)!;\n \n     // try cheaper subset first; might get lucky. seems to shave a wee bit off\n     final nextTokens = recognizer.getATN().nextTokens(s);\n@@ -372,15 +373,13 @@ class DefaultErrorStrategy implements ErrorStrategy {\n   void reportNoViableAlternative(Parser recognizer, NoViableAltException e) {\n     final tokens = recognizer.inputStream;\n     String input;\n-    if (tokens != null) {\n-      if (e.startToken.type == Token.EOF) {\n-        input = '<EOF>';\n-      } else {\n-        input = tokens.getTextRange(e.startToken, e.offendingToken);\n-      }\n+\n+    if (e.startToken.type == Token.EOF) {\n+      input = '<EOF>';\n     } else {\n-      input = '<unknown input>';\n+      input = tokens.getTextRange(e.startToken, e.offendingToken);\n     }\n+\n     final msg = 'no viable alternative at input ' + escapeWSAndQuote(input);\n     recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n   }\n@@ -396,7 +395,7 @@ class DefaultErrorStrategy implements ErrorStrategy {\n     final msg = 'mismatched input ' +\n         getTokenErrorDisplay(e.offendingToken) +\n         ' expecting ' +\n-        e.expectedTokens.toString(vocabulary: recognizer.vocabulary);\n+        e.expectedTokens!.toString(vocabulary: recognizer.vocabulary);\n     recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n   }\n \n@@ -408,8 +407,8 @@ class DefaultErrorStrategy implements ErrorStrategy {\n   /// @param recognizer the parser instance\n   /// @param e the recognition exception\n   void reportFailedPredicate(Parser recognizer, FailedPredicateException e) {\n-    final ruleName =\n-        recognizer.ruleNames[recognizer.context.ruleIndex];\n+    final ruleIndex = recognizer.context?.ruleIndex;\n+    final ruleName = ruleIndex != null ? recognizer.ruleNames[ruleIndex] : '';\n     final msg = 'rule ' + ruleName + ' ' + e.message;\n     recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n   }\n@@ -550,7 +549,10 @@ class DefaultErrorStrategy implements ErrorStrategy {\n       e = InputMismatchException(recognizer);\n     } else {\n       e = InputMismatchException(\n-          recognizer, nextTokensState, nextTokensContext);\n+        recognizer,\n+        nextTokensState!,\n+        nextTokensContext,\n+      );\n     }\n \n     throw e;\n@@ -572,14 +574,13 @@ class DefaultErrorStrategy implements ErrorStrategy {\n   /// @return [true] if single-token insertion is a viable recovery\n   /// strategy for the current mismatched input, otherwise [false]\n   bool singleTokenInsertion(Parser recognizer) {\n-    final currentSymbolType = recognizer.inputStream.LA(1);\n+    final currentSymbolType = recognizer.inputStream.LA(1)!;\n     // if current token is consistent with what could come after current\n     // ATN state, then we know we're missing a token; error recovery\n     // is free to conjure up and insert the missing token\n-    final currentState =\n-        recognizer.interpreter.atn.states[recognizer.state];\n+    final currentState = recognizer.interpreter!.atn.states[recognizer.state]!;\n     final next = currentState.transition(0).target;\n-    final atn = recognizer.interpreter.atn;\n+    final atn = recognizer.interpreter!.atn;\n     final expectingAtLL2 = atn.nextTokens(next, recognizer.context);\n //\t\tSystem.out.println(\"LT(2) set=\"+expectingAtLL2.toString(recognizer.getTokenNames()));\n     if (expectingAtLL2.contains(currentSymbolType)) {\n@@ -606,8 +607,8 @@ class DefaultErrorStrategy implements ErrorStrategy {\n   /// @return the successfully matched [Token] instance if single-token\n   /// deletion successfully recovers from the mismatched input, otherwise\n   /// null\n-  Token singleTokenDeletion(Parser recognizer) {\n-    final nextTokenType = recognizer.inputStream.LA(2);\n+  Token? singleTokenDeletion(Parser recognizer) {\n+    final nextTokenType = recognizer.inputStream.LA(2)!;\n     final expecting = getExpectedTokens(recognizer);\n     if (expecting.contains(nextTokenType)) {\n       reportUnwantedToken(recognizer);\n@@ -665,14 +666,15 @@ class DefaultErrorStrategy implements ErrorStrategy {\n       current = lookback;\n     }\n     return recognizer.tokenFactory.create(\n-        expectedTokenType,\n-        tokenText,\n-        Pair(current.tokenSource, current.tokenSource.inputStream),\n-        Token.DEFAULT_CHANNEL,\n-        -1,\n-        -1,\n-        current.line,\n-        current.charPositionInLine);\n+      expectedTokenType,\n+      tokenText,\n+      Pair(current.tokenSource, current.tokenSource?.inputStream),\n+      Token.DEFAULT_CHANNEL,\n+      -1,\n+      -1,\n+      current.line,\n+      current.charPositionInLine,\n+    );\n   }\n \n   IntervalSet getExpectedTokens(Parser recognizer) {\n@@ -686,7 +688,7 @@ class DefaultErrorStrategy implements ErrorStrategy {\n   ///  the token). This is better than forcing you to override a method in\n   ///  your token objects because you don't have to go modify your lexer\n   ///  so that it creates a new Java type.\n-  String getTokenErrorDisplay(Token t) {\n+  String getTokenErrorDisplay(Token? t) {\n     if (t == null) return '<no token>';\n     var s = getSymbolText(t);\n     if (s == null) {\n@@ -699,7 +701,7 @@ class DefaultErrorStrategy implements ErrorStrategy {\n     return escapeWSAndQuote(s);\n   }\n \n-  String getSymbolText(Token symbol) {\n+  String? getSymbolText(Token symbol) {\n     return symbol.text;\n   }\n \n@@ -808,31 +810,30 @@ class DefaultErrorStrategy implements ErrorStrategy {\n \t *  at run-time upon error to avoid overhead during parsing.\n \t */\n   IntervalSet getErrorRecoverySet(Parser recognizer) {\n-    final atn = recognizer.interpreter.atn;\n-    RuleContext ctx = recognizer.context;\n+    final atn = recognizer.interpreter!.atn;\n+    RuleContext? ctx = recognizer.context;\n     final recoverSet = IntervalSet();\n     while (ctx != null && ctx.invokingState >= 0) {\n       // compute what follows who invoked us\n-      final invokingState = atn.states[ctx.invokingState];\n-      RuleTransition rt = invokingState.transition(0);\n+      final invokingState = atn.states[ctx.invokingState]!;\n+      final rt = invokingState.transition(0) as RuleTransition;\n       final follow = atn.nextTokens(rt.followState);\n       recoverSet.addAll(follow);\n       ctx = ctx.parent;\n     }\n     recoverSet.remove(Token.EPSILON);\n-//\t\tSystem.out.println(\"recover set \"+recoverSet.toString(recognizer.getTokenNames()));\n     return recoverSet;\n   }\n \n   /// Consume tokens until one matches the given token set. */\n   void consumeUntil(Parser recognizer, IntervalSet set) {\n //\t\tlog(\"consumeUntil(\"+set.toString(recognizer.getTokenNames())+\")\", level: Level.SEVERE.value);\n-    var ttype = recognizer.inputStream.LA(1);\n+    var ttype = recognizer.inputStream.LA(1)!;\n     while (ttype != Token.EOF && !set.contains(ttype)) {\n       //System.out.println(\"consume during recover LA(1)=\"+getTokenNames()[input.LA(1)]);\n //\t\t\trecognizer.inputStream.consume();\n       recognizer.consume();\n-      ttype = recognizer.inputStream.LA(1);\n+      ttype = recognizer.inputStream.LA(1)!;\n     }\n   }\n }"
  },
  {
    "sha": "6db7ed9313bdc17614aba515787f27e6a99e7b9c",
    "filename": "runtime/Dart/lib/src/error/src/errors.dart",
    "status": "modified",
    "additions": 69,
    "deletions": 52,
    "changes": 121,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/error/src/errors.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/error/src/errors.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/error/src/errors.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -21,22 +21,22 @@ import '../../util/utils.dart';\n ///  mismatched input errors. In each case, the parser knows where it is\n ///  in the input, where it is in the ATN, the rule invocation stack,\n ///  and what kind of problem occurred.\n-class RecognitionException extends StateError {\n+class RecognitionException<StreamType extends IntStream> extends StateError {\n   /// Gets the [Recognizer] where this exception occurred.\n   ///\n   /// <p>If the recognizer is not available, this method returns null.</p>\n   ///\n   /// @return The recognizer where this exception occurred, or null if\n   /// the recognizer is not available.\n-  final Recognizer recognizer;\n+  final Recognizer? recognizer;\n \n   /// Gets the [RuleContext] at the time this exception was thrown.\n   ///\n   /// <p>If the context is not available, this method returns null.</p>\n   ///\n   /// @return The [RuleContext] at the time this exception was thrown.\n   /// If the context is not available, this method returns null.\n-  final RuleContext ctx;\n+  final RuleContext? ctx; // Todo: this is nullable and nothing can change it\n \n   /// Gets the input stream which is the symbol source for the recognizer where\n   /// this exception was thrown.\n@@ -46,12 +46,12 @@ class RecognitionException extends StateError {\n   /// @return The input stream which is the symbol source for the recognizer\n   /// where this exception was thrown, or null if the stream is not\n   /// available.\n-  final IntStream inputStream;\n+  final StreamType inputStream;\n \n   /// The current [Token] when an error occurred. Since not all streams\n   /// support accessing symbols by index, we have to track the [Token]\n   /// instance itself.\n-  Token offendingToken;\n+  late Token offendingToken;\n \n   /// Get the ATN state number the parser was in at the time the error\n   /// occurred. For [NoViableAltException] and\n@@ -62,10 +62,13 @@ class RecognitionException extends StateError {\n   /// <p>If the state number is not known, this method returns -1.</p>\n   int offendingState = -1;\n \n-  RecognitionException(this.recognizer, this.inputStream, this.ctx,\n-      [String message = ''])\n-      : super(message) {\n-    if (recognizer != null) offendingState = recognizer.state;\n+  RecognitionException(\n+    this.recognizer,\n+    this.inputStream,\n+    this.ctx, [\n+    String message = '',\n+  ]) : super(message) {\n+    if (recognizer != null) offendingState = recognizer!.state;\n   }\n \n   /// Gets the set of input symbols which could potentially follow the\n@@ -76,29 +79,27 @@ class RecognitionException extends StateError {\n   ///\n   /// @return The set of token types that could potentially follow the current\n   /// state in the ATN, or null if the information is not available.\n-  IntervalSet get expectedTokens {\n+  IntervalSet? get expectedTokens {\n     if (recognizer != null) {\n-      return recognizer.getATN().getExpectedTokens(offendingState, ctx);\n+      return recognizer!.getATN().getExpectedTokens(offendingState, ctx);\n     }\n     return null;\n   }\n }\n \n-class LexerNoViableAltException extends RecognitionException {\n+class LexerNoViableAltException extends RecognitionException<CharStream> {\n   /// Matching attempted at what input index? */\n   final int startIndex;\n \n   /// Which configurations did we try at input.index() that couldn't match input.LA(1)? */\n   final ATNConfigSet deadEndConfigs;\n \n   LexerNoViableAltException(\n-      Lexer lexer, CharStream input, this.startIndex, this.deadEndConfigs)\n-      : super(lexer, input, null);\n-\n-  @override\n-  CharStream get inputStream {\n-    return super.inputStream;\n-  }\n+    Lexer? lexer,\n+    CharStream input,\n+    this.startIndex,\n+    this.deadEndConfigs,\n+  ) : super(lexer, input, null);\n \n   @override\n   String toString() {\n@@ -108,7 +109,7 @@ class LexerNoViableAltException extends RecognitionException {\n       symbol = escapeWhitespace(symbol);\n     }\n \n-    return \"${LexerNoViableAltException}('${symbol}')\";\n+    return \"$LexerNoViableAltException('$symbol')\";\n   }\n }\n \n@@ -119,7 +120,7 @@ class LexerNoViableAltException extends RecognitionException {\n class NoViableAltException extends RecognitionException {\n   /// Which configurations did we try at input.index() that couldn't match input.LT(1)? */\n \n-  final ATNConfigSet deadEndConfigs;\n+  final ATNConfigSet? deadEndConfigs;\n \n   /// The token object at the start index; the input stream might\n   /// \tnot be buffering tokens so get a reference to it. (At the\n@@ -137,33 +138,42 @@ class NoViableAltException extends RecognitionException {\n //        recognizer._ctx);\n //  }\n \n-  NoViableAltException._(Parser recognizer, TokenStream input, this.startToken,\n-      Token offendingToken, this.deadEndConfigs, ParserRuleContext ctx)\n-      : super(recognizer, input, ctx) {\n+  NoViableAltException._(\n+    Parser recognizer,\n+    TokenStream input,\n+    this.startToken,\n+    Token offendingToken,\n+    this.deadEndConfigs,\n+    ParserRuleContext? ctx,\n+  ) : super(recognizer, input, ctx) {\n     this.offendingToken = offendingToken;\n   }\n \n-  NoViableAltException(Parser recognizer,\n-      [TokenStream input,\n-      Token startToken,\n-      Token offendingToken,\n-      ATNConfigSet deadEndConfigs,\n-      ParserRuleContext ctx])\n-      : this._(\n-            recognizer,\n-            input ?? recognizer.inputStream,\n-            startToken ?? recognizer.currentToken,\n-            offendingToken ?? recognizer.currentToken,\n-            deadEndConfigs,\n-            ctx ?? recognizer.context);\n+  NoViableAltException(\n+    Parser recognizer, [\n+    TokenStream? input,\n+    Token? startToken,\n+    Token? offendingToken,\n+    ATNConfigSet? deadEndConfigs,\n+    ParserRuleContext? ctx,\n+  ]) : this._(\n+          recognizer,\n+          input ?? recognizer.inputStream,\n+          startToken ?? recognizer.currentToken,\n+          offendingToken ?? recognizer.currentToken,\n+          deadEndConfigs,\n+          ctx ?? recognizer.context,\n+        );\n }\n \n /// This signifies any kind of mismatched input exceptions such as\n ///  when the current input does not match the expected token.\n class InputMismatchException extends RecognitionException {\n-  InputMismatchException(Parser recognizer,\n-      [int state = -1, ParserRuleContext ctx])\n-      : super(recognizer, recognizer.inputStream, ctx ?? recognizer.context) {\n+  InputMismatchException(\n+    Parser recognizer, [\n+    int state = -1,\n+    ParserRuleContext? ctx,\n+  ]) : super(recognizer, recognizer.inputStream, ctx ?? recognizer.context) {\n     if (state != -1 && ctx != null) {\n       offendingState = state;\n     }\n@@ -176,25 +186,32 @@ class InputMismatchException extends RecognitionException {\n ///  Disambiguating predicate evaluation occurs when we test a predicate during\n ///  prediction.\n class FailedPredicateException extends RecognitionException {\n-  int ruleIndex;\n-  int predIndex;\n-  final String predicate;\n-\n-  FailedPredicateException(Parser recognizer,\n-      [this.predicate, String message])\n-      : super(recognizer, recognizer.inputStream, recognizer.context,\n-            formatMessage(predicate, message)) {\n-    final s = recognizer.interpreter.atn.states[recognizer.state];\n-\n-    AbstractPredicateTransition trans = s.transition(0);\n+  int? ruleIndex;\n+  int? predIndex;\n+  final String? predicate;\n+\n+  FailedPredicateException(\n+    Parser recognizer, [\n+    this.predicate,\n+    String? message,\n+  ]) : super(\n+          recognizer,\n+          recognizer.inputStream,\n+          recognizer.context,\n+          formatMessage(predicate, message),\n+        ) {\n+    final s = recognizer.interpreter!.atn.states[recognizer.state]!;\n+\n+    //Todo: review type inference here\n+    final trans = s.transition(0) as AbstractPredicateTransition;\n     if (trans is PredicateTransition) {\n       ruleIndex = trans.ruleIndex;\n       predIndex = trans.predIndex;\n     }\n     offendingToken = recognizer.currentToken;\n   }\n \n-  static String formatMessage(String predicate, String message) {\n+  static String formatMessage(String? predicate, String? message) {\n     if (message != null) {\n       return message;\n     }"
  },
  {
    "sha": "8bd9c39471464a716d078058ede7c733c0b1f3c1",
    "filename": "runtime/Dart/lib/src/input_stream.dart",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/input_stream.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/input_stream.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/input_stream.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -89,7 +89,7 @@ abstract class IntStream {\n   ///\n   /// @throws UnsupportedOperationException if the stream does not support\n   /// retrieving the value of the specified symbol\n-  int LA(int i);\n+  int? LA(int i);\n \n   /// A mark provides a guarantee that {@link #seek seek()} operations will be\n   /// valid over a \"marked range\" extending from the index where {@code mark()}\n@@ -221,7 +221,7 @@ abstract class CharStream extends IntStream {\n // Vacuum all input from a string and then treat it like a buffer.\n class InputStream extends CharStream {\n   final name = '<empty>';\n-  List<int> data;\n+  late List<int> data;\n   int _index = 0;\n   bool decodeToUnicodeCodePoints = false;\n "
  },
  {
    "sha": "6cb9340effa94bca5a8ca6056566a0a5ccd76979",
    "filename": "runtime/Dart/lib/src/interval_set.dart",
    "status": "modified",
    "additions": 29,
    "deletions": 32,
    "changes": 61,
    "blob_url": "https://github.com/antlr/antlr4/blob/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/interval_set.dart",
    "raw_url": "https://github.com/antlr/antlr4/raw/7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4/runtime/Dart/lib/src/interval_set.dart",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/Dart/lib/src/interval_set.dart?ref=7ec098335a767e3d8fcbcfcc19ebc3482e3c11f4",
    "patch": "@@ -19,7 +19,8 @@ class Interval {\n \n   static final Interval INVALID = Interval(-1, -2);\n \n-  static List<Interval> cache = List<Interval>(INTERVAL_POOL_MAX_VALUE + 1);\n+  static List<Interval?> cache =\n+      List<Interval?>.filled(INTERVAL_POOL_MAX_VALUE + 1, null);\n \n   int a;\n   int b;\n@@ -44,7 +45,7 @@ class Interval {\n     if (cache[a] == null) {\n       cache[a] = Interval(a, a);\n     }\n-    return cache[a];\n+    return cache[a]!;\n   }\n \n   /// return number of elements between a and b inclusively. x..x is length 1.\n@@ -55,11 +56,10 @@ class Interval {\n   }\n \n   @override\n-  bool operator ==(Object o) {\n-    if (o == null || !(o is Interval)) {\n+  bool operator ==(Object other) {\n+    if (other is! Interval) {\n       return false;\n     }\n-    Interval other = o;\n     return a == other.a && b == other.b;\n   }\n \n@@ -124,8 +124,8 @@ class Interval {\n   ///  other must not be totally enclosed (properly contained)\n   ///  within this, which would result in two disjoint intervals\n   ///  instead of the single one returned by this method.\n-  Interval differenceNotProperlyContained(Interval other) {\n-    Interval diff;\n+  Interval? differenceNotProperlyContained(Interval other) {\n+    Interval? diff;\n     // other.a to left of this.a (or same)\n     if (other.startsBeforeNonDisjoint(this)) {\n       diff = Interval.of(max(a, other.b + 1), b);\n@@ -166,7 +166,7 @@ class IntervalSet {\n \n   bool readonly = false;\n \n-  IntervalSet([List<Interval> intervals]) {\n+  IntervalSet([List<Interval>? intervals]) {\n     this.intervals = intervals ?? [];\n   }\n \n@@ -282,7 +282,7 @@ class IntervalSet {\n     return o;\n   }\n \n-  IntervalSet addAll(IntervalSet set) {\n+  IntervalSet addAll(IntervalSet? set) {\n     if (set == null) {\n       return this;\n     }\n@@ -304,12 +304,12 @@ class IntervalSet {\n     return this;\n   }\n \n-  IntervalSet complementRange(int minElement, int maxElement) {\n+  IntervalSet? complementRange(int minElement, int maxElement) {\n     return complement(IntervalSet.ofRange(minElement, maxElement));\n   }\n \n   /// {@inheritDoc} */\n-  IntervalSet complement(IntervalSet vocabulary) {\n+  IntervalSet? complement(IntervalSet? vocabulary) {\n     if (vocabulary == null || vocabulary.isNil) {\n       return null; // nothing in common with null set\n     }\n@@ -325,7 +325,7 @@ class IntervalSet {\n   }\n \n   IntervalSet operator -(IntervalSet a) {\n-    if (a == null || a.isNil) {\n+    if (a.isNil) {\n       return IntervalSet.ofSet(this);\n     }\n \n@@ -342,12 +342,12 @@ class IntervalSet {\n   /// operation is {@code left - right}. If either of the input sets is\n   /// null, it is treated as though it was an empty set.\n   static IntervalSet subtract(IntervalSet left, IntervalSet right) {\n-    if (left == null || left.isNil) {\n+    if (left.isNil) {\n       return IntervalSet();\n     }\n \n     final result = IntervalSet.ofSet(left);\n-    if (right == null || right.isNil) {\n+    if (right.isNil) {\n       // right set has no elements; just return the copy of the current set\n       return result;\n     }\n@@ -371,8 +371,8 @@ class IntervalSet {\n         continue;\n       }\n \n-      Interval beforeCurrent;\n-      Interval afterCurrent;\n+      Interval? beforeCurrent;\n+      Interval? afterCurrent;\n       if (rightInterval.a > resultInterval.a) {\n         beforeCurrent = Interval(resultInterval.a, rightInterval.a - 1);\n       }\n@@ -417,14 +417,9 @@ class IntervalSet {\n \n   /// {@inheritDoc} */\n   IntervalSet operator +(IntervalSet other) {\n-    if (other == null) {\n-      //|| !(other is IntervalSet) ) {\n-      return null; // nothing in common with null set\n-    }\n-\n     final myIntervals = intervals;\n     final theirIntervals = (other).intervals;\n-    IntervalSet intersection;\n+    IntervalSet? intersection;\n     final mySize = myIntervals.length;\n     final theirSize = theirIntervals.length;\n     var i = 0;\n@@ -442,15 +437,18 @@ class IntervalSet {\n         j++;\n       } else if (mine.properlyContains(theirs)) {\n // overlap, add intersection, get next theirs\n-        intersection ??= IntervalSet();     intersection.add(mine.intersection(theirs));\n+        intersection ??= IntervalSet();\n+        intersection.add(mine.intersection(theirs));\n         j++;\n       } else if (theirs.properlyContains(mine)) {\n // overlap, add intersection, get next mine\n-        intersection ??= IntervalSet();     intersection.add(mine.intersection(theirs));\n+        intersection ??= IntervalSet();\n+        intersection.add(mine.intersection(theirs));\n         i++;\n       } else if (!mine.disjoint(theirs)) {\n // overlap, add intersection\n-        intersection ??= IntervalSet();     intersection.add(mine.intersection(theirs));\n+        intersection ??= IntervalSet();\n+        intersection.add(mine.intersection(theirs));\n // Move the iterator of lower range [a..b], but not\n // the upper range as it may contain elements that will collide\n // with the next iterator. So, if mine=[0..115] and\n@@ -499,7 +497,7 @@ class IntervalSet {\n   /// {@inheritDoc} */\n \n   bool get isNil {\n-    return intervals == null || intervals.isEmpty;\n+    return intervals.isEmpty;\n   }\n \n   /// Returns the maximum value contained in the set if not isNil().\n@@ -544,16 +542,15 @@ class IntervalSet {\n \n   @override\n   bool operator ==(Object obj) {\n-    if (obj == null || !(obj is IntervalSet)) {\n+    if (obj is! IntervalSet) {\n       return false;\n     }\n-    IntervalSet other = obj;\n-    return ListEquality().equals(intervals, other?.intervals);\n+    return ListEquality().equals(intervals, obj.intervals);\n   }\n \n   @override\n-  String toString({bool elemAreChar = false, Vocabulary vocabulary}) {\n-    if (intervals == null || intervals.isEmpty) {\n+  String toString({bool elemAreChar = false, Vocabulary? vocabulary}) {\n+    if (intervals.isEmpty) {\n       return '{}';\n     }\n \n@@ -628,7 +625,7 @@ class IntervalSet {\n   }\n \n   List<int> toIntegerList() {\n-    final values = List<int>(length);\n+    final values = <int>[];\n     final n = intervals.length;\n     for (var i = 0; i < n; i++) {\n       final I = intervals[i];"
  }
]
