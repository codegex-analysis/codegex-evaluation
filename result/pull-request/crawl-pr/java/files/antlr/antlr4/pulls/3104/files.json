[
  {
    "sha": "c9af2936997f6576eb0cdf1eeb556a563a09d7fd",
    "filename": "runtime/CSharp/src/Atn/ATNSimulator.cs",
    "status": "modified",
    "additions": 0,
    "deletions": 5,
    "changes": 5,
    "blob_url": "https://github.com/antlr/antlr4/blob/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/src/Atn/ATNSimulator.cs",
    "raw_url": "https://github.com/antlr/antlr4/raw/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/src/Atn/ATNSimulator.cs",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/CSharp/src/Atn/ATNSimulator.cs?ref=12dcef6676a0d34c676899b2c3ed12bfbb6c6a82",
    "patch": "@@ -75,11 +75,6 @@ public virtual void ClearDFA()\n \t\t\tthrow new Exception(\"This ATN simulator does not support clearing the DFA.\");\n \t\t}\n \n-        protected void ConsoleWriteLine(string format, params object[] arg)\n-        {\n-            System.Console.WriteLine(format, arg);\n-        }\n-\n         public PredictionContextCache getSharedContextCache()\n \t\t{\n \t\t\treturn sharedContextCache;"
  },
  {
    "sha": "34fe30bbcea09bdc90fac6562f5a0b584886ff76",
    "filename": "runtime/CSharp/src/Atn/LexerATNSimulator.cs",
    "status": "modified",
    "additions": 12,
    "deletions": 12,
    "changes": 24,
    "blob_url": "https://github.com/antlr/antlr4/blob/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/src/Atn/LexerATNSimulator.cs",
    "raw_url": "https://github.com/antlr/antlr4/raw/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/src/Atn/LexerATNSimulator.cs",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/CSharp/src/Atn/LexerATNSimulator.cs?ref=12dcef6676a0d34c676899b2c3ed12bfbb6c6a82",
    "patch": "@@ -119,7 +119,7 @@ protected int MatchATN(ICharStream input)\n \t\t\tATNState startState = atn.modeToStartState[mode];\n             if (debug)\n \t\t\t{\n-\t\t\t\tConsoleWriteLine(\"matchATN mode \" + mode + \" start: \" + startState);\n+\t\t\t\tConsole.WriteLine(\"matchATN mode \" + mode + \" start: \" + startState);\n \t\t\t}\n             int old_mode = mode;\n \n@@ -136,7 +136,7 @@ protected int MatchATN(ICharStream input)\n \t\t\tint predict = ExecATN(input, next);\n             if (debug)\n \t\t\t{\n-\t\t\t\tConsoleWriteLine(\"DFA after matchATN: \" + decisionToDFA[old_mode].ToString());\n+\t\t\t\tConsole.WriteLine(\"DFA after matchATN: \" + decisionToDFA[old_mode].ToString());\n \t\t\t}\n             return predict;\n \t\t}\n@@ -146,7 +146,7 @@ protected int ExecATN(ICharStream input, DFAState ds0)\n             //System.out.println(\"enter exec index \"+input.index()+\" from \"+ds0.configs);\n             if (debug)\n             {\n-                ConsoleWriteLine(\"start state closure=\" + ds0.configSet);\n+                Console.WriteLine(\"start state closure=\" + ds0.configSet);\n \t\t\t}\n             if (ds0.isAcceptState)\n \t\t\t{\n@@ -162,7 +162,7 @@ protected int ExecATN(ICharStream input, DFAState ds0)\n \t\t\t{ // while more work\n                 if (debug)\n                 {\n-                    ConsoleWriteLine(\"execATN loop starting closure: \" + s.configSet);\n+                    Console.WriteLine(\"execATN loop starting closure: \" + s.configSet);\n \t\t\t\t}\n                 // As we move src->trg, src->trg, we keep track of the previous trg to\n                 // avoid looking up the DFA state again, which is expensive.\n@@ -239,7 +239,7 @@ protected DFAState GetExistingTargetState(DFAState s, int t)\n \t\t\tDFAState target = s.edges[t - MIN_DFA_EDGE];\n \t\t\tif (debug && target != null)\n \t\t\t{\n-\t\t\t\tConsoleWriteLine(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n+\t\t\t\tConsole.WriteLine(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n \t\t\t}\n \n \t\t\treturn target;\n@@ -323,7 +323,7 @@ protected void GetReachableConfigSet(ICharStream input, ATNConfigSet closure, AT\n \n \t\t\t\tif (debug)\n \t\t\t\t{\n-\t\t\t\t\tConsoleWriteLine(\"testing \" + GetTokenName(t) + \" at \" + c.ToString(recog, true));\n+\t\t\t\t\tConsole.WriteLine(\"testing \" + GetTokenName(t) + \" at \" + c.ToString(recog, true));\n \t\t\t\t}\n \n \t\t\t\tint n = c.state.NumberOfTransitions;\n@@ -357,7 +357,7 @@ protected void GetReachableConfigSet(ICharStream input, ATNConfigSet closure, AT\n \t\t{\n \t\t\tif (debug)\n \t\t\t{\n-\t\t\t\tConsoleWriteLine(\"ACTION \" + lexerActionExecutor);\n+\t\t\t\tConsole.WriteLine(\"ACTION \" + lexerActionExecutor);\n \t\t\t}\n \n \t\t\t// seek to after last char in token\n@@ -411,7 +411,7 @@ protected bool Closure(ICharStream input, LexerATNConfig config, ATNConfigSet co\n \t\t{\n \t\t\tif (debug)\n \t\t\t{\n-\t\t\t\tConsoleWriteLine(\"closure(\" + config.ToString(recog, true) + \")\");\n+\t\t\t\tConsole.WriteLine(\"closure(\" + config.ToString(recog, true) + \")\");\n \t\t\t}\n \n \t\t\tif (config.state is RuleStopState)\n@@ -420,10 +420,10 @@ protected bool Closure(ICharStream input, LexerATNConfig config, ATNConfigSet co\n \t\t\t\t{\n \t\t\t\t\tif (recog != null)\n \t\t\t\t\t{\n-\t\t\t\t\t\tConsoleWriteLine(\"closure at \" + recog.RuleNames[config.state.ruleIndex] + \" rule stop \" + config);\n+\t\t\t\t\t\tConsole.WriteLine(\"closure at \" + recog.RuleNames[config.state.ruleIndex] + \" rule stop \" + config);\n \t\t\t\t\t}\n \t\t\t\t\telse {\n-\t\t\t\t\t\tConsoleWriteLine(\"closure at rule stop \" + config);\n+\t\t\t\t\t\tConsole.WriteLine(\"closure at rule stop \" + config);\n \t\t\t\t\t}\n \t\t\t\t}\n \n@@ -523,7 +523,7 @@ protected bool Closure(ICharStream input, LexerATNConfig config, ATNConfigSet co\n \t\t\t\t\tPredicateTransition pt = (PredicateTransition)t;\n \t\t\t\t\tif (debug)\n \t\t\t\t\t{\n-\t\t\t\t\t\tConsoleWriteLine(\"EVAL rule \" + pt.ruleIndex + \":\" + pt.predIndex);\n+\t\t\t\t\t\tConsole.WriteLine(\"EVAL rule \" + pt.ruleIndex + \":\" + pt.predIndex);\n \t\t\t\t\t}\n \t\t\t\t\tconfigs.hasSemanticContext = true;\n \t\t\t\t\tif (EvaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative))\n@@ -682,7 +682,7 @@ protected void AddDFAEdge(DFAState p, int t, DFAState q)\n \n \t\t\tif (debug)\n \t\t\t{\n-\t\t\t\tConsoleWriteLine(\"EDGE \" + p + \" -> \" + q + \" upon \" + ((char)t));\n+\t\t\t\tConsole.WriteLine(\"EDGE \" + p + \" -> \" + q + \" upon \" + ((char)t));\n \t\t\t}\n \n \t\t\tlock (p)"
  },
  {
    "sha": "38ae76b9c17a3a285e6dae0f008fa13495582646",
    "filename": "runtime/CSharp/src/Atn/ParserATNSimulator.cs",
    "status": "modified",
    "additions": 42,
    "deletions": 42,
    "changes": 84,
    "blob_url": "https://github.com/antlr/antlr4/blob/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/src/Atn/ParserATNSimulator.cs",
    "raw_url": "https://github.com/antlr/antlr4/raw/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/src/Atn/ParserATNSimulator.cs",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/CSharp/src/Atn/ParserATNSimulator.cs?ref=12dcef6676a0d34c676899b2c3ed12bfbb6c6a82",
    "patch": "@@ -284,8 +284,8 @@ public class ParserATNSimulator : ATNSimulator\n \t\t\tthis.parser = parser;\n \t\t\tthis.decisionToDFA = decisionToDFA;\n \t\t\t//\t\tDOTGenerator dot = new DOTGenerator(null);\n-\t\t\t//\t\tConsoleWriteLine(dot.getDOT(atn.rules.get(0), parser.getRuleNames()));\n-\t\t\t//\t\tConsoleWriteLine(dot.getDOT(atn.rules.get(1), parser.getRuleNames()));\n+\t\t\t//\t\tConsole.WriteLine(dot.getDOT(atn.rules.get(0), parser.getRuleNames()));\n+\t\t\t//\t\tConsole.WriteLine(dot.getDOT(atn.rules.get(1), parser.getRuleNames()));\n \t\t}\n \n \t\tpublic override void Reset()\n@@ -306,7 +306,7 @@ public override void ClearDFA()\n \t\t{\n \t\t\tif (debug || debug_list_atn_decisions)\n \t\t\t{\n-\t\t\t\tConsoleWriteLine(\"adaptivePredict decision \" + decision +\n+\t\t\t\tConsole.WriteLine(\"adaptivePredict decision \" + decision +\n \t\t\t\t\t\t\t\t\t   \" exec LA(1)==\" + GetLookaheadName(input) +\n \t\t\t\t\t\t\t\t  \" line \" + input.LT(1).Line + \":\" + input.LT(1).Column);\n \t\t\t}\n@@ -341,7 +341,7 @@ public override void ClearDFA()\n \t\t\t\t\tif (outerContext == null) outerContext = ParserRuleContext.EmptyContext;\n \t\t\t\t\tif (debug || debug_list_atn_decisions)\n \t\t\t\t\t{\n-\t\t\t\t\t\tConsoleWriteLine(\"predictATN decision \" + dfa.decision +\n+\t\t\t\t\t\tConsole.WriteLine(\"predictATN decision \" + dfa.decision +\n \t\t\t\t\t\t\t\t\t\t   \" exec LA(1)==\" + GetLookaheadName(input) +\n \t\t\t\t\t\t\t\t\t\t   \", outerContext=\" + outerContext.ToString(parser));\n \t\t\t\t\t}\n@@ -373,7 +373,7 @@ public override void ClearDFA()\n \n \t\t\t\tint alt = ExecATN(dfa, s0, input, index, outerContext);\n \t\t\t\tif (debug)\n-\t\t\t\t\tConsoleWriteLine(\"DFA after predictATN: \" + dfa.ToString(parser.Vocabulary));\n+\t\t\t\t\tConsole.WriteLine(\"DFA after predictATN: \" + dfa.ToString(parser.Vocabulary));\n \t\t\t\treturn alt;\n \t\t\t}\n \t\t\tfinally\n@@ -421,14 +421,14 @@ single alt\n \t\t{\n \t\t\tif (debug || debug_list_atn_decisions)\n \t\t\t{\n-\t\t\t\tConsoleWriteLine(\"execATN decision \" + dfa.decision +\n+\t\t\t\tConsole.WriteLine(\"execATN decision \" + dfa.decision +\n \t\t\t\t\t\t\t\t   \" exec LA(1)==\" + GetLookaheadName(input) +\n \t\t\t\t\t\t\t\t   \" line \" + input.LT(1).Line + \":\" + input.LT(1).Column);\n \t\t\t}\n \n \t\t\tDFAState previousD = s0;\n \n-\t\t\tif (debug) ConsoleWriteLine(\"s0 = \" + s0);\n+\t\t\tif (debug) Console.WriteLine(\"s0 = \" + s0);\n \n \t\t\tint t = input.LA(1);\n \n@@ -467,7 +467,7 @@ single alt\n \t\t\t\t\tBitSet conflictingAlts = D.configSet.conflictingAlts;\n \t\t\t\t\tif (D.predicates != null)\n \t\t\t\t\t{\n-\t\t\t\t\t\tif (debug) ConsoleWriteLine(\"DFA state has preds in DFA sim LL failover\");\n+\t\t\t\t\t\tif (debug) Console.WriteLine(\"DFA state has preds in DFA sim LL failover\");\n \t\t\t\t\t\tint conflictIndex = input.Index;\n \t\t\t\t\t\tif (conflictIndex != startIndex)\n \t\t\t\t\t\t{\n@@ -477,7 +477,7 @@ single alt\n \t\t\t\t\t\tconflictingAlts = EvalSemanticContext(D.predicates, outerContext, true);\n \t\t\t\t\t\tif (conflictingAlts.Cardinality() == 1)\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\tif (debug) ConsoleWriteLine(\"Full LL avoided\");\n+\t\t\t\t\t\t\tif (debug) Console.WriteLine(\"Full LL avoided\");\n \t\t\t\t\t\t\treturn conflictingAlts.NextSetBit(0);\n \t\t\t\t\t\t}\n \n@@ -489,7 +489,7 @@ single alt\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n-\t\t\t\t\tif (dfa_debug) ConsoleWriteLine(\"ctx sensitive state \" + outerContext + \" in \" + D);\n+\t\t\t\t\tif (dfa_debug) Console.WriteLine(\"ctx sensitive state \" + outerContext + \" in \" + D);\n \t\t\t\t\tbool fullCtx = true;\n \t\t\t\t\tATNConfigSet s0_closure =\n \t\t\t\t\t\tComputeStartState(dfa.atnStartState, outerContext, fullCtx);\n@@ -587,7 +587,7 @@ protected virtual DFAState ComputeTargetState(DFA dfa, DFAState previousD, int t\n \t\t\tif (debug)\n \t\t\t{\n \t\t\t\tICollection<BitSet> altSubSets = PredictionMode.GetConflictingAltSubsets(reach.configs);\n-\t\t\t\tConsoleWriteLine(\"SLL altSubSets=\" + altSubSets +\n+\t\t\t\tConsole.WriteLine(\"SLL altSubSets=\" + StaticUtils.ToString(altSubSets) +\n \t\t\t\t\t\t\t\t   \", configs=\" + reach +\n \t\t\t\t\t\t\t\t   \", predict=\" + predictedAlt + \", allSubsetsConflict=\" +\n \t\t\t\t\t\t\t\t\t   PredictionMode.AllSubsetsConflict(altSubSets) + \", conflictingAlts=\" +\n@@ -656,7 +656,7 @@ protected void PredicateDFAState(DFAState dfaState, DecisionState decisionState)\n \t\t{\n \t\t\tif (debug || debug_list_atn_decisions)\n \t\t\t{\n-\t\t\t\tConsoleWriteLine(\"execATNWithFullContext \" + s0);\n+\t\t\t\tConsole.WriteLine(\"execATNWithFullContext \" + s0);\n \t\t\t}\n \t\t\tbool fullCtx = true;\n \t\t\tbool foundExactAmbig = false;\n@@ -667,7 +667,7 @@ protected void PredicateDFAState(DFAState dfaState, DecisionState decisionState)\n \t\t\tint predictedAlt;\n \t\t\twhile (true)\n \t\t\t{ // while more work\n-\t\t\t  //\t\t\tConsoleWriteLine(\"LL REACH \"+GetLookaheadName(input)+\n+\t\t\t  //\t\t\tConsole.WriteLine(\"LL REACH \"+GetLookaheadName(input)+\n \t\t\t  //\t\t\t\t\t\t\t   \" from configs.size=\"+previous.size()+\n \t\t\t  //\t\t\t\t\t\t\t   \" line \"+input.LT(1)Line+\":\"+input.LT(1).Column);\n \t\t\t\treach = ComputeReachSet(previous, t, fullCtx);\n@@ -695,13 +695,13 @@ protected void PredicateDFAState(DFAState dfaState, DecisionState decisionState)\n \t\t\t\tICollection<BitSet> altSubSets = PredictionMode.GetConflictingAltSubsets(reach.configs);\n \t\t\t\tif (debug)\n \t\t\t\t{\n-\t\t\t\t\tConsoleWriteLine(\"LL altSubSets=\" + altSubSets +\n+\t\t\t\t\tConsole.WriteLine(\"LL altSubSets=\" + altSubSets +\n \t\t\t\t\t\t\t\t\t   \", predict=\" + PredictionMode.GetUniqueAlt(altSubSets) +\n \t\t\t\t\t\t\t\t\t   \", ResolvesToJustOneViableAlt=\" +\n \t\t\t\t\t\t\t\t\t\t   PredictionMode.ResolvesToJustOneViableAlt(altSubSets));\n \t\t\t\t}\n \n-\t\t\t\t//\t\t\tConsoleWriteLine(\"altSubSets: \"+altSubSets);\n+\t\t\t\t//\t\t\tConsole.WriteLine(\"altSubSets: \"+altSubSets);\n \t\t\t\t//\t\t\tSystem.err.println(\"reach=\"+reach+\", \"+reach.conflictingAlts);\n \t\t\t\treach.uniqueAlt = GetUniqueAlt(reach);\n \t\t\t\t// unique prediction?\n@@ -785,7 +785,7 @@ protected void PredicateDFAState(DFAState dfaState, DecisionState decisionState)\n \t\tprotected virtual ATNConfigSet ComputeReachSet(ATNConfigSet closure, int t, bool fullCtx)\n \t\t{\n \t\t\tif (debug)\n-\t\t\t\tConsoleWriteLine(\"in computeReachSet, starting closure: \" + closure);\n+\t\t\t\tConsole.WriteLine(\"in computeReachSet, starting closure: \" + closure);\n \n \t\t\tif (mergeCache == null)\n \t\t\t{\n@@ -809,7 +809,7 @@ protected virtual ATNConfigSet ComputeReachSet(ATNConfigSet closure, int t, bool\n \t\t\t// First figure out where we can reach on input t\n \t\t\tforeach (ATNConfig c in closure.configs)\n \t\t\t{\n-\t\t\t\tif (debug) ConsoleWriteLine(\"testing \" + GetTokenName(t) + \" at \" + c.ToString());\n+\t\t\t\tif (debug) Console.WriteLine(\"testing \" + GetTokenName(t) + \" at \" + c.ToString());\n \n \t\t\t\tif (c.state is RuleStopState)\n \t\t\t\t{\n@@ -1275,7 +1275,7 @@ protected ATNState GetReachableTarget(Transition trans, int ttype)\n \n \t\t\t// nonambig alts are null in altToPred\n \t\t\tif (nPredAlts == 0) altToPred = null;\n-\t\t\tif (debug) ConsoleWriteLine(\"getPredsForAmbigAlts result \" + Arrays.ToString(altToPred));\n+\t\t\tif (debug) Console.WriteLine(\"getPredsForAmbigAlts result \" + Arrays.ToString(altToPred));\n \t\t\treturn altToPred;\n \t\t}\n \n@@ -1302,7 +1302,7 @@ protected ATNState GetReachableTarget(Transition trans, int ttype)\n \t\t\t\treturn null;\n \t\t\t}\n \n-\t\t\t//\t\tConsoleWriteLine(Arrays.toString(altToPred)+\"->\"+pairs);\n+\t\t\t//\t\tConsole.WriteLine(Arrays.toString(altToPred)+\"->\"+pairs);\n \t\t\treturn pairs.ToArray();\n \t\t}\n \n@@ -1452,12 +1452,12 @@ protected int getAltThatFinishedDecisionEntryRule(ATNConfigSet configSet)\n \t\t\t\tbool predicateEvaluationResult = EvalSemanticContext(pair.pred, outerContext, pair.alt, fullCtx);\n \t\t\t\tif (debug || dfa_debug)\n \t\t\t\t{\n-\t\t\t\t\tConsoleWriteLine(\"eval pred \" + pair + \"=\" + predicateEvaluationResult);\n+\t\t\t\t\tConsole.WriteLine(\"eval pred \" + pair + \"=\" + predicateEvaluationResult);\n \t\t\t\t}\n \n \t\t\t\tif (predicateEvaluationResult)\n \t\t\t\t{\n-\t\t\t\t\tif (debug || dfa_debug) ConsoleWriteLine(\"PREDICT \" + pair.alt);\n+\t\t\t\t\tif (debug || dfa_debug) Console.WriteLine(\"PREDICT \" + pair.alt);\n \t\t\t\t\tpredictions[pair.alt] = true;\n \t\t\t\t\tif (!complete)\n \t\t\t\t\t{\n@@ -1533,7 +1533,7 @@ protected virtual bool EvalSemanticContext(SemanticContext pred, ParserRuleConte\n \t\t\t\t\t\t\t\t\t\t\t\tbool treatEofAsEpsilon)\n \t\t{\n \t\t\tif (debug)\n-\t\t\t\tConsoleWriteLine(\"closure(\" + config.ToString(parser, true) + \")\");\n+\t\t\t\tConsole.WriteLine(\"closure(\" + config.ToString(parser, true) + \")\");\n \n \t\t\tif (config.state is RuleStopState)\n \t\t\t{\n@@ -1552,7 +1552,7 @@ protected virtual bool EvalSemanticContext(SemanticContext pred, ParserRuleConte\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// we have no context info, just chase follow links (if greedy)\n-\t\t\t\t\t\t\t\tif (debug) ConsoleWriteLine(\"FALLING off rule \" +\n+\t\t\t\t\t\t\t\tif (debug) Console.WriteLine(\"FALLING off rule \" +\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  GetRuleName(config.state.ruleIndex));\n \t\t\t\t\t\t\t\tClosure_(config, configSet, closureBusy, collectPredicates,\n \t\t\t\t\t\t\t\t\t\t fullCtx, depth, treatEofAsEpsilon);\n@@ -1583,7 +1583,7 @@ protected virtual bool EvalSemanticContext(SemanticContext pred, ParserRuleConte\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\t// else if we have no context info, just chase follow links (if greedy)\n-\t\t\t\t\tif (debug) ConsoleWriteLine(\"FALLING off rule \" +\n+\t\t\t\t\tif (debug) Console.WriteLine(\"FALLING off rule \" +\n \t\t\t\t\t\t\t\t\t\t\t\t  GetRuleName(config.state.ruleIndex));\n \t\t\t\t}\n \t\t\t}\n@@ -1608,7 +1608,7 @@ protected virtual bool EvalSemanticContext(SemanticContext pred, ParserRuleConte\n \t\t\t\tconfigs.Add(config, mergeCache);\n \t\t\t\t// make sure to not return here, because EOF transitions can act as\n \t\t\t\t// both epsilon transitions and non-epsilon transitions.\n-\t\t\t\t//            if ( debug ) ConsoleWriteLine(\"added config \"+configs);\n+\t\t\t\t//            if ( debug ) Console.WriteLine(\"added config \"+configs);\n \t\t\t}\n \n \t\t\tfor (int i = 0; i < p.NumberOfTransitions; i++)\n@@ -1650,7 +1650,7 @@ protected virtual bool EvalSemanticContext(SemanticContext pred, ParserRuleConte\n \t\t\t\t\t\tconfigs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n \t\t\t\t\t\tnewDepth--;\n \t\t\t\t\t\tif (debug)\n-\t\t\t\t\t\t\tConsoleWriteLine(\"dips into outer ctx: \" + c);\n+\t\t\t\t\t\t\tConsole.WriteLine(\"dips into outer ctx: \" + c);\n \t\t\t\t\t}\n \t\t\t\t\telse\n \t\t\t\t\t{\n@@ -1898,7 +1898,7 @@ public string GetRuleName(int index)\n \n \t\tprotected ATNConfig ActionTransition(ATNConfig config, ActionTransition t)\n \t\t{\n-\t\t\tif (debug) ConsoleWriteLine(\"ACTION edge \" + t.ruleIndex + \":\" + t.actionIndex);\n+\t\t\tif (debug) Console.WriteLine(\"ACTION edge \" + t.ruleIndex + \":\" + t.actionIndex);\n \t\t\treturn new ATNConfig(config, t.target);\n \t\t}\n \n@@ -1911,13 +1911,13 @@ protected ATNConfig ActionTransition(ATNConfig config, ActionTransition t)\n \t\t{\n \t\t\tif (debug)\n \t\t\t{\n-\t\t\t\tConsoleWriteLine(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\n+\t\t\t\tConsole.WriteLine(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\n \t\t\t\t\t\tpt.precedence + \">=_p\" +\n \t\t\t\t\t\t\", ctx dependent=true\");\n \t\t\t\tif (parser != null)\n \t\t\t\t{\n-\t\t\t\t\tConsoleWriteLine(\"context surrounding pred is \" +\n-\t\t\t\t\t\t\t\t\t   parser.GetRuleInvocationStack());\n+\t\t\t\t\tConsole.WriteLine(\"context surrounding pred is \" +\n+\t\t\t\t\t\t\t\t\t   StaticUtils.ToString(parser.GetRuleInvocationStack()));\n \t\t\t\t}\n \t\t\t}\n \n@@ -1948,7 +1948,7 @@ protected ATNConfig ActionTransition(ATNConfig config, ActionTransition t)\n \t\t\t\tc = new ATNConfig(config, pt.target);\n \t\t\t}\n \n-\t\t\tif (debug) ConsoleWriteLine(\"config from pred transition=\" + c);\n+\t\t\tif (debug) Console.WriteLine(\"config from pred transition=\" + c);\n \t\t\treturn c;\n \t\t}\n \n@@ -1961,13 +1961,13 @@ protected ATNConfig ActionTransition(ATNConfig config, ActionTransition t)\n \t\t{\n \t\t\tif (debug)\n \t\t\t{\n-\t\t\t\tConsoleWriteLine(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\n+\t\t\t\tConsole.WriteLine(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\n \t\t\t\t\t\tpt.ruleIndex + \":\" + pt.predIndex +\n \t\t\t\t\t\t\", ctx dependent=\" + pt.isCtxDependent);\n \t\t\t\tif (parser != null)\n \t\t\t\t{\n-\t\t\t\t\tConsoleWriteLine(\"context surrounding pred is \" +\n-\t\t\t\t\t\t\t\t\t   parser.GetRuleInvocationStack());\n+\t\t\t\t\tConsole.WriteLine(\"context surrounding pred is \" +\n+\t\t\t\t\t\t\t\t\t   StaticUtils.ToString(parser.GetRuleInvocationStack()));\n \t\t\t\t}\n \t\t\t}\n \n@@ -1999,7 +1999,7 @@ protected ATNConfig ActionTransition(ATNConfig config, ActionTransition t)\n \t\t\t\tc = new ATNConfig(config, pt.target);\n \t\t\t}\n \n-\t\t\tif (debug) ConsoleWriteLine(\"config from pred transition=\" + c);\n+\t\t\tif (debug) Console.WriteLine(\"config from pred transition=\" + c);\n \t\t\treturn c;\n \t\t}\n \n@@ -2008,7 +2008,7 @@ protected ATNConfig RuleTransition(ATNConfig config, RuleTransition t)\n \t\t{\n \t\t\tif (debug)\n \t\t\t{\n-\t\t\t\tConsoleWriteLine(\"CALL rule \" + GetRuleName(t.target.ruleIndex) +\n+\t\t\t\tConsole.WriteLine(\"CALL rule \" + GetRuleName(t.target.ruleIndex) +\n \t\t\t\t\t\t\t\t   \", ctx=\" + config.context);\n \t\t\t}\n \n@@ -2192,7 +2192,7 @@ protected static int GetUniqueAlt(ATNConfigSet configSet)\n \t\t{\n \t\t\tif (debug)\n \t\t\t{\n-\t\t\t\tConsoleWriteLine(\"EDGE \" + from + \" -> \" + to + \" upon \" + GetTokenName(t));\n+\t\t\t\tConsole.WriteLine(\"EDGE \" + from + \" -> \" + to + \" upon \" + GetTokenName(t));\n \t\t\t}\n \n \t\t\tif (to == null)\n@@ -2218,7 +2218,7 @@ protected static int GetUniqueAlt(ATNConfigSet configSet)\n \n \t\t\tif (debug)\n \t\t\t{\n-\t\t\t\tConsoleWriteLine(\"DFA=\\n\" + dfa.ToString(parser != null ? parser.Vocabulary : Vocabulary.EmptyVocabulary));\n+\t\t\t\tConsole.WriteLine(\"DFA=\\n\" + dfa.ToString(parser != null ? parser.Vocabulary : Vocabulary.EmptyVocabulary));\n \t\t\t}\n \n \t\t\treturn to;\n@@ -2258,7 +2258,7 @@ protected DFAState AddDFAState(DFA dfa, DFAState D)\n \t\t\t\t\tD.configSet.IsReadOnly = true;\n \t\t\t\t}\n \t\t\t\tdfa.states.Put(D, D);\n-\t\t\t\tif (debug) ConsoleWriteLine(\"adding new DFA state: \" + D);\n+\t\t\t\tif (debug) Console.WriteLine(\"adding new DFA state: \" + D);\n \t\t\t\treturn D;\n \t\t\t}\n \t\t}\n@@ -2268,7 +2268,7 @@ protected virtual void ReportAttemptingFullContext(DFA dfa, BitSet conflictingAl\n \t\t\tif (debug || retry_debug)\n \t\t\t{\n \t\t\t\tInterval interval = Interval.Of(startIndex, stopIndex);\n-\t\t\t\tConsoleWriteLine(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + configs +\n+\t\t\t\tConsole.WriteLine(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + configs +\n \t\t\t\t\t\t\t\t   \", input=\" + parser.TokenStream.GetText(interval));\n \t\t\t}\n \t\t\tif (parser != null)\n@@ -2280,7 +2280,7 @@ protected virtual void ReportContextSensitivity(DFA dfa, int prediction, ATNConf\n \t\t\tif (debug || retry_debug)\n \t\t\t{\n \t\t\t\tInterval interval = Interval.Of(startIndex, stopIndex);\n-\t\t\t\tConsoleWriteLine(\"ReportContextSensitivity decision=\" + dfa.decision + \":\" + configs +\n+\t\t\t\tConsole.WriteLine(\"ReportContextSensitivity decision=\" + dfa.decision + \":\" + configs +\n \t\t\t\t\t\t\t\t   \", input=\" + parser.TokenStream.GetText(interval));\n \t\t\t}\n \t\t\tif (parser != null) parser.ErrorListenerDispatch.ReportContextSensitivity(parser, dfa, startIndex, stopIndex, prediction, null /*configs*/);\n@@ -2297,7 +2297,7 @@ protected virtual void ReportContextSensitivity(DFA dfa, int prediction, ATNConf\n \t\t\tif (debug || retry_debug)\n \t\t\t{\n \t\t\t\tInterval interval = Interval.Of(startIndex, stopIndex);\n-\t\t\t\tConsoleWriteLine(\"ReportAmbiguity \" +\n+\t\t\t\tConsole.WriteLine(\"ReportAmbiguity \" +\n \t\t\t\t\t\t\t\t   ambigAlts + \":\" + configs +\n \t\t\t\t\t\t\t\t   \", input=\" + parser.TokenStream.GetText(interval));\n \t\t\t}"
  },
  {
    "sha": "2484a05a19d2e361457088a7f3faa86bb4d09e04",
    "filename": "runtime/CSharp/src/Misc/Utils.cs",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/antlr/antlr4/blob/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/src/Misc/Utils.cs",
    "raw_url": "https://github.com/antlr/antlr4/raw/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/src/Misc/Utils.cs",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/CSharp/src/Misc/Utils.cs?ref=12dcef6676a0d34c676899b2c3ed12bfbb6c6a82",
    "patch": "@@ -8,6 +8,14 @@\n \n namespace Antlr4.Runtime.Misc\n {\n+    public static class StaticUtils\n+    {\n+        public static string ToString<T>(this IEnumerable<T> list)\n+        {\n+            return \"[\" + Utils.Join(\", \", list) + \"]\";\n+        }\n+    }\n+\n     public class Utils\n     {\n         public static string Join<T>(string separator, IEnumerable<T> items)"
  },
  {
    "sha": "4768052b0f9c411ad850cea82c2d78f73af69529",
    "filename": "runtime/CSharp/tests/issue-2693/Test.sln",
    "status": "added",
    "additions": 31,
    "deletions": 0,
    "changes": 31,
    "blob_url": "https://github.com/antlr/antlr4/blob/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-2693/Test.sln",
    "raw_url": "https://github.com/antlr/antlr4/raw/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-2693/Test.sln",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/CSharp/tests/issue-2693/Test.sln?ref=12dcef6676a0d34c676899b2c3ed12bfbb6c6a82",
    "patch": "@@ -0,0 +1,31 @@\n+﻿\n+Microsoft Visual Studio Solution File, Format Version 12.00\n+# Visual Studio Version 16\n+VisualStudioVersion = 16.0.31019.35\n+MinimumVisualStudioVersion = 10.0.40219.1\n+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Test\", \"Test.csproj\", \"{FD11E8CC-1631-4FF3-9B44-F10084562311}\"\n+EndProject\n+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Antlr4\", \"..\\..\\src\\Antlr4.csproj\", \"{A60B5000-4473-4D00-85C4-C3A4B469F608}\"\n+EndProject\n+Global\n+\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n+\t\tDebug|Any CPU = Debug|Any CPU\n+\t\tRelease|Any CPU = Release|Any CPU\n+\tEndGlobalSection\n+\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n+\t\t{FD11E8CC-1631-4FF3-9B44-F10084562311}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n+\t\t{FD11E8CC-1631-4FF3-9B44-F10084562311}.Debug|Any CPU.Build.0 = Debug|Any CPU\n+\t\t{FD11E8CC-1631-4FF3-9B44-F10084562311}.Release|Any CPU.ActiveCfg = Release|Any CPU\n+\t\t{FD11E8CC-1631-4FF3-9B44-F10084562311}.Release|Any CPU.Build.0 = Release|Any CPU\n+\t\t{A60B5000-4473-4D00-85C4-C3A4B469F608}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n+\t\t{A60B5000-4473-4D00-85C4-C3A4B469F608}.Debug|Any CPU.Build.0 = Debug|Any CPU\n+\t\t{A60B5000-4473-4D00-85C4-C3A4B469F608}.Release|Any CPU.ActiveCfg = Release|Any CPU\n+\t\t{A60B5000-4473-4D00-85C4-C3A4B469F608}.Release|Any CPU.Build.0 = Release|Any CPU\n+\tEndGlobalSection\n+\tGlobalSection(SolutionProperties) = preSolution\n+\t\tHideSolutionNode = FALSE\n+\tEndGlobalSection\n+\tGlobalSection(ExtensibilityGlobals) = postSolution\n+\t\tSolutionGuid = {2FFB66F7-2552-4F2B-B97E-77B5F8743ED4}\n+\tEndGlobalSection\n+EndGlobal"
  },
  {
    "sha": "672ebbaca328c5ad639402637469e2cae466f376",
    "filename": "runtime/CSharp/tests/issue-3079/Arithmetic.g4",
    "status": "added",
    "additions": 33,
    "deletions": 0,
    "changes": 33,
    "blob_url": "https://github.com/antlr/antlr4/blob/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-3079/Arithmetic.g4",
    "raw_url": "https://github.com/antlr/antlr4/raw/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-3079/Arithmetic.g4",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/CSharp/tests/issue-3079/Arithmetic.g4?ref=12dcef6676a0d34c676899b2c3ed12bfbb6c6a82",
    "patch": "@@ -0,0 +1,33 @@\n+\n+// Template generated code from Antlr4BuildTasks.dotnet-antlr v 2.2\n+\n+grammar Arithmetic;\n+\n+file : expression (SEMI expression)* EOF;\n+expression : expression POW expression | expression (TIMES | DIV) expression | expression (PLUS | MINUS) expression | LPAREN expression RPAREN | (PLUS | MINUS)* atom ;\n+atom : scientific | variable ;\n+scientific : SCIENTIFIC_NUMBER ;\n+variable : VARIABLE ;\n+\n+VARIABLE : VALID_ID_START VALID_ID_CHAR* ;\n+SCIENTIFIC_NUMBER : NUMBER (E SIGN? UNSIGNED_INTEGER)? ;\n+LPAREN : '(' ;\n+RPAREN : ')' ;\n+PLUS : '+' ;\n+MINUS : '-' ;\n+TIMES : '*' ;\n+DIV : '/' ;\n+GT : '>' ;\n+LT : '<' ;\n+EQ : '=' ;\n+POINT : '.' ;\n+POW : '^' ;\n+SEMI : ';' ;\n+WS : [ \\r\\n\\t] + -> channel(HIDDEN) ;\n+\n+fragment VALID_ID_START : ('a' .. 'z') | ('A' .. 'Z') | '_' ;\n+fragment VALID_ID_CHAR : VALID_ID_START | ('0' .. '9') ;\n+fragment NUMBER : ('0' .. '9') + ('.' ('0' .. '9') +)? ;\n+fragment UNSIGNED_INTEGER : ('0' .. '9')+ ;\n+fragment E : 'E' | 'e' ;\n+fragment SIGN : ('+' | '-') ;"
  },
  {
    "sha": "094eda52c7c7c75aadf0dc05e5bb73776b5019ab",
    "filename": "runtime/CSharp/tests/issue-3079/ErrorListener.cs",
    "status": "added",
    "additions": 20,
    "deletions": 0,
    "changes": 20,
    "blob_url": "https://github.com/antlr/antlr4/blob/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-3079/ErrorListener.cs",
    "raw_url": "https://github.com/antlr/antlr4/raw/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-3079/ErrorListener.cs",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/CSharp/tests/issue-3079/ErrorListener.cs?ref=12dcef6676a0d34c676899b2c3ed12bfbb6c6a82",
    "patch": "@@ -0,0 +1,20 @@\n+// Template generated code from Antlr4BuildTasks.dotnet-antlr v 2.2\n+\n+using Antlr4.Runtime;\n+using Antlr4.Runtime.Misc;\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Linq;\n+\n+public class ErrorListener<S> : ConsoleErrorListener<S>\n+{\n+    public bool had_error;\n+\n+    public override void SyntaxError(TextWriter output, IRecognizer recognizer, S offendingSymbol, int line,\n+        int col, string msg, RecognitionException e)\n+    {\n+        had_error = true;\n+        base.SyntaxError(output, recognizer, offendingSymbol, line, col, msg, e);\n+    }\n+}"
  },
  {
    "sha": "3f74094153f57d77136a3a6706baecd3354b986a",
    "filename": "runtime/CSharp/tests/issue-3079/Program.cs",
    "status": "added",
    "additions": 110,
    "deletions": 0,
    "changes": 110,
    "blob_url": "https://github.com/antlr/antlr4/blob/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-3079/Program.cs",
    "raw_url": "https://github.com/antlr/antlr4/raw/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-3079/Program.cs",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/CSharp/tests/issue-3079/Program.cs?ref=12dcef6676a0d34c676899b2c3ed12bfbb6c6a82",
    "patch": "@@ -0,0 +1,110 @@\n+// Template generated code from Antlr4BuildTasks.dotnet-antlr v 2.2\n+\n+using Antlr4.Runtime;\n+using Antlr4.Runtime.Tree;\n+using System;\n+using System.IO;\n+using System.Linq;\n+using System.Text;\n+using System.Runtime.CompilerServices;\n+\n+public class Program\n+{\n+    public static Parser Parser { get; set; }\n+    public static Lexer Lexer { get; set; }\n+    public static ITokenStream TokenStream { get; set; }\n+    public static IParseTree Tree { get; set; }\n+    public static IParseTree Parse(string input)\n+    {\n+        var str = new AntlrInputStream(input);\n+        var lexer = new ArithmeticLexer(str);\n+        Lexer = lexer;\n+        var tokens = new CommonTokenStream(lexer);\n+        TokenStream = tokens;\n+        var parser = new ArithmeticParser(tokens);\n+        Parser = parser;\n+        var tree = parser.file();\n+        Tree = tree;\n+        return tree;\n+    }\n+\n+    static void Main(string[] args)\n+    {\n+        bool show_tree = false;\n+        bool show_tokens = false;\n+        string file_name = null;\n+        string input = null;\n+        for (int i = 0; i < args.Length; ++i)\n+        {\n+            if (args[i].Equals(\"-tokens\"))\n+            {\n+                show_tokens = true;\n+                continue;\n+            }\n+            else if (args[i].Equals(\"-tree\"))\n+            {\n+                show_tree = true;\n+                continue;\n+            }\n+            else if (args[i].Equals(\"-input\"))\n+                input = args[++i];\n+            else if (args[i].Equals(\"-file\"))\n+                file_name = args[++i];\n+        }\n+        ICharStream str = null;\n+        if (input == null && file_name == null)\n+        {\n+            StringBuilder sb = new StringBuilder();\n+            int ch;\n+            while ((ch = System.Console.Read()) != -1)\n+            {\n+                sb.Append((char)ch);\n+            }\n+            input = sb.ToString();\n+            \n+str = CharStreams.fromString(input);\n+        } else if (input != null)\n+        {\n+            str = CharStreams.fromString(input);\n+        } else if (file_name != null)\n+        {\n+            str = CharStreams.fromPath(file_name);\n+        }\n+        var lexer = new ArithmeticLexer(str);\n+        if (show_tokens)\n+        {\n+            StringBuilder new_s = new StringBuilder();\n+            for (int i = 0; ; ++i)\n+            {\n+                var ro_token = lexer.NextToken();\n+                var token = (CommonToken)ro_token;\n+                token.TokenIndex = i;\n+                new_s.AppendLine(token.ToString());\n+                if (token.Type == Antlr4.Runtime.TokenConstants.EOF)\n+                    break;\n+            }\n+            System.Console.Error.WriteLine(new_s.ToString());\n+            lexer.Reset();\n+        }\n+        var tokens = new CommonTokenStream(lexer);\n+        var parser = new ArithmeticParser(tokens);\n+        var listener_lexer = new ErrorListener<int>();\n+        var listener_parser = new ErrorListener<IToken>();\n+        lexer.AddErrorListener(listener_lexer);\n+        parser.AddErrorListener(listener_parser);\n+        var tree = parser.file();\n+        if (listener_lexer.had_error || listener_parser.had_error)\n+        {\n+            System.Console.Error.WriteLine(\"parse failed.\");\n+        }\n+        else\n+        {\n+            System.Console.Error.WriteLine(\"parse succeeded.\");\n+        }\n+        if (show_tree)\n+        {\n+            System.Console.Error.WriteLine(tree.ToStringTree(parser));\n+        }\n+        System.Environment.Exit(listener_lexer.had_error || listener_parser.had_error ? 1 : 0);\n+    }\n+}"
  },
  {
    "sha": "6984882ae574b126159fa97daa5076b7e2aedb47",
    "filename": "runtime/CSharp/tests/issue-3079/Test.csproj",
    "status": "added",
    "additions": 65,
    "deletions": 0,
    "changes": 65,
    "blob_url": "https://github.com/antlr/antlr4/blob/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-3079/Test.csproj",
    "raw_url": "https://github.com/antlr/antlr4/raw/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-3079/Test.csproj",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/CSharp/tests/issue-3079/Test.csproj?ref=12dcef6676a0d34c676899b2c3ed12bfbb6c6a82",
    "patch": "@@ -0,0 +1,65 @@\n+﻿<!-- Template generated code from Antlr4BuildTasks.dotnet-antlr v 2.2 -->\n+<Project Sdk=\"Microsoft.NET.Sdk\" >\n+  <PropertyGroup>\n+    <TargetFramework>net5.0</TargetFramework>\n+    <OutputType>Exe</OutputType>\n+  </PropertyGroup>\n+  \n+  <ItemGroup>\n+    <Antlr4 Include=\"Arithmetic.g4\" />\n+  </ItemGroup>\n+  \n+  <PropertyGroup>\n+    <AntlrToolPath>../../../../tool/target/antlr4-*-SNAPSHOT-complete.jar</AntlrToolPath>\n+  </PropertyGroup>\n+\n+  <ItemGroup>\n+    <ProjectReference Include=\"../../src/Antlr4.csproj\" />\n+    <PackageReference Include=\"Antlr4BuildTasks\" Version = \"8.13\" PrivateAssets=\"all\" />\n+  </ItemGroup>\n+\n+  <PropertyGroup>\n+    <RestoreProjectStyle>PackageReference</RestoreProjectStyle>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|AnyCPU'\" >\n+    <NoWarn>1701;1702;3021</NoWarn>\n+  </PropertyGroup>\n+\n+  <PropertyGroup>\n+    <!--\n+      need the CData since this blob is just going to\n+      be embedded in a mini batch file by studio/msbuild\n+    -->\n+    <MyTester><![CDATA[\n+\n+set ERR=0\n+for %%G in (..\\examples\\*) do (\n+  setlocal EnableDelayedExpansion\n+  set FILE=%%G\n+  set X1=%%~xG\n+  set X2=%%~nG\n+  set X3=%%~pG\n+  if !X1! neq .errors (\n+    echo !FILE!\n+    cat !FILE! | bin\\Debug\\net5.0\\Test.exe\n+    if not exist !FILE!.errors (\n+      if ERRORLEVEL 1 set ERR=1\n+    ) else (\n+      echo Expected.\n+    )\n+  )\n+)\n+EXIT %ERR%\n+\n+]]></MyTester>\n+</PropertyGroup>\n+\n+  <Target Name=\"Test\" >\n+    <Message Text=\"testing\" />\n+    <Exec Command=\"$(MyTester)\" >\n+       <Output TaskParameter=\"ExitCode\" PropertyName =\"ErrorCode\" />\n+    </Exec>\n+    <Message Importance=\"high\" Text=\"$(ErrorCode)\"/>\n+  </Target>\n+\n+</Project>"
  },
  {
    "sha": "f4f77747aced5a270fffaa6a88fabe346e2615b1",
    "filename": "runtime/CSharp/tests/issue-3079/Test.sln",
    "status": "added",
    "additions": 31,
    "deletions": 0,
    "changes": 31,
    "blob_url": "https://github.com/antlr/antlr4/blob/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-3079/Test.sln",
    "raw_url": "https://github.com/antlr/antlr4/raw/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-3079/Test.sln",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/CSharp/tests/issue-3079/Test.sln?ref=12dcef6676a0d34c676899b2c3ed12bfbb6c6a82",
    "patch": "@@ -0,0 +1,31 @@\n+﻿\n+Microsoft Visual Studio Solution File, Format Version 12.00\n+# Visual Studio Version 16\n+VisualStudioVersion = 16.0.31019.35\n+MinimumVisualStudioVersion = 10.0.40219.1\n+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Test\", \"Test.csproj\", \"{1B229E17-E0E5-4D3B-8978-A4E61B9233E5}\"\n+EndProject\n+Project(\"{9A19103F-16F7-4668-BE54-9A1E7A4F7556}\") = \"Antlr4\", \"..\\..\\src\\Antlr4.csproj\", \"{95247929-4C60-4CDF-B202-1BAE1C12AA57}\"\n+EndProject\n+Global\n+\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n+\t\tDebug|Any CPU = Debug|Any CPU\n+\t\tRelease|Any CPU = Release|Any CPU\n+\tEndGlobalSection\n+\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n+\t\t{1B229E17-E0E5-4D3B-8978-A4E61B9233E5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n+\t\t{1B229E17-E0E5-4D3B-8978-A4E61B9233E5}.Debug|Any CPU.Build.0 = Debug|Any CPU\n+\t\t{1B229E17-E0E5-4D3B-8978-A4E61B9233E5}.Release|Any CPU.ActiveCfg = Release|Any CPU\n+\t\t{1B229E17-E0E5-4D3B-8978-A4E61B9233E5}.Release|Any CPU.Build.0 = Release|Any CPU\n+\t\t{95247929-4C60-4CDF-B202-1BAE1C12AA57}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n+\t\t{95247929-4C60-4CDF-B202-1BAE1C12AA57}.Debug|Any CPU.Build.0 = Debug|Any CPU\n+\t\t{95247929-4C60-4CDF-B202-1BAE1C12AA57}.Release|Any CPU.ActiveCfg = Release|Any CPU\n+\t\t{95247929-4C60-4CDF-B202-1BAE1C12AA57}.Release|Any CPU.Build.0 = Release|Any CPU\n+\tEndGlobalSection\n+\tGlobalSection(SolutionProperties) = preSolution\n+\t\tHideSolutionNode = FALSE\n+\tEndGlobalSection\n+\tGlobalSection(ExtensibilityGlobals) = postSolution\n+\t\tSolutionGuid = {4819731D-3C62-4CFA-A99C-09103728C086}\n+\tEndGlobalSection\n+EndGlobal"
  },
  {
    "sha": "e68f2a53bf2dd7299ee9986a8b1ea8a424513b01",
    "filename": "runtime/CSharp/tests/issue-3079/readme.md",
    "status": "added",
    "additions": 10,
    "deletions": 0,
    "changes": 10,
    "blob_url": "https://github.com/antlr/antlr4/blob/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-3079/readme.md",
    "raw_url": "https://github.com/antlr/antlr4/raw/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-3079/readme.md",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/CSharp/tests/issue-3079/readme.md?ref=12dcef6676a0d34c676899b2c3ed12bfbb6c6a82",
    "patch": "@@ -0,0 +1,10 @@\n+# How to test Issue 3079\n+\n+1) Build the Antlr Tool first.\n+2) `bash test.sh` in this directory.\n+\n+NB: The CSharp runtime source is modified by the test.sh script to\n+change \"debug = true;\" for ParserATNSimulator.cs. There is no way to\n+change the value of the static readonly variable using System.Reflection\n+after the static initializer for the class has loaded. This is why\n+it is change in the source here for this test and only this test."
  },
  {
    "sha": "49f63139954b077c48d1a9e2b23789f0a403bf61",
    "filename": "runtime/CSharp/tests/issue-3079/test.sh",
    "status": "added",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/antlr/antlr4/blob/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-3079/test.sh",
    "raw_url": "https://github.com/antlr/antlr4/raw/12dcef6676a0d34c676899b2c3ed12bfbb6c6a82/runtime/CSharp/tests/issue-3079/test.sh",
    "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime/CSharp/tests/issue-3079/test.sh?ref=12dcef6676a0d34c676899b2c3ed12bfbb6c6a82",
    "patch": "@@ -0,0 +1,14 @@\n+#\n+\n+cat ../../src/Atn/ParserATNSimulator.cs > ParserATNSimulator.save\n+cat ParserATNSimulator.save | sed 's/bool debug = false;/bool debug = true;/' > ../../src/Atn/ParserATNSimulator.cs\n+dotnet restore\n+dotnet build\n+dotnet run -input \"1+2\"\n+if [[ \"$?\" != \"0\" ]]\n+then\n+    echo \"Issue 2693 test failed.\"\n+    exit 1\n+else\n+    echo \"Test passed--did not crash.\"\n+fi"
  }
]
