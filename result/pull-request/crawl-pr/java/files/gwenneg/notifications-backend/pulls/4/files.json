[
  {
    "sha": "17b1513d758618d594284ff23fc9af70a743fe50",
    "filename": "pom.xml",
    "status": "modified",
    "additions": 9,
    "deletions": 22,
    "changes": 31,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/pom.xml",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/pom.xml",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/pom.xml?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -13,17 +13,13 @@\n         <maven.compiler.target>11</maven.compiler.target>\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n-        <quarkus.platform.version>1.10.1.Final</quarkus.platform.version>\n+        <quarkus.platform.version>1.12.2.Final</quarkus.platform.version>\n         <quarkus-plugin.version>${quarkus.platform.version}</quarkus-plugin.version>\n         <quarkus.platform.artifact-id>quarkus-bom</quarkus.platform.artifact-id>\n         <quarkus.platform.group-id>io.quarkus</quarkus.platform.group-id>\n         <surefire-plugin.version>2.22.1</surefire-plugin.version>\n-        <!-- r2dbc versions do not necessarily align -->\n-        <r2dbc-postgres.version>0.8.6.RELEASE</r2dbc-postgres.version>\n-        <r2dbc-pool.version>0.8.5.RELEASE</r2dbc-pool.version>\n         <checkstyle-plugin.version>3.1.1</checkstyle-plugin.version>\n         <checkstyle.version>8.36.2</checkstyle.version>\n-        <mutiny-reactor.version>0.10.0</mutiny-reactor.version>\n         <testcontainers.version>1.15.1</testcontainers.version>\n         <mockserver-client-java.version>5.5.4</mockserver-client-java.version> <!-- not the newest, but matches what is in org.testcontainers:mockserver -->\n         <version.cloud-commons>0.1.1</version.cloud-commons>\n@@ -119,6 +115,14 @@\n             <groupId>io.quarkus</groupId>\n             <artifactId>quarkus-resteasy-qute</artifactId>\n         </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-hibernate-reactive</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-reactive-pg-client</artifactId>\n+        </dependency>\n \n         <!-- Related to Quarkus, but outside the Quarkus namespace -->\n         <!-- https://github.com/quarkusio/quarkus/issues/12913 -->\n@@ -135,11 +139,6 @@\n             <groupId>io.smallrye.reactive</groupId>\n             <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n         </dependency>\n-        <dependency>\n-            <groupId>io.smallrye.reactive</groupId>\n-            <artifactId>mutiny-reactor</artifactId>\n-            <version>${mutiny-reactor.version}</version>\n-        </dependency>\n \n         <!-- Flyway specific dependencies -->\n         <dependency>\n@@ -151,18 +150,6 @@\n             <artifactId>quarkus-jdbc-postgresql</artifactId>\n         </dependency>\n \n-        <!-- R2DBC dependencies -->\n-        <dependency>\n-            <groupId>io.r2dbc</groupId> <!-- org.postgresql after 0.9.* -->\n-            <artifactId>r2dbc-postgresql</artifactId>\n-            <version>${r2dbc-postgres.version}</version>\n-        </dependency>\n-        <dependency>\n-            <groupId>io.r2dbc</groupId>\n-            <artifactId>r2dbc-pool</artifactId>\n-            <version>${r2dbc-pool.version}</version>\n-        </dependency>\n-\n         <!-- Test dependencies -->\n         <dependency>\n             <groupId>io.quarkus</groupId>"
  },
  {
    "sha": "273a765eb745680f47459d1485ee8c8cce9133d9",
    "filename": "src/main/java/com/redhat/cloud/notifications/auth/RHIdentityAuthMechanism.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/auth/RHIdentityAuthMechanism.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/auth/RHIdentityAuthMechanism.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/auth/RHIdentityAuthMechanism.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -51,7 +51,7 @@\n                     good = true;\n                 }\n             } else if (path.startsWith(\"/openapi.json\") || path.startsWith(\"/internal\")\n-                    || path.startsWith(\"/admin\") || path.startsWith(\"/health\")) {\n+                    || path.startsWith(\"/admin\") || path.startsWith(\"/health\") || path.startsWith(\"/q/health\")) {\n                 good = true;\n             }\n "
  },
  {
    "sha": "cf02f8f7a84ca690ab19448302fda2dbd6c75ede",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/AbstractGenericResource.java",
    "status": "removed",
    "additions": 0,
    "deletions": 37,
    "changes": 37,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/4513da97584698a734a26e462b7a52632db1a981/src/main/java/com/redhat/cloud/notifications/db/AbstractGenericResource.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/4513da97584698a734a26e462b7a52632db1a981/src/main/java/com/redhat/cloud/notifications/db/AbstractGenericResource.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/AbstractGenericResource.java?ref=4513da97584698a734a26e462b7a52632db1a981",
    "patch": "@@ -1,37 +0,0 @@\n-package com.redhat.cloud.notifications.db;\n-\n-import io.r2dbc.postgresql.api.PostgresqlConnection;\n-import io.r2dbc.postgresql.api.PostgresqlResult;\n-import io.smallrye.mutiny.Multi;\n-import io.smallrye.mutiny.Uni;\n-import reactor.core.publisher.Flux;\n-\n-import javax.inject.Inject;\n-import javax.inject.Provider;\n-import java.util.UUID;\n-\n-/**\n- * A base class for some of the resources stuff\n- */\n-public abstract class AbstractGenericResource {\n-\n-    @Inject\n-    Provider<Uni<PostgresqlConnection>> connectionPublisher;\n-\n-    protected Uni<Boolean> runDeleteQuery(UUID eventTypeId, String query) {\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                    c2 -> {\n-                        Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                .bind(\"$1\", eventTypeId)\n-                                .execute();\n-                        return execute.flatMap(PostgresqlResult::getRowsUpdated)\n-                                .map(i -> true).next();\n-\n-                    })\n-                    .withFinalizer(postgresqlConnection -> {\n-                        postgresqlConnection.close().subscribe();\n-                    })\n-                ).toUni();\n-    }\n-}"
  },
  {
    "sha": "d4758844bf620c1595ffa9d7244fe519742c9e2a",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/ApplicationResources.java",
    "status": "modified",
    "additions": 96,
    "deletions": 222,
    "changes": 318,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/ApplicationResources.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/ApplicationResources.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/ApplicationResources.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -1,274 +1,148 @@\n package com.redhat.cloud.notifications.db;\n \n import com.redhat.cloud.notifications.models.Application;\n+import com.redhat.cloud.notifications.models.Bundle;\n import com.redhat.cloud.notifications.models.EventType;\n-import io.r2dbc.postgresql.api.PostgresqlConnection;\n-import io.r2dbc.postgresql.api.PostgresqlResult;\n-import io.r2dbc.postgresql.api.PostgresqlStatement;\n import io.smallrye.mutiny.Multi;\n import io.smallrye.mutiny.Uni;\n-import reactor.core.publisher.Flux;\n+import org.hibernate.reactive.mutiny.Mutiny;\n \n import javax.enterprise.context.ApplicationScoped;\n import javax.inject.Inject;\n-import javax.inject.Provider;\n import javax.validation.constraints.NotNull;\n-import java.util.Date;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.Set;\n import java.util.UUID;\n \n @ApplicationScoped\n-public class ApplicationResources extends AbstractGenericResource {\n+public class ApplicationResources {\n \n-    private static final String APPLICATION_QUERY = \"SELECT a.id, a.name, a.display_name, a.created, a.updated, a.bundle_id FROM public.applications a\";\n-    private static final String APPLICATION_QUERY_BY_BUNDLE_NAME = APPLICATION_QUERY + \" JOIN bundles AS b ON a.bundle_id = b.id WHERE b.name = $1\";\n     @Inject\n-    Provider<Uni<PostgresqlConnection>> connectionPublisher;\n+    Mutiny.Session session;\n \n     public Uni<Application> createApplication(Application app) {\n-        String query = \"INSERT INTO public.applications (name, display_name, bundle_id) VALUES ($1, $2, $3)\";\n-        // Return filled with id\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> c2.createStatement(query)\n-                                .bind(\"$1\", app.getName())\n-                                .bind(\"$2\", app.getDisplay_name())\n-                                .bind(\"$3\", app.getBundleId())\n-                                .returnGeneratedValues(\"id\", \"created\")\n-                                .execute()\n-                                .flatMap(res -> res.map((row, rowMetadata) -> {\n-                                    app.setId(row.get(\"id\", UUID.class));\n-                                    app.setCreated(row.get(\"created\", Date.class));\n-                                    return app;\n-                                })))\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        // The returned app will contain an ID and a creation timestamp.\n+        return Uni.createFrom().item(app)\n+                .onItem().transform(this::addBundleReference)\n+                .onItem().transformToUni(session::persist)\n+                .call(session::flush)\n+                .replaceWith(app);\n     }\n \n-    public Uni<Boolean> deleteApplication(UUID applicationId) {\n-        String query = \"DELETE FROM public.applications WHERE id = $1\";\n-\n-        return runDeleteQuery(applicationId, query);\n+    public Uni<Boolean> deleteApplication(UUID id) {\n+        String query = \"DELETE FROM Application WHERE id = :id\";\n+        return session.createQuery(query)\n+                .setParameter(\"id\", id)\n+                .executeUpdate()\n+                .call(session::flush)\n+                .onItem().transform(rowCount -> rowCount > 0);\n     }\n \n-    public Uni<EventType> addEventTypeToApplication(UUID applicationId, EventType type) {\n-        String insertQuery = \"INSERT INTO public.event_type (name, display_name, application_id, description) VALUES ($1, $2, $3, $4)\";\n-\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            PostgresqlStatement bind = c2.createStatement(insertQuery)\n-                                    .bind(\"$1\", type.getName())\n-                                    .bind(\"$2\", type.getDisplay_name())\n-                                    .bind(\"$3\", applicationId)\n-\n-                                    .returnGeneratedValues(\"id\");\n-\n-                            if (type.getDescription() != null) {\n-                                bind.bind(\"$4\", type.getDescription());\n-                            } else {\n-                                bind.bindNull(\"$4\", String.class);\n-                            }\n-\n-                            return bind\n-                                    .execute()\n-                                    .flatMap(res -> res.map((row, rowMetadata) -> {\n-                                        type.setId(row.get(\"id\", UUID.class));\n-                                        return type;\n-                                    }));\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+    public Uni<EventType> addEventTypeToApplication(UUID appId, EventType eventType) {\n+        return session.find(Application.class, appId)\n+                .onItem().transform(app -> {\n+                    eventType.setApplication(app);\n+                    return eventType;\n+                })\n+                .onItem().transformToUni(session::persist)\n+                .call(session::flush)\n+                .replaceWith(eventType);\n     }\n \n     public Multi<Application> getApplications(String bundleName) {\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(APPLICATION_QUERY_BY_BUNDLE_NAME)\n-                                    .bind(\"$1\", bundleName)\n-                                    .execute();\n-\n-                            return mapResultSetToApplication(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n-    }\n-\n-    private Flux<Application> mapResultSetToApplication(Flux<PostgresqlResult> resultFlux) {\n-        return resultFlux.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-            Application app = new Application();\n-            app.setId(row.get(\"id\", UUID.class));\n-            app.setBundleId(row.get(\"bundle_id\", UUID.class));\n-            app.setName(row.get(\"name\", String.class));\n-            app.setDisplay_name(row.get(\"display_name\", String.class));\n-            app.setCreated(row.get(\"created\", Date.class));\n-            app.setUpdated(row.get(\"updated\", Date.class));\n-            return app;\n-        }));\n+        String query = \"FROM Application WHERE bundle.name = :bundleName\";\n+        return session.createQuery(query, Application.class)\n+                .setParameter(\"bundleName\", bundleName)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n \n-    public Uni<Application> getApplication(UUID applicationId) {\n-        String query = APPLICATION_QUERY + \" WHERE id = $1\";\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", applicationId)\n-                                    .execute();\n-\n-                            return mapResultSetToApplication(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        })).toUni();\n+    public Uni<Application> getApplication(UUID id) {\n+        return session.find(Application.class, id);\n     }\n \n     public Uni<Application> getApplication(String bundleName, String applicationName) {\n-        final String query = APPLICATION_QUERY_BY_BUNDLE_NAME + \" AND a.name = $2\";\n-\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", bundleName)\n-                                    .bind(\"$2\", applicationName)\n-                                    .execute();\n-\n-                            return mapResultSetToApplication(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        })).toUni();\n-    }\n-\n-    public Multi<EventType> getEventTypes(UUID applicationId) {\n-        String query = \"SELECT et.id, et.name, et.display_name FROM public.event_type et \" +\n-                \"WHERE et.application_id = $1\";\n-\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", applicationId)\n-                                    .execute();\n-\n-                            return execute.flatMap(res -> res.map((row, rowMetadata) -> {\n-                                EventType eventType = new EventType();\n-                                eventType.setId(row.get(\"id\", UUID.class));\n-                                eventType.setName(row.get(\"name\", String.class));\n-                                eventType.setDisplay_name(row.get(\"display_name\", String.class));\n-                                return eventType;\n-                            }));\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n+        String query = \"FROM Application WHERE bundle.name = :bundleName AND name = :applicationName\";\n+        return session.createQuery(query, Application.class)\n+                .setParameter(\"bundleName\", bundleName)\n+                .setParameter(\"applicationName\", applicationName)\n+                .getSingleResultOrNull();\n     }\n \n-    public Uni<Boolean> deleteEventTypeById(UUID eventTypeId) {\n-        String query = \"DELETE FROM public.event_type WHERE id = $1\";\n-        return runDeleteQuery(eventTypeId, query);\n+    public Multi<EventType> getEventTypes(UUID appId) {\n+        String query = \"FROM EventType WHERE application.id = :appId\";\n+        return session.createQuery(query, EventType.class)\n+                .setParameter(\"appId\", appId)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n \n-    public Multi<EventType> getEventTypes(Query limiter) {\n-        return this.getEventTypes(limiter, null, null);\n+    public Uni<Boolean> deleteEventTypeById(UUID id) {\n+        String query = \"DELETE FROM EventType WHERE id = :id\";\n+        return session.createQuery(query)\n+                .setParameter(\"id\", id)\n+                .executeUpdate()\n+                .call(session::flush)\n+                .onItem().transform(rowCount -> rowCount > 0);\n     }\n \n-    public Multi<EventType> getEventTypes(Query limiter, Set<UUID> applicationId, UUID bundleId) {\n-        String basicQuery = \"SELECT et.id AS et_id, et.name AS et_name, et.display_name AS et_din, et.description AS et_description, a.id AS a_id, a.name AS a_name, a.display_name as a_displayName, a.bundle_id as a_bundle_id FROM public.event_type et \" +\n-                \"JOIN public.applications a ON a.id = et.application_id \";\n-\n-        String whereClause = \"\";\n-        boolean hasWhere = false;\n-        String bundleIdParam = \"$1\";\n+    public Multi<EventType> getEventTypes(Query limiter, Set<UUID> appIds, UUID bundleId) {\n+        String query = \"SELECT e FROM EventType e LEFT JOIN FETCH e.application\";\n \n-        if (applicationId != null && applicationId.size() > 0) {\n-            whereClause += \" a.id = ANY ($1) \";\n-            bundleIdParam = \"$2\";\n-            hasWhere = true;\n+        List<String> conditions = new ArrayList<>();\n+        if (appIds != null && appIds.size() > 0) {\n+            conditions.add(\"e.application.id IN (:appIds)\");\n         }\n-\n         if (bundleId != null) {\n-            if (hasWhere) {\n-                whereClause += \" AND \";\n-            }\n-            whereClause += \" a.bundle_id = \" + bundleIdParam + \" \";\n+            conditions.add(\"e.application.bundle.id = :bundleId\");\n         }\n-\n-        if (!whereClause.equals(\"\")) {\n-            basicQuery += \" WHERE \" + whereClause;\n+        if (conditions.size() > 0) {\n+            query += \" WHERE \" + String.join(\" AND \", conditions);\n         }\n \n-        String query = limiter.getModifiedQuery(basicQuery);\n-\n-        final String finalBundleIdParam = bundleIdParam;\n-\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            PostgresqlStatement statement = c2.createStatement(query);\n-\n-                            if (applicationId != null && applicationId.size() > 0) {\n-                                statement = statement.bind(\"$1\", applicationId.toArray(new UUID[applicationId.size()]));\n-                            }\n+        if (limiter != null) {\n+            query = limiter.getModifiedQuery(query);\n+        }\n \n-                            if (bundleId != null) {\n-                                statement = statement.bind(finalBundleIdParam, bundleId);\n-                            }\n+        Mutiny.Query<EventType> mutinyQuery = session.createQuery(query, EventType.class);\n+        if (appIds != null && appIds.size() > 0) {\n+            mutinyQuery = mutinyQuery.setParameter(\"appIds\", appIds);\n+        }\n+        if (bundleId != null) {\n+            mutinyQuery = mutinyQuery.setParameter(\"bundleId\", bundleId);\n+        }\n \n-                            Flux<PostgresqlResult> execute = statement.execute();\n+        if (limiter != null && limiter.getLimit() != null && limiter.getLimit().getLimit() > 0) {\n+            mutinyQuery = mutinyQuery.setMaxResults(limiter.getLimit().getLimit())\n+                    .setFirstResult(limiter.getLimit().getOffset());\n+        }\n \n-                            return mapResultSetToEventTypes(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n+        return mutinyQuery.getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n \n     public Multi<EventType> getEventTypesByEndpointId(@NotNull String accountId, @NotNull UUID endpointId) {\n-        String query = \"SELECT et.id AS et_id, et.name AS et_name, et.display_name AS et_din, et.description AS et_description, a.id AS a_id, a.name AS a_name, a.display_name as a_displayName, a.bundle_id as a_bundle_id FROM public.event_type et \" +\n-                \"JOIN public.applications a ON a.id = et.application_id \" +\n-                \"JOIN public.endpoint_targets endt ON  endt.event_type_id = et.id \" +\n-                \"WHERE endt.endpoint_id = $1 AND endt.account_id = $2\";\n-\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", endpointId)\n-                                    .bind(\"$2\", accountId)\n-                                    .execute();\n-\n-                            return mapResultSetToEventTypes(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n+        String query = \"SELECT e FROM EventType e LEFT JOIN FETCH e.application JOIN e.targets t \" +\n+                \"WHERE t.id.accountId = :accountId AND t.endpoint.id = :endpointId\";\n+        return session.createQuery(query, EventType.class)\n+                .setParameter(\"accountId\", accountId)\n+                .setParameter(\"endpointId\", endpointId)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n \n-    private Flux<EventType> mapResultSetToEventTypes(Flux<PostgresqlResult> resultFlux) {\n-        return resultFlux.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-            Application app = new Application();\n-            app.setBundleId(row.get(\"a_bundle_id\", UUID.class));\n-            app.setId(row.get(\"a_id\", UUID.class));\n-            app.setName(row.get(\"a_name\", String.class));\n-            app.setDisplay_name(row.get(\"a_displayName\", String.class));\n-\n-            EventType eventType = new EventType();\n-            eventType.setId(row.get(\"et_id\", UUID.class));\n-            eventType.setName(row.get(\"et_name\", String.class));\n-            eventType.setDisplay_name(row.get(\"et_din\", String.class));\n-            eventType.setDescription(row.get(\"et_description\", String.class));\n-\n-            eventType.setApplication(app);\n-\n-            return eventType;\n-        }));\n+    /**\n+     * Adds to the given {@link Application} a reference to a persistent {@link Bundle} without actually loading its\n+     * state from the database. The app will remain unchanged if it does not contain a non-null bundle identifier.\n+     *\n+     * @param app the app that will hold the bundle reference\n+     * @return the same app instance, possibly modified if a bundle reference was added\n+     */\n+    private Application addBundleReference(Application app) {\n+        if (app.getBundleId() != null && app.getBundle() == null) {\n+            app.setBundle(session.getReference(Bundle.class, app.getBundleId()));\n+        }\n+        return app;\n     }\n }"
  },
  {
    "sha": "1d5d948fb2424fcde659ce15e0866316e2ff7ca5",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/BundleResources.java",
    "status": "modified",
    "additions": 48,
    "deletions": 114,
    "changes": 162,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/BundleResources.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/BundleResources.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/BundleResources.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -2,145 +2,79 @@\n \n import com.redhat.cloud.notifications.models.Application;\n import com.redhat.cloud.notifications.models.Bundle;\n-import io.r2dbc.postgresql.api.PostgresqlResult;\n import io.smallrye.mutiny.Multi;\n import io.smallrye.mutiny.Uni;\n-import reactor.core.publisher.Flux;\n+import org.hibernate.reactive.mutiny.Mutiny;\n \n import javax.enterprise.context.ApplicationScoped;\n-import java.util.Date;\n+import javax.inject.Inject;\n import java.util.UUID;\n \n /**\n  * Deal with Bundles.\n- * More or less stupid copy & paste & search & replace of\n- * code in BundleResources\n  */\n @ApplicationScoped\n-public class BundleResources extends  AbstractGenericResource {\n+public class BundleResources {\n \n-    public static final String PUBLIC_APPLICATIONS = \"public.applications\";\n-    public static final String PUBLIC_BUNDLES = \"public.bundles\";\n+    @Inject\n+    Mutiny.Session session;\n \n     public Uni<Bundle> createBundle(Bundle bundle) {\n-        String query = \"INSERT INTO \" + PUBLIC_BUNDLES + \" (name, display_name) VALUES ($1, $2)\";\n-        // Return filled with id\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                    c2 -> c2.createStatement(query)\n-                    .bind(\"$1\", bundle.getName())\n-                    .bind(\"$2\", bundle.getDisplay_name())\n-                    .returnGeneratedValues(\"id\", \"created\")\n-                    .execute()\n-                    .flatMap(res -> res.map((row, rowMetadata) -> {\n-                        bundle.setId(row.get(\"id\", UUID.class));\n-                        bundle.setCreated(row.get(\"created\", Date.class));\n-                        return bundle;\n-                    })))\n-            .withFinalizer(postgresqlConnection -> {\n-                postgresqlConnection.close().subscribe();\n-            }))\n-                .toUni();\n+        // The returned bundle will contain an ID and a creation timestamp.\n+        return Uni.createFrom().item(bundle)\n+                .onItem().transformToUni(session::persist)\n+                .call(session::flush)\n+                .replaceWith(bundle);\n     }\n \n-    private static final String BUNDLE_QUERY = \"SELECT b.id, b.name, b.display_name, b.created, b.updated FROM \" + PUBLIC_BUNDLES + \" b\";\n-\n     public Multi<Bundle> getBundles() {\n-        return connectionPublisher.get().onItem()\n-            .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                c2 -> {\n-                    Flux<PostgresqlResult> execute = c2.createStatement(BUNDLE_QUERY)\n-                        .execute();\n-\n-                    return mapResultSetToBundle(execute);\n-                })\n-                .withFinalizer(postgresqlConnection -> {\n-                    postgresqlConnection.close().subscribe();\n-                }));\n+        String query = \"FROM Bundle\";\n+        return session.createQuery(query, Bundle.class)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n \n-    private Flux<Bundle> mapResultSetToBundle(Flux<PostgresqlResult> resultFlux) {\n-        return resultFlux.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-            Bundle bundle = new Bundle();\n-            bundle.setId(row.get(\"id\", UUID.class));\n-            bundle.setName(row.get(\"name\", String.class));\n-            bundle.setDisplay_name(row.get(\"display_name\", String.class));\n-            bundle.setCreated(row.get(\"created\", Date.class));\n-            bundle.setUpdated(row.get(\"updated\", Date.class));\n-            return bundle;\n-        }));\n+    public Uni<Bundle> getBundle(UUID id) {\n+        return session.find(Bundle.class, id);\n     }\n \n-    public Uni<Bundle> getBundle(UUID bundleId) {\n-        String query = BUNDLE_QUERY + \" WHERE id = $1\";\n-        return connectionPublisher.get().onItem()\n-            .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                c2 -> {\n-                    Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                            .bind(\"$1\", bundleId)\n-                            .execute();\n-\n-                    return mapResultSetToBundle(execute);\n-                })\n-                .withFinalizer(postgresqlConnection -> {\n-                    postgresqlConnection.close().subscribe();\n-                })).toUni();\n+    public Uni<Boolean> deleteBundle(UUID id) {\n+        String query = \"DELETE FROM Bundle WHERE id = :id\";\n+        return session.createQuery(query)\n+                .setParameter(\"id\", id)\n+                .executeUpdate()\n+                .call(session::flush)\n+                .onItem().transform(rowCount -> rowCount > 0);\n     }\n \n-    public Uni<Boolean> deleteBundle(UUID bundleId) {\n-\n-        String query = \"DELETE FROM \" + PUBLIC_BUNDLES + \" WHERE id = $1\";\n-        return runDeleteQuery(bundleId, query);\n-    }\n-\n-\n-    public Multi<Application> getApplications(UUID bundleId) {\n-        String query = \"SELECT et.id, et.name, et.display_name FROM \" + PUBLIC_APPLICATIONS + \" et \" +\n-                \"WHERE et.bundle_id = $1\";\n-\n-        return connectionPublisher.get().onItem()\n-            .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                c2 -> {\n-                    Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                            .bind(\"$1\", bundleId)\n-                            .execute();\n-\n-                    return execute.flatMap(res -> res.map((row, rowMetadata) -> {\n-                        Application application = new Application();\n-                        application.setId(row.get(\"id\", UUID.class));\n-                        application.setName(row.get(\"name\", String.class));\n-                        application.setDisplay_name(row.get(\"display_name\", String.class));\n-                        application.setBundleId(bundleId);\n-                        return application;\n-                    }));\n-                })\n-                .withFinalizer(postgresqlConnection -> {\n-                    postgresqlConnection.close().subscribe();\n-                }));\n+    public Multi<Application> getApplications(UUID id) {\n+        String query = \"FROM Application WHERE bundle.id = :id\";\n+        return session.createQuery(query, Application.class)\n+                .setParameter(\"id\", id)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n \n     public Uni<Application> addApplicationToBundle(UUID bundleId, Application app) {\n-        String insertQuery = \"INSERT INTO \" + PUBLIC_APPLICATIONS + \" (name, display_name, bundle_Id) VALUES ($1, $2, $3)\";\n-\n-        return connectionPublisher.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                    c2 ->  c2.createStatement(insertQuery)\n-                            .bind(\"$1\", app.getName())\n-                            .bind(\"$2\", app.getDisplay_name())\n-                            .bind(\"$3\", bundleId)\n-                            .returnGeneratedValues(\"id\")\n-                            .execute()\n-                            .flatMap(res -> res.map((row, rowMetadata) -> {\n-                                app.setId(row.get(\"id\", UUID.class));\n-                                return app;\n-                            }))\n-\n-                )\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        return Uni.createFrom().item(app)\n+                .onItem().transform(a -> addBundleReference(a, bundleId))\n+                .onItem().transformToUni(session::persist)\n+                .call(session::flush)\n+                .replaceWith(app);\n     }\n \n-\n+    /**\n+     * Adds to the given {@link Application} a reference to a persistent {@link Bundle} without actually loading its\n+     * state from the database. The app will remain unchanged if the given bundle identifier is null.\n+     *\n+     * @param app the app that will hold the bundle reference\n+     * @param bundleId the persistent bundle identifier\n+     * @return the same app instance, possibly modified if a bundle reference was added\n+     */\n+    private Application addBundleReference(Application app, UUID bundleId) {\n+        if (bundleId != null && app.getBundle() == null) {\n+            app.setBundle(session.getReference(Bundle.class, bundleId));\n+        }\n+        return app;\n+    }\n }"
  },
  {
    "sha": "21868efeb39442d2b3fa776fbfc61ede176dfc50",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/DatasourceProvider.java",
    "status": "removed",
    "additions": 0,
    "deletions": 57,
    "changes": 57,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/4513da97584698a734a26e462b7a52632db1a981/src/main/java/com/redhat/cloud/notifications/db/DatasourceProvider.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/4513da97584698a734a26e462b7a52632db1a981/src/main/java/com/redhat/cloud/notifications/db/DatasourceProvider.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/DatasourceProvider.java?ref=4513da97584698a734a26e462b7a52632db1a981",
    "patch": "@@ -1,57 +0,0 @@\n-package com.redhat.cloud.notifications.db;\n-\n-import io.r2dbc.pool.ConnectionPool;\n-import io.r2dbc.postgresql.PostgresqlConnectionFactory;\n-import io.r2dbc.postgresql.api.PostgresqlConnection;\n-import io.r2dbc.spi.ConnectionFactories;\n-import io.r2dbc.spi.ConnectionFactory;\n-import io.r2dbc.spi.ConnectionFactoryOptions;\n-import io.smallrye.mutiny.Uni;\n-import org.eclipse.microprofile.config.inject.ConfigProperty;\n-import reactor.core.publisher.Mono;\n-\n-import javax.annotation.PostConstruct;\n-import javax.enterprise.context.ApplicationScoped;\n-import javax.enterprise.inject.Produces;\n-\n-@ApplicationScoped\n-public class DatasourceProvider {\n-\n-    @ConfigProperty(name = \"quarkus.datasource.jdbc.url\")\n-    String dataSourceUrl;\n-\n-    @ConfigProperty(name = \"quarkus.datasource.username\")\n-    String username;\n-\n-    @ConfigProperty(name = \"quarkus.datasource.password\")\n-    String password;\n-\n-    private ConnectionFactory pool;\n-\n-    @PostConstruct\n-    void init() {\n-        ConnectionFactoryOptions parse = ConnectionFactoryOptions.parse(dataSourceUrl.replaceFirst(\"jdbc\", \"r2dbc:pool\"));\n-        ConnectionFactoryOptions options = parse.mutate()\n-                .option(ConnectionFactoryOptions.USER, username)\n-                .option(ConnectionFactoryOptions.PASSWORD, password)\n-                .build();\n-\n-        this.pool = ConnectionFactories.get(options);\n-    }\n-\n-    @Produces\n-    Mono<PostgresqlConnection> getPostgresConnection() {\n-        ConnectionPool connectionPool = (ConnectionPool) pool;\n-        PostgresqlConnectionFactory postgresqlConnectionFactory = (PostgresqlConnectionFactory) connectionPool.unwrap();\n-\n-        return postgresqlConnectionFactory.create();\n-    }\n-\n-    @Produces\n-    Uni<PostgresqlConnection> getConnection() {\n-        ConnectionPool connectionPool = (ConnectionPool) pool;\n-        PostgresqlConnectionFactory postgresqlConnectionFactory = (PostgresqlConnectionFactory) connectionPool.unwrap();\n-\n-        return Uni.createFrom().publisher(postgresqlConnectionFactory.create());\n-    }\n-}"
  },
  {
    "sha": "2841bfd0ed13edebb96105b8bf3526bb54db6456",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/EmailAggregationResources.java",
    "status": "modified",
    "additions": 31,
    "deletions": 95,
    "changes": 126,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/EmailAggregationResources.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/EmailAggregationResources.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/EmailAggregationResources.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -2,121 +2,57 @@\n \n import com.redhat.cloud.notifications.models.EmailAggregation;\n import com.redhat.cloud.notifications.models.EmailAggregationKey;\n-import io.r2dbc.postgresql.api.PostgresqlConnection;\n-import io.r2dbc.postgresql.api.PostgresqlResult;\n-import io.r2dbc.postgresql.codec.Json;\n import io.smallrye.mutiny.Multi;\n import io.smallrye.mutiny.Uni;\n-import io.vertx.core.json.JsonObject;\n-import reactor.core.publisher.Flux;\n+import org.hibernate.reactive.mutiny.Mutiny;\n \n import javax.enterprise.context.ApplicationScoped;\n import javax.inject.Inject;\n-import javax.inject.Provider;\n import java.time.LocalDateTime;\n \n @ApplicationScoped\n-public class EmailAggregationResources extends DatasourceProvider {\n+public class EmailAggregationResources {\n \n     @Inject\n-    Provider<Uni<PostgresqlConnection>> connectionPublisherUni;\n-\n+    Mutiny.Session session;\n \n     public Uni<Boolean> addEmailAggregation(EmailAggregation aggregation) {\n-        String query = \"INSERT INTO public.email_aggregation(account_id, bundle, application, payload) \" +\n-                \"VALUES ($1, $2, $3, $4)\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                .bind(\"$1\", aggregation.getAccountId())\n-                                .bind(\"$2\", aggregation.getBundle())\n-                                .bind(\"$3\", aggregation.getApplication())\n-                                .bind(\"$4\", Json.of(aggregation.getPayload().encode()))\n-                                .execute();\n-                            return execute.flatMap(PostgresqlResult::getRowsUpdated).map(i -> i > 0);\n-                        })\n-                        .withFinalizer(psqlConnection -> {\n-                            psqlConnection.close().subscribe();\n-                        })\n-                ).toUni();\n+        return Uni.createFrom().item(aggregation)\n+                .onItem().transformToUni(session::persist)\n+                .call(session::flush)\n+                .replaceWith(Boolean.TRUE)\n+                .onFailure().recoverWithItem(Boolean.FALSE);\n     }\n \n     public Multi<EmailAggregationKey> getApplicationsWithPendingAggregation(LocalDateTime start, LocalDateTime end) {\n-        String query = \"SELECT DISTINCT account_id, bundle, application FROM public.email_aggregation \" +\n-                \"WHERE created > $1 AND created <= $2 \";\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", start)\n-                                    .bind(\"$2\", end)\n-                                    .execute();\n-                            return execute.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-                                EmailAggregationKey key = new EmailAggregationKey();\n-                                key.setApplication(row.get(\"application\", String.class));\n-                                key.setBundle(row.get(\"bundle\", String.class));\n-                                key.setAccountId(row.get(\"account_id\", String.class));\n-                                return key;\n-                            }));\n-                        })\n-                        .withFinalizer(psqlConnection -> {\n-                            psqlConnection.close().subscribe();\n-                        })\n-                );\n+        String query = \"SELECT DISTINCT NEW com.redhat.cloud.notifications.models.EmailAggregationKey(accountId, bundleName, applicationName) FROM EmailAggregation WHERE created > :start AND created <= :end\";\n+        return session.createQuery(query, EmailAggregationKey.class)\n+                .setParameter(\"start\", start)\n+                .setParameter(\"end\", end)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n \n     public Multi<EmailAggregation> getEmailAggregation(EmailAggregationKey key, LocalDateTime start, LocalDateTime end) {\n-        String query = \"SELECT id, account_id, bundle, application, created, payload FROM public.email_aggregation \" +\n-                \"WHERE account_id = $1 AND bundle = $5 AND application = $2 AND created > $3 AND created <= $4 \" +\n-                \"ORDER BY created\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", key.getAccountId())\n-                                    .bind(\"$2\", key.getApplication())\n-                                    .bind(\"$3\", start)\n-                                    .bind(\"$4\", end)\n-                                    .bind(\"$5\", key.getBundle())\n-                                    .execute();\n-                            return execute.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-                                EmailAggregation emailAggregation = new EmailAggregation();\n-                                emailAggregation.setId(row.get(\"id\", Integer.class));\n-                                emailAggregation.setAccountId(row.get(\"account_id\", String.class));\n-                                emailAggregation.setCreated(row.get(\"created\", LocalDateTime.class));\n-                                emailAggregation.setBundle(row.get(\"bundle\", String.class));\n-                                emailAggregation.setApplication(row.get(\"application\", String.class));\n-                                emailAggregation.setPayload(new JsonObject(row.get(\"payload\", String.class)));\n-\n-                                return emailAggregation;\n-                            }));\n-                        })\n-                        .withFinalizer(psqlConnection -> {\n-                            psqlConnection.close().subscribe();\n-                        })\n-                );\n+        String query = \"FROM EmailAggregation WHERE accountId = :accountId AND bundleName = :bundleName AND applicationName = :applicationName AND created > :start AND created <= :end ORDER BY created\";\n+        return session.createQuery(query, EmailAggregation.class)\n+                .setParameter(\"accountId\", key.getAccountId())\n+                .setParameter(\"bundleName\", key.getBundle())\n+                .setParameter(\"applicationName\", key.getApplication())\n+                .setParameter(\"start\", start)\n+                .setParameter(\"end\", end)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n \n     public Uni<Integer> purgeOldAggregation(EmailAggregationKey key, LocalDateTime lastUsedTime) {\n-        String query = \"DELETE FROM public.email_aggregation WHERE account_id = $1 AND bundle = $4 AND application = $2 AND created <= $3\";\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", key.getAccountId())\n-                                    .bind(\"$2\", key.getApplication())\n-                                    .bind(\"$3\", lastUsedTime)\n-                                    .bind(\"$4\", key.getBundle())\n-                                    .execute();\n-                            return execute.flatMap(PostgresqlResult::getRowsUpdated);\n-                        })\n-                        .withFinalizer(psqlConnection -> {\n-                            psqlConnection.close().subscribe();\n-                        })\n-                ).toUni();\n+        String query = \"DELETE FROM EmailAggregation WHERE account_id = :accountId AND bundleName = :bundleName AND applicationName = :applicationName AND created <= :created\";\n+        return session.createQuery(query)\n+                .setParameter(\"accountId\", key.getAccountId())\n+                .setParameter(\"bundleName\", key.getBundle())\n+                .setParameter(\"applicationName\", key.getApplication())\n+                .setParameter(\"created\", lastUsedTime)\n+                .executeUpdate()\n+                .call(session::flush);\n     }\n-\n }"
  },
  {
    "sha": "bdeaae0d7b41e1d7f3ba4062dc30e5d9229f5631",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/EndpointEmailSubscriptionResources.java",
    "status": "modified",
    "additions": 66,
    "deletions": 121,
    "changes": 187,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/EndpointEmailSubscriptionResources.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/EndpointEmailSubscriptionResources.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/EndpointEmailSubscriptionResources.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -1,148 +1,93 @@\n package com.redhat.cloud.notifications.db;\n \n import com.redhat.cloud.notifications.models.EmailSubscription;\n-import com.redhat.cloud.notifications.models.EmailSubscription.EmailSubscriptionType;\n-import io.r2dbc.postgresql.api.PostgresqlConnection;\n-import io.r2dbc.postgresql.api.PostgresqlResult;\n+import com.redhat.cloud.notifications.models.EmailSubscriptionType;\n import io.smallrye.mutiny.Multi;\n import io.smallrye.mutiny.Uni;\n-import reactor.core.publisher.Flux;\n+import org.hibernate.reactive.mutiny.Mutiny;\n \n import javax.enterprise.context.ApplicationScoped;\n import javax.inject.Inject;\n-import javax.inject.Provider;\n \n @ApplicationScoped\n-public class EndpointEmailSubscriptionResources extends DatasourceProvider {\n-\n-    private final String COMMON_WHERE_FILTER = \" WHERE account_id = $1 AND bundle = $2 AND application = $3 AND subscription_type = $4 \";\n+public class EndpointEmailSubscriptionResources {\n \n     @Inject\n-    Provider<Uni<PostgresqlConnection>> connectionPublisherUni;\n+    Mutiny.Session session;\n \n-    public Uni<Boolean> subscribe(String accountNumber, String username, String bundle, String application, EmailSubscriptionType type) {\n-        String query = \"INSERT INTO public.endpoint_email_subscriptions(account_id, user_id, bundle, application, subscription_type) VALUES($1, $2, $3, $4, $5) \" +\n+    public Uni<Boolean> subscribe(String accountNumber, String username, String bundleName, String applicationName, EmailSubscriptionType subscriptionType) {\n+        String query = \"INSERT INTO public.endpoint_email_subscriptions(account_id, user_id, bundle, application, subscription_type) \" +\n+                \"VALUES(:accountId, :userId, :bundleName, :application, :subscriptionType) \" +\n                 \"ON CONFLICT (account_id, user_id, bundle, application, subscription_type) DO NOTHING\"; // The value is already on the database, this is OK\n-        return this.executeBooleanQuery(query, accountNumber, username, bundle, application, type);\n+        // HQL does not support the ON CONFLICT clause so we need a native query here\n+        return session.createNativeQuery(query)\n+                .setParameter(\"accountId\", accountNumber)\n+                .setParameter(\"userId\", username)\n+                .setParameter(\"bundleName\", bundleName)\n+                .setParameter(\"application\", applicationName)\n+                .setParameter(\"subscriptionType\", subscriptionType.name())\n+                .executeUpdate()\n+                .replaceWith(Boolean.TRUE)\n+                .onFailure().recoverWithItem(Boolean.FALSE);\n     }\n \n-    public Uni<Boolean> unsubscribe(String accountNumber, String username, String bundle, String application, EmailSubscriptionType type) {\n-        String query = \"DELETE FROM public.endpoint_email_subscriptions where account_id = $1 AND user_id = $2 AND bundle = $3 AND application = $4 AND subscription_type = $5\";\n-\n-        return this.executeBooleanQuery(query, accountNumber, username, bundle, application, type);\n+    public Uni<Boolean> unsubscribe(String accountNumber, String username, String bundleName, String applicationName, EmailSubscriptionType subscriptionType) {\n+        String query = \"DELETE FROM EmailSubscription WHERE id.accountId = :accountId AND id.userId = :userId \" +\n+                \"AND id.bundleName = :bundleName AND id.applicationName = :applicationName AND id.subscriptionType = :subscriptionType\";\n+        return session.createQuery(query)\n+                .setParameter(\"accountId\", accountNumber)\n+                .setParameter(\"userId\", username)\n+                .setParameter(\"bundleName\", bundleName)\n+                .setParameter(\"applicationName\", applicationName)\n+                .setParameter(\"subscriptionType\", subscriptionType)\n+                .executeUpdate()\n+                .call(session::flush)\n+                .replaceWith(Boolean.TRUE)\n+                .onFailure().recoverWithItem(Boolean.FALSE);\n     }\n \n-    public Uni<EmailSubscription> getEmailSubscription(String accountNumber, String username, String bundle, String application, EmailSubscriptionType type) {\n-        String query = \"SELECT account_id, bundle, application, user_id, subscription_type FROM public.endpoint_email_subscriptions \" + COMMON_WHERE_FILTER + \" AND user_id = $5 LIMIT 1\";\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute =  c2.createStatement(query)\n-                                    .bind(\"$1\", accountNumber)\n-                                    .bind(\"$2\", bundle)\n-                                    .bind(\"$3\", application)\n-                                    .bind(\"$4\", type.toString())\n-                                    .bind(\"$5\", username)\n-                                    .execute();\n-                            return this.mapResultSetToEmailSubscription(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        })\n-                ).toUni();\n+    public Uni<EmailSubscription> getEmailSubscription(String accountNumber, String username, String bundleName, String applicationName, EmailSubscriptionType subscriptionType) {\n+        String query = \"FROM EmailSubscription WHERE id.accountId = :accountId AND id.userId = :userId \" +\n+                \"AND id.bundleName = :bundleName AND id.applicationName = :applicationName AND id.subscriptionType = :subscriptionType\";\n+        return session.createQuery(query, EmailSubscription.class)\n+                .setParameter(\"accountId\", accountNumber)\n+                .setParameter(\"userId\", username)\n+                .setParameter(\"bundleName\", bundleName)\n+                .setParameter(\"applicationName\", applicationName)\n+                .setParameter(\"subscriptionType\", subscriptionType)\n+                .setMaxResults(1)\n+                .getSingleResultOrNull();\n     }\n \n     public Multi<EmailSubscription> getEmailSubscriptionsForUser(String accountNumber, String username) {\n-        String query = \"SELECT account_id, bundle, application, user_id, subscription_type FROM public.endpoint_email_subscriptions WHERE account_id = $1 AND user_id = $2\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute =  c2.createStatement(query)\n-                                    .bind(\"$1\", accountNumber)\n-                                    .bind(\"$2\", username)\n-                                    .execute();\n-                            return this.mapResultSetToEmailSubscription(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        })\n-                );\n-    }\n-\n-    public Uni<Integer> getEmailSubscribersCount(String accountNumber, String bundle, String application, EmailSubscriptionType type) {\n-        String query = \"SELECT count(user_id) FROM public.endpoint_email_subscriptions \" + COMMON_WHERE_FILTER;\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                    c2 -> {\n-                        Flux<PostgresqlResult> execute =  c2.createStatement(query)\n-                                .bind(\"$1\", accountNumber)\n-                                .bind(\"$2\", bundle)\n-                                .bind(\"$3\", application)\n-                                .bind(\"$4\", type.toString())\n-                                .execute();\n-                        return execute.flatMap(r -> r.map((row, rowMetadata) -> row.get(0, Integer.class)));\n-                    })\n-                    .withFinalizer(postgresqlConnection -> {\n-                        postgresqlConnection.close().subscribe();\n-                    })\n-        ).toUni();\n+        String query = \"FROM EmailSubscription WHERE id.accountId = :accountId AND id.userId = :userId\";\n+        return session.createQuery(query, EmailSubscription.class)\n+                .setParameter(\"accountId\", accountNumber)\n+                .setParameter(\"userId\", username)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n \n-    public Multi<EmailSubscription> getEmailSubscribers(String accountNumber, String bundle, String application, EmailSubscriptionType type) {\n-        String query = \"SELECT account_id, bundle, application, user_id, subscription_type FROM public.endpoint_email_subscriptions \" + COMMON_WHERE_FILTER;\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute =  c2.createStatement(query)\n-                                    .bind(\"$1\", accountNumber)\n-                                    .bind(\"$2\", bundle)\n-                                    .bind(\"$3\", application)\n-                                    .bind(\"$4\", type.toString())\n-                                    .execute();\n-                            return this.mapResultSetToEmailSubscription(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        })\n-                );\n-    }\n-\n-    private Flux<EmailSubscription> mapResultSetToEmailSubscription(Flux<PostgresqlResult> resultFlux) {\n-        return resultFlux.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-            EmailSubscriptionType subscriptionType = EmailSubscriptionType.valueOf(row.get(\"subscription_type\", String.class));\n-            EmailSubscription emailSubscription = new EmailSubscription();\n-\n-            emailSubscription.setAccountId(row.get(\"account_id\", String.class));\n-            emailSubscription.setUsername(row.get(\"user_id\", String.class));\n-            emailSubscription.setBundle(row.get(\"bundle\", String.class));\n-            emailSubscription.setApplication(row.get(\"application\", String.class));\n-            emailSubscription.setType(subscriptionType);\n-\n-            return emailSubscription;\n-        }));\n+    public Uni<Long> getEmailSubscribersCount(String accountNumber, String bundleName, String applicationName, EmailSubscriptionType subscriptionType) {\n+        String query = \"SELECT COUNT(id.userId) FROM EmailSubscription WHERE id.accountId = :accountId \" +\n+                \"AND id.bundleName = :bundleName AND id.applicationName = :applicationName AND id.subscriptionType = :subscriptionType\";\n+        return session.createQuery(query, Long.class)\n+                .setParameter(\"accountId\", accountNumber)\n+                .setParameter(\"bundleName\", bundleName)\n+                .setParameter(\"applicationName\", applicationName)\n+                .setParameter(\"subscriptionType\", subscriptionType)\n+                .getSingleResult();\n     }\n \n-    private Uni<Boolean> executeBooleanQuery(String query, String accountNumber, String username, String bundle, String application, EmailSubscriptionType type) {\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", accountNumber)\n-                                    .bind(\"$2\", username)\n-                                    .bind(\"$3\", bundle)\n-                                    .bind(\"$4\", application)\n-                                    .bind(\"$5\", type.toString())\n-                                    .execute();\n-                            return execute.flatMap(PostgresqlResult::getRowsUpdated)\n-                                    .map(i -> true).next();\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        })\n-                ).toUni();\n+    public Multi<EmailSubscription> getEmailSubscribers(String accountNumber, String bundleName, String applicationName, EmailSubscriptionType subscriptionType) {\n+        String query = \"FROM EmailSubscription WHERE id.accountId = :accountId AND id.bundleName = :bundleName \" +\n+                \"AND id.applicationName = :applicationName AND id.subscriptionType = :subscriptionType\";\n+        return session.createQuery(query, EmailSubscription.class)\n+                .setParameter(\"accountId\", accountNumber)\n+                .setParameter(\"bundleName\", bundleName)\n+                .setParameter(\"applicationName\", applicationName)\n+                .setParameter(\"subscriptionType\", subscriptionType)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n-\n }"
  },
  {
    "sha": "934143f8948f6fbd91192b69c742676b59274f45",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/EndpointResources.java",
    "status": "modified",
    "additions": 215,
    "deletions": 453,
    "changes": 668,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/EndpointResources.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/EndpointResources.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/EndpointResources.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -1,321 +1,144 @@\n package com.redhat.cloud.notifications.db;\n \n+import com.redhat.cloud.notifications.models.Attributes;\n import com.redhat.cloud.notifications.models.Endpoint;\n+import com.redhat.cloud.notifications.models.EndpointDefault;\n+import com.redhat.cloud.notifications.models.EndpointTarget;\n+import com.redhat.cloud.notifications.models.EndpointType;\n+import com.redhat.cloud.notifications.models.EndpointWebhook;\n+import com.redhat.cloud.notifications.models.EventType;\n import com.redhat.cloud.notifications.models.WebhookAttributes;\n-import io.r2dbc.postgresql.api.PostgresqlConnection;\n-import io.r2dbc.postgresql.api.PostgresqlResult;\n-import io.r2dbc.postgresql.api.PostgresqlStatement;\n-import io.r2dbc.spi.R2dbcDataIntegrityViolationException;\n import io.smallrye.mutiny.Multi;\n import io.smallrye.mutiny.Uni;\n-import io.smallrye.mutiny.converters.uni.UniReactorConverters;\n-import io.vertx.core.json.Json;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n+import org.hibernate.reactive.mutiny.Mutiny;\n \n import javax.enterprise.context.ApplicationScoped;\n import javax.inject.Inject;\n-import javax.inject.Provider;\n+import javax.persistence.PersistenceException;\n import javax.ws.rs.BadRequestException;\n-import java.time.LocalDateTime;\n-import java.util.Date;\n import java.util.UUID;\n \n @ApplicationScoped\n-public class EndpointResources extends DatasourceProvider {\n+public class EndpointResources {\n \n     @Inject\n-    Provider<Mono<PostgresqlConnection>> connectionPublisher;\n-\n-    @Inject\n-    Provider<Uni<PostgresqlConnection>> connectionPublisherUni;\n-\n-    // TODO Modify to use PreparedStatements\n+    Mutiny.Session session;\n \n     public Uni<Endpoint> createEndpoint(Endpoint endpoint) {\n-        Mono<Endpoint> endpointMono =\n-                Mono.usingWhen(\n-                        connectionPublisher.get(),\n-                        conn -> {\n-                            Flux<Endpoint> endpointFlux = insertEndpointStatement(endpoint, conn);\n-                            Flux<Endpoint> endpointFlux1 = endpointFlux.flatMap(ep -> {\n-                                if (endpoint.getProperties() != null && ep.getType() == Endpoint.EndpointType.WEBHOOK) {\n-                                    return insertWebhooksStatement(ep, conn);\n-                                } else {\n-                                    // Other types are not supported at this point\n-                                    return Flux.just(ep);\n-                                }\n-                            });\n-                            return endpointFlux1.next();\n-                        },\n-                        PostgresqlConnection::close);\n-\n-        return Uni.createFrom().converter(UniReactorConverters.fromMono(), endpointMono);\n+        return Uni.createFrom().item(endpoint)\n+                .onItem().transform(this::mapProperties)\n+                .onItem().transformToUni(session::persist)\n+                .call(session::flush)\n+                .replaceWith(endpoint);\n     }\n \n-    private Flux<Endpoint> insertEndpointStatement(Endpoint endpoint, PostgresqlConnection conn) {\n-        Flux<PostgresqlResult> execute = conn.createStatement(\"INSERT INTO public.endpoints (account_id, endpoint_type, enabled, name, description, created) VALUES ($1, $2, $3, $4, $5, $6)\")\n-                .bind(\"$1\", endpoint.getTenant())\n-                .bind(\"$2\", endpoint.getType().ordinal())\n-                .bind(\"$3\", endpoint.isEnabled())\n-                .bind(\"$4\", endpoint.getName())\n-                .bind(\"$5\", endpoint.getDescription())\n-                .bind(\"$6\", LocalDateTime.now())\n-                .returnGeneratedValues(\"id\", \"created\")\n-                .execute();\n-\n-        return execute.flatMap(res -> res\n-                .map(((row, rowMetadata) -> {\n-                    endpoint.setId(row.get(\"id\", UUID.class));\n-                    endpoint.setCreated(row.get(\"created\", Date.class));\n-                    return endpoint;\n-                })));\n-    }\n-\n-    private Flux<Endpoint> insertWebhooksStatement(Endpoint endpoint, PostgresqlConnection conn) {\n-        WebhookAttributes attr = (WebhookAttributes) endpoint.getProperties();\n-        PostgresqlStatement bind = conn.createStatement(\"INSERT INTO public.endpoint_webhooks (endpoint_id, url, method, disable_ssl_verification, secret_token, basic_authentication) VALUES ($1, $2, $3, $4, $5, $6)\")\n-                .bind(\"$1\", endpoint.getId())\n-                .bind(\"$2\", attr.getUrl())\n-                .bind(\"$3\", attr.getMethod().toString())\n-                .bind(\"$4\", attr.isDisableSSLVerification());\n-\n-        if (attr.getSecretToken() != null) {\n-            bind.bind(\"$5\", attr.getSecretToken());\n-        } else {\n-            bind.bindNull(\"$5\", String.class);\n+    public Multi<Endpoint> getEndpointsPerType(String tenant, EndpointType type, Boolean activeOnly, Query limiter) {\n+        // TODO Modify the parameter to take a vararg of Functions that modify the query\n+        // TODO Modify to take account selective joins (JOIN (..) UNION (..)) based on the type, same for getEndpoints\n+        String query = \"SELECT e FROM Endpoint e LEFT JOIN FETCH e.webhook WHERE e.accountId = :accountId AND e.type = :endpointType\";\n+        if (activeOnly != null) {\n+            query += \" AND enabled = :enabled\";\n         }\n \n-        if (attr.getBasicAuthentication() != null) {\n-            String encodedJson = Json.encode(attr.getBasicAuthentication());\n-            bind.bind(\"$6\", io.r2dbc.postgresql.codec.Json.of(encodedJson));\n-        } else {\n-            bind.bindNull(\"$6\", io.r2dbc.postgresql.codec.Json.class);\n+        if (limiter != null) {\n+            query = limiter.getModifiedQuery(query);\n         }\n \n-        Flux<PostgresqlResult> execute = bind\n-                .returnGeneratedValues(\"id\")\n-                .execute();\n+        Mutiny.Query<Endpoint> mutinyQuery = session.createQuery(query, Endpoint.class)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"endpointType\", type);\n \n-        return execute.flatMap(res -> res\n-                .map(((row, rowMetadata) -> {\n-                    // Should we update the id here? row.get(\"id\", Integer.class); since it's the generated value\n-                    endpoint.setProperties(attr);\n-                    return endpoint;\n-                })));\n-    }\n+        if (activeOnly != null) {\n+            mutinyQuery = mutinyQuery.setParameter(\"enabled\", activeOnly);\n+        }\n \n-    private static final String basicEndpointSelectQuery = \"SELECT e.account_id, e.id AS endpoint_id, e.endpoint_type, e.enabled, e.name, e.description, e.created, e.updated\";\n-    private static final String webhookEndpointSelectQuery = \", ew.id AS webhook_id, ew.url, ew.method, ew.disable_ssl_verification, ew.secret_token, ew.basic_authentication\";\n-    private static final String basicEndpointGetQuery = basicEndpointSelectQuery + webhookEndpointSelectQuery + \" FROM public.endpoints AS e LEFT JOIN public.endpoint_webhooks AS ew ON ew.endpoint_id = e.id \";\n-    private static final String basicEndpointCountQuery = \"SELECT count(e.id) as count FROM public.endpoints AS e \";\n+        if (limiter != null && limiter.getLimit() != null && limiter.getLimit().getLimit() > 0) {\n+            mutinyQuery = mutinyQuery.setMaxResults(limiter.getLimit().getLimit())\n+                    .setFirstResult(limiter.getLimit().getOffset());\n+        }\n \n-    public Multi<Endpoint> getEndpointsPerType(String tenant, Endpoint.EndpointType type, Boolean activeOnly, Query limiter) {\n-        // TODO Modify the parameter to take a vararg of Functions that modify the query\n-        // TODO Modify to take account selective joins (JOIN (..) UNION (..)) based on the type, same for getEndpoints\n-        StringBuilder queryBuilder = new StringBuilder();\n-        queryBuilder\n-                .append(basicEndpointGetQuery)\n-                .append(\"WHERE e.account_id = $1 AND e.endpoint_type = $2\");\n+        return mutinyQuery.getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n+    }\n \n+    public Uni<Long> getEndpointsCountPerType(String tenant, EndpointType type, Boolean activeOnly) {\n+        String query = \"SELECT COUNT(*) FROM Endpoint WHERE accountId = :accountId AND type = :endpointType\";\n         if (activeOnly != null) {\n-            queryBuilder.append(\" AND e.enabled = $3\");\n+            query += \" AND enabled = :enabled\";\n         }\n \n-        final String query = limiter == null ? queryBuilder.toString() : limiter.getModifiedQuery(queryBuilder.toString());\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            PostgresqlStatement statement = c.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", type.ordinal());\n-\n-                            if (activeOnly != null) {\n-                                statement = statement.bind(\"$3\", activeOnly);\n-                            }\n-\n-                            Flux<PostgresqlResult> execute = statement.execute();\n-                            return this.mapResultSetToEndpoint(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n-    }\n-\n-    public Uni<Integer> getEndpointsCountPerType(String tenant, Endpoint.EndpointType type, Boolean activeOnly) {\n-        StringBuilder queryBuilder = new StringBuilder();\n-        queryBuilder\n-                .append(basicEndpointCountQuery)\n-                .append(\"WHERE e.account_id = $1 AND e.endpoint_type = $2\");\n+        Mutiny.Query<Long> mutinyQuery = session.createQuery(query, Long.class)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"endpointType\", type);\n \n         if (activeOnly != null) {\n-            queryBuilder.append(\" AND e.enabled = $3\");\n+            mutinyQuery = mutinyQuery.setParameter(\"enabled\", activeOnly);\n         }\n \n-        final String query = queryBuilder.toString();\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            PostgresqlStatement statement = c.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", type.ordinal());\n-\n-                            if (activeOnly != null) {\n-                                statement = statement.bind(\"$3\", activeOnly);\n-                            }\n-\n-                            Flux<PostgresqlResult> execute = statement.execute();\n-                            return execute.flatMap(r -> r.map((row, rowMetadata) -> row.get(0, Integer.class)));\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        return mutinyQuery.getSingleResult();\n     }\n \n     public Multi<Endpoint> getTargetEndpoints(String tenant, String bundleName, String applicationName, String eventTypeName) {\n         // TODO Add UNION JOIN for different endpoint types here\n-        String query = \"WITH accepted_event_types AS ( \" +\n-                \"SELECT et.id FROM public.event_type et \" +\n-                \"JOIN public.applications a ON a.id = et.application_id \" +\n-                \"JOIN public.bundles b ON b.id = a.bundle_id \" +\n-                \"WHERE a.name = $1 AND et.name = $2 AND b.name = $4) \" +\n-                basicEndpointGetQuery +\n-                \"JOIN public.endpoint_targets et ON et.endpoint_id = e.id \" +\n-                \"JOIN accepted_event_types aet ON aet.id = et.event_type_id \" +\n-                \"WHERE et.account_id = $3 AND e.enabled = true\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", applicationName)\n-                                    .bind(\"$2\", eventTypeName)\n-                                    .bind(\"$3\", tenant)\n-                                    .bind(\"$4\", bundleName)\n-                                    .execute();\n-\n-                            return this.mapResultSetToEndpoint(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n+        String query = \"SELECT e FROM Endpoint e LEFT JOIN FETCH e.webhook JOIN e.targets t \" +\n+                \"WHERE e.enabled = TRUE AND t.eventType.name = :eventTypeName AND t.id.accountId = :accountId \" +\n+                \"AND t.eventType.application.name = :applicationName AND t.eventType.application.bundle.name = :bundleName\";\n+\n+        return session.createQuery(query, Endpoint.class)\n+                .setParameter(\"applicationName\", applicationName)\n+                .setParameter(\"eventTypeName\", eventTypeName)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"bundleName\", bundleName)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n \n     public Multi<Endpoint> getEndpoints(String tenant, Query limiter) {\n         // TODO Add the ability to modify the getEndpoints to return also with JOIN to application_eventtypes_endpoints link table\n         //      or should I just create a new method for it?\n-        String allAccountEndpointsQuery = basicEndpointGetQuery + \" WHERE e.account_id = $1\";\n+        String query = \"SELECT e FROM Endpoint e LEFT JOIN FETCH e.webhook WHERE e.accountId = :accountId\";\n \n-        String query = limiter.getModifiedQuery(allAccountEndpointsQuery);\n+        if (limiter != null) {\n+            query = limiter.getModifiedQuery(query);\n+        }\n         // TODO Add JOIN ON clause to proper table, such as webhooks and then read the results\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .execute();\n-\n-                            return this.mapResultSetToEndpoint(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n-    }\n \n-    public Uni<Integer> getEndpointsCount(String tenant) {\n-        String query = basicEndpointCountQuery + \" WHERE e.account_id = $1\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .execute();\n-                            return execute.flatMap(r -> r.map((row, rowMetadata) -> row.get(0, Integer.class)));\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n-    }\n+        Mutiny.Query<Endpoint> mutinyQuery = session.createQuery(query, Endpoint.class)\n+                .setParameter(\"accountId\", tenant);\n \n-    private Flux<Endpoint> mapResultSetToEndpoint(Flux<PostgresqlResult> resultFlux) {\n-        return resultFlux.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-            Endpoint.EndpointType endpointType = Endpoint.EndpointType.values()[row.get(\"endpoint_type\", Integer.class)];\n-\n-            Endpoint endpoint = new Endpoint();\n-            endpoint.setTenant(row.get(\"account_id\", String.class));\n-            endpoint.setId(row.get(\"endpoint_id\", UUID.class));\n-            endpoint.setEnabled(row.get(\"enabled\", Boolean.class));\n-            endpoint.setType(endpointType);\n-            endpoint.setName(row.get(\"name\", String.class));\n-            endpoint.setDescription(row.get(\"description\", String.class));\n-            endpoint.setCreated(row.get(\"created\", Date.class));\n-            endpoint.setUpdated(row.get(\"updated\", Date.class));\n-\n-            switch (endpointType) {\n-                case WEBHOOK:\n-                    WebhookAttributes attr = new WebhookAttributes();\n-                    attr.setId(row.get(\"webhook_id\", Integer.class));\n-                    attr.setDisableSSLVerification(row.get(\"disable_ssl_verification\", Boolean.class));\n-                    attr.setSecretToken(row.get(\"secret_token\", String.class));\n-                    String method = row.get(\"method\", String.class);\n-                    attr.setMethod(WebhookAttributes.HttpType.valueOf(method));\n-                    attr.setUrl(row.get(\"url\", String.class));\n-\n-                    String basicAuthentication = row.get(\"basic_authentication\", String.class);\n-                    if (basicAuthentication != null) {\n-                        attr.setBasicAuthentication(Json.decodeValue(basicAuthentication, WebhookAttributes.BasicAuthentication.class));\n-                    }\n+        if (limiter != null && limiter.getLimit() != null && limiter.getLimit().getLimit() > 0) {\n+            mutinyQuery = mutinyQuery.setMaxResults(limiter.getLimit().getLimit())\n+                    .setFirstResult(limiter.getLimit().getOffset());\n+        }\n \n-                    endpoint.setProperties(attr);\n-                    break;\n-                default:\n-            }\n+        return mutinyQuery.getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n+    }\n \n-            return endpoint;\n-        }));\n+    public Uni<Long> getEndpointsCount(String tenant) {\n+        String query = \"SELECT COUNT(*) FROM Endpoint WHERE accountId = :accountId\";\n+        return session.createQuery(query, Long.class)\n+                .setParameter(\"accountId\", tenant)\n+                .getSingleResult();\n     }\n \n     public Uni<Endpoint> getEndpoint(String tenant, UUID id) {\n-        String allAccountEndpointsQuery = basicEndpointGetQuery + \" WHERE e.account_id = $1\";\n-        String query = allAccountEndpointsQuery + \" AND e.id = $2\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", id)\n-                                    .execute();\n-                            return this.mapResultSetToEndpoint(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        String query = \"SELECT e FROM Endpoint e LEFT JOIN FETCH e.webhook WHERE e.accountId = :accountId AND e.id = :id\";\n+        return session.createQuery(query, Endpoint.class)\n+                .setParameter(\"id\", id)\n+                .setParameter(\"accountId\", tenant)\n+                .getSingleResultOrNull();\n     }\n \n     public Uni<Boolean> deleteEndpoint(String tenant, UUID id) {\n-        String query = \"DELETE FROM public.endpoints WHERE account_id = $1 AND id = $2\";\n-        Mono<Boolean> monoResult =\n-                Mono.usingWhen(connectionPublisher.get(),\n-                        conn -> {\n-                            Flux<PostgresqlResult> resultFlux = conn.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", id)\n-                                    .execute();\n-\n-                            // Actually, the endpoint targeting this should be repeatable\n-                            return resultFlux.flatMap(PostgresqlResult::getRowsUpdated)\n-                                    .map(i -> i > 0).next();\n-                        },\n-                        PostgresqlConnection::close);\n-\n-        return Uni.createFrom().converter(UniReactorConverters.fromMono(), monoResult);\n+        String query = \"DELETE FROM Endpoint WHERE accountId = :accountId AND id = :id\";\n+        return session.createQuery(query)\n+                .setParameter(\"id\", id)\n+                .setParameter(\"accountId\", tenant)\n+                .executeUpdate()\n+                .call(session::flush)\n+                .onItem().transform(rowCount -> rowCount > 0);\n+        // Actually, the endpoint targeting this should be repeatable\n     }\n \n     public Uni<Boolean> disableEndpoint(String tenant, UUID id) {\n@@ -326,226 +149,165 @@\n         return modifyEndpointStatus(tenant, id, true);\n     }\n \n-    public Uni<Boolean> modifyEndpointStatus(String tenant, UUID id, boolean enabled) {\n-        String query = \"UPDATE public.endpoints SET enabled = $1 WHERE account_id = $2 AND id = $3\";\n-\n-        Mono<Boolean> monoResult =\n-                Mono.usingWhen(connectionPublisher.get(),\n-                        conn -> {\n-                            Flux<PostgresqlResult> resultFlux = conn.createStatement(query)\n-                                    .bind(\"$1\", enabled)\n-                                    .bind(\"$2\", tenant)\n-                                    .bind(\"$3\", id)\n-                                    .execute();\n+    private Uni<Boolean> modifyEndpointStatus(String tenant, UUID id, boolean enabled) {\n+        String query = \"UPDATE Endpoint SET enabled = :enabled WHERE accountId = :accountId AND id = :id\";\n \n-                            return resultFlux.flatMap(PostgresqlResult::getRowsUpdated)\n-                                    .map(i -> i > 0).next();\n-                        },\n-                        PostgresqlConnection::close);\n-\n-        return Uni.createFrom().converter(UniReactorConverters.fromMono(), monoResult);\n+        return session.createQuery(query)\n+                .setParameter(\"id\", id)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"enabled\", enabled)\n+                .executeUpdate()\n+                .call(session::flush)\n+                .onItem().transform(rowCount -> rowCount > 0);\n     }\n \n     public Uni<Boolean> linkEndpoint(String tenant, UUID endpointId, UUID eventTypeId) {\n-        String query = \"INSERT INTO public.endpoint_targets (account_id, event_type_id, endpoint_id) VALUES ($1, $2, $3)\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", eventTypeId)\n-                                    .bind(\"$3\", endpointId)\n-                                    .execute();\n-                            return execute.flatMap(PostgresqlResult::getRowsUpdated)\n-                                    .map(i -> i > 0).next();\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        return Uni.createFrom().item(() -> {\n+            Endpoint endpoint = session.getReference(Endpoint.class, endpointId);\n+            EventType eventType = session.getReference(EventType.class, eventTypeId);\n+            return new EndpointTarget(tenant, endpoint, eventType);\n+        })\n+                .onItem().transformToUni(session::persist)\n+                .call(session::flush)\n+                .replaceWith(Boolean.TRUE)\n+                .onFailure().recoverWithItem(Boolean.FALSE);\n     }\n \n     public Uni<Boolean> unlinkEndpoint(String tenant, UUID endpointId, UUID eventTypeId) {\n-        String query = \"DELETE FROM public.endpoint_targets WHERE account_id = $1 AND event_type_id = $2 AND endpoint_id = $3\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", eventTypeId)\n-                                    .bind(\"$3\", endpointId)\n-                                    .execute();\n-                            return execute.flatMap(PostgresqlResult::getRowsUpdated)\n-                                    .map(i -> i > 0).next();\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        String query = \"DELETE FROM EndpointTarget WHERE id.accountId = :accountId AND eventType.id = :eventTypeId AND endpoint.id = :endpointId\";\n+\n+        return session.createQuery(query)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"eventTypeId\", eventTypeId)\n+                .setParameter(\"endpointId\", endpointId)\n+                .executeUpdate()\n+                .call(session::flush)\n+                .onItem().transform(rowCount -> rowCount > 0);\n     }\n \n     public Multi<Endpoint> getLinkedEndpoints(String tenant, UUID eventTypeId, Query limiter) {\n-        String basicQuery = basicEndpointGetQuery +\n-                \"JOIN public.endpoint_targets et ON et.endpoint_id = e.id \" +\n-                \"WHERE et.account_id = $1 AND et.event_type_id = $2\";\n-\n-        String query = limiter.getModifiedQuery(basicQuery);\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", eventTypeId)\n-                                    .execute();\n-\n-                            return this.mapResultSetToEndpoint(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n+        String query = \"SELECT e FROM Endpoint e LEFT JOIN FETCH e.webhook JOIN e.targets t WHERE t.id.accountId = :accountId AND t.eventType.id = :eventTypeId\";\n+\n+        if (limiter != null) {\n+            query = limiter.getModifiedQuery(query);\n+        }\n+\n+        Mutiny.Query<Endpoint> mutinyQuery = session.createQuery(query, Endpoint.class)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"eventTypeId\", eventTypeId);\n+\n+        if (limiter != null && limiter.getLimit() != null && limiter.getLimit().getLimit() > 0) {\n+            mutinyQuery = mutinyQuery.setMaxResults(limiter.getLimit().getLimit())\n+                    .setFirstResult(limiter.getLimit().getOffset());\n+        }\n+\n+        return mutinyQuery.getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n \n     public Multi<Endpoint> getDefaultEndpoints(String tenant) {\n-        String query = \"WITH default_endpoints AS ( \" +\n-                \"SELECT endpoint_id \" +\n-                \"FROM public.endpoint_defaults \" +\n-                \"WHERE account_id = $1 \" +\n-                \")\" +\n-                basicEndpointGetQuery +\n-                \"JOIN default_endpoints ae ON ae.endpoint_id = e.id\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .execute();\n-\n-                            return this.mapResultSetToEndpoint(execute);\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }));\n+        String query = \"SELECT e FROM Endpoint e LEFT JOIN FETCH e.webhook JOIN e.defaults d WHERE d.id.accountId = :accountId\";\n+\n+        return session.createQuery(query, Endpoint.class)\n+                .setParameter(\"accountId\", tenant)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n \n     public Uni<Boolean> endpointInDefaults(String tenant, UUID endpointId) {\n-        String query = \"SELECT count(endpoint_id) FROM public.endpoint_defaults WHERE account_id = $1 and endpoint_id = $2\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", endpointId)\n-                                    .execute();\n-\n-                            return execute.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> row.get(0, Integer.class) > 0));\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        })).toUni();\n+        String query = \"SELECT COUNT(*) FROM EndpointDefault WHERE id.accountId = :accountId AND endpoint.id = :endpointId\";\n+\n+        return session.createQuery(query, Long.class)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"endpointId\", endpointId)\n+                .getSingleResult()\n+                .onItem().transform(count -> count > 0);\n     }\n \n     public Uni<Boolean> addEndpointToDefaults(String tenant, UUID endpointId) {\n-        String query = \"INSERT INTO public.endpoint_defaults (account_id, endpoint_id) VALUES ($1, $2)\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", endpointId)\n-                                    .execute();\n-                            return execute.flatMap(PostgresqlResult::getRowsUpdated)\n-                                    .map(i -> i > 0).next();\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni()\n-                .onFailure()\n-                .transform(t -> {\n-                    if (t instanceof R2dbcDataIntegrityViolationException) {\n-                        return new BadRequestException(\"Given endpoint id can not be linked to default\");\n-                    }\n-                    return t;\n-                });\n+        return Uni.createFrom().item(() -> {\n+            Endpoint endpoint = session.getReference(Endpoint.class, endpointId);\n+            return new EndpointDefault(tenant, endpoint);\n+        })\n+                .onItem().transformToUni(session::persist)\n+                .call(session::flush)\n+                .onFailure(PersistenceException.class).transform(a -> new BadRequestException(\"Given endpoint id can not be linked to default\"))\n+                .replaceWith(Boolean.TRUE);\n     }\n \n     public Uni<Boolean> deleteEndpointFromDefaults(String tenant, UUID endpointId) {\n-        String query = \"DELETE FROM public.endpoint_defaults WHERE account_id = $1 AND endpoint_id = $2\";\n-\n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", endpointId)\n-                                    .execute();\n-                            return execute.flatMap(PostgresqlResult::getRowsUpdated)\n-                                    .map(i -> i > 0).next();\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+        String query = \"DELETE FROM EndpointDefault WHERE accountId = :accountId AND endpointId = :endpointId\";\n+\n+        return session.createQuery(query)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"endpointId\", endpointId)\n+                .executeUpdate()\n+                .call(session::flush)\n+                .onItem().transform(rowCount -> rowCount > 0);\n     }\n \n     public Uni<Boolean> updateEndpoint(Endpoint endpoint) {\n         // TODO Update could fail because the item did not exist, throw 404 in that case?\n         // TODO Fix transaction so that we don't end up with half the updates applied\n-        Mono<Boolean> endpointMono =\n-                Mono.usingWhen(connectionPublisher.get(),\n-                        conn -> updateEndpointStatement(endpoint, conn)\n-                                .flatMap(ep -> {\n-                                    if (endpoint.getProperties() != null && endpoint.getType() == Endpoint.EndpointType.WEBHOOK) {\n-                                        return updateWebhooksStatement(endpoint, conn);\n-                                    }\n-                                    return Mono.empty();\n-                                }),\n-                        PostgresqlConnection::close);\n-\n-        return Uni.createFrom().converter(UniReactorConverters.fromMono(), endpointMono);\n-    }\n-\n-    private Mono<Boolean> updateEndpointStatement(Endpoint endpoint, PostgresqlConnection conn) {\n-        String endpointQuery = \"UPDATE public.endpoints SET name = $3, description = $4, enabled = $5, updated = $6 WHERE account_id = $1 AND id = $2\";\n-        PostgresqlStatement bindSt = conn.createStatement(endpointQuery)\n-                .bind(\"$1\", endpoint.getTenant())\n-                .bind(\"$2\", endpoint.getId())\n-                .bind(\"$3\", endpoint.getName())\n-                .bind(\"$4\", endpoint.getDescription())\n-                .bind(\"$5\", endpoint.isEnabled())\n-                .bind(\"$6\", LocalDateTime.now());\n-\n-        return bindSt\n-                .execute()\n-                .flatMap(PostgresqlResult::getRowsUpdated)\n-                .map(i -> i > 0).next();\n+        String endpointQuery = \"UPDATE Endpoint SET name = :name, description = :description, enabled = :enabled \" +\n+                \"WHERE accountId = :accountId AND id = :id\";\n+        String webhookQuery = \"UPDATE EndpointWebhook SET url = :url, method = :method, \" +\n+                \"disableSslVerification = :disableSslVerification, secretToken = :secretToken WHERE endpoint.id = :endpointId\";\n+\n+        return session.createQuery(endpointQuery)\n+                .setParameter(\"name\", endpoint.getName())\n+                .setParameter(\"description\", endpoint.getDescription())\n+                .setParameter(\"enabled\", endpoint.getEnabled())\n+                .setParameter(\"accountId\", endpoint.getAccountId())\n+                .setParameter(\"id\", endpoint.getId())\n+                .executeUpdate()\n+                .call(session::flush)\n+                .onItem().transformToUni(endpointRowCount -> {\n+                    if (endpointRowCount == 0) {\n+                        return Uni.createFrom().item(Boolean.FALSE);\n+                    } else if (endpoint.getProperties() == null || endpoint.getType() != EndpointType.WEBHOOK) {\n+                        return Uni.createFrom().item(Boolean.TRUE);\n+                    } else {\n+                        WebhookAttributes attr = (WebhookAttributes) endpoint.getProperties();\n+                        return session.createQuery(webhookQuery)\n+                                .setParameter(\"url\", attr.getUrl())\n+                                .setParameter(\"method\", attr.getMethod())\n+                                .setParameter(\"disableSslVerification\", attr.isDisableSSLVerification())\n+                                .setParameter(\"secretToken\", attr.getSecretToken())\n+                                .setParameter(\"endpointId\", endpoint.getId())\n+                                .executeUpdate()\n+                                .call(session::flush)\n+                                .onItem().transform(rowCount -> rowCount > 0);\n+                    }\n+                });\n     }\n \n-    private Mono<Boolean> updateWebhooksStatement(Endpoint endpoint, PostgresqlConnection conn) {\n-        WebhookAttributes attr = (WebhookAttributes) endpoint.getProperties();\n-        String webhookQuery = \"UPDATE public.endpoint_webhooks SET url = $2, method = $3, disable_ssl_verification = $4, secret_token = $5 WHERE endpoint_id = $1 \";\n-\n-        PostgresqlStatement bindSt = conn.createStatement(webhookQuery)\n-                .bind(\"$1\", endpoint.getId())\n-                .bind(\"$2\", attr.getUrl())\n-                .bind(\"$3\", attr.getMethod().toString())\n-                .bind(\"$4\", attr.isDisableSSLVerification());\n-\n-        if (attr.getSecretToken() != null) {\n-            bindSt.bind(\"$5\", attr.getSecretToken());\n-        } else {\n-            bindSt.bindNull(\"$5\", String.class);\n+    private Endpoint mapProperties(Endpoint endpoint) {\n+        if (endpoint.getProperties() != null) {\n+            switch (endpoint.getType()) {\n+                case WEBHOOK:\n+                    EndpointWebhook webhook = webhook(endpoint.getProperties());\n+                    webhook.setEndpoint(endpoint);\n+                    endpoint.setWebhook(webhook);\n+                    break;\n+                case EMAIL_SUBSCRIPTION:\n+                case DEFAULT:\n+                default:\n+                    // Do nothing for now\n+                    break;\n+            }\n         }\n+        return endpoint;\n+    }\n \n-        return bindSt\n-                .execute()\n-                .flatMap(PostgresqlResult::getRowsUpdated)\n-                .map(i -> i > 0).next();\n+    private EndpointWebhook webhook(Attributes properties) {\n+        WebhookAttributes attr = (WebhookAttributes) properties;\n+        EndpointWebhook webhook = new EndpointWebhook();\n+        webhook.setUrl(attr.getUrl());\n+        webhook.setMethod(attr.getMethod());\n+        webhook.setDisableSslVerification(attr.isDisableSSLVerification());\n+        webhook.setSecretToken(attr.getSecretToken());\n+        webhook.setBasicAuthentication(attr.getBasicAuthentication());\n+        return webhook;\n     }\n }"
  },
  {
    "sha": "714de7c0026ec2d1f6fb91bb787e9a1b7622cd24",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/FlywayWorkaround.java",
    "status": "added",
    "additions": 34,
    "deletions": 0,
    "changes": 34,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/FlywayWorkaround.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/FlywayWorkaround.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/FlywayWorkaround.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -0,0 +1,34 @@\n+package com.redhat.cloud.notifications.db;\n+\n+import io.quarkus.runtime.StartupEvent;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.flywaydb.core.Flyway;\n+import org.jboss.logging.Logger;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+/**\n+ * This is a temporary workaround for a quarkus-flyway / quarkus-hibernate-reactive incompatibility.\n+ * See https://github.com/quarkusio/quarkus/issues/10716 for more details.\n+ */\n+@ApplicationScoped\n+public class FlywayWorkaround {\n+\n+    private static final Logger LOGGER = Logger.getLogger(FlywayWorkaround.class);\n+\n+    @ConfigProperty(name = \"quarkus.datasource.reactive.url\")\n+    String datasourceUrl;\n+\n+    @ConfigProperty(name = \"quarkus.datasource.username\")\n+    String datasourceUsername;\n+\n+    @ConfigProperty(name = \"quarkus.datasource.password\")\n+    String datasourcePassword;\n+\n+    public void runFlywayMigration(@Observes StartupEvent event) {\n+        LOGGER.warn(\"Starting Flyway workaround... remove it ASAP!\");\n+        Flyway flyway = Flyway.configure().dataSource(\"jdbc:\" + datasourceUrl, datasourceUsername, datasourcePassword).load();\n+        flyway.migrate();\n+    }\n+}"
  },
  {
    "sha": "a1bf07458c55b830d286ff360a7e2bf635f515ce",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/NotificationResources.java",
    "status": "modified",
    "additions": 46,
    "deletions": 85,
    "changes": 131,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/NotificationResources.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/NotificationResources.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/NotificationResources.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -1,112 +1,73 @@\n package com.redhat.cloud.notifications.db;\n \n+import com.redhat.cloud.notifications.models.Endpoint;\n import com.redhat.cloud.notifications.models.NotificationHistory;\n-import io.r2dbc.postgresql.api.PostgresqlConnection;\n-import io.r2dbc.postgresql.api.PostgresqlResult;\n-import io.r2dbc.postgresql.api.PostgresqlStatement;\n-import io.r2dbc.postgresql.codec.Json;\n import io.smallrye.mutiny.Multi;\n import io.smallrye.mutiny.Uni;\n-import io.smallrye.mutiny.converters.multi.MultiReactorConverters;\n-import io.smallrye.mutiny.converters.uni.UniReactorConverters;\n import io.vertx.core.json.JsonObject;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n+import org.hibernate.reactive.mutiny.Mutiny;\n \n import javax.enterprise.context.ApplicationScoped;\n import javax.inject.Inject;\n-import javax.inject.Provider;\n-import java.util.Date;\n+import java.util.Map;\n import java.util.UUID;\n \n @ApplicationScoped\n public class NotificationResources {\n \n     @Inject\n-    Provider<Mono<PostgresqlConnection>> connectionPublisher;\n-\n-    @Inject\n-    Provider<Uni<PostgresqlConnection>> connectionPublisherUni;\n+    Mutiny.Session session;\n \n     public Uni<NotificationHistory> createNotificationHistory(NotificationHistory history) {\n-        Flux<NotificationHistory> notificationHistoryFlux = Flux.usingWhen(connectionPublisher.get(),\n-                conn -> {\n-                    String query = \"INSERT INTO public.notification_history (account_id, endpoint_id, invocation_time, invocation_result, event_id, details) VALUES ($1, $2, $3, $4, $5, $6)\";\n-\n-                    PostgresqlStatement st = conn.createStatement(query)\n-                            .bind(\"$1\", history.getTenant())\n-                            .bind(\"$2\", history.getEndpoint().getId())\n-                            .bind(\"$3\", history.getInvocationTime())\n-                            .bind(\"$4\", history.isInvocationResult())\n-                            .bind(\"$5\", history.getEventId());\n-\n-                    if (history.getDetails() != null) {\n-                        st.bind(\"$6\", Json.of(new JsonObject(history.getDetails()).encode()));\n-                    } else {\n-                        st.bindNull(\"$6\", Json.class);\n-                    }\n-                    Flux<PostgresqlResult> execute = st.returnGeneratedValues(\"id\", \"created\").execute();\n-                    return execute.flatMap(res -> res.map((row, rowMetadata) -> {\n-                        history.setCreated(row.get(\"created\", Date.class));\n-                        history.setId(row.get(\"id\", Integer.class));\n-                        return history;\n-                    }));\n-                },\n-                PostgresqlConnection::close);\n-\n-        return Uni.createFrom().converter(UniReactorConverters.fromMono(), notificationHistoryFlux.next());\n+        return Uni.createFrom().item(history)\n+                .onItem().transform(this::addEndpointReference)\n+                .onItem().transformToUni(session::persist)\n+                .call(session::flush)\n+                .replaceWith(history);\n     }\n \n     public Multi<NotificationHistory> getNotificationHistory(String tenant, UUID endpoint) {\n-        String query = \"SELECT id, endpoint_id, created, invocation_time, invocation_result, event_id FROM public.notification_history WHERE account_id = $1 AND endpoint_id = $2\";\n-        Flux<NotificationHistory> endpointFlux = Flux.usingWhen(connectionPublisher.get(),\n-                conn -> {\n-                    Flux<PostgresqlResult> resultFlux = conn.createStatement(query)\n-                            .bind(\"$1\", tenant)\n-                            .bind(\"$2\", endpoint)\n-                            .execute();\n-                    return mapResultSetToNotificationHistory(resultFlux);\n-                },\n-                PostgresqlConnection::close);\n-\n-        return Multi.createFrom().converter(MultiReactorConverters.fromFlux(), endpointFlux);\n+        // FIXME This loads more fields than before (accountId and details)\n+        String query = \"FROM NotificationHistory WHERE accountId = :accountId AND endpoint.id = :endpointId\";\n+        return session.createQuery(query, NotificationHistory.class)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"endpointId\", endpoint)\n+                .getResultList()\n+                .onItem().transformToMulti(Multi.createFrom()::iterable);\n     }\n \n-    private Flux<NotificationHistory> mapResultSetToNotificationHistory(Flux<PostgresqlResult> resultFlux) {\n-        return resultFlux.flatMap(postgresqlResult -> postgresqlResult.map((row, rowMetadata) -> {\n-            NotificationHistory history = new NotificationHistory();\n-            history.setId(row.get(\"id\", Integer.class));\n-            history.setCreated(row.get(\"created\", Date.class));\n-            history.setEndpointId(row.get(\"endpoint_id\", UUID.class));\n-            history.setInvocationResult(row.get(\"invocation_result\", Boolean.class));\n-            history.setInvocationTime(row.get(\"invocation_time\", Integer.class));\n-            history.setEventId(row.get(\"event_id\", String.class));\n+    public Uni<JsonObject> getNotificationDetails(String tenant, Query limiter, UUID endpoint, Integer historyId) {\n+        String query = \"SELECT details FROM NotificationHistory WHERE accountId = :accountId AND endpoint.id = :endpointId AND id = :historyId\";\n+        if (limiter != null) {\n+            query = limiter.getModifiedQuery(query);\n+        }\n \n-            return history;\n-        }));\n-    }\n+        Mutiny.Query<Map> mutinyQuery = session.createQuery(query, Map.class)\n+                .setParameter(\"accountId\", tenant)\n+                .setParameter(\"endpointId\", endpoint)\n+                .setParameter(\"historyId\", historyId);\n \n-    public Uni<JsonObject> getNotificationDetails(String tenant, Query limiter, UUID endpoint, Integer historyId) {\n-        String basicQuery = \"SELECT details FROM public.notification_history WHERE account_id = $1 AND endpoint_id = $2 AND id = $3\";\n-        String query = limiter.getModifiedQuery(basicQuery);\n+        if (limiter != null && limiter.getLimit() != null && limiter.getLimit().getLimit() > 0) {\n+            mutinyQuery = mutinyQuery.setMaxResults(limiter.getLimit().getLimit())\n+                    .setFirstResult(limiter.getLimit().getOffset());\n+        }\n+\n+        return mutinyQuery.getSingleResultOrNull()\n+                .onItem().ifNotNull().transform(JsonObject::new);\n+    }\n \n-        return connectionPublisherUni.get().onItem()\n-                .transformToMulti(c -> Multi.createFrom().resource(() -> c,\n-                        c2 -> {\n-                            Flux<PostgresqlResult> execute = c2.createStatement(query)\n-                                    .bind(\"$1\", tenant)\n-                                    .bind(\"$2\", endpoint)\n-                                    .bind(\"$3\", historyId)\n-                                    .execute();\n-                            return execute.flatMap(res -> res.map((row, rowMetadata) -> {\n-                                String json = row.get(\"details\", String.class);\n-                                // TODO json field is not necessarily available!\n-                                return new JsonObject(json);\n-                            }));\n-                        })\n-                        .withFinalizer(postgresqlConnection -> {\n-                            postgresqlConnection.close().subscribe();\n-                        }))\n-                .toUni();\n+    /**\n+     * Adds to the given {@link NotificationHistory} a reference to a persistent {@link Endpoint} without actually\n+     * loading its state from the database. The notification history will remain unchanged if it does not contain\n+     * a non-null endpoint identifier.\n+     *\n+     * @param history the notification history that will hold the endpoint reference\n+     * @return the same notification history instance, possibly modified if an endpoint reference was added\n+     */\n+    private NotificationHistory addEndpointReference(NotificationHistory history) {\n+        if (history.getEndpointId() != null && history.getEndpoint() == null) {\n+            history.setEndpoint(session.getReference(Endpoint.class, history.getEndpointId()));\n+        }\n+        return history;\n     }\n }"
  },
  {
    "sha": "64ed8e2e7182fe9bb26b60904c72fa5cfbe472a8",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/Query.java",
    "status": "modified",
    "additions": 0,
    "deletions": 21,
    "changes": 21,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/Query.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/Query.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/Query.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -104,13 +104,6 @@ public Sort getSort() {\n         return sort;\n     }\n \n-    public static String getLimiterQuery(Limit limiter) {\n-        return \"LIMIT \" +\n-                limiter.getLimit() +\n-                \" OFFSET \" +\n-                limiter.getOffset();\n-    }\n-\n     public String getModifiedQuery(String basicQuery) {\n         // Use the internal Query\n         // What's the proper order? SORT first, then LIMIT? COUNT as last one?\n@@ -119,23 +112,9 @@ public String getModifiedQuery(String basicQuery) {\n         if (sort != null) {\n             query = modifyWithSort(query, sort);\n         }\n-        Limit limiter = getLimit();\n-        if (limiter != null && (limiter.getLimit() > 0)) {\n-            query = modifyQueryWithOffsetLimit(query, limiter);\n-        }\n         return query;\n     }\n \n-    private static String modifyQueryWithOffsetLimit(String basicQuery, Query.Limit limiter) {\n-        if (limiter != null && limiter.getLimit() > 0) {\n-            return basicQuery +\n-                    \" \" +\n-                    Query.getLimiterQuery(limiter);\n-        }\n-\n-        return basicQuery;\n-    }\n-\n     public static Function<String, String> modifyToCountQuery() {\n         return s -> \"SELECT COUNT(*) FROM (\" +\n                 s +"
  },
  {
    "sha": "4cda07dccfa2e34d340f7551e8eb6fa9d4df4dc4",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/converters/BasicAuthenticationConverter.java",
    "status": "added",
    "additions": 29,
    "deletions": 0,
    "changes": 29,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/converters/BasicAuthenticationConverter.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/converters/BasicAuthenticationConverter.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/converters/BasicAuthenticationConverter.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -0,0 +1,29 @@\n+package com.redhat.cloud.notifications.db.converters;\n+\n+import com.redhat.cloud.notifications.models.BasicAuthentication;\n+import io.vertx.core.json.Json;\n+\n+import javax.persistence.AttributeConverter;\n+import javax.persistence.Converter;\n+\n+@Converter\n+public class BasicAuthenticationConverter implements AttributeConverter<BasicAuthentication, String> {\n+\n+    @Override\n+    public String convertToDatabaseColumn(BasicAuthentication auth) {\n+        if (auth == null) {\n+            return null;\n+        } else {\n+            return Json.encode(auth);\n+        }\n+    }\n+\n+    @Override\n+    public BasicAuthentication convertToEntityAttribute(String json) {\n+        if (json == null) {\n+            return null;\n+        } else {\n+            return Json.decodeValue(json, BasicAuthentication.class);\n+        }\n+    }\n+}"
  },
  {
    "sha": "c7a4b63ac351d9a66bb2ab78fd83c5983385a424",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/converters/EmailSubscriptionTypeConverter.java",
    "status": "added",
    "additions": 32,
    "deletions": 0,
    "changes": 32,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/converters/EmailSubscriptionTypeConverter.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/converters/EmailSubscriptionTypeConverter.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/converters/EmailSubscriptionTypeConverter.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -0,0 +1,32 @@\n+package com.redhat.cloud.notifications.db.converters;\n+\n+import com.redhat.cloud.notifications.models.EmailSubscriptionType;\n+\n+import javax.persistence.AttributeConverter;\n+import javax.persistence.Converter;\n+\n+@Converter\n+public class EmailSubscriptionTypeConverter implements AttributeConverter<EmailSubscriptionType, String> {\n+\n+    @Override\n+    public String convertToDatabaseColumn(EmailSubscriptionType type) {\n+        if (type == null) {\n+            return null;\n+        } else {\n+            return type.name();\n+        }\n+    }\n+\n+    @Override\n+    public EmailSubscriptionType convertToEntityAttribute(String name) {\n+        if (name == null) {\n+            return null;\n+        } else {\n+            try {\n+                return EmailSubscriptionType.valueOf(name);\n+            } catch (IllegalArgumentException e) {\n+                throw new RuntimeException(\"Unknown EmailSubscriptionType \" + name);\n+            }\n+        }\n+    }\n+}"
  },
  {
    "sha": "fc9f5362f24e52bdc97fa07d88277c0d43157583",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/converters/EndpointTypeConverter.java",
    "status": "added",
    "additions": 28,
    "deletions": 0,
    "changes": 28,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/converters/EndpointTypeConverter.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/converters/EndpointTypeConverter.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/converters/EndpointTypeConverter.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -0,0 +1,28 @@\n+package com.redhat.cloud.notifications.db.converters;\n+\n+import com.redhat.cloud.notifications.models.EndpointType;\n+\n+import javax.persistence.AttributeConverter;\n+import javax.persistence.Converter;\n+\n+@Converter\n+public class EndpointTypeConverter implements AttributeConverter<EndpointType, Integer> {\n+\n+    @Override\n+    public Integer convertToDatabaseColumn(EndpointType type) {\n+        if (type == null) {\n+            return null;\n+        } else {\n+            return type.ordinal();\n+        }\n+    }\n+\n+    @Override\n+    public EndpointType convertToEntityAttribute(Integer ordinal) {\n+        if (ordinal == null) {\n+            return null;\n+        } else {\n+            return EndpointType.values()[ordinal];\n+        }\n+    }\n+}"
  },
  {
    "sha": "6d2ad2b1b9e9833e393944e911a55ae16405c888",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/converters/HttpTypeConverter.java",
    "status": "added",
    "additions": 28,
    "deletions": 0,
    "changes": 28,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/converters/HttpTypeConverter.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/converters/HttpTypeConverter.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/converters/HttpTypeConverter.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -0,0 +1,28 @@\n+package com.redhat.cloud.notifications.db.converters;\n+\n+import com.redhat.cloud.notifications.models.HttpType;\n+\n+import javax.persistence.AttributeConverter;\n+import javax.persistence.Converter;\n+\n+@Converter\n+public class HttpTypeConverter implements AttributeConverter<HttpType, String> {\n+\n+    @Override\n+    public String convertToDatabaseColumn(HttpType type) {\n+        if (type == null) {\n+            return null;\n+        } else {\n+            return type.name();\n+        }\n+    }\n+\n+    @Override\n+    public HttpType convertToEntityAttribute(String name) {\n+        if (name == null) {\n+            return null;\n+        } else {\n+            return HttpType.valueOf(name);\n+        }\n+    }\n+}"
  },
  {
    "sha": "809ef25a33b34a6d4626fc0a6d2d13706b8799be",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/converters/JsonObjectConverter.java",
    "status": "added",
    "additions": 28,
    "deletions": 0,
    "changes": 28,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/converters/JsonObjectConverter.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/converters/JsonObjectConverter.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/converters/JsonObjectConverter.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -0,0 +1,28 @@\n+package com.redhat.cloud.notifications.db.converters;\n+\n+import io.vertx.core.json.JsonObject;\n+\n+import javax.persistence.AttributeConverter;\n+import javax.persistence.Converter;\n+\n+@Converter\n+public class JsonObjectConverter implements AttributeConverter<JsonObject, String> {\n+\n+    @Override\n+    public String convertToDatabaseColumn(JsonObject jsonObject) {\n+        if (jsonObject == null) {\n+            return null;\n+        } else {\n+            return jsonObject.encode();\n+        }\n+    }\n+\n+    @Override\n+    public JsonObject convertToEntityAttribute(String json) {\n+        if (json == null) {\n+            return null;\n+        } else {\n+            return new JsonObject(json);\n+        }\n+    }\n+}"
  },
  {
    "sha": "b8e6689d166b42efa89c64d2cce20aa07c51f539",
    "filename": "src/main/java/com/redhat/cloud/notifications/db/converters/NotificationHistoryDetailsConverter.java",
    "status": "added",
    "additions": 29,
    "deletions": 0,
    "changes": 29,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/converters/NotificationHistoryDetailsConverter.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/db/converters/NotificationHistoryDetailsConverter.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/db/converters/NotificationHistoryDetailsConverter.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -0,0 +1,29 @@\n+package com.redhat.cloud.notifications.db.converters;\n+\n+import io.vertx.core.json.Json;\n+\n+import javax.persistence.AttributeConverter;\n+import javax.persistence.Converter;\n+import java.util.Map;\n+\n+@Converter\n+public class NotificationHistoryDetailsConverter implements AttributeConverter<Map<String, Object>, String> {\n+\n+    @Override\n+    public String convertToDatabaseColumn(Map<String, Object> details) {\n+        if (details == null) {\n+            return null;\n+        } else {\n+            return Json.encode(details);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, Object> convertToEntityAttribute(String details) {\n+        if (details == null) {\n+            return null;\n+        } else {\n+            return Json.decodeValue(details, Map.class);\n+        }\n+    }\n+}"
  },
  {
    "sha": "367c4a57a7e1db0e669e9d05e7fb8969e299a347",
    "filename": "src/main/java/com/redhat/cloud/notifications/events/DefaultProcessor.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/events/DefaultProcessor.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/events/DefaultProcessor.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/events/DefaultProcessor.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -29,8 +29,8 @@ void init() {\n \n     public Multi<Endpoint> getDefaultEndpoints(Endpoint defaultEndpoint) {\n         processedItems.increment();\n-        return resources.getDefaultEndpoints(defaultEndpoint.getTenant())\n-                .transform().byFilteringItemsWith(Endpoint::isEnabled)\n+        return resources.getDefaultEndpoints(defaultEndpoint.getAccountId())\n+                .transform().byFilteringItemsWith(Endpoint::getEnabled)\n                 .onItem().invoke(() -> enrichedEndpoints.increment());\n     }\n }"
  },
  {
    "sha": "04035be1adad274acebdbdc40bf1e4935075f3b4",
    "filename": "src/main/java/com/redhat/cloud/notifications/events/EndpointProcessor.java",
    "status": "modified",
    "additions": 9,
    "deletions": 5,
    "changes": 14,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/events/EndpointProcessor.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/events/EndpointProcessor.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/events/EndpointProcessor.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -4,6 +4,7 @@\n import com.redhat.cloud.notifications.db.NotificationResources;\n import com.redhat.cloud.notifications.ingress.Action;\n import com.redhat.cloud.notifications.models.Endpoint;\n+import com.redhat.cloud.notifications.models.EndpointType;\n import com.redhat.cloud.notifications.models.Notification;\n import com.redhat.cloud.notifications.models.NotificationHistory;\n import com.redhat.cloud.notifications.processors.EndpointTypeProcessor;\n@@ -67,18 +68,21 @@ void init() {\n                     Notification endpointNotif = new Notification(action, endpoint);\n                     return endpointTypeToProcessor(endpoint.getType()).process(endpointNotif);\n                 })\n-                .merge()\n+                .concatenate()\n                 .onItem().transformToUni(history -> notifResources.createNotificationHistory(history))\n-                .merge();\n+                .concatenate();\n \n         // Should this be a separate endpoint type as well (since it is configurable) ?\n         Notification notification = new Notification(action, null);\n         Uni<NotificationHistory> notificationResult = notificationProcessor.process(notification);\n \n-        return Uni.combine().all().unis(endpointsCallResult.onItem().ignoreAsUni(), notificationResult).discardItems();\n+        return endpointsCallResult\n+                .onItem().ignoreAsUni()\n+                .replaceWith(notificationResult)\n+                .replaceWith(Uni.createFrom().voidItem());\n     }\n \n-    public EndpointTypeProcessor endpointTypeToProcessor(Endpoint.EndpointType endpointType) {\n+    public EndpointTypeProcessor endpointTypeToProcessor(EndpointType endpointType) {\n         switch (endpointType) {\n             case WEBHOOK:\n                 return webhooks;\n@@ -93,7 +97,7 @@ public EndpointTypeProcessor endpointTypeToProcessor(Endpoint.EndpointType endpo\n         return resources.getTargetEndpoints(tenant, bundleName, applicationName, eventTypeName)\n                 .flatMap((Function<Endpoint, Publisher<Endpoint>>) endpoint -> {\n                     // If the tenant has a default endpoint for the eventType, then add the target endpoints here\n-                    if (endpoint.getType() == Endpoint.EndpointType.DEFAULT) {\n+                    if (endpoint.getType() == EndpointType.DEFAULT) {\n                         return defaultProcessor.getDefaultEndpoints(endpoint);\n                     }\n                     return Multi.createFrom().item(endpoint);"
  },
  {
    "sha": "76bdf7f65c055dd2946532e73e872ea7fa397944",
    "filename": "src/main/java/com/redhat/cloud/notifications/models/Application.java",
    "status": "modified",
    "additions": 73,
    "deletions": 43,
    "changes": 116,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/Application.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/Application.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/models/Application.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -1,46 +1,60 @@\n package com.redhat.cloud.notifications.models;\n \n-import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n-import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-\n+import com.fasterxml.jackson.databind.annotation.JsonNaming;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.Table;\n+import javax.persistence.Transient;\n import javax.validation.constraints.NotNull;\n import javax.validation.constraints.Pattern;\n-import java.util.Date;\n+import javax.validation.constraints.Size;\n+import java.util.Objects;\n import java.util.Set;\n import java.util.UUID;\n \n-public class Application {\n+import static com.fasterxml.jackson.annotation.JsonProperty.Access.READ_ONLY;\n+import static com.fasterxml.jackson.databind.PropertyNamingStrategies.SnakeCaseStrategy;\n+\n+@Entity\n+@Table(name = \"applications\")\n+@JsonNaming(SnakeCaseStrategy.class)\n+public class Application extends CreationUpdateTimestamped {\n+\n+    @Id\n+    @GeneratedValue\n+    @JsonProperty(access = READ_ONLY)\n     private UUID id;\n \n     @NotNull\n     @Pattern(regexp = \"[a-z][a-z_0-9-]*\")\n+    @Size(max = 255)\n     private String name;\n \n     @NotNull\n-    @JsonInclude(JsonInclude.Include.NON_NULL)\n-    private String display_name;\n-\n-    @JsonFormat(shape = JsonFormat.Shape.STRING)\n-    @JsonInclude(JsonInclude.Include.NON_NULL)\n-    private Date created;\n-\n-    @JsonFormat(shape = JsonFormat.Shape.STRING)\n-    @JsonInclude(JsonInclude.Include.NON_NULL)\n-    private Date updated;\n-\n-    @JsonInclude(JsonInclude.Include.NON_NULL)\n-    private Set<EventType> eventTypes; // optional\n+    @Column(name = \"display_name\")\n+    private String displayName;\n \n-    @NotNull\n-    @JsonInclude(JsonInclude.Include.NON_NULL)\n-    @JsonProperty(\"bundle_id\")\n+    @Transient\n     private UUID bundleId;\n \n-    public Application() {\n+    @ManyToOne(fetch = FetchType.LAZY, optional = false)\n+    @JoinColumn(name = \"bundle_id\")\n+    @JsonIgnore\n+    private Bundle bundle;\n \n-    }\n+    @OneToMany(mappedBy = \"application\", cascade = CascadeType.REMOVE)\n+    @JsonIgnore\n+    private Set<EventType> eventTypes;\n \n     public UUID getId() {\n         return id;\n@@ -58,39 +72,55 @@ public void setName(String name) {\n         this.name = name;\n     }\n \n-    public String getDisplay_name() {\n-        return display_name;\n+    public String getDisplayName() {\n+        return displayName;\n+    }\n+\n+    public void setDisplayName(String displayName) {\n+        this.displayName = displayName;\n     }\n \n-    public void setDisplay_name(String display_name) {\n-        this.display_name = display_name;\n+    public UUID getBundleId() {\n+        if (bundleId == null && bundle != null) {\n+            bundleId = bundle.getId();\n+        }\n+        return bundleId;\n     }\n \n-    @JsonProperty\n-    public Date getCreated() {\n-        return created;\n+    public void setBundleId(UUID bundleId) {\n+        this.bundleId = bundleId;\n     }\n \n-    @JsonIgnore\n-    public void setCreated(Date created) {\n-        this.created = created;\n+    public Bundle getBundle() {\n+        return bundle;\n     }\n \n-    @JsonProperty\n-    public Date getUpdated() {\n-        return updated;\n+    public void setBundle(Bundle bundle) {\n+        this.bundle = bundle;\n     }\n \n-    @JsonIgnore\n-    public void setUpdated(Date updated) {\n-        this.updated = updated;\n+    public Set<EventType> getEventTypes() {\n+        return eventTypes;\n     }\n \n-    public UUID getBundleId() {\n-        return bundleId;\n+    public void setEventTypes(Set<EventType> eventTypes) {\n+        this.eventTypes = eventTypes;\n     }\n \n-    public void setBundleId(UUID bundleId) {\n-        this.bundleId = bundleId;\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof Application) {\n+            Application other = (Application) o;\n+            return Objects.equals(id, other.id);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n     }\n }"
  },
  {
    "sha": "4559d69d3cf6031eec8a347f78f6d05760d7d9a6",
    "filename": "src/main/java/com/redhat/cloud/notifications/models/BasicAuthentication.java",
    "status": "added",
    "additions": 21,
    "deletions": 0,
    "changes": 21,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/BasicAuthentication.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/BasicAuthentication.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/models/BasicAuthentication.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -0,0 +1,21 @@\n+package com.redhat.cloud.notifications.models;\n+\n+public class BasicAuthentication {\n+    private String username;\n+    private String password;\n+\n+    public BasicAuthentication() { }\n+\n+    public BasicAuthentication(String username, String password) {\n+        this.username = username;\n+        this.password = password;\n+    }\n+\n+    public String getUsername() {\n+        return username;\n+    }\n+\n+    public String getPassword() {\n+        return password;\n+    }\n+}"
  },
  {
    "sha": "f5b04be8f77cb5b12d5b20c8a36c7a680e7b4e5b",
    "filename": "src/main/java/com/redhat/cloud/notifications/models/Bundle.java",
    "status": "modified",
    "additions": 54,
    "deletions": 41,
    "changes": 95,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/Bundle.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/Bundle.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/models/Bundle.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -1,46 +1,58 @@\n package com.redhat.cloud.notifications.models;\n \n-import com.fasterxml.jackson.annotation.JsonFormat;\n-import com.fasterxml.jackson.annotation.JsonInclude;\n-\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.annotation.JsonNaming;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+import javax.persistence.OneToMany;\n+import javax.persistence.Table;\n import javax.validation.constraints.NotNull;\n import javax.validation.constraints.Pattern;\n-import java.util.Date;\n+import javax.validation.constraints.Size;\n+import java.util.Objects;\n import java.util.Set;\n import java.util.UUID;\n \n+import static com.fasterxml.jackson.annotation.JsonProperty.Access.READ_ONLY;\n+import static com.fasterxml.jackson.databind.PropertyNamingStrategies.SnakeCaseStrategy;\n+\n /**\n  * A bundle is an aggregation of applications.\n  */\n-public class Bundle {\n+@Entity\n+@Table(name = \"bundles\")\n+@JsonNaming(SnakeCaseStrategy.class)\n+public class Bundle extends CreationUpdateTimestamped {\n \n-    UUID id;\n+    @Id\n+    @GeneratedValue\n+    @JsonProperty(access = READ_ONLY)\n+    private UUID id;\n \n     @NotNull\n     @Pattern(regexp = \"[a-z][a-z_0-9-]*\")\n-    String name;\n+    @Size(max = 255)\n+    private String name;\n \n     @NotNull\n-    @JsonInclude(JsonInclude.Include.NON_NULL)\n-    String display_name;\n-\n-    @JsonFormat(shape = JsonFormat.Shape.STRING)\n-    @JsonInclude(JsonInclude.Include.NON_NULL)\n-    private Date created;\n+    @Column(name = \"display_name\")\n+    private String displayName;\n \n-    @JsonFormat(shape = JsonFormat.Shape.STRING)\n-    @JsonInclude(JsonInclude.Include.NON_NULL)\n-    private Date updated;\n-\n-    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    @OneToMany(mappedBy = \"bundle\", cascade = CascadeType.REMOVE)\n+    @JsonIgnore\n     private Set<Application> applications;\n \n     public Bundle() {\n     }\n \n-    public Bundle(String bundleName, String display_name) {\n-        this.name = bundleName;\n-        this.display_name = display_name;\n+    public Bundle(String name, String displayName) {\n+        this.name = name;\n+        this.displayName = displayName;\n     }\n \n     public UUID getId() {\n@@ -59,28 +71,12 @@ public void setName(String name) {\n         this.name = name;\n     }\n \n-    public String getDisplay_name() {\n-        return display_name;\n-    }\n-\n-    public void setDisplay_name(String display_name) {\n-        this.display_name = display_name;\n-    }\n-\n-    public Date getCreated() {\n-        return created;\n+    public String getDisplayName() {\n+        return displayName;\n     }\n \n-    public void setCreated(Date created) {\n-        this.created = created;\n-    }\n-\n-    public Date getUpdated() {\n-        return updated;\n-    }\n-\n-    public void setUpdated(Date updated) {\n-        this.updated = updated;\n+    public void setDisplayName(String displayName) {\n+        this.displayName = displayName;\n     }\n \n     public Set<Application> getApplications() {\n@@ -90,4 +86,21 @@ public void setUpdated(Date updated) {\n     public void setApplications(Set<Application> applications) {\n         this.applications = applications;\n     }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof Bundle) {\n+            Bundle other = (Bundle) o;\n+            return Objects.equals(id, other.id);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n+    }\n }"
  },
  {
    "sha": "6072e2d6ac2a1bd510064152700ca1ea5ddb9f1a",
    "filename": "src/main/java/com/redhat/cloud/notifications/models/CreationTimestamped.java",
    "status": "added",
    "additions": 35,
    "deletions": 0,
    "changes": 35,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/CreationTimestamped.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/CreationTimestamped.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/models/CreationTimestamped.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -0,0 +1,35 @@\n+package com.redhat.cloud.notifications.models;\n+\n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import javax.persistence.MappedSuperclass;\n+import javax.persistence.PrePersist;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+\n+import static com.fasterxml.jackson.annotation.JsonFormat.Shape.STRING;\n+import static com.fasterxml.jackson.annotation.JsonProperty.Access.READ_ONLY;\n+\n+@MappedSuperclass\n+public abstract class CreationTimestamped {\n+\n+    protected static final ZoneId UTC = ZoneId.of(\"UTC\");\n+\n+    @JsonProperty(access = READ_ONLY)\n+    @JsonFormat(shape = STRING)\n+    private LocalDateTime created;\n+\n+    public LocalDateTime getCreated() {\n+        return created;\n+    }\n+\n+    public void setCreated(LocalDateTime created) {\n+        this.created = created;\n+    }\n+\n+    @PrePersist\n+    public void prePersist() {\n+        created = LocalDateTime.now(UTC);\n+    }\n+}"
  },
  {
    "sha": "d54816493b20e72e6fcfe3e6fa1fc99e58fa06c6",
    "filename": "src/main/java/com/redhat/cloud/notifications/models/CreationUpdateTimestamped.java",
    "status": "added",
    "additions": 35,
    "deletions": 0,
    "changes": 35,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/CreationUpdateTimestamped.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/CreationUpdateTimestamped.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/models/CreationUpdateTimestamped.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -0,0 +1,35 @@\n+package com.redhat.cloud.notifications.models;\n+\n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import javax.persistence.MappedSuperclass;\n+import javax.persistence.PreUpdate;\n+import java.time.LocalDateTime;\n+\n+import static com.fasterxml.jackson.annotation.JsonFormat.Shape.STRING;\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL;\n+import static com.fasterxml.jackson.annotation.JsonProperty.Access.READ_ONLY;\n+\n+@MappedSuperclass\n+public abstract class CreationUpdateTimestamped extends CreationTimestamped {\n+\n+    @JsonProperty(access = READ_ONLY)\n+    @JsonInclude(NON_NULL)\n+    @JsonFormat(shape = STRING)\n+    private LocalDateTime updated;\n+\n+    public LocalDateTime getUpdated() {\n+        return updated;\n+    }\n+\n+    public void setUpdated(LocalDateTime updated) {\n+        this.updated = updated;\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        updated = LocalDateTime.now(UTC);\n+    }\n+}"
  },
  {
    "sha": "0747f8f6edc43fc221f7e0c88045054f40e73a13",
    "filename": "src/main/java/com/redhat/cloud/notifications/models/EmailAggregation.java",
    "status": "modified",
    "additions": 55,
    "deletions": 28,
    "changes": 83,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/EmailAggregation.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/EmailAggregation.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/models/EmailAggregation.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -1,34 +1,52 @@\n package com.redhat.cloud.notifications.models;\n \n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.redhat.cloud.notifications.db.converters.JsonObjectConverter;\n import io.vertx.core.json.JsonObject;\n \n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.Table;\n import javax.validation.constraints.NotNull;\n-import java.time.LocalDateTime;\n+import javax.validation.constraints.Size;\n+import java.util.Objects;\n \n-public class EmailAggregation {\n+import static com.fasterxml.jackson.annotation.JsonProperty.Access.READ_ONLY;\n \n-    @NotNull\n+@Entity\n+@Table(name = \"email_aggregation\")\n+public class EmailAggregation extends CreationTimestamped {\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO, generator = \"email_aggregation_id_seq\")\n+    @JsonProperty(access = READ_ONLY)\n     private Integer id;\n \n     @NotNull\n+    @Size(max = 50)\n+    @Column(name = \"account_id\")\n     private String accountId;\n \n     @NotNull\n-    private LocalDateTime created;\n-\n-    @NotNull\n-    private String bundle;\n+    @Size(max = 255)\n+    @Column(name = \"bundle\")\n+    @JsonProperty(\"bundle\")\n+    private String bundleName;\n \n     @NotNull\n-    private String application;\n+    @Size(max = 255)\n+    @Column(name = \"application\")\n+    @JsonProperty(\"application\")\n+    private String applicationName;\n \n     @NotNull\n+    @Convert(converter = JsonObjectConverter.class)\n     private JsonObject payload;\n \n-    public EmailAggregation() {\n-\n-    }\n-\n     public Integer getId() {\n         return id;\n     }\n@@ -45,35 +63,44 @@ public void setAccountId(String accountId) {\n         this.accountId = accountId;\n     }\n \n-    public LocalDateTime getCreated() {\n-        return created;\n+    public String getBundleName() {\n+        return bundleName;\n     }\n \n-    public void setCreated(LocalDateTime created) {\n-        this.created = created;\n+    public void setBundleName(String bundleName) {\n+        this.bundleName = bundleName;\n     }\n \n-    public String getBundle() {\n-        return bundle;\n+    public String getApplicationName() {\n+        return applicationName;\n     }\n \n-    public void setBundle(String bundle) {\n-        this.bundle = bundle;\n+    public void setApplicationName(String applicationName) {\n+        this.applicationName = applicationName;\n     }\n \n-    public String getApplication() {\n-        return application;\n+    public JsonObject getPayload() {\n+        return payload;\n     }\n \n-    public void setApplication(String application) {\n-        this.application = application;\n+    public void setPayload(JsonObject payload) {\n+        this.payload = payload;\n     }\n \n-    public JsonObject getPayload() {\n-        return this.payload;\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof EmailAggregation) {\n+            EmailAggregation other = (EmailAggregation) o;\n+            return Objects.equals(id, other.id);\n+        }\n+        return false;\n     }\n \n-    public void setPayload(JsonObject payload) {\n-        this.payload = payload;\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n     }\n }"
  },
  {
    "sha": "5feaa6d7fdc57b249cb917f6fa82977caaa14b5e",
    "filename": "src/main/java/com/redhat/cloud/notifications/models/EmailAggregationKey.java",
    "status": "modified",
    "additions": 9,
    "deletions": 0,
    "changes": 9,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/EmailAggregationKey.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/EmailAggregationKey.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/models/EmailAggregationKey.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -13,6 +13,15 @@\n     @NotNull\n     private String application;\n \n+    public EmailAggregationKey() {\n+    }\n+\n+    public EmailAggregationKey(String accountId, String bundle, String application) {\n+        this.accountId = accountId;\n+        this.bundle = bundle;\n+        this.application = application;\n+    }\n+\n     public String getAccountId() {\n         return accountId;\n     }"
  },
  {
    "sha": "15e7b5b6a98e7d7938af5892896fd5699692c240",
    "filename": "src/main/java/com/redhat/cloud/notifications/models/EmailSubscription.java",
    "status": "modified",
    "additions": 40,
    "deletions": 53,
    "changes": 93,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/EmailSubscription.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/EmailSubscription.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/models/EmailSubscription.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -1,84 +1,71 @@\n package com.redhat.cloud.notifications.models;\n \n-import java.time.Duration;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import javax.persistence.Table;\n+import java.util.Objects;\n \n+@Entity\n+@Table(name = \"endpoint_email_subscriptions\")\n public class EmailSubscription {\n \n-    public enum EmailSubscriptionType {\n-        INSTANT(\"INSTANT\", null),\n-        DAILY(\"DAILY\", Duration.ofDays(1));\n-\n-        private String name;\n-        private Duration duration;\n-\n-        EmailSubscriptionType(String name, Duration duration) {\n-            this.name = name;\n-            this.duration = duration;\n-        }\n-\n-        public Duration getDuration() {\n-            return this.duration;\n-        }\n-\n-        public String toString() {\n-            return this.name;\n-        }\n-\n-        public static EmailSubscriptionType fromString(String value) {\n-            for (EmailSubscriptionType type : EmailSubscriptionType.values()) {\n-                if (type.toString().equals(value.toUpperCase())) {\n-                    return type;\n-                }\n-            }\n-\n-            throw new RuntimeException(\"Unknow EmailSubscriptionType \" + value);\n-        }\n-    }\n-\n-    private String accountId;\n-    private String username;\n-    private String bundle;\n-    private String application;\n-    private EmailSubscriptionType type;\n+    @EmbeddedId\n+    private EmailSubscriptionId id;\n \n     public String getAccountId() {\n-        return accountId;\n+        return id.accountId;\n     }\n \n     public void setAccountId(String accountId) {\n-        this.accountId = accountId;\n+        id.accountId = accountId;\n     }\n \n-    public String getUsername() {\n-        return username;\n+    public String getUserId() {\n+        return id.userId;\n     }\n \n-    public void setUsername(String username) {\n-        this.username = username;\n+    public void setUserId(String userId) {\n+        id.userId = userId;\n     }\n \n-    public String getBundle() {\n-        return bundle;\n+    public String getBundleName() {\n+        return id.bundleName;\n     }\n \n-    public void setBundle(String bundle) {\n-        this.bundle = bundle;\n+    public void setBundleName(String bundleName) {\n+        id.bundleName = bundleName;\n     }\n \n-    public String getApplication() {\n-        return application;\n+    public String getApplicationName() {\n+        return id.applicationName;\n     }\n \n-    public void setApplication(String application) {\n-        this.application = application;\n+    public void setApplicationName(String applicationName) {\n+        id.applicationName = applicationName;\n     }\n \n     public EmailSubscriptionType getType() {\n-        return type;\n+        return id.subscriptionType;\n     }\n \n     public void setType(EmailSubscriptionType type) {\n-        this.type = type;\n+        id.subscriptionType = type;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof EmailSubscription) {\n+            EmailSubscription other = (EmailSubscription) o;\n+            return Objects.equals(id, other.id);\n+        }\n+        return false;\n     }\n \n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id);\n+    }\n }"
  },
  {
    "sha": "eb47efb1030cd3e80d3d8e736fd67bd4c30f9025",
    "filename": "src/main/java/com/redhat/cloud/notifications/models/EmailSubscriptionId.java",
    "status": "added",
    "additions": 62,
    "deletions": 0,
    "changes": 62,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/EmailSubscriptionId.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/EmailSubscriptionId.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/models/EmailSubscriptionId.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -0,0 +1,62 @@\n+package com.redhat.cloud.notifications.models;\n+\n+import com.redhat.cloud.notifications.db.converters.EmailSubscriptionTypeConverter;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+import java.io.Serializable;\n+import java.util.Objects;\n+\n+@Embeddable\n+public class EmailSubscriptionId implements Serializable {\n+\n+    @Column(name = \"account_id\")\n+    @NotNull\n+    @Size(max = 50)\n+    public String accountId;\n+\n+    @Column(name = \"user_id\")\n+    @NotNull\n+    @Size(max = 50)\n+    public String userId;\n+\n+    @Column(name = \"bundle\")\n+    @NotNull\n+    @Size(max = 255)\n+    public String bundleName;\n+\n+    @Column(name = \"application\")\n+    @NotNull\n+    @Size(max = 255)\n+    public String applicationName;\n+\n+    @Column(name = \"subscription_type\")\n+    @NotNull\n+    @Size(max = 50)\n+    @Convert(converter = EmailSubscriptionTypeConverter.class)\n+    public EmailSubscriptionType subscriptionType;\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof EmailSubscriptionId) {\n+            EmailSubscriptionId other = (EmailSubscriptionId) o;\n+            return Objects.equals(accountId, other.accountId) &&\n+                    Objects.equals(userId, other.userId) &&\n+                    Objects.equals(subscriptionType, other.subscriptionType) &&\n+                    Objects.equals(bundleName, other.bundleName) &&\n+                    Objects.equals(applicationName, other.applicationName);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(accountId, userId, subscriptionType, applicationName, bundleName);\n+    }\n+}"
  },
  {
    "sha": "7fbca567944fe400c3f81f2410fed7033fb09bae",
    "filename": "src/main/java/com/redhat/cloud/notifications/models/EmailSubscriptionType.java",
    "status": "added",
    "additions": 22,
    "deletions": 0,
    "changes": 22,
    "blob_url": "https://github.com/gwenneg/notifications-backend/blob/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/EmailSubscriptionType.java",
    "raw_url": "https://github.com/gwenneg/notifications-backend/raw/a5385a0fdf0318bfd91eb652aafdf05d0f6ca131/src/main/java/com/redhat/cloud/notifications/models/EmailSubscriptionType.java",
    "contents_url": "https://api.github.com/repos/gwenneg/notifications-backend/contents/src/main/java/com/redhat/cloud/notifications/models/EmailSubscriptionType.java?ref=a5385a0fdf0318bfd91eb652aafdf05d0f6ca131",
    "patch": "@@ -0,0 +1,22 @@\n+package com.redhat.cloud.notifications.models;\n+\n+import java.time.Duration;\n+\n+public enum EmailSubscriptionType {\n+    INSTANT(null),\n+    DAILY(Duration.ofDays(1));\n+\n+    private Duration duration;\n+\n+    EmailSubscriptionType(Duration duration) {\n+        this.duration = duration;\n+    }\n+\n+    public Duration getDuration() {\n+        return this.duration;\n+    }\n+\n+    public static EmailSubscriptionType fromString(String value) {\n+        return EmailSubscriptionType.valueOf(value.toUpperCase());\n+    }\n+}"
  }
]
