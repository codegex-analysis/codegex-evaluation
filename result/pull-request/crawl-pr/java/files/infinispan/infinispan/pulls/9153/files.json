[
  {
    "sha": "345dfe5c06eec92e9633593600bcd1f2a130fb06",
    "filename": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/Compactor.java",
    "status": "modified",
    "additions": 1,
    "deletions": 3,
    "changes": 4,
    "blob_url": "https://github.com/infinispan/infinispan/blob/cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/Compactor.java",
    "raw_url": "https://github.com/infinispan/infinispan/raw/cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/Compactor.java",
    "contents_url": "https://api.github.com/repos/infinispan/infinispan/contents/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/Compactor.java?ref=cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff",
    "patch": "@@ -338,7 +338,6 @@ public void accept(Object o) throws Throwable {\n                   log.tracef(\"Update %d:%d -> %d:%d | %d,%d\", scheduledFile, indexedOffset,\n                         logFile.fileId, entryOffset, logFile.fileChannel.position(), logFile.fileChannel.size());\n                }\n-               // TODO: need to wait on th index request once we change over the index queues\n                // entryFile cannot be used as we have to report the file due to free space statistics\n                IndexRequest moveRequest = IndexRequest.moved(segment, key, serializedKey, logFile.fileId, entryOffset, writtenLength,\n                      scheduledFile, indexedOffset);\n@@ -359,8 +358,7 @@ public void accept(Object o) throws Throwable {\n       if (!terminateSignal && clearSignal.get() == 0) {\n          // The deletion must be executed only after the index is fully updated.\n          log.debugf(\"Finished compacting %d, scheduling delete\", scheduledFile);\n-         // TODO: why does index queue do this? This should be a single file, can the compactor not just delete it?\n-//         index.handleRequest(IndexRequest.deleteFileRequest(scheduledFile));\n+         index.deleteFileAsync(scheduledFile);\n       }\n    }\n "
  },
  {
    "sha": "368311566a2d872ea2a9220908d900fbcbd12100",
    "filename": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/FileProvider.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/infinispan/infinispan/blob/cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/FileProvider.java",
    "raw_url": "https://github.com/infinispan/infinispan/raw/cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/FileProvider.java",
    "contents_url": "https://api.github.com/repos/infinispan/infinispan/contents/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/FileProvider.java?ref=cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff",
    "patch": "@@ -156,7 +156,8 @@ private String fileIdToString(int fileId) {\n       return prefix + fileId;\n    }\n \n-   private File newFile(int fileId) {\n+   // Package private for tests\n+   File newFile(int fileId) {\n       return new File(dataDir, fileIdToString(fileId));\n    }\n "
  },
  {
    "sha": "e8484eb9f936bcc979604f38c4852d61291f598f",
    "filename": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/Index.java",
    "status": "modified",
    "additions": 30,
    "deletions": 12,
    "changes": 42,
    "blob_url": "https://github.com/infinispan/infinispan/blob/cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/Index.java",
    "raw_url": "https://github.com/infinispan/infinispan/raw/cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/Index.java",
    "contents_url": "https://api.github.com/repos/infinispan/infinispan/contents/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/Index.java?ref=cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff",
    "patch": "@@ -13,6 +13,7 @@\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CompletionStage;\n import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReadWriteLock;\n@@ -22,6 +23,7 @@\n import org.infinispan.commons.util.IntSet;\n import org.infinispan.util.concurrent.AggregateCompletionStage;\n import org.infinispan.util.concurrent.CompletionStages;\n+import org.infinispan.util.concurrent.NonBlockingManager;\n import org.infinispan.util.logging.LogFactory;\n \n import io.reactivex.rxjava3.core.Flowable;\n@@ -51,8 +53,9 @@\n    // 8 bytes number of elements\n    private static final int INDEX_FILE_HEADER_SIZE = 34;\n \n-   private final Path indexDir;\n+   private final NonBlockingManager nonBlockingManager;\n    private final FileProvider fileProvider;\n+   private final Path indexDir;\n    private final Compactor compactor;\n    private final int minNodeSize;\n    private final int maxNodeSize;\n@@ -62,8 +65,10 @@\n \n    private final FlowableProcessor<IndexRequest>[] flowableProcessors;\n \n-   public Index(FileProvider fileProvider, Path indexDir, int segments, int minNodeSize, int maxNodeSize,\n-                TemporaryTable temporaryTable, Compactor compactor, TimeService timeService) throws IOException {\n+   public Index(NonBlockingManager nonBlockingManager, FileProvider fileProvider, Path indexDir, int segments,\n+                int minNodeSize, int maxNodeSize, TemporaryTable temporaryTable, Compactor compactor,\n+                TimeService timeService) throws IOException {\n+      this.nonBlockingManager = nonBlockingManager;\n       this.fileProvider = fileProvider;\n       this.compactor = compactor;\n       this.timeService = timeService;\n@@ -154,6 +159,21 @@ public EntryInfo getInfo(Object key, byte[] serializedKey) throws IOException {\n       return indexRequest;\n    }\n \n+   public void deleteFileAsync(int fileId) {\n+      AtomicInteger count = new AtomicInteger(flowableProcessors.length);\n+      for (FlowableProcessor<IndexRequest> flowableProcessor : flowableProcessors) {\n+         IndexRequest deleteFile = IndexRequest.syncRequest(() -> {\n+            // After all indexes have ensured they have processed all requests - the last one will delete the file\n+            // This guarantees that the index can't see an outdated value\n+            if (count.decrementAndGet() == 0) {\n+               fileProvider.deleteFile(fileId);\n+               compactor.releaseStats(fileId);\n+            }\n+         });\n+         flowableProcessor.onNext(deleteFile);\n+      }\n+   }\n+\n    public CompletionStage<Void> stop() throws InterruptedException {\n       for (FlowableProcessor<IndexRequest> flowableProcessor : flowableProcessors) {\n          flowableProcessor.onComplete();\n@@ -286,14 +306,12 @@ public void accept(IndexRequest request) throws Throwable {\n                indexFileSize = INDEX_FILE_HEADER_SIZE;\n                freeBlocks.clear();\n                size.set(0);\n-               request.complete(null);\n+               nonBlockingManager.complete(request,null);\n                return;\n-            case DELETE_FILE:\n-               // the last segment that processes the delete request actually deletes the file\n-               if (request.countDown()) {\n-                  fileProvider.deleteFile(request.getFile());\n-                  compactor.releaseStats(request.getFile());\n-               }\n+            case SYNC_REQUEST:\n+               Runnable runnable = (Runnable) request.getKey();\n+               runnable.run();\n+               nonBlockingManager.complete(request, null);\n                return;\n             case MOVED:\n                recordChange = IndexNode.RecordChange.MOVE;\n@@ -335,7 +353,7 @@ public void setOverwritten(boolean overwritten, int prevFile, int prevOffset) {\n                overwriteHook = IndexNode.NOOP_HOOK;\n                break;\n             case SIZE:\n-               request.complete(size.get());\n+               nonBlockingManager.complete(request, size.get());\n                return;\n             default:\n                throw new IllegalArgumentException(request.toString());\n@@ -347,7 +365,7 @@ public void setOverwritten(boolean overwritten, int prevFile, int prevOffset) {\n             request.completeExceptionally(e);\n          }\n          temporaryTable.removeConditionally(request.getSegment(), request.getKey(), request.getFile(), request.getOffset());\n-         request.complete(null);\n+         nonBlockingManager.complete(request, null);\n       }\n \n       // This is ran when the flowable ends either via normal termination or error"
  },
  {
    "sha": "5af37216f41fba36c88156b299ddb640bb3127da",
    "filename": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/IndexRequest.java",
    "status": "modified",
    "additions": 9,
    "deletions": 10,
    "changes": 19,
    "blob_url": "https://github.com/infinispan/infinispan/blob/cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/IndexRequest.java",
    "raw_url": "https://github.com/infinispan/infinispan/raw/cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/IndexRequest.java",
    "contents_url": "https://api.github.com/repos/infinispan/infinispan/contents/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/IndexRequest.java?ref=cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff",
    "patch": "@@ -18,10 +18,7 @@\n       DROPPED,\n       FOUND_OLD,\n       CLEAR,\n-      // TODO: this can probably be removed and just let compactor delete the file - no reason for index to do that\n-      DELETE_FILE,\n-      // TODO: NEED TO REMOVE THIS\n-      STOP,\n+      SYNC_REQUEST,\n       SIZE\n    }\n \n@@ -70,12 +67,14 @@ public static IndexRequest clearRequest() {\n       return new IndexRequest(Type.CLEAR, -1, null, null, -1, -1, -1, -1, -1);\n    }\n \n-   public static IndexRequest deleteFileRequest(int deletedFile) {\n-      return new IndexRequest(Type.DELETE_FILE, -1, null, null, deletedFile, -1, -1, -1, -1);\n-   }\n-\n-   public static IndexRequest stopRequest() {\n-      return new IndexRequest(Type.STOP, -1,null, null, -1, -1, -1, -1, -1);\n+   /**\n+    * Allows for an index request that will be ran in the index thread. This can be useful to run something after all\n+    * pending index updates have been applied.\n+    * @param runnable what will be ran in the index thread after all pending index updates are applied first\n+    * @return the request\n+    */\n+   public static IndexRequest syncRequest(Runnable runnable) {\n+      return new IndexRequest(Type.SYNC_REQUEST, -1, runnable, null, -1, -1, -1, -1, -1);\n    }\n \n    public static IndexRequest sizeRequest() {"
  },
  {
    "sha": "8b38b9cfc1572e3a9e6dd8644e5f7b5afb826496",
    "filename": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/NonBlockingSoftIndexFileStore.java",
    "status": "modified",
    "additions": 6,
    "deletions": 1,
    "changes": 7,
    "blob_url": "https://github.com/infinispan/infinispan/blob/cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/NonBlockingSoftIndexFileStore.java",
    "raw_url": "https://github.com/infinispan/infinispan/raw/cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/NonBlockingSoftIndexFileStore.java",
    "contents_url": "https://api.github.com/repos/infinispan/infinispan/contents/persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/NonBlockingSoftIndexFileStore.java?ref=cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff",
    "patch": "@@ -192,7 +192,7 @@\n       compactor = new Compactor(fileProvider, temporaryTable, marshaller, timeService, keyPartitioner, configuration.maxFileSize(), configuration.compactionThreshold(),\n             blockingManager.asExecutor(\"compactor\"));\n       try {\n-         index = new Index(fileProvider, getIndexLocation(), configuration.indexSegments(),\n+         index = new Index(ctx.getNonBlockingManager(), fileProvider, getIndexLocation(), configuration.indexSegments(),\n                configuration.minNodeSize(), configuration.maxNodeSize(),\n                temporaryTable, compactor, timeService);\n       } catch (IOException e) {\n@@ -342,6 +342,11 @@ private void buildIndex(final AtomicLong maxSeqId) {\n       CompletionStages.join(stage);\n    }\n \n+   // Package protected for tests only\n+   FileProvider getFileProvider() {\n+      return fileProvider;\n+   }\n+\n    private Path getDataLocation() {\n       return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.dataLocation(), ctx.getCache().getName(), \"data\");\n    }"
  },
  {
    "sha": "623dac5400bfae8cb28701e4177433cb701e78ca",
    "filename": "persistence/soft-index/src/test/java/org/infinispan/persistence/sifs/SoftIndexFileStoreTest.java",
    "status": "modified",
    "additions": 47,
    "deletions": 0,
    "changes": 47,
    "blob_url": "https://github.com/infinispan/infinispan/blob/cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff/persistence/soft-index/src/test/java/org/infinispan/persistence/sifs/SoftIndexFileStoreTest.java",
    "raw_url": "https://github.com/infinispan/infinispan/raw/cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff/persistence/soft-index/src/test/java/org/infinispan/persistence/sifs/SoftIndexFileStoreTest.java",
    "contents_url": "https://api.github.com/repos/infinispan/infinispan/contents/persistence/soft-index/src/test/java/org/infinispan/persistence/sifs/SoftIndexFileStoreTest.java?ref=cc792b6e415bfa04a5d8ba4a97d6cfa6d38018ff",
    "patch": "@@ -1,13 +1,17 @@\n package org.infinispan.persistence.sifs;\n \n import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertFalse;\n import static org.testng.AssertJUnit.assertNotNull;\n import static org.testng.AssertJUnit.assertNull;\n import static org.testng.AssertJUnit.assertTrue;\n \n+import java.io.IOException;\n+import java.util.Iterator;\n import java.util.concurrent.CompletionStage;\n \n import org.infinispan.commons.test.CommonsTestingUtil;\n+import org.infinispan.commons.util.CloseableIterator;\n import org.infinispan.commons.util.IntSets;\n import org.infinispan.commons.util.Util;\n import org.infinispan.configuration.cache.Configuration;\n@@ -199,6 +203,49 @@ public void testStopStartWithLoadDoesNotNukeValues() throws InterruptedException\n       }\n    }\n \n+   private int countIterator(Iterator<?> iterator) {\n+      int count = 0;\n+      while (iterator.hasNext()) {\n+         iterator.next();\n+         count++;\n+      }\n+      return count;\n+   }\n+\n+   public void testCompactorRemovesOldFile() throws IOException {\n+      // Make sure no additional logs around\n+      store.clear();\n+      NonBlockingSoftIndexFileStore<Object, Object> actualStore = (NonBlockingSoftIndexFileStore<Object, Object>) store.delegate();\n+\n+      FileProvider fileProvider = actualStore.getFileProvider();\n+\n+      // we need to write an entry for it to create a file\n+      int maxWritten = 1;\n+      InternalCacheEntry ice = TestInternalCacheEntryFactory.create(key(maxWritten), \"value\" + maxWritten);\n+      store.write(MarshalledEntryUtil.create(ice, getMarshaller()));\n+\n+      int onlyFileId;\n+      try (CloseableIterator<Integer> iter = fileProvider.getFileIterator()) {\n+         assertTrue(iter.hasNext());\n+         onlyFileId = iter.next();\n+         assertFalse(iter.hasNext());\n+      }\n+      // Keep writing until the current file fills up and we create a new one\n+      while (countIterator(fileProvider.getFileIterator()) == 1) {\n+         int i = ++maxWritten;\n+         ice = TestInternalCacheEntryFactory.create(key(i), \"value\" + i);\n+         store.write(MarshalledEntryUtil.create(ice, getMarshaller()));\n+      }\n+\n+      // Now we write over all the previous values, which should force the compactor to eventually remove the file\n+      for (int i = 0; i < maxWritten; ++i) {\n+         ice = TestInternalCacheEntryFactory.create(key(i), \"value\" + i + \"-second\");\n+         store.write(MarshalledEntryUtil.create(ice, getMarshaller()));\n+      }\n+\n+      eventuallyEquals(Boolean.FALSE, () -> fileProvider.newFile(onlyFileId).exists());\n+   }\n+\n    private void writeGibberish() {\n       for (int i = 0; i < 100; ++i) {\n          store.write(marshalledEntry(internalCacheEntry(\"foo\", \"bar\", -1)));"
  }
]
