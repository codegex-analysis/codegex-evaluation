[
  {
    "sha": "9ec535a9e301c02e0e166e2c0fbca8ebb50eb317",
    "filename": "dart-lang/src/main/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/AnalyzerMode.java",
    "status": "added",
    "additions": 26,
    "deletions": 0,
    "changes": 26,
    "blob_url": "https://github.com/insideapp-oss/sonar-flutter/blob/1646f23ce696a1b215d7d76d0e724ccc1d6990bb/dart-lang/src/main/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/AnalyzerMode.java",
    "raw_url": "https://github.com/insideapp-oss/sonar-flutter/raw/1646f23ce696a1b215d7d76d0e724ccc1d6990bb/dart-lang/src/main/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/AnalyzerMode.java",
    "contents_url": "https://api.github.com/repos/insideapp-oss/sonar-flutter/contents/dart-lang/src/main/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/AnalyzerMode.java?ref=1646f23ce696a1b215d7d76d0e724ccc1d6990bb",
    "patch": "@@ -0,0 +1,26 @@\n+/*\n+ * SonarQube Flutter Plugin\n+ * Copyright (C) 2020 inside|app\n+ * contact@insideapp.fr\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+\n+package fr.insideapp.sonarqube.dart.lang.issues.dartanalyzer;\n+\n+public enum AnalyzerMode {\n+    legacy,\n+    flutter,\n+}"
  },
  {
    "sha": "176ee4ae76af4827891b5e931bb056c95bb39c9a",
    "filename": "dart-lang/src/main/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/DartAnalyzerReportParser.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/insideapp-oss/sonar-flutter/blob/1646f23ce696a1b215d7d76d0e724ccc1d6990bb/dart-lang/src/main/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/DartAnalyzerReportParser.java",
    "raw_url": "https://github.com/insideapp-oss/sonar-flutter/raw/1646f23ce696a1b215d7d76d0e724ccc1d6990bb/dart-lang/src/main/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/DartAnalyzerReportParser.java",
    "contents_url": "https://api.github.com/repos/insideapp-oss/sonar-flutter/contents/dart-lang/src/main/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/DartAnalyzerReportParser.java?ref=1646f23ce696a1b215d7d76d0e724ccc1d6990bb",
    "patch": "@@ -31,7 +31,7 @@\n         List<DartAnalyzerReportIssue> issues = new ArrayList<>();\n \n         String[] lines = input.split(System.getProperty(\"line.separator\"));\n-        Pattern pattern = Pattern.compile(\"(error|hint|lint)(.*)(-|•)(.*)(-|•)(.*):(.*):(.*)(-|•)(.*)\");\n+        Pattern pattern = Pattern.compile(\"(hint|lint|info|warning|error)(.*)(-|•)(.*)(-|•)(.*):(.*):(.*)(-|•)(.*)\");\n         for (int i = 0; i < lines.length; i++) {\n             Matcher matcher = pattern.matcher(lines[i]);\n             while (matcher.find()) {"
  },
  {
    "sha": "b0c1680c64ab363a81d995ac5e6f42f9bc2be339",
    "filename": "dart-lang/src/main/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/DartAnalyzerSensor.java",
    "status": "modified",
    "additions": 286,
    "deletions": 236,
    "changes": 522,
    "blob_url": "https://github.com/insideapp-oss/sonar-flutter/blob/1646f23ce696a1b215d7d76d0e724ccc1d6990bb/dart-lang/src/main/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/DartAnalyzerSensor.java",
    "raw_url": "https://github.com/insideapp-oss/sonar-flutter/raw/1646f23ce696a1b215d7d76d0e724ccc1d6990bb/dart-lang/src/main/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/DartAnalyzerSensor.java",
    "contents_url": "https://api.github.com/repos/insideapp-oss/sonar-flutter/contents/dart-lang/src/main/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/DartAnalyzerSensor.java?ref=1646f23ce696a1b215d7d76d0e724ccc1d6990bb",
    "patch": "@@ -46,243 +46,293 @@\n import java.util.Set;\n import java.util.stream.Collectors;\n \n+import static java.util.Arrays.asList;\n+\n+\n public class DartAnalyzerSensor implements Sensor {\n-\tprivate static final Logger LOGGER = LoggerFactory.getLogger(DartAnalyzerSensor.class);\n-\tprivate static final String ANALYZER_COMMAND = System.getProperty(\"os.name\").toUpperCase().contains(\"WINDOWS\")\n-\t\t\t? \"dartanalyzer.bat\"\n-\t\t\t: \"dartanalyzer\";\n-\tprivate static final int ANALYZER_TIMEOUT = 10 * 60 * 1000;\n-\tprivate static final String ANALYSIS_OPTIONS_FILENAME = \"analysis_options.yaml\";\n-\tprivate static final String ANALYSIS_OPTIONS_FILE = \"/fr/insideapp/sonarqube/dart/dartanalyzer/analysis_options.yaml\";\n-\tprivate static final Integer PAGE_SIZE = 50;\n-\tprivate boolean useExistingAnalysisOptions;\n-\t\n-\t@Override\n-\tpublic void describe(SensorDescriptor sensorDescriptor) {\n-\t\tsensorDescriptor.onlyOnLanguage(Dart.KEY).name(\"dartanalyzer sensor\").onlyOnFileType(Type.MAIN);\n-\t}\n-\n-\t@Override\n-\tpublic void execute(SensorContext sensorContext) {\n-\t\ttry {\n-\t\t\tverifyIfDartAnalyzerExists();\n-\t\t\t\n-\t\t\tselectOptionFileToUse(sensorContext);\n-\n-\t\t\trecordIssues(sensorContext, buildIssues(getFilesWithAbsolutePath(sensorContext)));\n-\n-\t\t} catch (Exception e) {\n-\t\t\tLOGGER.error(e.getMessage(), e);\n-\t\t} finally {\n-\t\t\tif (!useExistingAnalysisOptions) {\n-\t\t\t\trestoreCurrentAnalysisOptionsFile(sensorContext);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void selectOptionFileToUse(SensorContext sensorContext) throws IOException {\n-\t\tuseExistingAnalysisOptions = getUseExistingAnalysisOptions(sensorContext);\n-\n-\t\t// Usage of existing option is required but file is missing\n-\t\t// Or usage of existing option is not required\n-\t\tif ((useExistingAnalysisOptions && !this.existsAnalysisOptionsFile(sensorContext)) || !useExistingAnalysisOptions) {\n-\t\t\tuseDefaultAnalysisOptionsFile(sensorContext);\n-\t\t}\n-\t}\n-\n-\tprivate void useDefaultAnalysisOptionsFile(SensorContext sensorContext) throws IOException {\n-\t\tLOGGER.debug(\"Either {} option is not set to true or {} file does not exists, use default analysis options instead\",\n-\t\t\t\tDartSensor.DART_ANALYSIS_USE_EXISTING_OPTIONS_KEY, ANALYSIS_OPTIONS_FILENAME);\n-\n-\t\tuseExistingAnalysisOptions = false;\n-\n-\t\tthis.saveCurrentAnalysisOptionsFile(sensorContext);\n-\t\tthis.createAnalysisOptionsFile(sensorContext);\n-\t}\n-\n-\tprivate Boolean getUseExistingAnalysisOptions(SensorContext sensorContext) {\n-\t\treturn sensorContext.config().getBoolean(DartSensor.DART_ANALYSIS_USE_EXISTING_OPTIONS_KEY).orElse(false);\n-\t}\n-\n-\tprivate List<DartAnalyzerReportIssue> buildIssues(List<String> filesWithAbsolutePath)\n-\t\t\tthrows IOException {\n-\t\tSet<DartAnalyzerReportIssue> issues = new HashSet<>();\n-\n-\t\tfor (String paginatedFileBatch : getPaginatedFilesPaths(filesWithAbsolutePath)) {\n-\n-\t\t\tLOGGER.debug(\"Current file batch: {}\", paginatedFileBatch);\n-\n-\t\t\ttry {\n-\t\t\t\tString output = new ProcBuilder(ANALYZER_COMMAND)\n-\t\t\t\t\t\t.withArgs(paginatedFileBatch.split(\" \"))\n-\t\t\t\t\t\t.withTimeoutMillis(ANALYZER_TIMEOUT)\n-\t\t\t\t\t\t//.withExpectedExitStatuses(0, 1, 2, 3)\n-\t\t\t\t\t\t.ignoreExitStatus()\n-\t\t\t\t\t\t.run()\n-\t\t\t\t\t\t.getOutputString();\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DartAnalyzerSensor.class);\n+    private static final String ANALYZER_DART_COMMAND = System.getProperty(\"os.name\").toUpperCase().contains(\"WINDOWS\")\n+            ? \"dartanalyzer.bat\"\n+            : \"dartanalyzer\";\n+    private static final String ANALYZER_FLUTTER_COMMAND = System.getProperty(\"os.name\").toUpperCase().contains(\"WINDOWS\")\n+            ? \"flutter.bat\"\n+            : \"flutter\";\n+    private static final int ANALYZER_TIMEOUT = 10 * 60 * 1000;\n+    private static final String ANALYSIS_OPTIONS_FILENAME = \"analysis_options.yaml\";\n+    private static final String ANALYSIS_OPTIONS_FILE = \"/fr/insideapp/sonarqube/dart/dartanalyzer/analysis_options.yaml\";\n+    private static final Integer PAGE_SIZE = 50;\n+    private boolean useExistingAnalysisOptions;\n+    public static final String FLUTTER_ANALYZER_MODE = \"sonar.flutter.analyzer.mode\";\n+    public static final List<AnalyzerMode> FLUTTER_ANALYZER_MODE_OPTIONS = asList(AnalyzerMode.values());\n+\n+    @Override\n+    public void describe(SensorDescriptor sensorDescriptor) {\n+        sensorDescriptor.onlyOnLanguage(Dart.KEY).name(\"dartanalyzer sensor\").onlyOnFileType(Type.MAIN);\n+    }\n+\n+    @Override\n+    public void execute(SensorContext sensorContext) {\n+\n+        AnalyzerMode analyzerMode = getAnalyzerMode(sensorContext);\n+        LOGGER.info(\"Chosen analyzer mode: {}\", analyzerMode);\n+\n+        switch (analyzerMode) {\n+            case legacy:\n+                try {\n+\n+                    verifyIfDartAnalyzerExists();\n+\n+                    selectOptionFileToUse(sensorContext);\n+\n+                    recordIssues(sensorContext, buildIssues(getFilesWithAbsolutePath(sensorContext)));\n+\n+                } catch (Exception e) {\n+                    LOGGER.error(e.getMessage(), e);\n+                } finally {\n+                    if (!useExistingAnalysisOptions) {\n+                        restoreCurrentAnalysisOptionsFile(sensorContext);\n+                    }\n+                }\n+                break;\n+\n+            case flutter:\n+                try {\n+                    final List<DartAnalyzerReportIssue> issues = getIssuesFromFlutterAnalyze();\n+                    recordIssues(sensorContext, issues);\n+                } catch (Exception e) {\n+                    LOGGER.error(e.getMessage(), e);\n+                }\n+                break;\n+        }\n+    }\n+\n+    private List<DartAnalyzerReportIssue> getIssuesFromFlutterAnalyze() throws IOException {\n+        try {\n+            LOGGER.info(\"Running 'flutter analyze'...\");\n+            String output = new ProcBuilder(ANALYZER_FLUTTER_COMMAND, \"analyze\")\n+                    .withTimeoutMillis(ANALYZER_TIMEOUT)\n+                    .ignoreExitStatus()\n+                    .run()\n+                    .getOutputString();\n+\n+            List<DartAnalyzerReportIssue> issues = new DartAnalyzerReportParser().parse(output);\n+            LOGGER.info(\"Found issues: {}\", issues.size());\n+            return issues;\n+        } catch (Exception e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    private void selectOptionFileToUse(SensorContext sensorContext) throws IOException {\n+        useExistingAnalysisOptions = getUseExistingAnalysisOptions(sensorContext);\n+\n+        // Usage of existing option is required but file is missing\n+        // Or usage of existing option is not required\n+        if ((useExistingAnalysisOptions && !this.existsAnalysisOptionsFile(sensorContext)) || !useExistingAnalysisOptions) {\n+            useDefaultAnalysisOptionsFile(sensorContext);\n+        }\n+    }\n+\n+    private void useDefaultAnalysisOptionsFile(SensorContext sensorContext) throws IOException {\n+        LOGGER.debug(\"Either {} option is not set to true or {} file does not exists, use default analysis options instead\",\n+                DartSensor.DART_ANALYSIS_USE_EXISTING_OPTIONS_KEY, ANALYSIS_OPTIONS_FILENAME);\n+\n+        useExistingAnalysisOptions = false;\n+\n+        this.saveCurrentAnalysisOptionsFile(sensorContext);\n+        this.createAnalysisOptionsFile(sensorContext);\n+    }\n+\n+    private AnalyzerMode getAnalyzerMode(SensorContext sensorContext) {\n+        return sensorContext.config()\n+                .get(FLUTTER_ANALYZER_MODE)\n+                .map(AnalyzerMode::valueOf)\n+                .orElse(AnalyzerMode.legacy);\n+    }\n+\n+    private Boolean getUseExistingAnalysisOptions(SensorContext sensorContext) {\n+        return sensorContext.config().getBoolean(DartSensor.DART_ANALYSIS_USE_EXISTING_OPTIONS_KEY).orElse(false);\n+    }\n+\n+    private List<DartAnalyzerReportIssue> buildIssues(List<String> filesWithAbsolutePath)\n+            throws IOException {\n+        Set<DartAnalyzerReportIssue> issues = new HashSet<>();\n+\n+        for (String paginatedFileBatch : getPaginatedFilesPaths(filesWithAbsolutePath)) {\n+\n+            LOGGER.debug(\"Current file batch: {}\", paginatedFileBatch);\n+\n+            try {\n+                String output = new ProcBuilder(ANALYZER_DART_COMMAND)\n+                        .withArgs(paginatedFileBatch.split(\" \"))\n+                        .withTimeoutMillis(ANALYZER_TIMEOUT)\n+                        //.withExpectedExitStatuses(0, 1, 2, 3)\n+                        .ignoreExitStatus()\n+                        .run()\n+                        .getOutputString();\n \n-\t\t\t\tissues.addAll(new DartAnalyzerReportParser().parse(output));\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tthrow new IOException(e);\n-\t\t\t}\n+                issues.addAll(new DartAnalyzerReportParser().parse(output));\n+            } catch (Exception e) {\n+                throw new IOException(e);\n+            }\n \n-\n-\t\t}\n-\t\tLOGGER.debug(\"Found issues: {}\", issues.size());\n-\t\tList<DartAnalyzerReportIssue> result = new ArrayList<>();\n-\t\tresult.addAll(issues);\n-\t\treturn result;\n-\t}\n-\n-\tprivate List<String> getPaginatedFilesPaths(List<String> filesWithAbsolutePath) {\n-\t\tList<String> paginated = new ArrayList<String>();\n-\n-\t\tLOGGER.debug(\"Paging the files to execute the analyzer...\");\n-\n-\t\tInteger pagingStart = 0;\n-\t\tInteger pagingRemainder = getPaginationRemainder(filesWithAbsolutePath);\n-\t\tInteger totalPages = getPaginationTotalPages(filesWithAbsolutePath, PAGE_SIZE, pagingRemainder);\n-\n-\t\tfor (int i = 0; i < totalPages; i++) {\n-\t\t\tLOGGER.debug(\"Current index: {}\", i);\n-\n-\t\t\tLOGGER.debug(\"Current paging start: {}\", pagingStart);\n-\n-\t\t\tInteger pagingEnd = getPagingEnd(pagingStart, pagingRemainder, totalPages, i);\n-\n-\t\t\tpaginated.add(getFilesPathsSplitBySpace(filesWithAbsolutePath, pagingStart, pagingEnd));\n-\n-\t\t\tpagingStart += PAGE_SIZE;\n-\t\t}\n-\t\treturn paginated;\n-\t}\n-\n-\tprivate Integer getPagingEnd(Integer pagingStart, Integer pagingRemainder, Integer totalPages, int i) {\n-\t\tInteger pagingEnd = pagingStart + PAGE_SIZE;\n-\t\tif (isLastPage(pagingRemainder, totalPages, i)) {\n-\t\t\tpagingEnd = pagingStart + pagingRemainder;\n-\t\t}\n-\t\tLOGGER.debug(\"Current paging end: {}\", pagingEnd);\n-\t\treturn pagingEnd;\n-\t}\n-\n-\tprivate String getFilesPathsSplitBySpace(List<String> filesWithAbsolutePath, Integer pagingStart,\n-\t\t\tInteger pagingEnd) {\n-\t\treturn filesWithAbsolutePath.subList(pagingStart, pagingEnd).stream().collect(Collectors.joining(\" \"));\n-\t}\n-\n-\tprivate boolean isLastPage(Integer pagingRemainder, Integer totalPages, int i) {\n-\t\treturn pagingRemainder != 0 && i + 1 == totalPages;\n-\t}\n-\n-\tprivate Integer getPaginationRemainder(List<String> filesWithAbsolutePath) {\n-\t\tInteger remainder = filesWithAbsolutePath.size() % PAGE_SIZE;\n-\n-\t\tLOGGER.debug(\"Paging remainder: {}\", remainder);\n-\n-\t\treturn remainder;\n-\t}\n-\n-\tprivate Integer getPaginationTotalPages(List<String> filesWithAbsolutePath, final Integer PAGE_SIZE,\n-\t\t\tInteger remainder) {\n-\t\tInteger total = filesWithAbsolutePath.size() / PAGE_SIZE;\n-\n-\t\tif (remainder != 0) {\n-\t\t\ttotal++;\n-\t\t}\n-\t\tLOGGER.debug(\"Paging total items: {}\", total);\n-\t\treturn total;\n-\t}\n-\n-\tprivate List<String> getFilesWithAbsolutePath(SensorContext sensorContext) {\n-\t\tList<String> filesWithAbsolutePath = new ArrayList<>();\n-\n-\t\tFileSystem fileSystem = getFileSystem(sensorContext);\n-\n-\t\tFilePredicate mainFilePredicate = getFilesFilter(fileSystem);\n-\n-\t\tString absolutePath = fileSystem.baseDir().getAbsolutePath();\n-\n-\t\tLOGGER.debug(\"Files absolute path: {}\", absolutePath);\n-\n-\t\tfileSystem.inputFiles(mainFilePredicate).forEach(s -> {\n-\t\t\tLOGGER.debug(\"Input file path: {}\", s.toString());\n-\n-\t\t\tString fullPath = new StringBuilder(absolutePath).append(File.separator).append(s.toString().replace(\"/\", File.separator))\n-\t\t\t\t\t.toString();\n-\n-\t\t\tLOGGER.debug(\"Current file full path: {}\", fullPath);\n-\n-\t\t\tfilesWithAbsolutePath.add(fullPath);\n-\t\t});\n-\n-\t\treturn filesWithAbsolutePath;\n-\t}\n-\n-\tprivate FilePredicate getFilesFilter(FileSystem fileSystem) {\n-\t\tFilePredicate mainFilePredicate = fileSystem.predicates().and(\n-\t\t\t\tfileSystem.predicates().hasType(InputFile.Type.MAIN), fileSystem.predicates().hasLanguage(Dart.KEY));\n-\t\treturn mainFilePredicate;\n-\t}\n-\n-\tprivate FileSystem getFileSystem(SensorContext sensorContext) {\n-\t\tFileSystem fileSystem = sensorContext.fileSystem();\n-\t\treturn fileSystem;\n-\t}\n-\n-\tprivate void recordIssues(SensorContext sensorContext, List<DartAnalyzerReportIssue> issues) {\n-\t\t// Record issues\n-\t\tissues.forEach(i -> {\n-\t\t\tFile file = new File(sensorContext.fileSystem().baseDir(), i.getFilePath());\n-\t\t\tLOGGER.debug(\"Inside issue forEach, file absolute path: {}\", file.getAbsolutePath());\n-\n-\t\t\tFilePredicate fp = sensorContext.fileSystem().predicates().hasAbsolutePath(file.getAbsolutePath());\n-\t\t\tif (!sensorContext.fileSystem().hasFiles(fp)) {\n-\t\t\t\tLOGGER.warn(\"File not included in SonarQube {}\", file.getAbsoluteFile());\n-\t\t\t} else {\n-\t\t\t\tInputFile inputFile = sensorContext.fileSystem().inputFile(fp);\n-\t\t\t\tNewIssueLocation nil = new DefaultIssueLocation().on(inputFile)\n-\t\t\t\t\t\t.at(inputFile.selectLine(i.getLineNumber())).message(i.getMessage());\n-\t\t\t\tsensorContext.newIssue().forRule(RuleKey.of(DartAnalyzerRulesDefinition.REPOSITORY_KEY, i.getRuleId()))\n-\t\t\t\t\t\t.at(nil).save();\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\tprivate void verifyIfDartAnalyzerExists() {\n-\t\tLOGGER.debug(\"Verify dart analyser...\");\n-\t\tnew ProcBuilder(ANALYZER_COMMAND).withArg(\"-h\").run();\n-\t\tLOGGER.debug(\"Verify dart analyser done\");\n-\t}\n-\n-\tprivate boolean existsAnalysisOptionsFile(SensorContext sensorContext) {\n-\t\treturn new File(sensorContext.fileSystem().baseDir(), ANALYSIS_OPTIONS_FILENAME).exists();\n-\t}\n-\n-\tprivate void saveCurrentAnalysisOptionsFile(SensorContext sensorContext) {\n-\t\tFile analysisOptionsFile = new File(sensorContext.fileSystem().baseDir(), ANALYSIS_OPTIONS_FILENAME);\n-\t\tif (analysisOptionsFile.exists()) {\n-\t\t\tanalysisOptionsFile\n-\t\t\t\t\t.renameTo(new File(sensorContext.fileSystem().baseDir(), ANALYSIS_OPTIONS_FILENAME + \".sonar\"));\n-\t\t\tLOGGER.info(\"Backup of original analysis_options.yaml file to {}\", ANALYSIS_OPTIONS_FILENAME + \".sonar\");\n-\t\t}\n-\t}\n-\n-\tprivate void createAnalysisOptionsFile(SensorContext sensorContext) throws IOException {\n-\t\tFile analysisOptionsFile = new File(sensorContext.fileSystem().baseDir(), ANALYSIS_OPTIONS_FILENAME);\n-\t\tURL inputUrl = getClass().getResource(ANALYSIS_OPTIONS_FILE);\n-\t\tResources.asByteSource(inputUrl).copyTo(Files.asByteSink(analysisOptionsFile));\n-\t}\n-\n-\tprivate void restoreCurrentAnalysisOptionsFile(SensorContext sensorContext) {\n-\t\tFile analysisOptionsFile = new File(sensorContext.fileSystem().baseDir(), ANALYSIS_OPTIONS_FILENAME);\n-\t\tFile currentAnalysisOptionsFile = new File(sensorContext.fileSystem().baseDir(),\n-\t\t\t\tANALYSIS_OPTIONS_FILENAME + \".sonar\");\n-\t\tif (currentAnalysisOptionsFile.exists()) {\n-\t\t\tcurrentAnalysisOptionsFile.renameTo(analysisOptionsFile);\n-\t\t\tLOGGER.info(\"Restored original analysis_options.yaml file\");\n-\t\t} else {\n-\t\t\tanalysisOptionsFile.delete();\n-\t\t}\n-\t}\n+\n+        }\n+        LOGGER.debug(\"Found issues: {}\", issues.size());\n+        List<DartAnalyzerReportIssue> result = new ArrayList<>();\n+        result.addAll(issues);\n+        return result;\n+    }\n+\n+    private List<String> getPaginatedFilesPaths(List<String> filesWithAbsolutePath) {\n+        List<String> paginated = new ArrayList<String>();\n+\n+        LOGGER.debug(\"Paging the files to execute the analyzer...\");\n+\n+        Integer pagingStart = 0;\n+        Integer pagingRemainder = getPaginationRemainder(filesWithAbsolutePath);\n+        Integer totalPages = getPaginationTotalPages(filesWithAbsolutePath, PAGE_SIZE, pagingRemainder);\n+\n+        for (int i = 0; i < totalPages; i++) {\n+            LOGGER.debug(\"Current index: {}\", i);\n+\n+            LOGGER.debug(\"Current paging start: {}\", pagingStart);\n+\n+            Integer pagingEnd = getPagingEnd(pagingStart, pagingRemainder, totalPages, i);\n+\n+            paginated.add(getFilesPathsSplitBySpace(filesWithAbsolutePath, pagingStart, pagingEnd));\n+\n+            pagingStart += PAGE_SIZE;\n+        }\n+        return paginated;\n+    }\n+\n+    private Integer getPagingEnd(Integer pagingStart, Integer pagingRemainder, Integer totalPages, int i) {\n+        Integer pagingEnd = pagingStart + PAGE_SIZE;\n+        if (isLastPage(pagingRemainder, totalPages, i)) {\n+            pagingEnd = pagingStart + pagingRemainder;\n+        }\n+        LOGGER.debug(\"Current paging end: {}\", pagingEnd);\n+        return pagingEnd;\n+    }\n+\n+    private String getFilesPathsSplitBySpace(List<String> filesWithAbsolutePath, Integer pagingStart,\n+                                             Integer pagingEnd) {\n+        return filesWithAbsolutePath.subList(pagingStart, pagingEnd).stream().collect(Collectors.joining(\" \"));\n+    }\n+\n+    private boolean isLastPage(Integer pagingRemainder, Integer totalPages, int i) {\n+        return pagingRemainder != 0 && i + 1 == totalPages;\n+    }\n+\n+    private Integer getPaginationRemainder(List<String> filesWithAbsolutePath) {\n+        Integer remainder = filesWithAbsolutePath.size() % PAGE_SIZE;\n+\n+        LOGGER.debug(\"Paging remainder: {}\", remainder);\n+\n+        return remainder;\n+    }\n+\n+    private Integer getPaginationTotalPages(List<String> filesWithAbsolutePath, final Integer PAGE_SIZE,\n+                                            Integer remainder) {\n+        Integer total = filesWithAbsolutePath.size() / PAGE_SIZE;\n+\n+        if (remainder != 0) {\n+            total++;\n+        }\n+        LOGGER.debug(\"Paging total items: {}\", total);\n+        return total;\n+    }\n+\n+    private List<String> getFilesWithAbsolutePath(SensorContext sensorContext) {\n+        List<String> filesWithAbsolutePath = new ArrayList<>();\n+\n+        FileSystem fileSystem = getFileSystem(sensorContext);\n+\n+        FilePredicate mainFilePredicate = getFilesFilter(fileSystem);\n+\n+        String absolutePath = fileSystem.baseDir().getAbsolutePath();\n+\n+        LOGGER.debug(\"Files absolute path: {}\", absolutePath);\n+\n+        fileSystem.inputFiles(mainFilePredicate).forEach(s -> {\n+            LOGGER.debug(\"Input file path: {}\", s.toString());\n+\n+            String fullPath = new StringBuilder(absolutePath).append(File.separator).append(s.toString().replace(\"/\", File.separator))\n+                    .toString();\n+\n+            LOGGER.debug(\"Current file full path: {}\", fullPath);\n+\n+            filesWithAbsolutePath.add(fullPath);\n+        });\n+\n+        return filesWithAbsolutePath;\n+    }\n+\n+    private FilePredicate getFilesFilter(FileSystem fileSystem) {\n+        FilePredicate mainFilePredicate = fileSystem.predicates().and(\n+                fileSystem.predicates().hasType(InputFile.Type.MAIN), fileSystem.predicates().hasLanguage(Dart.KEY));\n+        return mainFilePredicate;\n+    }\n+\n+    private FileSystem getFileSystem(SensorContext sensorContext) {\n+        FileSystem fileSystem = sensorContext.fileSystem();\n+        return fileSystem;\n+    }\n+\n+    private void recordIssues(SensorContext sensorContext, List<DartAnalyzerReportIssue> issues) {\n+        // Record issues\n+        issues.forEach(i -> {\n+            File file = new File(sensorContext.fileSystem().baseDir(), i.getFilePath());\n+            LOGGER.debug(\"Inside issue forEach, file absolute path: {}\", file.getAbsolutePath());\n+\n+            FilePredicate fp = sensorContext.fileSystem().predicates().hasAbsolutePath(file.getAbsolutePath());\n+            if (!sensorContext.fileSystem().hasFiles(fp)) {\n+                LOGGER.warn(\"File not included in SonarQube {}\", file.getAbsoluteFile());\n+            } else {\n+                InputFile inputFile = sensorContext.fileSystem().inputFile(fp);\n+                NewIssueLocation nil = new DefaultIssueLocation().on(inputFile)\n+                        .at(inputFile.selectLine(i.getLineNumber())).message(i.getMessage());\n+                sensorContext.newIssue().forRule(RuleKey.of(DartAnalyzerRulesDefinition.REPOSITORY_KEY, i.getRuleId()))\n+                        .at(nil).save();\n+            }\n+        });\n+    }\n+\n+    private void verifyIfDartAnalyzerExists() {\n+        LOGGER.debug(\"Verify dart analyser...\");\n+        new ProcBuilder(ANALYZER_DART_COMMAND).withArg(\"-h\").run();\n+        LOGGER.debug(\"Verify dart analyser done\");\n+    }\n+\n+    private boolean existsAnalysisOptionsFile(SensorContext sensorContext) {\n+        return new File(sensorContext.fileSystem().baseDir(), ANALYSIS_OPTIONS_FILENAME).exists();\n+    }\n+\n+    private void saveCurrentAnalysisOptionsFile(SensorContext sensorContext) {\n+        File analysisOptionsFile = new File(sensorContext.fileSystem().baseDir(), ANALYSIS_OPTIONS_FILENAME);\n+        if (analysisOptionsFile.exists()) {\n+            analysisOptionsFile\n+                    .renameTo(new File(sensorContext.fileSystem().baseDir(), ANALYSIS_OPTIONS_FILENAME + \".sonar\"));\n+            LOGGER.info(\"Backup of original analysis_options.yaml file to {}\", ANALYSIS_OPTIONS_FILENAME + \".sonar\");\n+        }\n+    }\n+\n+    private void createAnalysisOptionsFile(SensorContext sensorContext) throws IOException {\n+        File analysisOptionsFile = new File(sensorContext.fileSystem().baseDir(), ANALYSIS_OPTIONS_FILENAME);\n+        URL inputUrl = getClass().getResource(ANALYSIS_OPTIONS_FILE);\n+        Resources.asByteSource(inputUrl).copyTo(Files.asByteSink(analysisOptionsFile));\n+    }\n+\n+    private void restoreCurrentAnalysisOptionsFile(SensorContext sensorContext) {\n+        File analysisOptionsFile = new File(sensorContext.fileSystem().baseDir(), ANALYSIS_OPTIONS_FILENAME);\n+        File currentAnalysisOptionsFile = new File(sensorContext.fileSystem().baseDir(),\n+                ANALYSIS_OPTIONS_FILENAME + \".sonar\");\n+        if (currentAnalysisOptionsFile.exists()) {\n+            currentAnalysisOptionsFile.renameTo(analysisOptionsFile);\n+            LOGGER.info(\"Restored original analysis_options.yaml file\");\n+        } else {\n+            analysisOptionsFile.delete();\n+        }\n+    }\n }"
  },
  {
    "sha": "4c8eb091326fb7e56a1fe6c7d8597db517008a3c",
    "filename": "dart-lang/src/test/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/DartAnalyzerReportParserTest.java",
    "status": "modified",
    "additions": 20,
    "deletions": 3,
    "changes": 23,
    "blob_url": "https://github.com/insideapp-oss/sonar-flutter/blob/1646f23ce696a1b215d7d76d0e724ccc1d6990bb/dart-lang/src/test/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/DartAnalyzerReportParserTest.java",
    "raw_url": "https://github.com/insideapp-oss/sonar-flutter/raw/1646f23ce696a1b215d7d76d0e724ccc1d6990bb/dart-lang/src/test/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/DartAnalyzerReportParserTest.java",
    "contents_url": "https://api.github.com/repos/insideapp-oss/sonar-flutter/contents/dart-lang/src/test/java/fr/insideapp/sonarqube/dart/lang/issues/dartanalyzer/DartAnalyzerReportParserTest.java?ref=1646f23ce696a1b215d7d76d0e724ccc1d6990bb",
    "patch": "@@ -19,11 +19,11 @@\n  */\n package fr.insideapp.sonarqube.dart.lang.issues.dartanalyzer;\n \n-import static org.assertj.core.api.Assertions.assertThat;\n+import org.junit.Test;\n \n import java.util.List;\n \n-import org.junit.Test;\n+import static org.assertj.core.api.Assertions.assertThat;\n \n public class DartAnalyzerReportParserTest {\n \n@@ -89,7 +89,24 @@ public void parseWithTraces() {\n     \tassertRuleId(issues.get(10), RULE_ID_UNUSED_LOCAL_VARIABLE);\n     \tassertMessage(issues.get(10), \"The value of the local variable 'j' isn't used.\");\n     }\n-\t\n+\n+\t@Test\n+\tpublic void parseFlutterReport() {\n+\t\tString input = \"   info • The value of the local variable 'chocolate' isn't used • lib/api/icecream/icecream_api.dart:110:29 • unused_local_variable\\n\" +\n+\t\t\t\t\"   info • 'nothing' is deprecated and shouldn't be used. Do not use this anymore, please use [Nothing] instead. • lib/src/path/to/very_cool_widget.dart:32:59 • deprecated_member_use_from_same_package\\n\" +\n+\t\t\t\t\"   info • The parameter 'foo' is required • lib/src/path/to/this_file.dart:9:5 • missing_required_param\\n\" +\n+\t\t\t\t\"   info • Unnecessary await keyword in return • lib/path/to/other/file.dart:37:27 • unnecessary_await_in_return\";\n+\n+\t\tList<DartAnalyzerReportIssue> issues = parser.parse(input);\n+\t\tassertThat(issues).hasSize(4);\n+\t\tassertThat(issues.stream().map(DartAnalyzerReportIssue::getRuleId)).containsExactly(\n+\t\t\t\t\"unused_local_variable\",\n+\t\t\t\t\"deprecated_member_use_from_same_package\",\n+\t\t\t\t\"missing_required_param\",\n+\t\t\t\t\"unnecessary_await_in_return\"\n+\t\t);\n+\t}\n+\n \tprivate void assertFilePath(DartAnalyzerReportIssue issue, String expectedPath) {\n \t\tassertThat(issue.getFilePath()).isEqualTo(expectedPath);\n \t}"
  },
  {
    "sha": "7f43191612f6d318e959cfc9265fda70b5b534dd",
    "filename": "sonar-flutter-plugin/src/main/java/fr/insideapp/sonarqube/flutter/FlutterPlugin.java",
    "status": "modified",
    "additions": 16,
    "deletions": 2,
    "changes": 18,
    "blob_url": "https://github.com/insideapp-oss/sonar-flutter/blob/1646f23ce696a1b215d7d76d0e724ccc1d6990bb/sonar-flutter-plugin/src/main/java/fr/insideapp/sonarqube/flutter/FlutterPlugin.java",
    "raw_url": "https://github.com/insideapp-oss/sonar-flutter/raw/1646f23ce696a1b215d7d76d0e724ccc1d6990bb/sonar-flutter-plugin/src/main/java/fr/insideapp/sonarqube/flutter/FlutterPlugin.java",
    "contents_url": "https://api.github.com/repos/insideapp-oss/sonar-flutter/contents/sonar-flutter-plugin/src/main/java/fr/insideapp/sonarqube/flutter/FlutterPlugin.java?ref=1646f23ce696a1b215d7d76d0e724ccc1d6990bb",
    "patch": "@@ -19,23 +19,25 @@\n  */\n package fr.insideapp.sonarqube.flutter;\n \n+import fr.insideapp.sonarqube.dart.lang.Dart;\n import fr.insideapp.sonarqube.dart.lang.DartSensor;\n import fr.insideapp.sonarqube.dart.lang.issues.DartProfile;\n import fr.insideapp.sonarqube.dart.lang.issues.dartanalyzer.DartAnalyzerRulesDefinition;\n import fr.insideapp.sonarqube.dart.lang.issues.dartanalyzer.DartAnalyzerSensor;\n import fr.insideapp.sonarqube.flutter.coverage.FlutterCoverageSensor;\n import fr.insideapp.sonarqube.flutter.tests.FlutterTestSensor;\n import org.sonar.api.Plugin;\n-import fr.insideapp.sonarqube.dart.lang.Dart;\n+import org.sonar.api.PropertyType;\n import org.sonar.api.config.PropertyDefinition;\n import org.sonar.api.resources.Qualifiers;\n \n+import java.util.stream.Collectors;\n+\n public class FlutterPlugin implements Plugin {\n \n     public static final String DART_CATEGORY = \"Dart\";\n     public static final String FLUTTER_CATEGORY = \"Flutter\";\n     public static final String ANALYSIS_SUBCATEGORY = \"Analysis\";\n-    public static final String GENERAL_SUBCATEGORY = \"General\";\n     public static final String TESTS_SUBCATEGORY = \"Tests\";\n \n     public static final String FLUTTER_TESTS_REPORT_PATH_KEY = \"sonar.flutter.tests.reportPath\";\n@@ -77,6 +79,18 @@ public void define(Context context) {\n                         .defaultValue(\"false\")\n                         .build());\n \n+        context.addExtension(\n+                PropertyDefinition.builder(DartAnalyzerSensor.FLUTTER_ANALYZER_MODE)\n+                        .name(\"Analyzer\")\n+                        .description(\"Which analyzer to use\")\n+                        .onQualifiers(Qualifiers.MODULE, Qualifiers.PROJECT)\n+                        .category(DART_CATEGORY)\n+                        .subCategory(ANALYSIS_SUBCATEGORY)\n+                        .options(DartAnalyzerSensor.FLUTTER_ANALYZER_MODE_OPTIONS.stream().map(Enum::name).collect(Collectors.toList()))\n+                        .defaultValue(DartAnalyzerSensor.FLUTTER_ANALYZER_MODE_OPTIONS.get(0).name())\n+                        .type(PropertyType.SINGLE_SELECT_LIST)\n+                        .build());\n+\n         // Tests\n         context.addExtension(FlutterTestSensor.class);\n "
  }
]
