[
  {
    "sha": "957098d9392918b267c25c2dfa814f87c953891e",
    "filename": ".vscode/launch.json",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/33e2443c8a921a5d219781418371cf12b5cc5280/.vscode/launch.json",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/33e2443c8a921a5d219781418371cf12b5cc5280/.vscode/launch.json",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/.vscode/launch.json?ref=33e2443c8a921a5d219781418371cf12b5cc5280",
    "patch": "@@ -4,6 +4,13 @@\n   // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n   \"version\": \"0.2.0\",\n   \"configurations\": [\n+    {\n+      \"type\": \"java\",\n+      \"name\": \"CodeLens (Launch) - BobTrajectoryApp\",\n+      \"request\": \"launch\",\n+      \"mainClass\": \"com.team319.ui.BobTrajectoryApp\",\n+      \"projectName\": \"BobTrajectory\"\n+    },\n     {\n       \"type\": \"java\",\n       \"name\": \"CodeLens (Launch) - PlotterFrame\","
  },
  {
    "sha": "66a2fdd8e3a82521c3ab31c9a8a4fe094f8422d9",
    "filename": "src/main/java/com/team2363/geometry/Pose2d.java",
    "status": "added",
    "additions": 37,
    "deletions": 0,
    "changes": 37,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team2363/geometry/Pose2d.java",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team2363/geometry/Pose2d.java",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/src/main/java/com/team2363/geometry/Pose2d.java?ref=33e2443c8a921a5d219781418371cf12b5cc5280",
    "patch": "@@ -0,0 +1,37 @@\n+/*----------------------------------------------------------------------------*/\n+/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        */\n+/* Open Source Software - may be modified and shared by FRC teams. The code   */\n+/* must be accompanied by the FIRST BSD license file in the root directory of */\n+/* the project.                                                               */\n+/*----------------------------------------------------------------------------*/\n+\n+package com.team2363.geometry;\n+\n+public class Pose2d {\n+\n+    private double x;\n+    private double y;\n+    private double rotation;\n+\n+    public Pose2d(double x, double y, double rotation) {\n+        this.x = x;\n+        this.y = y;\n+        this.rotation = rotation;\n+    }\n+\n+    public double x() {\n+        return x;\n+    }\n+\n+    public double y() {\n+        return y;\n+    }\n+\n+    public double getRotation() {\n+        return rotation;\n+    }\n+\n+    public double getDistance(Pose2d p1) {\n+        return Math.sqrt((p1.x() - x) * (p1.x() - x) + (p1.y() - y) * (p1.y() - y));\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "7637cd34b5cc39c2d495e21ba690b6e2edd42898",
    "filename": "src/main/java/com/team2363/spline/CartesianCubicSpline.java",
    "status": "added",
    "additions": 131,
    "deletions": 0,
    "changes": 131,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team2363/spline/CartesianCubicSpline.java",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team2363/spline/CartesianCubicSpline.java",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/src/main/java/com/team2363/spline/CartesianCubicSpline.java?ref=33e2443c8a921a5d219781418371cf12b5cc5280",
    "patch": "@@ -0,0 +1,131 @@\n+// /*----------------------------------------------------------------------------*/\n+// /* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        */\n+// /* Open Source Software - may be modified and shared by FRC teams. The code   */\n+// /* must be accompanied by the FIRST BSD license file in the root directory of */\n+// /* the project.                                                               */\n+// /*----------------------------------------------------------------------------*/\n+\n+// package com.team2363.spline;\n+\n+// import com.team2363.geometry.Pose2d;\n+\n+// public class CartesianCubicSpline extends Spline {\n+\n+//     private double a,b,c;\n+//     private double dydx0, dydx1;\n+//     private double x0, y0, thetaOffset, distance;\n+\n+// \tCartesianCubicSpline(Pose2d p0, Pose2d p1) {\n+\n+//         x0 = p0.x();\n+//         y0 = p0.y();\n+//         thetaOffset = Math.atan2(p1.y() - p0.y(), p1.x() - p0.x());\n+//         distance = p0.getDistance(p1);\n+\n+//         dydx0 = Math.tan((p0.getRotation() - thetaOffset) % (2 * Math.PI));\n+//         dydx1 = Math.tan((p1.getRotation() - thetaOffset) % (2 * Math.PI));\n+\n+//         a = ;\n+//         b = ;\n+//         c = ;\n+// \t}\n+\n+// \tprivate static boolean almostEqual(double x, double y) {\n+// \t\treturn Math.abs(x - y) < 1E-6;\n+// \t}\n+\n+// \tpublic static boolean reticulateSplines(double x0, double y0, double theta0, double x1, double y1, double theta1,\n+// \t\t\tSpline result) {\n+//         // System.out.println(\"Reticulating splines...\");\n+\n+// \t\t// Transform x to the origin\n+// \t\tif (distance == 0) {\n+// \t\t\treturn false;\n+// \t\t}\n+\n+// \t\tdouble theta0_hat = ChezyMath.getDifferenceInAngleRadians(result.theta_offset_, theta0);\n+// \t\tdouble theta1_hat = ChezyMath.getDifferenceInAngleRadians(result.theta_offset_, theta1);\n+// \t\t// We cannot handle vertical slopes in our rotated, translated basis.\n+// \t\t// This would mean the user wants to end up 90 degrees off of the straight\n+// \t\t// line between p0 and p1.\n+// \t\tif (almostEqual(Math.abs(theta0_hat), Math.PI / 2) || almostEqual(Math.abs(theta1_hat), Math.PI / 2)) {\n+// \t\t\treturn false;\n+// \t\t}\n+// \t\t// We also cannot handle the case that the end angle is facing towards the\n+// \t\t// start angle (total turn > 90 degrees).\n+// \t\tif (Math.abs(ChezyMath.getDifferenceInAngleRadians(theta0_hat, theta1_hat)) >= Math.PI / 2) {\n+// \t\t\treturn false;\n+// \t\t}\n+// \t\t// Turn angles into derivatives (slopes)\n+// \t\tdouble yp0_hat = Math.tan(theta0_hat);\n+// \t\tdouble yp1_hat = Math.tan(theta1_hat);\n+\n+// \t\t// Calculate the cubic spline coefficients\n+// \t\tresult.a_ = 0;\n+// \t\tresult.b_ = 0;\n+// \t\tresult.c_ = 0;\n+\n+// \t\treturn true;\n+// \t}\n+\n+// \tpublic double calculateLength() {\n+\n+// \t\tfinal int kNumSamples = 100000;\n+// \t\tdouble integral = 0;\n+// \t\tdouble integrand, last_integrand = Math.sqrt(1 + derivativeAt(0) * derivativeAt(0)) / kNumSamples;\n+// \t\tfor (double i = 1; i <= kNumSamples; ++i) {\n+// \t\t\tdouble t = i / kNumSamples;\n+// \t\t\tintegrand = Math.sqrt(1 + dydx(t) * dydx(t)) / kNumSamples;\n+// \t\t\tintegral += (integrand + last_integrand) / 2;\n+// \t\t\tlast_integrand = integrand;\n+// \t\t}\n+\n+// \t\treturn integral;\n+// \t}\n+\n+// \tpublic double calculateInput(double distance) {\n+// \t\tfinal int kNumSamples = 100000;\n+// \t\tdouble arc_length = 0;\n+// \t\tdouble t = 0;\n+// \t\tdouble last_arc_length = 0;\n+// \t\tdouble dydt;\n+// \t\tdouble integrand, last_integrand = Math.sqrt(1 + dydx(0) * dydx(0)) / kNumSamples;\n+// \t\tdistance /= knot_distance_;\n+// \t\tfor (double i = 1; i <= kNumSamples; ++i) {\n+// \t\t\tt = i / kNumSamples;\n+// \t\t\tintegrand = Math.sqrt(1 + dydx(t) * dydx(t)) / kNumSamples;\n+// \t\t\tarc_length += (integrand + last_integrand) / 2;\n+// \t\t\tif (arc_length > distance) {\n+// \t\t\t\tbreak;\n+// \t\t\t}\n+// \t\t\tlast_integrand = integrand;\n+// \t\t\tlast_arc_length = arc_length;\n+// \t\t}\n+\n+// \t\t// Interpolate between samples.\n+// \t\tdouble interpolated = t;\n+// \t\tif (arc_length != last_arc_length) {\n+// \t\t\tinterpolated += ((distance - last_arc_length) / (arc_length - last_arc_length) - 1) / (double) kNumSamples;\n+// \t\t}\n+// \t\treturn interpolated;\n+//     }\n+    \n+//     public Pose2d getPoint(double t) {\n+// \t\tdouble x_hat = t * distance;\n+// \t\tdouble y_hat = (a_ * x_hat + b_) * x_hat * x_hat * x_hat * x_hat + c_ * x_hat * x_hat * x_hat\n+// \t\t\t\t+ d_ * x_hat * x_hat + e_ * x_hat;\n+\n+// \t\tdouble cos_theta = Math.cos(thetaOffset);\n+//         double sin_theta = Math.sin(thetaOffset);\n+        \n+//         double x = x_hat * cos_theta - y_hat * sin_theta + x0;\n+//         double y = x_hat * sin_theta + y_hat * cos_theta + y0;\n+//         double theta = ;\n+\n+// \t\treturn new Pose2d(x, y, theta);\n+//     }\n+    \n+//     private double dydx(double t) {\n+//         return 3 * a * (t * distance) * (t * distance) + 2 * b * (t * distance) + c;\n+//     }\n+// }\n\\ No newline at end of file"
  },
  {
    "sha": "2f65044fc9078a354761812c88e4004376614f9e",
    "filename": "src/main/java/com/team2363/spline/CartesianQuinticSpline.java",
    "status": "added",
    "additions": 29,
    "deletions": 0,
    "changes": 29,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team2363/spline/CartesianQuinticSpline.java",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team2363/spline/CartesianQuinticSpline.java",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/src/main/java/com/team2363/spline/CartesianQuinticSpline.java?ref=33e2443c8a921a5d219781418371cf12b5cc5280",
    "patch": "@@ -0,0 +1,29 @@\n+// /*----------------------------------------------------------------------------*/\n+// /* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        */\n+// /* Open Source Software - may be modified and shared by FRC teams. The code   */\n+// /* must be accompanied by the FIRST BSD license file in the root directory of */\n+// /* the project.                                                               */\n+// /*----------------------------------------------------------------------------*/\n+\n+// package com.team2363.spline;\n+\n+// import com.team2363.geometry.Pose2d;\n+\n+// public class CartesianQuinticSpline extends Spline {\n+\n+//     CartesianQuinticSpline(Pose2d p0, Pose2d p1) {\n+        \n+//     }\n+\n+//     public Pose2d getPoint(double t) {\n+//         return new Pose2d(0, 0, 0);\n+//     }\n+\n+//     public double calculateLength() {\n+//         return 0;\n+//     }\n+\n+//     public double calculateInput(double distance) {\n+//         return 0;\n+//     }\n+// }\n\\ No newline at end of file"
  },
  {
    "sha": "53ec7b49be965029519da888feed6985aa201bd3",
    "filename": "src/main/java/com/team2363/spline/ParametricCubicSpline.java",
    "status": "added",
    "additions": 78,
    "deletions": 0,
    "changes": 78,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team2363/spline/ParametricCubicSpline.java",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team2363/spline/ParametricCubicSpline.java",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/src/main/java/com/team2363/spline/ParametricCubicSpline.java?ref=33e2443c8a921a5d219781418371cf12b5cc5280",
    "patch": "@@ -0,0 +1,78 @@\n+/*----------------------------------------------------------------------------*/\n+/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        */\n+/* Open Source Software - may be modified and shared by FRC teams. The code   */\n+/* must be accompanied by the FIRST BSD license file in the root directory of */\n+/* the project.                                                               */\n+/*----------------------------------------------------------------------------*/\n+\n+package com.team2363.spline;\n+\n+import com.team2363.geometry.Pose2d;\n+\n+public class ParametricCubicSpline extends Spline {\n+\n+    private double vectorMagnitude;\n+    private double dx0,dx1,dy0,dy1;\n+    private double ax,bx,cx,dx,ay,by,cy,dy;\n+\n+    public ParametricCubicSpline(Pose2d p0, Pose2d p1) {\n+\n+        vectorMagnitude = 1.5 * p0.getDistance(p1);\n+\n+        dx0 = Math.cos(p0.getRotation()) * vectorMagnitude;\n+        dx1 = Math.cos(p1.getRotation()) * vectorMagnitude;\n+\n+        dy0 = Math.sin(p0.getRotation()) * vectorMagnitude;\n+        dy1 = Math.sin(p1.getRotation()) * vectorMagnitude;\n+\n+        ax = 2 * p0.x() - 2 * p1.x() + dx0 + dx1;\n+        bx = -2 * dx0 - dx1 - 3 * p0.x() + 3 * p1.x();\n+        cx = dx0;\n+        dx = p0.x();\n+\n+        ay = 2 * p0.y() - 2 * p1.y() + dy0 + dy1;\n+        by = -2 * dy0 - dy1 - 3 * p0.y() + 3 * p1.y();\n+        cy = dy0;\n+        dy = p0.y();\n+    }\n+\n+    public Pose2d getPoint(double t) {\n+        return new Pose2d(x(t), y(t), Math.atan2(dy(t), dx(t)));\n+    }\n+\n+    public double arcLengthSegment(double t) {\n+        return Math.sqrt(dx(t) * dx(t) + dy(t) * dy(t));\n+    }\n+\n+    private double x(double t) {\n+        return ax * t * t * t + bx * t * t + cx * t + dx;\n+    }\n+\n+    private double y(double t) {\n+        return ay * t * t * t + by * t * t + cy * t + dy;\n+    }\n+\n+    private double dx(double t) {\n+        return 3 * ax * t * t + 2 * bx * t + cx;\n+    }\n+\n+    private double dy(double t) {\n+        return 3 * ay * t * t + 2 * by * t + cy;\n+    }\n+\n+    public double calculateLength() {\n+\n+        final int kNumSamples = 100000;\n+\t\tdouble integral = 0;\n+        double integrand, last_integrand = Math.sqrt(dx(0) * dx(0) + dy(0) * dy(0)) / kNumSamples;\n+        \n+\t\tfor (double i = 1; i <= kNumSamples; ++i) {\n+            double t = i / kNumSamples;\n+\t\t\tintegrand = Math.sqrt(dx(t) * dx(t) + dy(t) * dy(t)) / kNumSamples;\n+\t\t\tintegral += (integrand + last_integrand) / 2;\n+\t\t\tlast_integrand = integrand;\n+        }\n+        \n+\t\treturn integral;\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "ed9c28a70d7cf232d8e5e2ace3133232c47c97b2",
    "filename": "src/main/java/com/team2363/spline/ParametricQuinticSpline.java",
    "status": "added",
    "additions": 96,
    "deletions": 0,
    "changes": 96,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team2363/spline/ParametricQuinticSpline.java",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team2363/spline/ParametricQuinticSpline.java",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/src/main/java/com/team2363/spline/ParametricQuinticSpline.java?ref=33e2443c8a921a5d219781418371cf12b5cc5280",
    "patch": "@@ -0,0 +1,96 @@\n+/*----------------------------------------------------------------------------*/\n+/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        */\n+/* Open Source Software - may be modified and shared by FRC teams. The code   */\n+/* must be accompanied by the FIRST BSD license file in the root directory of */\n+/* the project.                                                               */\n+/*----------------------------------------------------------------------------*/\n+\n+package com.team2363.spline;\n+\n+import com.team2363.geometry.Pose2d;\n+import com.team254.lib.trajectory.Trajectory;\n+import com.team319.ui.DraggableWaypoint;\n+\n+public class ParametricQuinticSpline extends Spline {\n+\n+    private double vectorMagnitude;\n+    private double x0,x1,dx0,dx1,ddx0,ddx1,y0,y1,dy0,dy1,ddy0,ddy1;\n+    private double ax,bx,cx,dx,ex,fx,ay,by,cy,dy,ey,fy;\n+\n+    public ParametricQuinticSpline(DraggableWaypoint w0, DraggableWaypoint w1) {\n+\n+        vectorMagnitude = 1.5 * w0.getDistance(w1);\n+\n+        x0 = w0.getX();\n+        x1 = w1.getX();\n+        dx0 = Math.cos(w0.getHeading()) * vectorMagnitude;\n+        dx1 = Math.cos(w1.getHeading()) * vectorMagnitude;\n+        ddy0 = 0;\n+        ddy1 = 0;\n+\n+        y0 = w0.getY();\n+        y1 = w1.getY();\n+        dy0 = Math.sin(w0.getHeading()) * vectorMagnitude;\n+        dy1 = Math.sin(w1.getHeading()) * vectorMagnitude;\n+        ddy0 = 0;\n+        ddy1 = 0;\n+\n+        calculateCoefficients();\n+    }\n+\n+    public void calculateCoefficients() {\n+        ax = 6 * (x1 - x0) - 3 * (dx0 + dx1) + 0.5 * (ddx1 - ddx0);\n+        bx = 15 * x0 + 8 * dx0 + 1.5 * ddx0 - ddx1 + 7 * dx1 - 15 * x1;\n+        cx = -10 * x0 - 6 * dx0 - 1.5 * ddx0 + 0.5 * ddx1 - 4 * dx1 + 10 * x1;\n+        dx = 0.5 * ddx0;\n+        ex = dx0;\n+        fx = x0;\n+\n+        ay = 6 * (y1 - y0) - 3 * (dy0 + dy1) + 0.5 * (ddy1 - ddy0);;\n+        by = 15 * y0 + 8 * dy0 + 1.5 * ddy0 - ddy1 + 7 * dy1 - 15 * y1;\n+        cy = -10 * y0 - 6 * dy0 - 1.5 * ddy0 + 0.5 * ddy1 - 4 * dy1 + 10 * y1;\n+        dy = 0.5 * ddy0;\n+        ey = dy0;\n+        fy = y0;\n+    }\n+\n+    public Pose2d getPoint(double t) {\n+        return new Pose2d(x(t), y(t), Math.atan2(dy(t), dx(t)));\n+    }\n+\n+    public double arcLengthSegment(double t) {\n+        return Math.sqrt(dx(t) * dx(t) + dy(t) * dy(t));\n+    }\n+\n+    private double x(double t) {\n+        return ax * t * t * t * t * t + bx * t * t * t * t + cx * t * t * t + dx * t * t + ex * t + fx;\n+    }\n+\n+    private double y(double t) {\n+        return ay * t * t * t * t * t + by * t * t * t * t + cy * t * t * t + dy * t * t + ey * t + fy;\n+    }\n+\n+    private double dx(double t) {\n+        return 5 * ax * t * t * t * t + 4 * bx * t * t * t + 3 * cx * t * t + 2 * dx * t + ex;\n+    }\n+\n+    private double dy(double t) {\n+        return 5 * ay * t * t * t * t + 4 * by * t * t * t + 3 * cy * t * t + 2 * dy * t + ey;\n+    }\n+\n+    public double calculateLength() {\n+\n+        final int kNumSamples = 100000;\n+\t\tdouble integral = 0;\n+        double integrand, last_integrand = Math.sqrt(dx(0) * dx(0) + dy(0) * dy(0)) / kNumSamples;\n+        \n+\t\tfor (double i = 1; i <= kNumSamples; ++i) {\n+            double t = i / kNumSamples;\n+\t\t\tintegrand = Math.sqrt(dx(t) * dx(t) + dy(t) * dy(t)) / kNumSamples;\n+\t\t\tintegral += (integrand + last_integrand) / 2;\n+\t\t\tlast_integrand = integrand;\n+        }\n+        \n+\t\treturn integral;\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "cc66848df9d5fd31d654979fd0e823d60e9aa466",
    "filename": "src/main/java/com/team2363/spline/Spline.java",
    "status": "added",
    "additions": 12,
    "deletions": 0,
    "changes": 12,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team2363/spline/Spline.java",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team2363/spline/Spline.java",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/src/main/java/com/team2363/spline/Spline.java?ref=33e2443c8a921a5d219781418371cf12b5cc5280",
    "patch": "@@ -0,0 +1,12 @@\n+package com.team2363.spline;\n+\n+import com.team2363.geometry.Pose2d;\n+import com.team254.lib.trajectory.Trajectory;\n+\n+public abstract class Spline {\n+    public abstract Pose2d getPoint(double input);\n+\n+    public abstract double arcLengthSegment(double t);\n+\n+    public abstract double calculateLength();\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "1fa7e23bc2856558e1a2c06efe9cdb882b4e1506",
    "filename": "src/main/java/com/team2363/spline/SplineGenerator.java",
    "status": "added",
    "additions": 59,
    "deletions": 0,
    "changes": 59,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team2363/spline/SplineGenerator.java",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team2363/spline/SplineGenerator.java",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/src/main/java/com/team2363/spline/SplineGenerator.java?ref=33e2443c8a921a5d219781418371cf12b5cc5280",
    "patch": "@@ -0,0 +1,59 @@\n+package com.team2363.spline;\n+\n+import java.util.List;\n+\n+import com.team2363.geometry.Pose2d;\n+import com.team254.lib.trajectory.Segment;\n+import com.team254.lib.trajectory.Trajectory;\n+import com.team319.ui.DraggableWaypoint;\n+\n+public class SplineGenerator {\n+\n+    public static Spline[] getSplines(List<DraggableWaypoint> waypoints) {\n+        Spline[] splines = new Spline[waypoints.size() - 1];\n+\t\tfor (int i = 0; i < splines.length; ++i) {\n+            splines[i] = new ParametricQuinticSpline(waypoints.get(i), waypoints.get(i + 1));\n+        }\n+        return splines;\n+    }\n+\n+    public static void parametrizeSplines(Trajectory traj, Spline[] splines) {\n+        double startPos = 0;\n+        double splineLength = splines[0].calculateLength();\n+        int currentSpline = 0;\n+        double t = 0;\n+        double dt = 0.00001;\n+        double integral = 0;\n+        double lastIntegral = 0;\n+        double result = 0;\n+        double integrand, lastIntegrand = splines[0].arcLengthSegment(0) * dt;\n+        for (Segment segment : traj.getSegments()) {\n+            if (segment.pos - startPos > splineLength && currentSpline < splines.length - 1) {\n+                startPos += splineLength;\n+                splineLength = splines[currentSpline + 1].calculateLength();\n+                currentSpline++;\n+\n+                integral = 0;\n+                lastIntegral = 0;\n+                lastIntegrand = splines[currentSpline].arcLengthSegment(0) * dt;\n+                t = 0;\n+            }\n+            \n+            while (integral < segment.pos - startPos) {\n+                t += dt;\n+                integrand = splines[currentSpline].arcLengthSegment(t) * dt;\n+                integral += (integrand + lastIntegrand) / 2;\n+                if (integral > segment.pos - startPos) {\n+                    result = (integral != lastIntegral) ? t + ((segment.pos - startPos - lastIntegral) / (integral - lastIntegral) - 1) * dt : t;\n+                }\n+                lastIntegrand = integrand;\n+                lastIntegral = integral;\n+            }\n+\n+            Pose2d pose = splines[currentSpline].getPoint(Math.min(result, 1));\n+            segment.x = pose.x();\n+            segment.y = pose.y();\n+            segment.heading = pose.getRotation();\n+        }\n+    }\n+}"
  },
  {
    "sha": "f0593d1e4b3e098348843f42691ede7949336353",
    "filename": "src/main/java/com/team254/lib/trajectory/PathGenerator.java",
    "status": "modified",
    "additions": 32,
    "deletions": 75,
    "changes": 107,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team254/lib/trajectory/PathGenerator.java",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team254/lib/trajectory/PathGenerator.java",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/src/main/java/com/team254/lib/trajectory/PathGenerator.java?ref=33e2443c8a921a5d219781418371cf12b5cc5280",
    "patch": "@@ -2,6 +2,9 @@\n \n import java.util.List;\n \n+import com.team2363.geometry.Pose2d;\n+import com.team2363.spline.Spline;\n+import com.team2363.spline.SplineGenerator;\n import com.team319.trajectory.RobotConfig;\n import com.team319.ui.DraggableWaypoint;\n \n@@ -28,44 +31,11 @@ public static Trajectory generateTrajectory(List<DraggableWaypoint> waypoints) {\n \t\t\t\t\t\t\twaypoints.get(i).getMaxVelocity()));\n \t\t}\n \n-\t\tassignHeadings(traj, splines);\n+\t\tSplineGenerator.parametrizeSplines(traj, splines);\n \t\tcorrectHeading(traj);\n \t\treturn traj;\n \t}\t\n \n-\tprivate static void assignHeadings(Trajectory traj, Spline[] splines) {\n-\t\t// Assign headings based on the splines.\n-\t\tint cur_spline = 0;\n-\t\tdouble cur_spline_start_pos = 0;\n-\t\tdouble length_of_splines_finished = 0;\n-\t\tfor (int i = 0; i < traj.getNumSegments(); ++i) {\n-\t\t\tdouble cur_pos = traj.getSegments().get(i).pos;\n-\n-\t\t\tboolean found_spline = false;\n-\t\t\twhile (!found_spline) {\n-\t\t\t\tdouble cur_pos_relative = cur_pos - cur_spline_start_pos;\n-\t\t\t\tif (cur_pos_relative <= splines[cur_spline].calculateLength()) {\n-\t\t\t\t\tdouble percentage = splines[cur_spline].getPercentageForDistance(cur_pos_relative);\n-\t\t\t\t\ttraj.getSegments().get(i).heading = splines[cur_spline].angleAt(percentage);\n-\t\t\t\t\tdouble[] coords = splines[cur_spline].getXandY(percentage);\n-\t\t\t\t\ttraj.getSegments().get(i).x = coords[0];\n-\t\t\t\t\ttraj.getSegments().get(i).y = coords[1];\n-\t\t\t\t\tfound_spline = true;\n-\t\t\t\t} else if (cur_spline < splines.length - 1) {\n-\t\t\t\t\tlength_of_splines_finished += splines[cur_spline].calculateLength();\n-\t\t\t\t\tcur_spline_start_pos = length_of_splines_finished;\n-\t\t\t\t\t++cur_spline;\n-\t\t\t\t} else {\n-\t\t\t\t\ttraj.getSegments().get(i).heading = splines[splines.length - 1].angleAt(1.0);\n-\t\t\t\t\tdouble[] coords = splines[splines.length - 1].getXandY(1.0);\n-\t\t\t\t\ttraj.getSegments().get(i).x = coords[0];\n-\t\t\t\t\ttraj.getSegments().get(i).y = coords[1];\n-\t\t\t\t\tfound_spline = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n \tprivate static void correctHeading(Trajectory trajectory) {\n \t\t// Fix headings so they are continuously additive \n \t\tdouble lastUncorrectedHeading = trajectory.getSegments().get(0).heading;\n@@ -83,56 +53,43 @@ private static void correctHeading(Trajectory trajectory) {\n \t\t\t\theadingDelta = lastUncorrectedHeading - uncorrectedHeading;\n \t\t\t}\n \n-\t\t\tdouble correctedHeading = lastCorrectedHeading - headingDelta;\n-\t\t\tcurrentSegment.heading = correctedHeading;\n+\t\t\tcurrentSegment.heading = lastCorrectedHeading - headingDelta;\n \t\t\tlastUncorrectedHeading = uncorrectedHeading;\n-\t\t\tlastCorrectedHeading = correctedHeading;\n+\t\t\tlastCorrectedHeading = currentSegment.heading;\n \t\t}\n \t}\n \n \tpublic static TrajectorySet makeLeftAndRightTrajectories(Trajectory input) {\n-\t\tTrajectory[] output = new Trajectory[2];\n-\t\toutput[0] = input.copy();\n-\t\toutput[1] = input.copy();\n-\t\tTrajectory left = output[0];\n-\t\tTrajectory right = output[1];\n+\t\tTrajectory left = input.copy();\n+\t\tTrajectory right = input.copy();\n \n \t\tfor (int i = 0; i < input.getNumSegments(); ++i) {\n-\t\t\tSegment current = input.getSegments().get(i);\n-\t\t\tdouble cos_angle = Math.cos(current.heading);\n-\t\t\tdouble sin_angle = Math.sin(current.heading);\n+\t\t\tSegment currentCenter = input.getSegments().get(i);\n+\t\t\tdouble cos_angle = Math.cos(currentCenter.heading);\n+\t\t\tdouble sin_angle = Math.sin(currentCenter.heading);\n \n-\t\t\tSegment s_left = left.getSegments().get(i);\n-\t\t\ts_left.x = current.x - RobotConfig.wheelBase / 2 * sin_angle;\n-\t\t\ts_left.y = current.y + RobotConfig.wheelBase / 2 * cos_angle;\n-\t\t\tif (i > 0) {\n-\t\t\t\t// Get distance between current and last segment\n-\t\t\t\tdouble dist = Math.sqrt((s_left.x - left.getSegments().get(i - 1).x)\n-\t\t\t\t\t\t* (s_left.x - left.getSegments().get(i - 1).x)\n-\t\t\t\t\t\t+ (s_left.y - left.getSegments().get(i - 1).y)\n-\t\t\t\t\t\t* (s_left.y - left.getSegments().get(i - 1).y));\n-\t\t\t\ts_left.pos = left.getSegments().get(i - 1).pos + dist;\n-\t\t\t\ts_left.vel = dist / s_left.dt;\n-\t\t\t\ts_left.acc = (s_left.vel - left.getSegments().get(i - 1).vel) / s_left.dt;\n-\t\t\t\ts_left.jerk = (s_left.acc - left.getSegments().get(i - 1).acc) / s_left.dt;\n-\t\t\t}\n+\t\t\tSegment currentLeft = left.getSegments().get(i);\n+\t\t\tcurrentLeft.x = currentCenter.x + RobotConfig.wheelBase / 2 * sin_angle;\n+\t\t\tcurrentLeft.y = currentCenter.y - RobotConfig.wheelBase / 2 * cos_angle;\n+\t\t\tif (i > 0) calculateSegmentData(currentLeft, left.getSegments().get(i - 1));\n \n-\t\t\tSegment s_right = right.getSegments().get(i);\n-\t\t\ts_right.x = current.x + RobotConfig.wheelBase / 2 * sin_angle;\n-\t\t\ts_right.y = current.y - RobotConfig.wheelBase / 2 * cos_angle;\n-\t\t\tif (i > 0) {\n-\t\t\t\t// Get distance between current and last segment\n-\t\t\t\tdouble dist = Math.sqrt((s_right.x - right.getSegments().get(i - 1).x)\n-\t\t\t\t\t\t* (s_right.x - right.getSegments().get(i - 1).x)\n-\t\t\t\t\t\t+ (s_right.y - right.getSegments().get(i - 1).y)\n-\t\t\t\t\t\t* (s_right.y - right.getSegments().get(i - 1).y));\n-\t\t\t\ts_right.pos = right.getSegments().get(i - 1).pos + dist;\n-\t\t\t\ts_right.vel = dist / s_right.dt;\n-\t\t\t\ts_right.acc = (s_right.vel - right.getSegments().get(i - 1).vel) / s_right.dt;\n-\t\t\t\ts_right.jerk = (s_right.acc - right.getSegments().get(i - 1).acc) / s_right.dt;\n-\t\t\t}\n+\t\t\tSegment currentRight = right.getSegments().get(i);\n+\t\t\tcurrentRight.x = currentCenter.x + RobotConfig.wheelBase / 2 * sin_angle;\n+\t\t\tcurrentRight.y = currentCenter.y - RobotConfig.wheelBase / 2 * cos_angle;\n+\t\t\tif (i > 0) calculateSegmentData(currentRight, right.getSegments().get(i - 1));\n \t\t}\n \n-\t\treturn new TrajectorySet(output[0], input, output[1]);\n+\t\treturn new TrajectorySet(left, input, right);\n+\t}\n+\n+\tprivate static void calculateSegmentData(Segment current, Segment previous) {\n+\t\tdouble dist = Math.sqrt((current.x - previous.x) \n+\t\t* (current.x - previous.x) \n+\t\t+ (current.y - previous.y) \n+\t\t* (current.y - previous.y));\n+\t\tcurrent.pos = previous.pos + dist;\n+\t\tcurrent.vel = dist / current.dt;\n+\t\tcurrent.acc = (current.vel - previous.vel) / current.dt;\n+\t\tcurrent.jerk = (current.acc - previous.acc) / current.dt;\n \t}\n-}\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "b7ac0f4fae2fc5890593d2943ed90f45a0c76c0d",
    "filename": "src/main/java/com/team254/lib/trajectory/Spline.java",
    "status": "removed",
    "additions": 0,
    "deletions": 224,
    "changes": 224,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/3721fc660b1f058a17c1f48670f35dc14f89501d/src/main/java/com/team254/lib/trajectory/Spline.java",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/3721fc660b1f058a17c1f48670f35dc14f89501d/src/main/java/com/team254/lib/trajectory/Spline.java",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/src/main/java/com/team254/lib/trajectory/Spline.java?ref=3721fc660b1f058a17c1f48670f35dc14f89501d",
    "patch": "@@ -1,224 +0,0 @@\n-package com.team254.lib.trajectory;\n-\n-import com.team254.lib.util.ChezyMath;\n-import com.team319.ui.DraggableWaypoint;\n-\n-/**\n- * Do cubic spline interpolation between points.\n- *\n- * @author Art Kalb\n- * @author Jared341\n- */\n-public class Spline {\n-\n-\tpublic static class Type {\n-\n-\t\tprivate final String value_;\n-\n-\t\tprivate Type(String value) {\n-\t\t\tthis.value_ = value;\n-\t\t}\n-\n-\t\tpublic String toString() {\n-\t\t\treturn value_;\n-\t\t}\n-\t}\n-\n-\t// Cubic spline where positions and first derivatives (angle) constraints will\n-\t// be met but second derivatives may be discontinuous.\n-\tpublic static final Type CubicHermite = new Type(\"CubicHermite\");\n-\n-\t// Quintic spline where positions and first derivatives (angle) constraints\n-\t// will be met, and all second derivatives at knots = 0.\n-\tpublic static final Type QuinticHermite = new Type(\"QuinticHermite\");\n-\n-\tType type_;\n-\tdouble a_; // ax^5\n-\tdouble b_; // + bx^4\n-\tdouble c_; // + cx^3\n-\tdouble d_; // + dx^2\n-\tdouble e_; // + ex\n-\t// f is always 0 for the spline formulation we support.\n-\n-\t// The offset from the world frame to the spline frame.\n-\t// Add these to the output of the spline to obtain world coordinates.\n-\tdouble y_offset_;\n-\tdouble x_offset_;\n-\tdouble knot_distance_;\n-\tdouble theta_offset_;\n-\tdouble arc_length_;\n-\n-\tSpline() {\n-\t\t// All splines should be made via the static interface\n-\t\tarc_length_ = -1;\n-\t}\n-\n-\tprivate static boolean almostEqual(double x, double y) {\n-\t\treturn Math.abs(x - y) < 1E-6;\n-\t}\n-\n-\tpublic static boolean reticulateSplines(DraggableWaypoint start, DraggableWaypoint goal,\n-\t\t\tSpline result, Type type) {\n-\t\treturn reticulateSplines(start.getX(), start.getY(), start.getHeading(), goal.getX(), goal.getY(), goal.getHeading(), result, type);\n-\t}\n-\n-\tpublic static boolean reticulateSplines(double x0, double y0, double theta0, double x1, double y1, double theta1,\n-\t\t\tSpline result, Type type) {\n-//\t\tSystem.out.println(\"Reticulating splines...\");\n-\t\tresult.type_ = type;\n-\n-\t\t// Transform x to the origin\n-\t\tresult.x_offset_ = x0;\n-\t\tresult.y_offset_ = y0;\n-\t\tdouble x1_hat = Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));\n-\t\tif (x1_hat == 0) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tresult.knot_distance_ = x1_hat;\n-\t\tresult.theta_offset_ = Math.atan2(y1 - y0, x1 - x0);\n-\t\tdouble theta0_hat = ChezyMath.getDifferenceInAngleRadians(result.theta_offset_, theta0);\n-\t\tdouble theta1_hat = ChezyMath.getDifferenceInAngleRadians(result.theta_offset_, theta1);\n-\t\t// We cannot handle vertical slopes in our rotated, translated basis.\n-\t\t// This would mean the user wants to end up 90 degrees off of the straight\n-\t\t// line between p0 and p1.\n-\t\tif (almostEqual(Math.abs(theta0_hat), Math.PI / 2) || almostEqual(Math.abs(theta1_hat), Math.PI / 2)) {\n-\t\t\treturn false;\n-\t\t}\n-\t\t// We also cannot handle the case that the end angle is facing towards the\n-\t\t// start angle (total turn > 90 degrees).\n-\t\tif (Math.abs(ChezyMath.getDifferenceInAngleRadians(theta0_hat, theta1_hat)) >= Math.PI / 2) {\n-\t\t\treturn false;\n-\t\t}\n-\t\t// Turn angles into derivatives (slopes)\n-\t\tdouble yp0_hat = Math.tan(theta0_hat);\n-\t\tdouble yp1_hat = Math.tan(theta1_hat);\n-\n-\t\tif (type == CubicHermite) {\n-\t\t\t// Calculate the cubic spline coefficients\n-\t\t\tresult.a_ = 0;\n-\t\t\tresult.b_ = 0;\n-\t\t\tresult.c_ = (yp1_hat + yp0_hat) / (x1_hat * x1_hat);\n-\t\t\tresult.d_ = -(2 * yp0_hat + yp1_hat) / x1_hat;\n-\t\t\tresult.e_ = yp0_hat;\n-\t\t} else if (type == QuinticHermite) {\n-\t\t\tresult.a_ = -(3 * (yp0_hat + yp1_hat)) / (x1_hat * x1_hat * x1_hat * x1_hat);\n-\t\t\tresult.b_ = (8 * yp0_hat + 7 * yp1_hat) / (x1_hat * x1_hat * x1_hat);\n-\t\t\tresult.c_ = -(6 * yp0_hat + 4 * yp1_hat) / (x1_hat * x1_hat);\n-\t\t\tresult.d_ = 0;\n-\t\t\tresult.e_ = yp0_hat;\n-\t\t}\n-\n-\t\treturn true;\n-\t}\n-\n-\tpublic double calculateLength() {\n-\t\tif (arc_length_ >= 0) {\n-\t\t\treturn arc_length_;\n-\t\t}\n-\n-\t\tfinal int kNumSamples = 100000;\n-\t\tdouble arc_length = 0;\n-\t\tdouble t, dydt;\n-\t\tdouble integrand, last_integrand = Math.sqrt(1 + derivativeAt(0) * derivativeAt(0)) / kNumSamples;\n-\t\tfor (int i = 1; i <= kNumSamples; ++i) {\n-\t\t\tt = ((double) i) / kNumSamples;\n-\t\t\tdydt = derivativeAt(t);\n-\t\t\tintegrand = Math.sqrt(1 + dydt * dydt) / kNumSamples;\n-\t\t\tarc_length += (integrand + last_integrand) / 2;\n-\t\t\tlast_integrand = integrand;\n-\t\t}\n-\t\tarc_length_ = knot_distance_ * arc_length;\n-\t\treturn arc_length_;\n-\t}\n-\n-\tpublic double getPercentageForDistance(double distance) {\n-\t\tfinal int kNumSamples = 100000;\n-\t\tdouble arc_length = 0;\n-\t\tdouble t = 0;\n-\t\tdouble last_arc_length = 0;\n-\t\tdouble dydt;\n-\t\tdouble integrand, last_integrand = Math.sqrt(1 + derivativeAt(0) * derivativeAt(0)) / kNumSamples;\n-\t\tdistance /= knot_distance_;\n-\t\tfor (int i = 1; i <= kNumSamples; ++i) {\n-\t\t\tt = ((double) i) / kNumSamples;\n-\t\t\tdydt = derivativeAt(t);\n-\t\t\tintegrand = Math.sqrt(1 + dydt * dydt) / kNumSamples;\n-\t\t\tarc_length += (integrand + last_integrand) / 2;\n-\t\t\tif (arc_length > distance) {\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tlast_integrand = integrand;\n-\t\t\tlast_arc_length = arc_length;\n-\t\t}\n-\n-\t\t// Interpolate between samples.\n-\t\tdouble interpolated = t;\n-\t\tif (arc_length != last_arc_length) {\n-\t\t\tinterpolated += ((distance - last_arc_length) / (arc_length - last_arc_length) - 1) / (double) kNumSamples;\n-\t\t}\n-\t\treturn interpolated;\n-\t}\n-\n-\tpublic double[] getXandY(double percentage) {\n-\t\tdouble[] result = new double[2];\n-\n-\t\tpercentage = Math.max(Math.min(percentage, 1), 0);\n-\t\tdouble x_hat = percentage * knot_distance_;\n-\t\tdouble y_hat = (a_ * x_hat + b_) * x_hat * x_hat * x_hat * x_hat + c_ * x_hat * x_hat * x_hat\n-\t\t\t\t+ d_ * x_hat * x_hat + e_ * x_hat;\n-\n-\t\tdouble cos_theta = Math.cos(theta_offset_);\n-\t\tdouble sin_theta = Math.sin(theta_offset_);\n-\n-\t\tresult[0] = x_hat * cos_theta - y_hat * sin_theta + x_offset_;\n-\t\tresult[1] = x_hat * sin_theta + y_hat * cos_theta + y_offset_;\n-\t\treturn result;\n-\t}\n-\n-\tpublic double valueAt(double percentage) {\n-\t\tpercentage = Math.max(Math.min(percentage, 1), 0);\n-\t\tdouble x_hat = percentage * knot_distance_;\n-\t\tdouble y_hat = (a_ * x_hat + b_) * x_hat * x_hat * x_hat * x_hat + c_ * x_hat * x_hat * x_hat\n-\t\t\t\t+ d_ * x_hat * x_hat + e_ * x_hat;\n-\n-\t\tdouble cos_theta = Math.cos(theta_offset_);\n-\t\tdouble sin_theta = Math.sin(theta_offset_);\n-\n-\t\tdouble value = x_hat * sin_theta + y_hat * cos_theta + y_offset_;\n-\t\treturn value;\n-\t}\n-\n-\tprivate double derivativeAt(double percentage) {\n-\t\tpercentage = Math.max(Math.min(percentage, 1), 0);\n-\n-\t\tdouble x_hat = percentage * knot_distance_;\n-\t\tdouble yp_hat = (5 * a_ * x_hat + 4 * b_) * x_hat * x_hat * x_hat + 3 * c_ * x_hat * x_hat + 2 * d_ * x_hat\n-\t\t\t\t+ e_;\n-\n-\t\treturn yp_hat;\n-\t}\n-\n-\tprivate double secondDerivativeAt(double percentage) {\n-\t\tpercentage = Math.max(Math.min(percentage, 1), 0);\n-\n-\t\tdouble x_hat = percentage * knot_distance_;\n-\t\tdouble ypp_hat = (20 * a_ * x_hat + 12 * b_) * x_hat * x_hat + 6 * c_ * x_hat + 2 * d_;\n-\n-\t\treturn ypp_hat;\n-\t}\n-\n-\tpublic double angleAt(double percentage) {\n-\t\tdouble derivative = derivativeAt(percentage);\n-\t\tdouble angle = Math.atan(derivative) + theta_offset_;\n-\t\t//double angle = ChezyMath.boundAngle0to2PiRadians(Math.atan(derivative) + theta_offset_);\n-\t\treturn angle;\n-\t}\n-\n-\tpublic double angleChangeAt(double percentage) {\n-\t\treturn ChezyMath.boundAngleNegPiToPiRadians(Math.atan(secondDerivativeAt(percentage)));\n-\t}\n-\n-\tpublic String toString() {\n-\t\treturn \"a=\" + a_ + \"; b=\" + b_ + \"; c=\" + c_ + \"; d=\" + d_ + \"; e=\" + e_;\n-\t}\n-}"
  },
  {
    "sha": "a67a84b49906ba29edc3aa055e1b48f5bb99867d",
    "filename": "src/main/java/com/team254/lib/trajectory/SplineGenerator.java",
    "status": "removed",
    "additions": 0,
    "deletions": 23,
    "changes": 23,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/3721fc660b1f058a17c1f48670f35dc14f89501d/src/main/java/com/team254/lib/trajectory/SplineGenerator.java",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/3721fc660b1f058a17c1f48670f35dc14f89501d/src/main/java/com/team254/lib/trajectory/SplineGenerator.java",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/src/main/java/com/team254/lib/trajectory/SplineGenerator.java?ref=3721fc660b1f058a17c1f48670f35dc14f89501d",
    "patch": "@@ -1,23 +0,0 @@\n-package com.team254.lib.trajectory;\n-\n-import java.util.List;\n-\n-import com.team319.ui.DraggableWaypoint;\n-\n-public class SplineGenerator {\n-\n-    public static Spline[] getSplines(List<DraggableWaypoint> waypoints) {\n-        Spline[] splines = new Spline[waypoints.size() - 1];\n-\t\tdouble[] spline_lengths = new double[splines.length];\n-\t\tfor (int i = 0; i < splines.length; ++i) {\n-\t\t\tsplines[i] = new Spline();\n-\t\t\tif (!Spline.reticulateSplines(waypoints.get(i), waypoints.get(i + 1), splines[i],\n-\t\t\t\t\tSpline.QuinticHermite)) {\n-\t\t\t\tSystem.out.println(\"COULDN'T RETICULATE SPLINE!!\");\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\tspline_lengths[i] = splines[i].calculateLength();\n-        }\n-        return splines;\n-    }\n-}"
  },
  {
    "sha": "d1bbe3510faa2520acc1d2da31246da7cf802474",
    "filename": "src/main/java/com/team254/lib/trajectory/TrajectoryGenerator.java",
    "status": "modified",
    "additions": 49,
    "deletions": 24,
    "changes": 73,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team254/lib/trajectory/TrajectoryGenerator.java",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team254/lib/trajectory/TrajectoryGenerator.java",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/src/main/java/com/team254/lib/trajectory/TrajectoryGenerator.java?ref=33e2443c8a921a5d219781418371cf12b5cc5280",
    "patch": "@@ -1,50 +1,75 @@\n package com.team254.lib.trajectory;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n import com.team319.trajectory.RobotConfig;\n \n public class TrajectoryGenerator {\n \n-\tpublic static Trajectory generate(double startVelocity, double startDistance, double finalDistance, double finalVelocity, double maxVelocity) {\n-\t\tTrajectory trajectory = new Trajectory();\n-\t\tdouble currentVelocity = startVelocity;\n-\t\tdouble currentDistance = startDistance;\n+\tpublic static Trajectory generate(double startVelocity, double startPosition, double finalPosition, double finalVelocity, double maxVelocity) {\n \t\tdouble dt = RobotConfig.dt;\n-\n+\t\t\n+\t\tList<Segment> segments = new ArrayList<>();\n+\t\tdouble currentVelocity = startVelocity;\n+\t\tdouble currentPosition = startPosition;\n+\t\t\n+\t\tdouble nextVelocity = startVelocity + RobotConfig.maxAcceleration * dt;\n+\t\tdouble nextPosition = startPosition + (startVelocity + nextVelocity) / 2 * dt;\n+\t\t\n \t\t// Add ramp up points\n-\t\twhile(isEnoughDistanceRemainingToRampDown(currentVelocity, finalVelocity, finalDistance - currentDistance)) {\n-\t\t\tcurrentVelocity += RobotConfig.maxAcceleration * dt;\n-\t\t\tcurrentVelocity = Math.min(maxVelocity, currentVelocity);\n-\t\t\tcurrentDistance += currentVelocity * dt;\n-\n+\t\twhile(isEnoughDistanceRemainingToRampDown(nextVelocity, finalVelocity, finalPosition - nextPosition)) {\n+\t\t\tcurrentVelocity = nextVelocity;\n+\t\t\tcurrentPosition = nextPosition;\n+\t\n \t\t\tSegment current = new Segment();\n-\t\t\tcurrent.pos = currentDistance;\n+\t\t\tcurrent.pos = currentPosition;\n \t\t\tcurrent.vel = currentVelocity;\n \t\t\tcurrent.acc = RobotConfig.maxAcceleration;\n \t\t\tcurrent.dt = dt;\n \n-\t\t\ttrajectory.getSegments().add(current);\n-\t\t}\n+\t\t\tsegments.add(current);\n+\n+\t\t\tnextVelocity = currentVelocity + RobotConfig.maxAcceleration * dt;\n+\t\t\tnextVelocity = Math.min(maxVelocity, nextVelocity);\n+\t\t\tnextPosition = currentPosition +  (currentVelocity + nextVelocity) / 2 * dt;\n+\t\t} \n \n+\t\tdouble remainingDistance = finalPosition - currentPosition;\n+\t\tdouble rampDownAcceleration = (finalVelocity * finalVelocity - currentVelocity * currentVelocity) / 2.0 / remainingDistance;\n \n-\t\t// Add ramp down points\n-\t\twhile(currentVelocity > finalVelocity) {\n-\t\t\tcurrentVelocity -= RobotConfig.maxAcceleration * dt;\n-\t\t\tcurrentDistance += currentVelocity * dt;\n+\t\tnextVelocity = currentVelocity + rampDownAcceleration * dt;\n+\t\tnextPosition = currentPosition +  (currentVelocity + nextVelocity) / 2 * dt;\n \n+\t\t// add ramp down points\n+\t\twhile(rampDownAcceleration != 0 && nextVelocity >= finalVelocity) {\n+\t\t\tcurrentVelocity = nextVelocity;\n+\t\t\tcurrentPosition = nextPosition;\n+\t\n \t\t\tSegment current = new Segment();\n-\t\t\tcurrent.pos = Math.min(currentDistance, finalDistance);\n+\t\t\tcurrent.pos = currentPosition;\n \t\t\tcurrent.vel = currentVelocity;\n-\t\t\tcurrent.acc = -RobotConfig.maxAcceleration;\n+\t\t\tcurrent.acc = rampDownAcceleration;\n \t\t\tcurrent.dt = dt;\n \n-\t\t\ttrajectory.getSegments().add(current);\n-\t\t}\n+\t\t\tsegments.add(current);\n+\n+\t\t\tnextVelocity = currentVelocity + rampDownAcceleration * dt;\n+\t\t\tnextPosition = currentPosition + (currentVelocity + nextVelocity) / 2 * dt;\n+\t\t} \n+\n+\t\tTrajectory trajectory = new Trajectory();\n+\t\ttrajectory.getSegments().addAll(segments);\n \t\treturn trajectory;\n \t}\n \n \tprivate static boolean isEnoughDistanceRemainingToRampDown(double currentVelocity, double finalVelocity, double distanceRemaining) {\n-\t\tdouble timeToDecellerate = (currentVelocity - finalVelocity) / RobotConfig.maxAcceleration;\n-\t\tdouble distanceToDecellerate = (currentVelocity + finalVelocity) / 2.0 * timeToDecellerate;\n+\t\tdouble distanceToDecellerate = getRampDownDistanceNeeded(currentVelocity, finalVelocity);\n \t\treturn distanceToDecellerate < distanceRemaining;\n \t}\n-}\n+\n+\tprivate static double getRampDownDistanceNeeded(double currentVelocity, double finalVelocity) {\n+\t\tdouble timeToDecellerate = (currentVelocity - finalVelocity) / RobotConfig.maxAcceleration;\n+\t\treturn (currentVelocity + finalVelocity) / 2.0 * timeToDecellerate;\n+\t}\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "d8375615335a1aef1784f8f578b47b7fe01532ab",
    "filename": "src/main/java/com/team319/ui/ClickableSpline.java",
    "status": "modified",
    "additions": 5,
    "deletions": 6,
    "changes": 11,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team319/ui/ClickableSpline.java",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team319/ui/ClickableSpline.java",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/src/main/java/com/team319/ui/ClickableSpline.java?ref=33e2443c8a921a5d219781418371cf12b5cc5280",
    "patch": "@@ -8,7 +8,7 @@\n \n import javax.swing.JOptionPane;\n \n-import com.team254.lib.trajectory.Spline;\n+import com.team2363.spline.Spline;\n \n public class ClickableSpline implements MouseListener{\n     private static final int DIAMETER = 20;\n@@ -28,8 +28,8 @@\n     public ClickableSpline(Spline spline, Plotter parentPanel, DraggableWaypoint startPoint, DraggableWaypoint endPoint) {\n         this.spline = spline;\n         this.parentPanel = parentPanel;\n-        this.clickableX = spline.getXandY(0.5)[0];\n-        this.clickableY = spline.getXandY(0.5)[1];\n+        this.clickableX = spline.getPoint(0.5).x();\n+        this.clickableY = spline.getPoint(0.5).y();\n         this.endPoint = endPoint;\n         this.startPoint = startPoint;\n         parentPanel.addMouseListener(this);\n@@ -55,9 +55,8 @@ private void drawHighlight(Graphics2D gc) {\n \n     private void drawSpline(Graphics2D gc) {\n         for (double i = 0; i <= 1; i += 0.005) {\n-            double[] xy = spline.getXandY(i);\n-                gc.fillOval(\n-                    Plotter.convertXToPixel(xy[0]) - 2, Plotter.convertYToPixel(xy[1]) - 2, 4, 4);\n+            gc.fillOval(\n+                Plotter.convertXToPixel(spline.getPoint(i).x()) - 2, Plotter.convertYToPixel(spline.getPoint(i).y()) - 2, 4, 4);\n         }\n     }\n "
  },
  {
    "sha": "460ead6eddda78e67bf6ed175548792f18cd7411",
    "filename": "src/main/java/com/team319/ui/DraggableWaypoint.java",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team319/ui/DraggableWaypoint.java",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team319/ui/DraggableWaypoint.java",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/src/main/java/com/team319/ui/DraggableWaypoint.java?ref=33e2443c8a921a5d219781418371cf12b5cc5280",
    "patch": "@@ -184,6 +184,10 @@ public void setMaxVelocity(double maxVelocity) {\n         this.maxVelocity = maxVelocity;\n     }\n \n+    public double getDistance(DraggableWaypoint w1) {\n+        return Math.sqrt((w1.getX() - getX()) * (w1.getX() - getX()) + (w1.getY() - getY()) * (w1.getY() - getY()));\n+    }\n+\n     /**\n      * @return the isFirst\n      */"
  },
  {
    "sha": "b79a9b6b5afcd5c817df8c73452467910fe0cc25",
    "filename": "src/main/java/com/team319/ui/Plotter.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/TripleHelixProgramming/BobTrajectory/blob/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team319/ui/Plotter.java",
    "raw_url": "https://github.com/TripleHelixProgramming/BobTrajectory/raw/33e2443c8a921a5d219781418371cf12b5cc5280/src/main/java/com/team319/ui/Plotter.java",
    "contents_url": "https://api.github.com/repos/TripleHelixProgramming/BobTrajectory/contents/src/main/java/com/team319/ui/Plotter.java?ref=33e2443c8a921a5d219781418371cf12b5cc5280",
    "patch": "@@ -11,8 +11,8 @@\n import javax.imageio.ImageIO;\n import javax.swing.JPanel;\n \n-import com.team254.lib.trajectory.Spline;\n-import com.team254.lib.trajectory.SplineGenerator;\n+import com.team2363.spline.Spline;\n+import com.team2363.spline.SplineGenerator;\n import com.team319.trajectory.BobPath;\n \n public class Plotter extends JPanel {"
  }
]
