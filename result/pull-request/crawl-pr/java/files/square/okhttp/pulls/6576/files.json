[
  {
    "sha": "99cc3e1b92e135c6f6a86593c501cb1f4972e4fa",
    "filename": "build.gradle",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/square/okhttp/blob/bf73ea02e73a91666a7d3851ccd257057459e4f9/build.gradle",
    "raw_url": "https://github.com/square/okhttp/raw/bf73ea02e73a91666a7d3851ccd257057459e4f9/build.gradle",
    "contents_url": "https://api.github.com/repos/square/okhttp/contents/build.gradle?ref=bf73ea02e73a91666a7d3851ccd257057459e4f9",
    "patch": "@@ -154,7 +154,7 @@ subprojects { project ->\n     }\n   } else if (platform == \"conscrypt\") {\n     dependencies {\n-      testRuntime \"org.conscrypt:conscrypt-openjdk-uber:${versions.conscrypt}\"\n+      testRuntime \"org.conscrypt:conscrypt-openjdk-uber:${Versions.conscrypt}\"\n     }\n   } else if (platform == \"openjsse\") {\n     dependencies {"
  },
  {
    "sha": "8394308b20ed73414b3c7aa3fd3f4152a4b8e7aa",
    "filename": "okhttp/src/test/java/okhttp3/ConscryptTest.kt",
    "status": "modified",
    "additions": 100,
    "deletions": 3,
    "changes": 103,
    "blob_url": "https://github.com/square/okhttp/blob/bf73ea02e73a91666a7d3851ccd257057459e4f9/okhttp/src/test/java/okhttp3/ConscryptTest.kt",
    "raw_url": "https://github.com/square/okhttp/raw/bf73ea02e73a91666a7d3851ccd257057459e4f9/okhttp/src/test/java/okhttp3/ConscryptTest.kt",
    "contents_url": "https://api.github.com/repos/square/okhttp/contents/okhttp/src/test/java/okhttp3/ConscryptTest.kt?ref=bf73ea02e73a91666a7d3851ccd257057459e4f9",
    "patch": "@@ -15,34 +15,129 @@\n  */\n package okhttp3\n \n+import mockwebserver3.MockResponse\n+import mockwebserver3.MockWebServer\n import okhttp3.TestUtil.assumeNetwork\n import okhttp3.internal.platform.ConscryptPlatform\n import okhttp3.internal.platform.Platform\n import okhttp3.testing.PlatformRule\n+import okhttp3.tls.internal.TlsUtil\n+import okio.ByteString.Companion.toByteString\n import org.assertj.core.api.Assertions.assertThat\n import org.conscrypt.Conscrypt\n+import org.junit.jupiter.api.Assertions.assertEquals\n import org.junit.jupiter.api.Assertions.assertFalse\n import org.junit.jupiter.api.Assertions.assertTrue\n import org.junit.jupiter.api.BeforeEach\n import org.junit.jupiter.api.Disabled\n import org.junit.jupiter.api.Test\n import org.junit.jupiter.api.extension.RegisterExtension\n+import org.junit.jupiter.params.ParameterizedTest\n+import org.junit.jupiter.params.provider.ValueSource\n+import javax.net.ssl.SSLSocket\n \n class ConscryptTest {\n   @JvmField @RegisterExtension val platform = PlatformRule.conscrypt()\n   @JvmField @RegisterExtension val clientTestRule = OkHttpClientTestRule()\n \n-  private val client = clientTestRule.newClient()\n+  private var client = clientTestRule.newClient()\n \n-  @BeforeEach fun setUp() {\n+  private val handshakeCertificates = TlsUtil.localhost()\n+\n+  private lateinit var server: MockWebServer\n+\n+  @BeforeEach @Throws(Exception::class) fun setUp(server: MockWebServer) {\n     platform.assumeConscrypt()\n+    this.server = server\n+  }\n+\n+  private fun enableTls() {\n+    client = client.newBuilder()\n+      .sslSocketFactory(\n+        handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager\n+      )\n+      .build()\n+    server.useHttps(handshakeCertificates.sslSocketFactory(), false)\n   }\n \n   @Test\n   fun testTrustManager() {\n     assertThat(Conscrypt.isConscrypt(Platform.get().platformTrustManager())).isTrue()\n   }\n \n+  @ParameterizedTest(name = \"{displayName}({arguments})\")\n+  @ValueSource(strings = [\"TLSv1.2\", \"TLSv1.3\"])\n+  fun testSessionReuse(tlsVersion: String) {\n+    val sessionIds = mutableListOf<String>()\n+\n+    enableTls()\n+\n+    val tlsVersion = TlsVersion.forJavaName(tlsVersion)\n+    val spec = ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)\n+      .tlsVersions(tlsVersion)\n+      .build()\n+\n+    var reuseSession = false\n+\n+    val sslContext = handshakeCertificates.sslContext()\n+    val systemSslSocketFactory = sslContext.socketFactory\n+    val sslSocketFactory = object : DelegatingSSLSocketFactory(systemSslSocketFactory) {\n+      override fun configureSocket(sslSocket: SSLSocket): SSLSocket {\n+        return sslSocket.apply {\n+          if (reuseSession) {\n+            this.enableSessionCreation = false\n+          }\n+        }\n+      }\n+    }\n+\n+    client = client.newBuilder().connectionSpecs(listOf(spec))\n+      .eventListenerFactory(clientTestRule.wrap(object : EventListener() {\n+        override fun connectionAcquired(call: Call, connection: Connection) {\n+          val sslSocket = connection.socket() as SSLSocket\n+\n+          sessionIds.add(sslSocket.session.id.toByteString().hex())\n+        }\n+      }))\n+      .sslSocketFactory(sslSocketFactory, handshakeCertificates.trustManager)\n+      .build()\n+\n+    server.enqueue(MockResponse().setBody(\"abc1\"))\n+    server.enqueue(MockResponse().setBody(\"abc2\"))\n+\n+    val request = Request.Builder().url(server.url(\"/\")).build()\n+\n+    client.newCall(request).execute().use { response ->\n+      assertEquals(200, response.code)\n+    }\n+\n+    client.connectionPool.evictAll()\n+    assertEquals(0, client.connectionPool.connectionCount())\n+\n+    // Force reuse\n+    reuseSession = true\n+\n+    client.newCall(request).execute().use { response ->\n+      assertEquals(200, response.code)\n+    }\n+\n+    assertEquals(2, sessionIds.size)\n+    val directSessionIds =\n+      sslContext.clientSessionContext.ids.toList().map { it.toByteString().hex() }\n+    if (tlsVersion == TlsVersion.TLS_1_3) {\n+      assertThat(sessionIds[0]).isBlank()\n+      assertThat(sessionIds[1]).isBlank()\n+\n+      // https://github.com/google/conscrypt/issues/985\n+      // assertThat(directSessionIds).containsExactlyInAnyOrder(sessionIds[0], sessionIds[1])\n+    } else {\n+      assertThat(sessionIds[0]).isNotBlank()\n+      assertThat(sessionIds[1]).isNotBlank()\n+\n+      assertThat(directSessionIds).containsExactlyInAnyOrder(sessionIds[1])\n+    }\n+  }\n+\n   @Test\n   @Disabled\n   fun testMozilla() {\n@@ -86,7 +181,9 @@ class ConscryptTest {\n     assertTrue(ConscryptPlatform.atLeastVersion(version.major()))\n     assertTrue(ConscryptPlatform.atLeastVersion(version.major(), version.minor()))\n     assertTrue(ConscryptPlatform.atLeastVersion(version.major(), version.minor(), version.patch()))\n-    assertFalse(ConscryptPlatform.atLeastVersion(version.major(), version.minor(), version.patch() + 1))\n+    assertFalse(\n+      ConscryptPlatform.atLeastVersion(version.major(), version.minor(), version.patch() + 1)\n+    )\n     assertFalse(ConscryptPlatform.atLeastVersion(version.major(), version.minor() + 1))\n     assertFalse(ConscryptPlatform.atLeastVersion(version.major() + 1))\n   }"
  },
  {
    "sha": "1cbaf50bbe52e25dd5062e7f392ba7dc54926af5",
    "filename": "okhttp/src/test/java/okhttp3/JSSETest.kt",
    "status": "added",
    "additions": 217,
    "deletions": 0,
    "changes": 217,
    "blob_url": "https://github.com/square/okhttp/blob/bf73ea02e73a91666a7d3851ccd257057459e4f9/okhttp/src/test/java/okhttp3/JSSETest.kt",
    "raw_url": "https://github.com/square/okhttp/raw/bf73ea02e73a91666a7d3851ccd257057459e4f9/okhttp/src/test/java/okhttp3/JSSETest.kt",
    "contents_url": "https://api.github.com/repos/square/okhttp/contents/okhttp/src/test/java/okhttp3/JSSETest.kt?ref=bf73ea02e73a91666a7d3851ccd257057459e4f9",
    "patch": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (C) 2019 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package okhttp3\n+\n+import mockwebserver3.MockResponse\n+import mockwebserver3.MockWebServer\n+import okhttp3.TestUtil.assumeNetwork\n+import okhttp3.internal.platform.OpenJSSEPlatform\n+import okhttp3.testing.Flaky\n+import okhttp3.testing.PlatformRule\n+import okhttp3.tls.internal.TlsUtil\n+import okio.ByteString.Companion.toByteString\n+import org.assertj.core.api.Assertions.assertThat\n+import org.junit.jupiter.api.Assertions.assertEquals\n+import org.junit.jupiter.api.Assertions.assertNotEquals\n+import org.junit.jupiter.api.BeforeEach\n+import org.junit.jupiter.api.Disabled\n+import org.junit.jupiter.api.Test\n+import org.junit.jupiter.api.extension.RegisterExtension\n+import org.junit.jupiter.params.ParameterizedTest\n+import org.junit.jupiter.params.provider.ValueSource\n+import javax.net.ssl.SSLSocket\n+import javax.net.ssl.SSLSocketFactory\n+\n+class JSSETest(\n+  val server: MockWebServer\n+) {\n+  @JvmField @RegisterExtension var platform = PlatformRule()\n+  @JvmField @RegisterExtension val clientTestRule = OkHttpClientTestRule()\n+\n+  private val handshakeCertificates = TlsUtil.localhost()\n+\n+  var client = clientTestRule.newClient()\n+\n+  @BeforeEach\n+  fun setUp() {\n+    // Default after JDK 14, but we are avoiding tests that assume special setup.\n+    // System.setProperty(\"jdk.tls.client.enableSessionTicketExtension\", \"true\")\n+    // System.setProperty(\"jdk.tls.server.enableSessionTicketExtension\", \"true\")\n+\n+    platform.assumeJdk9()\n+  }\n+\n+  @Test\n+  fun testTlsv13Works() {\n+    // https://docs.oracle.com/en/java/javase/14/security/java-secure-socket-extension-jsse-reference-guide.html\n+    // TODO test jdk.tls.client.enableSessionTicketExtension\n+    // TODO check debugging information\n+\n+    enableTls()\n+\n+    server.enqueue(MockResponse().setBody(\"abc\"))\n+\n+    val request = Request.Builder().url(server.url(\"/\")).build()\n+\n+    val response = client.newCall(request).execute()\n+\n+    response.use {\n+      assertEquals(200, response.code)\n+      assertEquals(TlsVersion.TLS_1_3, response.handshake?.tlsVersion)\n+      assertEquals(Protocol.HTTP_2, response.protocol)\n+\n+      assertThat(response.exchange!!.connection.socket().javaClass.name).isEqualTo(\n+        \"sun.security.ssl.SSLSocketImpl\"\n+      )\n+    }\n+  }\n+\n+  @Test\n+  fun testSupportedProtocols() {\n+    val factory = SSLSocketFactory.getDefault()\n+    assertThat(factory.javaClass.name).isEqualTo(\"sun.security.ssl.SSLSocketFactoryImpl\")\n+    val s = factory.createSocket() as SSLSocket\n+\n+    assertEquals(listOf(\"TLSv1.3\", \"TLSv1.2\", \"TLSv1.1\", \"TLSv1\"), s.enabledProtocols.toList())\n+  }\n+\n+  @Test\n+  @Disabled\n+  fun testFacebook() {\n+    val sessionIds = mutableListOf<String>()\n+\n+    assumeNetwork()\n+\n+    client = client.newBuilder()\n+      .eventListenerFactory(clientTestRule.wrap(object : EventListener() {\n+        override fun connectionAcquired(call: Call, connection: Connection) {\n+          val sslSocket = connection.socket() as SSLSocket\n+\n+          sessionIds.add(sslSocket.session.id.toByteString().hex())\n+        }\n+      }))\n+      .build()\n+\n+    val request = Request.Builder().url(\"https://facebook.com/robots.txt\").build()\n+\n+    client.newCall(request).execute().use {\n+      assertThat(it.protocol).isEqualTo(Protocol.HTTP_2)\n+      assertThat(it.handshake!!.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)\n+    }\n+\n+    client.connectionPool.evictAll()\n+    assertEquals(0, client.connectionPool.connectionCount())\n+\n+    client.newCall(request).execute().use {\n+      assertThat(it.protocol).isEqualTo(Protocol.HTTP_2)\n+      assertThat(it.handshake!!.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)\n+    }\n+\n+    assertEquals(2, sessionIds.size)\n+    assertNotEquals(sessionIds[0], sessionIds[1])\n+    assertThat(sessionIds[0]).isNotBlank()\n+  }\n+\n+  @Test\n+  fun testBuildIfSupported() {\n+    val actual = OpenJSSEPlatform.buildIfSupported()\n+    assertThat(actual).isNotNull\n+  }\n+\n+  @ParameterizedTest(name = \"{displayName}({arguments})\")\n+  @ValueSource(strings = [\"TLSv1.2\", \"TLSv1.3\"])\n+  @Flaky\n+  fun testSessionReuse(tlsVersion: String) {\n+    val sessionIds = mutableListOf<String>()\n+\n+    enableTls()\n+\n+    val tlsVersion = TlsVersion.forJavaName(tlsVersion)\n+    val spec = ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)\n+      .tlsVersions(tlsVersion)\n+      .build()\n+\n+    var reuseSession = false\n+\n+    val sslContext = handshakeCertificates.sslContext()\n+    val systemSslSocketFactory = sslContext.socketFactory\n+    val sslSocketFactory = object : DelegatingSSLSocketFactory(systemSslSocketFactory) {\n+      override fun configureSocket(sslSocket: SSLSocket): SSLSocket {\n+        return sslSocket.apply {\n+          if (reuseSession) {\n+            this.enableSessionCreation = false\n+          }\n+        }\n+      }\n+    }\n+\n+    client = client.newBuilder()\n+      .connectionSpecs(listOf(spec))\n+      .eventListenerFactory(clientTestRule.wrap(object : EventListener() {\n+        override fun connectionAcquired(call: Call, connection: Connection) {\n+          val sslSocket = connection.socket() as SSLSocket\n+\n+          sessionIds.add(sslSocket.session.id.toByteString().hex())\n+        }\n+      }))\n+      .sslSocketFactory(sslSocketFactory, handshakeCertificates.trustManager)\n+      .build()\n+\n+    server.enqueue(MockResponse().setBody(\"abc1\"))\n+    server.enqueue(MockResponse().setBody(\"abc2\"))\n+\n+    val request = Request.Builder().url(server.url(\"/\")).build()\n+\n+    client.newCall(request).execute().use { response ->\n+      assertEquals(200, response.code)\n+    }\n+\n+    client.connectionPool.evictAll()\n+    assertEquals(0, client.connectionPool.connectionCount())\n+\n+    // Force reuse. This appears flaky (30% of the time) even though sessions are reused.\n+    // javax.net.ssl.SSLHandshakeException: No new session is allowed and no existing\n+    // session can be resumed\n+    // TODO: raise JDK bug.\n+    // reuseSession = true\n+\n+    client.newCall(request).execute().use { response ->\n+      assertEquals(200, response.code)\n+    }\n+\n+    assertEquals(2, sessionIds.size)\n+    val directSessionIds =\n+      sslContext.clientSessionContext.ids.toList().map { it.toByteString().hex() }\n+    if (tlsVersion == TlsVersion.TLS_1_3) {\n+      // We can't rely on the same session id with TLSv1.3 ids.\n+      assertNotEquals(sessionIds[0], sessionIds[1])\n+    } else {\n+      // With TLSv1.2 it is really JDK specific.\n+      assertEquals(sessionIds[0], sessionIds[1])\n+      assertThat(directSessionIds).contains(sessionIds[0], sessionIds[1])\n+    }\n+    assertThat(sessionIds[0]).isNotBlank()\n+  }\n+\n+  private fun enableTls() {\n+    client = client.newBuilder()\n+      .sslSocketFactory(\n+        handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager\n+      )\n+      .build()\n+    server.useHttps(handshakeCertificates.sslSocketFactory(), false)\n+  }\n+}"
  }
]
