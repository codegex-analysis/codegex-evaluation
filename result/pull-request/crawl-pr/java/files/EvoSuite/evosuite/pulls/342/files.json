[
  {
    "sha": "b91038af1344b348a60b2b45a3308758ccb18f15",
    "filename": "client/src/main/java/org/evosuite/Properties.java",
    "status": "modified",
    "additions": 8,
    "deletions": 3,
    "changes": 11,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/Properties.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/Properties.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/Properties.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -455,8 +455,8 @@\n \tpublic static String CURRENT_TARGET_METHOD = \"\";\n \n     // NOTE: by default we use the sage implementation of the algorithm\n-\t@Parameter(key = \"dse_algorithm\", group = \"DSE\", description = \"Type of DSE algorithm to use.\")\n-\tpublic static DSEAlgorithms DSE_ALGORITHM_TYPE = DSEAlgorithms.SAGE;\n+\t@Parameter(key = \"dse_exploration_algorithm\", group = \"DSE\", description = \"Type of DSE algorithm to use.\")\n+\tpublic static DSEAlgorithms DSE_EXPLORATION_ALGORITHM_TYPE = DSEAlgorithms.GENERATIONAL_SEARCH;\n \n \t@Parameter(key = \"local_search_dse\", group = \"DSE\", description = \"Granularity of DSE application\")\n \tpublic static DSEType LOCAL_SEARCH_DSE = DSEType.TEST;\n@@ -481,9 +481,14 @@\n \tpublic enum DSEStoppingConditionCriterion {\n \t\tTARGETCOVERAGE,\n \t\tMAXTIME, /** In seconds */\n-    \tZEROFITNESS\n+    \tZEROFITNESS,\n+\t\tMAXTESTS,\n+\t\tDEFAULTS /** The ones that are setted by default on the algorithm + Strategy */\n \t}\n \n+\t@Parameter(key = \"dse_stopping_condition\", group = \"DSE\", description = \"Indicate which stopping condition to use.\")\n+\tpublic static DSEStoppingConditionCriterion DSE_STOPPING_CONDITION = DSEStoppingConditionCriterion.DEFAULTS;\n+\n \t@Parameter(key = \"bytecode_logging_enabled\", group = \"DSE\", description = \"Indicates whether bytecode instructions that are being executed should be logged.\")\n \tpublic static boolean BYTECODE_LOGGING_ENABLED = false;\n "
  },
  {
    "sha": "6e54071b2d8b4f21132878e9c71dd81d5ec3fb3f",
    "filename": "client/src/main/java/org/evosuite/symbolic/PathConditionUtils.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/PathConditionUtils.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/PathConditionUtils.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/PathConditionUtils.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -160,7 +160,7 @@ public static boolean hasPathConditionDiverged(PathCondition expectedPrefixPathC\n \t\t\tBranchCondition newBranchCondition = newBranchConditions.get(currentBranchConditionIndex);\n \n \t\t\t// if the expected prefix path is not a prefix of the new one, there's a divergence\n-\t\t\tif (!expectedPrefixBranchCondition.equals(newBranchCondition)) {\n+\t\t\tif (!expectedPrefixBranchCondition.getConstraint().equals(newBranchCondition.getConstraint())) {\n \t\t\t\treturn true;\n \t\t\t}\n \t\t}"
  },
  {
    "sha": "7db0e435960bd97894559dabf298e96e549ce8cd",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/DSELegacyAlgorithm.java",
    "status": "modified",
    "additions": 8,
    "deletions": 1,
    "changes": 9,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/DSELegacyAlgorithm.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/DSELegacyAlgorithm.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/DSELegacyAlgorithm.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -12,6 +12,7 @@\n import org.evosuite.symbolic.expr.bv.IntegerVariable;\n import org.evosuite.symbolic.expr.constraint.IntegerConstraint;\n import org.evosuite.symbolic.expr.fp.RealVariable;\n+import org.evosuite.symbolic.expr.ref.array.ArrayVariable;\n import org.evosuite.symbolic.expr.str.StringVariable;\n import org.evosuite.symbolic.solver.SolverResult;\n import org.evosuite.symbolic.solver.SolverUtils;\n@@ -40,7 +41,11 @@\n \n /**\n  * This class implements a DSE algorithm *as* a subclass of genetic algorithm.\n- * \n+ *\n+ * Note (ilebrero): not working properly when using MAXTestsStoppingCondition. Recalculating the hole test suite\n+ *                    fitness adds an extra count besides the concolic engine execution case,\n+ *                    (see {@link org.evosuite.ga.stoppingconditions.MaxTestsStoppingCondition#testExecuted()} uses).\n+ *\n  * @author jgaleotti\n  */\n public class DSELegacyAlgorithm extends GeneticAlgorithm<TestSuiteChromosome> {\n@@ -266,6 +271,8 @@ private boolean shouldSkipCurrentConstraintSet(HashSet<Set<Constraint<?>>> pathC\n         // skip\n       } else if (variable instanceof StringVariable) {\n         // skip\n+      } else if (variable instanceof ArrayVariable) {\n+        // skip\n       } else {\n         throw new UnsupportedOperationException(\n             \"Unknown variable type \" + variable.getClass().getName());"
  },
  {
    "sha": "c58e7077e1872803b15f22e183447a09129e2a6b",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/DSEStrategy.java",
    "status": "modified",
    "additions": 19,
    "deletions": 12,
    "changes": 31,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/DSEStrategy.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/DSEStrategy.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/DSEStrategy.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -71,7 +71,7 @@\n \t@Override\n \tpublic TestSuiteChromosome generateTests() {\n \t\tLoggingUtils.getEvoLogger().info(SETTING_UP_DSE_GENERATION_INFO_MESSAGE);\n-\t\tProperties.CRITERION = Properties.DSE_ALGORITHM_TYPE.getCriteria();\n+\t\tProperties.CRITERION = Properties.DSE_EXPLORATION_ALGORITHM_TYPE.getCriteria();\n \t\tCriterion[] criterion = Properties.CRITERION;\n \n \t\tlong startTime = System.currentTimeMillis() / 1000;\n@@ -112,7 +112,7 @@ public TestSuiteChromosome generateTests() {\n \t\t\t\tTestGenerationResultBuilder.getInstance().setDSEAlgorithm(algorithm);\n \t\t\t}\n \t\t} else {\n-\t\t\ttestSuite = setNoGoalsCoverage(Properties.DSE_ALGORITHM_TYPE);\n+\t\t\ttestSuite = setNoGoalsCoverage(Properties.DSE_EXPLORATION_ALGORITHM_TYPE);\n \t\t}\n \n \t\tlong endTime = System.currentTimeMillis() / 1000;\n@@ -161,24 +161,31 @@ private void logDSEEngineEnabledFeatures() {\n \n \tprivate ExplorationAlgorithm buildDSEAlgorithm() {\n \t\tDSEAlgorithmFactory dseFactory = new DSEAlgorithmFactory();\n-\t\tDSEAlgorithms dseAlgorithmType = Properties.DSE_ALGORITHM_TYPE;\n+\t\tDSEAlgorithms dseAlgorithmType = Properties.DSE_EXPLORATION_ALGORITHM_TYPE;\n \n \t\tLoggingUtils.getEvoLogger().info(USING_DSE_ALGORITHM, dseAlgorithmType.getName());\n \t\tExplorationAlgorithm algorithm = dseFactory.getDSEAlgorithm(dseAlgorithmType);\n \n-\t\t/** Default conditions */\n-\t\tfor (Properties.DSEStoppingConditionCriterion condition : defaultStoppingConditions) {\n-\t\t\talgorithm.addStoppingCondition(StoppingConditionFactory.getStoppingCondition(condition));\n+\t\tif (Properties.DSE_STOPPING_CONDITION.equals(Properties.DSEStoppingConditionCriterion.DEFAULTS)) {\n+\t\t\t/** Default conditions */\n+\t\t\tfor (Properties.DSEStoppingConditionCriterion condition : defaultStoppingConditions) {\n+\t\t\t\talgorithm.addStoppingCondition(StoppingConditionFactory.getStoppingCondition(condition));\n+\t\t\t}\n+\n+\t\t\t/** Stopping conditions */\n+\t\t\tfor (Properties.DSEStoppingConditionCriterion stoppingConditionCriterion : dseAlgorithmType.getStoppingConditionCriterions()) {\n+\t\t\t\talgorithm.addStoppingCondition(StoppingConditionFactory.getStoppingCondition(stoppingConditionCriterion));\n+\t\t\t}\n+\t\t} else {\n+\t\t\t/** User chosen Stopping Condition */\n+\t\t\talgorithm.addStoppingCondition(StoppingConditionFactory.getStoppingCondition(Properties.DSE_STOPPING_CONDITION));\n \t\t}\n \n+\n \t\t/** Fitness functions */\n-\t\tList<TestSuiteFitnessFunction> sageFitnessFunctions = FitnessFunctionsUtils.getFitnessFunctions(dseAlgorithmType.getCriteria());\n-\t\talgorithm.addFitnessFunctions(sageFitnessFunctions);\n+\t\tList<TestSuiteFitnessFunction> fitnessFunctions = FitnessFunctionsUtils.getFitnessFunctions(dseAlgorithmType.getCriteria());\n+\t\talgorithm.addFitnessFunctions(fitnessFunctions);\n \n-\t\t/** Stopping conditions */\n-\t\tfor (Properties.DSEStoppingConditionCriterion stoppingConditionCriterion : dseAlgorithmType.getStoppingConditionCriterions()) {\n-\t\t\talgorithm.addStoppingCondition(StoppingConditionFactory.getStoppingCondition(stoppingConditionCriterion));\n-\t\t}\n \n \t\tLoggingUtils.getEvoLogger().debug(WITH_TIMEOUT, Properties.GLOBAL_TIMEOUT);\n \t\tLoggingUtils.getEvoLogger().debug(WITH_TARGET_COVERAGE, Properties.DSE_TARGET_COVERAGE);"
  },
  {
    "sha": "d1649fd08bc7462a4d018e90c0e9b230ca4feba0",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/DSEAlgorithmFactory.java",
    "status": "modified",
    "additions": 6,
    "deletions": 3,
    "changes": 9,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/DSEAlgorithmFactory.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/DSEAlgorithmFactory.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/DSEAlgorithmFactory.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -21,6 +21,7 @@\n \n import org.evosuite.Properties;\n import org.evosuite.symbolic.dse.DSEStatistics;\n+import org.evosuite.symbolic.dse.algorithm.explorationalgorithms.DFSExplorationAlgorithm;\n import org.evosuite.symbolic.dse.algorithm.explorationalgorithms.SAGEExplorationAlgorithm;\n \n /**\n@@ -30,7 +31,7 @@\n  */\n public class DSEAlgorithmFactory {\n     public static final String DSE_ALGORITHM_TYPE_NOT_PROVIDED   = \"A DSE algorithm type must be provided\";\n-    public static final String DSE_ALGORITHM_NOT_YET_IMPLEMENTED = \"DSEAlgorithm not yet implemented: \";\n+    public static final String DSE_EXPLORATION_ALGORITHM_NOT_YET_IMPLEMENTED = \"DSE exploration algorithm not yet implemented: \";\n \n     /** Statistics object for when creating a customized algorithm */\n     private final DSEStatistics dseStatistics = DSEStatistics.getInstance();\n@@ -44,10 +45,12 @@ public ExplorationAlgorithm getDSEAlgorithm(DSEAlgorithms dseAlgorithmType) {\n         }\n \n         switch (dseAlgorithmType) {\n-            case SAGE:\n+            case GENERATIONAL_SEARCH:\n                 return new SAGEExplorationAlgorithm(dseStatistics, showProgress);\n+            case DFS:\n+                return new DFSExplorationAlgorithm(dseStatistics, showProgress);\n             default:\n-                throw new IllegalStateException(DSE_ALGORITHM_NOT_YET_IMPLEMENTED + dseAlgorithmType.name());\n+                throw new IllegalStateException(DSE_EXPLORATION_ALGORITHM_NOT_YET_IMPLEMENTED + dseAlgorithmType.name());\n         }\n     }\n }"
  },
  {
    "sha": "b4d26df485d2bee987da08632fbe18862c7dad0d",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/DSEAlgorithms.java",
    "status": "modified",
    "additions": 5,
    "deletions": 1,
    "changes": 6,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/DSEAlgorithms.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/DSEAlgorithms.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/DSEAlgorithms.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -28,9 +28,13 @@\n  * @author ignacio lebrero\n  */\n public enum DSEAlgorithms {\n-    SAGE(\"SAGE\",\n+    GENERATIONAL_SEARCH(\"GENERATIONAL_SEARCH\",\n       \"Based on generational search in Automated Whitebox Fuzz Testing, Godefroid, Levin, Molnar\",\n       new Properties.Criterion[]{Properties.Criterion.BRANCH},\n+      new Properties.DSEStoppingConditionCriterion[]{}),\n+    DFS(\"DFS\",\n+      \"Based on the classic DFS exploration (See Baldoni et. al., A Survey of Symbolic Execution Techniques.)\",\n+      new Properties.Criterion[]{Properties.Criterion.BRANCH},\n       new Properties.DSEStoppingConditionCriterion[]{});\n \n     private String name;"
  },
  {
    "sha": "9b3a1e3f0979dfabbd250be86d85c444fe80b3c5",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/ExplorationAlgorithm.java",
    "status": "modified",
    "additions": 86,
    "deletions": 18,
    "changes": 104,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/ExplorationAlgorithm.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/ExplorationAlgorithm.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/ExplorationAlgorithm.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -27,12 +27,12 @@\n import org.evosuite.symbolic.dse.ConcolicExecutorImpl;\n import org.evosuite.symbolic.dse.DSEStatistics;\n import org.evosuite.symbolic.dse.DSETestCase;\n+import org.evosuite.symbolic.dse.algorithm.strategies.CachingStrategy;\n import org.evosuite.symbolic.dse.algorithm.strategies.KeepSearchingCriteriaStrategy;\n import org.evosuite.symbolic.dse.algorithm.strategies.PathExtensionStrategy;\n-import org.evosuite.symbolic.dse.algorithm.strategies.CachingStrategy;\n-import org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathPruningStrategies.CacheQueryResult;\n import org.evosuite.symbolic.dse.algorithm.strategies.TestCaseBuildingStrategy;\n import org.evosuite.symbolic.dse.algorithm.strategies.TestCaseSelectionStrategy;\n+import org.evosuite.symbolic.dse.algorithm.strategies.implementations.CachingStrategies.CacheQueryResult;\n import org.evosuite.symbolic.expr.Constraint;\n import org.evosuite.symbolic.solver.Solver;\n import org.evosuite.symbolic.solver.SolverEmptyQueryException;\n@@ -59,10 +59,10 @@\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.PriorityQueue;\n+import java.util.Queue;\n import java.util.Set;\n \n-  /**\n+/**\n    * Structure of a DSE Exploration algorithm,\n    *\n    * Current implementation represents an abstracted version of SAGE's generational algorithm.\n@@ -81,17 +81,22 @@\n      **/\n \n     // Solver\n+    public static final String CACHE_CALL_MISSED                       = \"Cache call missed\";\n+    public static final String CACHE_CALL_HIT_SAT                      = \"cache call hit sat\";\n+    public static final String CACHE_CALL_HIT_UNSAT                    = \"cache call hit unsat\";\n     public static final String SOLVER_ERROR_DEBUG_MESSAGE              = \"Solver threw an exception when running: {}\";\n     public static final String SOLVER_QUERY_STARTED_MESSAGE            = \"Solving query with {} constraints\";\n     public static final String SOLVER_SOLUTION_DEBUG_MESSAGE           = \"solver found solution {}\";\n+    public static final String SOLVING_QUERY_WITH_CONSTRAINTS          = \"Solving query with {} constraints\";\n     public static final String SOLVER_OUTCOME_NULL_DEBUG_MESSAGE       = \"Solver outcome is null (probably failure/unknown/timeout)\";\n     public static final String SOLVER_OUTCOME_IS_SAT_DEBUG_MESSAGE     = \"query is SAT (solution found)\";\n     public static final String SOLVER_OUTCOME_IS_UNSAT_DEBUG_MESSAGE   = \"query is UNSAT (no solution found)\";\n     public static final String SOLVING_CURRENT_SMT_QUERY_DEBUG_MESSAGE = \"* Solving current SMT query\";\n \n     // Concolic Engine\n-    public static final String FINISHED_CONCOLIC_EXECUTION_DEBUG_MESSAGE                  = \"* Finished concolic execution.\";\n-    public static final String EXECUTING_CONCOLICALLY_THE_CURRENT_TEST_CASE_DEBUG_MESSAGE = \"* Executing concolically the current test case\";\n+    public static final String PATH_CONDITION_COLLECTED_SIZE                              = \"Path condition collected with: {} branches\";\n+    public static final String FINISHED_CONCOLIC_EXECUTION_DEBUG_MESSAGE                  = \"Finished concolic execution.\";\n+    public static final String EXECUTING_CONCOLICALLY_THE_CURRENT_TEST_CASE_DEBUG_MESSAGE = \"Starting concolic execution of test case: {}\";\n \n     // TestCase generation\n     public static final String NEW_TEST_CASE_SCORE_DEBUG_MESSAGE   = \"New test case score: {}\";\n@@ -100,12 +105,19 @@\n     // Exploration Algorithm\n     public static final String PROGRESS_MSG_INFO                                             = \"Total progress: {}\";\n     public static final String STRATEGY_CANNOT_BE_NULL                                       = \"Strategy cannot be null\";\n+    public static final String NUMBER_OF_SEEN_PATH_CONDITIONS = \"Number of seen path condition: {}\";\n     public static final String ENTRY_POINTS_FOUND_DEBUG_MESSAGE                              = \"Found {} as entry points for DSE\";\n     public static final String STOPPING_CONDITION_MET_DEBUG_MESSAGE                          = \"A stopping condition was met. No more tests can be generated using DSE.\";\n     public static final String GENERATING_TESTS_FOR_ENTRY_DEBUG_MESSAGE                      = \"Generating tests for entry method: {}\";\n-    public static final String TESTS_WERE_GENERATED_FOR_ENTRY_METHOD_DEBUG_MESSAGE           = \"{} tests were generated for entry method {}\";\n+    public static final String TESTS_WERE_GENERATED_FOR_ENTRY_METHOD_DEBUG_MESSAGE           = \"DSE test generation finished. Generated {} test for method {}.\";\n     public static final String EXPLORATION_STRATEGIES_MUST_BE_INITIALIZED_TO_START_SEARCHING = \"Exploration strategies must be initialized to start searching.\";\n \n+    // Path Pruning\n+    public static final String PATH_PRUNING_SINCE_IT_IS_IN_THE_QUERY_CACHE                                                   = \"skipping exploring current child since it is in the query cache\";\n+    public static final String PATH_PRUNING_BECAUSE_THE_PATH_CONDITION_WAS_ALREADY_EXPLORED                                  = \"skipping exploring current child because the path condition was already explored\";\n+    public static final String PATH_PRUNING_BECAUSE_IT_IS_SATISFIABLE_AND_SOLVED_BY_PREVIOUS_PATH_CONDITION                  = \"skipping exploring current child because it is satisfiable and solved by previous path condition\";\n+    public static final String PATH_PRUNING_BECAUSE_IT_IS_SATISFIABLE_AND_WAS_SOLVED_BY_A_PREVIOUSLY_EXPLORED_PATH_CONDITION = \"skipping exploring current child because it is satisfiable and was solved by a previously explored path condition\";\n+\n     /**\n      * A cache of previous results from the constraint solver\n      **/\n@@ -195,9 +207,10 @@ public void setKeepSearchingCriteriaStrategy(KeepSearchingCriteriaStrategy keepS\n      @Override\n      public TestSuiteChromosome explore() {\n          if (!strategiesInitialized()) throw new DSEExplorationException(EXPLORATION_STRATEGIES_MUST_BE_INITIALIZED_TO_START_SEARCHING);\n+\n          notifyGenerationStarted();\n-         final Class<?> targetClass = Properties.getTargetClassAndDontInitialise();\n \n+         final Class<?> targetClass = Properties.getTargetClassAndDontInitialise();\n          List<Method> targetStaticMethods = ClassUtil.getTargetClassStaticMethods(targetClass);\n          Collections.sort(targetStaticMethods, new MethodComparator());\n          logger.debug(ENTRY_POINTS_FOUND_DEBUG_MESSAGE, targetStaticMethods.size());\n@@ -216,7 +229,7 @@ public TestSuiteChromosome explore() {\n \n              explore(entryMethod);\n              int numOfGeneratedTestCases = testSuite.getTests().size() - testCaseCount;\n-             logger.debug(TESTS_WERE_GENERATED_FOR_ENTRY_METHOD_DEBUG_MESSAGE, numOfGeneratedTestCases, entryMethod.getName());\n+             LoggingUtils.getEvoLogger().info(\"* \" + TESTS_WERE_GENERATED_FOR_ENTRY_METHOD_DEBUG_MESSAGE, numOfGeneratedTestCases, entryMethod.getName());\n          }\n \n          // Run this before finish\n@@ -237,28 +250,27 @@ protected void explore(Method method) {\n         HashSet<Set<Constraint<?>>> seenChildren = new HashSet();\n \n         // WorkList\n-        PriorityQueue<DSETestCase> testCasesWorkList = new PriorityQueue<>();\n+        Queue<DSETestCase> testCasesWorkList = createWorkList();\n \n         // Initial element\n         DSETestCase initialTestCase = testCaseBuildingStrategy.buildInitialTestCase(method);\n \n         // Run & check\n         testCasesWorkList.add(initialTestCase);\n+        addNewTestCaseToTestSuite(initialTestCase);\n \n         while (keepSearchingCriteriaStrategy.ShouldKeepSearching(testCasesWorkList)) {\n             // This gets wrapped into the building and fitness strategy selected due to the PriorityQueue sorting nature\n             DSETestCase currentTestCase = testCaseSelectionStrategy.getCurrentIterationBasedTestCase(testCasesWorkList);\n \n-            // NOTE: We consider Adding a testCase an iteration\n-            addNewTestCaseToTestSuite(currentTestCase);\n-            notifyIteration();\n-\n             // After iteration checks and logs\n             if (showProgress) logger.info(PROGRESS_MSG_INFO, getProgress());\n             if (isFinished()) return;\n \n             // Runs the current test case\n             GenerationalSearchPathCondition currentExecutedPathCondition = executeTestCaseConcolically(currentTestCase);\n+            statisticsLogger.reportNewPathExplored();\n+            logger.debug(PATH_CONDITION_COLLECTED_SIZE, currentExecutedPathCondition.getPathCondition().size());\n \n             // Checks for a divergence\n             boolean hasPathConditionDiverged = checkPathConditionDivergence(\n@@ -274,42 +286,56 @@ protected void explore(Method method) {\n \n                 // Adds the new path condition to the already visited set\n                 seenChildren.add(normalizedPathCondition);\n+                logger.debug(NUMBER_OF_SEEN_PATH_CONDITIONS, seenChildren.size());\n \n                 // Generates the children\n                 List<GenerationalSearchPathCondition> children = pathsExpansionStrategy.generateChildren(currentExecutedPathCondition);\n \n-                processChildren(testCasesWorkList, currentTestCase, children, hasPathConditionDiverged);\n+                processChildren(testCasesWorkList, seenChildren, currentTestCase, children, hasPathConditionDiverged);\n             }\n \n         }\n     }\n \n+    /**\n+     * Work list implementation. Depends on the subjacent algorithm that want's to be created.\n+     *\n+     * @return\n+     */\n+    protected abstract Queue<DSETestCase> createWorkList();\n+\n     private boolean shouldSkipCurrentPathcondition(boolean hasPathConditionDiverged, Set<Constraint<?>> seenPathCondition, HashSet<Set<Constraint<?>>> seenChildren) {\n         return hasPathConditionDiverged && (\n             seenChildren.contains(seenPathCondition)\n               || PathConditionUtils.isConstraintSetSubSetOf(seenPathCondition, seenChildren));\n     }\n \n-    private void processChildren(PriorityQueue<DSETestCase> testCasesWorkList, DSETestCase currentTestCase, List<GenerationalSearchPathCondition> children, boolean hasPathConditionDiverged) {\n+    private void processChildren(Queue<DSETestCase> testCasesWorkList, HashSet<Set<Constraint<?>>> seenChildren, DSETestCase currentTestCase, List<GenerationalSearchPathCondition> children, boolean hasPathConditionDiverged) {\n         // We look at all the children\n         for (GenerationalSearchPathCondition child : children) {\n             List<Constraint<?>> childQuery = SolverUtils.buildQuery(child.getPathCondition());\n             Set<Constraint<?>> normalizedChildQuery = normalize(childQuery);\n \n+            if (shouldSkipChild(seenChildren, normalizedChildQuery)) continue;\n+            if (this.isFinished()) return;\n+\n             CacheQueryResult cacheQueryResult = cachingStrategy.checkCache(normalizedChildQuery, queryCache);\n \n             // Path condition previously explored and unsatisfiable\n             if (!cacheQueryResult.hitUnSat()) {\n+                logger.debug(CACHE_CALL_HIT_UNSAT);\n                 statisticsLogger.reportNewConstraints(childQuery);\n                 Map<String, Object> smtSolution;\n \n                 // Path condition already solved before\n                 if (cacheQueryResult.hitSat()) {\n+                    logger.debug(CACHE_CALL_HIT_SAT);\n                     smtSolution = cacheQueryResult.getSmtSolution();\n-\n                 } else {\n                     // Path condition not explored\n                     assert(cacheQueryResult.missed());\n+                    logger.debug(CACHE_CALL_MISSED);\n+                    logger.debug(SOLVING_QUERY_WITH_CONSTRAINTS, childQuery.size());\n \n                     childQuery.addAll(\n                       SolverUtils.createBoundsForQueryVariables(childQuery)\n@@ -333,11 +359,40 @@ private void processChildren(PriorityQueue<DSETestCase> testCasesWorkList, DSETe\n                         hasPathConditionDiverged);\n \n                     testCasesWorkList.offer(newTestCase);\n+                    addNewTestCaseToTestSuite(newTestCase);\n+\n+                    // NOTE: We consider adding a test case an iteration\n+                    notifyIteration();\n                 }\n             }\n         }\n     }\n \n+    /**\n+     * Child PC is not processed if it was already explored, this is:\n+     *     - Their constraints were already solved by a previous SMT query\n+     *     - Their constraints are the same as a previous explored PC.\n+     *\n+     * @param pathConditions\n+     * @param constraintSet\n+     * @return\n+     */\n+      private boolean shouldSkipChild(HashSet<Set<Constraint<?>>> pathConditions, Set<Constraint<?>> constraintSet) {\n+          statisticsLogger.reportNewQueryCacheCall();\n+          if (queryCache.containsKey(constraintSet)) {\n+              statisticsLogger.reportNewQueryCacheHit();\n+              logger.debug(PATH_PRUNING_SINCE_IT_IS_IN_THE_QUERY_CACHE);\n+              return true;\n+          }\n+\n+          if (pathConditions.contains(constraintSet)) {\n+              logger.debug(PATH_PRUNING_BECAUSE_THE_PATH_CONDITION_WAS_ALREADY_EXPLORED);\n+              return true;\n+          }\n+\n+          return false;\n+      }\n+\n       /**\n      * Generates a new test case from the concolic execution data.\n      *\n@@ -362,6 +417,19 @@ private DSETestCase generateNewTestCase(DSETestCase currentConcreteTest, Generat\n         return newDSETestCase;\n     }\n \n+    /**\n+     * Test Score calculation, depends on the subjacent implemented algorithm.\n+     * <p>\n+     *\n+     * TODO (ilebrero): This could be better if there was a way to run calculate the coverage of adding a new test without changng\n+     * the hole testSuite data.\n+     *\n+     * @param newTestCase\n+     * @param hasPathConditionDiverged\n+     * @return\n+     */\n+    abstract protected double getTestScore(TestCase newTestCase, boolean hasPathConditionDiverged);\n+\n     /**\n      * Analyzes the results of an smtQuery.\n      *\n@@ -450,7 +518,7 @@ private SolverResult solveQuery(List<Constraint<?>> SMTQuery) {\n      * @return\n      */\n     private GenerationalSearchPathCondition executeTestCaseConcolically(DSETestCase currentTestCase) {\n-        logger.debug(EXECUTING_CONCOLICALLY_THE_CURRENT_TEST_CASE_DEBUG_MESSAGE);\n+        logger.debug(EXECUTING_CONCOLICALLY_THE_CURRENT_TEST_CASE_DEBUG_MESSAGE, currentTestCase.getTestCase().toCode());\n \n         TestCase clonedCurrentTestCase = currentTestCase.getTestCase().clone();\n         PathCondition result = engine.execute((DefaultTestCase) clonedCurrentTestCase);"
  },
  {
    "sha": "42de3660ee4aec27376bdf4c65577d9552686da3",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/ExplorationAlgorithmBase.java",
    "status": "modified",
    "additions": 1,
    "deletions": 21,
    "changes": 22,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/ExplorationAlgorithmBase.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/ExplorationAlgorithmBase.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/ExplorationAlgorithmBase.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -297,7 +297,6 @@ protected double getProgress() {\n      */\n     protected boolean checkPathConditionDivergence(PathCondition currentPathCondition, PathCondition expectedPathCondition) {\n \t\tboolean hasPathConditionDiverged = PathConditionUtils.hasPathConditionDiverged(expectedPathCondition, currentPathCondition);\n-    \tstatisticsLogger.reportNewPathExplored();\n \n         if (hasPathConditionDiverged) {\n             logger.debug(PATH_DIVERGENCE_FOUND_WARNING_MESSAGE);\n@@ -307,32 +306,13 @@ protected boolean checkPathConditionDivergence(PathCondition currentPathConditio\n         return hasPathConditionDiverged;\n     }\n \n-\t\t/**\n-\t\t * Score calculation is based on coverage improvement against the current testSuite.\n-\t\t *\n-\t\t * TODO: This could be better if there was a way to run calculate the coverage of adding a new test without changng\n-\t\t *       the hole testSuite data.\n-\t\t *\n-\t\t * @param newTestCase\n-\t\t * @param hasPathConditionDiverged\n-\t\t * @return\n-\t\t */\n-    protected double getTestScore(TestCase newTestCase, boolean hasPathConditionDiverged) {\n-    \tif (hasPathConditionDiverged) {\n-    \t\tstatisticsLogger.reportNewTestUnuseful();\n-    \t\treturn PATH_DIVERGED_BASED_TEST_CASE_PENALTY_SCORE;\n-\t\t\t}\n-\n-    \treturn getTestCaseAdditionIncrementalCoverage(newTestCase);\n-    }\n-\n \t\t\t/**\n \t\t\t * Returns the incremental coverage of adding a test case to the current test suite.\n \t\t\t *\n \t\t\t * @param newTestCase\n \t\t\t * @return\n \t\t\t */\n-\t\t\tprivate double getTestCaseAdditionIncrementalCoverage(TestCase newTestCase) {\n+\t\t\tprotected double getTestCaseAdditionIncrementalCoverage(TestCase newTestCase) {\n \t\t\t\tdouble oldCoverage;\n \t\t\t\tdouble newCoverage;\n \t\t\t\tdouble coverageDiff;"
  },
  {
    "sha": "bbc3f066b6dbbc7e1a071ac08071098454dc77b2",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/explorationalgorithms/DFSExplorationAlgorithm.java",
    "status": "added",
    "additions": 90,
    "deletions": 0,
    "changes": 90,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/explorationalgorithms/DFSExplorationAlgorithm.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/explorationalgorithms/DFSExplorationAlgorithm.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/explorationalgorithms/DFSExplorationAlgorithm.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (C) 2010-2018 Gordon Fraser, Andrea Arcuri and EvoSuite\n+ * contributors\n+ *\n+ * This file is part of EvoSuite.\n+ *\n+ * EvoSuite is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, either version 3.0 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * EvoSuite is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with EvoSuite. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package org.evosuite.symbolic.dse.algorithm.explorationalgorithms;\n+\n+import org.evosuite.symbolic.dse.DSEStatistics;\n+import org.evosuite.symbolic.dse.DSETestCase;\n+import org.evosuite.symbolic.dse.algorithm.ExplorationAlgorithm;\n+import org.evosuite.symbolic.dse.algorithm.strategies.implementations.KeepSearchingCriteriaStrategies.TestCasesPendingStrategy;\n+import org.evosuite.symbolic.dse.algorithm.strategies.implementations.CachingStrategies.CounterExampleCache;\n+import org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathExtensionStrategies.RevertedExpandExecutionStrategy;\n+import org.evosuite.symbolic.dse.algorithm.strategies.implementations.TestCaseBuildingStrategies.DefaultTestCaseBuildingStrategy;\n+import org.evosuite.symbolic.dse.algorithm.strategies.implementations.TestCaseSelectionStrategies.TopTestCaseSelectionStrategy;\n+import org.evosuite.testcase.TestCase;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+/**\n+ * Classic DFS exploration algorithm.\n+ * See Baldoni et.al., A Survey of Symbolic Execution Techniques for more info.\n+ *\n+ * We model it as a decremental score on each tests that is created so we maintain it's order in the\n+ * {@link java.util.PriorityQueue} in {@link org.evosuite.symbolic.dse.algorithm.ExplorationAlgorithm}. This strongly\n+ * depends on the order that {@link org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathExtensionStrategies.DFSStrategy} creates them.\n+ *\n+ * In case a path condition diverges, it's score is automatically 0 so it's explored at the end of the process.\n+ *\n+ * @author Ignacio Lebrero\n+ */\n+public class DFSExplorationAlgorithm extends ExplorationAlgorithm {\n+\n+    public DFSExplorationAlgorithm(DSEStatistics statistics, boolean showProgress) {\n+        super(statistics, showProgress);\n+\n+        /** Strategies */\n+        setCachingStrategy(new CounterExampleCache());\n+\n+        /**\n+         * Note (ilebrero): Not sure why is not working so far, reverted generational search expansion\n+         *                  algorithm should suffice for now.\n+         */\n+        // setPathsExpansionStrategy(new DFSStrategy());\n+\n+        setPathsExpansionStrategy(new RevertedExpandExecutionStrategy());\n+        setTestCaseBuildingStrategy(new DefaultTestCaseBuildingStrategy());\n+        setTestCaseSelectionStrategy(new TopTestCaseSelectionStrategy());\n+        setKeepSearchingCriteriaStrategy(new TestCasesPendingStrategy());\n+    }\n+\n+    /**\n+     * The DFS uses a simple queue for ordering the test cases as they are created. This strongly depends on the order\n+     * given by {@link org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathExtensionStrategies.DFSStrategy}.\n+     *\n+     * @return\n+     */\n+    @Override\n+    protected Queue<DSETestCase> createWorkList() {\n+        return new LinkedList();\n+    }\n+\n+    /**\n+     * Returns the current position in the DFS exploration.\n+     *\n+     * @param newTestCase\n+     * @param hasPathConditionDiverged\n+     * @return\n+     */\n+    @Override\n+    protected double getTestScore(TestCase newTestCase, boolean hasPathConditionDiverged) {\n+        /** Not relevant for DFS, the order is implicitly given by the construction of the path conditions */\n+        return 0;\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "4826d58f34295fb8317c9226f076f6f1ddfd05bb",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/explorationalgorithms/DefaultExplorationAlgorithm.java",
    "status": "removed",
    "additions": 0,
    "deletions": 47,
    "changes": 47,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/3bd21046e3ddb3e7543552356e903b26fcf75379/client/src/main/java/org/evosuite/symbolic/dse/algorithm/explorationalgorithms/DefaultExplorationAlgorithm.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/3bd21046e3ddb3e7543552356e903b26fcf75379/client/src/main/java/org/evosuite/symbolic/dse/algorithm/explorationalgorithms/DefaultExplorationAlgorithm.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/explorationalgorithms/DefaultExplorationAlgorithm.java?ref=3bd21046e3ddb3e7543552356e903b26fcf75379",
    "patch": "@@ -1,47 +0,0 @@\n-/*\n- * Copyright (C) 2010-2018 Gordon Fraser, Andrea Arcuri and EvoSuite\n- * contributors\n- *\n- * This file is part of EvoSuite.\n- *\n- * EvoSuite is free software: you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, either version 3.0 of the License, or\n- * (at your option) any later version.\n- *\n- * EvoSuite is distributed in the hope that it will be useful, but\n- * WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with EvoSuite. If not, see <http://www.gnu.org/licenses/>.\n- */\n-package org.evosuite.symbolic.dse.algorithm.explorationalgorithms;\n-\n-import org.evosuite.symbolic.dse.DSEStatistics;\n-import org.evosuite.symbolic.dse.algorithm.ExplorationAlgorithm;\n-import org.evosuite.symbolic.dse.algorithm.strategies.implementations.KeepSearchingCriteriaStrategies.TestCasesPendingStrategy;\n-import org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathPruningStrategies.CounterExampleCache;\n-import org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathSelectionStrategies.ExpandExecutionStrategy;\n-import org.evosuite.symbolic.dse.algorithm.strategies.implementations.TestCaseBuildingStrategies.DefaultTestCaseBuildingStrategy;\n-import org.evosuite.symbolic.dse.algorithm.strategies.implementations.TestCaseSelectionStrategies.TopTestCaseSelectionStrategy;\n-\n-/**\n- * Default implementation of the Exploration Algorithm.\n- *\n- * @author Ignacio Lebrero\n- */\n-public class DefaultExplorationAlgorithm extends ExplorationAlgorithm {\n-\n-  public DefaultExplorationAlgorithm(DSEStatistics statistics, boolean showProgress) {\n-    super(statistics, showProgress);\n-\n-    /** Strategies */\n-    setCachingStrategy(new CounterExampleCache());\n-    setPathsExpansionStrategy(new ExpandExecutionStrategy());\n-    setTestCaseBuildingStrategy(new DefaultTestCaseBuildingStrategy());\n-    setTestCaseSelectionStrategy(new TopTestCaseSelectionStrategy());\n-    setKeepSearchingCriteriaStrategy(new TestCasesPendingStrategy());\n-  }\n-}"
  },
  {
    "sha": "2fb4a52a31feacd88f63d60a6f6ce7f3ae8ea0ed",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/explorationalgorithms/SAGEExplorationAlgorithm.java",
    "status": "modified",
    "additions": 48,
    "deletions": 12,
    "changes": 60,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/explorationalgorithms/SAGEExplorationAlgorithm.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/explorationalgorithms/SAGEExplorationAlgorithm.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/explorationalgorithms/SAGEExplorationAlgorithm.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -20,29 +20,65 @@\n package org.evosuite.symbolic.dse.algorithm.explorationalgorithms;\n \n import org.evosuite.symbolic.dse.DSEStatistics;\n+import org.evosuite.symbolic.dse.DSETestCase;\n import org.evosuite.symbolic.dse.algorithm.ExplorationAlgorithm;\n import org.evosuite.symbolic.dse.algorithm.strategies.implementations.KeepSearchingCriteriaStrategies.TestCasesPendingStrategy;\n-import org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathPruningStrategies.CounterExampleCache;\n-import org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathSelectionStrategies.ExpandExecutionStrategy;\n+import org.evosuite.symbolic.dse.algorithm.strategies.implementations.CachingStrategies.CounterExampleCache;\n+import org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathExtensionStrategies.ExpandExecutionStrategy;\n import org.evosuite.symbolic.dse.algorithm.strategies.implementations.TestCaseBuildingStrategies.DefaultTestCaseBuildingStrategy;\n import org.evosuite.symbolic.dse.algorithm.strategies.implementations.TestCaseSelectionStrategies.TopTestCaseSelectionStrategy;\n+import org.evosuite.testcase.TestCase;\n+\n+import java.util.PriorityQueue;\n+import java.util.Queue;\n \n /**\n- * SAGE's implementation of generational search\n+ * SAGE's implementation of generational search. It differs in that Evosuite uses incremental branch coverage\n+ * instead of incremental line coverage to score the test cases.\n  *\n  * @author Ignacio Lebrero\n  */\n public class SAGEExplorationAlgorithm extends ExplorationAlgorithm {\n \n-  public SAGEExplorationAlgorithm(DSEStatistics statistics, boolean showProgress) {\n-      super(statistics, showProgress);\n+    public SAGEExplorationAlgorithm(DSEStatistics statistics, boolean showProgress) {\n+        super(statistics, showProgress);\n+\n+        /** Strategies */\n+        setCachingStrategy(new CounterExampleCache());\n+        setPathsExpansionStrategy(new ExpandExecutionStrategy());\n+        setTestCaseBuildingStrategy(new DefaultTestCaseBuildingStrategy());\n+        setTestCaseSelectionStrategy(new TopTestCaseSelectionStrategy());\n+        setKeepSearchingCriteriaStrategy(new TestCasesPendingStrategy());\n+    }\n+\n+    /**\n+     * Generational search uses a priority queue for ordering the tests cases by a score which is given by\n+     * {@link #getTestScore(org.evosuite.testcase.TestCase, boolean)}.\n+     *\n+     * @return\n+     */\n+    @Override\n+    protected Queue<DSETestCase> createWorkList() {\n+        return new PriorityQueue();\n+    }\n \n-      /** Strategies */\n-      setCachingStrategy(new CounterExampleCache());\n-      setPathsExpansionStrategy(new ExpandExecutionStrategy());\n-      setTestCaseBuildingStrategy(new DefaultTestCaseBuildingStrategy());\n-      setTestCaseSelectionStrategy(new TopTestCaseSelectionStrategy());\n-      setKeepSearchingCriteriaStrategy(new TestCasesPendingStrategy());\n-  }\n+    /**\n+     * Scoring is based on incremental coverage generated by adding a new {@link org.evosuite.testcase.TestCase} to the\n+     * test Suite.\n+     * <p>\n+     * In case the current {@link org.evosuite.testcase.TestCase} diverged, its score is automatically 0.\n+     *\n+     * @param newTestCase\n+     * @param hasPathConditionDiverged\n+     * @return\n+     */\n+    @Override\n+    protected double getTestScore(TestCase newTestCase, boolean hasPathConditionDiverged) {\n+        if (hasPathConditionDiverged) {\n+            statisticsLogger.reportNewTestUnuseful();\n+            return PATH_DIVERGED_BASED_TEST_CASE_PENALTY_SCORE;\n+        }\n \n+        return getTestCaseAdditionIncrementalCoverage(newTestCase);\n+    }\n }"
  },
  {
    "sha": "6ff7887175588f658a5f30ee1a1d2ee244fa8bac",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/listener/StoppingConditionFactory.java",
    "status": "modified",
    "additions": 20,
    "deletions": 16,
    "changes": 36,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/listener/StoppingConditionFactory.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/listener/StoppingConditionFactory.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/listener/StoppingConditionFactory.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -20,6 +20,7 @@\n package org.evosuite.symbolic.dse.algorithm.listener;\n \n import org.evosuite.Properties;\n+import org.evosuite.symbolic.dse.algorithm.listener.implementations.MaxTestsStoppingCondition;\n import org.evosuite.symbolic.dse.algorithm.listener.implementations.MaxTimeStoppingCondition;\n import org.evosuite.symbolic.dse.algorithm.listener.implementations.TargetCoverageReachedStoppingCondition;\n import org.evosuite.symbolic.dse.algorithm.listener.implementations.ZeroFitnessStoppingCondition;\n@@ -31,21 +32,24 @@\n  */\n public class StoppingConditionFactory {\n \n-  /**\n-\t * Convert property to actual stopping condition\n-\t * @return\n-\t */\n-\tpublic static StoppingCondition getStoppingCondition(Properties.DSEStoppingConditionCriterion stoppingCondition) {\n-\t\tswitch (stoppingCondition) {\n-\t\tcase MAXTIME:\n-\t\t\treturn new MaxTimeStoppingCondition();\n-    case TARGETCOVERAGE:\n-      return new TargetCoverageReachedStoppingCondition();\n-    case ZEROFITNESS:\n-      return new ZeroFitnessStoppingCondition();\n-\t\tdefault:\n-\t\t\treturn new MaxTimeStoppingCondition();\n-\t\t}\n-\t}\n+    /**\n+     * Convert property to actual stopping condition\n+     *\n+     * @return\n+     */\n+    public static StoppingCondition getStoppingCondition(Properties.DSEStoppingConditionCriterion stoppingCondition) {\n+        switch (stoppingCondition) {\n+            case MAXTIME:\n+                return new MaxTimeStoppingCondition();\n+            case TARGETCOVERAGE:\n+                return new TargetCoverageReachedStoppingCondition();\n+            case ZEROFITNESS:\n+                return new ZeroFitnessStoppingCondition();\n+\t\t\tcase MAXTESTS:\n+\t\t\t\treturn new MaxTestsStoppingCondition();\n+\t\t\tdefault:\n+                return new MaxTimeStoppingCondition();\n+        }\n+    }\n \n }"
  },
  {
    "sha": "155abff1f5ba34361e5b23a730dd2e79e4cd05ac",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/listener/implementations/MaxTestsStoppingCondition.java",
    "status": "added",
    "additions": 91,
    "deletions": 0,
    "changes": 91,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/listener/implementations/MaxTestsStoppingCondition.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/listener/implementations/MaxTestsStoppingCondition.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/listener/implementations/MaxTestsStoppingCondition.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (C) 2010-2018 Gordon Fraser, Andrea Arcuri and EvoSuite\n+ * contributors\n+ *\n+ * This file is part of EvoSuite.\n+ *\n+ * EvoSuite is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, either version 3.0 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * EvoSuite is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with EvoSuite. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package org.evosuite.symbolic.dse.algorithm.listener.implementations;\n+\n+import org.evosuite.Properties;\n+import org.evosuite.symbolic.dse.algorithm.ExplorationAlgorithmBase;\n+\n+/**\n+ * Mirror implementation of {@link org.evosuite.ga.stoppingconditions.MaxTestsStoppingCondition} for the DSE Module.\n+ *\n+ * @author Ignacio Lebrero\n+ */\n+public class MaxTestsStoppingCondition extends StoppingConditionImpl {\n+\n+\t/** Current number of tests */\n+\tprotected static long numTests = 0;\n+\n+\t/** Maximum number of evaluations */\n+\tprotected long maxTests;\n+\n+\tpublic MaxTestsStoppingCondition() {\n+\t\tmaxTests = Properties.SEARCH_BUDGET;\n+\t}\n+\n+\tpublic MaxTestsStoppingCondition(MaxTestsStoppingCondition that) {\n+\t\tthis.maxTests = that.maxTests;\n+\t}\n+\n+\t@Override\n+\tpublic MaxTestsStoppingCondition clone() {\n+\t\treturn new MaxTestsStoppingCondition(this);\n+\t}\n+\n+\t/** {@inheritDoc} */\n+\t@Override\n+\tpublic void reset() {\n+\t\tnumTests = 0;\n+\t}\n+\n+\t/** {@inheritDoc} */\n+\t@Override\n+\tpublic boolean isFinished() {\n+\t\treturn numTests >= maxTests;\n+\t}\n+\n+\t@Override\n+    public void iteration(ExplorationAlgorithmBase algorithm) {\n+        numTests++;\n+    }\n+\n+\t/* (non-Javadoc)\n+\t * @see org.evosuite.ga.StoppingCondition#getCurrentValue()\n+\t */\n+\t/** {@inheritDoc} */\n+\t@Override\n+\tpublic long getCurrentValue() {\n+\t\treturn numTests;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.evosuite.ga.StoppingCondition#setLimit(int)\n+\t */\n+\t/** {@inheritDoc} */\n+\t@Override\n+\tpublic void setLimit(long limit) {\n+\t\tmaxTests = limit;\n+\t}\n+\n+\t/** {@inheritDoc} */\n+\t@Override\n+\tpublic long getLimit() {\n+\t\treturn maxTests;\n+\t}\n+}"
  },
  {
    "sha": "4b977dd9fa5d87592760755bc44cdae95538a878",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/CachingStrategy.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/CachingStrategy.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/CachingStrategy.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/CachingStrategy.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -19,7 +19,7 @@\n  */\n package org.evosuite.symbolic.dse.algorithm.strategies;\n \n-import org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathPruningStrategies.CacheQueryResult;\n+import org.evosuite.symbolic.dse.algorithm.strategies.implementations.CachingStrategies.CacheQueryResult;\n import org.evosuite.symbolic.expr.Constraint;\n import org.evosuite.symbolic.solver.SolverResult;\n "
  },
  {
    "sha": "55234ed68951eda62d9c4290cf819559671a2c44",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/KeepSearchingCriteriaStrategy.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/KeepSearchingCriteriaStrategy.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/KeepSearchingCriteriaStrategy.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/KeepSearchingCriteriaStrategy.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -22,12 +22,13 @@\n import org.evosuite.symbolic.dse.DSETestCase;\n \n import java.util.PriorityQueue;\n+import java.util.Queue;\n \n /**\n  * Interface for extra stopping conditions on the generated test suite\n  *\n  * @author ignacio lebrero\n  */\n public interface KeepSearchingCriteriaStrategy {\n-    boolean ShouldKeepSearching(PriorityQueue<DSETestCase> generatedTests);\n+    boolean ShouldKeepSearching(Queue<DSETestCase> generatedTests);\n }"
  },
  {
    "sha": "bfb0cf830daed22c24e08842cfd0b79ac76f1ed9",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/TestCaseSelectionStrategy.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/TestCaseSelectionStrategy.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/TestCaseSelectionStrategy.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/TestCaseSelectionStrategy.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -22,12 +22,13 @@\n import org.evosuite.symbolic.dse.DSETestCase;\n \n import java.util.PriorityQueue;\n+import java.util.Queue;\n \n /**\n  * Interface for test case selection strategies.\n  *\n  * @author ignacio lebrero\n  */\n public interface TestCaseSelectionStrategy {\n-    DSETestCase getCurrentIterationBasedTestCase(PriorityQueue<DSETestCase> generatedTests);\n+    DSETestCase getCurrentIterationBasedTestCase(Queue<DSETestCase> generatedTests);\n }"
  },
  {
    "sha": "2a45522f097aa925f95307ab901eaecb4bf0dd64",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CacheCheckResult.java",
    "status": "renamed",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CacheCheckResult.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CacheCheckResult.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CacheCheckResult.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -17,7 +17,7 @@\n  * You should have received a copy of the GNU Lesser General Public\n  * License along with EvoSuite. If not, see <http://www.gnu.org/licenses/>.\n  */\n-package org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathPruningStrategies;\n+package org.evosuite.symbolic.dse.algorithm.strategies.implementations.CachingStrategies;\n \n import org.evosuite.symbolic.dse.algorithm.DSEExplorationException;\n ",
    "previous_filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathPruningStrategies/CacheCheckResult.java"
  },
  {
    "sha": "b86b2fd847f80ac2d0bfea3d0dfe54727a320a67",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CacheQueryResult.java",
    "status": "renamed",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CacheQueryResult.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CacheQueryResult.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CacheQueryResult.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -17,7 +17,7 @@\n  * You should have received a copy of the GNU Lesser General Public\n  * License along with EvoSuite. If not, see <http://www.gnu.org/licenses/>.\n  */\n-package org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathPruningStrategies;\n+package org.evosuite.symbolic.dse.algorithm.strategies.implementations.CachingStrategies;\n \n import org.evosuite.symbolic.dse.algorithm.DSEExplorationException;\n ",
    "previous_filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathPruningStrategies/CacheQueryResult.java"
  },
  {
    "sha": "14301eb07219ac4aa78136b06787ae37ff1968be",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CacheQueryStatus.java",
    "status": "renamed",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CacheQueryStatus.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CacheQueryStatus.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CacheQueryStatus.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -17,7 +17,7 @@\n  * You should have received a copy of the GNU Lesser General Public\n  * License along with EvoSuite. If not, see <http://www.gnu.org/licenses/>.\n  */\n-package org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathPruningStrategies;\n+package org.evosuite.symbolic.dse.algorithm.strategies.implementations.CachingStrategies;\n \n /**\n  * Enum for checking which case of skipping solving we are in.",
    "previous_filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathPruningStrategies/CacheQueryStatus.java"
  },
  {
    "sha": "64c3322f66e829afa09335f7029234d79d12bb75",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CounterExampleCache.java",
    "status": "renamed",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CounterExampleCache.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CounterExampleCache.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/CachingStrategies/CounterExampleCache.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -17,7 +17,7 @@\n  * You should have received a copy of the GNU Lesser General Public\n  * License along with EvoSuite. If not, see <http://www.gnu.org/licenses/>.\n  */\n-package org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathPruningStrategies;\n+package org.evosuite.symbolic.dse.algorithm.strategies.implementations.CachingStrategies;\n \n import org.evosuite.symbolic.PathConditionUtils;\n import org.evosuite.symbolic.dse.DSEStatistics;",
    "previous_filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathPruningStrategies/CounterExampleCache.java"
  },
  {
    "sha": "573e94368af408f94f405631fcae51528979754f",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/KeepSearchingCriteriaStrategies/TestCasesPendingStrategy.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/KeepSearchingCriteriaStrategies/TestCasesPendingStrategy.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/KeepSearchingCriteriaStrategies/TestCasesPendingStrategy.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/KeepSearchingCriteriaStrategies/TestCasesPendingStrategy.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -22,7 +22,7 @@\n import org.evosuite.symbolic.dse.DSETestCase;\n import org.evosuite.symbolic.dse.algorithm.strategies.KeepSearchingCriteriaStrategy;\n \n-import java.util.PriorityQueue;\n+import java.util.Queue;\n \n /**\n  * Strategy for keep searching in case there's still test cases left to explore.\n@@ -31,7 +31,7 @@\n  */\n public class TestCasesPendingStrategy implements KeepSearchingCriteriaStrategy {\n     @Override\n-    public boolean ShouldKeepSearching(PriorityQueue<DSETestCase> generatedTests) {\n+public boolean ShouldKeepSearching(Queue<DSETestCase> generatedTests) {\n         return generatedTests.size() > 0;\n     }\n }"
  },
  {
    "sha": "d7ba7b30f3e1fd9f3175c3f63fe0074a72117a2b",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/DFSStrategy.java",
    "status": "added",
    "additions": 85,
    "deletions": 0,
    "changes": 85,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/DFSStrategy.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/DFSStrategy.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/DFSStrategy.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright (C) 2010-2018 Gordon Fraser, Andrea Arcuri and EvoSuite\n+ * contributors\n+ *\n+ * This file is part of EvoSuite.\n+ *\n+ * EvoSuite is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, either version 3.0 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * EvoSuite is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with EvoSuite. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathExtensionStrategies;\n+\n+import org.evosuite.symbolic.BranchCondition;\n+import org.evosuite.symbolic.PathCondition;\n+import org.evosuite.symbolic.dse.algorithm.GenerationalSearchPathCondition;\n+import org.evosuite.symbolic.dse.algorithm.strategies.PathExtensionStrategy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Stack;\n+\n+/**\n+ * Classic DFS exploration. New path conditions are created incrementally from the smallest to the largest.\n+ *\n+ * TODO: This is very similar to {@link org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathExtensionStrategies.ExpandExecutionStrategy}\n+ * It can be an extensions later on.\n+ *\n+ * @author Ignacio Lebrero\n+ */\n+public class DFSStrategy implements PathExtensionStrategy {\n+\n+    public static final String DEBUG_MSG_NEGATING_INDEX_OF_PATH_CONDITION   = \"negating index {} of path condition\";\n+\n+    Logger logger = LoggerFactory.getLogger(DFSStrategy.class);\n+\n+    @Override\n+    public List<GenerationalSearchPathCondition> generateChildren(GenerationalSearchPathCondition currentPathConditionChild) {\n+        List<GenerationalSearchPathCondition> result = new ArrayList();\n+        List<BranchCondition> accumulatedBranchConditions = new ArrayList();\n+        List<BranchCondition> currentPathConditionBranchConditions = currentPathConditionChild.getPathCondition().getBranchConditions();\n+\n+        // Create the PCs from the longest to the shortest\n+        for (int i = 0; i < currentPathConditionBranchConditions.size(); i++) {\n+            logger.debug(DEBUG_MSG_NEGATING_INDEX_OF_PATH_CONDITION, i);\n+\n+            BranchCondition currentBranchCondition = currentPathConditionBranchConditions.get(i);\n+\n+            // Add negated version of current branch\n+            accumulatedBranchConditions.add(currentBranchCondition.getNegatedVersion());\n+\n+            GenerationalSearchPathCondition newChild = new GenerationalSearchPathCondition(\n+                    new PathCondition(\n+                            new ArrayList(accumulatedBranchConditions)\n+                    ),\n+                    0 // not relevant for DFS\n+            );\n+\n+            // Append the new PC\n+            result.add(newChild);\n+\n+            // Replace the negated branch condition with the original one for continuing generating\n+            accumulatedBranchConditions.set(\n+                    accumulatedBranchConditions.size() - 1,\n+                    currentBranchCondition\n+            );\n+        }\n+\n+        // Revert it from largest to smallest\n+        Collections.reverse(result);\n+\n+        return result;\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "eac47bf094e20c61436ce779b57bb0decb9f199b",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/ExpandExecutionStrategy.java",
    "status": "renamed",
    "additions": 11,
    "deletions": 1,
    "changes": 12,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/ExpandExecutionStrategy.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/ExpandExecutionStrategy.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/ExpandExecutionStrategy.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -17,12 +17,14 @@\n  * You should have received a copy of the GNU Lesser General Public\n  * License along with EvoSuite. If not, see <http://www.gnu.org/licenses/>.\n  */\n-package org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathSelectionStrategies;\n+package org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathExtensionStrategies;\n \n import org.evosuite.symbolic.BranchCondition;\n import org.evosuite.symbolic.dse.algorithm.GenerationalSearchPathCondition;\n import org.evosuite.symbolic.dse.algorithm.strategies.PathExtensionStrategy;\n import org.evosuite.symbolic.PathCondition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import java.util.ArrayList;\n import java.util.List;\n@@ -34,12 +36,19 @@\n  */\n public class ExpandExecutionStrategy implements PathExtensionStrategy {\n \n+    public static final String DEBUG_MSG_NEGATING_INDEX_OF_PATH_CONDITION   = \"negating index {} of path condition\";\n+    public static final String DEBUG_MSG_GENERATING_CHILDREN_FOR_GENERATION = \"Generating children for generation {}\";\n+\n+    Logger logger = LoggerFactory.getLogger(ExpandExecutionStrategy.class);\n+\n     @Override\n     public List<GenerationalSearchPathCondition> generateChildren(GenerationalSearchPathCondition currentPathConditionChild) {\n         List<GenerationalSearchPathCondition> generatedChildren = new ArrayList<>();\n         List<BranchCondition> accumulatedBranchConditions = new ArrayList<>();\n         List<BranchCondition> currentPathConditionBranchConditions = currentPathConditionChild.getPathCondition().getBranchConditions();\n+\n         int currentPathConditionIndexGeneratedFrom = currentPathConditionChild.getGeneratedFromIndex();\n+        logger.debug(DEBUG_MSG_GENERATING_CHILDREN_FOR_GENERATION, currentPathConditionIndexGeneratedFrom);\n \n         // adds the untouched prefix\n         for (int indexBound = 0; indexBound < currentPathConditionIndexGeneratedFrom; ++indexBound) {\n@@ -48,6 +57,7 @@\n \n         // Important!! We start from the index the test was generated from to avoid re-create already checked paths\n         for (int indexBound = currentPathConditionIndexGeneratedFrom; indexBound < currentPathConditionBranchConditions.size(); indexBound++) {\n+            logger.debug(DEBUG_MSG_NEGATING_INDEX_OF_PATH_CONDITION, indexBound);\n             BranchCondition currentBranchCondition = currentPathConditionBranchConditions.get(indexBound);\n \n             // Adds the negated BranchCondition version to the current created pathCondition",
    "previous_filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathSelectionStrategies/ExpandExecutionStrategy.java"
  },
  {
    "sha": "4f1df8c1346fcff290ec95ff14e3a0ac39ee4bc4",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/RevertedExpandExecutionStrategy.java",
    "status": "added",
    "additions": 42,
    "deletions": 0,
    "changes": 42,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/RevertedExpandExecutionStrategy.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/RevertedExpandExecutionStrategy.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/RevertedExpandExecutionStrategy.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright (C) 2010-2018 Gordon Fraser, Andrea Arcuri and EvoSuite\n+ * contributors\n+ *\n+ * This file is part of EvoSuite.\n+ *\n+ * EvoSuite is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, either version 3.0 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * EvoSuite is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with EvoSuite. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathExtensionStrategies;\n+\n+import org.evosuite.symbolic.dse.algorithm.GenerationalSearchPathCondition;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Differs with {@link org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathExtensionStrategies.ExpandExecutionStrategy}\n+ * only in that it returns paths in the reverse order.\n+ *\n+ * @author Ignacio Lebrero\n+ */\n+public class RevertedExpandExecutionStrategy extends ExpandExecutionStrategy {\n+\n+    @Override\n+    public List<GenerationalSearchPathCondition> generateChildren(GenerationalSearchPathCondition currentPathConditionChild) {\n+        List<GenerationalSearchPathCondition> result = super.generateChildren(currentPathConditionChild);\n+        Collections.reverse(result);\n+        return result;\n+    }\n+\n+}"
  },
  {
    "sha": "e41aba7638532a2c1707c7633010c759f7027859",
    "filename": "client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/TestCaseSelectionStrategies/TopTestCaseSelectionStrategy.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/TestCaseSelectionStrategies/TopTestCaseSelectionStrategy.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/TestCaseSelectionStrategies/TopTestCaseSelectionStrategy.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/main/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/TestCaseSelectionStrategies/TopTestCaseSelectionStrategy.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -22,7 +22,7 @@\n import org.evosuite.symbolic.dse.DSETestCase;\n import org.evosuite.symbolic.dse.algorithm.strategies.TestCaseSelectionStrategy;\n \n-import java.util.PriorityQueue;\n+import java.util.Queue;\n \n /**\n  * Strategy for retrieving the last generated tests case for symbolic execution in the current iteration.\n@@ -31,7 +31,7 @@\n  */\n public class TopTestCaseSelectionStrategy implements TestCaseSelectionStrategy {\n     @Override\n-    public DSETestCase getCurrentIterationBasedTestCase(PriorityQueue<DSETestCase> generatedTests) {\n+    public DSETestCase getCurrentIterationBasedTestCase(Queue<DSETestCase> generatedTests) {\n         return generatedTests.poll();\n     }\n }"
  },
  {
    "sha": "c5dfc83d0e4e2c2a704dcc3dea8fa1c7d97b8e8d",
    "filename": "client/src/test/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/DFSStrategyTest.java",
    "status": "added",
    "additions": 70,
    "deletions": 0,
    "changes": 70,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/test/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/DFSStrategyTest.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/client/src/test/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/DFSStrategyTest.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/client/src/test/java/org/evosuite/symbolic/dse/algorithm/strategies/implementations/PathExtensionStrategies/DFSStrategyTest.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -0,0 +1,70 @@\n+package org.evosuite.symbolic.dse.algorithm.strategies.implementations.PathExtensionStrategies;\n+\n+import org.evosuite.symbolic.BranchCondition;\n+import org.evosuite.symbolic.PathCondition;\n+import org.evosuite.symbolic.dse.algorithm.GenerationalSearchPathCondition;\n+import org.evosuite.symbolic.dse.algorithm.strategies.PathExtensionStrategy;\n+import org.evosuite.symbolic.expr.Comparator;\n+import org.evosuite.symbolic.expr.bv.IntegerConstant;\n+import org.evosuite.symbolic.expr.constraint.IntegerConstraint;\n+import org.evosuite.symbolic.vm.PathConditionCollector;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import static org.junit.Assert.*;\n+\n+public class DFSStrategyTest {\n+\n+    @Test\n+    public void generateChildren() {\n+        GenerationalSearchPathCondition generationalPathCondition = generatePathCondition1();\n+\n+        PathCondition pathCondition = generationalPathCondition.getPathCondition();\n+        PathExtensionStrategy dfsStrategy = new DFSStrategy();\n+\n+        List<GenerationalSearchPathCondition> children = dfsStrategy.generateChildren(generationalPathCondition);\n+\n+        // One expansion per branch\n+        assertEquals(pathCondition.getBranchConditions().size(), children.size());\n+\n+        // Children composition\n+        int expectedSize = children.size();\n+        for(GenerationalSearchPathCondition gpc : children) {\n+            PathCondition childPathCondition = gpc.getPathCondition();\n+\n+            // from largest to smallest\n+            assertEquals(expectedSize, childPathCondition.size());\n+\n+            // Current size determines the last branch index\n+            int lastBranchIndex = expectedSize  - 1;\n+\n+            // Last branch must be negated\n+            isNegatedVersion(pathCondition, childPathCondition, lastBranchIndex);\n+\n+            expectedSize--;\n+        }\n+    }\n+\n+    private void isNegatedVersion(PathCondition pathCondition, PathCondition childPathCondition, int expectedSize) {\n+        BranchCondition childBranch = childPathCondition.get(expectedSize);\n+        BranchCondition originalBranch = pathCondition.get(expectedSize);\n+\n+        assertEquals(originalBranch.getConstraint(), childBranch.getNegatedVersion().getConstraint());\n+    }\n+\n+    private GenerationalSearchPathCondition generatePathCondition1() {\n+        PathConditionCollector pcc = new PathConditionCollector();\n+\n+        IntegerConstraint intConst1 = new IntegerConstraint(new IntegerConstant(2), Comparator.EQ, new IntegerConstant(3));\n+        IntegerConstraint intConst2 = new IntegerConstraint(new IntegerConstant(5), Comparator.NE, new IntegerConstant(1));\n+        IntegerConstraint intConst3 = new IntegerConstraint(new IntegerConstant(18), Comparator.LT, new IntegerConstant(3));\n+\n+        pcc.appendIfBranchCondition(\"test\", \"test\", 1, true, intConst1);\n+        pcc.appendIfBranchCondition(\"test\", \"test\", 1, true, intConst2);\n+        pcc.appendIfBranchCondition(\"test\", \"test\", 1, true, intConst3);\n+\n+        PathCondition result = new PathCondition(pcc.getPathCondition());\n+        return new GenerationalSearchPathCondition(result, 0);\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "96f485069b4272628d497e338345ce846152df37",
    "filename": "master/src/test/java/org/evosuite/dse/DSEAlgorithmDFSSystemTest.java",
    "status": "added",
    "additions": 50,
    "deletions": 0,
    "changes": 50,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/master/src/test/java/org/evosuite/dse/DSEAlgorithmDFSSystemTest.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/master/src/test/java/org/evosuite/dse/DSEAlgorithmDFSSystemTest.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/master/src/test/java/org/evosuite/dse/DSEAlgorithmDFSSystemTest.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright (C) 2010-2018 Gordon Fraser, Andrea Arcuri and EvoSuite\n+ * contributors\n+ *\n+ * This file is part of EvoSuite.\n+ *\n+ * EvoSuite is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, either version 3.0 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * EvoSuite is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with EvoSuite. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package org.evosuite.dse;\n+\n+import com.examples.with.different.packagename.solver.MazeClientArrays;\n+import org.evosuite.Properties;\n+import org.evosuite.symbolic.dse.algorithm.DSEAlgorithms;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * DFS exploration algorithm related system tests.\n+ * Main DFS implementation can be found at\n+ * {@link org.evosuite.symbolic.dse.algorithm.explorationalgorithms.DFSExplorationAlgorithm}\n+ *\n+ * @author Ignacio Lebrero\n+ */\n+public class DSEAlgorithmDFSSystemTest extends DSESystemTestBase {\n+\n+    @Before\n+    public void init() {\n+        super.init();\n+\n+        Properties.CURRENT_DSE_MODULE_VERSION = Properties.DSE_MODULE_VERSION.NEW;\n+        Properties.DSE_EXPLORATION_ALGORITHM_TYPE = DSEAlgorithms.DFS;\n+        Properties.SELECTED_DSE_ARRAYS_MEMORY_MODEL_VERSION = Properties.DSE_ARRAYS_MEMORY_MODEL_VERSION.SELECT_STORE_EXPRESSIONS;\n+    }\n+\n+    @Test\n+\tpublic void testMazeClientInputWithDFSAlgorithm() {\n+\t\ttestDSEExecution(26, 0, MazeClientArrays.class);\n+\t}\n+}"
  },
  {
    "sha": "9d724bfcc8f83be1bd921251b023227701c27fdc",
    "filename": "master/src/test/java/org/evosuite/dse/DSEAlgorithmSystemTest.java",
    "status": "modified",
    "additions": 11,
    "deletions": 5,
    "changes": 16,
    "blob_url": "https://github.com/EvoSuite/evosuite/blob/c1394624e4b571f9a419087391f77e4906bdfde1/master/src/test/java/org/evosuite/dse/DSEAlgorithmSystemTest.java",
    "raw_url": "https://github.com/EvoSuite/evosuite/raw/c1394624e4b571f9a419087391f77e4906bdfde1/master/src/test/java/org/evosuite/dse/DSEAlgorithmSystemTest.java",
    "contents_url": "https://api.github.com/repos/EvoSuite/evosuite/contents/master/src/test/java/org/evosuite/dse/DSEAlgorithmSystemTest.java?ref=c1394624e4b571f9a419087391f77e4906bdfde1",
    "patch": "@@ -44,8 +44,10 @@\n import org.evosuite.EvoSuite;\n import org.evosuite.Properties;\n import org.evosuite.Properties.StoppingCondition;\n+import org.evosuite.symbolic.dse.algorithm.DSEAlgorithms;\n import org.evosuite.symbolic.dse.algorithm.ExplorationAlgorithmBase;\n import org.evosuite.testsuite.TestSuiteChromosome;\n+import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n@@ -55,6 +57,14 @@\n \n public class DSEAlgorithmSystemTest extends DSESystemTestBase {\n \n+\t@Before\n+\tpublic void init() {\n+\t\tsuper.init();\n+\n+\t\tProperties.DSE_EXPLORATION_ALGORITHM_TYPE = DSEAlgorithms.GENERATIONAL_SEARCH;\n+\t\tProperties.CURRENT_DSE_MODULE_VERSION = Properties.DSE_MODULE_VERSION.NEW;\n+\t}\n+\n \t@Test\n \tpublic void testMax() {\n \t\tEvoSuite evosuite = new EvoSuite();\n@@ -94,7 +104,6 @@ public void testAdd() {\n \n \t\tassertEquals(1, best.getNumOfCoveredGoals());\n \t\tassertEquals(1, best.getNumOfNotCoveredGoals());\n-\n \t}\n \n \t@Test\n@@ -348,7 +357,6 @@ public void testMaxFitnessEvaluationStoppingCondition() {\n \t\tEvoSuite evosuite = new EvoSuite();\n \t\tString targetClass = Max.class.getCanonicalName();\n \t\tProperties.TARGET_CLASS = targetClass;\n-\n \t\tProperties.STOPPING_CONDITION = StoppingCondition.MAXFITNESSEVALUATIONS;\n \t\tProperties.SEARCH_BUDGET = 2;\n \n@@ -372,7 +380,6 @@ public void testMaxTimeStoppingCondition() {\n \t\tEvoSuite evosuite = new EvoSuite();\n \t\tString targetClass = Max.class.getCanonicalName();\n \t\tProperties.TARGET_CLASS = targetClass;\n-\n \t\tProperties.STOPPING_CONDITION = StoppingCondition.MAXTIME;\n \t\tProperties.SEARCH_BUDGET = -1;\n \n@@ -395,7 +402,6 @@ public void testMaxStatementsStoppingCondition() {\n \t\tEvoSuite evosuite = new EvoSuite();\n \t\tString targetClass = Max.class.getCanonicalName();\n \t\tProperties.TARGET_CLASS = targetClass;\n-\n \t\tProperties.STOPPING_CONDITION = StoppingCondition.MAXSTATEMENTS;\n \t\tProperties.SEARCH_BUDGET = 1;\n \n@@ -616,7 +622,7 @@ public void testStringArrayAssignment() {\n \t}\n \n \t/**\n-\t * Given that the concolic engine makes the un-instrumented functions results concrete, the hashing case gets covered..\n+\t * Given that the concolic engine makes the un-instrumented functions results concrete, the hashing case gets covered.\n \t *\n \t * See examples on: Patrice Godefroid - Higher-Order Test Generation.\n \t */"
  }
]
