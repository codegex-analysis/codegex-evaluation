[
  {
    "sha": "b51dcfbb0920a91712f86e08f607ad4735dc81a0",
    "filename": "jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/codeAction/CodeActionHandler.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/eclipse/lsp4jakarta/blob/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/codeAction/CodeActionHandler.java",
    "raw_url": "https://github.com/eclipse/lsp4jakarta/raw/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/codeAction/CodeActionHandler.java",
    "contents_url": "https://api.github.com/repos/eclipse/lsp4jakarta/contents/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/codeAction/CodeActionHandler.java?ref=dcccd8d9ec130b20d684c31440c5dd44172fdc64",
    "patch": "@@ -30,6 +30,8 @@\n import org.eclipse.lsp4j.Range;\n import org.jakarta.jdt.JDTUtils;\n import org.jakarta.jdt.JsonRpcHelpers;\n+import org.jakarta.jdt.beanvalidation.BeanValidationConstants;\n+import org.jakarta.jdt.beanvalidation.BeanValidationQuickFix;\n import org.jakarta.jdt.persistence.PersistenceAnnotationQuickFix;\n import org.jakarta.jdt.persistence.PersistenceConstants;\n import org.jakarta.jdt.persistence.PersistenceEntityQuickFix;\n@@ -89,6 +91,7 @@\n             ManagedBeanQuickFix ManagedBeanQuickFix = new ManagedBeanQuickFix();\n             PersistenceEntityQuickFix PersistenceEntityQuickFix = new PersistenceEntityQuickFix();\n             ConflictProducesInjectQuickFix ConflictProducesInjectQuickFix = new ConflictProducesInjectQuickFix();\n+            BeanValidationQuickFix BeanValidationQuickFix = new BeanValidationQuickFix();\n             ManagedBeanConstructorQuickFix ManagedBeanConstructorQuickFix = new ManagedBeanConstructorQuickFix();\n \n             for (Diagnostic diagnostic : params.getContext().getDiagnostics()) {\n@@ -136,6 +139,10 @@\n                     if (diagnostic.getCode().getLeft().equals(ManagedBeanConstants.DIAGNOSTIC_CODE_PRODUCES_INJECT)) {\n                         codeActions.addAll(ConflictProducesInjectQuickFix.getCodeActions(context, diagnostic, monitor));\n                     }\n+                    if (diagnostic.getCode().getLeft().equals(BeanValidationConstants.DIAGNOSTIC_CODE_STATIC)\n+                            || diagnostic.getCode().getLeft().equals(BeanValidationConstants.DIAGNOSTIC_CODE_INVALID_TYPE)) {\n+                        codeActions.addAll(BeanValidationQuickFix.getCodeActions(context, diagnostic, monitor));\n+                    }\n                     if(diagnostic.getCode().getLeft().equals(ManagedBeanConstants.CONSTRUCTOR_DIAGNOSTIC_CODE)) {\n                     \tcodeActions.addAll(ManagedBeanConstructorQuickFix.getCodeActions(context, diagnostic, monitor));\n                     }"
  },
  {
    "sha": "a090f1f7aad045601937034d1ee908fe50b97f1e",
    "filename": "jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/codeAction/proposal/DeleteAnnotationProposal.java",
    "status": "modified",
    "additions": 4,
    "deletions": 2,
    "changes": 6,
    "blob_url": "https://github.com/eclipse/lsp4jakarta/blob/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/codeAction/proposal/DeleteAnnotationProposal.java",
    "raw_url": "https://github.com/eclipse/lsp4jakarta/raw/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/codeAction/proposal/DeleteAnnotationProposal.java",
    "contents_url": "https://api.github.com/repos/eclipse/lsp4jakarta/contents/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/codeAction/proposal/DeleteAnnotationProposal.java?ref=dcccd8d9ec130b20d684c31440c5dd44172fdc64",
    "patch": "@@ -81,7 +81,10 @@ protected ASTRewrite getRewrite() throws CoreException {\n         }\n         ImportRewrite imports = createImportRewrite(newRoot);\n \n-        boolean isField = declNode instanceof VariableDeclarationFragment;\n+        if (declNode instanceof VariableDeclarationFragment) {\n+            declNode = declNode.getParent();\n+        }\n+        boolean isField = declNode instanceof FieldDeclaration;\n         boolean isMethod = declNode instanceof MethodDeclaration;\n \n         String[] annotations = getAnnotations();\n@@ -106,7 +109,6 @@ protected ASTRewrite getRewrite() throws CoreException {\n                 children = (List<? extends ASTNode>) declNode\n                         .getStructuralProperty(MethodDeclaration.MODIFIERS2_PROPERTY);\n             } else {\n-                declNode = declNode.getParent();\n                 children = (List<? extends ASTNode>) declNode\n                         .getStructuralProperty(FieldDeclaration.MODIFIERS2_PROPERTY);\n             }"
  },
  {
    "sha": "c8ecd9921bfdd776b4c49152f718f4ab5c06ad6b",
    "filename": "jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/codeAction/proposal/ModifyModifiersProposal.java",
    "status": "modified",
    "additions": 4,
    "deletions": 3,
    "changes": 7,
    "blob_url": "https://github.com/eclipse/lsp4jakarta/blob/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/codeAction/proposal/ModifyModifiersProposal.java",
    "raw_url": "https://github.com/eclipse/lsp4jakarta/raw/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/codeAction/proposal/ModifyModifiersProposal.java",
    "contents_url": "https://api.github.com/repos/eclipse/lsp4jakarta/contents/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/codeAction/proposal/ModifyModifiersProposal.java?ref=dcccd8d9ec130b20d684c31440c5dd44172fdc64",
    "patch": "@@ -105,13 +105,14 @@ protected ASTRewrite getRewrite() throws CoreException {\n             declNode = newRoot.findDeclaringNode(binding.getKey());\n         }\n \n+        if (coveredNode != null) {\n+            declNode = coveredNode;\n+        }\n         boolean isField = declNode instanceof VariableDeclarationFragment;\n         if (isField) {\n             declNode = declNode.getParent();\n         }\n-        if (coveredNode != null) {\n-            declNode = coveredNode.getParent();\n-        }\n+\n         \n         AST ast = declNode.getAST();\n         ASTRewrite rewrite = ASTRewrite.create(ast);"
  },
  {
    "sha": "ff7daf95233395dae752b00f7176466e9c9c0c03",
    "filename": "jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/beanvalidation/BeanValidationConstants.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/eclipse/lsp4jakarta/blob/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/beanvalidation/BeanValidationConstants.java",
    "raw_url": "https://github.com/eclipse/lsp4jakarta/raw/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/beanvalidation/BeanValidationConstants.java",
    "contents_url": "https://api.github.com/repos/eclipse/lsp4jakarta/contents/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/beanvalidation/BeanValidationConstants.java?ref=dcccd8d9ec130b20d684c31440c5dd44172fdc64",
    "patch": "@@ -74,8 +74,8 @@\n     public static final String BIG_DECIMAL = \"BigDecimal\";\n \n     public static final String DIAGNOSTIC_SOURCE = \"jakarta-bean-validation\";\n-    public static final String DIAGNOSTIC_CODE_FIELD = \"FixTypeOfField\";\n-    public static final String DIAGNOSTIC_CODE_Static = \"MakeFieldNotStatic\";\n+    public static final String DIAGNOSTIC_CODE_INVALID_TYPE = \"FixTypeOfElement\";\n+    public static final String DIAGNOSTIC_CODE_STATIC = \"MakeNotStatic\";\n     public static final DiagnosticSeverity SEVERITY = DiagnosticSeverity.Error;\n \n     public final static Set<String> SET_OF_ANNOTATIONS = Collections"
  },
  {
    "sha": "2af04da8d7420cf6d4eca5e8c3cde6bce268c338",
    "filename": "jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/beanvalidation/BeanValidationDiagnosticsCollector.java",
    "status": "modified",
    "additions": 123,
    "deletions": 99,
    "changes": 222,
    "blob_url": "https://github.com/eclipse/lsp4jakarta/blob/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/beanvalidation/BeanValidationDiagnosticsCollector.java",
    "raw_url": "https://github.com/eclipse/lsp4jakarta/raw/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/beanvalidation/BeanValidationDiagnosticsCollector.java",
    "contents_url": "https://api.github.com/repos/eclipse/lsp4jakarta/contents/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/beanvalidation/BeanValidationDiagnosticsCollector.java?ref=dcccd8d9ec130b20d684c31440c5dd44172fdc64",
    "patch": "@@ -24,8 +24,8 @@\n import static org.jakarta.jdt.beanvalidation.BeanValidationConstants.DATE;\n import static org.jakarta.jdt.beanvalidation.BeanValidationConstants.DECIMAL_MAX;\n import static org.jakarta.jdt.beanvalidation.BeanValidationConstants.DECIMAL_MIN;\n-import static org.jakarta.jdt.beanvalidation.BeanValidationConstants.DIAGNOSTIC_CODE_FIELD;\n-import static org.jakarta.jdt.beanvalidation.BeanValidationConstants.DIAGNOSTIC_CODE_Static;\n+import static org.jakarta.jdt.beanvalidation.BeanValidationConstants.DIAGNOSTIC_CODE_INVALID_TYPE;\n+import static org.jakarta.jdt.beanvalidation.BeanValidationConstants.DIAGNOSTIC_CODE_STATIC;\n import static org.jakarta.jdt.beanvalidation.BeanValidationConstants.DIAGNOSTIC_SOURCE;\n import static org.jakarta.jdt.beanvalidation.BeanValidationConstants.DIGITS;\n import static org.jakarta.jdt.beanvalidation.BeanValidationConstants.DOUBLE;\n@@ -70,6 +70,7 @@\n import org.eclipse.jdt.core.IAnnotation;\n import org.eclipse.jdt.core.ICompilationUnit;\n import org.eclipse.jdt.core.IField;\n+import org.eclipse.jdt.core.IMethod;\n import org.eclipse.jdt.core.ISourceRange;\n import org.eclipse.jdt.core.IType;\n import org.eclipse.jdt.core.JavaModelException;\n@@ -94,36 +95,57 @@ public void collectDiagnostics(ICompilationUnit unit, List<Diagnostic> diagnosti\n             IType[] alltypes;\n             IField[] allFields;\n             IAnnotation[] allFieldAnnotations;\n+            IMethod[] allMethods;\n+            IAnnotation[] allMethodAnnotations;\n \n             try {\n                 alltypes = unit.getAllTypes();\n                 for (IType type : alltypes) {\n                     allFields = type.getFields();\n                     for (IField field : allFields) {\n-\n                         allFieldAnnotations = field.getAnnotations();\n                         String fieldType = field.getTypeSignature();\n+                        ISourceRange fieldNameRange = JDTUtils.getNameRange(field);\n+                        Range fieldRange = JDTUtils.toRange(unit, fieldNameRange.getOffset(),\n+                                fieldNameRange.getLength());\n \n                         for (IAnnotation annotation : allFieldAnnotations) {\n                             if (SET_OF_ANNOTATIONS.contains(annotation.getElementName())) {\n-                                checkAnnotationAllowedTypes(unit, diagnostics, fieldType, annotation);\n-\n                                 if (Flags.isStatic(field.getFlags())) {\n-                                    ISourceRange fieldAnnotationNameRange = JDTUtils.getNameRange(annotation);\n-                                    Range fieldAnnotationrange = JDTUtils.toRange(unit,\n-                                            fieldAnnotationNameRange.getOffset(), fieldAnnotationNameRange.getLength());\n-\n-                                    Diagnostic diagnostic = new Diagnostic(fieldAnnotationrange,\n+                                    Diagnostic diagnostic = new Diagnostic(fieldRange,\n                                             \"Constraint annotations are not allowed on static fields\");\n                                     diagnostic.setSource(DIAGNOSTIC_SOURCE);\n-                                    diagnostic.setCode(DIAGNOSTIC_CODE_Static);\n+                                    diagnostic.setCode(DIAGNOSTIC_CODE_STATIC);\n                                     diagnostic.setSeverity(SEVERITY);\n                                     diagnostics.add(diagnostic);\n+                                } else {\n+                                    checkAnnotationAllowedTypes(unit, diagnostics, fieldType, annotation, fieldRange);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    allMethods = type.getMethods();\n+                    for (IMethod method : allMethods) {\n+                        allMethodAnnotations = method.getAnnotations();\n+                        String returnType = method.getReturnType();\n+                        ISourceRange methodNameRange = JDTUtils.getNameRange(method);\n+                        Range methodRange = JDTUtils.toRange(unit, methodNameRange.getOffset(),\n+                                methodNameRange.getLength());\n+                        \n+                        for (IAnnotation annotation : allMethodAnnotations) {\n+                            if (SET_OF_ANNOTATIONS.contains(annotation.getElementName())) {                                \n+                                if (Flags.isStatic(method.getFlags())) {\n+                                    Diagnostic diagnostic = new Diagnostic(methodRange,\n+                                            \"Constraint annotations are not allowed on static methods\");\n+                                    diagnostic.setSource(DIAGNOSTIC_SOURCE);\n+                                    diagnostic.setCode(DIAGNOSTIC_CODE_STATIC);\n+                                    diagnostic.setSeverity(SEVERITY);\n+                                    diagnostics.add(diagnostic);\n+                                } else {\n+                                    checkAnnotationAllowedTypes(unit, diagnostics, returnType, annotation, methodRange, true);\n                                 }\n                             }\n-\n                         }\n-\n                     }\n                 }\n \n@@ -134,145 +156,147 @@ public void collectDiagnostics(ICompilationUnit unit, List<Diagnostic> diagnosti\n \n     }\n \n-    private void checkAnnotationAllowedTypes(ICompilationUnit unit, List<Diagnostic> diagnostics, String fieldType,\n-            IAnnotation annotation) throws JavaModelException {\n-\n-        ISourceRange fieldAnnotationNameRange = JDTUtils.getNameRange(annotation);\n-        Range fieldAnnotationrange = JDTUtils.toRange(unit, fieldAnnotationNameRange.getOffset(),\n-                fieldAnnotationNameRange.getLength());\n-\n+    private void checkAnnotationAllowedTypes(ICompilationUnit unit, List<Diagnostic> diagnostics, String type,\n+            IAnnotation annotation, Range range) throws JavaModelException {\n+        checkAnnotationAllowedTypes(unit, diagnostics, type, annotation, range, false);\n+    }\n+    \n+    private void checkAnnotationAllowedTypes(ICompilationUnit unit, List<Diagnostic> diagnostics, String type,\n+            IAnnotation annotation, Range range, Boolean isMethod) throws JavaModelException {\n+        String source = isMethod ? \"methods.\" : \"fields.\";\n+        \n         if (annotation.getElementName().equals(ASSERT_FALSE) || annotation.getElementName().equals(ASSERT_TRUE)) {\n \n-            if (!fieldType.equals(getSignatureFormatOfType(BOOLEAN)) && !fieldType.equals(Signature.SIG_BOOLEAN)) {\n-\n-                Diagnostic diagnostic = new Diagnostic(fieldAnnotationrange, \"The @\" + annotation.getElementName()\n-                        + \" annotation can only be used on boolean and Boolean type fields.\");\n-                diagnostic.setCode(DIAGNOSTIC_CODE_FIELD);\n+            if (!type.equals(getSignatureFormatOfType(BOOLEAN)) && !type.equals(Signature.SIG_BOOLEAN)) {\n+                \n+                Diagnostic diagnostic = new Diagnostic(range, \"The @\" + annotation.getElementName()\n+                        + \" annotation can only be used on boolean and Boolean type \" + source);\n+                diagnostic.setCode(DIAGNOSTIC_CODE_INVALID_TYPE);\n                 completeDiagnostic(diagnostic);\n                 diagnostics.add(diagnostic);\n             }\n         } else if (annotation.getElementName().equals(DECIMAL_MAX) || annotation.getElementName().equals(DECIMAL_MIN)\n                 || annotation.getElementName().equals(DIGITS)) {\n \n-            if (!fieldType.equals(getSignatureFormatOfType(BIG_DECIMAL))\n-                    && !fieldType.equals(getSignatureFormatOfType(BIG_INTEGER))\n-                    && !fieldType.equals(getSignatureFormatOfType(CHAR_SEQUENCE))\n-                    && !fieldType.equals(getSignatureFormatOfType(BYTE))\n-                    && !fieldType.equals(getSignatureFormatOfType(SHORT))\n-                    && !fieldType.equals(getSignatureFormatOfType(INTEGER))\n-                    && !fieldType.equals(getSignatureFormatOfType(LONG)) && !fieldType.equals(Signature.SIG_BYTE)\n-                    && !fieldType.equals(Signature.SIG_SHORT) && !fieldType.equals(Signature.SIG_INT)\n-                    && !fieldType.equals(Signature.SIG_LONG)) {\n-\n-                Diagnostic diagnostic = new Diagnostic(fieldAnnotationrange,\n+            if (!type.equals(getSignatureFormatOfType(BIG_DECIMAL))\n+                    && !type.equals(getSignatureFormatOfType(BIG_INTEGER))\n+                    && !type.equals(getSignatureFormatOfType(CHAR_SEQUENCE))\n+                    && !type.equals(getSignatureFormatOfType(BYTE))\n+                    && !type.equals(getSignatureFormatOfType(SHORT))\n+                    && !type.equals(getSignatureFormatOfType(INTEGER))\n+                    && !type.equals(getSignatureFormatOfType(LONG)) && !type.equals(Signature.SIG_BYTE)\n+                    && !type.equals(Signature.SIG_SHORT) && !type.equals(Signature.SIG_INT)\n+                    && !type.equals(Signature.SIG_LONG)) {\n+\n+                Diagnostic diagnostic = new Diagnostic(range,\n                         \"The @\" + annotation.getElementName()\n                                 + \" annotation can only be used on: \\n- BigDecimal \\n- BigInteger \\n- CharSequence\"\n-                                + \"\\n- byte, short, int, long (and their respective wrappers) \\n type fields.\");\n-                diagnostic.setCode(DIAGNOSTIC_CODE_FIELD);\n+                                + \"\\n- byte, short, int, long (and their respective wrappers) \\n type \" + source);\n+                diagnostic.setCode(DIAGNOSTIC_CODE_INVALID_TYPE);\n                 completeDiagnostic(diagnostic);\n                 diagnostics.add(diagnostic);\n             }\n         } else if (annotation.getElementName().equals(EMAIL)) {\n \n-            if (!fieldType.equals(getSignatureFormatOfType(STRING))\n-                    && !fieldType.equals(getSignatureFormatOfType(CHAR_SEQUENCE))) {\n+            if (!type.equals(getSignatureFormatOfType(STRING))\n+                    && !type.equals(getSignatureFormatOfType(CHAR_SEQUENCE))) {\n \n-                Diagnostic diagnostic = new Diagnostic(fieldAnnotationrange, \"The @\" + annotation.getElementName()\n-                        + \" annotation can only be used on String and CharSequence type fields.\");\n-                diagnostic.setCode(DIAGNOSTIC_CODE_FIELD);\n+                Diagnostic diagnostic = new Diagnostic(range, \"The @\" + annotation.getElementName()\n+                        + \" annotation can only be used on String and CharSequence type \" + source);\n+                diagnostic.setCode(DIAGNOSTIC_CODE_INVALID_TYPE);\n                 completeDiagnostic(diagnostic);\n                 diagnostics.add(diagnostic);\n             }\n         } else if (annotation.getElementName().equals(FUTURE) || annotation.getElementName().equals(FUTURE_OR_PRESENT)\n                 || annotation.getElementName().equals(PAST) || annotation.getElementName().equals(PAST_OR_PRESENT)) {\n \n-            if (!fieldType.equals(getSignatureFormatOfType(DATE))\n-                    && !fieldType.equals(getSignatureFormatOfType(CALENDAR))\n-                    && !fieldType.equals(getSignatureFormatOfType(INSTANT))\n-                    && !fieldType.equals(getSignatureFormatOfType(LOCAL_DATE))\n-                    && !fieldType.equals(getSignatureFormatOfType(LOCAL_DATE_TIME))\n-                    && !fieldType.equals(getSignatureFormatOfType(LOCAL_TIME))\n-                    && !fieldType.equals(getSignatureFormatOfType(MONTH_DAY))\n-                    && !fieldType.equals(getSignatureFormatOfType(OFFSET_DATE_TIME))\n-                    && !fieldType.equals(getSignatureFormatOfType(OFFSET_TIME))\n-                    && !fieldType.equals(getSignatureFormatOfType(YEAR))\n-                    && !fieldType.equals(getSignatureFormatOfType(YEAR_MONTH))\n-                    && !fieldType.equals(getSignatureFormatOfType(ZONED_DATE_TIME))\n-                    && !fieldType.equals(getSignatureFormatOfType(HIJRAH_DATE))\n-                    && !fieldType.equals(getSignatureFormatOfType(JAPANESE_DATE))\n-                    && !fieldType.equals(getSignatureFormatOfType(MINGUO_DATE))\n-                    && !fieldType.equals(getSignatureFormatOfType(THAI_BUDDHIST_DATE))) {\n-\n-                Diagnostic diagnostic = new Diagnostic(fieldAnnotationrange, \"The @\" + annotation.getElementName()\n+            if (!type.equals(getSignatureFormatOfType(DATE))\n+                    && !type.equals(getSignatureFormatOfType(CALENDAR))\n+                    && !type.equals(getSignatureFormatOfType(INSTANT))\n+                    && !type.equals(getSignatureFormatOfType(LOCAL_DATE))\n+                    && !type.equals(getSignatureFormatOfType(LOCAL_DATE_TIME))\n+                    && !type.equals(getSignatureFormatOfType(LOCAL_TIME))\n+                    && !type.equals(getSignatureFormatOfType(MONTH_DAY))\n+                    && !type.equals(getSignatureFormatOfType(OFFSET_DATE_TIME))\n+                    && !type.equals(getSignatureFormatOfType(OFFSET_TIME))\n+                    && !type.equals(getSignatureFormatOfType(YEAR))\n+                    && !type.equals(getSignatureFormatOfType(YEAR_MONTH))\n+                    && !type.equals(getSignatureFormatOfType(ZONED_DATE_TIME))\n+                    && !type.equals(getSignatureFormatOfType(HIJRAH_DATE))\n+                    && !type.equals(getSignatureFormatOfType(JAPANESE_DATE))\n+                    && !type.equals(getSignatureFormatOfType(MINGUO_DATE))\n+                    && !type.equals(getSignatureFormatOfType(THAI_BUDDHIST_DATE))) {\n+\n+                Diagnostic diagnostic = new Diagnostic(range, \"The @\" + annotation.getElementName()\n                         + \" annotation can only be used on: Date, Calendar, Instant, \"\n                         + \"LocalDate, LocalDateTime, LocalTime, MonthDay, OffsetDateTime, \"\n                         + \"OffsetTime, Year, YearMonth, ZonedDateTime, \"\n-                        + \"HijrahDate, JapaneseDate, JapaneseDate, MinguoDate and \" + \"ThaiBuddhistDate type fields.\");\n-                diagnostic.setCode(DIAGNOSTIC_CODE_FIELD);\n+                        + \"HijrahDate, JapaneseDate, JapaneseDate, MinguoDate and \" + \"ThaiBuddhistDate type \" + source);\n+                diagnostic.setCode(DIAGNOSTIC_CODE_INVALID_TYPE);\n                 completeDiagnostic(diagnostic);\n                 diagnostics.add(diagnostic);\n             }\n         } else if (annotation.getElementName().equals(MIN) || annotation.getElementName().equals(MAX)) {\n \n-            if (!fieldType.equals(getSignatureFormatOfType(BIG_DECIMAL))\n-                    && !fieldType.equals(getSignatureFormatOfType(BIG_INTEGER))\n-                    && !fieldType.equals(getSignatureFormatOfType(BYTE))\n-                    && !fieldType.equals(getSignatureFormatOfType(SHORT))\n-                    && !fieldType.equals(getSignatureFormatOfType(INTEGER))\n-                    && !fieldType.equals(getSignatureFormatOfType(LONG)) && !fieldType.equals(Signature.SIG_BYTE)\n-                    && !fieldType.equals(Signature.SIG_SHORT) && !fieldType.equals(Signature.SIG_INT)\n-                    && !fieldType.equals(Signature.SIG_LONG)) {\n+            if (!type.equals(getSignatureFormatOfType(BIG_DECIMAL))\n+                    && !type.equals(getSignatureFormatOfType(BIG_INTEGER))\n+                    && !type.equals(getSignatureFormatOfType(BYTE))\n+                    && !type.equals(getSignatureFormatOfType(SHORT))\n+                    && !type.equals(getSignatureFormatOfType(INTEGER))\n+                    && !type.equals(getSignatureFormatOfType(LONG)) && !type.equals(Signature.SIG_BYTE)\n+                    && !type.equals(Signature.SIG_SHORT) && !type.equals(Signature.SIG_INT)\n+                    && !type.equals(Signature.SIG_LONG)) {\n \n-                Diagnostic diagnostic = new Diagnostic(fieldAnnotationrange,\n+                Diagnostic diagnostic = new Diagnostic(range,\n                         \"The @\" + annotation.getElementName()\n                                 + \" annotation can only be used on \\n- BigDecimal \\n- BigInteger\"\n-                                + \"\\n- byte, short, int, long (and their respective wrappers) \\n type fields.\");\n-                diagnostic.setCode(DIAGNOSTIC_CODE_FIELD);\n+                                + \"\\n- byte, short, int, long (and their respective wrappers) \\n type \" + source);\n+                diagnostic.setCode(DIAGNOSTIC_CODE_INVALID_TYPE);\n                 completeDiagnostic(diagnostic);\n                 diagnostics.add(diagnostic);\n             }\n         } else if (annotation.getElementName().equals(NEGATIVE) || annotation.getElementName().equals(NEGATIVE_OR_ZERO)\n                 || annotation.getElementName().equals(POSITIVE)\n                 || annotation.getElementName().equals(POSTIVE_OR_ZERO)) {\n \n-            if (!fieldType.equals(getSignatureFormatOfType(BIG_DECIMAL))\n-                    && !fieldType.equals(getSignatureFormatOfType(BIG_INTEGER))\n-                    && !fieldType.equals(getSignatureFormatOfType(BYTE))\n-                    && !fieldType.equals(getSignatureFormatOfType(SHORT))\n-                    && !fieldType.equals(getSignatureFormatOfType(INTEGER))\n-                    && !fieldType.equals(getSignatureFormatOfType(LONG))\n-                    && !fieldType.equals(getSignatureFormatOfType(FLOAT))\n-                    && !fieldType.equals(getSignatureFormatOfType(DOUBLE)) && !fieldType.equals(Signature.SIG_BYTE)\n-                    && !fieldType.equals(Signature.SIG_SHORT) && !fieldType.equals(Signature.SIG_INT)\n-                    && !fieldType.equals(Signature.SIG_LONG) && !fieldType.equals(Signature.SIG_FLOAT)\n-                    && !fieldType.equals(Signature.SIG_DOUBLE)) {\n-\n-                Diagnostic diagnostic = new Diagnostic(fieldAnnotationrange, \"The @\" + annotation.getElementName()\n+            if (!type.equals(getSignatureFormatOfType(BIG_DECIMAL))\n+                    && !type.equals(getSignatureFormatOfType(BIG_INTEGER))\n+                    && !type.equals(getSignatureFormatOfType(BYTE))\n+                    && !type.equals(getSignatureFormatOfType(SHORT))\n+                    && !type.equals(getSignatureFormatOfType(INTEGER))\n+                    && !type.equals(getSignatureFormatOfType(LONG))\n+                    && !type.equals(getSignatureFormatOfType(FLOAT))\n+                    && !type.equals(getSignatureFormatOfType(DOUBLE)) && !type.equals(Signature.SIG_BYTE)\n+                    && !type.equals(Signature.SIG_SHORT) && !type.equals(Signature.SIG_INT)\n+                    && !type.equals(Signature.SIG_LONG) && !type.equals(Signature.SIG_FLOAT)\n+                    && !type.equals(Signature.SIG_DOUBLE)) {\n+\n+                Diagnostic diagnostic = new Diagnostic(range, \"The @\" + annotation.getElementName()\n                         + \" annotation can only be used on \\n- BigDecimal \\n- BigInteger\"\n-                        + \"\\n- byte, short, int, long, float, double (and their respective wrappers) \\n type fields.\");\n-                diagnostic.setCode(DIAGNOSTIC_CODE_FIELD);\n+                        + \"\\n- byte, short, int, long, float, double (and their respective wrappers) \\n type \" + source);\n+                diagnostic.setCode(DIAGNOSTIC_CODE_INVALID_TYPE);\n                 completeDiagnostic(diagnostic);\n                 diagnostics.add(diagnostic);\n             }\n         } else if (annotation.getElementName().equals(NOT_BLANK)) {\n \n-            if (!fieldType.equals(getSignatureFormatOfType(STRING))\n-                    && !fieldType.equals(getSignatureFormatOfType(CHAR_SEQUENCE))) {\n+            if (!type.equals(getSignatureFormatOfType(STRING))\n+                    && !type.equals(getSignatureFormatOfType(CHAR_SEQUENCE))) {\n \n-                Diagnostic diagnostic = new Diagnostic(fieldAnnotationrange, \"The @\" + annotation.getElementName()\n-                        + \" annotation can only be used on String and CharSequence type fields.\");\n-                diagnostic.setCode(DIAGNOSTIC_CODE_FIELD);\n+                Diagnostic diagnostic = new Diagnostic(range, \"The @\" + annotation.getElementName()\n+                        + \" annotation can only be used on String and CharSequence type \" + source);\n+                diagnostic.setCode(DIAGNOSTIC_CODE_INVALID_TYPE);\n                 completeDiagnostic(diagnostic);\n                 diagnostics.add(diagnostic);\n             }\n         } else if (annotation.getElementName().equals(PATTERN)) {\n \n-            if (!fieldType.equals(getSignatureFormatOfType(STRING))\n-                    && !fieldType.equals(getSignatureFormatOfType(CHAR_SEQUENCE))) {\n+            if (!type.equals(getSignatureFormatOfType(STRING))\n+                    && !type.equals(getSignatureFormatOfType(CHAR_SEQUENCE))) {\n \n-                Diagnostic diagnostic = new Diagnostic(fieldAnnotationrange, \"The @\" + annotation.getElementName()\n-                        + \" annotation can only be used on String and CharSequence type fields.\");\n-                diagnostic.setCode(DIAGNOSTIC_CODE_FIELD);\n+                Diagnostic diagnostic = new Diagnostic(range, \"The @\" + annotation.getElementName()\n+                        + \" annotation can only be used on String and CharSequence type \" + source);\n+                diagnostic.setCode(DIAGNOSTIC_CODE_INVALID_TYPE);\n                 completeDiagnostic(diagnostic);\n                 diagnostics.add(diagnostic);\n             }"
  },
  {
    "sha": "df17e77f9a59dc9df41fda37ea90d4a3bf090c44",
    "filename": "jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/beanvalidation/BeanValidationQuickFix.java",
    "status": "added",
    "additions": 90,
    "deletions": 0,
    "changes": 90,
    "blob_url": "https://github.com/eclipse/lsp4jakarta/blob/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/beanvalidation/BeanValidationQuickFix.java",
    "raw_url": "https://github.com/eclipse/lsp4jakarta/raw/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/beanvalidation/BeanValidationQuickFix.java",
    "contents_url": "https://api.github.com/repos/eclipse/lsp4jakarta/contents/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/beanvalidation/BeanValidationQuickFix.java?ref=dcccd8d9ec130b20d684c31440c5dd44172fdc64",
    "patch": "@@ -0,0 +1,90 @@\n+/*******************************************************************************\n+* Copyright (c) 2021 IBM Corporation and others.\n+*\n+* This program and the accompanying materials are made available under the\n+* terms of the Eclipse Public License v. 2.0 which is available at\n+* http://www.eclipse.org/legal/epl-2.0.\n+*\n+* SPDX-License-Identifier: EPL-2.0\n+*\n+* Contributors:\n+*     IBM Corporation - initial API and implementation\n+*******************************************************************************/\n+package org.jakarta.jdt.beanvalidation;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.jdt.core.dom.ASTNode;\n+import org.eclipse.jdt.core.dom.IBinding;\n+import org.eclipse.jdt.core.dom.VariableDeclarationFragment;\n+import org.eclipse.jdt.internal.corext.dom.Bindings;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.jakarta.codeAction.IJavaCodeActionParticipant;\n+import org.jakarta.codeAction.JavaCodeActionContext;\n+import org.jakarta.codeAction.proposal.ChangeCorrectionProposal;\n+import org.jakarta.codeAction.proposal.DeleteAnnotationProposal;\n+import org.jakarta.codeAction.proposal.ModifyModifiersProposal;\n+\n+/**\n+ * Quickfix for fixing {@link BeanValidationConstants#DIAGNOSTIC_CODE_Static} error by either action \n+ * 1. Removing constraint annotation on static field or method\n+ * 2. Removing static modifier from field or method\n+ * \n+ * @author Leslie Dawson (lamminade)\n+ *\n+ */\n+public class BeanValidationQuickFix implements IJavaCodeActionParticipant {\n+\n+    @Override\n+    public List<? extends CodeAction> getCodeActions(JavaCodeActionContext context, Diagnostic diagnostic,\n+            IProgressMonitor monitor) throws CoreException {\n+        ASTNode node = context.getCoveredNode();\n+        IBinding parentType = getBinding(node);\n+\n+        List<CodeAction> codeActions = new ArrayList<>();\n+        codeActions.add(removeConstraintAnnotations(diagnostic, context, parentType));\n+\n+        if (diagnostic.getCode().getLeft().equals(BeanValidationConstants.DIAGNOSTIC_CODE_STATIC)) {\n+            codeActions.add(removeStaticModifier(diagnostic, context, parentType));\n+        }\n+\n+        return codeActions;\n+    }\n+\n+    private CodeAction removeConstraintAnnotations(Diagnostic diagnostic, JavaCodeActionContext context, IBinding parentType) throws CoreException {\n+        String name = \"Remove constraint annotation from element\";\n+        String[] annotations = BeanValidationConstants.SET_OF_ANNOTATIONS.stream().toArray((String[]::new));\n+        ChangeCorrectionProposal proposal = new DeleteAnnotationProposal(name, context.getCompilationUnit(),\n+                context.getASTRoot(), parentType, 0, context.getCoveredNode().getParent(), annotations);\n+        CodeAction codeAction = context.convertToCodeAction(proposal, diagnostic);\n+\n+        if (codeAction != null) {\n+            return codeAction;\n+        }\n+        return null;\n+    }\n+\n+    private CodeAction removeStaticModifier(Diagnostic diagnostic, JavaCodeActionContext context, IBinding parentType) throws CoreException {\n+        String name = \"Remove static modifier from element\";\n+        ModifyModifiersProposal proposal = new ModifyModifiersProposal(name, context.getCompilationUnit(), \n+                context.getASTRoot(), parentType, 0, context.getCoveredNode().getParent(), new ArrayList<>(), Arrays.asList(\"static\"));\n+        CodeAction codeAction = context.convertToCodeAction(proposal, diagnostic);\n+\n+        if (codeAction != null) {\n+            return codeAction;\n+        }\n+        return null;\n+    }\n+\n+    protected IBinding getBinding(ASTNode node) {\n+        if (node.getParent() instanceof VariableDeclarationFragment) {\n+            return ((VariableDeclarationFragment) node.getParent()).resolveBinding();\n+        }\n+        return Bindings.getBindingOfParentType(node);\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "61f67ba3281dc201981bba1ed4d85e8bf3428c30",
    "filename": "jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/persistence/PersistenceEntityQuickFix.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/eclipse/lsp4jakarta/blob/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/persistence/PersistenceEntityQuickFix.java",
    "raw_url": "https://github.com/eclipse/lsp4jakarta/raw/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/persistence/PersistenceEntityQuickFix.java",
    "contents_url": "https://api.github.com/repos/eclipse/lsp4jakarta/contents/jakarta-eclipse/org.eclipse.lsp4jakarta.core/src/org/jakarta/jdt/persistence/PersistenceEntityQuickFix.java?ref=dcccd8d9ec130b20d684c31440c5dd44172fdc64",
    "patch": "@@ -111,7 +111,7 @@ protected static IBinding getBinding(ASTNode node) {\n         name = \"Add a no-arg public constructor to this class\";\n         proposal = new AddConstructorProposal(name,\n                 context.getCompilationUnit(), context.getASTRoot(), parentType, 0, \"public\");\n-         codeAction = context.convertToCodeAction(proposal, diagnostic);\n+        codeAction = context.convertToCodeAction(proposal, diagnostic);\n \n         if (codeAction != null) {\n             codeActions.add(codeAction);\n@@ -127,7 +127,7 @@ protected static IBinding getBinding(ASTNode node) {\n         String type = \"\";\n         if (diagnostic.getCode().getLeft().equals(PersistenceConstants.DIAGNOSTIC_CODE_FINAL_METHODS)) {\n             type = \"method\";\n-            coveredNode = context.getCoveredNode();\n+            coveredNode = context.getCoveredNode().getParent();\n         } else if (diagnostic.getCode().getLeft().equals(PersistenceConstants.DIAGNOSTIC_CODE_FINAL_VARIABLES)) {\n             type = \"variable\";\n         } else if (diagnostic.getCode().getLeft().equals(PersistenceConstants.DIAGNOSTIC_CODE_FINAL_CLASS)) {"
  },
  {
    "sha": "2568e28a559314add8e7ac61ecc8bb953edf06c9",
    "filename": "jakarta-eclipse/org.eclipse.lsp4jakarta.tests/projects/jakarta-sample/src/main/java/io/openliberty/sample/jakarta/beanvalidation/FieldConstraintValidation.java",
    "status": "added",
    "additions": 65,
    "deletions": 0,
    "changes": 65,
    "blob_url": "https://github.com/eclipse/lsp4jakarta/blob/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.tests/projects/jakarta-sample/src/main/java/io/openliberty/sample/jakarta/beanvalidation/FieldConstraintValidation.java",
    "raw_url": "https://github.com/eclipse/lsp4jakarta/raw/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.tests/projects/jakarta-sample/src/main/java/io/openliberty/sample/jakarta/beanvalidation/FieldConstraintValidation.java",
    "contents_url": "https://api.github.com/repos/eclipse/lsp4jakarta/contents/jakarta-eclipse/org.eclipse.lsp4jakarta.tests/projects/jakarta-sample/src/main/java/io/openliberty/sample/jakarta/beanvalidation/FieldConstraintValidation.java?ref=dcccd8d9ec130b20d684c31440c5dd44172fdc64",
    "patch": "@@ -0,0 +1,65 @@\n+package io.openliberty.sample.jakarta.beanvalidation;\n+\n+import java.util.Calendar;\n+import java.util.List;\n+\n+import jakarta.validation.constraints.*;\n+\n+public class FieldConstraintValidation {\n+\n+    @AssertTrue\n+    private int isHappy;                    // invalid types\n+\n+    @AssertFalse\n+    private Double isSad;\n+\n+    @DecimalMax(\"30.0\")\n+    @DecimalMin(\"10.0\")\n+    private String bigDecimal;\n+\n+    @Digits(fraction = 0, integer = 0)\n+    private boolean digits;\n+\n+    @Email\n+    private Integer emailAddress;\n+\n+    @FutureOrPresent\n+    private boolean graduationDate;\n+\n+    @Future\n+    private double fergiesYear;\n+\n+    @Min(value = 50)\n+    @Max(value = 100)\n+    private boolean gpa;\n+\n+    @Negative\n+    private boolean subZero;\n+\n+    @NegativeOrZero\n+    private String notPos;\n+\n+    @NotBlank\n+    private boolean saysomething;\n+\n+    @Pattern(regexp = \"\")\n+    private Calendar thisIsUsed;\n+\n+    @Past\n+    private double theGoodOldDays;\n+\n+    @PastOrPresent\n+    private char[] aGoodFieldName;\n+\n+    @Positive\n+    private String[] area;\n+\n+    @PositiveOrZero\n+    private List<String> maybeZero;\n+\n+    @AssertTrue\n+    private static boolean typeValid;       // static\n+\n+    @Past\n+    private static boolean doubleBad;      // static and invalid type\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "e43c58597f927c6a47a3ae8d49d0e23a1f6638ac",
    "filename": "jakarta-eclipse/org.eclipse.lsp4jakarta.tests/projects/jakarta-sample/src/main/java/io/openliberty/sample/jakarta/beanvalidation/MethodConstraintValidation.java",
    "status": "added",
    "additions": 35,
    "deletions": 0,
    "changes": 35,
    "blob_url": "https://github.com/eclipse/lsp4jakarta/blob/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.tests/projects/jakarta-sample/src/main/java/io/openliberty/sample/jakarta/beanvalidation/MethodConstraintValidation.java",
    "raw_url": "https://github.com/eclipse/lsp4jakarta/raw/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.tests/projects/jakarta-sample/src/main/java/io/openliberty/sample/jakarta/beanvalidation/MethodConstraintValidation.java",
    "contents_url": "https://api.github.com/repos/eclipse/lsp4jakarta/contents/jakarta-eclipse/org.eclipse.lsp4jakarta.tests/projects/jakarta-sample/src/main/java/io/openliberty/sample/jakarta/beanvalidation/MethodConstraintValidation.java?ref=dcccd8d9ec130b20d684c31440c5dd44172fdc64",
    "patch": "@@ -0,0 +1,35 @@\n+package io.openliberty.sample.jakarta.beanvalidation;\n+\n+import jakarta.validation.constraints.AssertFalse;\n+import jakarta.validation.constraints.AssertTrue;\n+\n+public class MethodConstraintValidation {\n+\n+    // valid cases\n+    @AssertFalse\n+    private boolean falseMethod() {\n+        return false;\n+    }\n+\n+    @AssertTrue\n+    public boolean trueMethod() {\n+        return true;\n+    }\n+\n+    // invalid cases\n+    @AssertTrue\n+    public static boolean anotherTruth() {  // static\n+        return true;\n+    }\n+\n+    @AssertTrue\n+    public String notBoolean() {            // invalid type\n+        return \"aha!\";\n+    }\n+\n+    @AssertFalse\n+    private static int notBoolTwo(int x) {  // invalid type, static\n+        return x;\n+    }\n+   \n+}\n\\ No newline at end of file"
  },
  {
    "sha": "5ee8133c889cda921177d4c7959a193aafcf5a69",
    "filename": "jakarta-eclipse/org.eclipse.lsp4jakarta.tests/projects/jakarta-sample/src/main/java/io/openliberty/sample/jakarta/beanvalidation/ValidConstraints.java",
    "status": "added",
    "additions": 95,
    "deletions": 0,
    "changes": 95,
    "blob_url": "https://github.com/eclipse/lsp4jakarta/blob/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.tests/projects/jakarta-sample/src/main/java/io/openliberty/sample/jakarta/beanvalidation/ValidConstraints.java",
    "raw_url": "https://github.com/eclipse/lsp4jakarta/raw/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.tests/projects/jakarta-sample/src/main/java/io/openliberty/sample/jakarta/beanvalidation/ValidConstraints.java",
    "contents_url": "https://api.github.com/repos/eclipse/lsp4jakarta/contents/jakarta-eclipse/org.eclipse.lsp4jakarta.tests/projects/jakarta-sample/src/main/java/io/openliberty/sample/jakarta/beanvalidation/ValidConstraints.java?ref=dcccd8d9ec130b20d684c31440c5dd44172fdc64",
    "patch": "@@ -0,0 +1,95 @@\n+package io.openliberty.sample.jakarta.beanvalidation;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.sql.Time;\n+import java.time.OffsetDateTime;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.util.Calendar;\n+import java.util.Map;\n+\n+import jakarta.validation.constraints.Email;\n+import jakarta.validation.constraints.Future;\n+import jakarta.validation.constraints.FutureOrPresent;\n+import jakarta.validation.constraints.Max;\n+import jakarta.validation.constraints.Min;\n+import jakarta.validation.constraints.Negative;\n+import jakarta.validation.constraints.NegativeOrZero;\n+import jakarta.validation.constraints.NotBlank;\n+import jakarta.validation.constraints.NotEmpty;\n+import jakarta.validation.constraints.NotNull;\n+import jakarta.validation.constraints.Null;\n+import jakarta.validation.constraints.Past;\n+import jakarta.validation.constraints.PastOrPresent;\n+import jakarta.validation.constraints.Positive;\n+import jakarta.validation.constraints.PositiveOrZero;\n+import jakarta.validation.constraints.Size;\n+import jakarta.validation.constraints.AssertFalse;\n+import jakarta.validation.constraints.AssertTrue;\n+import jakarta.validation.constraints.DecimalMax;\n+import jakarta.validation.constraints.DecimalMin;\n+import jakarta.validation.constraints.Digits;\n+\n+public class ValidConstraints {\n+    @AssertTrue\n+    private boolean isHappy;\n+\n+    @AssertFalse\n+    private boolean isSad;\n+\n+    @DecimalMax(\"30.0\")\n+    @DecimalMin(\"10.0\")\n+    private BigDecimal bigDecimal;\n+    \n+    @Digits(integer=5, fraction=1)\n+    private BigInteger digies;\n+    \n+    @Email\n+    private String emailAddress;\n+    \n+    @FutureOrPresent\n+    private Calendar graduationDate;\n+    \n+    @Future\n+    private Year fergiesYear;\n+\n+    @Min(value = 50)\n+    @Max(value = 100)\n+    private Integer gpa;\n+    \n+    @Negative\n+    private int subZero;\n+    \n+    @NegativeOrZero\n+    private double notPos;\n+    \n+    @NotBlank\n+    private String saysomething;\n+   \n+//    not yet implemented - see issue #63\n+//    @NotEmpty\n+//    private String imgivinguponyou;\n+    \n+    @NotNull\n+    private String thisIsUsed;\n+    \n+    @Null\n+    private String NeverUsed;\n+\n+    @Past\n+    private OffsetDateTime theGoodOldDays;\n+    \n+    @PastOrPresent\n+    private YearMonth aGoodFieldName;\n+    \n+    @Positive\n+    private int area;\n+    \n+    @PositiveOrZero\n+    private int maybeZero;\n+\n+//    not yet implemented - see issue #63\n+//    @Size\n+//    private boolean wordMap;\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "2a736c1106a86b7911eabd6c84e5dbaf2ded0fe4",
    "filename": "jakarta-eclipse/org.eclipse.lsp4jakarta.tests/src/main/java/org/eclipse/lsp4jakarta/jdt/beanvalidation/BeanValidationTest.java",
    "status": "added",
    "additions": 241,
    "deletions": 0,
    "changes": 241,
    "blob_url": "https://github.com/eclipse/lsp4jakarta/blob/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.tests/src/main/java/org/eclipse/lsp4jakarta/jdt/beanvalidation/BeanValidationTest.java",
    "raw_url": "https://github.com/eclipse/lsp4jakarta/raw/dcccd8d9ec130b20d684c31440c5dd44172fdc64/jakarta-eclipse/org.eclipse.lsp4jakarta.tests/src/main/java/org/eclipse/lsp4jakarta/jdt/beanvalidation/BeanValidationTest.java",
    "contents_url": "https://api.github.com/repos/eclipse/lsp4jakarta/contents/jakarta-eclipse/org.eclipse.lsp4jakarta.tests/src/main/java/org/eclipse/lsp4jakarta/jdt/beanvalidation/BeanValidationTest.java?ref=dcccd8d9ec130b20d684c31440c5dd44172fdc64",
    "patch": "@@ -0,0 +1,241 @@\n+/*******************************************************************************\n+* Copyright (c) 2021 IBM Corporation and others.\n+*\n+* This program and the accompanying materials are made available under the\n+* terms of the Eclipse Public License v. 2.0 which is available at\n+* http://www.eclipse.org/legal/epl-2.0.\n+*\n+* SPDX-License-Identifier: EPL-2.0\n+*\n+* Contributors:\n+*     IBM Corporation - initial API and implementation\n+*******************************************************************************/\n+package org.eclipse.lsp4jakarta.jdt.beanvalidation;\n+\n+import static org.eclipse.lsp4jakarta.jdt.core.JakartaForJavaAssert.assertJavaCodeAction;\n+import static org.eclipse.lsp4jakarta.jdt.core.JakartaForJavaAssert.assertJavaDiagnostics;\n+import static org.eclipse.lsp4jakarta.jdt.core.JakartaForJavaAssert.ca;\n+import static org.eclipse.lsp4jakarta.jdt.core.JakartaForJavaAssert.createCodeActionParams;\n+import static org.eclipse.lsp4jakarta.jdt.core.JakartaForJavaAssert.d;\n+import static org.eclipse.lsp4jakarta.jdt.core.JakartaForJavaAssert.te;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.runtime.Path;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.DiagnosticSeverity;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4jakarta.jdt.core.BaseJakartaTest;\n+import org.jakarta.jdt.JDTUtils;\n+import org.junit.Test;\n+\n+import io.microshed.jakartals.commons.JakartaDiagnosticsParams;\n+import io.microshed.jakartals.commons.JakartaJavaCodeActionParams;\n+\n+public class BeanValidationTest extends BaseJakartaTest {\n+    protected static JDTUtils JDT_UTILS = new JDTUtils();\n+\n+    @Test\n+    public void validFieldConstraints() throws Exception {\n+        JDTUtils utils = JDT_UTILS;\n+        IJavaProject javaProject = loadJavaProject(\"jakarta-sample\", \"\");\n+\n+        IFile javaFile = javaProject.getProject().getFile(\n+                new Path(\"src/main/java/io/openliberty/sample/jakarta/beanvalidation/ValidConstraints.java\"));\n+        String uri = javaFile.getLocation().toFile().toURI().toString();\n+\n+        JakartaDiagnosticsParams diagnosticsParams = new JakartaDiagnosticsParams();\n+        diagnosticsParams.setUris(Arrays.asList(uri));\n+\n+        // should be no errors \n+        assertJavaDiagnostics(diagnosticsParams, utils);\n+    }\n+\n+    @Test\n+    public void fieldConstraintValidation() throws Exception {\n+        JDTUtils utils = JDT_UTILS;\n+        IJavaProject javaProject = loadJavaProject(\"jakarta-sample\", \"\");\n+\n+        IFile javaFile = javaProject.getProject().getFile(\n+                new Path(\"src/main/java/io/openliberty/sample/jakarta/beanvalidation/FieldConstraintValidation.java\"));\n+        String uri = javaFile.getLocation().toFile().toURI().toString();\n+\n+        JakartaDiagnosticsParams diagnosticsParams = new JakartaDiagnosticsParams();\n+        diagnosticsParams.setUris(Arrays.asList(uri));\n+\n+        // Test diagnostics\n+        Diagnostic d1 = d(10, 16, 23,\n+                \"The @AssertTrue annotation can only be used on boolean and Boolean type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d2 = d(13, 19, 24,\n+                \"The @AssertFalse annotation can only be used on boolean and Boolean type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d3 = d(17, 19, 29,\n+                \"The @DecimalMax annotation can only be used on: \\n\"\n+                + \"- BigDecimal \\n\"\n+                + \"- BigInteger \\n\"\n+                + \"- CharSequence\\n\"\n+                + \"- byte, short, int, long (and their respective wrappers) \\n\"\n+                + \" type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d4 = d(17, 19, 29,\n+                \"The @DecimalMin annotation can only be used on: \\n\"\n+                + \"- BigDecimal \\n\"\n+                + \"- BigInteger \\n\"\n+                + \"- CharSequence\\n\"\n+                + \"- byte, short, int, long (and their respective wrappers) \\n\"\n+                + \" type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d5 = d(20, 20, 26,\n+                \"The @Digits annotation can only be used on: \\n\"\n+                + \"- BigDecimal \\n\"\n+                + \"- BigInteger \\n\"\n+                + \"- CharSequence\\n\"\n+                + \"- byte, short, int, long (and their respective wrappers) \\n\"\n+                + \" type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d6 = d(23, 20, 32,\n+                \"The @Email annotation can only be used on String and CharSequence type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d7 = d(26, 20, 34,\n+                \"The @FutureOrPresent annotation can only be used on: Date, Calendar, Instant, LocalDate, LocalDateTime, LocalTime, MonthDay, OffsetDateTime, OffsetTime, Year, YearMonth, ZonedDateTime, HijrahDate, JapaneseDate, JapaneseDate, MinguoDate and ThaiBuddhistDate type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d8 = d(29, 19, 30,\n+                \"The @Future annotation can only be used on: Date, Calendar, Instant, LocalDate, LocalDateTime, LocalTime, MonthDay, OffsetDateTime, OffsetTime, Year, YearMonth, ZonedDateTime, HijrahDate, JapaneseDate, JapaneseDate, MinguoDate and ThaiBuddhistDate type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d9 = d(33, 20, 23,\n+                \"The @Min annotation can only be used on \\n\"\n+                        + \"- BigDecimal \\n\"\n+                        + \"- BigInteger\\n\"\n+                        + \"- byte, short, int, long (and their respective wrappers) \\n\"\n+                        + \" type fields.\",\n+                        DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d10 = d(33, 20, 23,\n+                \"The @Max annotation can only be used on \\n\"\n+                + \"- BigDecimal \\n\"\n+                + \"- BigInteger\\n\"\n+                + \"- byte, short, int, long (and their respective wrappers) \\n\"\n+                + \" type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d11 = d(36, 20, 27,\n+                \"The @Negative annotation can only be used on \\n\"\n+                + \"- BigDecimal \\n\"\n+                + \"- BigInteger\\n\"\n+                + \"- byte, short, int, long, float, double (and their respective wrappers) \\n\"\n+                + \" type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d12 = d(39, 19, 25,\n+                \"The @NegativeOrZero annotation can only be used on \\n\"\n+                + \"- BigDecimal \\n\"\n+                + \"- BigInteger\\n\"\n+                + \"- byte, short, int, long, float, double (and their respective wrappers) \\n\"\n+                + \" type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d13 = d(42, 20, 32,\n+                \"The @NotBlank annotation can only be used on String and CharSequence type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d14 = d(45, 21, 31,\n+                \"The @Pattern annotation can only be used on String and CharSequence type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d15 = d(48, 19, 33,\n+                \"The @Past annotation can only be used on: Date, Calendar, Instant, LocalDate, LocalDateTime, LocalTime, MonthDay, OffsetDateTime, OffsetTime, Year, YearMonth, ZonedDateTime, HijrahDate, JapaneseDate, JapaneseDate, MinguoDate and ThaiBuddhistDate type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d16 = d(51, 19, 33,\n+                \"The @PastOrPresent annotation can only be used on: Date, Calendar, Instant, LocalDate, LocalDateTime, LocalTime, MonthDay, OffsetDateTime, OffsetTime, Year, YearMonth, ZonedDateTime, HijrahDate, JapaneseDate, JapaneseDate, MinguoDate and ThaiBuddhistDate type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d17 = d(54, 21, 25,\n+                \"The @Positive annotation can only be used on \\n\"\n+                + \"- BigDecimal \\n\"\n+                + \"- BigInteger\\n\"\n+                + \"- byte, short, int, long, float, double (and their respective wrappers) \\n\"\n+                + \" type fields.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        // not yet implemented\n+//        Diagnostic d18 = d(11, 17, 24,\n+//                \"The @PositiveOrZero annotation can only be used on boolean and Boolean type fields.\",\n+//                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d19 = d(60, 27, 36,\n+                \"Constraint annotations are not allowed on static fields\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"MakeNotStatic\");\n+        Diagnostic d20 = d(63, 27, 36,\n+                \"Constraint annotations are not allowed on static fields\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"MakeNotStatic\");\n+        \n+        assertJavaDiagnostics(diagnosticsParams, utils, d1, d2, d3, d4, d5, d6, d7, d8,\n+                d9, d10, d11, d12, d13, d14, d15, d16, d17, d19, d20);\n+\n+        // Test quickfix codeActions - type (1-17), static, static+type (should only display static)\n+        JakartaJavaCodeActionParams codeActionParams = createCodeActionParams(uri, d1);\n+        TextEdit te = te(9, 4, 10, 4, \"\");\n+        CodeAction ca = ca(uri, \"Remove constraint annotation from element\", d1, te);    \n+\n+        assertJavaCodeAction(codeActionParams, utils, ca);\n+\n+        JakartaJavaCodeActionParams codeActionParams2 = createCodeActionParams(uri, d19);\n+        TextEdit te1 = te(59, 4, 60, 4, \"\");\n+        TextEdit te2 = te(60, 11, 60, 18, \"\");\n+        CodeAction ca1 = ca(uri, \"Remove constraint annotation from element\", d19, te1);\n+        CodeAction ca2 = ca(uri, \"Remove static modifier from element\", d19, te2);\n+\n+        assertJavaCodeAction(codeActionParams2, utils, ca1, ca2);\n+        \n+\n+        JakartaJavaCodeActionParams codeActionParams3 = createCodeActionParams(uri, d20);\n+        TextEdit te3 = te(62, 4, 63, 4, \"\");\n+        TextEdit te4 = te(63, 11, 63, 18, \"\");\n+        CodeAction ca3 = ca(uri, \"Remove constraint annotation from element\", d20, te3);\n+        CodeAction ca4 = ca(uri, \"Remove static modifier from element\", d20, te4);\n+\n+        assertJavaCodeAction(codeActionParams3, utils, ca3, ca4);\n+    }\n+    \n+    @Test\n+    public void methodConstraintValidation() throws Exception {\n+        JDTUtils utils = JDT_UTILS;\n+        IJavaProject javaProject = loadJavaProject(\"jakarta-sample\", \"\");\n+\n+        IFile javaFile = javaProject.getProject().getFile(\n+                new Path(\"src/main/java/io/openliberty/sample/jakarta/beanvalidation/MethodConstraintValidation.java\"));\n+        String uri = javaFile.getLocation().toFile().toURI().toString();\n+\n+        JakartaDiagnosticsParams diagnosticsParams = new JakartaDiagnosticsParams();\n+        diagnosticsParams.setUris(Arrays.asList(uri));\n+\n+        // Test diagnostics\n+        Diagnostic d1 = d(20, 26, 38,\n+                \"Constraint annotations are not allowed on static methods\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"MakeNotStatic\");\n+        Diagnostic d2 = d(25, 18, 28,\n+                \"The @AssertTrue annotation can only be used on boolean and Boolean type methods.\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"FixTypeOfElement\");\n+        Diagnostic d3 = d(30, 23, 33,\n+                \"Constraint annotations are not allowed on static methods\",\n+                DiagnosticSeverity.Error, \"jakarta-bean-validation\", \"MakeNotStatic\");\n+        \n+        assertJavaDiagnostics(diagnosticsParams, utils, d1, d2, d3);\n+\n+        // Test quickfix codeActions\n+        JakartaJavaCodeActionParams codeActionParams = createCodeActionParams(uri, d1);\n+        TextEdit te = te(19, 4, 20, 4, \"\");\n+        TextEdit te2 = te(20, 10, 20, 17, \"\");\n+        CodeAction ca = ca(uri, \"Remove constraint annotation from element\", d1, te);\n+        CodeAction ca2 = ca(uri, \"Remove static modifier from element\", d1, te2);\n+\n+        assertJavaCodeAction(codeActionParams, utils, ca, ca2);\n+\n+        codeActionParams = createCodeActionParams(uri, d2);\n+        te = te(24, 4, 25, 4, \"\");\n+        ca = ca(uri, \"Remove constraint annotation from element\", d2, te);    \n+\n+        assertJavaCodeAction(codeActionParams, utils, ca);\n+        \n+        codeActionParams = createCodeActionParams(uri, d3);\n+        te = te(19, 4, 20, 4, \"\");\n+        te2 = te(20, 10, 20, 17, \"\");\n+        ca = ca(uri, \"Remove constraint annotation from element\", d3, te);\n+        ca2 = ca(uri, \"Remove static modifier from element\", d3, te2);\n+    }\n+}"
  }
]
