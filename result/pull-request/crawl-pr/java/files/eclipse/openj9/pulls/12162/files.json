[
  {
    "sha": "9452c555d896878da219b3295c5b0fc215bab453",
    "filename": "runtime/compiler/codegen/J9RecognizedMethodsEnum.hpp",
    "status": "modified",
    "additions": 4,
    "deletions": 1,
    "changes": 5,
    "blob_url": "https://github.com/eclipse/openj9/blob/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/codegen/J9RecognizedMethodsEnum.hpp",
    "raw_url": "https://github.com/eclipse/openj9/raw/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/codegen/J9RecognizedMethodsEnum.hpp",
    "contents_url": "https://api.github.com/repos/eclipse/openj9/contents/runtime/compiler/codegen/J9RecognizedMethodsEnum.hpp?ref=8a986c5f09055ee6eea0371359f76d4d228af995",
    "patch": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2000, 2020 IBM Corp. and others\n+ * Copyright (c) 2000, 2021 IBM Corp. and others\n  *\n  * This program and the accompanying materials are made available under\n  * the terms of the Eclipse Public License 2.0 which accompanies this\n@@ -1022,6 +1022,9 @@\n    java_lang_invoke_MethodHandle_linkToSpecial,\n    java_lang_invoke_MethodHandle_linkToVirtual,\n    java_lang_invoke_MethodHandle_linkToInterface,\n+   java_lang_invoke_DirectMethodHandle_internalMemberName,\n+   java_lang_invoke_DirectMethodHandle_internalMemberNameEnsureInit,\n+   java_lang_invoke_DirectMethodHandle_constructorMethod,\n    java_lang_invoke_MethodHandles_getStackClass,\n    java_lang_invoke_MethodHandle_type,\n    java_lang_invoke_MethodHandle_undoCustomizationLogic,"
  },
  {
    "sha": "8eb149d032c26d8b832545226c0fcd16cefd4b6a",
    "filename": "runtime/compiler/env/VMJ9.cpp",
    "status": "modified",
    "additions": 12,
    "deletions": 0,
    "changes": 12,
    "blob_url": "https://github.com/eclipse/openj9/blob/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/env/VMJ9.cpp",
    "raw_url": "https://github.com/eclipse/openj9/raw/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/env/VMJ9.cpp",
    "contents_url": "https://api.github.com/repos/eclipse/openj9/contents/runtime/compiler/env/VMJ9.cpp?ref=8a986c5f09055ee6eea0371359f76d4d228af995",
    "patch": "@@ -3113,6 +3113,18 @@ TR_J9VMBase::isMethodTracingEnabled(TR_OpaqueMethodBlock *method)\n    return VM_VMHelpers::methodBeingTraced(_jitConfig->javaVM, (J9Method *)method);\n    }\n \n+bool\n+TR_J9VMBase::isLambdaFormGeneratedMethod(TR_OpaqueMethodBlock *method)\n+   {\n+   return VM_VMHelpers::isLambdaFormGeneratedMethod(vmThread(), (J9Method *)method);\n+   }\n+\n+bool\n+TR_J9VMBase::isLambdaFormGeneratedMethod(TR_ResolvedMethod *method)\n+   {\n+   return isLambdaFormGeneratedMethod(method->getPersistentIdentifier());\n+   }\n+\n bool\n TR_J9VMBase::isSelectiveMethodEnterExitEnabled()\n    {"
  },
  {
    "sha": "f75a643ac73f5f7e1e540136a733bf075282c5a9",
    "filename": "runtime/compiler/env/VMJ9.h",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/eclipse/openj9/blob/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/env/VMJ9.h",
    "raw_url": "https://github.com/eclipse/openj9/raw/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/env/VMJ9.h",
    "contents_url": "https://api.github.com/repos/eclipse/openj9/contents/runtime/compiler/env/VMJ9.h?ref=8a986c5f09055ee6eea0371359f76d4d228af995",
    "patch": "@@ -1007,6 +1007,10 @@ class TR_J9VMBase : public TR_FrontEnd\n       return isMethodTracingEnabled((TR_OpaqueMethodBlock *)j9method);\n       }\n \n+   // Is method generated for LambdaForm\n+   virtual bool isLambdaFormGeneratedMethod(TR_OpaqueMethodBlock *method);\n+   virtual bool isLambdaFormGeneratedMethod(TR_ResolvedMethod *method);\n+\n    virtual bool isSelectiveMethodEnterExitEnabled();\n \n    virtual bool canMethodEnterEventBeHooked();"
  },
  {
    "sha": "c62c0df8f67f8d6eea7bcd378e73b749695e0010",
    "filename": "runtime/compiler/env/j9method.cpp",
    "status": "modified",
    "additions": 9,
    "deletions": 0,
    "changes": 9,
    "blob_url": "https://github.com/eclipse/openj9/blob/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/env/j9method.cpp",
    "raw_url": "https://github.com/eclipse/openj9/raw/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/env/j9method.cpp",
    "contents_url": "https://api.github.com/repos/eclipse/openj9/contents/runtime/compiler/env/j9method.cpp?ref=8a986c5f09055ee6eea0371359f76d4d228af995",
    "patch": "@@ -3953,6 +3953,14 @@ void TR_ResolvedJ9Method::construct()\n       {  TR::unknownMethod}\n       };\n \n+   static X DirectMethodHandleMethods[] =\n+      {\n+      {x(TR::java_lang_invoke_DirectMethodHandle_internalMemberName,            \"internalMemberName\",                 \"(Ljava/lang/Object;)Ljava/lang/Object;\")},\n+      {x(TR::java_lang_invoke_DirectMethodHandle_internalMemberNameEnsureInit,  \"internalMemberNameEnsureInit\",       \"(Ljava/lang/Object;)Ljava/lang/Object;\")},\n+      {x(TR::java_lang_invoke_DirectMethodHandle_constructorMethod,             \"constructorMethod\",       \"(Ljava/lang/Object;)Ljava/lang/Object;\")},\n+      {  TR::unknownMethod}\n+      };\n+\n    static X PrimitiveHandleMethods[] =\n       {\n       {x(TR::java_lang_invoke_PrimitiveHandle_initializeClassIfRequired,  \"initializeClassIfRequired\",       \"()V\")},\n@@ -4463,6 +4471,7 @@ void TR_ResolvedJ9Method::construct()\n       {\n       { \"java/lang/invoke/ExplicitCastHandle\", ExplicitCastHandleMethods },\n       { \"jdk/internal/loader/NativeLibraries\", NativeLibrariesMethods },\n+      { \"java/lang/invoke/DirectMethodHandle\", DirectMethodHandleMethods },\n       { 0 }\n       };\n "
  },
  {
    "sha": "a49705c4ed549d2927f2ff050e5098d2b3bfc8d8",
    "filename": "runtime/compiler/optimizer/EstimateCodeSize.hpp",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/eclipse/openj9/blob/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/optimizer/EstimateCodeSize.hpp",
    "raw_url": "https://github.com/eclipse/openj9/raw/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/optimizer/EstimateCodeSize.hpp",
    "contents_url": "https://api.github.com/repos/eclipse/openj9/contents/runtime/compiler/optimizer/EstimateCodeSize.hpp?ref=8a986c5f09055ee6eea0371359f76d4d228af995",
    "patch": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2000, 2020 IBM Corp. and others\n+ * Copyright (c) 2000, 2021 IBM Corp. and others\n  *\n  * This program and the accompanying materials are made available under\n  * the terms of the Eclipse Public License 2.0 which accompanies this\n@@ -93,6 +93,7 @@ class TR_EstimateCodeSize\n \n    TR::Compilation *comp()              { return _inliner->comp(); }\n    TR_InlinerTracer *tracer()          { return _tracer; }\n+   TR_InlinerBase* getInliner()        { return _inliner; }\n \n    protected:\n "
  },
  {
    "sha": "1af43c9932f6ab106d0c628ea75a1e97f1dcda8e",
    "filename": "runtime/compiler/optimizer/InlinerTempForJ9.cpp",
    "status": "modified",
    "additions": 17,
    "deletions": 3,
    "changes": 20,
    "blob_url": "https://github.com/eclipse/openj9/blob/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/optimizer/InlinerTempForJ9.cpp",
    "raw_url": "https://github.com/eclipse/openj9/raw/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/optimizer/InlinerTempForJ9.cpp",
    "contents_url": "https://api.github.com/repos/eclipse/openj9/contents/runtime/compiler/optimizer/InlinerTempForJ9.cpp?ref=8a986c5f09055ee6eea0371359f76d4d228af995",
    "patch": "@@ -436,7 +436,8 @@ static bool checkForRemainingInlineableJSR292(TR::Compilation *comp, TR::Resolve\n                {\n                TR_ResolvedMethod * resolvedMethod = node->getSymbolReference()->getSymbol()->getResolvedMethodSymbol()->getResolvedMethod();\n                if (!node->isTheVirtualCallNodeForAGuardedInlinedCall() &&\n-                  (resolvedMethod->convertToMethod()->isArchetypeSpecimen() ||\n+                  (comp->fej9()->isLambdaFormGeneratedMethod(resolvedMethod) ||\n+                   resolvedMethod->convertToMethod()->isArchetypeSpecimen() ||\n                    resolvedMethod->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeExact))\n                   {\n                   return true;\n@@ -2374,6 +2375,9 @@ TR_J9InlinerPolicy::callMustBeInlined(TR_CallTarget *calltarget)\n    if (method->convertToMethod()->isArchetypeSpecimen())\n       return true;\n \n+   if (comp()->fej9()->isLambdaFormGeneratedMethod(method))\n+      return true;\n+\n    if (insideIntPipelineForEach(method, comp()))\n       {\n       if (comp()->trace(OMR::inlining))\n@@ -3839,7 +3843,8 @@ void TR_MultipleCallTargetInliner::weighCallSite( TR_CallStack * callStack , TR_\n \n       int32_t weightBeforeLookingForBenefits = weight;\n \n-      if (calltarget->_calleeMethod->convertToMethod()->isArchetypeSpecimen() && calltarget->_calleeMethod->getMethodHandleLocation())\n+      bool isLambdaFormGeneratedMethod = comp()->fej9()->isLambdaFormGeneratedMethod(calltarget->_calleeMethod);\n+      if ((calltarget->_calleeMethod->convertToMethod()->isArchetypeSpecimen() && calltarget->_calleeMethod->getMethodHandleLocation()) || isLambdaFormGeneratedMethod)\n          {\n          static char *methodHandleThunkWeightFactorStr = feGetEnv(\"TR_methodHandleThunkWeightFactor\");\n          static int32_t methodHandleThunkWeightFactor = methodHandleThunkWeightFactorStr? atoi(methodHandleThunkWeightFactorStr) : 10;\n@@ -4224,13 +4229,18 @@ TR_MultipleCallTargetInliner::exceedsSizeThreshold(TR_CallSite *callSite, int by\n      // HACK: Get frequency from both sources, and use both.  You're\n      // only cold if you're cold according to both.\n \n+     bool isLambdaFormGeneratedMethod = comp()->fej9()->isLambdaFormGeneratedMethod(callerResolvedMethod);\n+     // TODO: we should ignore frequency for thunk archetype, however, this require performance evaluation\n+     bool frequencyIsInaccurate = isLambdaFormGeneratedMethod;\n+\n      frequency1 = comp()->convertNonDeterministicInput(comp()->fej9()->getIProfilerCallCount(bcInfo, comp()), MAX_BLOCK_COUNT + MAX_COLD_BLOCK_COUNT, randomGenerator(), 0);\n      frequency2 = comp()->convertNonDeterministicInput(block->getFrequency(), MAX_BLOCK_COUNT + MAX_COLD_BLOCK_COUNT, randomGenerator(), 0);\n      if (frequency1 > frequency2 && callerResolvedMethod->convertToMethod()->isArchetypeSpecimen())\n         frequency2 = frequency1;\n \n      if ((frequency1 <= 0) && ((0 <= frequency2) &&  (frequency2 <= MAX_COLD_BLOCK_COUNT)) &&\n-        !alwaysWorthInlining(calleeResolvedMethod, callNode))\n+        !alwaysWorthInlining(calleeResolvedMethod, callNode) &&\n+        !frequencyIsInaccurate)\n         {\n         isCold = true;\n         }\n@@ -4240,6 +4250,7 @@ TR_MultipleCallTargetInliner::exceedsSizeThreshold(TR_CallSite *callSite, int by\n      if (allowBiggerMethods() &&\n          !comp()->getMethodSymbol()->doJSR292PerfTweaks() &&\n          calleeResolvedMethod &&\n+         !frequencyIsInaccurate &&\n          !j9InlinerPolicy->isInlineableJNI(calleeResolvedMethod, callNode))\n         {\n         bytecodeSize = scaleSizeBasedOnBlockFrequency(bytecodeSize,frequency2,borderFrequency, calleeResolvedMethod,callNode,veryColdBorderFrequency);\n@@ -5028,6 +5039,9 @@ bool TR_J9InlinerPolicy::isJSR292AlwaysWorthInlining(TR_ResolvedMethod *resolved\n    if (resolvedMethod->convertToMethod()->isArchetypeSpecimen())\n       return true;\n \n+   if (TR::comp()->fej9()->isLambdaFormGeneratedMethod(resolvedMethod))\n+      return true;\n+\n    return false;\n    }\n "
  },
  {
    "sha": "239bfb118c10c29b7319b3e14534c5257f7c182a",
    "filename": "runtime/compiler/optimizer/InterpreterEmulator.cpp",
    "status": "modified",
    "additions": 685,
    "deletions": 115,
    "changes": 800,
    "blob_url": "https://github.com/eclipse/openj9/blob/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/optimizer/InterpreterEmulator.cpp",
    "raw_url": "https://github.com/eclipse/openj9/raw/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/optimizer/InterpreterEmulator.cpp",
    "contents_url": "https://api.github.com/repos/eclipse/openj9/contents/runtime/compiler/optimizer/InterpreterEmulator.cpp?ref=8a986c5f09055ee6eea0371359f76d4d228af995",
    "patch": "@@ -27,11 +27,190 @@\n #include \"optimizer/J9CallGraph.hpp\"\n #include \"ilgen/IlGenRequest.hpp\"\n #include \"jilconsts.h\"\n+#include \"il/ParameterSymbol.hpp\"\n+#include \"optimizer/PreExistence.hpp\"\n+#include \"il/OMRNode_inlines.hpp\"\n #if defined(J9VM_OPT_JITSERVER)\n #include \"control/CompilationRuntime.hpp\"\n #include \"env/j9methodServer.hpp\"\n #endif /* defined(J9VM_OPT_JITSERVER) */\n \n+const char* Operand::KnowledgeStrings[] = {\"NONE\", \"OBJECT\", \"MUTABLE_CALLSITE_TARGET\", \"PREEXISTENT\", \"FIXED_CLASS\", \"KNOWN_OBJECT\", \"ICONST\" };\n+\n+char*\n+ObjectOperand::getSignature(TR::Compilation *comp, TR_Memory *trMemory)\n+   {\n+   if (!_signature && _clazz)\n+      _signature = TR::Compiler->cls.classSignature(comp, _clazz, trMemory);\n+   return _signature;\n+   }\n+\n+KnownObjOperand::KnownObjOperand(TR::Compilation* comp, TR::KnownObjectTable::Index koi, TR_OpaqueClassBlock* clazz)\n+   : knownObjIndex(koi), FixedClassOperand(clazz)\n+   {\n+   auto knot = comp->getOrCreateKnownObjectTable();\n+   if (clazz || knownObjIndex == TR::KnownObjectTable::UNKNOWN || !knot || knot->isNull(knownObjIndex))\n+      return;\n+\n+#if defined(J9VM_OPT_JITSERVER)\n+   // TODO: add JITServer support\n+   if (comp->isOutOfProcessCompilation())\n+      return;\n+   else\n+#endif\n+      {\n+      TR::VMAccessCriticalSection KnownObjOperandCriticalSection(comp,\n+                                                                 TR::VMAccessCriticalSection::tryToAcquireVMAccess);\n+\n+      if (KnownObjOperandCriticalSection.hasVMAccess())\n+         {\n+         _clazz = TR::Compiler->cls.objectClass(comp, knot->getPointer(knownObjIndex));\n+         }\n+      }\n+\n+   TR_ASSERT_FATAL(_clazz, \"_clazz shouldn't be null for known object operand\");\n+   }\n+\n+Operand*\n+Operand::merge(Operand* other)\n+   {\n+   if (getKnowledgeLevel() > other->getKnowledgeLevel())\n+      return other->merge1(this);\n+   else\n+      return merge1(other);\n+   }\n+\n+Operand*\n+Operand::merge1(Operand* other)\n+   {\n+   if (this == other)\n+      return this;\n+   else\n+      return NULL;\n+   }\n+\n+Operand*\n+IconstOperand::merge1(Operand* other)\n+   {\n+   TR_ASSERT(other->getKnowledgeLevel() >= this->getKnowledgeLevel(), \"Should be calling other->merge1(this)\");\n+   IconstOperand* otherIconst = other->asIconst();\n+   if (otherIconst && this->intValue == otherIconst->intValue)\n+      return this;\n+   else\n+      return NULL;\n+   }\n+\n+// TODO: check instanceOf relationship and create new Operand if neccessary\n+Operand*\n+ObjectOperand::merge1(Operand* other)\n+   {\n+   TR_ASSERT(other->getKnowledgeLevel() >= this->getKnowledgeLevel(), \"Should be calling other->merge1(this)\");\n+   ObjectOperand* otherObject = other->asObjectOperand();\n+   if (otherObject && this->_clazz == otherObject->_clazz)\n+      return this;\n+   else\n+      return NULL;\n+   }\n+\n+// Both are preexistent objects\n+Operand*\n+PreexistentObjectOperand::merge1(Operand* other)\n+   {\n+   TR_ASSERT(other->getKnowledgeLevel() >= this->getKnowledgeLevel(), \"Should be calling other->merge1(this)\");\n+   PreexistentObjectOperand* otherPreexistentObjectOperand = other->asPreexistentObjectOperand();\n+   if (otherPreexistentObjectOperand && this->_clazz == otherPreexistentObjectOperand->_clazz)\n+      return this;\n+   else\n+      return NULL;\n+   }\n+\n+Operand*\n+FixedClassOperand::merge1(Operand* other)\n+   {\n+   TR_ASSERT(other->getKnowledgeLevel() >= this->getKnowledgeLevel(), \"Should be calling other->merge1(this)\");\n+   FixedClassOperand* otherFixedClass = other->asFixedClassOperand();\n+   if (otherFixedClass && this->_clazz == otherFixedClass->_clazz)\n+      return this;\n+   else\n+      return NULL;\n+   }\n+\n+Operand*\n+KnownObjOperand::merge1(Operand* other)\n+   {\n+   TR_ASSERT(other->getKnowledgeLevel() >= this->getKnowledgeLevel(), \"Should be calling other->merge1(this)\");\n+   KnownObjOperand* otherKnownObj = other->asKnownObject();\n+   if (otherKnownObj && this->knownObjIndex == otherKnownObj->knownObjIndex)\n+      return this;\n+   else\n+      return NULL;\n+   }\n+\n+Operand*\n+MutableCallsiteTargetOperand::merge1(Operand* other)\n+   {\n+   TR_ASSERT(other->getKnowledgeLevel() >= this->getKnowledgeLevel(), \"Should be calling other->merge1(this)\");\n+   MutableCallsiteTargetOperand* otherMutableCallsiteTarget = other->asMutableCallsiteTargetOperand();\n+   if (otherMutableCallsiteTarget &&\n+       this->mutableCallsiteIndex== otherMutableCallsiteTarget->mutableCallsiteIndex &&\n+       this->methodHandleIndex && otherMutableCallsiteTarget->methodHandleIndex)\n+      return this;\n+   else\n+      return NULL;\n+   }\n+\n+void\n+InterpreterEmulator::printOperandArray(OperandArray* operands)\n+   {\n+   int32_t size = operands->size();\n+   for (int32_t i = 0; i < size; i++)\n+      {\n+      char buffer[20];\n+      (*operands)[i]->printToString(buffer);\n+      traceMsg(comp(), \"[%d]=%s, \", i, buffer);\n+      }\n+   if (size > 0)\n+      traceMsg(comp(), \"\\n\");\n+   }\n+\n+// Merge second OperandArray into the first one\n+// The merge does an intersect\n+//\n+void InterpreterEmulator::mergeOperandArray(OperandArray *first, OperandArray *second)\n+   {\n+   bool enableTrace = tracer()->debugLevel();\n+   if (enableTrace)\n+      {\n+      traceMsg(comp(), \"Operands before merging:\\n\");\n+      printOperandArray(first);\n+      }\n+\n+   bool changed = false;\n+   for (int i = 0; i < _numSlots; i++)\n+      {\n+      Operand* firstObj = (*first)[i];\n+      Operand* secondObj = (*second)[i];\n+\n+      firstObj = firstObj->merge(secondObj);\n+      if (firstObj == NULL)\n+         firstObj = _unknownOperand;\n+\n+      if (firstObj != (*first)[i])\n+         changed = true;\n+      }\n+\n+   if (enableTrace)\n+      {\n+      if (changed)\n+         {\n+         traceMsg(comp(), \"Operands after merging:\\n\");\n+         printOperandArray(first);\n+         }\n+      else\n+         traceMsg(comp(), \"Operands is not changed after merging\\n\");\n+      }\n+   }\n+\n void\n InterpreterEmulator::maintainStackForIf(TR_J9ByteCode bc)\n    {\n@@ -119,7 +298,7 @@ InterpreterEmulator::maintainStackForGetField()\n                   {\n                   knot->updateKnownObjectTableAtServer(resultIndex, objectPointerReference);\n \n-                  newOperand = new (trStackMemory()) KnownObjOperand(resultIndex);\n+                  newOperand = new (trStackMemory()) KnownObjOperand(comp(), resultIndex);\n                   int32_t len = 0;\n                   debugTrace(tracer(), \"dereference obj%d (%p)from field %s(offset = %d) of base obj%d(%p)\\n\",\n                         newOperand->getKnownObjectIndex(), (void *)fieldAddress, _calltarget->_calleeMethod->fieldName(cpIndex, len, this->trMemory()),\n@@ -137,7 +316,7 @@ InterpreterEmulator::maintainStackForGetField()\n                if (fieldDeclaringClass && comp()->fej9()->isInstanceOf(baseObjectClass, fieldDeclaringClass, true) == TR_yes)\n                   {\n                   uintptr_t fieldAddress = comp()->fej9()->getReferenceFieldAtAddress(baseObjectAddress + fieldOffset);\n-                  newOperand = new (trStackMemory()) KnownObjOperand(knot->getOrCreateIndex(fieldAddress));\n+                  newOperand = new (trStackMemory()) KnownObjOperand(comp(), knot->getOrCreateIndex(fieldAddress));\n                   int32_t len = 0;\n                   debugTrace(tracer(), \"dereference obj%d (%p)from field %s(offset = %d) of base obj%d(%p)\\n\",\n                         newOperand->getKnownObjectIndex(), (void *)fieldAddress, _calltarget->_calleeMethod->fieldName(cpIndex, len, this->trMemory()),\n@@ -156,11 +335,27 @@ InterpreterEmulator::maintainStackForGetField()\n void\n InterpreterEmulator::saveStack(int32_t targetIndex)\n    {\n-   if (_stack->isEmpty())\n+   if (!_iteratorWithState)\n       return;\n-   bool createTargetStack = (targetIndex >= 0 && !_stacks[targetIndex]);\n-   if (createTargetStack)\n-      _stacks[targetIndex] = new (trStackMemory()) ByteCodeStack(this->trMemory(), std::max<uint32_t>(20, _stack->size()));\n+\n+   // Propagate stack state to successor\n+   if (!_stack->isEmpty())\n+      {\n+      bool createTargetStack = (targetIndex >= 0 && !_stacks[targetIndex]);\n+      if (createTargetStack)\n+         _stacks[targetIndex] = new (trStackMemory()) ByteCodeStack(*_stack);\n+      else\n+         mergeOperandArray(_stacks[targetIndex], _stack);\n+      }\n+\n+   // Propagate local object info to successor\n+   if (_numSlots)\n+      {\n+      if (!_localObjectInfos[targetIndex])\n+         _localObjectInfos[targetIndex] = new (trStackMemory()) OperandArray(*_currentLocalObjectInfo);\n+      else\n+         mergeOperandArray(_localObjectInfos[targetIndex], _currentLocalObjectInfo);\n+      }\n    }\n \n void\n@@ -174,12 +369,129 @@ InterpreterEmulator::initializeIteratorWithState()\n    memset(_flags, 0, size * sizeof(flags8_t));\n    memset(_stacks, 0, size * sizeof(ByteCodeStack *));\n    _stack = new (trStackMemory()) TR_Stack<Operand *>(this->trMemory(), 20, false, stackAlloc);\n+   _localObjectInfos = (OperandArray**) this->trMemory()->allocateStackMemory(size * sizeof(OperandArray *));\n+   memset(_localObjectInfos, 0, size * sizeof(OperandArray *));\n+\n+   int32_t numParmSlots = method()->numberOfParameterSlots();\n+   _numSlots = numParmSlots + method()->numberOfTemps();\n \n    genBBStart(0);\n    setupBBStartContext(0);\n    this->setIndex(0);\n    }\n \n+void\n+InterpreterEmulator::setupMethodEntryLocalObjectState()\n+   {\n+   TR_PrexArgInfo *argInfo = _calltarget->_ecsPrexArgInfo;\n+   if (argInfo)\n+      {\n+      TR_ASSERT_FATAL(argInfo->getNumArgs() == method()->numberOfParameters(), \"Prex arg number should match parm number\");\n+\n+      if(tracer()->heuristicLevel())\n+         {\n+         heuristicTrace(tracer(), \"Save argInfo to slot state array\");\n+         argInfo->dumpTrace();\n+         }\n+\n+      method()->makeParameterList(_methodSymbol);\n+      ListIterator<TR::ParameterSymbol> parms(&_methodSymbol->getParameterList());\n+\n+      // save prex arg into local var arrays\n+      for (TR::ParameterSymbol *p = parms.getFirst(); p != NULL; p = parms.getNext())\n+          {\n+          int32_t ordinal = p->getOrdinal();\n+          int32_t slotIndex = p->getSlot();\n+          TR_PrexArgument *prexArgument = argInfo->get(ordinal);\n+          if (!prexArgument)\n+             {\n+             (*_currentLocalObjectInfo)[slotIndex] = _unknownOperand;\n+             }\n+          else\n+             {\n+             auto operand = createOperandFromPrexArg(prexArgument);\n+             if (operand)\n+                {\n+                (*_currentLocalObjectInfo)[slotIndex] = operand;\n+                }\n+             else\n+                (*_currentLocalObjectInfo)[slotIndex] = _unknownOperand;\n+             }\n+         char buffer[50];\n+         (*_currentLocalObjectInfo)[slotIndex]->printToString(buffer);\n+         heuristicTrace(tracer(), \"Creating operand %s for parm %d slot %d from PrexArgument %p\", buffer, ordinal, slotIndex, prexArgument);\n+         }\n+      }\n+   }\n+\n+bool\n+InterpreterEmulator::hasUnvisitedPred(TR::Block* block)\n+   {\n+   TR_PredecessorIterator pi(block);\n+   for (TR::CFGEdge *edge = pi.getFirst(); edge != NULL; edge = pi.getNext())\n+      {\n+      TR::Block *fromBlock = toBlock(edge->getFrom());\n+      auto fromBCIndex = fromBlock->getEntry()->getNode()->getByteCodeIndex();\n+      if (!isGenerated(fromBCIndex))\n+         {\n+         return true;\n+         }\n+      }\n+\n+   return false;\n+   }\n+\n+void\n+InterpreterEmulator::setupBBStartStackState(int32_t index)\n+   {\n+   if (index == 0)\n+      return;\n+\n+   auto block = blocks(index);\n+   auto stack = _stacks[index];\n+   if (stack && hasUnvisitedPred(block))\n+      {\n+      for (int32_t i = 0; i < stack->size(); ++i)\n+         (*stack)[i] = _unknownOperand;\n+      }\n+   }\n+\n+void\n+InterpreterEmulator::setupBBStartLocalObjectState(int32_t index)\n+   {\n+   if (_numSlots == 0)\n+      return;\n+\n+   if (!_localObjectInfos[index])\n+      {\n+      _localObjectInfos[index] = new (trStackMemory()) OperandArray(trMemory(), _numSlots, false, stackAlloc);\n+      for (int32_t i = 0; i < _numSlots; i++)\n+          (*_localObjectInfos[index])[i] = _unknownOperand;\n+      }\n+   else if (hasUnvisitedPred(blocks(index)))\n+      {\n+      for (int32_t i = 0; i < _numSlots; i++)\n+          (*_localObjectInfos[index])[i] = _unknownOperand;\n+      }\n+\n+   _currentLocalObjectInfo = _localObjectInfos[index];\n+\n+   if (index == 0)\n+      setupMethodEntryLocalObjectState();\n+   }\n+\n+int32_t\n+InterpreterEmulator::setupBBStartContext(int32_t index)\n+   {\n+   if (_iteratorWithState)\n+      {\n+      setupBBStartStackState(index);\n+      setupBBStartLocalObjectState(index);\n+      }\n+   Base::setupBBStartContext(index);\n+   return index;\n+   }\n+\n bool\n InterpreterEmulator::maintainStack(TR_J9ByteCode bc)\n    {\n@@ -197,7 +509,12 @@ InterpreterEmulator::maintainStack(TR_J9ByteCode bc)\n \n       case J9BCinvokespecial:\n       case J9BCinvokespecialsplit:\n-         maintainStackForDirectCall(_calltarget->_calleeMethod);\n+      case J9BCinvokevirtual:\n+      case J9BCinvokestatic:\n+      case J9BCinvokestaticsplit:\n+      case J9BCinvokedynamic:\n+      case J9BCinvokehandle:\n+         maintainStackForCall();\n          break;\n       case J9BCiconstm1: push (new (trStackMemory()) IconstOperand(-1)); break;\n       case J9BCiconst0:  push (new (trStackMemory()) IconstOperand(0)); break;\n@@ -225,18 +542,26 @@ InterpreterEmulator::maintainStack(TR_J9ByteCode bc)\n       case J9BCladd:\n       case J9BCiadd:\n       case J9BCisub:\n+      case J9BCiand:\n          popn(2);\n          pushUnknownOperand();\n          break;\n-      case J9BCistore: case J9BClstore: case J9BCfstore: case J9BCdstore: case J9BCastore:\n-      case J9BCistorew: case J9BClstorew: case J9BCfstorew: case J9BCdstorew: case J9BCastorew:\n-      case J9BCistore0: case J9BCistore1: case J9BCistore2: case J9BCistore3:\n-      case J9BClstore0: case J9BClstore1: case J9BClstore2: case J9BClstore3:\n-      case J9BCfstore0: case J9BCfstore1: case J9BCfstore2: case J9BCfstore3:\n-      case J9BCdstore0: case J9BCdstore1: case J9BCdstore2: case J9BCdstore3:\n-      case J9BCastore0: case J9BCastore1: case J9BCastore2: case J9BCastore3:\n+      case J9BCistore: case J9BClstore: case J9BCfstore: case J9BCdstore:\n+      case J9BCistorew: case J9BClstorew: case J9BCfstorew: case J9BCdstorew:\n+      case J9BCistore0: case J9BClstore0: case J9BCfstore0: case J9BCdstore0:\n+      case J9BCistore1: case J9BClstore1: case J9BCfstore1: case J9BCdstore1:\n+      case J9BCistore2: case J9BClstore2: case J9BCfstore2: case J9BCdstore2:\n+      case J9BCistore3: case J9BClstore3: case J9BCfstore3: case J9BCdstore3:\n          pop();\n          break;\n+      // Maintain stack for object store\n+      case J9BCastorew: maintainStackForAstore(next2Bytes()); break;\n+      case J9BCastore: maintainStackForAstore(nextByte()); break;\n+      case J9BCastore0: maintainStackForAstore(0); break;\n+      case J9BCastore1: maintainStackForAstore(1); break;\n+      case J9BCastore2: maintainStackForAstore(2); break;\n+      case J9BCastore3: maintainStackForAstore(3); break;\n+\n       case J9BCiload0: case J9BCiload1: case J9BCiload2: case J9BCiload3:\n       case J9BCdload0: case J9BCdload1: case J9BCdload2: case J9BCdload3:\n       case J9BClload0: case J9BClload1: case J9BClload2: case J9BClload3:\n@@ -249,11 +574,13 @@ InterpreterEmulator::maintainStack(TR_J9ByteCode bc)\n       case J9BCgenericReturn:\n       case J9BCi2l:\n          break;\n-      //following bytecodes has been handled when creating callsites\n-      case J9BCinvokevirtual:\n-      case J9BCinvokestatic:\n-      case J9BCinvokestaticsplit:\n+      case J9BCcheckcast:\n+         break;\n+      case J9BCdup:\n+         push(top());\n          break;\n+      case J9BCldc:\n+         maintainStackForldc(nextByte()); break;\n       default:\n          static const bool assertfatal = feGetEnv(\"TR_AssertFatalForUnexpectedBytecodeInMethodHandleThunk\") ? true: false;\n          if (!assertfatal)\n@@ -278,66 +605,146 @@ void\n InterpreterEmulator::maintainStackForAload(int slotIndex)\n    {\n    TR_ASSERT_FATAL(_iteratorWithState, \"has to be called when the iterator has state!\");\n-   TR_PrexArgInfo *argInfo = _calltarget->_ecsPrexArgInfo;\n-   TR_ASSERT_FATAL(argInfo, \"thunk archetype target doesn't have _ecsPrexArgInfo %p\\n\", _calltarget);\n-   if (slotIndex < argInfo->getNumArgs())\n+\n+   push((*_currentLocalObjectInfo)[slotIndex]);\n+   }\n+\n+void\n+InterpreterEmulator::maintainStackForAstore(int slotIndex)\n+   {\n+   TR_ASSERT_FATAL(_iteratorWithState, \"has to be called when the iterator has state!\");\n+   (*_currentLocalObjectInfo)[slotIndex] = pop();\n+   }\n+\n+void\n+InterpreterEmulator::maintainStackForldc(int32_t cpIndex)\n+   {\n+   TR::DataType type = method()->getLDCType(cpIndex);\n+   switch (type)\n       {\n-      TR_PrexArgument *prexArgument = argInfo->get(slotIndex);\n-      if (prexArgument && TR_PrexArgument::knowledgeLevel(prexArgument) == KNOWN_OBJECT)\n-         {\n-         debugTrace(tracer(), \"aload known obj%d from slot %d\\n\", prexArgument->getKnownObjectIndex(), slotIndex);\n-         push(new (trStackMemory()) KnownObjOperand(prexArgument->getKnownObjectIndex()));\n-         return;\n-         }\n+      case TR::Address:\n+         // TODO: should add a function to check if cp entry is unresolved for all constant\n+         // not just for string. Currently only do it for string because it may be patched\n+         // to a different object in OpenJDK MethodHandle implementation\n+         //\n+         if (method()->isStringConstant(cpIndex) && !method()->isUnresolvedString(cpIndex))\n+            {\n+            uintptr_t * location = (uintptr_t *)method()->stringConstant(cpIndex);\n+            TR::KnownObjectTable *knot = comp()->getKnownObjectTable();\n+            if (knot)\n+               {\n+               TR::KnownObjectTable::Index koi = knot->getOrCreateIndexAt(location);\n+               push(new (trStackMemory()) KnownObjOperand(comp(), koi));\n+               debugTrace(tracer(), \"aload known obj%d from ldc %d\", koi, cpIndex);\n+               return;\n+               }\n+            }\n+         break;\n+      default:\n+         break;\n       }\n+\n    pushUnknownOperand();\n    }\n \n void\n-InterpreterEmulator::maintainStackForCall(TR_ResolvedMethod *callerMethod, Operand *result, bool isDirect)\n+InterpreterEmulator::maintainStackForCall(Operand *result, int32_t numArgs, TR::DataType returnType)\n    {\n    TR_ASSERT_FATAL(_iteratorWithState, \"has to be called when the iterator has state!\");\n-   int32_t cpIndex = next2Bytes();\n-   TR::Method * calleeMethod = comp()->fej9()->createMethod(trMemory(), callerMethod->containingClass(), cpIndex);\n-   int32_t argNum = calleeMethod->numberOfExplicitParameters() + (isDirect ? 0: 1);\n \n-   for (int i = 1; i <= argNum; i++)\n+   for (int i = 1; i <= numArgs; i++)\n       pop();\n \n    if (result)\n       push(result);\n-   else if (calleeMethod->returnType() != TR::NoType)\n+   else if (returnType != TR::NoType)\n       pushUnknownOperand();\n    }\n \n+void\n+InterpreterEmulator::maintainStackForCall()\n+   {\n+   TR_ASSERT_FATAL(_iteratorWithState, \"has to be called when the iterator has state!\");\n+   int32_t numOfArgs = 0;\n+   TR::DataType returnType = TR::NoType;\n+   Operand* result = NULL;\n+   bool callerIsArchetypeSpecimen = _calltarget->_calleeMethod->convertToMethod()->isArchetypeSpecimen();\n+   if (_currentCallSite && _currentCallSite->_initialCalleeMethod)\n+      result = getReturnValue(_currentCallSite->_initialCalleeMethod);\n+\n+   if (_currentCallSite && !callerIsArchetypeSpecimen)\n+      {\n+      if (_currentCallSite->_isInterface)\n+         {\n+         numOfArgs = _currentCallSite->_interfaceMethod->numberOfExplicitParameters() + 1;\n+         returnType = _currentCallSite->_interfaceMethod->returnType();\n+         }\n+      else if (_currentCallSite->_initialCalleeMethod)\n+         {\n+         numOfArgs = _currentCallSite->_initialCalleeMethod->numberOfParameters();\n+         returnType = _currentCallSite->_initialCalleeMethod->returnType();\n+         }\n+      }\n+   else\n+      {\n+      int32_t cpIndex = next2Bytes();\n+      bool isStatic = false;\n+      switch (current())\n+         {\n+         case J9BCinvokespecialsplit:\n+            cpIndex |= J9_SPECIAL_SPLIT_TABLE_INDEX_FLAG;\n+            break;\n+         case J9BCinvokestaticsplit:\n+            cpIndex |= J9_STATIC_SPLIT_TABLE_INDEX_FLAG;\n+         case J9BCinvokestatic:\n+            isStatic = true;\n+            break;\n+         case J9BCinvokedynamic:\n+         case J9BCinvokehandle:\n+            TR_ASSERT_FATAL(false, \"Can't maintain stack for unresolved invokehandle\");\n+            break;\n+         }\n+      TR::Method * calleeMethod = comp()->fej9()->createMethod(trMemory(), _calltarget->_calleeMethod->containingClass(), cpIndex);\n+      numOfArgs = calleeMethod->numberOfExplicitParameters() + (isStatic ? 0 : 1);\n+      returnType = calleeMethod->returnType();\n+      }\n+   maintainStackForCall(result, numOfArgs, returnType);\n+   }\n+\n void\n InterpreterEmulator::dumpStack()\n    {\n-   debugTrace(tracer(), \"operandStack after %d : %s \", _bcIndex, comp()->fej9()->getByteCodeName(nextByte(0)));\n+   debugTrace(tracer(), \"operandStack after bytecode %d : %s \", _bcIndex, comp()->fej9()->getByteCodeName(nextByte(0)));\n    for (int i = 0; i < _stack->size(); i++ )\n       {\n       Operand *x = (*_stack)[i];\n-      char buffer[20];\n+      char buffer[50];\n       x->printToString(buffer);\n-      debugTrace(tracer(), \"[%d]=%s, \", i, buffer);\n+      debugTrace(tracer(), \"[%d]=%s\", i, buffer);\n       }\n-   debugTrace(tracer(),\"\\n\");\n    }\n \n Operand *\n-InterpreterEmulator::getReturnValueForInvokestatic(TR_ResolvedMethod *callee)\n+InterpreterEmulator::getReturnValue(TR_ResolvedMethod *callee)\n    {\n    if (!callee)\n       return NULL;\n    Operand *result = NULL;\n    TR::RecognizedMethod recognizedMethod = callee->getRecognizedMethod();\n+   TR::KnownObjectTable *knot = comp()->getKnownObjectTable();\n+\n+   // The ILGen request is not relevant to current inlining\n+   // And if we inline a thunk archetype, it must be a custom thunk\n+   // The following code is not useful, comment it out\n+   /*\n    TR::IlGeneratorMethodDetails & details = comp()->ilGenRequest().details();\n    if (details.isMethodHandleThunk())\n       {\n       J9::MethodHandleThunkDetails & thunkDetails = static_cast<J9::MethodHandleThunkDetails &>(details);\n       if (!thunkDetails.isCustom())\n          recognizedMethod = TR::unknownMethod;\n       }\n+   */\n \n    switch (recognizedMethod)\n       {\n@@ -347,55 +754,81 @@ InterpreterEmulator::getReturnValueForInvokestatic(TR_ResolvedMethod *callee)\n       case TR::java_lang_invoke_ILGenMacros_isShareableThunk:\n          result = new (trStackMemory()) IconstOperand(0);\n          break;\n-      }\n-   return result;\n-   }\n-\n-Operand *\n-InterpreterEmulator::getReturnValueForInvokevirtual(TR_ResolvedMethod *callee)\n-   {\n-   if (!callee)\n-      return NULL;\n-   Operand *result = NULL;\n-   int argNum = callee->numberOfExplicitParameters();\n-   TR::KnownObjectTable *knot = comp()->getKnownObjectTable();\n-   TR::KnownObjectTable::Index receiverIndex = topn(argNum)->getKnownObjectIndex();\n-   if (callee->getRecognizedMethod() == TR::java_lang_invoke_MutableCallSite_getTarget &&\n-      receiverIndex != TR::KnownObjectTable::UNKNOWN &&\n-      knot)\n-      {\n-      TR::KnownObjectTable::Index resultIndex = TR::KnownObjectTable::UNKNOWN;\n-      TR_OpaqueClassBlock *mutableCallsiteClass = callee->classOfMethod();\n-      debugTrace(tracer(), \"java_lang_invoke_MutableCallSite_target receiver obj%d(*%p) mutableCallsiteClass %p\\n\", receiverIndex, knot->getPointerLocation(receiverIndex), mutableCallsiteClass);\n-      if (mutableCallsiteClass)\n+      case TR::java_lang_invoke_DirectMethodHandle_internalMemberName:\n+      case TR::java_lang_invoke_DirectMethodHandle_internalMemberNameEnsureInit:\n          {\n-#if defined(J9VM_OPT_JITSERVER)\n-         if (comp()->isOutOfProcessCompilation())\n+         Operand* mh = top();\n+         TR::KnownObjectTable::Index mhIndex = top()->getKnownObjectIndex();\n+         debugTrace(tracer(), \"Known DirectMethodHandle koi %d\\n\", mhIndex);\n+         TR::KnownObjectTable *knot = comp()->getKnownObjectTable();\n+         if (mhIndex != TR::KnownObjectTable::UNKNOWN)\n+            {\n+            TR::VMAccessCriticalSection dereferenceKnownObjectField(comp()->fej9());\n+            uintptr_t mhObjectAddress = knot->getPointer(mhIndex);\n+            uintptr_t memberAddress = comp()->fej9()->getReferenceField(mhObjectAddress, \"member\", \"Ljava/lang/invoke/MemberName;\");\n+            TR::KnownObjectTable::Index memberIndex = knot->getOrCreateIndex(memberAddress);\n+            debugTrace(tracer(), \"Known internal member name koi %d\\n\", memberIndex);\n+            result = new (trStackMemory()) KnownObjOperand(comp(), memberIndex);\n+            }\n+         break;\n+         }\n+      case TR::java_lang_invoke_DirectMethodHandle_constructorMethod:\n+         {\n+         Operand* mh = top();\n+         TR::KnownObjectTable::Index mhIndex = top()->getKnownObjectIndex();\n+         debugTrace(tracer(), \"Known DirectMethodHandle koi %d\\n\", mhIndex);\n+         TR::KnownObjectTable *knot = comp()->getKnownObjectTable();\n+         if (mhIndex != TR::KnownObjectTable::UNKNOWN)\n             {\n-            auto stream = TR::CompilationInfo::getStream();\n-            stream->write(JITServer::MessageType::KnownObjectTable_dereferenceKnownObjectField2, mutableCallsiteClass, receiverIndex);\n+            TR::VMAccessCriticalSection dereferenceKnownObjectField(comp()->fej9());\n+            uintptr_t mhObjectAddress = knot->getPointer(mhIndex);\n+            uintptr_t memberNameObject = comp()->fej9()->getReferenceField(mhObjectAddress, \"initMethod\", \"Ljava/lang/invoke/MemberName;\");\n+            TR::KnownObjectTable::Index memberIndex = knot->getOrCreateIndex(memberNameObject);\n+            debugTrace(tracer(), \"Known internal member name koi %d\\n\", memberIndex);\n+            result = new (trStackMemory()) KnownObjOperand(comp(), memberIndex);\n+            }\n+         break;\n+         }\n+      case TR::java_lang_invoke_MutableCallSite_getTarget:\n+         {\n+         int argNum = callee->numberOfExplicitParameters();\n+         TR::KnownObjectTable::Index receiverIndex = topn(argNum)->getKnownObjectIndex();\n+         if (receiverIndex == TR::KnownObjectTable::UNKNOWN)\n+            return NULL;\n+\n+         TR::KnownObjectTable::Index resultIndex = TR::KnownObjectTable::UNKNOWN;\n+         TR_OpaqueClassBlock *mutableCallsiteClass = callee->classOfMethod();\n+         debugTrace(tracer(), \"java_lang_invoke_MutableCallSite_target receiver obj%d(*%p) mutableCallsiteClass %p\\n\", receiverIndex, knot->getPointerLocation(receiverIndex), mutableCallsiteClass);\n+         if (mutableCallsiteClass)\n+            {\n+   #if defined(J9VM_OPT_JITSERVER)\n+            if (comp()->isOutOfProcessCompilation())\n+               {\n+               auto stream = TR::CompilationInfo::getStream();\n+               stream->write(JITServer::MessageType::KnownObjectTable_dereferenceKnownObjectField2, mutableCallsiteClass, receiverIndex);\n \n-            auto recv = stream->read<TR::KnownObjectTable::Index, uintptr_t*>();\n-            resultIndex = std::get<0>(recv);\n-            uintptr_t *objectPointerReference = std::get<1>(recv);\n+               auto recv = stream->read<TR::KnownObjectTable::Index, uintptr_t*>();\n+               resultIndex = std::get<0>(recv);\n+               uintptr_t *objectPointerReference = std::get<1>(recv);\n \n-            if (resultIndex != TR::KnownObjectTable::UNKNOWN)\n+               if (resultIndex != TR::KnownObjectTable::UNKNOWN)\n+                  {\n+                  knot->updateKnownObjectTableAtServer(resultIndex, objectPointerReference);\n+                  }\n+               result = new (trStackMemory()) MutableCallsiteTargetOperand(resultIndex, receiverIndex);\n+               }\n+            else\n+   #endif /* defined(J9VM_OPT_JITSERVER) */\n                {\n-               knot->updateKnownObjectTableAtServer(resultIndex, objectPointerReference);\n+               TR::VMAccessCriticalSection dereferenceKnownObjectField(comp()->fej9());\n+               int32_t targetFieldOffset = comp()->fej9()->getInstanceFieldOffset(mutableCallsiteClass, \"target\", \"Ljava/lang/invoke/MethodHandle;\");\n+               uintptr_t receiverAddress = knot->getPointer(receiverIndex);\n+               TR_OpaqueClassBlock *receiverClass = comp()->fej9()->getObjectClass(receiverAddress);\n+               TR_ASSERT_FATAL(comp()->fej9()->isInstanceOf(receiverClass, mutableCallsiteClass, true) == TR_yes, \"receiver of mutableCallsite_getTarget must be instance of MutableCallSite (*%p)\", knot->getPointerLocation(receiverIndex));\n+               uintptr_t fieldAddress = comp()->fej9()->getReferenceFieldAt(receiverAddress, targetFieldOffset);\n+               resultIndex = knot->getOrCreateIndex(fieldAddress);\n+               result = new (trStackMemory()) MutableCallsiteTargetOperand(resultIndex, receiverIndex);\n                }\n-            result = new (trStackMemory()) MutableCallsiteTargetOperand(resultIndex, receiverIndex);\n-            }\n-         else\n-#endif /* defined(J9VM_OPT_JITSERVER) */\n-            {\n-            TR::VMAccessCriticalSection dereferenceKnownObjectField(comp()->fej9());\n-            int32_t targetFieldOffset = comp()->fej9()->getInstanceFieldOffset(mutableCallsiteClass, \"target\", \"Ljava/lang/invoke/MethodHandle;\");\n-            uintptr_t receiverAddress = knot->getPointer(receiverIndex);\n-            TR_OpaqueClassBlock *receiverClass = comp()->fej9()->getObjectClass(receiverAddress);\n-            TR_ASSERT_FATAL(comp()->fej9()->isInstanceOf(receiverClass, mutableCallsiteClass, true) == TR_yes, \"receiver of mutableCallsite_getTarget must be instance of MutableCallSite (*%p)\", knot->getPointerLocation(receiverIndex));\n-            uintptr_t fieldAddress = comp()->fej9()->getReferenceFieldAt(receiverAddress, targetFieldOffset);\n-            resultIndex = knot->getOrCreateIndex(fieldAddress);\n-            result = new (trStackMemory()) MutableCallsiteTargetOperand(resultIndex, receiverIndex);\n             }\n          }\n       }\n@@ -411,7 +844,8 @@ InterpreterEmulator::refineResolvedCalleeForInvokestatic(TR_ResolvedMethod *&cal\n \n    bool isVirtual = false;\n    bool isInterface = false;\n-   switch (callee->getRecognizedMethod())\n+   TR::RecognizedMethod rm = callee->getRecognizedMethod();\n+   switch (rm)\n       {\n       // refine the ILGenMacros_invokeExact* callees\n       case TR::java_lang_invoke_ILGenMacros_invokeExact:\n@@ -505,12 +939,37 @@ InterpreterEmulator::refineResolvedCalleeForInvokestatic(TR_ResolvedMethod *&cal\n          callee = fej9->createResolvedMethod(this->trMemory(), j9method);\n          return;\n          }\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+      case TR::java_lang_invoke_MethodHandle_linkToStatic:\n+      case TR::java_lang_invoke_MethodHandle_linkToSpecial:\n+      case TR::java_lang_invoke_MethodHandle_linkToVirtual:\n+         {\n+         TR::KnownObjectTable::Index memberNameIndex = top()->getKnownObjectIndex();\n+         TR_J9VMBase* fej9 = comp()->fej9();\n+         auto targetMethod = fej9->targetMethodFromMemberName(comp(), memberNameIndex);\n+         if (!targetMethod)\n+            return;\n+\n+         uint32_t vTableSlot = 0;\n+         if (rm == TR::java_lang_invoke_MethodHandle_linkToVirtual)\n+            vTableSlot = fej9->vTableOrITableIndexFromMemberName(comp(), memberNameIndex);\n+\n+         callee = fej9->createResolvedMethodWithVTableSlot(comp()->trMemory(), vTableSlot, targetMethod, _calltarget->_calleeMethod);\n+         isIndirectCall = rm == TR::java_lang_invoke_MethodHandle_linkToVirtual || rm == TR::java_lang_invoke_MethodHandle_linkToInterface;\n+         heuristicTrace(tracer(), \"Refine linkTo to %s\\n\", callee->signature(trMemory(), stackAlloc));\n+         // The refined method doesn't take MemberName as an argument, pop MemberName out of the operand stack\n+         pop();\n+         return;\n+         }\n+#endif //J9VM_OPT_OPENJDK_METHODHANDLE\n       }\n    }\n \n bool\n InterpreterEmulator::findAndCreateCallsitesFromBytecodes(bool wasPeekingSuccessfull, bool withState)\n    {\n+   heuristicTrace(tracer(),\"Find and create callsite %s\\n\", withState ? \"with state\" : \"without state\");\n+\n    TR::Region findCallsitesRegion(comp()->region());\n    if (withState)\n       initializeIteratorWithState();\n@@ -519,6 +978,8 @@ InterpreterEmulator::findAndCreateCallsitesFromBytecodes(bool wasPeekingSuccessf\n    TR_J9ByteCode bc = first();\n    while (bc != J9BCunknown)\n       {\n+      _currentCallSite = NULL;\n+\n       if (_InterpreterEmulatorFlags[_bcIndex].testAny(InterpreterEmulator::BytecodePropertyFlag::bbStart))\n          {\n          _currentInlinedBlock = TR_J9EstimateCodeSize::getBlock(comp(), _blocks, _calltarget->_calleeMethod, _bcIndex, *_cfg);\n@@ -661,7 +1122,7 @@ InterpreterEmulator::updateKnotAndCreateCallSiteUsingInvokeCacheArray(TR_Resolve\n       {\n       TR::KnownObjectTable::Index idx = fej9->getKnotIndexOfInvokeCacheArrayAppendixElement(comp(), invokeCacheArray);\n       if (idx != TR::KnownObjectTable::UNKNOWN)\n-         push(new (trStackMemory()) KnownObjOperand(idx));\n+         push(new (trStackMemory()) KnownObjOperand(comp(), idx));\n       else\n          pushUnknownOperand();\n       }\n@@ -723,6 +1184,36 @@ InterpreterEmulator::debugUnresolvedOrCold(TR_ResolvedMethod *resolvedMethod)\n       }\n    }\n \n+void\n+InterpreterEmulator::refineResolvedCalleeForInvokevirtual(TR_ResolvedMethod *&callee, bool &isIndirectCall)\n+   {\n+   TR_ASSERT_FATAL(_iteratorWithState, \"has to be called when the iterator has state!\");\n+   if (!comp()->getOrCreateKnownObjectTable())\n+      return;\n+\n+   TR::RecognizedMethod rm = callee->getRecognizedMethod();\n+   switch (rm)\n+      {\n+#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n+      case TR::java_lang_invoke_MethodHandle_invokeBasic:\n+         {\n+         int argNum = callee->numberOfExplicitParameters();\n+         TR::KnownObjectTable::Index receiverIndex = topn(argNum)->getKnownObjectIndex();\n+         TR_J9VMBase* fej9 = comp()->fej9();\n+         auto targetMethod = fej9->targetMethodFromMethodHandle(comp(), receiverIndex);\n+         if (!targetMethod) return;\n+\n+         isIndirectCall = false;\n+         callee = fej9->createResolvedMethod(comp()->trMemory(), targetMethod, callee->owningMethod());\n+         heuristicTrace(tracer(), \"Refine invokeBasic to %s\\n\", callee->signature(trMemory(), stackAlloc));\n+         return;\n+         }\n+#endif //J9VM_OPT_OPENJDK_METHODHANDLE\n+      default:\n+         return;\n+      }\n+   }\n+\n void\n InterpreterEmulator::visitInvokevirtual()\n    {\n@@ -737,14 +1228,16 @@ InterpreterEmulator::visitInvokevirtual()\n       }\n    else if (resolvedMethod)\n       {\n+      bool isIndirectCall = !resolvedMethod->isFinal() && !resolvedMethod->isPrivate();\n+      if (_iteratorWithState)\n+         refineResolvedCalleeForInvokevirtual(resolvedMethod, isIndirectCall);\n+\n       bool allconsts= false;\n       heuristicTrace(tracer(),\"numberOfExplicitParameters = %d  _pca.getNumPrevConstArgs = %d\\n\",resolvedMethod->numberOfExplicitParameters() ,_pca.getNumPrevConstArgs(resolvedMethod->numberOfExplicitParameters()));\n       if ( resolvedMethod->numberOfExplicitParameters() > 0 && resolvedMethod->numberOfExplicitParameters() <= _pca.getNumPrevConstArgs(resolvedMethod->numberOfExplicitParameters()))\n          allconsts = true;\n \n       TR_CallSite *callsite;\n-      bool isIndirectCall = resolvedMethod == NULL ||\n-                           (!resolvedMethod->isFinal() && !resolvedMethod->isPrivate());\n       bool isInterface = false;\n       TR::Method *interfaceMethod = 0;\n       TR::TreeTop *callNodeTreeTop = 0;\n@@ -781,7 +1274,7 @@ InterpreterEmulator::visitInvokevirtual()\n          {\n          callsite = new (comp()->trHeapMemory()) TR_DirectCallSite(_calltarget->_calleeMethod, callNodeTreeTop, parent,\n                                                                         callNode, interfaceMethod, resolvedMethod->classOfMethod(),\n-                                                                        (int32_t) resolvedMethod->virtualCallSelector(cpIndex), cpIndex, resolvedMethod,\n+                                                                        -1, cpIndex, resolvedMethod,\n                                                                         resolvedSymbol, isIndirectCall, isInterface, *_newBCInfo, comp(),\n                                                                         _recursionDepth, allconsts);\n \n@@ -792,8 +1285,6 @@ InterpreterEmulator::visitInvokevirtual()\n       findTargetAndUpdateInfoForCallsite(callsite);\n       }\n \n-   if (_iteratorWithState)\n-      maintainStackForIndirectCall(_calltarget->_calleeMethod, getReturnValueForInvokevirtual(resolvedMethod));\n    }\n \n void\n@@ -834,7 +1325,6 @@ InterpreterEmulator::visitInvokestatic()\n    int32_t cpIndex = next2Bytes();\n    bool isUnresolvedInCP;\n    TR_ResolvedMethod *resolvedMethod = _calltarget->_calleeMethod->getResolvedStaticMethod(comp(), (current() == J9BCinvokestaticsplit) ? cpIndex |= J9_STATIC_SPLIT_TABLE_INDEX_FLAG:cpIndex, &isUnresolvedInCP);\n-   TR_ResolvedMethod *origResolvedMethod = resolvedMethod;\n    if (isCurrentCallUnresolvedOrCold(resolvedMethod, isUnresolvedInCP))\n       {\n       debugUnresolvedOrCold(resolvedMethod);\n@@ -891,7 +1381,7 @@ InterpreterEmulator::visitInvokestatic()\n          {\n          callsite = new (comp()->trHeapMemory()) TR_J9VirtualCallSite(\n                _calltarget->_calleeMethod, callNodeTreeTop, parent, callNode,\n-               interfaceMethod, resolvedMethod->classOfMethod(), -1, cpIndex,\n+               interfaceMethod, resolvedMethod->classOfMethod(), (int32_t) resolvedMethod->virtualCallSelector(cpIndex), cpIndex,\n                resolvedMethod, resolvedSymbol, isIndirectCall, isInterface,\n                *_newBCInfo, comp(), _recursionDepth, allconsts);\n          }\n@@ -905,8 +1395,6 @@ InterpreterEmulator::visitInvokestatic()\n       findTargetAndUpdateInfoForCallsite(callsite);\n       }\n \n-   if (_iteratorWithState)\n-      maintainStackForDirectCall(_calltarget->_calleeMethod, getReturnValueForInvokestatic(origResolvedMethod));\n    }\n \n void\n@@ -978,40 +1466,122 @@ InterpreterEmulator::visitInvokeinterface()\n    findTargetAndUpdateInfoForCallsite(callsite);\n    }\n \n+Operand*\n+InterpreterEmulator::createOperandFromPrexArg(TR_PrexArgument* prexArgument)\n+   {\n+   auto prexKnowledge = TR_PrexArgument::knowledgeLevel(prexArgument);\n+   switch (prexKnowledge)\n+      {\n+      case KNOWN_OBJECT:\n+         return new (trStackMemory()) KnownObjOperand(comp(), prexArgument->getKnownObjectIndex(), prexArgument->getClass());\n+      case FIXED_CLASS:\n+         return new (trStackMemory()) FixedClassOperand(prexArgument->getClass());\n+      case PREEXISTENT:\n+         return new (trStackMemory()) PreexistentObjectOperand(prexArgument->getClass());\n+      case NONE:\n+         return prexArgument->getClass() ? new (trStackMemory()) ObjectOperand(prexArgument->getClass()) : NULL;\n+      }\n+   return NULL;\n+   }\n+\n+TR_PrexArgument*\n+InterpreterEmulator::createPrexArgFromOperand(Operand* operand)\n+   {\n+   if (operand->asKnownObject())\n+      {\n+      return new (comp()->trHeapMemory()) TR_PrexArgument(operand->getKnownObjectIndex(), comp());\n+      }\n+   else if (operand->asObjectOperand())\n+      {\n+      TR_OpaqueClassBlock* clazz = operand->asObjectOperand()->getClass();\n+      TR_PrexArgument::ClassKind kind = TR_PrexArgument::ClassIsUnknown;\n+      if (operand->asFixedClassOperand())\n+         kind = TR_PrexArgument::ClassIsFixed;\n+      else if (operand->asPreexistentObjectOperand())\n+         kind = TR_PrexArgument::ClassIsPreexistent;\n+\n+      return new (comp()->trHeapMemory()) TR_PrexArgument(kind, clazz);\n+      }\n+\n+   return NULL;\n+   }\n+\n+TR_PrexArgInfo*\n+InterpreterEmulator::computePrexInfo(TR_CallSite *callsite)\n+   {\n+   if (tracer()->heuristicLevel())\n+      _ecs->getInliner()->tracer()->dumpCallSite(callsite, \"Compute prex info for call site %p\\n\", callsite);\n+\n+   int32_t numOfArgs = 0;\n+   if (callsite->_isInterface)\n+      {\n+      numOfArgs = callsite->_interfaceMethod->numberOfExplicitParameters() + 1;\n+      }\n+   else if (callsite->_initialCalleeMethod)\n+      {\n+      numOfArgs = callsite->_initialCalleeMethod->numberOfParameters();\n+      }\n+\n+   bool callerIsArchetypeSpecimen = _calltarget->_calleeMethod->convertToMethod()->isArchetypeSpecimen();\n+   // Always favor prex arg from operand if we're iterating with state\n+   // But not for thunk archetype as the method's bytecodes manipulate\n+   // the operand stack differently\n+   //\n+   if (!callerIsArchetypeSpecimen && _iteratorWithState)\n+      {\n+      TR_PrexArgInfo* prexArgInfo = new (comp()->trHeapMemory()) TR_PrexArgInfo(numOfArgs, comp()->trMemory());\n+      for (int32_t i = 0; i < numOfArgs; i++)\n+         {\n+         int32_t posInStack = numOfArgs - i - 1;\n+         prexArgInfo->set(i, createPrexArgFromOperand(topn(posInStack)));\n+         }\n+\n+      if (tracer()->heuristicLevel())\n+         {\n+         alwaysTrace(tracer(), \"argInfo from operand stack:\");\n+         prexArgInfo->dumpTrace();\n+         }\n+      return prexArgInfo;\n+      }\n+   else if (_wasPeekingSuccessfull)\n+      {\n+      auto callNodeTT = TR_PrexArgInfo::getCallTree(_methodSymbol, callsite, tracer());\n+      if (callNodeTT)\n+         {\n+         // Temporarily set call tree and call node of callsite such that computePrexInfo can use it\n+         callsite->_callNodeTreeTop = callNodeTT;\n+         callsite->_callNode = callNodeTT->getNode()->getChild(0);\n+         auto prexArgInfo = TR_J9InlinerUtil::computePrexInfo(_ecs->getInliner(), callsite, _calltarget->_ecsPrexArgInfo);\n+\n+         // Reset call tree and call node\n+         callsite->_callNodeTreeTop = NULL;\n+         callsite->_callNode = NULL;\n+         return prexArgInfo;\n+         }\n+      return NULL;\n+      }\n+\n+   return NULL;\n+   }\n+\n void\n InterpreterEmulator::findTargetAndUpdateInfoForCallsite(TR_CallSite *callsite)\n    {\n+   _currentCallSite = callsite;\n    callsite->_callerBlock = _currentInlinedBlock;\n-   if (current() == J9BCinvokevirtual || current() == J9BCinvokeinterface)\n+   callsite->_ecsPrexArgInfo = computePrexInfo(callsite);\n+\n+   if (callsite->_ecsPrexArgInfo && tracer()->heuristicLevel())\n       {\n-      if (_wasPeekingSuccessfull)\n-         {\n-         TR_PrexArgInfo::propagateReceiverInfoIfAvailable(_methodSymbol, callsite, _calltarget->_ecsPrexArgInfo, tracer());\n-         if (tracer()->heuristicLevel())\n-            {\n-            alwaysTrace(tracer(), \"propagateReceiverInfoIfAvailable :\");\n-            if (callsite->_ecsPrexArgInfo)\n-               callsite->_ecsPrexArgInfo->dumpTrace();\n-            }\n-         }\n+      alwaysTrace(tracer(), \"Prex arg info for callsite %p :\", callsite);\n+      callsite->_ecsPrexArgInfo->dumpTrace();\n       }\n \n    if (_ecs->isInlineable(_callStack, callsite))\n       {\n       _callSites[_bcIndex] = callsite;\n       _inlineableCallExists = true;\n \n-      if (_wasPeekingSuccessfull)\n-         {\n-         TR_PrexArgInfo::propagateArgsFromCaller(_methodSymbol, callsite, _calltarget->_ecsPrexArgInfo, tracer());\n-         if (tracer()->heuristicLevel())\n-            {\n-            alwaysTrace(tracer(), \"propagateArgs :\");\n-            if (callsite->numTargets() && callsite->getTarget(0)->_ecsPrexArgInfo)\n-               callsite->getTarget(0)->_ecsPrexArgInfo->dumpTrace();\n-            }\n-         }\n-\n       if (!_currentInlinedBlock->isCold())\n             _nonColdCallExists = true;\n "
  },
  {
    "sha": "527784f7abe9b182b59c1ab6a8c734d47f178994",
    "filename": "runtime/compiler/optimizer/InterpreterEmulator.hpp",
    "status": "modified",
    "additions": 181,
    "deletions": 32,
    "changes": 213,
    "blob_url": "https://github.com/eclipse/openj9/blob/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/optimizer/InterpreterEmulator.hpp",
    "raw_url": "https://github.com/eclipse/openj9/raw/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/optimizer/InterpreterEmulator.hpp",
    "contents_url": "https://api.github.com/repos/eclipse/openj9/contents/runtime/compiler/optimizer/InterpreterEmulator.hpp?ref=8a986c5f09055ee6eea0371359f76d4d228af995",
    "patch": "@@ -60,6 +60,10 @@\n class IconstOperand;\n class KnownObjOperand;\n class MutableCallsiteTargetOperand;\n+class FixedClassOperand;\n+class PreexistentObjectOperand;\n+class ObjectOperand;\n+class TR_PrexArgument;\n \n /*\n  * \\class Operand\n@@ -72,49 +76,120 @@ class Operand\n    {\n    public:\n       TR_ALLOC(TR_Memory::EstimateCodeSize);\n-      virtual IconstOperand *asIconst(){ return NULL;}\n+\n+      enum KnowledgeLevel { NONE, OBJECT, MUTABLE_CALLSITE_TARGET, PREEXISTENT, FIXED_CLASS, KNOWN_OBJECT, ICONST };\n+      static const char* KnowledgeStrings[];\n+\n+      virtual IconstOperand* asIconst(){ return NULL;}\n       virtual KnownObjOperand *asKnownObject(){ return NULL;}\n+      virtual FixedClassOperand *asFixedClassOperand(){ return NULL;}\n+      virtual PreexistentObjectOperand *asPreexistentObjectOperand(){ return NULL;}\n+      virtual ObjectOperand *asObjectOperand(){ return NULL;}\n       virtual MutableCallsiteTargetOperand* asMutableCallsiteTargetOperand(){ return NULL;}\n-      virtual bool isUnkownOperand(){ return true;}\n       virtual TR::KnownObjectTable::Index getKnownObjectIndex(){ return TR::KnownObjectTable::UNKNOWN;}\n+      virtual char* getSignature(TR::Compilation *comp, TR_Memory *trMemory) {return NULL;}\n       virtual void printToString( char *buffer)\n          {\n-         sprintf(buffer, \"(obj%d)\", getKnownObjectIndex());\n+         sprintf(buffer, \"(unknown)\");\n+         }\n+      virtual KnowledgeLevel getKnowledgeLevel() { return NONE; }\n+      Operand* merge(Operand* other);\n+      virtual Operand* merge1(Operand* other);\n+   };\n+\n+class IconstOperand : public Operand\n+   {\n+   public:\n+      TR_ALLOC(TR_Memory::EstimateCodeSize);\n+      IconstOperand (int x): intValue(x) { }\n+      virtual IconstOperand *asIconst() { return this;}\n+      virtual void printToString( char *buffer)\n+         {\n+         sprintf(buffer, \"(iconst=%d)\", intValue);\n          }\n+      int32_t intValue;\n+\n+      virtual KnowledgeLevel getKnowledgeLevel() { return ICONST; }\n+      virtual Operand* merge1(Operand* other);\n    };\n \n+\n /*\n- * \\class KnownOperand\n+ * \\class ObjectOperand\n  *\n- * \\brief represent operands that can be reasoned about at compile time\n+ * \\brief Represent a java object\n  */\n-class KnownOperand : public Operand\n+class ObjectOperand : public Operand\n    {\n    public:\n       TR_ALLOC(TR_Memory::EstimateCodeSize);\n-      virtual bool isUnkownOperand(){ return false;}\n+      ObjectOperand(TR_OpaqueClassBlock* clazz = NULL):\n+                   _signature(NULL), _clazz(clazz) {}\n+      virtual char* getSignature(TR::Compilation *comp, TR_Memory *trMemory);\n+      virtual ObjectOperand *asObjectOperand(){ return this;}\n+      TR_OpaqueClassBlock* getClass() { return _clazz;}\n+      virtual KnowledgeLevel getKnowledgeLevel() { return OBJECT; }\n+      virtual Operand* merge1(Operand* other);\n+      virtual void printToString(char *buffer)\n+         {\n+         sprintf(buffer, \"(%s=clazz%p)\", KnowledgeStrings[getKnowledgeLevel()], _clazz);\n+         }\n+\n+   protected:\n+      char* _signature;\n+      TR_OpaqueClassBlock* _clazz;\n    };\n \n-class IconstOperand : public KnownOperand\n+/*\n+ * \\class PreexistentObjectOperand\n+ *\n+ * \\brief Represent an object that preexist before the compiled method, i.e. it is\n+ *        a parm of the compiled method.\n+ */\n+class PreexistentObjectOperand : public ObjectOperand\n    {\n    public:\n       TR_ALLOC(TR_Memory::EstimateCodeSize);\n-      IconstOperand (int x): intValue(x) { }\n-      virtual IconstOperand *asIconst() { return this;}\n-      virtual void printToString( char *buffer)\n-         {\n-         sprintf(buffer, \"(iconst=%d)\", intValue);\n-         }\n-      int32_t intValue;\n+      PreexistentObjectOperand(TR_OpaqueClassBlock* clazz):ObjectOperand(clazz){ }\n+      virtual PreexistentObjectOperand *asPreexistentObjectOperand(){ return this;}\n+      virtual KnowledgeLevel getKnowledgeLevel() { return PREEXISTENT; }\n+      virtual Operand* merge1(Operand* other);\n    };\n \n-class KnownObjOperand : public KnownOperand\n+/*\n+ * \\class FixedClassOperand\n+ *\n+ * \\brief An object with known type\n+ */\n+class FixedClassOperand : public ObjectOperand\n    {\n    public:\n       TR_ALLOC(TR_Memory::EstimateCodeSize);\n-      KnownObjOperand(TR::KnownObjectTable::Index koi):knownObjIndex(koi){ }\n+      FixedClassOperand(TR_OpaqueClassBlock* clazz):ObjectOperand(clazz){ }\n+      virtual FixedClassOperand *asFixedClassOperand(){ return this;}\n+      virtual KnowledgeLevel getKnowledgeLevel() { return FIXED_CLASS; }\n+      virtual Operand* merge1(Operand* other);\n+   };\n+\n+/*\n+ * \\class KnownObjOperand\n+ *\n+ * \\brief Represent an object with known identity at compile time\n+ */\n+class KnownObjOperand : public FixedClassOperand\n+   {\n+   public:\n+      TR_ALLOC(TR_Memory::EstimateCodeSize);\n+      KnownObjOperand(TR::Compilation* comp, TR::KnownObjectTable::Index koi, TR_OpaqueClassBlock* clazz = NULL);\n       virtual KnownObjOperand *asKnownObject(){ return this;}\n       virtual TR::KnownObjectTable::Index getKnownObjectIndex(){ return knownObjIndex;}\n+      virtual KnowledgeLevel getKnowledgeLevel() { return KNOWN_OBJECT; }\n+      virtual Operand* merge1(Operand* other);\n+      virtual void printToString( char *buffer)\n+         {\n+         sprintf(buffer, \"(obj%d)\", getKnownObjectIndex());\n+         }\n+   private:\n       TR::KnownObjectTable::Index knownObjIndex;\n    };\n \n@@ -126,25 +201,28 @@ class KnownObjOperand : public KnownOperand\n  *       the mutable callsite object can be set for the callsite even though it's really the\n  *       methodhandle object that's on the operand stack.\n  *\n- * \\see getReturnValueForInvokevirtual\n+ * \\see getReturnValue\n  * \\see refineResolvedCalleeForInvokestatic\n  * \\see visitInvokestatic\n  */\n-class MutableCallsiteTargetOperand : public KnownObjOperand\n+class MutableCallsiteTargetOperand : public ObjectOperand\n    {\n    public:\n       TR_ALLOC(TR_Memory::EstimateCodeSize);\n       MutableCallsiteTargetOperand (TR::KnownObjectTable::Index methodHandleIndex, TR::KnownObjectTable::Index mutableCallsiteIndex):\n-         KnownObjOperand(methodHandleIndex),\n+         methodHandleIndex(methodHandleIndex),\n          mutableCallsiteIndex(mutableCallsiteIndex){}\n       virtual MutableCallsiteTargetOperand* asMutableCallsiteTargetOperand(){ return this; }\n+      virtual Operand* merge1(Operand* other);\n       virtual void printToString(char *buffer)\n          {\n          sprintf(buffer, \"(mh=%d, mcs=%d)\", getMethodHandleIndex(), getMutableCallsiteIndex());\n          }\n-      TR::KnownObjectTable::Index getMethodHandleIndex(){ return knownObjIndex; }\n+      virtual KnowledgeLevel getKnowledgeLevel() { return MUTABLE_CALLSITE_TARGET; }\n+      TR::KnownObjectTable::Index getMethodHandleIndex(){ return methodHandleIndex; }\n       TR::KnownObjectTable::Index getMutableCallsiteIndex() { return mutableCallsiteIndex; }\n       TR::KnownObjectTable::Index mutableCallsiteIndex;\n+      TR::KnownObjectTable::Index methodHandleIndex;\n    };\n \n class InterpreterEmulator : public TR_ByteCodeIteratorWithState<TR_J9ByteCode, J9BCunknown, TR_J9ByteCodeIterator, Operand *>\n@@ -168,6 +246,10 @@ class InterpreterEmulator : public TR_ByteCodeIteratorWithState<TR_J9ByteCode, J\n          TR_J9ByteCodeIterator::initialize(static_cast<TR_ResolvedJ9Method *>(methodSymbol->getResolvedMethod()), fe);\n          _flags = NULL;\n          _stacks = NULL;\n+         _currentLocalObjectInfo = NULL;\n+         _localObjectInfos = NULL;\n+         _currentCallSite = NULL;\n+         _numSlots = 0;\n          }\n       TR_LogTracer *tracer() { return _tracer; }\n       /* \\brief Initialize data needed for looking for callsites\n@@ -206,6 +288,14 @@ class InterpreterEmulator : public TR_ByteCodeIteratorWithState<TR_J9ByteCode, J\n       bool findAndCreateCallsitesFromBytecodes(bool wasPeekingSuccessfull, bool withState);\n       void setBlocks(TR::Block **blocks) { _blocks = blocks; }\n       TR_StackMemory trStackMemory()            { return _trMemory; }\n+\n+      /*\n+       * \\brief Compute prex arg info for the given call site\n+       */\n+      TR_PrexArgInfo* computePrexInfo(TR_CallSite *callsite);\n+      TR_PrexArgument* createPrexArgFromOperand(Operand* operand);\n+      Operand* createOperandFromPrexArg(TR_PrexArgument* arg);\n+\n       bool _nonColdCallExists;\n       bool _inlineableCallExists;\n \n@@ -236,29 +326,40 @@ class InterpreterEmulator : public TR_ByteCodeIteratorWithState<TR_J9ByteCode, J\n       /*\n        * \\brief helper to pop arguments from the stack and push the result for calls\n        *\n-       * \\param method\n-       *    the method being called from the current bytecode\n+       * \\param numArgs\n+       *    Number of arguments of the call\n        *\n        * \\param result\n        *    the operand reprenting the call return value\n        *\n-       * \\param isDirect\n-       *    whether it's a direct call or indirect call\n+       * \\param returnType\n+       *    Return type of the call\n        */\n-      void maintainStackForCall(TR_ResolvedMethod *method, Operand *result, bool isDirect);\n-      void maintainStackForDirectCall(TR_ResolvedMethod *method, Operand *result = NULL) { maintainStackForCall(method, result, true /* isDirect */); }\n-      void maintainStackForIndirectCall(TR_ResolvedMethod *method, Operand *result = NULL) { maintainStackForCall(method, result, false/* isDirect */); }\n+      void maintainStackForCall(Operand *result, int32_t numArgs, TR::DataType returnType);\n       /*\n-       * \\brief refine the callee method based on operands when possible\n+       * \\brief helper to pop arguments from the stack and push the result for calls\n+       */\n+      void maintainStackForCall();\n+      /*\n+       * \\brief refine invokestatic callee method based on operands when possible\n        */\n       void refineResolvedCalleeForInvokestatic(TR_ResolvedMethod *&callee, TR::KnownObjectTable::Index & mcsIndex, TR::KnownObjectTable::Index & mhIndex, bool & isIndirectCall);\n-      Operand *getReturnValueForInvokevirtual(TR_ResolvedMethod *callee);\n-      Operand *getReturnValueForInvokestatic(TR_ResolvedMethod *callee);\n+      /*\n+       * \\brief refine invokevirtual callee method based on operands when possible\n+       */\n+      void refineResolvedCalleeForInvokevirtual(TR_ResolvedMethod*& callee, bool &isIndirectCall);\n+      /*\n+       * \\brief Compute result of the given call based on operand stack state\n+       */\n+      Operand *getReturnValue(TR_ResolvedMethod *callee);\n       void dumpStack();\n       void pushUnknownOperand() { Base::push(_unknownOperand); }\n       // doesn't need to handle execeptions yet as they don't exist in method handle thunk archetypes\n       virtual void findAndMarkExceptionRanges(){ }\n-      virtual void saveStack(int32_t targetIndex);\n+      /*\n+       * \\brief Propagte state state and local variable state to next target\n+       */\n+      virtual void saveStack(int32_t targetIndex) override;\n \n       // the following methods can be used in both stateless and with state mode\n \n@@ -275,6 +376,32 @@ class InterpreterEmulator : public TR_ByteCodeIteratorWithState<TR_J9ByteCode, J\n        * \\note This query is used to avoid regenerating bytecodes which shouldn't happen at stateless mode\n        */\n       bool isGenerated(int32_t bcIndex) { return _iteratorWithState ? Base::isGenerated(bcIndex): false; }\n+      /*\n+       * \\brief Set up operand stack and local slot array for block starting at given bytecode index\n+       *\n+       * \\param index\n+       *    Bytecode index at the block entry\n+       */\n+      virtual int32_t setupBBStartContext(int32_t index) override;\n+      /*\n+       * \\brief set up object info in local slots at entry of a block\n+       *\n+       * \\param index\n+       *    Bytecode index at the block entry\n+       */\n+      void setupBBStartLocalObjectState(int32_t index);\n+      /*\n+       * \\brief set up object info in local slots for the method entry\n+       */\n+      void setupMethodEntryLocalObjectState();\n+      /*\n+       * \\brief set up operand stack state at entry of a block\n+       *\n+       * \\param index\n+       *    Bytecode index at the block entry\n+       */\n+      void setupBBStartStackState(int32_t index);\n+\n       void visitInvokedynamic();\n       void visitInvokevirtual();\n #if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n@@ -287,6 +414,20 @@ class InterpreterEmulator : public TR_ByteCodeIteratorWithState<TR_J9ByteCode, J\n       void findTargetAndUpdateInfoForCallsite(TR_CallSite *callsite);\n       bool isCurrentCallUnresolvedOrCold(TR_ResolvedMethod *resolvedMethod, bool isUnresolvedInCP);\n       void debugUnresolvedOrCold(TR_ResolvedMethod *resolvedMethod);\n+      void maintainStackForAstore(int slotIndex);\n+      void maintainStackForldc(int32_t cpIndex);\n+      /*\n+       * \\brief Check if a block has predecessors whose bytecodes haven't been visited\n+       */\n+      bool hasUnvisitedPred(TR::Block* block);\n+\n+      typedef TR_Array<Operand*> OperandArray;\n+      void printOperandArray(OperandArray* operands);\n+      /*\n+       * \\brief Merge second operand into the first, does an intersect operand on every operand in the array\n+       */\n+      void mergeOperandArray(OperandArray *first, OperandArray *second);\n+\n \n       TR_LogTracer *_tracer;\n       TR_EstimateCodeSize *_ecs;\n@@ -295,12 +436,20 @@ class InterpreterEmulator : public TR_ByteCodeIteratorWithState<TR_J9ByteCode, J\n       bool _iteratorWithState;\n       flags8_t * _InterpreterEmulatorFlags; // flags with bits to indicate property of each bytecode.\n       TR_CallSite ** _callSites;\n+      TR_CallSite * _currentCallSite; // Store created callsite if visiting invoke* bytecodes\n       TR::CFG* _cfg;\n       TR_ByteCodeInfo *_newBCInfo;\n       int32_t _recursionDepth;\n       TR_CallStack *_callStack; // the call stack from the current inlined call target to the method being compiled\n       bool _wasPeekingSuccessfull;\n       TR::Block *_currentInlinedBlock;\n       TR_prevArgs _pca;\n+\n+      // State of local object for current bytecode being visited\n+      OperandArray* _currentLocalObjectInfo;\n+      // Array of local object info arrays, indexed by bytecode index\n+      OperandArray** _localObjectInfos;\n+      // Number of local slots\n+      int32_t _numSlots;\n    };\n #endif"
  },
  {
    "sha": "46b1e30a6c6cef34777e0035f19b0fbbe25eb27f",
    "filename": "runtime/compiler/optimizer/J9EstimateCodeSize.cpp",
    "status": "modified",
    "additions": 13,
    "deletions": 6,
    "changes": 19,
    "blob_url": "https://github.com/eclipse/openj9/blob/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/optimizer/J9EstimateCodeSize.cpp",
    "raw_url": "https://github.com/eclipse/openj9/raw/8a986c5f09055ee6eea0371359f76d4d228af995/runtime/compiler/optimizer/J9EstimateCodeSize.cpp",
    "contents_url": "https://api.github.com/repos/eclipse/openj9/contents/runtime/compiler/optimizer/J9EstimateCodeSize.cpp?ref=8a986c5f09055ee6eea0371359f76d4d228af995",
    "patch": "@@ -1152,10 +1152,16 @@ TR_J9EstimateCodeSize::realEstimateCodeSize(TR_CallTarget *calltarget, TR_CallSt\n    const static bool debugMHInlineWithOutPeeking = feGetEnv(\"TR_DebugMHInlineWithOutPeeking\") ? true: false;\n    bool mhInlineWithPeeking =  comp()->getOption(TR_DisableMHInlineWithoutPeeking);\n    const static bool disableMethodHandleInliningAfterFirstPass = feGetEnv(\"TR_DisableMethodHandleInliningAfterFirstPass\") ? true: false;\n-   bool inlineMethodHandleCallee = calltarget->_calleeMethod->convertToMethod()->isArchetypeSpecimen() &&\n+   bool inlineArchetypeSpecimen = calltarget->_calleeMethod->convertToMethod()->isArchetypeSpecimen() &&\n                                    (!disableMethodHandleInliningAfterFirstPass || _inliner->firstPass());\n-   if (nph.doPeeking() && recurseDown ||\n-       inlineMethodHandleCallee && mhInlineWithPeeking)\n+   bool inlineLambdaFormGeneratedMethod = comp()->fej9()->isLambdaFormGeneratedMethod(calltarget->_calleeMethod) &&\n+                                   (!disableMethodHandleInliningAfterFirstPass || _inliner->firstPass());\n+\n+   // No need to peek LF methods, as we'll always interprete the method with state in order to propagate object info\n+   // through bytecodes to find call targets\n+   if (!inlineLambdaFormGeneratedMethod &&\n+       (nph.doPeeking() && recurseDown ||\n+       inlineArchetypeSpecimen && mhInlineWithPeeking))\n       {\n \n       heuristicTrace(tracer(), \"*** Depth %d: ECS CSI -- needsPeeking is true for calltarget %p\",\n@@ -1169,7 +1175,7 @@ TR_J9EstimateCodeSize::realEstimateCodeSize(TR_CallTarget *calltarget, TR_CallSt\n          wasPeekingSuccessfull = true;\n          }\n       }\n-   else if (inlineMethodHandleCallee && !mhInlineWithPeeking && debugMHInlineWithOutPeeking)\n+   else if (inlineArchetypeSpecimen && !mhInlineWithPeeking && debugMHInlineWithOutPeeking)\n       {\n       traceMsg(comp(), \"printing out trees and bytecodes through peeking because DebugMHInlineWithOutPeeking is on\\n\");\n       methodSymbol->getResolvedMethod()->genMethodILForPeekingEvenUnderMethodRedefinition(methodSymbol, comp(), false, NULL);\n@@ -1187,7 +1193,7 @@ TR_J9EstimateCodeSize::realEstimateCodeSize(TR_CallTarget *calltarget, TR_CallSt\n    //\n    TR_ValueProfileInfoManager * profileManager = TR_ValueProfileInfoManager::get(comp());\n    bool callGraphEnabled = !comp()->getOption(TR_DisableCallGraphInlining);//profileManager->isCallGraphProfilingEnabled(comp());\n-   if (!_inliner->firstPass() || inlineMethodHandleCallee)\n+   if (!_inliner->firstPass() || inlineArchetypeSpecimen || inlineLambdaFormGeneratedMethod)\n       callGraphEnabled = false; // TODO: Work out why this doesn't function properly on subsequent passes\n    if (callGraphEnabled && recurseDown)\n       {\n@@ -1290,7 +1296,8 @@ TR_J9EstimateCodeSize::realEstimateCodeSize(TR_CallTarget *calltarget, TR_CallSt\n    if (!callsitesAreCreatedFromTrees)\n       {\n       bci.prepareToFindAndCreateCallsites(blocks, flags, callSites, &cfg, &newBCInfo, _recursionDepth, &callStack);\n-      bool iteratorWithState = inlineMethodHandleCallee && !mhInlineWithPeeking;\n+      bool iteratorWithState = (inlineArchetypeSpecimen && !mhInlineWithPeeking) || inlineLambdaFormGeneratedMethod;\n+\n       if (!bci.findAndCreateCallsitesFromBytecodes(wasPeekingSuccessfull, iteratorWithState))\n          {\n          heuristicTrace(tracer(), \"*** Depth %d: ECS end for target %p signature %s. bci.findAndCreateCallsitesFromBytecode failed\", _recursionDepth, calltarget, callerName);"
  }
]
