[
  {
    "sha": "93723e413028c0914899f25d10f6e55438a822cf",
    "filename": "docs/asciidoc/apdx-operatorChoice.adoc",
    "status": "modified",
    "additions": 211,
    "deletions": 214,
    "changes": 425,
    "blob_url": "https://github.com/reactor/reactor-core/blob/ebcc0e6e4217aa4252a60edc7baff95c9c59edad/docs/asciidoc/apdx-operatorChoice.adoc",
    "raw_url": "https://github.com/reactor/reactor-core/raw/ebcc0e6e4217aa4252a60edc7baff95c9c59edad/docs/asciidoc/apdx-operatorChoice.adoc",
    "contents_url": "https://api.github.com/repos/reactor/reactor-core/contents/docs/asciidoc/apdx-operatorChoice.adoc?ref=ebcc0e6e4217aa4252a60edc7baff95c9c59edad",
    "patch": "@@ -1,10 +1,7 @@\n [[which-operator]]\n = Which operator do I need?\n \n-TIP: In this section, if an operator is specific to `Flux` or `Mono`, it is\n-prefixed accordingly. Common operators have no prefix. When a specific use case\n-is covered by a combination of operators, it is presented as a method call, with\n-leading dot and parameters in parentheses, as follows: `.methodCall(parameter)`.\n+TIP: In this section, if an operator is specific to https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux] or https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono], it is prefixed and linked accordingly, like this: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromArray-T:A-[Flux#fromArray]. Common operators have no prefix, and links to both implementations are provided, for example: `just` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-[Mono]). When a specific use case is covered by a combination of operators, it is presented as a method call, with a leading dot and parameters in parentheses, as follows: `.methodCall(parameter)`.\n \n //TODO flux:  publishOn/subscribeOn/cancelOn\n //transformDeferred/transform, repeatWhen, sort, startWith\n@@ -33,298 +30,298 @@ I want to deal with:\n [[which.create]]\n == Creating a New Sequence...\n \n-* that emits a `T`, and I already have: `just`\n-** ...from an `Optional<T>`: `Mono#justOrEmpty(Optional<T>)`\n-** ...from a potentially `null` T: `Mono#justOrEmpty(T)`\n-* that emits a `T` returned by a method: `just` as well\n-** ...but lazily captured: use `Mono#fromSupplier` or wrap `just` inside `defer`\n-* that emits several `T` I can explicitly enumerate: `Flux#just(T...)`\n+* that emits a `T`, and I already have: `just` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-[Mono])\n+** ...from an https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html[Optional<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#justOrEmpty-java.util.Optional-[Mono#justOrEmpty(Optional<T>)]\n+** ...from a potentially `null` T: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#justOrEmpty-T-[Mono#justOrEmpty(T)]\n+* that emits a `T` returned by a method: `just` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-[Mono]) as well\n+** ...but lazily captured: use https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromSupplier-java.util.function.Supplier-[Mono#fromSupplier] or wrap `just` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-[Mono]) inside `defer` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defer-java.util.function.Supplier-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defer-java.util.function.Supplier-[Mono])\n+* that emits several `T` I can explicitly enumerate: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux#just(T...)]\n * that iterates over:\n-** an array: `Flux#fromArray`\n-** a collection or iterable: `Flux#fromIterable`\n-** a range of integers: `Flux#range`\n-** a `Stream` supplied for each Subscription: `Flux#fromStream(Supplier<Stream>)`\n+** an array: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromArray-T:A-[Flux#fromArray]\n+** a collection or iterable: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromIterable-java.lang.Iterable-[Flux#fromIterable]\n+** a range of integers: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#range-int-int-[Flux#range]\n+** a https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html[Stream] supplied for each Subscription: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromStream-java.util.function.Supplier-[Flux#fromStream(Supplier<Stream>)]\n * that emits from various single-valued sources such as:\n-** a `Supplier<T>`: `Mono#fromSupplier`\n-** a task: `Mono#fromCallable`, `Mono#fromRunnable`\n-** a `CompletableFuture<T>`: `Mono#fromFuture`\n-* that completes: `empty`\n-* that errors immediately: `error`\n-** ...but lazily build the `Throwable`: `error(Supplier<Throwable>)`\n-* that never does anything: `never`\n-* that is decided at subscription: `defer`\n-* that depends on a disposable resource: `using`\n+** a https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html[Supplier<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromSupplier-java.util.function.Supplier-[Mono#fromSupplier]\n+** a task: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromCallable-java.util.concurrent.Callable-[Mono#fromCallable], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromRunnable-java.lang.Runnable-[Mono#fromRunnable]\n+** a https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html[CompletableFuture<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromFuture-java.util.concurrent.CompletableFuture-[Mono#fromFuture]\n+* that completes: `empty` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#empty--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#empty--[Mono])\n+* that errors immediately: `error` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-[Mono])\n+** ...but lazily build the https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html[Throwable]: `error(Supplier<Throwable>)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.util.function.Supplier-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.util.function.Supplier-[Mono])\n+* that never does anything: `never` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#never--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#never--[Mono])\n+* that is decided at subscription: `defer` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defer-java.util.function.Supplier-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defer-java.util.function.Supplier-[Mono])\n+* that depends on a disposable resource: `using` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-[Mono])\n * that generates events programmatically (can use state):\n-** synchronously and one-by-one: `Flux#generate`\n-** asynchronously (can also be sync), multiple emissions possible in one pass: `Flux#create`\n-(`Mono#create` as well, without the multiple emission aspect)\n+** synchronously and one-by-one: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#generate-java.util.concurrent.Callable-java.util.function.BiFunction-[Flux#generate]\n+** asynchronously (can also be sync), multiple emissions possible in one pass: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#create-java.util.function.Consumer-[Flux#create]\n+(https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#create-java.util.function.Consumer-[Mono#create] as well, without the multiple emission aspect)\n \n [[which.values]]\n == Transforming an Existing Sequence\n \n * I want to transform existing data:\n-** on a 1-to-1 basis (eg. strings to their length): `map`\n-*** ...by just casting it: `cast`\n-*** ...in order to materialize each source value's index: `Flux#index`\n-** on a 1-to-n basis (eg. strings to their characters): `flatMap` + use a factory method\n-** on a 1-to-n basis with programmatic behavior for each source element and/or state: `handle`\n-** running an asynchronous task for each source item (eg. urls to http request): `flatMap` + an async `Publisher`-returning method\n-*** ...ignoring some data: conditionally return a `Mono.empty()` in the flatMap lambda\n-*** ...retaining the original sequence order: `Flux#flatMapSequential` (this triggers the async processes immediately but reorders the results)\n-*** ...where the async task can return multiple values, from a `Mono` source: `Mono#flatMapMany`\n+** on a 1-to-1 basis (eg. strings to their length): `map` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#map-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#map-java.util.function.Function-[Mono])\n+*** ...by just casting it: `cast` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cast-java.lang.Class-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#cast-java.lang.Class-[Mono])\n+*** ...in order to materialize each source value's index: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#index--[Flux#index]\n+** on a 1-to-n basis (eg. strings to their characters): `flatMap` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMap-java.util.function.Function-[Mono]) + use a factory method\n+** on a 1-to-n basis with programmatic behavior for each source element and/or state: `handle` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#handle-java.util.function.BiConsumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#handle-java.util.function.BiConsumer-[Mono])\n+** running an asynchronous task for each source item (eg. urls to http request): `flatMap` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMap-java.util.function.Function-[Mono]) + an async https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true[Publisher]-returning method\n+*** ...ignoring some data: conditionally return a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#empty--[Mono.empty()] in the flatMap lambda\n+*** ...retaining the original sequence order: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-[Flux#flatMapSequential] (this triggers the async processes immediately but reorders the results)\n+*** ...where the async task can return multiple values, from a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono] source: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMapMany-java.util.function.Function-[Mono#flatMapMany]\n \n * I want to add pre-set elements to an existing sequence:\n-** at the start: `Flux#startWith(T...)`\n-** at the end: `Flux#concatWith(T...)`\n-\n-* I want to aggregate a `Flux`: (the `Flux#` prefix is assumed below)\n-** into a List: `collectList`, `collectSortedList`\n-** into a Map: `collectMap`, `collectMultiMap`\n-** into an arbitrary container: `collect`\n-** into the size of the sequence: `count`\n-** by applying a function between each element (eg. running sum): `reduce`\n-*** ...but emitting each intermediary value: `scan`\n+** at the start: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#startWith-T%2E%2E%2E-[Flux#startWith(T...)]\n+** at the end: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatWithValues-T%2E%2E%2E-[Flux#concatWithValues(T...)]\n+\n+* I want to aggregate a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux]: (the `Flux#` prefix is assumed below)\n+** into a List: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectList--[collectList], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectSortedList--[collectSortedList]\n+** into a Map: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectMap-java.util.function.Function-[collectMap], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectMultimap-java.util.function.Function-[collectMultiMap]\n+** into an arbitrary container: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collect-java.util.stream.Collector-[collect]\n+** into the size of the sequence: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#count--[count]\n+** by applying a function between each element (eg. running sum): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#reduce-A-java.util.function.BiFunction-[reduce]\n+*** ...but emitting each intermediary value: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#scan-A-java.util.function.BiFunction-[scan]\n ** into a boolean value from a predicate:\n-*** applied to all values (AND): `all`\n-*** applied to at least one value (OR): `any`\n-*** testing the presence of any value: `hasElements`\n-*** testing the presence of a specific value: `hasElement`\n+*** applied to all values (AND): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#all-java.util.function.Predicate-[all]\n+*** applied to at least one value (OR): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#any-java.util.function.Predicate-[any]\n+*** testing the presence of any value: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#hasElements--[hasElements]\n+*** testing the presence of a specific value: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#hasElement-T-[hasElement(T)]\n \n \n * I want to combine publishers...\n-** in sequential order: `Flux#concat` or `.concatWith(other)`\n-*** ...but delaying any error until remaining publishers have been emitted: `Flux#concatDelayError`\n-*** ...but eagerly subscribing to subsequent publishers: `Flux#mergeSequential`\n-** in emission order (combined items emitted as they come): `Flux#merge` / `.mergeWith(other)`\n-*** ...with different types (transforming merge): `Flux#zip` / `Flux#zipWith`\n+** in sequential order: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher%2E%2E%2E-[Flux#concat] or `.concatWith(other)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatWith-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#concatWith-org.reactivestreams.Publisher-[Mono])\n+*** ...but delaying any error until remaining publishers have been emitted: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatDelayError-org.reactivestreams.Publisher-[Flux#concatDelayError]\n+*** ...but eagerly subscribing to subsequent publishers: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#mergeSequential-int-org.reactivestreams.Publisher%2E%2E%2E-[Flux#mergeSequential]\n+** in emission order (combined items emitted as they come): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#merge-int-org.reactivestreams.Publisher%2E%2E%2E-[Flux#merge] / `.mergeWith(other)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#mergeWith-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#mergeWith-org.reactivestreams.Publisher-[Mono])\n+*** ...with different types (transforming merge): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zip-java.util.function.Function-org.reactivestreams.Publisher%2E%2E%2E-[Flux#zip] / https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zipWith-org.reactivestreams.Publisher-[Flux#zipWith]\n ** by pairing values:\n-*** from 2 Monos into a `Tuple2`: `Mono#zipWith`\n-*** from n Monos when they all completed: `Mono#zip`\n+*** from 2 Monos into a https://projectreactor.io/docs/core/release/api/reactor/util/function/Tuple2.html[Tuple2]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#zipWith-reactor.core.publisher.Mono-[Mono#zipWith]\n+*** from n Monos when they all completed: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#zip-java.util.function.Function-reactor.core.publisher.Mono%2E%2E%2E-[Mono#zip]\n ** by coordinating their termination:\n-*** from 1 Mono and any source into a `Mono<Void>`: `Mono#and`\n-*** from n sources when they all completed: `Mono#when`\n+*** from 1 Mono and any source into a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono<Void>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#and-org.reactivestreams.Publisher-[Mono#and]\n+*** from n sources when they all completed: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#when-java.lang.Iterable-[Mono#when]\n *** into an arbitrary container type:\n-**** each time all sides have emitted: `Flux#zip` (up to the smallest cardinality)\n-**** each time a new value arrives at either side: `Flux#combineLatest`\n+**** each time all sides have emitted: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zip-java.util.function.Function-org.reactivestreams.Publisher%2E%2E%2E-[Flux#zip] (up to the smallest cardinality)\n+**** each time a new value arrives at either side: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#combineLatest-java.util.function.Function-int-org.reactivestreams.Publisher%2E%2E%2E-[Flux#combineLatest]\n ** selecting the first publisher which...\n-*** produces a _value_ (`onNext`): `firstWithValue`\n-*** produces _any signal_: `firstWithSignal`\n-** triggered by the elements in a source sequence: `switchMap` (each source element is mapped to a Publisher)\n-** triggered by the start of the next publisher in a sequence of publishers: `switchOnNext`\n+*** produces a _value_ (`onNext`): `firstWithValue` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#firstWithValue-java.lang.Iterable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#firstWithValue-java.lang.Iterable-[Mono])\n+*** produces _any signal_: `firstWithSignal` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#firstWithSignal-java.lang.Iterable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#firstWithSignal-java.lang.Iterable-[Mono])\n+** triggered by the elements in a source sequence: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchMap-java.util.function.Function-[switchMap] (each source element is mapped to a Publisher)\n+** triggered by the start of the next publisher in a sequence of publishers: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchOnNext-org.reactivestreams.Publisher-[switchOnNext]\n \n-* I want to repeat an existing sequence: `repeat`\n+* I want to repeat an existing sequence: `repeat` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#repeat--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#repeat--[Mono])\n ** ...but at time intervals: `Flux.interval(duration).flatMap(tick -> myExistingPublisher)`\n \n * I have an empty sequence but...\n-** I want a value instead: `defaultIfEmpty`\n-** I want another sequence instead: `switchIfEmpty`\n+** I want a value instead: `defaultIfEmpty` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defaultIfEmpty-T-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defaultIfEmpty-T-[Mono])\n+** I want another sequence instead: `switchIfEmpty` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchIfEmpty-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#switchIfEmpty-reactor.core.publisher.Mono-[Mono])\n \n-* I have a sequence but I am not interested in values: `ignoreElements`\n-** ...and I want the completion represented as a `Mono`: `then`\n-** ...and I want to wait for another task to complete at the end: `thenEmpty`\n-** ...and I want to switch to another `Mono` at the end: `Mono#then(mono)`\n-** ...and I want to emit a single value at the end: `Mono#thenReturn(T)`\n-** ...and I want to switch to a `Flux` at the end: `thenMany`\n+* I have a sequence but I am not interested in values: `ignoreElements` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ignoreElements--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ignoreElement--[Mono])\n+** ...and I want the completion represented as a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono<Void>]: `then` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#then--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#then--[Mono])\n+** ...and I want to wait for another task to complete at the end: `thenEmpty` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#thenEmpty-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenEmpty-org.reactivestreams.Publisher-[Mono])\n+** ...and I want to switch to another https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono] at the end: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#then-reactor.core.publisher.Mono-[Mono#then(mono)]\n+** ...and I want to emit a single value at the end: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenReturn-V-[Mono#thenReturn(T)]\n+** ...and I want to switch to a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux] at the end: `thenMany` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#thenMany-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenMany-org.reactivestreams.Publisher-[Mono])\n \n * I have a Mono for which I want to defer completion...\n-** ...until another publisher, which is derived from this value, has completed: `Mono#delayUntil(Function)`\n+** ...until another publisher, which is derived from this value, has completed: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delayUntil-java.util.function.Function-[Mono#delayUntil(Function)]\n \n * I want to expand elements recursively into a graph of sequences and emit the combination...\n-** ...expanding the graph breadth first: `expand(Function)`\n-** ...expanding the graph depth first: `expandDeep(Function)`\n+** ...expanding the graph breadth first: `expand(Function)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expand-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#expand-java.util.function.Function-[Mono])\n+** ...expanding the graph depth first: `expandDeep(Function)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expandDeep-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#expandDeep-java.util.function.Function-[Mono])\n \n [[which.peeking]]\n == Peeking into a Sequence\n \n * Without modifying the final sequence, I want to:\n ** get notified of / execute additional behavior (sometimes referred to as \"side-effects\") on:\n-*** emissions: `doOnNext`\n-*** completion: `Flux#doOnComplete`, `Mono#doOnSuccess` (includes the result, if any)\n-*** error termination: `doOnError`\n-*** cancellation: `doOnCancel`\n-*** \"start\" of the sequence: `doFirst`\n-**** this is tied to `Publisher#subscribe(Subscriber)`\n-*** post-subscription : `doOnSubscribe`\n-**** as in `Subscription` acknowledgment after `subscribe`\n-**** this is tied to `Subscriber#onSubscribe(Subscription)`\n-*** request: `doOnRequest`\n-*** completion or error: `doOnTerminate` (Mono version includes the result, if any)\n-**** but *after* it has been propagated downstream: `doAfterTerminate`\n-*** any type of signal, represented as a `Signal`: `Flux#doOnEach`\n-*** any terminating condition (complete, error, cancel): `doFinally`\n-** log what happens internally: `log`\n+*** emissions: `doOnNext` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnNext-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnNext-java.util.function.Consumer-[Mono])\n+*** completion: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnComplete-java.lang.Runnable-[Flux#doOnComplete], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnSuccess-java.util.function.Consumer-[Mono#doOnSuccess] (includes the result, if any)\n+*** error termination: `doOnError` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnError-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnError-java.util.function.Consumer-[Mono])\n+*** cancellation: `doOnCancel` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnCancel-java.lang.Runnable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnCancel-java.lang.Runnable-[Mono])\n+*** \"start\" of the sequence: `doFirst` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFirst-java.lang.Runnable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFirst-java.lang.Runnable-[Mono])\n+**** this is tied to https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true#subscribe(org.reactivestreams.Subscriber)[Publisher#subscribe(Subscriber)]\n+*** post-subscription : `doOnSubscribe` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnSubscribe-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnSubscribe-java.util.function.Consumer-[Mono])\n+**** `Subscription` acknowledgment after `subscribe`\n+**** this is tied to https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true#onSubscribe(org.reactivestreams.Subscription)[Subscriber#onSubscribe(Subscription)]\n+*** request: `doOnRequest` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnRequest-java.util.function.LongConsumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnRequest-java.util.function.LongConsumer-[Mono])\n+*** completion or error: `doOnTerminate` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnTerminate-java.lang.Runnable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnTerminate-java.lang.Runnable-[Mono])\n+**** but *after* it has been propagated downstream: `doAfterTerminate` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doAfterTerminate-java.lang.Runnable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doAfterTerminate-java.lang.Runnable-[Mono])\n+*** any type of signal, represented as a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Signal.html[Signal]: `doOnEach` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnEach-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnEach-java.util.function.Consumer-[Mono])\n+*** any terminating condition (complete, error, cancel): `doFinally` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFinally-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFinally-java.util.function.Consumer-[Mono])\n+** log what happens internally: `log` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#log--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#log--[Mono])\n \n * I want to know of all events:\n-** each represented as `Signal` object:\n-*** in a callback outside the sequence: `doOnEach`\n-*** instead of the original onNext emissions: `materialize`\n-**** ...and get back to the onNexts: `dematerialize`\n-** as a line in a log: `log`\n+** each represented as https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Signal.html[Signal] object:\n+*** in a callback outside the sequence: `doOnEach` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnEach-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnEach-java.util.function.Consumer-[Mono])\n+*** instead of the original onNext emissions: `materialize` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#materialize--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#materialize--[Mono])\n+**** ...and get back to the onNexts: `dematerialize` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#dematerialize--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#dematerialize--[Mono])\n+** as a line in a log: `log` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#log--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#log--[Mono])\n \n [[which.filtering]]\n == Filtering a Sequence\n \n * I want to filter a sequence:\n-** based on an arbitrary criteria: `filter`\n-*** ...that is asynchronously computed: `filterWhen`\n-** restricting on the type of the emitted objects: `ofType`\n-** by ignoring the values altogether: `ignoreElements`\n+** based on an arbitrary criteria: `filter` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filter-java.util.function.Predicate-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#filter-java.util.function.Predicate-[Mono])\n+*** ...that is asynchronously computed: `filterWhen` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filterWhen-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#filterWhen-java.util.function.Function-[Mono])\n+** restricting on the type of the emitted objects: `ofType` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ofType-java.lang.Class-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ofType-java.lang.Class-[Mono])\n+** by ignoring the values altogether: `ignoreElements` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ignoreElements--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ignoreElement--[Mono])\n ** by ignoring duplicates:\n-*** in the whole sequence (logical set): `Flux#distinct`\n-*** between subsequently emitted items (deduplication): `Flux#distinctUntilChanged`\n+*** in the whole sequence (logical set): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#distinct--[Flux#distinct]\n+*** between subsequently emitted items (deduplication): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#distinctUntilChanged--[Flux#distinctUntilChanged]\n \n * I want to keep only a subset of the sequence:\n ** by taking N elements:\n-*** at the beginning of the sequence: `Flux#take(long)`\n-**** ...based on a duration: `Flux#take(Duration)`\n-**** ...only the first element, as a `Mono`: `Flux#next()`\n-**** ...using `request(N)` rather than cancellation: `Flux#limitRequest(long)`\n-*** at the end of the sequence: `Flux#takeLast`\n-*** until a criteria is met (inclusive): `Flux#takeUntil` (predicate-based), `Flux#takeUntilOther` (companion publisher-based)\n-*** while a criteria is met (exclusive): `Flux#takeWhile`\n+*** at the beginning of the sequence: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-long-[Flux#take(long)]\n+**** ...based on a duration: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-java.time.Duration-[Flux#take(Duration)]\n+**** ...only the first element, as a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#next--[Flux#next()]\n+**** ...using https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscription.html#request(long)[request(N)] rather than cancellation: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#limitRequest-long-[Flux#limitRequest(long)]\n+*** at the end of the sequence: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeLast-int-[Flux#takeLast]\n+*** until a criteria is met (inclusive): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeUntil-java.util.function.Predicate-[Flux#takeUntil] (predicate-based), https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeUntilOther-org.reactivestreams.Publisher-[Flux#takeUntilOther] (companion publisher-based)\n+*** while a criteria is met (exclusive): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeWhile-java.util.function.Predicate-[Flux#takeWhile]\n ** by taking at most 1 element:\n-*** at a specific position: `Flux#elementAt`\n-*** at the end: `.takeLast(1)`\n-**** ...and emit an error if empty: `Flux#last()`\n-**** ...and emit a default value if empty: `Flux#last(T)`\n+*** at a specific position: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#elementAt-int-[Flux#elementAt]\n+*** at the end: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeLast-int-[.takeLast(1)]\n+**** ...and emit an error if empty: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#last--[Flux#last()]\n+**** ...and emit a default value if empty: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#last-T-[Flux#last(T)]\n ** by skipping elements:\n-*** at the beginning of the sequence: `Flux#skip(long)`\n-**** ...based on a duration: `Flux#skip(Duration)`\n-*** at the end of the sequence: `Flux#skipLast`\n-*** until a criteria is met (inclusive): `Flux#skipUntil` (predicate-based), `Flux#skipUntilOther` (companion publisher-based)\n-*** while a criteria is met (exclusive): `Flux#skipWhile`\n+*** at the beginning of the sequence: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skip-long-[Flux#skip(long)]\n+**** ...based on a duration: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skip-java.time.Duration-[Flux#skip(Duration)]\n+*** at the end of the sequence: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipLast-int-[Flux#skipLast]\n+*** until a criteria is met (inclusive): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipUntil-java.util.function.Predicate-[Flux#skipUntil] (predicate-based), https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipUntilOther-org.reactivestreams.Publisher-[Flux#skipUntilOther] (companion publisher-based)\n+*** while a criteria is met (exclusive): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipWhile-java.util.function.Predicate-[Flux#skipWhile]\n ** by sampling items:\n-*** by duration: `Flux#sample(Duration)`\n-**** but keeping the first element in the sampling window instead of the last: `sampleFirst`\n-*** by a publisher-based window: `Flux#sample(Publisher)`\n-*** based on a publisher \"timing out\": `Flux#sampleTimeout` (each element triggers a publisher, and is emitted if that publisher does not overlap with the next)\n+*** by duration: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sample-java.time.Duration-[Flux#sample(Duration)]\n+**** but keeping the first element in the sampling window instead of the last: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sampleFirst-java.time.Duration-[sampleFirst]\n+*** by a publisher-based window: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sample-org.reactivestreams.Publisher-[Flux#sample(Publisher)]\n+*** based on a publisher \"timing out\": https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sampleTimeout-java.util.function.Function-[Flux#sampleTimeout] (each element triggers a publisher, and is emitted if that publisher does not overlap with the next)\n \n * I expect at most 1 element (error if more than one)...\n-** and I want an error if the sequence is empty: `Flux#single()`\n-** and I want a default value if the sequence is empty: `Flux#single(T)`\n-** and I accept an empty sequence as well: `Flux#singleOrEmpty`\n+** and I want an error if the sequence is empty: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#single--[Flux#single()]\n+** and I want a default value if the sequence is empty: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#single-T-[Flux#single(T)]\n+** and I accept an empty sequence as well: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#singleOrEmpty--[Flux#singleOrEmpty]\n \n \n \n [[which.errors]]\n == Handling Errors\n \n-* I want to create an erroring sequence: `error`...\n-** ...to replace the completion of a successful `Flux`: `.concat(Flux.error(e))`\n-** ...to replace the *emission* of a successful `Mono`: `.then(Mono.error(e))`\n-** ...if too much time elapses between onNexts: `timeout`\n-** ...lazily: `error(Supplier<Throwable>)`\n+* I want to create an erroring sequence: `error` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-[Mono])...\n+** ...to replace the completion of a successful https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux]: `.concat(Flux.error(e))`\n+** ...to replace the *emission* of a successful https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono]: `.then(Mono.error(e))`\n+** ...if too much time elapses between onNexts: `timeout` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timeout-java.time.Duration-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timeout-java.time.Duration-[Mono])\n+** ...lazily: `error(Supplier<Throwable>)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.util.function.Supplier-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.util.function.Supplier-[Mono])\n \n * I want the try/catch equivalent of:\n-** throwing: `error`\n+** throwing: `error` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-[Mono])\n ** catching an exception:\n-*** and falling back to a default value: `onErrorReturn`\n-*** and falling back to another `Flux` or `Mono`: `onErrorResume`\n-*** and wrapping and re-throwing: `.onErrorMap(t -> new RuntimeException(t))`\n-** the finally block: `doFinally`\n-** the using pattern from Java 7: `using` factory method\n+*** and falling back to a default value: `onErrorReturn` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorReturn-java.lang.Class-T-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorReturn-java.lang.Class-T-[Mono])\n+*** and falling back to another https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux] or https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono]: `onErrorResume` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorResume-java.lang.Class-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorResume-java.lang.Class-java.util.function.Function-[Mono])\n+*** and wrapping and re-throwing: `.onErrorMap(t -> new RuntimeException(t))` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorMap-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorMap-java.util.function.Function-[Mono])\n+** the finally block: `doFinally` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFinally-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFinally-java.util.function.Consumer-[Mono])\n+** the using pattern from Java 7: `using` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-[Mono]) factory method\n \n * I want to recover from errors...\n ** by falling back:\n-*** to a value: `onErrorReturn`\n-*** to a `Publisher` or `Mono`, possibly different ones depending on the error: `Flux#onErrorResume` and `Mono#onErrorResume`\n+*** to a value: `onErrorReturn` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorReturn-java.lang.Class-T-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorReturn-java.lang.Class-T-[Mono])\n+*** to a https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true[Publisher] or https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono], possibly different ones depending on the error: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorResume-java.lang.Class-java.util.function.Function-[Flux#onErrorResume] and https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorResume-java.lang.Class-java.util.function.Function-[Mono#onErrorResume]\n ** by retrying...\n-*** ...with a simple policy (max number of attempts): `retry()`, `retry(long)`\n-*** ...triggered by a companion control Flux: `retryWhen`\n-*** ...using a standard backoff strategy (exponential backoff with jitter): `retryWhen(Retry.backoff(...))` (see also other factory methods in `Retry`)\n+*** ...with a simple policy (max number of attempts): `retry()` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retry--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retry--[Mono]), `retry(long)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retry-long-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retry-long-[Mono])\n+*** ...triggered by a companion control Flux: `retryWhen` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retryWhen-reactor.util.retry.Retry-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retryWhen-reactor.util.retry.Retry-[Mono])\n+*** ...using a standard backoff strategy (exponential backoff with jitter): `retryWhen(Retry.backoff(...))` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retryWhen-reactor.util.retry.Retry-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retryWhen-reactor.util.retry.Retry-[Mono]) (see also other factory methods in https://projectreactor.io/docs/core/release/api/reactor/util/retry/Retry.html[Retry])\n \n * I want to deal with backpressure \"errors\" (request max from upstream and apply the strategy when downstream does not produce enough request)...\n-** by throwing a special `IllegalStateException`: `Flux#onBackpressureError`\n-** by dropping excess values: `Flux#onBackpressureDrop`\n-*** ...except the last one seen: `Flux#onBackpressureLatest`\n-** by buffering excess values (bounded or unbounded): `Flux#onBackpressureBuffer`\n-*** ...and applying a strategy when bounded buffer also overflows: `Flux#onBackpressureBuffer` with a `BufferOverflowStrategy`\n+** by throwing a special https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalStateException.html?is-external=true[IllegalStateException]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureError--[Flux#onBackpressureError]\n+** by dropping excess values: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureDrop--[Flux#onBackpressureDrop]\n+*** ...except the last one seen: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureLatest--[Flux#onBackpressureLatest]\n+** by buffering excess values (bounded or unbounded): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureBuffer--[Flux#onBackpressureBuffer]\n+*** ...and applying a strategy when bounded buffer also overflows: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureBuffer-int-reactor.core.publisher.BufferOverflowStrategy-[Flux#onBackpressureBuffer] with a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/BufferOverflowStrategy.html[BufferOverflowStrategy]\n \n [[which.time]]\n == Working with Time\n \n * I want to associate emissions with a timing measured...\n-** ...with best available precision and versatility of provided data: `timed`\n-*** `Timed<T>#elapsed()` for `Duration` since last `onNext`\n-*** `Timed<T>#timestamp()` for `Instant` representation of the epoch timestamp (milliseconds resolution)\n-*** `Timed<T>#elapsedSinceSubcription()` for `Duration` since subscription (rather than last onNext)\n-*** can have nanoseconds resolution for elapsed `Duration`s\n-** ...as a (legacy) `Tuple2<Long, T>`...\n-*** since last onNext: `elapsed`\n-*** since the dawn of time (well, computer time): `timestamp`\n+** ...with best available precision and versatility of provided data: `timed` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timed--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timed--[Mono])\n+*** https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#elapsed--[Timed<T>#elapsed()] for https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true[Duration] since last `onNext`\n+*** https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#timestamp--[Timed<T>#timestamp()] for https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html?is-external=true[Instant] representation of the epoch timestamp (milliseconds resolution)\n+*** https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#elapsedSinceSubscription--[Timed<T>#elapsedSinceSubcription()] for https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true[Duration] since subscription (rather than last onNext)\n+*** can have nanoseconds resolution for elapsed https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true[Duration]s\n+** ...as a (legacy) https://projectreactor.io/docs/core/release/api/reactor/util/function/Tuple2.html[Tuple2<Long, T>]...\n+*** since last onNext: `elapsed` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#elapsed--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#elapsed--[Mono])\n+*** since the dawn of time (well, computer time): `timestamp` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timestamp--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timestamp--[Mono])\n \n \n-* I want my sequence to be interrupted if there is too much delay between emissions: `timeout`\n+* I want my sequence to be interrupted if there is too much delay between emissions: `timeout` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timeout-java.time.Duration-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timeout-java.time.Duration-[Mono])\n \n-* I want to get ticks from a clock, regular time intervals: `Flux#interval`\n+* I want to get ticks from a clock, regular time intervals: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#interval-java.time.Duration-[Flux#interval]\n \n-* I want to emit a single `0` after an initial delay: static `Mono.delay`.\n+* I want to emit a single `0` after an initial delay: static https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delay-java.time.Duration-[Mono.delay].\n \n * I want to introduce a delay:\n-** between each onNext signal: `Mono#delayElement`, `Flux#delayElements`\n-** before the subscription happens: `delaySubscription`\n+** between each onNext signal: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delayElement-java.time.Duration-[Mono#delayElement], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#delayElements-java.time.Duration-[Flux#delayElements]\n+** before the subscription happens: `delaySubscription` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#delaySubscription-java.time.Duration-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delaySubscription-java.time.Duration-[Mono])\n \n [[which.window]]\n-== Splitting a `Flux`\n-\n-* I want to split a `Flux<T>` into a `Flux<Flux<T>>`, by a boundary criteria:\n-** of size: `window(int)`\n-*** ...with overlapping or dropping windows: `window(int, int)`\n-** of time `window(Duration)`\n-*** ...with overlapping or dropping windows: `window(Duration, Duration)`\n-** of size OR time (window closes when count is reached or timeout elapsed): `windowTimeout(int, Duration)`\n-** based on a predicate on elements: `windowUntil`\n-*** ...…emitting the element that triggered the boundary in the next window (`cutBefore` variant): `.windowUntil(predicate, true)`\n-*** ...keeping the window open while elements match a predicate: `windowWhile` (non-matching elements are not emitted)\n-** driven by an arbitrary boundary represented by onNexts in a control Publisher: `window(Publisher)`, `windowWhen`\n-\n-* I want to split a `Flux<T>` and buffer elements within boundaries together...\n-** into `List`:\n-*** by a size boundary: `buffer(int)`\n-**** ...with overlapping or dropping buffers: `buffer(int, int)`\n-*** by a duration boundary: `buffer(Duration)`\n-**** ...with overlapping or dropping buffers: `buffer(Duration, Duration)`\n-*** by a size OR duration boundary: `bufferTimeout(int, Duration)`\n-*** by an arbitrary criteria boundary: `bufferUntil(Predicate)`\n-**** ...putting the element that triggered the boundary in the next buffer: `.bufferUntil(predicate, true)`\n-**** ...buffering while predicate matches and dropping the element that triggered the boundary: `bufferWhile(Predicate)`\n-*** driven by an arbitrary boundary represented by onNexts in a control Publisher: `buffer(Publisher)`, `bufferWhen`\n-** into an arbitrary \"collection\" type `C`: use variants like `buffer(int, Supplier<C>)`\n-\n-* I want to split a `Flux<T>` so that element that share a characteristic end up in the same sub-flux: `groupBy(Function<T,K>)`\n-TIP: Note that this returns a `Flux<GroupedFlux<K, T>>`, each inner `GroupedFlux` shares the same `K` key accessible through `key()`.\n+== Splitting a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux]\n+\n+* I want to split a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux<T>] into a `Flux<Flux<T>>`, by a boundary criteria:\n+** of size: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-int-[window(int)]\n+*** ...with overlapping or dropping windows: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-int-int-[window(int, int)]\n+** of time https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-java.time.Duration-[window(Duration)]\n+*** ...with overlapping or dropping windows: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-java.time.Duration-java.time.Duration-[window(Duration, Duration)]\n+** of size OR time (window closes when count is reached or timeout elapsed): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowTimeout-int-java.time.Duration-[windowTimeout(int, Duration)]\n+** based on a predicate on elements: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-[windowUntil]\n+*** ...…emitting the element that triggered the boundary in the next window (`cutBefore` variant): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-boolean-[.windowUntil(predicate, true)]\n+*** ...keeping the window open while elements match a predicate: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowWhile-java.util.function.Predicate-[windowWhile] (non-matching elements are not emitted)\n+** driven by an arbitrary boundary represented by onNexts in a control Publisher: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-org.reactivestreams.Publisher-[window(Publisher)], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowWhen-org.reactivestreams.Publisher-java.util.function.Function-[windowWhen]\n+\n+* I want to split a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux<T>] and buffer elements within boundaries together...\n+** into https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true[List]:\n+*** by a size boundary: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-[buffer(int)]\n+**** ...with overlapping or dropping buffers: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-int-[buffer(int, int)]\n+*** by a duration boundary: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-java.time.Duration-java.time.Duration-[buffer(Duration)]\n+**** ...with overlapping or dropping buffers: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-java.time.Duration-java.time.Duration-[buffer(Duration, Duration)]\n+*** by a size OR duration boundary: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferTimeout-int-java.time.Duration-[bufferTimeout(int, Duration)]\n+*** by an arbitrary criteria boundary: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferUntil-java.util.function.Predicate-[bufferUntil(Predicate)]\n+**** ...putting the element that triggered the boundary in the next buffer: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferUntil-java.util.function.Predicate-boolean-[.bufferUntil(predicate, true)]\n+**** ...buffering while predicate matches and dropping the element that triggered the boundary: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferWhile-java.util.function.Predicate-[bufferWhile(Predicate)]\n+*** driven by an arbitrary boundary represented by onNexts in a control Publisher: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-org.reactivestreams.Publisher-[buffer(Publisher)], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferWhen-org.reactivestreams.Publisher-java.util.function.Function-[bufferWhen]\n+** into an arbitrary \"collection\" type `C`: use variants like https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-java.util.function.Supplier-[buffer(int, Supplier<C>)]\n+\n+* I want to split a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux<T>] so that element that share a characteristic end up in the same sub-flux: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#groupBy-java.util.function.Function-[groupBy(Function<T,K>)]\n+TIP: Note that this returns a `Flux<GroupedFlux<K, T>>`, each inner https://projectreactor.io/docs/core/release/api/reactor/core/publisher/GroupedFlux.html[GroupedFlux] shares the same `K` key accessible through https://projectreactor.io/docs/core/release/api/reactor/core/publisher/GroupedFlux.html#key--[key()].\n \n [[which.blocking]]\n == Going Back to the Synchronous World\n \n-Note: all of these methods except `Mono#toFuture` will throw an `UnsupportedOperatorException` if called from\n-within a `Scheduler` marked as \"non-blocking only\" (by default `parallel()` and `single()`).\n+Note: all of these methods except https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#toFuture--[Mono#toFuture] will throw an https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html?is-external=true[UnsupportedOperatorException] if called from\n+within a https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html[Scheduler] marked as \"non-blocking only\" (by default https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html#parallel--[parallel()] and https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html#single--[single()]).\n \n-* I have a `Flux<T>` and I want to:\n-** block until I can get the first element: `Flux#blockFirst`\n-*** ...with a timeout: `Flux#blockFirst(Duration)`\n-** block until I can get the last element (or null if empty): `Flux#blockLast`\n-*** ...with a timeout: `Flux#blockLast(Duration)`\n-** synchronously switch to an `Iterable<T>`: `Flux#toIterable`\n-** synchronously switch to a Java 8 `Stream<T>`: `Flux#toStream`\n+* I have a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux<T>] and I want to:\n+** block until I can get the first element: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockFirst--[Flux#blockFirst]\n+*** ...with a timeout: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockFirst-java.time.Duration-[Flux#blockFirst(Duration)]\n+** block until I can get the last element (or null if empty): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockLast--[Flux#blockLast]\n+*** ...with a timeout: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockLast-java.time.Duration-[Flux#blockLast(Duration)]\n+** synchronously switch to an https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html?is-external=true[Iterable<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#toIterable--[Flux#toIterable]\n+** synchronously switch to a Java 8 https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html[Stream<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#toStream--[Flux#toStream]\n \n-* I have a `Mono<T>` and I want:\n-** to block until I can get the value: `Mono#block`\n-*** ...with a timeout: `Mono#block(Duration)`\n-** a `CompletableFuture<T>`: `Mono#toFuture`\n+* I have a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono<T>] and I want:\n+** to block until I can get the value: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#block--[Mono#block]\n+*** ...with a timeout: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#block-java.time.Duration-[Mono#block(Duration)]\n+** a https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html[CompletableFuture<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#toFuture--[Mono#toFuture]\n \n [[which.multicasting]]\n-== Multicasting a `Flux` to several `Subscribers`\n-\n-* I want to connect multiple `Subscriber` to a `Flux`:\n-** and decide when to trigger the source with `connect()`: `publish()` (returns a `ConnectableFlux`)\n-** and trigger the source immediately (late subscribers see later data): `share()`\n-** and permanently connect the source when enough subscribers have registered: `.publish().autoConnect(n)`\n-** and automatically connect and cancel the source when subscribers go above/below the threshold: `.publish().refCount(n)`\n-*** ...but giving a chance for new subscribers to come in before cancelling: `.publish().refCountGrace(n, Duration)`\n-\n-* I want to cache data from a `Publisher` and replay it to later subscribers:\n-** up to `n` elements: `cache(int)`\n-** caching latest elements seen within a `Duration` (Time-To-Live): `cache(Duration)`\n-*** ...but retain no more than `n` elements: `cache(int, Duration)`\n-** but without immediately triggering the source: `Flux#replay` (returns a `ConnectableFlux`)\n+== Multicasting a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux] to several https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true[Subscribers]\n+\n+* I want to connect multiple https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true[Subscriber] to a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux]:\n+** and decide when to trigger the source with https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#connect--[connect()]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#publish--[publish()] (returns a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html[ConnectableFlux])\n+** and trigger the source immediately (late subscribers see later data): `share()` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#share--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#share--[Mono])\n+** and permanently connect the source when enough subscribers have registered: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#autoConnect-int-[.publish().autoConnect(n)]\n+** and automatically connect and cancel the source when subscribers go above/below the threshold: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#refCount-int-[.publish().refCount(n)]\n+*** ...but giving a chance for new subscribers to come in before cancelling: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#refCount-int-java.time.Duration-[.publish().refCount(n, Duration)]\n+\n+* I want to cache data from a https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true[Publisher] and replay it to later subscribers:\n+** up to `n` elements: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-int-[cache(int)]\n+** caching latest elements seen within a https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true[Duration] (Time-To-Live): `cache(Duration)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-java.time.Duration-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#cache-java.time.Duration-[Mono])\n+*** ...but retain no more than `n` elements: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-int-java.time.Duration-[cache(int, Duration)]\n+** but without immediately triggering the source: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#replay--[Flux#replay] (returns a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html[ConnectableFlux])"
  }
]
