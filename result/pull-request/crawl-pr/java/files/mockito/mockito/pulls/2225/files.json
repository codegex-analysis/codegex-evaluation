[
  {
    "sha": "083fce65a484fd459f4633eafd5c1ae6221b0d0d",
    "filename": "src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java",
    "status": "modified",
    "additions": 77,
    "deletions": 54,
    "changes": 131,
    "blob_url": "https://github.com/mockito/mockito/blob/e36cb84b7032f18eec95a35d7b23248756fd1dd5/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java",
    "raw_url": "https://github.com/mockito/mockito/raw/e36cb84b7032f18eec95a35d7b23248756fd1dd5/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java",
    "contents_url": "https://api.github.com/repos/mockito/mockito/contents/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java?ref=e36cb84b7032f18eec95a35d7b23248756fd1dd5",
    "patch": "@@ -5,10 +5,15 @@\n package org.mockito.internal.exceptions.stacktrace;\n \n import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.ArrayList;\n import java.util.List;\n-\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.stacktrace.StackTraceCleaner;\n import org.mockito.internal.configuration.plugins.Plugins;\n \n@@ -20,18 +25,22 @@\n             Plugins.getStackTraceCleanerProvider()\n                     .getStackTraceCleaner(new DefaultStackTraceCleaner());\n \n-    private static Object JAVA_LANG_ACCESS;\n-    private static Method GET_STACK_TRACE_ELEMENT;\n+    private static Object STACK_WALKER_INSTANCE;\n+    private static Method WALK_METHOD;\n+    private static Method TO_STACKTRACE_ELEMENT;\n+    private static Method DROP_WHILE;\n \n     static {\n         try {\n-            JAVA_LANG_ACCESS =\n-                    Class.forName(\"sun.misc.SharedSecrets\")\n-                            .getMethod(\"getJavaLangAccess\")\n-                            .invoke(null);\n-            GET_STACK_TRACE_ELEMENT =\n-                    Class.forName(\"sun.misc.JavaLangAccess\")\n-                            .getMethod(\"getStackTraceElement\", Throwable.class, int.class);\n+            STACK_WALKER_INSTANCE =\n+                    Class.forName(\"java.lang.StackWalker\").getMethod(\"getInstance\").invoke(null);\n+            WALK_METHOD = Class.forName(\"java.lang.StackWalker\").getMethod(\"walk\", Function.class);\n+            TO_STACKTRACE_ELEMENT =\n+                    Class.forName(\"java.lang.StackWalker.StackFrame\")\n+                            .getMethod(\"toStackTraceElement\");\n+            DROP_WHILE =\n+                    Class.forName(\"java.util.stream.Stream\")\n+                            .getMethod(\"dropWhile\", Predicate.class);\n         } catch (Exception ignored) {\n             // Use the slow computational path for filtering stacktraces if fast path does not exist\n             // in JVM\n@@ -60,56 +69,35 @@\n     /**\n      * This filtering strategy makes use of a fast-path computation to retrieve stackTraceElements\n      * from a Stacktrace of a Throwable. It does so, by taking advantage of {@link\n-     * sun.misc.SharedSecrets} and {@link sun.misc.JavaLangAccess}.\n+     * java.lang.StackWalker}.\n      *\n-     * <p>The {@link sun.misc.SharedSecrets} provides a method to obtain an instance of an {@link\n-     * sun.misc.JavaLangAccess}. The latter class has a method to fast-path into {@link\n-     * Throwable#getStackTrace()} and retrieve a single {@link StackTraceElement}. This prevents the\n-     * JVM from having to generate a full stacktrace, which could potentially be expensive if\n-     * stacktraces become very large.\n+     * <p>The {@link java.lang.StackWalker} provides a method to efficiently walk a stacktrace,\n+     * without requiring to compute the full stacktrace. This prevents the JVM from having to\n+     * generate a full stacktrace, which could potentially be expensive if stacktraces become\n+     * very large.\n      *\n      * @param target The throwable target to find the first {@link StackTraceElement} that should\n      *     not be filtered out per {@link StackTraceFilter#CLEANER}.\n      * @return The first {@link StackTraceElement} outside of the {@link StackTraceFilter#CLEANER}\n      */\n     public StackTraceElement filterFirst(Throwable target, boolean isInline) {\n-        boolean shouldSkip = isInline;\n-\n-        if (GET_STACK_TRACE_ELEMENT != null) {\n-            int i = 0;\n+        AtomicBoolean shouldSkip = new AtomicBoolean(isInline);\n \n-            // The assumption here is that the CLEANER filter will not filter out every single\n-            // element. However, since we don't want to compute the full length of the stacktrace,\n-            // we don't know the upper boundary. Therefore, simply increment the counter and go as\n-            // far as we have to go, assuming that we get there. If, in the rare occasion, we\n-            // don't, we fall back to the old slow path.\n-            while (true) {\n-                try {\n-                    StackTraceElement stackTraceElement =\n-                            (StackTraceElement)\n-                                    GET_STACK_TRACE_ELEMENT.invoke(JAVA_LANG_ACCESS, target, i);\n-\n-                    if (CLEANER.isIn(stackTraceElement)) {\n-                        if (shouldSkip) {\n-                            shouldSkip = false;\n-                        } else {\n-                            return stackTraceElement;\n-                        }\n-                    }\n-                } catch (Exception e) {\n-                    // Fall back to slow path\n-                    break;\n-                }\n-                i++;\n+        if (STACK_WALKER_INSTANCE != null) {\n+            try {\n+                WALK_METHOD.invoke(\n+                        STACK_WALKER_INSTANCE, getFirstNonMockitoStackTraceElement(shouldSkip));\n+            } catch (IllegalAccessException | InvocationTargetException ignored) {\n+                // Fall back to slow path\n             }\n         }\n \n         // If we can't use the fast path of retrieving stackTraceElements, use the slow path by\n         // iterating over the actual stacktrace\n         for (StackTraceElement stackTraceElement : target.getStackTrace()) {\n             if (CLEANER.isIn(stackTraceElement)) {\n-                if (shouldSkip) {\n-                    shouldSkip = false;\n+                if (shouldSkip.get()) {\n+                    shouldSkip.set(false);\n                 } else {\n                     return stackTraceElement;\n                 }\n@@ -118,16 +106,51 @@ public StackTraceElement filterFirst(Throwable target, boolean isInline) {\n         return null;\n     }\n \n-    /**\n-     * Finds the source file of the target stack trace.\n-     * Returns the default value if source file cannot be found.\n-     */\n-    public String findSourceFile(StackTraceElement[] target, String defaultValue) {\n-        for (StackTraceElement e : target) {\n-            if (CLEANER.isIn(e)) {\n-                return e.getFileName();\n+    private Function<Stream<Object>, StackTraceElement> getFirstNonMockitoStackTraceElement(\n+            AtomicBoolean shouldSkip) {\n+        return (Stream<Object> s) ->\n+                removeMockitoStackTraceElements(shouldSkip, s)\n+                        .map(StackTraceFilter::getStackTraceElement)\n+                        .findFirst()\n+                        .orElseThrow(\n+                                () -> {\n+                                    throw new MockitoException(\n+                                            \"Internal error occurred. Mockito was unable to find the first non-Mockito stackframe.\");\n+                                });\n+    }\n+\n+    private Stream<Object> removeMockitoStackTraceElements(\n+            AtomicBoolean shouldSkip, Stream<Object> s) {\n+        try {\n+            return (Stream<Object>)\n+                    DROP_WHILE.invoke(\n+                            s,\n+                            (Predicate<Object>) frame -> shouldDropStackFrame(frame, shouldSkip));\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new MockitoException(\n+                    \"Internal error occurred. Mockito was unable to find the first non-Mockito stackframe.\",\n+                    e);\n+        }\n+    }\n+\n+    private static StackTraceElement getStackTraceElement(Object frame) {\n+        try {\n+            return (StackTraceElement) TO_STACKTRACE_ELEMENT.invoke(frame);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new MockitoException(\n+                    \"Internal error occurred. Mockito was unable to find the first non-Mockito stackframe.\",\n+                    e);\n+        }\n+    }\n+\n+    private static boolean shouldDropStackFrame(Object frame, AtomicBoolean shouldSkip) {\n+        if (CLEANER.isIn(getStackTraceElement(frame))) {\n+            if (shouldSkip.get()) {\n+                shouldSkip.set(false);\n+            } else {\n+                return false;\n             }\n         }\n-        return defaultValue;\n+        return true;\n     }\n }"
  },
  {
    "sha": "61f5c47ac09554d5d692503a2cb0301c8fa65458",
    "filename": "subprojects/memory-test/memory-test.gradle",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/mockito/mockito/blob/e36cb84b7032f18eec95a35d7b23248756fd1dd5/subprojects/memory-test/memory-test.gradle",
    "raw_url": "https://github.com/mockito/mockito/raw/e36cb84b7032f18eec95a35d7b23248756fd1dd5/subprojects/memory-test/memory-test.gradle",
    "contents_url": "https://api.github.com/repos/mockito/mockito/contents/subprojects/memory-test/memory-test.gradle?ref=e36cb84b7032f18eec95a35d7b23248756fd1dd5",
    "patch": "@@ -14,6 +14,6 @@ dependencies {\n tasks.javadoc.enabled = false\n \n test {\n-    maxHeapSize = \"128m\"\n-    jvmArgs = [\"-XX:MaxPermSize=128m\"]\n+    maxHeapSize = \"64m\"\n+    jvmArgs = [\"-XX:MaxMetaspaceSize=64m\"]\n }"
  },
  {
    "sha": "c3d06f0415e78a5315f8c2ecab85a82565ebbf2d",
    "filename": "subprojects/memory-test/src/test/java/org/mockito/memorytest/ShouldNotStarveMemoryOnLargeStackTraceInvocationsTest.java",
    "status": "modified",
    "additions": 2,
    "deletions": 7,
    "changes": 9,
    "blob_url": "https://github.com/mockito/mockito/blob/e36cb84b7032f18eec95a35d7b23248756fd1dd5/subprojects/memory-test/src/test/java/org/mockito/memorytest/ShouldNotStarveMemoryOnLargeStackTraceInvocationsTest.java",
    "raw_url": "https://github.com/mockito/mockito/raw/e36cb84b7032f18eec95a35d7b23248756fd1dd5/subprojects/memory-test/src/test/java/org/mockito/memorytest/ShouldNotStarveMemoryOnLargeStackTraceInvocationsTest.java",
    "contents_url": "https://api.github.com/repos/mockito/mockito/contents/subprojects/memory-test/src/test/java/org/mockito/memorytest/ShouldNotStarveMemoryOnLargeStackTraceInvocationsTest.java?ref=e36cb84b7032f18eec95a35d7b23248756fd1dd5",
    "patch": "@@ -14,19 +14,14 @@\n \n public class ShouldNotStarveMemoryOnLargeStackTraceInvocationsTest {\n \n-    private static final int STACK_TRACE_DEPTH = 1000;\n+    private static final int STACK_TRACE_DEPTH = 10000;\n     private static final int INVOCATIONS_ON_STACK_TRACE_LEVEL = 100;\n \n     private static boolean supported = false;\n \n     static {\n         try {\n-            Class.forName(\"sun.misc.SharedSecrets\")\n-                .getMethod(\"getJavaLangAccess\")\n-                .invoke(null);\n-            Class.forName(\"sun.misc.JavaLangAccess\")\n-                .getMethod(\"getStackTraceElement\", Throwable.class, int.class);\n-\n+            Class.forName(\"java.lang.StackWalker\").getMethod(\"getInstance\").invoke(null);\n             supported = true;\n         } catch (Exception ignored) {\n         }"
  }
]
