[
  {
    "sha": "ab4ff69c4b58a484059fe51b68797618f2c6826b",
    "filename": ".gitignore",
    "status": "modified",
    "additions": 5,
    "deletions": 1,
    "changes": 6,
    "blob_url": "https://github.com/santanusinha/json-rules/blob/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/.gitignore",
    "raw_url": "https://github.com/santanusinha/json-rules/raw/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/.gitignore",
    "contents_url": "https://api.github.com/repos/santanusinha/json-rules/contents/.gitignore?ref=282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b",
    "patch": "@@ -60,4 +60,8 @@ com_crashlytics_export_strings.xml\n crashlytics.properties\n crashlytics-build.properties\n \n-target\n\\ No newline at end of file\n+target\n+\n+.classpath\n+.project\n+.settings/"
  },
  {
    "sha": "8849f1490690748cb58cee8be3ee29073edcf807",
    "filename": "README.md",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/santanusinha/json-rules/blob/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/README.md",
    "raw_url": "https://github.com/santanusinha/json-rules/raw/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/README.md",
    "contents_url": "https://api.github.com/repos/santanusinha/json-rules/contents/README.md?ref=282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b",
    "patch": "@@ -30,7 +30,7 @@ Maven repo\n   <dependency>\n     <groupId>io.appform.rules</groupId>\n     <artifactId>json-rules</artifactId>\n-    <version>1.0.10</version>\n+    <version>1.0.11</version>\n   </dependency>\n ```\n "
  },
  {
    "sha": "432e41d1730830019359683a6fa8e10daec804ad",
    "filename": "src/main/java/io/appform/jsonrules/Expression.java",
    "status": "modified",
    "additions": 16,
    "deletions": 5,
    "changes": 21,
    "blob_url": "https://github.com/santanusinha/json-rules/blob/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/src/main/java/io/appform/jsonrules/Expression.java",
    "raw_url": "https://github.com/santanusinha/json-rules/raw/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/src/main/java/io/appform/jsonrules/Expression.java",
    "contents_url": "https://api.github.com/repos/santanusinha/json-rules/contents/src/main/java/io/appform/jsonrules/Expression.java?ref=282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b",
    "patch": "@@ -28,6 +28,8 @@\n import io.appform.jsonrules.expressions.composite.AndExpression;\n import io.appform.jsonrules.expressions.composite.NotExpression;\n import io.appform.jsonrules.expressions.composite.OrExpression;\n+import io.appform.jsonrules.expressions.debug.DenialDetail;\n+import io.appform.jsonrules.expressions.debug.ExpressionDebugger;\n import io.appform.jsonrules.expressions.equality.EqualsExpression;\n import io.appform.jsonrules.expressions.equality.NotEqualsExpression;\n import io.appform.jsonrules.expressions.meta.ExistsExpression;\n@@ -48,8 +50,7 @@\n @EqualsAndHashCode\n @ToString\n @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.EXISTING_PROPERTY, property = \"type\")\n-@JsonSubTypes({\n-        @JsonSubTypes.Type(name = \"equals\", value = EqualsExpression.class),\n+@JsonSubTypes({ @JsonSubTypes.Type(name = \"equals\", value = EqualsExpression.class),\n         @JsonSubTypes.Type(name = \"not_equals\", value = NotEqualsExpression.class),\n \n         @JsonSubTypes.Type(name = \"greater_than\", value = GreaterThanExpression.class),\n@@ -74,8 +75,7 @@\n         @JsonSubTypes.Type(name = \"in\", value = InExpression.class),\n         @JsonSubTypes.Type(name = \"not_in\", value = NotInExpression.class),\n         @JsonSubTypes.Type(name = \"contains_any\", value = ContainsAnyExpression.class),\n-        @JsonSubTypes.Type(name = \"contains_all\", value = ContainsAllExpression.class),\n-})\n+        @JsonSubTypes.Type(name = \"contains_all\", value = ContainsAllExpression.class), })\n public abstract class Expression {\n     private final ExpressionType type;\n \n@@ -92,7 +92,18 @@ public boolean evaluate(JsonNode node, Map<OptionKeys, Object> options) {\n             // Fail safe check, to replace null with missing node.\n             node = MissingNode.getInstance();\n         }\n-        return evaluate(ExpressionEvaluationContext.builder().node(node).options(options).build());\n+        return evaluate(ExpressionEvaluationContext.builder()\n+                .node(node)\n+                .options(options)\n+                .build());\n+    }\n+\n+    public DenialDetail debug(JsonNode node) {\n+        return ExpressionDebugger.builder()\n+                .expression(this)\n+                .node(node)\n+                .build()\n+                .debug();\n     }\n \n     public abstract boolean evaluate(ExpressionEvaluationContext context);"
  },
  {
    "sha": "d4f9cca96e9afd5a4b3bc49a70bccb362495268f",
    "filename": "src/main/java/io/appform/jsonrules/expressions/debug/DenialDetail.java",
    "status": "added",
    "additions": 34,
    "deletions": 0,
    "changes": 34,
    "blob_url": "https://github.com/santanusinha/json-rules/blob/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/src/main/java/io/appform/jsonrules/expressions/debug/DenialDetail.java",
    "raw_url": "https://github.com/santanusinha/json-rules/raw/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/src/main/java/io/appform/jsonrules/expressions/debug/DenialDetail.java",
    "contents_url": "https://api.github.com/repos/santanusinha/json-rules/contents/src/main/java/io/appform/jsonrules/expressions/debug/DenialDetail.java?ref=282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b",
    "patch": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2021 Mohammed Irfanulla S <mohammed.irfanulla.s1@gmail.com>\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package io.appform.jsonrules.expressions.debug;\n+\n+import io.appform.jsonrules.ExpressionType;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+@Data\n+@Builder\n+@AllArgsConstructor\n+public class DenialDetail {\n+    private ExpressionType expressionType;\n+    private String path;\n+    private Object value;\n+    private boolean denied;\n+    private String reason;\n+}"
  },
  {
    "sha": "889326f6ffc6e32be0f61d96b957350d98c1d999",
    "filename": "src/main/java/io/appform/jsonrules/expressions/debug/ExpressionDebugger.java",
    "status": "added",
    "additions": 461,
    "deletions": 0,
    "changes": 461,
    "blob_url": "https://github.com/santanusinha/json-rules/blob/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/src/main/java/io/appform/jsonrules/expressions/debug/ExpressionDebugger.java",
    "raw_url": "https://github.com/santanusinha/json-rules/raw/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/src/main/java/io/appform/jsonrules/expressions/debug/ExpressionDebugger.java",
    "contents_url": "https://api.github.com/repos/santanusinha/json-rules/contents/src/main/java/io/appform/jsonrules/expressions/debug/ExpressionDebugger.java?ref=282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b",
    "patch": "@@ -0,0 +1,461 @@\n+/**\n+ * Copyright (c) 2021 Mohammed Irfanulla S <mohammed.irfanulla.s1@gmail.com>\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package io.appform.jsonrules.expressions.debug;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.jayway.jsonpath.JsonPath;\n+import com.jayway.jsonpath.PathNotFoundException;\n+\n+import io.appform.jsonrules.Expression;\n+import io.appform.jsonrules.ExpressionVisitor;\n+import io.appform.jsonrules.expressions.array.ContainsAllExpression;\n+import io.appform.jsonrules.expressions.array.ContainsAnyExpression;\n+import io.appform.jsonrules.expressions.array.InExpression;\n+import io.appform.jsonrules.expressions.array.NotInExpression;\n+import io.appform.jsonrules.expressions.composite.AndExpression;\n+import io.appform.jsonrules.expressions.composite.NotExpression;\n+import io.appform.jsonrules.expressions.composite.OrExpression;\n+import io.appform.jsonrules.expressions.equality.EqualsExpression;\n+import io.appform.jsonrules.expressions.equality.NotEqualsExpression;\n+import io.appform.jsonrules.expressions.meta.ExistsExpression;\n+import io.appform.jsonrules.expressions.meta.NotExistsExpression;\n+import io.appform.jsonrules.expressions.numeric.BetweenExpression;\n+import io.appform.jsonrules.expressions.numeric.GreaterThanEqualsExpression;\n+import io.appform.jsonrules.expressions.numeric.GreaterThanExpression;\n+import io.appform.jsonrules.expressions.numeric.LessThanEqualsExpression;\n+import io.appform.jsonrules.expressions.numeric.LessThanExpression;\n+import io.appform.jsonrules.expressions.string.EmptyExpression;\n+import io.appform.jsonrules.expressions.string.EndsWithExpression;\n+import io.appform.jsonrules.expressions.string.MatchesExpression;\n+import io.appform.jsonrules.expressions.string.NotEmptyExpression;\n+import io.appform.jsonrules.expressions.string.StartsWithExpression;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.val;\n+\n+@Data\n+@Builder\n+public class ExpressionDebugger implements ExpressionVisitor<DenialDetail> {\n+    private static final DenialDetail DEFAULT_SUCCESS_RESPONSE = DenialDetail.builder()\n+            .denied(false)\n+            .build();\n+    private final Expression expression;\n+    private final JsonNode node;\n+\n+    public DenialDetail debug() {\n+        return expression.accept(this, node);\n+    }\n+\n+    @Override\n+    public DenialDetail visit(AndExpression expression, JsonNode node) {\n+        final List<DenialDetail> details = expression.getChildren()\n+                .stream()\n+                .map(e -> e.accept(this, node))\n+                .filter(debugResult -> debugResult.isDenied())\n+                .collect(Collectors.toList());\n+        if (details.isEmpty()) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .denied(true)\n+                .reason(details.stream()\n+                        .map(DenialDetail::getReason)\n+                        .collect(Collectors.joining(\"\\n\", \"{\\n\", \"\\n}\")))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(OrExpression expression, JsonNode node) {\n+        final List<DenialDetail> details = expression.getChildren()\n+                .stream()\n+                .map(e -> e.accept(this, node))\n+                .filter(debugResult -> debugResult.isDenied())\n+                .collect(Collectors.toList());\n+        if (details.size() < expression.getChildren()\n+                .size()) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .denied(true)\n+                .reason(details.stream()\n+                        .map(DenialDetail::getReason)\n+                        .collect(Collectors.joining(\"\\n\", \"{\\n\", \"\\n}\")))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(NotExpression expression, JsonNode node) {\n+        final List<DenialDetail> details = expression.getChildren()\n+                .stream()\n+                .map(e -> e.accept(this, node))\n+                .filter(debugResult -> debugResult.isDenied())\n+                .collect(Collectors.toList());\n+        if (details.size() == expression.getChildren()\n+                .size()) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .denied(true)\n+                .reason(details.stream()\n+                        .map(DenialDetail::getReason)\n+                        .collect(Collectors.joining(\"\\n\", \"{\\n\", \"\\n}\")))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(ExistsExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Path [%s] doesn't exist\", expression.getPath()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(NotExistsExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Path [%s] exists\", expression.getPath()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(GreaterThanExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Value of [%s] at path [%s] is not greater than [%s]\",\n+                        value,\n+                        expression.getPath(),\n+                        expression.getValue()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(GreaterThanEqualsExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Value of [%s] at path [%s] is less than [%s]\",\n+                        value,\n+                        expression.getPath(),\n+                        expression.getValue()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(LessThanExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Value of [%s] at path [%s] is not less than [%s]\",\n+                        value,\n+                        expression.getPath(),\n+                        expression.getValue()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(LessThanEqualsExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Value of [%s] at path [%s] is greater than [%s]\",\n+                        value,\n+                        expression.getPath(),\n+                        expression.getValue()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(EqualsExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Value of [%s] at path [%s] is not equals to [%s]\",\n+                        value,\n+                        expression.getPath(),\n+                        expression.getValue()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(NotEqualsExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Value of [%s] at path [%s] is equal to [%s]\",\n+                        value,\n+                        expression.getPath(),\n+                        expression.getValue()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(EmptyExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Value at path [%s] is not empty\", expression.getPath()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(NotEmptyExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Value at path [%s] is empty\", expression.getPath()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(StartsWithExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Value of [%s] at path [%s] doesn't start with [%s]\",\n+                        value,\n+                        expression.getPath(),\n+                        expression.getValue()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(EndsWithExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Value of [%s] at path [%s] doesn't end with [%s]\",\n+                        value,\n+                        expression.getPath(),\n+                        expression.getValue()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(MatchesExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Value of [%s] at path [%s] doesn't match with [%s]\",\n+                        value,\n+                        expression.getPath(),\n+                        expression.getValue()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(InExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Value of [%s] at path [%s] is not among shorlisted values\",\n+                        value,\n+                        expression.getPath()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(NotInExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String\n+                        .format(\"Value of [%s] at path [%s] is among shortlisted values\", value, expression.getPath()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(ContainsAnyExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"None of the values at path [%s] are among shortlisted values\",\n+                        expression.getPath()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(ContainsAllExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Not all of the values at path [%s] are among shortlisted values\",\n+                        expression.getPath()))\n+                .build();\n+    }\n+\n+    @Override\n+    public DenialDetail visit(BetweenExpression expression, JsonNode node) {\n+        final val value = fetchValue(node, expression.getPath());\n+        final boolean result = expression.evaluate(node);\n+        if (result) {\n+            return DEFAULT_SUCCESS_RESPONSE;\n+        }\n+        return DenialDetail.builder()\n+                .expressionType(expression.getType())\n+                .path(expression.getPath())\n+                .value(value)\n+                .denied(true)\n+                .reason(String.format(\"Value of [%s] at path [%s] is not between [%s] & [%s]\",\n+                        value,\n+                        expression.getPath(),\n+                        expression.getLowerBound(),\n+                        expression.getUpperBound()))\n+                .build();\n+    }\n+\n+    private Object fetchValue(JsonNode jsonNode, String path) {\n+        if (jsonNode != null && path != null) {\n+            try {\n+                return JsonPath.read(jsonNode.toString(), path);\n+            } catch (PathNotFoundException e) {\n+                // ignore\n+            }\n+        }\n+        return null;\n+    }\n+\n+}"
  },
  {
    "sha": "939f8b8aed731430d2797f772e552908e015b805",
    "filename": "src/test/java/io/appform/jsonrules/CollectionExpressionDebugTest.java",
    "status": "added",
    "additions": 151,
    "deletions": 0,
    "changes": 151,
    "blob_url": "https://github.com/santanusinha/json-rules/blob/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/src/test/java/io/appform/jsonrules/CollectionExpressionDebugTest.java",
    "raw_url": "https://github.com/santanusinha/json-rules/raw/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/src/test/java/io/appform/jsonrules/CollectionExpressionDebugTest.java",
    "contents_url": "https://api.github.com/repos/santanusinha/json-rules/contents/src/test/java/io/appform/jsonrules/CollectionExpressionDebugTest.java?ref=282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b",
    "patch": "@@ -0,0 +1,151 @@\n+/**\n+ * Copyright (c) 2021 Mohammed Irfanulla S <mohammed.irfanulla.s1@gmail.com>\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package io.appform.jsonrules;\n+\n+import java.util.Objects;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.Sets;\n+\n+import io.appform.jsonrules.expressions.array.ContainsAllExpression;\n+import io.appform.jsonrules.expressions.array.ContainsAnyExpression;\n+import io.appform.jsonrules.expressions.array.InExpression;\n+import io.appform.jsonrules.expressions.array.NotInExpression;\n+import io.appform.jsonrules.expressions.debug.DenialDetail;\n+\n+public class CollectionExpressionDebugTest {\n+\n+    private ExpressionEvaluationContext context;\n+    private ObjectMapper mapper;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        mapper = new ObjectMapper();\n+        JsonNode node = mapper.readTree(\n+                \"{ \\\"felines\\\": [\\\"leopard\\\",\\\"lion\\\",\\\"tiger\\\",\\\"jaguar\\\"],\\\"integers\\\": [10,20,30,40],\\\"decimals\\\": [10.01,20.22,30.33,40.55], \\\"emptyString\\\" : \\\"\\\", \\\"s3\\\" : \\\"Hello.*\\\", \\\"s1\\\" : \\\"HelloAllHello\\\", \\\"s2\\\" : \\\"Hello\\\",\\\"string\\\" : \\\"Hello\\\", \\\"kid\\\": null, \\\"boolean\\\" : true }\");\n+        context = ExpressionEvaluationContext.builder()\n+                .node(node)\n+                .build();\n+    }\n+\n+    @Test\n+    public void testContainsAnyExpression() throws Exception {\n+        final ContainsAnyExpression positiveCase = ContainsAnyExpression.builder()\n+                .path(\"$.felines\")\n+                .values(Sets.newHashSet(\"leopard\", \"lion\", \"panther\"))\n+                .defaultResult(false)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final ContainsAnyExpression negativeCase = ContainsAnyExpression.builder()\n+                .path(\"$.felines\")\n+                .values(Sets.newHashSet(\"panther\"))\n+                .defaultResult(false)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"None of the values at path [$.felines] are among shortlisted values\",\n+                debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testContainsAllExpression() throws Exception {\n+        final ContainsAllExpression positiveCase = ContainsAllExpression.builder()\n+                .path(\"$.felines\")\n+                .values(Sets.newHashSet(\"tiger\", \"leopard\", \"lion\", \"jaguar\"))\n+                .defaultResult(false)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final ContainsAllExpression negativeCase = ContainsAllExpression.builder()\n+                .path(\"$.felines\")\n+                .values(Sets.newHashSet(\"tiger\", \"leopard\", \"lion\", \"panther\"))\n+                .defaultResult(false)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Not all of the values at path [$.felines] are among shortlisted values\",\n+                debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testInExpression() throws Exception {\n+        final InExpression positiveCase = InExpression.builder()\n+                .path(\"$.felines[0]\")\n+                .valuesPath(\"$.felines\")\n+                .extractValues(true)\n+                .defaultResult(false)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final InExpression negativeCase = InExpression.builder()\n+                .path(\"$.felines[0]\")\n+                .valuesPath(\"$.integers\")\n+                .extractValues(true)\n+                .defaultResult(false)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value of [leopard] at path [$.felines[0]] is not among shorlisted values\",\n+                debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testNotInExpression() throws Exception {\n+        final NotInExpression positiveCase = NotInExpression.builder()\n+                .path(\"$.felines[0]\")\n+                .valuesPath(\"$.integers\")\n+                .extractValues(true)\n+                .defaultResult(false)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final NotInExpression negativeCase = NotInExpression.builder()\n+                .path(\"$.felines[0]\")\n+                .valuesPath(\"$.felines\")\n+                .extractValues(true)\n+                .defaultResult(false)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value of [leopard] at path [$.felines[0]] is among shortlisted values\",\n+                debugNegative.getReason());\n+    }\n+\n+}"
  },
  {
    "sha": "fe6a101180ae0ed42a2855ed6b9fde57996882fd",
    "filename": "src/test/java/io/appform/jsonrules/CompositeExpressionDebugTest.java",
    "status": "added",
    "additions": 157,
    "deletions": 0,
    "changes": 157,
    "blob_url": "https://github.com/santanusinha/json-rules/blob/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/src/test/java/io/appform/jsonrules/CompositeExpressionDebugTest.java",
    "raw_url": "https://github.com/santanusinha/json-rules/raw/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/src/test/java/io/appform/jsonrules/CompositeExpressionDebugTest.java",
    "contents_url": "https://api.github.com/repos/santanusinha/json-rules/contents/src/test/java/io/appform/jsonrules/CompositeExpressionDebugTest.java?ref=282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b",
    "patch": "@@ -0,0 +1,157 @@\n+/**\n+ * Copyright (c) 2021 Mohammed Irfanulla S <mohammed.irfanulla.s1@gmail.com>\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.appform.jsonrules;\n+\n+import java.util.Objects;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import io.appform.jsonrules.expressions.composite.AndExpression;\n+import io.appform.jsonrules.expressions.composite.NotExpression;\n+import io.appform.jsonrules.expressions.composite.OrExpression;\n+import io.appform.jsonrules.expressions.debug.DenialDetail;\n+import io.appform.jsonrules.expressions.numeric.GreaterThanExpression;\n+import io.appform.jsonrules.expressions.numeric.LessThanExpression;\n+\n+public class CompositeExpressionDebugTest {\n+\n+    private ExpressionEvaluationContext context;\n+    private ObjectMapper mapper;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        mapper = new ObjectMapper();\n+        JsonNode node = mapper.readTree(\n+                \"{ \\\"v1\\\": 20, \\\"v2\\\": 30, \\\"v3\\\": 20.001, \\\"value\\\": 20, \\\"string\\\" : \\\"Hello\\\", \\\"string1\\\" : \\\"Hello1\\\", \\\"kid\\\": null, \\\"boolean\\\" : true }\");\n+        context = ExpressionEvaluationContext.builder()\n+                .node(node)\n+                .build();\n+    }\n+\n+    @Test\n+    public void testAndExpression() {\n+        final AndExpression positiveCase = AndExpression.builder()\n+                .child(LessThanExpression.builder()\n+                        .path(\"$.value\")\n+                        .value(30)\n+                        .build())\n+                .child(GreaterThanExpression.builder()\n+                        .path(\"$.value\")\n+                        .value(10)\n+                        .build())\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final AndExpression negativeCase = AndExpression.builder()\n+                .child(LessThanExpression.builder()\n+                        .path(\"$.value\")\n+                        .value(5)\n+                        .build())\n+                .child(GreaterThanExpression.builder()\n+                        .path(\"$.value\")\n+                        .value(10)\n+                        .build())\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"{\\nValue of [20] at path [$.value] is not less than [5]\\n}\", debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testOrExpression() {\n+        final OrExpression positiveCase = OrExpression.builder()\n+                .child(LessThanExpression.builder()\n+                        .path(\"$.value\")\n+                        .value(20)\n+                        .build())\n+                .child(GreaterThanExpression.builder()\n+                        .path(\"$.value\")\n+                        .value(10)\n+                        .build())\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final OrExpression negativeCase = OrExpression.builder()\n+                .child(LessThanExpression.builder()\n+                        .path(\"$.value\")\n+                        .value(11)\n+                        .build())\n+                .child(GreaterThanExpression.builder()\n+                        .path(\"$.value\")\n+                        .value(30)\n+                        .build())\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\n+                \"{\\nValue of [20] at path [$.value] is not less than [11]\\n\"\n+                        + \"Value of [20] at path [$.value] is not greater than [30]\\n\" + \"}\",\n+                debugNegative.getReason());\n+\n+    }\n+\n+    @Test\n+    public void testNotExpression() throws Exception {\n+        final NotExpression positiveCase = NotExpression.builder()\n+                .child(OrExpression.builder()\n+                        .child(LessThanExpression.builder()\n+                                .path(\"$.value\")\n+                                .value(11)\n+                                .build())\n+                        .child(GreaterThanExpression.builder()\n+                                .path(\"$.value\")\n+                                .value(19)\n+                                .build())\n+                        .build())\n+                .build();\n+        Assert.assertFalse(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertTrue(debugPositive.isDenied());\n+        Assert.assertEquals(\"{\\n\\n}\", debugPositive.getReason());\n+\n+        final NotExpression negativeCase = NotExpression.builder()\n+                .child(OrExpression.builder()\n+                        .child(LessThanExpression.builder()\n+                                .path(\"$.value\")\n+                                .value(11)\n+                                .build())\n+                        .child(GreaterThanExpression.builder()\n+                                .path(\"$.value\")\n+                                .value(21)\n+                                .build())\n+                        .build())\n+                .build();\n+        Assert.assertTrue(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertFalse(debugNegative.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugNegative.getReason()));\n+    }\n+\n+}"
  },
  {
    "sha": "a19150ad683766b0c2cd6ffebadb4e2040a7fa39",
    "filename": "src/test/java/io/appform/jsonrules/NumericalExpressionDebugTest.java",
    "status": "added",
    "additions": 289,
    "deletions": 0,
    "changes": 289,
    "blob_url": "https://github.com/santanusinha/json-rules/blob/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/src/test/java/io/appform/jsonrules/NumericalExpressionDebugTest.java",
    "raw_url": "https://github.com/santanusinha/json-rules/raw/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/src/test/java/io/appform/jsonrules/NumericalExpressionDebugTest.java",
    "contents_url": "https://api.github.com/repos/santanusinha/json-rules/contents/src/test/java/io/appform/jsonrules/NumericalExpressionDebugTest.java?ref=282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b",
    "patch": "@@ -0,0 +1,289 @@\n+/**\n+ * Copyright (c) 2021 Mohammed Irfanulla S <mohammed.irfanulla.s1@gmail.com>\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.appform.jsonrules;\n+\n+import java.util.Objects;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.Sets;\n+\n+import io.appform.jsonrules.expressions.array.InExpression;\n+import io.appform.jsonrules.expressions.array.NotInExpression;\n+import io.appform.jsonrules.expressions.debug.DenialDetail;\n+import io.appform.jsonrules.expressions.equality.EqualsExpression;\n+import io.appform.jsonrules.expressions.equality.NotEqualsExpression;\n+import io.appform.jsonrules.expressions.meta.ExistsExpression;\n+import io.appform.jsonrules.expressions.meta.NotExistsExpression;\n+import io.appform.jsonrules.expressions.numeric.BetweenExpression;\n+import io.appform.jsonrules.expressions.numeric.GreaterThanEqualsExpression;\n+import io.appform.jsonrules.expressions.numeric.GreaterThanExpression;\n+import io.appform.jsonrules.expressions.numeric.LessThanEqualsExpression;\n+import io.appform.jsonrules.expressions.numeric.LessThanExpression;\n+\n+public class NumericalExpressionDebugTest {\n+\n+    private ExpressionEvaluationContext context;\n+    private ObjectMapper mapper;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        mapper = new ObjectMapper();\n+        JsonNode node = mapper.readTree(\n+                \"{ \\\"v1\\\": 20, \\\"v2\\\": 30, \\\"v3\\\": 20.001, \\\"value\\\": 20, \\\"string\\\" : \\\"Hello\\\", \\\"string1\\\" : \\\"Hello1\\\", \\\"kid\\\": null, \\\"boolean\\\" : true }\");\n+        context = ExpressionEvaluationContext.builder()\n+                .node(node)\n+                .build();\n+    }\n+\n+    @Test\n+    public void testEqualsExpression() throws Exception {\n+        final EqualsExpression positiveCase = EqualsExpression.builder()\n+                .path(\"$.value\")\n+                .value(20)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final EqualsExpression negativeCase = EqualsExpression.builder()\n+                .path(\"$.abcd\")\n+                .value(20)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value of [null] at path [$.abcd] is not equals to [20]\", debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testNotEqualsExpression() throws Exception {\n+        final NotEqualsExpression positiveCase = NotEqualsExpression.builder()\n+                .path(\"$.value\")\n+                .value(10)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final NotEqualsExpression negativeCase = NotEqualsExpression.builder()\n+                .path(\"$.value\")\n+                .value(20)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value of [20] at path [$.value] is equal to [20]\", debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testInExpression() throws Exception {\n+        final InExpression positiveCase = InExpression.builder()\n+                .path(\"$.string\")\n+                .values(Sets.newHashSet(\"Hello\", \"World\"))\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final InExpression negativeCase = InExpression.builder()\n+                .path(\"$.kid\")\n+                .values(Sets.newHashSet(\"Hello\", \"World\"))\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value of [null] at path [$.kid] is not among shorlisted values\",\n+                debugNegative.getReason());\n+\n+    }\n+\n+    @Test\n+    public void testNotInExpression() throws Exception {\n+        final NotInExpression positiveCase = NotInExpression.builder()\n+                .path(\"$.string\")\n+                .values(Sets.newHashSet(\"hello\", \"world\"))\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final NotInExpression negativeCase = NotInExpression.builder()\n+                .path(\"$.string\")\n+                .values(Sets.newHashSet(\"Hello\", \"World\"))\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value of [Hello] at path [$.string] is among shortlisted values\",\n+                debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testExistsExpression() throws Exception {\n+        final ExistsExpression positiveCase = ExistsExpression.builder()\n+                .path(\"$.string\")\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final ExistsExpression negativeCase = ExistsExpression.builder()\n+                .path(\"$.somepath\")\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Path [$.somepath] doesn't exist\", debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testNotExistsExpression() throws Exception {\n+        final NotExistsExpression positiveCase = NotExistsExpression.builder()\n+                .path(\"$.somepath\")\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final NotExistsExpression negativeCase = NotExistsExpression.builder()\n+                .path(\"$.string\")\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Path [$.string] exists\", debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testGreaterThanExpression() throws Exception {\n+        final GreaterThanExpression positiveCase = GreaterThanExpression.builder()\n+                .path(\"$.value\")\n+                .value(5)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final GreaterThanExpression negativeCase = GreaterThanExpression.builder()\n+                .path(\"$.value\")\n+                .value(50)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value of [20] at path [$.value] is not greater than [50]\", debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testGreaterThanEqualsExpression() throws Exception {\n+        final GreaterThanEqualsExpression positiveCase = GreaterThanEqualsExpression.builder()\n+                .path(\"$.value\")\n+                .value(20)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final GreaterThanEqualsExpression negativeCase = GreaterThanEqualsExpression.builder()\n+                .path(\"$.value\")\n+                .value(21)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value of [20] at path [$.value] is less than [21]\", debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testLessThanExpression() throws Exception {\n+        final LessThanExpression positiveCase = LessThanExpression.builder()\n+                .path(\"$.value\")\n+                .value(30)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final LessThanExpression negativeCase = LessThanExpression.builder()\n+                .path(\"$.value\")\n+                .value(10)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value of [20] at path [$.value] is not less than [10]\", debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testLessThanEqualsExpression() throws Exception {\n+        final LessThanEqualsExpression positiveCase = LessThanEqualsExpression.builder()\n+                .path(\"$.value\")\n+                .value(20)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final LessThanEqualsExpression negativeCase = LessThanEqualsExpression.builder()\n+                .path(\"$.value\")\n+                .value(19)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value of [20] at path [$.value] is greater than [19]\", debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testBetweenExpression() throws Exception {\n+        final BetweenExpression positiveCase = BetweenExpression.builder()\n+                .path(\"$.v1\")\n+                .lowerbound(10)\n+                .upperBound(30)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final BetweenExpression negativeCase = BetweenExpression.builder()\n+                .path(\"$.v1\")\n+                .lowerbound(10)\n+                .upperBound(19)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value of [20] at path [$.v1] is not between [10] & [19]\", debugNegative.getReason());\n+    }\n+\n+}"
  },
  {
    "sha": "ee63612e86819f3a70df2e7327207f0c7b540e5a",
    "filename": "src/test/java/io/appform/jsonrules/StringBasedExpressionDebugTest.java",
    "status": "added",
    "additions": 144,
    "deletions": 0,
    "changes": 144,
    "blob_url": "https://github.com/santanusinha/json-rules/blob/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/src/test/java/io/appform/jsonrules/StringBasedExpressionDebugTest.java",
    "raw_url": "https://github.com/santanusinha/json-rules/raw/282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b/src/test/java/io/appform/jsonrules/StringBasedExpressionDebugTest.java",
    "contents_url": "https://api.github.com/repos/santanusinha/json-rules/contents/src/test/java/io/appform/jsonrules/StringBasedExpressionDebugTest.java?ref=282d786c6226d8bf0d188dfa6c1a6a44a2d78f5b",
    "patch": "@@ -0,0 +1,144 @@\n+package io.appform.jsonrules;\n+\n+import java.util.Objects;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import io.appform.jsonrules.expressions.debug.DenialDetail;\n+import io.appform.jsonrules.expressions.string.EmptyExpression;\n+import io.appform.jsonrules.expressions.string.EndsWithExpression;\n+import io.appform.jsonrules.expressions.string.MatchesExpression;\n+import io.appform.jsonrules.expressions.string.NotEmptyExpression;\n+import io.appform.jsonrules.expressions.string.StartsWithExpression;\n+\n+public class StringBasedExpressionDebugTest {\n+\n+    private ExpressionEvaluationContext context;\n+    private ObjectMapper mapper;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        mapper = new ObjectMapper();\n+        JsonNode node = mapper.readTree(\n+                \"{ \\\"value\\\": 20, \\\"emptyString\\\" : \\\"\\\", \\\"s3\\\" : \\\"Hello.*\\\", \\\"s1\\\" : \\\"HelloAllHello\\\", \\\"s2\\\" : \\\"Hello\\\",\\\"string\\\" : \\\"Hello\\\", \\\"kid\\\": null, \\\"boolean\\\" : true }\");\n+        context = ExpressionEvaluationContext.builder()\n+                .node(node)\n+                .build();\n+    }\n+\n+    @Test\n+    public void testEmptyExpression() throws Exception {\n+        final Expression positiveCase = EmptyExpression.builder()\n+                .path(\"$.somepath\")\n+                .defaultResult(true)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final Expression negativeCase = EmptyExpression.builder()\n+                .path(\"$.string\")\n+                .defaultResult(false)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value at path [$.string] is not empty\", debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testNotEmptyExpression() throws Exception {\n+\n+        final NotEmptyExpression positiveCase = NotEmptyExpression.builder()\n+                .path(\"$.somepath\")\n+                .defaultResult(true)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final NotEmptyExpression negativeCase = NotEmptyExpression.builder()\n+                .path(\"$.emptyString\")\n+                .defaultResult(false)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value at path [$.emptyString] is empty\", debugNegative.getReason());\n+\n+    }\n+\n+    @Test\n+    public void testStartsWithExpression() throws Exception {\n+        final StartsWithExpression positiveCase = StartsWithExpression.builder()\n+                .path(\"$.somepath\")\n+                .defaultResult(true)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final StartsWithExpression negativeCase = StartsWithExpression.builder()\n+                .path(\"$.string\")\n+                .value(\"he\")\n+                .defaultResult(false)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value of [Hello] at path [$.string] doesn't start with [he]\", debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testEndsWithExpression() throws Exception {\n+        final EndsWithExpression positiveCase = EndsWithExpression.builder()\n+                .path(\"$.somepath\")\n+                .defaultResult(true)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final EndsWithExpression negativeCase = EndsWithExpression.builder()\n+                .path(\"$.string\")\n+                .value(\"LO\")\n+                .defaultResult(false)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value of [Hello] at path [$.string] doesn't end with [LO]\", debugNegative.getReason());\n+    }\n+\n+    @Test\n+    public void testMatchesExpression() throws Exception {\n+        final MatchesExpression positiveCase = MatchesExpression.builder()\n+                .path(\"$.somepath\")\n+                .defaultResult(true)\n+                .build();\n+        Assert.assertTrue(positiveCase.evaluate(context));\n+        final DenialDetail debugPositive = positiveCase.debug(context.getNode());\n+        Assert.assertFalse(debugPositive.isDenied());\n+        Assert.assertTrue(Objects.isNull(debugPositive.getReason()));\n+\n+        final MatchesExpression negativeCase = MatchesExpression.builder()\n+                .path(\"$.string\")\n+                .value(\".*LO\")\n+                .defaultResult(false)\n+                .build();\n+        Assert.assertFalse(negativeCase.evaluate(context));\n+        final DenialDetail debugNegative = negativeCase.debug(context.getNode());\n+        Assert.assertTrue(debugNegative.isDenied());\n+        Assert.assertEquals(\"Value of [Hello] at path [$.string] doesn't match with [.*LO]\", debugNegative.getReason());\n+    }\n+\n+}"
  }
]
