[
  {
    "sha": "268910b961460807fcb2afb6b3fc64f146bc035b",
    "filename": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java",
    "status": "modified",
    "additions": 65,
    "deletions": 37,
    "changes": 102,
    "blob_url": "https://github.com/apache/helix/blob/3a7ba81c73a680a9b31f7280a5b536943d070f06/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java",
    "raw_url": "https://github.com/apache/helix/raw/3a7ba81c73a680a9b31f7280a5b536943d070f06/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java",
    "contents_url": "https://api.github.com/repos/apache/helix/contents/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java?ref=3a7ba81c73a680a9b31f7280a5b536943d070f06",
    "patch": "@@ -1266,13 +1266,20 @@ private void reconnect() {\n \n   private void doAsyncSync(final ZooKeeper zk, final String path, final long startT,\n       final ZkAsyncCallbacks.SyncCallbackHandler cb) {\n-    zk.sync(path, cb,\n-        new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n-          @Override\n-          protected void doRetry() throws Exception {\n-            doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n-          }\n-        });\n+    try {\n+      zk.sync(path, cb,\n+          new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+            @Override\n+            protected void doRetry() throws Exception {\n+              doAsyncSync(zk, path, System.currentTimeMillis(), cb);\n+            }\n+          });\n+    } catch (RuntimeException e) {\n+      // Process callback to release caller from waiting\n+      cb.processResult(ZkAsyncCallbacks.UNKNOWN_RET_CODE, path,\n+          new ZkAsyncCallMonitorContext(_monitor, startT, 0, true));\n+      throw e;\n+    }\n   }\n \n \n@@ -2001,44 +2008,65 @@ protected void doRetry() {\n \n   public void asyncGetData(final String path, final ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n     final long startT = System.currentTimeMillis();\n-    retryUntilConnected(() -> {\n-      ((ZkConnection) getConnection()).getZookeeper().getData(path, null, cb,\n-          new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n-            @Override\n-            protected void doRetry() {\n-              asyncGetData(path, cb);\n-            }\n-          });\n-      return null;\n-    });\n+    try {\n+      retryUntilConnected(() -> {\n+        ((ZkConnection) getConnection()).getZookeeper().getData(path, null, cb,\n+            new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+              @Override\n+              protected void doRetry() {\n+                asyncGetData(path, cb);\n+              }\n+            });\n+        return null;\n+      });\n+    } catch (RuntimeException e) {\n+      // Process callback to release caller from waiting\n+      cb.processResult(ZkAsyncCallbacks.UNKNOWN_RET_CODE, path,\n+          new ZkAsyncCallMonitorContext(_monitor, startT, 0, true), null, null);\n+      throw e;\n+    }\n   }\n \n   public void asyncExists(final String path, final ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n     final long startT = System.currentTimeMillis();\n-    retryUntilConnected(() -> {\n-      ((ZkConnection) getConnection()).getZookeeper().exists(path, null, cb,\n-          new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n-            @Override\n-            protected void doRetry() {\n-              asyncExists(path, cb);\n-            }\n-          });\n-      return null;\n-    });\n+    try {\n+      retryUntilConnected(() -> {\n+        ((ZkConnection) getConnection()).getZookeeper().exists(path, null, cb,\n+            new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, true) {\n+              @Override\n+              protected void doRetry() {\n+                asyncExists(path, cb);\n+              }\n+            });\n+        return null;\n+      });\n+    } catch (RuntimeException e) {\n+      // Process callback to release caller from waiting\n+      cb.processResult(ZkAsyncCallbacks.UNKNOWN_RET_CODE, path,\n+          new ZkAsyncCallMonitorContext(_monitor, startT, 0, true), null);\n+      throw e;\n+    }\n   }\n \n   public void asyncDelete(final String path, final ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n     final long startT = System.currentTimeMillis();\n-    retryUntilConnected(() -> {\n-      ((ZkConnection) getConnection()).getZookeeper().delete(path, -1, cb,\n-          new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n-            @Override\n-            protected void doRetry() {\n-              asyncDelete(path, cb);\n-            }\n-          });\n-      return null;\n-    });\n+    try {\n+      retryUntilConnected(() -> {\n+        ((ZkConnection) getConnection()).getZookeeper().delete(path, -1, cb,\n+            new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT, 0, false) {\n+              @Override\n+              protected void doRetry() {\n+                asyncDelete(path, cb);\n+              }\n+            });\n+        return null;\n+      });\n+    } catch (RuntimeException e) {\n+      // Process callback to release caller from waiting\n+      cb.processResult(ZkAsyncCallbacks.UNKNOWN_RET_CODE, path,\n+          new ZkAsyncCallMonitorContext(_monitor, startT, 0, false));\n+      throw e;\n+    }\n   }\n \n   private void checkDataSizeLimit(String path, byte[] data) {"
  },
  {
    "sha": "ce691e91b783aeda8f5d5fa8de10dcdc4ecfebb6",
    "filename": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallMonitorContext.java",
    "status": "modified",
    "additions": 16,
    "deletions": 2,
    "changes": 18,
    "blob_url": "https://github.com/apache/helix/blob/3a7ba81c73a680a9b31f7280a5b536943d070f06/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallMonitorContext.java",
    "raw_url": "https://github.com/apache/helix/raw/3a7ba81c73a680a9b31f7280a5b536943d070f06/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallMonitorContext.java",
    "contents_url": "https://api.github.com/repos/apache/helix/contents/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallMonitorContext.java?ref=3a7ba81c73a680a9b31f7280a5b536943d070f06",
    "patch": "@@ -56,9 +56,23 @@ void setBytes(int bytes) {\n   void recordAccess(String path) {\n     if (_monitor != null) {\n       if (_isRead) {\n-        _monitor.record(path, _bytes, _startTimeMilliSec, ZkClientMonitor.AccessType.READ);\n+        _monitor.recordAsync(path, _bytes, _startTimeMilliSec, ZkClientMonitor.AccessType.READ);\n       } else {\n-        _monitor.record(path, _bytes, _startTimeMilliSec, ZkClientMonitor.AccessType.WRITE);\n+        _monitor.recordAsync(path, _bytes, _startTimeMilliSec, ZkClientMonitor.AccessType.WRITE);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Record the operation failure into the specified ZkClient monitor.\n+   * @param path The monitored path\n+   */\n+  void recordFailure(String path) {\n+    if (_monitor != null) {\n+      if (_isRead) {\n+        _monitor.recordAsyncFailure(path, ZkClientMonitor.AccessType.READ);\n+      } else {\n+        _monitor.recordAsyncFailure(path, ZkClientMonitor.AccessType.WRITE);\n       }\n     }\n   }"
  },
  {
    "sha": "fc1d14d10ef8b72bd366c7f23bc61cf9f1ee1582",
    "filename": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java",
    "status": "modified",
    "additions": 24,
    "deletions": 1,
    "changes": 25,
    "blob_url": "https://github.com/apache/helix/blob/3a7ba81c73a680a9b31f7280a5b536943d070f06/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java",
    "raw_url": "https://github.com/apache/helix/raw/3a7ba81c73a680a9b31f7280a5b536943d070f06/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java",
    "contents_url": "https://api.github.com/repos/apache/helix/contents/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java?ref=3a7ba81c73a680a9b31f7280a5b536943d070f06",
    "patch": "@@ -58,6 +58,13 @@ public void processResult(int rc, String path, Object ctx, byte[] data, Stat sta\n     public void handle() {\n       // TODO Auto-generated method stub\n     }\n+\n+    @Override\n+    protected void recordFailure(int rc, String path, ZkAsyncCallMonitorContext monitor) {\n+      if(rc != Code.NONODE.intValue()) {\n+        monitor.recordFailure(path);\n+      }\n+    }\n   }\n \n   public static class SetDataCallbackHandler extends DefaultCallback implements StatCallback {\n@@ -96,6 +103,13 @@ public void processResult(int rc, String path, Object ctx, Stat stat) {\n     public void handle() {\n       // TODO Auto-generated method stub\n     }\n+\n+    @Override\n+    protected void recordFailure(int rc, String path, ZkAsyncCallMonitorContext monitor) {\n+      if(rc != Code.NONODE.intValue()) {\n+        monitor.recordFailure(path);\n+      }\n+    }\n   }\n \n   public static class CreateCallbackHandler extends DefaultCallback implements StringCallback {\n@@ -170,7 +184,12 @@ public void callback(int rc, String path, Object ctx) {\n       }\n \n       if (ctx != null && ctx instanceof ZkAsyncCallMonitorContext) {\n-        ((ZkAsyncCallMonitorContext) ctx).recordAccess(path);\n+        ZkAsyncCallMonitorContext monitor = (ZkAsyncCallMonitorContext) ctx;\n+        if(rc == 0) {\n+          monitor.recordAccess(path);\n+        } else {\n+          recordFailure(rc, path, monitor);\n+        }\n       }\n \n       _rc = rc;\n@@ -206,6 +225,10 @@ public void callback(int rc, String path, Object ctx) {\n       }\n     }\n \n+    protected void recordFailure(int rc, String path, ZkAsyncCallMonitorContext monitor) {\n+      monitor.recordFailure(path);\n+    }\n+\n     public boolean isOperationDone() {\n       return _isOperationDone.get();\n     }"
  },
  {
    "sha": "635146872f51dbcd0ee2922cc2302ede9d0557ed",
    "filename": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/metric/ZkClientMonitor.java",
    "status": "modified",
    "additions": 44,
    "deletions": 0,
    "changes": 44,
    "blob_url": "https://github.com/apache/helix/blob/3a7ba81c73a680a9b31f7280a5b536943d070f06/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/metric/ZkClientMonitor.java",
    "raw_url": "https://github.com/apache/helix/raw/3a7ba81c73a680a9b31f7280a5b536943d070f06/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/metric/ZkClientMonitor.java",
    "contents_url": "https://api.github.com/repos/apache/helix/contents/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/metric/ZkClientMonitor.java?ref=3a7ba81c73a680a9b31f7280a5b536943d070f06",
    "patch": "@@ -245,6 +245,50 @@ public void recordFailure(String path, AccessType accessType) {\n     }\n   }\n \n+  /**\n+   * Records metrics for async operations\n+   */\n+  private void recordAsync(String path, int bytes, long latencyMilliSec, boolean isFailure,\n+      boolean isRead) {\n+    if (null == path) {\n+      return;\n+    }\n+    Arrays.stream(ZkClientPathMonitor.PredefinedPath.values())\n+        .filter(predefinedPath -> predefinedPath.match(path))\n+        .forEach(predefinedPath -> {\n+          ZkClientPathMonitor zkClientPathMonitor = _zkClientPathMonitorMap.get(predefinedPath);\n+          if (zkClientPathMonitor != null) {\n+            zkClientPathMonitor.recordAsync(bytes, latencyMilliSec, isFailure, isRead);\n+          }\n+        });\n+  }\n+\n+  public void recordAsync(String path, int dataSize, long startTimeMilliSec, AccessType accessType) {\n+    switch (accessType) {\n+      case READ:\n+        recordAsync(path, dataSize, System.currentTimeMillis() - startTimeMilliSec, false, true);\n+        return;\n+      case WRITE:\n+        recordAsync(path, dataSize, System.currentTimeMillis() - startTimeMilliSec, false, false);\n+        return;\n+      default:\n+        return;\n+    }\n+  }\n+\n+  public void recordAsyncFailure(String path, AccessType accessType) {\n+    switch (accessType) {\n+      case READ:\n+        recordAsync(path, 0, 0, true, true);\n+        return;\n+      case WRITE:\n+        recordAsync(path, 0, 0, true, false);\n+        return;\n+      default:\n+        return;\n+    }\n+  }\n+\n   class ZkThreadMetric extends DynamicMetric<ZkEventThread, ZkEventThread> {\n     public ZkThreadMetric(ZkEventThread eventThread) {\n       super(\"ZkEventThead\", eventThread);"
  },
  {
    "sha": "097b815af656fec796fa3c164cc72c73e6971d02",
    "filename": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/metric/ZkClientPathMonitor.java",
    "status": "modified",
    "additions": 48,
    "deletions": 0,
    "changes": 48,
    "blob_url": "https://github.com/apache/helix/blob/3a7ba81c73a680a9b31f7280a5b536943d070f06/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/metric/ZkClientPathMonitor.java",
    "raw_url": "https://github.com/apache/helix/raw/3a7ba81c73a680a9b31f7280a5b536943d070f06/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/metric/ZkClientPathMonitor.java",
    "contents_url": "https://api.github.com/repos/apache/helix/contents/zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/metric/ZkClientPathMonitor.java?ref=3a7ba81c73a680a9b31f7280a5b536943d070f06",
    "patch": "@@ -69,10 +69,14 @@ public boolean match(String path) {\n     ReadTotalLatencyCounter,\n     WriteFailureCounter,\n     ReadFailureCounter,\n+    WriteAsyncFailureCounter,\n+    ReadAsyncFailureCounter,\n     WriteBytesCounter,\n     ReadBytesCounter,\n     WriteCounter,\n     ReadCounter,\n+    WriteAsyncCounter,\n+    ReadAsyncCounter,\n     ReadLatencyGauge,\n     WriteLatencyGauge,\n     ReadBytesGauge,\n@@ -91,10 +95,14 @@ public boolean match(String path) {\n \n   private SimpleDynamicMetric<Long> _readCounter;\n   private SimpleDynamicMetric<Long> _writeCounter;\n+  private SimpleDynamicMetric<Long> _readAsyncCounter;\n+  private SimpleDynamicMetric<Long> _writeAsyncCounter;\n   private SimpleDynamicMetric<Long> _readBytesCounter;\n   private SimpleDynamicMetric<Long> _writeBytesCounter;\n   private SimpleDynamicMetric<Long> _readFailureCounter;\n   private SimpleDynamicMetric<Long> _writeFailureCounter;\n+  private SimpleDynamicMetric<Long> _readAsyncFailureCounter;\n+  private SimpleDynamicMetric<Long> _writeAsyncFailureCounter;\n   private SimpleDynamicMetric<Long> _readTotalLatencyCounter;\n   private SimpleDynamicMetric<Long> _writeTotalLatencyCounter;\n \n@@ -134,12 +142,20 @@ public ZkClientPathMonitor(PredefinedPath path, String monitorType, String monit\n         new SimpleDynamicMetric(PredefinedMetricDomains.WriteFailureCounter.name(), 0l);\n     _readFailureCounter =\n         new SimpleDynamicMetric(PredefinedMetricDomains.ReadFailureCounter.name(), 0l);\n+    _writeAsyncFailureCounter =\n+        new SimpleDynamicMetric(PredefinedMetricDomains.WriteAsyncFailureCounter.name(), 0l);\n+    _readAsyncFailureCounter =\n+        new SimpleDynamicMetric(PredefinedMetricDomains.ReadAsyncFailureCounter.name(), 0l);\n     _writeBytesCounter =\n         new SimpleDynamicMetric(PredefinedMetricDomains.WriteBytesCounter.name(), 0l);\n     _readBytesCounter =\n         new SimpleDynamicMetric(PredefinedMetricDomains.ReadBytesCounter.name(), 0l);\n     _writeCounter = new SimpleDynamicMetric(PredefinedMetricDomains.WriteCounter.name(), 0l);\n     _readCounter = new SimpleDynamicMetric(PredefinedMetricDomains.ReadCounter.name(), 0l);\n+    _writeAsyncCounter =\n+        new SimpleDynamicMetric(PredefinedMetricDomains.WriteAsyncCounter.name(), 0l);\n+    _readAsyncCounter =\n+        new SimpleDynamicMetric(PredefinedMetricDomains.ReadAsyncCounter.name(), 0l);\n \n     _readLatencyGauge = new HistogramDynamicMetric(PredefinedMetricDomains.ReadLatencyGauge.name(),\n         new Histogram(\n@@ -169,10 +185,14 @@ public ZkClientPathMonitor register() throws JMException {\n     List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n     attributeList.add(_readCounter);\n     attributeList.add(_writeCounter);\n+    attributeList.add(_readAsyncCounter);\n+    attributeList.add(_writeAsyncCounter);\n     attributeList.add(_readBytesCounter);\n     attributeList.add(_writeBytesCounter);\n     attributeList.add(_readFailureCounter);\n     attributeList.add(_writeFailureCounter);\n+    attributeList.add(_readAsyncFailureCounter);\n+    attributeList.add(_writeAsyncFailureCounter);\n     attributeList.add(_readTotalLatencyCounter);\n     attributeList.add(_writeTotalLatencyCounter);\n     attributeList.add(_readLatencyGauge);\n@@ -204,6 +224,18 @@ protected synchronized void record(int bytes, long latencyMilliSec, boolean isFa\n     }\n   }\n \n+  /**\n+   * Records metrics for async operations\n+   */\n+  protected synchronized void recordAsync(int bytes, long latencyMilliSec, boolean isFailure,\n+      boolean isRead) {\n+    if (isFailure) {\n+      increaseAsyncFailureCounter(isRead);\n+    } else {\n+      increaseAsyncCounter(isRead);\n+    }\n+  }\n+\n   public void recordDataPropagationLatency(long latency) {\n     _dataPropagationLatencyGauge.updateValue(latency);\n     _dataPropagationLatencyGuage.updateValue(latency);\n@@ -217,6 +249,14 @@ private void increaseFailureCounter(boolean isRead) {\n     }\n   }\n \n+  private void increaseAsyncFailureCounter(boolean isRead) {\n+    if (isRead) {\n+      _readAsyncFailureCounter.updateValue(_readAsyncFailureCounter.getValue() + 1);\n+    } else {\n+      _writeAsyncFailureCounter.updateValue(_writeAsyncFailureCounter.getValue() + 1);\n+    }\n+  }\n+\n   private void increaseCounter(boolean isRead) {\n     if (isRead) {\n       _readCounter.updateValue(_readCounter.getValue() + 1);\n@@ -225,6 +265,14 @@ private void increaseCounter(boolean isRead) {\n     }\n   }\n \n+  private void increaseAsyncCounter(boolean isRead) {\n+    if (isRead) {\n+      _readAsyncCounter.updateValue(_readAsyncCounter.getValue() + 1);\n+    } else {\n+      _writeAsyncCounter.updateValue(_writeAsyncCounter.getValue() + 1);\n+    }\n+  }\n+\n   private void increaseBytesCounter(boolean isRead, int bytes) {\n     if (isRead) {\n       _readBytesCounter.updateValue(_readBytesCounter.getValue() + bytes);"
  },
  {
    "sha": "22be865940c8cfbb97b5250f256d03e424c42559",
    "filename": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java",
    "status": "modified",
    "additions": 8,
    "deletions": 8,
    "changes": 16,
    "blob_url": "https://github.com/apache/helix/blob/3a7ba81c73a680a9b31f7280a5b536943d070f06/zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java",
    "raw_url": "https://github.com/apache/helix/raw/3a7ba81c73a680a9b31f7280a5b536943d070f06/zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java",
    "contents_url": "https://api.github.com/repos/apache/helix/contents/zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestRawZkClient.java?ref=3a7ba81c73a680a9b31f7280a5b536943d070f06",
    "patch": "@@ -289,7 +289,7 @@ public void testZkClientMonitor()\n     Assert.assertEquals((long) beanServer.getAttribute(name, \"OutstandingRequestGauge\"), 0);\n \n     boolean verifyResult = TestHelper.verify(()->{\n-      return (long) beanServer.getAttribute(rootname, \"ReadCounter\") == 1;\n+      return (long) beanServer.getAttribute(rootname, \"ReadAsyncCounter\") == 1;\n     }, TestHelper.WAIT_DURATION);\n     Assert.assertTrue(verifyResult, \" did not see first sync() read\");\n \n@@ -301,7 +301,7 @@ public void testZkClientMonitor()\n     Assert.assertTrue(firstReadLatencyGauge >= 0);\n     zkClient.exists(TEST_ROOT);\n \n-    Assert.assertTrue((long) beanServer.getAttribute(rootname, \"ReadCounter\") == 2);\n+    Assert.assertTrue((long) beanServer.getAttribute(rootname, \"ReadCounter\") == 1);\n \n     Assert.assertTrue((long) beanServer.getAttribute(rootname, \"ReadTotalLatencyCounter\") >= firstLatencyCounter);\n     Assert.assertTrue((long) beanServer.getAttribute(rootname, \"ReadLatencyGauge.Max\") >= firstReadLatencyGauge);\n@@ -333,7 +333,7 @@ public void testZkClientMonitor()\n     Assert.assertTrue((long) beanServer.getAttribute(idealStatename, \"WriteLatencyGauge.Max\") >= 0);\n \n     // Test read\n-    Assert.assertEquals((long) beanServer.getAttribute(rootname, \"ReadCounter\"), 2);\n+    Assert.assertEquals((long) beanServer.getAttribute(rootname, \"ReadCounter\"), 1);\n     Assert.assertEquals((long) beanServer.getAttribute(rootname, \"ReadBytesCounter\"), 0);\n     Assert.assertEquals((long) beanServer.getAttribute(idealStatename, \"ReadCounter\"), 0);\n     Assert.assertEquals((long) beanServer.getAttribute(idealStatename, \"ReadBytesCounter\"), 0);\n@@ -344,7 +344,7 @@ public void testZkClientMonitor()\n     Assert.assertEquals(origIdealStatesReadTotalLatencyCounter, 0);\n     Assert.assertEquals((long) beanServer.getAttribute(idealStatename, \"ReadLatencyGauge.Max\"), 0);\n     zkClient.readData(TEST_PATH, new Stat());\n-    Assert.assertEquals((long) beanServer.getAttribute(rootname, \"ReadCounter\"), 3);\n+    Assert.assertEquals((long) beanServer.getAttribute(rootname, \"ReadCounter\"), 2);\n     Assert\n         .assertEquals((long) beanServer.getAttribute(rootname, \"ReadBytesCounter\"), TEST_DATA_SIZE);\n     Assert.assertEquals((long) beanServer.getAttribute(idealStatename, \"ReadCounter\"), 1);\n@@ -356,27 +356,27 @@ public void testZkClientMonitor()\n         >= origIdealStatesReadTotalLatencyCounter);\n     Assert.assertTrue((long) beanServer.getAttribute(idealStatename, \"ReadLatencyGauge.Max\") >= 0);\n     zkClient.getChildren(TEST_PATH);\n-    Assert.assertEquals((long) beanServer.getAttribute(rootname, \"ReadCounter\"), 4);\n+    Assert.assertEquals((long) beanServer.getAttribute(rootname, \"ReadCounter\"), 3);\n     Assert\n         .assertEquals((long) beanServer.getAttribute(rootname, \"ReadBytesCounter\"), TEST_DATA_SIZE);\n     Assert.assertEquals((long) beanServer.getAttribute(idealStatename, \"ReadCounter\"), 2);\n     Assert.assertEquals((long) beanServer.getAttribute(idealStatename, \"ReadBytesCounter\"),\n         TEST_DATA_SIZE);\n     zkClient.getStat(TEST_PATH);\n-    Assert.assertEquals((long) beanServer.getAttribute(rootname, \"ReadCounter\"), 5);\n+    Assert.assertEquals((long) beanServer.getAttribute(rootname, \"ReadCounter\"), 4);\n     Assert\n         .assertEquals((long) beanServer.getAttribute(rootname, \"ReadBytesCounter\"), TEST_DATA_SIZE);\n     Assert.assertEquals((long) beanServer.getAttribute(idealStatename, \"ReadCounter\"), 3);\n     Assert.assertEquals((long) beanServer.getAttribute(idealStatename, \"ReadBytesCounter\"),\n         TEST_DATA_SIZE);\n     zkClient.readDataAndStat(TEST_PATH, new Stat(), true);\n-    Assert.assertEquals((long) beanServer.getAttribute(rootname, \"ReadCounter\"), 6);\n+    Assert.assertEquals((long) beanServer.getAttribute(rootname, \"ReadCounter\"), 5);\n \n     ZkAsyncCallbacks.ExistsCallbackHandler callbackHandler =\n         new ZkAsyncCallbacks.ExistsCallbackHandler();\n     zkClient.asyncExists(TEST_PATH, callbackHandler);\n     callbackHandler.waitForSuccess();\n-    Assert.assertEquals((long) beanServer.getAttribute(rootname, \"ReadCounter\"), 7);\n+    Assert.assertEquals((long) beanServer.getAttribute(rootname, \"ReadAsyncCounter\"), 2);\n \n     // Test write\n     zkClient.writeData(TEST_PATH, TEST_DATA);"
  },
  {
    "sha": "663a55b9aa0249d1db9a1e4fa7f4d72c1dd5aad6",
    "filename": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestZkClientAsyncRetry.java",
    "status": "modified",
    "additions": 198,
    "deletions": 11,
    "changes": 209,
    "blob_url": "https://github.com/apache/helix/blob/3a7ba81c73a680a9b31f7280a5b536943d070f06/zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestZkClientAsyncRetry.java",
    "raw_url": "https://github.com/apache/helix/raw/3a7ba81c73a680a9b31f7280a5b536943d070f06/zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestZkClientAsyncRetry.java",
    "contents_url": "https://api.github.com/repos/apache/helix/contents/zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestZkClientAsyncRetry.java?ref=3a7ba81c73a680a9b31f7280a5b536943d070f06",
    "patch": "@@ -19,13 +19,22 @@\n  * under the License.\n  */\n \n+import java.lang.management.ManagementFactory;\n+import javax.management.JMException;\n+import javax.management.MBeanServer;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n import org.apache.helix.zookeeper.datamodel.ZNRecord;\n import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallMonitorContext;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncRetryCallContext;\n import org.apache.helix.zookeeper.zkclient.exception.ZkException;\n import org.apache.helix.zookeeper.zkclient.exception.ZkInterruptedException;\n+import org.apache.helix.zookeeper.zkclient.metric.ZkClientMonitor;\n+import org.apache.helix.zookeeper.zkclient.metric.ZkClientPathMonitor;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n import org.testng.Assert;\n@@ -43,23 +52,55 @@\n public class TestZkClientAsyncRetry extends ZkTestBase {\n   private final String TEST_ROOT = String.format(\"/%s\", getClass().getSimpleName());\n   private final String NODE_PATH = TEST_ROOT + \"/async\";\n+  final String TEST_TAG = \"test_tag\";\n+  final String TEST_KEY = \"test_key\";\n+  final String TEST_INSTANCE = \"test_instance\";\n \n   private org.apache.helix.zookeeper.zkclient.ZkClient _zkClient;\n   private String _zkServerAddress;\n \n+  private final MBeanServer _beanServer = ManagementFactory.getPlatformMBeanServer();\n+  private ZkClientMonitor _monitor;\n+  ObjectName _rootName;\n+  int _readFailures;\n+  int _writeFailures;\n+\n   @BeforeClass\n-  public void beforeClass() {\n+  public void beforeClass() throws JMException {\n     _zkClient = _zkServerMap.values().iterator().next().getZkClient();\n     _zkServerAddress = _zkClient.getServers();\n     _zkClient.createPersistent(TEST_ROOT);\n+\n+    _monitor = new ZkClientMonitor(TEST_TAG, TEST_KEY, TEST_INSTANCE, false, null);\n+    _monitor.register();\n+\n+    _rootName = buildPathMonitorObjectName(TEST_TAG, TEST_KEY, TEST_INSTANCE,\n+        ZkClientPathMonitor.PredefinedPath.Root.name());\n+    _readFailures = 0;\n+    _writeFailures = 0;\n   }\n \n   @AfterClass\n   public void afterClass() {\n+    _monitor.unregister();\n     _zkClient.deleteRecursively(TEST_ROOT);\n     _zkClient.close();\n   }\n \n+  private boolean needRetry(int rc) {\n+    switch (KeeperException.Code.get(rc)) {\n+      /** Connection to the server has been lost */\n+      case CONNECTIONLOSS:\n+        /** The session has been expired by the server */\n+      case SESSIONEXPIRED:\n+        /** Session moved to another server, so operation is ignored */\n+      case SESSIONMOVED:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n   private boolean waitAsyncOperation(ZkAsyncCallbacks.DefaultCallback callback, long timeout) {\n     final boolean[] ret = { false };\n     Thread waitThread = new Thread(() -> ret[0] = callback.waitForSuccess());\n@@ -73,8 +114,19 @@ private boolean waitAsyncOperation(ZkAsyncCallbacks.DefaultCallback callback, lo\n     }\n   }\n \n+  private ObjectName buildObjectName(String tag, String key, String instance)\n+      throws MalformedObjectNameException {\n+    return ZkClientMonitor.getObjectName(tag, key, instance);\n+  }\n+\n+  private ObjectName buildPathMonitorObjectName(String tag, String key, String instance,\n+      String path) throws MalformedObjectNameException {\n+    return new ObjectName(String.format(\"%s,%s=%s\", buildObjectName(tag, key, instance).toString(),\n+        ZkClientPathMonitor.MONITOR_PATH, path));\n+  }\n+\n   @Test\n-  public void testAsyncRetryCategories() {\n+  public void testAsyncRetryCategories() throws JMException {\n     MockAsyncZkClient testZkClient = new MockAsyncZkClient(_zkServerAddress);\n     try {\n       ZNRecord tmpRecord = new ZNRecord(\"tmpRecord\");\n@@ -108,7 +160,11 @@ public void testAsyncRetryCategories() {\n           Assert.assertTrue(waitAsyncOperation(createCallback, 1000));\n           Assert.assertEquals(createCallback.getRc(), code.intValue());\n           Assert.assertEquals(testZkClient.getAndResetRetryCount(), 0);\n+          ++_writeFailures;\n         }\n+        Assert.assertEquals((long) _beanServer.getAttribute(_rootName,\n+            ZkClientPathMonitor.PredefinedMetricDomains.WriteAsyncFailureCounter.toString()),\n+            _writeFailures);\n         testZkClient.delete(NODE_PATH);\n         Assert.assertFalse(testZkClient.exists(NODE_PATH));\n       }\n@@ -120,7 +176,7 @@ public void testAsyncRetryCategories() {\n   }\n \n   @Test(dependsOnMethods = \"testAsyncRetryCategories\")\n-  public void testAsyncWriteRetry() {\n+  public void testAsyncWriteRetry() throws JMException {\n     MockAsyncZkClient testZkClient = new MockAsyncZkClient(_zkServerAddress);\n     try {\n       ZNRecord tmpRecord = new ZNRecord(\"tmpRecord\");\n@@ -146,6 +202,10 @@ public void testAsyncWriteRetry() {\n       Assert.assertEquals(((ZNRecord) testZkClient.readData(NODE_PATH)).getSimpleField(\"test\"),\n           \"data\");\n       Assert.assertTrue(testZkClient.getAndResetRetryCount() >= 1);\n+      // Check failure metric, which should be unchanged because the operation succeeded\n+      Assert.assertEquals((long) _beanServer.getAttribute(_rootName,\n+          ZkClientPathMonitor.PredefinedMetricDomains.WriteAsyncFailureCounter.toString()),\n+          _writeFailures);\n \n       // 2. Test async delete\n       ZkAsyncCallbacks.DeleteCallbackHandler deleteCallback =\n@@ -164,6 +224,10 @@ public void testAsyncWriteRetry() {\n       Assert.assertEquals(deleteCallback.getRc(), KeeperException.Code.OK.intValue());\n       Assert.assertFalse(testZkClient.exists(NODE_PATH));\n       Assert.assertTrue(testZkClient.getAndResetRetryCount() >= 1);\n+      // Check failure metric, which should be unchanged because the operation succeeded\n+      Assert.assertEquals((long) _beanServer.getAttribute(_rootName,\n+          ZkClientPathMonitor.PredefinedMetricDomains.WriteAsyncFailureCounter.toString()),\n+          _writeFailures);\n     } finally {\n       testZkClient.setAsyncCallRC(KeeperException.Code.OK.intValue());\n       testZkClient.close();\n@@ -176,7 +240,7 @@ public void testAsyncWriteRetry() {\n    * the context should be cancelled correctly.\n    */\n   @Test(dependsOnMethods = \"testAsyncWriteRetry\")\n-  public void testAsyncWriteRetryThrowException() {\n+  public void testAsyncWriteRetryThrowException() throws JMException {\n     MockAsyncZkClient testZkClient = new MockAsyncZkClient(_zkServerAddress);\n     try {\n       ZNRecord tmpRecord = new ZNRecord(\"tmpRecord\");\n@@ -201,6 +265,10 @@ public void testAsyncWriteRetryThrowException() {\n           \"Async callback should have been canceled\");\n       Assert.assertEquals(createCallback.getRc(), CONNECTIONLOSS.intValue());\n       Assert.assertTrue(testZkClient.getAndResetRetryCount() >= 1);\n+      // Check failure metric, which should be unchanged because the operation succeeded\n+      Assert.assertEquals((long) _beanServer.getAttribute(_rootName,\n+          ZkClientPathMonitor.PredefinedMetricDomains.WriteAsyncFailureCounter.toString()),\n+          _writeFailures);\n \n       // Restore the state\n       testZkClient.setZkExceptionInRetry(false);\n@@ -223,6 +291,10 @@ public void testAsyncWriteRetryThrowException() {\n           \"Async callback should have been canceled\");\n       Assert.assertEquals(setCallback.getRc(), CONNECTIONLOSS.intValue());\n       Assert.assertTrue(testZkClient.getAndResetRetryCount() >= 1);\n+      // Check failure metric, which should be unchanged because the operation succeeded\n+      Assert.assertEquals((long) _beanServer.getAttribute(_rootName,\n+          ZkClientPathMonitor.PredefinedMetricDomains.WriteAsyncFailureCounter.toString()),\n+          _writeFailures);\n     } finally {\n       testZkClient.setAsyncCallRC(KeeperException.Code.OK.intValue());\n       testZkClient.close();\n@@ -231,7 +303,7 @@ public void testAsyncWriteRetryThrowException() {\n   }\n \n   @Test(dependsOnMethods = \"testAsyncWriteRetryThrowException\")\n-  public void testAsyncReadRetry() {\n+  public void testAsyncReadRetry() throws JMException {\n     MockAsyncZkClient testZkClient = new MockAsyncZkClient(_zkServerAddress);\n     try {\n       ZNRecord tmpRecord = new ZNRecord(\"tmpRecord\");\n@@ -255,6 +327,10 @@ public void testAsyncReadRetry() {\n       Assert.assertEquals(existsCallback.getRc(), KeeperException.Code.OK.intValue());\n       Assert.assertTrue(existsCallback._stat != null);\n       Assert.assertTrue(testZkClient.getAndResetRetryCount() >= 1);\n+      // Check failure metric, which should be unchanged because the operation succeeded\n+      Assert.assertEquals((long) _beanServer.getAttribute(_rootName,\n+          ZkClientPathMonitor.PredefinedMetricDomains.ReadAsyncFailureCounter.toString()),\n+          _readFailures);\n \n       // 2. Test async get\n       ZkAsyncCallbacks.GetDataCallbackHandler getCallback =\n@@ -274,6 +350,10 @@ public void testAsyncReadRetry() {\n       ZNRecord record = testZkClient.deserialize(getCallback._data, NODE_PATH);\n       Assert.assertEquals(record.getSimpleField(\"foo\"), \"bar\");\n       Assert.assertTrue(testZkClient.getAndResetRetryCount() >= 1);\n+      // Check failure metric, which should be unchanged because the operation succeeded\n+      Assert.assertEquals((long) _beanServer.getAttribute(_rootName,\n+          ZkClientPathMonitor.PredefinedMetricDomains.ReadAsyncFailureCounter.toString()),\n+          _readFailures);\n     } finally {\n       testZkClient.setAsyncCallRC(KeeperException.Code.OK.intValue());\n       testZkClient.close();\n@@ -282,7 +362,7 @@ public void testAsyncReadRetry() {\n   }\n \n   @Test(dependsOnMethods = \"testAsyncReadRetry\")\n-  public void testAsyncRequestCleanup() {\n+  public void testAsyncRequestCleanup() throws JMException {\n     int cbCount = 10;\n     MockAsyncZkClient testZkClient = new MockAsyncZkClient(_zkServerAddress);\n     try {\n@@ -313,6 +393,11 @@ public void testAsyncRequestCleanup() {\n       for (ZkAsyncCallbacks.ExistsCallbackHandler cb : existsCallbacks) {\n         Assert.assertTrue(waitAsyncOperation(cb, 1000));\n         Assert.assertEquals(cb.getRc(), CONNECTIONLOSS.intValue());\n+        // The failure metric doesn't increase here, because an exception is thrown before the logic\n+        // responsible for increasing the metric is reached.\n+        Assert.assertEquals((long) _beanServer.getAttribute(_rootName,\n+            ZkClientPathMonitor.PredefinedMetricDomains.ReadAsyncFailureCounter.toString()),\n+            _readFailures);\n       }\n       Assert.assertTrue(testZkClient.getAndResetRetryCount() >= 1);\n     } finally {\n@@ -322,6 +407,93 @@ public void testAsyncRequestCleanup() {\n     }\n   }\n \n+  @Test(dependsOnMethods = \"testAsyncRequestCleanup\")\n+  public void testAsyncFailureMetrics() throws JMException {\n+    // The remaining failure paths that weren't covered in other test methods are tested here\n+    MockAsyncZkClient testZkClient = new MockAsyncZkClient(_zkServerAddress);\n+    try {\n+      ZNRecord tmpRecord = new ZNRecord(\"tmpRecord\");\n+      tmpRecord.setSimpleField(\"foo\", \"bar\");\n+      testZkClient.createPersistent(NODE_PATH, tmpRecord);\n+\n+      // Test asyncGet failure\n+      ZkAsyncCallbacks.GetDataCallbackHandler getCallback =\n+          new ZkAsyncCallbacks.GetDataCallbackHandler();\n+      Assert.assertEquals(getCallback.getRc(), UNKNOWN_RET_CODE);\n+      // asyncGet should fail because the return code is APIERROR\n+      testZkClient.setAsyncCallRC(KeeperException.Code.APIERROR.intValue());\n+      testZkClient.asyncGetData(NODE_PATH, getCallback);\n+      getCallback.waitForSuccess();\n+      Assert.assertEquals(getCallback.getRc(), KeeperException.Code.APIERROR.intValue());\n+      ++_readFailures;\n+      Assert.assertEquals((long) _beanServer.getAttribute(_rootName,\n+          ZkClientPathMonitor.PredefinedMetricDomains.ReadAsyncFailureCounter.toString()),\n+          _readFailures);\n+      // asyncGet should succeed because the return code is NONODE\n+      testZkClient.setAsyncCallRC(KeeperException.Code.NONODE.intValue());\n+      testZkClient.asyncGetData(NODE_PATH, getCallback);\n+      getCallback.waitForSuccess();\n+      Assert.assertEquals(getCallback.getRc(), KeeperException.Code.NONODE.intValue());\n+      Assert.assertEquals((long) _beanServer.getAttribute(_rootName,\n+          ZkClientPathMonitor.PredefinedMetricDomains.ReadAsyncFailureCounter.toString()),\n+          _readFailures);\n+\n+      // Test asyncExists failure\n+      ZkAsyncCallbacks.ExistsCallbackHandler existsCallback =\n+          new ZkAsyncCallbacks.ExistsCallbackHandler();\n+      Assert.assertEquals(existsCallback.getRc(), UNKNOWN_RET_CODE);\n+      // asyncExists should fail because the return code is APIERROR\n+      testZkClient.setAsyncCallRC(KeeperException.Code.APIERROR.intValue());\n+      testZkClient.asyncExists(NODE_PATH, existsCallback);\n+      existsCallback.waitForSuccess();\n+      Assert.assertEquals(existsCallback.getRc(), KeeperException.Code.APIERROR.intValue());\n+      ++_readFailures;\n+      Assert.assertEquals((long) _beanServer.getAttribute(_rootName,\n+          ZkClientPathMonitor.PredefinedMetricDomains.ReadAsyncFailureCounter.toString()),\n+          _readFailures);\n+      // asyncExists should fail because the return code is NONODE\n+      testZkClient.setAsyncCallRC(KeeperException.Code.NONODE.intValue());\n+      testZkClient.asyncExists(NODE_PATH, existsCallback);\n+      existsCallback.waitForSuccess();\n+      Assert.assertEquals(existsCallback.getRc(), KeeperException.Code.NONODE.intValue());\n+      Assert.assertEquals((long) _beanServer.getAttribute(_rootName,\n+          ZkClientPathMonitor.PredefinedMetricDomains.ReadAsyncFailureCounter.toString()),\n+          _readFailures);\n+\n+      // Test asyncSet failure\n+      ZkAsyncCallbacks.SetDataCallbackHandler setCallback =\n+          new ZkAsyncCallbacks.SetDataCallbackHandler();\n+      Assert.assertEquals(setCallback.getRc(), UNKNOWN_RET_CODE);\n+      // asyncSet should fail because the return code is APIERROR\n+      testZkClient.setAsyncCallRC(KeeperException.Code.APIERROR.intValue());\n+      testZkClient.asyncSetData(NODE_PATH, tmpRecord, -1, setCallback);\n+      setCallback.waitForSuccess();\n+      Assert.assertEquals(setCallback.getRc(), KeeperException.Code.APIERROR.intValue());\n+      ++_writeFailures;\n+      Assert.assertEquals((long) _beanServer.getAttribute(_rootName,\n+          ZkClientPathMonitor.PredefinedMetricDomains.WriteAsyncFailureCounter.toString()),\n+          _writeFailures);\n+\n+      // Test asyncDelete failure\n+      ZkAsyncCallbacks.DeleteCallbackHandler deleteCallback =\n+          new ZkAsyncCallbacks.DeleteCallbackHandler();\n+      Assert.assertEquals(deleteCallback.getRc(), UNKNOWN_RET_CODE);\n+      // asyncDelete should fail because the return code is APIERROR\n+      testZkClient.setAsyncCallRC(KeeperException.Code.APIERROR.intValue());\n+      testZkClient.asyncDelete(NODE_PATH, deleteCallback);\n+      deleteCallback.waitForSuccess();\n+      Assert.assertEquals(deleteCallback.getRc(), KeeperException.Code.APIERROR.intValue());\n+      ++_writeFailures;\n+      Assert.assertEquals((long) _beanServer.getAttribute(_rootName,\n+          ZkClientPathMonitor.PredefinedMetricDomains.WriteAsyncFailureCounter.toString()),\n+          _writeFailures);\n+    } finally {\n+      testZkClient.setAsyncCallRC(KeeperException.Code.OK.intValue());\n+      testZkClient.close();\n+      _zkClient.delete(NODE_PATH);\n+    }\n+  }\n+\n   /**\n    * Mock client to whitebox test async functionality.\n    */\n@@ -362,7 +534,7 @@ public void asyncCreate(String path, Object datat, CreateMode mode,\n       if (_asyncCallRetCode == KeeperException.Code.OK.intValue()) {\n         super.asyncCreate(path, datat, mode, cb);\n         return;\n-      } else {\n+      } else if (needRetry(_asyncCallRetCode)) {\n         cb.processResult(_asyncCallRetCode, path,\n             new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, null, 0, 0, false) {\n               @Override\n@@ -371,6 +543,9 @@ protected void doRetry() {\n                 asyncCreate(path, datat, mode, cb);\n               }\n             }, null);\n+      } else {\n+        cb.processResult(_asyncCallRetCode, path,\n+            new ZkAsyncCallMonitorContext(_monitor, 0, 0, false), null);\n       }\n     }\n \n@@ -380,7 +555,7 @@ public void asyncSetData(String path, Object datat, int version,\n       if (_asyncCallRetCode == KeeperException.Code.OK.intValue()) {\n         super.asyncSetData(path, datat, version, cb);\n         return;\n-      } else {\n+      } else if (needRetry(_asyncCallRetCode)) {\n         cb.processResult(_asyncCallRetCode, path,\n             new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, null, 0, 0, false) {\n               @Override\n@@ -389,6 +564,9 @@ protected void doRetry() {\n                 asyncSetData(path, datat, version, cb);\n               }\n             }, null);\n+      } else {\n+        cb.processResult(_asyncCallRetCode, path,\n+            new ZkAsyncCallMonitorContext(_monitor, 0, 0, false), null);\n       }\n     }\n \n@@ -397,7 +575,7 @@ public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb\n       if (_asyncCallRetCode == KeeperException.Code.OK.intValue()) {\n         super.asyncGetData(path, cb);\n         return;\n-      } else {\n+      } else if (needRetry(_asyncCallRetCode)) {\n         cb.processResult(_asyncCallRetCode, path,\n             new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, null, 0, 0, true) {\n               @Override\n@@ -406,6 +584,9 @@ protected void doRetry() {\n                 asyncGetData(path, cb);\n               }\n             }, null, null);\n+      } else {\n+        cb.processResult(_asyncCallRetCode, path,\n+            new ZkAsyncCallMonitorContext(_monitor, 0, 0, true), null, null);\n       }\n     }\n \n@@ -414,7 +595,7 @@ public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb)\n       if (_asyncCallRetCode == KeeperException.Code.OK.intValue()) {\n         super.asyncExists(path, cb);\n         return;\n-      } else {\n+      } else if (needRetry(_asyncCallRetCode)) {\n         cb.processResult(_asyncCallRetCode, path,\n             new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, null, 0, 0, true) {\n               @Override\n@@ -423,6 +604,9 @@ protected void doRetry() {\n                 asyncExists(path, cb);\n               }\n             }, null);\n+      } else {\n+        cb.processResult(_asyncCallRetCode, path,\n+            new ZkAsyncCallMonitorContext(_monitor, 0, 0, true), null);\n       }\n     }\n \n@@ -431,7 +615,7 @@ public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb)\n       if (_asyncCallRetCode == KeeperException.Code.OK.intValue()) {\n         super.asyncDelete(path, cb);\n         return;\n-      } else {\n+      } else if (needRetry(_asyncCallRetCode)) {\n         cb.processResult(_asyncCallRetCode, path,\n             new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, null, 0, 0, false) {\n               @Override\n@@ -440,6 +624,9 @@ protected void doRetry() {\n                 asyncDelete(path, cb);\n               }\n             });\n+      } else {\n+        cb.processResult(_asyncCallRetCode, path,\n+            new ZkAsyncCallMonitorContext(_monitor, 0, 0, false));\n       }\n     }\n "
  }
]
