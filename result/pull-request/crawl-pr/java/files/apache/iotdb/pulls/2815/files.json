[
  {
    "sha": "9c61ea017bf2bae3bbdd34e79b71875e2dc993db",
    "filename": "antlr/src/main/antlr4/org/apache/iotdb/db/qp/sql/SqlBase.g4",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/antlr/src/main/antlr4/org/apache/iotdb/db/qp/sql/SqlBase.g4",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/antlr/src/main/antlr4/org/apache/iotdb/db/qp/sql/SqlBase.g4",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/antlr/src/main/antlr4/org/apache/iotdb/db/qp/sql/SqlBase.g4?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -102,7 +102,7 @@ statement\n     | DROP TRIGGER triggerName=ID #dropTrigger\n     | START TRIGGER triggerName=ID #startTrigger\n     | STOP TRIGGER triggerName=ID #stopTrigger\n-    | SHOW TRIGGERS (ON fullPath)? #showTriggers\n+    | SHOW TRIGGERS #showTriggers\n     | SELECT topClause? selectElements\n     fromClause\n     whereClause?"
  },
  {
    "sha": "d031600543071ae76eb71da1c83a5c1728850bd5",
    "filename": "cluster/src/test/java/org/apache/iotdb/cluster/server/member/DataGroupMemberTest.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/cluster/src/test/java/org/apache/iotdb/cluster/server/member/DataGroupMemberTest.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/cluster/src/test/java/org/apache/iotdb/cluster/server/member/DataGroupMemberTest.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/cluster/src/test/java/org/apache/iotdb/cluster/server/member/DataGroupMemberTest.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -62,6 +62,7 @@\n import org.apache.iotdb.db.engine.storagegroup.StorageGroupProcessor;\n import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.TriggerExecutionException;\n import org.apache.iotdb.db.exception.WriteProcessException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.StorageGroupNotSetException;\n@@ -439,7 +440,7 @@ public void onError(Exception e) {\n   @Test\n   public void testApplySnapshot()\n       throws IOException, WriteProcessException, SnapshotInstallationException,\n-          QueryProcessException, IllegalPathException {\n+          QueryProcessException, IllegalPathException, TriggerExecutionException {\n     System.out.println(\"Start testApplySnapshot()\");\n     FileSnapshot snapshot = new FileSnapshot();\n     List<TimeseriesSchema> schemaList = new ArrayList<>();"
  },
  {
    "sha": "d084d0c4a3882d2bce313a686d7c545d8e7becef",
    "filename": "docs/UserGuide/Operation Manual/Triggers.md",
    "status": "modified",
    "additions": 232,
    "deletions": 8,
    "changes": 240,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/docs/UserGuide/Operation%20Manual/Triggers.md",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/docs/UserGuide/Operation%20Manual/Triggers.md",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/docs/UserGuide/Operation%20Manual/Triggers.md?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -23,19 +23,166 @@\n \n # Triggers\n \n+The trigger provides a mechanism for listening to changes in time series data. With user-defined logic, tasks such as alerting, data cleaning, and data forwarding can be conducted.\n+\n+The trigger is implemented based on the reflection mechanism. Users can monitor data changes by implementing the Java interfaces. IoTDB allows users to dynamically register and drop triggers without restarting the server.\n+\n+The document will help you learn to define and manage triggers.\n+\n+\n+\n+## Triggers Implementation\n+\n+### Dependency\n+\n+You need to implement the trigger by writing a Java class, where the dependency shown below is required. If you use [Maven](http://search.maven.org/), you can search for them directly from the [Maven repository](http://search.maven.org/).\n+\n+```xml\n+<dependency>\n+  <groupId>org.apache.iotdb</groupId>\n+  <artifactId>iotdb-server</artifactId>\n+  <version>0.12.0-SNAPSHOT</version>\n+  <scope>provided</scope>\n+</dependency>\n+```\n+\n+Note that the dependency version should be correspondent to the target server version.\n+\n+\n+\n+### Programming Interfaces\n+\n+To implement a trigger, you need to implement the `org.apache.iotdb.db.engine.trigger.api.Trigger` class.\n+\n+This class provides two types of programming interfaces: **life cycle hooks** and **data change listening hooks**. All the interfaces in this class are not required to be implemented. When the interfaces are not implemented, the trigger will not respond to the data changes. You can implement only some of these interfaces according to your needs.\n+\n+Descriptions of the interfaces are as followed.\n+\n+\n+\n+#### Life Cycle Hooks\n+\n+| Interface Definition                                         | Description                                                  |\n+| :----------------------------------------------------------- | ------------------------------------------------------------ |\n+| `void onCreate(TriggerAttributes attributes) throws Exception` | When you use the `CREATE TRIGGER` statement to register the trigger, the hook will be called. In the life cycle of each instance, the hook will and only will be called once. This hook mainly has the following functions: 1. To parse custom attributes in SQL statements (using `TriggerAttributes`). 2. To create or apply for resources, such as establishing external links, opening files, etc. |\n+| `void onDrop() throws Exception`                             | When you use the `DROP TRIGGER` statement to drop the trigger, the hook will be called. In the life cycle of each instance, the hook will and only will be called once. The main function of this hook is to perform operations such as releasing resources. |\n+| `void onStart() throws Exception`                            | This hook will be called when you use the `START TRIGGER` statement to manually start the trigger (whose state should be `STOPPED`). |\n+| `void onStop() throws Exception`                             | This hook will be called when you use the `STOP TRIGGER` statement to manually stop the trigger (whose state should be `STARTED`). |\n+\n+\n+\n+#### Data Change Listening Hooks\n+\n+Currently, triggers can only listen for data insertion operations.\n+\n+The timing of calling the data change listener hooks is explicitly specified in the `CREATE TRIGGER` statement rather than at the programming interface level.\n+\n+\n+\n+##### Single Point Insertion Listening Hooks\n+\n+``` java\n+Integer fire(long timestamp, Integer value) throws Exception;\n+Long fire(long timestamp, Long value) throws Exception;\n+Float fire(long timestamp, Float value) throws Exception;\n+Double fire(long timestamp, Double value) throws Exception;\n+Boolean fire(long timestamp, Boolean value) throws Exception;\n+Binary fire(long timestamp, Binary value) throws Exception;\n+```\n+\n+For each data insertion in the registered time series, the trigger will call `fire` as a response. The input parameters `timestamp` and `value` are the time and value of the data point inserted this time. You can write any logic to process data in the `fire` hook.\n+\n+Note that currently the return value of the hook is meaningless.\n+\n+\n+\n+##### Batch Data Insertion Listening Hooks\n+\n+```java\n+int[] fire(long[] timestamps, int[] values) throws Exception;\n+long[] fire(long[] timestamps, long[] values) throws Exception;\n+float[] fire(long[] timestamps, float[] values) throws Exception;\n+double[] fire(long[] timestamps, double[] values) throws Exception;\n+boolean[] fire(long[] timestamps, boolean[] values) throws Exception;\n+Binary[] fire(long[] timestamps, Binary[] values) throws Exception;\n+```\n+\n+If you need to use the `insertTablet` interface or the `insertTablets` interface of the Session API, you can reduce the overhead of trigger calls by implementing the above batch data insertion listening hooks.\n+\n+It is recommended that the behaviors of the batch data insertion listening hooks and the single point insertion listening hooks be consistent. The default implemetation of the listening hook for batch data insertion is as followed.\n+\n+```java\n+default int[] fire(long[] timestamps, int[] values) throws Exception {\n+  int size = timestamps.length;\n+  for (int i = 0; i < size; ++i) {\n+    fire(timestamps[i], values[i]);\n+  }\n+  return values;\n+}\n+```\n+\n+Note that currently the return value of the hook is meaningless.\n+\n+\n+\n+#### Important Notes\n+\n+* Triggers registered on different time series are difference instances, so you can maintain states in triggers.\n+* The states maintained by triggers will be cleared after the system stops (unless you persist the data by yourself). The states of the triggers will be default values after the system is restarted.\n+* All hook calls of a trigger are serialized.\n+\n \n \n ## Triggers Management\n \n-You can register, deregister, start or stop a trigger instance through SQL statements, and you can also query all registered triggers through SQL statements.\n+You can register, drop, start or stop a trigger instance through SQL statements, and you can also query all registered triggers through SQL statements.\n+\n+\n+\n+### Trigger States\n+\n+Triggers have two states: `STARTED` and `STOPPED`. You can start or stop a trigger by executing `START TRIGGER` or `STOP TRIGGER`. \n+\n+When the state of a trigger is `STOPPED`, it will not respond to the operations on the registered time series (such as inserting a data point), but all status (trigger variables), and registration information will be saved.\n+\n+Note that the default state of the triggers registered by the `CREATE TRIGGER` statement is `STARTED`.\n+\n+\n+\n+### Register Triggers\n \n-Triggers have two states: `STARTED` and `STOPPED`. You can start or stop a trigger by executing `START TRIGGER` or `STOP TRIGGER`. Note that the triggers registered by the `CREATE TRIGGER` statement are `STARTED` by default.\n+A trigger can only be registered on an existing time series. Only one trigger can be registered for any time series.\n \n+The time series registered with the trigger will be listened to by the trigger. When there is a data change in the time series, the corresponding hook in the trigger will be called.\n \n \n-### Create Triggers\n \n-The following shows the SQL syntax of how to register a trigger.\n+Registering a trigger can be carried out as follows:\n+\n+1. Implement a complete Trigger class. Assume that the full class name of this class is `org.apache.iotdb.db.engine.trigger.example.AlertListener`.\n+\n+2. Pack the project into a JAR package. If you use Maven to manage the project, you can refer to the above Maven project example.\n+\n+3. Put the JAR package in the directory `iotdb-server-0.12.0-SNAPSHOT/ext/trigger` (or a subdirectory of `iotdb-server-0.12.0-SNAPSHOT/ext/trigger`).\n+\n+   > You can specify the root path to load the trigger JAR packages by modifying the `trigger_root_dir` in the configuration file.\n+\n+4. Use the SQL statement to register the trigger. Assume that the name given to the trigger is `alert-listener-sg1d1s1`.\n+\n+   ```sql\n+   CREATE TRIGGER alert-listener-sg1d1s1\n+   AFTER INSERT\n+   ON root.sg1.d1.s1\n+   AS \"org.apache.iotdb.db.engine.trigger.example.AlertListener\"\n+   WITH (\n+     \"lo\" = \"0\", \n+     \"hi\" = \"100.0\"\n+   )\n+   ```\n+\n+\n+\n+The following shows the SQL syntax of registering a trigger.\n \n ```sql\n CREATE TRIGGER <TRIGGER-NAME>\n@@ -58,43 +205,120 @@ WITH (\n )\n ```\n \n-Note that `CLASSNAME`, `KEY` and `VALUE` in key-value pair attributes need to be quoted in single or double quotes.\n+`TRIGGER-NAME` is a globally unique ID of the trigger, which is case sensitive.\n+\n+At present, the trigger can listen to all data insertion operations on the time series. The hook can be called `BEFORE`  or `AFTER` the data is inserted.\n+\n+`FULL-PATH` is the name of the time series that the trigger listens to. The path must be a measurement path.\n+\n+`CLASSNAME` is the full class name of the trigger.\n+\n+Note that `CLASSNAME`,  `KEY` and `VALUE` in the attributes need to be quoted in single or double quotes.\n \n \n \n ### Drop Triggers\n \n-The following shows the SQL syntax of how to deregister a trigger.\n+Triggers will be dropped in the following scenarios:\n+\n+1. When the user executes `DELETE TIMESERIES`, the triggers registered on the time series will be dropped.\n+2. When the user executes `DELETE STORAGE GROUP`, the triggers registered under the storage group will be dropped.\n+3. When the user executes the `DROP TRIGGER` statement.\n+\n+\n+\n+The following shows the SQL syntax of dropping a trigger:\n \n ```sql\n DROP TRIGGER <TRIGGER-NAME>\n ```\n \n+The following is an example of a `DROP TRIGGER` statement:\n+\n+```sql\n+DROP TRIGGER alert-listener-sg1d1s1\n+```\n+\n \n \n ### Start Triggers\n \n-The following shows the SQL syntax of how to start a trigger.\n+This operation changes the state of the trigger from `STOPPED` to `STARTED`, which will make the trigger re-listen to the operations on the registered time series and respond to data changes.\n+\n+\n+\n+The following shows the SQL syntax of starting a trigger:\n \n ```sql\n START TRIGGER <TRIGGER-NAME>\n ```\n \n \n \n+The following is an example of a `START TRIGGER` statement:\n+\n+```sql\n+START TRIGGER alert-listener-sg1d1s1\n+```\n+\n+\n+\n+Note that the triggers registered by the `CREATE TRIGGER` statements are `STARTED` by default.\n+\n+\n+\n ### Stop Triggers\n \n-The following shows the SQL syntax of how to stop a trigger.\n+This operation changes the state of the trigger from `STARTED` to `STOPPED`. When the status of a trigger is `STOPPED`, it will not respond to the operations on the registered time series (such as inserting a data point). You can restart a trigger using the `START TRIGGER` statement.\n+\n+\n+\n+The following shows the SQL syntax of stopping a trigger:\n \n ```sql\n STOP TRIGGER <TRIGGER-NAME>\n ```\n \n \n \n+The following is an example of a `STOP TRIGGER` statement:\n+\n+```sql\n+STOP TRIGGER alert-listener-sg1d1s1\n+```\n+\n+\n+\n ### Show All Registered Triggers\n \n ``` sql\n SHOW TRIGGERS\n ```\n \n+\n+\n+### User Authority Management\n+\n+When a user manages triggers, 4 types of authorities will be involved:\n+\n+* `CREATE_TRIGGER`: Only users with this authority are allowed to register triggers.\n+* `DROP_TRIGGER`: Only users with this authority are allowed to drop triggers.\n+* `START_TRIGGER`: Only users with this authority are allowed to start triggers.\n+* `STOP_TRIGGER`: Only users with this authority are allowed to stop triggers.\n+\n+For more information, refer to [Authority Management Statement](../Operation%20Manual/Administration.md).\n+\n+\n+\n+### Important Notes\n+\n+* The trigger is implemented based on the reflection mechanism. Triggers can be dynamically registered and dropped without restarting the server.\n+\n+* It is best not to have classes with the same full class name but different function implementations in different JAR packages under `trigger_root_dir`. For example: the triggers `trigger1` and `trigger2` correspond to `trigger1.jar` and `trigger2.jar` respectively. If both JAR packages contain a `org.apache.iotdb.db.engine.trigger.example.AlertListener` class, when this class is used by a `CREATE TRIGGER` statement, the system will randomly load the class in one of the JAR packages, which may lead to inconsistent trigger behaviors and other problems.\n+\n+* Version management of trigger classes with the same full class name. Triggers with the same full class name but different versions (logic) are not allowed to register in the system.\n+\n+  Related question: IoTDB pre-registered 10 `org.apache.iotdb.db.engine.trigger.example.AlertListener` trigger instances and DBA updated the implementation and corresponding JAR package of `org.apache.iotdb.db.engine.trigger.example.AlertListener`. Is it possible to drop only 5 of the instances and replace them with 5 updated trigger instances?\n+\n+  Answer: No. Only by dropping all the 10 pre-registered triggers can you register the updated triggers. If all the original triggers are not dropped, the newly registered triggers with the same full class name will behave in the same way as the existing triggers.\n+"
  },
  {
    "sha": "4668f5ad9119bcfb85f4131c83d8c333554ae849",
    "filename": "docs/zh/UserGuide/Operation Manual/Triggers.md",
    "status": "modified",
    "additions": 245,
    "deletions": 4,
    "changes": 249,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/docs/zh/UserGuide/Operation%20Manual/Triggers.md",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/docs/zh/UserGuide/Operation%20Manual/Triggers.md",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/docs/zh/UserGuide/Operation%20Manual/Triggers.md?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -23,19 +23,170 @@\n \n # 触发器\n \n+触发器提供了一种侦听序列数据变动的机制。配合用户自定义逻辑，可完成告警、数据清洗、数据转发等功能。\n \n+触发器基于Java反射机制实现。用户通过简单实现Java接口，即可实现数据侦听。IoTDB允许用户动态装载、卸载触发器，在装载、卸载期间，无需启停服务器。\n \n-## SQL管理语句\n+根据此文档，您将会很快学会触发器的编写与管理。\n+\n+\n+\n+## 编写触发器\n+\n+### 触发器依赖\n+\n+触发器的逻辑需要您编写Java类进行实现。\n+\n+在编写触发器逻辑时，需要使用到下面展示的依赖。如果您使用[Maven](http://search.maven.org/)，则可以直接从[Maven库](http://search.maven.org/)中搜索到它们。\n+\n+``` xml\n+<dependency>\n+  <groupId>org.apache.iotdb</groupId>\n+  <artifactId>iotdb-server</artifactId>\n+  <version>0.12.0-SNAPSHOT</version>\n+  <scope>provided</scope>\n+</dependency>\n+```\n+\n+请注意选择和目标服务器版本相同的依赖版本。\n+\n+\n+\n+### 用户编程接口\n+\n+编写一个触发器需要实现`org.apache.iotdb.db.engine.trigger.api.Trigger`类。\n+\n+该类提供了两类编程接口：**生命周期钩子**和**数据变动侦听钩子**。该类中所有的接口都不是必须实现的，当您不实现它们时，它们不会对流经的数据操作产生任何响应。您可以根据实际需要，只实现其中若干接口。\n+\n+下面是所有可供用户进行实现的接口的说明。\n+\n+\n+\n+#### 生命周期钩子\n+\n+| 接口定义                                                     | 描述                                                         |\n+| :----------------------------------------------------------- | ------------------------------------------------------------ |\n+| `void onCreate(TriggerAttributes attributes) throws Exception` | 当您使用`CREATE TRIGGER`语句注册触发器后，该钩子会被调用一次。在每一个实例的生命周期内，该钩子会且仅仅会被调用一次。该钩子主要有如下作用：1. 帮助用户解析SQL语句中的自定义属性（使用`TriggerAttributes`）。 2. 创建或申请资源，如建立外部链接、打开文件等。 |\n+| `void onDrop() throws Exception`                             | 当您使用`DROP TRIGGER`语句删除触发器后，该钩子会被调用。在每一个实例的生命周期内，该钩子会且仅仅会被调用一次。该钩子的主要作用是进行一些资源释放等的操作。 |\n+| `void onStart() throws Exception`                            | 当您使用`START TRIGGER`语句手动启动（被`STOP TRIGGER`语句停止的）触发器后，该钩子会被调用。 |\n+| `void onStop() throws Exception`                             | 当您使用`STOP TRIGGER`语句手动停止触发器后，该钩子会被调用。 |\n+\n+\n+\n+#### 数据变动侦听钩子\n+\n+目前触发器仅能侦听数据插入的操作。\n+\n+数据变动侦听钩子的调用时机由`CREATE TRIGGER`语句显式指定，在编程接口层面不作区分。\n+\n+\n+\n+##### 单点数据插入侦听钩子\n+\n+``` java\n+Integer fire(long timestamp, Integer value) throws Exception;\n+Long fire(long timestamp, Long value) throws Exception;\n+Float fire(long timestamp, Float value) throws Exception;\n+Double fire(long timestamp, Double value) throws Exception;\n+Boolean fire(long timestamp, Boolean value) throws Exception;\n+Binary fire(long timestamp, Binary value) throws Exception;\n+```\n+\n+对于注册序列上的每一点数据插入，触发器都会调用`fire`作为响应，钩子的入参`timestamp`和`value`即是这一次插入数据点的时间和数据值。您可以在`fire`钩子中编写处理数据的任意逻辑。\n+\n+注意，目前钩子的返回值是没有任何意义的。\n+\n+\n+\n+##### 批量数据插入侦听钩子\n+\n+```java\n+int[] fire(long[] timestamps, int[] values) throws Exception;\n+long[] fire(long[] timestamps, long[] values) throws Exception;\n+float[] fire(long[] timestamps, float[] values) throws Exception;\n+double[] fire(long[] timestamps, double[] values) throws Exception;\n+boolean[] fire(long[] timestamps, boolean[] values) throws Exception;\n+Binary[] fire(long[] timestamps, Binary[] values) throws Exception;\n+```\n+\n+如果您需要在业务场景中使用到Session API的`insertTablet`接口或`insertTablets`接口，那么您可以通过实现上述数据插入的侦听钩子来降低触发器的调用开销。\n+\n+推荐您在实现上述批量数据插入的侦听钩子时， 保证批量数据插入侦听钩子与单点数据插入侦听钩子的行为具有一致性。当您不实现批量数据插入的侦听钩子时，它将遵循下面的默认逻辑。\n+\n+```java\n+default int[] fire(long[] timestamps, int[] values) throws Exception {\n+  int size = timestamps.length;\n+  for (int i = 0; i < size; ++i) {\n+    fire(timestamps[i], values[i]);\n+  }\n+  return values;\n+}\n+```\n+\n+注意，目前钩子的返回值是没有任何意义的。\n+\n+\n+\n+#### 重要注意事项\n+\n+* 每条序列上注册的触发器都是一个完整的触发器类的实例，因此您可以在触发器中维护一些状态数据。\n+* 触发器维护的状态会在系统停止后被清空（除非您在钩子中主动将状态持久化）。换言之，系统启动后触发器的状态将会默认为初始值。\n+* 一个触发器所有钩子的调用都是串行化的。\n+\n+\n+\n+## 管理触发器\n \n 您可以通过SQL语句注册、卸载、启动或停止一个触发器实例，您也可以通过SQL语句查询到所有已经注册的触发器。\n \n-触发器有两种运行状态：`STARTED`和`STOPPED`，您可以通过执行`START TRIGGER`或者`STOP TRIGGER`启动或者停止一个触发器。注意，通过`CREATE TRIGGER`语句注册的触发器默认是`STARTED`的。\n+\n+\n+### 触发器的状态\n+\n+触发器有两种运行状态：`STARTED`和`STOPPED`，您需要执行`START TRIGGER`或者`STOP TRIGGER`来启动或者停止一个触发器。\n+\n+当一个触发器的状态为`STOPPED`时，它将不会响应被注册序列上的操作（如插入数据点的操作），对外表现就会像是这个序列没有被注册过触发器一样，但是它会保存所有的状态（触发器类变量）信息，同时也会保存所有的注册信息。\n+\n+注意，通过`CREATE TRIGGER`语句注册的触发器默认是`STARTED`的。\n \n \n \n ### 注册触发器\n \n-注册触发器的SQL语法如下：\n+触发器只能注册在一个已经存在的时间序列上。任何时间序列只允许注册一个触发器。\n+\n+被注册有触发器的序列将会被触发器侦听，当序列上有数据变动时，触发器中对应的钩子将会被调用。\n+\n+\n+\n+注册一个触发器可以按如下流程进行：\n+\n+1. 实现一个完整的Trigger类，假定这个类的全类名为`org.apache.iotdb.db.engine.trigger.example.AlertListener`\n+\n+2. 将项目打成JAR包，如果您使用Maven管理项目，可以参考上述Maven项目示例的写法\n+\n+3. 将JAR包放置到目录 `iotdb-server-0.12.0-SNAPSHOT/ext/trigger` （也可以是`iotdb-server-0.12.0-SNAPSHOT/ext/trigger`的子目录）下。\n+\n+   > 您可以通过修改配置文件中的`trigger_root_dir`来指定加载触发器JAR包的根路径。\n+\n+4. 使用SQL语句注册该触发器，假定赋予该触发器的名字为`alert-listener-sg1d1s1`\n+\n+5. 使用`CREATE TRIGGER`语句注册该触发器\n+\n+   ```sql\n+   CREATE TRIGGER alert-listener-sg1d1s1\n+   AFTER INSERT\n+   ON root.sg1.d1.s1\n+   AS \"org.apache.iotdb.db.engine.trigger.example.AlertListener\"\n+   WITH (\n+     \"lo\" = \"0\", \n+     \"hi\" = \"100.0\"\n+   )\n+   ```\n+\n+   \n+\n+注册触发器的详细SQL语法如下：\n \n ```sql\n CREATE TRIGGER <TRIGGER-NAME>\n@@ -58,43 +209,133 @@ WITH (\n )\n ```\n \n-注意，`CLASSNAME`以及属性值中的`KEY`和`VALUE`都需要被单引号或者双引号引用起来。\n+`TRIGGER-NAME`是用于标定触发器的全局唯一ID，它是大小写敏感的。\n+\n+目前触发器可以侦听序列上的所有的数据插入操作，触发器可以选择在数据插入前（`BEFORE INSERT`）或者数据插入后（`AFTER INSERT`）触发钩子调用。\n+\n+`FULL-PATH`是触发器侦听的目标序列名称，这个序列必须是一个测点。\n+\n+`CLASSNAME`是触发器类的全类名。\n+\n+请注意，`CLASSNAME`以及属性值中的`KEY`和`VALUE`都需要被单引号或者双引号引用起来。\n \n \n \n ### 卸载触发器\n \n+触发器会在下面几种情景下被卸载：\n+\n+1. 用户执行`DELETE TIMESERIES`时，序列上注册的触发器会被卸载\n+2. 用户执行`DELETE STORAGE GROUP`时，对应存储组下注册的触发器会全部被卸载\n+3. 用户使用`DROP TRIGGER`语句主动卸载\n+\n+\n+\n 卸载触发器的SQL语法如下：\n \n ```sql\n DROP TRIGGER <TRIGGER-NAME>\n ```\n \n+`TRIGGER-NAME`是用于标定触发器的全局唯一ID。\n+\n+\n+\n+下面是一个`DROP TRIGGER`语句的例子：\n+\n+```sql\n+DROP TRIGGER alert-listener-sg1d1s1\n+```\n+\n \n \n ### 启动触发器\n \n+该操作是“停止触发器”的逆操作。它将运行状态为`STOPPED`的触发器的运行状态变更为`STARTED`，这会使得触发器重新侦听被注册序列上的操作，并对数据变动产生响应。\n+\n+\n+\n 启动触发器的SQL语法如下：\n \n ```sql\n START TRIGGER <TRIGGER-NAME>\n ```\n \n+`TRIGGER-NAME`是用于标定触发器的全局唯一ID。\n+\n+\n+\n+下面是一个`START TRIGGER`语句的例子：\n+\n+```sql\n+START TRIGGER alert-listener-sg1d1s1\n+```\n+\n+\n+\n+注意，通过`CREATE TRIGGER`语句注册的触发器默认是`STARTED`的。\n+\n \n \n ### 停止触发器\n \n+该操作将触发器的状态由`STARTED`变为`STOPPED`。当一个触发器的状态为`STOPPED`时，它将不会响应被注册序列上的操作（如插入数据点的操作），对外表现就会像是这个序列没有被注册过触发器一样。您可以使用`START TRIGGER`语句重新启动一个触发器。\n+\n+\n+\n 停止触发器的SQL语法如下：\n \n ```sql\n STOP TRIGGER <TRIGGER-NAME>\n ```\n \n+`TRIGGER-NAME`是用于标定触发器的全局唯一ID。\n+\n+\n+\n+下面是一个`STOP TRIGGER`语句的例子：\n+\n+```sql\n+STOP TRIGGER alert-listener-sg1d1s1\n+```\n+\n \n \n ### 查询所有注册的触发器\n \n+查询触发器的SQL语句如下：\n+\n ``` sql\n SHOW TRIGGERS\n ```\n \n+该语句展示已注册触发器的ID、运行状态、触发时机、被注册的序列、触发器实例的全类名和注册触发器时用到的自定义属性。\n+\n+\n+\n+### 用户权限管理\n+\n+用户在使用触发器时会涉及到4种权限：\n+\n+* `CREATE_TRIGGER`：具备该权限的用户才被允许注册触发器操作。\n+* `DROP_TRIGGER`：具备该权限的用户才被允许卸载触发器操作。\n+* `START_TRIGGER`：具备该权限的用户才被允许启动已被停止的触发器。\n+* `STOP_TRIGGER`：具备该权限的用户才被允许停止正在运行的触发器。\n+\n+更多用户权限相关的内容，请参考[权限管理语句](../Operation%20Manual/Administration.md)。\n+\n+\n+\n+### 重要注意事项\n+\n+* 触发器是通过反射技术动态装载的，因此您在装载过程中无需启停服务器。\n+\n+* 不同的JAR包中最好不要有全类名相同但功能实现不一样的类。例如：触发器`trigger1`、`trigger2`分别对应资源`trigger1.jar`、`trigger2.jar`。如果两个JAR包里都包含一个`org.apache.iotdb.db.engine.trigger.example.AlertListener`类，当`CREATE TRIGGER`使用到这个类时，系统会随机加载其中一个JAR包中的类，最终导致触发器执行行为不一致以及其他的问题。\n+\n+* 拥有同一个全类名的触发器类的版本管理问题。IoTDB不允许系统中存在拥有同一全类名但是版本（逻辑）不一样的触发器。\n+\n+  相关问题：IoTDB预先注册了10个`org.apache.iotdb.db.engine.trigger.example.AlertListener`触发器实例，DBA更新了`org.apache.iotdb.db.engine.trigger.example.AlertListener`的实现和对应的JAR包，是否可以只卸载其中5个，将这5个替换为新的实现？\n+\n+  回答：无法做到。只有将预先注册的10个触发器全部卸载，才能装载到新的触发器实例。在原有触发器没有全部被卸载的情况下，新注册的拥有相同全类名的触发器行为只会与现有触发器的行为一致。\n+\n+"
  },
  {
    "sha": "5c31027c9687b73d86f96ed32b23936bce884113",
    "filename": "docs/zh/UserGuide/Operation Manual/UDF User Defined Function.md",
    "status": "modified",
    "additions": 5,
    "deletions": 1,
    "changes": 6,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/docs/zh/UserGuide/Operation%20Manual/UDF%20User%20Defined%20Function.md",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/docs/zh/UserGuide/Operation%20Manual/UDF%20User%20Defined%20Function.md",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/docs/zh/UserGuide/Operation%20Manual/UDF%20User%20Defined%20Function.md?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -388,7 +388,7 @@ UDTF的结束方法，您可以在此方法中进行一些资源释放等的操\n 1. 实现一个完整的UDF类，假定这个类的全类名为`org.apache.iotdb.udf.ExampleUDTF`\n 2. 将项目打成JAR包，如果您使用Maven管理项目，可以参考上述Maven项目示例的写法\n 3. 将JAR包放置到目录 `iotdb-server-0.12.0-SNAPSHOT/ext/udf` （也可以是`iotdb-server-0.12.0-SNAPSHOT/ext/udf`的子目录）下。\n-    \n+   \n     > 您可以通过修改配置文件中的`udf_root_dir`来指定UDF加载Jar的根路径。\n 4. 使用SQL语句注册该UDF，假定赋予该UDF的名字为`example`\n \n@@ -572,11 +572,15 @@ SHOW FUNCTIONS\n 当 PR 评审通过并被合并后，您的 UDF 就已经贡献给 IoTDB 社区了！\n \n \n+\n+\n ## 已知的UDF库实现\n \n + [IoTDB-Quality](https://thulab.github.io/iotdb-quality)，一个关于数据质量的UDF库实现，包括数据画像、数据质量评估与修复等一系列函数。\n \n \n+\n+\n ## Q&A\n \n **Q1: 如何修改已经注册的UDF？**"
  },
  {
    "sha": "b829d380f2d8f80832455b1c08d0f6bbe49c7147",
    "filename": "server/src/assembly/resources/conf/iotdb-engine.properties",
    "status": "modified",
    "additions": 27,
    "deletions": 4,
    "changes": 31,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/assembly/resources/conf/iotdb-engine.properties",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/assembly/resources/conf/iotdb-engine.properties",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/assembly/resources/conf/iotdb-engine.properties?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -614,7 +614,7 @@ authorizer_provider_class=org.apache.iotdb.db.auth.authorizer.LocalFileAuthorize\n #openID_url=\n \n ####################\n-### UDF Query Configuration\n+### UDF Configuration\n ####################\n \n # Used to estimate the memory usage of text fields in a UDF query.\n@@ -630,13 +630,36 @@ udf_memory_budget_in_mb=30.0\n # The parameter form is a:b:c, where a, b, and c are integers.\n udf_reader_transformer_collector_memory_proportion=1:1:1\n \n-# Uncomment following fields to configure the udf root directory.\n-# For Window platform, the index is as follows:\n+# Uncomment the following field to configure the udf root directory.\n+# For Window platform\n+# If its prefix is a drive specifier followed by \"\\\\\", or if its prefix is \"\\\\\\\\\", then the path is\n+# absolute. Otherwise, it is relative.\n # udf_root_dir=ext\\\\udf\n # For Linux platform\n # If its prefix is \"/\", then the path is absolute. Otherwise, it is relative.\n-# index_root_dir=ext/udf\n+# udf_root_dir=ext/udf\n+\n+####################\n+### Trigger Configuration\n+####################\n+\n+# The size of log buffer for every trigger management operation plan. If the size of a trigger\n+# management operation plan is larger than this parameter, the trigger management operation plan\n+# will be rejected by TriggerManager.\n+tlog_buffer_size=1048576\n+\n+# Uncomment the following field to configure the trigger root directory.\n+# For Window platform\n+# If its prefix is a drive specifier followed by \"\\\\\", or if its prefix is \"\\\\\\\\\", then the path is\n+# absolute. Otherwise, it is relative.\n+# trigger_root_dir=ext\\\\trigger\n+# For Linux platform\n+# If its prefix is \"/\", then the path is absolute. Otherwise, it is relative.\n+# trigger_root_dir=ext/trigger\n \n+####################\n+### Index Configuration\n+####################\n \n # Uncomment following fields to configure the index root directory.\n # For Window platform, the index is as follows:"
  },
  {
    "sha": "238d11052f02d484aaa60f8ba5dc6265acc81280",
    "filename": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java",
    "status": "modified",
    "additions": 28,
    "deletions": 0,
    "changes": 28,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -179,6 +179,13 @@\n    */\n   private int mlogBufferSize = 1024 * 1024;\n \n+  /**\n+   * The size of log buffer for every trigger management operation plan. If the size of a trigger\n+   * management operation plan is larger than this parameter, the trigger management operation plan\n+   * will be rejected by TriggerManager.\n+   */\n+  private int tlogBufferSize = 1024 * 1024;\n+\n   /** default base dir, stores all IoTDB runtime files */\n   private static final String DEFAULT_BASE_DIR = \"data\";\n \n@@ -214,6 +221,10 @@\n   private String udfDir =\n       IoTDBConstant.EXT_FOLDER_NAME + File.separator + IoTDBConstant.UDF_FOLDER_NAME;\n \n+  /** External lib directory for trigger, stores user-uploaded JAR files */\n+  private String triggerDir =\n+      IoTDBConstant.EXT_FOLDER_NAME + File.separator + IoTDBConstant.TRIGGER_FOLDER_NAME;\n+\n   /** Data directory of data. It can be settled as dataDirs = {\"data1\", \"data2\", \"data3\"}; */\n   private String[] dataDirs = {\"data\" + File.separator + \"data\"};\n \n@@ -767,6 +778,7 @@ private void formulateFolders() {\n     indexRootFolder = addHomeDir(indexRootFolder);\n     extDir = addHomeDir(extDir);\n     udfDir = addHomeDir(udfDir);\n+    triggerDir = addHomeDir(triggerDir);\n \n     if (TSFileDescriptor.getInstance().getConfig().getTSFileStorageFs().equals(FSType.HDFS)) {\n       String hdfsDir = getHdfsDir();\n@@ -991,6 +1003,14 @@ public void setUdfDir(String udfDir) {\n     this.udfDir = udfDir;\n   }\n \n+  public String getTriggerDir() {\n+    return triggerDir;\n+  }\n+\n+  public void setTriggerDir(String triggerDir) {\n+    this.triggerDir = triggerDir;\n+  }\n+\n   public String getMultiDirStrategyClassName() {\n     return multiDirStrategyClassName;\n   }\n@@ -2066,6 +2086,14 @@ public void setMlogBufferSize(int mlogBufferSize) {\n     this.mlogBufferSize = mlogBufferSize;\n   }\n \n+  public int getTlogBufferSize() {\n+    return tlogBufferSize;\n+  }\n+\n+  public void setTlogBufferSize(int tlogBufferSize) {\n+    this.tlogBufferSize = tlogBufferSize;\n+  }\n+\n   public boolean isEnableRpcService() {\n     return enableRpcService;\n   }"
  },
  {
    "sha": "57c586e24c011700d8af2c3fa7d939f5ace58674",
    "filename": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConstant.java",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConstant.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConstant.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/conf/IoTDBConstant.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -107,6 +107,9 @@ private IoTDBConstant() {}\n   public static final String COLUMN_TRIGGER_CLASS = \"class name\";\n   public static final String COLUMN_TRIGGER_ATTRIBUTES = \"attributes\";\n \n+  public static final String COLUMN_TRIGGER_STATUS_STARTED = \"started\";\n+  public static final String COLUMN_TRIGGER_STATUS_STOPPED = \"stopped\";\n+\n   public static final String PATH_WILDCARD = \"*\";\n   public static final String TIME = \"time\";\n \n@@ -132,6 +135,7 @@ private IoTDBConstant() {}\n   public static final String TRACING_LOG = \"tracing.txt\";\n   public static final String EXT_FOLDER_NAME = \"ext\";\n   public static final String UDF_FOLDER_NAME = \"udf\";\n+  public static final String TRIGGER_FOLDER_NAME = \"trigger\";\n \n   // mqtt\n   public static final String ENABLE_MQTT = \"enable_mqtt_service\";"
  },
  {
    "sha": "6c6724868c33a49a0d548dc1a759272f38fba1d0",
    "filename": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBDescriptor.java",
    "status": "modified",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/conf/IoTDBDescriptor.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/conf/IoTDBDescriptor.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/conf/IoTDBDescriptor.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -749,6 +749,9 @@ private void loadProps() {\n       // UDF\n       loadUDFProps(properties);\n \n+      // trigger\n+      loadTriggerProps(properties);\n+\n     } catch (FileNotFoundException e) {\n       logger.warn(\"Fail to find config file {}\", url, e);\n     } catch (IOException e) {\n@@ -1139,6 +1142,17 @@ private void loadUDFProps(Properties properties) {\n     }\n   }\n \n+  private void loadTriggerProps(Properties properties) {\n+    conf.setTriggerDir(properties.getProperty(\"trigger_root_dir\", conf.getTriggerDir()));\n+\n+    int tlogBufferSize =\n+        Integer.parseInt(\n+            properties.getProperty(\"tlog_buffer_size\", Integer.toString(conf.getTlogBufferSize())));\n+    if (tlogBufferSize > 0) {\n+      conf.setTlogBufferSize(tlogBufferSize);\n+    }\n+  }\n+\n   /** Get default encode algorithm by data type */\n   public TSEncoding getDefaultEncodingByType(TSDataType dataType) {\n     switch (dataType) {"
  },
  {
    "sha": "c15ae59cce52ae54f80957b33418faf6e5ed21f0",
    "filename": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -506,7 +506,6 @@ public synchronized void reset() {\n    * @param insertRowPlan physical plan of insertion\n    */\n   public void insert(InsertRowPlan insertRowPlan) throws StorageEngineException {\n-\n     StorageGroupProcessor storageGroupProcessor = getProcessor(insertRowPlan.getDeviceId());\n \n     try {\n@@ -553,6 +552,7 @@ public void insertTablet(InsertTabletPlan insertTabletPlan)\n     }\n \n     storageGroupProcessor.insertTablet(insertTabletPlan);\n+\n     if (config.isEnableStatMonitor()) {\n       try {\n         StorageGroupMNode storageGroupMNode ="
  },
  {
    "sha": "00660a728f97b1107a0f9498f5c2e9fd3b50d8de",
    "filename": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java",
    "status": "modified",
    "additions": 26,
    "deletions": 4,
    "changes": 30,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -36,6 +36,8 @@\n import org.apache.iotdb.db.engine.modification.ModificationFile;\n import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n import org.apache.iotdb.db.engine.storagegroup.timeindex.DeviceTimeIndex;\n+import org.apache.iotdb.db.engine.trigger.executor.TriggerEngine;\n+import org.apache.iotdb.db.engine.trigger.executor.TriggerEvent;\n import org.apache.iotdb.db.engine.upgrade.UpgradeCheckStatus;\n import org.apache.iotdb.db.engine.upgrade.UpgradeLog;\n import org.apache.iotdb.db.engine.version.SimpleFileVersionController;\n@@ -44,6 +46,7 @@\n import org.apache.iotdb.db.exception.DiskSpaceInsufficientException;\n import org.apache.iotdb.db.exception.LoadFileException;\n import org.apache.iotdb.db.exception.StorageGroupProcessorException;\n+import org.apache.iotdb.db.exception.TriggerExecutionException;\n import org.apache.iotdb.db.exception.TsFileProcessorException;\n import org.apache.iotdb.db.exception.WriteProcessException;\n import org.apache.iotdb.db.exception.WriteProcessRejectException;\n@@ -780,7 +783,8 @@ private int compareFileName(File o1, File o2) {\n     }\n   }\n \n-  public void insert(InsertRowPlan insertRowPlan) throws WriteProcessException {\n+  public void insert(InsertRowPlan insertRowPlan)\n+      throws WriteProcessException, TriggerExecutionException {\n     // reject insertions that are out of ttl\n     if (!isAlive(insertRowPlan.getTime())) {\n       throw new OutOfTTLException(insertRowPlan.getTime(), (System.currentTimeMillis() - dataTTL));\n@@ -809,9 +813,13 @@ public void insert(InsertRowPlan insertRowPlan) throws WriteProcessException {\n       }\n \n       latestTimeForEachDevice.computeIfAbsent(timePartitionId, l -> new HashMap<>());\n+\n+      // fire trigger before insertion\n+      TriggerEngine.fire(TriggerEvent.BEFORE_INSERT, insertRowPlan);\n       // insert to sequence or unSequence file\n       insertToTsFileProcessor(insertRowPlan, isSequence, timePartitionId);\n-\n+      // fire trigger after insertion\n+      TriggerEngine.fire(TriggerEvent.AFTER_INSERT, insertRowPlan);\n     } finally {\n       writeUnlock();\n     }\n@@ -823,7 +831,8 @@ public void insert(InsertRowPlan insertRowPlan) throws WriteProcessException {\n    * @throws BatchProcessException if some of the rows failed to be inserted\n    */\n   @SuppressWarnings(\"squid:S3776\") // Suppress high Cognitive Complexity warning\n-  public void insertTablet(InsertTabletPlan insertTabletPlan) throws BatchProcessException {\n+  public void insertTablet(InsertTabletPlan insertTabletPlan)\n+      throws BatchProcessException, TriggerExecutionException {\n     if (enableMemControl) {\n       try {\n         StorageEngine.blockInsertionIfReject();\n@@ -862,6 +871,11 @@ public void insertTablet(InsertTabletPlan insertTabletPlan) throws BatchProcessE\n       if (loc == insertTabletPlan.getRowCount()) {\n         throw new BatchProcessException(results);\n       }\n+\n+      // fire trigger before insertion\n+      final int firePosition = loc;\n+      TriggerEngine.fire(TriggerEvent.BEFORE_INSERT, insertTabletPlan, firePosition);\n+\n       // before is first start point\n       int before = loc;\n       // before time partition\n@@ -932,6 +946,9 @@ public void insertTablet(InsertTabletPlan insertTabletPlan) throws BatchProcessE\n       if (!noFailure) {\n         throw new BatchProcessException(results);\n       }\n+\n+      // fire trigger after insertion\n+      TriggerEngine.fire(TriggerEvent.AFTER_INSERT, insertTabletPlan, firePosition);\n     } finally {\n       writeUnlock();\n     }\n@@ -2858,7 +2875,7 @@ public TsFileManagement getTsFileManagement() {\n   }\n \n   public void insert(InsertRowsOfOneDevicePlan insertRowsOfOneDevicePlan)\n-      throws WriteProcessException {\n+      throws WriteProcessException, TriggerExecutionException {\n     if (enableMemControl) {\n       StorageEngine.blockInsertionIfReject();\n     }\n@@ -2891,8 +2908,13 @@ public void insert(InsertRowsOfOneDevicePlan insertRowsOfOneDevicePlan)\n           return;\n         }\n         latestTimeForEachDevice.computeIfAbsent(timePartitionId, l -> new HashMap<>());\n+\n+        // fire trigger before insertion\n+        TriggerEngine.fire(TriggerEvent.BEFORE_INSERT, plan);\n         // insert to sequence or unSequence file\n         insertToTsFileProcessor(plan, isSequence, timePartitionId);\n+        // fire trigger before insertion\n+        TriggerEngine.fire(TriggerEvent.AFTER_INSERT, plan);\n       }\n     } finally {\n       writeUnlock();"
  },
  {
    "sha": "9a2b9f16b4a84dfd6f93ff4d534256d201b22aa8",
    "filename": "server/src/main/java/org/apache/iotdb/db/engine/trigger/api/Trigger.java",
    "status": "added",
    "additions": 116,
    "deletions": 0,
    "changes": 116,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/api/Trigger.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/api/Trigger.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/engine/trigger/api/Trigger.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.trigger.api;\n+\n+import org.apache.iotdb.tsfile.utils.Binary;\n+\n+/** User Guide: docs/UserGuide/Operation Manual/Triggers.md */\n+public interface Trigger {\n+\n+  @SuppressWarnings(\"squid:S112\")\n+  default void onCreate(TriggerAttributes attributes) throws Exception {}\n+\n+  @SuppressWarnings(\"squid:S112\")\n+  default void onDrop() throws Exception {}\n+\n+  @SuppressWarnings(\"squid:S112\")\n+  default void onStart() throws Exception {}\n+\n+  @SuppressWarnings(\"squid:S112\")\n+  default void onStop() throws Exception {}\n+\n+  @SuppressWarnings(\"squid:S112\")\n+  default Integer fire(long timestamp, Integer value) throws Exception {\n+    return value;\n+  }\n+\n+  default int[] fire(long[] timestamps, int[] values) throws Exception {\n+    int size = timestamps.length;\n+    for (int i = 0; i < size; ++i) {\n+      fire(timestamps[i], values[i]);\n+    }\n+    return values;\n+  }\n+\n+  @SuppressWarnings(\"squid:S112\")\n+  default Long fire(long timestamp, Long value) throws Exception {\n+    return value;\n+  }\n+\n+  default long[] fire(long[] timestamps, long[] values) throws Exception {\n+    int size = timestamps.length;\n+    for (int i = 0; i < size; ++i) {\n+      fire(timestamps[i], values[i]);\n+    }\n+    return values;\n+  }\n+\n+  @SuppressWarnings(\"squid:S112\")\n+  default Float fire(long timestamp, Float value) throws Exception {\n+    return value;\n+  }\n+\n+  default float[] fire(long[] timestamps, float[] values) throws Exception {\n+    int size = timestamps.length;\n+    for (int i = 0; i < size; ++i) {\n+      fire(timestamps[i], values[i]);\n+    }\n+    return values;\n+  }\n+\n+  @SuppressWarnings(\"squid:S112\")\n+  default Double fire(long timestamp, Double value) throws Exception {\n+    return value;\n+  }\n+\n+  default double[] fire(long[] timestamps, double[] values) throws Exception {\n+    int size = timestamps.length;\n+    for (int i = 0; i < size; ++i) {\n+      fire(timestamps[i], values[i]);\n+    }\n+    return values;\n+  }\n+\n+  @SuppressWarnings(\"squid:S112\")\n+  default Boolean fire(long timestamp, Boolean value) throws Exception {\n+    return value;\n+  }\n+\n+  default boolean[] fire(long[] timestamps, boolean[] values) throws Exception {\n+    int size = timestamps.length;\n+    for (int i = 0; i < size; ++i) {\n+      fire(timestamps[i], values[i]);\n+    }\n+    return values;\n+  }\n+\n+  @SuppressWarnings(\"squid:S112\")\n+  default Binary fire(long timestamp, Binary value) throws Exception {\n+    return value;\n+  }\n+\n+  default Binary[] fire(long[] timestamps, Binary[] values) throws Exception {\n+    int size = timestamps.length;\n+    for (int i = 0; i < size; ++i) {\n+      fire(timestamps[i], values[i]);\n+    }\n+    return values;\n+  }\n+}"
  },
  {
    "sha": "2fd69d856fd4f8fa100fbab9a5cf5e39d2ae7bb8",
    "filename": "server/src/main/java/org/apache/iotdb/db/engine/trigger/api/TriggerAttributes.java",
    "status": "added",
    "additions": 98,
    "deletions": 0,
    "changes": 98,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/api/TriggerAttributes.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/api/TriggerAttributes.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/engine/trigger/api/TriggerAttributes.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.trigger.api;\n+\n+import java.util.Map;\n+\n+public class TriggerAttributes {\n+\n+  private final Map<String, String> attributes;\n+\n+  public TriggerAttributes(Map<String, String> attributes) {\n+    this.attributes = attributes;\n+  }\n+\n+  public Map<String, String> getAttributes() {\n+    return attributes;\n+  }\n+\n+  public boolean hasAttribute(String attributeKey) {\n+    return attributes.containsKey(attributeKey);\n+  }\n+\n+  public String getString(String key) {\n+    return attributes.get(key);\n+  }\n+\n+  public Boolean getBoolean(String key) {\n+    String value = attributes.get(key);\n+    return value == null ? null : Boolean.parseBoolean(value);\n+  }\n+\n+  public Integer getInt(String key) {\n+    String value = attributes.get(key);\n+    return value == null ? null : Integer.parseInt(value);\n+  }\n+\n+  public Long getLong(String key) {\n+    String value = attributes.get(key);\n+    return value == null ? null : Long.parseLong(value);\n+  }\n+\n+  public Float getFloat(String key) {\n+    String value = attributes.get(key);\n+    return value == null ? null : Float.parseFloat(value);\n+  }\n+\n+  public Double getDouble(String key) {\n+    String value = attributes.get(key);\n+    return value == null ? null : Double.parseDouble(value);\n+  }\n+\n+  public String getStringOrDefault(String key, String defaultValue) {\n+    String value = attributes.get(key);\n+    return value == null ? defaultValue : value;\n+  }\n+\n+  public boolean getBooleanOrDefault(String key, boolean defaultValue) {\n+    String value = attributes.get(key);\n+    return value == null ? defaultValue : Boolean.parseBoolean(value);\n+  }\n+\n+  public int getIntOrDefault(String key, int defaultValue) {\n+    String value = attributes.get(key);\n+    return value == null ? defaultValue : Integer.parseInt(value);\n+  }\n+\n+  public long getLongOrDefault(String key, long defaultValue) {\n+    String value = attributes.get(key);\n+    return value == null ? defaultValue : Long.parseLong(value);\n+  }\n+\n+  public float getFloatOrDefault(String key, float defaultValue) {\n+    String value = attributes.get(key);\n+    return value == null ? defaultValue : Float.parseFloat(value);\n+  }\n+\n+  public double getDoubleOrDefault(String key, double defaultValue) {\n+    String value = attributes.get(key);\n+    return value == null ? defaultValue : Double.parseDouble(value);\n+  }\n+}"
  },
  {
    "sha": "2dfb10fc48f5767ca9714bcfbfac7d29cd1e24d4",
    "filename": "server/src/main/java/org/apache/iotdb/db/engine/trigger/executor/TriggerEngine.java",
    "status": "added",
    "additions": 114,
    "deletions": 0,
    "changes": 114,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/executor/TriggerEngine.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/executor/TriggerEngine.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/engine/trigger/executor/TriggerEngine.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.trigger.executor;\n+\n+import org.apache.iotdb.db.engine.trigger.service.TriggerRegistrationInformation;\n+import org.apache.iotdb.db.engine.trigger.service.TriggerRegistrationService;\n+import org.apache.iotdb.db.exception.TriggerExecutionException;\n+import org.apache.iotdb.db.exception.TriggerManagementException;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.qp.physical.crud.InsertTabletPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DropTriggerPlan;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class TriggerEngine {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(TriggerEngine.class);\n+\n+  public static void fire(TriggerEvent event, InsertRowPlan insertRowPlan)\n+      throws TriggerExecutionException {\n+    MeasurementMNode[] mNodes = insertRowPlan.getMeasurementMNodes();\n+    int size = mNodes.length;\n+\n+    long timestamp = insertRowPlan.getTime();\n+    Object[] values = insertRowPlan.getValues();\n+\n+    for (int i = 0; i < size; ++i) {\n+      MeasurementMNode mNode = mNodes[i];\n+      if (mNode == null) {\n+        continue;\n+      }\n+      TriggerExecutor executor = mNode.getTriggerExecutor();\n+      if (executor == null) {\n+        continue;\n+      }\n+      executor.fireIfActivated(event, timestamp, values[i]);\n+    }\n+  }\n+\n+  public static void fire(TriggerEvent event, InsertTabletPlan insertTabletPlan, int firePosition)\n+      throws TriggerExecutionException {\n+    MeasurementMNode[] mNodes = insertTabletPlan.getMeasurementMNodes();\n+    int size = mNodes.length;\n+\n+    long[] timestamps = insertTabletPlan.getTimes();\n+    Object[] columns = insertTabletPlan.getColumns();\n+    if (firePosition != 0) {\n+      timestamps = Arrays.copyOfRange(timestamps, firePosition, timestamps.length);\n+      columns = Arrays.copyOfRange(columns, firePosition, columns.length);\n+    }\n+\n+    for (int i = 0; i < size; ++i) {\n+      MeasurementMNode mNode = mNodes[i];\n+      if (mNode == null) {\n+        continue;\n+      }\n+      TriggerExecutor executor = mNode.getTriggerExecutor();\n+      if (executor == null) {\n+        continue;\n+      }\n+      executor.fireIfActivated(event, timestamps, columns[i]);\n+    }\n+  }\n+\n+  public static void drop(MeasurementMNode measurementMNode) {\n+    TriggerExecutor executor = measurementMNode.getTriggerExecutor();\n+    if (executor == null) {\n+      return;\n+    }\n+\n+    TriggerRegistrationInformation information = executor.getRegistrationInformation();\n+    try {\n+      TriggerRegistrationService.getInstance()\n+          .deregister(new DropTriggerPlan(information.getTriggerName()));\n+    } catch (TriggerManagementException e) {\n+      LOGGER.warn(\n+          \"Failed to deregister trigger {}({}) when deleting timeseries ({}).\",\n+          information.getTriggerName(),\n+          information.getClassName(),\n+          measurementMNode.getPartialPath().getFullPath(),\n+          e);\n+    }\n+  }\n+\n+  public static void drop(List<MeasurementMNode> measurementMNodes) {\n+    for (MeasurementMNode measurementMNode : measurementMNodes) {\n+      drop(measurementMNode);\n+    }\n+  }\n+\n+  private TriggerEngine() {}\n+}"
  },
  {
    "sha": "2ffb1ee0c0744de72e3a70b8a5fa29198465f044",
    "filename": "server/src/main/java/org/apache/iotdb/db/engine/trigger/executor/TriggerEvent.java",
    "status": "added",
    "additions": 53,
    "deletions": 0,
    "changes": 53,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/executor/TriggerEvent.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/executor/TriggerEvent.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/engine/trigger/executor/TriggerEvent.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.trigger.executor;\n+\n+public enum TriggerEvent {\n+  BEFORE_INSERT((byte) 0, \"before insert\"),\n+  AFTER_INSERT((byte) 1, \"after insert\");\n+\n+  private final byte id;\n+  private final String event;\n+\n+  TriggerEvent(byte id, String event) {\n+    this.id = id;\n+    this.event = event;\n+  }\n+\n+  public byte getId() {\n+    return id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return event;\n+  }\n+\n+  public static TriggerEvent construct(byte id) {\n+    switch (id) {\n+      case 0:\n+        return BEFORE_INSERT;\n+      case 1:\n+        return AFTER_INSERT;\n+      default:\n+        throw new IllegalArgumentException(String.format(\"No such trigger event (id: %d)\", id));\n+    }\n+  }\n+}"
  },
  {
    "sha": "4ba59bd6fee4520f2cdd038413d28146cf85f328",
    "filename": "server/src/main/java/org/apache/iotdb/db/engine/trigger/executor/TriggerExecutor.java",
    "status": "added",
    "additions": 238,
    "deletions": 0,
    "changes": 238,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/executor/TriggerExecutor.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/executor/TriggerExecutor.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/engine/trigger/executor/TriggerExecutor.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.trigger.executor;\n+\n+import org.apache.iotdb.db.engine.trigger.api.Trigger;\n+import org.apache.iotdb.db.engine.trigger.api.TriggerAttributes;\n+import org.apache.iotdb.db.engine.trigger.service.TriggerClassLoader;\n+import org.apache.iotdb.db.engine.trigger.service.TriggerRegistrationInformation;\n+import org.apache.iotdb.db.exception.TriggerExecutionException;\n+import org.apache.iotdb.db.exception.TriggerManagementException;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class TriggerExecutor {\n+\n+  private final TriggerRegistrationInformation registrationInformation;\n+  private final TriggerAttributes attributes;\n+\n+  private final TriggerClassLoader classLoader;\n+\n+  private final MeasurementMNode measurementMNode;\n+  private final TSDataType seriesDataType;\n+\n+  private final Trigger trigger;\n+\n+  public TriggerExecutor(\n+      TriggerRegistrationInformation registrationInformation,\n+      TriggerClassLoader classLoader,\n+      MeasurementMNode measurementMNode)\n+      throws TriggerManagementException {\n+    this.registrationInformation = registrationInformation;\n+    attributes = new TriggerAttributes(registrationInformation.getAttributes());\n+\n+    this.classLoader = classLoader;\n+\n+    this.measurementMNode = measurementMNode;\n+    seriesDataType = measurementMNode.getSchema().getType();\n+\n+    trigger = constructTriggerInstance();\n+  }\n+\n+  private Trigger constructTriggerInstance() throws TriggerManagementException {\n+    try {\n+      Class<?> triggerClass =\n+          Class.forName(registrationInformation.getClassName(), true, classLoader);\n+      return (Trigger) triggerClass.getDeclaredConstructor().newInstance();\n+    } catch (InstantiationException\n+        | InvocationTargetException\n+        | NoSuchMethodException\n+        | IllegalAccessException\n+        | ClassNotFoundException e) {\n+      throw new TriggerManagementException(\n+          String.format(\n+              \"Failed to reflect Trigger %s(%s) instance, because %s\",\n+              registrationInformation.getTriggerName(), registrationInformation.getClassName(), e));\n+    }\n+  }\n+\n+  public void onCreate() throws TriggerExecutionException {\n+    Thread.currentThread().setContextClassLoader(classLoader);\n+\n+    try {\n+      trigger.onCreate(attributes);\n+    } catch (Exception e) {\n+      onTriggerExecutionError(\"onConfig(TriggerAttributes)\", e);\n+    }\n+\n+    registrationInformation.markAsStarted();\n+  }\n+\n+  public synchronized void onDrop() throws TriggerExecutionException {\n+    Thread.currentThread().setContextClassLoader(classLoader);\n+\n+    registrationInformation.markAsStopped();\n+\n+    try {\n+      trigger.onDrop();\n+    } catch (Exception e) {\n+      onTriggerExecutionError(\"onConfig(TriggerAttributes)\", e);\n+    }\n+  }\n+\n+  public synchronized void onStart() throws TriggerExecutionException {\n+    // The execution order of statement here cannot be swapped!\n+    invokeOnStart();\n+    registrationInformation.markAsStarted();\n+  }\n+\n+  private void invokeOnStart() throws TriggerExecutionException {\n+    Thread.currentThread().setContextClassLoader(classLoader);\n+\n+    try {\n+      trigger.onStart();\n+    } catch (Exception e) {\n+      onTriggerExecutionError(\"onStart()\", e);\n+    }\n+  }\n+\n+  public synchronized void onStop() throws TriggerExecutionException {\n+    // The execution order of statement here cannot be swapped!\n+    registrationInformation.markAsStopped();\n+    invokeOnStop();\n+  }\n+\n+  private void invokeOnStop() throws TriggerExecutionException {\n+    Thread.currentThread().setContextClassLoader(classLoader);\n+\n+    try {\n+      trigger.onStop();\n+    } catch (Exception e) {\n+      onTriggerExecutionError(\"onStop()\", e);\n+    }\n+  }\n+\n+  public void fireIfActivated(TriggerEvent event, long timestamp, Object value)\n+      throws TriggerExecutionException {\n+    if (!registrationInformation.isStopped() && event.equals(registrationInformation.getEvent())) {\n+      fire(timestamp, value);\n+    }\n+  }\n+\n+  private synchronized void fire(long timestamp, Object value) throws TriggerExecutionException {\n+    Thread.currentThread().setContextClassLoader(classLoader);\n+\n+    try {\n+      switch (seriesDataType) {\n+        case INT32:\n+          trigger.fire(timestamp, (Integer) value);\n+          break;\n+        case INT64:\n+          trigger.fire(timestamp, (Long) value);\n+          break;\n+        case FLOAT:\n+          trigger.fire(timestamp, (Float) value);\n+          break;\n+        case DOUBLE:\n+          trigger.fire(timestamp, (Double) value);\n+          break;\n+        case BOOLEAN:\n+          trigger.fire(timestamp, (Boolean) value);\n+          break;\n+        case TEXT:\n+          trigger.fire(timestamp, (Binary) value);\n+          break;\n+        default:\n+          throw new TriggerExecutionException(\"Unsupported series data type.\");\n+      }\n+    } catch (TriggerExecutionException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      onTriggerExecutionError(\"fire(long, Object)\", e);\n+    }\n+  }\n+\n+  public void fireIfActivated(TriggerEvent event, long[] timestamps, Object values)\n+      throws TriggerExecutionException {\n+    if (!registrationInformation.isStopped() && event.equals(registrationInformation.getEvent())) {\n+      fire(timestamps, values);\n+    }\n+  }\n+\n+  private synchronized void fire(long[] timestamps, Object values)\n+      throws TriggerExecutionException {\n+    Thread.currentThread().setContextClassLoader(classLoader);\n+\n+    try {\n+      switch (seriesDataType) {\n+        case INT32:\n+          trigger.fire(timestamps, (int[]) values);\n+          break;\n+        case INT64:\n+          trigger.fire(timestamps, (long[]) values);\n+          break;\n+        case FLOAT:\n+          trigger.fire(timestamps, (float[]) values);\n+          break;\n+        case DOUBLE:\n+          trigger.fire(timestamps, (double[]) values);\n+          break;\n+        case BOOLEAN:\n+          trigger.fire(timestamps, (boolean[]) values);\n+          break;\n+        case TEXT:\n+          trigger.fire(timestamps, (Binary[]) values);\n+          break;\n+        default:\n+          throw new TriggerExecutionException(\"Unsupported series data type.\");\n+      }\n+    } catch (TriggerExecutionException e) {\n+      throw e;\n+    } catch (Exception e) {\n+      onTriggerExecutionError(\"fire(long[], Object)\", e);\n+    }\n+  }\n+\n+  private void onTriggerExecutionError(String methodName, Exception e)\n+      throws TriggerExecutionException {\n+    throw new TriggerExecutionException(\n+        String.format(\n+                \"Error occurred during executing Trigger#%s: %s\",\n+                methodName, System.lineSeparator())\n+            + e);\n+  }\n+\n+  public TriggerRegistrationInformation getRegistrationInformation() {\n+    return registrationInformation;\n+  }\n+\n+  public MeasurementMNode getMeasurementMNode() {\n+    return measurementMNode;\n+  }\n+\n+  @TestOnly\n+  public Trigger getTrigger() {\n+    return trigger;\n+  }\n+}"
  },
  {
    "sha": "28303d62e0adbd52b78efb1601530dd8e92f2065",
    "filename": "server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerClassLoader.java",
    "status": "added",
    "additions": 55,
    "deletions": 0,
    "changes": 55,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerClassLoader.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerClassLoader.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerClassLoader.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.trigger.service;\n+\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.HashSet;\n+\n+public class TriggerClassLoader extends URLClassLoader {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(TriggerClassLoader.class);\n+\n+  private final String libRoot;\n+\n+  TriggerClassLoader(String libRoot) throws IOException {\n+    super(new URL[0]);\n+    this.libRoot = libRoot;\n+    LOGGER.info(\"Trigger lib root: {}\", libRoot);\n+    addURLs();\n+  }\n+\n+  private void addURLs() throws IOException {\n+    HashSet<File> fileSet =\n+        new HashSet<>(FileUtils.listFiles(SystemFileFactory.INSTANCE.getFile(libRoot), null, true));\n+    URL[] urls = FileUtils.toURLs(fileSet.toArray(new File[0]));\n+    for (URL url : urls) {\n+      super.addURL(url);\n+    }\n+  }\n+}"
  },
  {
    "sha": "ca461425864116c21108689eebdd920bb855884e",
    "filename": "server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerClassLoaderManager.java",
    "status": "added",
    "additions": 94,
    "deletions": 0,
    "changes": 94,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerClassLoaderManager.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerClassLoaderManager.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerClassLoaderManager.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.trigger.service;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.exception.TriggerManagementException;\n+import org.apache.iotdb.tsfile.utils.Pair;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/** Note: it is NOT thread safe. */\n+public class TriggerClassLoaderManager {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(TriggerClassLoaderManager.class);\n+\n+  private static final String LIB_ROOT = IoTDBDescriptor.getInstance().getConfig().getTriggerDir();\n+\n+  private final Map<String, Pair<TriggerClassLoader, Integer>> classNameToClassLoaderUsagePairMap;\n+\n+  private TriggerClassLoaderManager() {\n+    classNameToClassLoaderUsagePairMap = new HashMap<>();\n+  }\n+\n+  public TriggerClassLoader register(String className) throws TriggerManagementException {\n+    Pair<TriggerClassLoader, Integer> classLoaderUsagePair =\n+        classNameToClassLoaderUsagePairMap.get(className);\n+    if (classLoaderUsagePair == null) {\n+      try {\n+        TriggerClassLoader classLoader = new TriggerClassLoader(LIB_ROOT);\n+        classLoaderUsagePair = new Pair<>(classLoader, 0);\n+        classNameToClassLoaderUsagePairMap.put(className, classLoaderUsagePair);\n+        LOGGER.info(\n+            \"A new trigger classloader was constructed for managing trigger class {}.\", className);\n+      } catch (IOException e) {\n+        throw new TriggerManagementException(\n+            String.format(\n+                \"Failed to construct a new trigger classloader for managing trigger class %s.\",\n+                className),\n+            e);\n+      }\n+    }\n+    classLoaderUsagePair.right++;\n+    return classLoaderUsagePair.left;\n+  }\n+\n+  public void deregister(String className) {\n+    Pair<TriggerClassLoader, Integer> classLoaderUsagePair =\n+        classNameToClassLoaderUsagePairMap.get(className);\n+    classLoaderUsagePair.right--;\n+    if (classLoaderUsagePair.right == 0) {\n+      try {\n+        classLoaderUsagePair.left.close();\n+      } catch (IOException e) {\n+        LOGGER.warn(\"Failed to close a trigger classloader ({}).\", className);\n+      } finally {\n+        classNameToClassLoaderUsagePairMap.remove(className);\n+        LOGGER.info(\"A trigger classloader ({}) was removed.\", className);\n+      }\n+    }\n+  }\n+\n+  public static TriggerClassLoaderManager getInstance() {\n+    return TriggerClassLoaderManager.TriggerClassLoaderManagerHelper.INSTANCE;\n+  }\n+\n+  private static class TriggerClassLoaderManagerHelper {\n+\n+    private static final TriggerClassLoaderManager INSTANCE = new TriggerClassLoaderManager();\n+\n+    private TriggerClassLoaderManagerHelper() {}\n+  }\n+}"
  },
  {
    "sha": "4bad1f5a6f9d447494849abf083b4e27ee2f0866",
    "filename": "server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerLogReader.java",
    "status": "added",
    "additions": 48,
    "deletions": 0,
    "changes": 48,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerLogReader.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerLogReader.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerLogReader.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -0,0 +1,48 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.trigger.service;\n+\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.writelog.io.SingleFileLogReader;\n+\n+import java.io.File;\n+import java.io.IOException;\n+\n+public class TriggerLogReader implements AutoCloseable {\n+\n+  private final SingleFileLogReader logReader;\n+\n+  public TriggerLogReader(File logFile) throws IOException {\n+    logReader = new SingleFileLogReader(logFile);\n+  }\n+\n+  public boolean hasNext() {\n+    return !logReader.isFileCorrupted() && logReader.hasNext();\n+  }\n+\n+  public PhysicalPlan next() {\n+    return logReader.next();\n+  }\n+\n+  @Override\n+  public void close() {\n+    logReader.close();\n+  }\n+}"
  },
  {
    "sha": "77cbdb15f30e4349b597cf08b456a746b48214e7",
    "filename": "server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerLogWriter.java",
    "status": "added",
    "additions": 68,
    "deletions": 0,
    "changes": 68,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerLogWriter.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerLogWriter.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerLogWriter.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.trigger.service;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.writelog.io.ILogWriter;\n+import org.apache.iotdb.db.writelog.io.LogWriter;\n+\n+import org.apache.commons.io.FileUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+\n+public class TriggerLogWriter implements AutoCloseable {\n+\n+  private final ByteBuffer logBuffer;\n+  private final File logFile;\n+  private final ILogWriter logWriter;\n+\n+  public TriggerLogWriter(String logFilePath) throws IOException {\n+    logBuffer = ByteBuffer.allocate(IoTDBDescriptor.getInstance().getConfig().getMlogBufferSize());\n+    logFile = SystemFileFactory.INSTANCE.getFile(logFilePath);\n+    logWriter = new LogWriter(logFile, false);\n+  }\n+\n+  public synchronized void write(PhysicalPlan plan) throws IOException {\n+    try {\n+      plan.serialize(logBuffer);\n+      logWriter.write(logBuffer);\n+    } catch (BufferOverflowException e) {\n+      throw new IOException(\n+          \"Current trigger management operation plan is too large to write into buffer, please increase tlog_buffer_size.\",\n+          e);\n+    } finally {\n+      logBuffer.clear();\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    logWriter.close();\n+  }\n+\n+  public void deleteLogFile() throws IOException {\n+    FileUtils.forceDelete(logFile);\n+  }\n+}"
  },
  {
    "sha": "12d03432e979f7fa83780d7584fcb5039e53e58f",
    "filename": "server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerRegistrationInformation.java",
    "status": "added",
    "additions": 82,
    "deletions": 0,
    "changes": 82,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerRegistrationInformation.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerRegistrationInformation.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerRegistrationInformation.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.trigger.service;\n+\n+import org.apache.iotdb.db.engine.trigger.executor.TriggerEvent;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTriggerPlan;\n+\n+import java.util.Map;\n+\n+public class TriggerRegistrationInformation {\n+\n+  private final String triggerName;\n+  private final TriggerEvent event;\n+  private final PartialPath fullPath;\n+  private final String className;\n+  private final Map<String, String> attributes;\n+\n+  private volatile boolean isStopped;\n+\n+  public TriggerRegistrationInformation(CreateTriggerPlan plan) {\n+    this.triggerName = plan.getTriggerName();\n+    this.event = plan.getEvent();\n+    this.fullPath = plan.getFullPath();\n+    this.className = plan.getClassName();\n+    this.attributes = plan.getAttributes();\n+    this.isStopped = plan.isStopped();\n+  }\n+\n+  public CreateTriggerPlan convertToCreateTriggerPlan() {\n+    return new CreateTriggerPlan(triggerName, event, fullPath, className, attributes);\n+  }\n+\n+  public void markAsStarted() {\n+    isStopped = false;\n+  }\n+\n+  public void markAsStopped() {\n+    isStopped = true;\n+  }\n+\n+  public String getTriggerName() {\n+    return triggerName;\n+  }\n+\n+  public TriggerEvent getEvent() {\n+    return event;\n+  }\n+\n+  public PartialPath getFullPath() {\n+    return fullPath;\n+  }\n+\n+  public String getClassName() {\n+    return className;\n+  }\n+\n+  public Map<String, String> getAttributes() {\n+    return attributes;\n+  }\n+\n+  public boolean isStopped() {\n+    return isStopped;\n+  }\n+}"
  },
  {
    "sha": "b6675e9a3ddc067259a75cf80ddc32c79521303b",
    "filename": "server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerRegistrationService.java",
    "status": "added",
    "additions": 447,
    "deletions": 0,
    "changes": 447,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerRegistrationService.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerRegistrationService.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/engine/trigger/service/TriggerRegistrationService.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -0,0 +1,447 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.trigger.service;\n+\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n+import org.apache.iotdb.db.engine.trigger.api.Trigger;\n+import org.apache.iotdb.db.engine.trigger.executor.TriggerExecutor;\n+import org.apache.iotdb.db.exception.StartupException;\n+import org.apache.iotdb.db.exception.TriggerExecutionException;\n+import org.apache.iotdb.db.exception.TriggerManagementException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.metadata.mnode.MeasurementMNode;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTriggerPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DropTriggerPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StartTriggerPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StopTriggerPlan;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.service.IService;\n+import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.ServiceType;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TRIGGER_ATTRIBUTES;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TRIGGER_CLASS;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TRIGGER_EVENT;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TRIGGER_NAME;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TRIGGER_PATH;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TRIGGER_STATUS;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TRIGGER_STATUS_STARTED;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TRIGGER_STATUS_STOPPED;\n+\n+public class TriggerRegistrationService implements IService {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(TriggerRegistrationService.class);\n+\n+  private static final String LOG_FILE_DIR =\n+      IoTDBDescriptor.getInstance().getConfig().getSystemDir()\n+          + File.separator\n+          + \"trigger\"\n+          + File.separator;\n+  private static final String LOG_FILE_NAME = LOG_FILE_DIR + \"tlog.bin\";\n+  private static final String TEMPORARY_LOG_FILE_NAME = LOG_FILE_NAME + \".tmp\";\n+\n+  private static final String LIB_ROOT = IoTDBDescriptor.getInstance().getConfig().getTriggerDir();\n+\n+  private final ConcurrentHashMap<String, TriggerExecutor> executors;\n+\n+  private TriggerLogWriter logWriter;\n+\n+  private TriggerRegistrationService() {\n+    executors = new ConcurrentHashMap<>();\n+  }\n+\n+  public synchronized void register(CreateTriggerPlan plan)\n+      throws TriggerManagementException, TriggerExecutionException {\n+    checkIfRegistered(plan);\n+    MeasurementMNode measurementMNode = tryGetMeasurementMNode(plan);\n+    tryAppendRegistrationLog(plan);\n+    doRegister(plan, measurementMNode);\n+  }\n+\n+  private void checkIfRegistered(CreateTriggerPlan plan) throws TriggerManagementException {\n+    TriggerExecutor executor = executors.get(plan.getTriggerName());\n+    if (executor == null) {\n+      return;\n+    }\n+\n+    TriggerRegistrationInformation information = executor.getRegistrationInformation();\n+    throw new TriggerManagementException(\n+        information.getClassName().equals(plan.getClassName())\n+            ? String.format(\n+                \"Failed to register trigger %s(%s), because a trigger with the same trigger name and the class name has already been registered.\",\n+                plan.getTriggerName(), plan.getClassName())\n+            : String.format(\n+                \"Failed to register trigger %s(%s), because a trigger %s(%s) with the same trigger name but a different class name has already been registered.\",\n+                plan.getTriggerName(),\n+                plan.getClassName(),\n+                information.getTriggerName(),\n+                information.getClassName()));\n+  }\n+\n+  private MeasurementMNode tryGetMeasurementMNode(CreateTriggerPlan plan)\n+      throws TriggerManagementException {\n+    try {\n+      return (MeasurementMNode) IoTDB.metaManager.getNodeByPath(plan.getFullPath());\n+    } catch (MetadataException e) {\n+      throw new TriggerManagementException(e.getMessage(), e);\n+    } catch (ClassCastException e) {\n+      throw new TriggerManagementException(\"Triggers can only be registered on MeasurementMNode.\");\n+    }\n+  }\n+\n+  private void tryAppendRegistrationLog(CreateTriggerPlan plan) throws TriggerManagementException {\n+    try {\n+      logWriter.write(plan);\n+    } catch (IOException e) {\n+      throw new TriggerManagementException(\n+          String.format(\n+              \"Failed to append trigger management operation log when registering trigger %s(%s), because %s\",\n+              plan.getTriggerName(), plan.getClassName(), e));\n+    }\n+  }\n+\n+  private void doRegister(CreateTriggerPlan plan, MeasurementMNode measurementMNode)\n+      throws TriggerManagementException, TriggerExecutionException {\n+    TriggerRegistrationInformation information = new TriggerRegistrationInformation(plan);\n+    TriggerClassLoader classLoader =\n+        TriggerClassLoaderManager.getInstance().register(plan.getClassName());\n+\n+    TriggerExecutor executor;\n+    try {\n+      executor = new TriggerExecutor(information, classLoader, measurementMNode);\n+      executor.onCreate();\n+    } catch (TriggerManagementException | TriggerExecutionException e) {\n+      TriggerClassLoaderManager.getInstance().deregister(plan.getClassName());\n+      throw e;\n+    }\n+\n+    executors.put(plan.getTriggerName(), executor);\n+    measurementMNode.setTriggerExecutor(executor);\n+  }\n+\n+  public synchronized void deregister(DropTriggerPlan plan) throws TriggerManagementException {\n+    getTriggerExecutorWithExistenceCheck(plan.getTriggerName());\n+    tryAppendDeregistrationLog(plan);\n+    doDeregister(plan);\n+  }\n+\n+  private TriggerExecutor getTriggerExecutorWithExistenceCheck(String triggerName)\n+      throws TriggerManagementException {\n+    TriggerExecutor executor = executors.get(triggerName);\n+\n+    if (executor == null) {\n+      throw new TriggerManagementException(\n+          String.format(\"Trigger %s does not exist.\", triggerName));\n+    }\n+\n+    return executor;\n+  }\n+\n+  private void tryAppendDeregistrationLog(DropTriggerPlan plan) throws TriggerManagementException {\n+    try {\n+      logWriter.write(plan);\n+    } catch (IOException e) {\n+      throw new TriggerManagementException(\n+          String.format(\n+              \"Failed to drop trigger %s because the operation plan was failed to log: %s\",\n+              plan.getTriggerName(), e));\n+    }\n+  }\n+\n+  private void doDeregister(DropTriggerPlan plan) {\n+    TriggerExecutor executor = executors.remove(plan.getTriggerName());\n+    executor.getMeasurementMNode().setTriggerExecutor(null);\n+\n+    try {\n+      executor.onDrop();\n+    } catch (TriggerExecutionException e) {\n+      LOGGER.warn(e.getMessage(), e);\n+    }\n+\n+    TriggerClassLoaderManager.getInstance()\n+        .deregister(executor.getRegistrationInformation().getClassName());\n+  }\n+\n+  public void activate(StartTriggerPlan plan)\n+      throws TriggerManagementException, TriggerExecutionException {\n+    TriggerExecutor executor = getTriggerExecutorWithExistenceCheck(plan.getTriggerName());\n+\n+    if (!executor.getRegistrationInformation().isStopped()) {\n+      throw new TriggerManagementException(\n+          String.format(\"Trigger %s has already been started.\", plan.getTriggerName()));\n+    }\n+\n+    try {\n+      logWriter.write(plan);\n+    } catch (IOException e) {\n+      throw new TriggerManagementException(\n+          String.format(\n+              \"Failed to append trigger management operation log when starting trigger %s, because %s\",\n+              plan.getTriggerName(), e));\n+    }\n+\n+    executor.onStart();\n+  }\n+\n+  public void inactivate(StopTriggerPlan plan) throws TriggerManagementException {\n+    TriggerExecutor executor = getTriggerExecutorWithExistenceCheck(plan.getTriggerName());\n+\n+    if (executor.getRegistrationInformation().isStopped()) {\n+      throw new TriggerManagementException(\n+          String.format(\"Trigger %s has already been stopped.\", plan.getTriggerName()));\n+    }\n+\n+    try {\n+      logWriter.write(plan);\n+    } catch (IOException e) {\n+      throw new TriggerManagementException(\n+          String.format(\n+              \"Failed to append trigger management operation log when stopping trigger %s, because %s\",\n+              plan.getTriggerName(), e));\n+    }\n+\n+    try {\n+      executor.onStop();\n+    } catch (TriggerExecutionException e) {\n+      LOGGER.warn(\n+          \"Failed to stop the executor of trigger {}({})\",\n+          executor.getRegistrationInformation().getTriggerName(),\n+          executor.getRegistrationInformation().getClassName(),\n+          e);\n+    }\n+  }\n+\n+  public QueryDataSet show() {\n+    ListDataSet dataSet =\n+        new ListDataSet(\n+            Arrays.asList(\n+                new PartialPath(COLUMN_TRIGGER_NAME, false),\n+                new PartialPath(COLUMN_TRIGGER_STATUS, false),\n+                new PartialPath(COLUMN_TRIGGER_EVENT, false),\n+                new PartialPath(COLUMN_TRIGGER_PATH, false),\n+                new PartialPath(COLUMN_TRIGGER_CLASS, false),\n+                new PartialPath(COLUMN_TRIGGER_ATTRIBUTES, false)),\n+            Arrays.asList(\n+                TSDataType.TEXT,\n+                TSDataType.TEXT,\n+                TSDataType.TEXT,\n+                TSDataType.TEXT,\n+                TSDataType.TEXT,\n+                TSDataType.TEXT));\n+    putTriggerRecords(dataSet);\n+    return dataSet;\n+  }\n+\n+  private void putTriggerRecords(ListDataSet dataSet) {\n+    for (TriggerExecutor executor : executors.values().toArray(new TriggerExecutor[0])) {\n+      TriggerRegistrationInformation information = executor.getRegistrationInformation();\n+\n+      RowRecord rowRecord = new RowRecord(0); // ignore timestamp\n+      rowRecord.addField(Binary.valueOf(information.getTriggerName()), TSDataType.TEXT);\n+      rowRecord.addField(\n+          Binary.valueOf(\n+              information.isStopped()\n+                  ? COLUMN_TRIGGER_STATUS_STOPPED\n+                  : COLUMN_TRIGGER_STATUS_STARTED),\n+          TSDataType.TEXT);\n+      rowRecord.addField(Binary.valueOf(information.getEvent().toString()), TSDataType.TEXT);\n+      rowRecord.addField(Binary.valueOf(information.getFullPath().getFullPath()), TSDataType.TEXT);\n+      rowRecord.addField(Binary.valueOf(information.getClassName()), TSDataType.TEXT);\n+      rowRecord.addField(Binary.valueOf(information.getAttributes().toString()), TSDataType.TEXT);\n+      dataSet.putRecord(rowRecord);\n+    }\n+  }\n+\n+  @Override\n+  public void start() throws StartupException {\n+    try {\n+      makeDirIfNecessary(LIB_ROOT);\n+      makeDirIfNecessary(LOG_FILE_DIR);\n+      doRecovery();\n+      logWriter = new TriggerLogWriter(LOG_FILE_NAME);\n+    } catch (Exception e) {\n+      throw new StartupException(e);\n+    }\n+  }\n+\n+  private static void makeDirIfNecessary(String dir) throws IOException {\n+    File file = SystemFileFactory.INSTANCE.getFile(dir);\n+    if (file.exists() && file.isDirectory()) {\n+      return;\n+    }\n+    FileUtils.forceMkdir(file);\n+  }\n+\n+  private void doRecovery() throws IOException, TriggerManagementException {\n+    File temporaryLogFile = SystemFileFactory.INSTANCE.getFile(TEMPORARY_LOG_FILE_NAME);\n+    File logFile = SystemFileFactory.INSTANCE.getFile(LOG_FILE_NAME);\n+\n+    if (temporaryLogFile.exists()) {\n+      if (logFile.exists()) {\n+        doRecoveryFromLogFile(logFile);\n+        FileUtils.deleteQuietly(temporaryLogFile);\n+      } else {\n+        doRecoveryFromLogFile(temporaryLogFile);\n+        FSFactoryProducer.getFSFactory().moveFile(temporaryLogFile, logFile);\n+      }\n+    } else if (logFile.exists()) {\n+      doRecoveryFromLogFile(logFile);\n+    }\n+  }\n+\n+  private void doRecoveryFromLogFile(File logFile) throws IOException, TriggerManagementException {\n+    for (CreateTriggerPlan createTriggerPlan : recoverCreateTriggerPlans(logFile)) {\n+      try {\n+        doRegister(createTriggerPlan, tryGetMeasurementMNode(createTriggerPlan));\n+        if (createTriggerPlan.isStopped()) {\n+          executors.get(createTriggerPlan.getTriggerName()).onStop();\n+        }\n+      } catch (TriggerExecutionException | TriggerManagementException e) {\n+        LOGGER.error(\n+            \"Failed to register the trigger {}({}) during recovering.\",\n+            createTriggerPlan.getTriggerName(),\n+            createTriggerPlan.getClassName());\n+      }\n+    }\n+  }\n+\n+  private Collection<CreateTriggerPlan> recoverCreateTriggerPlans(File logFile)\n+      throws IOException, TriggerManagementException {\n+    Map<String, CreateTriggerPlan> recoveredCreateTriggerPlans = new HashMap<>();\n+\n+    try (TriggerLogReader reader = new TriggerLogReader(logFile)) {\n+      while (reader.hasNext()) {\n+        PhysicalPlan plan = reader.next();\n+        CreateTriggerPlan createTriggerPlan;\n+        switch (plan.getOperatorType()) {\n+          case CREATE_TRIGGER:\n+            recoveredCreateTriggerPlans.put(\n+                ((CreateTriggerPlan) plan).getTriggerName(), (CreateTriggerPlan) plan);\n+            break;\n+          case DROP_TRIGGER:\n+            recoveredCreateTriggerPlans.remove(((DropTriggerPlan) plan).getTriggerName());\n+            break;\n+          case START_TRIGGER:\n+            createTriggerPlan =\n+                recoveredCreateTriggerPlans.get(((StartTriggerPlan) plan).getTriggerName());\n+            if (createTriggerPlan != null) {\n+              createTriggerPlan.markAsStarted();\n+            }\n+            break;\n+          case STOP_TRIGGER:\n+            createTriggerPlan =\n+                recoveredCreateTriggerPlans.get(((StopTriggerPlan) plan).getTriggerName());\n+            if (createTriggerPlan != null) {\n+              createTriggerPlan.markAsStopped();\n+            }\n+            break;\n+          default:\n+            throw new TriggerManagementException(\n+                \"Unrecognized trigger management operation plan is recovered.\");\n+        }\n+      }\n+    }\n+\n+    return recoveredCreateTriggerPlans.values();\n+  }\n+\n+  @Override\n+  public void stop() {\n+    try {\n+      writeTemporaryLogFile();\n+\n+      logWriter.close();\n+      logWriter.deleteLogFile();\n+\n+      File temporaryLogFile = SystemFileFactory.INSTANCE.getFile(TEMPORARY_LOG_FILE_NAME);\n+      File logFile = SystemFileFactory.INSTANCE.getFile(LOG_FILE_NAME);\n+      FSFactoryProducer.getFSFactory().moveFile(temporaryLogFile, logFile);\n+    } catch (IOException ignored) {\n+      // ignored\n+    }\n+  }\n+\n+  private void writeTemporaryLogFile() throws IOException {\n+    try (TriggerLogWriter temporaryLogWriter = new TriggerLogWriter(TEMPORARY_LOG_FILE_NAME)) {\n+      for (TriggerExecutor executor : executors.values()) {\n+        TriggerRegistrationInformation information = executor.getRegistrationInformation();\n+        temporaryLogWriter.write(information.convertToCreateTriggerPlan());\n+        if (information.isStopped()) {\n+          temporaryLogWriter.write(new StopTriggerPlan(information.getTriggerName()));\n+        }\n+      }\n+    }\n+  }\n+\n+  @TestOnly\n+  public void deregisterAll() throws TriggerManagementException {\n+    for (TriggerExecutor executor : executors.values()) {\n+      deregister(new DropTriggerPlan(executor.getRegistrationInformation().getTriggerName()));\n+    }\n+  }\n+\n+  @TestOnly\n+  public Trigger getTriggerInstance(String triggerName) throws TriggerManagementException {\n+    return getTriggerExecutorWithExistenceCheck(triggerName).getTrigger();\n+  }\n+\n+  @TestOnly\n+  public TriggerRegistrationInformation getRegistrationInformation(String triggerName)\n+      throws TriggerManagementException {\n+    return getTriggerExecutorWithExistenceCheck(triggerName).getRegistrationInformation();\n+  }\n+\n+  @Override\n+  public ServiceType getID() {\n+    return ServiceType.TRIGGER_REGISTRATION_SERVICE;\n+  }\n+\n+  public static TriggerRegistrationService getInstance() {\n+    return TriggerRegistrationService.TriggerRegistrationServiceHelper.INSTANCE;\n+  }\n+\n+  private static class TriggerRegistrationServiceHelper {\n+\n+    private static final TriggerRegistrationService INSTANCE = new TriggerRegistrationService();\n+\n+    private TriggerRegistrationServiceHelper() {}\n+  }\n+}"
  },
  {
    "sha": "ac3684be22ea8553fd6a660c5912691218707af9",
    "filename": "server/src/main/java/org/apache/iotdb/db/exception/TriggerExecutionException.java",
    "status": "renamed",
    "additions": 7,
    "deletions": 10,
    "changes": 17,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/exception/TriggerExecutionException.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/exception/TriggerExecutionException.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/exception/TriggerExecutionException.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -17,19 +17,16 @@\n  * under the License.\n  */\n \n-package org.apache.iotdb.db.engine.trigger.api;\n+package org.apache.iotdb.db.exception;\n \n-public enum TriggerEvent {\n-  BEFORE_INSERT((byte) 0),\n-  AFTER_INSERT((byte) 1);\n+public class TriggerExecutionException extends StorageEngineException {\n \n-  private final byte id;\n-\n-  TriggerEvent(byte id) {\n-    this.id = id;\n+  public TriggerExecutionException(String message, Throwable cause) {\n+    super(message);\n+    this.initCause(cause);\n   }\n \n-  public byte getId() {\n-    return id;\n+  public TriggerExecutionException(String message) {\n+    super(message);\n   }\n }",
    "previous_filename": "server/src/main/java/org/apache/iotdb/db/engine/trigger/api/TriggerEvent.java"
  },
  {
    "sha": "2565f1138279cb6141b74fb835b76a6385aec865",
    "filename": "server/src/main/java/org/apache/iotdb/db/exception/TriggerManagementException.java",
    "status": "added",
    "additions": 32,
    "deletions": 0,
    "changes": 32,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/exception/TriggerManagementException.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/exception/TriggerManagementException.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/exception/TriggerManagementException.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.exception;\n+\n+public class TriggerManagementException extends StorageEngineException {\n+\n+  public TriggerManagementException(String message, Throwable cause) {\n+    super(message);\n+    this.initCause(cause);\n+  }\n+\n+  public TriggerManagementException(String message) {\n+    super(message);\n+  }\n+}"
  },
  {
    "sha": "74617f77403365ed9c8d55f5aed5c0bce6adbdd9",
    "filename": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java",
    "status": "modified",
    "additions": 9,
    "deletions": 2,
    "changes": 11,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/metadata/MManager.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -23,6 +23,7 @@\n import org.apache.iotdb.db.engine.StorageEngine;\n import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.engine.storagegroup.StorageGroupProcessor;\n+import org.apache.iotdb.db.engine.trigger.executor.TriggerEngine;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.AliasAlreadyExistException;\n import org.apache.iotdb.db.exception.metadata.DataTypeMismatchException;\n@@ -512,7 +513,7 @@ private void deleteSingleTimeseriesInternal(PartialPath p, Set<String> failedNam\n       throws MetadataException, IOException {\n     DeleteTimeSeriesPlan deleteTimeSeriesPlan = new DeleteTimeSeriesPlan();\n     try {\n-      PartialPath emptyStorageGroup = deleteOneTimeseriesAndUpdateStatistics(p);\n+      PartialPath emptyStorageGroup = deleteOneTimeseriesUpdateStatisticsAndDropTrigger(p);\n       if (!isRecovering) {\n         if (emptyStorageGroup != null) {\n           StorageEngine.getInstance().deleteAllDataFilesInOneStorageGroup(emptyStorageGroup);\n@@ -573,7 +574,7 @@ private void removeFromTagInvertedIndex(MeasurementMNode node) throws IOExceptio\n    * @param path full path from root to leaf node\n    * @return after delete if the storage group is empty, return its path, otherwise return null\n    */\n-  private PartialPath deleteOneTimeseriesAndUpdateStatistics(PartialPath path)\n+  private PartialPath deleteOneTimeseriesUpdateStatisticsAndDropTrigger(PartialPath path)\n       throws MetadataException, IOException {\n     Pair<PartialPath, MeasurementMNode> pair =\n         mtree.deleteTimeseriesAndReturnEmptyStorageGroup(path);\n@@ -583,6 +584,9 @@ private PartialPath deleteOneTimeseriesAndUpdateStatistics(PartialPath path)\n     // update statistics in schemaDataTypeNumMap\n     updateSchemaDataTypeNumMap(pair.right.getSchema().getType(), -1);\n \n+    // drop trigger with no exceptions\n+    TriggerEngine.drop(pair.right);\n+\n     // TODO: delete the path node and all its ancestors\n     mNodeCache.clear();\n     totalSeriesNumber.addAndGet(-1);\n@@ -638,6 +642,9 @@ public void deleteStorageGroups(List<PartialPath> storageGroups) throws Metadata\n           updateSchemaDataTypeNumMap(leafMNode.getSchema().getType(), -1);\n         }\n \n+        // drop triggers with no exceptions\n+        TriggerEngine.drop(leafMNodes);\n+\n         if (!config.isEnableMemControl()) {\n           MemTableManager.getInstance().addOrDeleteStorageGroup(-1);\n         }"
  },
  {
    "sha": "ad898d5bc59393554b4e9df2e54c8e9738cba5c9",
    "filename": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MeasurementMNode.java",
    "status": "modified",
    "additions": 11,
    "deletions": 0,
    "changes": 11,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MeasurementMNode.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MeasurementMNode.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/metadata/mnode/MeasurementMNode.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -18,6 +18,7 @@\n  */\n package org.apache.iotdb.db.metadata.mnode;\n \n+import org.apache.iotdb.db.engine.trigger.executor.TriggerExecutor;\n import org.apache.iotdb.db.metadata.logfile.MLogWriter;\n import org.apache.iotdb.db.qp.physical.sys.MeasurementMNodePlan;\n import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n@@ -44,6 +45,8 @@\n \n   private TimeValuePair cachedLastValuePair = null;\n \n+  private TriggerExecutor triggerExecutor = null;\n+\n   /** @param alias alias of measurementName */\n   public MeasurementMNode(\n       MNode parent,\n@@ -115,6 +118,10 @@ public String getAlias() {\n     return alias;\n   }\n \n+  public TriggerExecutor getTriggerExecutor() {\n+    return triggerExecutor;\n+  }\n+\n   public void setAlias(String alias) {\n     this.alias = alias;\n   }\n@@ -123,6 +130,10 @@ public void setSchema(MeasurementSchema schema) {\n     this.schema = schema;\n   }\n \n+  public void setTriggerExecutor(TriggerExecutor triggerExecutor) {\n+    this.triggerExecutor = triggerExecutor;\n+  }\n+\n   @Override\n   public void serializeTo(MLogWriter logWriter) throws IOException {\n     serializeChildren(logWriter);"
  },
  {
    "sha": "b8b4a61c18e314cbecf4645414ae48e14245b380",
    "filename": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java",
    "status": "modified",
    "additions": 20,
    "deletions": 33,
    "changes": 53,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -35,9 +35,12 @@\n import org.apache.iotdb.db.engine.merge.manage.MergeManager.TaskStatus;\n import org.apache.iotdb.db.engine.storagegroup.StorageGroupProcessor.TimePartitionFilter;\n import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.engine.trigger.service.TriggerRegistrationService;\n import org.apache.iotdb.db.exception.BatchProcessException;\n import org.apache.iotdb.db.exception.QueryIdNotExsitException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.TriggerExecutionException;\n+import org.apache.iotdb.db.exception.TriggerManagementException;\n import org.apache.iotdb.db.exception.UDFRegistrationException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n@@ -99,7 +102,6 @@\n import org.apache.iotdb.db.qp.physical.sys.ShowStorageGroupPlan;\n import org.apache.iotdb.db.qp.physical.sys.ShowTTLPlan;\n import org.apache.iotdb.db.qp.physical.sys.ShowTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ShowTriggersPlan;\n import org.apache.iotdb.db.qp.physical.sys.StartTriggerPlan;\n import org.apache.iotdb.db.qp.physical.sys.StopTriggerPlan;\n import org.apache.iotdb.db.qp.physical.sys.TracingPlan;\n@@ -168,12 +170,6 @@\n import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_ROLE;\n import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_STORAGE_GROUP;\n import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TASK_NAME;\n-import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TRIGGER_ATTRIBUTES;\n-import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TRIGGER_CLASS;\n-import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TRIGGER_EVENT;\n-import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TRIGGER_NAME;\n-import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TRIGGER_PATH;\n-import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TRIGGER_STATUS;\n import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TTL;\n import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_USER;\n import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n@@ -186,7 +182,6 @@\n import static org.apache.iotdb.db.conf.IoTDBConstant.STATEMENT;\n import static org.apache.iotdb.tsfile.common.constant.TsFileConstant.TSFILE_SUFFIX;\n \n-@SuppressWarnings(\"java:S1135\") // ignore todos\n public class PlanExecutor implements IPlanExecutor {\n \n   // for data query\n@@ -352,20 +347,26 @@ private boolean operateDropFunction(DropFunctionPlan plan) throws UDFRegistratio\n     return true;\n   }\n \n-  private boolean operateCreateTrigger(CreateTriggerPlan plan) {\n-    return false;\n+  private boolean operateCreateTrigger(CreateTriggerPlan plan)\n+      throws TriggerManagementException, TriggerExecutionException {\n+    TriggerRegistrationService.getInstance().register(plan);\n+    return true;\n   }\n \n-  private boolean operateDropTrigger(DropTriggerPlan plan) {\n-    return false;\n+  private boolean operateDropTrigger(DropTriggerPlan plan) throws TriggerManagementException {\n+    TriggerRegistrationService.getInstance().deregister(plan);\n+    return true;\n   }\n \n-  private boolean operateStartTrigger(StartTriggerPlan plan) {\n-    return false;\n+  private boolean operateStartTrigger(StartTriggerPlan plan)\n+      throws TriggerManagementException, TriggerExecutionException {\n+    TriggerRegistrationService.getInstance().activate(plan);\n+    return true;\n   }\n \n-  private boolean operateStopTrigger(StopTriggerPlan plan) {\n-    return false;\n+  private boolean operateStopTrigger(StopTriggerPlan plan) throws TriggerManagementException {\n+    TriggerRegistrationService.getInstance().inactivate(plan);\n+    return true;\n   }\n \n   private void operateMerge(MergePlan plan) throws StorageEngineException {\n@@ -538,7 +539,7 @@ protected QueryDataSet processShowQuery(ShowPlan showPlan, QueryContext context)\n       case FUNCTIONS:\n         return processShowFunctions((ShowFunctionsPlan) showPlan);\n       case TRIGGERS:\n-        return processShowTriggers((ShowTriggersPlan) showPlan);\n+        return processShowTriggers();\n       default:\n         throw new QueryProcessException(String.format(\"Unrecognized show plan %s\", showPlan));\n     }\n@@ -875,22 +876,8 @@ private void appendNativeFunctions(ListDataSet listDataSet, ShowFunctionsPlan sh\n     }\n   }\n \n-  private QueryDataSet processShowTriggers(ShowTriggersPlan showPlan) {\n-    return new ListDataSet(\n-        Arrays.asList(\n-            new PartialPath(COLUMN_TRIGGER_NAME, false),\n-            new PartialPath(COLUMN_TRIGGER_STATUS, false),\n-            new PartialPath(COLUMN_TRIGGER_EVENT, false),\n-            new PartialPath(COLUMN_TRIGGER_PATH, false),\n-            new PartialPath(COLUMN_TRIGGER_CLASS, false),\n-            new PartialPath(COLUMN_TRIGGER_ATTRIBUTES, false)),\n-        Arrays.asList(\n-            TSDataType.TEXT,\n-            TSDataType.TEXT,\n-            TSDataType.TEXT,\n-            TSDataType.TEXT,\n-            TSDataType.TEXT,\n-            TSDataType.TEXT));\n+  private QueryDataSet processShowTriggers() {\n+    return TriggerRegistrationService.getInstance().show();\n   }\n \n   private void addRowRecordForShowQuery("
  },
  {
    "sha": "144168897d01b91fa75ff16cefeaf86d6965b457",
    "filename": "server/src/main/java/org/apache/iotdb/db/qp/logical/sys/CreateTriggerOperator.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/qp/logical/sys/CreateTriggerOperator.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/qp/logical/sys/CreateTriggerOperator.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/qp/logical/sys/CreateTriggerOperator.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -19,7 +19,7 @@\n \n package org.apache.iotdb.db.qp.logical.sys;\n \n-import org.apache.iotdb.db.engine.trigger.api.TriggerEvent;\n+import org.apache.iotdb.db.engine.trigger.executor.TriggerEvent;\n import org.apache.iotdb.db.metadata.PartialPath;\n import org.apache.iotdb.db.qp.logical.RootOperator;\n "
  },
  {
    "sha": "d54f4e7ec844ad5949c6dcd717c066427a293958",
    "filename": "server/src/main/java/org/apache/iotdb/db/qp/logical/sys/ShowTriggersOperator.java",
    "status": "modified",
    "additions": 0,
    "deletions": 12,
    "changes": 12,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/qp/logical/sys/ShowTriggersOperator.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/qp/logical/sys/ShowTriggersOperator.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/qp/logical/sys/ShowTriggersOperator.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -19,21 +19,9 @@\n \n package org.apache.iotdb.db.qp.logical.sys;\n \n-import org.apache.iotdb.db.metadata.PartialPath;\n-\n public class ShowTriggersOperator extends ShowOperator {\n \n-  private PartialPath path;\n-\n   public ShowTriggersOperator(int tokenIntType) {\n     super(tokenIntType);\n   }\n-\n-  public void setPath(PartialPath path) {\n-    this.path = path;\n-  }\n-\n-  public PartialPath getPath() {\n-    return path;\n-  }\n }"
  },
  {
    "sha": "7c5a90a8aa5951e4969c3582257a54b9323562b4",
    "filename": "server/src/main/java/org/apache/iotdb/db/qp/physical/PhysicalPlan.java",
    "status": "modified",
    "additions": 22,
    "deletions": 37,
    "changes": 59,
    "blob_url": "https://github.com/apache/iotdb/blob/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/qp/physical/PhysicalPlan.java",
    "raw_url": "https://github.com/apache/iotdb/raw/10f277cc5e0a63e15ed1ce657720fc7b188c9f42/server/src/main/java/org/apache/iotdb/db/qp/physical/PhysicalPlan.java",
    "contents_url": "https://api.github.com/repos/apache/iotdb/contents/server/src/main/java/org/apache/iotdb/db/qp/physical/PhysicalPlan.java?ref=10f277cc5e0a63e15ed1ce657720fc7b188c9f42",
    "patch": "@@ -35,10 +35,12 @@\n import org.apache.iotdb.db.qp.physical.sys.CreateIndexPlan;\n import org.apache.iotdb.db.qp.physical.sys.CreateMultiTimeSeriesPlan;\n import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.CreateTriggerPlan;\n import org.apache.iotdb.db.qp.physical.sys.DataAuthPlan;\n import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n import org.apache.iotdb.db.qp.physical.sys.DropIndexPlan;\n+import org.apache.iotdb.db.qp.physical.sys.DropTriggerPlan;\n import org.apache.iotdb.db.qp.physical.sys.FlushPlan;\n import org.apache.iotdb.db.qp.physical.sys.LoadConfigurationPlan;\n import org.apache.iotdb.db.qp.physical.sys.MNodePlan;\n@@ -47,6 +49,8 @@\n import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n import org.apache.iotdb.db.qp.physical.sys.ShowDevicesPlan;\n import org.apache.iotdb.db.qp.physical.sys.ShowTimeSeriesPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StartTriggerPlan;\n+import org.apache.iotdb.db.qp.physical.sys.StopTriggerPlan;\n import org.apache.iotdb.db.qp.physical.sys.StorageGroupMNodePlan;\n import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n \n@@ -216,151 +220,128 @@ public static PhysicalPlan create(ByteBuffer buffer) throws IOException, Illegal\n       switch (type) {\n         case INSERT:\n           plan = new InsertRowPlan();\n-          plan.deserialize(buffer);\n           break;\n         case BATCHINSERT:\n           plan = new InsertTabletPlan();\n-          plan.deserialize(buffer);\n           break;\n         case MULTI_BATCH_INSERT:\n           plan = new InsertMultiTabletPlan();\n-          plan.deserialize(buffer);\n           break;\n         case DELETE:\n           plan = new DeletePlan();\n-          plan.deserialize(buffer);\n           break;\n         case SET_STORAGE_GROUP:\n           plan = new SetStorageGroupPlan();\n-          plan.deserialize(buffer);\n           break;\n         case CREATE_TIMESERIES:\n           plan = new CreateTimeSeriesPlan();\n-          plan.deserialize(buffer);\n           break;\n         case DELETE_TIMESERIES:\n           plan = new DeleteTimeSeriesPlan();\n-          plan.deserialize(buffer);\n           break;\n         case CREATE_INDEX:\n           plan = new CreateIndexPlan();\n-          plan.deserialize(buffer);\n           break;\n         case DROP_INDEX:\n           plan = new DropIndexPlan();\n-          plan.deserialize(buffer);\n           break;\n         case TTL:\n           plan = new SetTTLPlan();\n-          plan.deserialize(buffer);\n           break;\n         case GRANT_WATERMARK_EMBEDDING:\n           plan = new DataAuthPlan(OperatorType.GRANT_WATERMARK_EMBEDDING);\n-          plan.deserialize(buffer);\n           break;\n         case REVOKE_WATERMARK_EMBEDDING:\n           plan = new DataAuthPlan(OperatorType.REVOKE_WATERMARK_EMBEDDING);\n-          plan.deserialize(buffer);\n           break;\n         case CREATE_ROLE:\n           plan = new AuthorPlan(OperatorType.CREATE_ROLE);\n-          plan.deserialize(buffer);\n           break;\n         case DELETE_ROLE:\n           plan = new AuthorPlan(OperatorType.DELETE_ROLE);\n-          plan.deserialize(buffer);\n           break;\n         case CREATE_USER:\n           plan = new AuthorPlan(OperatorType.CREATE_USER);\n-          plan.deserialize(buffer);\n           break;\n         case REVOKE_USER_ROLE:\n           plan = new AuthorPlan(OperatorType.REVOKE_USER_ROLE);\n-          plan.deserialize(buffer);\n           break;\n         case REVOKE_ROLE_PRIVILEGE:\n           plan = new AuthorPlan(OperatorType.REVOKE_ROLE_PRIVILEGE);\n-          plan.deserialize(buffer);\n           break;\n         case REVOKE_USER_PRIVILEGE:\n           plan = new AuthorPlan(OperatorType.REVOKE_USER_PRIVILEGE);\n-          plan.deserialize(buffer);\n           break;\n         case GRANT_ROLE_PRIVILEGE:\n           plan = new AuthorPlan(OperatorType.GRANT_ROLE_PRIVILEGE);\n-          plan.deserialize(buffer);\n           break;\n         case GRANT_USER_PRIVILEGE:\n           plan = new AuthorPlan(OperatorType.GRANT_USER_PRIVILEGE);\n-          plan.deserialize(buffer);\n           break;\n         case GRANT_USER_ROLE:\n           plan = new AuthorPlan(OperatorType.GRANT_USER_ROLE);\n-          plan.deserialize(buffer);\n           break;\n         case MODIFY_PASSWORD:\n           plan = new AuthorPlan(OperatorType.MODIFY_PASSWORD);\n-          plan.deserialize(buffer);\n           break;\n         case DELETE_USER:\n           plan = new AuthorPlan(OperatorType.DELETE_USER);\n-          plan.deserialize(buffer);\n           break;\n         case DELETE_STORAGE_GROUP:\n           plan = new DeleteStorageGroupPlan();\n-          plan.deserialize(buffer);\n           break;\n         case SHOW_TIMESERIES:\n           plan = new ShowTimeSeriesPlan();\n-          plan.deserialize(buffer);\n           break;\n         case SHOW_DEVICES:\n           plan = new ShowDevicesPlan();\n-          plan.deserialize(buffer);\n           break;\n         case LOAD_CONFIGURATION:\n           plan = new LoadConfigurationPlan();\n-          plan.deserialize(buffer);\n           break;\n         case ALTER_TIMESERIES:\n           plan = new AlterTimeSeriesPlan();\n-          plan.deserialize(buffer);\n           break;\n         case FLUSH:\n           plan = new FlushPlan();\n-          plan.deserialize(buffer);\n           break;\n         case CREATE_MULTI_TIMESERIES:\n           plan = new CreateMultiTimeSeriesPlan();\n-          plan.deserialize(buffer);\n           break;\n         case CHANGE_ALIAS:\n           plan = new ChangeAliasPlan();\n-          plan.deserialize(buffer);\n           break;\n         case CHANGE_TAG_OFFSET:\n           plan = new ChangeTagOffsetPlan();\n-          plan.deserialize(buffer);\n           break;\n         case MNODE:\n           plan = new MNodePlan();\n-          plan.deserialize(buffer);\n           break;\n         case MEASUREMENT_MNODE:\n           plan = new MeasurementMNodePlan();\n-          plan.deserialize(buffer);\n           break;\n         case STORAGE_GROUP_MNODE:\n           plan = new StorageGroupMNodePlan();\n-          plan.deserialize(buffer);\n           break;\n         case BATCH_INSERT_ROWS:\n           plan = new InsertRowsPlan();\n-          plan.deserialize(buffer);\n+          break;\n+        case CREATE_TRIGGER:\n+          plan = new CreateTriggerPlan();\n+          break;\n+        case DROP_TRIGGER:\n+          plan = new DropTriggerPlan();\n+          break;\n+        case START_TRIGGER:\n+          plan = new StartTriggerPlan();\n+          break;\n+        case STOP_TRIGGER:\n+          plan = new StopTriggerPlan();\n           break;\n         default:\n           throw new IOException(\"unrecognized log type \" + type);\n       }\n+      plan.deserialize(buffer);\n       return plan;\n     }\n   }\n@@ -402,7 +383,11 @@ public static PhysicalPlan create(ByteBuffer buffer) throws IOException, Illegal\n     BATCH_INSERT_ONE_DEVICE,\n     MULTI_BATCH_INSERT,\n     BATCH_INSERT_ROWS,\n-    SHOW_DEVICES\n+    SHOW_DEVICES,\n+    CREATE_TRIGGER,\n+    DROP_TRIGGER,\n+    START_TRIGGER,\n+    STOP_TRIGGER\n   }\n \n   public long getIndex() {"
  }
]
