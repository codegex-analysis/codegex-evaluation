[
  {
    "sha": "318dd50a2685c8ecdef325c1e0f5960fcdae467b",
    "filename": "hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/PerformanceEvaluation.java",
    "status": "modified",
    "additions": 44,
    "deletions": 29,
    "changes": 73,
    "blob_url": "https://github.com/apache/hbase/blob/9995daf7b2167be9a056ea29b06d7ebcde2aa9f8/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/PerformanceEvaluation.java",
    "raw_url": "https://github.com/apache/hbase/raw/9995daf7b2167be9a056ea29b06d7ebcde2aa9f8/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/PerformanceEvaluation.java",
    "contents_url": "https://api.github.com/repos/apache/hbase/contents/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/PerformanceEvaluation.java?ref=9995daf7b2167be9a056ea29b06d7ebcde2aa9f8",
    "patch": "@@ -503,7 +503,9 @@ public RunResult call() throws Exception {\n           TestOptions threadOpts = new TestOptions(opts);\n           final Connection con = cons[index % cons.length];\n           final AsyncConnection asyncCon = asyncCons[index % asyncCons.length];\n-          if (threadOpts.startRow == 0) threadOpts.startRow = index * threadOpts.perClientRunRows;\n+          if (threadOpts.startRow == 0) {\n+            threadOpts.startRow = index * (threadOpts.initRows / threadOpts.numClientThreads);\n+          }\n           RunResult run = runOneClient(cmd, conf, con, asyncCon, threadOpts, new Status() {\n             @Override\n             public void setStatus(final String msg) throws IOException {\n@@ -640,12 +642,11 @@ static Path writeInputFile(final Configuration c, final TestOptions opts, final\n     // Make input random.\n     Map<Integer, String> m = new TreeMap<>();\n     Hash h = MurmurHash.getInstance();\n-    int perClientRows = (opts.totalRows / opts.numClientThreads);\n+    int startRowSteps = (opts.initRows / opts.numClientThreads);\n     try {\n       for (int j = 0; j < opts.numClientThreads; j++) {\n         TestOptions next = new TestOptions(opts);\n-        next.startRow = j * perClientRows;\n-        next.perClientRunRows = perClientRows;\n+        next.startRow = j * startRowSteps;\n         String s = GSON.toJson(next);\n         LOG.info(\"Client=\" + j + \", input=\" + s);\n         byte[] b = Bytes.toBytes(s);\n@@ -704,6 +705,7 @@ public String getDescription() {\n     int perClientRunRows = DEFAULT_ROWS_PER_GB;\n     int numClientThreads = 1;\n     int totalRows = DEFAULT_ROWS_PER_GB;\n+    int initRows = -1; // will decide the actual num later\n     int measureAfter = 0;\n     float sampleRate = 1.0f;\n     double traceRate = 0.0;\n@@ -712,7 +714,7 @@ public String getDescription() {\n     boolean writeToWAL = true;\n     boolean autoFlush = false;\n     boolean oneCon = false;\n-    int connCount = -1; //wil decide the actual num later\n+    int connCount = -1; // will decide the actual num later\n     boolean useTags = false;\n     int noOfTags = 1;\n     boolean reportLatency = false;\n@@ -760,6 +762,7 @@ public TestOptions(TestOptions that) {\n       this.perClientRunRows = that.perClientRunRows;\n       this.numClientThreads = that.numClientThreads;\n       this.totalRows = that.totalRows;\n+      this.initRows = that.initRows;\n       this.sampleRate = that.sampleRate;\n       this.traceRate = that.traceRate;\n       this.tableName = that.tableName;\n@@ -1135,6 +1138,14 @@ public MemoryCompactionPolicy getInMemoryCompaction() {\n     public long getBufferSize() {\n       return this.bufferSize;\n     }\n+\n+    public int getInitRows() {\n+      return initRows;\n+    }\n+\n+    public void setInitRows(int initRows) {\n+      this.initRows = initRows;\n+    }\n   }\n \n   /*\n@@ -1550,7 +1561,7 @@ boolean testRow(final int i, final long startTime) throws IOException, Interrupt\n       if (opts.randomSleep > 0) {\n         Thread.sleep(rd.nextInt(opts.randomSleep));\n       }\n-      Get get = new Get(getRandomRow(this.rand, opts.totalRows));\n+      Get get = new Get(getRandomRow(this.rand, opts.initRows));\n       for (int family = 0; family < opts.families; family++) {\n         byte[] familyName = Bytes.toBytes(FAMILY_NAME_BASE + family);\n         if (opts.addColumns) {\n@@ -1626,7 +1637,7 @@ protected void testTakedown() throws IOException {\n \n     @Override\n     protected byte[] generateRow(final int i) {\n-      return getRandomRow(this.rand, opts.totalRows);\n+      return getRandomRow(this.rand, opts.initRows);\n     }\n   }\n \n@@ -1807,7 +1818,7 @@ void onTakedown() throws IOException {\n \n     @Override\n     boolean testRow(final int i, final long startTime) throws IOException {\n-      Scan scan = new Scan().withStartRow(getRandomRow(this.rand, opts.totalRows))\n+      Scan scan = new Scan().withStartRow(getRandomRow(this.rand, opts.initRows))\n           .setCaching(opts.caching).setCacheBlocks(opts.cacheBlocks)\n           .setAsyncPrefetch(opts.asyncPrefetch).setReadType(opts.scanReadType)\n           .setScanMetricsEnabled(true);\n@@ -1897,7 +1908,7 @@ boolean testRow(final int i, final long startTime) throws IOException {\n     protected abstract Pair<byte[],byte[]> getStartAndStopRow();\n \n     protected Pair<byte[], byte[]> generateStartAndStopRows(int maxRange) {\n-      int start = this.rand.nextInt(Integer.MAX_VALUE) % opts.totalRows;\n+      int start = this.rand.nextInt(Integer.MAX_VALUE) % opts.initRows;\n       int stop = start + maxRange;\n       return new Pair<>(format(start), format(stop));\n     }\n@@ -1973,7 +1984,7 @@ boolean testRow(final int i, final long startTime) throws IOException, Interrupt\n       if (opts.randomSleep > 0) {\n         Thread.sleep(rd.nextInt(opts.randomSleep));\n       }\n-      Get get = new Get(getRandomRow(this.rand, opts.totalRows));\n+      Get get = new Get(getRandomRow(this.rand, opts.initRows));\n       for (int family = 0; family < opts.families; family++) {\n         byte[] familyName = Bytes.toBytes(FAMILY_NAME_BASE + family);\n         if (opts.addColumns) {\n@@ -2079,7 +2090,7 @@ protected void testTakedown() throws IOException {\n \n     @Override\n     protected byte[] generateRow(final int i) {\n-      return getRandomRow(this.rand, opts.totalRows);\n+      return getRandomRow(this.rand, opts.initRows);\n     }\n \n \n@@ -2614,7 +2625,7 @@ protected static void printUsage(final String shortName, final String message) {\n     System.err.println(\" nomapred        Run multiple clients using threads \" +\n       \"(rather than use mapreduce)\");\n     System.err.println(\" oneCon          all the threads share the same connection. Default: False\");\n-    System.err.println(\" connCount          connections all threads share. \"\n+    System.err.println(\" connCount       connections all threads share. \"\n         + \"For example, if set to 2, then all thread share 2 connection. \"\n         + \"Default: depend on oneCon parameter. if oneCon set to true, then connCount=1, \"\n         + \"if not, connCount=thread number\");\n@@ -2637,19 +2648,18 @@ protected static void printUsage(final String shortName, final String message) {\n         \"'valueSize'; set on read for stats on size: Default: Not set.\");\n     System.err.println(\" blockEncoding   Block encoding to use. Value should be one of \"\n         + Arrays.toString(DataBlockEncoding.values()) + \". Default: NONE\");\n+    System.err.println(\" initRows        The total rows currently in the table. This could \"\n+        + \"specify the range of reading and writing, making reading and writing more random. \"\n+        + \"If initRows is less than totalRows(perClientRunRows * nclients), initRows will be \"\n+        + \"set equal to totalRows. Default: -1\");\n     System.err.println();\n     System.err.println(\"Table Creation / Write Tests:\");\n     System.err.println(\" table           Alternate table name. Default: 'TestTable'\");\n     System.err.println(\" rows            Rows each client runs. Default: \"\n-        + DEFAULT_OPTS.getPerClientRunRows()\n-        + \".  In case of randomReads and randomSeekScans this could\"\n-        + \" be specified along with --size to specify the number of rows to be scanned within\"\n-        + \" the total range specified by the size.\");\n-    System.err.println(\n-      \" size            Total size in GiB. Mutually exclusive with --rows for writes and scans\"\n-          + \". But for randomReads and randomSeekScans when you use size with --rows you could\"\n-          + \" use size to specify the end range and --rows\"\n-          + \" specifies the number of rows within that range. \" + \"Default: 1.0.\");\n+        + DEFAULT_OPTS.getPerClientRunRows());\n+    System.err.println(\" size            Total size in GiB. Mutually exclusive with --rows. \"\n+        + \"When both --size and --rows are set, the value of perClientRunRows is only calculated \"\n+        + \"based on --size, --rows is ignored. Default: 1.0.\");\n     System.err.println(\" compress        Compression type to use (GZ, LZO, ...). Default: 'NONE'\");\n     System.err.println(\" flushCommits    Used to determine if the test should flush the table. \" +\n       \"Default: false\");\n@@ -2991,6 +3001,12 @@ static TestOptions parseOpts(Queue<String> args) {\n         continue;\n       }\n \n+      final String initRows = \"--initRows=\";\n+      if (cmd.startsWith(initRows)) {\n+        opts.initRows = Integer.parseInt(cmd.substring(initRows.length()));\n+        continue;\n+      }\n+\n       validateParsedOpts(opts);\n \n       if (isCommandClass(cmd)) {\n@@ -3000,7 +3016,7 @@ static TestOptions parseOpts(Queue<String> args) {\n         } catch (NoSuchElementException | NumberFormatException e) {\n           throw new IllegalArgumentException(\"Command \" + cmd + \" does not have threads number\", e);\n         }\n-        opts = calculateRowsAndSize(opts);\n+        calculateRowsAndSize(opts);\n         break;\n       } else {\n         printUsageAndExit(\"ERROR: Unrecognized option/command: \" + cmd, -1);\n@@ -3035,18 +3051,17 @@ private static void validateParsedOpts(TestOptions opts)  {\n \n   static TestOptions calculateRowsAndSize(final TestOptions opts) {\n     int rowsPerGB = getRowsPerGB(opts);\n-    if ((opts.getCmdName() != null\n-        && (opts.getCmdName().equals(RANDOM_READ) || opts.getCmdName().equals(RANDOM_SEEK_SCAN)))\n-        && opts.size != DEFAULT_OPTS.size\n-        && opts.perClientRunRows != DEFAULT_OPTS.perClientRunRows) {\n-      opts.totalRows = (int) opts.size * rowsPerGB;\n-    } else if (opts.size != DEFAULT_OPTS.size) {\n+    if (opts.size != DEFAULT_OPTS.size) {\n       // total size in GB specified\n       opts.totalRows = (int) opts.size * rowsPerGB;\n       opts.perClientRunRows = opts.totalRows / opts.numClientThreads;\n     } else {\n       opts.totalRows = opts.perClientRunRows * opts.numClientThreads;\n-      opts.size = opts.totalRows / rowsPerGB;\n+    }\n+\n+    // initRows must greater or equal to totalRows\n+    if (opts.initRows < opts.totalRows) {\n+      opts.initRows = opts.totalRows;\n     }\n     return opts;\n   }"
  },
  {
    "sha": "3e165091801f3a0ebe78f646f01af48b216e80d7",
    "filename": "hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/TestPerformanceEvaluation.java",
    "status": "modified",
    "additions": 71,
    "deletions": 14,
    "changes": 85,
    "blob_url": "https://github.com/apache/hbase/blob/9995daf7b2167be9a056ea29b06d7ebcde2aa9f8/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/TestPerformanceEvaluation.java",
    "raw_url": "https://github.com/apache/hbase/raw/9995daf7b2167be9a056ea29b06d7ebcde2aa9f8/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/TestPerformanceEvaluation.java",
    "contents_url": "https://api.github.com/repos/apache/hbase/contents/hbase-mapreduce/src/test/java/org/apache/hadoop/hbase/TestPerformanceEvaluation.java?ref=9995daf7b2167be9a056ea29b06d7ebcde2aa9f8",
    "patch": "@@ -33,10 +33,13 @@\n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n import java.util.LinkedList;\n+import java.util.Map;\n import java.util.NoSuchElementException;\n import java.util.Queue;\n import java.util.Random;\n+\n import org.apache.hadoop.fs.FSDataInputStream;\n import org.apache.hadoop.fs.FileSystem;\n import org.apache.hadoop.fs.Path;\n@@ -96,19 +99,30 @@ public void testWriteInputFile() throws IOException {\n     final int clients = 10;\n     opts.setNumClientThreads(clients);\n     opts.setPerClientRunRows(10);\n+    PerformanceEvaluation.calculateRowsAndSize(opts);\n     Path dir =\n       PerformanceEvaluation.writeInputFile(HTU.getConfiguration(), opts, HTU.getDataTestDir());\n     FileSystem fs = FileSystem.get(HTU.getConfiguration());\n     Path p = new Path(dir, PerformanceEvaluation.JOB_INPUT_FILENAME);\n     long len = fs.getFileStatus(p).getLen();\n     assertTrue(len > 0);\n     byte[] content = new byte[(int) len];\n+    Map<Integer, Boolean> map = new HashMap<>();\n+    for (int i = 0;i < 10; i++) {\n+      map.put(i * 10, false);\n+    }\n     try (FSDataInputStream dis = fs.open(p)) {\n       dis.readFully(content);\n       BufferedReader br = new BufferedReader(\n         new InputStreamReader(new ByteArrayInputStream(content), StandardCharsets.UTF_8));\n       int count = 0;\n-      while (br.readLine() != null) {\n+      Gson gson = GsonUtil.createGson().create();\n+      while (br.ready()) {\n+        String s = br.readLine();\n+        PerformanceEvaluation.TestOptions options =\n+          gson.fromJson(s, PerformanceEvaluation.TestOptions.class);\n+        assertFalse(map.get(options.getStartRow()));\n+        map.put(options.getStartRow(), true);\n         count++;\n       }\n       assertEquals(clients, count);\n@@ -118,48 +132,91 @@ public void testWriteInputFile() throws IOException {\n   @Test\n   public void testSizeCalculation() {\n     TestOptions opts = new PerformanceEvaluation.TestOptions();\n-    opts = PerformanceEvaluation.calculateRowsAndSize(opts);\n+    PerformanceEvaluation.calculateRowsAndSize(opts);\n     int rows = opts.getPerClientRunRows();\n     // Default row count\n     final int defaultPerClientRunRows = 1024 * 1024;\n     assertEquals(defaultPerClientRunRows, rows);\n     // If size is 2G, then twice the row count.\n     opts.setSize(2.0f);\n-    opts = PerformanceEvaluation.calculateRowsAndSize(opts);\n+    PerformanceEvaluation.calculateRowsAndSize(opts);\n     assertEquals(defaultPerClientRunRows * 2, opts.getPerClientRunRows());\n     // If two clients, then they get half the rows each.\n     opts.setNumClientThreads(2);\n-    opts = PerformanceEvaluation.calculateRowsAndSize(opts);\n+    PerformanceEvaluation.calculateRowsAndSize(opts);\n     assertEquals(defaultPerClientRunRows, opts.getPerClientRunRows());\n     // What if valueSize is 'random'? Then half of the valueSize so twice the rows.\n     opts.valueRandom = true;\n-    opts = PerformanceEvaluation.calculateRowsAndSize(opts);\n+    PerformanceEvaluation.calculateRowsAndSize(opts);\n     assertEquals(defaultPerClientRunRows * 2, opts.getPerClientRunRows());\n   }\n \n+  @Test\n+  public void testSizeCalculation2() {\n+    TestOptions opts = new PerformanceEvaluation.TestOptions();\n+    PerformanceEvaluation.calculateRowsAndSize(opts);\n+    // Default row count\n+    final int defaultPerClientRunRows = 1024 * 1024;\n+    assertEquals(defaultPerClientRunRows, opts.getPerClientRunRows());\n+    assertEquals(defaultPerClientRunRows, opts.getTotalRows());\n+    assertEquals(opts.getTotalRows(), opts.getInitRows());\n+    // When initRows is not set\n+    opts = new PerformanceEvaluation.TestOptions();\n+    opts.setNumClientThreads(2);\n+    opts.setPerClientRunRows(1000);\n+    PerformanceEvaluation.calculateRowsAndSize(opts);\n+    assertEquals(1000, opts.getPerClientRunRows());\n+    assertEquals(2000, opts.getTotalRows());\n+    assertEquals(opts.getTotalRows(), opts.getInitRows());\n+    // When initRows is not set, and size is 2G\n+    opts = new PerformanceEvaluation.TestOptions();\n+    opts.setNumClientThreads(2);\n+    opts.setSize(2);\n+    PerformanceEvaluation.calculateRowsAndSize(opts);\n+    assertEquals(defaultPerClientRunRows, opts.getPerClientRunRows());\n+    assertEquals(defaultPerClientRunRows * 2, opts.getTotalRows());\n+    assertEquals(opts.getTotalRows(), opts.getInitRows());\n+    // When initRows is set, and greater than totalRows\n+    opts = new PerformanceEvaluation.TestOptions();\n+    opts.setNumClientThreads(2);\n+    opts.setPerClientRunRows(1000);\n+    opts.setInitRows(10000);\n+    PerformanceEvaluation.calculateRowsAndSize(opts);\n+    assertEquals(1000, opts.getPerClientRunRows());\n+    assertEquals(2000, opts.getTotalRows());\n+    assertEquals(10000, opts.getInitRows());\n+    // When initRows is set, and less than totalRows\n+    opts = new PerformanceEvaluation.TestOptions();\n+    opts.setNumClientThreads(2);\n+    opts.setPerClientRunRows(1000);\n+    opts.setInitRows(100);\n+    PerformanceEvaluation.calculateRowsAndSize(opts);\n+    assertEquals(1000, opts.getPerClientRunRows());\n+    assertEquals(2000, opts.getTotalRows());\n+    assertEquals(opts.getTotalRows(), opts.getInitRows());\n+  }\n+\n   @Test\n   public void testRandomReadCalculation() {\n     TestOptions opts = new PerformanceEvaluation.TestOptions();\n-    opts = PerformanceEvaluation.calculateRowsAndSize(opts);\n+    PerformanceEvaluation.calculateRowsAndSize(opts);\n     int rows = opts.getPerClientRunRows();\n     // Default row count\n     final int defaultPerClientRunRows = 1024 * 1024;\n     assertEquals(defaultPerClientRunRows, rows);\n-    // If size is 2G, then twice the row count.\n-    opts.setSize(2.0f);\n+    // If initRows is 4 * 1024 * 1024\n+    opts.setInitRows(defaultPerClientRunRows * 4);\n     opts.setPerClientRunRows(1000);\n-    opts.setCmdName(PerformanceEvaluation.RANDOM_READ);\n-    opts = PerformanceEvaluation.calculateRowsAndSize(opts);\n-    assertEquals(1000, opts.getPerClientRunRows());\n-    // If two clients, then they get half the rows each.\n     opts.setNumClientThreads(2);\n-    opts = PerformanceEvaluation.calculateRowsAndSize(opts);\n+    opts.setCmdName(PerformanceEvaluation.RANDOM_READ);\n+    PerformanceEvaluation.calculateRowsAndSize(opts);\n     assertEquals(1000, opts.getPerClientRunRows());\n+    assertEquals(defaultPerClientRunRows * 4, opts.getInitRows());\n     Random random = new Random();\n     // assuming we will get one before this loop expires\n     boolean foundValue = false;\n     for (int i = 0; i < 10000000; i++) {\n-      int randomRow = PerformanceEvaluation.generateRandomRow(random, opts.totalRows);\n+      int randomRow = PerformanceEvaluation.generateRandomRow(random, opts.initRows);\n       if (randomRow > 1000) {\n         foundValue = true;\n         break;"
  }
]
