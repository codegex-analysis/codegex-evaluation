[
  {
    "sha": "d33a0ca98618fdae38e0d23572edebd221ecc814",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/pom.xml",
    "status": "modified",
    "additions": 10,
    "deletions": 4,
    "changes": 14,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/pom.xml",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/pom.xml",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/pom.xml?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -9,7 +9,8 @@ by applicable law or agreed to in writing, software distributed under the\n License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS \n OF ANY KIND, either express or implied. See the License for the specific \n language governing permissions and limitations under the License. -->\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n     <modelVersion>4.0.0</modelVersion>\n     <parent>\n         <groupId>org.apache.nifi</groupId>\n@@ -20,8 +21,8 @@ language governing permissions and limitations under the License. -->\n     <packaging>jar</packaging>\n \n     <properties>\n-        <snmp4j.version>1.10.1</snmp4j.version>\n-        <snmp4j-agent.version>1.3.1</snmp4j-agent.version>\n+        <snmp4j.version>2.8.6</snmp4j.version>\n+        <snmp4j-agent.version>2.6.4</snmp4j-agent.version>\n     </properties>\n \n     <dependencies>\n@@ -30,13 +31,18 @@ language governing permissions and limitations under the License. -->\n             <artifactId>snmp4j</artifactId>\n             <version>${snmp4j.version}</version>\n         </dependency>\n-        \n         <dependency>\n             <groupId>org.snmp4j</groupId>\n             <artifactId>snmp4j-agent</artifactId>\n             <version>${snmp4j-agent.version}</version>\n             <scope>test</scope>\n         </dependency>\n+        <dependency>\n+            <groupId>org.snmp4j</groupId>\n+            <artifactId>snmp4j-log4j</artifactId>\n+            <version>2.8.2</version>\n+            <scope>test</scope>\n+        </dependency>\n         <dependency>\n             <groupId>org.apache.nifi</groupId>\n             <artifactId>nifi-api</artifactId>"
  },
  {
    "sha": "6000de7203733c8be31718657f021ad0f31cb745",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/configuration/BasicConfiguration.java",
    "status": "added",
    "additions": 54,
    "deletions": 0,
    "changes": 54,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/configuration/BasicConfiguration.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/configuration/BasicConfiguration.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/configuration/BasicConfiguration.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.configuration;\n+\n+public class BasicConfiguration {\n+\n+    private final int clientPort;\n+    private final String host;\n+    private final int port;\n+    private final int retries;\n+    private final int timeout;\n+\n+    public BasicConfiguration(final int clientPort, final String host, final int port, final int retries, final int timeout) {\n+        this.clientPort = clientPort;\n+        this.host = host;\n+        this.port = port;\n+        this.retries = retries;\n+        this.timeout = timeout;\n+    }\n+\n+    public int getClientPort() {\n+        return clientPort;\n+    }\n+\n+    public String getHost() {\n+        return host;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public int getRetries() {\n+        return retries;\n+    }\n+\n+    public int getTimeout() {\n+        return timeout;\n+    }\n+}"
  },
  {
    "sha": "27013a708a55c003c4b1de77a7d4146533801876",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/configuration/SecurityConfiguration.java",
    "status": "added",
    "additions": 79,
    "deletions": 0,
    "changes": 79,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/configuration/SecurityConfiguration.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/configuration/SecurityConfiguration.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/configuration/SecurityConfiguration.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.configuration;\n+\n+public class SecurityConfiguration {\n+\n+    private final String version;\n+    private final String authProtocol;\n+    private final String authPassword;\n+    private final String privacyProtocol;\n+    private final String privacyPassword;\n+    private final String securityName;\n+    private final String securityLevel;\n+    private final String communityString;\n+\n+    public SecurityConfiguration(final String version,\n+                                 final String authProtocol,\n+                                 final String authPassword,\n+                                 final String privacyProtocol,\n+                                 final String privacyPassword,\n+                                 final String securityName,\n+                                 final String securityLevel,\n+                                 final String communityString) {\n+        this.version = version;\n+        this.authProtocol = authProtocol;\n+        this.authPassword = authPassword;\n+        this.privacyProtocol = privacyProtocol;\n+        this.privacyPassword = privacyPassword;\n+        this.securityName = securityName;\n+        this.securityLevel = securityLevel;\n+        this.communityString = communityString;\n+    }\n+\n+    public String getVersion() {\n+        return version;\n+    }\n+\n+    public String getAuthProtocol() {\n+        return authProtocol;\n+    }\n+\n+    public String getAuthPassword() {\n+        return authPassword;\n+    }\n+\n+    public String getPrivacyProtocol() {\n+        return privacyProtocol;\n+    }\n+\n+    public String getPrivacyPassword() {\n+        return privacyPassword;\n+    }\n+\n+    public String getSecurityName() {\n+        return securityName;\n+    }\n+\n+    public String getSecurityLevel() {\n+        return securityLevel;\n+    }\n+\n+    public String getCommunityString() {\n+        return communityString;\n+    }\n+}"
  },
  {
    "sha": "df0481048841d4172af4fffeff87e4e860042177",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/configuration/SecurityConfigurationBuilder.java",
    "status": "added",
    "additions": 72,
    "deletions": 0,
    "changes": 72,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/configuration/SecurityConfigurationBuilder.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/configuration/SecurityConfigurationBuilder.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/configuration/SecurityConfigurationBuilder.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.configuration;\n+\n+public class SecurityConfigurationBuilder {\n+    private String version;\n+    private String authProtocol;\n+    private String authPassword;\n+    private String privacyProtocol;\n+    private String privacyPassword;\n+    private String securityName;\n+    private String securityLevel;\n+    private String communityString;\n+\n+    public SecurityConfigurationBuilder setVersion(String version) {\n+        this.version = version;\n+        return this;\n+    }\n+\n+    public SecurityConfigurationBuilder setAuthProtocol(String authProtocol) {\n+        this.authProtocol = authProtocol;\n+        return this;\n+    }\n+\n+    public SecurityConfigurationBuilder setAuthPassword(String authPassword) {\n+        this.authPassword = authPassword;\n+        return this;\n+    }\n+\n+    public SecurityConfigurationBuilder setPrivacyProtocol(String privacyProtocol) {\n+        this.privacyProtocol = privacyProtocol;\n+        return this;\n+    }\n+\n+    public SecurityConfigurationBuilder setPrivacyPassword(String privacyPassword) {\n+        this.privacyPassword = privacyPassword;\n+        return this;\n+    }\n+\n+    public SecurityConfigurationBuilder setSecurityName(String securityName) {\n+        this.securityName = securityName;\n+        return this;\n+    }\n+\n+    public SecurityConfigurationBuilder setSecurityLevel(String securityLevel) {\n+        this.securityLevel = securityLevel;\n+        return this;\n+    }\n+\n+    public SecurityConfigurationBuilder setCommunityString(String communityString) {\n+        this.communityString = communityString;\n+        return this;\n+    }\n+\n+    public SecurityConfiguration createSecurityConfiguration() {\n+        return new SecurityConfiguration(version, authProtocol, authPassword, privacyProtocol, privacyPassword, securityName, securityLevel, communityString);\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "db2a17722a2a0e3d6dbf045e80f384cca64d8bb6",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/context/SNMPContext.java",
    "status": "added",
    "additions": 141,
    "deletions": 0,
    "changes": 141,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/context/SNMPContext.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/context/SNMPContext.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/context/SNMPContext.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.context;\n+\n+import org.apache.nifi.snmp.configuration.BasicConfiguration;\n+import org.apache.nifi.snmp.configuration.SecurityConfiguration;\n+import org.apache.nifi.snmp.exception.AgentSecurityConfigurationException;\n+import org.apache.nifi.snmp.utils.SNMPUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.snmp4j.AbstractTarget;\n+import org.snmp4j.CommunityTarget;\n+import org.snmp4j.Snmp;\n+import org.snmp4j.UserTarget;\n+import org.snmp4j.mp.SnmpConstants;\n+import org.snmp4j.security.SecurityLevel;\n+import org.snmp4j.security.UsmUser;\n+import org.snmp4j.smi.OctetString;\n+import org.snmp4j.smi.UdpAddress;\n+import org.snmp4j.transport.DefaultUdpTransportMapping;\n+\n+import java.io.IOException;\n+\n+public class SNMPContext {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SNMPContext.class);\n+\n+    private Snmp snmp;\n+    private AbstractTarget target;\n+\n+    public static SNMPContext newInstance() {\n+        return new SNMPContext();\n+    }\n+\n+    public void init(final BasicConfiguration basicConfiguration, final SecurityConfiguration securityConfiguration) {\n+        initSnmp(basicConfiguration);\n+\n+        final String snmpVersion = securityConfiguration.getVersion();\n+\n+        final int version = SNMPUtils.getSnmpVersion(snmpVersion);\n+\n+        if (version == SnmpConstants.version3) {\n+            createUserTarget(basicConfiguration, securityConfiguration, snmp, version);\n+        } else {\n+            target = createCommunityTarget(basicConfiguration, securityConfiguration, version);\n+        }\n+    }\n+\n+    public void close() {\n+        try {\n+            snmp.close();\n+        } catch (IOException e) {\n+            LOGGER.error(\"Could not close SNMP session.\");\n+        }\n+\n+    }\n+\n+    private CommunityTarget createCommunityTarget(BasicConfiguration basicConfiguration, SecurityConfiguration securityConfiguration, int version) {\n+        CommunityTarget communityTarget = new CommunityTarget();\n+        setupTargetBasicProperties(communityTarget, basicConfiguration, version);\n+        String community = securityConfiguration.getCommunityString();\n+        if (community != null) {\n+            communityTarget.setCommunity(new OctetString(community));\n+        }\n+        return communityTarget;\n+    }\n+\n+    private void createUserTarget(BasicConfiguration basicConfiguration, SecurityConfiguration securityConfiguration, Snmp snmp, int version) {\n+        final String username = securityConfiguration.getSecurityName();\n+        final String authProtocol = securityConfiguration.getAuthProtocol();\n+        final String authPassword = securityConfiguration.getAuthPassword();\n+        final String privacyProtocol = securityConfiguration.getPrivacyProtocol();\n+        final String privacyPassword = securityConfiguration.getPrivacyPassword();\n+        final OctetString authPasswordOctet = authPassword != null ? new OctetString(authPassword) : null;\n+        final OctetString privacyPasswordOctet = privacyPassword != null ? new OctetString(privacyPassword) : null;\n+\n+        if (snmp.getUSM() == null) {\n+            throw new AgentSecurityConfigurationException(\"No security model has been configured in agent.\");\n+        }\n+\n+        // Add user information.\n+        snmp.getUSM().addUser(\n+                new OctetString(username),\n+                new UsmUser(new OctetString(username), SNMPUtils.getAuth(authProtocol), authPasswordOctet,\n+                        SNMPUtils.getPriv(privacyProtocol), privacyPasswordOctet));\n+\n+        target = new UserTarget();\n+        setupTargetBasicProperties(target, basicConfiguration, version);\n+        int securityLevel = SecurityLevel.valueOf(securityConfiguration.getSecurityLevel()).getSnmpValue();\n+        target.setSecurityLevel(securityLevel);\n+\n+        final String securityName = securityConfiguration.getSecurityName();\n+        if (securityName != null) {\n+            target.setSecurityName(new OctetString(securityName));\n+        }\n+    }\n+\n+    private void initSnmp(final BasicConfiguration basicConfiguration) {\n+        int clientPort = basicConfiguration.getClientPort();\n+        try {\n+            snmp = new Snmp(new DefaultUdpTransportMapping(new UdpAddress(\"0.0.0.0/\" + clientPort)));\n+            snmp.listen();\n+        } catch (IOException e) {\n+            LOGGER.error(\"Could not create transport mapping\", e);\n+        }\n+    }\n+\n+    private void setupTargetBasicProperties(AbstractTarget abstractTarget, BasicConfiguration basicConfiguration, int version) {\n+        final String host = basicConfiguration.getHost();\n+        final int port = basicConfiguration.getPort();\n+        final int retries = basicConfiguration.getRetries();\n+        final int timeout = basicConfiguration.getTimeout();\n+\n+        abstractTarget.setVersion(version);\n+        abstractTarget.setAddress(new UdpAddress(host + \"/\" + port));\n+        abstractTarget.setRetries(retries);\n+        abstractTarget.setTimeout(timeout);\n+    }\n+\n+    public Snmp getSnmp() {\n+        return snmp;\n+    }\n+\n+    public AbstractTarget getTarget() {\n+        return target;\n+    }\n+}"
  },
  {
    "sha": "b9aa96f2c8fbed285cff10376a310dc6ebc68140",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/exception/AgentSecurityConfigurationException.java",
    "status": "renamed",
    "additions": 4,
    "deletions": 24,
    "changes": 28,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/exception/AgentSecurityConfigurationException.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/exception/AgentSecurityConfigurationException.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/exception/AgentSecurityConfigurationException.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -14,31 +14,11 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.nifi.snmp.processors;\n+package org.apache.nifi.snmp.exception;\n \n-import java.io.IOException;\n-import java.net.ServerSocket;\n+public class AgentSecurityConfigurationException extends RuntimeException {\n \n-public class SNMPTestUtil {\n-\n-    /**\n-     * Will determine an available port.\n-     */\n-    public static synchronized int availablePort() {\n-        ServerSocket s = null;\n-        try {\n-            s = new ServerSocket(0);\n-            s.setReuseAddress(true);\n-            return s.getLocalPort();\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Failed to discover available port.\", e);\n-        } finally {\n-            try {\n-                s.close();\n-            } catch (IOException e) {\n-                // ignore\n-            }\n-        }\n+    public AgentSecurityConfigurationException(String errorMessage) {\n+        super(errorMessage);\n     }\n-\n }",
    "previous_filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/processors/SNMPTestUtil.java"
  },
  {
    "sha": "ec0a01eace4aaa2ac64beca5b0d52ce9e034189a",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/logging/Slf4jLogAdapter.java",
    "status": "added",
    "additions": 114,
    "deletions": 0,
    "changes": 114,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/logging/Slf4jLogAdapter.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/logging/Slf4jLogAdapter.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/logging/Slf4jLogAdapter.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.logging;\n+\n+import org.slf4j.Logger;\n+import org.snmp4j.log.LogAdapter;\n+import org.snmp4j.log.LogLevel;\n+\n+import java.io.Serializable;\n+import java.util.Iterator;\n+import java.util.logging.Handler;\n+\n+public class Slf4jLogAdapter implements LogAdapter {\n+\n+    private final Logger logger;\n+\n+    public Slf4jLogAdapter(Logger logger) {\n+        this.logger = logger;\n+    }\n+\n+    // ---- Checking methods\n+\n+    public boolean isDebugEnabled() {\n+        return true;\n+    }\n+\n+    public boolean isInfoEnabled() {\n+        return true;\n+    }\n+\n+    public boolean isWarnEnabled() {\n+        return true;\n+    }\n+\n+    // ---- Logging methods\n+\n+    public void debug(Serializable message) {\n+        log(LogLevel.DEBUG, message.toString(), null);\n+    }\n+\n+    public void info(CharSequence message) {\n+        log(LogLevel.INFO, message.toString(), null);\n+    }\n+\n+    public void warn(Serializable message) {\n+        log(LogLevel.WARN, message.toString(), null);\n+    }\n+\n+    public void error(Serializable message) {\n+        log(LogLevel.ERROR, message.toString(), null);\n+    }\n+\n+    public void error(CharSequence message, Throwable t) {\n+        log(LogLevel.ERROR, message.toString(), t);\n+    }\n+\n+    public void fatal(Object message) {\n+        log(LogLevel.FATAL, message.toString(), null);\n+    }\n+\n+    public void fatal(CharSequence message, Throwable t) {\n+        log(LogLevel.FATAL, message.toString(), t);\n+    }\n+\n+    // ---- Public methods\n+\n+    public LogLevel getEffectiveLogLevel() {\n+        return LogLevel.ALL;\n+    }\n+\n+    public Iterator<Handler> getLogHandler() {\n+        return null;\n+    }\n+\n+    public LogLevel getLogLevel() {\n+        return getEffectiveLogLevel();\n+    }\n+\n+    public String getName() {\n+        return logger.getName();\n+    }\n+\n+    public void setLogLevel(LogLevel logLevel) {\n+        // no need to set log level\n+    }\n+\n+    // ---- Private methods\n+\n+    private void log(LogLevel logLevel, String msg, Throwable t) {\n+        if (logLevel == LogLevel.ERROR || logLevel == LogLevel.FATAL) {\n+            logger.error(msg, t);\n+        } else if (logLevel == LogLevel.WARN) {\n+            logger.warn(msg);\n+        } else if (logLevel == LogLevel.INFO) {\n+            logger.info(msg);\n+        } else {\n+            logger.debug(msg);\n+        }\n+    }\n+}"
  },
  {
    "sha": "cf5e65bf3009ef38fed8d91fbb7d5c06afb0f549",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/logging/Slf4jLogFactory.java",
    "status": "added",
    "additions": 49,
    "deletions": 0,
    "changes": 49,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/logging/Slf4jLogFactory.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/logging/Slf4jLogFactory.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/logging/Slf4jLogFactory.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.logging;\n+\n+import org.slf4j.LoggerFactory;\n+import org.snmp4j.log.LogAdapter;\n+import org.snmp4j.log.LogFactory;\n+\n+import java.util.Iterator;\n+\n+public class Slf4jLogFactory extends LogFactory {\n+\n+    public Slf4jLogFactory() {\n+    }\n+\n+    @Override\n+    protected LogAdapter createLogger(Class c) {\n+        return new Slf4jLogAdapter(LoggerFactory.getLogger(c.getName()));\n+    }\n+\n+    @Override\n+    protected LogAdapter createLogger(String className) {\n+        return new Slf4jLogAdapter(LoggerFactory.getLogger(className));\n+    }\n+\n+    @Override\n+    public LogAdapter getRootLogger() {\n+        return new Slf4jLogAdapter(LoggerFactory.getLogger(\"\"));\n+    }\n+\n+    @Override\n+    public Iterator loggers() {\n+        return null;\n+    }\n+}"
  },
  {
    "sha": "7c35fa0bcc77f41caafe00cfcc03639bf1e76aca",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/operations/SNMPGetter.java",
    "status": "renamed",
    "additions": 21,
    "deletions": 22,
    "changes": 43,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/operations/SNMPGetter.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/operations/SNMPGetter.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/operations/SNMPGetter.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -14,7 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.nifi.snmp.processors;\n+package org.apache.nifi.snmp.operations;\n \n import java.io.IOException;\n import java.util.List;\n@@ -35,63 +35,62 @@\n import org.snmp4j.util.TreeUtils;\n \n /**\n- * Extension of {@link SNMPWorker} to perform SNMP Get and SNMP Walk requests\n+ * Extension of {@link SNMPWorker} to perform SNMP Get and SNMP Walk requests.\n  */\n-final class SNMPGetter extends SNMPWorker {\n+public final class SNMPGetter extends SNMPWorker {\n \n-    /** logger */\n-    private final static Logger logger = LoggerFactory.getLogger(SNMPGetter.class);\n-\n-    /** OID to request */\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SNMPGetter.class);\n     private final OID oid;\n \n     /**\n-     * Creates an instance of this getter\n-     * @param snmp instance of {@link Snmp}\n+     * Creates an instance of this getter.\n+     *\n+     * @param snmp   instance of {@link Snmp}\n      * @param target instance of {@link AbstractTarget} to request\n-     * @param oid instance of {@link OID} to request\n+     * @param oid    instance of {@link OID} to request\n      */\n-    SNMPGetter(Snmp snmp, AbstractTarget target, OID oid) {\n+    public SNMPGetter(Snmp snmp, AbstractTarget target, OID oid) {\n         super(snmp, target);\n         this.oid = oid;\n-        logger.info(\"Successfully initialized SNMP Getter\");\n+        LOGGER.info(\"Successfully initialized SNMP Getter\");\n     }\n \n     /**\n      * Construct the PDU to perform the SNMP Get request and returns\n      * the result in order to create the flow file.\n+     *\n      * @return {@link ResponseEvent}\n      */\n     public ResponseEvent get() {\n         try {\n-            PDU pdu = null;\n-            if(this.target.getVersion() == SnmpConstants.version3) {\n+            PDU pdu;\n+            if (target.getVersion() == SnmpConstants.version3) {\n                 pdu = new ScopedPDU();\n             } else {\n                 pdu = new PDU();\n             }\n-            pdu.add(new VariableBinding(this.oid));\n+            pdu.add(new VariableBinding(oid));\n             pdu.setType(PDU.GET);\n-            return this.snmp.get(pdu, this.target);\n+            return snmp.get(pdu, target);\n         } catch (IOException e) {\n-            logger.error(\"Failed to get information from SNMP agent; \" + this, e);\n+            LOGGER.error(\"Failed to get information from SNMP agent; {}\", this, e);\n             throw new ProcessException(e);\n         }\n     }\n \n     /**\n      * Perform a SNMP walk and returns the list of {@link TreeEvent}\n+     *\n      * @return the list of {@link TreeEvent}\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public List<TreeEvent> walk() {\n-        TreeUtils treeUtils = new TreeUtils(this.snmp, new DefaultPDUFactory());\n-        @SuppressWarnings(\"unchecked\")\n-        List<TreeEvent> events = treeUtils.getSubtree(this.target, this.oid);\n-        return events;\n+        TreeUtils treeUtils = new TreeUtils(snmp, new DefaultPDUFactory());\n+        return treeUtils.getSubtree(target, oid);\n     }\n \n     /**\n-     * @see org.apache.nifi.snmp.processors.SNMPWorker#toString()\n+     * @see SNMPWorker#toString()\n      */\n     @Override\n     public String toString() {",
    "previous_filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/SNMPGetter.java"
  },
  {
    "sha": "bd6d0077cf8c70be1f07f26eb536443c87aa4eaf",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/operations/SNMPSetter.java",
    "status": "renamed",
    "additions": 9,
    "deletions": 10,
    "changes": 19,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/operations/SNMPSetter.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/operations/SNMPSetter.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/operations/SNMPSetter.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -14,7 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.nifi.snmp.processors;\n+package org.apache.nifi.snmp.operations;\n \n import java.io.IOException;\n \n@@ -26,31 +26,30 @@\n import org.snmp4j.event.ResponseEvent;\n \n /**\n- * Extension of {@link SNMPWorker} to perform SNMP Set requests\n+ * Extension of {@link SNMPWorker} to perform SNMP Set requests.\n  */\n-final class SNMPSetter extends SNMPWorker {\n+public final class SNMPSetter extends SNMPWorker {\n \n-    /** logger */\n-    private final static Logger logger = LoggerFactory.getLogger(SNMPSetter.class);\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SNMPSetter.class);\n \n     /**\n-     * Creates an instance of this setter\n+     * Creates an instance of this setter.\n      * @param snmp instance of {@link Snmp}\n      * @param target instance of {@link AbstractTarget} to request\n      */\n-    SNMPSetter(Snmp snmp, AbstractTarget target) {\n+    public SNMPSetter(Snmp snmp, AbstractTarget target) {\n         super(snmp, target);\n-        logger.info(\"Successfully initialized SNMP Setter\");\n+        LOGGER.info(\"Successfully initialized SNMP Setter\");\n     }\n \n     /**\n-     * Executes the SNMP set request and returns the response\n+     * Executes the SNMP set request and returns the response.\n      * @param pdu PDU to send\n      * @return Response event\n      * @throws IOException IO Exception\n      */\n     public ResponseEvent set(PDU pdu) throws IOException {\n-        return this.snmp.set(pdu, this.target);\n+        return snmp.set(pdu, target);\n     }\n \n }",
    "previous_filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/SNMPSetter.java"
  },
  {
    "sha": "445d8285c5d75790200f84f72e6309e715027d34",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/operations/SNMPWorker.java",
    "status": "renamed",
    "additions": 9,
    "deletions": 16,
    "changes": 25,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/operations/SNMPWorker.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/operations/SNMPWorker.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/operations/SNMPWorker.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -14,10 +14,9 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.nifi.snmp.processors;\n+package org.apache.nifi.snmp.operations;\n \n import java.io.IOException;\n-import java.util.concurrent.TimeoutException;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -32,35 +31,29 @@\n  */\n abstract class SNMPWorker implements AutoCloseable {\n \n-    /** logger */\n-    private final static Logger logger = LoggerFactory.getLogger(SNMPWorker.class);\n-\n-    /** SNMP abstraction */\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SNMPWorker.class);\n     protected final Snmp snmp;\n-\n-    /** Target to request */\n     protected final AbstractTarget target;\n \n     /**\n      * Creates an instance of this worker and initializing it with {@link Snmp}\n      * and {@link AbstractTarget} used by sub-classes to interact with SNMP agent.\n-     * @param snmp instance of {@link Snmp}\n+     *\n+     * @param snmp   instance of {@link Snmp}\n      * @param target instance of {@link AbstractTarget}\n      */\n-    public SNMPWorker(Snmp snmp, AbstractTarget target) {\n+    protected SNMPWorker(Snmp snmp, AbstractTarget target) {\n         this.snmp = snmp;\n         this.target = target;\n     }\n \n     /**\n-     * Closes {@link Snmp} created when instance of this class was created.\n+     * Closes {@link Snmp}.\n      */\n     @Override\n-    public void close() throws TimeoutException, IOException {\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"Closing SNMP connection\");\n-        }\n-        this.snmp.close();\n+    public void close() throws IOException {\n+        LOGGER.debug(\"Closing SNMP connection\");\n+        snmp.close();\n     }\n \n     /**",
    "previous_filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/SNMPWorker.java"
  },
  {
    "sha": "61eff598d21cb172393c0f825e4994b0e1509006",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/AbstractSNMPProcessor.java",
    "status": "modified",
    "additions": 116,
    "deletions": 289,
    "changes": 405,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/AbstractSNMPProcessor.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/AbstractSNMPProcessor.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/AbstractSNMPProcessor.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -16,66 +16,69 @@\n  */\n package org.apache.nifi.snmp.processors;\n \n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-\n import org.apache.nifi.annotation.lifecycle.OnStopped;\n import org.apache.nifi.components.PropertyDescriptor;\n import org.apache.nifi.components.ValidationContext;\n import org.apache.nifi.components.ValidationResult;\n import org.apache.nifi.processor.AbstractProcessor;\n import org.apache.nifi.processor.ProcessContext;\n-import org.apache.nifi.processor.ProcessSession;\n-import org.apache.nifi.processor.Processor;\n-import org.apache.nifi.processor.exception.ProcessException;\n import org.apache.nifi.processor.util.StandardValidators;\n-import org.snmp4j.AbstractTarget;\n-import org.snmp4j.CommunityTarget;\n-import org.snmp4j.Snmp;\n-import org.snmp4j.TransportMapping;\n-import org.snmp4j.UserTarget;\n-import org.snmp4j.mp.MPv3;\n-import org.snmp4j.mp.SnmpConstants;\n-import org.snmp4j.security.SecurityModels;\n-import org.snmp4j.security.SecurityProtocols;\n-import org.snmp4j.security.USM;\n-import org.snmp4j.security.UsmUser;\n-import org.snmp4j.smi.OctetString;\n-import org.snmp4j.smi.UdpAddress;\n-import org.snmp4j.transport.DefaultUdpTransportMapping;\n+import org.apache.nifi.snmp.configuration.BasicConfiguration;\n+import org.apache.nifi.snmp.configuration.SecurityConfiguration;\n+import org.apache.nifi.snmp.configuration.SecurityConfigurationBuilder;\n+import org.apache.nifi.snmp.context.SNMPContext;\n+import org.apache.nifi.snmp.logging.Slf4jLogFactory;\n+import org.apache.nifi.snmp.validators.OIDValidator;\n+import org.snmp4j.log.LogFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n \n /**\n- * Base processor that uses SNMP4J client API\n+ * Base processor that uses SNMP4J client API.\n  * (http://www.snmp4j.org/)\n- *\n- * @param <T> the type of {@link SNMPWorker}. Please see {@link SNMPSetter}\n- *            and {@link SNMPGetter}\n  */\n-abstract class AbstractSNMPProcessor<T extends SNMPWorker> extends AbstractProcessor {\n+abstract class AbstractSNMPProcessor extends AbstractProcessor {\n+\n+    static {\n+        LogFactory.setLogFactory(new Slf4jLogFactory());\n+    }\n+\n+    // Property to define the host of the SNMP agent.\n+    public static final PropertyDescriptor SNMP_CLIENT_PORT = new PropertyDescriptor.Builder()\n+            .name(\"snmp-client-port\")\n+            .displayName(\"SNMP client (processor) port\")\n+            .description(\"The processor runs an SNMP client on localhost. The port however can be specified\")\n+            .required(true)\n+            .defaultValue(\"0\")\n+            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)\n+            .build();\n \n-    /** property to define host of the SNMP agent */\n-    public static final PropertyDescriptor HOST = new PropertyDescriptor.Builder()\n-            .name(\"snmp-hostname\")\n-            .displayName(\"Host Name\")\n+    // Property to define the host of the SNMP agent.\n+    public static final PropertyDescriptor AGENT_HOST = new PropertyDescriptor.Builder()\n+            .name(\"snmp-agent-hostname\")\n+            .displayName(\"SNMP agent hostname\")\n             .description(\"Network address of SNMP Agent (e.g., localhost)\")\n             .required(true)\n             .defaultValue(\"localhost\")\n             .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)\n             .build();\n \n-    /** property to define port of the SNMP agent */\n-    public static final PropertyDescriptor PORT = new PropertyDescriptor.Builder()\n-            .name(\"snmp-port\")\n-            .displayName(\"Port\")\n-            .description(\"Numeric value identifying Port of SNMP Agent (e.g., 161)\")\n+    // Property to define the port of the SNMP agent.\n+    public static final PropertyDescriptor AGENT_PORT = new PropertyDescriptor.Builder()\n+            .name(\"snmp-agent-port\")\n+            .displayName(\"SNMP agent port\")\n+            .description(\"Numeric value identifying the port of SNMP Agent (e.g., 161)\")\n             .required(true)\n             .defaultValue(\"161\")\n             .addValidator(StandardValidators.PORT_VALIDATOR)\n             .build();\n \n-    /** property to define SNMP version to use */\n+    // Property to define SNMP version.\n     public static final PropertyDescriptor SNMP_VERSION = new PropertyDescriptor.Builder()\n             .name(\"snmp-version\")\n             .displayName(\"SNMP Version\")\n@@ -85,17 +88,19 @@\n             .defaultValue(\"SNMPv1\")\n             .build();\n \n-    /** property to define SNMP community to use */\n+    // Property to define SNMP community.\n     public static final PropertyDescriptor SNMP_COMMUNITY = new PropertyDescriptor.Builder()\n             .name(\"snmp-community\")\n             .displayName(\"SNMP Community (v1 & v2c)\")\n-            .description(\"SNMP Community to use (e.g., public)\")\n+            .description(\"SNMP Community to use (e.g., public). The SNMP Community string\" +\n+                    \" is like a user id or password that allows access to a router's or \" +\n+                    \"other device's statistics.\")\n             .required(false)\n             .defaultValue(\"public\")\n             .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)\n             .build();\n \n-    /** property to define SNMP security level to use */\n+    // Property to define SNMP security level.\n     public static final PropertyDescriptor SNMP_SECURITY_LEVEL = new PropertyDescriptor.Builder()\n             .name(\"snmp-security-level\")\n             .displayName(\"SNMP Security Level\")\n@@ -105,7 +110,7 @@\n             .defaultValue(\"authPriv\")\n             .build();\n \n-    /** property to define SNMP security name to use */\n+    // Property to define SNMP security name.\n     public static final PropertyDescriptor SNMP_SECURITY_NAME = new PropertyDescriptor.Builder()\n             .name(\"snmp-security-name\")\n             .displayName(\"SNMP Security name / user name\")\n@@ -114,7 +119,7 @@\n             .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)\n             .build();\n \n-    /** property to define SNMP authentication protocol to use */\n+    // Property to define SNMP authentication protocol.\n     public static final PropertyDescriptor SNMP_AUTH_PROTOCOL = new PropertyDescriptor.Builder()\n             .name(\"snmp-authentication-protocol\")\n             .displayName(\"SNMP Authentication Protocol\")\n@@ -124,7 +129,7 @@\n             .defaultValue(\"\")\n             .build();\n \n-    /** property to define SNMP authentication password to use */\n+    // Property to define SNMP authentication password.\n     public static final PropertyDescriptor SNMP_AUTH_PASSWORD = new PropertyDescriptor.Builder()\n             .name(\"snmp-authentication-passphrase\")\n             .displayName(\"SNMP Authentication pass phrase\")\n@@ -134,27 +139,27 @@\n             .sensitive(true)\n             .build();\n \n-    /** property to define SNMP private protocol to use */\n-    public static final PropertyDescriptor SNMP_PRIV_PROTOCOL = new PropertyDescriptor.Builder()\n-            .name(\"snmp-private-protocol\")\n-            .displayName(\"SNMP Private Protocol\")\n-            .description(\"SNMP Private Protocol to use\")\n+    // Property to define SNMP private protocol.\n+    public static final PropertyDescriptor SNMP_PRIVACY_PROTOCOL = new PropertyDescriptor.Builder()\n+            .name(\"snmp-privacy-protocol\")\n+            .displayName(\"SNMP Privacy Protocol\")\n+            .description(\"SNMP Privacy Protocol to use\")\n             .required(true)\n             .allowableValues(\"DES\", \"3DES\", \"AES128\", \"AES192\", \"AES256\", \"\")\n             .defaultValue(\"\")\n             .build();\n \n-    /** property to define SNMP private password to use */\n-    public static final PropertyDescriptor SNMP_PRIV_PASSWORD = new PropertyDescriptor.Builder()\n-            .name(\"snmp-private-protocol-passphrase\")\n-            .displayName(\"SNMP Private protocol pass phrase\")\n-            .description(\"Pass phrase used for SNMP private protocol\")\n+    // Property to define SNMP private password.\n+    public static final PropertyDescriptor SNMP_PRIVACY_PASSWORD = new PropertyDescriptor.Builder()\n+            .name(\"snmp-privacy-protocol-passphrase\")\n+            .displayName(\"SNMP Privacy protocol pass phrase\")\n+            .description(\"Pass phrase used for SNMP privacy protocol\")\n             .required(false)\n             .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)\n             .sensitive(true)\n             .build();\n \n-    /** property to define the number of SNMP retries when requesting the SNMP Agent */\n+    // Property to define the number of SNMP retries when requesting the SNMP Agent.\n     public static final PropertyDescriptor SNMP_RETRIES = new PropertyDescriptor.Builder()\n             .name(\"snmp-retries\")\n             .displayName(\"Number of retries\")\n@@ -164,7 +169,7 @@\n             .addValidator(StandardValidators.INTEGER_VALIDATOR)\n             .build();\n \n-    /** property to define the timeout when requesting the SNMP Agent */\n+    // Property to define the timeout when requesting the SNMP Agent.\n     public static final PropertyDescriptor SNMP_TIMEOUT = new PropertyDescriptor.Builder()\n             .name(\"snmp-timeout\")\n             .displayName(\"Timeout (ms)\")\n@@ -174,84 +179,56 @@\n             .addValidator(StandardValidators.INTEGER_VALIDATOR)\n             .build();\n \n-    /** list of property descriptors */\n-    static List<PropertyDescriptor> descriptors = new ArrayList<>();\n-\n-    /*\n-     * Will ensure that list of PropertyDescriptors is build only once, since\n-     * all other life cycle methods are invoked multiple times.\n-     */\n-    static {\n-        descriptors.add(HOST);\n-        descriptors.add(PORT);\n-        descriptors.add(SNMP_VERSION);\n-        descriptors.add(SNMP_COMMUNITY);\n-        descriptors.add(SNMP_SECURITY_LEVEL);\n-        descriptors.add(SNMP_SECURITY_NAME);\n-        descriptors.add(SNMP_AUTH_PROTOCOL);\n-        descriptors.add(SNMP_AUTH_PASSWORD);\n-        descriptors.add(SNMP_PRIV_PROTOCOL);\n-        descriptors.add(SNMP_PRIV_PASSWORD);\n-        descriptors.add(SNMP_RETRIES);\n-        descriptors.add(SNMP_TIMEOUT);\n+    protected static final List<PropertyDescriptor> BASIC_PROPERTIES = Collections.unmodifiableList(Arrays.asList(\n+            SNMP_CLIENT_PORT,\n+            AGENT_HOST,\n+            AGENT_PORT,\n+            SNMP_VERSION,\n+            SNMP_COMMUNITY,\n+            SNMP_SECURITY_LEVEL,\n+            SNMP_SECURITY_NAME,\n+            SNMP_AUTH_PROTOCOL,\n+            SNMP_AUTH_PASSWORD,\n+            SNMP_PRIVACY_PROTOCOL,\n+            SNMP_PRIVACY_PASSWORD,\n+            SNMP_RETRIES,\n+            SNMP_TIMEOUT\n+    ));\n+\n+    protected SNMPContext snmpContext;\n+\n+    public void initSnmpClient(ProcessContext context) {\n+        final BasicConfiguration basicConfiguration = new BasicConfiguration(\n+                context.getProperty(SNMP_CLIENT_PORT).asInteger(),\n+                context.getProperty(AGENT_HOST).getValue(),\n+                context.getProperty(AGENT_PORT).asInteger(),\n+                context.getProperty(SNMP_RETRIES).asInteger(),\n+                context.getProperty(SNMP_TIMEOUT).asInteger()\n+        );\n+\n+        final SecurityConfiguration securityConfiguration = new SecurityConfigurationBuilder()\n+                .setVersion(context.getProperty(SNMP_VERSION).getValue())\n+                .setAuthProtocol(context.getProperty(SNMP_AUTH_PROTOCOL).getValue())\n+                .setAuthPassword(context.getProperty(SNMP_AUTH_PASSWORD).getValue())\n+                .setPrivacyProtocol(context.getProperty(SNMP_PRIVACY_PROTOCOL).getValue())\n+                .setPrivacyPassword(context.getProperty(SNMP_PRIVACY_PASSWORD).getValue())\n+                .setSecurityName(context.getProperty(SNMP_SECURITY_NAME).getValue())\n+                .setSecurityLevel(context.getProperty(SNMP_SECURITY_LEVEL).getValue())\n+                .setCommunityString(context.getProperty(SNMP_COMMUNITY).getValue())\n+                .createSecurityConfiguration();\n+\n+        snmpContext = SNMPContext.newInstance();\n+        snmpContext.init(basicConfiguration, securityConfiguration);\n     }\n \n-    /** SNMP target */\n-    protected volatile AbstractTarget snmpTarget;\n-\n-    /** transport mapping */\n-    protected volatile TransportMapping transportMapping;\n-\n-    /** SNMP */\n-    protected volatile Snmp snmp;\n-\n-    /** target resource */\n-    protected volatile T targetResource;\n-\n     /**\n-     * Will builds target resource upon first invocation and will delegate to the\n-     * implementation of {@link #onTriggerSnmp(ProcessContext, ProcessSession)} method for\n-     * further processing.\n-     */\n-    @Override\n-    public void onTrigger(ProcessContext context, ProcessSession session) throws ProcessException {\n-        synchronized (this) {\n-            this.buildTargetResource(context);\n-        }\n-        this.onTriggerSnmp(context, session);\n-    }\n-\n-    /**\n-     * Will close current SNMP mapping.\n+     * Closes the current SNMP mapping.\n      */\n     @OnStopped\n     public void close() {\n-        try {\n-            if (this.targetResource != null) {\n-                this.targetResource.close();\n-            }\n-        } catch (Exception e) {\n-            this.getLogger().warn(\"Failure while closing target resource \" + this.targetResource, e);\n-        }\n-        this.targetResource = null;\n-\n-        try {\n-            if (this.transportMapping != null) {\n-                this.transportMapping.close();\n-            }\n-        } catch (IOException e) {\n-            this.getLogger().warn(\"Failure while closing UDP transport mapping\", e);\n-        }\n-        this.transportMapping = null;\n-\n-        try {\n-            if (this.snmp != null) {\n-                this.snmp.close();\n-            }\n-        } catch (IOException e) {\n-            this.getLogger().warn(\"Failure while closing UDP transport mapping\", e);\n+        if (snmpContext != null) {\n+            snmpContext.close();\n         }\n-        this.snmp = null;\n     }\n \n     /**\n@@ -261,168 +238,18 @@ public void close() {\n     protected Collection<ValidationResult> customValidate(ValidationContext validationContext) {\n         final List<ValidationResult> problems = new ArrayList<>(super.customValidate(validationContext));\n \n-        final boolean isVersion3 = \"SNMPv3\".equals(validationContext.getProperty(SNMP_VERSION).getValue());\n-\n-        if(isVersion3) {\n-            final boolean isSecurityNameSet = validationContext.getProperty(SNMP_SECURITY_NAME).isSet();\n-            if(!isSecurityNameSet) {\n-                problems.add(new ValidationResult.Builder()\n-                        .input(\"SNMP Security Name\")\n-                        .valid(false)\n-                        .explanation(\"SNMP Security Name must be set with SNMPv3.\")\n-                        .build());\n-            }\n-\n-            final boolean isAuthProtOK = !\"\".equals(validationContext.getProperty(SNMP_AUTH_PROTOCOL).getValue());\n-            final boolean isAuthPwdSet = validationContext.getProperty(SNMP_AUTH_PASSWORD).isSet();\n-            final boolean isPrivProtOK = !\"\".equals(validationContext.getProperty(SNMP_PRIV_PROTOCOL).getValue());\n-            final boolean isPrivPwdSet = validationContext.getProperty(SNMP_PRIV_PASSWORD).isSet();\n-\n-            switch(validationContext.getProperty(SNMP_SECURITY_LEVEL).getValue()) {\n-            case \"authNoPriv\":\n-                if(!isAuthProtOK || !isAuthPwdSet) {\n-                    problems.add(new ValidationResult.Builder()\n-                            .input(\"SNMP Security Level\")\n-                            .valid(false)\n-                            .explanation(\"Authentication protocol and password must be set when using authNoPriv security level.\")\n-                            .build());\n-                }\n-                break;\n-            case \"authPriv\":\n-                if(!isAuthProtOK || !isAuthPwdSet || !isPrivProtOK || !isPrivPwdSet) {\n-                    problems.add(new ValidationResult.Builder()\n-                            .input(\"SNMP Security Level\")\n-                            .valid(false)\n-                            .explanation(\"All protocols and passwords must be set when using authPriv security level.\")\n-                            .build());\n-                }\n-                break;\n-            case \"noAuthNoPriv\":\n-            default:\n-                break;\n-            }\n-        } else {\n-            final boolean isCommunitySet = validationContext.getProperty(SNMP_COMMUNITY).isSet();\n-            if(!isCommunitySet) {\n-                problems.add(new ValidationResult.Builder()\n-                        .input(\"SNMP Community\")\n-                        .valid(false)\n-                        .explanation(\"SNMP Community must be set with SNMPv1 and SNMPv2c.\")\n-                        .build());\n-            }\n-        }\n-\n-        return problems;\n-    }\n-\n-    /**\n-     * Delegate method to supplement\n-     * {@link #onTrigger(ProcessContext, ProcessSession)}. It is implemented by\n-     * sub-classes to perform {@link Processor} specific functionality.\n-     *\n-     * @param context\n-     *            instance of {@link ProcessContext}\n-     * @param session\n-     *            instance of {@link ProcessSession}\n-     * @throws ProcessException Process exception\n-     */\n-    protected abstract void onTriggerSnmp(ProcessContext context, ProcessSession session) throws ProcessException;\n-\n-    /**\n-     * Delegate method to supplement building of target {@link SNMPWorker} (see\n-     * {@link SNMPSetter} or {@link SNMPGetter}) and is implemented by\n-     * sub-classes.\n-     *\n-     * @param context\n-     *            instance of {@link ProcessContext}\n-     * @return new instance of {@link SNMPWorker}\n-     */\n-    protected abstract T finishBuildingTargetResource(ProcessContext context);\n-\n-    /**\n-     * Builds target resource.\n-     * @param context Process context\n-     */\n-    private void buildTargetResource(ProcessContext context) {\n-        if((this.transportMapping == null) || !this.transportMapping.isListening() || (this.snmp == null)) {\n-            try {\n-                this.transportMapping = new DefaultUdpTransportMapping();\n-                this.snmp = new Snmp(this.transportMapping);\n-\n-                if(\"SNMPv3\".equals(context.getProperty(SNMP_VERSION).getValue())) {\n-                    USM usm = new USM(SecurityProtocols.getInstance(), new OctetString(MPv3.createLocalEngineID()), 0);\n-                    SecurityModels.getInstance().addSecurityModel(usm);\n-                }\n-\n-                this.transportMapping.listen();\n-            } catch (Exception e) {\n-                throw new IllegalStateException(\"Failed to initialize UDP transport mapping\", e);\n-            }\n-        }\n-        if (this.snmpTarget == null) {\n-            this.snmpTarget = this.createSnmpTarget(context);\n-        }\n-        if (this.targetResource == null) {\n-            this.targetResource = this.finishBuildingTargetResource(context);\n-        }\n+        final SecurityConfiguration securityConfiguration = new SecurityConfigurationBuilder()\n+                .setVersion(validationContext.getProperty(SNMP_VERSION).getValue())\n+                .setAuthProtocol(validationContext.getProperty(SNMP_SECURITY_NAME).getValue())\n+                .setAuthPassword(validationContext.getProperty(SNMP_AUTH_PROTOCOL).getValue())\n+                .setPrivacyProtocol(validationContext.getProperty(SNMP_AUTH_PASSWORD).getValue())\n+                .setPrivacyPassword(validationContext.getProperty(SNMP_PRIVACY_PROTOCOL).getValue())\n+                .setSecurityName(validationContext.getProperty(SNMP_PRIVACY_PASSWORD).getValue())\n+                .setSecurityLevel(validationContext.getProperty(SNMP_SECURITY_LEVEL).getValue())\n+                .setCommunityString(validationContext.getProperty(SNMP_COMMUNITY).getValue())\n+                .createSecurityConfiguration();\n+\n+        OIDValidator oidValidator = new OIDValidator(securityConfiguration, problems);\n+        return oidValidator.validate();\n     }\n-\n-    /**\n-     * Creates {@link AbstractTarget} to request SNMP agent.\n-     * @param context Process context\n-     * @return the SNMP target\n-     */\n-    private AbstractTarget createSnmpTarget(ProcessContext context) {\n-        AbstractTarget result = null;\n-        String snmpVersion = context.getProperty(SNMP_VERSION).getValue();\n-        int version = 0;\n-        switch (snmpVersion) {\n-        case \"SNMPv2c\":\n-            version = SnmpConstants.version2c;\n-            break;\n-        case \"SNMPv3\":\n-            version = SnmpConstants.version3;\n-            break;\n-        case \"SNMPv1\":\n-        default:\n-            version = SnmpConstants.version1;\n-            break;\n-        }\n-\n-        if(version == SnmpConstants.version3) {\n-            final String username = context.getProperty(SNMP_SECURITY_NAME).getValue();\n-            final String authPassword = context.getProperty(SNMP_AUTH_PASSWORD).getValue();\n-            final String privPassword = context.getProperty(SNMP_PRIV_PASSWORD).getValue();\n-            final String authProtocol = context.getProperty(SNMP_AUTH_PROTOCOL).getValue();\n-            final String privProtocol = context.getProperty(SNMP_PRIV_PROTOCOL).getValue();\n-            OctetString aPwd = authPassword != null ? new OctetString(authPassword) : null;\n-            OctetString pPwd = privPassword != null ? new OctetString(privPassword) : null;\n-\n-            // add user information\n-            this.snmp.getUSM().addUser(new OctetString(username),\n-                    new UsmUser(new OctetString(username), SNMPUtils.getAuth(authProtocol), aPwd, SNMPUtils.getPriv(privProtocol), pPwd));\n-\n-            result = new UserTarget();\n-\n-            ((UserTarget) result).setSecurityLevel(SNMPUtils.getSecLevel(context.getProperty(SNMP_SECURITY_LEVEL).getValue()));\n-            final String securityName = context.getProperty(SNMP_SECURITY_NAME).getValue();\n-            if(securityName != null) {\n-                ((UserTarget) result).setSecurityName(new OctetString(securityName));\n-            }\n-        } else {\n-            result = new CommunityTarget();\n-            String community = context.getProperty(SNMP_COMMUNITY).getValue();\n-            if(community != null) {\n-                ((CommunityTarget) result).setCommunity(new OctetString(community));\n-            }\n-        }\n-\n-        result.setVersion(version);\n-        result.setAddress(new UdpAddress(context.getProperty(HOST).getValue() + \"/\" + context.getProperty(PORT).getValue()));\n-        result.setRetries(context.getProperty(SNMP_RETRIES).asInteger());\n-        result.setTimeout(context.getProperty(SNMP_TIMEOUT).asInteger());\n-\n-        return result;\n-    }\n-\n }"
  },
  {
    "sha": "82d169c61b1633bef663e8ac9da80ebd8a206cfd",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/GetSNMP.java",
    "status": "modified",
    "additions": 77,
    "deletions": 76,
    "changes": 153,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/GetSNMP.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/GetSNMP.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/GetSNMP.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -16,58 +16,62 @@\n  */\n package org.apache.nifi.snmp.processors;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-\n import org.apache.nifi.annotation.behavior.InputRequirement;\n import org.apache.nifi.annotation.behavior.InputRequirement.Requirement;\n import org.apache.nifi.annotation.behavior.WritesAttribute;\n import org.apache.nifi.annotation.behavior.WritesAttributes;\n import org.apache.nifi.annotation.documentation.CapabilityDescription;\n import org.apache.nifi.annotation.documentation.Tags;\n+import org.apache.nifi.annotation.lifecycle.OnScheduled;\n import org.apache.nifi.components.PropertyDescriptor;\n import org.apache.nifi.flowfile.FlowFile;\n import org.apache.nifi.processor.ProcessContext;\n import org.apache.nifi.processor.ProcessSession;\n import org.apache.nifi.processor.Processor;\n import org.apache.nifi.processor.Relationship;\n-import org.apache.nifi.processor.util.StandardValidators;\n import org.apache.nifi.processor.exception.ProcessException;\n+import org.apache.nifi.processor.util.StandardValidators;\n+import org.apache.nifi.snmp.operations.SNMPGetter;\n+import org.apache.nifi.snmp.utils.SNMPUtils;\n import org.snmp4j.PDU;\n import org.snmp4j.event.ResponseEvent;\n import org.snmp4j.smi.OID;\n import org.snmp4j.util.TreeEvent;\n \n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n /**\n  * Retrieving data from configured SNMP agent which, upon each invocation of\n  * {@link #onTrigger(ProcessContext, ProcessSession)} method, will construct a\n  * {@link FlowFile} containing in its properties the information retrieved.\n  * The output {@link FlowFile} won't have any content.\n  */\n-@Tags({ \"snmp\", \"get\", \"oid\", \"walk\" })\n+@Tags({\"snmp\", \"get\", \"oid\", \"walk\"})\n @InputRequirement(Requirement.INPUT_FORBIDDEN)\n @CapabilityDescription(\"Retrieves information from SNMP Agent and outputs a FlowFile with information in attributes and without any content\")\n @WritesAttributes({\n-    @WritesAttribute(attribute=SNMPUtils.SNMP_PROP_PREFIX + \"*\", description=\"Attributes retrieved from the SNMP response. It may include:\"\n-            + \" snmp$errorIndex, snmp$errorStatus, snmp$errorStatusText, snmp$nonRepeaters, snmp$requestID, snmp$type, snmp$variableBindings\"),\n-    @WritesAttribute(attribute=SNMPUtils.SNMP_PROP_PREFIX + \"textualOid\", description=\"This attribute will exist if and only if the strategy\"\n-            + \" is GET and will be equal to the value given in Textual Oid property.\")\n+        @WritesAttribute(attribute = SNMPUtils.SNMP_PROP_PREFIX + \"*\", description = \"Attributes retrieved from the SNMP response. It may include:\"\n+                + \" snmp$errorIndex, snmp$errorStatus, snmp$errorStatusText, snmp$nonRepeaters, snmp$requestID, snmp$type, snmp$variableBindings\"),\n+        @WritesAttribute(attribute = SNMPUtils.SNMP_PROP_PREFIX + \"textualOid\", description = \"This attribute will exist if and only if the strategy\"\n+                + \" is GET and will be equal to the value given in Textual Oid property.\")\n })\n-public class GetSNMP extends AbstractSNMPProcessor<SNMPGetter> {\n+public class GetSNMP extends AbstractSNMPProcessor {\n \n-    /** OID to request (if walk, it is the root ID of the request) */\n+    // OID to request (if walk, it is the root ID of the request).\n     public static final PropertyDescriptor OID = new PropertyDescriptor.Builder()\n             .name(\"snmp-oid\")\n             .displayName(\"OID\")\n             .description(\"The OID to request\")\n             .required(true)\n-            .addValidator(SNMPUtils.SNMP_OID_VALIDATOR)\n+            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)\n             .build();\n \n-    /** Textual OID to request */\n+    // Textual OID to request.\n     public static final PropertyDescriptor TEXTUAL_OID = new PropertyDescriptor.Builder()\n             .name(\"snmp-textual-oid\")\n             .displayName(\"Textual OID\")\n@@ -77,7 +81,7 @@\n             .defaultValue(null)\n             .build();\n \n-    /** SNMP strategy for SNMP Get processor : simple get or walk */\n+    // SNMP strategy for SNMP Get processor: GET or WALK.\n     public static final PropertyDescriptor SNMP_STRATEGY = new PropertyDescriptor.Builder()\n             .name(\"snmp-strategy\")\n             .displayName(\"SNMP strategy (GET/WALK)\")\n@@ -87,113 +91,110 @@\n             .defaultValue(\"GET\")\n             .build();\n \n-    /** relationship for success */\n     public static final Relationship REL_SUCCESS = new Relationship.Builder()\n             .name(\"success\")\n             .description(\"All FlowFiles that are received from the SNMP agent are routed to this relationship\")\n             .build();\n \n-    /** relationship for failure */\n     public static final Relationship REL_FAILURE = new Relationship.Builder()\n             .name(\"failure\")\n             .description(\"All FlowFiles that cannot received from the SNMP agent are routed to this relationship\")\n             .build();\n \n-    /** list of property descriptors */\n-    private final static List<PropertyDescriptor> propertyDescriptors;\n+    private static final List<PropertyDescriptor> PROPERTY_DESCRIPTORS = createPropertyList();\n \n-    /** list of relationships */\n-    private final static Set<Relationship> relationships;\n+    private static final Set<Relationship> RELATIONSHIPS = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(\n+            REL_SUCCESS,\n+            REL_FAILURE\n+    )));\n \n-    /*\n-     * Will ensure that the list of property descriptors is build only once.\n-     * Will also create a Set of relationships\n-     */\n-    static {\n-        List<PropertyDescriptor> _propertyDescriptors = new ArrayList<>();\n-        _propertyDescriptors.add(OID);\n-        _propertyDescriptors.add(TEXTUAL_OID);\n-        _propertyDescriptors.add(SNMP_STRATEGY);\n-        _propertyDescriptors.addAll(descriptors);\n-        propertyDescriptors = Collections.unmodifiableList(_propertyDescriptors);\n-\n-        Set<Relationship> _relationships = new HashSet<>();\n-        _relationships.add(REL_SUCCESS);\n-        _relationships.add(REL_FAILURE);\n-        relationships = Collections.unmodifiableSet(_relationships);\n+    private SNMPGetter snmpGetter;\n+\n+    @OnScheduled\n+    @Override\n+    public void initSnmpClient(ProcessContext context) {\n+        super.initSnmpClient(context);\n+        String oid = context.getProperty(OID).getValue();\n+        snmpGetter = new SNMPGetter(snmpContext.getSnmp(), snmpContext.getTarget(), new OID(oid));\n     }\n \n     /**\n      * Delegate method to supplement\n      * {@link #onTrigger(ProcessContext, ProcessSession)}. It is implemented by\n      * sub-classes to perform {@link Processor} specific functionality.\n      *\n-     * @param context\n-     *            instance of {@link ProcessContext}\n-     * @param processSession\n-     *            instance of {@link ProcessSession}\n+     * @param context        instance of {@link ProcessContext}\n+     * @param processSession instance of {@link ProcessSession}\n      * @throws ProcessException Process exception\n      */\n     @Override\n-    protected void onTriggerSnmp(ProcessContext context, ProcessSession processSession) throws ProcessException {\n-        if(\"GET\".equals(context.getProperty(SNMP_STRATEGY).getValue())) {\n-            final ResponseEvent response = this.targetResource.get();\n-            if (response.getResponse() != null){\n-                FlowFile flowFile = processSession.create();\n+    public void onTrigger(ProcessContext context, ProcessSession processSession) {\n+        final String targetUri = snmpContext.getTarget().getAddress().toString();\n+        final String snmpStrategy = context.getProperty(SNMP_STRATEGY).getValue();\n+        final String oid = context.getProperty(OID).getValue();\n+\n+        if (\"GET\".equals(snmpStrategy)) {\n+            final ResponseEvent response = snmpGetter.get();\n+            if (response.getResponse() != null) {\n                 PDU pdu = response.getResponse();\n-                flowFile = SNMPUtils.updateFlowFileAttributesWithPduProperties(pdu, flowFile, processSession);\n-                flowFile = SNMPUtils.addAttribute(SNMPUtils.SNMP_PROP_PREFIX + \"textualOid\",\n-                        context.getProperty(TEXTUAL_OID).getValue(), flowFile, processSession);\n-                processSession.getProvenanceReporter().receive(flowFile,\n-                        this.snmpTarget.getAddress().toString() + \"/\" + context.getProperty(OID).getValue());\n-                if(pdu.getErrorStatus() == PDU.noError) {\n+                FlowFile flowFile = createFlowFile(context, processSession, pdu);\n+                processSession.getProvenanceReporter().receive(flowFile, targetUri + \"/\" + oid);\n+                if (pdu.getErrorStatus() == PDU.noError) {\n                     processSession.transfer(flowFile, REL_SUCCESS);\n                 } else {\n                     processSession.transfer(flowFile, REL_FAILURE);\n                 }\n             } else {\n-                this.getLogger().error(\"Get request timed out or parameters are incorrect.\");\n+                getLogger().error(\"Get request timed out or parameters are incorrect.\");\n                 context.yield();\n             }\n-        } else if(\"WALK\".equals(context.getProperty(SNMP_STRATEGY).getValue())) {\n-            final List<TreeEvent> events = this.targetResource.walk();\n-            if((events != null) && !events.isEmpty() && (events.get(0).getVariableBindings() != null)) {\n+        } else if (\"WALK\".equals(snmpStrategy)) {\n+            final List<TreeEvent> events = snmpGetter.walk();\n+            if (areValidEvents(events)) {\n                 FlowFile flowFile = processSession.create();\n                 for (TreeEvent treeEvent : events) {\n                     flowFile = SNMPUtils.updateFlowFileAttributesWithTreeEventProperties(treeEvent, flowFile, processSession);\n                 }\n-                processSession.getProvenanceReporter().receive(flowFile,\n-                        this.snmpTarget.getAddress().toString() + \"/\" + context.getProperty(OID).getValue());\n+                processSession.getProvenanceReporter().receive(flowFile, targetUri + \"/\" + oid);\n                 processSession.transfer(flowFile, REL_SUCCESS);\n             } else {\n-                this.getLogger().error(\"Get request timed out or parameters are incorrect.\");\n+                getLogger().error(\"Get request timed out or parameters are incorrect.\");\n                 context.yield();\n             }\n         }\n     }\n \n-    /**\n-     * Will create an instance of {@link SNMPGetter}\n-     */\n     @Override\n-    protected SNMPGetter finishBuildingTargetResource(ProcessContext context) {\n-        String oid = context.getProperty(OID).getValue();\n-        return new SNMPGetter(this.snmp, this.snmpTarget, new OID(oid));\n+    protected List<PropertyDescriptor> getSupportedPropertyDescriptors() {\n+        return PROPERTY_DESCRIPTORS;\n     }\n \n-    /**\n-     * get list of supported property descriptors\n-     */\n     @Override\n-    protected List<PropertyDescriptor> getSupportedPropertyDescriptors() {\n-        return propertyDescriptors;\n+    public Set<Relationship> getRelationships() {\n+        return RELATIONSHIPS;\n     }\n \n     /**\n-     * get list of relationships\n+     * Creates a list of the base class' and the current properties.\n+     *\n+     * @return a list of properties\n      */\n-    @Override\n-    public Set<Relationship> getRelationships() {\n-        return relationships;\n+    private static List<PropertyDescriptor> createPropertyList() {\n+        List<PropertyDescriptor> propertyDescriptors = new ArrayList<>();\n+        propertyDescriptors.addAll(BASIC_PROPERTIES);\n+        propertyDescriptors.addAll(Arrays.asList(OID, TEXTUAL_OID, SNMP_STRATEGY));\n+        return Collections.unmodifiableList(propertyDescriptors);\n+    }\n+\n+    private FlowFile createFlowFile(ProcessContext context, ProcessSession processSession, PDU pdu) {\n+        FlowFile flowFile = processSession.create();\n+        flowFile = SNMPUtils.updateFlowFileAttributesWithPduProperties(pdu, flowFile, processSession);\n+        flowFile = SNMPUtils.addAttribute(SNMPUtils.SNMP_PROP_PREFIX + \"textualOid\", context.getProperty(TEXTUAL_OID).getValue(),\n+                flowFile, processSession);\n+        return flowFile;\n+    }\n+\n+    private boolean areValidEvents(List<TreeEvent> events) {\n+        return (events != null) && !events.isEmpty() && (events.get(0).getVariableBindings() != null);\n     }\n }"
  },
  {
    "sha": "1b578956ed99c0f7156ba3efedbef4535159fc17",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/SetSNMP.java",
    "status": "modified",
    "additions": 55,
    "deletions": 137,
    "changes": 192,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/SetSNMP.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/SetSNMP.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/SetSNMP.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -16,209 +16,127 @@\n  */\n package org.apache.nifi.snmp.processors;\n \n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.Set;\n-\n import org.apache.nifi.annotation.behavior.InputRequirement;\n import org.apache.nifi.annotation.behavior.InputRequirement.Requirement;\n import org.apache.nifi.annotation.documentation.CapabilityDescription;\n import org.apache.nifi.annotation.documentation.Tags;\n+import org.apache.nifi.annotation.lifecycle.OnScheduled;\n import org.apache.nifi.components.PropertyDescriptor;\n import org.apache.nifi.flowfile.FlowFile;\n import org.apache.nifi.processor.ProcessContext;\n import org.apache.nifi.processor.ProcessSession;\n import org.apache.nifi.processor.Relationship;\n-import org.apache.nifi.processor.exception.ProcessException;\n+import org.apache.nifi.snmp.operations.SNMPSetter;\n+import org.apache.nifi.snmp.utils.SNMPUtils;\n import org.snmp4j.PDU;\n import org.snmp4j.ScopedPDU;\n import org.snmp4j.event.ResponseEvent;\n import org.snmp4j.mp.SnmpConstants;\n-import org.snmp4j.smi.AbstractVariable;\n-import org.snmp4j.smi.AssignableFromInteger;\n-import org.snmp4j.smi.AssignableFromLong;\n-import org.snmp4j.smi.AssignableFromString;\n-import org.snmp4j.smi.OID;\n-import org.snmp4j.smi.OctetString;\n-import org.snmp4j.smi.Variable;\n-import org.snmp4j.smi.VariableBinding;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n \n /**\n  * Performs a SNMP Set operation based on attributes of incoming FlowFile.\n  * Upon each invocation of {@link #onTrigger(ProcessContext, ProcessSession)}\n  * method, it will inspect attributes of FlowFile and look for attributes with\n  * name formatted as \"snmp$OID\" to set the attribute value to this OID.\n  */\n-@Tags({ \"snmp\", \"set\", \"oid\" })\n+@Tags({\"snmp\", \"set\", \"oid\"})\n @InputRequirement(Requirement.INPUT_REQUIRED)\n @CapabilityDescription(\"Based on incoming FlowFile attributes, the processor will execute SNMP Set requests.\" +\n         \" When founding attributes with name like snmp$<OID>, the processor will atempt to set the value of\" +\n         \" attribute to the corresponding OID given in the attribute name\")\n-public class SetSNMP extends AbstractSNMPProcessor<SNMPSetter> {\n+public class SetSNMP extends AbstractSNMPProcessor {\n \n-    /** relationship for success */\n     public static final Relationship REL_SUCCESS = new Relationship.Builder()\n             .name(\"success\")\n             .description(\"All FlowFiles that have been successfully used to perform SNMP Set are routed to this relationship\")\n             .build();\n-    /** relationship for failure */\n+\n     public static final Relationship REL_FAILURE = new Relationship.Builder()\n             .name(\"failure\")\n             .description(\"All FlowFiles that failed during the SNMP Set care routed to this relationship\")\n             .build();\n \n-    /** list of properties descriptors */\n-    private final static List<PropertyDescriptor> propertyDescriptors;\n+    private static final Set<Relationship> RELATIONSHIPS = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(\n+            REL_SUCCESS,\n+            REL_FAILURE\n+    )));\n \n-    /** list of relationships */\n-    private final static Set<Relationship> relationships;\n-\n-    /*\n-     * Will ensure that the list of property descriptors is build only once.\n-     * Will also create a Set of relationships\n-     */\n-    static {\n-        List<PropertyDescriptor> _propertyDescriptors = new ArrayList<>();\n-        _propertyDescriptors.addAll(descriptors);\n-        propertyDescriptors = Collections.unmodifiableList(_propertyDescriptors);\n+    private SNMPSetter snmpSetter;\n \n-        Set<Relationship> _relationships = new HashSet<>();\n-        _relationships.add(REL_SUCCESS);\n-        _relationships.add(REL_FAILURE);\n-        relationships = Collections.unmodifiableSet(_relationships);\n+    @OnScheduled\n+    public void initSnmpClient(ProcessContext context) {\n+        super.initSnmpClient(context);\n+        snmpSetter = new SNMPSetter(snmpContext.getSnmp(), snmpContext.getTarget());\n     }\n \n-    /**\n-     * @see org.apache.nifi.snmp.processors.AbstractSNMPProcessor#onTriggerSnmp(org.apache.nifi.processor.ProcessContext, org.apache.nifi.processor.ProcessSession)\n-     */\n+\n     @Override\n-    protected void onTriggerSnmp(ProcessContext context, ProcessSession processSession) throws ProcessException {\n+    public void onTrigger(ProcessContext context, ProcessSession processSession) {\n         FlowFile flowFile = processSession.get();\n         if (flowFile != null) {\n-            // Create the PDU object\n-            PDU pdu = null;\n-            if(this.snmpTarget.getVersion() == SnmpConstants.version3) {\n-                pdu = new ScopedPDU();\n-            } else {\n-                pdu = new PDU();\n-            }\n-            if(this.addVariables(pdu, flowFile.getAttributes())) {\n+            PDU pdu = createPdu();\n+            if (SNMPUtils.addVariables(pdu, flowFile.getAttributes(), getLogger())) {\n                 pdu.setType(PDU.SET);\n-                try {\n-                    ResponseEvent response = this.targetResource.set(pdu);\n-                    if(response.getResponse() == null) {\n-                        processSession.transfer(processSession.penalize(flowFile), REL_FAILURE);\n-                        this.getLogger().error(\"Set request timed out or parameters are incorrect.\");\n-                        context.yield();\n-                    } else if(response.getResponse().getErrorStatus() == PDU.noError) {\n-                        flowFile = SNMPUtils.updateFlowFileAttributesWithPduProperties(pdu, flowFile, processSession);\n-                        processSession.transfer(flowFile, REL_SUCCESS);\n-                        processSession.getProvenanceReporter().send(flowFile, this.snmpTarget.getAddress().toString());\n-                    } else {\n-                        final String error = response.getResponse().getErrorStatusText();\n-                        flowFile = SNMPUtils.addAttribute(SNMPUtils.SNMP_PROP_PREFIX + \"error\", error, flowFile, processSession);\n-                        processSession.transfer(processSession.penalize(flowFile), REL_FAILURE);\n-                        this.getLogger().error(\"Failed while executing SNMP Set [{}] via \" + this.targetResource + \". Error = {}\", new Object[]{response.getRequest().getVariableBindings(), error});\n-                    }\n-                } catch (IOException e) {\n-                    processSession.transfer(processSession.penalize(flowFile), REL_FAILURE);\n-                    this.getLogger().error(\"Failed while executing SNMP Set via \" + this.targetResource, e);\n-                    context.yield();\n-                }\n+                processPdu(context, processSession, flowFile, pdu);\n             } else {\n                 processSession.transfer(processSession.penalize(flowFile), REL_FAILURE);\n-                this.getLogger().warn(\"No attributes found in the FlowFile to perform SNMP Set\");\n+                getLogger().warn(\"No attributes found in the FlowFile to perform SNMP Set\");\n             }\n         }\n     }\n \n-    /**\n-     * Method to construct {@link VariableBinding} based on {@link FlowFile}\n-     * attributes in order to update the {@link PDU} that is going to be sent to\n-     * the SNMP Agent.\n-     * @param pdu {@link PDU} to be sent\n-     * @param attributes {@link FlowFile} attributes\n-     * @return true if at least one {@link VariableBinding} has been created, false otherwise\n-     */\n-    private boolean addVariables(PDU pdu, Map<String, String> attributes) {\n-        boolean result = false;\n-        for (Entry<String, String> attributeEntry : attributes.entrySet()) {\n-            if (attributeEntry.getKey().startsWith(SNMPUtils.SNMP_PROP_PREFIX)) {\n-                String[] splits = attributeEntry.getKey().split(\"\\\\\" + SNMPUtils.SNMP_PROP_DELIMITER);\n-                String snmpPropName = splits[1];\n-                String snmpPropValue = attributeEntry.getValue();\n-                if(SNMPUtils.OID_PATTERN.matcher(snmpPropName).matches()) {\n-                    Variable var = null;\n-                    if (splits.length == 2) { // no SMI syntax defined\n-                        var = new OctetString(snmpPropValue);\n-                    } else {\n-                        int smiSyntax = Integer.valueOf(splits[2]);\n-                        var = this.stringToVariable(snmpPropValue, smiSyntax);\n-                    }\n-                    if(var != null) {\n-                        VariableBinding varBind = new VariableBinding(new OID(snmpPropName), var);\n-                        pdu.add(varBind);\n-                        result = true;\n-                    }\n-                }\n+    private void processPdu(ProcessContext context, ProcessSession processSession, FlowFile flowFile, PDU pdu) {\n+        try {\n+            ResponseEvent response = snmpSetter.set(pdu);\n+            if (response.getResponse() == null) {\n+                processSession.transfer(processSession.penalize(flowFile), REL_FAILURE);\n+                getLogger().error(\"Set request timed out or parameters are incorrect.\");\n+                context.yield();\n+            } else if (response.getResponse().getErrorStatus() == PDU.noError) {\n+                flowFile = SNMPUtils.updateFlowFileAttributesWithPduProperties(pdu, flowFile, processSession);\n+                processSession.transfer(flowFile, REL_SUCCESS);\n+                processSession.getProvenanceReporter().send(flowFile, snmpContext.getTarget().getAddress().toString());\n+            } else {\n+                final String error = response.getResponse().getErrorStatusText();\n+                flowFile = SNMPUtils.addAttribute(SNMPUtils.SNMP_PROP_PREFIX + \"error\", error, flowFile, processSession);\n+                processSession.transfer(processSession.penalize(flowFile), REL_FAILURE);\n+                getLogger().error(\"Failed while executing SNMP Set [{}] via {}. Error = {}\", response.getRequest().getVariableBindings(), snmpSetter, error);\n             }\n+        } catch (IOException e) {\n+            processSession.transfer(processSession.penalize(flowFile), REL_FAILURE);\n+            getLogger().error(\"Failed while executing SNMP Set via \" + snmpSetter, e);\n+            context.yield();\n         }\n-        return result;\n     }\n \n-    /**\n-     * Method to create the variable from the attribute value and the given SMI syntax value\n-     * @param value attribute value\n-     * @param smiSyntax attribute SMI Syntax\n-     * @return variable\n-     */\n-    private Variable stringToVariable(String value, int smiSyntax) {\n-        Variable var = AbstractVariable.createFromSyntax(smiSyntax);\n-        try {\n-            if (var instanceof AssignableFromString) {\n-                ((AssignableFromString) var).setValue(value);\n-            } else if (var instanceof AssignableFromInteger) {\n-                ((AssignableFromInteger) var).setValue(Integer.valueOf(value));\n-            } else if (var instanceof AssignableFromLong) {\n-                ((AssignableFromLong) var).setValue(Long.valueOf(value));\n-            } else {\n-                this.getLogger().error(\"Unsupported conversion of [\" + value +\"] to \" + var.getSyntaxString());\n-                var = null;\n-            }\n-        } catch (IllegalArgumentException e) {\n-            this.getLogger().error(\"Unsupported conversion of [\" + value +\"] to \" + var.getSyntaxString(), e);\n-            var = null;\n+    private PDU createPdu() {\n+        if (snmpContext.getTarget().getVersion() == SnmpConstants.version3) {\n+            return new ScopedPDU();\n+        } else {\n+            return new PDU();\n         }\n-        return var;\n     }\n \n     /**\n      * @see org.apache.nifi.components.AbstractConfigurableComponent#getSupportedPropertyDescriptors()\n      */\n     @Override\n     protected List<PropertyDescriptor> getSupportedPropertyDescriptors() {\n-        return propertyDescriptors;\n+        return BASIC_PROPERTIES;\n     }\n \n     /**\n      * @see org.apache.nifi.processor.AbstractSessionFactoryProcessor#getRelationships()\n      */\n     @Override\n     public Set<Relationship> getRelationships() {\n-        return relationships;\n+        return RELATIONSHIPS;\n     }\n-\n-    /**\n-     * @see org.apache.nifi.snmp.processors.AbstractSNMPProcessor#finishBuildingTargetResource(org.apache.nifi.processor.ProcessContext)\n-     */\n-    @Override\n-    protected SNMPSetter finishBuildingTargetResource(ProcessContext context) {\n-        return new SNMPSetter(this.snmp, this.snmpTarget);\n-    }\n-\n }"
  },
  {
    "sha": "35216f440c89bfb9f6f97c6662f70058275d4e62",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/utils/SNMPUtils.java",
    "status": "renamed",
    "additions": 162,
    "deletions": 89,
    "changes": 251,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/utils/SNMPUtils.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/utils/SNMPUtils.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/utils/SNMPUtils.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -14,92 +14,97 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.nifi.snmp.processors;\n+package org.apache.nifi.snmp.utils;\n \n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Vector;\n-import java.util.regex.Pattern;\n-\n-import org.apache.nifi.components.ValidationContext;\n import org.apache.nifi.components.ValidationResult;\n import org.apache.nifi.components.Validator;\n import org.apache.nifi.flowfile.FlowFile;\n+import org.apache.nifi.logging.ComponentLog;\n import org.apache.nifi.processor.ProcessSession;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.snmp4j.PDU;\n+import org.snmp4j.mp.SnmpConstants;\n+\n+\n import org.snmp4j.security.AuthMD5;\n import org.snmp4j.security.AuthSHA;\n import org.snmp4j.security.Priv3DES;\n import org.snmp4j.security.PrivAES128;\n import org.snmp4j.security.PrivAES192;\n import org.snmp4j.security.PrivAES256;\n import org.snmp4j.security.PrivDES;\n-import org.snmp4j.security.SecurityLevel;\n+import org.snmp4j.smi.AbstractVariable;\n+import org.snmp4j.smi.AssignableFromInteger;\n+import org.snmp4j.smi.AssignableFromLong;\n+import org.snmp4j.smi.AssignableFromString;\n import org.snmp4j.smi.OID;\n+import org.snmp4j.smi.OctetString;\n+import org.snmp4j.smi.Variable;\n import org.snmp4j.smi.VariableBinding;\n import org.snmp4j.util.TreeEvent;\n \n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Vector;\n+import java.util.regex.Pattern;\n+\n /**\n  * Utility helper class that simplifies interactions with target SNMP API and NIFI API.\n  */\n-abstract class SNMPUtils {\n+public class SNMPUtils {\n \n-    /** logger */\n-    private final static Logger logger = LoggerFactory.getLogger(SNMPUtils.class);\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SNMPUtils.class);\n \n-    /** OID Pattern */\n-    public final static Pattern OID_PATTERN = Pattern.compile(\"[[0-9]+\\\\.]*\");\n+    public static final Pattern OID_PATTERN = Pattern.compile(\"[[0-9]+\\\\.]*\");\n \n-    /** delimiter for properties name */\n-    public final static String SNMP_PROP_DELIMITER = \"$\";\n+    // Delimiter for properties name.\n+    public static final String SNMP_PROP_DELIMITER = \"$\";\n \n-    /** prefix for SNMP properties in flow file */\n-    public final static String SNMP_PROP_PREFIX = \"snmp\" + SNMP_PROP_DELIMITER;\n+    // Prefix for SNMP properties in flow file.\n+    public static final String SNMP_PROP_PREFIX = \"snmp\" + SNMP_PROP_DELIMITER;\n \n-    /** list of properties name when performing simple get */\n-    private final static List<String> propertyNames = Arrays.asList(\"snmp$errorIndex\", \"snmp$errorStatus\", \"snmp$errorStatusText\",\n+    // List of properties name when performing simple get.\n+    private static final List<String> PROPERTY_NAMES = Arrays.asList(\"snmp$errorIndex\", \"snmp$errorStatus\", \"snmp$errorStatusText\",\n             \"snmp$nonRepeaters\", \"snmp$requestID\", \"snmp$type\", \"snmp$variableBindings\");\n \n-    /** used to validate OID syntax */\n-    public static final Validator SNMP_OID_VALIDATOR = new Validator() {\n-        @Override\n-        public ValidationResult validate(final String subject, final String input, final ValidationContext context) {\n-            final ValidationResult.Builder builder = new ValidationResult.Builder();\n-            builder.subject(subject).input(input);\n-            if (context.isExpressionLanguageSupported(subject) && context.isExpressionLanguagePresent(input)) {\n-                return builder.valid(true).explanation(\"Contains Expression Language\").build();\n-            }\n-            try {\n-                if (OID_PATTERN.matcher(input).matches()) {\n-                    builder.valid(true);\n-                } else {\n-                    builder.valid(false).explanation(input + \"is not a valid OID\");\n-                }\n-            } catch (final IllegalArgumentException e) {\n-                builder.valid(false).explanation(e.getMessage());\n+    // Used to validate OID syntax.\n+    public static final Validator SNMP_OID_VALIDATOR = (subject, input, context) -> {\n+        final ValidationResult.Builder builder = new ValidationResult.Builder();\n+        builder.subject(subject).input(input);\n+        if (context.isExpressionLanguageSupported(subject) && context.isExpressionLanguagePresent(input)) {\n+            return builder.valid(true).explanation(\"Contains Expression Language\").build();\n+        }\n+        try {\n+            if (OID_PATTERN.matcher(input).matches()) {\n+                builder.valid(true);\n+            } else {\n+                builder.valid(false).explanation(input + \"is not a valid OID\");\n             }\n-            return builder.build();\n+        } catch (final IllegalArgumentException e) {\n+            builder.valid(false).explanation(e.getMessage());\n         }\n+        return builder.build();\n     };\n \n     /**\n      * Updates {@link FlowFile} with attributes representing PDU properties\n-     * @param response PDU retried from SNMP Agent\n-     * @param flowFile instance of target {@link FlowFile}\n+     *\n+     * @param response       PDU retried from SNMP Agent\n+     * @param flowFile       instance of target {@link FlowFile}\n      * @param processSession instance of {@link ProcessSession}\n      * @return updated {@link FlowFile}\n      */\n     public static FlowFile updateFlowFileAttributesWithPduProperties(PDU response, FlowFile flowFile, ProcessSession processSession) {\n         if (response != null) {\n             try {\n                 Method[] methods = PDU.class.getDeclaredMethods();\n-                Map<String, String> attributes = new HashMap<String, String>();\n+                Map<String, String> attributes = new HashMap<>();\n                 for (Method method : methods) {\n                     if (Modifier.isPublic(method.getModifiers()) && (method.getParameterTypes().length == 0) && method.getName().startsWith(\"get\")) {\n                         String propertyName = extractPropertyNameFromMethod(method);\n@@ -117,45 +122,48 @@ public static FlowFile updateFlowFileAttributesWithPduProperties(PDU response, F\n                 }\n                 flowFile = processSession.putAllAttributes(flowFile, attributes);\n             } catch (Exception e) {\n-                logger.warn(\"Failed to update FlowFile with AMQP attributes\", e);\n+                LOGGER.warn(\"Failed to update FlowFile with AMQP attributes\", e);\n             }\n         }\n         return flowFile;\n     }\n \n     /**\n      * Method to add attribute in flow file\n-     * @param key attribute key\n-     * @param value attribute value\n-     * @param flowFile flow file to update\n+     *\n+     * @param key            attribute key\n+     * @param value          attribute value\n+     * @param flowFile       flow file to update\n      * @param processSession session\n      * @return updated flow file\n      */\n     public static FlowFile addAttribute(String key, String value, FlowFile flowFile, ProcessSession processSession) {\n-        Map<String, String> attributes = new HashMap<String, String>();\n+        Map<String, String> attributes = new HashMap<>();\n         attributes.put(key, value);\n         flowFile = processSession.putAllAttributes(flowFile, attributes);\n         return flowFile;\n     }\n \n     /**\n      * Method to construct {@link FlowFile} attributes from a {@link TreeEvent}\n-     * @param treeEvent a {@link TreeEvent}\n-     * @param flowFile instance of the {@link FlowFile} to update\n+     *\n+     * @param treeEvent      a {@link TreeEvent}\n+     * @param flowFile       instance of the {@link FlowFile} to update\n      * @param processSession instance of {@link ProcessSession}\n      * @return updated {@link FlowFile}\n      */\n     public static FlowFile updateFlowFileAttributesWithTreeEventProperties(TreeEvent treeEvent, FlowFile flowFile, ProcessSession processSession) {\n-        Map<String, String> attributes = new HashMap<String, String>();\n+        Map<String, String> attributes = new HashMap<>();\n         addWalkOidValues(attributes, treeEvent.getVariableBindings());\n         flowFile = processSession.putAllAttributes(flowFile, attributes);\n         return flowFile;\n     }\n \n     /**\n      * Method to construct {@link FlowFile} attributes from a vector of {@link VariableBinding}\n+     *\n      * @param attributes attributes\n-     * @param vector vector of {@link VariableBinding}\n+     * @param vector     vector of {@link VariableBinding}\n      */\n     private static void addWalkOidValues(Map<String, String> attributes, Object vector) {\n         if (vector instanceof VariableBinding[]) {\n@@ -168,8 +176,9 @@ private static void addWalkOidValues(Map<String, String> attributes, Object vect\n \n     /**\n      * Method to construct {@link FlowFile} attributes from a vector of {@link VariableBinding}\n+     *\n      * @param attributes attributes\n-     * @param vector vector of {@link VariableBinding}\n+     * @param vector     vector of {@link VariableBinding}\n      */\n     private static void addGetOidValues(Map<String, String> attributes, Object vector) {\n         if (vector instanceof Vector) {\n@@ -183,86 +192,150 @@ private static void addGetOidValues(Map<String, String> attributes, Object vecto\n \n     /**\n      * Method to add {@link FlowFile} attributes from a {@link VariableBinding}\n+     *\n      * @param variableBinding {@link VariableBinding}\n-     * @param attributes {@link FlowFile} attributes to update\n+     * @param attributes      {@link FlowFile} attributes to update\n      */\n     private static void addAttributeFromVariable(VariableBinding variableBinding, Map<String, String> attributes) {\n         attributes.put(SNMP_PROP_PREFIX + variableBinding.getOid() + SNMP_PROP_DELIMITER + variableBinding.getVariable().getSyntax(), variableBinding.getVariable().toString());\n     }\n \n     /**\n      * Will validate if provided name corresponds to valid SNMP property.\n+     *\n      * @param name the name of the property\n      * @return 'true' if valid otherwise 'false'\n      */\n     public static boolean isValidSnmpPropertyName(String name) {\n-        return propertyNames.contains(name);\n+        return PROPERTY_NAMES.contains(name);\n     }\n \n     /**\n      * Method to extract property name from given {@link Method}\n+     *\n      * @param method method\n      * @return property name\n      */\n     private static String extractPropertyNameFromMethod(Method method) {\n-        char c[] = method.getName().substring(3).toCharArray();\n+        char[] c = method.getName().substring(3).toCharArray();\n         c[0] = Character.toLowerCase(c[0]);\n         return SNMP_PROP_PREFIX + new String(c);\n     }\n \n     /**\n-     * Method to return the private protocol given the property\n+     * Method to return the private protocol given the property.\n+     *\n      * @param privProtocol property\n      * @return protocol\n      */\n     public static OID getPriv(String privProtocol) {\n         switch (privProtocol) {\n-        case \"DES\":\n-            return PrivDES.ID;\n-        case \"3DES\":\n-            return Priv3DES.ID;\n-        case \"AES128\":\n-            return PrivAES128.ID;\n-        case \"AES192\":\n-            return PrivAES192.ID;\n-        case \"AES256\":\n-            return PrivAES256.ID;\n-        default:\n-            return null;\n+            case \"DES\":\n+                return PrivDES.ID;\n+            case \"3DES\":\n+                return Priv3DES.ID;\n+            case \"AES128\":\n+                return PrivAES128.ID;\n+            case \"AES192\":\n+                return PrivAES192.ID;\n+            case \"AES256\":\n+                return PrivAES256.ID;\n+            default:\n+                return null;\n         }\n     }\n \n     /**\n-     * Method to return the authentication protocol given the property\n+     * Method to return the authentication protocol given the property.\n+     *\n      * @param authProtocol property\n      * @return protocol\n      */\n     public static OID getAuth(String authProtocol) {\n         switch (authProtocol) {\n-        case \"SHA\":\n-            return AuthSHA.ID;\n-        case \"MD5\":\n-            return AuthMD5.ID;\n-        default:\n-            return null;\n+            case \"SHA\":\n+                return AuthSHA.ID;\n+            case \"MD5\":\n+                return AuthMD5.ID;\n+            default:\n+                return null;\n         }\n     }\n \n+    public static int getSnmpVersion(String snmpVersion) {\n+        if (\"SNMPv1\".equals(snmpVersion)) {\n+            return SnmpConstants.version1;\n+        } else if (\"SNMPv2c\".equals(snmpVersion)) {\n+            return SnmpConstants.version2c;\n+        } else if (\"SNMPv3\".equals(snmpVersion)) {\n+            return SnmpConstants.version3;\n+        }\n+        throw new RuntimeException(\"SNMP version is invalid or not supported.\");\n+    }\n+\n     /**\n-     * Method to get security level from string representation of level\n-     * @param level level\n-     * @return security level as integer\n+     * Method to create the variable from the attribute value and the given SMI syntax value\n+     *\n+     * @param value     attribute value\n+     * @param smiSyntax attribute SMI Syntax\n+     * @return variable\n      */\n-    public static int getSecLevel(String level) {\n-        switch (level) {\n-        case \"noAuthNoPriv\":\n-            return SecurityLevel.NOAUTH_NOPRIV;\n-        case \"authNoPriv\":\n-            return SecurityLevel.AUTH_NOPRIV;\n-        case \"authPriv\":\n-        default:\n-            return SecurityLevel.AUTH_PRIV;\n+    public static Variable stringToVariable(String value, int smiSyntax, ComponentLog logger) {\n+        Variable var = AbstractVariable.createFromSyntax(smiSyntax);\n+        try {\n+            if (var instanceof AssignableFromString) {\n+                ((AssignableFromString) var).setValue(value);\n+            } else if (var instanceof AssignableFromInteger) {\n+                ((AssignableFromInteger) var).setValue(Integer.parseInt(value));\n+            } else if (var instanceof AssignableFromLong) {\n+                ((AssignableFromLong) var).setValue(Long.parseLong(value));\n+            } else {\n+                logger.error(\"Unsupported conversion of [ {} ] to \", var.getSyntaxString());\n+                var = null;\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.error(\"Unsupported conversion of [ {} ] to \", var.getSyntaxString(), e);\n+            var = null;\n         }\n+        return var;\n     }\n \n+    /**\n+     * Method to construct {@link VariableBinding} based on {@link FlowFile}\n+     * attributes in order to update the {@link PDU} that is going to be sent to\n+     * the SNMP Agent.\n+     *\n+     * @param pdu        {@link PDU} to be sent\n+     * @param attributes {@link FlowFile} attributes\n+     * @return true if at least one {@link VariableBinding} has been created, false otherwise\n+     */\n+    public static boolean addVariables(PDU pdu, Map<String, String> attributes, ComponentLog logger) {\n+        boolean result = false;\n+        for (Map.Entry<String, String> attributeEntry : attributes.entrySet()) {\n+            if (attributeEntry.getKey().startsWith(SNMPUtils.SNMP_PROP_PREFIX)) {\n+                String[] splits = attributeEntry.getKey().split(\"\\\\\" + SNMPUtils.SNMP_PROP_DELIMITER);\n+                String snmpPropName = splits[1];\n+                String snmpPropValue = attributeEntry.getValue();\n+                if (SNMPUtils.OID_PATTERN.matcher(snmpPropName).matches()) {\n+                    Variable var;\n+                    if (splits.length == 2) { // no SMI syntax defined\n+                        var = new OctetString(snmpPropValue);\n+                    } else {\n+                        int smiSyntax = Integer.parseInt(splits[2]);\n+                        var = SNMPUtils.stringToVariable(snmpPropValue, smiSyntax, logger);\n+                    }\n+                    if (var != null) {\n+                        VariableBinding varBind = new VariableBinding(new OID(snmpPropName), var);\n+                        pdu.add(varBind);\n+                        result = true;\n+                    }\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private SNMPUtils() {\n+        // hide implicit constructor\n+    }\n }",
    "previous_filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/processors/SNMPUtils.java"
  },
  {
    "sha": "0a730b272befb780c06ad6ab15f6eba7151f16de",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/validators/OIDValidator.java",
    "status": "added",
    "additions": 101,
    "deletions": 0,
    "changes": 101,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/validators/OIDValidator.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/validators/OIDValidator.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/java/org/apache/nifi/snmp/validators/OIDValidator.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.validators;\n+\n+import org.apache.nifi.components.ValidationResult;\n+import org.apache.nifi.snmp.configuration.SecurityConfiguration;\n+import org.apache.nifi.util.StringUtils;\n+import org.snmp4j.security.SecurityLevel;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class OIDValidator {\n+\n+    private static final String SNMP_V3 = \"SNMPv3\";\n+\n+    private final SecurityConfiguration securityConfiguration;\n+    private final List<ValidationResult> problems;\n+\n+    public OIDValidator(final SecurityConfiguration securityConfiguration, final List<ValidationResult> problems) {\n+        this.securityConfiguration = securityConfiguration;\n+        this.problems = problems;\n+    }\n+\n+    public Collection<ValidationResult> validate() {\n+        final boolean isVersion3 = SNMP_V3.equals(securityConfiguration.getVersion());\n+        final boolean isSecurityNameInvalid = isInvalid(securityConfiguration.getSecurityName());\n+        final boolean isCommunityStringInvalid = isInvalid(securityConfiguration.getCommunityString());\n+\n+        if (isVersion3 && isSecurityNameInvalid) {\n+            problems.add(new ValidationResult.Builder()\n+                    .input(\"SNMP Security Name\")\n+                    .valid(false)\n+                    .explanation(\"SNMP Security Name must be set with SNMPv3.\")\n+                    .build());\n+            checkSecurityLevel(securityConfiguration, problems);\n+\n+        } else if (isCommunityStringInvalid) {\n+            problems.add(new ValidationResult.Builder()\n+                    .input(\"SNMP Community\")\n+                    .valid(false)\n+                    .explanation(\"SNMP Community must be set with SNMPv1 and SNMPv2c.\")\n+                    .build());\n+        }\n+        return problems;\n+    }\n+\n+    private void checkSecurityLevel(SecurityConfiguration securityConfiguration, List<ValidationResult> problems) {\n+\n+        final boolean isAuthProtocolInvalid = isInvalid(securityConfiguration.getAuthProtocol());\n+        final boolean isAuthPasswordInvalid = isInvalid(securityConfiguration.getAuthPassword());\n+        final boolean isPrivacyProtocolInvalid = isInvalid(securityConfiguration.getPrivacyProtocol());\n+        final boolean isPrivacyPasswordInvalid = isInvalid(securityConfiguration.getPrivacyPassword());\n+        final SecurityLevel securityLevel = SecurityLevel.valueOf(securityConfiguration.getSecurityLevel());\n+\n+        if (isAuthNoPrivSecurityLevelInvalid(securityLevel, isAuthProtocolInvalid, isAuthPasswordInvalid)) {\n+            problems.add(new ValidationResult.Builder()\n+                    .input(\"SNMP Security Level\")\n+                    .valid(false)\n+                    .explanation(\"Authentication protocol and password must be set when using authNoPriv security level.\")\n+                    .build());\n+        }\n+\n+        if (isAuthPrivSecurityLevelInvalid(securityLevel, isAuthProtocolInvalid, isAuthPasswordInvalid, isPrivacyProtocolInvalid, isPrivacyPasswordInvalid)) {\n+            problems.add(new ValidationResult.Builder()\n+                    .input(\"SNMP Security Level\")\n+                    .valid(false)\n+                    .explanation(\"All protocols and passwords must be set when using authPriv security level.\")\n+                    .build());\n+        }\n+    }\n+\n+    private boolean isInvalid(String property) {\n+        return Objects.isNull(property) || StringUtils.EMPTY.equals(property);\n+    }\n+\n+    private boolean isAuthNoPrivSecurityLevelInvalid(final SecurityLevel securityLevel, final boolean isAuthProtocolInvalid, final boolean isAuthPasswordInvalid) {\n+        return SecurityLevel.authNoPriv == securityLevel && (isAuthProtocolInvalid || isAuthPasswordInvalid);\n+    }\n+\n+    private boolean isAuthPrivSecurityLevelInvalid(final SecurityLevel securityLevel, final boolean isAuthProtocolInvalid, final boolean isAuthPasswordInvalid,\n+                                                   final boolean isPrivacyProtocolInvalid, final boolean isPrivacyPasswordInvalid) {\n+        return SecurityLevel.authPriv == securityLevel && (isAuthProtocolInvalid || isAuthPasswordInvalid || isPrivacyProtocolInvalid || isPrivacyPasswordInvalid);\n+    }\n+\n+}"
  },
  {
    "sha": "9b2f4789089123a507d9bff4ab703197101eac56",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/resources/docs/org.apache.nifi.snmp.processors.GetSNMP/additionalDetails.html",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/resources/docs/org.apache.nifi.snmp.processors.GetSNMP/additionalDetails.html",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/resources/docs/org.apache.nifi.snmp.processors.GetSNMP/additionalDetails.html",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/main/resources/docs/org.apache.nifi.snmp.processors.GetSNMP/additionalDetails.html?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -60,8 +60,8 @@ <h2>Configuration Details</h2>\n     <li><b>Security Name</b> - [REQUIRED if SNMPv3] the security name (user name) to use.</li>\n     <li><b>Authentication Protocol</b> - [REQUIRED if SNMPv3 and authNoPriv or authPriv] the authentication protocol to use.</li>\n     <li><b>Authentication Password</b> - [REQUIRED if SNMPv3 and authNoPriv or authPriv] the authentication password to use.</li>\n-    <li><b>Private Protocol</b> - [REQUIRED if SNMPv3 and authPriv] the private protocol to use.</li>\n-    <li><b>Private Password</b> - [REQUIRED if SNMPv3 and authPriv] the private password to use.</li>\n+    <li><b>Privacy Protocol</b> - [REQUIRED if SNMPv3 and authPriv] the privacy protocol to use.</li>\n+    <li><b>Privacy Password</b> - [REQUIRED if SNMPv3 and authPriv] the privacy password to use.</li>\n     <li><b>Retries</b> - [REQUIRED] Sets the number of retries to be performed before a request is timed out. (default is 0)</li>\n     <li><b>Timeout</b> - [REQUIRED] Sets  timeout in milliseconds before a confirmed request is resent or timed out. (default is 5000)</li>\n </ul>"
  },
  {
    "sha": "1d25141b8fde18b5ea0439213ce9d6db4779548b",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/context/SNMPContextTest.java",
    "status": "added",
    "additions": 134,
    "deletions": 0,
    "changes": 134,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/context/SNMPContextTest.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/context/SNMPContextTest.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/context/SNMPContextTest.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.context;\n+\n+import org.apache.nifi.snmp.configuration.BasicConfiguration;\n+import org.apache.nifi.snmp.configuration.SecurityConfiguration;\n+import org.apache.nifi.snmp.configuration.SecurityConfigurationBuilder;\n+import org.apache.nifi.snmp.helper.SNMPTestUtil;\n+import org.apache.nifi.snmp.testagents.TestSNMPV3Agent;\n+import org.junit.Test;\n+import org.snmp4j.CommunityTarget;\n+import org.snmp4j.TransportMapping;\n+import org.snmp4j.UserTarget;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SNMPContextTest {\n+\n+    private static final BasicConfiguration basicConfiguration = new BasicConfiguration(SNMPTestUtil.availablePort(), \"localhost\", SNMPTestUtil.availablePort(), 1, 1000);\n+\n+    @Test\n+    public void testSnmpV1CreatesCommunityTarget() {\n+        SNMPContext snmpContext = SNMPContext.newInstance();\n+        SecurityConfiguration securityConfiguration = new SecurityConfigurationBuilder()\n+                .setVersion(\"SNMPv1\")\n+                .setSecurityLevel(\"noAuthNoPriv\")\n+                .setSecurityName(\"userName\")\n+                .setAuthProtocol(\"SHA\")\n+                .setAuthPassword(\"authPassword\")\n+                .setPrivacyProtocol(\"DES\")\n+                .setPrivacyPassword(\"privacyPassword\")\n+                .setCommunityString(\"public\")\n+                .createSecurityConfiguration();\n+\n+        snmpContext.init(basicConfiguration, securityConfiguration);\n+\n+        assertThat(snmpContext.getTarget(), instanceOf(CommunityTarget.class));\n+\n+        snmpContext.close();\n+    }\n+\n+    @Test\n+    public void testSnmpV2cCreatesCommunityTarget() {\n+        SNMPContext snmpContext = SNMPContext.newInstance();\n+        SecurityConfiguration securityConfiguration = new SecurityConfigurationBuilder()\n+                .setVersion(\"SNMPv2c\")\n+                .setSecurityLevel(\"noAuthNoPriv\")\n+                .setSecurityName(\"userName\")\n+                .setAuthProtocol(\"SHA\")\n+                .setAuthPassword(\"authPassword\")\n+                .setPrivacyProtocol(\"DES\")\n+                .setPrivacyPassword(\"privacyPassword\")\n+                .setCommunityString(\"public\")\n+                .createSecurityConfiguration();\n+\n+        snmpContext.init(basicConfiguration, securityConfiguration);\n+\n+        assertThat(snmpContext.getTarget(), instanceOf(CommunityTarget.class));\n+\n+        snmpContext.close();\n+    }\n+\n+    @Test\n+    public void testSnmpV3CreatesUserTarget() throws IOException {\n+\n+        TestSNMPV3Agent snmpV3Agent = new TestSNMPV3Agent(\"0.0.0.0\");\n+        snmpV3Agent.start();\n+\n+        SNMPContext snmpContext = SNMPContext.newInstance();\n+        SecurityConfiguration securityConfiguration = new SecurityConfigurationBuilder()\n+                .setVersion(\"SNMPv3\")\n+                .setSecurityLevel(\"authNoPriv\")\n+                .setSecurityName(\"SHA\")\n+                .setAuthProtocol(\"SHA\")\n+                .setAuthPassword(\"authPassword\")\n+                .setPrivacyProtocol(\"DES\")\n+                .setPrivacyPassword(\"privacyPassword\")\n+                .setCommunityString(\"public\")\n+                .createSecurityConfiguration();\n+\n+        snmpContext.init(basicConfiguration, securityConfiguration);\n+\n+        assertThat(snmpContext.getTarget(), instanceOf(UserTarget.class));\n+\n+        snmpV3Agent.stop();\n+\n+        snmpContext.close();\n+    }\n+\n+    @Test\n+    public void testResourcesClosed() {\n+        SNMPContext snmpContext = SNMPContext.newInstance();\n+        SecurityConfiguration securityConfiguration = new SecurityConfigurationBuilder()\n+                .setVersion(\"SNMPv2c\")\n+                .setSecurityLevel(\"noAuthNoPriv\")\n+                .setSecurityName(\"userName\")\n+                .setAuthProtocol(\"SHA\")\n+                .setAuthPassword(\"authPassword\")\n+                .setPrivacyProtocol(\"DES\")\n+                .setPrivacyPassword(\"privacyPassword\")\n+                .setCommunityString(\"public\")\n+                .createSecurityConfiguration();\n+\n+        snmpContext.init(basicConfiguration, securityConfiguration);\n+        snmpContext.close();\n+\n+        final Collection<TransportMapping> transportMappings = snmpContext.getSnmp().getMessageDispatcher().getTransportMappings();\n+\n+        boolean isAllClosed = transportMappings.stream().noneMatch(TransportMapping::isListening);\n+\n+        assertTrue(isAllClosed);\n+\n+        snmpContext.close();\n+    }\n+}"
  },
  {
    "sha": "b712c6307065c5cf56896d94675d804d7a36f6a3",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/helper/SNMPTestUtil.java",
    "status": "added",
    "additions": 100,
    "deletions": 0,
    "changes": 100,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/helper/SNMPTestUtil.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/helper/SNMPTestUtil.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/helper/SNMPTestUtil.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.helper;\n+\n+import org.apache.nifi.flowfile.FlowFile;\n+\n+import java.net.ServerSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class SNMPTestUtil {\n+\n+    /**\n+     * Will determine an available port.\n+     */\n+    public static synchronized int availablePort() {\n+        try (ServerSocket s = new ServerSocket(0)) {\n+            s.setReuseAddress(true);\n+            return s.getLocalPort();\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Failed to discover available port.\", e);\n+        }\n+    }\n+\n+    public static FlowFile createFlowFile(final long id, final long fileSize, final Map<String, String> attributes) {\n+        final Map<String, String> attrCopy = new HashMap<>(attributes);\n+\n+        return new FlowFile() {\n+            @Override\n+            public long getId() {\n+                return id;\n+            }\n+\n+            @Override\n+            public long getEntryDate() {\n+                return System.currentTimeMillis();\n+            }\n+\n+            @Override\n+            public long getLineageStartDate() {\n+                return System.currentTimeMillis();\n+            }\n+\n+            @Override\n+            public Long getLastQueueDate() {\n+                return System.currentTimeMillis();\n+            }\n+\n+            @Override\n+            public boolean isPenalized() {\n+                return false;\n+            }\n+\n+            @Override\n+            public String getAttribute(final String s) {\n+                return attrCopy.get(s);\n+            }\n+\n+            @Override\n+            public long getSize() {\n+                return fileSize;\n+            }\n+\n+            @Override\n+            public Map<String, String> getAttributes() {\n+                return attrCopy;\n+            }\n+\n+            @Override\n+            public int compareTo(final FlowFile o) {\n+                return 0;\n+            }\n+\n+            @Override\n+            public long getLineageStartIndex() {\n+                return 0;\n+            }\n+\n+            @Override\n+            public long getQueueDateIndex() {\n+                return 0;\n+            }\n+        };\n+    }\n+\n+}"
  },
  {
    "sha": "a51cb8f0b6c9e9dc27b7e70018c31bd93abe858b",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/operations/SNMPGetterTest.java",
    "status": "added",
    "additions": 174,
    "deletions": 0,
    "changes": 174,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/operations/SNMPGetterTest.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/operations/SNMPGetterTest.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/operations/SNMPGetterTest.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.operations;\n+\n+import org.apache.nifi.processor.exception.ProcessException;\n+import org.apache.nifi.snmp.helper.SNMPTestUtil;\n+import org.apache.nifi.snmp.testagents.TestSNMPV1Agent;\n+import org.apache.nifi.snmp.testagents.TestSNMPV2Agent;\n+import org.apache.nifi.snmp.testagents.TestSNMPV3Agent;\n+import org.apache.nifi.snmp.utils.SNMPUtilsTest;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.snmp4j.CommunityTarget;\n+import org.snmp4j.SNMP4JSettings;\n+import org.snmp4j.Snmp;\n+import org.snmp4j.UserTarget;\n+import org.snmp4j.agent.mo.DefaultMOFactory;\n+import org.snmp4j.agent.mo.MOAccessImpl;\n+import org.snmp4j.event.ResponseEvent;\n+import org.snmp4j.mp.SnmpConstants;\n+import org.snmp4j.security.AuthSHA;\n+import org.snmp4j.security.SecurityLevel;\n+import org.snmp4j.smi.OID;\n+import org.snmp4j.smi.OctetString;\n+import org.snmp4j.smi.VariableBinding;\n+import org.snmp4j.util.TreeEvent;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+\n+public class SNMPGetterTest {\n+\n+    private static TestSNMPV1Agent snmpV1Agent;\n+    private static TestSNMPV2Agent snmpV2Agent;\n+    private static TestSNMPV3Agent snmpV3Agent;\n+    private static final OID readOnlyOID1 = new OID(\"1.3.6.1.4.1.32437.1.5.1.4.2.0\");\n+    private static final OID readOnlyOID2 = new OID(\"1.3.6.1.4.1.32437.1.5.1.4.3.0\");\n+    private static final String OIDValue1 = \"TestOID1\";\n+    private static final String OIDValue2 = \"TestOID2\";\n+\n+\n+    @BeforeClass\n+    public static void setUp() throws IOException {\n+        snmpV1Agent = new TestSNMPV1Agent(\"0.0.0.0\");\n+        snmpV1Agent.start();\n+        snmpV1Agent.registerManagedObjects(\n+                DefaultMOFactory.getInstance().createScalar(new OID(readOnlyOID1), MOAccessImpl.ACCESS_READ_ONLY, new OctetString(OIDValue1)),\n+                DefaultMOFactory.getInstance().createScalar(new OID(readOnlyOID2), MOAccessImpl.ACCESS_READ_ONLY, new OctetString(OIDValue2))\n+        );\n+        snmpV2Agent = new TestSNMPV2Agent(\"0.0.0.0\");\n+        snmpV2Agent.start();\n+        snmpV2Agent.registerManagedObjects(\n+                DefaultMOFactory.getInstance().createScalar(new OID(readOnlyOID1), MOAccessImpl.ACCESS_READ_ONLY, new OctetString(OIDValue1)),\n+                DefaultMOFactory.getInstance().createScalar(new OID(readOnlyOID2), MOAccessImpl.ACCESS_READ_ONLY, new OctetString(OIDValue2))\n+        );\n+        snmpV3Agent = new TestSNMPV3Agent(\"0.0.0.0\");\n+        snmpV3Agent.start();\n+        snmpV3Agent.registerManagedObjects(\n+                DefaultMOFactory.getInstance().createScalar(new OID(readOnlyOID1), MOAccessImpl.ACCESS_READ_ONLY, new OctetString(OIDValue1))\n+        );\n+    }\n+\n+\n+    @AfterClass\n+    public static void tearDown() {\n+        snmpV1Agent.stop();\n+        snmpV2Agent.stop();\n+        snmpV3Agent.stop();\n+    }\n+\n+    @Test\n+    public void testSuccessfulSnmpV1Get() throws IOException {\n+        Snmp snmp = SNMPUtilsTest.createSnmp();\n+        CommunityTarget target = SNMPUtilsTest.createCommTarget(\"public\", \"127.0.0.1/\" + snmpV1Agent.getPort(), SnmpConstants.version1);\n+        try (SNMPGetter getter = new SNMPGetter(snmp, target, readOnlyOID1)) {\n+            ResponseEvent response = getter.get();\n+            assertEquals(OIDValue1, response.getResponse().get(0).getVariable().toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testSuccessfulSnmpV1Walk() throws IOException {\n+        Snmp snmp = SNMPUtilsTest.createSnmp();\n+        CommunityTarget target = SNMPUtilsTest.createCommTarget(\"public\", \"127.0.0.1/\" + snmpV1Agent.getPort(), SnmpConstants.version1);\n+        try (SNMPGetter getter = new SNMPGetter(snmp, target, new OID(\"1.3.6.1.4.1.32437\"))) {\n+            final List<TreeEvent> responseEvents = getter.walk();\n+            assertEquals(OIDValue1, responseEvents.get(0).getVariableBindings()[0].getVariable().toString());\n+            assertEquals(OIDValue2, responseEvents.get(1).getVariableBindings()[0].getVariable().toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testSuccessfulSnmpV2Get() throws IOException {\n+        Snmp snmp = SNMPUtilsTest.createSnmp();\n+        CommunityTarget target = SNMPUtilsTest.createCommTarget(\"public\", \"127.0.0.1/\" + snmpV2Agent.getPort(), SnmpConstants.version2c);\n+        try (SNMPGetter getter = new SNMPGetter(snmp, target, readOnlyOID1)) {\n+            ResponseEvent response = getter.get();\n+            assertEquals(OIDValue1, response.getResponse().get(0).getVariable().toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testSuccessfulSnmpV2Walk() throws IOException {\n+        Snmp snmp = SNMPUtilsTest.createSnmp();\n+        CommunityTarget target = SNMPUtilsTest.createCommTarget(\"public\", \"127.0.0.1/\" + snmpV2Agent.getPort(), SnmpConstants.version2c);\n+        try (SNMPGetter getter = new SNMPGetter(snmp, target, new OID(\"1.3.6.1.4.1.32437\"))) {\n+            final List<TreeEvent> responseEvents = getter.walk();\n+            final VariableBinding[] variableBindings = responseEvents.get(0).getVariableBindings();\n+            assertEquals(OIDValue1, variableBindings[0].getVariable().toString());\n+            assertEquals(OIDValue2, variableBindings[1].getVariable().toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testSuccessfulSnmpV3Get() throws IOException {\n+        SNMP4JSettings.setForwardRuntimeExceptions(true);\n+        Snmp snmp = SNMPUtilsTest.createSnmp();\n+        final UserTarget userTarget = SNMPUtilsTest.prepareUser(snmp, \"127.0.0.1/\" + snmpV3Agent.getPort(), SecurityLevel.AUTH_NOPRIV,\n+                \"SHA\", AuthSHA.ID, null, \"SHAAuthPassword\", null);\n+        try (SNMPGetter getter = new SNMPGetter(snmp, userTarget, readOnlyOID1)) {\n+            ResponseEvent response = getter.get();\n+            assertEquals(OIDValue1, response.getResponse().get(0).getVariable().toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testUnauthorizedUserSnmpV3GetReturnsNull() throws IOException {\n+        SNMP4JSettings.setForwardRuntimeExceptions(true);\n+        Snmp snmp = SNMPUtilsTest.createSnmp();\n+        final UserTarget userTarget = SNMPUtilsTest.prepareUser(snmp, \"127.0.0.1/\" + snmpV3Agent.getPort(), SecurityLevel.AUTH_NOPRIV,\n+                \"FakeUserName\", AuthSHA.ID, null, \"FakeAuthPassword\", null);\n+        try (SNMPGetter getter = new SNMPGetter(snmp, userTarget, readOnlyOID1)) {\n+            ResponseEvent response = getter.get();\n+            assertEquals(\"Null\", response.getResponse().get(0).getVariable().toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testSnmpV1GetTimeoutReturnsNull() throws IOException {\n+        Snmp snmp = SNMPUtilsTest.createSnmp();\n+        CommunityTarget target = SNMPUtilsTest.createCommTarget(\"public\", \"1.2.3.4/\" + SNMPTestUtil.availablePort(), SnmpConstants.version1);\n+        try (SNMPGetter getter = new SNMPGetter(snmp, target, readOnlyOID1)) {\n+            ResponseEvent response = getter.get();\n+            assertNull(response.getResponse());\n+        }\n+    }\n+\n+    @Test(expected = ProcessException.class)\n+    public void testSnmpV1GetWithInvalidTargetThrowsException() throws IOException {\n+        Snmp snmp = SNMPUtilsTest.createSnmp();\n+        CommunityTarget target = SNMPUtilsTest.createCommTarget(\"public\", \"127.0.0.1/\" + snmpV1Agent.getPort(), -1);\n+        try (SNMPGetter getter = new SNMPGetter(snmp, target, readOnlyOID1)) {\n+            getter.get();\n+        }\n+    }\n+}"
  },
  {
    "sha": "21b01b14fccae96c7b8cc86621fd70837aefbccc",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/operations/SNMPSetterTest.java",
    "status": "added",
    "additions": 153,
    "deletions": 0,
    "changes": 153,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/operations/SNMPSetterTest.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/operations/SNMPSetterTest.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/operations/SNMPSetterTest.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.operations;\n+\n+import org.apache.nifi.snmp.testagents.TestSNMPV1Agent;\n+import org.apache.nifi.snmp.testagents.TestSNMPV2Agent;\n+import org.apache.nifi.snmp.testagents.TestSNMPV3Agent;\n+import org.apache.nifi.snmp.utils.SNMPUtilsTest;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.snmp4j.CommunityTarget;\n+import org.snmp4j.PDU;\n+import org.snmp4j.ScopedPDU;\n+import org.snmp4j.Snmp;\n+import org.snmp4j.UserTarget;\n+import org.snmp4j.agent.mo.DefaultMOFactory;\n+import org.snmp4j.agent.mo.MOAccessImpl;\n+import org.snmp4j.event.ResponseEvent;\n+import org.snmp4j.mp.SnmpConstants;\n+import org.snmp4j.security.AuthSHA;\n+import org.snmp4j.security.SecurityLevel;\n+import org.snmp4j.smi.OID;\n+import org.snmp4j.smi.OctetString;\n+import org.snmp4j.smi.VariableBinding;\n+\n+import java.io.IOException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+\n+public class SNMPSetterTest {\n+\n+    private static TestSNMPV1Agent snmpV1Agent;\n+    private static TestSNMPV2Agent snmpV2Agent;\n+    private static TestSNMPV3Agent snmpV3Agent;\n+    private static final OID readOnlyOID = new OID(\"1.3.6.1.4.1.32437.1.5.1.4.2.0\");\n+    private static final OID writeOnlyOID = new OID(\"1.3.6.1.4.1.32437.1.5.1.4.3.0\");\n+    private static final String readOnlyOIDValue = \"readOnlyOID\";\n+    private static final String writeOnlyOIDValue = \"writeOnlyOID\";\n+\n+\n+    @BeforeClass\n+    public static void setUp() throws IOException {\n+        snmpV1Agent = new TestSNMPV1Agent(\"0.0.0.0\");\n+        snmpV1Agent.start();\n+        snmpV1Agent.registerManagedObjects(\n+                DefaultMOFactory.getInstance().createScalar(new OID(readOnlyOID), MOAccessImpl.ACCESS_READ_ONLY, new OctetString(readOnlyOIDValue)),\n+                DefaultMOFactory.getInstance().createScalar(new OID(writeOnlyOID), MOAccessImpl.ACCESS_WRITE_ONLY, new OctetString(writeOnlyOIDValue))\n+        );\n+        snmpV2Agent = new TestSNMPV2Agent(\"0.0.0.0\");\n+        snmpV2Agent.start();\n+        snmpV2Agent.registerManagedObjects(\n+                DefaultMOFactory.getInstance().createScalar(new OID(readOnlyOID), MOAccessImpl.ACCESS_READ_ONLY, new OctetString(readOnlyOIDValue)),\n+                DefaultMOFactory.getInstance().createScalar(new OID(writeOnlyOID), MOAccessImpl.ACCESS_WRITE_ONLY, new OctetString(writeOnlyOIDValue))\n+        );\n+        snmpV3Agent = new TestSNMPV3Agent(\"0.0.0.0\");\n+        snmpV3Agent.start();\n+        snmpV3Agent.registerManagedObjects(\n+                DefaultMOFactory.getInstance().createScalar(new OID(readOnlyOID), MOAccessImpl.ACCESS_READ_ONLY, new OctetString(readOnlyOIDValue)),\n+                DefaultMOFactory.getInstance().createScalar(new OID(writeOnlyOID), MOAccessImpl.ACCESS_WRITE_ONLY, new OctetString(writeOnlyOIDValue))\n+        );\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() {\n+        snmpV1Agent.stop();\n+        snmpV2Agent.stop();\n+        snmpV3Agent.stop();\n+    }\n+\n+    @Test\n+    public void testSuccessfulSnmpV1Set() throws IOException, InterruptedException {\n+        Snmp snmp = SNMPUtilsTest.createSnmp();\n+        CommunityTarget target = SNMPUtilsTest.createCommTarget(\"public\", \"127.0.0.1/\" + snmpV1Agent.getPort(), SnmpConstants.version1);\n+        String expectedOIDValue = \"testValue\";\n+        try (SNMPSetter setter = new SNMPSetter(snmp, target)) {\n+            PDU pdu = new PDU();\n+            pdu.add(new VariableBinding(writeOnlyOID, new OctetString(expectedOIDValue)));\n+            pdu.setType(PDU.SET);\n+            ResponseEvent response = setter.set(pdu);\n+\n+            assertEquals(expectedOIDValue, response.getResponse().get(0).getVariable().toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testSuccessfulSnmpV2Set() throws IOException {\n+        Snmp snmp = SNMPUtilsTest.createSnmp();\n+        CommunityTarget target = SNMPUtilsTest.createCommTarget(\"public\", \"127.0.0.1/\" + snmpV2Agent.getPort(), SnmpConstants.version2c);\n+        String expectedOIDValue = \"testValue\";\n+        try (SNMPSetter setter = new SNMPSetter(snmp, target)) {\n+            PDU pdu = new PDU();\n+            pdu.add(new VariableBinding(readOnlyOID, new OctetString(expectedOIDValue)));\n+            pdu.setType(PDU.SET);\n+            ResponseEvent response = setter.set(pdu);\n+\n+            assertEquals(expectedOIDValue, response.getResponse().get(0).getVariable().toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testSuccessfulSnmpV3Set() throws IOException {\n+        Snmp snmp = SNMPUtilsTest.createSnmp();\n+        final UserTarget userTarget = SNMPUtilsTest.prepareUser(snmp, \"127.0.0.1/\" + snmpV3Agent.getPort(), SecurityLevel.AUTH_NOPRIV,\n+                \"SHA\", AuthSHA.ID, null, \"SHAAuthPassword\", null);\n+        String expectedOIDValue = \"testValue\";\n+        try (SNMPSetter setter = new SNMPSetter(snmp, userTarget)) {\n+            ScopedPDU pdu = new ScopedPDU();\n+            pdu.add(new VariableBinding(writeOnlyOID, new OctetString(expectedOIDValue)));\n+            pdu.setType(PDU.SET);\n+            ResponseEvent response = setter.set(pdu);\n+\n+            assertEquals(expectedOIDValue, response.getResponse().get(0).getVariable().toString());\n+        }\n+    }\n+\n+    @Test\n+    public void testCannotSetReadOnlyObject() throws IOException {\n+        Snmp snmp = SNMPUtilsTest.createSnmp();\n+        final UserTarget userTarget = SNMPUtilsTest.prepareUser(snmp, \"127.0.0.1/\" + snmpV3Agent.getPort(), SecurityLevel.AUTH_NOPRIV,\n+                \"SHA\", AuthSHA.ID, null, \"SHAAuthPassword\", null);\n+        String expectedOIDValue = \"testValue\";\n+        try (SNMPSetter setter = new SNMPSetter(snmp, userTarget); SNMPGetter getter = new SNMPGetter(snmp, userTarget, readOnlyOID)) {\n+            ScopedPDU pdu = new ScopedPDU();\n+            pdu.add(new VariableBinding(readOnlyOID, new OctetString(expectedOIDValue)));\n+            pdu.setType(PDU.SET);\n+            ResponseEvent response = setter.set(pdu);\n+\n+            assertEquals(expectedOIDValue, response.getResponse().get(0).getVariable().toString());\n+\n+            final ResponseEvent responseEvent = getter.get();\n+\n+            assertNotEquals(expectedOIDValue, responseEvent.getResponse().get(0).getVariable().toString());\n+            assertEquals(readOnlyOIDValue, responseEvent.getResponse().get(0).getVariable().toString());\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "f6128fe77b07d8dd4794b3fce6ea8c6dce1891a7",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/processors/GetSNMPTest.java",
    "status": "added",
    "additions": 102,
    "deletions": 0,
    "changes": 102,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/processors/GetSNMPTest.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/processors/GetSNMPTest.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/processors/GetSNMPTest.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.processors;\n+\n+import org.apache.nifi.snmp.testagents.TestSNMPV1Agent;\n+import org.apache.nifi.snmp.utils.SNMPUtils;\n+import org.apache.nifi.util.MockFlowFile;\n+import org.apache.nifi.util.TestRunner;\n+import org.apache.nifi.util.TestRunners;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.snmp4j.agent.mo.DefaultMOFactory;\n+import org.snmp4j.agent.mo.MOAccessImpl;\n+import org.snmp4j.smi.OID;\n+import org.snmp4j.smi.OctetString;\n+\n+import java.io.IOException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class GetSNMPTest {\n+\n+    private static TestSNMPV1Agent snmpV1Agent;\n+    private static final OID readOnlyOID1 = new OID(\"1.3.6.1.4.1.32437.1.5.1.4.2.0\");\n+    private static final OID readOnlyOID2 = new OID(\"1.3.6.1.4.1.32437.1.5.1.4.3.0\");\n+    private static final String OIDValue1 = \"TestOID1\";\n+    private static final String OIDValue2 = \"TestOID2\";\n+\n+    @BeforeClass\n+    public static void setUp() throws IOException {\n+        snmpV1Agent = new TestSNMPV1Agent(\"0.0.0.0\");\n+        snmpV1Agent.start();\n+        snmpV1Agent.registerManagedObjects(\n+                DefaultMOFactory.getInstance().createScalar(new OID(readOnlyOID1), MOAccessImpl.ACCESS_READ_ONLY, new OctetString(OIDValue1)),\n+                DefaultMOFactory.getInstance().createScalar(new OID(readOnlyOID2), MOAccessImpl.ACCESS_READ_ONLY, new OctetString(OIDValue2))\n+        );\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() {\n+        snmpV1Agent.stop();\n+    }\n+\n+    @Test\n+    public void testSnmpV1Get() throws InterruptedException {\n+        TestRunner runner = getTestRunner(readOnlyOID1.toString(), String.valueOf(snmpV1Agent.getPort()), \"GET\");\n+        runner.run();\n+        Thread.sleep(200);\n+        final MockFlowFile successFF = runner.getFlowFilesForRelationship(GetSNMP.REL_SUCCESS).get(0);\n+        assertNotNull(successFF);\n+        assertEquals(OIDValue1, successFF.getAttribute(SNMPUtils.SNMP_PROP_PREFIX + readOnlyOID1.toString() + SNMPUtils.SNMP_PROP_DELIMITER + \"4\"));\n+    }\n+\n+    @Test\n+    public void testSnmpV1Walk() throws InterruptedException {\n+        TestRunner runner = getTestRunner(\"1.3.6.1.4.1.32437\", String.valueOf(snmpV1Agent.getPort()), \"WALK\");\n+        runner.run();\n+        Thread.sleep(200);\n+        final MockFlowFile successFF = runner.getFlowFilesForRelationship(GetSNMP.REL_SUCCESS).get(0);\n+        assertNotNull(successFF);\n+        assertEquals(OIDValue1, successFF.getAttribute(SNMPUtils.SNMP_PROP_PREFIX + readOnlyOID1.toString() + SNMPUtils.SNMP_PROP_DELIMITER + \"4\"));\n+        assertEquals(OIDValue2, successFF.getAttribute(SNMPUtils.SNMP_PROP_PREFIX + readOnlyOID2.toString() + SNMPUtils.SNMP_PROP_DELIMITER + \"4\"));\n+    }\n+\n+    @Test\n+    public void testInvalidPduResultsInFailure() throws InterruptedException {\n+        TestRunner runner = getTestRunner(\"1.3.6.1.4.1.32437.0\", String.valueOf(snmpV1Agent.getPort()), \"GET\");\n+        runner.run();\n+        Thread.sleep(200);\n+        final MockFlowFile failureFF = runner.getFlowFilesForRelationship(GetSNMP.REL_FAILURE).get(0);\n+        assertNotNull(failureFF);\n+        assertEquals(\"No such name\", failureFF.getAttribute(SNMPUtils.SNMP_PROP_PREFIX + \"errorStatusText\"));\n+    }\n+\n+    private TestRunner getTestRunner(String oid, String port, String strategy) {\n+        TestRunner runner = TestRunners.newTestRunner(GetSNMP.class);\n+        runner.setProperty(GetSNMP.OID, oid);\n+        runner.setProperty(GetSNMP.AGENT_HOST, \"127.0.0.1\");\n+        runner.setProperty(GetSNMP.AGENT_PORT, port);\n+        runner.setProperty(GetSNMP.SNMP_COMMUNITY, \"public\");\n+        runner.setProperty(GetSNMP.SNMP_VERSION, \"SNMPv1\");\n+        runner.setProperty(GetSNMP.SNMP_STRATEGY, strategy);\n+        return runner;\n+    }\n+\n+}"
  },
  {
    "sha": "442d473bb019b00226b40281b20fa41c037e3180",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/processors/SetSNMPTest.java",
    "status": "added",
    "additions": 159,
    "deletions": 0,
    "changes": 159,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/processors/SetSNMPTest.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/processors/SetSNMPTest.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/processors/SetSNMPTest.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.processors;\n+\n+import org.apache.nifi.snmp.testagents.TestSNMPV1Agent;\n+import org.apache.nifi.snmp.utils.SNMPUtils;\n+import org.apache.nifi.util.MockFlowFile;\n+import org.apache.nifi.util.TestRunner;\n+import org.apache.nifi.util.TestRunners;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.snmp4j.agent.mo.DefaultMOFactory;\n+import org.snmp4j.agent.mo.MOAccessImpl;\n+import org.snmp4j.smi.OID;\n+import org.snmp4j.smi.OctetString;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class SetSNMPTest {\n+\n+    private static TestSNMPV1Agent snmpV1Agent;\n+    private static final OID testOID = new OID(\"1.3.6.1.4.1.32437.1.5.1.4.2.0\");\n+    private static final String testOIDValue = \"TestOID\";\n+\n+    @BeforeClass\n+    public static void setUp() throws IOException {\n+        snmpV1Agent = new TestSNMPV1Agent(\"0.0.0.0\");\n+        snmpV1Agent.start();\n+        snmpV1Agent.registerManagedObjects(\n+                DefaultMOFactory.getInstance().createScalar(new OID(testOID), MOAccessImpl.ACCESS_READ_WRITE, new OctetString(testOIDValue))\n+        );\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() {\n+        snmpV1Agent.stop();\n+    }\n+\n+    @Test\n+    public void testSnmpV1Set() throws InterruptedException {\n+\n+        TestRunner runner = getTestRunner(String.valueOf(snmpV1Agent.getPort()));\n+        runner.run();\n+        Thread.sleep(200);\n+        final MockFlowFile successFF = runner.getFlowFilesForRelationship(SetSNMP.REL_SUCCESS).get(0);\n+        assertNotNull(successFF);\n+        assertEquals(testOIDValue, successFF.getAttribute(SNMPUtils.SNMP_PROP_PREFIX + testOID.toString() + SNMPUtils.SNMP_PROP_DELIMITER + \"4\"));\n+    }\n+\n+    @Test\n+    public void testSnmpV1SetEmptyFlowFileResultsInFailure() throws InterruptedException {\n+\n+        TestRunner runner = getTestRunnerWithEmptyFlowFile(String.valueOf(snmpV1Agent.getPort()));\n+        runner.run();\n+        Thread.sleep(200);\n+        final MockFlowFile failureFF = runner.getFlowFilesForRelationship(SetSNMP.REL_FAILURE).get(0);\n+        assertNotNull(failureFF);\n+    }\n+\n+    @Test\n+    public void testSnmpSetWithInvalidAddressResultsInFailure() throws InterruptedException {\n+\n+        TestRunner runner = getTestRunnerWithInvalidHost();\n+        runner.run();\n+        Thread.sleep(200);\n+        final MockFlowFile failureFF = runner.getFlowFilesForRelationship(SetSNMP.REL_FAILURE).get(0);\n+        assertNotNull(failureFF);\n+    }\n+\n+    @Test\n+    public void testSnmpSetWithInvalidOIDResultsInFailure() throws InterruptedException {\n+\n+        TestRunner runner = getTestRunnerWithInvalidOID();\n+        runner.run();\n+        Thread.sleep(200);\n+        final MockFlowFile failureFF = runner.getFlowFilesForRelationship(SetSNMP.REL_FAILURE).get(0);\n+        assertNotNull(failureFF);\n+    }\n+\n+    private TestRunner getTestRunner(String port) {\n+        SetSNMP processor = new SetSNMP();\n+        TestRunner runner = TestRunners.newTestRunner(processor);\n+        MockFlowFile ff = new MockFlowFile(123);\n+        final Map<String, String> attributes = ff.getAttributes();\n+        Map<String, String> newAttributes = new HashMap<>(attributes);\n+        newAttributes.put(\"snmp$1.3.6.1.4.1.32437.1.5.1.4.2.0$4\", testOIDValue);\n+        ff.putAttributes(newAttributes);\n+        runner.enqueue(ff);\n+        runner.setProperty(GetSNMP.AGENT_HOST, \"127.0.0.1\");\n+        runner.setProperty(GetSNMP.AGENT_PORT, port);\n+        runner.setProperty(GetSNMP.SNMP_COMMUNITY, \"public\");\n+        runner.setProperty(GetSNMP.SNMP_VERSION, \"SNMPv1\");\n+        return runner;\n+    }\n+\n+    private TestRunner getTestRunnerWithEmptyFlowFile(String port) {\n+        SetSNMP processor = new SetSNMP();\n+        TestRunner runner = TestRunners.newTestRunner(processor);\n+        runner.enqueue(new MockFlowFile(123));\n+        runner.setProperty(GetSNMP.AGENT_HOST, \"127.0.0.1\");\n+        runner.setProperty(GetSNMP.AGENT_PORT, port);\n+        runner.setProperty(GetSNMP.SNMP_COMMUNITY, \"public\");\n+        runner.setProperty(GetSNMP.SNMP_VERSION, \"SNMPv1\");\n+        return runner;\n+    }\n+\n+    private TestRunner getTestRunnerWithInvalidHost() {\n+        SetSNMP processor = new SetSNMP();\n+        TestRunner runner = TestRunners.newTestRunner(processor);\n+        MockFlowFile ff = new MockFlowFile(123);\n+        final Map<String, String> attributes = ff.getAttributes();\n+        Map<String, String> newAttributes = new HashMap<>(attributes);\n+        newAttributes.put(\"snmp$1.3.6.1.4.1.32437.1.5.1.4.2.0$4\", testOIDValue);\n+        ff.putAttributes(newAttributes);\n+        runner.enqueue(ff);\n+        runner.setProperty(GetSNMP.AGENT_HOST, \"127.0.0.2\");\n+        runner.setProperty(GetSNMP.AGENT_PORT, \"1234\");\n+        runner.setProperty(GetSNMP.SNMP_COMMUNITY, \"public\");\n+        runner.setProperty(GetSNMP.SNMP_VERSION, \"SNMPv1\");\n+        return runner;\n+    }\n+\n+    private TestRunner getTestRunnerWithInvalidOID() {\n+        SetSNMP processor = new SetSNMP();\n+        TestRunner runner = TestRunners.newTestRunner(processor);\n+        MockFlowFile ff = new MockFlowFile(123);\n+        final Map<String, String> attributes = ff.getAttributes();\n+        Map<String, String> newAttributes = new HashMap<>(attributes);\n+        newAttributes.put(\"snmp$1.3.6.1.4.1.32437.1.5.1.4.213.0$4\", testOIDValue);\n+        ff.putAttributes(newAttributes);\n+        runner.enqueue(ff);\n+        runner.setProperty(GetSNMP.AGENT_HOST, \"127.0.0.1\");\n+        runner.setProperty(GetSNMP.AGENT_PORT, String.valueOf(snmpV1Agent.getPort()));\n+        runner.setProperty(GetSNMP.SNMP_COMMUNITY, \"public\");\n+        runner.setProperty(GetSNMP.SNMP_VERSION, \"SNMPv1\");\n+        return runner;\n+    }\n+\n+}"
  },
  {
    "sha": "cb83cc5a30b0e4225f6b2b28972ba9e51811b5bc",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/testagents/TestSNMPV1Agent.java",
    "status": "added",
    "additions": 172,
    "deletions": 0,
    "changes": 172,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/testagents/TestSNMPV1Agent.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/testagents/TestSNMPV1Agent.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/testagents/TestSNMPV1Agent.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.testagents;\n+\n+import org.apache.nifi.snmp.helper.SNMPTestUtil;\n+import org.snmp4j.TransportMapping;\n+import org.snmp4j.agent.BaseAgent;\n+import org.snmp4j.agent.CommandProcessor;\n+import org.snmp4j.agent.DuplicateRegistrationException;\n+import org.snmp4j.agent.MOGroup;\n+import org.snmp4j.agent.ManagedObject;\n+import org.snmp4j.agent.mo.snmp.RowStatus;\n+import org.snmp4j.agent.mo.snmp.SnmpCommunityMIB;\n+import org.snmp4j.agent.mo.snmp.SnmpNotificationMIB;\n+import org.snmp4j.agent.mo.snmp.SnmpTargetMIB;\n+import org.snmp4j.agent.mo.snmp.StorageType;\n+import org.snmp4j.agent.mo.snmp.VacmMIB;\n+import org.snmp4j.agent.security.MutableVACM;\n+import org.snmp4j.log.ConsoleLogFactory;\n+import org.snmp4j.log.LogFactory;\n+import org.snmp4j.mp.MPv3;\n+import org.snmp4j.security.SecurityLevel;\n+import org.snmp4j.security.SecurityModel;\n+import org.snmp4j.security.USM;\n+import org.snmp4j.smi.Address;\n+import org.snmp4j.smi.GenericAddress;\n+import org.snmp4j.smi.Integer32;\n+import org.snmp4j.smi.OID;\n+import org.snmp4j.smi.OctetString;\n+import org.snmp4j.smi.Variable;\n+import org.snmp4j.transport.TransportMappings;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class TestSNMPV1Agent extends BaseAgent {\n+\n+    static {\n+        LogFactory.setLogFactory(new ConsoleLogFactory());\n+        //ConsoleLogAdapter.setDebugEnabled(true);\n+    }\n+\n+    private final String address;\n+    private final int port;\n+\n+    public TestSNMPV1Agent(final String address) {\n+        super(new File(\"target/bootCounter1.agent\"), new File(\"target/conf1.agent\"),\n+                new CommandProcessor(new OctetString(MPv3.createLocalEngineID())));\n+        port = SNMPTestUtil.availablePort();\n+        this.address = address + \"/\" + port;\n+    }\n+\n+    @Override\n+    protected void initTransportMappings() {\n+        transportMappings = new TransportMapping[1];\n+        Address transportAddress = GenericAddress.parse(address);\n+        TransportMapping<? extends Address> transportMapping = TransportMappings.getInstance().createTransportMapping(transportAddress);\n+        transportMappings[0] = transportMapping;\n+    }\n+\n+    public void start() throws IOException {\n+        init();\n+        addShutdownHook();\n+        getServer().addContext(new OctetString(\"public\"));\n+        finishInit();\n+        run();\n+        sendColdStartNotification();\n+    }\n+\n+    @Override\n+    protected void registerManagedObjects() {\n+    }\n+\n+    public void registerManagedObject(ManagedObject mo) {\n+        try {\n+            server.register(mo, null);\n+        } catch (DuplicateRegistrationException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public void registerManagedObjects(ManagedObject... managedObjects) {\n+        Arrays.stream(managedObjects).forEach(this::registerManagedObject);\n+    }\n+\n+    @Override\n+    protected void unregisterManagedObjects() {\n+    }\n+\n+    protected void unregisterManagedObject(MOGroup moGroup) {\n+        moGroup.unregisterMOs(server, getContext(moGroup));\n+    }\n+\n+    @Override\n+    protected void addUsmUser(USM usm) {\n+\n+    }\n+\n+    @Override\n+    protected void addNotificationTargets(SnmpTargetMIB targetMIB, SnmpNotificationMIB notificationMIB) {\n+\n+    }\n+\n+    @Override\n+    protected void addViews(VacmMIB vacmMIB) {\n+        vacmMIB.addGroup(SecurityModel.SECURITY_MODEL_SNMPv1,\n+                new OctetString(\"cpublic\"),\n+                new OctetString(\"v1v2group\"),\n+                StorageType.nonVolatile);\n+\n+        vacmMIB.addAccess(new OctetString(\"v1v2group\"),\n+                new OctetString(\"public\"),\n+                SecurityModel.SECURITY_MODEL_ANY,\n+                SecurityLevel.NOAUTH_NOPRIV,\n+                MutableVACM.VACM_MATCH_EXACT,\n+                new OctetString(\"fullReadView\"),\n+                new OctetString(\"fullWriteView\"),\n+                new OctetString(\"fullNotifyView\"),\n+                StorageType.nonVolatile);\n+\n+        vacmMIB.addViewTreeFamily(new OctetString(\"fullReadView\"),\n+                new OID(\"1.3\"),\n+                new OctetString(),\n+                VacmMIB.vacmViewIncluded,\n+                StorageType.nonVolatile);\n+        vacmMIB.addViewTreeFamily(new OctetString(\"fullWriteView\"),\n+                new OID(\"1.3\"),\n+                new OctetString(),\n+                VacmMIB.vacmViewIncluded,\n+                StorageType.nonVolatile);\n+        vacmMIB.addViewTreeFamily(new OctetString(\"fullNotifyView\"),\n+                new OID(\"1.3\"),\n+                new OctetString(),\n+                VacmMIB.vacmViewIncluded,\n+                StorageType.nonVolatile);\n+    }\n+\n+    @Override\n+    protected void addCommunities(SnmpCommunityMIB communityMIB) {\n+        Variable[] com2sec = new Variable[]{\n+                new OctetString(\"public\"), // community name\n+                new OctetString(\"cpublic\"), // security name\n+                this.getAgent().getContextEngineID(), // local engine ID\n+                new OctetString(\"public\"), // default context name\n+                new OctetString(), // transport tag\n+                new Integer32(StorageType.nonVolatile), // storage type\n+                new Integer32(RowStatus.active) // row status\n+        };\n+        final SnmpCommunityMIB.SnmpCommunityEntryRow row = communityMIB.getSnmpCommunityEntry().createRow(new OctetString(\"public2public\")\n+                .toSubIndex(true), com2sec);\n+        communityMIB.getSnmpCommunityEntry().addRow(row);\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+}"
  },
  {
    "sha": "2bfe640f09c5201a5486f690d15cad41b4612b26",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/testagents/TestSNMPV2Agent.java",
    "status": "added",
    "additions": 185,
    "deletions": 0,
    "changes": 185,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/testagents/TestSNMPV2Agent.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/testagents/TestSNMPV2Agent.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/testagents/TestSNMPV2Agent.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.testagents;\n+\n+import org.apache.nifi.snmp.helper.SNMPTestUtil;\n+import org.snmp4j.TransportMapping;\n+import org.snmp4j.agent.BaseAgent;\n+import org.snmp4j.agent.CommandProcessor;\n+import org.snmp4j.agent.DuplicateRegistrationException;\n+import org.snmp4j.agent.MOGroup;\n+import org.snmp4j.agent.ManagedObject;\n+import org.snmp4j.agent.mo.snmp.RowStatus;\n+import org.snmp4j.agent.mo.snmp.SnmpCommunityMIB;\n+import org.snmp4j.agent.mo.snmp.SnmpNotificationMIB;\n+import org.snmp4j.agent.mo.snmp.SnmpTargetMIB;\n+import org.snmp4j.agent.mo.snmp.StorageType;\n+import org.snmp4j.agent.mo.snmp.VacmMIB;\n+import org.snmp4j.agent.security.MutableVACM;\n+import org.snmp4j.log.ConsoleLogFactory;\n+import org.snmp4j.log.LogFactory;\n+import org.snmp4j.mp.MPv3;\n+import org.snmp4j.security.SecurityLevel;\n+import org.snmp4j.security.SecurityModel;\n+import org.snmp4j.security.USM;\n+import org.snmp4j.smi.Address;\n+import org.snmp4j.smi.GenericAddress;\n+import org.snmp4j.smi.Integer32;\n+import org.snmp4j.smi.OID;\n+import org.snmp4j.smi.OctetString;\n+import org.snmp4j.smi.Variable;\n+import org.snmp4j.transport.TransportMappings;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class TestSNMPV2Agent extends BaseAgent {\n+\n+    static {\n+        LogFactory.setLogFactory(new ConsoleLogFactory());\n+        //ConsoleLogAdapter.setDebugEnabled(true);\n+    }\n+\n+    /**\n+     * address\n+     */\n+    private final String address;\n+    /**\n+     * port\n+     */\n+    private final int port;\n+\n+    /**\n+     * constructor\n+     *\n+     * @param address address\n+     * @throws IOException IO Exception\n+     */\n+    public TestSNMPV2Agent(String address) throws IOException {\n+        super(new File(\"target/bootCounter2.agent\"), new File(\"target/conf2.agent\"),\n+                new CommandProcessor(new OctetString(MPv3.createLocalEngineID())));\n+        port = SNMPTestUtil.availablePort();\n+        this.address = address + \"/\" + port;\n+    }\n+\n+    @Override\n+    protected void initTransportMappings() throws IOException {\n+        transportMappings = new TransportMapping[1];\n+        Address transportAddress = GenericAddress.parse(address);\n+        TransportMapping<? extends Address> transportMapping = TransportMappings.getInstance().createTransportMapping(transportAddress);\n+        transportMappings[0] = transportMapping;\n+    }\n+\n+    public void start() throws IOException {\n+        init();\n+        addShutdownHook();\n+        getServer().addContext(new OctetString(\"public\"));\n+        finishInit();\n+        run();\n+        sendColdStartNotification();\n+    }\n+\n+    @Override\n+    protected void registerManagedObjects() {\n+    }\n+\n+    public void registerManagedObject(ManagedObject mo) {\n+        try {\n+            server.register(mo, null);\n+        } catch (DuplicateRegistrationException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public void registerManagedObjects(ManagedObject... managedObjects) {\n+        Arrays.stream(managedObjects).forEach(this::registerManagedObject);\n+    }\n+\n+    @Override\n+    protected void unregisterManagedObjects() {\n+    }\n+\n+    protected void unregisterManagedObject(MOGroup moGroup) {\n+        moGroup.unregisterMOs(server, getContext(moGroup));\n+    }\n+\n+    @Override\n+    protected void addUsmUser(USM usm) {\n+\n+    }\n+\n+    @Override\n+    protected void addNotificationTargets(SnmpTargetMIB targetMIB, SnmpNotificationMIB notificationMIB) {\n+\n+    }\n+\n+    @Override\n+    protected void addViews(VacmMIB vacmMIB) {\n+        vacmMIB.addGroup(SecurityModel.SECURITY_MODEL_SNMPv2c,\n+                new OctetString(\"cpublic\"),\n+                new OctetString(\"v1v2group\"),\n+                StorageType.nonVolatile);\n+\n+        vacmMIB.addAccess(new OctetString(\"v1v2group\"),\n+                new OctetString(\"public\"),\n+                SecurityModel.SECURITY_MODEL_ANY,\n+                SecurityLevel.NOAUTH_NOPRIV,\n+                MutableVACM.VACM_MATCH_EXACT,\n+                new OctetString(\"fullReadView\"),\n+                new OctetString(\"fullWriteView\"),\n+                new OctetString(\"fullNotifyView\"),\n+                StorageType.nonVolatile);\n+\n+        vacmMIB.addViewTreeFamily(new OctetString(\"fullReadView\"),\n+                new OID(\"1.3\"),\n+                new OctetString(),\n+                VacmMIB.vacmViewIncluded,\n+                StorageType.nonVolatile);\n+        vacmMIB.addViewTreeFamily(new OctetString(\"fullWriteView\"),\n+                new OID(\"1.3\"),\n+                new OctetString(),\n+                VacmMIB.vacmViewIncluded,\n+                StorageType.nonVolatile);\n+        vacmMIB.addViewTreeFamily(new OctetString(\"fullNotifyView\"),\n+                new OID(\"1.3\"),\n+                new OctetString(),\n+                VacmMIB.vacmViewIncluded,\n+                StorageType.nonVolatile);\n+    }\n+\n+    @Override\n+    protected void addCommunities(SnmpCommunityMIB communityMIB) {\n+        Variable[] com2sec = new Variable[]{\n+                new OctetString(\"public\"), // community name\n+                new OctetString(\"cpublic\"), // security name\n+                this.getAgent().getContextEngineID(), // local engine ID\n+                new OctetString(\"public\"), // default context name\n+                new OctetString(), // transport tag\n+                new Integer32(StorageType.nonVolatile), // storage type\n+                new Integer32(RowStatus.active) // row status\n+        };\n+        final SnmpCommunityMIB.SnmpCommunityEntryRow row = communityMIB.getSnmpCommunityEntry().createRow(new OctetString(\"public2public\")\n+                .toSubIndex(true), com2sec);\n+        communityMIB.getSnmpCommunityEntry().addRow(row);\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+}"
  },
  {
    "sha": "1f75b3ed1db860b9234da14d9bde4da1e771d128",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/testagents/TestSNMPV3Agent.java",
    "status": "added",
    "additions": 212,
    "deletions": 0,
    "changes": 212,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/testagents/TestSNMPV3Agent.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/testagents/TestSNMPV3Agent.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/testagents/TestSNMPV3Agent.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.snmp.testagents;\n+\n+import org.apache.nifi.snmp.helper.SNMPTestUtil;\n+import org.snmp4j.TransportMapping;\n+import org.snmp4j.agent.BaseAgent;\n+import org.snmp4j.agent.CommandProcessor;\n+import org.snmp4j.agent.DuplicateRegistrationException;\n+import org.snmp4j.agent.MOGroup;\n+import org.snmp4j.agent.ManagedObject;\n+import org.snmp4j.agent.mo.snmp.RowStatus;\n+import org.snmp4j.agent.mo.snmp.SnmpCommunityMIB;\n+import org.snmp4j.agent.mo.snmp.SnmpNotificationMIB;\n+import org.snmp4j.agent.mo.snmp.SnmpTargetMIB;\n+import org.snmp4j.agent.mo.snmp.StorageType;\n+import org.snmp4j.agent.mo.snmp.VacmMIB;\n+import org.snmp4j.agent.security.MutableVACM;\n+import org.snmp4j.log.ConsoleLogFactory;\n+import org.snmp4j.log.LogFactory;\n+import org.snmp4j.mp.MPv3;\n+import org.snmp4j.security.AuthMD5;\n+import org.snmp4j.security.AuthSHA;\n+import org.snmp4j.security.PrivAES128;\n+import org.snmp4j.security.PrivDES;\n+import org.snmp4j.security.SecurityLevel;\n+import org.snmp4j.security.SecurityModel;\n+import org.snmp4j.security.USM;\n+import org.snmp4j.security.UsmUser;\n+import org.snmp4j.smi.Address;\n+import org.snmp4j.smi.GenericAddress;\n+import org.snmp4j.smi.Integer32;\n+import org.snmp4j.smi.OID;\n+import org.snmp4j.smi.OctetString;\n+import org.snmp4j.smi.Variable;\n+import org.snmp4j.transport.TransportMappings;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class TestSNMPV3Agent extends BaseAgent {\n+\n+    static {\n+        LogFactory.setLogFactory(new ConsoleLogFactory());\n+        //ConsoleLogAdapter.setDebugEnabled(true);\n+    }\n+\n+    private final String address;\n+    private final int port;\n+\n+    public TestSNMPV3Agent(final String address) {\n+        super(new File(\"target/bootCounter3.agent\"), new File(\"target/conf3.agent\"),\n+                new CommandProcessor(new OctetString(MPv3.createLocalEngineID())));\n+        port = SNMPTestUtil.availablePort();\n+        this.address = address + \"/\" + port;\n+\n+    }\n+\n+    @Override\n+    protected void initTransportMappings() throws IOException {\n+        transportMappings = new TransportMapping[1];\n+        Address transportAddress = GenericAddress.parse(address);\n+        TransportMapping<? extends Address> transportMapping = TransportMappings.getInstance().createTransportMapping(transportAddress);\n+        transportMappings[0] = transportMapping;\n+    }\n+\n+    public void start() throws IOException {\n+        init();\n+        addShutdownHook();\n+        getServer().addContext(new OctetString(\"public\"));\n+        finishInit();\n+        run();\n+        sendColdStartNotification();\n+    }\n+\n+    @Override\n+    protected void registerManagedObjects() {\n+    }\n+\n+    public void registerManagedObject(ManagedObject mo) {\n+        try {\n+            server.register(mo, null);\n+        } catch (DuplicateRegistrationException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public void registerManagedObjects(ManagedObject... managedObjects) {\n+        Arrays.stream(managedObjects).forEach(this::registerManagedObject);\n+    }\n+\n+    @Override\n+    protected void unregisterManagedObjects() {\n+    }\n+\n+    protected void unregisterManagedObject(MOGroup moGroup) {\n+        moGroup.unregisterMOs(server, getContext(moGroup));\n+    }\n+\n+    @Override\n+    protected void addUsmUser(USM usm) {\n+        UsmUser user = new UsmUser(new OctetString(\"SHA\"),\n+                AuthSHA.ID,\n+                new OctetString(\"SHAAuthPassword\"),\n+                null,\n+                null);\n+        usm.addUser(user.getSecurityName(), usm.getLocalEngineID(), user);\n+        user = new UsmUser(new OctetString(\"SHADES\"),\n+                AuthSHA.ID,\n+                new OctetString(\"SHADESAuthPassword\"),\n+                PrivDES.ID,\n+                new OctetString(\"SHADESPrivPassword\"));\n+        usm.addUser(user.getSecurityName(), usm.getLocalEngineID(), user);\n+        user = new UsmUser(new OctetString(\"MD5DES\"),\n+                AuthMD5.ID,\n+                new OctetString(\"MD5DESAuthPassword\"),\n+                PrivDES.ID,\n+                new OctetString(\"MD5DESPrivPassword\"));\n+        usm.addUser(user.getSecurityName(), usm.getLocalEngineID(), user);\n+        user = new UsmUser(new OctetString(\"SHAAES128\"),\n+                AuthSHA.ID,\n+                new OctetString(\"SHAAES128AuthPassword\"),\n+                PrivAES128.ID,\n+                new OctetString(\"SHAAES128PrivPassword\"));\n+        usm.addUser(user.getSecurityName(), usm.getLocalEngineID(), user);\n+    }\n+\n+    @Override\n+    protected void addNotificationTargets(SnmpTargetMIB targetMIB, SnmpNotificationMIB notificationMIB) {\n+\n+    }\n+\n+    @Override\n+    protected void addViews(VacmMIB vacmMIB) {\n+        vacmMIB.addGroup(SecurityModel.SECURITY_MODEL_USM,\n+                new OctetString(\"SHA\"),\n+                new OctetString(\"v3-auth-no-priv-group\"),\n+                StorageType.nonVolatile);\n+        vacmMIB.addGroup(SecurityModel.SECURITY_MODEL_USM,\n+                new OctetString(\"SHADES\"),\n+                new OctetString(\"v3group\"),\n+                StorageType.nonVolatile);\n+        vacmMIB.addGroup(SecurityModel.SECURITY_MODEL_USM,\n+                new OctetString(\"MD5DES\"),\n+                new OctetString(\"v3group\"),\n+                StorageType.nonVolatile);\n+        vacmMIB.addGroup(SecurityModel.SECURITY_MODEL_USM,\n+                new OctetString(\"SHAAES128\"),\n+                new OctetString(\"v3group\"),\n+                StorageType.nonVolatile);\n+        vacmMIB.addAccess(new OctetString(\"v3group\"), new OctetString(),\n+                SecurityModel.SECURITY_MODEL_USM,\n+                SecurityLevel.AUTH_PRIV,\n+                MutableVACM.VACM_MATCH_EXACT,\n+                new OctetString(\"fullReadView\"),\n+                new OctetString(\"fullWriteView\"),\n+                new OctetString(\"fullNotifyView\"),\n+                StorageType.nonVolatile);\n+        vacmMIB.addAccess(new OctetString(\"v3-auth-no-priv-group\"), new OctetString(),\n+                SecurityModel.SECURITY_MODEL_USM,\n+                SecurityLevel.AUTH_NOPRIV,\n+                MutableVACM.VACM_MATCH_EXACT,\n+                new OctetString(\"fullReadView\"),\n+                new OctetString(\"fullWriteView\"),\n+                new OctetString(\"fullNotifyView\"),\n+                StorageType.nonVolatile);\n+        vacmMIB.addViewTreeFamily(new OctetString(\"fullReadView\"), new OID(\"1.3\"),\n+                new OctetString(), VacmMIB.vacmViewIncluded,\n+                StorageType.nonVolatile);\n+        vacmMIB.addViewTreeFamily(new OctetString(\"fullWriteView\"), new OID(\"1.3\"),\n+                new OctetString(), VacmMIB.vacmViewIncluded,\n+                StorageType.nonVolatile);\n+        vacmMIB.addViewTreeFamily(new OctetString(\"fullNotifyView\"), new OID(\"1.3\"),\n+                new OctetString(), VacmMIB.vacmViewIncluded,\n+                StorageType.nonVolatile);\n+    }\n+\n+    @Override\n+    protected void addCommunities(SnmpCommunityMIB communityMIB) {\n+        Variable[] com2sec = new Variable[]{\n+                new OctetString(\"public\"), // community name\n+                new OctetString(\"cpublic\"), // security name\n+                this.getAgent().getContextEngineID(), // local engine ID\n+                new OctetString(\"public\"), // default context name\n+                new OctetString(), // transport tag\n+                new Integer32(StorageType.nonVolatile), // storage type\n+                new Integer32(RowStatus.active) // row status\n+        };\n+        final SnmpCommunityMIB.SnmpCommunityEntryRow row = communityMIB.getSnmpCommunityEntry().createRow(new OctetString(\"public2public\")\n+                .toSubIndex(true), com2sec);\n+        communityMIB.getSnmpCommunityEntry().addRow(row);\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+}"
  },
  {
    "sha": "7c4809c443ee54ea25dd4b222d617d3c2e01636f",
    "filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/utils/SNMPUtilsTest.java",
    "status": "renamed",
    "additions": 6,
    "deletions": 5,
    "changes": 11,
    "blob_url": "https://github.com/apache/nifi/blob/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/utils/SNMPUtilsTest.java",
    "raw_url": "https://github.com/apache/nifi/raw/ee360fbf98b3c3f08d32e78533cd477ad8fbd08c/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/utils/SNMPUtilsTest.java",
    "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/utils/SNMPUtilsTest.java?ref=ee360fbf98b3c3f08d32e78533cd477ad8fbd08c",
    "patch": "@@ -14,7 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.nifi.snmp.processors;\n+package org.apache.nifi.snmp.utils;\n \n import static org.junit.Assert.assertEquals;\n \n@@ -23,6 +23,7 @@\n \n import org.apache.nifi.flowfile.FlowFile;\n import org.apache.nifi.processor.ProcessSession;\n+import org.apache.nifi.snmp.processors.GetSNMP;\n import org.apache.nifi.util.MockProcessSession;\n import org.apache.nifi.util.SharedSessionState;\n import org.junit.Test;\n@@ -70,7 +71,7 @@ public void validateUpdateFlowFileAttributes() {\n      * @return instance of SNMP\n      * @throws IOException IO Exception\n      */\n-    protected static Snmp createSnmp() throws IOException {\n+    public static Snmp createSnmp() throws IOException {\n         DefaultUdpTransportMapping transportMapping = new DefaultUdpTransportMapping();\n         transportMapping.listen();\n         return new Snmp(transportMapping);\n@@ -83,7 +84,7 @@ protected static Snmp createSnmp() throws IOException {\n      * @param version SNMP version\n      * @return community target\n      */\n-    protected static CommunityTarget createCommTarget(String community, String address, int version) {\n+    public static CommunityTarget createCommTarget(String community, String address, int version) {\n         CommunityTarget target = new CommunityTarget();\n         target.setVersion(version);\n         target.setCommunity(new OctetString(community));\n@@ -100,7 +101,7 @@ protected static CommunityTarget createCommTarget(String community, String addre\n      * @param securityName security name\n      * @return user target\n      */\n-    private static UserTarget createUserTarget(String address, int securityLevel, String securityName) {\n+    public static UserTarget createUserTarget(String address, int securityLevel, String securityName) {\n         UserTarget target = new UserTarget();\n         target.setVersion(SnmpConstants.version3);\n         target.setSecurityLevel(securityLevel);\n@@ -123,7 +124,7 @@ private static UserTarget createUserTarget(String address, int securityLevel, St\n      * @param privPwd private password\n      * @return user target\n      */\n-    protected static UserTarget prepareUser(Snmp snmp, String address, int securityLevel, String securityName, OID auth, OID priv, String authPwd, String privPwd) {\n+    public static UserTarget prepareUser(Snmp snmp, String address, int securityLevel, String securityName, OID auth, OID priv, String authPwd, String privPwd) {\n         snmp.getUSM().removeAllUsers();\n         OctetString aPwd = authPwd != null ? new OctetString(authPwd) : null;\n         OctetString pPwd = privPwd != null ? new OctetString(privPwd) : null;",
    "previous_filename": "nifi-nar-bundles/nifi-snmp-bundle/nifi-snmp-processors/src/test/java/org/apache/nifi/snmp/processors/SNMPUtilsTest.java"
  }
]
