[
  {
    "sha": "a40742bb016f948c872807bc4882f611015a0f78",
    "filename": "pom.xml",
    "status": "modified",
    "additions": 12,
    "deletions": 0,
    "changes": 12,
    "blob_url": "https://github.com/apache/commons-lang/blob/28e3d7fac4127fad1d55539cfe757a47edc1b8e5/pom.xml",
    "raw_url": "https://github.com/apache/commons-lang/raw/28e3d7fac4127fad1d55539cfe757a47edc1b8e5/pom.xml",
    "contents_url": "https://api.github.com/repos/apache/commons-lang/contents/pom.xml?ref=28e3d7fac4127fad1d55539cfe757a47edc1b8e5",
    "patch": "@@ -528,6 +528,12 @@\n   <!-- Lang should depend on very little -->\n   <dependencies>\n     <!-- testing -->\n+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-core</artifactId>\n+      <version>2.15.0</version>\n+      <scope>test</scope>\n+    </dependency>\n     <dependency>\n       <groupId>org.junit.jupiter</groupId>\n       <artifactId>junit-jupiter</artifactId>\n@@ -572,6 +578,12 @@\n       <version>3.0.2</version>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>junit</groupId>\n+      <artifactId>junit</artifactId>\n+      <version>4.12</version>\n+      <scope>test</scope>\n+    </dependency>\n   </dependencies>\n \n   <distributionManagement>"
  },
  {
    "sha": "3775a8e74b319be503cfe6bffbc5eb88a1b36f92",
    "filename": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
    "status": "modified",
    "additions": 158,
    "deletions": 0,
    "changes": 158,
    "blob_url": "https://github.com/apache/commons-lang/blob/28e3d7fac4127fad1d55539cfe757a47edc1b8e5/src/main/java/org/apache/commons/lang3/time/DateUtils.java",
    "raw_url": "https://github.com/apache/commons-lang/raw/28e3d7fac4127fad1d55539cfe757a47edc1b8e5/src/main/java/org/apache/commons/lang3/time/DateUtils.java",
    "contents_url": "https://api.github.com/repos/apache/commons-lang/contents/src/main/java/org/apache/commons/lang3/time/DateUtils.java?ref=28e3d7fac4127fad1d55539cfe757a47edc1b8e5",
    "patch": "@@ -712,6 +712,14 @@ public static Date round(final Date date, final int field) {\n         return gval.getTime();\n     }\n \n+    public static Date round2version(final Date date, final int field) {\n+        validateDateNotNull(date);\n+        final Calendar gval = Calendar.getInstance();\n+        gval.setTime(date);\n+        modify2Version(gval, field, ModifyType.ROUND);\n+        return gval.getTime();\n+    }\n+\n     /**\n      * <p>Rounds a date, leaving the field specified as the most\n      * significant field.</p>\n@@ -950,6 +958,156 @@ public static Date ceiling(final Object date, final int field) {\n         }\n     }\n \n+    public static long truncateCalendar(final Calendar val, final int field, final Object obj){\n+\n+        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n+        // see https://issues.apache.org/jira/browse/LANG-59\n+        //\n+        // Manually truncate milliseconds, seconds and minutes, rather than using\n+        // Calendar methods.\n+\n+        final Date date = val.getTime();\n+        long time = date.getTime();\n+        boolean done = false;\n+\n+        ModifyType modType = (ModifyType) obj;\n+\n+        // truncate milliseconds\n+        final int millisecs = val.get(Calendar.MILLISECOND);\n+        if (ModifyType.TRUNCATE == modType || millisecs < 500) {\n+            time = time - millisecs;\n+        }\n+        if (field == Calendar.SECOND) {\n+            done = true;\n+        }\n+\n+        // truncate seconds\n+        final int seconds = val.get(Calendar.SECOND);\n+        if (!done && (ModifyType.TRUNCATE == modType || seconds < 30)) {\n+            time = time - (seconds * 1000L);\n+        }\n+        if (field == Calendar.MINUTE) {\n+            done = true;\n+        }\n+\n+        // truncate minutes\n+        final int minutes = val.get(Calendar.MINUTE);\n+        if (!done && (ModifyType.TRUNCATE == modType || minutes < 30)) {\n+            time = time - (minutes * 60000L);\n+        }\n+\n+        return time;\n+    }\n+    private static void modify2Version(final Calendar val, final int field, final ModifyType modType) {\n+        if (val.get(Calendar.YEAR) > 280000000) {\n+            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n+        }\n+\n+        if (field == Calendar.MILLISECOND) {\n+            return;\n+        }\n+\n+        long time = truncateCalendar(val, field, modType);\n+\n+        final Date date = val.getTime();\n+\n+        // reset time\n+        if (date.getTime() != time) {\n+            date.setTime(time);\n+            val.setTime(date);\n+        }\n+        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n+\n+        boolean roundUp = false;\n+        for (final int[] aField : fields) {\n+            for (final int element : aField) {\n+                if (element == field) {\n+                    //This is our field... we stop looping\n+                    if (modType == ModifyType.CEILING || modType == ModifyType.ROUND && roundUp) {\n+                        if (field == SEMI_MONTH) {\n+                            //This is a special case that's hard to generalize\n+                            //If the date is 1, we round up to 16, otherwise\n+                            //  we subtract 15 days and add 1 month\n+                            if (val.get(Calendar.DATE) == 1) {\n+                                val.add(Calendar.DATE, 15);\n+                            } else {\n+                                val.add(Calendar.DATE, -15);\n+                                val.add(Calendar.MONTH, 1);\n+                            }\n+// ----------------- Fix for LANG-440 ---------------------- START ---------------\n+                        } else if (field == Calendar.AM_PM) {\n+                            // This is a special case\n+                            // If the time is 0, we round up to 12, otherwise\n+                            //  we subtract 12 hours and add 1 day\n+                            if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n+                                val.add(Calendar.HOUR_OF_DAY, 12);\n+                            } else {\n+                                val.add(Calendar.HOUR_OF_DAY, -12);\n+                                val.add(Calendar.DATE, 1);\n+                            }\n+// ----------------- Fix for LANG-440 ---------------------- END ---------------\n+                        } else {\n+                            //We need at add one to this field since the\n+                            //  last number causes us to round up\n+                            val.add(aField[0], 1);\n+                        }\n+                    }\n+                    return;\n+                }\n+            }\n+            //We have various fields that are not easy roundings\n+            int offset = 0;\n+            boolean offsetSet = false;\n+            //These are special types of fields that require different rounding rules\n+            switch (field) {\n+                case SEMI_MONTH:\n+                    if (aField[0] == Calendar.DATE) {\n+                        //If we're going to drop the DATE field's value,\n+                        //  we want to do this our own way.\n+                        //We need to subtract 1 since the date has a minimum of 1\n+                        offset = val.get(Calendar.DATE) - 1;\n+                        //If we're above 15 days adjustment, that means we're in the\n+                        //  bottom half of the month and should stay accordingly.\n+                        if (offset >= 15) {\n+                            offset -= 15;\n+                        }\n+                        //Record whether we're in the top or bottom half of that range\n+                        roundUp = offset > 7;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+                case Calendar.AM_PM:\n+                    if (aField[0] == Calendar.HOUR_OF_DAY) {\n+                        //If we're going to drop the HOUR field's value,\n+                        //  we want to do this our own way.\n+                        offset = val.get(Calendar.HOUR_OF_DAY);\n+                        if (offset >= 12) {\n+                            offset -= 12;\n+                        }\n+                        roundUp = offset >= 6;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+            if (!offsetSet) {\n+                final int min = val.getActualMinimum(aField[0]);\n+                final int max = val.getActualMaximum(aField[0]);\n+                //Calculate the offset from the minimum allowed value\n+                offset = val.get(aField[0]) - min;\n+                //Set roundUp if this is more than half way between the minimum and maximum\n+                roundUp = offset > ((max - min) / 2);\n+            }\n+            //We need to remove this field\n+            if (offset != 0) {\n+                val.set(aField[0], val.get(aField[0]) - offset);\n+            }\n+        }\n+        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n+\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * <p>Internal calculation method.</p>"
  },
  {
    "sha": "0d21dc1814b6f72f2b611e8990c7f628aaf1a016",
    "filename": "src/test/java/org/apache/commons/lang3/builder/MultilineRecursiveToStringStyleMockingTest.java",
    "status": "added",
    "additions": 130,
    "deletions": 0,
    "changes": 130,
    "blob_url": "https://github.com/apache/commons-lang/blob/28e3d7fac4127fad1d55539cfe757a47edc1b8e5/src/test/java/org/apache/commons/lang3/builder/MultilineRecursiveToStringStyleMockingTest.java",
    "raw_url": "https://github.com/apache/commons-lang/raw/28e3d7fac4127fad1d55539cfe757a47edc1b8e5/src/test/java/org/apache/commons/lang3/builder/MultilineRecursiveToStringStyleMockingTest.java",
    "contents_url": "https://api.github.com/repos/apache/commons-lang/contents/src/test/java/org/apache/commons/lang3/builder/MultilineRecursiveToStringStyleMockingTest.java?ref=28e3d7fac4127fad1d55539cfe757a47edc1b8e5",
    "patch": "@@ -0,0 +1,130 @@\n+package org.apache.commons.lang3.builder;\n+\n+import org.junit.Before;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import static org.mockito.Mockito.*;\n+\n+//this junit test needs to call ReflectionStringBuilder\n+public class MultilineRecursiveToStringStyleMockingTest {\n+\n+    private final String BR = System.lineSeparator();\n+\n+    final WithArraysOne wa1 = new WithArraysOne();\n+    final WithArraysTwo wa2 = new WithArraysTwo();\n+    final WithArraysThree wa3 = new WithArraysThree();\n+\n+    private ReflectionToStringBuilder reflectionToStringBuilder;\n+\n+    private List<ReflectionToStringBuilder> reflectionToStringBuilderList;\n+\n+    @Spy\n+    private ReflectionToStringBuilder builder1 = new ReflectionToStringBuilder(wa1, new MultilineRecursiveToStringStyle());\n+\n+    @Spy\n+    private ReflectionToStringBuilder builder2 = new ReflectionToStringBuilder(wa2, new MultilineRecursiveToStringStyle());\n+\n+    @Spy\n+    private ReflectionToStringBuilder builder3 = new ReflectionToStringBuilder(wa3, new MultilineRecursiveToStringStyle());\n+\n+\n+    @Before\n+    public void setup(){\n+        //Mocks are being created\n+        reflectionToStringBuilder = new ReflectionToStringBuilder(mock(ReflectionToStringBuilder.class));\n+\n+        MockitoAnnotations.initMocks(this);\n+        reflectionToStringBuilderList = Arrays.asList(builder1,builder2,builder3);\n+\n+    }\n+\n+    @Test\n+    public void doubleArray() {\n+        wa1.doubleArray = new double[] { 1, 2 };\n+        final String exp = getClassPrefix(wa1) + \"[\" + BR\n+                + \"  boolArray=<null>,\" + BR\n+                + \"  charArray=<null>,\" + BR\n+                + \"  doubleArray={\" + BR\n+                + \"    1.0,\" + BR\n+                + \"    2.0\" + BR\n+                + \"  },\" + BR\n+                + \"  intArray=<null>,\" + BR\n+                + \"  longArray=<null>,\" + BR\n+                + \"  stringArray=<null>\" + BR\n+                + \"]\";\n+        assertEquals(exp, builder1.toString());\n+    }\n+\n+    @Test\n+    public void longArray() {\n+        wa2.longArray = new long[] { 1L, 2L };\n+        final String exp = getClassPrefix(wa2) + \"[\" + BR\n+                + \"  boolArray=<null>,\" + BR\n+                + \"  charArray=<null>,\" + BR\n+                + \"  doubleArray=<null>,\" + BR\n+                + \"  intArray=<null>,\" + BR\n+                + \"  longArray={\" + BR\n+                + \"    1,\" + BR\n+                + \"    2\" + BR\n+                + \"  },\" + BR\n+                + \"  stringArray=<null>\" + BR\n+                + \"]\";\n+        assertEquals(exp, builder2.toString());\n+    }\n+\n+    @Test\n+    public void stringArray() {\n+        wa3.stringArray = new String[] { \"a\", \"A\" };\n+        final String exp = getClassPrefix(wa3) + \"[\" + BR\n+                + \"  boolArray=<null>,\" + BR\n+                + \"  charArray=<null>,\" + BR\n+                + \"  doubleArray=<null>,\" + BR\n+                + \"  intArray=<null>,\" + BR\n+                + \"  longArray=<null>,\" + BR\n+                + \"  stringArray={\" + BR\n+                + \"    a,\" + BR\n+                + \"    A\" + BR\n+                + \"  }\" + BR\n+                + \"]\";\n+        assertEquals(exp, builder3.toString());\n+    }\n+\n+\n+    private String getClassPrefix(final Object object) {\n+        return object.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(object));\n+    }\n+\n+    static class WithArraysOne {\n+        boolean[] boolArray;\n+        char[] charArray;\n+        double[] doubleArray;\n+        int[] intArray;\n+        long[] longArray;\n+        String[] stringArray;\n+    }\n+\n+    static class WithArraysTwo{\n+        boolean[] boolArray;\n+        char[] charArray;\n+        double[] doubleArray;\n+        int[] intArray;\n+        long[] longArray;\n+        String[] stringArray;\n+    }\n+\n+    static class WithArraysThree{\n+        boolean[] boolArray;\n+        char[] charArray;\n+        double[] doubleArray;\n+        int[] intArray;\n+        long[] longArray;\n+        String[] stringArray;\n+    }\n+}"
  },
  {
    "sha": "0333b000e6d055f085b14d1d0272ce12610ad821",
    "filename": "src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java",
    "status": "modified",
    "additions": 122,
    "deletions": 0,
    "changes": 122,
    "blob_url": "https://github.com/apache/commons-lang/blob/28e3d7fac4127fad1d55539cfe757a47edc1b8e5/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java",
    "raw_url": "https://github.com/apache/commons-lang/raw/28e3d7fac4127fad1d55539cfe757a47edc1b8e5/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java",
    "contents_url": "https://api.github.com/repos/apache/commons-lang/contents/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java?ref=28e3d7fac4127fad1d55539cfe757a47edc1b8e5",
    "patch": "@@ -16,6 +16,7 @@\n  */\n package org.apache.commons.lang3.time;\n \n+import static org.apache.commons.lang3.time.DateUtils.truncateCalendar;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n@@ -1126,6 +1127,115 @@ public void testRound() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testround2version() throws Exception {\n+        // tests for public static Date round2version(Date date, int field)\n+        assertEquals(dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.round2version(date1, Calendar.YEAR),\n+                \"round2version year-1 failed\");\n+        assertEquals(dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.round2version(date2, Calendar.YEAR),\n+                \"round2version year-2 failed\");\n+        assertEquals(dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.round2version(date1, Calendar.MONTH),\n+                \"round2version month-1 failed\");\n+        assertEquals(dateParser.parse(\"December 1, 2001\"),\n+                DateUtils.round2version(date2, Calendar.MONTH),\n+                \"round2version month-2 failed\");\n+        assertEquals(dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.round2version(date0, DateUtils.SEMI_MONTH),\n+                \"round2version semimonth-0 failed\");\n+        assertEquals(dateParser.parse(\"February 16, 2002\"),\n+                DateUtils.round2version(date1, DateUtils.SEMI_MONTH),\n+                \"round2version semimonth-1 failed\");\n+        assertEquals(dateParser.parse(\"November 16, 2001\"),\n+                DateUtils.round2version(date2, DateUtils.SEMI_MONTH),\n+                \"round2version semimonth-2 failed\");\n+\n+\n+        assertEquals(dateParser.parse(\"February 13, 2002\"),\n+                DateUtils.round2version(date1, Calendar.DATE),\n+                \"round2version date-1 failed\");\n+        assertEquals(dateParser.parse(\"November 18, 2001\"),\n+                DateUtils.round2version(date2, Calendar.DATE),\n+                \"round2version date-2 failed\");\n+        assertEquals(dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"),\n+                DateUtils.round2version(date1, Calendar.HOUR),\n+                \"round2version hour-1 failed\");\n+        assertEquals(dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"),\n+                DateUtils.round2version(date2, Calendar.HOUR),\n+                \"round2version hour-2 failed\");\n+        assertEquals(dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"),\n+                DateUtils.round2version(date1, Calendar.MINUTE),\n+                \"round2version minute-1 failed\");\n+        assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"),\n+                DateUtils.round2version(date2, Calendar.MINUTE),\n+                \"round2version minute-2 failed\");\n+        assertEquals(dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"),\n+                DateUtils.round2version(date1, Calendar.SECOND),\n+                \"round2version second-1 failed\");\n+        assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.round2version(date2, Calendar.SECOND),\n+                \"round2version second-2 failed\");\n+        assertEquals(dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.round2version(dateAmPm1, Calendar.AM_PM),\n+                \"round2version ampm-1 failed\");\n+        assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.round2version(dateAmPm2, Calendar.AM_PM),\n+                \"round2version ampm-2 failed\");\n+        assertEquals(dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.round2version(dateAmPm3, Calendar.AM_PM),\n+                \"round2version ampm-3 failed\");\n+        assertEquals(dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"),\n+                DateUtils.round2version(dateAmPm4, Calendar.AM_PM),\n+                \"round2version ampm-4 failed\");\n+\n+        // tests for public static Date round2version(Object date, int field)\n+        assertEquals(dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.round2version(date1, Calendar.YEAR),\n+                \"round2version year-1 failed\");\n+        assertEquals(dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.round2version(date2, Calendar.YEAR),\n+                \"round2version year-2 failed\");\n+        assertEquals(dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.round2version(date1, Calendar.MONTH),\n+                \"round2version month-1 failed\");\n+        assertEquals(dateParser.parse(\"December 1, 2001\"),\n+                DateUtils.round2version(date2, Calendar.MONTH),\n+                \"round2version month-2 failed\");\n+        assertEquals(dateParser.parse(\"February 16, 2002\"),\n+                DateUtils.round2version(date1, DateUtils.SEMI_MONTH),\n+                \"round2version semimonth-1 failed\");\n+        assertEquals(dateParser.parse(\"November 16, 2001\"),\n+                DateUtils.round2version(date2, DateUtils.SEMI_MONTH),\n+                \"round2version semimonth-2 failed\");\n+        assertEquals(dateParser.parse(\"February 13, 2002\"),\n+                DateUtils.round2version(date1, Calendar.DATE),\n+                \"round2version date-1 failed\");\n+        assertEquals(dateParser.parse(\"November 18, 2001\"),\n+                DateUtils.round2version(date2, Calendar.DATE),\n+                \"round2version date-2 failed\");\n+        assertEquals(dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"),\n+                DateUtils.round2version(date1, Calendar.HOUR),\n+                \"round2version hour-1 failed\");\n+        assertEquals(dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"),\n+                DateUtils.round2version(date2, Calendar.HOUR),\n+                \"round2version hour-2 failed\");\n+        assertEquals(dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"),\n+                DateUtils.round2version(date1, Calendar.MINUTE),\n+                \"round2version minute-1 failed\");\n+        assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"),\n+                DateUtils.round2version(date2, Calendar.MINUTE),\n+                \"round2version minute-2 failed\");\n+        assertEquals(dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"),\n+                DateUtils.round2version(date1, Calendar.SECOND),\n+                \"round2version second-1 failed\");\n+        assertEquals(dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.round2version(date2, Calendar.SECOND),\n+                \"round2version second-2 failed\");\n+    }\n+\n+\n     /**\n      * Tests the Changes Made by LANG-346 to the DateUtils.modify() private method invoked\n      * by DateUtils.round().\n@@ -1651,5 +1761,17 @@ public void testWeekIterator() {\n             now.add(Calendar.DATE, 1);\n         }\n     }\n+\n+    @Test\n+    public void testtruncateCalendar(){\n+        try {\n+            Class<?> enumElement = Class.forName(\"org.apache.commons.lang3.time.DateUtils$ModifyType\");\n+            Object[] enumElements = enumElement.getEnumConstants();\n+            Calendar calendar = new Calendar.Builder().setDate(2018, 1, 15).build();\n+            assertEquals(truncateCalendar(calendar, 2018, enumElements[1]), 1518681600000l);\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+        }\n+    }\n }\n "
  }
]
