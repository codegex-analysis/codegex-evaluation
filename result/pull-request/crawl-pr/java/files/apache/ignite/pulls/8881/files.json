[
  {
    "sha": "89655268f8ef126089969128677065a2b4c2e8a9",
    "filename": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java",
    "status": "modified",
    "additions": 75,
    "deletions": 42,
    "changes": 117,
    "blob_url": "https://github.com/apache/ignite/blob/f7abe21401a62961bf698388e0f66542e8151dd8/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java",
    "raw_url": "https://github.com/apache/ignite/raw/f7abe21401a62961bf698388e0f66542e8151dd8/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java",
    "contents_url": "https://api.github.com/repos/apache/ignite/contents/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java?ref=f7abe21401a62961bf698388e0f66542e8151dd8",
    "patch": "@@ -298,6 +298,9 @@\n     /** Time of last sent and acknowledged message. */\n     private volatile long lastRingMsgSentTime;\n \n+    /** Time of last failed message. */\n+    private volatile long msgNotSentNanos;\n+\n     /** */\n     private volatile boolean nodeCompactRepresentationSupported =\n         true; //assume that local node supports this feature\n@@ -394,6 +397,8 @@\n \n         lastRingMsgSentTime = 0;\n \n+        msgNotSentNanos = 0;\n+\n         // Foundumental timeout value for actions related to connection check.\n         connCheckTick = effectiveExchangeTimeout() / 3;\n \n@@ -3863,8 +3868,11 @@ else if (e instanceof SocketTimeoutException ||\n                 } // Iterating node's addresses.\n \n                 if (!sent) {\n-                    if (sndState == null && spi.getEffectiveConnectionRecoveryTimeout() > 0)\n-                        sndState = new CrossRingMessageSendState();\n+                    if (sndState == null && spi.getEffectiveConnectionRecoveryTimeout() > 0) {\n+                        msgNotSentNanos = System.nanoTime();\n+\n+                        sndState = new CrossRingMessageSendState(msgNotSentNanos);\n+                    }\n                     else if (sndState != null && sndState.checkTimeout()) {\n                         segmentLocalNodeOnSendFail(failedNodes);\n \n@@ -3941,6 +3949,8 @@ else if (!failedNextNode && sndState != null && sndState.isBackward()) {\n                 if (!sent) {\n                     assert next == null : next;\n \n+                    checkOutgoingConnection();\n+\n                     if (log.isDebugEnabled())\n                         log.debug(\"Pending messages will be resent to local node\");\n \n@@ -3987,39 +3997,6 @@ private void processPendingMessagesLocally(TcpDiscoveryAbstractMessage curMsg) {\n             }\n         }\n \n-        /**\n-         * Segment local node on failed message send.\n-         */\n-        private void segmentLocalNodeOnSendFail(List<TcpDiscoveryNode> failedNodes) {\n-            String failedNodesStr = failedNodes == null ? \"\" : (\", failedNodes=\" + failedNodes);\n-\n-            synchronized (mux) {\n-                if (spiState == CONNECTING) {\n-                    U.warn(log, \"Unable to connect to next nodes in a ring, it seems local node is experiencing \" +\n-                        \"connectivity issues or the rest of the cluster is undergoing massive restarts. Failing \" +\n-                        \"local node join to avoid case when one node fails a big part of cluster. To disable\" +\n-                        \" this behavior set TcpDiscoverySpi.setConnectionRecoveryTimeout() to 0. \" +\n-                        \"[connRecoveryTimeout=\" + spi.connRecoveryTimeout + \", effectiveConnRecoveryTimeout=\"\n-                        + spi.getEffectiveConnectionRecoveryTimeout() + failedNodesStr + ']');\n-\n-                    spiState = RING_FAILED;\n-\n-                    mux.notifyAll();\n-\n-                    return;\n-                }\n-            }\n-\n-            U.warn(log, \"Unable to connect to next nodes in a ring, \" +\n-                \"it seems local node is experiencing connectivity issues. Segmenting local node \" +\n-                \"to avoid case when one node fails a big part of cluster. To disable\" +\n-                \" this behavior set TcpDiscoverySpi.setConnectionRecoveryTimeout() to 0. \" +\n-                \"[connRecoveryTimeout=\" + spi.connRecoveryTimeout + \", effectiveConnRecoveryTimeout=\"\n-                + spi.getEffectiveConnectionRecoveryTimeout() + failedNodesStr + ']');\n-\n-            notifyDiscovery(EVT_NODE_SEGMENTED, ring.topologyVersion(), locNode);\n-        }\n-\n         /**\n          * Adds failed node IDs to the given discovery message. Will not clean the existing failed node IDs collection\n          * from the message.\n@@ -6527,6 +6504,53 @@ private void checkConnection() {\n         }\n     }\n \n+    /**\n+     * Segment local node if ring connection failed while incoming traffic is present.\n+     */\n+    private void checkOutgoingConnection() {\n+        // Skip if there is no msg sending failure or wait for ping comming after the failure.\n+        if (msgNotSentNanos == 0 || lastRingMsgReceivedTime < msgNotSentNanos + U.millisToNanos(connCheckInterval))\n+            return;\n+\n+        synchronized (mux) {\n+            if (spiState == CONNECTED && failedNodes.size() > 1 && ring.serverNodes(failedNodes.keySet()).size() == 1)\n+                segmentLocalNodeOnSendFail(failedNodes.keySet());\n+        }\n+    }\n+\n+    /**\n+     * Segment local node on failed message send.\n+     */\n+    private void segmentLocalNodeOnSendFail(Collection<TcpDiscoveryNode> failedNodes) {\n+        String failedNodesStr = failedNodes == null ? \"\" : (\", failedNodes=\" + failedNodes);\n+\n+        synchronized (mux) {\n+            if (spiState == CONNECTING) {\n+                U.warn(log, \"Unable to connect to next nodes in a ring, it seems local node is experiencing \" +\n+                    \"connectivity issues or the rest of the cluster is undergoing massive restarts. Failing \" +\n+                    \"local node join to avoid case when one node fails a big part of cluster. To disable\" +\n+                    \" this behavior set TcpDiscoverySpi.setConnectionRecoveryTimeout() to 0. \" +\n+                    \"[connRecoveryTimeout=\" + spi.connRecoveryTimeout + \", effectiveConnRecoveryTimeout=\"\n+                    + spi.getEffectiveConnectionRecoveryTimeout() + failedNodesStr + ']');\n+\n+                spiState = RING_FAILED;\n+\n+                mux.notifyAll();\n+\n+                return;\n+            }\n+        }\n+\n+        U.warn(log, \"Unable to connect to next nodes in a ring, \" +\n+            \"it seems local node is experiencing connectivity issues. Segmenting local node \" +\n+            \"to avoid case when one node fails a big part of cluster. To disable\" +\n+            \" this behavior set TcpDiscoverySpi.setConnectionRecoveryTimeout() to 0. \" +\n+            \"[connRecoveryTimeout=\" + spi.connRecoveryTimeout + \", effectiveConnRecoveryTimeout=\"\n+            + spi.getEffectiveConnectionRecoveryTimeout() + failedNodesStr + ']');\n+\n+        notifyDiscovery(EVT_NODE_SEGMENTED, ring.topologyVersion(), locNode);\n+    }\n+\n     /**\n      * Creates proper timeout helper taking in account current send state and ring state.\n      *\n@@ -6542,13 +6566,15 @@ private IgniteSpiOperationTimeoutHelper serverOperationTimeoutHelper(@Nullable C\n         // nodes failed. May be several failed in a row. But we got only one connectionRecoveryTimeout to establish new\n         // connection. We should travers rest of the cluster with sliced timeout for each node.\n         if (sndState != null)\n-            absoluteThreshold = Math.min(sndState.failTimeNanos, System.nanoTime() + U.millisToNanos(connCheckTick));\n+            absoluteThreshold = Math.min(sndState.absoluteTimeout, System.nanoTime() + U.millisToNanos(connCheckTick));\n \n         return new IgniteSpiOperationTimeoutHelper(spi, true, lastOperationNanos, absoluteThreshold);\n     }\n \n     /** Fixates time of last sent message. */\n     private void updateLastSentMessageTime() {\n+        msgNotSentNanos = 0;\n+\n         lastRingMsgSentTime = System.nanoTime();\n     }\n \n@@ -7378,6 +7404,8 @@ else if (msg instanceof TcpDiscoveryRingLatencyCheckMessage) {\n          */\n         private void ringMessageReceived() {\n             lastRingMsgReceivedTime = System.nanoTime();\n+\n+            checkOutgoingConnection();\n         }\n \n         /** @return Alive address if was able to connected to. {@code Null} otherwise. */\n@@ -8206,14 +8234,19 @@ public void sock(Socket sock) {\n         /** */\n         private int failedNodes;\n \n-        /** */\n-        private final long failTimeNanos;\n+        /** Maximal time point for any recovery operation. Nanos. */\n+        private final long absoluteTimeout;\n+\n+        /** Time of the failure in nanos. */\n+        private final long failTime;\n \n         /**\n-         *\n+         * @param failTime Time of the failure in nanos.\n          */\n-        CrossRingMessageSendState() {\n-            failTimeNanos = U.millisToNanos(spi.getEffectiveConnectionRecoveryTimeout()) + System.nanoTime();\n+        CrossRingMessageSendState(long failTime) {\n+            this.failTime = failTime;\n+\n+            this.absoluteTimeout = U.millisToNanos(spi.getEffectiveConnectionRecoveryTimeout()) + this.failTime;\n         }\n \n         /**\n@@ -8261,7 +8294,7 @@ boolean markNextNodeFailed() {\n          * @return {@code True} if passed timeout is reached. {@code False} otherwise.\n          */\n         boolean checkTimeout() {\n-            if (System.nanoTime() >= failTimeNanos) {\n+            if (System.nanoTime() >= absoluteTimeout) {\n                 state = RingMessageSendState.FAILED;\n \n                 return true;"
  },
  {
    "sha": "b7c91d207e23fe746d62998d7044865d0a6736a9",
    "filename": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySpi.java",
    "status": "modified",
    "additions": 10,
    "deletions": 5,
    "changes": 15,
    "blob_url": "https://github.com/apache/ignite/blob/f7abe21401a62961bf698388e0f66542e8151dd8/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySpi.java",
    "raw_url": "https://github.com/apache/ignite/raw/f7abe21401a62961bf698388e0f66542e8151dd8/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySpi.java",
    "contents_url": "https://api.github.com/repos/apache/ignite/contents/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySpi.java?ref=f7abe21401a62961bf698388e0f66542e8151dd8",
    "patch": "@@ -1610,24 +1610,29 @@ Socket createSocket() throws IOException {\n         Socket sock = null;\n \n         try {\n-            if (isSslEnabled())\n-                sock = sslSockFactory.createSocket();\n-            else\n-                sock = new Socket();\n+            sock = createSocket0();\n \n             sock.bind(new InetSocketAddress(locHost, 0));\n \n             configureSocketOptions(sock);\n \n             return sock;\n-        } catch (IOException e) {\n+        }\n+        catch (IOException e) {\n             if (sock != null)\n                 U.closeQuiet(sock);\n \n             throw e;\n         }\n     }\n \n+    /**\n+     * Creates proper socket.\n+     */\n+    protected Socket createSocket0() throws IOException {\n+        return isSslEnabled() ? sslSockFactory.createSocket() : new Socket();\n+    }\n+\n     /**\n      * Writes message to the socket.\n      *"
  },
  {
    "sha": "6950b9817ef6b82b07279552755ed8499403e80a",
    "filename": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/internal/TcpDiscoveryNodesRing.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/ignite/blob/f7abe21401a62961bf698388e0f66542e8151dd8/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/internal/TcpDiscoveryNodesRing.java",
    "raw_url": "https://github.com/apache/ignite/raw/f7abe21401a62961bf698388e0f66542e8151dd8/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/internal/TcpDiscoveryNodesRing.java",
    "contents_url": "https://api.github.com/repos/apache/ignite/contents/modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/internal/TcpDiscoveryNodesRing.java?ref=f7abe21401a62961bf698388e0f66542e8151dd8",
    "patch": "@@ -681,7 +681,7 @@ public long nextNodeOrder() {\n      * @param excluded Nodes to exclude from the search (optional).\n      * @return Collection of server nodes.\n      */\n-    private Collection<TcpDiscoveryNode> serverNodes(@Nullable final Collection<TcpDiscoveryNode> excluded) {\n+    public Collection<TcpDiscoveryNode> serverNodes(@Nullable final Collection<TcpDiscoveryNode> excluded) {\n         final boolean excludedEmpty = F.isEmpty(excluded);\n \n         return F.view(nodes, new P1<TcpDiscoveryNode>() {"
  },
  {
    "sha": "3603b6cfdaf8dd6b4be0888b161f31ad307d5161",
    "filename": "modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySelfTest.java",
    "status": "modified",
    "additions": 57,
    "deletions": 1,
    "changes": 58,
    "blob_url": "https://github.com/apache/ignite/blob/f7abe21401a62961bf698388e0f66542e8151dd8/modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySelfTest.java",
    "raw_url": "https://github.com/apache/ignite/raw/f7abe21401a62961bf698388e0f66542e8151dd8/modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySelfTest.java",
    "contents_url": "https://api.github.com/repos/apache/ignite/contents/modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySelfTest.java?ref=f7abe21401a62961bf698388e0f66542e8151dd8",
    "patch": "@@ -93,6 +93,7 @@\n import org.apache.ignite.testframework.ListeningTestLogger;\n import org.apache.ignite.testframework.LogListener;\n import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.util.FailureSimulatingTcpDiscoverySpi;\n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n import org.junit.Test;\n@@ -136,6 +137,9 @@\n     /** */\n     private SegmentationPolicy segPlc;\n \n+    /** */\n+    private int failureDetectionTimeout = 7500;\n+\n     /**\n      * @throws Exception If fails.\n      */\n@@ -170,7 +174,7 @@ public TcpDiscoverySelfTest() throws Exception {\n \n         cfg.setDiscoverySpi(spi);\n \n-        cfg.setFailureDetectionTimeout(7500);\n+        cfg.setFailureDetectionTimeout(failureDetectionTimeout);\n \n         if (ccfgs != null)\n             cfg.setCacheConfiguration(ccfgs);\n@@ -412,6 +416,58 @@ public void testFailureDetectionOnNodePing2() throws Exception {\n         }\n     }\n \n+    /**\n+     * Checks that node leaves the cluster after lose of outgoing connections.\n+     *\n+     * @throws Exception If any error occurs.\n+     */\n+    @Test\n+    public void testOutgoingConnectionsFailure() throws Exception {\n+        try {\n+            final int gridCnt = 4;\n+\n+            failureDetectionTimeout = 2000;\n+\n+            startGrids(gridCnt - 1);\n+\n+            nodeSpi.set(new FailureSimulatingTcpDiscoverySpi());\n+\n+            startGrid(gridCnt - 1);\n+\n+            UUID failingNodeId = grid(gridCnt - 1).localNode().id();\n+\n+            CountDownLatch testWaiter = new CountDownLatch(gridCnt - 1);\n+\n+            for (int i = 0; i < gridCnt - 1; ++i) {\n+                grid(0).events().localListen(new IgnitePredicate<Event>() {\n+                    @Override public boolean apply(Event evt) {\n+                        if (evt.type() == EventType.EVT_NODE_FAILED\n+                            && failingNodeId.equals(((DiscoveryEvent)evt).eventNode().id()))\n+                            testWaiter.countDown();\n+\n+                        return false;\n+                    }\n+                }, EVT_NODE_FAILED);\n+            }\n+\n+            FailureSimulatingTcpDiscoverySpi failSpi = ((FailureSimulatingTcpDiscoverySpi)grid(gridCnt - 1)\n+                .configuration().getDiscoverySpi());\n+\n+            long simulatedNetDelay = ((TcpDiscoverySpi)grid(gridCnt - 1).configuration()\n+                .getDiscoverySpi()).getEffectiveConnectionRecoveryTimeout() / gridCnt;\n+\n+            failSpi.enableNetworkTimeoutSimulation(1, (int)simulatedNetDelay);\n+\n+            testWaiter.await(failureDetectionTimeout * 3, MILLISECONDS);\n+\n+            for (int i = 0; i < gridCnt - 1; ++i)\n+                assert grid(i).cluster().nodes().size() == gridCnt - 1;\n+        }\n+        finally {\n+            stopAllGrids();\n+        }\n+    }\n+\n     /**\n      * @throws Exception If any error occurs.\n      */"
  },
  {
    "sha": "6d2b7d32914f7583de72686dfd51611ce2ad79b0",
    "filename": "modules/core/src/test/java/org/apache/ignite/util/FailureSimulatingTcpDiscoverySpi.java",
    "status": "added",
    "additions": 404,
    "deletions": 0,
    "changes": 404,
    "blob_url": "https://github.com/apache/ignite/blob/f7abe21401a62961bf698388e0f66542e8151dd8/modules/core/src/test/java/org/apache/ignite/util/FailureSimulatingTcpDiscoverySpi.java",
    "raw_url": "https://github.com/apache/ignite/raw/f7abe21401a62961bf698388e0f66542e8151dd8/modules/core/src/test/java/org/apache/ignite/util/FailureSimulatingTcpDiscoverySpi.java",
    "contents_url": "https://api.github.com/repos/apache/ignite/contents/modules/core/src/test/java/org/apache/ignite/util/FailureSimulatingTcpDiscoverySpi.java?ref=f7abe21401a62961bf698388e0f66542e8151dd8",
    "patch": "@@ -0,0 +1,404 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.util;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.nio.channels.SocketChannel;\n+import org.apache.ignite.internal.util.lang.IgnitePair;\n+import org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\n+import org.jetbrains.annotations.NotNull;\n+\n+/**\n+ * The TcpDiscovery able to simulate network failure.\n+ */\n+public class FailureSimulatingTcpDiscoverySpi extends TcpDiscoverySpi {\n+    /**\n+     * If not {@code null}, enables network timeout simulation. First value switches traffic droppage: negative for all\n+     * incoming, positive for all outgoing, 0 for both.\n+     */\n+    protected volatile IgnitePair<Integer> simulatedTimeout;\n+\n+    /** {@inheritDoc} */\n+    @Override protected Socket createSocket0() throws IOException {\n+        return new SocketWrap(super.createSocket0());\n+    }\n+\n+    /**\n+     * Enables simulation of network timeout.\n+     *\n+     * @param direction If negative, enables timeout simulation for incomming traffic. If positive, enables timeout\n+     *                  simulation for outgoing traffic. Set 0 to simlate failure for both traffics.\n+     * @param delay     Milliseconds of awaiting before raising {@code SocketTimeoutException}.\n+     * @see SocketWrap#simulateTimeout(Socket, int)\n+     */\n+    public void enableNetworkTimeoutSimulation(int direction, int delay) {\n+        simulatedTimeout = new IgnitePair<>(direction, delay);\n+    }\n+\n+    /**\n+     * Simulates network timeout if enabled, raises {@code SocketTimeoutException}.\n+     *\n+     * @param sock         The socket to simulate failure at.\n+     * @param forceTimeout If positive of 0, overrides the delay preset in {@link #enableNetworkTimeoutSimulation(int,\n+     *                     int)}.\n+     * @see #enableNetworkTimeoutSimulation(int, int)\n+     */\n+    private void simulateTimeout(Socket sock, int forceTimeout) throws SocketTimeoutException {\n+        IgnitePair<Integer> simulatedTimeout = this.simulatedTimeout;\n+\n+        if (simulatedTimeout == null)\n+            return;\n+\n+        boolean isClientSock = sock.getLocalPort() < locPort || sock.getLocalPort() > locPort + locPortRange;\n+\n+        if (isClientSock && simulatedTimeout.get1() < 0 || !isClientSock && simulatedTimeout.get1() > 0)\n+            return;\n+\n+        int timeout = forceTimeout >= 0 ? forceTimeout : simulatedTimeout.get2();\n+\n+        try {\n+            Thread.sleep(timeout);\n+        }\n+        catch (InterruptedException ignored) {\n+            // No-op.\n+        }\n+\n+        throw new SocketTimeoutException(\"Simulated failure after delay: \" + timeout + \"ms.\");\n+    }\n+\n+    /**\n+     * @see #simulateTimeout(Socket, int)\n+     */\n+    private void simulateTimeout(Socket sock) throws SocketTimeoutException {\n+        simulateTimeout(sock, -1);\n+    }\n+\n+    /**\n+     * Network failure simulator.\n+     */\n+    private class SocketWrap extends Socket {\n+        /** The real socket to simulate failure of. */\n+        private final Socket delegate;\n+\n+        /**\n+         * Constructor.\n+         *\n+         * @param sock The real socket to simulate failure of.\n+         */\n+        private SocketWrap(Socket sock) {\n+            delegate = sock;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public OutputStream getOutputStream() throws IOException {\n+            OutputStream src = delegate.getOutputStream();\n+\n+            return new OutputStream() {\n+                /** {@inheritDoc} */\n+                @Override public void write(@NotNull byte[] b) throws IOException {\n+                    simulateTimeout(delegate);\n+\n+                    src.write(b);\n+                }\n+\n+                /** {@inheritDoc} */\n+                @Override public void write(@NotNull byte[] b, int off, int len) throws IOException {\n+                    simulateTimeout(delegate);\n+\n+                    src.write(b, off, len);\n+                }\n+\n+                /** {@inheritDoc} */\n+                @Override public void write(int b) throws IOException {\n+                    simulateTimeout(delegate);\n+\n+                    src.write(b);\n+                }\n+\n+                /** {@inheritDoc} */\n+                @Override public void flush() throws IOException {\n+                    simulateTimeout(delegate);\n+\n+                    src.flush();\n+                }\n+\n+                /** {@inheritDoc} */\n+                @Override public void close() throws IOException {\n+                    src.close();\n+                }\n+            };\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public InputStream getInputStream() throws IOException {\n+            InputStream src = delegate.getInputStream();\n+\n+            return new InputStream() {\n+                @Override public int read(@NotNull byte[] b) throws IOException {\n+                    simulateTimeout(delegate);\n+\n+                    return src.read(b);\n+                }\n+\n+                @Override public int read(@NotNull byte[] b, int off, int len) throws IOException {\n+                    simulateTimeout(delegate);\n+\n+                    return src.read(b, off, len);\n+                }\n+\n+                @Override public long skip(long n) throws IOException {\n+                    simulateTimeout(delegate);\n+\n+                    return src.skip(n);\n+                }\n+\n+                @Override public int available() throws IOException {\n+                    return src.available();\n+                }\n+\n+                @Override public void close() throws IOException {\n+                    src.close();\n+                }\n+\n+                @Override public synchronized void mark(int readlimit) {\n+                    src.mark(readlimit);\n+                }\n+\n+                @Override public synchronized void reset() throws IOException {\n+                    src.reset();\n+                }\n+\n+                @Override public boolean markSupported() {\n+                    return src.markSupported();\n+                }\n+\n+                @Override public int read() throws IOException {\n+                    simulateTimeout(delegate);\n+\n+                    return src.read();\n+                }\n+            };\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public SocketChannel getChannel() {\n+            throw new UnsupportedOperationException(\"Failure simulation for socket channel is not supported yet.\");\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void connect(SocketAddress endpoint) throws IOException {\n+            simulateTimeout(delegate);\n+\n+            delegate.connect(endpoint);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void connect(SocketAddress endpoint, int timeout) throws IOException {\n+            simulateTimeout(delegate);\n+\n+            delegate.connect(endpoint, timeout);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void bind(SocketAddress bindpoint) throws IOException {\n+            delegate.bind(bindpoint);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public InetAddress getInetAddress() {\n+            return delegate.getInetAddress();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public InetAddress getLocalAddress() {\n+            return delegate.getLocalAddress();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int getPort() {\n+            return delegate.getPort();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int getLocalPort() {\n+            return delegate.getLocalPort();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public SocketAddress getRemoteSocketAddress() {\n+            return delegate.getRemoteSocketAddress();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public SocketAddress getLocalSocketAddress() {\n+            return delegate.getLocalSocketAddress();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void setTcpNoDelay(boolean on) throws SocketException {\n+            delegate.setTcpNoDelay(on);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean getTcpNoDelay() throws SocketException {\n+            return delegate.getTcpNoDelay();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void setSoLinger(boolean on, int linger) throws SocketException {\n+            delegate.setSoLinger(on, linger);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int getSoLinger() throws SocketException {\n+            return delegate.getSoLinger();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void sendUrgentData(int data) throws IOException {\n+            delegate.sendUrgentData(data);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void setOOBInline(boolean on) throws SocketException {\n+            delegate.setOOBInline(on);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean getOOBInline() throws SocketException {\n+            return delegate.getOOBInline();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public synchronized void setSoTimeout(int timeout) throws SocketException {\n+            delegate.setSoTimeout(timeout);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public synchronized int getSoTimeout() throws SocketException {\n+            return delegate.getSoTimeout();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public synchronized void setSendBufferSize(int size) throws SocketException {\n+            delegate.setSendBufferSize(size);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public synchronized int getSendBufferSize() throws SocketException {\n+            return delegate.getSendBufferSize();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public synchronized void setReceiveBufferSize(int size) throws SocketException {\n+            delegate.setReceiveBufferSize(size);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public synchronized int getReceiveBufferSize() throws SocketException {\n+            return delegate.getReceiveBufferSize();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void setKeepAlive(boolean on) throws SocketException {\n+            delegate.setKeepAlive(on);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean getKeepAlive() throws SocketException {\n+            return delegate.getKeepAlive();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void setTrafficClass(int tc) throws SocketException {\n+            delegate.setTrafficClass(tc);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int getTrafficClass() throws SocketException {\n+            return delegate.getTrafficClass();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void setReuseAddress(boolean on) throws SocketException {\n+            delegate.setReuseAddress(on);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean getReuseAddress() throws SocketException {\n+            return delegate.getReuseAddress();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public synchronized void close() throws IOException {\n+            delegate.close();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void shutdownInput() throws IOException {\n+            delegate.shutdownInput();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void shutdownOutput() throws IOException {\n+            delegate.shutdownOutput();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public String toString() {\n+            return delegate.toString();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean isConnected() {\n+            return delegate.isConnected();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean isBound() {\n+            return delegate.isBound();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean isClosed() {\n+            return delegate.isClosed();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean isInputShutdown() {\n+            return delegate.isInputShutdown();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean isOutputShutdown() {\n+            return delegate.isOutputShutdown();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {\n+            delegate.setPerformancePreferences(connectionTime, latency, bandwidth);\n+        }\n+    }\n+}"
  }
]
