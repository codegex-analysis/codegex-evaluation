[
  {
    "sha": "90a00f813c699133980bc6c6dfd4cb63deb64bdc",
    "filename": "lucene/core/src/java/org/apache/lucene/search/DisjunctionMatchesIterator.java",
    "status": "modified",
    "additions": 5,
    "deletions": 1,
    "changes": 6,
    "blob_url": "https://github.com/apache/lucene/blob/3888b5266b90a8bf8f3896585cd6d3319460488b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMatchesIterator.java",
    "raw_url": "https://github.com/apache/lucene/raw/3888b5266b90a8bf8f3896585cd6d3319460488b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMatchesIterator.java",
    "contents_url": "https://api.github.com/repos/apache/lucene/contents/lucene/core/src/java/org/apache/lucene/search/DisjunctionMatchesIterator.java?ref=3888b5266b90a8bf8f3896585cd6d3319460488b",
    "patch": "@@ -250,6 +250,10 @@ public MatchesIterator getSubMatches() throws IOException {\n \n   @Override\n   public Query getQuery() {\n-    return queue.top().getQuery();\n+    if (queue.size() > 0) {\n+      return queue.top().getQuery();\n+    } else {\n+      return null;\n+    }\n   }\n }"
  },
  {
    "sha": "1a08a6855874c61edff2c428ae9da7aaeeb14881",
    "filename": "lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/MatchRegionRetriever.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/lucene/blob/3888b5266b90a8bf8f3896585cd6d3319460488b/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/MatchRegionRetriever.java",
    "raw_url": "https://github.com/apache/lucene/raw/3888b5266b90a8bf8f3896585cd6d3319460488b/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/MatchRegionRetriever.java",
    "contents_url": "https://api.github.com/repos/apache/lucene/contents/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/MatchRegionRetriever.java?ref=3888b5266b90a8bf8f3896585cd6d3319460488b",
    "patch": "@@ -262,7 +262,7 @@ public static OffsetsRetrievalStrategySupplier computeOffsetRetrievalStrategies(\n \n       switch (fieldInfo.getIndexOptions()) {\n         case DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS:\n-          return new OffsetsFromMatchIterator(field);\n+          return new OffsetsFromMatchIterator(field, analyzer);\n \n         case DOCS_AND_FREQS_AND_POSITIONS:\n           return new OffsetsFromPositions(field, analyzer);"
  },
  {
    "sha": "444c9998a723cf97eeec3f21b1ee32fd9c22b86a",
    "filename": "lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/OffsetsFromMatchIterator.java",
    "status": "modified",
    "additions": 127,
    "deletions": 1,
    "changes": 128,
    "blob_url": "https://github.com/apache/lucene/blob/3888b5266b90a8bf8f3896585cd6d3319460488b/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/OffsetsFromMatchIterator.java",
    "raw_url": "https://github.com/apache/lucene/raw/3888b5266b90a8bf8f3896585cd6d3319460488b/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/OffsetsFromMatchIterator.java",
    "contents_url": "https://api.github.com/repos/apache/lucene/contents/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/OffsetsFromMatchIterator.java?ref=3888b5266b90a8bf8f3896585cd6d3319460488b",
    "patch": "@@ -18,15 +18,27 @@\n \n import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import org.apache.lucene.analysis.Analyzer;\n+import org.apache.lucene.analysis.TokenStream;\n+import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;\n+import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;\n+import org.apache.lucene.queries.intervals.ExtendedIntervalsSource;\n+import org.apache.lucene.queries.intervals.IntervalQuery;\n+import org.apache.lucene.queries.intervals.IntervalsSource;\n import org.apache.lucene.search.MatchesIterator;\n+import org.apache.lucene.search.Query;\n \n /** This strategy retrieves offsets directly from {@link MatchesIterator}. */\n public final class OffsetsFromMatchIterator implements OffsetsRetrievalStrategy {\n   private final String field;\n+  private final Analyzer analyzer;\n \n-  OffsetsFromMatchIterator(String field) {\n+  OffsetsFromMatchIterator(String field, Analyzer analyzer) {\n     this.field = field;\n+    this.analyzer = analyzer;\n   }\n \n   @Override\n@@ -42,6 +54,120 @@\n       }\n       ranges.add(new OffsetRange(from, to));\n     }\n+\n+    // nocommit seems too many type checking & casting?\n+    Query query = matchesIterator.getQuery();\n+    if (query != null && query instanceof IntervalQuery) {\n+      IntervalsSource intervalsSource = ((IntervalQuery) query).getIntervalsSource();\n+      if (intervalsSource instanceof ExtendedIntervalsSource) {\n+        ExtendedIntervalsSource extendedIntervalsSource = (ExtendedIntervalsSource) intervalsSource;\n+        // nocommit is there better way to get before / after values from ExtendedIntervalsSource ?\n+        int before = extendedIntervalsSource.getBefore();\n+        int after = extendedIntervalsSource.getAfter();\n+\n+        if (before > 0 || after > 0) {\n+          return adjustOffsetRange(doc, ranges, before, after);\n+        }\n+      }\n+    }\n+\n     return ranges;\n   }\n+\n+  private List<OffsetRange> adjustOffsetRange(\n+      MatchRegionRetriever.FieldValueProvider doc,\n+      ArrayList<OffsetRange> ranges,\n+      int before,\n+      int after)\n+      throws IOException {\n+    int position = -1;\n+    int valueOffset = 0;\n+\n+    Map<Integer, OffsetsPair> positionToOffsets = new HashMap<>();\n+    Map<Integer, Integer> startOffsetToPosition = new HashMap<>();\n+    Map<Integer, Integer> endOffsetToPosition = new HashMap<>();\n+\n+    List<CharSequence> values = doc.getValues(field);\n+    for (CharSequence charSequence : values) {\n+      final String value = charSequence.toString();\n+\n+      TokenStream ts = analyzer.tokenStream(field, value);\n+      OffsetAttribute offsetAttr = ts.getAttribute(OffsetAttribute.class);\n+      PositionIncrementAttribute posAttr = ts.getAttribute(PositionIncrementAttribute.class);\n+      ts.reset();\n+\n+      // go through all tokens to collect position from / to offset mappings\n+      while (ts.incrementToken()) {\n+        position += posAttr.getPositionIncrement();\n+        int startOffset = valueOffset + offsetAttr.startOffset();\n+        int endOffset = valueOffset + offsetAttr.endOffset();\n+\n+        positionToOffsets.put(position, new OffsetsPair(startOffset, endOffset));\n+        startOffsetToPosition.put(startOffset, position);\n+        endOffsetToPosition.put(endOffset, position);\n+      }\n+      ts.end();\n+      position += posAttr.getPositionIncrement() + analyzer.getPositionIncrementGap(field);\n+      valueOffset += offsetAttr.endOffset() + analyzer.getOffsetGap(field);\n+      ts.close();\n+    }\n+\n+    int maxPosition = position - analyzer.getPositionIncrementGap(field);\n+\n+    ArrayList<OffsetRange> extendedRanges = new ArrayList<>();\n+    for (OffsetRange original : ranges) {\n+      int originalStartOffset = original.from;\n+      int originalEndOffset = original.to;\n+      int originalStartPosition = startOffsetToPosition.get(originalStartOffset);\n+      int originalEndPosition = endOffsetToPosition.get(originalEndOffset);\n+\n+      int extendedStartPosition = Math.max(0, originalStartPosition - before);\n+      // nocommit needs to handle overflow\n+      int extendedEndPosition = Math.min(maxPosition, originalEndPosition + after);\n+\n+      assert extendedStartPosition >= 0;\n+      assert extendedEndPosition >= 0;\n+\n+      // nocommit is the following correct handling of highlighting when there's also token\n+      // filtering such as stopword?\n+      // if extendedStartPosition is not available due to stopword filtered out etc, find the\n+      // next possible extendedStartPosition\n+      // it's very likely that the next available extendedStartPosition requires only once or\n+      // twice increment, hence \"brute-force\" scan is used here\n+      while (!positionToOffsets.containsKey(extendedStartPosition)) {\n+        extendedStartPosition++;\n+      }\n+\n+      // nocommit is the following correct handling of highlighting when there's also token\n+      // filtering such as stopword?\n+      // if extendedEndPosition is not available due to stopword filtered out etc, find the\n+      // next possible extendedEndPosition\n+      // it's very likely that the next available extendedEndPosition requires only once or\n+      // twice decrement, hence \"brute-force\" scan is used here\n+      while (!positionToOffsets.containsKey(extendedEndPosition)) {\n+        extendedEndPosition--;\n+      }\n+\n+      int extendedStartOffset = positionToOffsets.get(extendedStartPosition).startOffset;\n+      int extendedEndOffset = positionToOffsets.get(extendedEndPosition).endOffset;\n+\n+      extendedRanges.add(new OffsetRange(extendedStartOffset, extendedEndOffset));\n+    }\n+    return extendedRanges;\n+  }\n+\n+  @Override\n+  public boolean requiresDocument() {\n+    return true;\n+  }\n+\n+  private class OffsetsPair {\n+    int startOffset;\n+    int endOffset;\n+\n+    public OffsetsPair(int startOffset, int endOffset) {\n+      this.startOffset = startOffset;\n+      this.endOffset = endOffset;\n+    }\n+  }\n }"
  },
  {
    "sha": "a52782624245160554ca2e593a3b42830105047d",
    "filename": "lucene/highlighter/src/test/org/apache/lucene/search/matchhighlight/TestMatchRegionRetriever.java",
    "status": "modified",
    "additions": 42,
    "deletions": 4,
    "changes": 46,
    "blob_url": "https://github.com/apache/lucene/blob/3888b5266b90a8bf8f3896585cd6d3319460488b/lucene/highlighter/src/test/org/apache/lucene/search/matchhighlight/TestMatchRegionRetriever.java",
    "raw_url": "https://github.com/apache/lucene/raw/3888b5266b90a8bf8f3896585cd6d3319460488b/lucene/highlighter/src/test/org/apache/lucene/search/matchhighlight/TestMatchRegionRetriever.java",
    "contents_url": "https://api.github.com/repos/apache/lucene/contents/lucene/highlighter/src/test/org/apache/lucene/search/matchhighlight/TestMatchRegionRetriever.java?ref=3888b5266b90a8bf8f3896585cd6d3319460488b",
    "patch": "@@ -397,15 +397,53 @@ public void testDegenerateIntervalsWithPositions() throws IOException {\n   }\n \n   @Test\n-  @AwaitsFix(\n-      bugUrl =\n-          \"https://issues.apache.org/jira/browse/LUCENE-9634: \"\n-              + \"Highlighting of degenerate spans on fields with offsets doesn't work properly\")\n+  public void testDegenerateIntervalsWithStopwordsAndPositions() throws IOException {\n+    testDegenerateIntervalsWithStopword(FLD_TEXT_POS);\n+  }\n+\n+  @Test\n   public void testDegenerateIntervalsWithOffsets() throws IOException {\n     testDegenerateIntervals(FLD_TEXT_POS_OFFS);\n   }\n \n+  @Test\n+  public void testDegenerateIntervalsWithStopwordsAndOffsets() throws IOException {\n+    testDegenerateIntervalsWithStopword(FLD_TEXT_POS_OFFS);\n+  }\n+\n   public void testDegenerateIntervals(String field) throws IOException {\n+    new IndexBuilder(this::toField)\n+        .doc(field, \"foo bla bar wow\")\n+        .build(\n+            analyzer,\n+            reader -> {\n+              assertThat(\n+                  highlights(\n+                      reader,\n+                      new IntervalQuery(field, Intervals.extend(Intervals.term(\"wow\"), 1, 3))),\n+                  containsInAnyOrder(fmt(\"0: (%s: 'foo bla >bar wow<')\", field)));\n+\n+              assertThat(\n+                  highlights(\n+                      reader,\n+                      new IntervalQuery(field, Intervals.extend(Intervals.term(\"bar\"), 1, 1))),\n+                  containsInAnyOrder(fmt(\"0: (%s: 'foo >bla bar wow<')\", field)));\n+\n+              assertThat(\n+                  highlights(\n+                      reader,\n+                      new IntervalQuery(field, Intervals.extend(Intervals.term(\"bar\"), 1, 0))),\n+                  containsInAnyOrder(fmt(\"0: (%s: 'foo >bla bar< wow')\", field)));\n+\n+              assertThat(\n+                  highlights(\n+                      reader,\n+                      new IntervalQuery(field, Intervals.extend(Intervals.term(\"bar\"), 5, 100))),\n+                  containsInAnyOrder(fmt(\"0: (%s: '>foo bla bar wow<')\", field)));\n+            });\n+  }\n+\n+  public void testDegenerateIntervalsWithStopword(String field) throws IOException {\n     new IndexBuilder(this::toField)\n         .doc(field, fmt(\"foo %s bar\", STOPWORD1))\n         .build("
  },
  {
    "sha": "4181a4d17e6ebe3e320ddbda4eb90eee8ed72866",
    "filename": "lucene/queries/src/java/org/apache/lucene/queries/intervals/ExtendedIntervalsSource.java",
    "status": "modified",
    "additions": 10,
    "deletions": 1,
    "changes": 11,
    "blob_url": "https://github.com/apache/lucene/blob/3888b5266b90a8bf8f3896585cd6d3319460488b/lucene/queries/src/java/org/apache/lucene/queries/intervals/ExtendedIntervalsSource.java",
    "raw_url": "https://github.com/apache/lucene/raw/3888b5266b90a8bf8f3896585cd6d3319460488b/lucene/queries/src/java/org/apache/lucene/queries/intervals/ExtendedIntervalsSource.java",
    "contents_url": "https://api.github.com/repos/apache/lucene/contents/lucene/queries/src/java/org/apache/lucene/queries/intervals/ExtendedIntervalsSource.java?ref=3888b5266b90a8bf8f3896585cd6d3319460488b",
    "patch": "@@ -25,7 +25,8 @@\n import org.apache.lucene.index.LeafReaderContext;\n import org.apache.lucene.search.QueryVisitor;\n \n-class ExtendedIntervalsSource extends IntervalsSource {\n+/** IntervalSource that supports before and after extension around current intervals */\n+public class ExtendedIntervalsSource extends IntervalsSource {\n \n   final IntervalsSource source;\n   private final int before;\n@@ -100,4 +101,12 @@ public int hashCode() {\n   public String toString() {\n     return \"EXTEND(\" + source + \",\" + before + \",\" + after + \")\";\n   }\n+\n+  public int getBefore() {\n+    return before;\n+  }\n+\n+  public int getAfter() {\n+    return after;\n+  }\n }"
  },
  {
    "sha": "eb55b20c06123833a928158483378773a9cd9a82",
    "filename": "lucene/queries/src/java/org/apache/lucene/queries/intervals/IntervalQuery.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/apache/lucene/blob/3888b5266b90a8bf8f3896585cd6d3319460488b/lucene/queries/src/java/org/apache/lucene/queries/intervals/IntervalQuery.java",
    "raw_url": "https://github.com/apache/lucene/raw/3888b5266b90a8bf8f3896585cd6d3319460488b/lucene/queries/src/java/org/apache/lucene/queries/intervals/IntervalQuery.java",
    "contents_url": "https://api.github.com/repos/apache/lucene/contents/lucene/queries/src/java/org/apache/lucene/queries/intervals/IntervalQuery.java?ref=3888b5266b90a8bf8f3896585cd6d3319460488b",
    "patch": "@@ -145,6 +145,11 @@ public int hashCode() {\n     return Objects.hash(field, intervalsSource);\n   }\n \n+  public IntervalsSource getIntervalsSource() {\n+    // nocommit clone?\n+    return intervalsSource;\n+  }\n+\n   private class IntervalWeight extends Weight {\n \n     final ScoreMode scoreMode;"
  }
]
