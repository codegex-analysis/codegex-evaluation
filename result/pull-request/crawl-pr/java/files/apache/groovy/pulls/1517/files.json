[
  {
    "sha": "b24cb91aa24f0d7d460bbbf00f3175266ef512b4",
    "filename": "src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java",
    "status": "modified",
    "additions": 29,
    "deletions": 22,
    "changes": 51,
    "blob_url": "https://github.com/apache/groovy/blob/10a364b7151ccbf65f1f7c80ef6c71aeaed7ffa7/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java",
    "raw_url": "https://github.com/apache/groovy/raw/10a364b7151ccbf65f1f7c80ef6c71aeaed7ffa7/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java",
    "contents_url": "https://api.github.com/repos/apache/groovy/contents/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java?ref=10a364b7151ccbf65f1f7c80ef6c71aeaed7ffa7",
    "patch": "@@ -744,25 +744,15 @@ public void visitBinaryExpression(final BinaryExpression expression) {\n                 if (ensureValidSetter(expression, leftExpression, rightExpression, setterInfo)) {\n                     return;\n                 }\n+                lType = getType(leftExpression);\n             } else {\n                 lType = getType(leftExpression);\n-                boolean isFunctionalInterface = isFunctionalInterface(lType);\n-                if (isFunctionalInterface && rightExpression instanceof MethodReferenceExpression) {\n-                    LambdaExpression lambdaExpression = constructLambdaExpressionForMethodReference(lType);\n-                    if (op == ASSIGN) {\n-                        inferParameterAndReturnTypesOfClosureOnRHS(lType, lambdaExpression);\n-                    }\n-                    rightExpression.putNodeMetaData(CONSTRUCTED_LAMBDA_EXPRESSION, lambdaExpression);\n-                    rightExpression.putNodeMetaData(CLOSURE_ARGUMENTS, Arrays.stream(lambdaExpression.getParameters()).map(Parameter::getType).toArray(ClassNode[]::new));\n-\n-                } else if (op == ASSIGN && isFunctionalInterface && rightExpression instanceof ClosureExpression) {\n-                    inferParameterAndReturnTypesOfClosureOnRHS(lType, (ClosureExpression) rightExpression);\n+                if (op == ASSIGN && isFunctionalInterface(lType)) {\n+                    processFunctionalInterfaceAssignment(lType, rightExpression);\n                 }\n-\n                 rightExpression.visit(this);\n             }\n \n-            if (lType == null) lType = getType(leftExpression);\n             ClassNode rType = isNullConstant(rightExpression) && !isPrimitiveType(lType)\n                     ? UNKNOWN_PARAMETER_TYPE // null to primitive type is handled elsewhere\n                     : getInferredTypeFromTempInfo(rightExpression, getType(rightExpression));\n@@ -910,6 +900,18 @@ private void validateResourceInARM(final BinaryExpression expression, final Clas\n         }\n     }\n \n+    private void processFunctionalInterfaceAssignment(final ClassNode lhsType, final Expression rhsExpression) {\n+        if (rhsExpression instanceof ClosureExpression) {\n+            inferParameterAndReturnTypesOfClosureOnRHS(lhsType, (ClosureExpression) rhsExpression);\n+        } else if (rhsExpression instanceof MethodReferenceExpression) {\n+            LambdaExpression lambdaExpression = constructLambdaExpressionForMethodReference(lhsType);\n+\n+            inferParameterAndReturnTypesOfClosureOnRHS(lhsType, lambdaExpression);\n+            rhsExpression.putNodeMetaData(CONSTRUCTED_LAMBDA_EXPRESSION, lambdaExpression);\n+            rhsExpression.putNodeMetaData(CLOSURE_ARGUMENTS, Arrays.stream(lambdaExpression.getParameters()).map(Parameter::getType).toArray(ClassNode[]::new));\n+        }\n+    }\n+\n     private void inferParameterAndReturnTypesOfClosureOnRHS(final ClassNode lhsType, final ClosureExpression rhsExpression) {\n         Tuple2<ClassNode[], ClassNode> typeInfo = GenericsUtils.parameterizeSAM(lhsType);\n         Parameter[] closureParameters = getParametersSafe(rhsExpression);\n@@ -1821,7 +1823,9 @@ public void visitProperty(final PropertyNode node) {\n         try {\n             typeCheckingContext.isInStaticContext = node.isInStaticContext();\n             currentProperty = node;\n-            super.visitProperty(node);\n+            visitAnnotations(node);\n+            visitClassCodeContainer(node.getGetterBlock());\n+            visitClassCodeContainer(node.getSetterBlock());\n         } finally {\n             currentProperty = null;\n             typeCheckingContext.isInStaticContext = osc;\n@@ -1834,19 +1838,22 @@ public void visitField(final FieldNode node) {\n         try {\n             typeCheckingContext.isInStaticContext = node.isInStaticContext();\n             currentField = node;\n-            super.visitField(node);\n+            visitAnnotations(node);\n             Expression init = node.getInitialExpression();\n             if (init != null) {\n-                FieldExpression left = new FieldExpression(node);\n-                BinaryExpression bexp = assignX(left, init, node);\n-                ClassNode lType = getType(node), rType = getType(init);\n-                typeCheckAssignment(bexp, left, lType, init, getResultType(lType, ASSIGN, rType, bexp));\n-\n+                ClassNode lType = getType(node);\n+                if (isFunctionalInterface(lType)) { // GROOVY-9977\n+                    processFunctionalInterfaceAssignment(lType, init);\n+                }\n+                init.visit(this);\n+                ClassNode rType = getType(init);\n                 if (init instanceof ConstructorCallExpression) {\n                     inferDiamondType((ConstructorCallExpression) init, lType);\n-                } else if (init instanceof ClosureExpression && isFunctionalInterface(lType)) {\n-                    inferParameterAndReturnTypesOfClosureOnRHS(lType, (ClosureExpression) init);\n                 }\n+\n+                FieldExpression left = new FieldExpression(node);\n+                BinaryExpression bexp = assignX(left, init, node);\n+                typeCheckAssignment(bexp, left, lType, init, getResultType(lType, ASSIGN, rType, bexp));\n             }\n         } finally {\n             currentField = null;"
  },
  {
    "sha": "618f18f5f8b6d2f85972d030cf21153c254666ba",
    "filename": "src/test/groovy/transform/stc/LambdaTest.groovy",
    "status": "modified",
    "additions": 37,
    "deletions": 0,
    "changes": 37,
    "blob_url": "https://github.com/apache/groovy/blob/10a364b7151ccbf65f1f7c80ef6c71aeaed7ffa7/src/test/groovy/transform/stc/LambdaTest.groovy",
    "raw_url": "https://github.com/apache/groovy/raw/10a364b7151ccbf65f1f7c80ef6c71aeaed7ffa7/src/test/groovy/transform/stc/LambdaTest.groovy",
    "contents_url": "https://api.github.com/repos/apache/groovy/contents/src/test/groovy/transform/stc/LambdaTest.groovy?ref=10a364b7151ccbf65f1f7c80ef6c71aeaed7ffa7",
    "patch": "@@ -293,6 +293,43 @@ final class LambdaTest {\n         '''\n     }\n \n+    @Test\n+    void testComparator1() {\n+        assertScript '''\n+            @groovy.transform.CompileStatic class T {\n+                Comparator<Integer> c = (Integer a, Integer b) -> Integer.compare(a, b)\n+            }\n+            def t = new T()\n+            assert t.c.compare(0,0) == 0\n+        '''\n+\n+        def err = shouldFail '''\n+            @groovy.transform.CompileStatic class T {\n+                Comparator<Integer> c = (int a, int b) -> Integer.compare(a, b)\n+            }\n+        '''\n+        assert err =~ /Cannot assign java.util.Comparator <int> to: java.util.Comparator <Integer>/\n+    }\n+\n+    @Test // GROOVY-9977\n+    void testComparator2() {\n+        assertScript '''\n+            @groovy.transform.CompileStatic\n+            class T {\n+                Comparator<Integer> c = (a, b) -> Integer.compare(a, b)\n+\n+                static void m1() {\n+                    Comparator<Integer> x = (a, b) -> Integer.compare(a, b)\n+                }\n+                void m2() {\n+                    Comparator<Integer> y = (a, b) -> Integer.compare(a, b)\n+                }\n+            }\n+            def t = new T()\n+            assert t.c.compare(0,0) == 0\n+        '''\n+    }\n+\n     @Test\n     void testFunctionWithLocalVariables() {\n         assertScript '''"
  }
]
