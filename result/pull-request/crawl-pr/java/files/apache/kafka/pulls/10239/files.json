[
  {
    "sha": "5c3a5a0d5c3656be9ac10695d9b24c1e228fffd3",
    "filename": "connect/transforms/src/main/java/org/apache/kafka/connect/transforms/TimestampConverter.java",
    "status": "modified",
    "additions": 319,
    "deletions": 196,
    "changes": 515,
    "blob_url": "https://github.com/apache/kafka/blob/2d741bba5c008308fb9b136b1b430f96d0b0be60/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/TimestampConverter.java",
    "raw_url": "https://github.com/apache/kafka/raw/2d741bba5c008308fb9b136b1b430f96d0b0be60/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/TimestampConverter.java",
    "contents_url": "https://api.github.com/repos/apache/kafka/contents/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/TimestampConverter.java?ref=2d741bba5c008308fb9b136b1b430f96d0b0be60",
    "patch": "@@ -37,6 +37,8 @@\n \n import java.text.ParseException;\n import java.text.SimpleDateFormat;\n+import java.time.LocalDate;\n+import java.time.ZoneOffset;\n import java.util.Arrays;\n import java.util.Calendar;\n import java.util.Date;\n@@ -54,25 +56,50 @@\n     public static final String OVERVIEW_DOC =\n             \"Convert timestamps between different formats such as Unix epoch, strings, and Connect Date/Timestamp types.\"\n                     + \"Applies to individual fields or to the entire value.\"\n-                    + \"<p/>Use the concrete transformation type designed for the record key (<code>\" + TimestampConverter.Key.class.getName() + \"</code>) \"\n-                    + \"or value (<code>\" + TimestampConverter.Value.class.getName() + \"</code>).\";\n+                    + \"<p/>Use the concrete transformation type designed for the record key (<code>\"\n+                    + TimestampConverter.Key.class.getName()\n+                    + \"</code>) \"\n+                    + \"or value (<code>\"\n+                    + TimestampConverter.Value.class.getName()\n+                    + \"</code>).\";\n \n     public static final String FIELD_CONFIG = \"field\";\n     private static final String FIELD_DEFAULT = \"\";\n \n     public static final String TARGET_TYPE_CONFIG = \"target.type\";\n \n-    public static final String FORMAT_CONFIG = \"format\";\n-    private static final String FORMAT_DEFAULT = \"\";\n-\n-    public static final ConfigDef CONFIG_DEF = new ConfigDef()\n-            .define(FIELD_CONFIG, ConfigDef.Type.STRING, FIELD_DEFAULT, ConfigDef.Importance.HIGH,\n-                    \"The field containing the timestamp, or empty if the entire value is a timestamp\")\n-            .define(TARGET_TYPE_CONFIG, ConfigDef.Type.STRING, ConfigDef.Importance.HIGH,\n-                    \"The desired timestamp representation: string, unix, Date, Time, or Timestamp\")\n-            .define(FORMAT_CONFIG, ConfigDef.Type.STRING, FORMAT_DEFAULT, ConfigDef.Importance.MEDIUM,\n-                    \"A SimpleDateFormat-compatible format for the timestamp. Used to generate the output when type=string \"\n-                            + \"or used to parse the input if the input is a string.\");\n+    public static final String FORMAT_DATE_CONFIG = \"format.date\";\n+    public static final String FORMAT_TIMESTAMP_CONFIG = \"format.timestamp\";\n+    private static final String FORMAT_TIMESTAMP_DEFAULT = \"yyyy-MM-dd HH:mm:ss\";\n+    private static final String FORMAT_DATE_DEFAULT = \"yyyy-MM-dd\";\n+\n+    public static final ConfigDef CONFIG_DEF =\n+            new ConfigDef()\n+                    .define(\n+                            FIELD_CONFIG,\n+                            ConfigDef.Type.STRING,\n+                            FIELD_DEFAULT,\n+                            ConfigDef.Importance.HIGH,\n+                            \"The field containing the timestamp, or empty if the entire value is a timestamp\")\n+                    .define(\n+                            TARGET_TYPE_CONFIG,\n+                            ConfigDef.Type.STRING,\n+                            ConfigDef.Importance.HIGH,\n+                            \"The desired timestamp representation: string, unix, Date, Time, or Timestamp\")\n+                    .define(\n+                            FORMAT_TIMESTAMP_CONFIG,\n+                            ConfigDef.Type.STRING,\n+                            FORMAT_TIMESTAMP_DEFAULT,\n+                            ConfigDef.Importance.MEDIUM,\n+                            \"A SimpleDateFormat-compatible format for the timestamp. Used to generate the output when type=string \"\n+                                    + \"or used to parse the input if the input is a string.\")\n+                    .define(\n+                            FORMAT_DATE_CONFIG,\n+                            ConfigDef.Type.STRING,\n+                            FORMAT_DATE_DEFAULT,\n+                            ConfigDef.Importance.MEDIUM,\n+                            \"A SimpleDateFormat-compatible format for the date. Used to generate the output when type=string \"\n+                                    + \"or used to parse the input if the input is a string.\");\n \n     private static final String PURPOSE = \"converting timestamp formats\";\n \n@@ -81,194 +108,256 @@\n     private static final String TYPE_DATE = \"Date\";\n     private static final String TYPE_TIME = \"Time\";\n     private static final String TYPE_TIMESTAMP = \"Timestamp\";\n-    private static final Set<String> VALID_TYPES = new HashSet<>(Arrays.asList(TYPE_STRING, TYPE_UNIX, TYPE_DATE, TYPE_TIME, TYPE_TIMESTAMP));\n+    private static final Set<String> VALID_TYPES =\n+            new HashSet<>(\n+                    Arrays.asList(TYPE_STRING, TYPE_UNIX, TYPE_DATE, TYPE_TIME, TYPE_TIMESTAMP));\n \n     private static final TimeZone UTC = TimeZone.getTimeZone(\"UTC\");\n \n-    public static final Schema OPTIONAL_DATE_SCHEMA = org.apache.kafka.connect.data.Date.builder().optional().schema();\n+    public static final Schema OPTIONAL_DATE_SCHEMA =\n+            org.apache.kafka.connect.data.Date.builder().optional().schema();\n     public static final Schema OPTIONAL_TIMESTAMP_SCHEMA = Timestamp.builder().optional().schema();\n     public static final Schema OPTIONAL_TIME_SCHEMA = Time.builder().optional().schema();\n \n     private interface TimestampTranslator {\n-        /**\n-         * Convert from the type-specific format to the universal java.util.Date format\n-         */\n+        /** Convert from the type-specific format to the universal java.util.Date format */\n         Date toRaw(Config config, Object orig);\n \n-        /**\n-         * Get the schema for this format.\n-         */\n+        /** Get the schema for this format. */\n         Schema typeSchema(boolean isOptional);\n \n-        /**\n-         * Convert from the universal java.util.Date format to the type-specific format\n-         */\n-        Object toType(Config config, Date orig);\n+        /** Convert from the universal java.util.Date format to the type-specific format */\n+        Object toType(Config config, Date orig, Schema schema);\n     }\n \n     private static final Map<String, TimestampTranslator> TRANSLATORS = new HashMap<>();\n+\n     static {\n-        TRANSLATORS.put(TYPE_STRING, new TimestampTranslator() {\n-            @Override\n-            public Date toRaw(Config config, Object orig) {\n-                if (!(orig instanceof String))\n-                    throw new DataException(\"Expected string timestamp to be a String, but found \" + orig.getClass());\n-                try {\n-                    return config.format.parse((String) orig);\n-                } catch (ParseException e) {\n-                    throw new DataException(\"Could not parse timestamp: value (\" + orig + \") does not match pattern (\"\n-                            + config.format.toPattern() + \")\", e);\n-                }\n-            }\n+        TRANSLATORS.put(\n+                TYPE_STRING,\n+                new TimestampTranslator() {\n+                    @Override\n+                    public Date toRaw(Config config, Object orig) {\n+                        if (!(orig instanceof String))\n+                            throw new DataException(\n+                                    \"Expected string timestamp to be a String, but found \"\n+                                            + orig.getClass());\n+                        try {\n+                            return config.formatTimestamp.parse((String) orig);\n+                        } catch (ParseException e) {\n+                            throw new DataException(\n+                                    \"Could not parse timestamp: value (\"\n+                                            + orig\n+                                            + \") does not match pattern (\"\n+                                            + config.formatTimestamp.toPattern()\n+                                            + \")\",\n+                                    e);\n+                        }\n+                    }\n \n-            @Override\n-            public Schema typeSchema(boolean isOptional) {\n-                return isOptional ? Schema.OPTIONAL_STRING_SCHEMA : Schema.STRING_SCHEMA;\n-            }\n+                    @Override\n+                    public Schema typeSchema(boolean isOptional) {\n+                        return isOptional ? Schema.OPTIONAL_STRING_SCHEMA : Schema.STRING_SCHEMA;\n+                    }\n \n-            @Override\n-            public String toType(Config config, Date orig) {\n-                synchronized (config.format) {\n-                    return config.format.format(orig);\n-                }\n-            }\n-        });\n-\n-        TRANSLATORS.put(TYPE_UNIX, new TimestampTranslator() {\n-            @Override\n-            public Date toRaw(Config config, Object orig) {\n-                if (!(orig instanceof Long))\n-                    throw new DataException(\"Expected Unix timestamp to be a Long, but found \" + orig.getClass());\n-                return Timestamp.toLogical(Timestamp.SCHEMA, (Long) orig);\n-            }\n+                    @Override\n+                    public String toType(Config config, Date orig, Schema fieldSchema) {\n+                        if (fieldSchema != null\n+                                && (org.apache.kafka.connect.data.Date.LOGICAL_NAME.equals(\n+                                fieldSchema.name()))) {\n+                            synchronized (config.formatDate) {\n+                                return config.formatDate.format(orig);\n+                            }\n+                        } else {\n+                            synchronized (config.formatTimestamp) {\n+                                return config.formatTimestamp.format(orig);\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        TRANSLATORS.put(\n+                TYPE_UNIX,\n+                new TimestampTranslator() {\n+                    @Override\n+                    public Date toRaw(Config config, Object orig) {\n+                        if (orig instanceof Integer) orig = Long.valueOf(orig.toString());\n+                        if (!(orig instanceof Long))\n+                            throw new DataException(\n+                                    \"Expected Unix timestamp to be a Long, but found \"\n+                                            + orig.getClass());\n+                        if (orig.toString().length() > 14) orig = (Long) orig / 1000;\n+                        return Timestamp.toLogical(Timestamp.SCHEMA, (Long) orig);\n+                    }\n \n-            @Override\n-            public Schema typeSchema(boolean isOptional) {\n-                return isOptional ? Schema.OPTIONAL_INT64_SCHEMA : Schema.INT64_SCHEMA;\n-            }\n+                    @Override\n+                    public Schema typeSchema(boolean isOptional) {\n+                        return isOptional ? Schema.OPTIONAL_INT64_SCHEMA : Schema.INT64_SCHEMA;\n+                    }\n \n-            @Override\n-            public Long toType(Config config, Date orig) {\n-                return Timestamp.fromLogical(Timestamp.SCHEMA, orig);\n-            }\n-        });\n-\n-        TRANSLATORS.put(TYPE_DATE, new TimestampTranslator() {\n-            @Override\n-            public Date toRaw(Config config, Object orig) {\n-                if (!(orig instanceof Date))\n-                    throw new DataException(\"Expected Date to be a java.util.Date, but found \" + orig.getClass());\n-                // Already represented as a java.util.Date and Connect Dates are a subset of valid java.util.Date values\n-                return (Date) orig;\n-            }\n+                    @Override\n+                    public Long toType(Config config, Date orig, Schema fieldSchema) {\n+                        return Timestamp.fromLogical(Timestamp.SCHEMA, orig);\n+                    }\n+                });\n+\n+        TRANSLATORS.put(\n+                TYPE_DATE,\n+                new TimestampTranslator() {\n+                    @Override\n+                    public Date toRaw(Config config, Object orig) {\n+                        if (orig instanceof Date) return (Date) orig;\n+                        if (orig instanceof Integer) {\n+                            LocalDate localDate =\n+                                    LocalDate.ofEpochDay(Long.parseLong(orig.toString()));\n+                            return Date.from(localDate.atStartOfDay(ZoneOffset.UTC).toInstant());\n+                        } else {\n+                            throw new DataException(\n+                                    \"Expected Date to be a java.util.Date, but found \"\n+                                            + orig.getClass());\n+                        }\n+                    }\n \n-            @Override\n-            public Schema typeSchema(boolean isOptional) {\n-                return isOptional ? OPTIONAL_DATE_SCHEMA : org.apache.kafka.connect.data.Date.SCHEMA;\n-            }\n+                    @Override\n+                    public Schema typeSchema(boolean isOptional) {\n+                        return isOptional\n+                                ? OPTIONAL_DATE_SCHEMA\n+                                : org.apache.kafka.connect.data.Date.SCHEMA;\n+                    }\n \n-            @Override\n-            public Date toType(Config config, Date orig) {\n-                Calendar result = Calendar.getInstance(UTC);\n-                result.setTime(orig);\n-                result.set(Calendar.HOUR_OF_DAY, 0);\n-                result.set(Calendar.MINUTE, 0);\n-                result.set(Calendar.SECOND, 0);\n-                result.set(Calendar.MILLISECOND, 0);\n-                return result.getTime();\n-            }\n-        });\n-\n-        TRANSLATORS.put(TYPE_TIME, new TimestampTranslator() {\n-            @Override\n-            public Date toRaw(Config config, Object orig) {\n-                if (!(orig instanceof Date))\n-                    throw new DataException(\"Expected Time to be a java.util.Date, but found \" + orig.getClass());\n-                // Already represented as a java.util.Date and Connect Times are a subset of valid java.util.Date values\n-                return (Date) orig;\n-            }\n+                    @Override\n+                    public Date toType(Config config, Date orig, Schema fieldSchema) {\n+                        Calendar result = Calendar.getInstance(UTC);\n+                        result.setTime(orig);\n+                        result.set(Calendar.HOUR_OF_DAY, 0);\n+                        result.set(Calendar.MINUTE, 0);\n+                        result.set(Calendar.SECOND, 0);\n+                        result.set(Calendar.MILLISECOND, 0);\n+                        return result.getTime();\n+                    }\n+                });\n+\n+        TRANSLATORS.put(\n+                TYPE_TIME,\n+                new TimestampTranslator() {\n+                    @Override\n+                    public Date toRaw(Config config, Object orig) {\n+                        if (!(orig instanceof Date))\n+                            throw new DataException(\n+                                    \"Expected Time to be a java.util.Date, but found \"\n+                                            + orig.getClass());\n+                        // Already represented as a java.util.Date and Connect Times are a subset of\n+                        // valid java.util.Date values\n+                        return (Date) orig;\n+                    }\n \n-            @Override\n-            public Schema typeSchema(boolean isOptional) {\n-                return isOptional ? OPTIONAL_TIME_SCHEMA : Time.SCHEMA;\n-            }\n+                    @Override\n+                    public Schema typeSchema(boolean isOptional) {\n+                        return isOptional ? OPTIONAL_TIME_SCHEMA : Time.SCHEMA;\n+                    }\n \n-            @Override\n-            public Date toType(Config config, Date orig) {\n-                Calendar origCalendar = Calendar.getInstance(UTC);\n-                origCalendar.setTime(orig);\n-                Calendar result = Calendar.getInstance(UTC);\n-                result.setTimeInMillis(0L);\n-                result.set(Calendar.HOUR_OF_DAY, origCalendar.get(Calendar.HOUR_OF_DAY));\n-                result.set(Calendar.MINUTE, origCalendar.get(Calendar.MINUTE));\n-                result.set(Calendar.SECOND, origCalendar.get(Calendar.SECOND));\n-                result.set(Calendar.MILLISECOND, origCalendar.get(Calendar.MILLISECOND));\n-                return result.getTime();\n-            }\n-        });\n-\n-        TRANSLATORS.put(TYPE_TIMESTAMP, new TimestampTranslator() {\n-            @Override\n-            public Date toRaw(Config config, Object orig) {\n-                if (!(orig instanceof Date))\n-                    throw new DataException(\"Expected Timestamp to be a java.util.Date, but found \" + orig.getClass());\n-                return (Date) orig;\n-            }\n+                    @Override\n+                    public Date toType(Config config, Date orig, Schema fieldSchema) {\n+                        Calendar origCalendar = Calendar.getInstance(UTC);\n+                        origCalendar.setTime(orig);\n+                        Calendar result = Calendar.getInstance(UTC);\n+                        result.setTimeInMillis(0L);\n+                        result.set(Calendar.HOUR_OF_DAY, origCalendar.get(Calendar.HOUR_OF_DAY));\n+                        result.set(Calendar.MINUTE, origCalendar.get(Calendar.MINUTE));\n+                        result.set(Calendar.SECOND, origCalendar.get(Calendar.SECOND));\n+                        result.set(Calendar.MILLISECOND, origCalendar.get(Calendar.MILLISECOND));\n+                        return result.getTime();\n+                    }\n+                });\n+\n+        TRANSLATORS.put(\n+                TYPE_TIMESTAMP,\n+                new TimestampTranslator() {\n+                    @Override\n+                    public Date toRaw(Config config, Object orig) {\n+                        if (!(orig instanceof Date))\n+                            throw new DataException(\n+                                    \"Expected Timestamp to be a java.util.Date, but found \"\n+                                            + orig.getClass());\n+                        return (Date) orig;\n+                    }\n \n-            @Override\n-            public Schema typeSchema(boolean isOptional) {\n-                return isOptional ? OPTIONAL_TIMESTAMP_SCHEMA : Timestamp.SCHEMA;\n-            }\n+                    @Override\n+                    public Schema typeSchema(boolean isOptional) {\n+                        return isOptional ? OPTIONAL_TIMESTAMP_SCHEMA : Timestamp.SCHEMA;\n+                    }\n \n-            @Override\n-            public Date toType(Config config, Date orig) {\n-                return orig;\n-            }\n-        });\n+                    @Override\n+                    public Date toType(Config config, Date orig, Schema fieldSchema) {\n+                        return orig;\n+                    }\n+                });\n     }\n \n-    // This is a bit unusual, but allows the transformation config to be passed to static anonymous classes to customize\n+    // This is a bit unusual, but allows the transformation config to be passed to static anonymous\n+    // classes to customize\n     // their behavior\n     private static class Config {\n-        Config(String field, String type, SimpleDateFormat format) {\n+        Config(\n+                String field,\n+                String type,\n+                SimpleDateFormat formatTimestamp,\n+                SimpleDateFormat formatDate) {\n             this.field = field;\n             this.type = type;\n-            this.format = format;\n+            this.formatTimestamp = formatTimestamp;\n+            this.formatDate = formatDate;\n         }\n+\n         String field;\n         String type;\n-        SimpleDateFormat format;\n+        SimpleDateFormat formatTimestamp;\n+        SimpleDateFormat formatDate;\n     }\n+\n     private Config config;\n     private Cache<Schema, Schema> schemaUpdateCache;\n \n-\n     @Override\n     public void configure(Map<String, ?> configs) {\n         final SimpleConfig simpleConfig = new SimpleConfig(CONFIG_DEF, configs);\n         final String field = simpleConfig.getString(FIELD_CONFIG);\n         final String type = simpleConfig.getString(TARGET_TYPE_CONFIG);\n-        String formatPattern = simpleConfig.getString(FORMAT_CONFIG);\n+        String formatTimestampPattern =\n+                simpleConfig.getString(FORMAT_TIMESTAMP_CONFIG) != null\n+                        ? simpleConfig.getString(FORMAT_TIMESTAMP_CONFIG)\n+                        : FORMAT_TIMESTAMP_DEFAULT;\n+        String formatDatePattern =\n+                simpleConfig.getString(FORMAT_DATE_CONFIG) != null\n+                        ? simpleConfig.getString(FORMAT_DATE_CONFIG)\n+                        : FORMAT_DATE_DEFAULT;\n         schemaUpdateCache = new SynchronizedCache<>(new LRUCache<>(16));\n \n         if (!VALID_TYPES.contains(type)) {\n-            throw new ConfigException(\"Unknown timestamp type in TimestampConverter: \" + type + \". Valid values are \"\n-                    + Utils.join(VALID_TYPES, \", \") + \".\");\n+            throw new ConfigException(\n+                    \"Unknown timestamp type in TimestampConverter: \"\n+                            + type\n+                            + \". Valid values are \"\n+                            + Utils.join(VALID_TYPES, \", \")\n+                            + \".\");\n         }\n-        if (type.equals(TYPE_STRING) && Utils.isBlank(formatPattern)) {\n-            throw new ConfigException(\"TimestampConverter requires format option to be specified when using string timestamps\");\n-        }\n-        SimpleDateFormat format = null;\n-        if (!Utils.isBlank(formatPattern)) {\n-            try {\n-                format = new SimpleDateFormat(formatPattern);\n-                format.setTimeZone(UTC);\n-            } catch (IllegalArgumentException e) {\n-                throw new ConfigException(\"TimestampConverter requires a SimpleDateFormat-compatible pattern for string timestamps: \"\n-                        + formatPattern, e);\n-            }\n+\n+        SimpleDateFormat formatTimestamp = null;\n+        SimpleDateFormat formatDate = null;\n+        try {\n+            formatTimestamp = new SimpleDateFormat(formatTimestampPattern);\n+            formatTimestamp.setTimeZone(UTC);\n+            formatDate = new SimpleDateFormat(formatDatePattern);\n+            formatDate.setTimeZone(UTC);\n+        } catch (IllegalArgumentException e) {\n+            throw new ConfigException(\n+                    \"TimestampConverter requires a SimpleDateFormat-compatible pattern for string timestamps: \"\n+                            + formatTimestampPattern\n+                            + \" or date: \"\n+                            + formatDatePattern,\n+                    e);\n         }\n-        config = new Config(field, type, format);\n+        config = new Config(field, type, formatTimestamp, formatDate);\n     }\n \n     @Override\n@@ -286,8 +375,7 @@ public ConfigDef config() {\n     }\n \n     @Override\n-    public void close() {\n-    }\n+    public void close() {}\n \n     public static class Key<R extends ConnectRecord<R>> extends TimestampConverter<R> {\n         @Override\n@@ -302,7 +390,14 @@ protected Object operatingValue(R record) {\n \n         @Override\n         protected R newRecord(R record, Schema updatedSchema, Object updatedValue) {\n-            return record.newRecord(record.topic(), record.kafkaPartition(), updatedSchema, updatedValue, record.valueSchema(), record.value(), record.timestamp());\n+            return record.newRecord(\n+                    record.topic(),\n+                    record.kafkaPartition(),\n+                    updatedSchema,\n+                    updatedValue,\n+                    record.valueSchema(),\n+                    record.value(),\n+                    record.timestamp());\n         }\n     }\n \n@@ -319,7 +414,14 @@ protected Object operatingValue(R record) {\n \n         @Override\n         protected R newRecord(R record, Schema updatedSchema, Object updatedValue) {\n-            return record.newRecord(record.topic(), record.kafkaPartition(), record.keySchema(), record.key(), updatedSchema, updatedValue, record.timestamp());\n+            return record.newRecord(\n+                    record.topic(),\n+                    record.kafkaPartition(),\n+                    record.keySchema(),\n+                    record.key(),\n+                    updatedSchema,\n+                    updatedValue,\n+                    record.timestamp());\n         }\n     }\n \n@@ -332,36 +434,50 @@ protected R newRecord(R record, Schema updatedSchema, Object updatedValue) {\n     private R applyWithSchema(R record) {\n         final Schema schema = operatingSchema(record);\n         if (config.field.isEmpty()) {\n-            Object value = operatingValue(record);\n-            // New schema is determined by the requested target timestamp type\n-            Schema updatedSchema = TRANSLATORS.get(config.type).typeSchema(schema.isOptional());\n-            return newRecord(record, updatedSchema, convertTimestamp(value, timestampTypeFromSchema(schema)));\n+            Object obj = operatingValue(record);\n+            if (obj instanceof Struct) {\n+                return buildRecordWithTimestampFields(record, schema);\n+            } else {\n+                // New schema is determined by the requested target timestamp type\n+                Schema updatedSchema = TRANSLATORS.get(config.type).typeSchema(schema.isOptional());\n+                return newRecord(record, updatedSchema, convertTimestamp(obj, schema));\n+            }\n+\n         } else {\n-            final Struct value = requireStructOrNull(operatingValue(record), PURPOSE);\n-            Schema updatedSchema = schemaUpdateCache.get(schema);\n-            if (updatedSchema == null) {\n-                SchemaBuilder builder = SchemaUtil.copySchemaBasics(schema, SchemaBuilder.struct());\n-                for (Field field : schema.fields()) {\n-                    if (field.name().equals(config.field)) {\n-                        builder.field(field.name(), TRANSLATORS.get(config.type).typeSchema(field.schema().isOptional()));\n-                    } else {\n-                        builder.field(field.name(), field.schema());\n-                    }\n-                }\n-                if (schema.isOptional())\n-                    builder.optional();\n-                if (schema.defaultValue() != null) {\n-                    Struct updatedDefaultValue = applyValueWithSchema((Struct) schema.defaultValue(), builder);\n-                    builder.defaultValue(updatedDefaultValue);\n-                }\n+            return buildRecordWithTimestampFields(record, schema);\n+        }\n+    }\n \n-                updatedSchema = builder.build();\n-                schemaUpdateCache.put(schema, updatedSchema);\n+    private R buildRecordWithTimestampFields(R record, Schema schema) {\n+        final Struct value = requireStructOrNull(operatingValue(record), PURPOSE);\n+        Schema updatedSchema = schemaUpdateCache.get(schema);\n+        if (updatedSchema == null) {\n+            SchemaBuilder builder = SchemaUtil.copySchemaBasics(schema, SchemaBuilder.struct());\n+            for (Field field : schema.fields()) {\n+                if (field.name().equals(config.field)\n+                        || org.apache.kafka.connect.data.Date.LOGICAL_NAME.equals(\n+                        field.schema().name())\n+                        || Timestamp.LOGICAL_NAME.equals(field.schema().name())) {\n+                    builder.field(\n+                            field.name(),\n+                            TRANSLATORS.get(config.type).typeSchema(field.schema().isOptional()));\n+                } else {\n+                    builder.field(field.name(), field.schema());\n+                }\n+            }\n+            if (schema.isOptional()) builder.optional();\n+            if (schema.defaultValue() != null) {\n+                Struct updatedDefaultValue =\n+                        applyValueWithSchema((Struct) schema.defaultValue(), builder);\n+                builder.defaultValue(updatedDefaultValue);\n             }\n \n-            Struct updatedValue = applyValueWithSchema(value, updatedSchema);\n-            return newRecord(record, updatedSchema, updatedValue);\n+            updatedSchema = builder.build();\n+            schemaUpdateCache.put(schema, updatedSchema);\n         }\n+\n+        Struct updatedValue = applyValueWithSchema(value, updatedSchema);\n+        return newRecord(record, updatedSchema, updatedValue);\n     }\n \n     private Struct applyValueWithSchema(Struct value, Schema updatedSchema) {\n@@ -371,8 +487,10 @@ private Struct applyValueWithSchema(Struct value, Schema updatedSchema) {\n         Struct updatedValue = new Struct(updatedSchema);\n         for (Field field : value.schema().fields()) {\n             final Object updatedFieldValue;\n-            if (field.name().equals(config.field)) {\n-                updatedFieldValue = convertTimestamp(value.get(field), timestampTypeFromSchema(field.schema()));\n+            if (field.name().equals(config.field)\n+                    || org.apache.kafka.connect.data.Date.LOGICAL_NAME.equals(field.schema().name())\n+                    || Timestamp.LOGICAL_NAME.equals(field.schema().name())) {\n+                updatedFieldValue = convertTimestamp(value.get(field), field.schema());\n             } else {\n                 updatedFieldValue = value.get(field);\n             }\n@@ -393,10 +511,11 @@ private R applySchemaless(R record) {\n         }\n     }\n \n-    /**\n-     * Determine the type/format of the timestamp based on the schema\n-     */\n+    /** Determine the type/format of the timestamp based on the schema */\n     private String timestampTypeFromSchema(Schema schema) {\n+        if (schema == null) {\n+            return null;\n+        }\n         if (Timestamp.LOGICAL_NAME.equals(schema.name())) {\n             return TYPE_TIMESTAMP;\n         } else if (org.apache.kafka.connect.data.Date.LOGICAL_NAME.equals(schema.name())) {\n@@ -410,14 +529,14 @@ private String timestampTypeFromSchema(Schema schema) {\n             // If not otherwise specified, long == unix time\n             return TYPE_UNIX;\n         }\n-        throw new ConnectException(\"Schema \" + schema + \" does not correspond to a known timestamp type format\");\n+        throw new ConnectException(\n+                \"Schema \" + schema + \" does not correspond to a known timestamp type format\");\n     }\n \n-    /**\n-     * Infer the type/format of the timestamp based on the raw Java type\n-     */\n+    /** Infer the type/format of the timestamp based on the raw Java type */\n     private String inferTimestampType(Object timestamp) {\n-        // Note that we can't infer all types, e.g. Date/Time/Timestamp all have the same runtime representation as a\n+        // Note that we can't infer all types, e.g. Date/Time/Timestamp all have the same runtime\n+        // representation as a\n         // java.util.Date\n         if (timestamp instanceof Date) {\n             return TYPE_TIMESTAMP;\n@@ -426,16 +545,20 @@ private String inferTimestampType(Object timestamp) {\n         } else if (timestamp instanceof String) {\n             return TYPE_STRING;\n         }\n-        throw new DataException(\"TimestampConverter does not support \" + timestamp.getClass() + \" objects as timestamps\");\n+        throw new DataException(\n+                \"TimestampConverter does not support \"\n+                        + timestamp.getClass()\n+                        + \" objects as timestamps\");\n     }\n \n     /**\n      * Convert the given timestamp to the target timestamp format.\n+     *\n      * @param timestamp the input timestamp, may be null\n-     * @param timestampFormat the format of the timestamp, or null if the format should be inferred\n      * @return the converted timestamp\n      */\n-    private Object convertTimestamp(Object timestamp, String timestampFormat) {\n+    private Object convertTimestamp(Object timestamp, Schema fieldSchema) {\n+        String timestampFormat = timestampTypeFromSchema(fieldSchema);\n         if (timestamp == null) {\n             return null;\n         }\n@@ -453,7 +576,7 @@ private Object convertTimestamp(Object timestamp, String timestampFormat) {\n         if (targetTranslator == null) {\n             throw new ConnectException(\"Unsupported timestamp type: \" + config.type);\n         }\n-        return targetTranslator.toType(config, rawTimestamp);\n+        return targetTranslator.toType(config, rawTimestamp, fieldSchema);\n     }\n \n     private Object convertTimestamp(Object timestamp) {"
  },
  {
    "sha": "d0fb5ada746ab84a03d930f5e53f9b18b3aa56b0",
    "filename": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/TimestampConverterTest.java",
    "status": "modified",
    "additions": 227,
    "deletions": 15,
    "changes": 242,
    "blob_url": "https://github.com/apache/kafka/blob/2d741bba5c008308fb9b136b1b430f96d0b0be60/connect/transforms/src/test/java/org/apache/kafka/connect/transforms/TimestampConverterTest.java",
    "raw_url": "https://github.com/apache/kafka/raw/2d741bba5c008308fb9b136b1b430f96d0b0be60/connect/transforms/src/test/java/org/apache/kafka/connect/transforms/TimestampConverterTest.java",
    "contents_url": "https://api.github.com/repos/apache/kafka/contents/connect/transforms/src/test/java/org/apache/kafka/connect/transforms/TimestampConverterTest.java?ref=2d741bba5c008308fb9b136b1b430f96d0b0be60",
    "patch": "@@ -28,6 +28,8 @@\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Test;\n \n+import java.time.LocalDate;\n+import java.time.ZoneOffset;\n import java.util.Calendar;\n import java.util.Collections;\n import java.util.GregorianCalendar;\n@@ -95,17 +97,11 @@ public void testConfigInvalidTargetType() {\n             () -> xformValue.configure(Collections.singletonMap(TimestampConverter.TARGET_TYPE_CONFIG, \"invalid\")));\n     }\n \n-    @Test\n-    public void testConfigMissingFormat() {\n-        assertThrows(ConfigException.class,\n-            () -> xformValue.configure(Collections.singletonMap(TimestampConverter.TARGET_TYPE_CONFIG, \"string\")));\n-    }\n-\n     @Test\n     public void testConfigInvalidFormat() {\n         Map<String, String> config = new HashMap<>();\n         config.put(TimestampConverter.TARGET_TYPE_CONFIG, \"string\");\n-        config.put(TimestampConverter.FORMAT_CONFIG, \"bad-format\");\n+        config.put(TimestampConverter.FORMAT_TIMESTAMP_CONFIG, \"bad-format\");\n         assertThrows(ConfigException.class, () -> xformValue.configure(config));\n     }\n \n@@ -151,7 +147,7 @@ public void testSchemalessTimestampToUnix() {\n     public void testSchemalessTimestampToString() {\n         Map<String, String> config = new HashMap<>();\n         config.put(TimestampConverter.TARGET_TYPE_CONFIG, \"string\");\n-        config.put(TimestampConverter.FORMAT_CONFIG, STRING_DATE_FMT);\n+        config.put(TimestampConverter.FORMAT_TIMESTAMP_CONFIG, STRING_DATE_FMT);\n         xformValue.configure(config);\n         SourceRecord transformed = xformValue.apply(createRecordSchemaless(DATE_PLUS_TIME.getTime()));\n \n@@ -195,7 +191,7 @@ public void testSchemalessUnixToTimestamp() {\n     public void testSchemalessStringToTimestamp() {\n         Map<String, String> config = new HashMap<>();\n         config.put(TimestampConverter.TARGET_TYPE_CONFIG, \"Timestamp\");\n-        config.put(TimestampConverter.FORMAT_CONFIG, STRING_DATE_FMT);\n+        config.put(TimestampConverter.FORMAT_TIMESTAMP_CONFIG, STRING_DATE_FMT);\n         xformValue.configure(config);\n         SourceRecord transformed = xformValue.apply(createRecordSchemaless(DATE_PLUS_TIME_STRING));\n \n@@ -246,7 +242,7 @@ public void testWithSchemaTimestampToUnix() {\n     public void testWithSchemaTimestampToString() {\n         Map<String, String> config = new HashMap<>();\n         config.put(TimestampConverter.TARGET_TYPE_CONFIG, \"string\");\n-        config.put(TimestampConverter.FORMAT_CONFIG, STRING_DATE_FMT);\n+        config.put(TimestampConverter.FORMAT_TIMESTAMP_CONFIG, STRING_DATE_FMT);\n         xformValue.configure(config);\n         SourceRecord transformed = xformValue.apply(createRecordWithSchema(Timestamp.SCHEMA, DATE_PLUS_TIME.getTime()));\n \n@@ -286,7 +282,7 @@ public void testSchemalessNullValueToTime() {\n     private void testSchemalessNullValueConversion(String targetType) {\n         Map<String, String> config = new HashMap<>();\n         config.put(TimestampConverter.TARGET_TYPE_CONFIG, targetType);\n-        config.put(TimestampConverter.FORMAT_CONFIG, STRING_DATE_FMT);\n+        config.put(TimestampConverter.FORMAT_TIMESTAMP_CONFIG, STRING_DATE_FMT);\n         xformValue.configure(config);\n         SourceRecord transformed = xformValue.apply(createRecordSchemaless(null));\n \n@@ -297,7 +293,7 @@ private void testSchemalessNullValueConversion(String targetType) {\n     private void testSchemalessNullFieldConversion(String targetType) {\n         Map<String, String> config = new HashMap<>();\n         config.put(TimestampConverter.TARGET_TYPE_CONFIG, targetType);\n-        config.put(TimestampConverter.FORMAT_CONFIG, STRING_DATE_FMT);\n+        config.put(TimestampConverter.FORMAT_TIMESTAMP_CONFIG, STRING_DATE_FMT);\n         config.put(TimestampConverter.FIELD_CONFIG, \"ts\");\n         xformValue.configure(config);\n         SourceRecord transformed = xformValue.apply(createRecordSchemaless(null));\n@@ -341,7 +337,7 @@ public void testWithSchemaUnixToTimestamp() {\n     public void testWithSchemaStringToTimestamp() {\n         Map<String, String> config = new HashMap<>();\n         config.put(TimestampConverter.TARGET_TYPE_CONFIG, \"Timestamp\");\n-        config.put(TimestampConverter.FORMAT_CONFIG, STRING_DATE_FMT);\n+        config.put(TimestampConverter.FORMAT_TIMESTAMP_CONFIG, STRING_DATE_FMT);\n         xformValue.configure(config);\n         SourceRecord transformed = xformValue.apply(createRecordWithSchema(Schema.STRING_SCHEMA, DATE_PLUS_TIME_STRING));\n \n@@ -444,7 +440,7 @@ public void testWithSchemaNullFieldToString() {\n     private void testWithSchemaNullValueConversion(String targetType, Schema originalSchema, Schema expectedSchema) {\n         Map<String, String> config = new HashMap<>();\n         config.put(TimestampConverter.TARGET_TYPE_CONFIG, targetType);\n-        config.put(TimestampConverter.FORMAT_CONFIG, STRING_DATE_FMT);\n+        config.put(TimestampConverter.FORMAT_TIMESTAMP_CONFIG, STRING_DATE_FMT);\n         xformValue.configure(config);\n         SourceRecord transformed = xformValue.apply(createRecordWithSchema(originalSchema, null));\n \n@@ -455,7 +451,7 @@ private void testWithSchemaNullValueConversion(String targetType, Schema origina\n     private void testWithSchemaNullFieldConversion(String targetType, Schema originalSchema, Schema expectedSchema) {\n         Map<String, String> config = new HashMap<>();\n         config.put(TimestampConverter.TARGET_TYPE_CONFIG, targetType);\n-        config.put(TimestampConverter.FORMAT_CONFIG, STRING_DATE_FMT);\n+        config.put(TimestampConverter.FORMAT_TIMESTAMP_CONFIG, STRING_DATE_FMT);\n         config.put(TimestampConverter.FIELD_CONFIG, \"ts\");\n         xformValue.configure(config);\n         SchemaBuilder structSchema = SchemaBuilder.struct()\n@@ -545,4 +541,220 @@ private SourceRecord createRecordWithSchema(Schema schema, Object value) {\n     private SourceRecord createRecordSchemaless(Object value) {\n         return createRecordWithSchema(null, value);\n     }\n+\n+    private static final Schema ORIGINAL_DATE_TIMESTAMP_SCHEMA =\n+            SchemaBuilder.struct()\n+                    .field(\"connect_date\", Date.SCHEMA)\n+                    .field(\"connect_timestamp\", Timestamp.SCHEMA)\n+                    .field(\"other\", Schema.STRING_SCHEMA)\n+                    .build();\n+\n+    private static final int NUM_OF_DAYS_SINCE_EPOCH = 0;\n+    private static final LocalDate LOCAL_DATE =\n+            LocalDate.ofEpochDay(Long.valueOf(NUM_OF_DAYS_SINCE_EPOCH));\n+    private static final java.util.Date EPOCH_DATE =\n+            java.util.Date.from(LOCAL_DATE.atStartOfDay(ZoneOffset.UTC).toInstant());\n+\n+    @Test\n+    public void testDateAndTimestampConversionWithRecordSchemaTargetString() {\n+        Map<String, String> config = Collections.singletonMap(TimestampConverter.TARGET_TYPE_CONFIG, \"string\");\n+        xformValue.configure(config);\n+        Struct original =\n+                new Struct(ORIGINAL_DATE_TIMESTAMP_SCHEMA)\n+                        .put(\"connect_date\", EPOCH_DATE)\n+                        .put(\"connect_timestamp\", EPOCH_DATE)\n+                        .put(\"other\", \"test\");\n+\n+        Schema expectedSchema =\n+                SchemaBuilder.struct()\n+                        .field(\"connect_date\", Schema.STRING_SCHEMA)\n+                        .field(\"connect_timestamp\", Schema.STRING_SCHEMA)\n+                        .field(\"other\", Schema.STRING_SCHEMA)\n+                        .build();\n+\n+        Struct expectedValue =\n+                new Struct(expectedSchema)\n+                        .put(\"connect_date\", \"1970-01-01\")\n+                        .put(\"connect_timestamp\", \"1970-01-01 00:00:00\")\n+                        .put(\"other\", \"test\");\n+\n+        SourceRecord transformed =\n+                xformValue.apply(createRecordWithSchema(ORIGINAL_DATE_TIMESTAMP_SCHEMA, original));\n+\n+        assertEquals(expectedSchema, transformed.valueSchema());\n+        assertEquals(expectedValue, transformed.value());\n+        assertEquals(\"test\", ((Struct) transformed.value()).get(\"other\"));\n+    }\n+\n+    @Test\n+    public void testDateAndTimestampConversionWithRecordSchemaTargetTimestamp() {\n+        Map<String, String> config = Collections.singletonMap(TimestampConverter.TARGET_TYPE_CONFIG, \"Timestamp\");\n+        xformValue.configure(config);\n+        java.util.Date date =\n+                java.util.Date.from(LOCAL_DATE.atStartOfDay(ZoneOffset.UTC).toInstant());\n+        Struct original =\n+                new Struct(ORIGINAL_DATE_TIMESTAMP_SCHEMA)\n+                        .put(\"connect_date\", EPOCH_DATE)\n+                        .put(\"connect_timestamp\", EPOCH_DATE)\n+                        .put(\"other\", \"test\");\n+\n+        Schema expectedSchema =\n+                SchemaBuilder.struct()\n+                        .field(\"connect_date\", Timestamp.SCHEMA)\n+                        .field(\"connect_timestamp\", Timestamp.SCHEMA)\n+                        .field(\"other\", Schema.STRING_SCHEMA)\n+                        .build();\n+\n+        Struct expectedValue =\n+                new Struct(expectedSchema)\n+                        .put(\"connect_date\", EPOCH_DATE)\n+                        .put(\"connect_timestamp\", EPOCH_DATE)\n+                        .put(\"other\", \"test\");\n+\n+        SourceRecord transformed =\n+                xformValue.apply(createRecordWithSchema(ORIGINAL_DATE_TIMESTAMP_SCHEMA, original));\n+\n+        assertEquals(\n+                expectedSchema.field(\"connect_date\").schema(),\n+                transformed.valueSchema().field(\"connect_date\").schema());\n+        assertEquals(\n+                expectedSchema.field(\"connect_timestamp\").schema(),\n+                transformed.valueSchema().field(\"connect_timestamp\").schema());\n+        assertEquals(\n+                expectedValue.get(\"connect_date\"),\n+                ((Struct) transformed.value()).get(\"connect_date\"));\n+        assertEquals(\n+                expectedValue.get(\"connect_timestamp\"),\n+                ((Struct) transformed.value()).get(\"connect_timestamp\"));\n+        assertEquals(expectedValue.get(\"other\"), ((Struct) transformed.value()).get(\"other\"));\n+    }\n+\n+    @Test\n+    public void testDateAndTimestampConversionWithRecordSchemaTargetTime() {\n+        Map<String, String> config = Collections.singletonMap(TimestampConverter.TARGET_TYPE_CONFIG, \"Time\");\n+        xformValue.configure(config);\n+        java.util.Date date =\n+                java.util.Date.from(LOCAL_DATE.atStartOfDay(ZoneOffset.UTC).toInstant());\n+        Struct original =\n+                new Struct(ORIGINAL_DATE_TIMESTAMP_SCHEMA)\n+                        .put(\"connect_date\", EPOCH_DATE)\n+                        .put(\"connect_timestamp\", EPOCH_DATE)\n+                        .put(\"other\", \"test\");\n+\n+        Schema expectedSchema =\n+                SchemaBuilder.struct()\n+                        .field(\"connect_date\", Time.SCHEMA)\n+                        .field(\"connect_timestamp\", Time.SCHEMA)\n+                        .field(\"other\", Schema.STRING_SCHEMA)\n+                        .build();\n+\n+        Struct expectedValue =\n+                new Struct(expectedSchema)\n+                        .put(\"connect_date\", EPOCH_DATE)\n+                        .put(\"connect_timestamp\", EPOCH_DATE)\n+                        .put(\"other\", \"test\");\n+\n+        SourceRecord transformed =\n+                xformValue.apply(createRecordWithSchema(ORIGINAL_DATE_TIMESTAMP_SCHEMA, original));\n+\n+        assertEquals(\n+                expectedSchema.field(\"connect_date\").schema(),\n+                transformed.valueSchema().field(\"connect_date\").schema());\n+        assertEquals(\n+                expectedSchema.field(\"connect_timestamp\").schema(),\n+                transformed.valueSchema().field(\"connect_timestamp\").schema());\n+        assertEquals(\n+                expectedValue.get(\"connect_date\"),\n+                ((Struct) transformed.value()).get(\"connect_date\"));\n+        assertEquals(\n+                expectedValue.get(\"connect_timestamp\"),\n+                ((Struct) transformed.value()).get(\"connect_timestamp\"));\n+        assertEquals(expectedValue.get(\"other\"), ((Struct) transformed.value()).get(\"other\"));\n+    }\n+\n+    @Test\n+    public void testDateAndTimestampConversionWithRecordSchemaTargetDate() {\n+        Map<String, String> config = Collections.singletonMap(TimestampConverter.TARGET_TYPE_CONFIG, \"Date\");\n+        xformValue.configure(config);\n+        java.util.Date date =\n+                java.util.Date.from(LOCAL_DATE.atStartOfDay(ZoneOffset.UTC).toInstant());\n+        Struct original =\n+                new Struct(ORIGINAL_DATE_TIMESTAMP_SCHEMA)\n+                        .put(\"connect_date\", EPOCH_DATE)\n+                        .put(\"connect_timestamp\", EPOCH_DATE)\n+                        .put(\"other\", \"test\");\n+\n+        Schema expectedSchema =\n+                SchemaBuilder.struct()\n+                        .field(\"connect_date\", Date.SCHEMA)\n+                        .field(\"connect_timestamp\", Date.SCHEMA)\n+                        .field(\"other\", Schema.STRING_SCHEMA)\n+                        .build();\n+\n+        Struct expectedValue =\n+                new Struct(expectedSchema)\n+                        .put(\"connect_date\", EPOCH_DATE)\n+                        .put(\"connect_timestamp\", EPOCH_DATE)\n+                        .put(\"other\", \"test\");\n+\n+        SourceRecord transformed =\n+                xformValue.apply(createRecordWithSchema(ORIGINAL_DATE_TIMESTAMP_SCHEMA, original));\n+\n+        assertEquals(\n+                expectedSchema.field(\"connect_date\").schema(),\n+                transformed.valueSchema().field(\"connect_date\").schema());\n+        assertEquals(\n+                expectedSchema.field(\"connect_timestamp\").schema(),\n+                transformed.valueSchema().field(\"connect_timestamp\").schema());\n+        assertEquals(\n+                expectedValue.get(\"connect_date\"),\n+                ((Struct) transformed.value()).get(\"connect_date\"));\n+        assertEquals(\n+                expectedValue.get(\"connect_timestamp\"),\n+                ((Struct) transformed.value()).get(\"connect_timestamp\"));\n+        assertEquals(expectedValue.get(\"other\"), ((Struct) transformed.value()).get(\"other\"));\n+    }\n+\n+    @Test\n+    public void testDateAndTimestampConversionWithRecordSchemaTargetUnix() {\n+        Map<String, String> config = Collections.singletonMap(TimestampConverter.TARGET_TYPE_CONFIG, \"unix\");\n+        xformValue.configure(config);\n+        java.util.Date date =\n+                java.util.Date.from(LOCAL_DATE.atStartOfDay(ZoneOffset.UTC).toInstant());\n+        Struct original =\n+                new Struct(ORIGINAL_DATE_TIMESTAMP_SCHEMA)\n+                        .put(\"connect_date\", EPOCH_DATE)\n+                        .put(\"connect_timestamp\", EPOCH_DATE)\n+                        .put(\"other\", \"test\");\n+\n+        Schema expectedSchema =\n+                SchemaBuilder.struct()\n+                        .field(\"connect_date\", SchemaBuilder.int64().build())\n+                        .field(\"connect_timestamp\", SchemaBuilder.int64().build())\n+                        .field(\"other\", Schema.STRING_SCHEMA)\n+                        .build();\n+\n+        Struct expectedValue =\n+                new Struct(expectedSchema)\n+                        .put(\"connect_date\", EPOCH_DATE.getTime())\n+                        .put(\"connect_timestamp\", EPOCH_DATE.getTime())\n+                        .put(\"other\", \"test\");\n+\n+        SourceRecord transformed =\n+                xformValue.apply(createRecordWithSchema(ORIGINAL_DATE_TIMESTAMP_SCHEMA, original));\n+\n+        assertEquals(\n+                expectedSchema.field(\"connect_date\").schema(),\n+                transformed.valueSchema().field(\"connect_date\").schema());\n+        assertEquals(\n+                expectedSchema.field(\"connect_timestamp\").schema(),\n+                transformed.valueSchema().field(\"connect_timestamp\").schema());\n+        assertEquals(\n+                expectedValue.get(\"connect_date\"),\n+                ((Struct) transformed.value()).get(\"connect_date\"));\n+        assertEquals(\n+                expectedValue.get(\"connect_timestamp\"),\n+                ((Struct) transformed.value()).get(\"connect_timestamp\"));\n+        assertEquals(expectedValue.get(\"other\"), ((Struct) transformed.value()).get(\"other\"));\n+    }\n }"
  }
]
