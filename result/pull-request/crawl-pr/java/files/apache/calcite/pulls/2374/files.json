[
  {
    "sha": "9efa6e02f2181d00d785cbdd346cf3531f379681",
    "filename": "core/src/main/java/org/apache/calcite/plan/RelOptCluster.java",
    "status": "modified",
    "additions": 1,
    "deletions": 8,
    "changes": 9,
    "blob_url": "https://github.com/apache/calcite/blob/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/plan/RelOptCluster.java",
    "raw_url": "https://github.com/apache/calcite/raw/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/plan/RelOptCluster.java",
    "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/plan/RelOptCluster.java?ref=be46f1c482f1e735f031e06f03e2157687551ab2",
    "patch": "@@ -20,12 +20,10 @@\n import org.apache.calcite.rel.core.CorrelationId;\n import org.apache.calcite.rel.hint.HintStrategyTable;\n import org.apache.calcite.rel.metadata.DefaultRelMetadataProvider;\n-import org.apache.calcite.rel.metadata.JaninoRelMetadataProvider;\n import org.apache.calcite.rel.metadata.MetadataFactory;\n import org.apache.calcite.rel.metadata.MetadataFactoryImpl;\n import org.apache.calcite.rel.metadata.RelMetadataProvider;\n import org.apache.calcite.rel.metadata.RelMetadataQuery;\n-import org.apache.calcite.rel.metadata.RelMetadataQueryBase;\n import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.rex.RexBuilder;\n import org.apache.calcite.rex.RexNode;\n@@ -136,7 +134,7 @@ public RexBuilder getRexBuilder() {\n     return rexBuilder;\n   }\n \n-  public @Nullable RelMetadataProvider getMetadataProvider() {\n+  public RelMetadataProvider getMetadataProvider() {\n     return metadataProvider;\n   }\n \n@@ -151,11 +149,6 @@ public void setMetadataProvider(\n       RelMetadataProvider metadataProvider) {\n     this.metadataProvider = metadataProvider;\n     this.metadataFactory = new MetadataFactoryImpl(metadataProvider);\n-    // Wrap the metadata provider as a JaninoRelMetadataProvider\n-    // and set it to the ThreadLocal,\n-    // JaninoRelMetadataProvider is required by the RelMetadataQuery.\n-    RelMetadataQueryBase.THREAD_PROVIDERS\n-        .set(JaninoRelMetadataProvider.of(metadataProvider));\n   }\n \n   public MetadataFactory getMetadataFactory() {"
  },
  {
    "sha": "b078e1906875169373f7d542997c2b6f72299590",
    "filename": "core/src/main/java/org/apache/calcite/plan/volcano/TopDownRuleDriver.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/calcite/blob/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/plan/volcano/TopDownRuleDriver.java",
    "raw_url": "https://github.com/apache/calcite/raw/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/plan/volcano/TopDownRuleDriver.java",
    "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/plan/volcano/TopDownRuleDriver.java?ref=be46f1c482f1e735f031e06f03e2157687551ab2",
    "patch": "@@ -440,7 +440,7 @@ default boolean onProduce(RelNode node) {\n       input.setExplored();\n       for (RelSubset subset : input.getSet().subsets) {\n         // Clear the LB cache as exploring state has changed.\n-        input.getCluster().getMetadataQuery().clearCache(subset);\n+        input.getCluster().getMetadataQuery().cache.clear(subset);\n       }\n     }\n "
  },
  {
    "sha": "a0c3fb248532567b4646f931e816c2e286cb29bc",
    "filename": "core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/apache/calcite/blob/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java",
    "raw_url": "https://github.com/apache/calcite/raw/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java",
    "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java?ref=be46f1c482f1e735f031e06f03e2157687551ab2",
    "patch": "@@ -1004,10 +1004,10 @@ void propagateCostImprovements(RelNode rel) {\n         subset.bestCost = cost;\n         subset.best = relNode;\n         // since best was changed, cached metadata for this subset should be removed\n-        mq.clearCache(subset);\n+        mq.cache.clear(subset);\n \n         for (RelNode parent : subset.getParents()) {\n-          mq.clearCache(parent);\n+          mq.cache.clear(parent);\n           RelOptCost newCost = getCostOrInfinite(parent, mq);\n           RelOptCost existingCost = propagateRels.get(parent);\n           if (existingCost == null || newCost.isLt(existingCost)) {"
  },
  {
    "sha": "b65577ccebcbe76f5a75aacdd1b49868cd44c780",
    "filename": "core/src/main/java/org/apache/calcite/rel/metadata/JaninoMetadataHandlerProvider.java",
    "status": "added",
    "additions": 53,
    "deletions": 0,
    "changes": 53,
    "blob_url": "https://github.com/apache/calcite/blob/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/JaninoMetadataHandlerProvider.java",
    "raw_url": "https://github.com/apache/calcite/raw/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/JaninoMetadataHandlerProvider.java",
    "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/metadata/JaninoMetadataHandlerProvider.java?ref=be46f1c482f1e735f031e06f03e2157687551ab2",
    "patch": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rel.metadata;\n+\n+import org.apache.calcite.rel.RelNode;\n+\n+import java.lang.reflect.Proxy;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Provides metadata handlers generated via Janino.\n+ */\n+public class JaninoMetadataHandlerProvider implements MetadataHandlerProvider {\n+\n+  public static final JaninoMetadataHandlerProvider INSTANCE = new JaninoMetadataHandlerProvider();\n+\n+  protected JaninoMetadataHandlerProvider() {\n+  }\n+\n+  @Override public <H> H initialHandler(Class<H> handlerClass) {\n+    return handlerClass.cast(\n+        Proxy.newProxyInstance(RelMetadataQuery.class.getClassLoader(),\n+            new Class[] {handlerClass}, (proxy, method, args) -> {\n+              final RelNode r = requireNonNull((RelNode) args[0], \"(RelNode) args[0]\");\n+              throw new NoHandler(r.getClass());\n+            }));\n+  }\n+\n+  @Override public <H extends MetadataHandler<M>, M extends Metadata> H revise(\n+      Class<? extends RelNode> rClass, MetadataDef<M> def,\n+      RelMetadataProvider relMetadataProvider) {\n+    return JaninoRelMetadataProvider.revise(relMetadataProvider, rClass, def);\n+  }\n+\n+  @Override public MetadataCache buildCache() {\n+    return new TableMetadataCache();\n+  }\n+}"
  },
  {
    "sha": "e446585b05cb987ad9526d834d70db0b1fb85b93",
    "filename": "core/src/main/java/org/apache/calcite/rel/metadata/JaninoRelMetadataProvider.java",
    "status": "modified",
    "additions": 20,
    "deletions": 13,
    "changes": 33,
    "blob_url": "https://github.com/apache/calcite/blob/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/JaninoRelMetadataProvider.java",
    "raw_url": "https://github.com/apache/calcite/raw/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/JaninoRelMetadataProvider.java",
    "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/metadata/JaninoRelMetadataProvider.java?ref=be46f1c482f1e735f031e06f03e2157687551ab2",
    "patch": "@@ -50,7 +50,6 @@\n import org.apache.calcite.rel.stream.LogicalChi;\n import org.apache.calcite.rel.stream.LogicalDelta;\n import org.apache.calcite.rex.RexNode;\n-import org.apache.calcite.util.ControlFlowException;\n import org.apache.calcite.util.Pair;\n import org.apache.calcite.util.Util;\n \n@@ -268,7 +267,7 @@ public static JaninoRelMetadataProvider of(RelMetadataProvider provider) {\n       }\n       safeArgList(buff, method.e)\n           .append(\");\\n\")\n-          .append(\"    final Object v = mq.map.get(r, key);\\n\")\n+          .append(\"    final Object v = mq.cache.get(r, key);\\n\")\n           .append(\"    if (v != null) {\\n\")\n           .append(\"      if (v == \")\n           .append(NullSentinel.class.getName())\n@@ -286,7 +285,7 @@ public static JaninoRelMetadataProvider of(RelMetadataProvider provider) {\n           .append(method.e.getReturnType().getName())\n           .append(\") v;\\n\")\n           .append(\"    }\\n\")\n-          .append(\"    mq.map.put(r, key,\")\n+          .append(\"    mq.cache.put(r, key,\")\n           .append(NullSentinel.class.getName())\n           .append(\".ACTIVE);\\n\")\n           .append(\"    try {\\n\")\n@@ -297,14 +296,14 @@ public static JaninoRelMetadataProvider of(RelMetadataProvider provider) {\n           .append(\"_(r, mq\");\n       argList(buff, method.e)\n           .append(\");\\n\")\n-          .append(\"      mq.map.put(r, key, \")\n+          .append(\"      mq.cache.put (r, key, \")\n           .append(NullSentinel.class.getName())\n           .append(\".mask(x));\\n\")\n           .append(\"      return x;\\n\")\n           .append(\"    } catch (\")\n           .append(Exception.class.getName())\n           .append(\" e) {\\n\")\n-          .append(\"      mq.map.row(r).clear();\\n\")\n+          .append(\"      mq.cache.clear(r);\\n\")\n           .append(\"      throw e;\\n\")\n           .append(\"    }\\n\")\n           .append(\"  }\\n\")\n@@ -461,10 +460,10 @@ private static StringBuilder paramList(StringBuilder buff, Method method) {\n     return def.handlerClass.cast(o);\n   }\n \n-  synchronized <M extends Metadata, H extends MetadataHandler<M>> H create(\n-      MetadataDef<M> def) {\n+  static synchronized <M extends Metadata, H extends MetadataHandler<M>> H create(\n+      RelMetadataProvider provider, MetadataDef<M> def) {\n     try {\n-      final Key key = new Key((MetadataDef) def, provider,\n+      final Key key = new Key(def, provider,\n           ImmutableList.copyOf(ALL_RELS));\n       //noinspection unchecked\n       return (H) HANDLERS.get(key);\n@@ -473,13 +472,19 @@ private static StringBuilder paramList(StringBuilder buff, Method method) {\n     }\n   }\n \n+  @Deprecated\n   synchronized <M extends Metadata, H extends MetadataHandler<M>> H revise(\n       Class<? extends RelNode> rClass, MetadataDef<M> def) {\n+    return revise(provider, rClass, def);\n+  }\n+\n+  static synchronized <M extends Metadata, H extends MetadataHandler<M>> H revise(\n+      RelMetadataProvider provider, Class<? extends RelNode> rClass, MetadataDef<M> def) {\n     if (ALL_RELS.add(rClass)) {\n       HANDLERS.invalidateAll();\n     }\n     //noinspection unchecked\n-    return (H) create(def);\n+    return (H) create(provider, def);\n   }\n \n   /** Registers some classes. Does not flush the providers, but next time we\n@@ -506,12 +511,14 @@ public void register(Iterable<Class<? extends RelNode>> classes) {\n \n   /** Exception that indicates there there should be a handler for\n    * this class but there is not. The action is probably to\n-   * re-generate the handler class. */\n-  public static class NoHandler extends ControlFlowException {\n-    public final Class<? extends RelNode> relClass;\n+   * re-generate the handler class.\n+   *\n+   * Please use MetadataHandlerProvider.NoHandler.*/\n+  @Deprecated\n+  public static class NoHandler extends MetadataHandlerProvider.NoHandler {\n \n     public NoHandler(Class<? extends RelNode> relClass) {\n-      this.relClass = relClass;\n+      super(relClass);\n     }\n   }\n "
  },
  {
    "sha": "d9d503f1472be33dd3d9b9709e2a1c3ad1586178",
    "filename": "core/src/main/java/org/apache/calcite/rel/metadata/MetadataCache.java",
    "status": "added",
    "additions": 41,
    "deletions": 0,
    "changes": 41,
    "blob_url": "https://github.com/apache/calcite/blob/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/MetadataCache.java",
    "raw_url": "https://github.com/apache/calcite/raw/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/MetadataCache.java",
    "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/metadata/MetadataCache.java?ref=be46f1c482f1e735f031e06f03e2157687551ab2",
    "patch": "@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rel.metadata;\n+\n+import org.apache.calcite.rel.RelNode;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+import java.util.List;\n+\n+/**\n+ * A cache for Rel Nodes Metadata.  {@link NullSentinel} is used for storing nulls and\n+ * detecting cyclic metadata calls.\n+ */\n+public interface MetadataCache {\n+  /**\n+   * Removes cached metadata values for specified RelNode.\n+   *\n+   * @param rel RelNode whose cached metadata should be removed\n+   * @return true if cache for the provided RelNode was not empty\n+   */\n+  boolean clear(RelNode rel);\n+\n+  @Nullable Object remove(RelNode relNode, List<?> args);\n+  @Nullable Object get(RelNode relNode, List<?> args);\n+  @Nullable Object put(RelNode relNode, List<?> args, Object value);\n+}"
  },
  {
    "sha": "3ec143b7f4a8e38a90a3cd849377387653460604",
    "filename": "core/src/main/java/org/apache/calcite/rel/metadata/MetadataHandlerProvider.java",
    "status": "added",
    "additions": 54,
    "deletions": 0,
    "changes": 54,
    "blob_url": "https://github.com/apache/calcite/blob/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/MetadataHandlerProvider.java",
    "raw_url": "https://github.com/apache/calcite/raw/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/MetadataHandlerProvider.java",
    "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/metadata/MetadataHandlerProvider.java?ref=be46f1c482f1e735f031e06f03e2157687551ab2",
    "patch": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rel.metadata;\n+\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.util.ControlFlowException;\n+\n+/**\n+ * Provides {@link MetadataHandler} call sites and {@link MetadataCache} for\n+ * {@link RelMetadataQuery}. The handlers provided are responsible for\n+ * updating the cache stored in {@link RelMetadataQuery}.\n+ */\n+public interface MetadataHandlerProvider {\n+\n+  <H> H initialHandler(Class<H> handlerClass);\n+\n+  /** Re-generates the handler for a given kind of metadata, adding support for\n+   * {@code class_} if it is not already present.*/\n+  <H extends MetadataHandler<M>, M extends Metadata> H revise(Class<? extends RelNode> rClass,\n+      MetadataDef<M> def, RelMetadataProvider relMetadataProvider);\n+\n+  /**\n+   * Creates a new cache.\n+   *\n+   * @return A new cache for {@link RelMetadataQuery}\n+   */\n+  MetadataCache buildCache();\n+\n+\n+  /** Exception that indicates there there should be a handler for\n+   * this class but there is not. The action is probably to\n+   * re-generate the handler class. */\n+  class NoHandler extends ControlFlowException {\n+    public final Class<? extends RelNode> relClass;\n+\n+    public NoHandler(Class<? extends RelNode> relClass) {\n+      this.relClass = relClass;\n+    }\n+  }\n+}"
  },
  {
    "sha": "16226f2419d0a60eacc861e65d2eef3ce4f8a817",
    "filename": "core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/apache/calcite/blob/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java",
    "raw_url": "https://github.com/apache/calcite/raw/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java",
    "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java?ref=be46f1c482f1e735f031e06f03e2157687551ab2",
    "patch": "@@ -182,7 +182,7 @@ private static RelMetadataProvider reflectiveSource(\n                   }\n                   key1 = FlatLists.copyOf(args2);\n                 }\n-                if (mq.map.put(rel, key1, NullSentinel.INSTANCE) != null) {\n+                if (mq.cache.put(rel, key1, NullSentinel.INSTANCE) != null) {\n                   throw new CyclicMetadataException();\n                 }\n                 try {\n@@ -191,7 +191,7 @@ private static RelMetadataProvider reflectiveSource(\n                     | UndeclaredThrowableException e) {\n                   throw Util.throwAsRuntime(Util.causeOrSelf(e));\n                 } finally {\n-                  mq.map.remove(rel, key1);\n+                  mq.cache.remove(rel, key1);\n                 }\n               });\n       methodsMap.put(key, function);"
  },
  {
    "sha": "cbdf0abbf5bdb644e0d190e8231388ef74af9ab3",
    "filename": "core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/calcite/blob/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java",
    "raw_url": "https://github.com/apache/calcite/raw/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java",
    "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java?ref=be46f1c482f1e735f031e06f03e2157687551ab2",
    "patch": "@@ -999,6 +999,6 @@ private static boolean isNonNegative(@Nullable Double result, boolean fail) {\n    * @return true if cache for the provided RelNode was not empty\n    */\n   public static boolean clearCache(RelNode rel) {\n-    return rel.getCluster().getMetadataQuery().clearCache(rel);\n+    return rel.getCluster().getMetadataQuery().cache.clear(rel);\n   }\n }"
  },
  {
    "sha": "d9faa764e5517b2642d473b97cc923e35792e1e6",
    "filename": "core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java",
    "status": "modified",
    "additions": 145,
    "deletions": 95,
    "changes": 240,
    "blob_url": "https://github.com/apache/calcite/blob/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java",
    "raw_url": "https://github.com/apache/calcite/raw/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java",
    "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java?ref=be46f1c482f1e735f031e06f03e2157687551ab2",
    "patch": "@@ -41,8 +41,6 @@\n \n import static org.apache.calcite.linq4j.Nullness.castNonNull;\n \n-import static java.util.Objects.requireNonNull;\n-\n /**\n  * RelMetadataQuery provides a strongly-typed facade on top of\n  * {@link RelMetadataProvider} for the set of relational expression metadata\n@@ -79,7 +77,8 @@\n  * plugin mechanism.\n  */\n public class RelMetadataQuery extends RelMetadataQueryBase {\n-  private static final RelMetadataQuery EMPTY = new RelMetadataQuery(false);\n+  private static final RelMetadataQuery PROTOTYPE =\n+      new RelMetadataQuery(JaninoMetadataHandlerProvider.INSTANCE);\n \n   private BuiltInMetadata.Collation.Handler collationHandler;\n   private BuiltInMetadata.ColumnOrigin.Handler columnOriginHandler;\n@@ -107,47 +106,69 @@\n   private BuiltInMetadata.LowerBoundCost.Handler lowerBoundCostHandler;\n \n   /**\n-   * Creates the instance with {@link JaninoRelMetadataProvider} instance\n-   * from {@link #THREAD_PROVIDERS} and {@link #EMPTY} as a prototype.\n+   * Creates the instance using the defualt prototype.\n    */\n   protected RelMetadataQuery() {\n-    this(castNonNull(THREAD_PROVIDERS.get()), EMPTY);\n+    this(PROTOTYPE);\n   }\n \n   /** Creates and initializes the instance that will serve as a prototype for\n    * all other instances. */\n-  private RelMetadataQuery(@SuppressWarnings(\"unused\") boolean dummy) {\n-    super(null);\n-    this.collationHandler = initialHandler(BuiltInMetadata.Collation.Handler.class);\n-    this.columnOriginHandler = initialHandler(BuiltInMetadata.ColumnOrigin.Handler.class);\n-    this.expressionLineageHandler = initialHandler(BuiltInMetadata.ExpressionLineage.Handler.class);\n-    this.tableReferencesHandler = initialHandler(BuiltInMetadata.TableReferences.Handler.class);\n-    this.columnUniquenessHandler = initialHandler(BuiltInMetadata.ColumnUniqueness.Handler.class);\n-    this.cumulativeCostHandler = initialHandler(BuiltInMetadata.CumulativeCost.Handler.class);\n-    this.distinctRowCountHandler = initialHandler(BuiltInMetadata.DistinctRowCount.Handler.class);\n-    this.distributionHandler = initialHandler(BuiltInMetadata.Distribution.Handler.class);\n-    this.explainVisibilityHandler = initialHandler(BuiltInMetadata.ExplainVisibility.Handler.class);\n-    this.maxRowCountHandler = initialHandler(BuiltInMetadata.MaxRowCount.Handler.class);\n-    this.minRowCountHandler = initialHandler(BuiltInMetadata.MinRowCount.Handler.class);\n-    this.memoryHandler = initialHandler(BuiltInMetadata.Memory.Handler.class);\n-    this.nonCumulativeCostHandler = initialHandler(BuiltInMetadata.NonCumulativeCost.Handler.class);\n-    this.parallelismHandler = initialHandler(BuiltInMetadata.Parallelism.Handler.class);\n+  protected RelMetadataQuery(MetadataHandlerProvider metadataHandlerProvider) {\n+    super(metadataHandlerProvider);\n+    this.collationHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.Collation.Handler.class);\n+    this.columnOriginHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.ColumnOrigin.Handler.class);\n+    this.expressionLineageHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.ExpressionLineage.Handler.class);\n+    this.tableReferencesHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.TableReferences.Handler.class);\n+    this.columnUniquenessHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.ColumnUniqueness.Handler.class);\n+    this.cumulativeCostHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.CumulativeCost.Handler.class);\n+    this.distinctRowCountHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.DistinctRowCount.Handler.class);\n+    this.distributionHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.Distribution.Handler.class);\n+    this.explainVisibilityHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.ExplainVisibility.Handler.class);\n+    this.maxRowCountHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.MaxRowCount.Handler.class);\n+    this.minRowCountHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.MinRowCount.Handler.class);\n+    this.memoryHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.Memory.Handler.class);\n+    this.nonCumulativeCostHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.NonCumulativeCost.Handler.class);\n+    this.parallelismHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.Parallelism.Handler.class);\n     this.percentageOriginalRowsHandler =\n-        initialHandler(BuiltInMetadata.PercentageOriginalRows.Handler.class);\n-    this.populationSizeHandler = initialHandler(BuiltInMetadata.PopulationSize.Handler.class);\n-    this.predicatesHandler = initialHandler(BuiltInMetadata.Predicates.Handler.class);\n-    this.allPredicatesHandler = initialHandler(BuiltInMetadata.AllPredicates.Handler.class);\n-    this.nodeTypesHandler = initialHandler(BuiltInMetadata.NodeTypes.Handler.class);\n-    this.rowCountHandler = initialHandler(BuiltInMetadata.RowCount.Handler.class);\n-    this.selectivityHandler = initialHandler(BuiltInMetadata.Selectivity.Handler.class);\n-    this.sizeHandler = initialHandler(BuiltInMetadata.Size.Handler.class);\n-    this.uniqueKeysHandler = initialHandler(BuiltInMetadata.UniqueKeys.Handler.class);\n-    this.lowerBoundCostHandler = initialHandler(BuiltInMetadata.LowerBoundCost.Handler.class);\n-  }\n-\n-  private RelMetadataQuery(JaninoRelMetadataProvider metadataProvider,\n-      RelMetadataQuery prototype) {\n-    super(requireNonNull(metadataProvider, \"metadataProvider\"));\n+        metadataHandlerProvider.initialHandler(\n+            BuiltInMetadata.PercentageOriginalRows.Handler.class);\n+    this.populationSizeHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.PopulationSize.Handler.class);\n+    this.predicatesHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.Predicates.Handler.class);\n+    this.allPredicatesHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.AllPredicates.Handler.class);\n+    this.nodeTypesHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.NodeTypes.Handler.class);\n+    this.rowCountHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.RowCount.Handler.class);\n+    this.selectivityHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.Selectivity.Handler.class);\n+    this.sizeHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.Size.Handler.class);\n+    this.uniqueKeysHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.UniqueKeys.Handler.class);\n+    this.lowerBoundCostHandler =\n+        metadataHandlerProvider.initialHandler(BuiltInMetadata.LowerBoundCost.Handler.class);\n+  }\n+\n+  protected RelMetadataQuery(RelMetadataQuery prototype) {\n+    super(prototype.metadataHandlerProvider);\n     this.collationHandler = prototype.collationHandler;\n     this.columnOriginHandler = prototype.columnOriginHandler;\n     this.expressionLineageHandler = prototype.expressionLineageHandler;\n@@ -195,8 +216,9 @@ public static RelMetadataQuery instance() {\n     for (;;) {\n       try {\n         return nodeTypesHandler.getNodeTypes(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n-        nodeTypesHandler = revise(e.relClass, BuiltInMetadata.NodeTypes.DEF);\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n+        nodeTypesHandler = metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.NodeTypes.DEF,\n+            rel.getCluster().getMetadataProvider());\n       } catch (CyclicMetadataException e) {\n         return null;\n       }\n@@ -217,8 +239,9 @@ public static RelMetadataQuery instance() {\n       try {\n         Double result = rowCountHandler.getRowCount(rel, this);\n         return RelMdUtil.validateResult(castNonNull(result));\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n-        rowCountHandler = revise(e.relClass, BuiltInMetadata.RowCount.DEF);\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n+        rowCountHandler = metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.RowCount.DEF,\n+            rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -235,9 +258,10 @@ public static RelMetadataQuery instance() {\n     for (;;) {\n       try {\n         return maxRowCountHandler.getMaxRowCount(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         maxRowCountHandler =\n-            revise(e.relClass, BuiltInMetadata.MaxRowCount.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.MaxRowCount.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -254,9 +278,10 @@ public static RelMetadataQuery instance() {\n     for (;;) {\n       try {\n         return minRowCountHandler.getMinRowCount(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         minRowCountHandler =\n-            revise(e.relClass, BuiltInMetadata.MinRowCount.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.MinRowCount.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -273,9 +298,10 @@ public static RelMetadataQuery instance() {\n     for (;;) {\n       try {\n         return cumulativeCostHandler.getCumulativeCost(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         cumulativeCostHandler =\n-            revise(e.relClass, BuiltInMetadata.CumulativeCost.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.CumulativeCost.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -292,9 +318,10 @@ public static RelMetadataQuery instance() {\n     for (;;) {\n       try {\n         return nonCumulativeCostHandler.getNonCumulativeCost(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         nonCumulativeCostHandler =\n-            revise(e.relClass, BuiltInMetadata.NonCumulativeCost.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.NonCumulativeCost.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -314,9 +341,10 @@ public static RelMetadataQuery instance() {\n         Double result =\n             percentageOriginalRowsHandler.getPercentageOriginalRows(rel, this);\n         return RelMdUtil.validatePercentage(result);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         percentageOriginalRowsHandler =\n-            revise(e.relClass, BuiltInMetadata.PercentageOriginalRows.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.PercentageOriginalRows.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -336,9 +364,10 @@ public static RelMetadataQuery instance() {\n     for (;;) {\n       try {\n         return columnOriginHandler.getColumnOrigins(rel, this, column);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         columnOriginHandler =\n-            revise(e.relClass, BuiltInMetadata.ColumnOrigin.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.ColumnOrigin.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -370,9 +399,10 @@ public static RelMetadataQuery instance() {\n     for (;;) {\n       try {\n         return expressionLineageHandler.getExpressionLineage(rel, this, expression);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         expressionLineageHandler =\n-            revise(e.relClass, BuiltInMetadata.ExpressionLineage.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.ExpressionLineage.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -384,9 +414,10 @@ public static RelMetadataQuery instance() {\n     for (;;) {\n       try {\n         return tableReferencesHandler.getTableReferences(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         tableReferencesHandler =\n-            revise(e.relClass, BuiltInMetadata.TableReferences.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.TableReferences.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -429,9 +460,10 @@ public static RelMetadataQuery instance() {\n       try {\n         Double result = selectivityHandler.getSelectivity(rel, this, predicate);\n         return RelMdUtil.validatePercentage(result);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         selectivityHandler =\n-            revise(e.relClass, BuiltInMetadata.Selectivity.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.Selectivity.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -466,9 +498,10 @@ public static RelMetadataQuery instance() {\n     for (;;) {\n       try {\n         return uniqueKeysHandler.getUniqueKeys(rel, this, ignoreNulls);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         uniqueKeysHandler =\n-            revise(e.relClass, BuiltInMetadata.UniqueKeys.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.UniqueKeys.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -525,9 +558,10 @@ public static RelMetadataQuery instance() {\n       try {\n         return columnUniquenessHandler.areColumnsUnique(rel, this, columns,\n             ignoreNulls);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         columnUniquenessHandler =\n-            revise(e.relClass, BuiltInMetadata.ColumnUniqueness.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.ColumnUniqueness.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -545,8 +579,9 @@ public static RelMetadataQuery instance() {\n     for (;;) {\n       try {\n         return collationHandler.collations(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n-        collationHandler = revise(e.relClass, BuiltInMetadata.Collation.DEF);\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n+        collationHandler = metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.Collation.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -569,9 +604,10 @@ public RelDistribution distribution(RelNode rel) {\n           return RelDistributions.ANY;\n         }\n         return distribution;\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         distributionHandler =\n-            revise(e.relClass, BuiltInMetadata.Distribution.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.Distribution.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -595,9 +631,10 @@ public RelDistribution distribution(RelNode rel) {\n         Double result =\n             populationSizeHandler.getPopulationSize(rel, this, groupKey);\n         return RelMdUtil.validateResult(result);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         populationSizeHandler =\n-            revise(e.relClass, BuiltInMetadata.PopulationSize.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.PopulationSize.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -614,8 +651,9 @@ public RelDistribution distribution(RelNode rel) {\n     for (;;) {\n       try {\n         return sizeHandler.averageRowSize(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n-        sizeHandler = revise(e.relClass, BuiltInMetadata.Size.DEF);\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n+        sizeHandler = metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.Size.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -634,8 +672,9 @@ public RelDistribution distribution(RelNode rel) {\n     for (;;) {\n       try {\n         return sizeHandler.averageColumnSizes(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n-        sizeHandler = revise(e.relClass, BuiltInMetadata.Size.DEF);\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n+        sizeHandler = metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.Size.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -663,9 +702,10 @@ public RelDistribution distribution(RelNode rel) {\n     for (;;) {\n       try {\n         return parallelismHandler.isPhaseTransition(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         parallelismHandler =\n-            revise(e.relClass, BuiltInMetadata.Parallelism.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.Parallelism.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -682,9 +722,10 @@ public RelDistribution distribution(RelNode rel) {\n     for (;;) {\n       try {\n         return parallelismHandler.splitCount(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         parallelismHandler =\n-            revise(e.relClass, BuiltInMetadata.Parallelism.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.Parallelism.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -703,8 +744,9 @@ public RelDistribution distribution(RelNode rel) {\n     for (;;) {\n       try {\n         return memoryHandler.memory(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n-        memoryHandler = revise(e.relClass, BuiltInMetadata.Memory.DEF);\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n+        memoryHandler = metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.Memory.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -723,8 +765,9 @@ public RelDistribution distribution(RelNode rel) {\n     for (;;) {\n       try {\n         return memoryHandler.cumulativeMemoryWithinPhase(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n-        memoryHandler = revise(e.relClass, BuiltInMetadata.Memory.DEF);\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n+        memoryHandler = metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.Memory.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -743,8 +786,9 @@ public RelDistribution distribution(RelNode rel) {\n     for (;;) {\n       try {\n         return memoryHandler.cumulativeMemoryWithinPhaseSplit(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n-        memoryHandler = revise(e.relClass, BuiltInMetadata.Memory.DEF);\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n+        memoryHandler = metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.Memory.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -770,9 +814,10 @@ public RelDistribution distribution(RelNode rel) {\n             distinctRowCountHandler.getDistinctRowCount(rel, this, groupKey,\n                 predicate);\n         return RelMdUtil.validateResult(result);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         distinctRowCountHandler =\n-            revise(e.relClass, BuiltInMetadata.DistinctRowCount.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.DistinctRowCount.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -790,8 +835,9 @@ public RelOptPredicateList getPulledUpPredicates(RelNode rel) {\n       try {\n         RelOptPredicateList result = predicatesHandler.getPredicates(rel, this);\n         return result != null ? result : RelOptPredicateList.EMPTY;\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n-        predicatesHandler = revise(e.relClass, BuiltInMetadata.Predicates.DEF);\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n+        predicatesHandler = metadataHandlerProvider.revise(e.relClass,\n+            BuiltInMetadata.Predicates.DEF, rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -808,8 +854,9 @@ public RelOptPredicateList getPulledUpPredicates(RelNode rel) {\n     for (;;) {\n       try {\n         return allPredicatesHandler.getAllPredicates(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n-        allPredicatesHandler = revise(e.relClass, BuiltInMetadata.AllPredicates.DEF);\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n+        allPredicatesHandler = metadataHandlerProvider.revise(e.relClass,\n+            BuiltInMetadata.AllPredicates.DEF, rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -831,9 +878,10 @@ public Boolean isVisibleInExplain(RelNode rel,\n         Boolean b = explainVisibilityHandler.isVisibleInExplain(rel, this,\n             explainLevel);\n         return b == null || b;\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         explainVisibilityHandler =\n-            revise(e.relClass, BuiltInMetadata.ExplainVisibility.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.ExplainVisibility.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -852,8 +900,9 @@ public Boolean isVisibleInExplain(RelNode rel,\n     for (;;) {\n       try {\n         return distributionHandler.distribution(rel, this);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n-        distributionHandler = revise(e.relClass, BuiltInMetadata.Distribution.DEF);\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n+        distributionHandler = metadataHandlerProvider.revise(e.relClass,\n+            BuiltInMetadata.Distribution.DEF, rel.getCluster().getMetadataProvider());\n       }\n     }\n   }\n@@ -865,9 +914,10 @@ public Boolean isVisibleInExplain(RelNode rel,\n     for (;;) {\n       try {\n         return lowerBoundCostHandler.getLowerBoundCost(rel, this, planner);\n-      } catch (JaninoRelMetadataProvider.NoHandler e) {\n+      } catch (MetadataHandlerProvider.NoHandler e) {\n         lowerBoundCostHandler =\n-            revise(e.relClass, BuiltInMetadata.LowerBoundCost.DEF);\n+            metadataHandlerProvider.revise(e.relClass, BuiltInMetadata.LowerBoundCost.DEF,\n+                rel.getCluster().getMetadataProvider());\n       }\n     }\n   }"
  },
  {
    "sha": "049cf897c98aebf6b4af32f9293f984251b2b9d9",
    "filename": "core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQueryBase.java",
    "status": "modified",
    "additions": 33,
    "deletions": 26,
    "changes": 59,
    "blob_url": "https://github.com/apache/calcite/blob/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQueryBase.java",
    "raw_url": "https://github.com/apache/calcite/raw/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQueryBase.java",
    "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQueryBase.java?ref=be46f1c482f1e735f031e06f03e2157687551ab2",
    "patch": "@@ -18,14 +18,12 @@\n \n import org.apache.calcite.rel.RelNode;\n \n-import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.ImmutableTable;\n import com.google.common.collect.Table;\n \n import org.checkerframework.checker.nullness.qual.Nullable;\n \n-import java.lang.reflect.Proxy;\n import java.util.List;\n-import java.util.Map;\n import java.util.function.Supplier;\n \n import static java.util.Objects.requireNonNull;\n@@ -63,41 +61,55 @@\n  * </ol>\n  */\n public class RelMetadataQueryBase {\n+\n   //~ Instance fields --------------------------------------------------------\n \n   /** Set of active metadata queries, and cache of previous results. */\n-  public final Table<RelNode, List, Object> map = HashBasedTable.create();\n+  @Deprecated // to be removed before 2.0\n+  public final Table<RelNode, List<?>, Object> map;\n+\n+  public final MetadataCache cache;\n \n-  public final @Nullable JaninoRelMetadataProvider metadataProvider;\n+  @Deprecated // to be removed before 2.0\n+  public final @Nullable JaninoRelMetadataProvider metadataProvider = THREAD_PROVIDERS.get();\n \n   //~ Static fields/initializers ---------------------------------------------\n \n+  protected final MetadataHandlerProvider metadataHandlerProvider;\n+\n+  @Deprecated // to be removed before 2.0\n   public static final ThreadLocal<@Nullable JaninoRelMetadataProvider> THREAD_PROVIDERS =\n       new ThreadLocal<>();\n \n-  //~ Constructors -----------------------------------------------------------\n-\n-  protected RelMetadataQueryBase(@Nullable JaninoRelMetadataProvider metadataProvider) {\n-    this.metadataProvider = metadataProvider;\n+  @Deprecated // to be removed before 2.0\n+  protected static <H> H initialHandler(Class<H> handlerClass) {\n+    return JaninoMetadataHandlerProvider.INSTANCE.initialHandler(handlerClass);\n   }\n \n-  protected static <H> H initialHandler(Class<H> handlerClass) {\n-    return handlerClass.cast(\n-        Proxy.newProxyInstance(RelMetadataQuery.class.getClassLoader(),\n-            new Class[] {handlerClass}, (proxy, method, args) -> {\n-              final RelNode r = requireNonNull((RelNode) args[0], \"(RelNode) args[0]\");\n-              throw new JaninoRelMetadataProvider.NoHandler(r.getClass());\n-            }));\n+  //~ Constructors ----------------------------------------------------------\n+\n+  protected RelMetadataQueryBase(MetadataHandlerProvider metadataHandlerProvider) {\n+    this.metadataHandlerProvider = metadataHandlerProvider;\n+    this.cache = metadataHandlerProvider.buildCache();\n+    if (cache instanceof TableMetadataCache) {\n+      map = ((TableMetadataCache) cache).map;\n+    } else {\n+      map = ImmutableTable.of();\n+    }\n   }\n \n   //~ Methods ----------------------------------------------------------------\n \n   /** Re-generates the handler for a given kind of metadata, adding support for\n    * {@code class_} if it is not already present. */\n+  @Deprecated // to be removed before 2.0\n   protected <M extends Metadata, H extends MetadataHandler<M>> H\n-      revise(Class<? extends RelNode> class_, MetadataDef<M> def) {\n-    requireNonNull(metadataProvider, \"metadataProvider\");\n-    return metadataProvider.revise(class_, def);\n+      revise(Class<? extends RelNode> class_,\n+      MetadataDef<M> def,\n+      @Nullable RelMetadataProvider relMetadataProvider) {\n+    return metadataHandlerProvider.revise(\n+        class_, def, requireNonNull(relMetadataProvider, \"relMetadataProvider\")\n+    );\n   }\n \n   /**\n@@ -106,13 +118,8 @@ protected RelMetadataQueryBase(@Nullable JaninoRelMetadataProvider metadataProvi\n    * @param rel RelNode whose cached metadata should be removed\n    * @return true if cache for the provided RelNode was not empty\n    */\n+  @Deprecated // to be removed before 2.0\n   public boolean clearCache(RelNode rel) {\n-    Map<List, Object> row = map.row(rel);\n-    if (row.isEmpty()) {\n-      return false;\n-    }\n-\n-    row.clear();\n-    return true;\n+    return cache.clear(rel);\n   }\n }"
  },
  {
    "sha": "b587d557001619baf4e54d757016af0a72e1d37a",
    "filename": "core/src/main/java/org/apache/calcite/rel/metadata/TableMetadataCache.java",
    "status": "added",
    "additions": 62,
    "deletions": 0,
    "changes": 62,
    "blob_url": "https://github.com/apache/calcite/blob/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/TableMetadataCache.java",
    "raw_url": "https://github.com/apache/calcite/raw/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/main/java/org/apache/calcite/rel/metadata/TableMetadataCache.java",
    "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/main/java/org/apache/calcite/rel/metadata/TableMetadataCache.java?ref=be46f1c482f1e735f031e06f03e2157687551ab2",
    "patch": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rel.metadata;\n+\n+import org.apache.calcite.rel.RelNode;\n+\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Rel Metadata cache back by @see HashBasedTable table.\n+ */\n+public class TableMetadataCache implements MetadataCache {\n+  final Table<RelNode, List<?>, Object> map = HashBasedTable.create();\n+\n+  /**\n+   * Removes cached metadata values for specified RelNode.\n+   *\n+   * @param rel RelNode whose cached metadata should be removed\n+   * @return true if cache for the provided RelNode was not empty\n+   */\n+  @Override public boolean clear(RelNode rel) {\n+    Map<List<?>, Object> row = map.row(rel);\n+    if (row.isEmpty()) {\n+      return false;\n+    }\n+\n+    row.clear();\n+    return true;\n+  }\n+\n+  @Override public @Nullable Object remove(RelNode relNode, List<?> args) {\n+    return map.remove(relNode, args);\n+  }\n+\n+  @Override public @Nullable Object get(RelNode relNode, List<?> args) {\n+    return map.get(relNode, args);\n+  }\n+\n+  @Override public @Nullable Object put(RelNode relNode, List<?> args, Object value) {\n+    return map.put(relNode, args, value);\n+  }\n+}"
  },
  {
    "sha": "93e1dfbed09d6ebfde6b99bc759ed86084f180cc",
    "filename": "core/src/test/java/org/apache/calcite/test/RelMetadataTest.java",
    "status": "modified",
    "additions": 180,
    "deletions": 7,
    "changes": 187,
    "blob_url": "https://github.com/apache/calcite/blob/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/test/java/org/apache/calcite/test/RelMetadataTest.java",
    "raw_url": "https://github.com/apache/calcite/raw/be46f1c482f1e735f031e06f03e2157687551ab2/core/src/test/java/org/apache/calcite/test/RelMetadataTest.java",
    "contents_url": "https://api.github.com/repos/apache/calcite/contents/core/src/test/java/org/apache/calcite/test/RelMetadataTest.java?ref=be46f1c482f1e735f031e06f03e2157687551ab2",
    "patch": "@@ -28,6 +28,7 @@\n import org.apache.calcite.plan.hep.HepPlanner;\n import org.apache.calcite.plan.hep.HepProgram;\n import org.apache.calcite.plan.hep.HepProgramBuilder;\n+import org.apache.calcite.rel.AbstractRelNode;\n import org.apache.calcite.rel.RelCollation;\n import org.apache.calcite.rel.RelCollationTraitDef;\n import org.apache.calcite.rel.RelCollations;\n@@ -67,17 +68,20 @@\n import org.apache.calcite.rel.metadata.CachingRelMetadataProvider;\n import org.apache.calcite.rel.metadata.ChainedRelMetadataProvider;\n import org.apache.calcite.rel.metadata.DefaultRelMetadataProvider;\n-import org.apache.calcite.rel.metadata.JaninoRelMetadataProvider;\n+import org.apache.calcite.rel.metadata.JaninoMetadataHandlerProvider;\n import org.apache.calcite.rel.metadata.Metadata;\n+import org.apache.calcite.rel.metadata.MetadataCache;\n import org.apache.calcite.rel.metadata.MetadataDef;\n import org.apache.calcite.rel.metadata.MetadataHandler;\n+import org.apache.calcite.rel.metadata.MetadataHandlerProvider;\n import org.apache.calcite.rel.metadata.ReflectiveRelMetadataProvider;\n import org.apache.calcite.rel.metadata.RelColumnOrigin;\n import org.apache.calcite.rel.metadata.RelMdCollation;\n import org.apache.calcite.rel.metadata.RelMdColumnUniqueness;\n import org.apache.calcite.rel.metadata.RelMdUtil;\n import org.apache.calcite.rel.metadata.RelMetadataProvider;\n import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rel.metadata.TableMetadataCache;\n import org.apache.calcite.rel.rules.CoreRules;\n import org.apache.calcite.rel.type.RelDataType;\n import org.apache.calcite.rel.type.RelDataTypeFactory;\n@@ -107,6 +111,7 @@\n import org.apache.calcite.util.Holder;\n import org.apache.calcite.util.ImmutableBitSet;\n import org.apache.calcite.util.ImmutableIntList;\n+import org.apache.calcite.util.Pair;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n@@ -136,6 +141,7 @@\n import java.util.Map.Entry;\n import java.util.Set;\n import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.BiFunction;\n import java.util.function.Function;\n \n import static org.apache.calcite.test.Matchers.within;\n@@ -151,6 +157,7 @@\n import static org.hamcrest.CoreMatchers.startsWith;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -924,9 +931,10 @@ private void checkRelSelectivity(\n         rel.getCluster().getMetadataProvider();\n     final RelOptPlanner planner = rel.getCluster().getPlanner();\n     for (int i = 0; i < iterationCount; i++) {\n-      RelMetadataQuery.THREAD_PROVIDERS.set(\n-          JaninoRelMetadataProvider.of(\n-              new CachingRelMetadataProvider(metadataProvider, planner)));\n+      RelOptCluster cluster = rel.getCluster();\n+      cluster.setMetadataProvider(\n+          new CachingRelMetadataProvider(metadataProvider, planner));\n+      cluster.invalidateMetadataQuery();\n       final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n       final Double result = mq.getRowCount(rel);\n       assertThat(result, within(14d, 0.1d));\n@@ -1506,6 +1514,63 @@ public String colType(MyRelMetadataQuery myRelMetadataQuery, RelNode rel, int co\n     assertThat(buf.size(), equalTo(7));\n   }\n \n+  @Test void testSupportLegacyCachingBehaviorViaMetadataQuery() {\n+    final BiFunction<RelNode, List<?>, List<?>> toArgList = (relNode, list) ->\n+        ImmutableList.builder().addAll(list)\n+            .add(relNode.getCluster().getPlanner().getRelMetadataTimestamp(relNode))\n+            .build();\n+    RelMetadataQuery prototype = new CustomMq(new JaninoMetadataHandlerProvider() {\n+      @Override public MetadataCache buildCache() {\n+        return new LegacyInvalidationMetadataCache();\n+      }\n+    });\n+\n+    final List<String> buf = new ArrayList<>();\n+    ColTypeImpl.THREAD_LIST.set(buf);\n+\n+    final String sql = \"select deptno, count(*) from emp where deptno > 10 \"\n+        + \"group by deptno having count(*) = 0\";\n+    final RelRoot root = tester\n+        .withClusterFactory(cluster -> {\n+          cluster.setMetadataQuerySupplier(() -> new CustomMq(prototype));\n+          return cluster;\n+        })\n+        .convertSqlToRel(sql);\n+    final RelNode rel = root.rel;\n+    final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();\n+    ColType.Handler colTypeHandler = JaninoMetadataHandlerProvider.INSTANCE.revise(\n+        RelNode.class, ColType.DEF, ColTypeImpl.SOURCE\n+    );\n+    // Top node is a filter. Its metadata uses getColType(RelNode, int).\n+    assertThat(rel, instanceOf(LogicalFilter.class));\n+\n+    // Next node is an aggregate. Its metadata uses\n+    // getColType(LogicalAggregate, int).\n+    final RelNode input = rel.getInput(0);\n+    assertThat(input, instanceOf(LogicalAggregate.class));\n+\n+    assertThat(colTypeHandler.getColType(input, mq, 0), equalTo(\"DEPTNO-agg\"));\n+    assertThat(buf.size(), equalTo(1));\n+    assertThat(colTypeHandler.getColType(input, mq, 0), equalTo(\"DEPTNO-agg\"));\n+    assertThat(buf.size(), equalTo(1));\n+    assertThat(colTypeHandler.getColType(input, mq, 1), equalTo(\"EXPR$1-agg\"));\n+    assertThat(buf.size(), equalTo(2));\n+    assertThat(colTypeHandler.getColType(input, mq, 1), equalTo(\"EXPR$1-agg\"));\n+    assertThat(buf.size(), equalTo(2));\n+    assertThat(colTypeHandler.getColType(input, mq, 0), equalTo(\"DEPTNO-agg\"));\n+    assertThat(buf.size(), equalTo(2));\n+\n+    // With a different timestamp, a metadata item is re-computed on first call.\n+    final RelOptPlanner planner = rel.getCluster().getPlanner();\n+    long timestamp = planner.getRelMetadataTimestamp(rel);\n+    assertThat(timestamp, equalTo(0L));\n+    ((MockRelOptPlanner) planner).setRelMetadataTimestamp(timestamp + 1);\n+    assertThat(colTypeHandler.getColType(input, mq, 0), equalTo(\"DEPTNO-agg\"));\n+    assertThat(buf.size(), equalTo(3));\n+    assertThat(colTypeHandler.getColType(input, mq, 0), equalTo(\"DEPTNO-agg\"));\n+    assertThat(buf.size(), equalTo(3));\n+  }\n+\n   @Test void testCustomProviderWithRelMetadataQuery() {\n     final List<String> buf = new ArrayList<>();\n     ColTypeImpl.THREAD_LIST.set(buf);\n@@ -3142,6 +3207,113 @@ private void checkNodeTypeCount(String sql, Map<Class<? extends RelNode>, Intege\n     checkNodeTypeCount(sql, expected);\n   }\n \n+  /**\n+   * Custom rel node for testing.\n+   */\n+  static class CustomRel extends AbstractRelNode {\n+    CustomRel(RelOptCluster cluster, RelTraitSet traits) {\n+      super(cluster, traits);\n+    }\n+  }\n+\n+  /**\n+   * Cache for testing supported legacy behavior.\n+   *\n+   * @see MetadataCache that adds @see RelOptPlanner.getRelMetadataTimestamp()\n+   * to the key.\n+   */\n+  static class LegacyInvalidationMetadataCache implements MetadataCache {\n+    private final TableMetadataCache metadataCache = new TableMetadataCache();\n+\n+    @Override public boolean clear(RelNode rel) {\n+      return metadataCache.clear(rel);\n+    }\n+\n+    @Override public @Nullable Object remove(RelNode relNode, List<?> args) {\n+      return metadataCache.remove(relNode, toArgList(relNode, args));\n+    }\n+\n+    @Override public @Nullable Object get(RelNode relNode, List<?> args) {\n+      return metadataCache.get(relNode, toArgList(relNode, args));\n+    }\n+\n+    @Override public @Nullable Object put(RelNode relNode,\n+        List<?> args, Object value) {\n+      return metadataCache.put(relNode, toArgList(relNode, args), value);\n+    }\n+\n+    private List<?> toArgList(RelNode relNode, List<?> args) {\n+      return ImmutableList.builder().addAll(args)\n+          .add(relNode.getCluster().getPlanner().getRelMetadataTimestamp(relNode))\n+          .build();\n+    }\n+  }\n+\n+  /**\n+   * Custom MetadataHandlerProvider for testing.\n+   */\n+  static class CustomMetadataHandlerProvider implements MetadataHandlerProvider {\n+    public static final List<Pair<String, String>>  REGENERATION_CAUSES = new ArrayList<>();\n+\n+    @Override public <H> H initialHandler(Class<H> handlerClass) {\n+      return JaninoMetadataHandlerProvider.INSTANCE.initialHandler(handlerClass);\n+    }\n+\n+    @Override public <H extends MetadataHandler<M>, M extends Metadata> H revise(\n+        Class<? extends RelNode> rClass,\n+        MetadataDef<M> def, RelMetadataProvider relMetadataProvider) {\n+      if (rClass == CustomRel.class) {\n+        REGENERATION_CAUSES.add(\n+            Pair.of(def.metadataClass.getSimpleName(), rClass.getSimpleName()));\n+      }\n+      return JaninoMetadataHandlerProvider.INSTANCE.revise(rClass, def, relMetadataProvider);\n+    }\n+\n+    @Override public MetadataCache buildCache() {\n+      return new TableMetadataCache();\n+    }\n+  }\n+\n+  /**\n+   * Custom Metadata Query for using a different MetadataHandlerProvider.\n+   */\n+  static class CustomMq extends RelMetadataQuery {\n+    CustomMq(MetadataHandlerProvider metadataHandlerProvider) {\n+      super(metadataHandlerProvider);\n+    }\n+\n+    CustomMq(RelMetadataQuery prototype) {\n+      super(prototype);\n+    }\n+  }\n+\n+  @Test void testRegenerateHandler() {\n+    final FrameworkConfig config = RelBuilderTest.config().build();\n+    final RelBuilder builder = RelBuilder.create(config);\n+    final CustomMq prototype = new CustomMq(new CustomMetadataHandlerProvider());\n+    final CustomMq mq = new CustomMq(prototype);\n+\n+    RelNode filter = builder\n+        .scan(\"EMP\")\n+        .filter(builder.call(NONDETERMINISTIC_OP))\n+        .build();\n+\n+    Pair<String, String> cause = Pair.of(\"Size\",\n+        \"CustomRel\");\n+\n+    // get metadata for the first time to make sure handler is generated.\n+    mq.getAverageRowSize(filter);\n+    assertFalse(CustomMetadataHandlerProvider.REGENERATION_CAUSES.contains(cause));\n+\n+    // get metadata for the second time, with a new node type,\n+    // and make sure regeneration happens.\n+    RelNode customRel = new CustomRel(filter.getCluster(), filter.getTraitSet());\n+    mq.getAverageRowSize(customRel);\n+\n+    // make sure a regeneration log is produced\n+    assertTrue(CustomMetadataHandlerProvider.REGENERATION_CAUSES.contains(cause));\n+  }\n+\n   private static final SqlOperator NONDETERMINISTIC_OP = new SqlSpecialOperator(\n           \"NDC\",\n           SqlKind.OTHER_FUNCTION,\n@@ -3339,15 +3511,16 @@ public String getColType(RelNode rel, RelMetadataQuery mq, int column) {\n     private ColType.Handler colTypeHandler;\n \n     MyRelMetadataQuery() {\n-      colTypeHandler = initialHandler(ColType.Handler.class);\n+      colTypeHandler = JaninoMetadataHandlerProvider.INSTANCE.initialHandler(ColType.Handler.class);\n     }\n \n     public String colType(RelNode rel, int column) {\n       for (;;) {\n         try {\n           return colTypeHandler.getColType(rel, this, column);\n-        } catch (JaninoRelMetadataProvider.NoHandler e) {\n-          colTypeHandler = revise(e.relClass, ColType.DEF);\n+        } catch (MetadataHandlerProvider.NoHandler e) {\n+          colTypeHandler = metadataHandlerProvider.revise(e.relClass, ColType.DEF,\n+              rel.getCluster().getMetadataProvider());\n         }\n       }\n     }"
  }
]
