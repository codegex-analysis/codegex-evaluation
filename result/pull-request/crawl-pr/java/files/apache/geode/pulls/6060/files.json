[
  {
    "sha": "d89a20c5aecb689d290d2174256bbb2decf80873",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/EntryEventImpl.java",
    "status": "modified",
    "additions": 0,
    "deletions": 5,
    "changes": 5,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/EntryEventImpl.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/EntryEventImpl.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/EntryEventImpl.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -2997,9 +2997,4 @@ public void changeRegionToBucketsOwner() {\n       setRegion(getRegion().getPartitionedRegion());\n     }\n   }\n-\n-  @Override\n-  public boolean isTransactional() {\n-    return getTransactionId() != null;\n-  }\n }"
  },
  {
    "sha": "b2a64c0714d7e0ef57f73a2c42b06e41a95c0d42",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/FilterProfile.java",
    "status": "modified",
    "additions": 10,
    "deletions": 55,
    "changes": 65,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/FilterProfile.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/FilterProfile.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/FilterProfile.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -15,7 +15,6 @@\n package org.apache.geode.internal.cache;\n \n import static org.apache.geode.internal.cache.LocalRegion.InitializationLevel.ANY_INIT;\n-import static org.apache.geode.util.internal.UncheckedUtils.uncheckedCast;\n \n import java.io.DataInput;\n import java.io.DataOutput;\n@@ -1046,7 +1045,7 @@ private void sendCQProfileOperation(operationType opType, ServerCQ cq) {\n \n   private final CacheProfile localProfile = new CacheProfile(this);\n \n-  final Profile[] localProfileArray = new Profile[] {localProfile};\n+  private final Profile[] localProfileArray = new Profile[] {localProfile};\n \n   /** compute local routing information */\n   public FilterInfo getLocalFilterRouting(CacheEvent event) {\n@@ -1087,6 +1086,7 @@ public FilterRoutingInfo getFilterRoutingInfoPart1(CacheEvent event, Profile[] p\n     // bug #50809 - local routing for transactional ops must be done here\n     // because the event isn't available later and we lose the old value for the entry\n     boolean processLocalProfile = false;\n+\n     CqService cqService = getCqService(event.getRegion());\n     if (cqService.isRunning()) {\n       processLocalProfile =\n@@ -1126,72 +1126,27 @@ public FilterRoutingInfo getFilterRoutingInfoPart1(CacheEvent event, Profile[] p\n    */\n   public FilterRoutingInfo getFilterRoutingInfoPart2(FilterRoutingInfo part1Info,\n       CacheEvent event) {\n-    return getFilterRoutingInfoPart2(part1Info, event, false);\n-  }\n-\n-  public FilterRoutingInfo getFilterRoutingInfoPart2(FilterRoutingInfo part1Info,\n-      CacheEvent event, boolean computeInterestRoutingInfo) {\n     FilterRoutingInfo result = part1Info;\n     if (localProfile.hasCacheServer) {\n       // bug #45520 - CQ events arriving out of order causes result set\n       // inconsistency, so don't compute routings for events in conflict\n       boolean isInConflict =\n           event.getOperation().isEntry() && ((EntryEventImpl) event).isConcurrencyConflict();\n       CqService cqService = getCqService(event.getRegion());\n-      if (!isInConflict && cqService.isRunning() && region != null) {\n+      if (!isInConflict && cqService.isRunning()\n+          && this.region != null /*\n+                                  * && !( this.region.isUsedForPartitionedRegionBucket() || //\n+                                  * partitioned region CQ this.region instanceof PartitionedRegion)\n+                                  */) { // processing is done in part 1\n         if (result == null) {\n           result = new FilterRoutingInfo();\n         }\n         if (logger.isDebugEnabled()) {\n           logger.debug(\"getting local cq matches for {}\", event);\n         }\n-        setLocalCQRoutingInfo(event, result);\n+        fillInCQRoutingInfo(event, true, NO_PROFILES, result);\n       }\n-      result = setLocalInterestRoutingInfo(event, result, computeInterestRoutingInfo);\n-    }\n-    return result;\n-  }\n-\n-  void setLocalCQRoutingInfo(CacheEvent event, FilterRoutingInfo result) {\n-    if (isCQRoutingNeeded(event)) {\n-      fillInCQRoutingInfo(event, true, NO_PROFILES, result);\n-    } else {\n-      result.setLocalFilterInfo(getLocalFilterInfo(event));\n-    }\n-  }\n-\n-  boolean isCQRoutingNeeded(CacheEvent event) {\n-    if (!isTransactionalEvent(event)) {\n-      return true;\n-    }\n-    FilterInfo localFilterInfo = getLocalFilterInfo(event);\n-    return localFilterInfo == null;\n-  }\n-\n-  FilterInfo getLocalFilterInfo(CacheEvent event) {\n-    EntryEventImpl entryEvent = uncheckedCast(event);\n-    return entryEvent.getLocalFilterInfo();\n-  }\n-\n-  boolean isTransactionalEvent(CacheEvent event) {\n-    if (event.getOperation().isEntry()) {\n-      EntryEventImpl entryEvent = uncheckedCast(event);\n-      return entryEvent.isTransactional();\n-    }\n-    return false;\n-  }\n-\n-  FilterRoutingInfo setLocalInterestRoutingInfo(CacheEvent event, FilterRoutingInfo result,\n-      boolean computeInterestRoutingInfo) {\n-    if (!isTransactionalEvent(event)) {\n       result = fillInInterestRoutingInfo(event, localProfileArray, result, Collections.emptySet());\n-    } else {\n-      // For transaction, compute interested clients after transaction is applied to cache.\n-      FilterInfo filterInfo = ((EntryEventImpl) event).getLocalFilterInfo();\n-      if (filterInfo == null || filterInfo.isChangeAppliedToCache() || computeInterestRoutingInfo) {\n-        result =\n-            fillInInterestRoutingInfo(event, localProfileArray, result, Collections.emptySet());\n-      }\n     }\n     return result;\n   }\n@@ -1203,7 +1158,7 @@ FilterRoutingInfo setLocalInterestRoutingInfo(CacheEvent event, FilterRoutingInf\n    * @param peerProfiles the profiles getting this event\n    * @param frInfo the routing table to update\n    */\n-  void fillInCQRoutingInfo(CacheEvent event, boolean processLocalProfile,\n+  private void fillInCQRoutingInfo(CacheEvent event, boolean processLocalProfile,\n       Profile[] peerProfiles, FilterRoutingInfo frInfo) {\n     CqService cqService = getCqService(event.getRegion());\n     if (cqService != null) {\n@@ -1222,7 +1177,7 @@ void fillInCQRoutingInfo(CacheEvent event, boolean processLocalProfile,\n     }\n   }\n \n-  CqService getCqService(Region region) {\n+  private CqService getCqService(Region region) {\n     return ((InternalCache) region.getRegionService()).getCqService();\n   }\n "
  },
  {
    "sha": "8918c3677948bf0c887dd3c1639edf5354492b30",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/FilterRoutingInfo.java",
    "status": "modified",
    "additions": 0,
    "deletions": 15,
    "changes": 15,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/FilterRoutingInfo.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/FilterRoutingInfo.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/FilterRoutingInfo.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -96,10 +96,6 @@ public void setLocalInterestedClients(Set clients, Set clientsInv) {\n     this.hasLocalInterestBeenComputed = true;\n   }\n \n-  public void setLocalFilterInfo(FilterInfo filterInfo) {\n-    localFilterInfo = filterInfo;\n-  }\n-\n   /**\n    * returns true if local interest has been computed\n    */\n@@ -336,9 +332,6 @@ public String toString() {\n     /** To identify where the filter is processed, locally or in remote node */\n     public boolean filterProcessedLocally = false;\n \n-    /** Used to determine when to computed interested clients for transactional events */\n-    private transient boolean changeAppliedToCache = false;\n-\n     /** adds the content from another FilterInfo object. */\n     public void addFilterInfo(FilterInfo other) {\n       if (other.cqs != null) {\n@@ -536,14 +529,6 @@ public String toString() {\n       }\n       return sb.toString();\n     }\n-\n-    public void setChangeAppliedToCache(boolean changeAppliedToCache) {\n-      this.changeAppliedToCache = changeAppliedToCache;\n-    }\n-\n-    public boolean isChangeAppliedToCache() {\n-      return changeAppliedToCache;\n-    }\n   }\n \n }"
  },
  {
    "sha": "a467d404b88e716889cdda6bb6a6fe3d9b85e5f5",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/InternalCacheEvent.java",
    "status": "modified",
    "additions": 0,
    "deletions": 3,
    "changes": 3,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/InternalCacheEvent.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/InternalCacheEvent.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/InternalCacheEvent.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -83,7 +83,4 @@\n    */\n   VersionTag getVersionTag();\n \n-  default boolean isTransactional() {\n-    return false;\n-  }\n }"
  },
  {
    "sha": "3b2d336e9accd60e6b32ab06aa06fd9ad2fe4d36",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/LocalRegion.java",
    "status": "modified",
    "additions": 1,
    "deletions": 12,
    "changes": 13,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/LocalRegion.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/LocalRegion.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/LocalRegion.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -5805,7 +5805,7 @@ void generateLocalFilterRouting(InternalCacheEvent event) {\n     FilterProfile filterProfile = getFilterProfile();\n     FilterInfo routing = event.getLocalFilterInfo();\n \n-    if (filterProfile != null && isGenerateLocalFilterRoutingNeeded(event)) {\n+    if (filterProfile != null && routing == null) {\n       boolean lockForCQ = false;\n       Object regionEntryObject = null;\n \n@@ -5843,17 +5843,6 @@ void generateLocalFilterRouting(InternalCacheEvent event) {\n     }\n   }\n \n-  boolean isGenerateLocalFilterRoutingNeeded(InternalCacheEvent event) {\n-    FilterRoutingInfo.FilterInfo filterInfo = event.getLocalFilterInfo();\n-    if (filterInfo == null) {\n-      return true;\n-    }\n-    if (!event.isTransactional()) {\n-      return false;\n-    }\n-    return filterInfo.isChangeAppliedToCache();\n-  }\n-\n   /**\n    * This notifies all WAN sites about updated timestamp on local site.\n    */"
  },
  {
    "sha": "95c3020a85eb6900a73063bcecda59ac08b8c9ab",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegion.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegion.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegion.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegion.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -7932,7 +7932,7 @@ public void dispatchListenerEvent(EnumListenerEvent op, InternalCacheEvent event\n \n   @Override\n   void generateLocalFilterRouting(InternalCacheEvent event) {\n-    if (isGenerateLocalFilterRoutingNeeded(event)) {\n+    if (event.getLocalFilterInfo() == null) {\n       super.generateLocalFilterRouting(event);\n     }\n   }"
  },
  {
    "sha": "faba988ffae62ffc32ddb842e13ea8a5424fb09b",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionQueryEvaluator.java",
    "status": "modified",
    "additions": 39,
    "deletions": 14,
    "changes": 53,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionQueryEvaluator.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionQueryEvaluator.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegionQueryEvaluator.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -863,22 +863,34 @@ private SelectResults buildSortedResult(CompiledSelect cs, int limit) throws Que\n     }\n \n     final List<Integer> bucketIds = new ArrayList<Integer>();\n-    PartitionedRegionDataStore dataStore = this.pr.getDataStore();\n     final int totalBucketsToQuery = bucketIdsToConsider.size();\n-    if (dataStore != null) {\n-      for (Integer bid : bucketIdsToConsider) {\n-        if (dataStore.isManagingBucket(bid)) {\n-          bucketIds.add(Integer.valueOf(bid));\n+    if (query.isCqQuery()) {\n+      // Execute the query on primary buckets only\n+      Set<Integer> localPrimaryBucketIds = this.pr.getDataStore().getAllLocalPrimaryBucketIds();\n+      if (!localPrimaryBucketIds.isEmpty()) {\n+        for (Integer bid : bucketIdsToConsider) {\n+          if (localPrimaryBucketIds.contains(bid)) {\n+            bucketIds.add(Integer.valueOf(bid));\n+          }\n         }\n       }\n-      if (bucketIds.size() > 0) {\n-        ret.put(pr.getMyId(), new ArrayList(bucketIds));\n-        // All the buckets are hosted locally.\n-        if (bucketIds.size() == totalBucketsToQuery) {\n-          return ret;\n+    } else {\n+      PartitionedRegionDataStore dataStore = this.pr.getDataStore();\n+      if (dataStore != null) {\n+        for (Integer bid : bucketIdsToConsider) {\n+          if (dataStore.isManagingBucket(bid)) {\n+            bucketIds.add(Integer.valueOf(bid));\n+          }\n         }\n       }\n     }\n+    if (bucketIds.size() > 0) {\n+      ret.put(pr.getMyId(), new ArrayList(bucketIds));\n+      // All the buckets are hosted locally.\n+      if (bucketIds.size() == totalBucketsToQuery) {\n+        return ret;\n+      }\n+    }\n \n     final List allNodes = getAllNodes(this.pr.getRegionAdvisor());\n     /*\n@@ -901,10 +913,19 @@ private SelectResults buildSortedResult(CompiledSelect cs, int limit) throws Que\n       final List<Integer> buckets = new ArrayList<Integer>();\n       for (Integer bid : bucketIdsToConsider) {\n         if (!bucketIds.contains(bid)) {\n-          final Set owners = getBucketOwners(bid);\n-          if (owners.contains(nd)) {\n-            buckets.add(bid);\n-            bucketIds.add(bid);\n+          if (query.isCqQuery()) {\n+            // Execute the query on primary buckets only\n+            InternalDistributedMember primary = getPrimaryBucketOwner(bid);\n+            if (primary.equals(nd)) {\n+              buckets.add(bid);\n+              bucketIds.add(bid);\n+            }\n+          } else {\n+            final Set owners = getBucketOwners(bid);\n+            if (owners.contains(nd)) {\n+              buckets.add(bid);\n+              bucketIds.add(bid);\n+            }\n           }\n         }\n       }\n@@ -925,6 +946,10 @@ private SelectResults buildSortedResult(CompiledSelect cs, int limit) throws Que\n     return ret;\n   }\n \n+  private InternalDistributedMember getPrimaryBucketOwner(Integer bid) {\n+    return pr.getBucketPrimary(bid.intValue());\n+  }\n+\n   protected Set<InternalDistributedMember> getBucketOwners(Integer bid) {\n     return pr.getRegionAdvisor().getBucketOwners(bid.intValue());\n   }"
  },
  {
    "sha": "f15ee80dc1fd321ee79dd39e7e65c4a37239e7d8",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/TXCommitMessage.java",
    "status": "modified",
    "additions": 3,
    "deletions": 10,
    "changes": 13,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/TXCommitMessage.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/TXCommitMessage.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/TXCommitMessage.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -727,22 +727,19 @@ public void basicProcessOps() {\n     firePendingCallbacks(pendingCallbacks);\n   }\n \n-  void firePendingCallbacks(List<EntryEventImpl> callbacks) {\n+  private void firePendingCallbacks(List<EntryEventImpl> callbacks) {\n     boolean isConfigError = false;\n     EntryEventImpl lastTransactionEvent = null;\n     try {\n-      lastTransactionEvent = getLastTransactionEvent(callbacks);\n+      lastTransactionEvent =\n+          TXLastEventInTransactionUtils.getLastTransactionEvent(callbacks, dm.getCache());\n     } catch (ServiceConfigurationError ex) {\n       logger.error(ex.getMessage());\n       isConfigError = true;\n     }\n \n     for (EntryEventImpl ee : callbacks) {\n       boolean isLastTransactionEvent = isConfigError || ee.equals(lastTransactionEvent);\n-      FilterRoutingInfo.FilterInfo filterInfo = ee.getLocalFilterInfo();\n-      if (filterInfo != null) {\n-        filterInfo.setChangeAppliedToCache(true);\n-      }\n       try {\n         if (ee.getOperation().isDestroy()) {\n           ee.getRegion().invokeTXCallbacks(EnumListenerEvent.AFTER_DESTROY, ee, true,\n@@ -763,10 +760,6 @@ void firePendingCallbacks(List<EntryEventImpl> callbacks) {\n     }\n   }\n \n-  EntryEventImpl getLastTransactionEvent(List<EntryEventImpl> callbacks) {\n-    return TXLastEventInTransactionUtils.getLastTransactionEvent(callbacks, dm.getCache());\n-  }\n-\n \n   protected void processCacheRuntimeException(CacheRuntimeException problem) {\n     if (problem instanceof RegionDestroyedException) { // catch RegionDestroyedException"
  },
  {
    "sha": "ba795cabbddeecd27c889438e57728caed1f728a",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/TXEntryState.java",
    "status": "modified",
    "additions": 0,
    "deletions": 5,
    "changes": 5,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/TXEntryState.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/TXEntryState.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/TXEntryState.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -1962,11 +1962,6 @@ private int getSortValue() {\n       return TXEntryState.this.getSortValue();\n     }\n \n-    @Override\n-    public boolean isTransactional() {\n-      return true;\n-    }\n-\n     @Override\n     public int compareTo(Object o) {\n       TxEntryEventImpl other = (TxEntryEventImpl) o;"
  },
  {
    "sha": "5a90e49ddf40fb9bf4f8f5e1dfe548dc61f423e6",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/TXState.java",
    "status": "modified",
    "additions": 5,
    "deletions": 13,
    "changes": 18,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/TXState.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/TXState.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/TXState.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -245,19 +245,15 @@ public void firePendingCallbacks() {\n     boolean isConfigError = false;\n     EntryEventImpl lastTransactionEvent = null;\n     try {\n-      lastTransactionEvent = getLastTransactionEvent();\n+      lastTransactionEvent =\n+          TXLastEventInTransactionUtils.getLastTransactionEvent(getPendingCallbacks(), getCache());\n     } catch (ServiceConfigurationError ex) {\n       logger.error(ex.getMessage());\n       isConfigError = true;\n     }\n \n     for (EntryEventImpl ee : getPendingCallbacks()) {\n       boolean isLastTransactionEvent = isConfigError || ee.equals(lastTransactionEvent);\n-      // Change has been applied to cache.\n-      FilterRoutingInfo.FilterInfo filterInfo = ee.getLocalFilterInfo();\n-      if (filterInfo != null) {\n-        filterInfo.setChangeAppliedToCache(true);\n-      }\n       if (ee.getOperation().isDestroy()) {\n         ee.getRegion().invokeTXCallbacks(EnumListenerEvent.AFTER_DESTROY, ee, true,\n             isLastTransactionEvent);\n@@ -274,10 +270,6 @@ public void firePendingCallbacks() {\n     }\n   }\n \n-  EntryEventImpl getLastTransactionEvent() {\n-    return TXLastEventInTransactionUtils.getLastTransactionEvent(getPendingCallbacks(), getCache());\n-  }\n-\n   public void freePendingCallbacks() {\n     for (EntryEventImpl ee : getPendingCallbacks()) {\n       ee.release();\n@@ -514,7 +506,6 @@ public void commit() throws CommitConflictException {\n       List/* <TXEntryStateWithRegionAndKey> */ entries = generateEventOffsets();\n       TXCommitMessage msg = null;\n       try {\n-\n         /*\n          * In order to preserve data consistency, we need to: 1. Modify the cache first\n          * (applyChanges) 2. Ask for advice on who to send to (buildMessage) 3. Send out to other\n@@ -523,8 +514,6 @@ public void commit() throws CommitConflictException {\n          * If this is done out of order, we will have problems with GII, split brain, and HA.\n          */\n \n-        attachFilterProfileInformation(entries);\n-\n         lockTXRegions(regions);\n \n         try {\n@@ -535,6 +524,9 @@ public void commit() throws CommitConflictException {\n             this.internalAfterApplyChanges.run();\n           }\n \n+          // Process filter events for peer servers\n+          attachFilterProfileInformation(entries);\n+\n           // build and send the message\n           msg = buildMessage();\n           this.commitMessage = msg;"
  },
  {
    "sha": "0c2da6698d3e88bd3f9b3fe401b48034dd0effe3",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/TxCallbackEventFactoryImpl.java",
    "status": "modified",
    "additions": 3,
    "deletions": 2,
    "changes": 5,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/TxCallbackEventFactoryImpl.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/TxCallbackEventFactoryImpl.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/TxCallbackEventFactoryImpl.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -55,10 +55,10 @@ public EntryEventImpl createCallbackEvent(final InternalRegion internalRegion,\n     @Retained\n     EntryEventImpl retVal = EntryEventImpl.create(internalRegion, op, key, newValue,\n         aCallbackArgument, txEntryState == null, originator);\n-    // Need to make it a Transactional event so that routing info can be computed correctly.\n-    retVal.setTransactionId(txId);\n     boolean returnedRetVal = false;\n     try {\n+\n+\n       if (bridgeContext != null) {\n         retVal.setContext(bridgeContext);\n       }\n@@ -135,6 +135,7 @@ public EntryEventImpl createCallbackEvent(final InternalRegion internalRegion,\n           retVal.setLocalFilterInfo(fp.getLocalFilterRouting(retVal));\n         }\n       }\n+      retVal.setTransactionId(txId);\n       returnedRetVal = true;\n       return retVal;\n     } finally {"
  },
  {
    "sha": "6075680e54ef813f92df98d1063aaeb14da8a6ad",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/BaseCommand.java",
    "status": "modified",
    "additions": 0,
    "deletions": 1,
    "changes": 1,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/BaseCommand.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/BaseCommand.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/BaseCommand.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -1329,7 +1329,6 @@ private static void handleListPR(final PartitionedRegion region, final List<?> k\n \n   private static void handleKVList(final LocalRegion region, final List<?> keyList,\n       boolean serializeValues, final ServerConnection servConn) throws IOException {\n-\n     if (region instanceof PartitionedRegion) {\n       handleKVKeysPR((PartitionedRegion) region, keyList, serializeValues, servConn);\n       return;"
  },
  {
    "sha": "5fa008323085485f7ed8cddcdb6400414c4af14d",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/CacheClientNotifier.java",
    "status": "modified",
    "additions": 0,
    "deletions": 1,
    "changes": 1,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/CacheClientNotifier.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/CacheClientNotifier.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/CacheClientNotifier.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -894,7 +894,6 @@ static void routeSingleClientMessage(ClientUpdateMessage clientMessage,\n \n   private void singletonRouteClientMessage(Conflatable conflatable,\n       Collection<ClientProxyMembershipID> filterClients) {\n-\n     cache.getCancelCriterion().checkCancelInProgress(null);\n \n     List<CacheClientProxy> deadProxies = null;"
  },
  {
    "sha": "574af24d38c2b53e50bead49f737733277e9765c",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/ClientRegistrationEventQueueManager.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/ClientRegistrationEventQueueManager.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/ClientRegistrationEventQueueManager.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/ClientRegistrationEventQueueManager.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -181,7 +181,7 @@ private void processEventAndDeliverConflatable(final CacheClientProxy cacheClien\n \n         if (filterProfile != null) {\n           FilterRoutingInfo filterRoutingInfo =\n-              filterProfile.getFilterRoutingInfoPart2(null, internalCacheEvent, true);\n+              filterProfile.getFilterRoutingInfoPart2(null, internalCacheEvent);\n \n           if (filterRoutingInfo != null) {\n             FilterRoutingInfo.FilterInfo filterInfo = filterRoutingInfo.getLocalFilterInfo();"
  },
  {
    "sha": "03581012b8a8ad488e3729fd09e24bbb1c871ff3",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/cache/tx/DistTxEntryEvent.java",
    "status": "modified",
    "additions": 0,
    "deletions": 5,
    "changes": 5,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/tx/DistTxEntryEvent.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/main/java/org/apache/geode/internal/cache/tx/DistTxEntryEvent.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/cache/tx/DistTxEntryEvent.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -71,11 +71,6 @@ public int getDSFID() {\n     return DIST_TX_OP;\n   }\n \n-  @Override\n-  public boolean isTransactional() {\n-    return true;\n-  }\n-\n   @Override\n   public void toData(DataOutput out,\n       SerializationContext context) throws IOException {"
  },
  {
    "sha": "781df783ed3e542057f33a229a851e8f4dc6aba4",
    "filename": "geode-core/src/test/java/org/apache/geode/internal/cache/EntryEventImplTest.java",
    "status": "modified",
    "additions": 141,
    "deletions": 57,
    "changes": 198,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/test/java/org/apache/geode/internal/cache/EntryEventImplTest.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/test/java/org/apache/geode/internal/cache/EntryEventImplTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/test/java/org/apache/geode/internal/cache/EntryEventImplTest.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -61,7 +61,12 @@ public void verifyToStringOutputHasRegionName() {\n     doReturn(expectedRegionName).when(region).getFullPath();\n     doReturn(keyInfo).when(region).getKeyInfo(any(), any(), any());\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n+\n \n     // create entry event for the region\n     EntryEventImpl e = createEntryEvent(region, value);\n@@ -102,7 +107,11 @@ public void verifyExportNewValueWithUnserializedStoredObject() {\n   public void verifyExportNewValueWithByteArray() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     byte[] newValue = new byte[] {1, 2, 3};\n     NewValueImporter nvImporter = mock(NewValueImporter.class);\n@@ -117,7 +126,11 @@ public void verifyExportNewValueWithByteArray() {\n   public void verifyExportNewValueWithStringIgnoresNewValueBytes() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     String newValue = \"newValue\";\n     NewValueImporter nvImporter = mock(NewValueImporter.class);\n@@ -135,7 +148,11 @@ public void verifyExportNewValueWithStringIgnoresNewValueBytes() {\n   public void verifyExportNewValueWithByteArrayCachedDeserializable() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     CachedDeserializable newValue = mock(CachedDeserializable.class);\n     byte[] newValueBytes = new byte[] {1, 2, 3};\n@@ -152,7 +169,11 @@ public void verifyExportNewValueWithByteArrayCachedDeserializable() {\n   public void verifyExportNewValueWithStringCachedDeserializable() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     CachedDeserializable newValue = mock(CachedDeserializable.class);\n     Object newValueObj = \"newValueObj\";\n@@ -172,7 +193,11 @@ public void verifyExportNewValueWithStringCachedDeserializable() {\n   public void verifyExportNewValueWithStringCachedDeserializablePrefersNewValueBytes() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     CachedDeserializable newValue = mock(CachedDeserializable.class);\n     Object newValueObj = \"newValueObj\";\n@@ -192,7 +217,11 @@ public void verifyExportNewValueWithStringCachedDeserializablePrefersNewValueByt\n   public void verifyExportNewValueWithStringCachedDeserializablePrefersCachedSerializedNewValue() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     CachedDeserializable newValue = mock(CachedDeserializable.class);\n     Object newValueObj = \"newValueObj\";\n@@ -310,7 +339,11 @@ public void verifyExportOldValueWithUnserializedStoredObject() {\n   public void verifyExportOldValueWithByteArray() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     byte[] oldValue = new byte[] {1, 2, 3};\n     OldValueImporter ovImporter = mock(OldValueImporter.class);\n@@ -326,7 +359,11 @@ public void verifyExportOldValueWithByteArray() {\n   public void verifyExportOldValueWithStringIgnoresOldValueBytes() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     String oldValue = \"oldValue\";\n     OldValueImporter ovImporter = mock(OldValueImporter.class);\n@@ -345,7 +382,11 @@ public void verifyExportOldValueWithStringIgnoresOldValueBytes() {\n   public void verifyExportOldValuePrefersOldValueBytes() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     OldValueImporter ovImporter = mock(OldValueImporter.class);\n     when(ovImporter.prefersOldSerialized()).thenReturn(true);\n@@ -362,7 +403,11 @@ public void verifyExportOldValuePrefersOldValueBytes() {\n   public void verifyExportOldValueWithCacheDeserializableByteArray() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     CachedDeserializable oldValue = mock(CachedDeserializable.class);\n     byte[] oldValueBytes = new byte[] {1, 2, 3};\n@@ -382,7 +427,11 @@ public void verifyExportOldValueWithCacheDeserializableString() {\n     CachedDeserializable oldValue = mock(CachedDeserializable.class);\n     Object oldValueObj = \"oldValueObj\";\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     when(oldValue.getValue()).thenReturn(oldValueObj);\n     OldValueImporter ovImporter = mock(OldValueImporter.class);\n@@ -400,7 +449,11 @@ public void verifyExportOldValueWithCacheDeserializableOk() {\n     CachedDeserializable oldValue = mock(CachedDeserializable.class);\n     Object oldValueObj = \"oldValueObj\";\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     when(oldValue.getValue()).thenReturn(oldValueObj);\n     OldValueImporter ovImporter = mock(OldValueImporter.class);\n@@ -494,7 +547,11 @@ public void verifyExportOldValueWithSerializedStoredObjectAndUnretainedOldRefere\n   public void setOldValueUnforcedWithRemoveTokenChangesOldValueToNull() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     String UNINITIALIZED = \"Uninitialized\";\n@@ -507,7 +564,11 @@ public void setOldValueUnforcedWithRemoveTokenChangesOldValueToNull() {\n   public void setOldValueForcedWithRemoveTokenChangesOldValueToNull() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     String UNINITIALIZED = \"Uninitialized\";\n@@ -520,7 +581,11 @@ public void setOldValueForcedWithRemoveTokenChangesOldValueToNull() {\n   public void setOldValueUnforcedWithInvalidTokenNullsOldValue() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     String UNINITIALIZED = \"Uninitialized\";\n@@ -533,7 +598,11 @@ public void setOldValueUnforcedWithInvalidTokenNullsOldValue() {\n   public void setOldValueForcedWithInvalidTokenNullsOldValue() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     String UNINITIALIZED = \"Uninitialized\";\n@@ -546,7 +615,11 @@ public void setOldValueForcedWithInvalidTokenNullsOldValue() {\n   public void setOldValueUnforcedWithNullChangesOldValueToNull() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     String UNINITIALIZED = \"Uninitialized\";\n@@ -559,7 +632,11 @@ public void setOldValueUnforcedWithNullChangesOldValueToNull() {\n   public void setOldValueForcedWithNullChangesOldValueToNull() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     String UNINITIALIZED = \"Uninitialized\";\n@@ -572,7 +649,11 @@ public void setOldValueForcedWithNullChangesOldValueToNull() {\n   public void setOldValueForcedWithNotAvailableTokenSetsOldValue() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     String UNINITIALIZED = \"Uninitialized\";\n@@ -585,7 +666,11 @@ public void setOldValueForcedWithNotAvailableTokenSetsOldValue() {\n   public void setOldValueUnforcedWithNotAvailableTokenSetsOldValue() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     String UNINITIALIZED = \"Uninitialized\";\n@@ -598,7 +683,11 @@ public void setOldValueUnforcedWithNotAvailableTokenSetsOldValue() {\n   public void setOldUnforcedValueSetsOldValue() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     String UNINITIALIZED = \"Uninitialized\";\n@@ -611,7 +700,11 @@ public void setOldUnforcedValueSetsOldValue() {\n   public void setOldValueForcedSetsOldValue() {\n     LocalRegion region = mock(LocalRegion.class);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     String UNINITIALIZED = \"Uninitialized\";\n@@ -813,7 +906,11 @@ public void testGetEventTimeWithNullVersionTag() {\n     LocalRegion region = mock(LocalRegion.class);\n     when(region.cacheTimeMillis()).thenReturn(timestamp);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     assertThat(e.getEventTime(0l)).isEqualTo(timestamp);\n@@ -825,7 +922,11 @@ public void testGetEventTimeWithVersionTagConcurrencyChecksEnabled() {\n     LocalRegion region = mock(LocalRegion.class);\n     when(region.getConcurrencyChecksEnabled()).thenReturn(true);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     VersionTag tag = VersionTag.create(mock(InternalDistributedMember.class));\n@@ -843,7 +944,11 @@ public void testGetEventTimeWithVersionTagConcurrencyChecksEnabledWithSuggestedT\n     when(region.getConcurrencyChecksEnabled()).thenReturn(true);\n     when(region.cacheTimeMillis()).thenReturn(timestamp);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     VersionTag tag = VersionTag.create(mock(InternalDistributedMember.class));\n@@ -853,22 +958,18 @@ public void testGetEventTimeWithVersionTagConcurrencyChecksEnabledWithSuggestedT\n     assertThat(tag.getVersionTimeStamp()).isEqualTo(timestampPlus2);\n   }\n \n-  private void setupCache(LocalRegion region) {\n-    InternalCache cache = mock(InternalCache.class);\n-    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n-    when(region.getCache()).thenReturn(cache);\n-    when(cache.getDistributedSystem()).thenReturn(ids);\n-    when(ids.getOffHeapStore()).thenReturn(null);\n-  }\n-\n   @Test\n   public void testGetEventTimeWithVersionTagConcurrencyChecksDisabledNoSuggestedTime() {\n     long timestamp = System.currentTimeMillis();\n     LocalRegion region = mock(LocalRegion.class);\n     when(region.getConcurrencyChecksEnabled()).thenReturn(false);\n     when(region.cacheTimeMillis()).thenReturn(timestamp);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     VersionTag tag = VersionTag.create(mock(InternalDistributedMember.class));\n@@ -883,7 +984,11 @@ public void testGetEventTimeWithVersionTagConcurrencyChecksDisabledWithSuggested\n     LocalRegion region = mock(LocalRegion.class);\n     when(region.getConcurrencyChecksEnabled()).thenReturn(false);\n \n-    setupCache(region);\n+    InternalCache cache = mock(InternalCache.class);\n+    InternalDistributedSystem ids = mock(InternalDistributedSystem.class);\n+    when(region.getCache()).thenReturn(cache);\n+    when(cache.getDistributedSystem()).thenReturn(ids);\n+    when(ids.getOffHeapStore()).thenReturn(null);\n \n     EntryEventImpl e = createEntryEvent(region, null);\n     VersionTag tag = VersionTag.create(mock(InternalDistributedMember.class));\n@@ -892,27 +997,6 @@ public void testGetEventTimeWithVersionTagConcurrencyChecksDisabledWithSuggested\n     assertThat(e.getEventTime(timestamp)).isEqualTo(timestamp);\n   }\n \n-  @Test\n-  public void isTransactionalReturnsTrueIfTXIdIsSet() {\n-    LocalRegion region = mock(LocalRegion.class);\n-    setupCache(region);\n-\n-    EntryEventImpl event = createEntryEvent(region, null);\n-    event.setTransactionId(mock(TXId.class));\n-\n-    assertThat(event.isTransactional()).isTrue();\n-  }\n-\n-  @Test\n-  public void isTransactionalReturnsFalseIfTXIdIsNotSet() {\n-    LocalRegion region = mock(LocalRegion.class);\n-    setupCache(region);\n-\n-    EntryEventImpl event = createEntryEvent(region, null);\n-\n-    assertThat(event.isTransactional()).isFalse();\n-  }\n-\n   private static class EntryEventImplWithOldValuesDisabled extends EntryEventImpl {\n     @Override\n     protected boolean areOldValuesEnabled() {"
  },
  {
    "sha": "1dcb743c2e2114fcb9980bdf3407d2d0becd89b6",
    "filename": "geode-core/src/test/java/org/apache/geode/internal/cache/FilterProfileTest.java",
    "status": "removed",
    "additions": 0,
    "deletions": 258,
    "changes": 258,
    "blob_url": "https://github.com/apache/geode/blob/0f400215ebcbd8032d5252dc4561047c4039aa9e/geode-core/src/test/java/org/apache/geode/internal/cache/FilterProfileTest.java",
    "raw_url": "https://github.com/apache/geode/raw/0f400215ebcbd8032d5252dc4561047c4039aa9e/geode-core/src/test/java/org/apache/geode/internal/cache/FilterProfileTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/test/java/org/apache/geode/internal/cache/FilterProfileTest.java?ref=0f400215ebcbd8032d5252dc4561047c4039aa9e",
    "patch": "@@ -1,258 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n- * agreements. See the NOTICE file distributed with this work for additional information regarding\n- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n- * copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package org.apache.geode.internal.cache;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.Mockito.doNothing;\n-import static org.mockito.Mockito.doReturn;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.spy;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n-\n-import java.util.Collections;\n-\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import org.apache.geode.cache.CacheEvent;\n-import org.apache.geode.cache.Operation;\n-import org.apache.geode.cache.query.internal.cq.CqService;\n-\n-public class FilterProfileTest {\n-  private LocalRegion region;\n-  private FilterProfile filterProfile;\n-  private final EntryEventImpl event = mock(EntryEventImpl.class);\n-  private final CqService cqService = mock(CqService.class);\n-  private final FilterRoutingInfo routingInfo = mock(FilterRoutingInfo.class);\n-  private final FilterRoutingInfo.FilterInfo filterInfo = mock(FilterRoutingInfo.FilterInfo.class);\n-\n-  @Before\n-  public void setUp() {\n-    region = mock(LocalRegion.class);\n-    GemFireCacheImpl mockCache = mock(GemFireCacheImpl.class);\n-    when(mockCache.getCacheServers()).thenReturn(Collections.emptyList());\n-    when(region.getGemFireCache()).thenReturn(mockCache);\n-    filterProfile = spy(new FilterProfile(region));\n-    when(cqService.isRunning()).thenReturn(true);\n-    when(event.getOperation()).thenReturn(Operation.CREATE);\n-    when(event.getRegion()).thenReturn(region);\n-  }\n-\n-  @Test\n-  public void getFilterRoutingInfoPart2DoesNotSetRoutingInfoIfNoCacheServer() {\n-    filterProfile.getLocalProfile().hasCacheServer = false;\n-    doReturn(cqService).when(filterProfile).getCqService(region);\n-\n-    assertThat(filterProfile.getFilterRoutingInfoPart2(routingInfo, event)).isEqualTo(routingInfo);\n-\n-    verify(filterProfile, never()).setLocalCQRoutingInfo(event, routingInfo);\n-    verify(filterProfile, never()).setLocalInterestRoutingInfo(event, routingInfo, false);\n-  }\n-\n-  @Test\n-  public void getFilterRoutingInfoPart2SetsLocalCQAndInterestRoutingInfo() {\n-    filterProfile.getLocalProfile().hasCacheServer = true;\n-    doReturn(cqService).when(filterProfile).getCqService(region);\n-\n-    assertThat(filterProfile.getFilterRoutingInfoPart2(routingInfo, event)).isEqualTo(routingInfo);\n-\n-    verify(filterProfile).setLocalCQRoutingInfo(event, routingInfo);\n-    verify(filterProfile).setLocalInterestRoutingInfo(event, routingInfo, false);\n-  }\n-\n-  @Test\n-  public void getFilterRoutingInfoPart2DoesNotSetLocalCQRoutingInfoIfNoRunningCQService() {\n-    when(cqService.isRunning()).thenReturn(false);\n-    filterProfile.getLocalProfile().hasCacheServer = true;\n-    doReturn(cqService).when(filterProfile).getCqService(region);\n-\n-    assertThat(filterProfile.getFilterRoutingInfoPart2(routingInfo, event, true)).isEqualTo(\n-        routingInfo);\n-\n-    verify(filterProfile, never()).setLocalCQRoutingInfo(event, routingInfo);\n-    verify(filterProfile).setLocalInterestRoutingInfo(event, routingInfo, true);\n-  }\n-\n-  @Test\n-  public void getFilterRoutingInfoPart2DoesNotSetLocalCQRoutingInfoForEventInConflict() {\n-    when(event.isConcurrencyConflict()).thenReturn(true);\n-    filterProfile.getLocalProfile().hasCacheServer = true;\n-    doReturn(cqService).when(filterProfile).getCqService(region);\n-\n-    assertThat(filterProfile.getFilterRoutingInfoPart2(routingInfo, event)).isEqualTo(routingInfo);\n-\n-    verify(filterProfile, never()).setLocalCQRoutingInfo(event, routingInfo);\n-    verify(filterProfile).setLocalInterestRoutingInfo(event, routingInfo, false);\n-  }\n-\n-  @Test\n-  public void getFilterRoutingInfoPart2DoesNotSetLocalCQRoutingInfoIfRegionIsNull() {\n-    filterProfile = spy(new FilterProfile());\n-    filterProfile.getLocalProfile().hasCacheServer = true;\n-    LocalRegion eventRegion = mock(LocalRegion.class);\n-    when(event.getRegion()).thenReturn(eventRegion);\n-    doReturn(cqService).when(filterProfile).getCqService(eventRegion);\n-\n-    assertThat(filterProfile.getFilterRoutingInfoPart2(routingInfo, event)).isEqualTo(routingInfo);\n-\n-    verify(filterProfile, never()).setLocalCQRoutingInfo(event, routingInfo);\n-    verify(filterProfile).setLocalInterestRoutingInfo(event, routingInfo, false);\n-  }\n-\n-  @Test\n-  public void isTransactionalEventReturnsFalseIfNotEntryEvent() {\n-    CacheEvent event = mock(CacheEvent.class);\n-    when(event.getOperation()).thenReturn(Operation.REGION_CREATE);\n-\n-    assertThat(filterProfile.isTransactionalEvent(event)).isFalse();\n-  }\n-\n-  @Test\n-  public void isTransactionalEventReturnsTrueIfATransactionalEntryEvent() {\n-    EntryEventImpl event = mock(EntryEventImpl.class);\n-    when(event.getOperation()).thenReturn(Operation.UPDATE);\n-    when(event.isTransactional()).thenReturn(true);\n-\n-    assertThat(filterProfile.isTransactionalEvent(event)).isTrue();\n-  }\n-\n-  @Test\n-  public void isTransactionalEventReturnsFalseIfNotATransactionalEntryEvent() {\n-    EntryEventImpl event = mock(EntryEventImpl.class);\n-    when(event.getOperation()).thenReturn(Operation.UPDATE);\n-    when(event.isTransactional()).thenReturn(false);\n-\n-    assertThat(filterProfile.isTransactionalEvent(event)).isFalse();\n-  }\n-\n-  @Test\n-  public void isCQRoutingNeededReturnsTrueIfEventNotTransactional() {\n-    doReturn(false).when(filterProfile).isTransactionalEvent(event);\n-\n-    assertThat(filterProfile.isCQRoutingNeeded(event)).isTrue();\n-  }\n-\n-  @Test\n-  public void isCQRoutingNeededReturnsTrueIfLocalFilterInfoIsNotSetInEvent() {\n-    doReturn(true).when(filterProfile).isTransactionalEvent(event);\n-    when(event.getLocalFilterInfo()).thenReturn(null);\n-\n-    assertThat(filterProfile.isCQRoutingNeeded(event)).isTrue();\n-  }\n-\n-  @Test\n-  public void isCQRoutingNeededReturnsFalseIfLocalFilterInfoIsSetInEvent() {\n-    doReturn(true).when(filterProfile).isTransactionalEvent(event);\n-    when(event.getLocalFilterInfo()).thenReturn(filterInfo);\n-\n-    assertThat(filterProfile.isCQRoutingNeeded(event)).isFalse();\n-  }\n-\n-  @Test\n-  public void setLocalCQRoutingInfoFillsInCQRoutingInfoIfCQRoutingNeeded() {\n-    doReturn(true).when(filterProfile).isCQRoutingNeeded(event);\n-    FilterRoutingInfo info = mock(FilterRoutingInfo.class);\n-    doNothing().when(filterProfile).fillInCQRoutingInfo(event, true, FilterProfile.NO_PROFILES,\n-        info);\n-\n-    filterProfile.setLocalCQRoutingInfo(event, info);\n-\n-    verify(filterProfile).fillInCQRoutingInfo(event, true, FilterProfile.NO_PROFILES, info);\n-  }\n-\n-  @Test\n-  public void setLocalCQRoutingInfoSetsLocalFilterInfoFromEventIfCQRoutingNotNeeded() {\n-    doReturn(false).when(filterProfile).isCQRoutingNeeded(event);\n-    when(event.getLocalFilterInfo()).thenReturn(filterInfo);\n-\n-\n-    filterProfile.setLocalCQRoutingInfo(event, routingInfo);\n-\n-    verify(routingInfo).setLocalFilterInfo(filterInfo);\n-  }\n-\n-  @Test\n-  public void setLocalInterestRoutingInfoFillsInInterestRoutingInfoIfEventNotTransactional() {\n-    doReturn(false).when(filterProfile).isTransactionalEvent(event);\n-    doReturn(routingInfo).when(filterProfile).fillInInterestRoutingInfo(event,\n-        filterProfile.localProfileArray, routingInfo, Collections.emptySet());\n-\n-    assertThat(filterProfile.setLocalInterestRoutingInfo(event, routingInfo, true))\n-        .isEqualTo(routingInfo);\n-\n-    verify(filterProfile).fillInInterestRoutingInfo(event, filterProfile.localProfileArray,\n-        routingInfo, Collections.emptySet());\n-  }\n-\n-  @Test\n-  public void setLocalInterestRoutingInfoFillsInInterestRoutingInfoIfNoFilterInfoInTransactionalEvent() {\n-    doReturn(true).when(filterProfile).isTransactionalEvent(event);\n-    doReturn(routingInfo).when(filterProfile).fillInInterestRoutingInfo(event,\n-        filterProfile.localProfileArray, routingInfo, Collections.emptySet());\n-\n-    assertThat(filterProfile.setLocalInterestRoutingInfo(event, routingInfo, false))\n-        .isEqualTo(routingInfo);\n-\n-    verify(filterProfile).fillInInterestRoutingInfo(event, filterProfile.localProfileArray,\n-        routingInfo, Collections.emptySet());\n-  }\n-\n-  @Test\n-  public void setLocalInterestRoutingInfoFillsInInterestRoutingInfoIfChangeAppliedToCache() {\n-    doReturn(true).when(filterProfile).isTransactionalEvent(event);\n-    doReturn(routingInfo).when(filterProfile).fillInInterestRoutingInfo(event,\n-        filterProfile.localProfileArray, routingInfo, Collections.emptySet());\n-    when(event.getLocalFilterInfo()).thenReturn(filterInfo);\n-    when(filterInfo.isChangeAppliedToCache()).thenReturn(true);\n-\n-    assertThat(filterProfile.setLocalInterestRoutingInfo(event, routingInfo, false))\n-        .isEqualTo(routingInfo);\n-\n-    verify(filterProfile).fillInInterestRoutingInfo(event, filterProfile.localProfileArray,\n-        routingInfo, Collections.emptySet());\n-  }\n-\n-  @Test\n-  public void setLocalInterestRoutingInfoDoesNotFillInInterestRoutingInfoIfNotAppliedToCacheYet() {\n-    doReturn(true).when(filterProfile).isTransactionalEvent(event);\n-    doReturn(routingInfo).when(filterProfile).fillInInterestRoutingInfo(event,\n-        filterProfile.localProfileArray, routingInfo, Collections.emptySet());\n-    when(event.getLocalFilterInfo()).thenReturn(filterInfo);\n-    when(filterInfo.isChangeAppliedToCache()).thenReturn(false);\n-\n-    assertThat(filterProfile.setLocalInterestRoutingInfo(event, routingInfo, false))\n-        .isEqualTo(routingInfo);\n-\n-    verify(filterProfile, never()).fillInInterestRoutingInfo(event, filterProfile.localProfileArray,\n-        routingInfo, Collections.emptySet());\n-  }\n-\n-  @Test\n-  public void setLocalInterestRoutingInfoFillsInInterestRoutingInfoIfNeededToCompute() {\n-    doReturn(true).when(filterProfile).isTransactionalEvent(event);\n-    doReturn(routingInfo).when(filterProfile).fillInInterestRoutingInfo(event,\n-        filterProfile.localProfileArray, routingInfo, Collections.emptySet());\n-    when(event.getLocalFilterInfo()).thenReturn(filterInfo);\n-    when(filterInfo.isChangeAppliedToCache()).thenReturn(false);\n-\n-    assertThat(filterProfile.setLocalInterestRoutingInfo(event, routingInfo, true))\n-        .isEqualTo(routingInfo);\n-\n-    verify(filterProfile).fillInInterestRoutingInfo(event, filterProfile.localProfileArray,\n-        routingInfo, Collections.emptySet());\n-  }\n-}"
  },
  {
    "sha": "d69556576bffd6b30f40614569111a563efe3c39",
    "filename": "geode-core/src/test/java/org/apache/geode/internal/cache/LocalRegionTest.java",
    "status": "modified",
    "additions": 0,
    "deletions": 80,
    "changes": 80,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/test/java/org/apache/geode/internal/cache/LocalRegionTest.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/test/java/org/apache/geode/internal/cache/LocalRegionTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/test/java/org/apache/geode/internal/cache/LocalRegionTest.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -222,84 +222,4 @@ public void getAllShouldNotThrowExceptionWhenEntryIsLocallyDeletedBetweenFetches\n     assertThat(result.get(\"key1\")).isNull();\n     assertThat(result.get(\"key2\")).isEqualTo(\"value2\");\n   }\n-\n-  @Test\n-  public void generateLocalFilterRoutingIsNeededIfFilterInfoNotSetInEvent() {\n-    LocalRegion region =\n-        spy(new LocalRegion(\"region\", regionAttributes, null, cache, internalRegionArguments,\n-            internalDataView, regionMapConstructor, serverRegionProxyConstructor, entryEventFactory,\n-            poolFinder, regionPerfStatsFactory, disabledClock()));\n-    InternalCacheEvent event = mock(InternalCacheEvent.class);\n-    when(event.getLocalFilterInfo()).thenReturn(null);\n-\n-    assertThat(region.isGenerateLocalFilterRoutingNeeded(event)).isTrue();\n-  }\n-\n-  @Test\n-  public void generateLocalFilterRoutingNotNeededIfNonTransactionalEventHasFilterInfo() {\n-    LocalRegion region =\n-        spy(new LocalRegion(\"region\", regionAttributes, null, cache, internalRegionArguments,\n-            internalDataView, regionMapConstructor, serverRegionProxyConstructor, entryEventFactory,\n-            poolFinder, regionPerfStatsFactory, disabledClock()));\n-    InternalCacheEvent event = mock(InternalCacheEvent.class);\n-    when(event.getLocalFilterInfo()).thenReturn(mock(FilterRoutingInfo.FilterInfo.class));\n-    when(event.isTransactional()).thenReturn(false);\n-\n-    assertThat(region.isGenerateLocalFilterRoutingNeeded(event)).isFalse();\n-  }\n-\n-  @Test\n-  public void generateLocalFilterRoutingIsNeededIfChangeAppliedToCacheForTransactionalEvent() {\n-    LocalRegion region =\n-        spy(new LocalRegion(\"region\", regionAttributes, null, cache, internalRegionArguments,\n-            internalDataView, regionMapConstructor, serverRegionProxyConstructor, entryEventFactory,\n-            poolFinder, regionPerfStatsFactory, disabledClock()));\n-    InternalCacheEvent event = mock(InternalCacheEvent.class);\n-    FilterRoutingInfo.FilterInfo filterInfo = mock(FilterRoutingInfo.FilterInfo.class);\n-    when(event.getLocalFilterInfo()).thenReturn(filterInfo);\n-    when(event.isTransactional()).thenReturn(true);\n-    when(filterInfo.isChangeAppliedToCache()).thenReturn(true);\n-\n-    assertThat(region.isGenerateLocalFilterRoutingNeeded(event)).isTrue();\n-  }\n-\n-  @Test\n-  public void generateLocalFilterRoutingIsNotNeededIfChangeNotAppliedToCacheYet() {\n-    LocalRegion region =\n-        spy(new LocalRegion(\"region\", regionAttributes, null, cache, internalRegionArguments,\n-            internalDataView, regionMapConstructor, serverRegionProxyConstructor, entryEventFactory,\n-            poolFinder, regionPerfStatsFactory, disabledClock()));\n-    InternalCacheEvent event = mock(InternalCacheEvent.class);\n-    FilterRoutingInfo.FilterInfo filterInfo = mock(FilterRoutingInfo.FilterInfo.class);\n-    when(event.getLocalFilterInfo()).thenReturn(filterInfo);\n-    when(event.isTransactional()).thenReturn(true);\n-    when(filterInfo.isChangeAppliedToCache()).thenReturn(false);\n-\n-    assertThat(region.isGenerateLocalFilterRoutingNeeded(event)).isFalse();\n-  }\n-\n-  @Test\n-  public void initializeStatsInvokesDiskRegionStatsMethods() {\n-    LocalRegion region =\n-        spy(new LocalRegion(\"region\", regionAttributes, null, cache, internalRegionArguments,\n-            internalDataView, regionMapConstructor, serverRegionProxyConstructor, entryEventFactory,\n-            poolFinder, regionPerfStatsFactory, disabledClock()));\n-\n-    // Mock DiskRegion and DiskRegionStats\n-    DiskRegion dr = mock(DiskRegion.class);\n-    when(region.getDiskRegion()).thenReturn(dr);\n-    DiskRegionStats drs = mock(DiskRegionStats.class);\n-    when(dr.getStats()).thenReturn(drs);\n-\n-    // Invoke initializeStats\n-    int numEntriesInVM = 100;\n-    long numOverflowOnDisk = 200l;\n-    long numOverflowBytesOnDisk = 300l;\n-    region.initializeStats(numEntriesInVM, numOverflowOnDisk, numOverflowBytesOnDisk);\n-\n-    // Verify the DiskRegionStats methods were invoked\n-    verify(drs).incNumEntriesInVM(numEntriesInVM);\n-    verify(drs).incNumOverflowOnDisk(numOverflowOnDisk);\n-    verify(drs).incNumOverflowBytesOnDisk(numOverflowBytesOnDisk);\n-  }\n }"
  },
  {
    "sha": "b0e6c284e85d671e372a1aa9eea2f4ee0a1ac304",
    "filename": "geode-core/src/test/java/org/apache/geode/internal/cache/TXCommitMessageTest.java",
    "status": "modified",
    "additions": 0,
    "deletions": 23,
    "changes": 23,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/test/java/org/apache/geode/internal/cache/TXCommitMessageTest.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/test/java/org/apache/geode/internal/cache/TXCommitMessageTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/test/java/org/apache/geode/internal/cache/TXCommitMessageTest.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -14,17 +14,14 @@\n  */\n package org.apache.geode.internal.cache;\n \n-import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n import static org.mockito.Mockito.doReturn;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.timeout;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n-import java.util.ArrayList;\n import java.util.HashSet;\n-import java.util.List;\n \n import org.junit.Test;\n \n@@ -60,24 +57,4 @@ public void commitProcessQueryMessageIsSentIfHostDeparted() {\n     verify(processor, timeout(60000)).waitForRepliesUninterruptibly();\n   }\n \n-  @Test\n-  public void firePendingCallbacksSetsChangeAppliedToCacheInEventLocalFilterInfo() {\n-    TXCommitMessage message = spy(new TXCommitMessage());\n-    FilterRoutingInfo.FilterInfo filterInfo1 = mock(FilterRoutingInfo.FilterInfo.class);\n-    FilterRoutingInfo.FilterInfo filterInfo2 = mock(FilterRoutingInfo.FilterInfo.class);\n-    EntryEventImpl event1 = mock(EntryEventImpl.class, RETURNS_DEEP_STUBS);\n-    EntryEventImpl event2 = mock(EntryEventImpl.class, RETURNS_DEEP_STUBS);\n-    List<EntryEventImpl> callbacks = new ArrayList<>();\n-    callbacks.add(event1);\n-    callbacks.add(event2);\n-    doReturn(event2).when(message).getLastTransactionEvent(callbacks);\n-    when(event1.getLocalFilterInfo()).thenReturn(filterInfo1);\n-    when(event2.getLocalFilterInfo()).thenReturn(filterInfo2);\n-\n-    message.firePendingCallbacks(callbacks);\n-\n-    verify(filterInfo1).setChangeAppliedToCache(true);\n-    verify(filterInfo2).setChangeAppliedToCache(true);\n-  }\n-\n }"
  },
  {
    "sha": "0c3151868d7b1bcdb29e6b6f5a878344ef4e3181",
    "filename": "geode-core/src/test/java/org/apache/geode/internal/cache/TXStateTest.java",
    "status": "modified",
    "additions": 24,
    "deletions": 24,
    "changes": 48,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/test/java/org/apache/geode/internal/cache/TXStateTest.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/test/java/org/apache/geode/internal/cache/TXStateTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/test/java/org/apache/geode/internal/cache/TXStateTest.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -19,25 +19,26 @@\n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatThrownBy;\n import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.doNothing;\n import static org.mockito.Mockito.doReturn;\n import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.inOrder;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n import javax.transaction.Status;\n \n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.ExpectedException;\n+import org.mockito.InOrder;\n \n import org.apache.geode.cache.CommitConflictException;\n import org.apache.geode.cache.EntryNotFoundException;\n@@ -95,6 +96,26 @@ public void doAfterCompletionThrowsIfCommitFails() {\n         .isSameAs(transactionDataNodeHasDepartedException);\n   }\n \n+  @Test\n+  public void attacheFilterProfileAfterApplyingChagnes() {\n+    TXState txState = spy(new TXState(txStateProxy, false, disabledClock()));\n+    ArrayList entries = mock(ArrayList.class);\n+    doReturn(entries).when(txState).generateEventOffsets();\n+    doNothing().when(txState).attachFilterProfileInformation(entries);\n+    doNothing().when(txState).applyChanges(entries);\n+    TXCommitMessage txCommitMessage = mock(TXCommitMessage.class);\n+    doReturn(txCommitMessage).when(txState).buildMessage();\n+\n+    txState.commit();\n+\n+    InOrder inOrder = inOrder(txState, txCommitMessage);\n+    inOrder.verify(txState).applyChanges(any());\n+    inOrder.verify(txState).attachFilterProfileInformation(any());\n+    inOrder.verify(txState).buildMessage();\n+    inOrder.verify(txCommitMessage).send(any());\n+    inOrder.verify(txState).firePendingCallbacks();\n+  }\n+\n   @Test\n   public void doAfterCompletionCanCommitJTA() {\n     TXState txState = spy(new TXState(txStateProxy, false, disabledClock()));\n@@ -369,25 +390,4 @@ public void txPutEntryRecordExceptionIfFailedWithTransactionDataRebalancedExcept\n     verify(txState, never()).getRecordedResultOrException(event);\n     verify(txState).recordEventException(event, exception);\n   }\n-\n-  @Test\n-  public void firePendingCallbacksSetsChangeAppliedToCacheInEventLocalFilterInfo() {\n-    TXState txState = spy(new TXState(txStateProxy, true, disabledClock()));\n-    FilterRoutingInfo.FilterInfo filterInfo1 = mock(FilterRoutingInfo.FilterInfo.class);\n-    FilterRoutingInfo.FilterInfo filterInfo2 = mock(FilterRoutingInfo.FilterInfo.class);\n-    EntryEventImpl event1 = mock(EntryEventImpl.class, RETURNS_DEEP_STUBS);\n-    EntryEventImpl event2 = mock(EntryEventImpl.class, RETURNS_DEEP_STUBS);\n-    List<EntryEventImpl> callbacks = new ArrayList<>();\n-    callbacks.add(event1);\n-    callbacks.add(event2);\n-    doReturn(event2).when(txState).getLastTransactionEvent();\n-    when(event1.getLocalFilterInfo()).thenReturn(filterInfo1);\n-    when(event2.getLocalFilterInfo()).thenReturn(filterInfo2);\n-    doReturn(callbacks).when(txState).getPendingCallbacks();\n-\n-    txState.firePendingCallbacks();\n-\n-    verify(filterInfo1).setChangeAppliedToCache(true);\n-    verify(filterInfo2).setChangeAppliedToCache(true);\n-  }\n }"
  },
  {
    "sha": "437c9790843bc0e6ffbc66fe37dd728c3620cad5",
    "filename": "geode-core/src/test/java/org/apache/geode/internal/cache/tier/sockets/CacheClientNotifierTest.java",
    "status": "modified",
    "additions": 246,
    "deletions": 264,
    "changes": 510,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/test/java/org/apache/geode/internal/cache/tier/sockets/CacheClientNotifierTest.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/test/java/org/apache/geode/internal/cache/tier/sockets/CacheClientNotifierTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/test/java/org/apache/geode/internal/cache/tier/sockets/CacheClientNotifierTest.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -14,351 +14,333 @@\n  */\n package org.apache.geode.internal.cache.tier.sockets;\n \n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.isA;\n import static org.mockito.Mockito.doAnswer;\n-import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.doReturn;\n import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n-import static org.mockito.quality.Strictness.STRICT_STUBS;\n \n import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n import java.net.Socket;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.concurrent.Callable;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n-import java.util.concurrent.atomic.AtomicReference;\n \n import org.junit.After;\n import org.junit.Before;\n-import org.junit.BeforeClass;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.mockito.junit.MockitoJUnit;\n-import org.mockito.junit.MockitoRule;\n \n-import org.apache.geode.CancelCriterion;\n-import org.apache.geode.Statistics;\n import org.apache.geode.cache.Operation;\n import org.apache.geode.cache.query.internal.cq.ServerCQ;\n-import org.apache.geode.distributed.internal.InternalDistributedSystem;\n-import org.apache.geode.internal.SystemTimer;\n+import org.apache.geode.internal.cache.DistributedRegion;\n import org.apache.geode.internal.cache.EntryEventImpl;\n import org.apache.geode.internal.cache.EnumListenerEvent;\n import org.apache.geode.internal.cache.FilterProfile;\n import org.apache.geode.internal.cache.FilterRoutingInfo;\n-import org.apache.geode.internal.cache.FilterRoutingInfo.FilterInfo;\n import org.apache.geode.internal.cache.InternalCache;\n import org.apache.geode.internal.cache.InternalCacheEvent;\n-import org.apache.geode.internal.cache.InternalRegion;\n+import org.apache.geode.internal.cache.LocalRegion;\n import org.apache.geode.internal.cache.RegionQueueException;\n-import org.apache.geode.internal.cache.tier.sockets.ClientRegistrationEventQueueManager.ClientRegistrationEventQueue;\n import org.apache.geode.internal.statistics.StatisticsClock;\n-import org.apache.geode.internal.statistics.StatisticsManager;\n-import org.apache.geode.test.junit.rules.ExecutorServiceRule;\n+import org.apache.geode.test.fake.Fakes;\n \n public class CacheClientNotifierTest {\n-\n-  private static final String CQ_NAME = \"testCQ\";\n-  private static final long CQ_ID = 0;\n-\n-  private final AtomicReference<CountDownLatch> afterLatch =\n-      new AtomicReference<>(new CountDownLatch(0));\n-  private final AtomicReference<CountDownLatch> beforeLatch =\n-      new AtomicReference<>(new CountDownLatch(0));\n-\n-  private CacheClientProxy cacheClientProxy;\n-  private ClientProxyMembershipID clientProxyMembershipId;\n-  private ClientRegistrationEventQueueManager clientRegistrationEventQueueManager;\n-  private ClientRegistrationMetadata clientRegistrationMetadata;\n-  private InternalCache internalCache;\n-  private InternalDistributedSystem internalDistributedSystem;\n-  private Socket socket;\n-  private Statistics statistics;\n-  private StatisticsManager statisticsManager;\n-  private InternalRegion region;\n-\n-  private CacheClientNotifier cacheClientNotifier;\n-\n-  @Rule\n-  public MockitoRule mockitoRule = MockitoJUnit.rule().strictness(STRICT_STUBS);\n-  @Rule\n-  public ExecutorServiceRule executorServiceRule = new ExecutorServiceRule();\n-\n-  @BeforeClass\n-  public static void clearStatics() {\n+  @Before\n+  public void setup() {\n     // Perform cleanup on any singletons received from previous test runs, since the\n     // CacheClientNotifier is a static and previous tests may not have cleaned up properly.\n-    CacheClientNotifier cacheClientNotifier = CacheClientNotifier.getInstance();\n-    if (cacheClientNotifier != null) {\n-      cacheClientNotifier.shutdown(0);\n-    }\n-  }\n-\n-  @Before\n-  public void setUp() {\n-    cacheClientProxy = mock(CacheClientProxy.class);\n-    clientProxyMembershipId = mock(ClientProxyMembershipID.class);\n-    clientRegistrationEventQueueManager = mock(ClientRegistrationEventQueueManager.class);\n-    clientRegistrationMetadata = mock(ClientRegistrationMetadata.class);\n-    internalCache = mock(InternalCache.class);\n-    internalDistributedSystem = mock(InternalDistributedSystem.class);\n-    region = mock(InternalRegion.class);\n-    socket = mock(Socket.class);\n-    statistics = mock(Statistics.class);\n-    statisticsManager = mock(StatisticsManager.class);\n+    shutdownExistingCacheClientNotifier();\n   }\n \n   @After\n   public void tearDown() {\n-    beforeLatch.get().countDown();\n-    afterLatch.get().countDown();\n-\n-    clearStatics();\n+    shutdownExistingCacheClientNotifier();\n   }\n \n   @Test\n   public void eventsInClientRegistrationQueueAreSentToClientAfterRegistrationIsComplete()\n-      throws Exception {\n-    // this test requires real impl instance of ClientRegistrationEventQueueManager\n-    clientRegistrationEventQueueManager = new ClientRegistrationEventQueueManager();\n-\n-    when(cacheClientProxy.getProxyID())\n-        .thenReturn(clientProxyMembershipId);\n-    when(clientRegistrationMetadata.getClientProxyMembershipID())\n-        .thenReturn(clientProxyMembershipId);\n-    when(internalCache.getCancelCriterion())\n-        .thenReturn(mock(CancelCriterion.class));\n-    when(internalCache.getCCPTimer())\n-        .thenReturn(mock(SystemTimer.class));\n-    when(internalCache.getInternalDistributedSystem())\n-        .thenReturn(internalDistributedSystem);\n-    when(internalDistributedSystem.getStatisticsManager())\n-        .thenReturn(statisticsManager);\n-    when(statisticsManager.createAtomicStatistics(any(), any()))\n-        .thenReturn(statistics);\n-\n-    cacheClientNotifier = spy(CacheClientNotifier.getInstance(internalCache,\n-        clientRegistrationEventQueueManager, mock(StatisticsClock.class),\n-        mock(CacheServerStats.class), 0, 0, mock(ConnectionListener.class), null, false));\n-\n-    beforeLatch.set(new CountDownLatch(1));\n-    afterLatch.set(new CountDownLatch(1));\n-\n-    // We stub out the CacheClientNotifier.registerClientInternal() to do some \"work\" until\n-    // a new event is received and queued, as triggered by the afterLatch\n-    doAnswer(invocation -> {\n-      cacheClientNotifier.addClientProxy(cacheClientProxy);\n-      beforeLatch.get().countDown();\n-      afterLatch.get().await();\n-      return null;\n-    })\n-        .when(cacheClientNotifier)\n-        .registerClientInternal(clientRegistrationMetadata, socket, false, 0, true);\n-\n-    Collection<Callable<Void>> tasks = new ArrayList<>();\n-\n-    // In one thread, we register the new client which should create the temporary client\n-    // registration event queue. Events will be passed to that queue while registration is\n-    // underway. Once registration is complete, the queue is drained and the event is processed\n-    // as normal.\n-    tasks.add(() -> {\n-      cacheClientNotifier.registerClient(clientRegistrationMetadata, socket, false, 0, true);\n-      return null;\n-    });\n-\n-    // In a second thread, we mock the arrival of a new event. We want to ensure this event\n-    // goes into the temporary client registration event queue. To do that, we wait on the\n-    // beforeLatch until registration is underway and the temp queue is\n-    // created. Once it is, we process the event and notify clients, which should add the event\n-    // to the temp queue. Finally, we resume registration and after it is complete, we verify\n-    // that the event was drained, processed, and \"delivered\" (note message delivery is mocked\n-    // and results in a no-op).\n-    tasks.add(() -> {\n-      beforeLatch.get().await();\n-\n-      InternalCacheEvent internalCacheEvent = internalCacheEvent(clientProxyMembershipId);\n-      ClientUpdateMessageImpl clientUpdateMessageImpl = mock(ClientUpdateMessageImpl.class);\n-      CacheClientNotifier.notifyClients(internalCacheEvent, clientUpdateMessageImpl);\n-\n-      afterLatch.get().countDown();\n-      return null;\n-    });\n-\n-    for (Future future : executorServiceRule.getExecutorService().invokeAll(tasks)) {\n-      future.get();\n+      throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException,\n+      InvocationTargetException, InterruptedException, ExecutionException {\n+    InternalCache internalCache = Fakes.cache();\n+    CacheServerStats cacheServerStats = mock(CacheServerStats.class);\n+    Socket socket = mock(Socket.class);\n+    ConnectionListener connectionListener = mock(ConnectionListener.class);\n+    ClientProxyMembershipID clientProxyMembershipID = mock(ClientProxyMembershipID.class);\n+    CacheClientProxy cacheClientProxy = mock(CacheClientProxy.class);\n+    ClientUpdateMessageImpl clientUpdateMessage = mock(ClientUpdateMessageImpl.class);\n+    ClientRegistrationMetadata clientRegistrationMetadata = mock(ClientRegistrationMetadata.class);\n+    StatisticsClock statisticsClock = mock(StatisticsClock.class);\n+\n+    when(clientRegistrationMetadata.getClientProxyMembershipID()).thenReturn(\n+        clientProxyMembershipID);\n+\n+    CacheClientNotifier cacheClientNotifier = CacheClientNotifier.getInstance(internalCache,\n+        new ClientRegistrationEventQueueManager(), statisticsClock, cacheServerStats, 0, 0,\n+        connectionListener, null, false);\n+    final CacheClientNotifier cacheClientNotifierSpy = spy(cacheClientNotifier);\n+\n+    CountDownLatch waitForEventDispatchCountdownLatch = new CountDownLatch(1);\n+    CountDownLatch waitForRegistrationCountdownLatch = new CountDownLatch(1);\n+    ExecutorService registerAndNotifyExecutor = Executors.newFixedThreadPool(2);\n+\n+    try {\n+      // We stub out the CacheClientNotifier.registerClientInternal() to do some \"work\" until\n+      // a new event is received and queued, as triggered by the waitForEventDispatchCountdownLatch\n+      doAnswer((i) -> {\n+        when(cacheClientProxy.getProxyID()).thenReturn(clientProxyMembershipID);\n+        cacheClientNotifierSpy.addClientProxy(cacheClientProxy);\n+        waitForRegistrationCountdownLatch.countDown();\n+        waitForEventDispatchCountdownLatch.await();\n+        return null;\n+      }).when(cacheClientNotifierSpy).registerClientInternal(clientRegistrationMetadata, socket,\n+          false, 0, true);\n+      List<Callable<Void>> registerAndNotifyTasks = new ArrayList<>();\n+\n+      // In one thread, we register the new client which should create the temporary client\n+      // registration event queue. Events will be passed to that queue while registration is\n+      // underway. Once registration is complete, the queue is drained and the event is processed\n+      // as normal.\n+      registerAndNotifyTasks.add(() -> {\n+        cacheClientNotifierSpy.registerClient(clientRegistrationMetadata, socket, false, 0, true);\n+        return null;\n+      });\n+\n+      // In a second thread, we mock the arrival of a new event. We want to ensure this event\n+      // goes into the temporary client registration event queue. To do that, we wait on the\n+      // waitForRegistrationCountdownLatch until registration is underway and the temp queue is\n+      // created. Once it is, we process the event and notify clients, which should add the event\n+      // to the temp queue. Finally, we resume registration and after it is complete, we verify\n+      // that the event was drained, processed, and \"delivered\" (note message delivery is mocked\n+      // and results in a no-op).\n+      registerAndNotifyTasks.add(() -> {\n+        try {\n+          waitForRegistrationCountdownLatch.await();\n+\n+          InternalCacheEvent internalCacheEvent =\n+              createMockInternalCacheEvent(clientProxyMembershipID, clientUpdateMessage,\n+                  cacheClientNotifierSpy);\n+\n+          CacheClientNotifier.notifyClients(internalCacheEvent, clientUpdateMessage);\n+        } finally {\n+          // Ensure we always countdown so if the test fails it won't hang due to\n+          // awaiting on this countdown latch.\n+          waitForEventDispatchCountdownLatch.countDown();\n+        }\n+        return null;\n+      });\n+\n+      final List<Future<Void>> futures =\n+          registerAndNotifyExecutor.invokeAll(registerAndNotifyTasks);\n+\n+      for (final Future future : futures) {\n+        future.get();\n+      }\n+    } finally {\n+      // To prevent not cleaning up test resources in case an unexpected exception occurs\n+      waitForEventDispatchCountdownLatch.countDown();\n+      waitForRegistrationCountdownLatch.countDown();\n+      registerAndNotifyExecutor.shutdownNow();\n+      cacheClientNotifier.shutdown(0);\n     }\n \n-    verify(cacheClientProxy).deliverMessage(any());\n+    verify(cacheClientProxy, times(1)).deliverMessage(isA(HAEventWrapper.class));\n   }\n \n   @Test\n-  public void initializingMessageDoesNotSerializeValuePrematurely() {\n-    // this test requires mock of EntryEventImpl instead of InternalCacheEvent\n-    EntryEventImpl entryEventImpl = mock(EntryEventImpl.class);\n-\n-    when(entryEventImpl.getEventType())\n-        .thenReturn(EnumListenerEvent.AFTER_CREATE);\n-    when(entryEventImpl.getOperation())\n-        .thenReturn(Operation.CREATE);\n-    when(entryEventImpl.getRegion())\n-        .thenReturn(region);\n-    when(internalCache.getCCPTimer())\n-        .thenReturn(mock(SystemTimer.class));\n-    when(internalCache.getInternalDistributedSystem())\n-        .thenReturn(internalDistributedSystem);\n-    when(internalDistributedSystem.getStatisticsManager())\n-        .thenReturn(statisticsManager);\n-    when(statisticsManager.createAtomicStatistics(any(), any()))\n-        .thenReturn(statistics);\n-\n-    cacheClientNotifier = CacheClientNotifier.getInstance(internalCache,\n-        mock(ClientRegistrationEventQueueManager.class), mock(StatisticsClock.class),\n-        mock(CacheServerStats.class), 0, 0, mock(ConnectionListener.class), null, false);\n-\n-    cacheClientNotifier.constructClientMessage(entryEventImpl);\n-\n-    verify(entryEventImpl, never()).exportNewValue(any());\n+  public void initializingMessageShouldntSerializeValuePrematurely() throws Exception {\n+    InternalCache internalCache = Fakes.cache();\n+    CacheServerStats cacheServerStats = mock(CacheServerStats.class);\n+    ConnectionListener connectionListener = mock(ConnectionListener.class);\n+    ClientProxyMembershipID clientProxyMembershipID = mock(ClientProxyMembershipID.class);\n+    ClientRegistrationMetadata clientRegistrationMetadata = mock(ClientRegistrationMetadata.class);\n+    StatisticsClock statisticsClock = mock(StatisticsClock.class);\n+\n+    when(clientRegistrationMetadata.getClientProxyMembershipID()).thenReturn(\n+        clientProxyMembershipID);\n+\n+    CacheClientNotifier cacheClientNotifier = CacheClientNotifier.getInstance(internalCache,\n+        new ClientRegistrationEventQueueManager(), statisticsClock, cacheServerStats, 0, 0,\n+        connectionListener, null, false);\n+    LocalRegion region = mock(LocalRegion.class);\n+\n+    EntryEventImpl entryEvent = mock(EntryEventImpl.class);\n+    when(entryEvent.getEventType()).thenReturn(EnumListenerEvent.AFTER_CREATE);\n+    when(entryEvent.getOperation()).thenReturn(Operation.CREATE);\n+    when(entryEvent.getRegion()).thenReturn(region);\n+    cacheClientNotifier.constructClientMessage(entryEvent);\n+    verify(entryEvent, times(0)).exportNewValue(any());\n   }\n \n   @Test\n-  public void clientRegistrationFailsQueueStillDrained() throws Exception {\n-    ClientRegistrationEventQueue clientRegistrationEventQueue =\n-        mock(ClientRegistrationEventQueue.class);\n-\n-    when(clientRegistrationEventQueueManager.create(eq(clientProxyMembershipId), any(), any()))\n+  public void clientRegistrationFailsQueueStillDrained()\n+      throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n+      IllegalAccessException, IOException {\n+    InternalCache internalCache = Fakes.cache();\n+    CacheServerStats cacheServerStats = mock(CacheServerStats.class);\n+    Socket socket = mock(Socket.class);\n+    ConnectionListener connectionListener = mock(ConnectionListener.class);\n+    ClientRegistrationMetadata clientRegistrationMetadata = mock(ClientRegistrationMetadata.class);\n+    StatisticsClock statisticsClock = mock(StatisticsClock.class);\n+    ClientProxyMembershipID clientProxyMembershipID = mock(ClientProxyMembershipID.class);\n+    ClientRegistrationEventQueueManager clientRegistrationEventQueueManager =\n+        mock(ClientRegistrationEventQueueManager.class);\n+    ClientRegistrationEventQueueManager.ClientRegistrationEventQueue clientRegistrationEventQueue =\n+        mock(ClientRegistrationEventQueueManager.ClientRegistrationEventQueue.class);\n+\n+    when(clientRegistrationMetadata.getClientProxyMembershipID()).thenReturn(\n+        clientProxyMembershipID);\n+    when(clientRegistrationEventQueueManager.create(eq(clientProxyMembershipID), any(), any()))\n         .thenReturn(clientRegistrationEventQueue);\n-    when(clientRegistrationMetadata.getClientProxyMembershipID())\n-        .thenReturn(clientProxyMembershipId);\n-    when(internalCache.getCCPTimer())\n-        .thenReturn(mock(SystemTimer.class));\n-    when(internalCache.getInternalDistributedSystem())\n-        .thenReturn(internalDistributedSystem);\n-    when(internalDistributedSystem.getStatisticsManager())\n-        .thenReturn(statisticsManager);\n-    when(statisticsManager.createAtomicStatistics(any(), any()))\n-        .thenReturn(statistics);\n-\n-    cacheClientNotifier = spy(CacheClientNotifier.getInstance(internalCache,\n-        clientRegistrationEventQueueManager, mock(StatisticsClock.class),\n-        mock(CacheServerStats.class), 0, 0, mock(ConnectionListener.class), null, false));\n-\n-    doThrow(new RegionQueueException(\"thrown during client registration\"))\n-        .when(cacheClientNotifier)\n-        .registerClientInternal(clientRegistrationMetadata, socket, false, 0, true);\n-\n-    Throwable thrown = catchThrowable(() -> {\n-      cacheClientNotifier.registerClient(clientRegistrationMetadata, socket, false, 0, true);\n-    });\n-    assertThat(thrown).isInstanceOf(IOException.class);\n-\n-    verify(clientRegistrationEventQueueManager)\n-        .create(eq(clientProxyMembershipId), any(), any());\n-\n-    verify(clientRegistrationEventQueueManager)\n-        .drain(eq(clientRegistrationEventQueue), eq(cacheClientNotifier));\n+\n+    CacheClientNotifier cacheClientNotifier = CacheClientNotifier.getInstance(internalCache,\n+        clientRegistrationEventQueueManager, statisticsClock, cacheServerStats, 0, 0,\n+        connectionListener, null, false);\n+    CacheClientNotifier cacheClientNotifierSpy = spy(cacheClientNotifier);\n+\n+    doAnswer((i) -> {\n+      throw new RegionQueueException();\n+    }).when(cacheClientNotifierSpy).registerClientInternal(clientRegistrationMetadata, socket,\n+        false, 0, true);\n+\n+    assertThatThrownBy(() -> cacheClientNotifierSpy.registerClient(clientRegistrationMetadata,\n+        socket, false, 0, true))\n+            .isInstanceOf(IOException.class);\n+\n+    verify(clientRegistrationEventQueueManager, times(1)).create(\n+        eq(clientProxyMembershipID), any(), any());\n+\n+    verify(clientRegistrationEventQueueManager, times(1)).drain(\n+        eq(clientRegistrationEventQueue),\n+        eq(cacheClientNotifierSpy));\n+  }\n+\n+  private InternalCacheEvent createMockInternalCacheEvent(\n+      final ClientProxyMembershipID clientProxyMembershipID,\n+      final ClientUpdateMessageImpl clientUpdateMessage,\n+      final CacheClientNotifier cacheClientNotifierSpy) {\n+    InternalCacheEvent internalCacheEvent = mock(InternalCacheEvent.class);\n+\n+    DistributedRegion region = mock(DistributedRegion.class);\n+    when(internalCacheEvent.getRegion()).thenReturn(region);\n+\n+    FilterRoutingInfo.FilterInfo filterInfo = mock(FilterRoutingInfo.FilterInfo.class);\n+    final Long cqId = 0L;\n+    final String cqName = \"testCQ\";\n+\n+    HashMap cqs = new HashMap<Long, Integer>() {\n+      {\n+        put(cqId, 123);\n+      }\n+    };\n+    when(filterInfo.getCQs()).thenReturn(cqs);\n+    when(internalCacheEvent.getLocalFilterInfo()).thenReturn(\n+        filterInfo);\n+    when(internalCacheEvent.getOperation()).thenReturn(mock(Operation.class));\n+\n+    FilterProfile filterProfile = mock(FilterProfile.class);\n+    when(filterProfile.getRealCqID(cqId)).thenReturn(cqName);\n+\n+    ServerCQ serverCQ = mock(ServerCQ.class);\n+    when(serverCQ.getClientProxyId()).thenReturn(clientProxyMembershipID);\n+    when(filterProfile.getCq(cqName)).thenReturn(serverCQ);\n+    when(region.getFilterProfile()).thenReturn(filterProfile);\n+\n+    FilterRoutingInfo filterRoutingInfo = mock(FilterRoutingInfo.class);\n+    when(filterRoutingInfo.getLocalFilterInfo()).thenReturn(filterInfo);\n+    when(filterProfile.getFilterRoutingInfoPart2(null, internalCacheEvent))\n+        .thenReturn(filterRoutingInfo);\n+    doReturn(clientUpdateMessage).when(cacheClientNotifierSpy)\n+        .constructClientMessage(internalCacheEvent);\n+\n+    return internalCacheEvent;\n   }\n \n   @Test\n   public void testSingletonHasClientProxiesFalseNoCCN() {\n-    assertThat(CacheClientNotifier.singletonHasClientProxies()).isFalse();\n+    assertFalse(CacheClientNotifier.singletonHasClientProxies());\n   }\n \n   @Test\n   public void testSingletonHasClientProxiesFalseNoProxy() {\n-    when(internalCache.getCCPTimer())\n-        .thenReturn(mock(SystemTimer.class));\n+    InternalCache internalCache = Fakes.cache();\n+\n+    CacheClientNotifier ccn =\n+        CacheClientNotifier.getInstance(internalCache,\n+            mock(ClientRegistrationEventQueueManager.class),\n+            mock(StatisticsClock.class),\n+            mock(CacheServerStats.class), 10, 10, mock(ConnectionListener.class), null, true);\n \n-    cacheClientNotifier = CacheClientNotifier.getInstance(internalCache,\n-        mock(ClientRegistrationEventQueueManager.class), mock(StatisticsClock.class),\n-        mock(CacheServerStats.class), 10, 10, mock(ConnectionListener.class), null, true);\n+    assertFalse(CacheClientNotifier.singletonHasClientProxies());\n+    ccn.shutdown(111);\n \n-    assertThat(CacheClientNotifier.singletonHasClientProxies()).isFalse();\n   }\n \n   @Test\n   public void testSingletonHasClientProxiesTrue() {\n-    when(cacheClientProxy.getAcceptorId())\n-        .thenReturn(111L);\n-    when(cacheClientProxy.getProxyID())\n-        .thenReturn(mock(ClientProxyMembershipID.class));\n-    when(internalCache.getCCPTimer())\n-        .thenReturn(mock(SystemTimer.class));\n+    InternalCache internalCache = Fakes.cache();\n+    CacheClientProxy proxy = mock(CacheClientProxy.class);\n \n-    cacheClientNotifier = CacheClientNotifier.getInstance(internalCache,\n-        mock(ClientRegistrationEventQueueManager.class), mock(StatisticsClock.class),\n-        mock(CacheServerStats.class), 10, 10, mock(ConnectionListener.class), null, true);\n+    CacheClientNotifier ccn =\n+        CacheClientNotifier.getInstance(internalCache,\n+            mock(ClientRegistrationEventQueueManager.class),\n+            mock(StatisticsClock.class),\n+            mock(CacheServerStats.class), 10, 10, mock(ConnectionListener.class), null, true);\n \n-    cacheClientNotifier.addClientProxy(cacheClientProxy);\n+    when(proxy.getProxyID()).thenReturn(mock(ClientProxyMembershipID.class));\n+    ccn.addClientProxy(proxy);\n \n     // check ClientProxy Map is not empty\n-    assertThat(CacheClientNotifier.singletonHasClientProxies()).isTrue();\n+    assertTrue(CacheClientNotifier.singletonHasClientProxies());\n+\n+    when(proxy.getAcceptorId()).thenReturn(Long.valueOf(111));\n+    ccn.shutdown(111);\n   }\n \n   @Test\n   public void testSingletonHasInitClientProxiesTrue() {\n-    when(cacheClientProxy.getAcceptorId())\n-        .thenReturn(111L);\n-    when(cacheClientProxy.getProxyID())\n-        .thenReturn(mock(ClientProxyMembershipID.class));\n-    when(internalCache.getCCPTimer())\n-        .thenReturn(mock(SystemTimer.class));\n+    InternalCache internalCache = Fakes.cache();\n+    CacheClientProxy proxy = mock(CacheClientProxy.class);\n \n-    cacheClientNotifier = CacheClientNotifier.getInstance(internalCache,\n-        mock(ClientRegistrationEventQueueManager.class), mock(StatisticsClock.class),\n-        mock(CacheServerStats.class), 10, 10, mock(ConnectionListener.class), null, true);\n+    CacheClientNotifier ccn =\n+        CacheClientNotifier.getInstance(internalCache,\n+            mock(ClientRegistrationEventQueueManager.class),\n+            mock(StatisticsClock.class),\n+            mock(CacheServerStats.class), 10, 10, mock(ConnectionListener.class), null, true);\n \n-    cacheClientNotifier.addClientInitProxy(cacheClientProxy);\n+    when(proxy.getProxyID()).thenReturn(mock(ClientProxyMembershipID.class));\n+    ccn.addClientInitProxy(proxy);\n \n     // check InitClientProxy Map is not empty\n-    assertThat(CacheClientNotifier.singletonHasClientProxies()).isTrue();\n+    assertTrue(CacheClientNotifier.singletonHasClientProxies());\n \n-    cacheClientNotifier.addClientProxy(cacheClientProxy);\n+    ccn.addClientProxy(proxy);\n \n     // check ClientProxy Map is not empty\n-    assertThat(CacheClientNotifier.singletonHasClientProxies()).isTrue();\n-  }\n-\n-  private InternalCacheEvent internalCacheEvent(ClientProxyMembershipID clientProxyMembershipID) {\n-    FilterInfo filterInfo = mock(FilterInfo.class);\n-    FilterProfile filterProfile = mock(FilterProfile.class);\n-    FilterRoutingInfo filterRoutingInfo = mock(FilterRoutingInfo.class);\n-    InternalCacheEvent internalCacheEvent = mock(InternalCacheEvent.class);\n-    ServerCQ serverCQ = mock(ServerCQ.class);\n-\n-    HashMap<Long, Integer> cqs = new HashMap<>();\n-    cqs.put(CQ_ID, 123);\n-\n-    when(filterInfo.getCQs())\n-        .thenReturn(cqs);\n-    when(filterProfile.getCq(CQ_NAME))\n-        .thenReturn(serverCQ);\n-    when(filterProfile.getRealCqID(CQ_ID))\n-        .thenReturn(CQ_NAME);\n-    when(filterProfile.getFilterRoutingInfoPart2(null, internalCacheEvent, true))\n-        .thenReturn(filterRoutingInfo);\n-    when(filterRoutingInfo.getLocalFilterInfo())\n-        .thenReturn(filterInfo);\n-    when(internalCacheEvent.getRegion())\n-        .thenReturn(region);\n-    when(internalCacheEvent.getLocalFilterInfo())\n-        .thenReturn(filterInfo);\n-    when(internalCacheEvent.getOperation())\n-        .thenReturn(mock(Operation.class));\n-    when(region.getFilterProfile())\n-        .thenReturn(filterProfile);\n-    when(serverCQ.getClientProxyId())\n-        .thenReturn(clientProxyMembershipID);\n+    assertTrue(CacheClientNotifier.singletonHasClientProxies());\n \n-    return internalCacheEvent;\n+    when(proxy.getAcceptorId()).thenReturn(Long.valueOf(111));\n+    ccn.shutdown(111);\n   }\n \n+  private void shutdownExistingCacheClientNotifier() {\n+    CacheClientNotifier cacheClientNotifier = CacheClientNotifier.getInstance();\n+    if (cacheClientNotifier != null) {\n+      cacheClientNotifier.shutdown(0);\n+    }\n+  }\n }"
  },
  {
    "sha": "16a4042e8a3c657df9132faf27d72bd3fccdb2a6",
    "filename": "geode-core/src/test/java/org/apache/geode/internal/cache/tier/sockets/ClientRegistrationEventQueueManagerTest.java",
    "status": "modified",
    "additions": 191,
    "deletions": 230,
    "changes": 421,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/test/java/org/apache/geode/internal/cache/tier/sockets/ClientRegistrationEventQueueManagerTest.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-core/src/test/java/org/apache/geode/internal/cache/tier/sockets/ClientRegistrationEventQueueManagerTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/test/java/org/apache/geode/internal/cache/tier/sockets/ClientRegistrationEventQueueManagerTest.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -12,396 +12,357 @@\n  * or implied. See the License for the specific language governing permissions and limitations under\n  * the License.\n  */\n+\n package org.apache.geode.internal.cache.tier.sockets;\n \n-import static java.util.Collections.emptySet;\n-import static org.apache.geode.internal.util.CollectionUtils.asSet;\n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n import static org.mockito.ArgumentMatchers.anyString;\n import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n-import static org.mockito.quality.Strictness.STRICT_STUBS;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;\n \n-import org.junit.Before;\n-import org.junit.Rule;\n import org.junit.Test;\n-import org.mockito.junit.MockitoJUnit;\n-import org.mockito.junit.MockitoRule;\n-import org.mockito.stubbing.Answer;\n \n import org.apache.geode.cache.Operation;\n import org.apache.geode.internal.cache.Conflatable;\n import org.apache.geode.internal.cache.EntryEventImpl;\n import org.apache.geode.internal.cache.FilterProfile;\n import org.apache.geode.internal.cache.FilterRoutingInfo;\n-import org.apache.geode.internal.cache.FilterRoutingInfo.FilterInfo;\n import org.apache.geode.internal.cache.InternalCacheEvent;\n-import org.apache.geode.internal.cache.InternalRegion;\n-import org.apache.geode.internal.cache.tier.sockets.ClientRegistrationEventQueueManager.ClientRegistrationEventQueue;\n+import org.apache.geode.internal.cache.LocalRegion;\n \n public class ClientRegistrationEventQueueManagerTest {\n-\n-  private CacheClientNotifier cacheClientNotifier;\n-  private CacheClientProxy cacheClientProxy;\n-  private ClientProxyMembershipID clientProxyMembershipId;\n-  private ClientUpdateMessageImpl clientUpdateMessage;\n-  private FilterInfo filterInfo;\n-  private FilterProfile filterProfile;\n-  private FilterRoutingInfo filterRoutingInfo;\n-  private InternalCacheEvent internalCacheEvent;\n-  private InternalRegion internalRegion;\n-  private Operation operation;\n-\n-  @Rule\n-  public MockitoRule mockitoRule = MockitoJUnit.rule().strictness(STRICT_STUBS);\n-\n-  @Before\n-  public void setUp() {\n-    cacheClientNotifier = mock(CacheClientNotifier.class);\n-    cacheClientProxy = mock(CacheClientProxy.class);\n-    clientProxyMembershipId = mock(ClientProxyMembershipID.class);\n-    clientUpdateMessage = mock(ClientUpdateMessageImpl.class);\n-    filterInfo = mock(FilterInfo.class);\n-    filterProfile = mock(FilterProfile.class);\n-    filterRoutingInfo = mock(FilterRoutingInfo.class);\n-    internalCacheEvent = mock(InternalCacheEvent.class);\n-    internalRegion = mock(InternalRegion.class);\n-    operation = mock(Operation.class);\n-  }\n-\n   @Test\n   public void messageDeliveredAfterRegisteringOnDrainIfNewFilterIDsIncludesClient() {\n-    // this test requires mock of EntryEventImpl instead of InternalCacheEvent\n-    EntryEventImpl entryEventImpl = mock(EntryEventImpl.class);\n-\n-    when(cacheClientNotifier.getClientProxy(clientProxyMembershipId))\n-        .thenReturn(cacheClientProxy);\n-    when(cacheClientNotifier.getFilterClientIDs(entryEventImpl, filterProfile, filterInfo,\n-        clientUpdateMessage))\n-            .thenReturn(asSet(clientProxyMembershipId));\n-    when(cacheClientProxy.getProxyID())\n-        .thenReturn(clientProxyMembershipId);\n-    when(entryEventImpl.getOperation())\n-        .thenReturn(operation);\n-    when(entryEventImpl.getRegion())\n-        .thenReturn(internalRegion);\n-    when(filterProfile.getFilterRoutingInfoPart2(null, entryEventImpl, true))\n-        .thenReturn(filterRoutingInfo);\n-    when(filterRoutingInfo.getLocalFilterInfo())\n-        .thenReturn(filterInfo);\n-    when(internalRegion.getFilterProfile())\n-        .thenReturn(filterProfile);\n-    when(operation.isEntry())\n-        .thenReturn(true);\n-\n     ClientRegistrationEventQueueManager clientRegistrationEventQueueManager =\n         new ClientRegistrationEventQueueManager();\n \n-    ClientRegistrationEventQueue clientRegistrationEventQueue =\n-        clientRegistrationEventQueueManager.create(clientProxyMembershipId,\n+    ClientProxyMembershipID clientProxyMembershipID = mock(ClientProxyMembershipID.class);\n+\n+    ClientRegistrationEventQueueManager.ClientRegistrationEventQueue clientRegistrationEventQueue =\n+        clientRegistrationEventQueueManager.create(clientProxyMembershipID,\n             new ConcurrentLinkedQueue<>(), new ReentrantReadWriteLock());\n \n+    InternalCacheEvent internalCacheEvent = mock(InternalCacheEvent.class);\n+    LocalRegion localRegion = mock(LocalRegion.class);\n+    FilterProfile filterProfile = mock(FilterProfile.class);\n+    FilterRoutingInfo filterRoutingInfo = mock(FilterRoutingInfo.class);\n+    FilterRoutingInfo.FilterInfo filterInfo = mock(FilterRoutingInfo.FilterInfo.class);\n+\n+    when(filterRoutingInfo.getLocalFilterInfo()).thenReturn(\n+        filterInfo);\n+    when(filterProfile.getFilterRoutingInfoPart2(null, internalCacheEvent))\n+        .thenReturn(filterRoutingInfo);\n+    when(localRegion.getFilterProfile()).thenReturn(filterProfile);\n+    when(internalCacheEvent.getRegion()).thenReturn(localRegion);\n+    when(internalCacheEvent.getOperation()).thenReturn(mock(Operation.class));\n+\n+    ClientUpdateMessageImpl clientUpdateMessage = mock(ClientUpdateMessageImpl.class);\n+\n+    CacheClientNotifier cacheClientNotifier = mock(CacheClientNotifier.class);\n+    Set<ClientProxyMembershipID> recalculatedFilterClientIDs = new HashSet<>();\n+    recalculatedFilterClientIDs.add(clientProxyMembershipID);\n+    when(cacheClientNotifier.getFilterClientIDs(internalCacheEvent, filterProfile, filterInfo,\n+        clientUpdateMessage))\n+            .thenReturn(recalculatedFilterClientIDs);\n+    CacheClientProxy cacheClientProxy = mock(CacheClientProxy.class);\n+    when(cacheClientProxy.getProxyID()).thenReturn(clientProxyMembershipID);\n+    when(cacheClientNotifier.getClientProxy(clientProxyMembershipID)).thenReturn(cacheClientProxy);\n+\n     // Create empty filter client IDs produced by the \"normal\" put processing path, so we can test\n     // that the event is still delivered if the client finished registering and needs the event.\n+    Set<ClientProxyMembershipID> normalPutFilterClientIDs = new HashSet<>();\n \n-    clientRegistrationEventQueueManager.add(entryEventImpl, clientUpdateMessage,\n-        clientUpdateMessage, emptySet(), cacheClientNotifier);\n+    clientRegistrationEventQueueManager\n+        .add(internalCacheEvent, clientUpdateMessage, normalPutFilterClientIDs,\n+            cacheClientNotifier);\n \n     clientRegistrationEventQueueManager.drain(clientRegistrationEventQueue, cacheClientNotifier);\n \n     // The client update message should still be delivered because it is now part of the\n     // filter clients interested in this event, despite having not been included in the original\n     // filter info in the \"normal\" put processing path.\n-    verify(cacheClientProxy).deliverMessage(clientUpdateMessage);\n+    verify(cacheClientProxy, times(1)).deliverMessage(clientUpdateMessage);\n   }\n \n   @Test\n   public void clientRemovedFromFilterClientsListIfEventAddedToRegistrationQueue() {\n-    // this test requires mock of EntryEventImpl instead of InternalCacheEvent\n-    EntryEventImpl entryEventImpl = mock(EntryEventImpl.class);\n-\n-    when(entryEventImpl.getOperation())\n-        .thenReturn(operation);\n-    when(operation.isEntry())\n-        .thenReturn(true);\n-\n     ClientRegistrationEventQueueManager clientRegistrationEventQueueManager =\n         new ClientRegistrationEventQueueManager();\n \n-    clientRegistrationEventQueueManager.create(clientProxyMembershipId,\n+    ClientProxyMembershipID clientProxyMembershipID = mock(ClientProxyMembershipID.class);\n+\n+    clientRegistrationEventQueueManager.create(clientProxyMembershipID,\n         new ConcurrentLinkedQueue<>(), new ReentrantReadWriteLock());\n \n+    InternalCacheEvent internalCacheEvent = mock(InternalCacheEvent.class);\n+    when(internalCacheEvent.getRegion()).thenReturn(mock(LocalRegion.class));\n+    when(internalCacheEvent.getOperation()).thenReturn(mock(Operation.class));\n+\n+    Conflatable conflatable = mock(Conflatable.class);\n+\n     // Add the registering client to the filter clients. This can happen if the filter info is\n     // received but the client is not completely registered yet (queue GII has not been completed).\n     // In that case, we want to remove the client from the filter IDs set and add the event\n     // to the client's registration queue.\n-    Set<ClientProxyMembershipID> filterClientIds = asSet(clientProxyMembershipId);\n+    Set<ClientProxyMembershipID> filterClientIDs = new HashSet<>();\n+    filterClientIDs.add(clientProxyMembershipID);\n+\n+    CacheClientNotifier cacheClientNotifier = mock(CacheClientNotifier.class);\n \n-    clientRegistrationEventQueueManager.add(entryEventImpl, mock(ClientUpdateMessageImpl.class),\n-        mock(Conflatable.class), filterClientIds, mock(CacheClientNotifier.class));\n+    clientRegistrationEventQueueManager.add(internalCacheEvent, conflatable, filterClientIDs,\n+        cacheClientNotifier);\n \n     // The client should no longer be in the filter clients since the event was queued in the\n     // client's registration queue.\n-    assertThat(filterClientIds).isEmpty();\n+    assertThat(filterClientIDs.isEmpty()).isTrue();\n   }\n \n   @Test\n   public void putInProgressCounterIncrementedOnAddAndDecrementedOnRemoveForAllEvents() {\n     ClientRegistrationEventQueueManager clientRegistrationEventQueueManager =\n         new ClientRegistrationEventQueueManager();\n \n-    ClientRegistrationEventQueue clientRegistrationEventQueue =\n-        clientRegistrationEventQueueManager.create(mock(ClientProxyMembershipID.class),\n-            new ConcurrentLinkedQueue<>(), new ReentrantReadWriteLock());\n-\n-    Collection<HAEventWrapper> haEventWrappers = new ArrayList<>();\n+    ClientProxyMembershipID clientProxyMembershipID = mock(ClientProxyMembershipID.class);\n \n-    for (int i = 0; i < 5; ++i) {\n-      EntryEventImpl entryEventImpl = mock(EntryEventImpl.class);\n+    ClientRegistrationEventQueueManager.ClientRegistrationEventQueue clientRegistrationEventQueue =\n+        clientRegistrationEventQueueManager.create(clientProxyMembershipID,\n+            new ConcurrentLinkedQueue<>(),\n+            new ReentrantReadWriteLock());\n \n-      when(entryEventImpl.getOperation())\n-          .thenReturn(operation);\n-      when(operation.isEntry())\n-          .thenReturn(true);\n+    List<HAEventWrapper> haEventWrappers = new ArrayList<>();\n+    CacheClientNotifier cacheClientNotifier = mock(CacheClientNotifier.class);\n \n+    for (int i = 0; i < 5; ++i) {\n       HAEventWrapper haEventWrapper = mock(HAEventWrapper.class);\n       haEventWrappers.add(haEventWrapper);\n-\n-      clientRegistrationEventQueueManager.add(entryEventImpl,\n-          mock(ClientUpdateMessageImpl.class), haEventWrapper, emptySet(), cacheClientNotifier);\n-\n-      verify(haEventWrapper).incrementPutInProgressCounter(anyString());\n+      InternalCacheEvent internalCacheEvent = mock(InternalCacheEvent.class);\n+      when(internalCacheEvent.getRegion()).thenReturn(mock(LocalRegion.class));\n+      when(internalCacheEvent.getOperation()).thenReturn(mock(Operation.class));\n+      clientRegistrationEventQueueManager.add(internalCacheEvent,\n+          haEventWrapper, new HashSet<>(), cacheClientNotifier);\n+      verify(haEventWrapper, times(1)).incrementPutInProgressCounter(anyString());\n     }\n \n     clientRegistrationEventQueueManager.drain(clientRegistrationEventQueue, cacheClientNotifier);\n \n     for (HAEventWrapper haEventWrapper : haEventWrappers) {\n-      verify(haEventWrapper).decrementPutInProgressCounter();\n+      verify(haEventWrapper, times(1)).decrementPutInProgressCounter();\n     }\n   }\n \n   @Test\n-  public void addAndDrainQueueContentionTest() throws Exception {\n-    ReentrantReadWriteLock readWriteLock = spy(new ReentrantReadWriteLock());\n+  public void addAndDrainQueueContentionTest() throws ExecutionException, InterruptedException {\n+    ClientProxyMembershipID clientProxyMembershipID = mock(ClientProxyMembershipID.class);\n+    ReentrantReadWriteLock mockPutDrainLock = mock(ReentrantReadWriteLock.class);\n+    ReentrantReadWriteLock actualPutDrainLock = new ReentrantReadWriteLock();\n+\n+    when(mockPutDrainLock.readLock())\n+        .thenReturn(actualPutDrainLock.readLock());\n \n-    when(readWriteLock.writeLock())\n-        .thenAnswer((Answer<WriteLock>) invocation -> {\n+    when(mockPutDrainLock.writeLock())\n+        .thenAnswer(i -> {\n           // Force a context switch from drain to put thread so we can ensure the event is not lost\n           Thread.sleep(1);\n-          return (WriteLock) invocation.callRealMethod();\n+          return actualPutDrainLock.writeLock();\n         });\n \n     ClientRegistrationEventQueueManager clientRegistrationEventQueueManager =\n         new ClientRegistrationEventQueueManager();\n \n-    ClientRegistrationEventQueue clientRegistrationEventQueue =\n-        clientRegistrationEventQueueManager.create(mock(ClientProxyMembershipID.class),\n-            new ConcurrentLinkedQueue<>(), readWriteLock);\n+    ClientRegistrationEventQueueManager.ClientRegistrationEventQueue clientRegistrationEventQueue =\n+        clientRegistrationEventQueueManager.create(clientProxyMembershipID,\n+            new ConcurrentLinkedQueue<>(), mockPutDrainLock);\n+\n+    InternalCacheEvent internalCacheEvent = mock(InternalCacheEvent.class);\n+    when(internalCacheEvent.getRegion()).thenReturn(mock(LocalRegion.class));\n+    when(internalCacheEvent.getOperation()).thenReturn(mock(Operation.class));\n+\n+    Conflatable conflatable = mock(Conflatable.class);\n+    Set<ClientProxyMembershipID> filterClientIDs = new HashSet<>();\n+    CacheClientNotifier cacheClientNotifier = mock(CacheClientNotifier.class);\n+    CacheClientProxy cacheClientProxy = mock(CacheClientProxy.class);\n+    when(cacheClientNotifier.getClientProxy(clientProxyMembershipID)).thenReturn(cacheClientProxy);\n \n     CompletableFuture<Void> addEventsToQueueTask = CompletableFuture.runAsync(() -> {\n-      for (int count = 0; count < 1_000; ++count) { // was 100_000\n+      for (int numAdds = 0; numAdds < 100000; ++numAdds) {\n         // In thread one, we add events to the queue\n-        clientRegistrationEventQueueManager.add(entryEventImpl(),\n-            mock(ClientUpdateMessageImpl.class), mock(Conflatable.class), emptySet(),\n-            cacheClientNotifier);\n+        clientRegistrationEventQueueManager\n+            .add(internalCacheEvent, conflatable, filterClientIDs, cacheClientNotifier);\n       }\n     });\n \n     CompletableFuture<Void> drainEventsFromQueueTask = CompletableFuture.runAsync(() -> {\n       // In thread two, we drain events from the queue\n-      clientRegistrationEventQueueManager.drain(clientRegistrationEventQueue,\n-          cacheClientNotifier);\n+      clientRegistrationEventQueueManager.drain(clientRegistrationEventQueue, cacheClientNotifier);\n     });\n \n-    CompletableFuture\n-        .allOf(addEventsToQueueTask, drainEventsFromQueueTask)\n-        .get();\n+    CompletableFuture.allOf(addEventsToQueueTask, drainEventsFromQueueTask).get();\n \n     assertThat(clientRegistrationEventQueue.isEmpty()).isTrue();\n   }\n \n   @Test\n   public void addEventWithOffheapValueCopiedToHeap() {\n-    // this test requires mock of EntryEventImpl instead of InternalCacheEvent\n-    EntryEventImpl entryEventImpl = mock(EntryEventImpl.class);\n+    EntryEventImpl internalCacheEvent = mock(EntryEventImpl.class);\n+    when(internalCacheEvent.getRegion()).thenReturn(mock(LocalRegion.class));\n+    Operation mockOperation = mock(Operation.class);\n+    when(mockOperation.isEntry()).thenReturn(true);\n+    when(internalCacheEvent.getOperation()).thenReturn(mockOperation);\n \n-    when(entryEventImpl.getOperation())\n-        .thenReturn(operation);\n-    when(operation.isEntry())\n-        .thenReturn(true);\n+    Conflatable conflatable = mock(Conflatable.class);\n+    Set<ClientProxyMembershipID> filterClientIDs = new HashSet<>();\n+    CacheClientNotifier cacheClientNotifier = mock(CacheClientNotifier.class);\n+    ClientProxyMembershipID clientProxyMembershipID = mock(ClientProxyMembershipID.class);\n \n     ClientRegistrationEventQueueManager clientRegistrationEventQueueManager =\n         new ClientRegistrationEventQueueManager();\n \n-    clientRegistrationEventQueueManager.create(mock(ClientProxyMembershipID.class),\n+    clientRegistrationEventQueueManager.create(clientProxyMembershipID,\n         new ConcurrentLinkedQueue<>(), new ReentrantReadWriteLock());\n \n-    clientRegistrationEventQueueManager.add(entryEventImpl, mock(ClientUpdateMessageImpl.class),\n-        mock(Conflatable.class), emptySet(), mock(CacheClientNotifier.class));\n+    clientRegistrationEventQueueManager\n+        .add(internalCacheEvent, conflatable, filterClientIDs, cacheClientNotifier);\n \n-    verify(entryEventImpl).copyOffHeapToHeap();\n+    verify(internalCacheEvent, times(1)).copyOffHeapToHeap();\n   }\n \n   @Test\n   public void clientWasNeverRegisteredDrainQueueStillRemoved() {\n     ClientRegistrationEventQueueManager clientRegistrationEventQueueManager =\n         new ClientRegistrationEventQueueManager();\n \n-    ClientRegistrationEventQueue clientRegistrationEventQueue =\n-        clientRegistrationEventQueueManager.create(mock(ClientProxyMembershipID.class),\n-            new ConcurrentLinkedQueue<>(), new ReentrantReadWriteLock());\n+    CacheClientNotifier cacheClientNotifier = mock(CacheClientNotifier.class);\n+    ClientProxyMembershipID clientProxyMembershipID = mock(ClientProxyMembershipID.class);\n+\n+    ClientRegistrationEventQueueManager.ClientRegistrationEventQueue clientRegistrationEventQueue =\n+        clientRegistrationEventQueueManager.create(clientProxyMembershipID,\n+            new ConcurrentLinkedQueue<>(),\n+            new ReentrantReadWriteLock());\n \n     clientRegistrationEventQueueManager.drain(clientRegistrationEventQueue, cacheClientNotifier);\n \n+    EntryEventImpl internalCacheEvent = mock(EntryEventImpl.class);\n+    Conflatable conflatable = mock(Conflatable.class);\n+    Set<ClientProxyMembershipID> filterClientIDs = new HashSet<>();\n+\n     // Pass a new event to the ClientRegistrationEventQueueManager. This event should not be added\n     // to the test client's registration queue, because it should already be removed. We can\n     // validate that by asserting that the client's registration queue is empty after the add.\n-    clientRegistrationEventQueueManager.add(mock(InternalCacheEvent.class),\n-        mock(ClientUpdateMessageImpl.class), mock(Conflatable.class), emptySet(),\n+    clientRegistrationEventQueueManager.add(internalCacheEvent, conflatable, filterClientIDs,\n         cacheClientNotifier);\n \n     assertThat(clientRegistrationEventQueue.isEmpty()).isTrue();\n   }\n \n   @Test\n   public void drainThrowsExceptionQueueStillRemoved() {\n-    // this test requires mock of EntryEventImpl instead of InternalCacheEvent\n-    EntryEventImpl entryEventImpl = mock(EntryEventImpl.class);\n-    RuntimeException thrownException = new RuntimeException(\"thrownException\");\n-\n-    when(cacheClientNotifier.getClientProxy(clientProxyMembershipId))\n-        .thenReturn(mock(CacheClientProxy.class));\n-    when(entryEventImpl.getOperation())\n-        .thenReturn(operation);\n-    when(entryEventImpl.getRegion())\n-        .thenThrow(thrownException);\n-    when(operation.isEntry())\n-        .thenReturn(true);\n+    CacheClientProxy cacheClientProxy = mock(CacheClientProxy.class);\n+    CacheClientNotifier cacheClientNotifier = mock(CacheClientNotifier.class);\n+    ClientProxyMembershipID clientProxyMembershipID = mock(ClientProxyMembershipID.class);\n+    when(cacheClientNotifier.getClientProxy(clientProxyMembershipID)).thenReturn(cacheClientProxy);\n \n     ClientRegistrationEventQueueManager clientRegistrationEventQueueManager =\n         new ClientRegistrationEventQueueManager();\n \n-    ClientRegistrationEventQueue clientRegistrationEventQueue =\n-        clientRegistrationEventQueueManager.create(clientProxyMembershipId,\n-            new ConcurrentLinkedQueue<>(), new ReentrantReadWriteLock());\n+    ClientRegistrationEventQueueManager.ClientRegistrationEventQueue clientRegistrationEventQueue =\n+        clientRegistrationEventQueueManager.create(clientProxyMembershipID,\n+            new ConcurrentLinkedQueue<>(),\n+            new ReentrantReadWriteLock());\n \n-    Set<ClientProxyMembershipID> filterClientIds = new HashSet<>();\n+    Conflatable conflatable = mock(Conflatable.class);\n+    Set<ClientProxyMembershipID> filterClientIDs = new HashSet<>();\n \n-    clientRegistrationEventQueueManager.add(entryEventImpl, clientUpdateMessage,\n-        mock(Conflatable.class), filterClientIds, cacheClientNotifier);\n+    EntryEventImpl internalCacheEvent = mock(EntryEventImpl.class);\n+    RuntimeException testException = new RuntimeException();\n+    when(internalCacheEvent.getRegion()).thenThrow(testException);\n+    Operation mockOperation = mock(Operation.class);\n+    when(mockOperation.isEntry()).thenReturn(true);\n+    when(internalCacheEvent.getOperation()).thenReturn(mockOperation);\n \n-    Throwable thrown = catchThrowable(() -> {\n-      clientRegistrationEventQueueManager.drain(clientRegistrationEventQueue, cacheClientNotifier);\n-    });\n+    clientRegistrationEventQueueManager.add(internalCacheEvent, conflatable, filterClientIDs,\n+        cacheClientNotifier);\n \n-    assertThat(thrown).isSameAs(thrownException);\n+    assertThatThrownBy(() -> clientRegistrationEventQueueManager.drain(clientRegistrationEventQueue,\n+        cacheClientNotifier))\n+            .isEqualTo(testException);\n \n     // Pass a new event to the ClientRegistrationEventQueueManager. This event should not be added\n     // to the test client's registration queue, because it should already be removed. We can\n     // validate that by asserting that the client's registration queue is empty after the add.\n-    clientRegistrationEventQueueManager.add(entryEventImpl, clientUpdateMessage,\n-        mock(Conflatable.class), filterClientIds, cacheClientNotifier);\n+    clientRegistrationEventQueueManager.add(internalCacheEvent, conflatable, filterClientIDs,\n+        cacheClientNotifier);\n \n-    assertThat(clientRegistrationEventQueue.isEmpty())\n-        .withFailMessage(clientRegistrationEventQueue + \" should be empty.\")\n-        .isTrue();\n+    assertThat(clientRegistrationEventQueue.isEmpty()).isTrue();\n   }\n \n   @Test\n   public void addEventInOriginalFilterIDsButQueueWasRemovedDueToSuccessfulRegistrationSoEventNotRedelivered() {\n-    // this test requires mock of EntryEventImpl instead of InternalCacheEvent\n-    when(cacheClientNotifier.getClientProxy(clientProxyMembershipId))\n-        .thenReturn(cacheClientProxy);\n-    when(cacheClientNotifier.getFilterClientIDs(internalCacheEvent, filterProfile, filterInfo,\n-        clientUpdateMessage))\n-            .thenReturn(asSet(clientProxyMembershipId));\n-    when(cacheClientProxy.getProxyID())\n-        .thenReturn(clientProxyMembershipId);\n-    when(internalCacheEvent.getRegion())\n-        .thenReturn(internalRegion);\n-    when(filterProfile.getFilterRoutingInfoPart2(null, internalCacheEvent, true))\n+    ClientProxyMembershipID clientProxyMembershipID = mock(ClientProxyMembershipID.class);\n+    CacheClientNotifier cacheClientNotifier = mock(CacheClientNotifier.class);\n+    CacheClientProxy cacheClientProxy = mock(CacheClientProxy.class);\n+    when(cacheClientNotifier.getClientProxy(clientProxyMembershipID)).thenReturn(cacheClientProxy);\n+    Set<ClientProxyMembershipID> originalFilterIDs = new HashSet<>();\n+    originalFilterIDs.add(clientProxyMembershipID);\n+\n+    ClientUpdateMessageImpl clientUpdateMessage = mock(ClientUpdateMessageImpl.class);\n+\n+    InternalCacheEvent internalCacheEvent = mock(InternalCacheEvent.class);\n+    LocalRegion localRegion = mock(LocalRegion.class);\n+    FilterProfile filterProfile = mock(FilterProfile.class);\n+    FilterRoutingInfo filterRoutingInfo = mock(FilterRoutingInfo.class);\n+    FilterRoutingInfo.FilterInfo filterInfo = mock(FilterRoutingInfo.FilterInfo.class);\n+\n+    when(filterRoutingInfo.getLocalFilterInfo()).thenReturn(\n+        filterInfo);\n+    when(filterProfile.getFilterRoutingInfoPart2(null, internalCacheEvent))\n         .thenReturn(filterRoutingInfo);\n-    when(filterRoutingInfo.getLocalFilterInfo())\n-        .thenReturn(filterInfo);\n-    when(internalRegion.getFilterProfile())\n-        .thenReturn(filterProfile);\n-\n-    ReentrantReadWriteLock readWriteLock = spy(new ReentrantReadWriteLock());\n-    ReadLock readLock = spy(readWriteLock.readLock());\n+    when(localRegion.getFilterProfile()).thenReturn(filterProfile);\n+    when(internalCacheEvent.getRegion()).thenReturn(localRegion);\n+    when(internalCacheEvent.getOperation()).thenReturn(mock(Operation.class));\n \n-    when(readWriteLock.readLock())\n-        .thenReturn(readLock);\n+    Set<ClientProxyMembershipID> recalculatedFilterClientIDs = new HashSet<>();\n+    recalculatedFilterClientIDs.add(clientProxyMembershipID);\n+    when(cacheClientNotifier.getFilterClientIDs(internalCacheEvent, filterProfile, filterInfo,\n+        clientUpdateMessage))\n+            .thenReturn(recalculatedFilterClientIDs);\n+    when(cacheClientProxy.getProxyID()).thenReturn(clientProxyMembershipID);\n+    when(cacheClientNotifier.getClientProxy(clientProxyMembershipID)).thenReturn(cacheClientProxy);\n+    ReentrantReadWriteLock mockReadWriteLock = mock(ReentrantReadWriteLock.class);\n \n     ClientRegistrationEventQueueManager clientRegistrationEventQueueManager =\n         new ClientRegistrationEventQueueManager();\n \n-    ClientRegistrationEventQueue clientRegistrationEventQueue =\n-        clientRegistrationEventQueueManager.create(clientProxyMembershipId,\n-            new ConcurrentLinkedQueue<>(), readWriteLock);\n+    ClientRegistrationEventQueueManager.ClientRegistrationEventQueue clientRegistrationEventQueue =\n+        clientRegistrationEventQueueManager.create(clientProxyMembershipID,\n+            new ConcurrentLinkedQueue<>(),\n+            mockReadWriteLock);\n \n-    doAnswer((Answer<Void>) invocation -> {\n+    ReentrantReadWriteLock.ReadLock mockReadLock = mock(ReentrantReadWriteLock.ReadLock.class);\n+    when(mockReadWriteLock.readLock()).thenReturn(mockReadLock);\n+    ReentrantReadWriteLock actualPutDrainLock = new ReentrantReadWriteLock();\n+    when(mockReadWriteLock.writeLock()).thenReturn(actualPutDrainLock.writeLock());\n+    doAnswer(i -> {\n       clientRegistrationEventQueueManager.drain(clientRegistrationEventQueue, cacheClientNotifier);\n-      invocation.callRealMethod();\n+      actualPutDrainLock.readLock();\n       return null;\n-    })\n-        .when(readLock)\n-        .lock();\n+    }).when(mockReadLock).lock();\n \n     clientRegistrationEventQueueManager.add(internalCacheEvent, clientUpdateMessage,\n-        clientUpdateMessage, asSet(clientProxyMembershipId), cacheClientNotifier);\n-\n-    verify(cacheClientProxy, never()).deliverMessage(clientUpdateMessage);\n-  }\n-\n-  @Test\n-  public void addEventWithClientTombstoneDoesNotExportNewValue() {\n-    ClientTombstoneMessage clientTombstoneMessage = mock(ClientTombstoneMessage.class);\n-    // this test requires mock of EntryEventImpl instead of InternalCacheEvent\n-    EntryEventImpl entryEventImpl = mock(EntryEventImpl.class);\n-\n-    ClientRegistrationEventQueueManager clientRegistrationEventQueueManager =\n-        new ClientRegistrationEventQueueManager();\n-\n-    clientRegistrationEventQueueManager.add(entryEventImpl, clientTombstoneMessage,\n-        clientTombstoneMessage, asSet(mock(ClientProxyMembershipID.class)),\n-        mock(CacheClientNotifier.class));\n-\n-    verify(entryEventImpl, never()).exportNewValue(clientTombstoneMessage);\n-  }\n-\n-  private EntryEventImpl entryEventImpl() {\n-    EntryEventImpl entryEventImpl = mock(EntryEventImpl.class);\n-    Operation operation = operation();\n-\n-    when(entryEventImpl.getOperation())\n-        .thenReturn(operation);\n-    when(entryEventImpl.getRegion())\n-        .thenReturn(internalRegion);\n-\n-    return entryEventImpl;\n-  }\n-\n-  private Operation operation() {\n-    Operation operation = mock(Operation.class);\n-\n-    when(operation.isEntry())\n-        .thenReturn(true);\n+        originalFilterIDs, cacheClientNotifier);\n \n-    return operation;\n+    verify(cacheClientProxy, times(0)).deliverMessage(clientUpdateMessage);\n   }\n }"
  },
  {
    "sha": "be95b1853e702a0af4fde0cf49988a800cdc7d87",
    "filename": "geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/dunit/PartitionedRegionTxDUnitTest.java",
    "status": "added",
    "additions": 241,
    "deletions": 0,
    "changes": 241,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/dunit/PartitionedRegionTxDUnitTest.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/dunit/PartitionedRegionTxDUnitTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-cq/src/distributedTest/java/org/apache/geode/cache/query/cq/dunit/PartitionedRegionTxDUnitTest.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.cache.query.cq.dunit;\n+\n+\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.Serializable;\n+import java.util.Properties;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import org.apache.geode.cache.InterestResultPolicy;\n+import org.apache.geode.cache.PartitionAttributesFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientRegionShortcut;\n+import org.apache.geode.cache.query.CqAttributes;\n+import org.apache.geode.cache.query.CqAttributesFactory;\n+import org.apache.geode.cache.query.CqEvent;\n+import org.apache.geode.cache.query.CqListener;\n+import org.apache.geode.cache.query.QueryService;\n+import org.apache.geode.cache.query.SelectResults;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.cache.TXManagerImpl;\n+import org.apache.geode.internal.cache.TXState;\n+import org.apache.geode.internal.cache.TXStateInterface;\n+import org.apache.geode.internal.cache.TXStateProxyImpl;\n+import org.apache.geode.security.query.TestCqListener;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.AsyncInvocation;\n+import org.apache.geode.test.dunit.DUnitBlackboard;\n+import org.apache.geode.test.dunit.rules.ClientVM;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.dunit.rules.MemberVM;\n+import org.apache.geode.test.junit.categories.ClientSubscriptionTest;\n+\n+@Category(ClientSubscriptionTest.class)\n+public class PartitionedRegionTxDUnitTest implements Serializable {\n+  private static volatile DUnitBlackboard blackboard;\n+\n+  @Rule\n+  public ClusterStartupRule clusterStartupRule = new ClusterStartupRule();\n+\n+  @Test\n+  public void eventsAreGeneratedWhenCQsAreRegisteredDuringCommit() throws Exception {\n+    getBlackboard().setMailbox(\"CqQueryResultCount\", 0);\n+    getBlackboard().setMailbox(\"CqEvents\", 0);\n+\n+    String REGION_NAME = \"region\";\n+    MemberVM locator = clusterStartupRule.startLocatorVM(0, new Properties());\n+    MemberVM server1 = clusterStartupRule.startServerVM(1, locator.getPort());\n+    ClientVM client =\n+        clusterStartupRule.startClientVM(3, c -> c.withLocatorConnection(locator.getPort())\n+            .withCacheSetup(\n+                cf -> cf.setPoolSubscriptionEnabled(true).setPoolSubscriptionRedundancy(1)));\n+\n+    MemberVM server2 = clusterStartupRule.startServerVM(2, locator.getPort());\n+\n+    server1.invoke(() -> {\n+      InternalCache cache = ClusterStartupRule.getCache();\n+      Region region = cache.createRegionFactory(RegionShortcut.PARTITION).setPartitionAttributes(\n+          new PartitionAttributesFactory().setRedundantCopies(1).setTotalNumBuckets(1).create())\n+          .create(REGION_NAME);\n+\n+      // Force primary bucket to get created.\n+      region.put(\"Key-1\", \"value-1\");\n+      region.destroy(\"Key-1\");\n+    });\n+\n+    server2.invoke(() -> {\n+      InternalCache cache = ClusterStartupRule.getCache();\n+      cache.createRegionFactory(RegionShortcut.PARTITION).setPartitionAttributes(\n+          new PartitionAttributesFactory().setRedundantCopies(1).setTotalNumBuckets(1).create())\n+          .create(REGION_NAME);\n+    });\n+\n+    AsyncInvocation serverAsync = server1.invokeAsync(() -> {\n+      InternalCache cache = ClusterStartupRule.getCache();\n+      TXManagerImpl txManager = (TXManagerImpl) cache.getCacheTransactionManager();\n+      txManager.begin();\n+\n+      TXStateInterface txState =\n+          ((TXStateProxyImpl) txManager.getTXState()).getRealDeal(null, null);\n+\n+      ((TXState) txState).setDuringApplyChanges(() -> {\n+        try {\n+          getBlackboard().signalGate(\"StartCQ\");\n+          getBlackboard().waitForGate(\"EndCQ\");\n+        } catch (TimeoutException e) {\n+          e.printStackTrace();\n+        } catch (InterruptedException e) {\n+          e.printStackTrace();\n+        }\n+      });\n+\n+      cache.getRegion(REGION_NAME).put(\"Key-1\", \"value-1\");\n+      txManager.commit();\n+\n+      txManager.begin();\n+      cache.getRegion(REGION_NAME).destroy(\"Key-1\");\n+      txManager.commit();\n+    });\n+\n+    client.invoke(() -> {\n+      ClientCache clientCache = ClusterStartupRule.getClientCache();\n+      clientCache.createClientRegionFactory(ClientRegionShortcut.CACHING_PROXY).create(REGION_NAME);\n+\n+      QueryService queryService = clientCache.getQueryService();\n+      CqAttributesFactory cqaf = new CqAttributesFactory();\n+      TestCqListener testListener = new TestCqListener();\n+      cqaf.addCqListener(testListener);\n+      CqAttributes cqAttributes = cqaf.create();\n+\n+      getBlackboard().waitForGate(\"StartCQ\");\n+      SelectResults cqResults = queryService\n+          .newCq(\"Select * from \" + SEPARATOR + REGION_NAME, cqAttributes)\n+          .executeWithInitialResults();\n+      getBlackboard().signalGate(\"EndCQ\");\n+      getBlackboard().setMailbox(\"CqQueryResultCount\", new Integer(cqResults.asList().size()));\n+    });\n+\n+    GeodeAwaitility.await().untilAsserted(() -> {\n+      Integer CqQueryResultCount = getBlackboard().getMailbox(\"CqQueryResultCount\");\n+      Integer CqEvents = getBlackboard().getMailbox(\"CqEvents\");\n+      assertThat(CqQueryResultCount + CqEvents).isEqualTo(2);\n+    });\n+\n+    serverAsync.await();\n+  }\n+\n+\n+  @Test\n+  public void interestsAreProcessedOnPrimaryNode() throws Exception {\n+    getBlackboard().setMailbox(\"CqQueryResultCount\", 0);\n+    getBlackboard().setMailbox(\"CqEvents\", 0);\n+\n+    String REGION_NAME = \"region\";\n+    MemberVM locator = clusterStartupRule.startLocatorVM(0, new Properties());\n+    MemberVM server1 = clusterStartupRule.startServerVM(1, locator.getPort());\n+    MemberVM server2 = clusterStartupRule.startServerVM(2, locator.getPort());\n+    ClientVM client = clusterStartupRule.startClientVM(3,\n+        cacheRule -> cacheRule.withServerConnection(server2.getPort()).withPoolSubscription(true));\n+\n+    server1.invoke(() -> {\n+      InternalCache cache = ClusterStartupRule.getCache();\n+      Region region = cache.createRegionFactory(RegionShortcut.PARTITION).setPartitionAttributes(\n+          new PartitionAttributesFactory().setRedundantCopies(1).setTotalNumBuckets(1).create())\n+          .create(REGION_NAME);\n+\n+      // Force primary bucket to get created.\n+      region.put(\"Key-1\", \"value-1\");\n+      region.destroy(\"Key-1\");\n+    });\n+\n+    server2.invoke(() -> {\n+      InternalCache cache = ClusterStartupRule.getCache();\n+      cache.createRegionFactory(RegionShortcut.PARTITION).setPartitionAttributes(\n+          new PartitionAttributesFactory().setRedundantCopies(1).setTotalNumBuckets(1).create())\n+          .create(REGION_NAME);\n+    });\n+\n+    AsyncInvocation serverAsync = server1.invokeAsync(() -> {\n+      InternalCache cache = ClusterStartupRule.getCache();\n+      TXManagerImpl txManager = (TXManagerImpl) cache.getCacheTransactionManager();\n+      txManager.begin();\n+\n+      TXStateInterface txState =\n+          ((TXStateProxyImpl) txManager.getTXState()).getRealDeal(null, null);\n+\n+      ((TXState) txState).setDuringApplyChanges(() -> {\n+        try {\n+          getBlackboard().signalGate(\"StartReg\");\n+          getBlackboard().waitForGate(\"EndReg\");\n+        } catch (TimeoutException e) {\n+          e.printStackTrace();\n+        } catch (InterruptedException e) {\n+          e.printStackTrace();\n+        }\n+      });\n+\n+      cache.getRegion(REGION_NAME).put(\"Key-5\", \"value-1\");\n+      txManager.commit();\n+    });\n+\n+    client.invoke(() -> {\n+      ClientCache clientCache = ClusterStartupRule.getClientCache();\n+      Region region = clientCache.createClientRegionFactory(ClientRegionShortcut.CACHING_PROXY)\n+          .create(REGION_NAME);\n+      getBlackboard().waitForGate(\"StartReg\");\n+      region.registerInterest(\"Key-5\", InterestResultPolicy.KEYS_VALUES);\n+      region.registerInterest(\"Key-6\", InterestResultPolicy.KEYS_VALUES);\n+      getBlackboard().signalGate(\"EndReg\");\n+\n+      GeodeAwaitility.await().untilAsserted(() -> {\n+        assertThat(region.size()).isEqualTo(1);\n+      });\n+\n+    });\n+\n+    serverAsync.await();\n+  }\n+\n+  private class TestCqListener implements CqListener, Serializable {\n+\n+    int numEvents = 0;\n+\n+    @Override\n+    public void onEvent(CqEvent aCqEvent) {\n+      numEvents++;\n+      getBlackboard().setMailbox(\"CqEvents\", new Integer(numEvents));\n+    }\n+\n+    @Override\n+    public void onError(CqEvent aCqEvent) {}\n+  }\n+\n+  private static DUnitBlackboard getBlackboard() {\n+    if (blackboard == null) {\n+      blackboard = new DUnitBlackboard();\n+    }\n+    return blackboard;\n+  }\n+}"
  },
  {
    "sha": "517c31692b575bceca8813864b130120e86592cb",
    "filename": "geode-cq/src/distributedTest/java/org/apache/geode/internal/cache/RemoteCQTransactionDUnitTest.java",
    "status": "modified",
    "additions": 143,
    "deletions": 167,
    "changes": 310,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-cq/src/distributedTest/java/org/apache/geode/internal/cache/RemoteCQTransactionDUnitTest.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-cq/src/distributedTest/java/org/apache/geode/internal/cache/RemoteCQTransactionDUnitTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-cq/src/distributedTest/java/org/apache/geode/internal/cache/RemoteCQTransactionDUnitTest.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -17,7 +17,6 @@\n import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;\n import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPort;\n import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n-import static org.assertj.core.api.Assertions.assertThat;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n@@ -27,7 +26,6 @@\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.Set;\n-import java.util.concurrent.TimeUnit;\n \n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n@@ -59,7 +57,6 @@\n import org.apache.geode.cache.query.CqAttributesFactory;\n import org.apache.geode.cache.query.CqEvent;\n import org.apache.geode.cache.query.CqListener;\n-import org.apache.geode.cache.query.CqQuery;\n import org.apache.geode.cache.server.CacheServer;\n import org.apache.geode.cache.util.CacheListenerAdapter;\n import org.apache.geode.cache.util.CacheWriterAdapter;\n@@ -69,7 +66,7 @@\n import org.apache.geode.internal.cache.execute.data.Customer;\n import org.apache.geode.internal.cache.execute.data.Order;\n import org.apache.geode.internal.cache.execute.data.OrderId;\n-import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.Host;\n import org.apache.geode.test.dunit.Invoke;\n import org.apache.geode.test.dunit.LogWriterUtils;\n import org.apache.geode.test.dunit.SerializableCallable;\n@@ -79,15 +76,13 @@\n \n @Category({ClientSubscriptionTest.class})\n public class RemoteCQTransactionDUnitTest extends JUnit4CacheTestCase {\n-  private final VM accessor = VM.getVM(0);\n-  private final VM dataStore = VM.getVM(1);\n-  private final VM client = VM.getVM(2);\n-  private final CustId expectedCustId = new CustId(6);\n-  private final Customer expectedCustomer = new Customer(\"customer6\", \"address6\");\n \n-  private static final String CUSTOMER = \"custRegion\";\n-  private static final String ORDER = \"orderRegion\";\n-  private static final String D_REFERENCE = \"distrReference\";\n+  protected final String CUSTOMER = \"custRegion\";\n+  protected final String ORDER = \"orderRegion\";\n+  protected final String D_REFERENCE = \"distrReference\";\n+\n+  final CustId expectedCustId = new CustId(6);\n+  final Customer expectedCustomer = new Customer(\"customer6\", \"address6\");\n \n   private final SerializableCallable getNumberOfTXInProgress = new SerializableCallable() {\n     @Override\n@@ -161,7 +156,7 @@ void populateData() {\n     }\n   }\n \n-  protected void initAccessorAndDataStore(VM accessor, VM dataStore, final int redundantCopies) {\n+  protected void initAccessorAndDataStore(VM accessor, VM datastore, final int redundantCopies) {\n     accessor.invoke(new SerializableCallable() {\n       @Override\n       public Object call() throws Exception {\n@@ -170,7 +165,7 @@ public Object call() throws Exception {\n       }\n     });\n \n-    dataStore.invoke(new SerializableCallable() {\n+    datastore.invoke(new SerializableCallable() {\n       @Override\n       public Object call() throws Exception {\n         createRegion(false/* accessor */, redundantCopies, null);\n@@ -180,30 +175,30 @@ public Object call() throws Exception {\n     });\n   }\n \n-  protected void initAccessorAndDataStore(VM accessor, VM dataStore1, VM dataStore2,\n+  protected void initAccessorAndDataStore(VM accessor, VM datastore1, VM datastore2,\n       final int redundantCopies) {\n-    dataStore2.invoke(new SerializableCallable() {\n+    datastore2.invoke(new SerializableCallable() {\n       @Override\n       public Object call() throws Exception {\n         createRegion(false/* accessor */, redundantCopies, null);\n         return null;\n       }\n     });\n \n-    initAccessorAndDataStore(accessor, dataStore1, redundantCopies);\n+    initAccessorAndDataStore(accessor, datastore1, redundantCopies);\n   }\n \n-  private void initAccessorAndDataStoreWithInterestPolicy(VM accessor, VM dataStore1, VM dataStore2,\n+  private void initAccessorAndDataStoreWithInterestPolicy(VM accessor, VM datastore1, VM datastore2,\n       final int redundantCopies) {\n-    dataStore2.invoke(new SerializableCallable() {\n+    datastore2.invoke(new SerializableCallable() {\n       @Override\n       public Object call() throws Exception {\n         createRegion(false/* accessor */, redundantCopies, InterestPolicy.ALL);\n         return null;\n       }\n     });\n \n-    initAccessorAndDataStore(accessor, dataStore1, redundantCopies);\n+    initAccessorAndDataStore(accessor, datastore1, redundantCopies);\n   }\n \n \n@@ -815,13 +810,11 @@ public void close() {}\n     int invokeCount = 0;\n     int invalidateCount = 0;\n     int putCount = 0;\n-    int destroyCount = 0;\n     boolean putAllOp = false;\n     boolean isOriginRemote = false;\n     int creates;\n     int updates;\n \n-\n     @Override\n     public void afterCreate(EntryEvent event) {\n       event.getRegion().getCache().getLogger().warning(\"ZZZ AFTER CREATE:\" + event.getKey());\n@@ -856,15 +849,6 @@ public void afterInvalidate(EntryEvent event) {\n       isOriginRemote = event.isOriginRemote();\n     }\n \n-    @Override\n-    public void afterDestroy(EntryEvent event) {\n-      event.getRegion().getCache().getLogger().warning(\"ZZZ AFTER DESTROY:\" + event.getKey());\n-      invoked = true;\n-      invokeCount++;\n-      destroyCount++;\n-      isOriginRemote = event.isOriginRemote();\n-    }\n-\n     public void reset() {\n       invoked = false;\n       invokeCount = 0;\n@@ -907,11 +891,16 @@ public void afterInvalidate(EntryEvent event) {\n \n   @Test\n   public void testTXWithCQCommitInDatastoreCQ() throws Exception {\n-    initAccessorAndDataStore(accessor, dataStore, 0);\n-    int port = startServer(dataStore);\n+    Host host = Host.getHost(0);\n+    VM accessor = host.getVM(0);\n+    VM datastore = host.getVM(1);\n+    VM client = host.getVM(2);\n+\n+    initAccessorAndDataStore(accessor, datastore, 0);\n+    int port = startServer(datastore);\n \n     createClientRegion(client, port, false, true, true);\n-    dataStore.invoke(new SerializableCallable() {\n+    datastore.invoke(new SerializableCallable() {\n       @Override\n       public Object call() throws Exception {\n         Region<CustId, Customer> custRegion = getCache().getRegion(CUSTOMER);\n@@ -928,16 +917,35 @@ public Object call() throws Exception {\n       }\n     });\n \n-    client.invoke(this::verifyCustomerRegion);\n+    Thread.sleep(10000);\n+    client.invoke(new SerializableCallable() {\n+      @Override\n+      public Object call() throws Exception {\n+        Region<CustId, Customer> custRegion = getCache().getRegion(CUSTOMER);\n+        Region<OrderId, Order> orderRegion = getCache().getRegion(ORDER);\n+        Region<CustId, Customer> refRegion = getCache().getRegion(D_REFERENCE);\n+        ClientListener cl = (ClientListener) custRegion.getAttributes().getCacheListeners()[0];\n+\n+        assertTrue(((ClientCQListener) custRegion.getCache().getQueryService().getCqs()[0]\n+            .getCqAttributes().getCqListener()).invoked);\n+        assertTrue(cl.invoked);\n+        return null;\n+      }\n+    });\n   }\n \n   @Test\n   public void testTXWithCQCommitInDatastoreConnectedToAccessorCQ() throws Exception {\n-    initAccessorAndDataStore(accessor, dataStore, 0);\n+    Host host = Host.getHost(0);\n+    VM accessor = host.getVM(0);\n+    VM datastore = host.getVM(1);\n+    VM client = host.getVM(2);\n+\n+    initAccessorAndDataStore(accessor, datastore, 0);\n     int port = startServer(accessor);\n \n     createClientRegion(client, port, false, true, true);\n-    dataStore.invoke(new SerializableCallable() {\n+    datastore.invoke(new SerializableCallable() {\n       @Override\n       public Object call() throws Exception {\n         Region<CustId, Customer> custRegion = getCache().getRegion(CUSTOMER);\n@@ -952,16 +960,34 @@ public Object call() throws Exception {\n       }\n     });\n \n-    client.invoke(this::verifyCustomerRegion);\n+    Thread.sleep(10000);\n+    client.invoke(new SerializableCallable() {\n+      @Override\n+      public Object call() throws Exception {\n+        Region<CustId, Customer> custRegion = getCache().getRegion(CUSTOMER);\n+        Region<OrderId, Order> orderRegion = getCache().getRegion(ORDER);\n+        Region<CustId, Customer> refRegion = getCache().getRegion(D_REFERENCE);\n+        ClientListener cl = (ClientListener) custRegion.getAttributes().getCacheListeners()[0];\n+        assertTrue(cl.invoked);\n+        assertTrue(((ClientCQListener) custRegion.getCache().getQueryService().getCqs()[0]\n+            .getCqAttributes().getCqListener()).invoked);\n+        return null;\n+      }\n+    });\n   }\n \n   @Test\n   public void testTXWithCQCommitInDatastoreConnectedToDatastoreCQ() throws Exception {\n-    initAccessorAndDataStore(accessor, dataStore, 0);\n-    int port = startServer(dataStore);\n+    Host host = Host.getHost(0);\n+    VM accessor = host.getVM(0);\n+    VM datastore = host.getVM(1);\n+    VM client = host.getVM(2);\n+\n+    initAccessorAndDataStore(accessor, datastore, 0);\n+    int port = startServer(datastore);\n \n     createClientRegion(client, port, false, true, true);\n-    dataStore.invoke(new SerializableCallable() {\n+    datastore.invoke(new SerializableCallable() {\n       @Override\n       public Object call() throws Exception {\n         Region<CustId, Customer> custRegion = getCache().getRegion(CUSTOMER);\n@@ -976,13 +1002,31 @@ public Object call() throws Exception {\n       }\n     });\n \n-    client.invoke(this::verifyCustomerRegion);\n+    Thread.sleep(10000);\n+    client.invoke(new SerializableCallable() {\n+      @Override\n+      public Object call() throws Exception {\n+        Region<CustId, Customer> custRegion = getCache().getRegion(CUSTOMER);\n+        Region<OrderId, Order> orderRegion = getCache().getRegion(ORDER);\n+        Region<CustId, Customer> refRegion = getCache().getRegion(D_REFERENCE);\n+        ClientListener cl = (ClientListener) custRegion.getAttributes().getCacheListeners()[0];\n+        assertTrue(cl.invoked);\n+        assertTrue(((ClientCQListener) custRegion.getCache().getQueryService().getCqs()[0]\n+            .getCqAttributes().getCqListener()).invoked);\n+        return null;\n+      }\n+    });\n   }\n \n   @Test\n   public void testTXWithCQCommitInAccessorConnectedToDatastoreCQ() throws Exception {\n-    initAccessorAndDataStore(accessor, dataStore, 0);\n-    int port = startServer(dataStore);\n+    Host host = Host.getHost(0);\n+    VM accessor = host.getVM(0);\n+    VM datastore = host.getVM(1);\n+    VM client = host.getVM(2);\n+\n+    initAccessorAndDataStore(accessor, datastore, 0);\n+    int port = startServer(datastore);\n \n     createClientRegion(client, port, false, true, true);\n     accessor.invoke(new SerializableCallable() {\n@@ -1000,12 +1044,30 @@ public Object call() throws Exception {\n       }\n     });\n \n-    client.invoke(this::verifyCustomerRegion);\n+    Thread.sleep(10000);\n+    client.invoke(new SerializableCallable() {\n+      @Override\n+      public Object call() throws Exception {\n+        Region<CustId, Customer> custRegion = getCache().getRegion(CUSTOMER);\n+        Region<OrderId, Order> orderRegion = getCache().getRegion(ORDER);\n+        Region<CustId, Customer> refRegion = getCache().getRegion(D_REFERENCE);\n+        ClientListener cl = (ClientListener) custRegion.getAttributes().getCacheListeners()[0];\n+        assertTrue(cl.invoked);\n+        assertTrue(((ClientCQListener) custRegion.getCache().getQueryService().getCqs()[0]\n+            .getCqAttributes().getCqListener()).invoked);\n+        return null;\n+      }\n+    });\n   }\n \n   @Test\n   public void testTXWithCQCommitInAccessorConnectedToAccessorCQ() throws Exception {\n-    initAccessorAndDataStore(accessor, dataStore, 0);\n+    Host host = Host.getHost(0);\n+    VM accessor = host.getVM(0);\n+    VM datastore = host.getVM(1);\n+    VM client = host.getVM(2);\n+\n+    initAccessorAndDataStore(accessor, datastore, 0);\n     int port = startServer(accessor);\n \n     createClientRegion(client, port, false, true, true);\n@@ -1024,16 +1086,34 @@ public Object call() throws Exception {\n       }\n     });\n \n-    client.invoke(this::verifyCustomerRegion);\n+    Thread.sleep(10000);\n+    client.invoke(new SerializableCallable() {\n+      @Override\n+      public Object call() throws Exception {\n+        Region<CustId, Customer> custRegion = getCache().getRegion(CUSTOMER);\n+        Region<OrderId, Order> orderRegion = getCache().getRegion(ORDER);\n+        Region<CustId, Customer> refRegion = getCache().getRegion(D_REFERENCE);\n+        ClientListener cl = (ClientListener) custRegion.getAttributes().getCacheListeners()[0];\n+        assertTrue(cl.invoked);\n+        assertTrue(((ClientCQListener) custRegion.getCache().getQueryService().getCqs()[0]\n+            .getCqAttributes().getCqListener()).invoked);\n+        return null;\n+      }\n+    });\n   }\n \n   @Test\n   public void testCQCommitInDatastoreConnectedToAccessorCQ() throws Exception {\n-    initAccessorAndDataStore(accessor, dataStore, 0);\n+    Host host = Host.getHost(0);\n+    VM accessor = host.getVM(0);\n+    VM datastore = host.getVM(1);\n+    VM client = host.getVM(2);\n+\n+    initAccessorAndDataStore(accessor, datastore, 0);\n     int port = startServer(accessor);\n \n     createClientRegion(client, port, false, true, true);\n-    dataStore.invoke(new SerializableCallable() {\n+    datastore.invoke(new SerializableCallable() {\n       @Override\n       public Object call() throws Exception {\n         Region<CustId, Customer> custRegion = getCache().getRegion(CUSTOMER);\n@@ -1048,124 +1128,20 @@ public Object call() throws Exception {\n       }\n     });\n \n-    client.invoke(this::verifyCustomerRegion);\n-  }\n-\n-  private void verifyCustomerRegion() {\n-    verifyCustomerRegionListenerInvocation();\n-    verifyCQListenerInvocation();\n-  }\n-\n-  private void verifyCustomerRegionListenerInvocation() {\n-    Region<CustId, Customer> customerRegion = getCache().getRegion(CUSTOMER);\n-    ClientListener customerRegionListener =\n-        (ClientListener) customerRegion.getAttributes().getCacheListeners()[0];\n-    GeodeAwaitility.await()\n-        .untilAsserted(() -> assertThat(customerRegionListener.invoked).isTrue());\n-  }\n-\n-  @Test\n-  public void testCQEntryDestroyCommitInDataStoreConnectedToAccessorCQ() {\n-    doCQWithDelete(false, true);\n-  }\n-\n-  @Test\n-  public void testCQEntryDestroyCommitInAccessorConnectedToAccessorCQ() {\n-    doCQWithDelete(false, false);\n-  }\n-\n-  @Test\n-  public void testCQEntryDestroyCommitInDataStoreConnectedToDataStoreCQ() {\n-    doCQWithDelete(true, true);\n-  }\n-\n-  @Test\n-  public void testCQEntryDestroyCommitInAccessorConnectedToDataStoreCQ() {\n-    doCQWithDelete(true, false);\n-  }\n-\n-  private void doCQWithDelete(boolean startCacheServerOnDataStore,\n-      boolean executeTransactionOnDataStore) {\n-    initAccessorAndDataStore(accessor, dataStore, 0);\n-    int port = startServer(startCacheServerOnDataStore);\n-\n-    createClientRegion(client, port, false, true, true);\n-    client.invoke(this::registerCQForRefRegion);\n-\n-    executeDeleteTransaction(executeTransactionOnDataStore);\n-    client.invoke(this::verify);\n-  }\n-\n-  private int startServer(boolean onDataStore) {\n-    if (onDataStore) {\n-      return startServer(dataStore);\n-    }\n-    return startServer(accessor);\n-  }\n-\n-  private void executeDeleteTransaction(boolean onDataStore) {\n-    if (onDataStore) {\n-      dataStore.invoke(this::doDeleteTransaction);\n-    } else {\n-      accessor.invoke(this::doDeleteTransaction);\n-    }\n-  }\n-\n-  private void registerCQForRefRegion() throws Exception {\n-    CqAttributesFactory cqf = new CqAttributesFactory();\n-    cqf.addCqListener(new ClientCQListener());\n-    CqAttributes ca = cqf.create();\n-    String refRegionPath = getCache().getRegion(D_REFERENCE).getFullPath();\n-    getCache().getQueryService().newCq(\"SELECT * FROM \" + refRegionPath, ca).execute();\n-  }\n-\n-  private void doDeleteTransaction() {\n-    Region<CustId, Customer> customerRegion = getCache().getRegion(CUSTOMER);\n-    Region<OrderId, Order> orderRegion = getCache().getRegion(ORDER);\n-    Region<CustId, Customer> refRegion = getCache().getRegion(D_REFERENCE);\n-    getCache().getCacheTransactionManager().begin();\n-    doDelete(customerRegion, orderRegion, refRegion);\n-    getCache().getCacheTransactionManager().commit();\n-  }\n-\n-  private void doDelete(Region<CustId, Customer> customerRegion, Region<OrderId, Order> orderRegion,\n-      Region<CustId, Customer> refRegion) {\n-    CustId custId = new CustId(1);\n-    OrderId orderId = new OrderId(1, custId);\n-    customerRegion.destroy(custId);\n-    orderRegion.destroy(orderId);\n-    refRegion.destroy(custId);\n-  }\n-\n-  private void verify() {\n-    Region<CustId, Customer> customerRegion = getCache().getRegion(CUSTOMER);\n-    Region<OrderId, Order> orderRegion = getCache().getRegion(ORDER);\n-    Region<CustId, Customer> refRegion = getCache().getRegion(D_REFERENCE);\n-    verifyListenerInvocation(customerRegion, orderRegion, refRegion);\n-    verifyCQListenerInvocation();\n-  }\n-\n-  private void verifyListenerInvocation(Region<CustId, Customer> customerRegion,\n-      Region<OrderId, Order> orderRegion,\n-      Region<CustId, Customer> refRegion) {\n-    ClientListener customerRegionListener =\n-        (ClientListener) customerRegion.getAttributes().getCacheListeners()[0];\n-    ClientListener orderRegionListener =\n-        (ClientListener) orderRegion.getAttributes().getCacheListeners()[0];\n-    ClientListener refRegionListener =\n-        (ClientListener) refRegion.getAttributes().getCacheListeners()[0];\n-    GeodeAwaitility.await()\n-        .untilAsserted(() -> assertThat(customerRegionListener.invoked).isTrue());\n-    GeodeAwaitility.await().untilAsserted(() -> assertThat(orderRegionListener.invoked).isTrue());\n-    GeodeAwaitility.await().untilAsserted(() -> assertThat(refRegionListener.invoked).isTrue());\n+    Thread.sleep(10000);\n+    client.invoke(new SerializableCallable() {\n+      @Override\n+      public Object call() throws Exception {\n+        Region<CustId, Customer> custRegion = getCache().getRegion(CUSTOMER);\n+        Region<OrderId, Order> orderRegion = getCache().getRegion(ORDER);\n+        Region<CustId, Customer> refRegion = getCache().getRegion(D_REFERENCE);\n+        ClientListener cl = (ClientListener) custRegion.getAttributes().getCacheListeners()[0];\n+        assertTrue(cl.invoked);\n+        assertTrue(((ClientCQListener) custRegion.getCache().getQueryService().getCqs()[0]\n+            .getCqAttributes().getCqListener()).invoked);\n+        return null;\n+      }\n+    });\n   }\n \n-  private void verifyCQListenerInvocation() {\n-    CqQuery[] queries = getCache().getQueryService().getCqs();\n-    for (CqQuery query : queries) {\n-      ClientCQListener listener = (ClientCQListener) query.getCqAttributes().getCqListener();\n-      GeodeAwaitility.await().atMost(10, TimeUnit.SECONDS)\n-          .untilAsserted(() -> assertThat(listener.invoked).isTrue());\n-    }\n-  }\n }"
  },
  {
    "sha": "13cd3c9c5556c48568e593c599a9751773458f02",
    "filename": "geode-cq/src/main/java/org/apache/geode/cache/query/cq/internal/CqServiceImpl.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/apache/geode/blob/459cd2d316a88a02a64bb103e3512956b92d8943/geode-cq/src/main/java/org/apache/geode/cache/query/cq/internal/CqServiceImpl.java",
    "raw_url": "https://github.com/apache/geode/raw/459cd2d316a88a02a64bb103e3512956b92d8943/geode-cq/src/main/java/org/apache/geode/cache/query/cq/internal/CqServiceImpl.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-cq/src/main/java/org/apache/geode/cache/query/cq/internal/CqServiceImpl.java?ref=459cd2d316a88a02a64bb103e3512956b92d8943",
    "patch": "@@ -1254,6 +1254,7 @@ private void processRegionEvent(CacheEvent event, Profile localProfile, Profile[\n \n   private void processEntryEvent(CacheEvent event, Profile localProfile, Profile[] profiles,\n       FilterRoutingInfo frInfo) throws CqException {\n+\n     final boolean isDebugEnabled = logger.isDebugEnabled();\n     HashSet<Object> cqUnfilteredEventsSet_newValue = new HashSet<>();\n     HashSet<Object> cqUnfilteredEventsSet_oldValue = new HashSet<>();"
  }
]
