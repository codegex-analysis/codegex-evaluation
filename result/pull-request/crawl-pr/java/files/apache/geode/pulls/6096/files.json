[
  {
    "sha": "e02a86ab9971ccca427a6f5ce507d36366fed925",
    "filename": "geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/INOperatorJUnitTest.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/apache/geode/blob/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/INOperatorJUnitTest.java",
    "raw_url": "https://github.com/apache/geode/raw/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/INOperatorJUnitTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/INOperatorJUnitTest.java?ref=93d344ebf5a8d90e11662f427eb1e2841c728480",
    "patch": "@@ -225,11 +225,11 @@ public void testUNDEFINED() throws Exception {\n \n     q = CacheUtils.getQueryService().newQuery(\" UNDEFINED IN SET(UNDEFINED)\");\n     result = q.execute();\n-    assertThat(result).isEqualTo(QueryService.UNDEFINED);\n+    assertThat(result).isEqualTo(TRUE);\n \n     q = CacheUtils.getQueryService().newQuery(\" UNDEFINED IN SET(UNDEFINED,UNDEFINED)\");\n     result = q.execute();\n-    assertThat(result).isEqualTo(QueryService.UNDEFINED);\n+    assertThat(result).isEqualTo(TRUE);\n   }\n \n   @Test"
  },
  {
    "sha": "219f3c343a0437e702dc728caec5fcd07070fe6f",
    "filename": "geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/IndexOperatorJUnitTest.java",
    "status": "modified",
    "additions": 3,
    "deletions": 4,
    "changes": 7,
    "blob_url": "https://github.com/apache/geode/blob/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/IndexOperatorJUnitTest.java",
    "raw_url": "https://github.com/apache/geode/raw/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/IndexOperatorJUnitTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/IndexOperatorJUnitTest.java?ref=93d344ebf5a8d90e11662f427eb1e2841c728480",
    "patch": "@@ -19,6 +19,7 @@\n  */\n package org.apache.geode.cache.query.functional;\n \n+import static org.assertj.core.api.Assertions.assertThat;\n import static org.junit.Assert.fail;\n \n import java.util.ArrayList;\n@@ -145,8 +146,7 @@ public void testWithNULL() throws Exception {\n     map.put(\"0\", new Integer(11));\n     map.put(\"1\", new Integer(12));\n     Object result = runQuery(map, null);\n-    if (result != null)\n-      fail();\n+    assertThat(result).isEqualTo(QueryService.UNDEFINED);\n   }\n \n   @Test\n@@ -171,8 +171,7 @@ public void testWithUNDEFINED() throws Exception {\n     map.put(\"0\", new Integer(11));\n     map.put(\"1\", new Integer(12));\n     Object result = runQuery(map, QueryService.UNDEFINED);\n-    if (result != null)\n-      fail();\n+    assertThat(result).isEqualTo(QueryService.UNDEFINED);\n   }\n \n   @Test"
  },
  {
    "sha": "a3e5254f55dbaa9a9c424ea1c75d0db23fc564ee",
    "filename": "geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/IndexStatisticsJUnitTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/geode/blob/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/IndexStatisticsJUnitTest.java",
    "raw_url": "https://github.com/apache/geode/raw/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/IndexStatisticsJUnitTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/IndexStatisticsJUnitTest.java?ref=93d344ebf5a8d90e11662f427eb1e2841c728480",
    "patch": "@@ -370,7 +370,7 @@ public void testStatsForCompactMapRangeIndex() throws Exception {\n \n     assertEquals(0, keyIndexStats.getReadLockCount());\n \n-    assertEquals(100, keyIndexStats.getTotalUses());\n+    assertEquals(0, keyIndexStats.getTotalUses());\n \n     for (int i = 0; i < 50; i++) {\n       region.invalidate(Integer.toString(i));"
  },
  {
    "sha": "b0e7508bdacf084ee0a77947278d7c113358fad9",
    "filename": "geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/IndexUseJUnitTest.java",
    "status": "modified",
    "additions": 4,
    "deletions": 3,
    "changes": 7,
    "blob_url": "https://github.com/apache/geode/blob/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/IndexUseJUnitTest.java",
    "raw_url": "https://github.com/apache/geode/raw/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/IndexUseJUnitTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/IndexUseJUnitTest.java?ref=93d344ebf5a8d90e11662f427eb1e2841c728480",
    "patch": "@@ -15,6 +15,7 @@\n package org.apache.geode.cache.query.internal.index;\n \n import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.assertj.core.api.Assertions.assertThat;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n@@ -342,7 +343,7 @@ public void testCompactMapIndexUsageWithIndexOnSingleKey() throws Exception {\n \n     evaluateMapTypeIndexUsage(\"objs.maap['key2']\", SEPARATOR + \"testRgn objs\", queries,\n         queriesIndexNotUsed,\n-        CompactRangeIndex.class);\n+        CompactMapRangeIndex.class);\n \n     String query = \"SELECT DISTINCT * FROM \" + SEPARATOR + \"testRgn itr1  WHERE itr1.liist[0] >= 2\";\n     SelectResults withoutIndex, withIndex;\n@@ -353,7 +354,7 @@ public void testCompactMapIndexUsageWithIndexOnSingleKey() throws Exception {\n \n     Index i2 =\n         qs.createIndex(\"Index2\", IndexType.FUNCTIONAL, \"objs.liist[0]\", SEPARATOR + \"testRgn objs\");\n-    assertTrue(i2 instanceof CompactRangeIndex);\n+    assertThat(i2).isInstanceOf(CompactMapRangeIndex.class);\n     CacheUtils.getLogger().info(\"Executing query: \" + query);\n     QueryObserverImpl observer = new QueryObserverImpl();\n     QueryObserverHolder.setInstance(observer);\n@@ -1196,7 +1197,7 @@ public void testCompactMapIndexUsageManyKeysWithVariousValueTypes() throws Excep\n     Index i5 = qs.createIndex(\"Index5\", IndexType.FUNCTIONAL, \"itr1.testFields['complex']\",\n         SEPARATOR + \"testRgn itr1\");\n \n-    assertTrue(i1 instanceof CompactRangeIndex);\n+    assertThat(i1).isInstanceOf(CompactMapRangeIndex.class);\n \n     // Execute Queries with Indexes\n     for (int i = 0; i < queries.length; i++) {"
  },
  {
    "sha": "f881f7d8bcf6eddd5b8e8b8c432f9deb445ccce0",
    "filename": "geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/MapRangeIndexMaintenanceJUnitTest.java",
    "status": "modified",
    "additions": 153,
    "deletions": 0,
    "changes": 153,
    "blob_url": "https://github.com/apache/geode/blob/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/MapRangeIndexMaintenanceJUnitTest.java",
    "raw_url": "https://github.com/apache/geode/raw/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/MapRangeIndexMaintenanceJUnitTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/MapRangeIndexMaintenanceJUnitTest.java?ref=93d344ebf5a8d90e11662f427eb1e2841c728480",
    "patch": "@@ -15,9 +15,11 @@\n package org.apache.geode.cache.query.internal.index;\n \n import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.assertj.core.api.Assertions.assertThat;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n \n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.HashMap;\n \n@@ -40,6 +42,7 @@\n import org.apache.geode.cache.query.internal.IndexTrackingQueryObserver;\n import org.apache.geode.cache.query.internal.QueryObserverHolder;\n import org.apache.geode.test.junit.categories.OQLIndexTest;\n+import org.apache.geode.util.internal.UncheckedUtils;\n \n @Category({OQLIndexTest.class})\n public class MapRangeIndexMaintenanceJUnitTest {\n@@ -341,6 +344,156 @@ public void testNullMapValuesInIndexOnLocalRegionForCompactMap() throws Exceptio\n     assertEquals(1, result.size());\n   }\n \n+  @Test\n+  public void testQueriesForValueInMapFieldWithoutIndex() throws Exception {\n+    region =\n+        CacheUtils.getCache().createRegionFactory(RegionShortcut.REPLICATE).create(\"portfolio\");\n+    qs = CacheUtils.getQueryService();\n+    testQueriesForValueInMapField(region, qs);\n+  }\n+\n+  @Test\n+  public void testQueriesForValueInMapFieldWithMapIndexWithOneKey() throws Exception {\n+    region =\n+        CacheUtils.getCache().createRegionFactory(RegionShortcut.REPLICATE).create(\"portfolio\");\n+    qs = CacheUtils.getQueryService();\n+\n+    keyIndex1 = qs.createIndex(INDEX_NAME, \"positions['SUN']\", SEPARATOR + \"portfolio \");\n+    assertThat(keyIndex1).isInstanceOf(CompactMapRangeIndex.class);\n+    testQueriesForValueInMapField(region, qs);\n+\n+    long keys = ((CompactMapRangeIndex) keyIndex1).internalIndexStats.getNumberOfKeys();\n+    long mapIndexKeys =\n+        ((CompactMapRangeIndex) keyIndex1).internalIndexStats.getNumberOfMapIndexKeys();\n+    long values =\n+        ((CompactMapRangeIndex) keyIndex1).internalIndexStats.getNumberOfValues();\n+    assertThat(keys).isEqualTo(3);\n+    assertThat(mapIndexKeys).isEqualTo(1);\n+    assertThat(values).isEqualTo(3);\n+  }\n+\n+  @Test\n+  public void testQueriesForValueInMapFieldWithMapIndexWithSeveralKeys() throws Exception {\n+    region =\n+        CacheUtils.getCache().createRegionFactory(RegionShortcut.REPLICATE).create(\"portfolio\");\n+    qs = CacheUtils.getQueryService();\n+\n+    keyIndex1 =\n+        qs.createIndex(INDEX_NAME, \"positions['SUN', 'ERICSSON']\", SEPARATOR + \"portfolio \");\n+    assertThat(keyIndex1).isInstanceOf(CompactMapRangeIndex.class);\n+    testQueriesForValueInMapField(region, qs);\n+\n+    long keys = ((CompactMapRangeIndex) keyIndex1).internalIndexStats.getNumberOfKeys();\n+    long mapIndexKeys =\n+        ((CompactMapRangeIndex) keyIndex1).internalIndexStats.getNumberOfMapIndexKeys();\n+    long values =\n+        ((CompactMapRangeIndex) keyIndex1).internalIndexStats.getNumberOfValues();\n+    assertThat(keys).isEqualTo(3);\n+    assertThat(mapIndexKeys).isEqualTo(1);\n+    assertThat(values).isEqualTo(3);\n+  }\n+\n+  @Test\n+  public void testQueriesForValueInMapFieldWithMapIndexWithStar() throws Exception {\n+    region =\n+        CacheUtils.getCache().createRegionFactory(RegionShortcut.REPLICATE).create(\"portfolio\");\n+    qs = CacheUtils.getQueryService();\n+\n+    keyIndex1 = qs.createIndex(INDEX_NAME, \"positions[*]\", SEPARATOR + \"portfolio \");\n+    assertThat(keyIndex1).isInstanceOf(CompactMapRangeIndex.class);\n+    testQueriesForValueInMapField(region, qs);\n+\n+    long keys = ((CompactMapRangeIndex) keyIndex1).internalIndexStats.getNumberOfKeys();\n+    long mapIndexKeys =\n+        ((CompactMapRangeIndex) keyIndex1).internalIndexStats.getNumberOfMapIndexKeys();\n+    long values =\n+        ((CompactMapRangeIndex) keyIndex1).internalIndexStats.getNumberOfValues();\n+    assertThat(keys).isEqualTo(5);\n+    assertThat(mapIndexKeys).isEqualTo(4);\n+    assertThat(values).isEqualTo(5);\n+  }\n+\n+  public void testQueriesForValueInMapField(Region<Object, Object> region, QueryService qs)\n+      throws Exception {\n+    // Empty map\n+    Portfolio p = new Portfolio(1, 1);\n+    p.positions = new HashMap<>();\n+    region.put(1, p);\n+\n+    // Map is null\n+    Portfolio p2 = new Portfolio(2, 2);\n+    p2.positions = null;\n+    region.put(2, p2);\n+\n+    // Map with null value for \"SUN\" key\n+    Portfolio p3 = new Portfolio(3, 3);\n+    p3.positions = new HashMap<>();\n+    p3.positions.put(\"IBM\", \"something\");\n+    p3.positions.put(\"SUN\", null);\n+    region.put(3, p3);\n+\n+    // Map with not null value for \"SUN\" key\n+    Portfolio p4 = new Portfolio(4, 4);\n+    p4.positions = new HashMap<>();\n+    p4.positions.put(\"SUN\", \"nothing\");\n+    region.put(4, p4);\n+\n+    // Map with null key\n+    Portfolio p5 = new Portfolio(5, 5);\n+    p5.positions = new HashMap<>();\n+    p5.positions.put(\"SUN\", \"more\");\n+    // The next one causes trouble with gfsh as json cannot show maps with null keys\n+    p5.positions.put(null, \"empty\");\n+    region.put(5, p5);\n+\n+    // One more with map without the \"SUN\" key\n+    Portfolio p6 = new Portfolio(6, 6);\n+    p6.positions = new HashMap<>();\n+    p6.positions.put(\"ERIC\", \"hey\");\n+    region.put(6, p6);\n+\n+    // One more with null map\n+    Portfolio p7 = new Portfolio(7, 7);\n+    p7.positions = null;\n+    region.put(7, p7);\n+\n+    String query;\n+    query = \"select * from \" + SEPARATOR + \"portfolio p where p.positions['SUN'] = null\";\n+    SelectResults<Object> result = UncheckedUtils.uncheckedCast(qs\n+        .newQuery(query)\n+        .execute());\n+    assertThat(result.size()).isEqualTo(1);\n+    assertThat(result.contains(p3)).isTrue();\n+\n+    query = \"select * from \" + SEPARATOR + \"portfolio p where p.positions['SUN'] != null\";\n+    result = UncheckedUtils.uncheckedCast(qs\n+        .newQuery(query)\n+        .execute());\n+    assertThat(result.size()).isEqualTo(6);\n+    assertThat(result.containsAll(Arrays.asList(p, p2, p4, p5, p6, p7))).isTrue();\n+\n+    query = \"select * from \" + SEPARATOR + \"portfolio p where p.positions['SUN'] = 'nothing'\";\n+    result = UncheckedUtils.uncheckedCast(qs\n+        .newQuery(query)\n+        .execute());\n+    assertThat(result.size()).isEqualTo(1);\n+    assertThat(result.contains(p4)).isTrue();\n+\n+    query = \"select * from \" + SEPARATOR + \"portfolio p where p.positions['SUN'] != 'nothing'\";\n+    result = UncheckedUtils.uncheckedCast(qs\n+        .newQuery(query)\n+        .execute());\n+    assertThat(result.size()).isEqualTo(6);\n+    assertThat(result.containsAll(Arrays.asList(p, p2, p3, p5, p6, p7))).isTrue();\n+\n+    query = \"select * from \" + SEPARATOR + \"portfolio p\";\n+    result = UncheckedUtils.uncheckedCast(qs\n+        .newQuery(query)\n+        .execute());\n+    assertThat(result.size()).isEqualTo(7);\n+    assertThat(result.containsAll(Arrays.asList(p, p2, p3, p4, p5, p6, p7))).isTrue();\n+  }\n+\n   @Test\n   public void testNullMapValuesInIndexOnLocalRegionForMap() throws Exception {\n     IndexManager.TEST_RANGEINDEX_ONLY = true;"
  },
  {
    "sha": "d4c654b4866f27c8ca27437a6526355df4867dac",
    "filename": "geode-core/src/integrationTest/java/org/apache/geode/cache/query/partitioned/PRIndexStatisticsJUnitTest.java",
    "status": "modified",
    "additions": 3,
    "deletions": 4,
    "changes": 7,
    "blob_url": "https://github.com/apache/geode/blob/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/integrationTest/java/org/apache/geode/cache/query/partitioned/PRIndexStatisticsJUnitTest.java",
    "raw_url": "https://github.com/apache/geode/raw/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/integrationTest/java/org/apache/geode/cache/query/partitioned/PRIndexStatisticsJUnitTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/cache/query/partitioned/PRIndexStatisticsJUnitTest.java?ref=93d344ebf5a8d90e11662f427eb1e2841c728480",
    "patch": "@@ -273,8 +273,8 @@ public void testStatsForCompactMapRangeIndex() throws Exception {\n       query.execute();\n     }\n \n-    // Both RangeIndex should be used\n-    assertEquals(100 /* Execution time */, keyIndexStats.getTotalUses());\n+    // Index should not be used\n+    assertEquals(0, keyIndexStats.getTotalUses());\n \n     for (int i = 0; i < 50; i++) {\n       region.invalidate(Integer.toString(i));\n@@ -585,8 +585,7 @@ public void testStatsForCompactMapRangeIndexBeforeRegionCreation() throws Except\n       query.execute();\n     }\n \n-    // Both RangeIndex should be used\n-    assertEquals((100 /* Execution time */), keyIndexStats.getTotalUses());\n+    assertEquals((0 /* Execution time */), keyIndexStats.getTotalUses());\n \n     for (int i = 0; i < 50; i++) {\n       region.invalidate(Integer.toString(i));"
  },
  {
    "sha": "862d3e7ff8f38be89f511d172fb92eac3de9b1d4",
    "filename": "geode-core/src/main/java/org/apache/geode/cache/query/internal/CompiledComparison.java",
    "status": "modified",
    "additions": 17,
    "deletions": 1,
    "changes": 18,
    "blob_url": "https://github.com/apache/geode/blob/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/main/java/org/apache/geode/cache/query/internal/CompiledComparison.java",
    "raw_url": "https://github.com/apache/geode/raw/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/main/java/org/apache/geode/cache/query/internal/CompiledComparison.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/cache/query/internal/CompiledComparison.java?ref=93d344ebf5a8d90e11662f427eb1e2841c728480",
    "patch": "@@ -22,16 +22,20 @@\n import org.apache.geode.cache.Region;\n import org.apache.geode.cache.query.AmbiguousNameException;\n import org.apache.geode.cache.query.FunctionDomainException;\n+import org.apache.geode.cache.query.Index;\n import org.apache.geode.cache.query.IndexType;\n import org.apache.geode.cache.query.NameResolutionException;\n import org.apache.geode.cache.query.QueryInvocationTargetException;\n import org.apache.geode.cache.query.QueryService;\n import org.apache.geode.cache.query.SelectResults;\n import org.apache.geode.cache.query.Struct;\n import org.apache.geode.cache.query.TypeMismatchException;\n+import org.apache.geode.cache.query.internal.index.AbstractIndex;\n+import org.apache.geode.cache.query.internal.index.CompactMapRangeIndex;\n import org.apache.geode.cache.query.internal.index.IndexData;\n import org.apache.geode.cache.query.internal.index.IndexProtocol;\n import org.apache.geode.cache.query.internal.index.IndexUtils;\n+import org.apache.geode.cache.query.internal.index.PartitionedIndex;\n import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;\n import org.apache.geode.cache.query.internal.types.StructTypeImpl;\n import org.apache.geode.cache.query.internal.types.TypeUtils;\n@@ -642,7 +646,7 @@ public static String getSimpleClassName(Class cls) {\n     } else {\n       CompiledValue path = pAndK._path;\n       CompiledValue indexKey = pAndK._key;\n-      IndexData indexData = null;\n+      IndexData indexData;\n       // CompiledLike should not use HashIndex and PrimarKey Index.\n       if (this instanceof CompiledLike) {\n         indexData =\n@@ -651,6 +655,18 @@ public static String getSimpleClassName(Class cls) {\n         indexData = QueryUtils.getAvailableIndexIfAny(path, context, this._operator);\n       }\n \n+      // Do not use indexes when map index and != condition\n+      if (indexData != null && indexData.getIndex() instanceof CompactMapRangeIndex\n+          && this._operator == TOK_NE) {\n+        Index prIndex = ((AbstractIndex) indexData.getIndex()).getPRIndex();\n+        if (prIndex != null) {\n+          ((PartitionedIndex) prIndex).releaseIndexReadLockForRemove();\n+        } else {\n+          ((AbstractIndex) indexData.getIndex()).releaseIndexReadLockForRemove();\n+        }\n+        return null;\n+      }\n+\n       IndexProtocol index = null;\n       if (indexData != null) {\n         index = indexData.getIndex();"
  },
  {
    "sha": "d80864d11c7652633c6f1724c303f1e487004c32",
    "filename": "geode-core/src/main/java/org/apache/geode/cache/query/internal/CompiledConstruction.java",
    "status": "modified",
    "additions": 0,
    "deletions": 4,
    "changes": 4,
    "blob_url": "https://github.com/apache/geode/blob/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/main/java/org/apache/geode/cache/query/internal/CompiledConstruction.java",
    "raw_url": "https://github.com/apache/geode/raw/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/main/java/org/apache/geode/cache/query/internal/CompiledConstruction.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/cache/query/internal/CompiledConstruction.java?ref=93d344ebf5a8d90e11662f427eb1e2841c728480",
    "patch": "@@ -23,7 +23,6 @@\n import org.apache.geode.cache.query.FunctionDomainException;\n import org.apache.geode.cache.query.NameResolutionException;\n import org.apache.geode.cache.query.QueryInvocationTargetException;\n-import org.apache.geode.cache.query.QueryService;\n import org.apache.geode.cache.query.TypeMismatchException;\n import org.apache.geode.internal.Assert;\n \n@@ -64,9 +63,6 @@ public Object evaluate(ExecutionContext context) throws FunctionDomainException,\n     for (Iterator itr = this.args.iterator(); itr.hasNext();) {\n       CompiledValue cv = (CompiledValue) itr.next();\n       Object eval = cv.evaluate(context);\n-      if (eval == QueryService.UNDEFINED) {\n-        return QueryService.UNDEFINED;\n-      }\n       newSet.add(eval);\n     }\n     return newSet;"
  },
  {
    "sha": "58c661609d6d73bce94eb3463c90d8a7d321ab2e",
    "filename": "geode-core/src/main/java/org/apache/geode/cache/query/internal/CompiledIndexOperation.java",
    "status": "modified",
    "additions": 4,
    "deletions": 1,
    "changes": 5,
    "blob_url": "https://github.com/apache/geode/blob/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/main/java/org/apache/geode/cache/query/internal/CompiledIndexOperation.java",
    "raw_url": "https://github.com/apache/geode/raw/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/main/java/org/apache/geode/cache/query/internal/CompiledIndexOperation.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/cache/query/internal/CompiledIndexOperation.java?ref=93d344ebf5a8d90e11662f427eb1e2841c728480",
    "patch": "@@ -104,7 +104,10 @@ public Object evaluate(ExecutionContext context) throws TypeMismatchException,\n     }\n \n     if (rcvr instanceof Map) {\n-      return ((Map) rcvr).get(index);\n+      if (((Map<?, ?>) rcvr).containsKey(index)) {\n+        return ((Map) rcvr).get(index);\n+      }\n+      return QueryService.UNDEFINED;\n     }\n     if ((rcvr instanceof List) || rcvr.getClass().isArray() || (rcvr instanceof String)) {\n       if (!(index instanceof Integer)) {"
  },
  {
    "sha": "09d4923e628b97b8ac0d5c5e2b4db6835fd15e38",
    "filename": "geode-core/src/main/java/org/apache/geode/cache/query/internal/ResultsCollectionPdxDeserializerWrapper.java",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/apache/geode/blob/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/main/java/org/apache/geode/cache/query/internal/ResultsCollectionPdxDeserializerWrapper.java",
    "raw_url": "https://github.com/apache/geode/raw/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/main/java/org/apache/geode/cache/query/internal/ResultsCollectionPdxDeserializerWrapper.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/cache/query/internal/ResultsCollectionPdxDeserializerWrapper.java?ref=93d344ebf5a8d90e11662f427eb1e2841c728480",
    "patch": "@@ -218,4 +218,12 @@ public void setElementType(ObjectType elementType) {\n     results.setElementType(elementType);\n   }\n \n+  public String toString() {\n+    String out = \"size: \" + size() + System.lineSeparator();\n+    Iterator iter = iterator();\n+    while (iter.hasNext()) {\n+      out += iter.next() + System.lineSeparator();\n+    }\n+    return out;\n+  }\n }"
  },
  {
    "sha": "e3ff53baf78be751fe06cab2551db80c3c0af31f",
    "filename": "geode-core/src/main/java/org/apache/geode/cache/query/internal/index/CompactMapRangeIndex.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/apache/geode/blob/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/main/java/org/apache/geode/cache/query/internal/index/CompactMapRangeIndex.java",
    "raw_url": "https://github.com/apache/geode/raw/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/main/java/org/apache/geode/cache/query/internal/index/CompactMapRangeIndex.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/cache/query/internal/index/CompactMapRangeIndex.java?ref=93d344ebf5a8d90e11662f427eb1e2841c728480",
    "patch": "@@ -112,9 +112,9 @@ void saveMapping(Object key, Object value, RegionEntry entry) throws IMQExceptio\n       removeOldMappings(((Map) key).keySet(), entry);\n     } else {\n       for (Object mapKey : mapKeys) {\n-        Object indexKey = ((Map) key).get(mapKey);\n-        if (indexKey != null) {\n+        if (((Map) key).containsKey(mapKey)) {\n           // Do not convert to IndexManager.NULL. We are only interested in specific keys\n+          Object indexKey = ((Map) key).get(mapKey);\n           this.saveIndexAddition(mapKey, indexKey, value, entry);\n         }\n       }"
  },
  {
    "sha": "bdb25793449d6883abbc484e35ddded482968e9f",
    "filename": "geode-core/src/main/java/org/apache/geode/cache/query/internal/index/FunctionalIndexCreationHelper.java",
    "status": "modified",
    "additions": 1,
    "deletions": 3,
    "changes": 4,
    "blob_url": "https://github.com/apache/geode/blob/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/main/java/org/apache/geode/cache/query/internal/index/FunctionalIndexCreationHelper.java",
    "raw_url": "https://github.com/apache/geode/raw/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-core/src/main/java/org/apache/geode/cache/query/internal/index/FunctionalIndexCreationHelper.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/cache/query/internal/index/FunctionalIndexCreationHelper.java?ref=93d344ebf5a8d90e11662f427eb1e2841c728480",
    "patch": "@@ -461,10 +461,8 @@ private void prepareIndexExpression(String indexedExpression) throws IndexInvali\n           expr = mi.getReceiverSansIndexArgs();\n           expr.generateCanonicalizedExpression(sb, this.context);\n           sb.append('[').append('*').append(']');\n-\n-        } else if (indexingKeys.size() == 1) {\n+        } else if (indexingKeys.size() == 1 && indexingKeys.get(0).hasIdentifierAtLeafNode()) {\n           expr.generateCanonicalizedExpression(sb, this.context);\n-\n         } else {\n           this.isMapTypeIndex = true;\n           this.multiIndexKeysPattern = new String[indexingKeys.size()];"
  },
  {
    "sha": "e6477ab53626f0d2226b0292962d655b937cbf48",
    "filename": "geode-junit/src/main/java/org/apache/geode/cache/query/data/Portfolio.java",
    "status": "modified",
    "additions": 10,
    "deletions": 7,
    "changes": 17,
    "blob_url": "https://github.com/apache/geode/blob/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-junit/src/main/java/org/apache/geode/cache/query/data/Portfolio.java",
    "raw_url": "https://github.com/apache/geode/raw/93d344ebf5a8d90e11662f427eb1e2841c728480/geode-junit/src/main/java/org/apache/geode/cache/query/data/Portfolio.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-junit/src/main/java/org/apache/geode/cache/query/data/Portfolio.java?ref=93d344ebf5a8d90e11662f427eb1e2841c728480",
    "patch": "@@ -183,14 +183,17 @@ public int hashCode() {\n \n   public String toString() {\n     String out =\n-        \"Portfolio [ID=\" + ID + \" status=\" + status + \" type=\" + type + \" pkid=\" + pkid + \"\\n \";\n-    Iterator iter = positions.entrySet().iterator();\n-    while (iter.hasNext()) {\n-      Map.Entry entry = (Map.Entry) iter.next();\n-      out += entry.getKey() + \":\" + entry.getValue() + \", \";\n+        \"Portfolio [ID=\" + ID + \" status=\" + status + \" type=\" + type + \" pkid=\" + pkid\n+            + System.lineSeparator();\n+    if (positions != null) {\n+      Iterator iter = positions.entrySet().iterator();\n+      while (iter.hasNext()) {\n+        Map.Entry entry = (Map.Entry) iter.next();\n+        out += entry.getKey() + \":\" + entry.getValue() + \", \";\n+      }\n+      out += System.lineSeparator() + \" P1:\" + position1 + \", P2:\" + position2;\n     }\n-    out += \"\\n P1:\" + position1 + \", P2:\" + position2;\n-    return out + \"\\n]\";\n+    return out + System.lineSeparator() + \"]\";\n   }\n \n   /**"
  }
]
