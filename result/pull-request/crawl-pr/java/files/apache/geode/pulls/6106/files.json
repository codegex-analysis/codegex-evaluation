[
  {
    "sha": "3fcc42b48567973a2afee404c410bba4999ba140",
    "filename": "geode-assembly/src/acceptanceTest/java/org/apache/geode/ssl/CertificateRotationTest.java",
    "status": "added",
    "additions": 432,
    "deletions": 0,
    "changes": 432,
    "blob_url": "https://github.com/apache/geode/blob/1c4e5346bd92e44134ab86da875801130189a797/geode-assembly/src/acceptanceTest/java/org/apache/geode/ssl/CertificateRotationTest.java",
    "raw_url": "https://github.com/apache/geode/raw/1c4e5346bd92e44134ab86da875801130189a797/geode-assembly/src/acceptanceTest/java/org/apache/geode/ssl/CertificateRotationTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-assembly/src/acceptanceTest/java/org/apache/geode/ssl/CertificateRotationTest.java?ref=1c4e5346bd92e44134ab86da875801130189a797",
    "patch": "@@ -0,0 +1,432 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.ssl;\n+\n+import static java.util.regex.Pattern.compile;\n+import static java.util.regex.Pattern.quote;\n+import static org.apache.geode.cache.client.ClientRegionShortcut.PROXY;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPorts;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.util.Properties;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.assertj.core.api.Condition;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.client.ClientCache;\n+import org.apache.geode.cache.client.ClientCacheFactory;\n+import org.apache.geode.cache.ssl.CertStores;\n+import org.apache.geode.cache.ssl.CertificateBuilder;\n+import org.apache.geode.cache.ssl.CertificateMaterial;\n+import org.apache.geode.test.junit.rules.gfsh.GfshRule;\n+\n+/**\n+ * This test creates a cluster and a client with SSL enabled for all components and client\n+ * authentication enabled.\n+ *\n+ * It verifies that the cluster certificate, the client certificate, and the CA certificate can be\n+ * rotated without having to restart the client or the members.\n+ */\n+public class CertificateRotationTest {\n+\n+  private static final String regionName = \"region\";\n+  private static final String dummyStorePass = \"geode\";\n+  private static final Pattern updatedKeyManager = compile(\"Updated KeyManager\");\n+  private static final Pattern updatedTrustManager = compile(\"Updated TrustManager\");\n+\n+  @Rule\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  @Rule\n+  public GfshRule gfshRule = new GfshRule();\n+\n+  private CertificateMaterial caCert;\n+\n+  private String[] memberNames;\n+  private int locatorPort;\n+  private int locatorHttpPort;\n+  private File clusterKeyStore;\n+  private File clusterTrustStore;\n+  private File clusterSecurityProperties;\n+\n+  private ClientCache client;\n+  private Region<String, String> region;\n+  private File clientKeyStore;\n+  private File clientTrustStore;\n+  private File clientLogFile;\n+\n+  /**\n+   * The test setup creates a cluster with 1 locator and 2 servers, a client cache, and a CA\n+   * certificate. The cluster has SSL enabled for all components and uses client authentication. The\n+   * cluster members share a certificate which is signed by a CA and trust the CA certificate. The\n+   * client has a certificate signed by the same CA and also trusts the CA certificate.\n+   */\n+  @Before\n+  public void setUp() throws Exception {\n+    caCert = new CertificateBuilder()\n+        .commonName(\"ca\")\n+        .isCA()\n+        .generate();\n+\n+    startCluster();\n+    startClient();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    if (client != null) {\n+      client.close();\n+    }\n+\n+    shutdownCluster();\n+  }\n+\n+  /**\n+   * This test rotates the cluster's certificate and verifies that the client can form a new secure\n+   * connection.\n+   */\n+  @Test\n+  public void rotateClusterCertificate() throws Exception {\n+    CertificateMaterial newClusterCert = new CertificateBuilder()\n+        .commonName(\"cluster\")\n+        .issuedBy(caCert)\n+        .sanDnsName(\"localhost\")\n+        .sanIpAddress(InetAddress.getByName(\"127.0.0.1\"))\n+        .generate();\n+\n+    writeCertsToKeyStore(clusterKeyStore.toPath(), newClusterCert);\n+    waitForMembersToLogMessage(updatedKeyManager);\n+\n+    assertThatCode(() -> region.put(\"foo\", \"bar\"))\n+        .as(\"The client performs an operation which requires a new secure connection\")\n+        .doesNotThrowAnyException();\n+  }\n+\n+  /**\n+   * This test rotates the client's certificate and verifies that the client can form a new secure\n+   * connection.\n+   */\n+  @Test\n+  public void rotateClientCertificate() throws Exception {\n+    CertificateMaterial newClientCert = new CertificateBuilder()\n+        .commonName(\"client\")\n+        .issuedBy(caCert)\n+        .sanDnsName(\"localhost\")\n+        .sanIpAddress(InetAddress.getByName(\"127.0.0.1\"))\n+        .generate();\n+\n+    writeCertsToKeyStore(clientKeyStore.toPath(), newClientCert);\n+    waitForClientToLogMessage(updatedKeyManager);\n+\n+    assertThatCode(() -> region.put(\"foo\", \"bar\"))\n+        .as(\"The client performs an operation which requires a new secure connection\")\n+        .doesNotThrowAnyException();\n+  }\n+\n+  /**\n+   * This test rotates the CA certificate in both the cluster and the client. It verifies that the\n+   * client can form a new secure connection after the new CA certificate has been added and the old\n+   * CA certificate removed.\n+   */\n+  @Test\n+  public void rotateCaCertificate() throws Exception {\n+    /*\n+     * First, create a new CA certificate and add it to both the cluster's and the client's trust\n+     * stores. The trust stores will contain both the old and the new CA certificates.\n+     */\n+\n+    CertificateMaterial newCaCert = new CertificateBuilder()\n+        .commonName(\"ca\")\n+        .isCA()\n+        .generate();\n+\n+    writeCertsToTrustStore(clusterTrustStore.toPath(), caCert, newCaCert);\n+    writeCertsToTrustStore(clientTrustStore.toPath(), caCert, newCaCert);\n+\n+    waitForMembersToLogMessage(updatedTrustManager);\n+    waitForClientToLogMessage(updatedTrustManager);\n+\n+    /*\n+     * Next, create new certificates for the cluster and the client which are signed by the new CA,\n+     * and replace the certificates in the cluster's and the client's key stores.\n+     */\n+\n+    CertificateMaterial newClusterCert = new CertificateBuilder()\n+        .commonName(\"cluster\")\n+        .issuedBy(newCaCert)\n+        .sanDnsName(\"localhost\")\n+        .sanIpAddress(InetAddress.getByName(\"127.0.0.1\"))\n+        .generate();\n+\n+    CertificateMaterial newClientCert = new CertificateBuilder()\n+        .commonName(\"client\")\n+        .issuedBy(newCaCert)\n+        .sanDnsName(\"localhost\")\n+        .sanIpAddress(InetAddress.getByName(\"127.0.0.1\"))\n+        .generate();\n+\n+    writeCertsToKeyStore(clusterKeyStore.toPath(), newClusterCert);\n+    writeCertsToKeyStore(clientKeyStore.toPath(), newClientCert);\n+\n+    waitForMembersToLogMessage(updatedKeyManager);\n+    waitForClientToLogMessage(updatedKeyManager);\n+\n+    /*\n+     * Finally, remove the old CA certificate from both the cluster's and the client's trust stores.\n+     */\n+\n+    writeCertsToTrustStore(clusterTrustStore.toPath(), newCaCert);\n+    writeCertsToTrustStore(clientTrustStore.toPath(), newCaCert);\n+\n+    for (String name : memberNames) {\n+      await().untilAsserted(() -> assertThat(logsForMember(name))\n+          .as(\"The cluster's trust manager has been updated twice\")\n+          .haveExactly(2, linesMatching(updatedTrustManager)));\n+    }\n+\n+    await().untilAsserted(() -> assertThat(logsForClient())\n+        .as(\"The client's trust manager has been updated twice\")\n+        .haveExactly(2, linesMatching(updatedTrustManager)));\n+\n+    assertThatCode(() -> region.put(\"foo\", \"bar\"))\n+        .as(\"The client performs an operation which requires a new secure connection\")\n+        .doesNotThrowAnyException();\n+  }\n+\n+  /**\n+   * This test verifies that rotating to an untrusted certificate causes an exception when the\n+   * client tries to form a new secure connection. This is a sanity check that certificates are\n+   * being dynamically updated.\n+   */\n+  @Test\n+  public void untrustedCertificateThrows() throws Exception {\n+    CertificateMaterial selfSignedCert = new CertificateBuilder()\n+        .commonName(\"client\")\n+        .sanDnsName(\"localhost\")\n+        .sanIpAddress(InetAddress.getByName(\"127.0.0.1\"))\n+        .generate();\n+\n+    writeCertsToKeyStore(clientKeyStore.toPath(), selfSignedCert);\n+    waitForClientToLogMessage(updatedKeyManager);\n+\n+    assertThatThrownBy(() -> region.put(\"foo\", \"bar\"))\n+        .as(\"The client performs an operation which requires a new connection\")\n+        .hasCauseInstanceOf(SSLException.class);\n+  }\n+\n+  private void writeCertsToKeyStore(Path keyStoreFile, CertificateMaterial... certs)\n+      throws GeneralSecurityException, IOException {\n+    CertStores store = new CertStores(\"\");\n+    for (int i = 0; i < certs.length; i++) {\n+      store.withCertificate(String.valueOf(i), certs[i]);\n+    }\n+    store.createKeyStore(keyStoreFile.toAbsolutePath().toString(), dummyStorePass);\n+  }\n+\n+  private void writeCertsToTrustStore(Path trustStoreFile, CertificateMaterial... certs)\n+      throws GeneralSecurityException, IOException {\n+    CertStores store = new CertStores(\"\");\n+    for (int i = 0; i < certs.length; i++) {\n+      store.trust(String.valueOf(i), certs[i]);\n+    }\n+    store.createTrustStore(trustStoreFile.toAbsolutePath().toString(), dummyStorePass);\n+  }\n+\n+  private void waitForMembersToLogMessage(Pattern pattern) {\n+    for (String name : memberNames) {\n+      await().untilAsserted(() -> assertThat(logsForMember(name))\n+          .as(\"The logs for member \" + name + \" include a line matching \\\"\" + pattern + \"\\\"\")\n+          .haveAtLeast(1, linesMatching(pattern)));\n+    }\n+  }\n+\n+  private void waitForClientToLogMessage(Pattern pattern) {\n+    await().untilAsserted(() -> assertThat(logsForClient())\n+        .as(\"The logs for the client include a line matching \\\"\" + pattern + \"\\\"\")\n+        .haveAtLeast(1, linesMatching(pattern)));\n+  }\n+\n+  private Condition<String> linesMatching(Pattern pattern) {\n+    return new Condition<>(pattern.asPredicate(), \"lines matching \\\"\" + pattern + \"\\\"\");\n+  }\n+\n+  private Stream<String> logsForClient() throws IOException {\n+    return Files.lines(clientLogFile.toPath());\n+  }\n+\n+  private Stream<String> logsForMember(String name) throws IOException {\n+    Path logFile = temporaryFolder.getRoot().toPath().resolve(name).resolve(name + \".log\");\n+    return Files.lines(logFile);\n+  }\n+\n+  private void startClient() throws IOException, GeneralSecurityException, InterruptedException {\n+    CertificateMaterial clientCert = new CertificateBuilder()\n+        .commonName(\"client\")\n+        .issuedBy(caCert)\n+        .sanDnsName(\"localhost\")\n+        .sanIpAddress(InetAddress.getByName(\"127.0.0.1\"))\n+        .generate();\n+\n+    clientKeyStore = temporaryFolder.newFile(\"client-keystore.jks\");\n+    writeCertsToKeyStore(clientKeyStore.toPath(), clientCert);\n+\n+    clientTrustStore = temporaryFolder.newFile(\"client-truststore.jks\");\n+    writeCertsToTrustStore(clientTrustStore.toPath(), caCert);\n+\n+    File clientSecurityProperties = temporaryFolder.newFile(\"client-security.properties\");\n+    Properties properties = CertStores.propertiesWith(\"all\", \"any\", \"any\",\n+        clientTrustStore, dummyStorePass, clientKeyStore, dummyStorePass, true, true);\n+    properties.store(new FileOutputStream(clientSecurityProperties), \"\");\n+\n+    clientLogFile = temporaryFolder.newFile(\"client.log\");\n+\n+    client = new ClientCacheFactory(properties)\n+        .addPoolLocator(\"localhost\", locatorPort)\n+        .set(\"log-file\", clientLogFile.getAbsolutePath())\n+        // prevent the client from creating a connection until the first cache operation\n+        .setPoolMinConnections(0)\n+        .create();\n+\n+    region = client.<String, String>createClientRegionFactory(PROXY)\n+        .create(regionName);\n+\n+    waitForClientToLogMessage(compile(quote(\"Started watching \" + clientKeyStore.getPath())));\n+    waitForClientToLogMessage(compile(quote(\"Started watching \" + clientTrustStore.getPath())));\n+\n+    /*\n+     * This sleep is needed to ensure that any updates to the key or trust store file are detected\n+     * by the client. Without it, the timestamp on the updated file might be the same as the\n+     * timestamp before the update, preventing the client from noticing the change.\n+     */\n+    Thread.sleep(Duration.ofSeconds(5).toMillis());\n+  }\n+\n+  private void startCluster() throws IOException, GeneralSecurityException {\n+    CertificateMaterial clusterCert = new CertificateBuilder()\n+        .commonName(\"cluster\")\n+        .issuedBy(caCert)\n+        .sanDnsName(\"localhost\")\n+        .sanIpAddress(InetAddress.getByName(\"127.0.0.1\"))\n+        .generate();\n+\n+    clusterKeyStore = temporaryFolder.newFile(\"cluster-keystore.jks\");\n+    writeCertsToKeyStore(clusterKeyStore.toPath(), clusterCert);\n+\n+    clusterTrustStore = temporaryFolder.newFile(\"cluster-truststore.jks\");\n+    writeCertsToTrustStore(clusterTrustStore.toPath(), caCert);\n+\n+    clusterSecurityProperties = temporaryFolder.newFile(\"cluster-security.properties\");\n+    Properties properties = CertStores.propertiesWith(\"all\", \"any\", \"any\",\n+        clusterTrustStore, dummyStorePass, clusterKeyStore, dummyStorePass, true, true);\n+    properties.store(new FileOutputStream(clusterSecurityProperties), \"\");\n+\n+    memberNames = new String[] {\"locator\", \"server1\", \"server2\"};\n+\n+    startLocator(memberNames[0]);\n+    startServer(memberNames[1]);\n+    startServer(memberNames[2]);\n+    createRegion();\n+  }\n+\n+  private void startLocator(String name) throws IOException {\n+    File dir = temporaryFolder.newFolder(name);\n+\n+    int[] availablePorts = getRandomAvailableTCPPorts(3);\n+    locatorPort = availablePorts[0];\n+    locatorHttpPort = availablePorts[1];\n+    int locatorJmxPort = availablePorts[2];\n+\n+    String startLocatorCommand = String.join(\" \",\n+        \"start locator\",\n+        \"--connect=false\",\n+        \"--name=\" + name,\n+        \"--dir=\" + dir.getAbsolutePath(),\n+        \"--bind-address=127.0.0.1\",\n+        \"--port=\" + locatorPort,\n+        \"--http-service-port=\" + locatorHttpPort,\n+        \"--J=-Dgemfire.jmx-manager-port=\" + locatorJmxPort,\n+        \"--security-properties-file=\" + clusterSecurityProperties.getAbsolutePath());\n+\n+    gfshRule.execute(startLocatorCommand);\n+  }\n+\n+  private void startServer(String name) throws IOException {\n+    File dir = temporaryFolder.newFolder(name);\n+\n+    int[] availablePorts = getRandomAvailableTCPPorts(1);\n+    int port = availablePorts[0];\n+\n+    String locatorString = \"localhost[\" + locatorPort + \"]\";\n+\n+    String startServerCommand = String.join(\" \",\n+        \"start server\",\n+        \"--name=\" + name,\n+        \"--dir=\" + dir.getAbsolutePath(),\n+        \"--bind-address=127.0.0.1\",\n+        \"--server-port=\" + port,\n+        \"--locators=\" + locatorString,\n+        \"--security-properties-file=\" + clusterSecurityProperties.getAbsolutePath());\n+\n+    gfshRule.execute(startServerCommand);\n+  }\n+\n+  private void createRegion() {\n+    String connectToLocatorCommand = String.join(\" \",\n+        \"connect\",\n+        \"--use-http\",\n+        \"--use-ssl\",\n+        \"--url=https://localhost:\" + locatorHttpPort + \"/geode-mgmt/v1\",\n+        \"--security-properties-file=\" + clusterSecurityProperties.getAbsolutePath());\n+\n+    String createRegionCommand = String.join(\" \",\n+        \"create region\",\n+        \"--name=\" + regionName,\n+        \"--type=REPLICATE\");\n+\n+    gfshRule.execute(connectToLocatorCommand, createRegionCommand);\n+  }\n+\n+  private void shutdownCluster() {\n+    String connectToLocatorCommand = String.join(\" \",\n+        \"connect\",\n+        \"--use-http\",\n+        \"--use-ssl\",\n+        \"--url=https://localhost:\" + locatorHttpPort + \"/geode-mgmt/v1\",\n+        \"--security-properties-file=\" + clusterSecurityProperties.getAbsolutePath());\n+\n+    String shutdownCommand = \"shutdown --include-locators=true\";\n+    gfshRule.execute(connectToLocatorCommand, shutdownCommand);\n+  }\n+}"
  },
  {
    "sha": "5b561e2245c3ef70728c4b2d4a156d67e523c844",
    "filename": "geode-core/src/integrationTest/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedKeyManagerIntegrationTest.java",
    "status": "added",
    "additions": 199,
    "deletions": 0,
    "changes": 199,
    "blob_url": "https://github.com/apache/geode/blob/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/integrationTest/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedKeyManagerIntegrationTest.java",
    "raw_url": "https://github.com/apache/geode/raw/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/integrationTest/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedKeyManagerIntegrationTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedKeyManagerIntegrationTest.java?ref=1c4e5346bd92e44134ab86da875801130189a797",
    "patch": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.net.filewatch;\n+\n+import static org.apache.geode.internal.net.filewatch.FileWatchingX509ExtendedKeyManager.newFileWatchingKeyManager;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import org.apache.geode.cache.ssl.CertStores;\n+import org.apache.geode.cache.ssl.CertificateBuilder;\n+import org.apache.geode.cache.ssl.CertificateMaterial;\n+import org.apache.geode.internal.net.SSLConfig;\n+\n+public class FileWatchingX509ExtendedKeyManagerIntegrationTest {\n+  private static final String dummyPassword = \"geode\";\n+  private static final String alias = \"alias\";\n+\n+  @Rule\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private Path keyStore;\n+  private FileWatchingX509ExtendedKeyManager target;\n+\n+  @Before\n+  public void createKeyStoreFile() throws Exception {\n+    keyStore = temporaryFolder.newFile(\"keystore.jks\").toPath();\n+  }\n+\n+  @After\n+  public void stopWatchingKeyStoreFile() {\n+    if (target != null && target.isWatching()) {\n+      target.stopWatching();\n+    }\n+  }\n+\n+  @Test\n+  public void initializesKeyManager() throws Exception {\n+    Map<String, CertificateMaterial> entries = storeCertificates(keyStore, alias);\n+\n+    target = newFileWatchingKeyManager(sslConfigFor(keyStore, alias));\n+\n+    X509Certificate[] chain = target.getCertificateChain(alias);\n+    assertThat(chain).containsExactly(entries.get(alias).getCertificate());\n+  }\n+\n+  @Test\n+  public void initializesKeyManagerWithoutAliasSpecified() throws Exception {\n+    String anotherAlias = \"another-alias\";\n+    Map<String, CertificateMaterial> entries = storeCertificates(keyStore, alias, anotherAlias);\n+\n+    target = newFileWatchingKeyManager(sslConfigFor(keyStore, null));\n+\n+    assertThat(target.getCertificateChain(alias))\n+        .as(\"The certificate chain for alias \" + alias + \" contains the correct cert\")\n+        .containsExactly(entries.get(alias).getCertificate());\n+\n+    assertThat(target.getCertificateChain(anotherAlias))\n+        .as(\"The certificate chain for alias \" + anotherAlias + \" contains the correct cert\")\n+        .containsExactly(entries.get(anotherAlias).getCertificate());\n+  }\n+\n+  @Test\n+  public void updatesKeyManager() throws Exception {\n+    storeCertificates(keyStore, alias);\n+\n+    target = newFileWatchingKeyManager(sslConfigFor(keyStore, alias));\n+\n+    pauseForFileWatcherToStartDetectingChanges();\n+\n+    Map<String, CertificateMaterial> updated = storeCertificates(keyStore, alias);\n+\n+    await().untilAsserted(() -> {\n+      X509Certificate[] chain = target.getCertificateChain(alias);\n+      assertThat(chain).containsExactly(updated.get(alias).getCertificate());\n+    });\n+  }\n+\n+  @Test\n+  public void returnsSameInstanceForSamePathAndAlias() throws Exception {\n+    storeCertificates(keyStore, alias);\n+\n+    target = newFileWatchingKeyManager(sslConfigFor(keyStore, alias));\n+\n+    assertThat(target).isSameAs(newFileWatchingKeyManager(sslConfigFor(keyStore, alias)));\n+  }\n+\n+  @Test\n+  public void returnsNewInstanceForDifferentPath() throws Exception {\n+    Path differentPath = temporaryFolder.newFile(\"another-keystore.jks\").toPath();\n+    storeCertificates(differentPath, alias);\n+    storeCertificates(keyStore, alias);\n+\n+    target = newFileWatchingKeyManager(sslConfigFor(keyStore, alias));\n+\n+    FileWatchingX509ExtendedKeyManager other =\n+        newFileWatchingKeyManager(sslConfigFor(differentPath, alias));\n+    try {\n+      assertThat(target).isNotSameAs(other);\n+    } finally {\n+      other.stopWatching();\n+    }\n+  }\n+\n+  @Test\n+  public void returnsNewInstanceForDifferentAlias() throws Exception {\n+    String differentAlias = \"different-alias\";\n+    storeCertificates(keyStore, alias, differentAlias);\n+\n+    target = newFileWatchingKeyManager(sslConfigFor(keyStore, alias));\n+\n+    FileWatchingX509ExtendedKeyManager other =\n+        newFileWatchingKeyManager(sslConfigFor(keyStore, differentAlias));\n+    try {\n+      assertThat(target).isNotSameAs(other);\n+    } finally {\n+      other.stopWatching();\n+    }\n+  }\n+\n+  @Test\n+  public void throwsIfUnableToLoadKeyManager() {\n+    Path notFoundFile = temporaryFolder.getRoot().toPath().resolve(\"notfound\");\n+\n+    Throwable thrown =\n+        catchThrowable(() -> newFileWatchingKeyManager(sslConfigFor(notFoundFile, alias)));\n+\n+    assertThat(thrown).isNotNull();\n+  }\n+\n+  @Test\n+  public void stopsWatchingWhenKeyManagerIsNoLongerValid() throws Exception {\n+    storeCertificates(keyStore, alias);\n+\n+    target = newFileWatchingKeyManager(sslConfigFor(keyStore, alias));\n+\n+    pauseForFileWatcherToStartDetectingChanges();\n+\n+    Files.delete(keyStore);\n+\n+    await().until(() -> !target.isWatching());\n+  }\n+\n+  private Map<String, CertificateMaterial> storeCertificates(Path keyStore, String... aliases)\n+      throws Exception {\n+    Map<String, CertificateMaterial> entries = new HashMap<>();\n+    CertStores store = new CertStores(\"\");\n+    for (String alias : aliases) {\n+      CertificateMaterial cert = new CertificateBuilder().commonName(\"geode\").generate();\n+      store.withCertificate(alias, cert);\n+      entries.put(alias, cert);\n+    }\n+    store.createKeyStore(keyStore.toString(), dummyPassword);\n+    return entries;\n+  }\n+\n+  private SSLConfig sslConfigFor(Path keyStore, String alias) {\n+    return new SSLConfig.Builder()\n+        .setKeystore(keyStore.toString())\n+        .setKeystorePassword(dummyPassword)\n+        .setAlias(alias)\n+        .build();\n+  }\n+\n+  private void pauseForFileWatcherToStartDetectingChanges() throws InterruptedException {\n+    /*\n+     * Some file systems only have 1-second granularity for file timestamps. This sleep is needed\n+     * so that the timestamp AFTER the update will be greater than the timestamp BEFORE the update.\n+     * Otherwise, the file watcher cannot detect the change. The sleep duration needs to be several\n+     * seconds longer than the granularity since the sleep duration is only approximate.\n+     */\n+    Thread.sleep(Duration.ofSeconds(5).toMillis());\n+  }\n+}"
  },
  {
    "sha": "1000733ef6639074acb154e7a2de7fa4b8520444",
    "filename": "geode-core/src/integrationTest/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedTrustManagerIntegrationTest.java",
    "status": "added",
    "additions": 158,
    "deletions": 0,
    "changes": 158,
    "blob_url": "https://github.com/apache/geode/blob/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/integrationTest/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedTrustManagerIntegrationTest.java",
    "raw_url": "https://github.com/apache/geode/raw/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/integrationTest/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedTrustManagerIntegrationTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedTrustManagerIntegrationTest.java?ref=1c4e5346bd92e44134ab86da875801130189a797",
    "patch": "@@ -0,0 +1,158 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.net.filewatch;\n+\n+import static org.apache.geode.internal.net.filewatch.FileWatchingX509ExtendedTrustManager.newFileWatchingTrustManager;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import org.apache.geode.cache.ssl.CertStores;\n+import org.apache.geode.cache.ssl.CertificateBuilder;\n+import org.apache.geode.cache.ssl.CertificateMaterial;\n+import org.apache.geode.internal.net.SSLConfig;\n+\n+public class FileWatchingX509ExtendedTrustManagerIntegrationTest {\n+  private static final String dummyPassword = \"geode\";\n+\n+  @Rule\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private Path trustStore;\n+  private FileWatchingX509ExtendedTrustManager target;\n+\n+  @Before\n+  public void createTrustStoreFile() throws Exception {\n+    trustStore = temporaryFolder.newFile(\"truststore.jks\").toPath();\n+  }\n+\n+  @After\n+  public void stopWatchingTrustStoreFile() {\n+    if (target != null && target.isWatching()) {\n+      target.stopWatching();\n+    }\n+  }\n+\n+  @Test\n+  public void initializesTrustManager() throws Exception {\n+    CertificateMaterial caCert = storeCa(trustStore);\n+\n+    target = newFileWatchingTrustManager(sslConfigFor(trustStore));\n+\n+    X509Certificate[] issuers = target.getAcceptedIssuers();\n+    assertThat(issuers).containsExactly(caCert.getCertificate());\n+  }\n+\n+  @Test\n+  public void updatesTrustManager() throws Exception {\n+    storeCa(trustStore);\n+\n+    target = newFileWatchingTrustManager(sslConfigFor(trustStore));\n+\n+    pauseForFileWatcherToStartDetectingChanges();\n+\n+    CertificateMaterial updated = storeCa(trustStore);\n+\n+    await().untilAsserted(() -> {\n+      X509Certificate[] issuers = target.getAcceptedIssuers();\n+      assertThat(issuers).containsExactly(updated.getCertificate());\n+    });\n+  }\n+\n+  @Test\n+  public void returnsSameInstanceForSamePath() throws Exception {\n+    storeCa(trustStore);\n+\n+    target = newFileWatchingTrustManager(sslConfigFor(trustStore));\n+\n+    assertThat(target).isSameAs(newFileWatchingTrustManager(sslConfigFor(trustStore)));\n+  }\n+\n+  @Test\n+  public void returnsNewInstanceForDifferentPath() throws Exception {\n+    Path differentPath = temporaryFolder.newFile(\"another-keystore.jks\").toPath();\n+    storeCa(differentPath);\n+    storeCa(trustStore);\n+\n+    target = newFileWatchingTrustManager(sslConfigFor(trustStore));\n+\n+    FileWatchingX509ExtendedTrustManager other =\n+        newFileWatchingTrustManager(sslConfigFor(differentPath));\n+    try {\n+      assertThat(target).isNotSameAs(other);\n+    } finally {\n+      other.stopWatching();\n+    }\n+  }\n+\n+  @Test\n+  public void throwsIfUnableToLoadTrustManager() {\n+    Path notFoundFile = temporaryFolder.getRoot().toPath().resolve(\"notfound\");\n+\n+    Throwable thrown =\n+        catchThrowable(() -> newFileWatchingTrustManager(sslConfigFor(notFoundFile)));\n+\n+    assertThat(thrown).isNotNull();\n+  }\n+\n+  @Test\n+  public void stopsWatchingWhenTrustManagerIsNoLongerValid() throws Exception {\n+    storeCa(trustStore);\n+\n+    target = newFileWatchingTrustManager(sslConfigFor(trustStore));\n+\n+    pauseForFileWatcherToStartDetectingChanges();\n+\n+    Files.delete(trustStore);\n+\n+    await().until(() -> !target.isWatching());\n+  }\n+\n+  private CertificateMaterial storeCa(Path trustStore) throws Exception {\n+    CertificateMaterial cert = new CertificateBuilder().commonName(\"geode\").generate();\n+    CertStores store = new CertStores(\"\");\n+    store.trust(\"default\", cert);\n+    store.createTrustStore(trustStore.toString(), dummyPassword);\n+    return cert;\n+  }\n+\n+  private SSLConfig sslConfigFor(Path trustStore) {\n+    return new SSLConfig.Builder()\n+        .setTruststore(trustStore.toString())\n+        .setTruststorePassword(dummyPassword)\n+        .build();\n+  }\n+\n+  private void pauseForFileWatcherToStartDetectingChanges() throws InterruptedException {\n+    /*\n+     * Some file systems only have 1-second granularity for file timestamps. This sleep is needed\n+     * so that the timestamp AFTER the update will be greater than the timestamp BEFORE the update.\n+     * Otherwise, the file watcher cannot detect the change. The sleep duration needs to be several\n+     * seconds longer than the granularity since the sleep duration is only approximate.\n+     */\n+    Thread.sleep(Duration.ofSeconds(5).toMillis());\n+  }\n+}"
  },
  {
    "sha": "dcd95034fe2e42dec10ee9d99d402f619cad092f",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/net/SSLUtil.java",
    "status": "modified",
    "additions": 26,
    "deletions": 69,
    "changes": 95,
    "blob_url": "https://github.com/apache/geode/blob/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/main/java/org/apache/geode/internal/net/SSLUtil.java",
    "raw_url": "https://github.com/apache/geode/raw/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/main/java/org/apache/geode/internal/net/SSLUtil.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/net/SSLUtil.java?ref=1c4e5346bd92e44134ab86da875801130189a797",
    "patch": "@@ -14,12 +14,12 @@\n  */\n package org.apache.geode.internal.net;\n \n-import java.io.FileInputStream;\n-import java.security.KeyStore;\n+import static org.apache.geode.internal.net.filewatch.FileWatchingX509ExtendedKeyManager.newFileWatchingKeyManager;\n+import static org.apache.geode.internal.net.filewatch.FileWatchingX509ExtendedTrustManager.newFileWatchingTrustManager;\n+\n import java.security.NoSuchAlgorithmException;\n import java.security.SecureRandom;\n import java.security.cert.X509Certificate;\n-import java.util.Objects;\n \n import javax.net.ssl.KeyManager;\n import javax.net.ssl.KeyManagerFactory;\n@@ -99,8 +99,29 @@ public static SSLContext createAndConfigureSSLContext(SSLConfig sslConfig,\n       }\n       SSLContext ssl = getSSLContextInstance(sslConfig);\n \n-      KeyManager[] keyManagers = getKeyManagers(sslConfig);\n-      TrustManager[] trustManagers = getTrustManagers(sslConfig, skipSslVerification);\n+      KeyManager[] keyManagers = null;\n+      if (sslConfig.getKeystore() != null) {\n+        keyManagers = new KeyManager[] {newFileWatchingKeyManager(sslConfig)};\n+      }\n+\n+      TrustManager[] trustManagers = null;\n+      if (skipSslVerification) {\n+        trustManagers = new TrustManager[] {new X509TrustManager() {\n+          @Override\n+          public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n+            return null;\n+          }\n+\n+          @Override\n+          public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n+\n+          @Override\n+          public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n+\n+        }};\n+      } else if (sslConfig.getTruststore() != null) {\n+        trustManagers = new TrustManager[] {newFileWatchingTrustManager(sslConfig)};\n+      }\n \n       ssl.init(keyManagers, trustManagers, new SecureRandom());\n       return ssl;\n@@ -109,76 +130,12 @@ public static SSLContext createAndConfigureSSLContext(SSLConfig sslConfig,\n     }\n   }\n \n-  private static KeyManager[] getKeyManagers(SSLConfig sslConfig) throws Exception {\n-    FileInputStream keyStoreStream = null;\n-    KeyManagerFactory keyManagerFactory = null;\n-\n-    try {\n-      if (StringUtils.isNotBlank(sslConfig.getKeystore())) {\n-        String keyStoreType = Objects.toString(sslConfig.getKeystoreType(), \"JKS\");\n-        KeyStore clientKeys = KeyStore.getInstance(keyStoreType);\n-        keyStoreStream = new FileInputStream(sslConfig.getKeystore());\n-        clientKeys.load(keyStoreStream, sslConfig.getKeystorePassword().toCharArray());\n-\n-        keyManagerFactory = getDefaultKeyManagerFactory();\n-        keyManagerFactory.init(clientKeys, sslConfig.getKeystorePassword().toCharArray());\n-      }\n-    } finally {\n-      if (keyStoreStream != null) {\n-        keyStoreStream.close();\n-      }\n-    }\n-\n-    return keyManagerFactory != null ? keyManagerFactory.getKeyManagers() : null;\n-  }\n-\n   static KeyManagerFactory getDefaultKeyManagerFactory() throws NoSuchAlgorithmException {\n     return KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n   }\n \n-  private static TrustManager[] getTrustManagers(SSLConfig sslConfig, boolean skipSslVerification)\n-      throws Exception {\n-    FileInputStream trustStoreStream = null;\n-    TrustManagerFactory trustManagerFactory = null;\n-\n-    if (skipSslVerification) {\n-      TrustManager[] trustAllCerts = new TrustManager[] {new X509TrustManager() {\n-        @Override\n-        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n-          return null;\n-        }\n-\n-        @Override\n-        public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n-\n-        @Override\n-        public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n-\n-      }};\n-      return trustAllCerts;\n-    }\n-\n-    try {\n-      // load server public key\n-      if (StringUtils.isNotBlank(sslConfig.getTruststore())) {\n-        String trustStoreType = Objects.toString(sslConfig.getTruststoreType(), \"JKS\");\n-        KeyStore serverPub = KeyStore.getInstance(trustStoreType);\n-        trustStoreStream = new FileInputStream(sslConfig.getTruststore());\n-        serverPub.load(trustStoreStream, sslConfig.getTruststorePassword().toCharArray());\n-        trustManagerFactory = getDefaultTrustManagerFactory();\n-        trustManagerFactory.init(serverPub);\n-      }\n-    } finally {\n-      if (trustStoreStream != null) {\n-        trustStoreStream.close();\n-      }\n-    }\n-    return trustManagerFactory != null ? trustManagerFactory.getTrustManagers() : null;\n-  }\n-\n   static TrustManagerFactory getDefaultTrustManagerFactory()\n       throws NoSuchAlgorithmException {\n     return TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n   }\n-\n }"
  },
  {
    "sha": "96672e4cf44231537a2163b236d5448d8dc61544",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/net/SocketCreator.java",
    "status": "modified",
    "additions": 14,
    "deletions": 212,
    "changes": 226,
    "blob_url": "https://github.com/apache/geode/blob/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/main/java/org/apache/geode/internal/net/SocketCreator.java",
    "raw_url": "https://github.com/apache/geode/raw/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/main/java/org/apache/geode/internal/net/SocketCreator.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/net/SocketCreator.java?ref=1c4e5346bd92e44134ab86da875801130189a797",
    "patch": "@@ -15,8 +15,10 @@\n package org.apache.geode.internal.net;\n \n \n+import static org.apache.geode.internal.net.filewatch.FileWatchingX509ExtendedKeyManager.newFileWatchingKeyManager;\n+import static org.apache.geode.internal.net.filewatch.FileWatchingX509ExtendedTrustManager.newFileWatchingTrustManager;\n+\n import java.io.Console;\n-import java.io.FileInputStream;\n import java.io.IOException;\n import java.net.BindException;\n import java.net.InetAddress;\n@@ -29,14 +31,6 @@\n import java.nio.ByteBuffer;\n import java.nio.channels.SocketChannel;\n import java.security.GeneralSecurityException;\n-import java.security.KeyStore;\n-import java.security.KeyStoreException;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.Principal;\n-import java.security.PrivateKey;\n-import java.security.UnrecoverableKeyException;\n-import java.security.cert.CertificateException;\n-import java.security.cert.X509Certificate;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n@@ -45,7 +39,6 @@\n import java.util.concurrent.ConcurrentHashMap;\n \n import javax.net.ssl.KeyManager;\n-import javax.net.ssl.KeyManagerFactory;\n import javax.net.ssl.SNIHostName;\n import javax.net.ssl.SNIServerName;\n import javax.net.ssl.SSLContext;\n@@ -58,10 +51,7 @@\n import javax.net.ssl.SSLSocket;\n import javax.net.ssl.StandardConstants;\n import javax.net.ssl.TrustManager;\n-import javax.net.ssl.TrustManagerFactory;\n-import javax.net.ssl.X509ExtendedKeyManager;\n \n-import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.validator.routines.InetAddressValidator;\n import org.apache.logging.log4j.Logger;\n \n@@ -83,7 +73,6 @@\n import org.apache.geode.internal.cache.wan.TransportFilterSocketFactory;\n import org.apache.geode.internal.inet.LocalHostUtil;\n import org.apache.geode.internal.util.ArgumentRedactor;\n-import org.apache.geode.internal.util.PasswordUtil;\n import org.apache.geode.logging.internal.log4j.api.LogService;\n import org.apache.geode.net.SSLParameterExtension;\n import org.apache.geode.util.internal.GeodeGlossary;\n@@ -267,17 +256,24 @@ private void initialize() {\n    * @return new SSLContext configured using the given protocols & properties\n    *\n    * @throws GeneralSecurityException if security information can not be found\n-   * @throws IOException if information can not be loaded\n    */\n-  private SSLContext createAndConfigureSSLContext() throws GeneralSecurityException, IOException {\n+  private SSLContext createAndConfigureSSLContext() throws GeneralSecurityException {\n \n     if (sslConfig.useDefaultSSLContext()) {\n       return SSLContext.getDefault();\n     }\n \n     SSLContext newSSLContext = SSLUtil.getSSLContextInstance(sslConfig);\n-    KeyManager[] keyManagers = getKeyManagers();\n-    TrustManager[] trustManagers = getTrustManagers();\n+\n+    KeyManager[] keyManagers = null;\n+    if (sslConfig.getKeystore() != null) {\n+      keyManagers = new KeyManager[] {newFileWatchingKeyManager(sslConfig)};\n+    }\n+\n+    TrustManager[] trustManagers = null;\n+    if (sslConfig.getTruststore() != null) {\n+      trustManagers = new TrustManager[] {newFileWatchingTrustManager(sslConfig)};\n+    }\n \n     newSSLContext.init(keyManagers, trustManagers, null /* use the default secure random */);\n     return newSSLContext;\n@@ -326,106 +322,6 @@ public static void readSSLProperties(Map<String, String> env, boolean ignoreGemF\n     }\n   }\n \n-  private TrustManager[] getTrustManagers()\n-      throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n-    TrustManager[] trustManagers;\n-\n-    String trustStoreType = sslConfig.getTruststoreType();\n-    if (StringUtils.isEmpty(trustStoreType)) {\n-      trustStoreType = KeyStore.getDefaultType();\n-    }\n-\n-    KeyStore ts = KeyStore.getInstance(trustStoreType);\n-    String trustStorePath = sslConfig.getTruststore();\n-    char[] password = null;\n-    try (FileInputStream fis = new FileInputStream(trustStorePath)) {\n-      String passwordString = sslConfig.getTruststorePassword();\n-      if (passwordString != null) {\n-        if (passwordString.trim().equals(\"\")) {\n-          if (!StringUtils.isEmpty(passwordString)) {\n-            String toDecrypt = \"encrypted(\" + passwordString + \")\";\n-            passwordString = PasswordUtil.decrypt(toDecrypt);\n-            password = passwordString.toCharArray();\n-          }\n-        } else {\n-          password = passwordString.toCharArray();\n-        }\n-      }\n-      ts.load(fis, password);\n-    }\n-\n-    // default algorithm can be changed by setting property \"ssl.TrustManagerFactory.algorithm\" in\n-    // security properties\n-    TrustManagerFactory tmf =\n-        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n-    tmf.init(ts);\n-    trustManagers = tmf.getTrustManagers();\n-    // follow the security tip in java doc\n-    if (password != null) {\n-      java.util.Arrays.fill(password, ' ');\n-    }\n-\n-    return trustManagers;\n-  }\n-\n-  private KeyManager[] getKeyManagers() throws KeyStoreException, IOException,\n-      NoSuchAlgorithmException, CertificateException, UnrecoverableKeyException {\n-    if (sslConfig.getKeystore() == null) {\n-      return null;\n-    }\n-\n-    KeyManager[] keyManagers;\n-    String keyStoreType = sslConfig.getKeystoreType();\n-    if (StringUtils.isEmpty(keyStoreType)) {\n-      keyStoreType = KeyStore.getDefaultType();\n-    }\n-    KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n-    String keyStoreFilePath = sslConfig.getKeystore();\n-    if (StringUtils.isEmpty(keyStoreFilePath)) {\n-      keyStoreFilePath =\n-          System.getProperty(\"user.home\") + System.getProperty(\"file.separator\") + \".keystore\";\n-    }\n-\n-\n-    char[] password = null;\n-    try (FileInputStream fileInputStream = new FileInputStream(keyStoreFilePath)) {\n-      String passwordString = sslConfig.getKeystorePassword();\n-      if (passwordString != null) {\n-        if (passwordString.trim().equals(\"\")) {\n-          String encryptedPass = System.getenv(\"javax.net.ssl.keyStorePassword\");\n-          if (!StringUtils.isEmpty(encryptedPass)) {\n-            String toDecrypt = \"encrypted(\" + encryptedPass + \")\";\n-            passwordString = PasswordUtil.decrypt(toDecrypt);\n-            password = passwordString.toCharArray();\n-          }\n-        } else {\n-          password = passwordString.toCharArray();\n-        }\n-      }\n-      keyStore.load(fileInputStream, password);\n-    }\n-    // default algorithm can be changed by setting property \"ssl.KeyManagerFactory.algorithm\" in\n-    // security properties\n-    KeyManagerFactory keyManagerFactory =\n-        KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n-    keyManagerFactory.init(keyStore, password);\n-    keyManagers = keyManagerFactory.getKeyManagers();\n-    // follow the security tip in java doc\n-    if (password != null) {\n-      java.util.Arrays.fill(password, ' ');\n-    }\n-\n-    KeyManager[] extendedKeyManagers = new KeyManager[keyManagers.length];\n-\n-    for (int i = 0; i < keyManagers.length; i++)\n-\n-    {\n-      extendedKeyManagers[i] = new ExtendedAliasKeyManager(keyManagers[i], sslConfig.getAlias());\n-    }\n-\n-    return extendedKeyManagers;\n-  }\n-\n   /**\n    * context for SSL socket factories\n    */\n@@ -445,100 +341,6 @@ public SSLConfig getSslConfig() {\n     return sslConfig;\n   }\n \n-  /**\n-   * ExtendedAliasKeyManager supports use of certificate aliases in distributed system\n-   * properties.\n-   */\n-  private static class ExtendedAliasKeyManager extends X509ExtendedKeyManager {\n-\n-    private final X509ExtendedKeyManager delegate;\n-\n-    private final String keyAlias;\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param mgr The X509KeyManager used as a delegate\n-     * @param keyAlias The alias name of the server's keypair and supporting certificate chain\n-     */\n-    ExtendedAliasKeyManager(KeyManager mgr, String keyAlias) {\n-      this.delegate = (X509ExtendedKeyManager) mgr;\n-      this.keyAlias = keyAlias;\n-    }\n-\n-\n-    @Override\n-    public String[] getClientAliases(final String s, final Principal[] principals) {\n-      return delegate.getClientAliases(s, principals);\n-    }\n-\n-    @Override\n-    public String chooseClientAlias(final String[] strings, final Principal[] principals,\n-        final Socket socket) {\n-      if (!StringUtils.isEmpty(this.keyAlias)) {\n-        return keyAlias;\n-      }\n-      return delegate.chooseClientAlias(strings, principals, socket);\n-    }\n-\n-    @Override\n-    public String[] getServerAliases(final String s, final Principal[] principals) {\n-      return delegate.getServerAliases(s, principals);\n-    }\n-\n-    @Override\n-    public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket) {\n-      if (!StringUtils.isEmpty(this.keyAlias)) {\n-        PrivateKey key = this.delegate.getPrivateKey(this.keyAlias);\n-        return getKeyAlias(keyType, key);\n-      }\n-      return this.delegate.chooseServerAlias(keyType, issuers, socket);\n-\n-    }\n-\n-    @Override\n-    public X509Certificate[] getCertificateChain(final String s) {\n-      if (!StringUtils.isEmpty(this.keyAlias)) {\n-        return delegate.getCertificateChain(keyAlias);\n-      }\n-      return delegate.getCertificateChain(s);\n-    }\n-\n-    @Override\n-    public PrivateKey getPrivateKey(final String alias) {\n-      return delegate.getPrivateKey(alias);\n-    }\n-\n-    @Override\n-    public String chooseEngineClientAlias(String[] keyTypes, Principal[] principals,\n-        SSLEngine sslEngine) {\n-      return delegate.chooseEngineClientAlias(keyTypes, principals, sslEngine);\n-    }\n-\n-    @Override\n-    public String chooseEngineServerAlias(final String keyType, final Principal[] principals,\n-        final SSLEngine sslEngine) {\n-      if (!StringUtils.isEmpty(this.keyAlias)) {\n-        PrivateKey key = this.delegate.getPrivateKey(this.keyAlias);\n-        return getKeyAlias(keyType, key);\n-      }\n-      return this.delegate.chooseEngineServerAlias(keyType, principals, sslEngine);\n-\n-    }\n-\n-    private String getKeyAlias(final String keyType, final PrivateKey key) {\n-      if (key != null) {\n-        if (key.getAlgorithm().equals(keyType)) {\n-          return this.keyAlias;\n-        } else {\n-          return null;\n-        }\n-      } else {\n-        return null;\n-      }\n-    }\n-  }\n-\n   /**\n    * Returns true if this SocketCreator is configured to use SSL.\n    */"
  },
  {
    "sha": "44881a2a4e5ffa291f646b8548fdddf6a19db2e8",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/net/filewatch/ExtendedAliasKeyManager.java",
    "status": "added",
    "additions": 120,
    "deletions": 0,
    "changes": 120,
    "blob_url": "https://github.com/apache/geode/blob/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/main/java/org/apache/geode/internal/net/filewatch/ExtendedAliasKeyManager.java",
    "raw_url": "https://github.com/apache/geode/raw/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/main/java/org/apache/geode/internal/net/filewatch/ExtendedAliasKeyManager.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/net/filewatch/ExtendedAliasKeyManager.java?ref=1c4e5346bd92e44134ab86da875801130189a797",
    "patch": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.net.filewatch;\n+\n+\n+import java.net.Socket;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+/**\n+ * ExtendedAliasKeyManager supports use of certificate aliases in distributed system\n+ * properties.\n+ */\n+final class ExtendedAliasKeyManager extends X509ExtendedKeyManager {\n+\n+  private final X509ExtendedKeyManager delegate;\n+\n+  private final String keyAlias;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param mgr The X509KeyManager used as a delegate\n+   * @param keyAlias The alias name of the server's keypair and supporting certificate chain\n+   */\n+  ExtendedAliasKeyManager(X509ExtendedKeyManager mgr, String keyAlias) {\n+    this.delegate = mgr;\n+    this.keyAlias = keyAlias;\n+  }\n+\n+\n+  @Override\n+  public String[] getClientAliases(final String s, final Principal[] principals) {\n+    return delegate.getClientAliases(s, principals);\n+  }\n+\n+  @Override\n+  public String chooseClientAlias(final String[] strings, final Principal[] principals,\n+      final Socket socket) {\n+    if (!StringUtils.isEmpty(this.keyAlias)) {\n+      return keyAlias;\n+    }\n+    return delegate.chooseClientAlias(strings, principals, socket);\n+  }\n+\n+  @Override\n+  public String[] getServerAliases(final String s, final Principal[] principals) {\n+    return delegate.getServerAliases(s, principals);\n+  }\n+\n+  @Override\n+  public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket) {\n+    if (!StringUtils.isEmpty(this.keyAlias)) {\n+      PrivateKey key = this.delegate.getPrivateKey(this.keyAlias);\n+      return getKeyAlias(keyType, key);\n+    }\n+    return this.delegate.chooseServerAlias(keyType, issuers, socket);\n+\n+  }\n+\n+  @Override\n+  public X509Certificate[] getCertificateChain(final String s) {\n+    if (!StringUtils.isEmpty(this.keyAlias)) {\n+      return delegate.getCertificateChain(keyAlias);\n+    }\n+    return delegate.getCertificateChain(s);\n+  }\n+\n+  @Override\n+  public PrivateKey getPrivateKey(final String alias) {\n+    return delegate.getPrivateKey(alias);\n+  }\n+\n+  @Override\n+  public String chooseEngineClientAlias(String[] keyTypes, Principal[] principals,\n+      SSLEngine sslEngine) {\n+    return delegate.chooseEngineClientAlias(keyTypes, principals, sslEngine);\n+  }\n+\n+  @Override\n+  public String chooseEngineServerAlias(final String keyType, final Principal[] principals,\n+      final SSLEngine sslEngine) {\n+    if (!StringUtils.isEmpty(this.keyAlias)) {\n+      PrivateKey key = this.delegate.getPrivateKey(this.keyAlias);\n+      return getKeyAlias(keyType, key);\n+    }\n+    return this.delegate.chooseEngineServerAlias(keyType, principals, sslEngine);\n+\n+  }\n+\n+  private String getKeyAlias(final String keyType, final PrivateKey key) {\n+    if (key != null) {\n+      if (key.getAlgorithm().equals(keyType)) {\n+        return this.keyAlias;\n+      } else {\n+        return null;\n+      }\n+    } else {\n+      return null;\n+    }\n+  }\n+}"
  },
  {
    "sha": "150163a1e6278c412e16f2d82658f9edaf5208f0",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedKeyManager.java",
    "status": "added",
    "additions": 242,
    "deletions": 0,
    "changes": 242,
    "blob_url": "https://github.com/apache/geode/blob/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/main/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedKeyManager.java",
    "raw_url": "https://github.com/apache/geode/raw/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/main/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedKeyManager.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedKeyManager.java?ref=1c4e5346bd92e44134ab86da875801130189a797",
    "patch": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.net.filewatch;\n+\n+import java.io.FileInputStream;\n+import java.net.Socket;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.KeyStore;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.InternalGemFireException;\n+import org.apache.geode.annotations.VisibleForTesting;\n+import org.apache.geode.annotations.internal.MakeNotStatic;\n+import org.apache.geode.internal.net.SSLConfig;\n+import org.apache.geode.internal.util.PasswordUtil;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+/**\n+ * Watches a key store file and updates the underlying key manager when the file is changed.\n+ */\n+public final class FileWatchingX509ExtendedKeyManager extends X509ExtendedKeyManager {\n+\n+  private static final Logger logger = LogService.getLogger();\n+\n+  /*\n+   * This annotation is needed for the PMD checks to pass, but it probably should not be a\n+   * cache-scoped field since there only needs to be one set of instances per JVM.\n+   */\n+  @MakeNotStatic\n+  private static final ConcurrentHashMap<PathAndAlias, FileWatchingX509ExtendedKeyManager> instances =\n+      new ConcurrentHashMap<>();\n+\n+  private final AtomicReference<X509ExtendedKeyManager> keyManager = new AtomicReference<>();\n+  private final Path keyStorePath;\n+  private final String keyStoreType;\n+  private final String keyStorePassword;\n+  private final String keyStoreAlias;\n+  private final PollingFileWatcher fileWatcher;\n+\n+  private FileWatchingX509ExtendedKeyManager(Path keyStorePath, String keyStoreType,\n+      String keyStorePassword, String keyStoreAlias) {\n+    this.keyStorePath = keyStorePath;\n+    this.keyStoreType = keyStoreType;\n+    this.keyStorePassword = keyStorePassword;\n+    this.keyStoreAlias = keyStoreAlias;\n+\n+    loadKeyManager();\n+\n+    fileWatcher =\n+        new PollingFileWatcher(this.keyStorePath, this::loadKeyManager, this::stopWatching);\n+  }\n+\n+  /**\n+   * Returns a {@link FileWatchingX509ExtendedKeyManager} for the given SSL config. A new instance\n+   * will be created only if one does not already exist for the provided key store path and alias.\n+   *\n+   * @param config The SSL config to use to load the key manager\n+   */\n+  public static FileWatchingX509ExtendedKeyManager newFileWatchingKeyManager(SSLConfig config) {\n+    Path path = Paths.get(config.getKeystore());\n+    String type = config.getKeystoreType();\n+    String password = config.getKeystorePassword();\n+    String alias = config.getAlias();\n+\n+    return instances.computeIfAbsent(new PathAndAlias(path, alias),\n+        (PathAndAlias k) -> new FileWatchingX509ExtendedKeyManager(path, type, password, alias));\n+  }\n+\n+  @Override\n+  public String chooseClientAlias(String[] strings, Principal[] principals, Socket socket) {\n+    return keyManager.get().chooseClientAlias(strings, principals, socket);\n+  }\n+\n+  @Override\n+  public String chooseEngineClientAlias(String[] strings, Principal[] principals,\n+      SSLEngine sslEngine) {\n+    return keyManager.get().chooseEngineClientAlias(strings, principals, sslEngine);\n+  }\n+\n+  @Override\n+  public String chooseEngineServerAlias(String s, Principal[] principals, SSLEngine sslEngine) {\n+    return keyManager.get().chooseEngineServerAlias(s, principals, sslEngine);\n+  }\n+\n+  @Override\n+  public String chooseServerAlias(String s, Principal[] principals, Socket socket) {\n+    return keyManager.get().chooseServerAlias(s, principals, socket);\n+  }\n+\n+  @Override\n+  public X509Certificate[] getCertificateChain(String s) {\n+    return keyManager.get().getCertificateChain(s);\n+  }\n+\n+  @Override\n+  public String[] getClientAliases(String s, Principal[] principals) {\n+    return keyManager.get().getClientAliases(s, principals);\n+  }\n+\n+  @Override\n+  public PrivateKey getPrivateKey(String s) {\n+    return keyManager.get().getPrivateKey(s);\n+  }\n+\n+  @Override\n+  public String[] getServerAliases(String s, Principal[] principals) {\n+    return keyManager.get().getServerAliases(s, principals);\n+  }\n+\n+  @VisibleForTesting\n+  void stopWatching() {\n+    fileWatcher.stop();\n+    instances.remove(new PathAndAlias(keyStorePath, keyStoreAlias), this);\n+  }\n+\n+  @VisibleForTesting\n+  boolean isWatching() {\n+    return instances.get(new PathAndAlias(keyStorePath, keyStoreAlias)) == this;\n+  }\n+\n+  private void loadKeyManager() {\n+    KeyManager[] keyManagers;\n+    try {\n+      KeyStore keyStore;\n+      if (StringUtils.isEmpty(keyStoreType)) {\n+        keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+      } else {\n+        keyStore = KeyStore.getInstance(keyStoreType);\n+      }\n+\n+      String keyStoreFilePath = keyStorePath.toString();\n+      if (StringUtils.isEmpty(keyStoreFilePath)) {\n+        keyStoreFilePath =\n+            System.getProperty(\"user.home\") + System.getProperty(\"file.separator\") + \".keystore\";\n+      }\n+\n+      char[] password = null;\n+      try (FileInputStream fileInputStream = new FileInputStream(keyStoreFilePath)) {\n+        String passwordString = keyStorePassword;\n+        if (passwordString != null) {\n+          if (passwordString.trim().equals(\"\")) {\n+            String encryptedPass = System.getenv(\"javax.net.ssl.keyStorePassword\");\n+            if (!StringUtils.isEmpty(encryptedPass)) {\n+              String toDecrypt = \"encrypted(\" + encryptedPass + \")\";\n+              passwordString = PasswordUtil.decrypt(toDecrypt);\n+              password = passwordString.toCharArray();\n+            }\n+          } else {\n+            password = passwordString.toCharArray();\n+          }\n+        }\n+        keyStore.load(fileInputStream, password);\n+      }\n+\n+      // default algorithm can be changed by setting property \"ssl.KeyManagerFactory.algorithm\" in\n+      // security properties\n+      KeyManagerFactory keyManagerFactory =\n+          KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+      keyManagerFactory.init(keyStore, password);\n+      keyManagers = keyManagerFactory.getKeyManagers();\n+\n+      // follow the security tip in java doc\n+      if (password != null) {\n+        java.util.Arrays.fill(password, ' ');\n+      }\n+    } catch (Exception e) {\n+      throw new InternalGemFireException(\"Unable to load KeyManager\", e);\n+    }\n+\n+    for (KeyManager km : keyManagers) {\n+      if (km instanceof X509ExtendedKeyManager) {\n+\n+        ExtendedAliasKeyManager extendedAliasKeyManager =\n+            new ExtendedAliasKeyManager((X509ExtendedKeyManager) km, keyStoreAlias);\n+\n+        if (keyManager.getAndSet(extendedAliasKeyManager) == null) {\n+          logger.info(\"Initialized KeyManager for {}\", keyStorePath);\n+        } else {\n+          logger.info(\"Updated KeyManager for {}\", keyStorePath);\n+        }\n+\n+        return;\n+      }\n+    }\n+\n+    throw new IllegalStateException(\"No X509ExtendedKeyManager available\");\n+  }\n+\n+  private static class PathAndAlias {\n+    private final Path keyStorePath;\n+    private final String keyStoreAlias;\n+\n+    public PathAndAlias(Path keyStorePath, String keyStoreAlias) {\n+      this.keyStorePath = keyStorePath;\n+      this.keyStoreAlias = keyStoreAlias;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      PathAndAlias that = (PathAndAlias) o;\n+      return Objects.equals(keyStorePath, that.keyStorePath) && Objects\n+          .equals(keyStoreAlias, that.keyStoreAlias);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(keyStorePath, keyStoreAlias);\n+    }\n+  }\n+}"
  },
  {
    "sha": "b593d0907026636a47033f4a7669627936fd8171",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedTrustManager.java",
    "status": "added",
    "additions": 200,
    "deletions": 0,
    "changes": 200,
    "blob_url": "https://github.com/apache/geode/blob/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/main/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedTrustManager.java",
    "raw_url": "https://github.com/apache/geode/raw/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/main/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedTrustManager.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/net/filewatch/FileWatchingX509ExtendedTrustManager.java?ref=1c4e5346bd92e44134ab86da875801130189a797",
    "patch": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.net.filewatch;\n+\n+\n+import java.io.FileInputStream;\n+import java.net.Socket;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.KeyStore;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509ExtendedTrustManager;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.InternalGemFireException;\n+import org.apache.geode.annotations.VisibleForTesting;\n+import org.apache.geode.annotations.internal.MakeNotStatic;\n+import org.apache.geode.internal.net.SSLConfig;\n+import org.apache.geode.internal.util.PasswordUtil;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+/**\n+ * Watches a trust store file and updates the underlying trust manager when the file is changed.\n+ */\n+public final class FileWatchingX509ExtendedTrustManager extends X509ExtendedTrustManager {\n+\n+  private static final Logger logger = LogService.getLogger();\n+\n+  /*\n+   * This annotation is needed for the PMD checks to pass, but it probably should not be a\n+   * cache-scoped field since there only needs to be one set of instances per JVM.\n+   */\n+  @MakeNotStatic\n+  private static final ConcurrentHashMap<Path, FileWatchingX509ExtendedTrustManager> instances =\n+      new ConcurrentHashMap<>();\n+\n+  private final AtomicReference<X509ExtendedTrustManager> trustManager = new AtomicReference<>();\n+  private final Path trustStorePath;\n+  private final String trustStoreType;\n+  private final String trustStorePassword;\n+  private final PollingFileWatcher fileWatcher;\n+\n+  private FileWatchingX509ExtendedTrustManager(Path trustStorePath, String trustStoreType,\n+      String trustStorePassword) {\n+    this.trustStorePath = trustStorePath;\n+    this.trustStoreType = trustStoreType;\n+    this.trustStorePassword = trustStorePassword;\n+\n+    loadTrustManager();\n+\n+    fileWatcher =\n+        new PollingFileWatcher(this.trustStorePath, this::loadTrustManager, this::stopWatching);\n+  }\n+\n+  /**\n+   * Returns a {@link FileWatchingX509ExtendedKeyManager} for the given SSL config. A new instance\n+   * will be created only if one does not already exist for the provided trust store path.\n+   *\n+   * @param config The SSL config to use to load the trust manager\n+   */\n+  public static FileWatchingX509ExtendedTrustManager newFileWatchingTrustManager(SSLConfig config) {\n+    Path path = Paths.get(config.getTruststore());\n+    String type = config.getTruststoreType();\n+    String password = config.getTruststorePassword();\n+\n+    return instances.computeIfAbsent(path,\n+        (Path p) -> new FileWatchingX509ExtendedTrustManager(path, type, password));\n+  }\n+\n+  @Override\n+  public void checkClientTrusted(X509Certificate[] x509Certificates, String s, Socket socket)\n+      throws CertificateException {\n+    trustManager.get().checkClientTrusted(x509Certificates, s, socket);\n+  }\n+\n+  @Override\n+  public void checkClientTrusted(X509Certificate[] x509Certificates, String s, SSLEngine sslEngine)\n+      throws CertificateException {\n+    trustManager.get().checkClientTrusted(x509Certificates, s, sslEngine);\n+  }\n+\n+  @Override\n+  public void checkClientTrusted(X509Certificate[] x509Certificates, String s)\n+      throws CertificateException {\n+    trustManager.get().checkClientTrusted(x509Certificates, s);\n+  }\n+\n+  @Override\n+  public void checkServerTrusted(X509Certificate[] x509Certificates, String s, SSLEngine sslEngine)\n+      throws CertificateException {\n+    trustManager.get().checkServerTrusted(x509Certificates, s, sslEngine);\n+  }\n+\n+  @Override\n+  public void checkServerTrusted(X509Certificate[] x509Certificates, String s, Socket socket)\n+      throws CertificateException {\n+    trustManager.get().checkServerTrusted(x509Certificates, s, socket);\n+  }\n+\n+  @Override\n+  public void checkServerTrusted(X509Certificate[] x509Certificates, String s)\n+      throws CertificateException {\n+    trustManager.get().checkServerTrusted(x509Certificates, s);\n+  }\n+\n+  @Override\n+  public X509Certificate[] getAcceptedIssuers() {\n+    return trustManager.get().getAcceptedIssuers();\n+  }\n+\n+  @VisibleForTesting\n+  void stopWatching() {\n+    fileWatcher.stop();\n+    instances.remove(trustStorePath, this);\n+  }\n+\n+  @VisibleForTesting\n+  boolean isWatching() {\n+    return instances.get(trustStorePath) == this;\n+  }\n+\n+  private void loadTrustManager() {\n+    TrustManager[] trustManagers;\n+    try {\n+      KeyStore trustStore;\n+      if (StringUtils.isEmpty(trustStoreType)) {\n+        trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+      } else {\n+        trustStore = KeyStore.getInstance(trustStoreType);\n+      }\n+\n+      char[] password = null;\n+      try (FileInputStream fis = new FileInputStream(trustStorePath.toString())) {\n+        String passwordString = trustStorePassword;\n+        if (passwordString != null) {\n+          if (passwordString.trim().equals(\"\")) {\n+            if (!StringUtils.isEmpty(passwordString)) {\n+              String toDecrypt = \"encrypted(\" + passwordString + \")\";\n+              passwordString = PasswordUtil.decrypt(toDecrypt);\n+              password = passwordString.toCharArray();\n+            }\n+          } else {\n+            password = passwordString.toCharArray();\n+          }\n+        }\n+        trustStore.load(fis, password);\n+      }\n+\n+      // default algorithm can be changed by setting property \"ssl.TrustManagerFactory.algorithm\" in\n+      // security properties\n+      TrustManagerFactory tmf =\n+          TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+      tmf.init(trustStore);\n+      trustManagers = tmf.getTrustManagers();\n+\n+      // follow the security tip in java doc\n+      if (password != null) {\n+        java.util.Arrays.fill(password, ' ');\n+      }\n+    } catch (Exception e) {\n+      throw new InternalGemFireException(\"Unable to load TrustManager\", e);\n+    }\n+\n+    for (TrustManager tm : trustManagers) {\n+      if (tm instanceof X509ExtendedTrustManager) {\n+\n+        if (trustManager.getAndSet((X509ExtendedTrustManager) tm) == null) {\n+          logger.info(\"Initialized TrustManager for {}\", trustStorePath);\n+        } else {\n+          logger.info(\"Updated TrustManager for {}\", trustStorePath);\n+        }\n+\n+        return;\n+      }\n+    }\n+\n+    throw new IllegalStateException(\"No X509ExtendedTrustManager available\");\n+  }\n+}"
  },
  {
    "sha": "ae5a3ba9913f18162b4f70d45c70fd40f2566f64",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/net/filewatch/PollingFileWatcher.java",
    "status": "added",
    "additions": 92,
    "deletions": 0,
    "changes": 92,
    "blob_url": "https://github.com/apache/geode/blob/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/main/java/org/apache/geode/internal/net/filewatch/PollingFileWatcher.java",
    "raw_url": "https://github.com/apache/geode/raw/1c4e5346bd92e44134ab86da875801130189a797/geode-core/src/main/java/org/apache/geode/internal/net/filewatch/PollingFileWatcher.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/net/filewatch/PollingFileWatcher.java?ref=1c4e5346bd92e44134ab86da875801130189a797",
    "patch": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.net.filewatch;\n+\n+import static java.nio.file.LinkOption.NOFOLLOW_LINKS;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.WatchService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.InternalGemFireException;\n+import org.apache.geode.logging.internal.executors.LoggingExecutors;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+/**\n+ * Watches a single file for changes by polling the last modified time on the file.\n+ *\n+ * <p>\n+ * Note: {@link WatchService} is not used here because it has problems with container file systems\n+ * and remote file systems.\n+ * </p>\n+ */\n+final class PollingFileWatcher {\n+  private static final long PERIOD_SECONDS = 10;\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private final Path path;\n+  private final Runnable onUpdate;\n+  private final Runnable onError;\n+  private final ScheduledExecutorService executor;\n+\n+  private long lastModifiedTimeMillis;\n+\n+  PollingFileWatcher(Path path, Runnable onUpdate, Runnable onError) {\n+    this.path = path;\n+    this.onUpdate = onUpdate;\n+    this.onError = onError;\n+\n+    try {\n+      lastModifiedTimeMillis = Files.getLastModifiedTime(path, NOFOLLOW_LINKS).toMillis();\n+    } catch (IOException e) {\n+      throw new InternalGemFireException(\"Unable to start watching \" + path, e);\n+    }\n+\n+    executor = LoggingExecutors.newSingleThreadScheduledExecutor(threadNameForPath(path));\n+    executor.scheduleAtFixedRate(this::poll, PERIOD_SECONDS, PERIOD_SECONDS, TimeUnit.SECONDS);\n+\n+    logger.info(\"Started watching {}\", path);\n+  }\n+\n+  void stop() {\n+    executor.shutdown();\n+    logger.info(\"Stopped watching {}\", path);\n+  }\n+\n+  private void poll() {\n+    try {\n+      long timeStampMillis = Files.getLastModifiedTime(path, NOFOLLOW_LINKS).toMillis();\n+      if (timeStampMillis != lastModifiedTimeMillis) {\n+        logger.debug(\"Detected update for {}\", path);\n+        lastModifiedTimeMillis = timeStampMillis;\n+        onUpdate.run();\n+      } else {\n+        logger.debug(\"No change detected for {}\", path);\n+      }\n+    } catch (Exception e) {\n+      logger.debug(\"Error watching {}\", path, e);\n+      onError.run();\n+    }\n+  }\n+\n+  private static String threadNameForPath(Path path) {\n+    return String.format(\"file-watcher-%s-\", path.getName(path.getNameCount() - 1));\n+  }\n+}"
  },
  {
    "sha": "6cce93054b52309936bac0b110a1f65934630e45",
    "filename": "geode-junit/src/main/java/org/apache/geode/cache/ssl/CertStores.java",
    "status": "modified",
    "additions": 5,
    "deletions": 4,
    "changes": 9,
    "blob_url": "https://github.com/apache/geode/blob/1c4e5346bd92e44134ab86da875801130189a797/geode-junit/src/main/java/org/apache/geode/cache/ssl/CertStores.java",
    "raw_url": "https://github.com/apache/geode/raw/1c4e5346bd92e44134ab86da875801130189a797/geode-junit/src/main/java/org/apache/geode/cache/ssl/CertStores.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-junit/src/main/java/org/apache/geode/cache/ssl/CertStores.java?ref=1c4e5346bd92e44134ab86da875801130189a797",
    "patch": "@@ -107,12 +107,13 @@ public Properties propertiesWith(String components, String protocols,\n     keyStoreFile.deleteOnExit();\n     createKeyStore(keyStoreFile.getPath(), keyStorePassword);\n \n-    return propertiesWith(components, protocols, ciphers, trustStoreFile, keyStoreFile, requireAuth,\n-        endPointIdentification);\n+    return propertiesWith(components, protocols, ciphers, trustStoreFile, trustStorePassword,\n+        keyStoreFile, keyStorePassword, requireAuth, endPointIdentification);\n   }\n \n-  private Properties propertiesWith(String components, String protocols, String ciphers,\n-      File trustStoreFile, File keyStoreFile, boolean requireAuth, boolean endPointVerification) {\n+  public static Properties propertiesWith(String components, String protocols, String ciphers,\n+      File trustStoreFile, String trustStorePassword, File keyStoreFile, String keyStorePassword,\n+      boolean requireAuth, boolean endPointVerification) {\n \n     Properties sslConfigs = new Properties();\n     sslConfigs.setProperty(SSL_ENABLED_COMPONENTS, components);"
  }
]
