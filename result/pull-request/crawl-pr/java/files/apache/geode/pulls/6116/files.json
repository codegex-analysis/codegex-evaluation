[
  {
    "sha": "27d42542be76529c630a492b8c71af77ab602282",
    "filename": "geode-assembly/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandIntegrationTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-assembly/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandIntegrationTest.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-assembly/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandIntegrationTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-assembly/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandIntegrationTest.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -86,7 +86,7 @@ public void startWithBindAddress() throws Exception {\n     verify(spy).getProcess(any(), commandLines.capture());\n \n     String[] lines = commandLines.getValue();\n-    assertThat(lines[12]).isEqualTo(\"--bind-address=127.0.0.1\");\n+    assertThat(lines).containsOnlyOnce(\"--bind-address=127.0.0.1\");\n   }\n \n   @Test"
  },
  {
    "sha": "5e0b75f4c9ba60b23b109a41e00567ea5c6f0892",
    "filename": "geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandWorkingDirectoryTest.java",
    "status": "removed",
    "additions": 0,
    "deletions": 152,
    "changes": 152,
    "blob_url": "https://github.com/apache/geode/blob/7aae7b8158a0c8aecc15468a81a421bd6ffdc05e/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandWorkingDirectoryTest.java",
    "raw_url": "https://github.com/apache/geode/raw/7aae7b8158a0c8aecc15468a81a421bd6ffdc05e/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandWorkingDirectoryTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandWorkingDirectoryTest.java?ref=7aae7b8158a0c8aecc15468a81a421bd6ffdc05e",
    "patch": "@@ -1,152 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n- * agreements. See the NOTICE file distributed with this work for additional information regarding\n- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n- * copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package org.apache.geode.management.internal.cli.commands;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.ArgumentMatchers.anyBoolean;\n-import static org.mockito.ArgumentMatchers.anyInt;\n-import static org.mockito.ArgumentMatchers.anyString;\n-import static org.mockito.ArgumentMatchers.isNull;\n-import static org.mockito.Mockito.doReturn;\n-import static org.mockito.Mockito.spy;\n-import static org.mockito.Mockito.verify;\n-\n-import java.io.File;\n-\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.mockito.ArgumentCaptor;\n-\n-public class StartLocatorCommandWorkingDirectoryTest {\n-\n-  private String memberName;\n-  private String workingDirectory;\n-  private StartLocatorCommand startLocatorCommand;\n-  private ArgumentCaptor<String> workingDirectoryCaptor;\n-\n-  @Before\n-  public void setUp() throws Exception {\n-    memberName = \"locator1\";\n-    startLocatorCommand = spy(new StartLocatorCommand());\n-\n-    doReturn(null).when(startLocatorCommand).doStartLocator(\n-        anyString(), isNull(), isNull(), anyBoolean(),\n-        isNull(), isNull(), isNull(), anyBoolean(),\n-        isNull(), isNull(), isNull(), anyInt(),\n-        anyInt(), anyString(), isNull(), isNull(),\n-        isNull(), isNull(), isNull(), anyBoolean(),\n-        anyBoolean(), anyBoolean(), isNull(), anyInt(),\n-        isNull(), anyBoolean());\n-\n-    workingDirectoryCaptor = ArgumentCaptor.forClass(String.class);\n-  }\n-\n-  @Test\n-  public void startLocatorWithRelativeWorkingDirectory() throws Exception {\n-    workingDirectory = \"locator1Directory\";\n-\n-    startLocatorCommand.startLocator(memberName, null, null, false,\n-        null, null, null, false,\n-        null, null, null, 0,\n-        0, workingDirectory, null, null,\n-        null, null, null, false,\n-        false, false, null, 0,\n-        null, false);\n-\n-    verifyDoStartLocatorInvoked();\n-\n-    assertThat(workingDirectoryCaptor.getValue())\n-        .isEqualTo(new File(workingDirectory).getAbsolutePath());\n-  }\n-\n-  @Test\n-  public void startLocatorWithNullWorkingDirectory() throws Exception {\n-    workingDirectory = null;\n-\n-    startLocatorCommand.startLocator(memberName, null, null, false,\n-        null, null, null, false,\n-        null, null, null, 0,\n-        0, workingDirectory, null, null,\n-        null, null, null, false,\n-        false, false, null, 0,\n-        null, false);\n-\n-    verifyDoStartLocatorInvoked();\n-\n-    assertThat(workingDirectoryCaptor.getValue()).isEqualTo(new File(memberName).getAbsolutePath());\n-  }\n-\n-  @Test\n-  public void startLocatorWithEmptyWorkingDirectory() throws Exception {\n-    workingDirectory = \"\";\n-\n-    startLocatorCommand.startLocator(memberName, null, null, false,\n-        null, null, null, false,\n-        null, null, null, 0,\n-        0, workingDirectory, null, null,\n-        null, null, null, false,\n-        false, false, null, 0,\n-        null, false);\n-\n-    verifyDoStartLocatorInvoked();\n-\n-    assertThat(workingDirectoryCaptor.getValue()).isEqualTo(new File(memberName).getAbsolutePath());\n-  }\n-\n-  @Test\n-  public void startLocatorWithDotWorkingDirectory() throws Exception {\n-    workingDirectory = \".\";\n-\n-    startLocatorCommand.startLocator(memberName, null, null, false,\n-        null, null, null, false,\n-        null, null, null, 0,\n-        0, workingDirectory, null, null,\n-        null, null, null, false,\n-        false, false, null, 0,\n-        null, false);\n-\n-    verifyDoStartLocatorInvoked();\n-\n-    assertThat(workingDirectoryCaptor.getValue())\n-        .isEqualTo(StartMemberUtils.resolveWorkingDir(new File(\".\"), new File(memberName)));\n-  }\n-\n-  @Test\n-  public void startLocatorWithAbsoluteWorkingDirectory() throws Exception {\n-    workingDirectory = new File(System.getProperty(\"user.dir\")).getAbsolutePath();\n-\n-    startLocatorCommand.startLocator(memberName, null, null, false,\n-        null, null, null, false,\n-        null, null, null, 0,\n-        0, workingDirectory, null, null,\n-        null, null, null, false,\n-        false, false, null, 0,\n-        null, false);\n-\n-    verifyDoStartLocatorInvoked();\n-\n-    assertThat(workingDirectoryCaptor.getValue()).isEqualTo(workingDirectory);\n-  }\n-\n-  private void verifyDoStartLocatorInvoked()\n-      throws Exception {\n-    verify(startLocatorCommand).doStartLocator(anyString(), isNull(), isNull(), anyBoolean(),\n-        isNull(), isNull(), isNull(), anyBoolean(), isNull(),\n-        isNull(), isNull(), anyInt(), anyInt(), workingDirectoryCaptor.capture(),\n-        isNull(), isNull(), isNull(), isNull(), isNull(),\n-        anyBoolean(), anyBoolean(), anyBoolean(), isNull(), anyInt(), isNull(),\n-        anyBoolean());\n-  }\n-}"
  },
  {
    "sha": "e7568658be0c7e04fcab08d52c9516ef21715770",
    "filename": "geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandWorkingDirectoryTest.java",
    "status": "removed",
    "additions": 0,
    "deletions": 146,
    "changes": 146,
    "blob_url": "https://github.com/apache/geode/blob/7aae7b8158a0c8aecc15468a81a421bd6ffdc05e/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandWorkingDirectoryTest.java",
    "raw_url": "https://github.com/apache/geode/raw/7aae7b8158a0c8aecc15468a81a421bd6ffdc05e/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandWorkingDirectoryTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandWorkingDirectoryTest.java?ref=7aae7b8158a0c8aecc15468a81a421bd6ffdc05e",
    "patch": "@@ -1,146 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n- * agreements. See the NOTICE file distributed with this work for additional information regarding\n- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n- * copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package org.apache.geode.management.internal.cli.commands;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.ArgumentMatchers.anyBoolean;\n-import static org.mockito.ArgumentMatchers.anyFloat;\n-import static org.mockito.ArgumentMatchers.anyInt;\n-import static org.mockito.ArgumentMatchers.anyString;\n-import static org.mockito.ArgumentMatchers.isNull;\n-import static org.mockito.Mockito.doReturn;\n-import static org.mockito.Mockito.spy;\n-import static org.mockito.Mockito.verify;\n-\n-import java.io.File;\n-\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.mockito.ArgumentCaptor;\n-\n-public class StartServerCommandWorkingDirectoryTest {\n-\n-  private String memberName;\n-  private String workingDirectory;\n-  private StartServerCommand startServerCommand;\n-  private ArgumentCaptor<String> workingDirectoryCaptor;\n-\n-  @Before\n-  public void setUp() throws Exception {\n-    memberName = \"server1\";\n-    startServerCommand = spy(new StartServerCommand());\n-\n-    doReturn(null).when(startServerCommand)\n-        .doStartServer(anyString(), anyBoolean(), isNull(), isNull(), isNull(), anyFloat(),\n-            anyFloat(), anyString(), anyBoolean(), anyBoolean(), anyBoolean(), anyFloat(),\n-            anyFloat(), anyBoolean(), isNull(), isNull(), isNull(), anyBoolean(), isNull(),\n-            isNull(), isNull(), anyInt(), anyBoolean(), isNull(), anyInt(), isNull(), anyInt(),\n-            anyInt(), isNull(), anyInt(), anyInt(), isNull(), isNull(), anyInt(), isNull(),\n-            isNull(), anyInt(), isNull(), isNull(), anyBoolean(), isNull(), isNull(), anyInt(),\n-            anyInt(), isNull(), isNull(), anyBoolean(), anyBoolean(), isNull(), isNull(), isNull(),\n-            isNull(), anyBoolean());\n-\n-    workingDirectoryCaptor = ArgumentCaptor.forClass(String.class);\n-  }\n-\n-  @Test\n-  public void startLocatorWithRelativeWorkingDirectory() throws Exception {\n-    workingDirectory = \"server1Directory\";\n-\n-    startServerCommand\n-        .startServer(memberName, false, null, null, null, 0.0f, 0.0f, workingDirectory, false,\n-            false, false, 0.0f, 0.0f, false, null, null, null, false, null, null, null, 0, false,\n-            null, 0, null, 0, 0, null, 0, 0, null, null, 0, null, null, 0, null, null, false, null,\n-            null, 0, 0, null, null, false, false, null, null, null, null, false);\n-\n-    verifyDoStartServerInvoked();\n-\n-    assertThat(workingDirectoryCaptor.getValue())\n-        .isEqualTo(new File(workingDirectory).getAbsolutePath());\n-  }\n-\n-  @Test\n-  public void startServerWithNullWorkingDirectory() throws Exception {\n-    workingDirectory = null;\n-\n-    startServerCommand\n-        .startServer(memberName, false, null, null, null, 0.0f, 0.0f, workingDirectory, false,\n-            false, false, 0.0f, 0.0f, false, null, null, null, false, null, null, null, 0, false,\n-            null, 0, null, 0, 0, null, 0, 0, null, null, 0, null, null, 0, null, null, false, null,\n-            null, 0, 0, null, null, false, false, null, null, null, null, false);\n-\n-    verifyDoStartServerInvoked();\n-\n-    assertThat(workingDirectoryCaptor.getValue()).isEqualTo(new File(memberName).getAbsolutePath());\n-  }\n-\n-  @Test\n-  public void startServerWithEmptyWorkingDirectory() throws Exception {\n-    workingDirectory = \"\";\n-\n-    startServerCommand\n-        .startServer(memberName, false, null, null, null, 0.0f, 0.0f, workingDirectory, false,\n-            false, false, 0.0f, 0.0f, false, null, null, null, false, null, null, null, 0, false,\n-            null, 0, null, 0, 0, null, 0, 0, null, null, 0, null, null, 0, null, null, false, null,\n-            null, 0, 0, null, null, false, false, null, null, null, null, false);\n-\n-    verifyDoStartServerInvoked();\n-\n-    assertThat(workingDirectoryCaptor.getValue()).isEqualTo(new File(memberName).getAbsolutePath());\n-  }\n-\n-  @Test\n-  public void startServerWithDotWorkingDirectory() throws Exception {\n-    workingDirectory = \".\";\n-\n-    startServerCommand\n-        .startServer(memberName, false, null, null, null, 0.0f, 0.0f, workingDirectory, false,\n-            false, false, 0.0f, 0.0f, false, null, null, null, false, null, null, null, 0, false,\n-            null, 0, null, 0, 0, null, 0, 0, null, null, 0, null, null, 0, null, null, false, null,\n-            null, 0, 0, null, null, false, false, null, null, null, null, false);\n-\n-    verifyDoStartServerInvoked();\n-\n-    assertThat(workingDirectoryCaptor.getValue())\n-        .isEqualTo(StartMemberUtils.resolveWorkingDir(new File(\".\"), new File(memberName)));\n-  }\n-\n-  @Test\n-  public void startServerWithAbsoluteWorkingDirectory() throws Exception {\n-    workingDirectory = new File(System.getProperty(\"user.dir\")).getAbsolutePath();\n-\n-    startServerCommand\n-        .startServer(memberName, false, null, null, null, 0.0f, 0.0f, workingDirectory, false,\n-            false, false, 0.0f, 0.0f, false, null, null, null, false, null, null, null, 0, false,\n-            null, 0, null, 0, 0, null, 0, 0, null, null, 0, null, null, 0, null, null, false, null,\n-            null, 0, 0, null, null, false, false, null, null, null, null, false);\n-\n-    verifyDoStartServerInvoked();\n-\n-    assertThat(workingDirectoryCaptor.getValue()).isEqualTo(workingDirectory);\n-  }\n-\n-  private void verifyDoStartServerInvoked() throws Exception {\n-    verify(startServerCommand)\n-        .doStartServer(anyString(), anyBoolean(), isNull(), isNull(), isNull(), anyFloat(),\n-            anyFloat(), workingDirectoryCaptor.capture(), anyBoolean(), anyBoolean(), anyBoolean(),\n-            anyFloat(), anyFloat(), anyBoolean(), isNull(), isNull(), isNull(), anyBoolean(),\n-            isNull(), isNull(), isNull(), anyInt(), anyBoolean(), isNull(), anyInt(), isNull(),\n-            anyInt(), anyInt(), isNull(), anyInt(), anyInt(), isNull(), isNull(), anyInt(),\n-            isNull(), isNull(), anyInt(), isNull(), isNull(), anyBoolean(), isNull(), isNull(),\n-            anyInt(), anyInt(), isNull(), isNull(), anyBoolean(), anyBoolean(), isNull(), isNull(),\n-            isNull(), isNull(), anyBoolean());\n-  }\n-}"
  },
  {
    "sha": "9915356afdb50d49c482b816443e645744b20fed",
    "filename": "geode-common/src/main/java/org/apache/geode/internal/inet/LocalHostUtil.java",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-common/src/main/java/org/apache/geode/internal/inet/LocalHostUtil.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-common/src/main/java/org/apache/geode/internal/inet/LocalHostUtil.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-common/src/main/java/org/apache/geode/internal/inet/LocalHostUtil.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -242,6 +242,10 @@ public static InetAddress getAnyLocalAddress() {\n     return new InetSocketAddress(0).getAddress();\n   }\n \n+  public static boolean isWildcardAddress(String address) {\n+    return (address != null && (address.equals(\"0.0.0.0\") || address.equals(\"::\")));\n+  }\n+\n   /**\n    * Returns true if host matches the LOCALHOST.\n    */"
  },
  {
    "sha": "1f7df90b290e9c4bdd9d881ca5426142e4fb240e",
    "filename": "geode-common/src/test/java/org/apache/geode/internal/inet/LocalHostUtilTest.java",
    "status": "added",
    "additions": 42,
    "deletions": 0,
    "changes": 42,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-common/src/test/java/org/apache/geode/internal/inet/LocalHostUtilTest.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-common/src/test/java/org/apache/geode/internal/inet/LocalHostUtilTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-common/src/test/java/org/apache/geode/internal/inet/LocalHostUtilTest.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.inet;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.junit.Test;\n+\n+public class LocalHostUtilTest {\n+\n+  @Test\n+  public void isWildCardAddressReturnsTrueIfAddressIsIPv4WildcardIP() {\n+    assertThat(LocalHostUtil.isWildcardAddress(\"0.0.0.0\")).isTrue();\n+  }\n+\n+  @Test\n+  public void isWildCardAddressReturnsTrueIfAddressIsIPv6WildcardIP() {\n+    assertThat(LocalHostUtil.isWildcardAddress(\"::\")).isTrue();\n+  }\n+\n+  @Test\n+  public void isWildCardAddressReturnsFalseIfAddressIsNull() {\n+    assertThat(LocalHostUtil.isWildcardAddress(null)).isFalse();\n+  }\n+\n+  @Test\n+  public void isWildCardAddressReturnsFalseIfAddressIsEmpty() {\n+    assertThat(LocalHostUtil.isWildcardAddress(\"\")).isFalse();\n+  }\n+}"
  },
  {
    "sha": "36ce02cc213465d6f292b0d21556f835d7a972e0",
    "filename": "geode-core/src/integrationTest/java/org/apache/geode/distributed/LocatorLauncherIntegrationTest.java",
    "status": "modified",
    "additions": 5,
    "deletions": 1,
    "changes": 6,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/integrationTest/java/org/apache/geode/distributed/LocatorLauncherIntegrationTest.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/integrationTest/java/org/apache/geode/distributed/LocatorLauncherIntegrationTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/distributed/LocatorLauncherIntegrationTest.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -111,7 +111,8 @@ public void parseArgumentsParsesValuesSeparatedByCommas() throws Exception {\n     builder.parseArguments(\"start\", \"memberOne\", \"--bind-address\",\n         InetAddress.getLocalHost().getHostAddress(), \"--dir\", getWorkingDirectoryPath(),\n         \"--hostname-for-clients\", \"Tucows\", \"--pid\", \"1234\", \"--port\", \"11235\", \"--redirect-output\",\n-        \"--force\", \"--debug\");\n+        \"--force\", \"--debug\", \"--membership-bind-address\",\n+        InetAddress.getLocalHost().getHostAddress());\n \n     // then: the getters should return properly parsed values\n     assertThat(builder.getCommand()).isEqualTo(Command.START);\n@@ -123,6 +124,8 @@ public void parseArgumentsParsesValuesSeparatedByCommas() throws Exception {\n     assertThat(builder.getPort().intValue()).isEqualTo(11235);\n     assertThat(builder.getRedirectOutput()).isTrue();\n     assertThat(builder.getWorkingDirectory()).isEqualTo(getWorkingDirectoryPath());\n+    assertThat(builder.getMembershipBindAddress())\n+        .isEqualTo(InetAddress.getLocalHost().getHostAddress());\n   }\n \n   @Test\n@@ -145,6 +148,7 @@ public void parseArgumentsParsesValuesSeparatedByEquals() {\n     assertThat(builder.getPid()).isNull();\n     assertThat(builder.getPort().intValue()).isEqualTo(12345);\n     assertThat(builder.getWorkingDirectory()).isEqualTo(getWorkingDirectoryPath());\n+    assertThat(builder.getMembershipBindAddress()).isNull();\n   }\n \n   @Test"
  },
  {
    "sha": "623dc944920b7130ba7ae16b5e05082729ed642a",
    "filename": "geode-core/src/integrationTest/java/org/apache/geode/distributed/ServerLauncherIntegrationTest.java",
    "status": "modified",
    "additions": 4,
    "deletions": 1,
    "changes": 5,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/integrationTest/java/org/apache/geode/distributed/ServerLauncherIntegrationTest.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/integrationTest/java/org/apache/geode/distributed/ServerLauncherIntegrationTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/integrationTest/java/org/apache/geode/distributed/ServerLauncherIntegrationTest.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -112,7 +112,8 @@ public void parseArgumentsParsesValuesSeparatedByCommas() throws Exception {\n     builder.parseArguments(\"start\", \"memberOne\", \"--server-bind-address\",\n         getLocalHost().getHostAddress(), \"--dir\", getWorkingDirectoryPath(),\n         \"--hostname-for-clients\", \"Tucows\", \"--pid\", \"1234\", \"--server-port\", \"11235\",\n-        \"--redirect-output\", \"--force\", \"--debug\");\n+        \"--redirect-output\", \"--force\", \"--debug\", \"--membership-bind-address\",\n+        getLocalHost().getHostAddress());\n \n     // then: the getters should return properly parsed values\n     assertThat(builder.getCommand()).isEqualTo(Command.START);\n@@ -124,6 +125,7 @@ public void parseArgumentsParsesValuesSeparatedByCommas() throws Exception {\n     assertThat(builder.getServerBindAddress()).isEqualTo(getLocalHost());\n     assertThat(builder.getServerPort().intValue()).isEqualTo(11235);\n     assertThat(builder.getWorkingDirectory()).isEqualTo(getWorkingDirectoryPath());\n+    assertThat(builder.getMembershipBindAddress()).isEqualTo(getLocalHost().getHostAddress());\n   }\n \n   @Test\n@@ -146,6 +148,7 @@ public void parseArgumentsParsesValuesSeparatedByEquals() {\n     assertThat(builder.getServerBindAddress()).isNull();\n     assertThat(builder.getServerPort().intValue()).isEqualTo(12345);\n     assertThat(builder.getWorkingDirectory()).isEqualTo(getWorkingDirectoryPath());\n+    assertThat(builder.getMembershipBindAddress()).isNull();\n   }\n \n   @Test"
  },
  {
    "sha": "3814cfc203a3a7533d138b136c8ca90706068acf",
    "filename": "geode-core/src/main/java/org/apache/geode/distributed/ConfigurationProperties.java",
    "status": "modified",
    "additions": 10,
    "deletions": 0,
    "changes": 10,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/ConfigurationProperties.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/ConfigurationProperties.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/ConfigurationProperties.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -1276,6 +1276,16 @@\n    * <U>Since</U>: GemFire 5.0\n    */\n   String MAX_WAIT_TIME_RECONNECT = \"max-wait-time-reconnect\";\n+  /**\n+   * The static String definition of the <i>\"membership-bind-address\"</i> property <a\n+   * name=\"membership-bind-address\"/a>\n+   * </p>\n+   * <U>Description</U>: Specifies the IP address to which the UDP membership-related traffic\n+   * will be bound.\n+   * <p>\n+   * <U>Default</U>: \"\"\n+   */\n+  String MEMBERSHIP_BIND_ADDRESS = \"membership-bind-address\";\n   /**\n    * The static String definition of the <i>\"mcast-address\"</i> property <a name=\"mcast-address\"/a>\n    * <p>"
  },
  {
    "sha": "eafc9f2f30c25b3815662c65cef4f98c0bd4f249",
    "filename": "geode-core/src/main/java/org/apache/geode/distributed/LocatorLauncher.java",
    "status": "modified",
    "additions": 114,
    "deletions": 45,
    "changes": 159,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/LocatorLauncher.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/LocatorLauncher.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/LocatorLauncher.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -19,6 +19,7 @@\n import static org.apache.commons.lang3.StringUtils.isNotBlank;\n import static org.apache.commons.lang3.StringUtils.lowerCase;\n import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;\n+import static org.apache.geode.distributed.ConfigurationProperties.MEMBERSHIP_BIND_ADDRESS;\n import static org.apache.geode.distributed.ConfigurationProperties.NAME;\n import static org.apache.geode.internal.lang.StringUtils.wrap;\n import static org.apache.geode.internal.lang.SystemUtils.CURRENT_DIRECTORY;\n@@ -94,7 +95,7 @@\n import org.apache.geode.util.internal.GeodeGlossary;\n \n /**\n- * The LocatorLauncher class is a launcher for a GemFire Locator.\n+ * The LocatorLauncher class is a launcher for a Geode Locator.\n  *\n  * @see org.apache.geode.distributed.AbstractLauncher\n  * @see org.apache.geode.distributed.ServerLauncher\n@@ -114,16 +115,16 @@\n   static {\n     final Map<String, String> help = new HashMap<>();\n     help.put(\"launcher\",\n-        \"A GemFire launcher used to start, stop and determine a Locator's status.\");\n+        \"A Geode launcher used to start, stop and determine a Locator's status.\");\n     help.put(Command.START.getName(), String.format(\n-        \"Starts a Locator running in the current working directory listening on the default port (%s) bound to all IP addresses available to the localhost.  The Locator must be given a member name in the GemFire cluster.  The default bind-address and port may be overridden using the corresponding command-line options.\",\n+        \"Starts a Locator running in the current working directory listening on the default port (%s) bound to all IP addresses available to the localhost.  The Locator must be given a member name in the Geode cluster.  The default bind-address and port may be overridden using the corresponding command-line options.\",\n         String.valueOf(getDefaultLocatorPort())));\n     help.put(Command.STATUS.getName(),\n         \"Displays the status of a Locator given any combination of the bind-address[port], member name/ID, PID, or the directory in which the Locator is running.\");\n     help.put(Command.STOP.getName(),\n         \"Stops a running Locator given a member name/ID, PID, or the directory in which the Locator is running.\");\n     help.put(Command.VERSION.getName(),\n-        \"Displays GemFire product version information.\");\n+        \"Displays Geode product version information.\");\n     help.put(\"bind-address\",\n         \"Specifies the IP address on which to bind, or on which the Locator is bound, listening for client requests.  Defaults to all IP addresses available to the localhost.\");\n     help.put(\"debug\", \"Displays verbose information during the invocation of the launcher.\");\n@@ -134,16 +135,18 @@\n     help.put(\"force\",\n         \"Enables any existing Locator PID file to be overwritten on start.  The default is to throw an error if a PID file already exists and --force is not specified.\");\n     help.put(\"help\",\n-        \"Causes GemFire to print out information instead of performing the command. This option is supported by all commands.\");\n+        \"Causes Geode to print out information instead of performing the command. This option is supported by all commands.\");\n     help.put(\"hostname-for-clients\",\n         \"An option to specify the hostname or IP address to send to clients so they can connect to this Locator. The default is to use the IP address to which the Locator is bound.\");\n-    help.put(\"member\", \"Identifies the Locator by member name or ID in the GemFire cluster.\");\n+    help.put(\"member\", \"Identifies the Locator by member name or ID in the Geode cluster.\");\n+    help.put(MEMBERSHIP_BIND_ADDRESS,\n+        \"Specifies the IP address to which the UDP membership-related traffic will be bound.\");\n     help.put(\"pid\", \"Indicates the OS process ID of the running Locator.\");\n     help.put(\"port\", String.format(\n         \"Specifies the port on which the Locator is listening for client requests. Defaults to %s.\",\n         String.valueOf(getDefaultLocatorPort())));\n     help.put(\"redirect-output\",\n-        \"An option to cause the Locator to redirect standard out and standard error to the GemFire log file.\");\n+        \"An option to cause the Locator to redirect standard out and standard error to the Geode log file.\");\n \n     helpMap = Collections.unmodifiableMap(help);\n   }\n@@ -154,7 +157,7 @@\n   static {\n     Map<Command, String> usage = new TreeMap<>();\n     usage.put(Command.START,\n-        \"start <member-name> [--bind-address=<IP-address>] [--hostname-for-clients=<IP-address>] [--port=<port>] [--dir=<Locator-working-directory>] [--force] [--debug] [--help]\");\n+        \"start <member-name> [--bind-address=<IP-address>] [--hostname-for-clients=<IP-address>] [--port=<port>] [--dir=<Locator-working-directory>] [--force] [--membership-bind-address=<IP-address>] [--debug] [--help]\");\n     usage.put(Command.STATUS,\n         \"status [--bind-address=<IP-address>] [--port=<port>] [--member=<member-ID/Name>] [--pid=<process-ID>] [--dir=<Locator-working-directory>] [--debug] [--help]\");\n     usage.put(Command.STOP,\n@@ -208,9 +211,9 @@\n   private final transient LocatorControllerParameters controllerParameters;\n \n   /**\n-   * Launches a GemFire Locator from the command-line configured with the given arguments.\n+   * Launches a Geode Locator from the command-line configured with the given arguments.\n    *\n-   * @param args the command-line arguments used to configure the GemFire Locator at runtime.\n+   * @param args the command-line arguments used to configure the Geode Locator at runtime.\n    */\n   public static void main(final String... args) {\n     try {\n@@ -226,10 +229,10 @@ private static Integer getDefaultLocatorPort() {\n   }\n \n   /**\n-   * Gets the instance of the LocatorLauncher used to launch the GemFire Locator, or null if this VM\n-   * does not have an instance of LocatorLauncher indicating no GemFire Locator is running.\n+   * Gets the instance of the LocatorLauncher used to launch the Geode Locator, or null if this VM\n+   * does not have an instance of LocatorLauncher indicating no Geode Locator is running.\n    *\n-   * @return the instance of LocatorLauncher used to launcher a GemFire Locator in this VM.\n+   * @return the instance of LocatorLauncher used to launcher a Geode Locator in this VM.\n    */\n   public static LocatorLauncher getInstance() {\n     return INSTANCE.get();\n@@ -286,6 +289,10 @@ public void handleStop() {\n         return statusInProcess();\n       }\n     };\n+    if (builder.membershipBindAddressSpecified()) {\n+      this.distributedSystemProperties.setProperty(MEMBERSHIP_BIND_ADDRESS,\n+          builder.getMembershipBindAddress());\n+    }\n   }\n \n   /**\n@@ -421,6 +428,25 @@ public boolean isRedirectingOutput() {\n     return this.redirectOutput;\n   }\n \n+  /**\n+   * Determines whether the membership-bind-address property is defined or not.\n+   *\n+   * @return a boolean value indicating if the membership-bind-address property is defined or not.\n+   */\n+  public boolean membershipBindAddressSpecified() {\n+    return (this.distributedSystemProperties.getProperty(MEMBERSHIP_BIND_ADDRESS) != null);\n+  }\n+\n+  /**\n+   * Gets the IP address to be used for UDP membership-related traffic binding.\n+   *\n+   * @return a String containing the IP address to be used for UDP membership-related traffic\n+   *         binding.\n+   */\n+  public String getMembershipBindAddress() {\n+    return this.distributedSystemProperties.getProperty(MEMBERSHIP_BIND_ADDRESS);\n+  }\n+\n   /**\n    * Gets the IP address of the NIC to which the Locator has bound itself listening for client\n    * requests.\n@@ -481,10 +507,10 @@ public String getLogFileName() {\n   }\n \n   /**\n-   * Gets the name of this member (this Locator) in the GemFire distributed system and determined by\n-   * the 'name' GemFire property.\n+   * Gets the name of this member (this Locator) in the Geode distributed system and determined by\n+   * the 'name' Geode property.\n    *\n-   * @return a String indicating the name of the member (this Locator) in the GemFire distributed\n+   * @return a String indicating the name of the member (this Locator) in the Geode distributed\n    *         system.\n    */\n   @Override\n@@ -530,9 +556,9 @@ public String getPortAsString() {\n   }\n \n   /**\n-   * Gets the GemFire Distributed System (cluster) Properties.\n+   * Gets the Geode Distributed System (cluster) Properties.\n    *\n-   * @return a Properties object containing the configuration settings for the GemFire Distributed\n+   * @return a Properties object containing the configuration settings for the Geode Distributed\n    *         System (cluster).\n    * @see java.util.Properties\n    */\n@@ -541,9 +567,9 @@ public Properties getProperties() {\n   }\n \n   /**\n-   * Gets the name for a GemFire Locator.\n+   * Gets the name for a Geode Locator.\n    *\n-   * @return a String indicating the name for a GemFire Locator.\n+   * @return a String indicating the name for a Geode Locator.\n    */\n   @Override\n   public String getServiceName() {\n@@ -650,9 +676,9 @@ protected File getLocatorPidFile() {\n   }\n \n   /**\n-   * Determines whether a GemFire Locator can be started with this instance of LocatorLauncher.\n+   * Determines whether a Geode Locator can be started with this instance of LocatorLauncher.\n    *\n-   * @return a boolean indicating whether a GemFire Locator can be started with this instance of\n+   * @return a boolean indicating whether a Geode Locator can be started with this instance of\n    *         LocatorLauncher, which is true if the LocatorLauncher has not already started a Locator\n    *         or a Locator is not already running.\n    * @see #start()\n@@ -892,7 +918,7 @@ private void timedWait(final long interval, final TimeUnit timeUnit) {\n    * If either the 'dir' or the 'pid' command-line option were specified, then an attempt is made to\n    * determine the Locator's status by using the dir or pid to correctly identify the Locator's\n    * MemberMXBean registered in the MBeanServer of the Locator's JVM, and invoking the 'status'\n-   * operation. The same behavior occurs if the caller specified the Locator's GemFire member name\n+   * operation. The same behavior occurs if the caller specified the Locator's Geode member name\n    * or ID.\n    *\n    * However, if 'dir' or 'pid' were not specified, then determining the Locator's status defaults\n@@ -916,7 +942,7 @@ public LocatorState status() {\n     // if this instance is starting then return local status\n     if (this.starting.get()) {\n       debug(\n-          \"Getting status from the LocatorLauncher instance that actually launched the GemFire Locator.%n\");\n+          \"Getting status from the LocatorLauncher instance that actually launched the Geode Locator.%n\");\n       return new LocatorState(this, Status.STARTING);\n     }\n     // if this instance is running then return local status\n@@ -951,7 +977,7 @@ else if (!(this.bindAddressSpecified || this.portSpecified)) {\n   private LocatorState statusInProcess() {\n     if (this.starting.get()) {\n       debug(\n-          \"Getting status from the LocatorLauncher instance that actually launched the GemFire Locator.%n\");\n+          \"Getting status from the LocatorLauncher instance that actually launched the Geode Locator.%n\");\n       return new LocatorState(this, Status.STARTING);\n     } else {\n       debug(\"Getting Locator status using host (%1$s) and port (%2$s)%n\", getBindAddressAsString(),\n@@ -1048,7 +1074,7 @@ protected boolean isStoppable() {\n   /**\n    * Stop shuts the running Locator down. Using the API, the Locator is requested to stop by calling\n    * the Locator object's 'stop' method. Internally, this method is no different than using the\n-   * LocatorLauncher class from the command-line or from within GemFire shell (Gfsh). In every\n+   * LocatorLauncher class from the command-line or from within Geode shell (Gfsh). In every\n    * single case, stop sends a TCP/IP 'shutdown' request on the configured address/port to which the\n    * Locator is bound and listening.\n    *\n@@ -1261,6 +1287,7 @@ public String getStatusMethod() {\n     private Command command;\n \n     private InetAddress bindAddress;\n+    private String membershipBindAddress;\n \n     private Integer pid;\n     private Integer port;\n@@ -1304,6 +1331,7 @@ private OptionParser getParser() {\n       parser.accepts(\"force\");\n       parser.accepts(\"help\");\n       parser.accepts(\"hostname-for-clients\").withRequiredArg().ofType(String.class);\n+      parser.accepts(MEMBERSHIP_BIND_ADDRESS).withRequiredArg().ofType(String.class);\n       parser.accepts(\"pid\").withRequiredArg().ofType(Integer.class);\n       parser.accepts(\"port\").withRequiredArg().ofType(Integer.class);\n       parser.accepts(\"redirect-output\");\n@@ -1357,6 +1385,11 @@ protected void parseArguments(final String... args) {\n           if (options.has(\"version\")) {\n             setCommand(Command.VERSION);\n           }\n+\n+          if (options.has(MEMBERSHIP_BIND_ADDRESS)) {\n+            setMembershipBindAddress(\n+                ObjectUtils.toString(options.valueOf(MEMBERSHIP_BIND_ADDRESS)));\n+          }\n         }\n       } catch (OptionException e) {\n         throw new IllegalArgumentException(\n@@ -1377,8 +1410,7 @@ protected void parseArguments(final String... args) {\n      */\n     protected void parseCommand(final String... args) {\n       // search the list of arguments for the command; technically, the command should be the first\n-      // argument in the\n-      // list, but does it really matter? stop after we find one valid command.\n+      // argument in the list, but does it really matter? stop after we find one valid command.\n       if (args != null) {\n         for (String arg : args) {\n           final Command command = Command.valueOfName(arg);\n@@ -1391,12 +1423,12 @@ protected void parseCommand(final String... args) {\n     }\n \n     /**\n-     * Iterates the list of arguments in search of the Locator's GemFire member name. If the\n+     * Iterates the list of arguments in search of the Locator's Geode member name. If the\n      * argument does not start with '-' or is not the name of a Locator launcher command, then the\n-     * value is presumed to be the member name for the Locator in GemFire.\n+     * value is presumed to be the member name for the Locator in Geode.\n      *\n      * @param args the array of arguments from which to search for the Locator's member name in\n-     *        GemFire.\n+     *        Geode.\n      * @see org.apache.geode.distributed.LocatorLauncher.Command#isCommand(String)\n      * @see #parseArguments(String...)\n      */\n@@ -1485,9 +1517,9 @@ public Builder setDeletePidFileOnStop(final Boolean deletePidFileOnStop) {\n     }\n \n     /**\n-     * Gets the GemFire Distributed System (cluster) Properties configuration.\n+     * Gets the Geode Distributed System (cluster) Properties configuration.\n      *\n-     * @return a Properties object containing configuration settings for the GemFire Distributed\n+     * @return a Properties object containing configuration settings for the Geode Distributed\n      *         System (cluster).\n      * @see java.util.Properties\n      */\n@@ -1592,7 +1624,12 @@ public Builder setBindAddress(final String bindAddress) {\n         return this;\n       } else {\n         try {\n-          InetAddress address = InetAddress.getByName(bindAddress);\n+          InetAddress address;\n+          if (LocalHostUtil.isWildcardAddress(bindAddress)) {\n+            address = LocalHostUtil.getAnyLocalAddress();\n+          } else {\n+            address = InetAddress.getByName(bindAddress);\n+          }\n           if (LocalHostUtil.isLocalHost(address)) {\n             this.bindAddress = address;\n             return this;\n@@ -1640,19 +1677,19 @@ public Builder setHostnameForClients(final String hostnameForClients) {\n     }\n \n     /**\n-     * Gets the member name of this Locator in GemFire.\n+     * Gets the member name of this Locator in Geode.\n      *\n-     * @return a String indicating the member name of this Locator in GemFire.\n+     * @return a String indicating the member name of this Locator in Geode.\n      * @see #setMemberName(String)\n      */\n     public String getMemberName() {\n       return this.memberName;\n     }\n \n     /**\n-     * Sets the member name of the Locator in GemFire.\n+     * Sets the member name of the Locator in Geode.\n      *\n-     * @param memberName a String indicating the member name of this Locator in GemFire.\n+     * @param memberName a String indicating the member name of this Locator in Geode.\n      * @return this Builder instance.\n      * @throws IllegalArgumentException if the member name is invalid.\n      * @see #getMemberName()\n@@ -1738,6 +1775,38 @@ public Builder setPort(final Integer port) {\n       return this;\n     }\n \n+    /**\n+     * Sets the IP address to be used for UDP membership-related traffic binding.\n+     *\n+     * @param membershipBindAddress a String containing the IP address to be used for\n+     *        UDP membership-related traffic binding.\n+     * @return this Builder instance.\n+     * @see #getMembershipBindAddress()\n+     */\n+    public Builder setMembershipBindAddress(final String membershipBindAddress) {\n+      this.membershipBindAddress = membershipBindAddress;\n+      return this;\n+    }\n+\n+    /**\n+     * Gets the IP address to be used for UDP membership-related traffic binding.\n+     *\n+     * @return a String containing the IP address to be used for UDP membership-related traffic\n+     *         binding.\n+     */\n+    public String getMembershipBindAddress() {\n+      return this.membershipBindAddress;\n+    }\n+\n+    /**\n+     * Determines whether the membership-bind-address property is defined or not.\n+     *\n+     * @return a boolean value indicating if the membership-bind-address property is defined or not.\n+     */\n+    public boolean membershipBindAddressSpecified() {\n+      return this.membershipBindAddress != null;\n+    }\n+\n     /**\n      * Determines whether the new instance of LocatorLauncher will redirect output to system logs\n      * when starting a Locator.\n@@ -1814,11 +1883,11 @@ public Builder setWorkingDirectory(final String workingDirectory) {\n     }\n \n     /**\n-     * Sets a GemFire Distributed System Property.\n+     * Sets a Geode Distributed System Property.\n      *\n-     * @param propertyName a String indicating the name of the GemFire Distributed System property\n+     * @param propertyName a String indicating the name of the Geode Distributed System property\n      *        as described in {@link ConfigurationProperties}\n-     * @param propertyValue a String value for the GemFire Distributed System property.\n+     * @param propertyValue a String value for the Geode Distributed System property.\n      * @return this Builder instance.\n      */\n     public Builder set(final String propertyName, final String propertyValue) {\n@@ -1827,9 +1896,9 @@ public Builder set(final String propertyName, final String propertyValue) {\n     }\n \n     /**\n-     * add the properties in the Gemfire Distributed System Property\n+     * add the properties in the Geode Distributed System Property\n      *\n-     * @param properties a property object that holds one or more Gemfire Distributed System\n+     * @param properties a property object that holds one or more Geode Distributed System\n      *        properties as described in {@link ConfigurationProperties}\n      * @return this Builder instance\n      * @since Geode 1.12\n@@ -1842,7 +1911,7 @@ public Builder set(Properties properties) {\n     /**\n      * Validates the configuration settings and properties of this Builder, ensuring that all\n      * invariants have been met. Currently, the only invariant constraining the Builder is that the\n-     * user must specify the member name for the Locator in the GemFire distributed system as a\n+     * user must specify the member name for the Locator in the Geode distributed system as a\n      * command-line argument, or by setting the memberName property programmatically using the\n      * corresponding setter method. If the member name is not given, then the user must have\n      * specified the pathname to the gemfire.properties file before validate is called. It is then\n@@ -1908,7 +1977,7 @@ protected void validateOnStop() {\n \n     /**\n      * Validates the Builder configuration settings and then constructs an instance of the\n-     * LocatorLauncher class to invoke operations on a GemFire Locator.\n+     * LocatorLauncher class to invoke operations on a Geode Locator.\n      *\n      * @return a newly constructed instance of LocatorLauncher configured with this Builder.\n      * @see #validate()"
  },
  {
    "sha": "b25f1c5c24e65a9aba52190cf7f1cd459e496b82",
    "filename": "geode-core/src/main/java/org/apache/geode/distributed/ServerLauncher.java",
    "status": "modified",
    "additions": 140,
    "deletions": 74,
    "changes": 214,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/ServerLauncher.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/ServerLauncher.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/ServerLauncher.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -21,6 +21,7 @@\n import static org.apache.commons.lang3.StringUtils.isNotBlank;\n import static org.apache.commons.lang3.StringUtils.lowerCase;\n import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;\n+import static org.apache.geode.distributed.ConfigurationProperties.MEMBERSHIP_BIND_ADDRESS;\n import static org.apache.geode.distributed.ConfigurationProperties.NAME;\n import static org.apache.geode.distributed.ConfigurationProperties.SERVER_BIND_ADDRESS;\n import static org.apache.geode.internal.lang.StringUtils.wrap;\n@@ -106,8 +107,8 @@\n import org.apache.geode.util.internal.GeodeGlossary;\n \n /**\n- * The ServerLauncher class is a launcher class with main method to start a GemFire Server (implying\n- * a GemFire Cache Server process).\n+ * The ServerLauncher class is a launcher class with main method to start a Geode Server (implying\n+ * a Geode Cache Server process).\n  *\n  * @see AbstractLauncher\n  * @see LocatorLauncher\n@@ -124,35 +125,37 @@\n   static {\n     Map<String, String> help = new HashMap<>();\n     help.put(\"launcher\",\n-        \"A GemFire launcher used to start, stop and determine a Server's status.\");\n+        \"A Geode launcher used to start, stop and determine a Server's status.\");\n     help.put(Command.START.getName(), String.format(\n-        \"Starts a Server running in the current working directory listening on the default port (%s) bound to all IP addresses available to the localhost.  The Server must be given a member name in the GemFire cluster.  The default server-bind-address and server-port may be overridden using the corresponding command-line options.\",\n+        \"Starts a Server running in the current working directory listening on the default port (%s) bound to all IP addresses available to the localhost.  The Server must be given a member name in the Geode cluster.  The default server-bind-address and server-port may be overridden using the corresponding command-line options.\",\n         String.valueOf(getDefaultServerPort())));\n     help.put(Command.STATUS.getName(),\n         \"Displays the status of a Server given any combination of the member name/ID, PID, or the directory in which the Server is running.\");\n     help.put(Command.STOP.getName(),\n         \"Stops a running Server given given a member name/ID, PID, or the directory in which the Server is running.\");\n     help.put(Command.VERSION.getName(),\n-        \"Displays GemFire product version information.\");\n+        \"Displays Geode product version information.\");\n     help.put(\"assign-buckets\",\n-        \"Causes buckets to be assigned to the partitioned regions in the GemFire cache on Server start.\");\n+        \"Causes buckets to be assigned to the partitioned regions in the Geode cache on Server start.\");\n     help.put(\"debug\", \"Displays verbose information during the invocation of the launcher.\");\n     help.put(\"delete-pid-file-on-stop\",\n         \"Specifies that this Server's PID file should be deleted on stop.  The default is to not delete this Server's PID file until JVM exit if --delete-pid-file-on-stop is not specified.\");\n     help.put(\"dir\",\n         \"Specifies the working directory where the Server is running.  Defaults to the current working directory.\");\n     help.put(\"disable-default-server\",\n-        \"Disables the addition of a default GemFire cache server.\");\n+        \"Disables the addition of a default Geode cache server.\");\n     help.put(\"force\",\n         \"Enables any existing Server PID file to be overwritten on start.  The default is to throw an error if a PID file already exists and --force is not specified.\");\n     help.put(\"help\",\n-        \"Causes GemFire to print out information instead of performing the command. This option is supported by all commands.\");\n-    help.put(\"member\", \"Identifies the Server by member name or ID in the GemFire cluster.\");\n+        \"Causes Geode to print out information instead of performing the command. This option is supported by all commands.\");\n+    help.put(\"member\", \"Identifies the Server by member name or ID in the Geode cluster.\");\n+    help.put(MEMBERSHIP_BIND_ADDRESS,\n+        \"Specifies the IP address to which the UDP membership-related traffic will be bound.\");\n     help.put(\"pid\", \"Indicates the OS process ID of the running Server.\");\n     help.put(\"rebalance\",\n-        \"An option to cause the GemFire cache's partitioned regions to be rebalanced on start.\");\n+        \"An option to cause the Geode cache's partitioned regions to be rebalanced on start.\");\n     help.put(\"redirect-output\",\n-        \"An option to cause the Server to redirect standard out and standard error to the GemFire log file.\");\n+        \"An option to cause the Server to redirect standard out and standard error to the Geode log file.\");\n     help.put(SERVER_BIND_ADDRESS,\n         \"Specifies the IP address on which to bind, or on which the Server is bound, listening for client requests.  Defaults to all IP addresses available to the localhost.\");\n     help.put(\"hostname-for-clients\",\n@@ -169,7 +172,7 @@\n   static {\n     Map<Command, String> usage = new TreeMap<>();\n     usage.put(Command.START,\n-        \"start <member-name> [--assign-buckets] [--disable-default-server] [--rebalance] [--server-bind-address=<IP-address>] [--server-port=<port>] [--force] [--debug] [--help]\");\n+        \"start <member-name> [--assign-buckets] [--disable-default-server] [--rebalance] [--server-bind-address=<IP-address>] [--server-port=<port>] [--membership-bind-address=<IP-address>] [--force] [--debug] [--help]\");\n     usage.put(Command.STATUS,\n         \"status [--member=<member-ID/Name>] [--pid=<process-ID>] [--dir=<Server-working-directory>] [--debug] [--help]\");\n     usage.put(Command.STOP,\n@@ -247,9 +250,9 @@\n   private final Supplier<ControllableProcess> controllableProcessFactory;\n \n   /**\n-   * Launches a GemFire Server from the command-line configured with the given arguments.\n+   * Launches a Geode Server from the command-line configured with the given arguments.\n    *\n-   * @param args the command-line arguments used to configure the GemFire Server at runtime.\n+   * @param args the command-line arguments used to configure the Geode Server at runtime.\n    */\n   public static void main(final String... args) {\n     try {\n@@ -265,11 +268,11 @@ private static Integer getDefaultServerPort() {\n   }\n \n   /**\n-   * Gets the instance of the ServerLauncher used to launch the GemFire Cache Server, or null if\n-   * this VM does not have an instance of ServerLauncher indicating no GemFire Cache Server is\n+   * Gets the instance of the ServerLauncher used to launch the Geode Cache Server, or null if\n+   * this VM does not have an instance of ServerLauncher indicating no Geode Cache Server is\n    * running.\n    *\n-   * @return the instance of ServerLauncher used to launcher a GemFire Cache Server in this VM.\n+   * @return the instance of ServerLauncher used to launcher a Geode Cache Server in this VM.\n    */\n   public static ServerLauncher getInstance() {\n     return INSTANCE.get();\n@@ -349,6 +352,11 @@ public void handleStop() {\n         builder.isServerBindAddressSetByUser() && this.serverBindAddress != null\n             ? this.serverBindAddress.getHostAddress() : null;\n \n+    if (builder.membershipBindAddressSpecified()) {\n+      this.distributedSystemProperties.setProperty(MEMBERSHIP_BIND_ADDRESS,\n+          builder.getMembershipBindAddress());\n+    }\n+\n     ServerLauncherParameters.INSTANCE\n         .withPort(serverPort)\n         .withMaxThreads(maxThreads)\n@@ -381,10 +389,10 @@ public Cache getCache() {\n   }\n \n   /**\n-   * Gets the CacheConfig object used to configure additional GemFire Cache components and features\n+   * Gets the CacheConfig object used to configure additional Geode Cache components and features\n    * (e.g. PDX).\n    *\n-   * @return a CacheConfig object with additional GemFire Cache configuration meta-data used on\n+   * @return a CacheConfig object with additional Geode Cache configuration meta-data used on\n    *         startup to configure the Cache.\n    */\n   public CacheConfig getCacheConfig() {\n@@ -433,7 +441,7 @@ public boolean isAssignBuckets() {\n   }\n \n   /**\n-   * Determines whether a default cache server will be added when the GemFire Server comes online.\n+   * Determines whether a default cache server will be added when the Geode Server comes online.\n    *\n    * @return a boolean value indicating whether to add a default cache server.\n    */\n@@ -465,10 +473,10 @@ public boolean isHelping() {\n   }\n \n   /**\n-   * Determines whether a rebalance operation on the cache will occur upon starting the GemFire\n+   * Determines whether a rebalance operation on the cache will occur upon starting the Geode\n    * server using this launcher.\n    *\n-   * @return a boolean indicating if the cache will be rebalance when the GemFire server starts.\n+   * @return a boolean indicating if the cache will be rebalance when the Geode server starts.\n    */\n   public boolean isRebalancing() {\n     return rebalance;\n@@ -485,6 +493,25 @@ public boolean isRedirectingOutput() {\n     return redirectOutput;\n   }\n \n+  /**\n+   * Determines whether the membership-bind-address property is defined or not.\n+   *\n+   * @return a boolean value indicating if the membership-bind-address property is defined or not.\n+   */\n+  public boolean membershipBindAddressSpecified() {\n+    return (this.distributedSystemProperties.getProperty(MEMBERSHIP_BIND_ADDRESS) != null);\n+  }\n+\n+  /**\n+   * Gets the IP address to be used for UDP membership-related traffic binding.\n+   *\n+   * @return a String containing the IP address to be used for UDP membership-related traffic\n+   *         binding.\n+   */\n+  public String getMembershipBindAddress() {\n+    return this.distributedSystemProperties.getProperty(MEMBERSHIP_BIND_ADDRESS);\n+  }\n+\n   /**\n    * Gets the name of the log file used to log information about this Server.\n    *\n@@ -496,10 +523,10 @@ public String getLogFileName() {\n   }\n \n   /**\n-   * Gets the name of this member (this Server) in the GemFire distributed system as determined by\n-   * the 'name' GemFire property.\n+   * Gets the name of this member (this Server) in the Geode distributed system as determined by\n+   * the 'name' Geode property.\n    *\n-   * @return a String indicating the name of the member (this Server) in the GemFire distributed\n+   * @return a String indicating the name of the member (this Server) in the Geode distributed\n    *         system.\n    */\n   @Override\n@@ -519,9 +546,9 @@ public Integer getPid() {\n   }\n \n   /**\n-   * Gets the GemFire Distributed System (cluster) Properties.\n+   * Gets the Geode Distributed System (cluster) Properties.\n    *\n-   * @return a Properties object containing the configuration settings for the GemFire Distributed\n+   * @return a Properties object containing the configuration settings for the Geode Distributed\n    *         System (cluster).\n    * @see Properties\n    */\n@@ -533,7 +560,7 @@ public Properties getProperties() {\n    * Gets the IP address to which the Server is bound listening for and accepting cache client\n    * connections. This property should not be confused with 'bindAddress' ServerLauncher property,\n    * which is the port for binding the Server's ServerSocket used in distribution and messaging\n-   * between the peers of the GemFire distributed system.\n+   * between the peers of the Geode distributed system.\n    *\n    * @return an InetAddress indicating the IP address that the Server is bound to listening for and\n    *         accepting cache client connections in a client/server topology.\n@@ -597,9 +624,9 @@ public String getServerPortAsString() {\n   }\n \n   /**\n-   * Gets the name for a GemFire Server.\n+   * Gets the name for a Geode Server.\n    *\n-   * @return a String indicating the name for a GemFire Server.\n+   * @return a String indicating the name for a Geode Server.\n    */\n   @Override\n   public String getServiceName() {\n@@ -608,7 +635,7 @@ public String getServiceName() {\n \n   /**\n    * Gets the location of the Spring XML configuration meta-data file used to bootstrap, configure\n-   * and initialize the GemFire Server on start.\n+   * and initialize the Geode Server on start.\n    * <p>\n    *\n    * @return a String indicating the location of the Spring XML configuration file.\n@@ -619,11 +646,11 @@ public String getSpringXmlLocation() {\n   }\n \n   /**\n-   * Determines whether this GemFire Server was configured and initialized with Spring configuration\n+   * Determines whether this Geode Server was configured and initialized with Spring configuration\n    * meta-data.\n    * <p>\n    *\n-   * @return a boolean value indicating whether this GemFire Server was configured with Spring\n+   * @return a boolean value indicating whether this Geode Server was configured with Spring\n    *         configuration meta-data.\n    */\n   public boolean isSpringXmlLocationSpecified() {\n@@ -723,7 +750,7 @@ public void usage() {\n   }\n \n   /**\n-   * A Runnable method used to invoke the GemFire server (cache server) with the specified command.\n+   * A Runnable method used to invoke the Geode server (cache server) with the specified command.\n    * From run, a user can invoke 'start', 'status', 'stop' and 'version'. Note, that 'version' is\n    * also a command-line option, but can be treated as a \"command\" as well.\n    *\n@@ -764,9 +791,9 @@ protected File getServerPidFile() {\n   }\n \n   /**\n-   * Determines whether a GemFire Cache Server can be started with this instance of ServerLauncher.\n+   * Determines whether a Geode Cache Server can be started with this instance of ServerLauncher.\n    *\n-   * @return a boolean indicating whether a GemFire Cache Server can be started with this instance\n+   * @return a boolean indicating whether a Geode Cache Server can be started with this instance\n    *         of ServerLauncher, which is true if the ServerLauncher has not already started a Server\n    *         or a Server is not already running.\n    * @see #start()\n@@ -776,7 +803,7 @@ private boolean isStartable() {\n   }\n \n   /**\n-   * Invokes the 'start' command and operation to startup a GemFire server (a cache server). Note,\n+   * Invokes the 'start' command and operation to startup a Geode server (a cache server). Note,\n    * this method will cause the JVM to block upon server start, providing the calling Thread is a\n    * non-daemon Thread.\n    *\n@@ -930,19 +957,19 @@ protected boolean isServing(final Cache cache) {\n   }\n \n   /**\n-   * Determines whether to continue waiting and keep the GemFire non-Server data member running.\n+   * Determines whether to continue waiting and keep the Geode non-Server data member running.\n    *\n-   * @param cache the Cache associated with this GemFire (non-Server) data member.\n-   * @return a boolean value indicating whether the GemFire data member should continue running, as\n-   *         determined by the running flag and a connection to the distributed system (GemFire\n+   * @param cache the Cache associated with this Geode (non-Server) data member.\n+   * @return a boolean value indicating whether the Geode data member should continue running, as\n+   *         determined by the running flag and a connection to the distributed system (Geode\n    *         cluster).\n    */\n   boolean isWaiting(final Cache cache) {\n     return isRunning() && (cache.getDistributedSystem().isConnected() || cache.isReconnecting());\n   }\n \n   /**\n-   * Causes the calling Thread to block until the GemFire Cache Server/Data Member stops.\n+   * Causes the calling Thread to block until the Geode Cache Server/Data Member stops.\n    */\n   public void waitOnServer() {\n     assert getCache() != null : \"The Cache Server must first be started with a call to start!\";\n@@ -1110,15 +1137,15 @@ protected boolean isStartingOrRunning() {\n   }\n \n   /**\n-   * Invokes the 'status' command and operation to check the status of a GemFire server (a cache\n+   * Invokes the 'status' command and operation to check the status of a Geode server (a cache\n    * server).\n    */\n   public ServerState status() {\n     final ServerLauncher launcher = getInstance();\n     // if this instance is running then return local status\n     if (isStartingOrRunning()) {\n       debug(\n-          \"Getting status from the ServerLauncher instance that actually launched the GemFire Cache Server.%n\");\n+          \"Getting status from the ServerLauncher instance that actually launched the Geode Cache Server.%n\");\n       return new ServerState(this, isRunning() ? Status.ONLINE : Status.STARTING);\n     }\n     if (isPidInProcess() && launcher != null) {\n@@ -1133,7 +1160,7 @@ public ServerState status() {\n       debug(\"Getting Server status using working directory (%1$s)%n\", getWorkingDirectory());\n       return statusWithWorkingDirectory();\n     }\n-    debug(\"This ServerLauncher was not the instance used to launch the GemFire Cache Server, and \"\n+    debug(\"This ServerLauncher was not the instance used to launch the Geode Cache Server, and \"\n         + \"neither PID nor working directory were specified; the Server's state is unknown.%n\");\n \n     return new ServerState(this, Status.NOT_RESPONDING);\n@@ -1142,7 +1169,7 @@ public ServerState status() {\n   private ServerState statusInProcess() {\n     if (isStartingOrRunning()) {\n       debug(\n-          \"Getting status from the ServerLauncher instance that actually launched the GemFire Cache Server.%n\");\n+          \"Getting status from the ServerLauncher instance that actually launched the Geode Cache Server.%n\");\n       return new ServerState(this, isRunning() ? Status.ONLINE : Status.STARTING);\n     }\n     return new ServerState(this, Status.NOT_RESPONDING);\n@@ -1219,7 +1246,7 @@ private boolean isStoppable() {\n   }\n \n   /**\n-   * Invokes the 'stop' command and operation to stop a GemFire server (a cache server).\n+   * Invokes the 'stop' command and operation to stop a Geode server (a cache server).\n    */\n   public ServerState stop() {\n     final ServerLauncher launcher = getInstance();\n@@ -1427,7 +1454,7 @@ public String getStatusMethod() {\n \n   /**\n    * The Builder class, modeled after the Builder creational design pattern, is used to construct a\n-   * properly configured and initialized instance of the ServerLauncher to control and run GemFire\n+   * properly configured and initialized instance of the ServerLauncher to control and run Geode\n    * servers (in particular, cache servers).\n    */\n   public static class Builder {\n@@ -1454,6 +1481,7 @@ public String getStatusMethod() {\n     private Command command;\n \n     private InetAddress serverBindAddress;\n+    private String membershipBindAddress;\n \n     private Integer pid;\n     private Integer serverPort;\n@@ -1519,6 +1547,7 @@ private OptionParser getParser() {\n       parser.accepts(\"force\");\n       parser.accepts(\"help\");\n       parser.accepts(\"member\").withRequiredArg().ofType(String.class);\n+      parser.accepts(MEMBERSHIP_BIND_ADDRESS).withRequiredArg().ofType(String.class);\n       parser.accepts(\"pid\").withRequiredArg().ofType(Integer.class);\n       parser.accepts(\"rebalance\");\n       parser.accepts(\"redirect-output\");\n@@ -1642,6 +1671,11 @@ void parseArguments(final String... args) {\n           if (options.has(\"version\")) {\n             setCommand(Command.VERSION);\n           }\n+\n+          if (options.has(MEMBERSHIP_BIND_ADDRESS)) {\n+            setMembershipBindAddress(\n+                ObjectUtils.toString(options.valueOf(MEMBERSHIP_BIND_ADDRESS)));\n+          }\n         }\n \n         // why are these option not inside the 'if (!isHelping())' conditional block?\n@@ -1716,12 +1750,12 @@ protected void parseCommand(final String... args) {\n     }\n \n     /**\n-     * Iterates the list of arguments in search of the Server's GemFire member name. If the argument\n+     * Iterates the list of arguments in search of the Server's Geode member name. If the argument\n      * does not start with '-' or is not the name of a Server launcher command, then the value is\n-     * presumed to be the member name for the Server in GemFire.\n+     * presumed to be the member name for the Server in Geode.\n      *\n      * @param args the array of arguments from which to search for the Server's member name in\n-     *        GemFire.\n+     *        Geode.\n      * @see ServerLauncher.Command#isCommand(String)\n      * @see #parseArguments(String...)\n      */\n@@ -1737,9 +1771,9 @@ protected void parseMemberName(final String... args) {\n     }\n \n     /**\n-     * Gets the CacheConfig object used to configure PDX on the GemFire Cache by the Builder.\n+     * Gets the CacheConfig object used to configure PDX on the Geode Cache by the Builder.\n      *\n-     * @return the CacheConfig object used to configure PDX on the GemFire Cache by the Builder.\n+     * @return the CacheConfig object used to configure PDX on the Geode Cache by the Builder.\n      */\n     CacheConfig getCacheConfig() {\n       return cacheConfig;\n@@ -1864,7 +1898,7 @@ public Boolean getDisableDefaultServer() {\n     }\n \n     /**\n-     * Sets a boolean value indicating whether to add a default cache when the GemFire Server comes\n+     * Sets a boolean value indicating whether to add a default cache when the Geode Server comes\n      * online.\n      *\n      * @param disableDefaultServer a boolean value indicating whether to add a default cache server.\n@@ -1877,9 +1911,9 @@ public Builder setDisableDefaultServer(final Boolean disableDefaultServer) {\n     }\n \n     /**\n-     * Gets the GemFire Distributed System (cluster) Properties configuration.\n+     * Gets the Geode Distributed System (cluster) Properties configuration.\n      *\n-     * @return a Properties object containing configuration settings for the GemFire Distributed\n+     * @return a Properties object containing configuration settings for the Geode Distributed\n      *         System (cluster).\n      * @see Properties\n      */\n@@ -1949,10 +1983,10 @@ public Builder setHelp(final Boolean help) {\n     }\n \n     /**\n-     * Determines whether a rebalance operation on the cache will occur upon starting the GemFire\n+     * Determines whether a rebalance operation on the cache will occur upon starting the Geode\n      * server.\n      *\n-     * @return a boolean indicating if the cache will be rebalance when the GemFire server starts.\n+     * @return a boolean indicating if the cache will be rebalance when the Geode server starts.\n      * @see #setRebalance(Boolean)\n      */\n     public Boolean getRebalance() {\n@@ -1961,9 +1995,9 @@ public Boolean getRebalance() {\n \n     /**\n      * Set a boolean value indicating whether a rebalance operation on the cache should occur upon\n-     * starting the GemFire server.\n+     * starting the Geode server.\n      *\n-     * @param rebalance a boolean indicating if the cache will be rebalanced when the GemFire server\n+     * @param rebalance a boolean indicating if the cache will be rebalanced when the Geode server\n      *        starts.\n      * @return this Builder instance.\n      * @see #getRebalance()\n@@ -1974,19 +2008,19 @@ public Builder setRebalance(final Boolean rebalance) {\n     }\n \n     /**\n-     * Gets the member name of this Server in GemFire.\n+     * Gets the member name of this Server in Geode.\n      *\n-     * @return a String indicating the member name of this Server in GemFire.\n+     * @return a String indicating the member name of this Server in Geode.\n      * @see #setMemberName(String)\n      */\n     public String getMemberName() {\n       return memberName;\n     }\n \n     /**\n-     * Sets the member name of the Server in GemFire.\n+     * Sets the member name of the Server in Geode.\n      *\n-     * @param memberName a String indicating the member name of this Server in GemFire.\n+     * @param memberName a String indicating the member name of this Server in Geode.\n      * @return this Builder instance.\n      * @throws IllegalArgumentException if the member name is invalid.\n      * @see #getMemberName()\n@@ -1999,6 +2033,38 @@ public Builder setMemberName(final String memberName) {\n       return this;\n     }\n \n+    /**\n+     * Sets the IP address to be used for UDP membership-related traffic binding.\n+     *\n+     * @param membershipBindAddress a String containing the IP address to be used for\n+     *        UDP membership-related traffic binding.\n+     * @return this Builder instance.\n+     * @see #getMembershipBindAddress()\n+     */\n+    public Builder setMembershipBindAddress(final String membershipBindAddress) {\n+      this.membershipBindAddress = membershipBindAddress;\n+      return this;\n+    }\n+\n+    /**\n+     * Gets the IP address to be used for UDP membership-related traffic binding.\n+     *\n+     * @return a String containing the IP address to be used for UDP membership-related traffic\n+     *         binding.\n+     */\n+    public String getMembershipBindAddress() {\n+      return this.membershipBindAddress;\n+    }\n+\n+    /**\n+     * Determines whether the membership-bind-address property is defined or not.\n+     *\n+     * @return a boolean value indicating if the membership-bind-address property is defined or not.\n+     */\n+    public boolean membershipBindAddressSpecified() {\n+      return this.membershipBindAddress != null;\n+    }\n+\n     /**\n      * Gets the process ID (PID) of the running Server indicated by the user as an argument to the\n      * ServerLauncher. This PID is used by the Server launcher to determine the Server's status, or\n@@ -2170,7 +2236,7 @@ public Builder setServerPort(final Integer serverPort) {\n \n     /**\n      * Gets the location of the Spring XML configuration meta-data file used to bootstrap, configure\n-     * and initialize the GemFire Server on start.\n+     * and initialize the Geode Server on start.\n      * <p>\n      *\n      * @return a String indicating the location of the Spring XML configuration file.\n@@ -2182,7 +2248,7 @@ public String getSpringXmlLocation() {\n \n     /**\n      * Sets the location of the Spring XML configuration meta-data file used to bootstrap, configure\n-     * and initialize the GemFire Server on start.\n+     * and initialize the Geode Server on start.\n      * <p>\n      *\n      * @param springXmlLocation a String indicating the location of the Spring XML configuration\n@@ -2376,11 +2442,11 @@ public Builder setSocketBufferSize(Integer socketBufferSize) {\n \n \n     /**\n-     * Sets a GemFire Distributed System Property.\n+     * Sets a Geode Distributed System Property.\n      *\n-     * @param propertyName a String indicating the name of the GemFire Distributed System property\n+     * @param propertyName a String indicating the name of the Geode Distributed System property\n      *        as described in {@link ConfigurationProperties}\n-     * @param propertyValue a String value for the GemFire Distributed System property.\n+     * @param propertyValue a String value for the Geode Distributed System property.\n      * @return this Builder instance.\n      */\n     public Builder set(final String propertyName, final String propertyValue) {\n@@ -2414,9 +2480,9 @@ public Builder setPdxPersistent(final boolean persistent) {\n     }\n \n     /**\n-     * Sets the GemFire Disk Store to be used to persist PDX type meta-data.\n+     * Sets the Geode Disk Store to be used to persist PDX type meta-data.\n      *\n-     * @param pdxDiskStore a String indicating the name of the GemFire Disk Store to use to store\n+     * @param pdxDiskStore a String indicating the name of the Geode Disk Store to use to store\n      *        PDX type meta-data\n      * @return this Builder instance.\n      */\n@@ -2451,7 +2517,7 @@ public Builder setPdxReadSerialized(final boolean readSerialized) {\n     }\n \n     /**\n-     * Set the PdxSerializer to use to serialize POJOs to the GemFire Cache Region or when sent\n+     * Set the PdxSerializer to use to serialize POJOs to the Geode Cache Region or when sent\n      * between peers, client/server, or during persistence to disk.\n      *\n      * @param pdxSerializer the PdxSerializer that is used to serialize application domain objects\n@@ -2466,7 +2532,7 @@ public Builder setPdxSerializer(final PdxSerializer pdxSerializer) {\n     /**\n      * Validates the configuration settings and properties of this Builder, ensuring that all\n      * invariants have been met. Currently, the only invariant constraining the Builder is that the\n-     * user must specify the member name for the Server in the GemFire distributed system as a\n+     * user must specify the member name for the Server in the Geode distributed system as a\n      * command-line argument, or by setting the memberName property programmatically using the\n      * corresponding setter method.\n      *\n@@ -2530,7 +2596,7 @@ void validateOnStop() {\n \n     /**\n      * Validates the Builder configuration settings and then constructs an instance of the\n-     * ServerLauncher class to invoke operations on a GemFire Server.\n+     * ServerLauncher class to invoke operations on a Geode Server.\n      *\n      * @return a newly constructed instance of the ServerLauncher configured with this Builder.\n      * @see #validate()"
  },
  {
    "sha": "9a10c6c6bc055ce1ccad8da86762fcbd036aa79b",
    "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/AbstractDistributionConfig.java",
    "status": "modified",
    "additions": 8,
    "deletions": 3,
    "changes": 11,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/internal/AbstractDistributionConfig.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/internal/AbstractDistributionConfig.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/AbstractDistributionConfig.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -104,6 +104,7 @@\n import static org.apache.geode.distributed.ConfigurationProperties.MCAST_RECV_BUFFER_SIZE;\n import static org.apache.geode.distributed.ConfigurationProperties.MCAST_SEND_BUFFER_SIZE;\n import static org.apache.geode.distributed.ConfigurationProperties.MCAST_TTL;\n+import static org.apache.geode.distributed.ConfigurationProperties.MEMBERSHIP_BIND_ADDRESS;\n import static org.apache.geode.distributed.ConfigurationProperties.MEMBERSHIP_PORT_RANGE;\n import static org.apache.geode.distributed.ConfigurationProperties.MEMBER_TIMEOUT;\n import static org.apache.geode.distributed.ConfigurationProperties.MEMCACHED_BIND_ADDRESS;\n@@ -349,11 +350,12 @@ protected String checkServerBindAddress(String value) {\n   }\n \n   @ConfigAttributeChecker(name = CLUSTER_SSL_ENABLED)\n-  protected Boolean checkClusterSSLEnabled(Boolean value) {\n+  protected boolean checkClusterSSLEnabled(boolean value) {\n     if (value && getMcastPort() != 0) {\n       throw new IllegalArgumentException(\n-          String.format(\"Could not set %s to %s because its value must be false when %s is not 0.\",\n-              CLUSTER_SSL_ENABLED, value, MCAST_PORT));\n+          String.format(\n+              \"Could not set %s to true because its value must be false when %s is not 0.\",\n+              CLUSTER_SSL_ENABLED, MCAST_PORT));\n     }\n     return value;\n   }\n@@ -1060,6 +1062,9 @@ static Class _getAttributeType(String attName) {\n         \"The address server sockets will listen on. An empty string causes the server socket to listen on all local addresses. Defaults to %s.\",\n         DEFAULT_BIND_ADDRESS));\n \n+    m.put(MEMBERSHIP_BIND_ADDRESS,\n+        \"Specifies the IP address to which the UDP membership-related traffic will be bound.\");\n+\n     m.put(SERVER_BIND_ADDRESS,\n         String.format(\n             \"The address server sockets in a client-server topology will listen on. An empty string causes the server socket to listen on all local addresses. Defaults to %s.\","
  },
  {
    "sha": "2534d67c6d49ed605ababfac52a54ab44cccf20e",
    "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/DistributionConfig.java",
    "status": "modified",
    "additions": 24,
    "deletions": 0,
    "changes": 24,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/internal/DistributionConfig.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/internal/DistributionConfig.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/DistributionConfig.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -104,6 +104,7 @@\n import static org.apache.geode.distributed.ConfigurationProperties.MCAST_RECV_BUFFER_SIZE;\n import static org.apache.geode.distributed.ConfigurationProperties.MCAST_SEND_BUFFER_SIZE;\n import static org.apache.geode.distributed.ConfigurationProperties.MCAST_TTL;\n+import static org.apache.geode.distributed.ConfigurationProperties.MEMBERSHIP_BIND_ADDRESS;\n import static org.apache.geode.distributed.ConfigurationProperties.MEMBERSHIP_PORT_RANGE;\n import static org.apache.geode.distributed.ConfigurationProperties.MEMBER_TIMEOUT;\n import static org.apache.geode.distributed.ConfigurationProperties.MEMCACHED_BIND_ADDRESS;\n@@ -544,6 +545,29 @@ static InetAddress _getDefaultMcastAddress() {\n    */\n   String DEFAULT_START_LOCATOR = MembershipConfig.DEFAULT_START_LOCATOR;\n \n+  /**\n+   * The IP address to which the UDP membership-related traffic will be bound.\n+   */\n+  @ConfigAttribute(type = String.class)\n+  String MEMBERSHIP_BIND_ADDRESS_NAME = MEMBERSHIP_BIND_ADDRESS;\n+\n+  /**\n+   * The default value of the {@link ConfigurationProperties#MEMBERSHIP_BIND_ADDRESS} property\n+   */\n+  String DEFAULT_MEMBERSHIP_BIND_ADDRESS = \"\";\n+\n+  /**\n+   * Returns the value of the {@link ConfigurationProperties#MEMBERSHIP_BIND_ADDRESS} property\n+   */\n+  @ConfigAttributeGetter(name = MEMBERSHIP_BIND_ADDRESS_NAME)\n+  String getMembershipBindAddress();\n+\n+  /**\n+   * Set the value of the {@link ConfigurationProperties#MEMBERSHIP_BIND_ADDRESS} property\n+   */\n+  @ConfigAttributeSetter(name = MEMBERSHIP_BIND_ADDRESS_NAME)\n+  void setMembershipBindAddress(String value);\n+\n   /**\n    * Returns the value of the {@link ConfigurationProperties#DEPLOY_WORKING_DIR} property\n    */"
  },
  {
    "sha": "3463d144ef65db59d15b4a4e3cf100b08b303b15",
    "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/DistributionConfigImpl.java",
    "status": "modified",
    "additions": 16,
    "deletions": 0,
    "changes": 16,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/internal/DistributionConfigImpl.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/internal/DistributionConfigImpl.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/DistributionConfigImpl.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -190,6 +190,11 @@\n    */\n   private int startLocatorPort;\n \n+  /**\n+   * The IP address to which the UDP membership-related traffic will be bound.\n+   */\n+  protected String membershipBindAddress = DEFAULT_MEMBERSHIP_BIND_ADDRESS;\n+\n   /**\n    * Is statistic sampling enabled?\n    */\n@@ -689,6 +694,7 @@ public DistributionConfigImpl(DistributionConfig other) {\n     roles = other.getRoles();\n     mcastAddress = other.getMcastAddress();\n     bindAddress = other.getBindAddress();\n+    membershipBindAddress = other.getMembershipBindAddress();\n     serverBindAddress = other.getServerBindAddress();\n     locators = ((DistributionConfigImpl) other).locators;\n     locatorWaitTime = other.getLocatorWaitTime();\n@@ -1833,6 +1839,11 @@ public String getStartLocator() {\n     return startLocator;\n   }\n \n+  @Override\n+  public String getMembershipBindAddress() {\n+    return membershipBindAddress;\n+  }\n+\n   @Override\n   public File getDeployWorkingDir() {\n     return deployWorkingDir;\n@@ -2129,6 +2140,11 @@ public void setStartLocator(String value) {\n     startLocator = value;\n   }\n \n+  @Override\n+  public void setMembershipBindAddress(String value) {\n+    membershipBindAddress = value;\n+  }\n+\n   @Override\n   public void setStatisticSamplingEnabled(boolean newValue) {\n     statisticSamplingEnabled = newValue;"
  },
  {
    "sha": "bcad27a5163ee38fe613918975e8b9f17bc7c4b3",
    "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/direct/DirectChannel.java",
    "status": "modified",
    "additions": 7,
    "deletions": 6,
    "changes": 13,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/internal/direct/DirectChannel.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/internal/direct/DirectChannel.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/direct/DirectChannel.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -681,14 +681,15 @@ public TCPConduit getConduit() {\n   private InetAddress initAddress(DistributionConfig dc) {\n \n     String bindAddress = dc.getBindAddress();\n-\n     try {\n-      /*\n-       * note: had to change the following to make sure the prop wasn't empty in addition to not\n-       * null for admin.DistributedSystemFactory\n-       */\n       if (bindAddress != null && bindAddress.length() > 0) {\n-        return InetAddress.getByName(bindAddress);\n+        InetAddress address;\n+        if (LocalHostUtil.isWildcardAddress(bindAddress)) {\n+          address = LocalHostUtil.getAnyLocalAddress();\n+        } else {\n+          address = InetAddress.getByName(bindAddress);\n+        }\n+        return address;\n \n       } else {\n         return LocalHostUtil.getLocalHost();"
  },
  {
    "sha": "1a11b44ba8773320a7f7c671b905478fdaeb4cce",
    "filename": "geode-core/src/main/java/org/apache/geode/distributed/internal/membership/adapter/ServiceConfig.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/adapter/ServiceConfig.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/adapter/ServiceConfig.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/distributed/internal/membership/adapter/ServiceConfig.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -198,6 +198,11 @@ public String getStartLocator() {\n     return dconfig.getStartLocator();\n   }\n \n+  @Override\n+  public String getMembershipBindAddress() {\n+    return dconfig.getMembershipBindAddress();\n+  }\n+\n   public boolean getEnableNetworkPartitionDetection() {\n     return dconfig.getEnableNetworkPartitionDetection();\n   }"
  },
  {
    "sha": "1af2afec751da4b2576a8ac81b549442a91a3070",
    "filename": "geode-core/src/main/java/org/apache/geode/management/internal/i18n/CliStrings.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/management/internal/i18n/CliStrings.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/main/java/org/apache/geode/management/internal/i18n/CliStrings.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/management/internal/i18n/CliStrings.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -2450,6 +2450,10 @@\n   public static final String START_LOCATOR__HTTP_SERVICE_BIND_ADDRESS = \"http-service-bind-address\";\n   public static final String START_LOCATOR__HTTP_SERVICE_BIND_ADDRESS__HELP =\n       \"The IP address on which the HTTP Service will be bound.  By default, the Server is bound to all local addresses.\";\n+  public static final String START_LOCATOR__MEMBERSHIP_BIND_ADDRESS =\n+      \"membership-bind-address\";\n+  public static final String START_LOCATOR__MEMBERSHIP_BIND_ADDRESS__HELP =\n+      \"Sets the IP address to which the UDP membership-related traffic will be bound.\";\n   public static final String START_LOCATOR__REDIRECT_OUTPUT = \"redirect-output\";\n   public static final String START_LOCATOR__REDIRECT_OUTPUT__HELP =\n       \"Causes the member to redirect standard out and standard error to its own log file\";\n@@ -2554,6 +2558,9 @@\n   public static final String START_SERVER__MCAST_PORT = MCAST_PORT;\n   public static final String START_SERVER__MCAST_PORT__HELP =\n       \"Sets the port used for multi-cast networking so the Cache Server can communicate with other members of the Geode cluster.  A zero value disables mcast.\";\n+  public static final String START_SERVER__MEMBERSHIP_BIND_ADDRESS = \"membership-bind-address\";\n+  public static final String START_SERVER__MEMBERSHIP_BIND_ADDRESS__HELP =\n+      \"Sets the IP address to which the UDP membership-related traffic will be bound.\";\n   public static final String START_SERVER__NAME = \"name\";\n   public static final String START_SERVER__NAME__HELP =\n       \"The member name to give this Cache Server in the Geode cluster.\";"
  },
  {
    "sha": "75180b37d86904566b6b16bb3a617f250ddc6189",
    "filename": "geode-core/src/test/java/org/apache/geode/distributed/internal/DistributionConfigJUnitTest.java",
    "status": "modified",
    "additions": 63,
    "deletions": 62,
    "changes": 125,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/test/java/org/apache/geode/distributed/internal/DistributionConfigJUnitTest.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-core/src/test/java/org/apache/geode/distributed/internal/DistributionConfigJUnitTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/test/java/org/apache/geode/distributed/internal/DistributionConfigJUnitTest.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -40,9 +40,6 @@\n import static org.apache.geode.distributed.ConfigurationProperties.STATISTIC_SAMPLING_ENABLED;\n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatThrownBy;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n import static org.mockito.Matchers.any;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n@@ -104,7 +101,7 @@ public void before() {\n   @Test\n   public void testGetAttributeNames() {\n     String[] attNames = AbstractDistributionConfig._getAttNames();\n-    assertThat(attNames.length).isEqualTo(169);\n+    assertThat(attNames).hasSize(170);\n \n     List boolList = new ArrayList();\n     List intList = new ArrayList();\n@@ -138,19 +135,19 @@ public void testGetAttributeNames() {\n \n     // TODO - This makes no sense. One has no idea what the correct expected number of attributes\n     // are.\n-    assertEquals(36, boolList.size());\n-    assertEquals(35, intList.size());\n-    assertEquals(88, stringList.size());\n-    assertEquals(5, fileList.size());\n-    assertEquals(5, otherList.size());\n+    assertThat(boolList).hasSize(36);\n+    assertThat(intList).hasSize(35);\n+    assertThat(stringList).hasSize(89);\n+    assertThat(fileList).hasSize(5);\n+    assertThat(otherList).hasSize(5);\n   }\n \n   @Test\n   public void testAttributeDesc() {\n     String[] attNames = AbstractDistributionConfig._getAttNames();\n     for (String attName : attNames) {\n-      assertTrue(\"Does not contain description for attribute \" + attName,\n-          AbstractDistributionConfig.dcAttDescriptions.containsKey(attName));\n+      assertThat(AbstractDistributionConfig.dcAttDescriptions.containsKey(attName))\n+          .as(\"Does not contain description for attribute \" + attName).isTrue();\n     }\n     List<String> attList = Arrays.asList(attNames);\n     for (Object attName : AbstractDistributionConfig.dcAttDescriptions.keySet()) {\n@@ -162,17 +159,17 @@ public void testAttributeDesc() {\n \n   @Test\n   public void sameCount() {\n-    assertEquals(attributes.size(), setters.size());\n-    assertEquals(setters.size(), getters.size());\n+    assertThat(setters).hasSize(attributes.size());\n+    assertThat(getters).hasSize(setters.size());\n   }\n \n   @Test\n   public void everyAttrHasValidSetter() {\n     for (String attr : attributes.keySet()) {\n       Method setter = setters.get(attr);\n-      assertNotNull(attr + \" should have a setter\", setter);\n-      assertTrue(setter.getName().startsWith(\"set\"));\n-      assertEquals(setter.getParameterCount(), 1);\n+      assertThat(setter).as(attr + \" should have a setter\").isNotNull();\n+      assertThat(setter.getName().startsWith(\"set\")).isTrue();\n+      assertThat(setter.getParameterCount()).isEqualTo(1);\n \n       if (!(attr.equalsIgnoreCase(LOG_LEVEL) || attr.equalsIgnoreCase(SECURITY_LOG_LEVEL))) {\n         Class clazz = attributes.get(attr).type();\n@@ -215,17 +212,17 @@ public void internalPropertiesAreIgnoredInSameAsCheck() {\n   public void everyAttrHasValidGetter() {\n     for (String attr : attributes.keySet()) {\n       Method getter = getters.get(attr);\n-      assertNotNull(attr + \" should have a getter\", getter);\n-      assertTrue(getter.getName().startsWith(\"get\"));\n-      assertEquals(getter.getParameterCount(), 0);\n+      assertThat(getter).as(attr + \" should have a getter\").isNotNull();\n+      assertThat(getter.getName().startsWith(\"get\")).isTrue();\n+      assertThat(getter.getParameterCount()).isEqualTo(0);\n \n       if (!(attr.equalsIgnoreCase(LOG_LEVEL) || attr.equalsIgnoreCase(SECURITY_LOG_LEVEL))) {\n         Class clazz = attributes.get(attr).type();\n         Class returnClass = getter.getReturnType();\n         if (returnClass.isPrimitive()) {\n           returnClass = classMap.get(returnClass);\n         }\n-        assertEquals(returnClass, clazz);\n+        assertThat(clazz).isEqualTo(returnClass);\n       }\n     }\n   }\n@@ -235,55 +232,59 @@ public void everyGetterSetterSameNameSameType() {\n     for (String attr : getters.keySet()) {\n       Method getter = getters.get(attr);\n       Method setter = setters.get(attr);\n-      assertNotNull(\"every getter should have a corresponding setter \" + attr, setter);\n+      assertThat(setter).as(\"every getter should have a corresponding setter \" + attr).isNotNull();\n       String setterName = setter.getName();\n       String getterName = getter.getName();\n-      assertEquals(setterName.substring(setterName.indexOf(\"set\") + 3),\n-          getterName.substring(getterName.indexOf(\"get\") + 3));\n-      assertEquals(setter.getParameterTypes()[0], getter.getReturnType());\n+      assertThat(getterName.substring(getterName.indexOf(\"get\") + 3))\n+          .isEqualTo(setterName.substring(setterName.indexOf(\"set\") + 3));\n+      assertThat(getter.getReturnType()).isEqualTo(setter.getParameterTypes()[0]);\n     }\n \n     for (String attr : setters.keySet()) {\n       Method getter = getters.get(attr);\n-      assertNotNull(\"every setter should have a corresponding getter: \" + attr, getter);\n+      assertThat(getter).as(\"every setter should have a corresponding getter: \" + attr).isNotNull();\n     }\n   }\n \n   @Test\n   public void everySetterHasAttributeDefined() {\n     for (String attr : setters.keySet()) {\n       ConfigAttribute configAttribute = attributes.get(attr);\n-      assertNotNull(attr + \" should be defined a ConfigAttribute\", configAttribute);\n+      assertThat(configAttribute).as(attr + \" should be defined a ConfigAttribute\").isNotNull();\n     }\n   }\n \n   @Test\n   public void everyGetterHasAttributeDefined() {\n     for (String attr : getters.keySet()) {\n       ConfigAttribute configAttribute = attributes.get(attr);\n-      assertNotNull(attr + \" should be defined a ConfigAttribute\", configAttribute);\n+      assertThat(configAttribute).as(attr + \" should be defined a ConfigAttribute\").isNotNull();\n     }\n   }\n \n   @Test\n   public void testGetAttributeObject() {\n-    assertEquals(config.getAttributeObject(LOG_LEVEL), \"config\");\n-    assertEquals(config.getAttributeObject(SECURITY_LOG_LEVEL), \"config\");\n-    assertEquals(config.getAttributeObject(REDUNDANCY_ZONE), \"\");\n-    assertEquals(config.getAttributeObject(ENABLE_CLUSTER_CONFIGURATION).getClass(), Boolean.class);\n+    assertThat(config.getAttributeObject(LOG_LEVEL)).isEqualTo(\"config\");\n+    assertThat(config.getAttributeObject(SECURITY_LOG_LEVEL)).isEqualTo(\"config\");\n+    assertThat(config.getAttributeObject(REDUNDANCY_ZONE)).isEqualTo(\"\");\n+    assertThat(config.getAttributeObject(ENABLE_CLUSTER_CONFIGURATION).getClass())\n+        .isEqualTo(Boolean.class);\n   }\n \n   @Test\n   public void testCheckerChecksValidAttribute() {\n     for (String att : checkers.keySet()) {\n       System.out.println(\"att = \" + att);\n-      assertTrue(attributes.containsKey(att));\n+      assertThat(attributes.containsKey(att)).isTrue();\n       Method checker = checkers.get(att);\n-      assertEquals(checker.getParameterCount(), 1);\n-      assertEquals(\"invalid checker: \" + checker.getName(), checker.getReturnType(),\n-          checker.getParameterTypes()[0]);\n-\n-      // TODO assert checker and setter accepts this same type of parameter\n+      assertThat(checker.getParameterCount()).isEqualTo(1);\n+      assertThat(checker.getParameterTypes()[0]).as(\"invalid checker: \" + checker.getName())\n+          .isEqualTo(checker.getReturnType());\n+      Method setter = setters.get(att);\n+      assertThat(checker.getParameterTypes()[0]).as(\"checker '\" + checker.getName()\n+          + \"' param type is '\" + checker.getParameterTypes()[0] + \"' but setter '\"\n+          + setter.getName() + \"' param type is '\" + setter.getParameterTypes()[0] + \"'\")\n+          .isEqualTo(setter.getParameterTypes()[0]);\n     }\n   }\n \n@@ -296,9 +297,9 @@ public void testDistributionConfigImplModifiable() {\n         modifiables.add(attName);\n       }\n     }\n-    assertEquals(modifiables.size(), 2);\n-    assertEquals(modifiables.get(0), HTTP_SERVICE_PORT);\n-    assertEquals(modifiables.get(1), JMX_MANAGER_HTTP_PORT);\n+    assertThat(modifiables.size()).isEqualTo(2);\n+    assertThat(modifiables.get(0)).isEqualTo(HTTP_SERVICE_PORT);\n+    assertThat(modifiables.get(1)).isEqualTo(JMX_MANAGER_HTTP_PORT);\n   }\n \n   @Test\n@@ -313,17 +314,17 @@ public void testRuntimeConfigModifiable() {\n       }\n     }\n \n-    assertEquals(modifiables.size(), 10);\n-    assertEquals(modifiables.get(0), ARCHIVE_DISK_SPACE_LIMIT);\n-    assertEquals(modifiables.get(1), ARCHIVE_FILE_SIZE_LIMIT);\n-    assertEquals(modifiables.get(2), HTTP_SERVICE_PORT);\n-    assertEquals(modifiables.get(3), JMX_MANAGER_HTTP_PORT);\n-    assertEquals(modifiables.get(4), LOG_DISK_SPACE_LIMIT);\n-    assertEquals(modifiables.get(5), LOG_FILE_SIZE_LIMIT);\n-    assertEquals(modifiables.get(6), LOG_LEVEL);\n-    assertEquals(modifiables.get(7), STATISTIC_ARCHIVE_FILE);\n-    assertEquals(modifiables.get(8), STATISTIC_SAMPLE_RATE);\n-    assertEquals(modifiables.get(9), STATISTIC_SAMPLING_ENABLED);\n+    assertThat(modifiables).hasSize(10);\n+    assertThat(modifiables.get(0)).isEqualTo(ARCHIVE_DISK_SPACE_LIMIT);\n+    assertThat(modifiables.get(1)).isEqualTo(ARCHIVE_FILE_SIZE_LIMIT);\n+    assertThat(modifiables.get(2)).isEqualTo(HTTP_SERVICE_PORT);\n+    assertThat(modifiables.get(3)).isEqualTo(JMX_MANAGER_HTTP_PORT);\n+    assertThat(modifiables.get(4)).isEqualTo(LOG_DISK_SPACE_LIMIT);\n+    assertThat(modifiables.get(5)).isEqualTo(LOG_FILE_SIZE_LIMIT);\n+    assertThat(modifiables.get(6)).isEqualTo(LOG_LEVEL);\n+    assertThat(modifiables.get(7)).isEqualTo(STATISTIC_ARCHIVE_FILE);\n+    assertThat(modifiables.get(8)).isEqualTo(STATISTIC_SAMPLE_RATE);\n+    assertThat(modifiables.get(9)).isEqualTo(STATISTIC_SAMPLING_ENABLED);\n   }\n \n   @Test(expected = IllegalArgumentException.class)\n@@ -339,7 +340,7 @@ public void testSetUnmodifiableAttributeObject() {\n   @Test\n   public void testValidAttributeObject() {\n     config.setAttributeObject(HTTP_SERVICE_PORT, 8080, ConfigSource.api());\n-    assertEquals(config.getHttpServicePort(), 8080);\n+    assertThat(config.getHttpServicePort()).isEqualTo(8080);\n   }\n \n   @Test(expected = IllegalArgumentException.class)\n@@ -351,25 +352,25 @@ public void testOutOfRangeAttributeObject() {\n   public void testLogLevel() {\n     config.modifiable = true;\n     config.setAttribute(LOG_LEVEL, \"config\", ConfigSource.api());\n-    assertEquals(config.getLogLevel(), 700);\n+    assertThat(config.getLogLevel()).isEqualTo(700);\n \n     config.setAttributeObject(SECURITY_LOG_LEVEL, \"debug\", ConfigSource.api());\n-    assertEquals(config.getSecurityLogLevel(), 500);\n+    assertThat(config.getSecurityLogLevel()).isEqualTo(500);\n   }\n \n   @Test\n   public void testLog4jLogLevel() {\n     config.modifiable = true;\n     config.setAttribute(LOG_LEVEL, \"fatal\", ConfigSource.api());\n-    assertEquals(config.getLogLevel(), 1000);\n+    assertThat(config.getLogLevel()).isEqualTo(1000);\n   }\n \n   @Test\n   public void testValidLocatorAddress() {\n     String address = \"81.240.0.1[7056]\";\n     config.modifiable = true;\n     config.setAttributeObject(START_LOCATOR, address, ConfigSource.api());\n-    assertEquals(config.getStartLocator(), address);\n+    assertThat(config.getStartLocator()).isEqualTo(address);\n   }\n \n   @Test\n@@ -383,12 +384,12 @@ public void testInvalidLocatorAddressDoesntThrowException() {\n   @Test\n   public void testAttributesAlwaysModifiable() {\n     config.modifiable = false;\n-    assertTrue(config.isAttributeModifiable(HTTP_SERVICE_PORT));\n-    assertTrue(config.isAttributeModifiable(JMX_MANAGER_HTTP_PORT));\n+    assertThat(config.isAttributeModifiable(HTTP_SERVICE_PORT)).isTrue();\n+    assertThat(config.isAttributeModifiable(JMX_MANAGER_HTTP_PORT)).isTrue();\n \n     config.modifiable = true;\n-    assertTrue(config.isAttributeModifiable(HTTP_SERVICE_PORT));\n-    assertTrue(config.isAttributeModifiable(JMX_MANAGER_HTTP_PORT));\n+    assertThat(config.isAttributeModifiable(HTTP_SERVICE_PORT)).isTrue();\n+    assertThat(config.isAttributeModifiable(JMX_MANAGER_HTTP_PORT)).isTrue();\n   }\n \n   @Test\n@@ -402,7 +403,7 @@ public void testSecurityProps() {\n \n     DistributionConfig config = new DistributionConfigImpl(props);\n     // SECURITY_ENABLED_COMPONENTS is automatically added to getSecurityProps\n-    assertEquals(config.getSecurityProps().size(), 3);\n+    assertThat(config.getSecurityProps().size()).isEqualTo(3);\n   }\n \n   @Test\n@@ -417,7 +418,7 @@ public void testSecurityPropsWithNoSetter() {\n \n     DistributionConfig config = new DistributionConfigImpl(props);\n     // SECURITY_ENABLED_COMPONENTS is automatically added to getSecurityProps\n-    assertEquals(config.getSecurityProps().size(), 4);\n+    assertThat(config.getSecurityProps().size()).isEqualTo(4);\n   }\n \n   @Test"
  },
  {
    "sha": "2b3bccef360092a8117f3532b0bd5088993ccfbb",
    "filename": "geode-docs/tools_modules/gfsh/command-pages/start.html.md.erb",
    "status": "modified",
    "additions": 28,
    "deletions": 4,
    "changes": 32,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-docs/tools_modules/gfsh/command-pages/start.html.md.erb",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-docs/tools_modules/gfsh/command-pages/start.html.md.erb",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-docs/tools_modules/gfsh/command-pages/start.html.md.erb?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -272,7 +272,7 @@ start locator --name=value [--bind-address=value] [--force(=value)]\n  [--connect(=value)] [--enable-cluster-configuration(=value)] [--load-cluster-configuration-from-dir(=value)]\n  [--cluster-config-dir=value] [--redirect-output(=value)]\n  [--http-service-port=value] [--http-service-bind-address=value] \n- [--J=value(,value)*]\n+ [--membership-bind-address=value] [--J=value(,value)*]\n ```\n \n **Parameters, start locator**\n@@ -298,7 +298,11 @@ start locator --name=value [--bind-address=value] [--force(=value)]\n </tr>\n <tr>\n <td><span class=\"keyword parmname\">\\-\\-bind-address</span></td>\n-<td>IP address on which the locator will be bound.</td>\n+<td>The IP address on which the locator will be bound. The '*' character is accepted for wildcard addresses.\n+<div class=\"note note\">\n+<b>Note:</b> In case the locator is bound to all local addresses, UDP membership-related traffic will be bound to the local host machine's address.\n+</div>\n+</td>\n <td>bind to all addresses</td>\n </tr>\n <tr>\n@@ -416,6 +420,14 @@ See <a href=\"../../../configuring/cluster_config/gfsh_persist.html\">Overview of\n <td>the local host machine's address</td>\n </tr>\n <tr>\n+<td><span class=\"keyword parmname\">\\-\\-membership-bind-address</span></td>\n+<td>Specifies the IP address to which the UDP membership-related traffic will be bound. If defined, it has precedence over the value of <code>bind-address</code>. Wildcard addresses are not accepted.\n+<div class=\"note note\">\n+<b>Note:</b> By default, UDP membership-related traffic is bound to <code>bind-address</code> but there is one exception. In case the locator is bound to all local addresses, UDP membership-related traffic will be bound to the local host machine's address by default.\n+</div></td>\n+<td>uses <code>bind-address</code></td>\n+</tr>\n+<tr>\n <td><span class=\"keyword parmname\">\\-\\-J </span></td>\n <td>Argument passed to the JVM on which the Locator will run. For example, specifying <code class=\"ph codeph\">--J=-Dfoo.bar=true</code> sets property &quot;foo.bar&quot; to &quot;true&quot;.\n <div class=\"note note\">\n@@ -495,7 +507,7 @@ start server --name=value [--assign-buckets(=value)] [--bind-address=value]\n     [--socket-buffer-size=value] [--lock-memory=value] [--off-heap-memory-size=value]\n     [--start-rest-api=value] [--redirect-output(=value)]\n     [--http-service-port=value] [--http-service-bind-address=value]\n-    [--user=value] [--password=value]\n+    [--user=value] [--password=value] [--membership-bind-address=value]\n ```\n \n **Parameters, start server**\n@@ -526,7 +538,11 @@ start server --name=value [--assign-buckets(=value)] [--bind-address=value]\n </tr>\n <tr>\n <td><span class=\"keyword parmname\">\\-\\-bind-address</span></td>\n-<td>The IP address on which the server will be bound.</td>\n+<td>The IP address on which the server will be bound. The '*' character is accepted for wildcard addresses.\n+<div class=\"note note\">\n+<b>Note:</b> In case the server is bound to all local addresses, UDP membership-related traffic will be bound to the local host machine's address.\n+</div>\n+</td>\n <td>binds to all local addresses</td>\n </tr>\n <tr>\n@@ -605,6 +621,14 @@ start server --name=value [--assign-buckets(=value)] [--bind-address=value]\n <td> </td>\n </tr>\n <tr>\n+<td><span class=\"keyword parmname\">\\-\\-membership-bind-address</span></td>\n+<td>Specifies the IP address to which the UDP membership-related traffic will be bound. If defined, it has precedence over the value of <code>bind-address</code>. Wildcard addresses are not accepted.\n+<div class=\"note note\">\n+<b>Note:</b> By default, UDP membership-related traffic is bound to <code>bind-address</code> but there is one exception. In case the server is bound to all local addresses, UDP membership-related traffic will be bound to the local host machine's address by default.\n+</div></td>\n+<td>uses <code>bind-address</code></td>\n+</tr>\n+<tr>\n <td><span class=\"keyword parmname\">\\-\\-memcached-port</span></td>\n <td>If specified and is non-zero, sets the port number for an embedded Gemcached server and starts the Gemcached server.</td>\n <td> </td>"
  },
  {
    "sha": "d9e508850aedd93e61fa2d26f26c2379737b649d",
    "filename": "geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/GfshParserAutoCompletionIntegrationTest.java",
    "status": "modified",
    "additions": 14,
    "deletions": 8,
    "changes": 22,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/GfshParserAutoCompletionIntegrationTest.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/GfshParserAutoCompletionIntegrationTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/GfshParserAutoCompletionIntegrationTest.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -30,6 +30,12 @@\n @Category(GfshTest.class)\n public class GfshParserAutoCompletionIntegrationTest {\n \n+  /**\n+   * Number of @CliOption parameters of StartServerCommand.startServer()\n+   * method +1 due to \"--group\" & \"--groups\" are defined in the same @CliOption\n+   */\n+  final int startServerCommandCliOptions = 55;\n+\n   @Rule\n   public GfshParserRule gfshParserRule = new GfshParserRule();\n \n@@ -148,7 +154,7 @@ public void testCompleteWithDashInTheEnd() {\n     String buffer = \"start server --name=name1 --\";\n     CommandCandidate candidate = gfshParserRule.complete(buffer);\n     assertThat(candidate.getCursor()).isEqualTo(buffer.length() - 2);\n-    assertThat(candidate.getCandidates()).hasSize(53);\n+    assertThat(candidate.getCandidates()).hasSize(startServerCommandCliOptions - 1);\n     assertThat(candidate.getCandidates()).contains(new Completion(\"--properties-file\"));\n     assertThat(candidate.getFirstCandidate()).isEqualTo(buffer + \"J\");\n   }\n@@ -158,7 +164,7 @@ public void testCompleteWithSpace() {\n     String buffer = \"start server --name=name1 \";\n     CommandCandidate candidate = gfshParserRule.complete(buffer);\n     assertThat(candidate.getCursor()).isEqualTo(buffer.length() - 1);\n-    assertThat(candidate.getCandidates()).hasSize(53);\n+    assertThat(candidate.getCandidates()).hasSize(startServerCommandCliOptions - 1);\n     assertThat(candidate.getCandidates()).contains(new Completion(\" --properties-file\"));\n     assertThat(candidate.getFirstCandidate()).isEqualTo(buffer + \"--J\");\n   }\n@@ -168,7 +174,7 @@ public void testCompleteWithOutSpace() {\n     String buffer = \"start server --name=name1\";\n     CommandCandidate candidate = gfshParserRule.complete(buffer);\n     assertThat(candidate.getCursor()).isEqualTo(buffer.length());\n-    assertThat(candidate.getCandidates()).hasSize(53);\n+    assertThat(candidate.getCandidates()).hasSize(startServerCommandCliOptions - 1);\n     assertThat(candidate.getCandidates()).contains(new Completion(\" --properties-file\"));\n     assertThat(candidate.getFirstCandidate()).isEqualTo(buffer + \" --J\");\n   }\n@@ -193,7 +199,7 @@ public void testCompleteWithValue() {\n   public void testCompleteWithDash() {\n     String buffer = \"start server --name=name1 --J=-Dfoo.bar --\";\n     CommandCandidate candidate = gfshParserRule.complete(buffer);\n-    assertThat(candidate.getCandidates()).hasSize(52);\n+    assertThat(candidate.getCandidates()).hasSize(startServerCommandCliOptions - 2);\n   }\n \n   @Test\n@@ -211,7 +217,7 @@ public void testMultiJComplete() {\n     String buffer = \"start server --name=name1 --J=-Dtest=test1 --J=-Dfoo=bar\";\n     CommandCandidate candidate = gfshParserRule.complete(buffer);\n     assertThat(candidate.getCursor()).isEqualTo(buffer.length());\n-    assertThat(candidate.getCandidates()).hasSize(52);\n+    assertThat(candidate.getCandidates()).hasSize(startServerCommandCliOptions - 2);\n     assertThat(candidate.getFirstCandidate()).isEqualTo(buffer + \" --assign-buckets\");\n   }\n \n@@ -220,7 +226,7 @@ public void testMultiJCompleteWithDifferentOrder() {\n     String buffer = \"start server --J=-Dtest=test1 --J=-Dfoo=bar --name=name1\";\n     CommandCandidate candidate = gfshParserRule.complete(buffer);\n     assertThat(candidate.getCursor()).isEqualTo(buffer.length());\n-    assertThat(candidate.getCandidates()).hasSize(52);\n+    assertThat(candidate.getCandidates()).hasSize(startServerCommandCliOptions - 2);\n     assertThat(candidate.getFirstCandidate()).isEqualTo(buffer + \" --assign-buckets\");\n   }\n \n@@ -229,7 +235,7 @@ public void testJComplete3() {\n     String buffer = \"start server --name=name1 --locators=localhost --J=-Dfoo=bar\";\n     CommandCandidate candidate = gfshParserRule.complete(buffer);\n     assertThat(candidate.getCursor()).isEqualTo(buffer.length());\n-    assertThat(candidate.getCandidates()).hasSize(51);\n+    assertThat(candidate.getCandidates()).hasSize(startServerCommandCliOptions - 3);\n     assertThat(candidate.getFirstCandidate()).isEqualTo(buffer + \" --assign-buckets\");\n   }\n \n@@ -238,7 +244,7 @@ public void testJComplete4() {\n     String buffer = \"start server --name=name1 --locators=localhost  --J=-Dfoo=bar --\";\n     CommandCandidate candidate = gfshParserRule.complete(buffer);\n     assertThat(candidate.getCursor()).isEqualTo(buffer.length() - 2);\n-    assertThat(candidate.getCandidates()).hasSize(51);\n+    assertThat(candidate.getCandidates()).hasSize(startServerCommandCliOptions - 3);\n     assertThat(candidate.getFirstCandidate()).isEqualTo(buffer + \"assign-buckets\");\n   }\n "
  },
  {
    "sha": "5bc9ffbe088b06baddf8afa2d0a1c7ab161013b4",
    "filename": "geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/StartMemberUtilsTest.java",
    "status": "modified",
    "additions": 49,
    "deletions": 4,
    "changes": 53,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/StartMemberUtilsTest.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/StartMemberUtilsTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/StartMemberUtilsTest.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -55,14 +55,14 @@ public void workingDirCantBeCreatedThrowsException() {\n     when(userSpecifiedDir.exists()).thenReturn(false);\n     when(userSpecifiedDir.mkdirs()).thenReturn(false);\n     assertThatThrownBy(\n-        () -> StartMemberUtils.resolveWorkingDir(userSpecifiedDir, new File(\"server1\")))\n+        () -> StartMemberUtils.resolveWorkingDirectory(userSpecifiedDir))\n             .isInstanceOf(IllegalStateException.class)\n             .hasMessageContaining(\"Could not create directory\");\n   }\n \n   @Test\n   public void workingDirDefaultsToMemberName() {\n-    String workingDir = StartMemberUtils.resolveWorkingDir(null, new File(\"server1\"));\n+    String workingDir = StartMemberUtils.resolveWorkingDirectory(null, \"server1\");\n     assertThat(new File(workingDir)).exists();\n     assertThat(workingDir).endsWith(\"server1\");\n   }\n@@ -73,7 +73,7 @@ public void workingDirGetsCreatedIfNecessary() throws Exception {\n     FileUtils.deleteQuietly(workingDir);\n     String workingDirString = workingDir.getAbsolutePath();\n     String resolvedWorkingDir =\n-        StartMemberUtils.resolveWorkingDir(new File(workingDirString), new File(\"server1\"));\n+        StartMemberUtils.resolveWorkingDirectory(workingDirString, \"server1\");\n     assertThat(new File(resolvedWorkingDir)).exists();\n     assertThat(workingDirString).endsWith(\"foo\");\n   }\n@@ -83,7 +83,7 @@ public void testWorkingDirWithRelativePath() throws Exception {\n     Path relativePath = Paths.get(\"some\").resolve(\"relative\").resolve(\"path\");\n     assertThat(relativePath.isAbsolute()).isFalse();\n     String resolvedWorkingDir =\n-        StartMemberUtils.resolveWorkingDir(new File(relativePath.toString()), new File(\"server1\"));\n+        StartMemberUtils.resolveWorkingDirectory(relativePath.toString(), \"server1\");\n     assertThat(resolvedWorkingDir).isEqualTo(relativePath.toAbsolutePath().toString());\n   }\n \n@@ -192,4 +192,49 @@ private void writePid(final File pidFile, final int pid) throws IOException {\n     fileWriter.flush();\n     IOUtils.close(fileWriter);\n   }\n+\n+  @Test\n+  public void whenResolveWorkingDirectoryIsCalledWithTwoNonEmptyStrings_thenTheUserSpecifiedDirectoryIsReturned()\n+      throws Exception {\n+    String userSpecifiedDir = \"locator1Directory\";\n+    String memberNameDir = \"member1\";\n+    assertThat(StartMemberUtils.resolveWorkingDirectory(userSpecifiedDir, memberNameDir))\n+        .isEqualTo(new File(userSpecifiedDir).getAbsolutePath());\n+  }\n+\n+  @Test\n+  public void whenResolveWorkingDirectoryIsCalledWithNullUserSpecifiedDir_thenTheMemberNameDirectoryIsReturned()\n+      throws Exception {\n+    String memberNameDir = \"member1\";\n+    assertThat(StartMemberUtils.resolveWorkingDirectory(null, memberNameDir))\n+        .isEqualTo(new File(memberNameDir).getAbsolutePath());\n+  }\n+\n+  @Test\n+  public void whenResolveWorkingDirectoryIsCalledWithEmptyUserSpecifiedDir_thenTheMemberNameDirectoryIsReturned()\n+      throws Exception {\n+    String userSpecifiedDir = \"\";\n+    String memberNameDir = \"member1\";\n+    assertThat(StartMemberUtils.resolveWorkingDirectory(userSpecifiedDir, memberNameDir))\n+        .isEqualTo(new File(memberNameDir).getAbsolutePath());\n+  }\n+\n+  @Test\n+  public void whenResolveWorkingDirectoryIsCalledWithUserSpecifiedDirAsDot_thenTheUserSpecifiedDirectoryIsReturned()\n+      throws Exception {\n+    String userSpecifiedDir = \".\";\n+    String memberNameDir = \"member1\";\n+    assertThat(StartMemberUtils.resolveWorkingDirectory(userSpecifiedDir, memberNameDir))\n+        .isEqualTo(\n+            StartMemberUtils.resolveWorkingDirectory(new File(userSpecifiedDir)));\n+  }\n+\n+  @Test\n+  public void whenResolveWorkingDirectoryIsCalledWithUserSpecifiedDirAsAbsolutePath_thenTheUserSpecifiedDirectoryIsReturned()\n+      throws Exception {\n+    String userSpecifiedDir = new File(System.getProperty(\"user.dir\")).getAbsolutePath();\n+    String memberNameDir = \"member1\";\n+    assertThat(StartMemberUtils.resolveWorkingDirectory(userSpecifiedDir, memberNameDir))\n+        .isEqualTo(new File(userSpecifiedDir).getAbsolutePath());\n+  }\n }"
  },
  {
    "sha": "d54b431c1ace392574878b6ff32c61ed73f20455",
    "filename": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommand.java",
    "status": "modified",
    "additions": 26,
    "deletions": 9,
    "changes": 35,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommand.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommand.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommand.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -15,8 +15,12 @@\n \n package org.apache.geode.management.internal.cli.commands;\n \n+import static org.apache.geode.management.internal.cli.commands.StartMemberUtils.resolveWorkingDirectory;\n+\n import java.io.File;\n import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n import java.net.InetAddress;\n import java.util.ArrayList;\n import java.util.Arrays;\n@@ -36,6 +40,7 @@\n import org.apache.geode.distributed.ConfigurationProperties;\n import org.apache.geode.distributed.LocatorLauncher;\n import org.apache.geode.distributed.ServerLauncher;\n+import org.apache.geode.internal.inet.LocalHostUtil;\n import org.apache.geode.internal.lang.SystemUtils;\n import org.apache.geode.internal.process.ProcessStreamReader;\n import org.apache.geode.internal.util.IOUtils;\n@@ -63,7 +68,7 @@ public ResultModel startLocator(\n       @CliOption(key = CliStrings.START_LOCATOR__MEMBER_NAME,\n           help = CliStrings.START_LOCATOR__MEMBER_NAME__HELP) String memberName,\n       @CliOption(key = CliStrings.START_LOCATOR__BIND_ADDRESS,\n-          help = CliStrings.START_LOCATOR__BIND_ADDRESS__HELP) final String bindAddress,\n+          help = CliStrings.START_LOCATOR__BIND_ADDRESS__HELP) String bindAddress,\n       @CliOption(key = CliStrings.START_LOCATOR__CLASSPATH,\n           help = CliStrings.START_LOCATOR__CLASSPATH__HELP) final String classpath,\n       @CliOption(key = CliStrings.START_LOCATOR__FORCE, unspecifiedDefaultValue = \"false\",\n@@ -120,22 +125,32 @@ public ResultModel startLocator(\n           help = CliStrings.START_LOCATOR__HTTP_SERVICE_BIND_ADDRESS__HELP) final String httpServiceBindAddress,\n       @CliOption(key = CliStrings.START_LOCATOR__REDIRECT_OUTPUT, unspecifiedDefaultValue = \"false\",\n           specifiedDefaultValue = \"true\",\n-          help = CliStrings.START_LOCATOR__REDIRECT_OUTPUT__HELP) final Boolean redirectOutput)\n+          help = CliStrings.START_LOCATOR__REDIRECT_OUTPUT__HELP) final Boolean redirectOutput,\n+      @CliOption(key = CliStrings.START_LOCATOR__MEMBERSHIP_BIND_ADDRESS,\n+          help = CliStrings.START_LOCATOR__MEMBERSHIP_BIND_ADDRESS__HELP) final String membershipBindAddress)\n       throws Exception {\n     if (StringUtils.isBlank(memberName)) {\n       // when the user doesn't give us a name, we make one up!\n       memberName = StartMemberUtils.getNameGenerator().generate('-');\n     }\n \n-    workingDirectory = StartMemberUtils.resolveWorkingDir(\n-        workingDirectory == null ? null : new File(workingDirectory), new File(memberName));\n+    if (bindAddress != null && bindAddress.equals(\"*\")) {\n+      if (LocalHostUtil.getAnyLocalAddress() instanceof Inet4Address) {\n+        bindAddress = \"0.0.0.0\";\n+      } else if (LocalHostUtil.getAnyLocalAddress() instanceof Inet6Address) {\n+        bindAddress = \"::\";\n+      }\n+    }\n+\n+    String resolvedWorkingDirectory = resolveWorkingDirectory(workingDirectory, memberName);\n \n     return doStartLocator(memberName, bindAddress, classpath, force, group, hostnameForClients,\n         jmxManagerHostnameForClients, includeSystemClasspath, locators, logLevel, mcastBindAddress,\n-        mcastPort, port, workingDirectory, gemfirePropertiesFile, gemfireSecurityPropertiesFile,\n+        mcastPort, port, resolvedWorkingDirectory, gemfirePropertiesFile,\n+        gemfireSecurityPropertiesFile,\n         initialHeap, maxHeap, jvmArgsOpts, connect, enableSharedConfiguration,\n         loadSharedConfigurationFromDirectory, clusterConfigDir, httpServicePort,\n-        httpServiceBindAddress, redirectOutput);\n+        httpServiceBindAddress, redirectOutput, membershipBindAddress);\n \n   }\n \n@@ -165,7 +180,8 @@ ResultModel doStartLocator(\n       String clusterConfigDir,\n       Integer httpServicePort,\n       String httpServiceBindAddress,\n-      Boolean redirectOutput)\n+      Boolean redirectOutput,\n+      String membershipBindAddress)\n       throws MalformedObjectNameException, IOException, InterruptedException,\n       ClassNotFoundException {\n     if (gemfirePropertiesFile != null && !gemfirePropertiesFile.exists()) {\n@@ -182,6 +198,8 @@ ResultModel doStartLocator(\n \n     Properties gemfireProperties = new Properties();\n \n+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.BIND_ADDRESS,\n+        bindAddress);\n     StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.GROUPS, group);\n     StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOCATORS,\n         locators);\n@@ -212,8 +230,8 @@ ResultModel doStartLocator(\n     if (memberName != null) {\n       locatorLauncherBuilder.setMemberName(memberName);\n     }\n+    locatorLauncherBuilder.setMembershipBindAddress(membershipBindAddress);\n     LocatorLauncher locatorLauncher = locatorLauncherBuilder.build();\n-\n     String[] locatorCommandLine = createStartLocatorCommandLine(locatorLauncher,\n         gemfirePropertiesFile, gemfireSecurityPropertiesFile, gemfireProperties, classpath,\n         includeSystemClasspath, jvmArgsOpts, initialHeap, maxHeap);\n@@ -464,7 +482,6 @@ private void doOnConnectionFailure(final String locatorHostName, final int locat\n     StartMemberUtils.addJvmArgumentsAndOptions(commandLine, jvmArgsOpts);\n     StartMemberUtils.addInitialHeap(commandLine, initialHeap);\n     StartMemberUtils.addMaxHeap(commandLine, maxHeap);\n-\n     commandLine.add(\n         \"-D\".concat(AbstractLauncher.SIGNAL_HANDLER_REGISTRATION_SYSTEM_PROPERTY.concat(\"=true\")));\n     commandLine.add(\"-Djava.awt.headless=true\");"
  },
  {
    "sha": "bac73745ffd0b6f82128d9f3df67a193a1ad2453",
    "filename": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/StartMemberUtils.java",
    "status": "modified",
    "additions": 16,
    "deletions": 9,
    "changes": 25,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/StartMemberUtils.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/StartMemberUtils.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/StartMemberUtils.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -46,8 +46,8 @@\n  * @see StartLocatorCommand\n  * @see StartServerCommand\n  */\n-public class StartMemberUtils {\n-  public static final String GEODE_HOME = System.getenv(\"GEODE_HOME\");\n+class StartMemberUtils {\n+  static final String GEODE_HOME = System.getenv(\"GEODE_HOME\");\n \n   private static final String JAVA_HOME = System.getProperty(\"java.home\");\n   static final int CMS_INITIAL_OCCUPANCY_FRACTION = 60;\n@@ -72,13 +72,20 @@ static void setPropertyIfNotNull(Properties properties, String key, Object value\n     }\n   }\n \n-  static String resolveWorkingDir(File userSpecifiedDir, File memberNameDir) {\n-    File workingDir =\n-        (userSpecifiedDir == null || userSpecifiedDir.equals(new File(\"\"))) ? memberNameDir\n-            : userSpecifiedDir;\n-    String workingDirPath = IOUtils.tryGetCanonicalPathElseGetAbsolutePath(workingDir);\n-    if (!workingDir.exists()) {\n-      if (!workingDir.mkdirs()) {\n+  static String resolveWorkingDirectory(String userSpecifiedDir, String memberNameDir) {\n+    String resolvedDir;\n+    if (StringUtils.isBlank(userSpecifiedDir)) {\n+      resolvedDir = resolveWorkingDirectory(new File(memberNameDir));\n+    } else {\n+      resolvedDir = resolveWorkingDirectory(new File(userSpecifiedDir));\n+    }\n+    return resolvedDir;\n+  }\n+\n+  static String resolveWorkingDirectory(File workingDirectory) {\n+    String workingDirPath = IOUtils.tryGetCanonicalPathElseGetAbsolutePath(workingDirectory);\n+    if (!workingDirectory.exists()) {\n+      if (!workingDirectory.mkdirs()) {\n         throw new IllegalStateException(String.format(\n             \"Could not create directory %s. Please verify directory path or user permissions.\",\n             workingDirPath));"
  },
  {
    "sha": "8f0255af29282c603267afd9e1df860e3c5017e8",
    "filename": "geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/StartServerCommand.java",
    "status": "modified",
    "additions": 30,
    "deletions": 7,
    "changes": 37,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/StartServerCommand.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/StartServerCommand.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/StartServerCommand.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -14,8 +14,13 @@\n  */\n package org.apache.geode.management.internal.cli.commands;\n \n+\n+import static org.apache.geode.management.internal.cli.commands.StartMemberUtils.resolveWorkingDirectory;\n+\n import java.io.File;\n import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n@@ -33,6 +38,7 @@\n import org.apache.geode.distributed.AbstractLauncher;\n import org.apache.geode.distributed.ConfigurationProperties;\n import org.apache.geode.distributed.ServerLauncher;\n+import org.apache.geode.internal.inet.LocalHostUtil;\n import org.apache.geode.internal.lang.SystemUtils;\n import org.apache.geode.internal.process.ProcessStreamReader;\n import org.apache.geode.internal.util.IOUtils;\n@@ -59,7 +65,7 @@ public ResultModel startServer(\n           specifiedDefaultValue = \"true\",\n           help = CliStrings.START_SERVER__ASSIGN_BUCKETS__HELP) final Boolean assignBuckets,\n       @CliOption(key = CliStrings.START_SERVER__BIND_ADDRESS,\n-          help = CliStrings.START_SERVER__BIND_ADDRESS__HELP) final String bindAddress,\n+          help = CliStrings.START_SERVER__BIND_ADDRESS__HELP) String bindAddress,\n       @CliOption(key = CliStrings.START_SERVER__CACHE_XML_FILE,\n           optionContext = ConverterHint.FILE_PATH,\n           help = CliStrings.START_SERVER__CACHE_XML_FILE__HELP) String cacheXmlPathname,\n@@ -176,7 +182,9 @@ public ResultModel startServer(\n           help = CliStrings.START_SERVER__PASSWORD__HELP) String passwordToUse,\n       @CliOption(key = CliStrings.START_SERVER__REDIRECT_OUTPUT, unspecifiedDefaultValue = \"false\",\n           specifiedDefaultValue = \"true\",\n-          help = CliStrings.START_SERVER__REDIRECT_OUTPUT__HELP) final Boolean redirectOutput)\n+          help = CliStrings.START_SERVER__REDIRECT_OUTPUT__HELP) final Boolean redirectOutput,\n+      @CliOption(key = CliStrings.START_SERVER__MEMBERSHIP_BIND_ADDRESS,\n+          help = CliStrings.START_SERVER__MEMBERSHIP_BIND_ADDRESS__HELP) final String membershipBindAddress)\n       throws Exception {\n     // NOTICE: keep the parameters in alphabetical order based on their CliStrings.START_SERVER_*\n     // text\n@@ -196,11 +204,19 @@ public ResultModel startServer(\n       }\n     }\n \n-    workingDirectory = StartMemberUtils.resolveWorkingDir(\n-        workingDirectory == null ? null : new File(workingDirectory), new File(memberName));\n+    if (bindAddress != null && bindAddress.equals(\"*\")) {\n+      if (LocalHostUtil.getAnyLocalAddress() instanceof Inet4Address) {\n+        bindAddress = \"0.0.0.0\";\n+      } else if (LocalHostUtil.getAnyLocalAddress() instanceof Inet6Address) {\n+        bindAddress = \"::\";\n+      }\n+    }\n+\n+    String resolvedWorkingDirectory = resolveWorkingDirectory(workingDirectory, memberName);\n \n     return doStartServer(memberName, assignBuckets, bindAddress, cacheXmlPathname, classpath,\n-        criticalHeapPercentage, criticalOffHeapPercentage, workingDirectory, disableDefaultServer,\n+        criticalHeapPercentage, criticalOffHeapPercentage, resolvedWorkingDirectory,\n+        disableDefaultServer,\n         disableExitWhenOutOfMemory, enableTimeStatistics, evictionHeapPercentage,\n         evictionOffHeapPercentage, force, group, hostNameForClients, jmxManagerHostnameForClients,\n         includeSystemClasspath, initialHeap, jvmArgsOpts, locators, locatorWaitTime, lockMemory,\n@@ -209,7 +225,8 @@ public ResultModel startServer(\n         redisPassword, messageTimeToLive, offHeapMemorySize, gemfirePropertiesFile, rebalance,\n         gemfireSecurityPropertiesFile, serverBindAddress, serverPort, socketBufferSize,\n         springXmlLocation, statisticsArchivePathname, requestSharedConfiguration, startRestApi,\n-        httpServicePort, httpServiceBindAddress, userName, passwordToUse, redirectOutput);\n+        httpServicePort, httpServiceBindAddress, userName, passwordToUse, redirectOutput,\n+        membershipBindAddress);\n   }\n \n   ResultModel doStartServer(String memberName, Boolean assignBuckets, String bindAddress,\n@@ -228,7 +245,7 @@ ResultModel doStartServer(String memberName, Boolean assignBuckets, String bindA\n       Integer serverPort, Integer socketBufferSize, String springXmlLocation,\n       String statisticsArchivePathname, Boolean requestSharedConfiguration, Boolean startRestApi,\n       String httpServicePort, String httpServiceBindAddress, String userName, String passwordToUse,\n-      Boolean redirectOutput)\n+      Boolean redirectOutput, String membershipBindAddress)\n       throws MalformedObjectNameException, IOException, InterruptedException {\n     cacheXmlPathname = CliUtil.resolvePathname(cacheXmlPathname);\n \n@@ -336,6 +353,7 @@ ResultModel doStartServer(String memberName, Boolean assignBuckets, String bindA\n     if (memberName != null) {\n       serverLauncherBuilder.setMemberName(memberName);\n     }\n+    serverLauncherBuilder.setMembershipBindAddress(membershipBindAddress);\n     ServerLauncher serverLauncher = serverLauncherBuilder.build();\n \n     String[] serverCommandLine = createStartServerCommandLine(serverLauncher, gemfirePropertiesFile,\n@@ -567,6 +585,11 @@ Process getProcess(String workingDir, String[] serverCommandLine) throws IOExcep\n           + launcher.getHostNameForClients());\n     }\n \n+    if (launcher.membershipBindAddressSpecified()) {\n+      commandLine.add(\"--\" + CliStrings.START_SERVER__MEMBERSHIP_BIND_ADDRESS + \"=\"\n+          + launcher.getMembershipBindAddress());\n+    }\n+\n     return commandLine.toArray(new String[] {});\n   }\n "
  },
  {
    "sha": "22c3dfc627f893b483ca7acf4b921ffa2e531605",
    "filename": "geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessengerJUnitTest.java",
    "status": "modified",
    "additions": 0,
    "deletions": 1,
    "changes": 1,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessengerJUnitTest.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessengerJUnitTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-membership/src/integrationTest/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessengerJUnitTest.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -1205,5 +1205,4 @@ public Object getOldMembershipInfo() {\n       return oldMembershipInfo;\n     }\n   }\n-\n }"
  },
  {
    "sha": "37a99b6cb34e766510f7a0c1ebad341c2c6ea30e",
    "filename": "geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/api/MembershipConfig.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/api/MembershipConfig.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/api/MembershipConfig.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/api/MembershipConfig.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -37,6 +37,7 @@\n   String DEFAULT_SECURITY_UDP_DHALGO = \"\";\n   int DEFAULT_UDP_FRAGMENT_SIZE = 60000;\n   String DEFAULT_START_LOCATOR = \"\";\n+  String DEFAULT_MEMBERSHIP_BIND_ADDRESS = \"\";\n   int DEFAULT_MEMBER_TIMEOUT = 5000;\n   int DEFAULT_LOSS_THRESHOLD = 51;\n   int DEFAULT_MEMBER_WEIGHT = 0;\n@@ -132,6 +133,10 @@ default String getStartLocator() {\n     return DEFAULT_START_LOCATOR;\n   }\n \n+  default String getMembershipBindAddress() {\n+    return DEFAULT_MEMBERSHIP_BIND_ADDRESS;\n+  }\n+\n   default String getBindAddress() {\n     return DEFAULT_BIND_ADDRESS;\n   };"
  },
  {
    "sha": "d1fbcdaf73655ef3bd09011eb91c1780a15531f3",
    "filename": "geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/gms/fd/GMSHealthMonitor.java",
    "status": "modified",
    "additions": 18,
    "deletions": 2,
    "changes": 20,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/gms/fd/GMSHealthMonitor.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/gms/fd/GMSHealthMonitor.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/gms/fd/GMSHealthMonitor.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -24,6 +24,7 @@\n import java.net.ServerSocket;\n import java.net.Socket;\n import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -71,6 +72,7 @@\n import org.apache.geode.distributed.internal.tcpserver.ConnectionWatcher;\n import org.apache.geode.distributed.internal.tcpserver.HostAndPort;\n import org.apache.geode.distributed.internal.tcpserver.TcpSocketCreator;\n+import org.apache.geode.internal.inet.LocalHostUtil;\n import org.apache.geode.internal.lang.JavaWorkarounds;\n import org.apache.geode.internal.serialization.KnownVersion;\n import org.apache.geode.logging.internal.executors.LoggingExecutors;\n@@ -953,8 +955,22 @@ public void init(Services<ID> s) throws MembershipConfigurationException {\n   public void started() throws MemberStartupException {\n     setLocalAddress(services.getMessenger().getMemberID());\n     try {\n-      serverSocket = createServerSocket(localAddress.getInetAddress(),\n-          services.getConfig().getMembershipPortRange());\n+      InetAddress address = localAddress.getInetAddress();\n+      String bindAddrStr = services.getConfig().getBindAddress();\n+      if (bindAddrStr != null && !bindAddrStr.isEmpty()) {\n+        try {\n+          if (LocalHostUtil.isWildcardAddress(bindAddrStr)) {\n+            address = LocalHostUtil.getAnyLocalAddress();\n+          } else {\n+            address = InetAddress.getByName(bindAddrStr);\n+          }\n+        } catch (UnknownHostException e) {\n+          logger.error(\n+              \"Error when configuring {} as bind address in membership, default address will be used. Exception: {}\",\n+              services.getConfig().getBindAddress(), e.getMessage());\n+        }\n+      }\n+      serverSocket = createServerSocket(address, services.getConfig().getMembershipPortRange());\n     } catch (IOException e) {\n       throw new MemberStartupException(\"Problem creating HealthMonitor socket\", e);\n     }"
  },
  {
    "sha": "802c4911eb4c4f5fa6693164d9348aacbb7d3434",
    "filename": "geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessenger.java",
    "status": "modified",
    "additions": 30,
    "deletions": 10,
    "changes": 40,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessenger.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessenger.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-membership/src/main/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessenger.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -279,16 +279,11 @@ public void init(Services<ID> s) throws MembershipConfigurationException {\n     properties =\n         replaceStrings(properties, \"UDP_SEND_BUFFER_SIZE\", \"\" + config.getUdpSendBufferSize());\n \n-    String str = config.getBindAddress();\n     // JGroups UDP protocol requires a bind address\n-    if (str == null || str.length() == 0) {\n-      try {\n-        str = LocalHostUtil.getLocalHost().getHostAddress();\n-      } catch (UnknownHostException e) {\n-        throw new MembershipConfigurationException(e.getMessage(), e);\n-      }\n-    }\n-    properties = replaceStrings(properties, \"BIND_ADDR_SETTING\", \"bind_addr=\\\"\" + str + \"\\\"\");\n+    String bindAddressStr =\n+        getAddressForUDPBinding(config.getBindAddress(), config.getMembershipBindAddress());\n+    properties =\n+        replaceStrings(properties, \"BIND_ADDR_SETTING\", \"bind_addr=\\\"\" + bindAddressStr + \"\\\"\");\n \n     int port = Integer.getInteger(GeodeGlossary.GEMFIRE_PREFIX + \"jg-bind-port\", 0);\n     if (port != 0) {\n@@ -321,6 +316,32 @@ public void init(Services<ID> s) throws MembershipConfigurationException {\n     }\n   }\n \n+  /**\n+   * Decides which address will be used to UDP binding.\n+   *\n+   * @param bindAddress Value of bind-address config parameter\n+   * @param membershipBindAddress Value of membership-bind-address config parameter\n+   * @return Address that will be used to UDP binding.\n+   */\n+  String getAddressForUDPBinding(String bindAddress, String membershipBindAddress)\n+      throws MembershipConfigurationException {\n+    try {\n+      if (membershipBindAddress != null && membershipBindAddress.length() > 0) {\n+        if (LocalHostUtil.isWildcardAddress(membershipBindAddress)) {\n+          throw new MembershipConfigurationException(\n+              \"'membership-bind-address' cannot be a wildcard address. JGroups UDP protocol requires a bind address.\");\n+        }\n+        return membershipBindAddress;\n+      } else if (bindAddress == null || bindAddress.length() == 0\n+          || LocalHostUtil.isWildcardAddress(bindAddress)) {\n+        return LocalHostUtil.getLocalHost().getHostAddress();\n+      }\n+    } catch (UnknownHostException e) {\n+      throw new MembershipConfigurationException(e.getMessage(), e);\n+    }\n+    return bindAddress;\n+  }\n+\n   @Override\n   @edu.umd.cs.findbugs.annotations.SuppressWarnings(\n       value = \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\")\n@@ -523,7 +544,6 @@ private void establishLocalAddress() throws MemberStartupException {\n     logicalAddress = logicalAddress.copy();\n \n     IpAddress ipaddr = (IpAddress) myChannel.down(new Event(Event.GET_PHYSICAL_ADDRESS));\n-\n     if (ipaddr != null) {\n       this.jgAddress = new JGAddress(logicalAddress, ipaddr);\n     } else {"
  },
  {
    "sha": "3282fcfcc1c587ca5df5d3f0b9baa2c8439a7dc6",
    "filename": "geode-membership/src/test/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessengerTest.java",
    "status": "added",
    "additions": 100,
    "deletions": 0,
    "changes": 100,
    "blob_url": "https://github.com/apache/geode/blob/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-membership/src/test/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessengerTest.java",
    "raw_url": "https://github.com/apache/geode/raw/16aace83102504f1f8c917c70d81fcf4ed7ad930/geode-membership/src/test/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessengerTest.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-membership/src/test/java/org/apache/geode/distributed/internal/membership/gms/messenger/JGroupsMessengerTest.java?ref=16aace83102504f1f8c917c70d81fcf4ed7ad930",
    "patch": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.distributed.internal.membership.gms.messenger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+\n+import java.net.UnknownHostException;\n+\n+import org.junit.Test;\n+\n+import org.apache.geode.distributed.internal.membership.api.MembershipConfigurationException;\n+import org.apache.geode.internal.inet.LocalHostUtil;\n+\n+public class JGroupsMessengerTest {\n+\n+  @Test\n+  public void getAddressForUDPBinding_ReturnsLocalAddressWhenInputParametersAreEmpty()\n+      throws MembershipConfigurationException, UnknownHostException {\n+    JGroupsMessenger j = new JGroupsMessenger();\n+    String localHostAddress = LocalHostUtil.getLocalHost().getHostAddress();\n+    assertThat(j.getAddressForUDPBinding(\"\", \"\"))\n+        .isEqualTo(localHostAddress);\n+  }\n+\n+  @Test\n+  public void getAddressForUDPBinding_ReturnsBindAddressWhenDefinedAndMembershipBindAddressIsEmpty()\n+      throws MembershipConfigurationException {\n+    JGroupsMessenger j = new JGroupsMessenger();\n+    String bindAddress = \"1.2.3.4\";\n+    String membershipBindAddress = \"\";\n+    assertThat(j.getAddressForUDPBinding(bindAddress, membershipBindAddress))\n+        .isEqualTo(bindAddress);\n+  }\n+\n+  @Test\n+  public void getAddressForUDPBinding_ReturnsMembershipAddressWhenDefinedAndBindAddressIsEmpty()\n+      throws MembershipConfigurationException {\n+    JGroupsMessenger j = new JGroupsMessenger();\n+    String bindAddress = \"\";\n+    String membershipBindAddress = \"4.3.2.1\";\n+    assertThat(j.getAddressForUDPBinding(bindAddress, membershipBindAddress))\n+        .isEqualTo(membershipBindAddress);\n+  }\n+\n+  @Test\n+  public void getAddressForUDPBinding_ReturnsMembershipAddressWhenBothInputParametersAreDefined()\n+      throws MembershipConfigurationException {\n+    JGroupsMessenger j = new JGroupsMessenger();\n+    String bindAddress = \"1.2.3.4\";\n+    String membershipBindAddress = \"4.3.2.1\";\n+    assertThat(j.getAddressForUDPBinding(bindAddress, membershipBindAddress))\n+        .isEqualTo(membershipBindAddress);\n+  }\n+\n+  @Test\n+  public void getAddressForUDPBinding_ReturnsLocalAddressWhenBindAddressIsIPv4WildcardAndMembershipBindAddressIsEmpty()\n+      throws MembershipConfigurationException, UnknownHostException {\n+    JGroupsMessenger j = new JGroupsMessenger();\n+    String bindAddress = \"0.0.0.0\";\n+    String membershipBindAddress = \"\";\n+    String localHostAddress = LocalHostUtil.getLocalHost().getHostAddress();\n+    assertThat(j.getAddressForUDPBinding(bindAddress, membershipBindAddress))\n+        .isEqualTo(localHostAddress);\n+  }\n+\n+  @Test\n+  public void getAddressForUDPBinding_ThrowsExceptionIfMembershipBindAddressIsIPv4WildcardAddress() {\n+    JGroupsMessenger j = new JGroupsMessenger();\n+    String membershipBindAddress = \"0.0.0.0\";\n+    assertThatExceptionOfType(MembershipConfigurationException.class).isThrownBy(() -> {\n+      j.getAddressForUDPBinding(\"\", membershipBindAddress);\n+    })\n+        .withMessage(\n+            \"'membership-bind-address' cannot be a wildcard address. JGroups UDP protocol requires a bind address.\");\n+  }\n+\n+  @Test\n+  public void getAddressForUDPBinding_ThrowsExceptionIfMembershipBindAddressIsIPv6WildcardAddress() {\n+    JGroupsMessenger j = new JGroupsMessenger();\n+    String membershipBindAddress = \"::\";\n+    assertThatExceptionOfType(MembershipConfigurationException.class).isThrownBy(() -> {\n+      j.getAddressForUDPBinding(\"\", membershipBindAddress);\n+    })\n+        .withMessage(\n+            \"'membership-bind-address' cannot be a wildcard address. JGroups UDP protocol requires a bind address.\");\n+  }\n+}"
  }
]
