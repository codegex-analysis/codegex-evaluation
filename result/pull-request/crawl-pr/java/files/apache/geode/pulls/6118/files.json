[
  {
    "sha": "284888ede2a49ff6428c8ef55fb4a81ad94e8727",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/net/BufferPool.java",
    "status": "modified",
    "additions": 37,
    "deletions": 4,
    "changes": 41,
    "blob_url": "https://github.com/apache/geode/blob/6e810e08b517c6c67369a3f314609fbaf57604db/geode-core/src/main/java/org/apache/geode/internal/net/BufferPool.java",
    "raw_url": "https://github.com/apache/geode/raw/6e810e08b517c6c67369a3f314609fbaf57604db/geode-core/src/main/java/org/apache/geode/internal/net/BufferPool.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/net/BufferPool.java?ref=6e810e08b517c6c67369a3f314609fbaf57604db",
    "patch": "@@ -14,6 +14,7 @@\n  */\n package org.apache.geode.internal.net;\n \n+import java.io.PrintWriter;\n import java.lang.ref.SoftReference;\n import java.lang.reflect.Method;\n import java.nio.ByteBuffer;\n@@ -27,6 +28,7 @@\n import org.apache.geode.distributed.internal.DMStats;\n import org.apache.geode.distributed.internal.DistributionConfig;\n import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.shared.StringPrintWriter;\n import org.apache.geode.internal.tcp.Connection;\n import org.apache.geode.logging.internal.log4j.api.LogService;\n import org.apache.geode.util.internal.GeodeGlossary;\n@@ -108,8 +110,17 @@ private ByteBuffer acquireDirectBuffer(int size, boolean send) {\n         result = acquireLargeBuffer(send, size);\n       }\n       if (result.capacity() > size) {\n+        ByteBuffer poolableBuffer = result;\n         result.position(0).limit(size);\n         result = result.slice();\n+        logger.info(\"BRUCE: acquiring buffer {}@{} holding pooled buffer {}@{},\\n{}\",\n+            result, Integer.toHexString(System.identityHashCode(result)),\n+            poolableBuffer, Integer.toHexString(System.identityHashCode(poolableBuffer)),\n+            getCallStackAsString(6));\n+      } else {\n+        logger.info(\"BRUCE: acquiring pooled buffer {}@{},\\n{}\",\n+            result, Integer.toHexString(System.identityHashCode(result)),\n+            getCallStackAsString(6));\n       }\n       return result;\n     }\n@@ -301,17 +312,39 @@ void releaseBuffer(BufferPool.BufferType type, ByteBuffer buffer) {\n     throw new IllegalArgumentException(\"Unexpected buffer type \" + type.toString());\n   }\n \n+  public static String getCallStackAsString(int maxframes) {\n+    PrintWriter pw = new StringPrintWriter();\n+    final StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n+    int i = 2;\n+    for (; i < stackTrace.length && i < maxframes + 2; i++) {\n+      StackTraceElement ste = stackTrace[i];\n+      pw.append(\"\\tat \" + ste.toString());\n+      pw.append('\\n');\n+    }\n+    return pw.toString();\n+  }\n+\n \n   /**\n    * Releases a previously acquired buffer.\n    */\n   private void releaseBuffer(ByteBuffer buffer, boolean send) {\n     if (buffer.isDirect()) {\n-      buffer = getPoolableBuffer(buffer);\n-      BBSoftReference bbRef = new BBSoftReference(buffer, send);\n-      if (buffer.capacity() <= SMALL_BUFFER_SIZE) {\n+      ByteBuffer poolableBuffer = getPoolableBuffer(buffer);\n+      if (buffer != poolableBuffer) {\n+        logger.info(\"BRUCE: releasing buffer {}@{} holding pooled buffer {}@{},\\n{}\",\n+            buffer, Integer.toHexString(System.identityHashCode(buffer)),\n+            poolableBuffer, Integer.toHexString(System.identityHashCode(poolableBuffer)),\n+            getCallStackAsString(6));\n+      } else {\n+        logger.info(\"BRUCE: releasing pooled buffer {}@{},\\n{}\",\n+            buffer, Integer.toHexString(System.identityHashCode(buffer)),\n+            getCallStackAsString(6));\n+      }\n+      BBSoftReference bbRef = new BBSoftReference(poolableBuffer, send);\n+      if (poolableBuffer.capacity() <= SMALL_BUFFER_SIZE) {\n         bufferSmallQueue.offer(bbRef);\n-      } else if (buffer.capacity() <= MEDIUM_BUFFER_SIZE) {\n+      } else if (poolableBuffer.capacity() <= MEDIUM_BUFFER_SIZE) {\n         bufferMiddleQueue.offer(bbRef);\n       } else {\n         bufferLargeQueue.offer(bbRef);"
  },
  {
    "sha": "c01ed6a71e2a4f0bf51db3c5a86f0617cfebc248",
    "filename": "geode-core/src/main/java/org/apache/geode/internal/tcp/Connection.java",
    "status": "modified",
    "additions": 33,
    "deletions": 1,
    "changes": 34,
    "blob_url": "https://github.com/apache/geode/blob/6e810e08b517c6c67369a3f314609fbaf57604db/geode-core/src/main/java/org/apache/geode/internal/tcp/Connection.java",
    "raw_url": "https://github.com/apache/geode/raw/6e810e08b517c6c67369a3f314609fbaf57604db/geode-core/src/main/java/org/apache/geode/internal/tcp/Connection.java",
    "contents_url": "https://api.github.com/repos/apache/geode/contents/geode-core/src/main/java/org/apache/geode/internal/tcp/Connection.java?ref=6e810e08b517c6c67369a3f314609fbaf57604db",
    "patch": "@@ -1367,6 +1367,8 @@ private void close(String reason, boolean cleanupEndpoint, boolean p_removeEndpo\n       }\n \n       // Make sure anyone waiting for a handshake stops waiting\n+      logger.info(\"BRUCE: in connection.close, notifying handshake waiter of failure.  reason={}\",\n+          reason);\n       notifyHandshakeWaiter(false);\n       // wait a bit for the our reader thread to exit don't wait if we are the reader thread\n       boolean isIBM = false;\n@@ -1505,6 +1507,7 @@ public void run() {\n       releaseInputBuffer();\n \n       // make sure that if the reader thread exits we notify a thread waiting for the handshake.\n+      logger.info(\"BRUCE: in connection.run, notifying handshake waiter of failure\");\n       notifyHandshakeWaiter(false);\n       readerThread.setName(\"unused p2p reader\");\n       synchronized (stateLock) {\n@@ -1641,6 +1644,7 @@ private void readMessages() {\n           }\n           if (amountRead < 0) {\n             readerShuttingDown = true;\n+            logger.info(\"BRUCE: Connection.readMessages encountered EOF\");\n             try {\n               requestClose(\"SocketChannel.read returned EOF\");\n             } catch (Exception e) {\n@@ -1683,12 +1687,27 @@ private void readMessages() {\n           return;\n         } catch (ClosedChannelException e) {\n           readerShuttingDown = true;\n+          logger.debug(\"BRUCE: {} Terminated <{}> due to closed channel\", p2pReaderName(), this, e);\n           try {\n             requestClose(String.format(\"ClosedChannelException in channel read: %s\", e));\n           } catch (Exception ignored) {\n           }\n           return;\n         } catch (IOException e) {\n+          if (inputBuffer != null) {\n+            ByteBuffer poolableBuffer = getBufferPool().getPoolableBuffer(inputBuffer);\n+            if (poolableBuffer != inputBuffer) {\n+              logger.info(\n+                  \"BRUCE: caught IOException with buffer {}@{} holding pooled buffer {}@{},\\n{}\",\n+                  inputBuffer, Integer.toHexString(System.identityHashCode(inputBuffer)),\n+                  poolableBuffer, Integer.toHexString(System.identityHashCode(poolableBuffer)),\n+                  BufferPool.getCallStackAsString(6));\n+            } else {\n+              logger.info(\"BRUCE: caught IOException with buffer {}@{},\\n{}\",\n+                  inputBuffer, Integer.toHexString(System.identityHashCode(inputBuffer)),\n+                  BufferPool.getCallStackAsString(6));\n+            }\n+          }\n           // \"Socket closed\" check needed for Solaris jdk 1.4.2_08\n           if (!isSocketClosed() && !\"Socket closed\".equalsIgnoreCase(e.getMessage())) {\n             if (logger.isInfoEnabled() && !isIgnorableIOException(e)) {\n@@ -1731,7 +1750,7 @@ private void readMessages() {\n         }\n       }\n       if (logger.isDebugEnabled()) {\n-        logger.debug(\"readMessages terminated id={} from {} isHandshakeReader={}\", conduitIdStr,\n+        logger.debug(\"readMessages terminated id={} from {} handshakeHasBeenRead={}\", conduitIdStr,\n             remoteAddr, handshakeHasBeenRead);\n       }\n     }\n@@ -2910,6 +2929,7 @@ private boolean readHandshakeForReceiver(DataInput dis) {\n           notifyHandshakeWaiter(true);\n         } else {\n           // check if we need notifyHandshakeWaiter() call.\n+          logger.info(\"BRUCE: in readHandshakeForReceiver, notifying handshake waiter of failure\");\n           notifyHandshakeWaiter(false);\n           logger.warn(\"{} timed out during a membership check.\",\n               p2pReaderName());\n@@ -3021,6 +3041,18 @@ private void readMessage(ByteBuffer peerDataBuffer, AbstractExecutor threadMonit\n         throw err;\n       } catch (Throwable t) {\n         logger.fatal(\"Error deserializing message\", t);\n+        if (inputBuffer != null) {\n+          ByteBuffer poolableBuffer = getBufferPool().getPoolableBuffer(inputBuffer);\n+          if (poolableBuffer != inputBuffer) {\n+            logger.info(\n+                \"BRUCE: caught Throwable with buffer {}@{} holding pooled buffer {}@{}\",\n+                inputBuffer, Integer.toHexString(System.identityHashCode(inputBuffer)),\n+                poolableBuffer, Integer.toHexString(System.identityHashCode(poolableBuffer)));\n+          } else {\n+            logger.info(\"BRUCE: caught IOException with buffer {}@{}\",\n+                inputBuffer, Integer.toHexString(System.identityHashCode(inputBuffer)));\n+          }\n+        }\n         // Whenever you catch Error or Throwable, you must also\n         // catch VirtualMachineError (see above). However, there is\n         // _still_ a possibility that you are dealing with a cascading"
  }
]
